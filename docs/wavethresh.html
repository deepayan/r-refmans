<!DOCTYPE html><html lang="en"><head><title>Help for package wavethresh</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wavethresh}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#wavethresh-package'><p>Wavelets Statistics and Transforms</p></a></li>
<li><a href='#accessc'><p>Get variance information from irregularly spaced wavelet decomposition object.</p></a></li>
<li><a href='#accessC'><p>Get &quot;detail&quot; (mother wavelet) coefficients data from wavelet object</p></a></li>
<li><a href='#accessC.mwd'><p>Get Smoothed Data from Wavelet Structure</p></a></li>
<li><a href='#accessC.wd'><p>Get smoothed data from wavelet object (wd)</p></a></li>
<li><a href='#accessC.wp'><p>Warning function when trying to access smooths from wavelet packet object (wp).</p></a></li>
<li><a href='#accessC.wst'><p>Get smoothed data from packet ordered non-decimated wavelet object (wst)</p></a></li>
<li><a href='#accessD'><p>Get &quot;detail&quot; (mother wavelet) coefficients data from wavelet object</p></a></li>
<li><a href='#accessD.mwd'><p>Get wavelet coefficients from multiple wavelet structure (mwd).</p></a></li>
<li><a href='#accessD.wd'><p>Get detail (mother wavelet) coefficients from wavelet object (wd).</p></a></li>
<li><a href='#accessD.wd3D'><p>Get wavelet coefficients from 3D wavelet object</p></a></li>
<li><a href='#accessD.wp'><p>Obtain whole resolution level of wavelet packet coefficients from a wavelet packet object (wp).</p></a></li>
<li><a href='#accessD.wpst'><p>Get coefficients from a non-decimated wavelet packet object (wpst) in time order.</p></a></li>
<li><a href='#accessD.wst'><p>Get mother wavelet coefficients from a packet ordered non-decimated wavelet object (wst).</p></a></li>
<li><a href='#addpkt'><p>Add a wavelet packet box to an already set up time-frequency plot</p></a></li>
<li><a href='#AutoBasis'><p>Run Coifman-Wickerhauser best basis algorithm on wavelet packet object</p></a></li>
<li><a href='#av.basis'><p>Perform basis averaging for wst class object</p></a></li>
<li><a href='#AvBasis'><p>Basis averaging (&quot;inversion&quot;)</p></a></li>
<li><a href='#AvBasis.wst'><p>Perform basis averaging for (packet-ordered) non-decimated wavelet transform.</p></a></li>
<li><a href='#AvBasis.wst2D'><p>Perform basis averaging for (packet-ordered) 2D non-decimated wavelet transform.</p></a></li>
<li><a href='#BabyECG'><p>Physiological data time series.</p></a></li>
<li><a href='#BabySS'><p>Physiological data time series.</p></a></li>
<li><a href='#basisplot'><p>Generic basis plot function</p></a></li>
<li><a href='#basisplot.BP'><p>Plot time-frequency plane and basis slots associated with basis object</p></a></li>
<li><a href='#basisplot.wp'><p>Function to graphically select a wavelet packet basis</p></a></li>
<li><a href='#BAYES.THR'><p>Bayesian wavelet thresholding.</p></a></li>
<li><a href='#Best1DCols'><p>Extract the best (one-dimensional) nondecimated WP packets</p></a></li>
<li><a href='#bestm'>
<p>Function called by makewpstRO to identify which packets are individually</p>
good for correlating with a response</a></li>
<li><a href='#BMdiscr'><p>Subsidiary routine for makewpstDO function</p></a></li>
<li><a href='#c2to4'><p>Take integer, represent in binary, then think of and return that</p>
representation in base 4</a></li>
<li><a href='#CanUseMoreThanOneColor'><p>Deprecated  function</p></a></li>
<li><a href='#checkmyews'><p>Check a LSW spectrum through repeated simulation and empirical averages</p></a></li>
<li><a href='#Chires5'><p>Subsid routine for denproj (calcs scaling function coefs without cov)</p></a></li>
<li><a href='#Chires6'><p>Subsid routine for denproj (calcs scaling function coefs with cov)</p></a></li>
<li><a href='#cns'><p>Create new zeroed spectrum.</p></a></li>
<li><a href='#compare.filters'><p>Compares two filters.</p></a></li>
<li><a href='#compgrot'><p>Compute empirical shift for time ordered non-decimated transforms.</p></a></li>
<li><a href='#compress'><p>Compress objects</p></a></li>
<li><a href='#compress.default'><p>Do &quot;zero&quot; run-length encoding compression of a vector of numbers.</p></a></li>
<li><a href='#compress.imwd'><p>Compress a (thresholded) imwd class object by removing zeroes.</p></a></li>
<li><a href='#conbar'><p>Performs inverse DWT reconstruction step</p></a></li>
<li><a href='#convert'><p>Convert one type of wavelet object into another.</p></a></li>
<li><a href='#convert.wd'><p>Convert a non-decimated wd object into a wst object.</p></a></li>
<li><a href='#convert.wst'><p>Convert a non-decimated wst object into a wd object.</p></a></li>
<li><a href='#ConvertMessage'><p>Print out a text message about an object which is from old version of WaveThresh</p></a></li>
<li><a href='#Crsswav'><p>Wrapper to C code version of rsswav</p></a></li>
<li><a href='#cthresh'><p>Estimate real signal using complex-valued wavelets</p></a></li>
<li><a href='#Cthreshold'><p>Calls C code to threshold wd class object.</p></a></li>
<li><a href='#CWavDE'><p>Simple wavelet density estimator with hard thresholding</p></a></li>
<li><a href='#CWCV'><p>C Wavelet Cross-validation</p></a></li>
<li><a href='#dclaw'><p>Claw distribution</p></a></li>
<li><a href='#dencvwd'>
<p>Calculate variances of wavlet coefficients of a p.d.f.</p></a></li>
<li><a href='#denplot'><p>Calculate plotting information for a density estimate.</p></a></li>
<li><a href='#denproj'><p>Calculate empirical scaling function coefficients of a p.d.f.</p></a></li>
<li><a href='#denwd'><p>Wavelet decomposition of empirical scaling function coefficients of a p.d.f.</p></a></li>
<li><a href='#denwr'><p>Wavelet reconstruction for density estimation.</p></a></li>
<li><a href='#DJ.EX'><p>Produce Donoho and Johnstone test functions</p></a></li>
<li><a href='#dof'><p>Compute number of non-zero coefficients in wd object</p></a></li>
<li><a href='#doppler'><p>Evaluate the Donoho and Johnstone Doppler signal.</p></a></li>
<li><a href='#draw'><p>Draw wavelets or scaling functions.</p></a></li>
<li><a href='#draw.default'><p>Draw picture of a wavelet or scaling function.</p></a></li>
<li><a href='#draw.imwd'><p>Draw mother wavelet associated with an imwd object.</p></a></li>
<li><a href='#draw.imwdc'><p>Draw mother wavelet associated with an imwdc object.</p></a></li>
<li><a href='#draw.mwd'><p>Draws a wavelet or scaling function used to compute an &lsquo;mwd&rsquo; object</p></a></li>
<li><a href='#draw.wd'><p>Draw mother wavelet or scaling function associated with wd object.</p></a></li>
<li><a href='#draw.wp'><p>Draw wavelet packet associated with a wp object.</p></a></li>
<li><a href='#draw.wst'><p>Draw mother wavelet or scaling function associated with wst object.</p></a></li>
<li><a href='#drawbox'><p>Draw a shaded coloured box</p></a></li>
<li><a href='#drawwp.default'><p>Subsidiary routine that actually computes wavelet packet values</p></a></li>
<li><a href='#ewspec'><p>Compute evolutionary wavelet spectrum estimate.</p></a></li>
<li><a href='#example.1'><p>Compute and return piecewise polynomial coordinates.</p></a></li>
<li><a href='#filter.select'><p>Provide wavelet filter coefficients.</p></a></li>
<li><a href='#find.parameters'><p>Find estimates of prior parameters</p></a></li>
<li><a href='#first.last'><p>Build a first/last database for wavelet transforms.</p></a></li>
<li><a href='#first.last.dh'><p>Build special first/last database for some wavelet density functions</p></a></li>
<li><a href='#firstdot'><p>Return the location of the first period character within a character string (for a vector of strings of arbitrary length).</p></a></li>
<li><a href='#FullWaveletCV'><p>Perform whole wavelet cross-validation in C code</p></a></li>
<li><a href='#GenW'><p>Generate (inverse) discrete wavelet transform matrix.</p></a></li>
<li><a href='#getarrvec'><p>Compute and return weaving permutation for conversion from wst objects to wd class objects.</p></a></li>
<li><a href='#getpacket'><p>Get a packet of coefficients from a wavelet object</p></a></li>
<li><a href='#getpacket.wp'><p>Get packet of coefficients from a wavelet packet object (wp).</p></a></li>
<li><a href='#getpacket.wpst'><p>Get packet of coefficients from a non-decimated wavelet packet object (wpst).</p></a></li>
<li><a href='#getpacket.wst'><p>Get packet of coefficients from a packet ordered non-decimated wavelet object (wst).</p></a></li>
<li><a href='#getpacket.wst2D'><p>Get packet of coefficients from a two-dimensional non-decimated wavelet object (wst2D).</p></a></li>
<li><a href='#GetRSSWST'><p>Computes estimate of error for function estimate.</p></a></li>
<li><a href='#griddata+20objects'><p>Data interpolated to a grid objects.</p></a></li>
<li><a href='#guyrot'><p>Cyclically rotate elements of a vector</p></a></li>
<li><a href='#HaarConcat'><p>Generate a concatenated Haar MA process</p></a></li>
<li><a href='#HaarMA'><p>Generate Haar MA processes.</p></a></li>
<li><a href='#image.wd'><p>Produce image representation of nondecimated wavelet transform</p></a></li>
<li><a href='#image.wst'><p>Produce image representation of a wst class object</p></a></li>
<li><a href='#imwd'><p>Two-dimensional wavelet transform (decomposition).</p></a></li>
<li><a href='#imwd.object'><p>Two-dimensional wavelet decomposition objects.</p></a></li>
<li><a href='#imwdc.object'><p>Two-dimensional compressed wavelet decomposition objects.</p></a></li>
<li><a href='#imwr'><p>Inverse two-dimensional wavelet transform.</p></a></li>
<li><a href='#imwr.imwd'><p>Inverse two-dimensional discrete wavelet transform.</p></a></li>
<li><a href='#imwr.imwdc'><p>Inverse two-dimensional discrete wavelet transform.</p></a></li>
<li><a href='#InvBasis'><p>Generic basis inversion for libraries</p></a></li>
<li><a href='#InvBasis.wp'><p>Invert a wp library representation with a particular basis spec</p></a></li>
<li><a href='#InvBasis.wst'><p>Invert a wst library representation with a basis specification</p></a></li>
<li><a href='#ipd'><p>Inductance plethysmography data.</p></a></li>
<li><a href='#ipndacw'><p>Compute inner product matrix of discrete non-decimated autocorrelation wavelets.</p></a></li>
<li><a href='#irregwd'><p>Irregular wavelet transform (decomposition).</p></a></li>
<li><a href='#irregwd.objects'><p>Irregular wavelet decomposition objects.</p></a></li>
<li><a href='#IsEarly'><p>Generic function to detect whether object is from an early version</p></a></li>
<li><a href='#IsEarly.default'><p>Detects whether object is from an earlier version of WaveThresh</p></a></li>
<li><a href='#IsEarly.wd'><p>Function to detect whether a wd object is from WaveThresh2 or not</p></a></li>
<li><a href='#IsPowerOfTwo'><p>Decides whether vector elements are integral powers of two (returns NA if not).</p></a></li>
<li><a href='#l2norm'><p>Compute L2 distance between two vectors of numbers.</p></a></li>
<li><a href='#lennon'><p>John Lennon image.</p></a></li>
<li><a href='#levarr'><p>Subsidiary routine that generates a particular permutation</p></a></li>
<li><a href='#linfnorm'><p>Compute L infinity distance between two vectors of numbers.</p></a></li>
<li><a href='#LocalSpec'><p>Compute Nason and Silverman smoothed wavelet periodogram.</p></a></li>
<li><a href='#LocalSpec.wd'><p>Compute Nason and Silverman raw or smoothed wavelet periodogram.</p></a></li>
<li><a href='#LocalSpec.wst'><p>Obsolete function (use ewspec)</p></a></li>
<li><a href='#logabs'>
<p>Take the logarithm of the squares of the argument</p></a></li>
<li><a href='#LSWsim'><p>Simulate arbitrary locally stationary wavelet process.</p></a></li>
<li><a href='#lt.to.name'><p>Convert desired level and orientation into code used by imwd</p></a></li>
<li><a href='#madmad'><p>Compute square of median absolute deviation (mad) function.</p></a></li>
<li><a href='#make.dwwt'><p>Compute diagonal of the matrix WWT</p></a></li>
<li><a href='#makegrid'><p>Interpolate data to a grid.</p></a></li>
<li><a href='#makewpstDO'><p>Help page for a function</p></a></li>
<li><a href='#makewpstRO'>
<p>Make a wavelet packet regression object from a dependent and independent</p>
time series variable.</a></li>
<li><a href='#MaNoVe'><p>Make Node Vector (using Coifman-Wickerhauser best-basis type algorithm)</p></a></li>
<li><a href='#MaNoVe.wp'><p>Make Node Vector (using Coifman-Wickerhauser best-basis type algorithm) on wavelet packet object</p></a></li>
<li><a href='#MaNoVe.wst'><p>Make Node Vector (using Coifman-Wickerhauser best-basis type algorithm) on nondecimated wavelet transform object</p></a></li>
<li><a href='#mfilter.select'><p>Provide filter coefficients for multiple wavelets.</p></a></li>
<li><a href='#mfirst.last'><p>Build a first/last database for multiple wavelet transforms.</p></a></li>
<li><a href='#modernise'><p>Generic function to upgrade a V2 WaveThresh object to V4</p></a></li>
<li><a href='#modernise.wd'><p>Modernise a wd class object</p></a></li>
<li><a href='#mpostfilter'><p>Multiwavelet postfilter</p></a></li>
<li><a href='#mprefilter'><p>Multiwavelet prefilter</p></a></li>
<li><a href='#mwd'><p>Discrete multiple wavelet transform (decomposition).</p></a></li>
<li><a href='#mwd.object'><p>Multiple wavelet decomposition object (1D)</p></a></li>
<li><a href='#mwr'><p>Multiple discrete wavelet transform (reconstruction).</p></a></li>
<li><a href='#newsure'><p>Version of sure that acts as subsidiary for threshold.irregwd</p></a></li>
<li><a href='#nlevelsWT'><p>Returns number of scale (resolution) levels.</p></a></li>
<li><a href='#nlevelsWT.default'><p>Returns number of levels associated with an object</p></a></li>
<li><a href='#nullevels'><p>Set whole resolution levels of coefficients equal to zero.</p></a></li>
<li><a href='#nullevels.imwd'><p>Sets whole resolution levels of coefficients equal to zero in a imwd object.</p></a></li>
<li><a href='#nullevels.wd'><p>Sets whole resolution levels of coefficients equal to zero in a wd object.</p></a></li>
<li><a href='#nullevels.wst'><p>Sets whole resolution levels of coefficients equal to zero in a wst object.</p></a></li>
<li><a href='#numtonv'><p>Convert an index number into a node vector object.</p></a></li>
<li><a href='#nv.object'><p>Node vector objects.</p></a></li>
<li><a href='#plot.imwd'><p>Draw a picture of the 2D wavelet coefficients using image</p></a></li>
<li><a href='#plot.irregwd'><p>Plot variance factors of wavelet transform coefficients for irregularly spaced wavelet transform object</p></a></li>
<li><a href='#plot.mwd'><p>Use plot on an mwd object.</p></a></li>
<li><a href='#plot.nvwp'><p>Depict wavelet packet basis specfication</p></a></li>
<li><a href='#plot.wd'><p>Plot wavelet transform coefficients.</p></a></li>
<li><a href='#plot.wp'><p>Plot wavelet packet transform coefficients</p></a></li>
<li><a href='#plot.wst'><p>Plot packet-ordered non-decimated wavelet transform coefficients.</p></a></li>
<li><a href='#plot.wst2D'><p>Plot packet-ordered 2D non-decimated wavelet coefficients.</p></a></li>
<li><a href='#plotdenwd'><p>Plot the wavelet coefficients of a p.d.f.</p></a></li>
<li><a href='#plotpkt'><p>Sets up a high level plot ready to show the time-frequency plane</p>
and wavelet packet basis slots</a></li>
<li><a href='#print.BP'><p>Print top best basis information for BP class object</p></a></li>
<li><a href='#print.imwd'><p>Print out information about an imwd object in readable form.</p></a></li>
<li><a href='#print.imwdc'><p>Print out information about an imwdc object in readable form.</p></a></li>
<li><a href='#print.mwd'><p>Use print() on a mwd object.</p></a></li>
<li><a href='#print.nv'><p>Print a node vector object, also used by several other functions to</p>
obtain packet list information</a></li>
<li><a href='#print.nvwp'><p>Print a wavelet packet node vector object,</p>
also used by several other functions to
obtain packet list information</a></li>
<li><a href='#print.w2d'><p>Print method for printing w2d class objects</p></a></li>
<li><a href='#print.w2m'>
<p>Print a w2m class object</p></a></li>
<li><a href='#print.wd'><p>Print out information about an wd object in readable form.</p></a></li>
<li><a href='#print.wd3D'><p>Print out information about an wd3D object in a readable form.</p></a></li>
<li><a href='#print.wp'><p>Print out information about an wd object in readable form.</p></a></li>
<li><a href='#print.wpst'><p>Prints out basic information about a wpst class object</p></a></li>
<li><a href='#print.wpstCL'><p>Prints some information about a wpstCL object</p></a></li>
<li><a href='#print.wpstDO'><p>Print information about a wpstDO class object</p></a></li>
<li><a href='#print.wpstRO'>
<p>Print a wpstRO class object</p></a></li>
<li><a href='#print.wst'><p>Print out information about an wst object in readable form.</p></a></li>
<li><a href='#print.wst2D'><p>Print out information about an wst2d object in a readable form.</p></a></li>
<li><a href='#PsiJ'><p>Compute discrete autocorrelation wavelets.</p></a></li>
<li><a href='#PsiJmat'><p>Compute discrete autocorrelation wavelets but return result in matrix form.</p></a></li>
<li><a href='#Psiname'><p>Return a PsiJ list object style name.</p></a></li>
<li><a href='#putC'><p>Put smoothed data (father wavelet) coefficients into wavelet structure</p></a></li>
<li><a href='#putC.mwd'><p>Put smoothed data into wavelet structure</p></a></li>
<li><a href='#putC.wd'><p>Puts a whole resolution level of father wavelet coeffients into wd wavelet object.</p></a></li>
<li><a href='#putC.wp'><p>Warning function when trying to insert father wavelet coefficients into wavelet packet object (wp).</p></a></li>
<li><a href='#putC.wst'><p>Puts a whole resolution level of father wavelet coeffients into wst wavelet object.</p></a></li>
<li><a href='#putD'><p>Put mother wavelet coefficients into wavelet structure</p></a></li>
<li><a href='#putD.mwd'><p>Put wavelet coefficients into multiple wavelet structure</p></a></li>
<li><a href='#putD.wd'><p>Puts a whole resolution level of mother wavelet coeffients into wd wavelet object.</p></a></li>
<li><a href='#putD.wd3D'><p>Put wavelet coefficient array into a 3D wavelet object</p></a></li>
<li><a href='#putD.wp'><p>Puts a whole resolution level of wavelet packet coeffients into wp wavelet object.</p></a></li>
<li><a href='#putD.wst'><p>Puts a whole resolution level of mother wavelet coeffients into wst wavelet object.</p></a></li>
<li><a href='#putDwd3Dcheck'><p>Check argument list for putD.wd3D</p></a></li>
<li><a href='#putpacket'><p>Insert a packet of coefficients into a wavelet object.</p></a></li>
<li><a href='#putpacket.wp'><p>Inserts a packet of coefficients into a wavelet packet object (wp).</p></a></li>
<li><a href='#putpacket.wst'><p>Put a packet of coefficients into a packet ordered non-decimated wavelet object (wst).</p></a></li>
<li><a href='#putpacket.wst2D'><p>Replace packet of coefficients in a two-dimensional non-decimated wavelet object (wst2D).</p></a></li>
<li><a href='#rcov'><p>Computes robust estimate of covariance matrix</p></a></li>
<li><a href='#rfft'><p>Real Fast Fourier transform</p></a></li>
<li><a href='#rfftinv'><p>Inverse real FFT, inverse of rfft</p></a></li>
<li><a href='#rfftwt'><p>Weight a Fourier series sequence by a set of weights</p></a></li>
<li><a href='#rm.det'><p>Set coarse levels of a wavelets on the interval transform object to zero</p></a></li>
<li><a href='#rmget'><p>Search for existing ipndacw matrices.</p></a></li>
<li><a href='#rmname'><p>Return a ipndacw matrix style name.</p></a></li>
<li><a href='#rotateback'><p>Cyclically shift a vector one place to the right</p></a></li>
<li><a href='#rsswav'><p>Compute mean residual sum of squares for odd prediction of even ordinates and vice versa</p></a></li>
<li><a href='#ScalingFunction'><p>Compute scaling functions on internally predefined grid</p></a></li>
<li><a href='#Shannon.entropy'><p>Compute Shannon entropy</p></a></li>
<li><a href='#simchirp'><p>Compute and return simulated chirp function.</p></a></li>
<li><a href='#ssq'><p>Compute sum of squares difference between two vectors</p></a></li>
<li><a href='#summary.imwd'><p>Print out some basic information associated with an imwd object</p></a></li>
<li><a href='#summary.imwdc'><p>Print out some basic information associated with an imwdc object</p></a></li>
<li><a href='#summary.mwd'><p>Use summary() on a mwd object.</p></a></li>
<li><a href='#summary.wd'><p>Print out some basic information associated with a wd object</p></a></li>
<li><a href='#summary.wd3D'><p>Print out some basic information associated with a wd3D object</p></a></li>
<li><a href='#summary.wp'><p>Print out some basic information associated with a wp object</p></a></li>
<li><a href='#summary.wpst'><p>Print out some basic information associated with a wpst object</p></a></li>
<li><a href='#summary.wst'><p>Print out some basic information associated with a wst object</p></a></li>
<li><a href='#summary.wst2D'><p>Print out some basic information associated with a wst2D object</p></a></li>
<li><a href='#support'><p>Returns support of compactly supported wavelets.</p></a></li>
<li><a href='#sure'><p>Computes the minimum of the SURE thresholding function</p></a></li>
<li><a href='#teddy'><p>Picture of a teddy bear's picnic.</p></a></li>
<li><a href='#test.dataCT'><p>Test functions for wavelet regression and thresholding</p></a></li>
<li><a href='#threshold'><p>Threshold coefficients</p></a></li>
<li><a href='#threshold.imwd'><p>Threshold two-dimensional wavelet decomposition object</p></a></li>
<li><a href='#threshold.imwdc'><p>Threshold two-dimensional compressed wavelet decomposition object</p></a></li>
<li><a href='#threshold.irregwd'><p>hold irregularly spaced wavelet decomposition object</p></a></li>
<li><a href='#threshold.mwd'><p>Use threshold on an mwd object.</p></a></li>
<li><a href='#threshold.wd'><p>Threshold (DWT) wavelet decomposition object</p></a></li>
<li><a href='#threshold.wd3D'><p>Threshold 3D DWT object</p></a></li>
<li><a href='#threshold.wp'><p>Threshold wavelet packet decomposition object</p></a></li>
<li><a href='#threshold.wst'><p>Threshold (NDWT) packet-ordered non-decimated wavelet decomposition object</p></a></li>
<li><a href='#TOgetthrda1'><p>Subsidiary routines for Ogden and Parzen's wavelet shrinkage methods</p></a></li>
<li><a href='#TOthreshda1'><p>Data analytic wavelet thresholding routine</p></a></li>
<li><a href='#TOthreshda2'><p>Data analytic wavelet thresholding routine</p></a></li>
<li><a href='#tpwd'><p>Tensor product 2D wavelet transform</p></a></li>
<li><a href='#tpwr'><p>Inverse tensor product 2D wavelet transform.</p></a></li>
<li><a href='#uncompress'><p>Uncompress objects</p></a></li>
<li><a href='#uncompress.default'><p>Undo zero run-length encoding for a vector.</p></a></li>
<li><a href='#uncompress.imwdc'><p>Uncompress an imwdc class object</p></a></li>
<li><a href='#wavegrow'><p>Interactive graphical tool to grow a wavelet synthesis</p></a></li>
<li><a href='#WaveletCV'><p>Wavelet cross-validation</p></a></li>
<li><a href='#wd'><p>Wavelet transform (decomposition).</p></a></li>
<li><a href='#wd.dh'><p>Compute specialized wavelet transform for density estimation</p></a></li>
<li><a href='#wd.int'><p>Computes &quot;wavelets on the interval&quot; transform</p></a></li>
<li><a href='#wd.object'><p>Wavelet decomposition objects</p></a></li>
<li><a href='#wd3D'><p>Three-dimensional discrete wavelet transform</p></a></li>
<li><a href='#wd3D.object'><p>Three-dimensional wavelet object</p></a></li>
<li><a href='#Whistory'><p>Obsolete function supposedly detailed history of object</p></a></li>
<li><a href='#Whistory.wst'><p>Obsolete function: as Whistory, but for wst objects</p></a></li>
<li><a href='#wp'><p>Wavelet packet transform.</p></a></li>
<li><a href='#wp.object'><p>Wavelet Packet decomposition objects.</p></a></li>
<li><a href='#wpst'><p>Non-decimated wavelet packet transform.</p></a></li>
<li><a href='#wpst2discr'><p>Reshape/reformat packet coefficients into a multivariate data set</p></a></li>
<li><a href='#wpst2m'>
<p>Converts a nondecimated wavelet packet object to a (large) matrix with</p>
packets stored as columns</a></li>
<li><a href='#wpstCLASS'>
<p>Predict values using new time series values via a non-decimated wavelet packet</p>
discrimination object.</a></li>
<li><a href='#wpstREGR'><p>Construct data frame using new time series using information</p>
from a previously constructed wpstRO object</a></li>
<li><a href='#wr'><p>Wavelet reconstruction (inverse DWT).</p></a></li>
<li><a href='#wr.int'><p>Computes inverse &quot;wavelets on the interval&quot; transform.</p></a></li>
<li><a href='#wr.mwd'><p>Multiple wavelet reconstruction for mwd objects</p></a></li>
<li><a href='#wr.wd'><p>Wavelet reconstruction for wd class objects (inverse discrete wavelet transform).</p></a></li>
<li><a href='#wr3D'><p>Inverse DWT for 3D DWT object.</p></a></li>
<li><a href='#wst'><p>Packet-ordered non-decimated wavelet transform.</p></a></li>
<li><a href='#wst.object'><p>(Packet ordered) Nondecimated wavelet transform decomposition objects.</p></a></li>
<li><a href='#wst2D'><p>(Packet-ordered) 2D non-decimated wavelet transform.</p></a></li>
<li><a href='#wst2D.object'><p>(Packet ordered) Two-dimensional nondecimated wavelet transform decomposition objects.</p></a></li>
<li><a href='#wstCV'><p>Performs two-fold cross-validation estimation using packet-ordered non-decimated wavelet transforms and one, global, threshold.</p></a></li>
<li><a href='#wstCVl'><p>Performs two-fold cross-validation estimation using packet-ordered non-decimated wavelet transforms and a (vector) level-dependent threshold.</p></a></li>
<li><a href='#WTEnv'><p>Environment that exists to store intermediate calculations for re-use within the same R session.</p></a></li>
<li><a href='#wvcvlrss'><p>Computes estimate of error for function estimate.</p></a></li>
<li><a href='#wvmoments'><p>Compute moments of wavelets or scaling function</p></a></li>
<li><a href='#wvrelease'><p>Prints out the release number of the WaveThresh package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wavelets Statistics and Transforms</td>
</tr>
<tr>
<td>Version:</td>
<td>4.7.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-19</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), MASS</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs 1, 2 and 3D real and complex-valued wavelet transforms,
	nondecimated transforms, wavelet packet transforms, nondecimated
	wavelet packet transforms, multiple wavelet transforms,
	complex-valued wavelet transforms, wavelet shrinkage for
	various kinds of data, locally stationary wavelet time series,
	nonstationary multiscale transfer function modeling, density
	estimation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-19 14:03:47 UTC; guynason</td>
</tr>
<tr>
<td>Author:</td>
<td>Guy Nason [aut, cre],
  Stuart Barber [ctb],
  Tim Downie [ctb],
  Piotr Frylewicz [ctb],
  Arne Kovac [ctb],
  Todd Ogden [ctb],
  Bernard Silverman [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guy Nason &lt;g.nason@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-19 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='wavethresh-package'>Wavelets Statistics and Transforms</h2><span id='topic+wavethresh-package'></span><span id='topic+wavethresh'></span>

<h3>Description</h3>

<p>Performs 1, 2 and 3D real and complex-valued wavelet transforms,
	nondecimated transforms, wavelet packet transforms, nondecimated
	wavelet packet transforms, multiple wavelet transforms,
	complex-valued wavelet transforms, wavelet shrinkage for
	various kinds of data, locally stationary wavelet time series,
	nonstationary multiscale transfer function modeling, density
	estimation.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> wavethresh</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Wavelets Statistics and Transforms</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 4.7.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-08-19</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Guy", "Nason", role=c("aut", "cre"),
        email="g.nason@imperial.ac.uk"),
	person("Stuart", "Barber", role="ctb", email="s.barber@leeds.ac.uk"),
	person("Tim", "Downie", role="ctb", email="tim.downie@bht-berlin.de"),
	person("Piotr", "Frylewicz", role="ctb", email="p.fryzlewicz@lse.ac.uk"),
	person("Arne", "Kovac", role="ctb", email="A.Kovac@bristol.ac.uk"),
	person("Todd", "Ogden", role="ctb", email="todd.ogden@columbia.edu"),
	person("Bernard", "Silverman", role="ctb"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.10), MASS</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Performs 1, 2 and 3D real and complex-valued wavelet transforms,
	nondecimated transforms, wavelet packet transforms, nondecimated
	wavelet packet transforms, multiple wavelet transforms,
	complex-valued wavelet transforms, wavelet shrinkage for
	various kinds of data, locally stationary wavelet time series,
	nonstationary multiscale transfer function modeling, density
	estimation.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Guy Nason [aut, cre],
  Stuart Barber [ctb],
  Tim Downie [ctb],
  Piotr Frylewicz [ctb],
  Arne Kovac [ctb],
  Todd Ogden [ctb],
  Bernard Silverman [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Guy Nason &lt;g.nason@imperial.ac.uk&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
AutoBasis               Run Coifman-Wickerhauser best basis algorithm
                        on wavelet packet object
AvBasis                 Basis averaging ("inversion")
AvBasis.wst             Perform basis averaging for (packet-ordered)
                        non-decimated wavelet transform.
AvBasis.wst2D           Perform basis averaging for (packet-ordered) 2D
                        non-decimated wavelet transform.
BAYES.THR               Bayesian wavelet thresholding.
BMdiscr                 Subsidiary routine for makewpstDO function
BabyECG                 Physiological data time series.
BabySS                  Physiological data time series.
Best1DCols              Extract the best (one-dimensional) nondecimated
                        WP packets
CWCV                    C Wavelet Cross-validation
CWavDE                  Simple wavelet density estimator with hard
                        thresholding
CanUseMoreThanOneColor
                        Deprecated function
Chires5                 Subsid routine for denproj (calcs scaling
                        function coefs without cov)
Chires6                 Subsid routine for denproj (calcs scaling
                        function coefs with cov)
ConvertMessage          Print out a text message about an object which
                        is from old version of WaveThresh
Crsswav                 Wrapper to C code version of rsswav
Cthreshold              Calls C code to threshold wd class object.
DJ.EX                   Produce Donoho and Johnstone test functions
FullWaveletCV           Perform whole wavelet cross-validation in C
                        code
GenW                    Generate (inverse) discrete wavelet transform
                        matrix.
GetRSSWST               Computes estimate of error for function
                        estimate.
HaarConcat              Generate a concatenated Haar MA process
HaarMA                  Generate Haar MA processes.
InvBasis                Generic basis inversion for libraries
InvBasis.wp             Invert a wp library representation with a
                        particular basis spec
InvBasis.wst            Invert a wst library representation with a
                        basis specification
IsEarly                 Generic function to detect whether object is
                        from an early version
IsEarly.default         Detects whether object is from an earlier
                        version of WaveThresh
IsEarly.wd              Function to detect whether a wd object is from
                        WaveThresh2 or not
IsPowerOfTwo            Decides whether vector elements are integral
                        powers of two (returns NA if not).
LSWsim                  Simulate arbitrary locally stationary wavelet
                        process.
LocalSpec               Compute Nason and Silverman smoothed wavelet
                        periodogram.
LocalSpec.wd            Compute Nason and Silverman raw or smoothed
                        wavelet periodogram.
LocalSpec.wst           Obsolete function (use ewspec)
MaNoVe                  Make Node Vector (using Coifman-Wickerhauser
                        best-basis type algorithm)
MaNoVe.wp               Make Node Vector (using Coifman-Wickerhauser
                        best-basis type algorithm) on wavelet packet
                        object
MaNoVe.wst              Make Node Vector (using Coifman-Wickerhauser
                        best-basis type algorithm) on nondecimated
                        wavelet transform object
PsiJ                    Compute discrete autocorrelation wavelets.
PsiJmat                 Compute discrete autocorrelation wavelets but
                        return result in matrix form.
Psiname                 Return a PsiJ list object style name.
ScalingFunction         Compute scaling functions on internally
                        predefined grid
Shannon.entropy         Compute Shannon entropy
TOgetthrda1             Subsidiary routines for Ogden and Parzen's
                        wavelet shrinkage methods
TOthreshda1             Data analytic wavelet thresholding routine
TOthreshda2             Data analytic wavelet thresholding routine
WTEnv                   Environment that exists to store intermediate
                        calculations for re-use within the same R
                        session.
WaveletCV               Wavelet cross-validation
Whistory                Obsolete function supposedly detailed history
                        of object
Whistory.wst            Obsolete function: as Whistory, but for wst
                        objects
accessC                 Get "detail" (mother wavelet) coefficients data
                        from wavelet object
accessC.mwd             Get Smoothed Data from Wavelet Structure
accessC.wd              Get smoothed data from wavelet object (wd)
accessC.wp              Warning function when trying to access smooths
                        from wavelet packet object (wp).
accessC.wst             Get smoothed data from packet ordered
                        non-decimated wavelet object (wst)
accessD                 Get "detail" (mother wavelet) coefficients data
                        from wavelet object
accessD.mwd             Get wavelet coefficients from multiple wavelet
                        structure (mwd).
accessD.wd              Get detail (mother wavelet) coefficients from
                        wavelet object (wd).
accessD.wd3D            Get wavelet coefficients from 3D wavelet object
accessD.wp              Obtain whole resolution level of wavelet packet
                        coefficients from a wavelet packet object (wp).
accessD.wpst            Get coefficients from a non-decimated wavelet
                        packet object (wpst) in time order.
accessD.wst             Get mother wavelet coefficients from a packet
                        ordered non-decimated wavelet object (wst).
accessc                 Get variance information from irregularly
                        spaced wavelet decomposition object.
addpkt                  Add a wavelet packet box to an already set up
                        time-frequency plot
av.basis                Perform basis averaging for wst class object
basisplot               Generic basis plot function
basisplot.BP            Plot time-frequency plane and basis slots
                        associated with basis object
basisplot.wp            Function to graphically select a wavelet packet
                        basis
bestm                   Function called by makewpstRO to identify which
                        packets are individually good for correlating
                        with a response
c2to4                   Take integer, represent in binary, then think
                        of and return that representation in base 4
checkmyews              Check a LSW spectrum through repeated
                        simulation and empirical averages
cns                     Create new zeroed spectrum.
compare.filters         Compares two filters.
compgrot                Compute empirical shift for time ordered
                        non-decimated transforms.
compress                Compress objects
compress.default        Do "zero" run-length encoding compression of a
                        vector of numbers.
compress.imwd           Compress a (thresholded) imwd class object by
                        removing zeroes.
conbar                  Performs inverse DWT reconstruction step
convert                 Convert one type of wavelet object into
                        another.
convert.wd              Convert a non-decimated wd object into a wst
                        object.
convert.wst             Convert a non-decimated wst object into a wd
                        object.
cthresh                 Estimate real signal using complex-valued
                        wavelets
dclaw                   Claw distribution
dencvwd                 Calculate variances of wavlet coefficients of a
                        p.d.f.
denplot                 Calculate plotting information for a density
                        estimate.
denproj                 Calculate empirical scaling function
                        coefficients of a p.d.f.
denwd                   Wavelet decomposition of empirical scaling
                        function coefficients of a p.d.f.
denwr                   Wavelet reconstruction for density estimation.
dof                     Compute number of non-zero coefficients in wd
                        object
doppler                 Evaluate the Donoho and Johnstone Doppler
                        signal.
draw                    Draw wavelets or scaling functions.
draw.default            Draw picture of a wavelet or scaling function.
draw.imwd               Draw mother wavelet associated with an imwd
                        object.
draw.imwdc              Draw mother wavelet associated with an imwdc
                        object.
draw.mwd                Draws a wavelet or scaling function used to
                        compute an 'mwd' object
draw.wd                 Draw mother wavelet or scaling function
                        associated with wd object.
draw.wp                 Draw wavelet packet associated with a wp
                        object.
draw.wst                Draw mother wavelet or scaling function
                        associated with wst object.
drawbox                 Draw a shaded coloured box
drawwp.default          Subsidiary routine that actually computes
                        wavelet packet values
ewspec                  Compute evolutionary wavelet spectrum estimate.
example.1               Compute and return piecewise polynomial
                        coordinates.
filter.select           Provide wavelet filter coefficients.
find.parameters         Find estimates of prior parameters
first.last              Build a first/last database for wavelet
                        transforms.
first.last.dh           Build special first/last database for some
                        wavelet density functions
firstdot                Return the location of the first period
                        character within a character string (for a
                        vector of strings of arbitrary length).
getarrvec               Compute and return weaving permutation for
                        conversion from wst objects to wd class
                        objects.
getpacket               Get a packet of coefficients from a wavelet
                        object
getpacket.wp            Get packet of coefficients from a wavelet
                        packet object (wp).
getpacket.wpst          Get packet of coefficients from a non-decimated
                        wavelet packet object (wpst).
getpacket.wst           Get packet of coefficients from a packet
                        ordered non-decimated wavelet object (wst).
getpacket.wst2D         Get packet of coefficients from a
                        two-dimensional non-decimated wavelet object
                        (wst2D).
griddata objects        Data interpolated to a grid objects.
guyrot                  Cyclically rotate elements of a vector
image.wd                Produce image representation of nondecimated
                        wavelet transform
image.wst               Produce image representation of a wst class
                        object
imwd                    Two-dimensional wavelet transform
                        (decomposition).
imwd.object             Two-dimensional wavelet decomposition objects.
imwdc.object            Two-dimensional compressed wavelet
                        decomposition objects.
imwr                    Inverse two-dimensional wavelet transform.
imwr.imwd               Inverse two-dimensional discrete wavelet
                        transform.
imwr.imwdc              Inverse two-dimensional discrete wavelet
                        transform.
ipd                     Inductance plethysmography data.
ipndacw                 Compute inner product matrix of discrete
                        non-decimated autocorrelation wavelets.
irregwd                 Irregular wavelet transform (decomposition).
irregwd.objects         Irregular wavelet decomposition objects.
l2norm                  Compute L2 distance between two vectors of
                        numbers.
lennon                  John Lennon image.
levarr                  Subsidiary routine that generates a particular
                        permutation
linfnorm                Compute L infinity distance between two vectors
                        of numbers.
logabs                  Take the logarithm of the squares of the
                        argument
lt.to.name              Convert desired level and orientation into code
                        used by imwd
madmad                  Compute square of median absolute deviation
                        (mad) function.
make.dwwt               Compute diagonal of the matrix WWT
makegrid                Interpolate data to a grid.
makewpstDO              Help page for a function
makewpstRO              Make a wavelet packet regression object from a
                        dependent and independent time series variable.
mfilter.select          Provide filter coefficients for multiple
                        wavelets.
mfirst.last             Build a first/last database for multiple
                        wavelet transforms.
modernise               Generic function to upgrade a V2 WaveThresh
                        object to V4
modernise.wd            Modernise a wd class object
mpostfilter             Multiwavelet postfilter
mprefilter              Multiwavelet prefilter
mwd                     Discrete multiple wavelet transform
                        (decomposition).
mwd.object              Multiple wavelet decomposition object (1D)
mwr                     Multiple discrete wavelet transform
                        (reconstruction).
newsure                 Version of sure that acts as subsidiary for
                        threshold.irregwd
nlevelsWT               Returns number of scale (resolution) levels.
nlevelsWT.default       Returns number of levels associated with an
                        object
nullevels               Set whole resolution levels of coefficients
                        equal to zero.
nullevels.imwd          Sets whole resolution levels of coefficients
                        equal to zero in a imwd object.
nullevels.wd            Sets whole resolution levels of coefficients
                        equal to zero in a wd object.
nullevels.wst           Sets whole resolution levels of coefficients
                        equal to zero in a wst object.
numtonv                 Convert an index number into a node vector
                        object.
nv.object               Node vector objects.
plot.imwd               Draw a picture of the 2D wavelet coefficients
                        using image
plot.irregwd            Plot variance factors of wavelet transform
                        coefficients for irregularly spaced wavelet
                        transform object
plot.mwd                Use plot on an mwd object.
plot.nvwp               Depict wavelet packet basis specfication
plot.wd                 Plot wavelet transform coefficients.
plot.wp                 Plot wavelet packet transform coefficients
plot.wst                Plot packet-ordered non-decimated wavelet
                        transform coefficients.
plot.wst2D              Plot packet-ordered 2D non-decimated wavelet
                        coefficients.
plotdenwd               Plot the wavelet coefficients of a p.d.f.
plotpkt                 Sets up a high level plot ready to show the
                        time-frequency plane and wavelet packet basis
                        slots
print.BP                Print top best basis information for BP class
                        object
print.imwd              Print out information about an imwd object in
                        readable form.
print.imwdc             Print out information about an imwdc object in
                        readable form.
print.mwd               Use print() on a mwd object.
print.nv                Print a node vector object, also used by
                        several other functions to obtain packet list
                        information
print.nvwp              Print a wavelet packet node vector object, also
                        used by several other functions to obtain
                        packet list information
print.w2d               Print method for printing w2d class objects
print.w2m               Print a w2m class object
print.wd                Print out information about an wd object in
                        readable form.
print.wd3D              Print out information about an wd3D object in a
                        readable form.
print.wp                Print out information about an wd object in
                        readable form.
print.wpst              Prints out basic information about a wpst class
                        object
print.wpstCL            Prints some information about a wpstCL object
print.wpstDO            Print information about a wpstDO class object
print.wpstRO            Print a wpstRO class object
print.wst               Print out information about an wst object in
                        readable form.
print.wst2D             Print out information about an wst2d object in
                        a readable form.
putC                    Put smoothed data (father wavelet) coefficients
                        into wavelet structure
putC.mwd                Put smoothed data into wavelet structure
putC.wd                 Puts a whole resolution level of father wavelet
                        coeffients into wd wavelet object.
putC.wp                 Warning function when trying to insert father
                        wavelet coefficients into wavelet packet object
                        (wp).
putC.wst                Puts a whole resolution level of father wavelet
                        coeffients into wst wavelet object.
putD                    Put mother wavelet coefficients into wavelet
                        structure
putD.mwd                Put wavelet coefficients into multiple wavelet
                        structure
putD.wd                 Puts a whole resolution level of mother wavelet
                        coeffients into wd wavelet object.
putD.wd3D               Put wavelet coefficient array into a 3D wavelet
                        object
putD.wp                 Puts a whole resolution level of wavelet packet
                        coeffients into wp wavelet object.
putD.wst                Puts a whole resolution level of mother wavelet
                        coeffients into wst wavelet object.
putDwd3Dcheck           Check argument list for putD.wd3D
putpacket               Insert a packet of coefficients into a wavelet
                        object.
putpacket.wp            Inserts a packet of coefficients into a wavelet
                        packet object (wp).
putpacket.wst           Put a packet of coefficients into a packet
                        ordered non-decimated wavelet object (wst).
putpacket.wst2D         Replace packet of coefficients in a
                        two-dimensional non-decimated wavelet object
                        (wst2D).
rcov                    Computes robust estimate of covariance matrix
rfft                    Real Fast Fourier transform
rfftinv                 Inverse real FFT, inverse of rfft
rfftwt                  Weight a Fourier series sequence by a set of
                        weights
rm.det                  Set coarse levels of a wavelets on the interval
                        transform object to zero
rmget                   Search for existing ipndacw matrices.
rmname                  Return a ipndacw matrix style name.
rotateback              Cyclically shift a vector one place to the
                        right
rsswav                  Compute mean residual sum of squares for odd
                        prediction of even ordinates and vice versa
simchirp                Compute and return simulated chirp function.
ssq                     Compute sum of squares difference between two
                        vectors
summary.imwd            Print out some basic information associated
                        with an imwd object
summary.imwdc           Print out some basic information associated
                        with an imwdc object
summary.mwd             Use summary() on a mwd object.
summary.wd              Print out some basic information associated
                        with a wd object
summary.wd3D            Print out some basic information associated
                        with a wd3D object
summary.wp              Print out some basic information associated
                        with a wp object
summary.wpst            Print out some basic information associated
                        with a wpst object
summary.wst             Print out some basic information associated
                        with a wst object
summary.wst2D           Print out some basic information associated
                        with a wst2D object
support                 Returns support of compactly supported
                        wavelets.
sure                    Computes the minimum of the SURE thresholding
                        function
teddy                   Picture of a teddy bear's picnic.
test.dataCT             Test functions for wavelet regression and
                        thresholding
threshold               Threshold coefficients
threshold.imwd          Threshold two-dimensional wavelet decomposition
                        object
threshold.imwdc         Threshold two-dimensional compressed wavelet
                        decomposition object
threshold.irregwd       hold irregularly spaced wavelet decomposition
                        object
threshold.mwd           Use threshold on an mwd object.
threshold.wd            Threshold (DWT) wavelet decomposition object
threshold.wd3D          Threshold 3D DWT object
threshold.wp            Threshold wavelet packet decomposition object
threshold.wst           Threshold (NDWT) packet-ordered non-decimated
                        wavelet decomposition object
tpwd                    Tensor product 2D wavelet transform
tpwr                    Inverse tensor product 2D wavelet transform.
uncompress              Uncompress objects
uncompress.default      Undo zero run-length encoding for a vector.
uncompress.imwdc        Uncompress an imwdc class object
wavegrow                Interactive graphical tool to grow a wavelet
                        synthesis
wavethresh-package      Wavelets Statistics and Transforms
wd                      Wavelet transform (decomposition).
wd.dh                   Compute specialized wavelet transform for
                        density estimation
wd.int                  Computes "wavelets on the interval" transform
wd.object               Wavelet decomposition objects
wd3D                    Three-dimensional discrete wavelet transform
wd3D.object             Three-dimensional wavelet object
wp                      Wavelet packet transform.
wp.object               Wavelet Packet decomposition objects.
wpst                    Non-decimated wavelet packet transform.
wpst2discr              Reshape/reformat packet coefficients into a
                        multivariate data set
wpst2m                  Converts a nondecimated wavelet packet object
                        to a (large) matrix with packets stored as
                        columns
wpstCLASS               Predict values using new time series values via
                        a non-decimated wavelet packet discrimination
                        object.
wpstREGR                Construct data frame using new time series
                        using information from a previously constructed
                        wpstRO object
wr                      Wavelet reconstruction (inverse DWT).
wr.int                  Computes inverse "wavelets on the interval"
                        transform.
wr.mwd                  Multiple wavelet reconstruction for mwd objects
wr.wd                   Wavelet reconstruction for wd class objects
                        (inverse discrete wavelet transform).
wr3D                    Inverse DWT for 3D DWT object.
wst                     Packet-ordered non-decimated wavelet transform.
wst.object              (Packet ordered) Nondecimated wavelet transform
                        decomposition objects.
wst2D                   (Packet-ordered) 2D non-decimated wavelet
                        transform.
wst2D.object            (Packet ordered) Two-dimensional nondecimated
                        wavelet transform decomposition objects.
wstCV                   Performs two-fold cross-validation estimation
                        using packet-ordered non-decimated wavelet
                        transforms and one, global, threshold.
wstCVl                  Performs two-fold cross-validation estimation
                        using packet-ordered non-decimated wavelet
                        transforms and a (vector) level-dependent
                        threshold.
wvcvlrss                Computes estimate of error for function
                        estimate.
wvmoments               Compute moments of wavelets or scaling function
wvrelease               Prints out the release number of the WaveThresh
                        package
</pre>
<p>See book or individual help pages for main functions. For example,
<code><a href="#topic+wd">wd</a></code> for the one-dimensional discrete wavelet transform.
</p>


<h3>Author(s)</h3>

<p>Guy Nason [aut, cre],
  Stuart Barber [ctb],
  Tim Downie [ctb],
  Piotr Frylewicz [ctb],
  Arne Kovac [ctb],
  Todd Ogden [ctb],
  Bernard Silverman [ctb]
</p>
<p>Maintainer: Guy Nason &lt;g.nason@imperial.ac.uk&gt;
</p>


<h3>References</h3>

<p>Nason, G.P. (2008) Wavelet methods in Statistics with R. Springer, New York.
<a href="https://link.springer.com/book/10.1007/978-0-387-75961-6">Book URL.</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ewspec">ewspec</a></code>, <code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+threshold">threshold</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wst">wst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See examples in individual help pages
#
</code></pre>

<hr>
<h2 id='accessc'>Get variance information from irregularly spaced wavelet decomposition object. </h2><span id='topic+accessc'></span>

<h3>Description</h3>

<p>This function gets information from the c component of an <code><a href="#topic+irregwd.objects">irregwd.objects</a></code> an irregularly spaced wavelet decomposition object. 
</p>
<p>Note that this function is <em>not</em> the same as <code><a href="#topic+accessC">accessC</a></code> which obtains father wavelet coefficients from an <code><a href="#topic+wd">wd</a></code> class object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accessc(irregwd.structure, level, boundary=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessc_+3A_irregwd.structure">irregwd.structure</code></td>
<td>
<p>Irregular wavelet decomposition object from which you wish to extract parts of the <code>c</code> component from.</p>
</td></tr>
<tr><td><code id="accessc_+3A_level">level</code></td>
<td>
<p>The level that you wish to extract. This value ranges from 0 to the <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(irregwd.structure)-1.</p>
</td></tr>
<tr><td><code id="accessc_+3A_boundary">boundary</code></td>
<td>
<p>If this argument is T then all of the boundary correction values will be returned as well (note: the length of the returned vector may not be a power of 2). If boundary is false, then just the coefficients will be returned. If the decomposition (or reconstruction) was done with periodic boundary conditions then this option has no effect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+irregwd">irregwd</a></code> function produces a irregular wavelet decomposition (reconstruction) structure. 
</p>
<p>The <code>c</code> component is stored in a similar way to the C and D vectors which store the father and mother wavelet coefficients respectively. Hence to access the information the accessc function plays a similar role to <code><a href="#topic+accessC">accessC</a></code> and <code><a href="#topic+accessD">accessD</a></code> functions. 
</p>


<h3>Value</h3>

<p>A vector of the extracted data. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.4 Code Copyright Arne Kovac 1997. Help Copyright Guy Nason 2004. </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+irregwd">irregwd</a></code>, <code><a href="#topic+irregwd.objects">irregwd.objects</a></code>, <code><a href="#topic+threshold.irregwd">threshold.irregwd</a></code>,<code><a href="#topic+makegrid">makegrid</a></code>, <code><a href="#topic+plot.irregwd">plot.irregwd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Most users will not need to use this function. However, see the main
# examples for the irregular wavelet denoising in the examples for
# makegrid.
#
</code></pre>

<hr>
<h2 id='accessC'>Get &quot;detail&quot; (mother wavelet) coefficients data from wavelet object</h2><span id='topic+accessC'></span>

<h3>Description</h3>

<p>This generic function extracts detail from various types of wavelet objects. It extracts and returns a whole resolution level of coefficients. To obtain individual packets from relevant transforms use the <a href="#topic+getpacket">getpacket</a>() series of functions. 
This function is generic. 
</p>
<p>Particular methods exist. For objects of class:
</p>

<dl>
<dt>wd</dt><dd><p>use the <code><a href="#topic+accessC.wd">accessC.wd</a></code> method</p>
</dd>
<dt>wp</dt><dd><p>use the <code><a href="#topic+accessC.wp">accessC.wp</a></code> method</p>
</dd>
<dt>wst</dt><dd><p>use the <code><a href="#topic+accessC.wst">accessC.wst</a></code> method</p>
</dd>
</dl>

<p>See individual method help pages for operation and examples. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accessC(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessC_+3A_...">...</code></td>
<td>
<p>See individual help for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector coefficients representing the detail coefficients for the requested resolution level. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.wd">accessC.wd</a></code>, <code><a href="#topic+accessC.wp">accessC.wp</a></code>,<code><a href="#topic+accessC.wst">accessC.wst</a></code>,<code><a href="#topic+accessD">accessD</a></code>
</p>

<hr>
<h2 id='accessC.mwd'>Get Smoothed Data from Wavelet Structure</h2><span id='topic+accessC.mwd'></span>

<h3>Description</h3>

<p>The smoothed and original data from a multiple wavelet decomposition structure, <code><a href="#topic+mwd.object">mwd.object</a></code>  ect  (e.g. returned from <code><a href="#topic+mwd">mwd</a></code>) are packed into a single matrix in that structure.  TRUE  his function extracts the data corresponding to a particular resolution level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mwd'
accessC(mwd, level = nlevelsWT(mwd), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessC.mwd_+3A_mwd">mwd</code></td>
<td>
<p>Multiple wavelet decomposition structure from which you wish to extract the smoothed or original data if the structure is from a wavelet decomposition, or the reconstructed data if the structure is from a wavelet reconstruction.</p>
</td></tr>
<tr><td><code id="accessC.mwd_+3A_level">level</code></td>
<td>
<p>The level that you wish to extract. By default, this is the level with most detail (in the case of structures from a decomposition this is the original data, in the case of structures from a reconstruction this is the top-level reconstruction).</p>
</td></tr>
<tr><td><code id="accessC.mwd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="#topic+mwd">mwd</a> function produces a wavelet decomposition structure.
</p>
<p>For decomposition, the top level contains the original data, and subsequent lower levels contain the successively smoothed data. So if there are <code>mwd$filter$npsi*2^m</code> original data points (<code>mwd$filter$npsi</code> is the multiplicity of wavelets), there will be <code>m+1</code> levels indexed 0,1,...,m. So 
</p>
<p><code>accessC.mwd(Mwd, level=m)</code>
</p>
<p>pulls out the original data, as does
</p>
<p><code>accessC.mwd(mwd)</code>
</p>
<p>To get hold of lower levels just specify the level that you're interested in, e.g. 
</p>
<p><code>accessC.mwd(mwd, level=2)</code>
</p>
<p>Gets hold of the second level.
</p>
<p>The need for this function is a consequence of the pyramidal structure of Mallat's algorithm and the memory efficiency gain achieved by storing the pyramid as a linear matrix of coefficients. AccessC obtains information about where the smoothed data appears from the fl.dbase component of mwd, in particular the array <code>fl.dbase$first.last.c</code> which gives a complete specification of index numbers and offsets for <code>mwd$C</code>. 
</p>
<p>Note also that this function only gets information from <a href="#topic+mwd">mwd</a> class objects. To <em>put</em> coefficients into <a href="#topic+mwd">mwd</a> structures you have to use the <a href="#topic+putC.mwd">putC.mwd</a> function. 
</p>
<p>See Downie and Silverman, 1998. 
</p>


<h3>Value</h3>

<p>A matrix with <code>mwd$filter$npsi</code> rows containing the extracted data of all the coefficients at that level.
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie 1995-6.)</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mfilter.select">mfilter.select</a></code>, <code><a href="#topic+mwd">mwd</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+mwr">mwr</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>, <code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Get the 3rd level of smoothed data from a decomposition
#
dat &lt;- rnorm(32)
accessC.mwd(mwd(dat), level=3)
</code></pre>

<hr>
<h2 id='accessC.wd'>Get smoothed data from wavelet object (wd)</h2><span id='topic+accessC.wd'></span>

<h3>Description</h3>

<p>The smoothed and original data from a wavelet decomposition structure
(returned from <code><a href="#topic+wd">wd</a></code>) are packed into a single vector in that
structure.  This function extracts the data corresponding to a
particular resolution level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
accessC(wd, level = nlevelsWT(wd), boundary=FALSE, aspect, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessC.wd_+3A_wd">wd</code></td>
<td>

<p>wavelet decomposition structure from which you wish to extract the
smoothed or original data if the structure is from a wavelet decomposition,
or the reconstructed data if the structure is from a wavelet reconstruction.
</p>
</td></tr>
<tr><td><code id="accessC.wd_+3A_level">level</code></td>
<td>

<p>the level that you wish to extract.  By default, this is the level with
most detail (in the case of structures from a decomposition this is the
original data, in the case of structures from a reconstruction this is the
top-level reconstruction).
</p>
</td></tr>
<tr><td><code id="accessC.wd_+3A_boundary">boundary</code></td>
<td>
<p>logical;
if <code>TRUE</code> then all of the boundary correction values
will be returned as well (note: the length of the returned vector
may not be a power of 2).<br />
If <code>boundary</code> is false, then just the coefficients will be returned.
</p>
<p>If the decomposition (or reconstruction)
was done with periodic boundary conditions, this option has no effect.</p>
</td></tr>
<tr><td><code id="accessC.wd_+3A_aspect">aspect</code></td>
<td>
<p>Applies a function to the coefficients before return.
Supplied as a text string which gets converted to a function.
For example, &quot;Mod&quot; for complex-valued arguments</p>
</td></tr>
<tr><td><code id="accessC.wd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="#topic+wd">wd</a> (<code><a href="#topic+wr.wd">wr.wd</a></code>) function produces a wavelet decomposition (reconstruction)
structure.
</p>
<p>For decomposition, the top level contains the original data, and
subsequent lower levels contain the successively smoothed data.
So if there are <code class="reqn">2^m</code> original data points, there will be m+1 levels
indexed 0,1,...,m. So
</p>
<p><code>accessC.wd(wdobj, level=m)</code>
</p>
<p>pulls out the original data, as does
</p>
<p><code>accessC.wd(wdobj)</code>
</p>
<p>To get hold of lower levels just specify the level that you're interested
in, e.g.
</p>
<p><code>accessC.wd(wdobj, level=2)</code>
</p>
<p>gets hold of the second level.
</p>
<p>For reconstruction, the top level contains the ultimate step in the
Mallat pyramid reconstruction algorithm, lower levels are intermediate
steps.
</p>
<p>The need for this function is a consequence of the pyramidal structure
of Mallat's algorithm and the memory efficiency gain achieved by
storing the pyramid as a linear vector. AccessC obtains information about
where the smoothed data appears from the fl.dbase component of
an <a href="#topic+wd.object">wd.object</a>, in particular the array <code>fl.dbase$first.last.c</code> which
gives a complete specification of index numbers and offsets for
<code>wd.object$C</code>.
</p>
<p>Note that this function is method for the generic function <code><a href="#topic+accessC">accessC</a></code>.
When the <code><a href="#topic+wd.object">wd.object</a></code> is definitely a wd class object then you only need use the generic version of this function. 
</p>
<p>Note that this function only gets information from <code><a href="#topic+wd">wd</a></code> class
objects. To insert coefficients etc. into <code><a href="#topic+wd">wd</a></code> structures you have to
use the <code><a href="#topic+putC">putC</a></code> function (or more precisely, the <code><a href="#topic+putC.wd">putC.wd</a></code> method).
</p>


<h3>Value</h3>

<p>A vector of the extracted data.
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Mallat, S. G. (1989) A theory for multiresolution signal decomposition: 
the wavelet representation. <em>IEEE Transactions on Pattern Analysis
and Machine Intelligence</em> <b>11</b>, 674&ndash;693.
</p>
<p>Nason, G. P. and Silverman, B. W. (1994). The discrete wavelet transform in S. 
<em>Journal of Computational and Graphical Statistics,</em> <b>3</b>, 163&ndash;191. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+wr">wr</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+accessD.wd">accessD.wd</a></code>,
<code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+threshold">threshold</a></code>, <code><a href="#topic+putC.wd">putC.wd</a></code>, <code><a href="#topic+putD.wd">putD.wd</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get the 3rd level of smoothed data from a decomposition
dat &lt;- rnorm(64)
accessC(wd(dat), level=3)
</code></pre>

<hr>
<h2 id='accessC.wp'>Warning function when trying to access smooths from wavelet packet object (wp).</h2><span id='topic+accessC.wp'></span>

<h3>Description</h3>

<p>There are no real smooths to access in a <code><a href="#topic+wp">wp</a></code> wavelet packet object. This function returns an error message. To obtain coefficients from a wavelet packet object you should use the <code><a href="#topic+getpacket">getpacket</a></code> collection of functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
accessC(wp, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessC.wp_+3A_wp">wp</code></td>
<td>
<p>Wavelet packet object.</p>
</td></tr>
<tr><td><code id="accessC.wp_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An error message!</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

 <p><code><a href="#topic+getpacket">getpacket</a></code>
</p>

<hr>
<h2 id='accessC.wst'>Get smoothed data from packet ordered non-decimated wavelet object (wst)</h2><span id='topic+accessC.wst'></span>

<h3>Description</h3>

<p>The smoothed data from a packet ordered non-decimated wavelet object (returned from <code><a href="#topic+wst">wst</a></code>) are stored in a matrix. This function extracts all the coefficients corresponding to a particular resolution level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
accessC(wst, level, aspect, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessC.wst_+3A_wst">wst</code></td>
<td>
<p>Packet ordered non-decimated wavelet object from which you wish to extract the smoothed or original data (if the object is directly from a packet ordered non-decimated wavelet transform of some data).</p>
</td></tr>
<tr><td><code id="accessC.wst_+3A_level">level</code></td>
<td>
<p>The level that you wish to extract. This can range from zero (the coarsest coefficients) to nlevelsWT(wstobj) which returns the original data.</p>
</td></tr>
<tr><td><code id="accessC.wst_+3A_aspect">aspect</code></td>
<td>
<p>Applies function to coefficients before return. Supplied
as a character string which gets converted to a function.
For example &quot;Mod&quot; which returns the absolute values of the coefficients</p>
</td></tr>
<tr><td><code id="accessC.wst_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+wst">wst</a></code> function performs a packet-ordered non-decimated wavelet transform. This function extracts all the father wavelet coefficients at a particular resolution level specified by <code>level</code>.
</p>
<p>Note that coefficients returned by this function are in <em>packet order</em>. They can be used <em>as is</em> but for many applications it might be more useful to deal with the coefficients in packets: see the function <code><a href="#topic+getpacket.wst">getpacket.wst</a></code> for further details. 
</p>


<h3>Value</h3>

<p>A vector of the extracted data. 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G. P. and Silverman, B. W. (1994). The discrete wavelet transform in S. <em>Journal of Computational and Graphical Statistics</em>, <b>3</b>, 163&ndash;191. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+accessC">accessC</a></code>, <code><a href="#topic+getpacket.wst">getpacket.wst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Get the 3rd level of smoothed data from a decomposition
#
dat &lt;- rnorm(64)
accessC(wst(dat), level=3)
</code></pre>

<hr>
<h2 id='accessD'>Get &quot;detail&quot; (mother wavelet) coefficients data from wavelet object</h2><span id='topic+accessD'></span>

<h3>Description</h3>

<p>This generic function extracts detail from various types of wavelet objects. It extracts and returns a whole resolution level of coefficients. To obtain individual packets from relevant transforms use the <a href="#topic+getpacket">getpacket</a>() series of functions. 
This function is generic. 
</p>
<p>Particular methods exist. For objects of class:
</p>

<dl>
<dt>wd</dt><dd><p>use the <code><a href="#topic+accessD.wd">accessD.wd</a></code> method</p>
</dd>
<dt>wd3D</dt><dd><p>use the <code><a href="#topic+accessD.wd3D">accessD.wd3D</a></code> method</p>
</dd>
<dt>wp</dt><dd><p>use the <code><a href="#topic+accessD.wp">accessD.wp</a></code> method</p>
</dd>
<dt>wpst</dt><dd><p>use the <code><a href="#topic+accessD.wpst">accessD.wpst</a></code> method</p>
</dd>
<dt>wst</dt><dd><p>use the <code><a href="#topic+accessD.wst">accessD.wst</a></code> method</p>
</dd>
</dl>

<p>See individual method help pages for operation and examples. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accessD(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessD_+3A_...">...</code></td>
<td>
<p>See individual help for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector coefficients representing the detail coefficients for the requested resolution level. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessD.wd">accessD.wd</a></code>, <code><a href="#topic+accessD.wp">accessD.wp</a></code>,<code><a href="#topic+accessD.wst">accessD.wst</a></code>,<code><a href="#topic+accessC">accessC</a></code>
</p>

<hr>
<h2 id='accessD.mwd'>Get wavelet coefficients from multiple wavelet structure (mwd).</h2><span id='topic+accessD.mwd'></span>

<h3>Description</h3>

<p>The wavelet coefficients from a multiple wavelet decomposition structure, <code><a href="#topic+mwd.object">mwd.object</a></code>, (e.g. returned from <code><a href="#topic+mwd">mwd</a></code>) are packed into a single matrix in that structure. This function extracts the coefficients corresponding to a particular resolution level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mwd'
accessD(mwd, level, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessD.mwd_+3A_mwd">mwd</code></td>
<td>
<p>Multiple wavelet decomposition structure from which you wish to extract the expansion coefficients.</p>
</td></tr>
<tr><td><code id="accessD.mwd_+3A_level">level</code></td>
<td>
<p>The level that you wish to extract. If the &quot;original&quot; data has <code>mwd$filter$npsi*2^m</code> data points (<code>mwd$filter$npsi</code> being the multiplicity of the multiple wavelets) then there are m possible levels that you could want to access, indexed by 0,1,...,(m-1) </p>
</td></tr>
<tr><td><code id="accessD.mwd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+mwd">mwd</a></code> function produces a <code>multiple wavelet decomposition object</code> .
</p>
<p>The need for this function is a consequence of the pyramidal structure of
<code>Mallats algorithm</code> and the memory efficiency gain achieved by storing
the pyramid as a linear matrix.
AccessD obtains information about where the coefficients appear from the
fl.dbase component of <code><a href="#topic+mwd">mwd</a></code>,
in particular the array <code>fl.dbase$first.last.d</code> which gives a complete
specification of index numbers and offsets for <code>mwd$D</code>. 
</p>
<p>Note that this function and <code><a href="#topic+accessC">accessC</a></code> only work on objects of class <code><a href="#topic+mwd">mwd</a></code> to <em>extract</em> coefficients. You have to use
<code><a href="#topic+putD.mwd">putD.mwd</a></code> to insert wavelet coefficients into a <code><a href="#topic+mwd">mwd</a></code> object. 
</p>
<p>See Downie and Silverman, 1998. 
</p>


<h3>Value</h3>

<p>A matrix with <code>mwd$filter$npsi</code> rows containing the extracted coefficients.
</p>


<h3>RELEASE</h3>

<p>Tim Downie 1995-6</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mfilter.select">mfilter.select</a></code>, <code><a href="#topic+mwd">mwd</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>, <code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Get the 3rd level of smoothed data from a decomposition
#
data(ipd)
accessD.mwd(mwd(ipd), level=3)
</code></pre>

<hr>
<h2 id='accessD.wd'>Get detail (mother wavelet) coefficients from wavelet object (wd).</h2><span id='topic+accessD.wd'></span>

<h3>Description</h3>

<p>This function extracts and returns a vector of mother wavelet coefficients, corresponding to a particular resolution level, from a <code><a href="#topic+wd">wd</a></code> wavelet decomposition object.
</p>
<p>The pyramid of coefficients in a wavelet decomposition (returned from the <code><a href="#topic+wd">wd</a></code> function, say) are packed into a single vector in WaveThresh. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
accessD(wd, level, boundary=FALSE, aspect="Identity", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessD.wd_+3A_wd">wd</code></td>
<td>
<p>Wavelet decomposition object from which you wish to extract the mother wavelet coefficients.</p>
</td></tr>
<tr><td><code id="accessD.wd_+3A_level">level</code></td>
<td>
<p>The resolution level at which you wish to extract coefficients.</p>
</td></tr>
<tr><td><code id="accessD.wd_+3A_boundary">boundary</code></td>
<td>
<p>some methods of wavelet transform computation handle the boundaries by keeping some extra bookkeeping coefficients at either end of a resolution level. If this argument is TRUE then these bookkeeping coefficients are returned when the mother wavelets are returned. Otherwise, if FALSE, these coefficients are not returned.</p>
</td></tr>
<tr><td><code id="accessD.wd_+3A_aspect">aspect</code></td>
<td>
<p>The aspect argument permits the user to supply a function to modify the returned coefficients. The function is applied to the vector of coefficients before it is returned. This can be useful, say, with the complex DWT where you could supply aspect=&quot;Mod&quot; if you wanted to return the modulus of the coefficients at a given resolution level. The default argument, &quot;Identity&quot;, ensures that the coefficients are not modified before returning.</p>
</td></tr>
<tr><td><code id="accessD.wd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The need for this function is a consequence of the pyramidal structure of Mallat's algorithm and the memory efficiency gain achieved by storing the pyramid as a linear vector. AccessD obtains information about where the smoothed data appears from the <code>fl.dbase</code> component of an <code><a href="#topic+wd">wd</a></code> object, in particular the array
</p>
<p><code>fl.dbase$first.last.d</code>
</p>
<p>which gives a complete specification of index numbers and offsets for
</p>
<p><code>wd.object$D</code>.
</p>
<p>Note that this function is a method for the generic function <code><a href="#topic+accessD">accessD</a></code>. 
</p>
<p>Note also that this function only retrieves information from <code><a href="#topic+wd">wd</a></code> class objects. To insert coefficients into <code><a href="#topic+wd">wd</a></code> objects you have to use the <code><a href="#topic+putD">putD</a></code> function (or more precisely, the <code><a href="#topic+putD.wd">putD.wd</a></code> method).
</p>


<h3>Value</h3>

<p>A vector containing the mother wavelet coefficients at the required resolution level (the coefficients might have been modified depending on the value of the aspect argument).
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Mallat, S. G. (1989) A theory for multiresolution signal decomposition: the wavelet representation. <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>. <b>11</b>, 674&ndash;693. 
</p>
<p>Nason, G. P. and Silverman, B. W. (1994). The discrete wavelet transform in S. <em>Journal of Computational and Graphical Statistics</em>, <b>3</b>, 163&ndash;191
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wr">wr</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+threshold">threshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Get the 4th resolution level of wavelet coefficients. 
#
dat &lt;- rnorm(128)
accessD(wd(dat), level=4)
</code></pre>

<hr>
<h2 id='accessD.wd3D'>Get wavelet coefficients from 3D wavelet object</h2><span id='topic+accessD.wd3D'></span>

<h3>Description</h3>

<p>This function extracts and returns arrays of wavelet coefficients, corresponding to a particular resolution level, from a <code><a href="#topic+wd">wd</a></code> wavelet decomposition object.
</p>
<p>The pyramid of coefficients in a wavelet decomposition (returned from the <code><a href="#topic+wd3D">wd3D</a></code> function, say) are packed into a single array in <code>WaveThresh3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd3D'
accessD(obj, level = nlevelsWT(obj)-1, block, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessD.wd3D_+3A_obj">obj</code></td>
<td>
<p>3D Wavelet decomposition object from which you wish to extract the wavelet coefficients.</p>
</td></tr>
<tr><td><code id="accessD.wd3D_+3A_level">level</code></td>
<td>
<p>The resolution level at which you wish to extract coefficients. The minimum level you can enter is 0, the largest is one less than the number of nlevelsWT stored in the obj object.</p>
</td></tr>
<tr><td><code id="accessD.wd3D_+3A_block">block</code></td>
<td>
<p>if block is missing then a list containing all of the wavelet coefficient blocks GGG, GGH, GHG, GHH, HGG, HGH, HHG (and HHH, if level=0) is returned. Otherwise block should be one of the character strings GGG, GGH, GHG, GHH, HGG, HGH, HHG and then only that sub-block is returned from the resolution level specified.</p>
</td></tr>
<tr><td><code id="accessD.wd3D_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The need for this function is a consequence of the pyramidal structure of Mallat's algorithm and the memory efficiency gain achieved by storing the pyramid as a array. 
</p>
<p>Note that this functiOn is a method for the generic function <code><a href="#topic+accessD">accessD</a></code>.
</p>


<h3>Value</h3>

<p>If the block is missing then a list is returned containing all the sub-blocks of coefficients for the specificed resolution <code>level</code>.
</p>
<p>Otherwise the block character string specifies which sub-block of coefficients to return. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code>link{accessD}</code>, <code>link{print.wd3D}</code>, <code>link{putD.wd3D}</code>,  <code>link{putDwd3Dcheck}</code>,  <code>link{summary.wd3D}</code>,  <code>link{threshold.wd3D}</code>,  <code>link{wd3D}</code>,  <code>link{wd3D object}</code>,  <code>link{wr3D}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
a &lt;- array(rnorm(8*8*8), dim=c(8,8,8))
#
# Perform the 3D DWT
#
awd3D &lt;- wd3D(a)
#
# How many levels does this object have?
#
nlevelsWT(awd3D)
# [1] 3
#
# So conceivably we could access levels 0, 1 or 2.
#
# Ok. Let's get the level 1 HGH sub-block coefficients:
#
accessD(awd3D, level=1, block="HGH")
#
#, , 1
#           [,1]      [,2] 
#[1,]  0.8359289 1.3596832
#[2,] -0.1771688 0.2987303
#
#, , 2
#           [,1]       [,2] 
#[1,] -1.2633313 1.00221652
#[2,] -0.3004413 0.04728019
#
# This was a 3D array of dimension size 2 (8 -&gt; 4 -&gt; 2, level 3, 2 and then 1)
#
#
# Let's do the same call except this time don't specify the block arg.
#
alllev1 &lt;- accessD(awd3D, level=1)
#
# This new object should be a list containing all the subblocks at this level.
# What are the components?
#
names(alllev1)
#[1] "GHH" "HGH" "GGH" "HHG" "GHG" "HGG" "GGG"
#
# O.k. Let's look at HGH again
#
alllev1$HGH
#
#, , 1
#           [,1]      [,2] 
#[1,]  0.8359289 1.3596832
#[2,] -0.1771688 0.2987303
#
#, , 2
#           [,1]       [,2] 
#[1,] -1.2633313 1.00221652
#[2,] -0.3004413 0.04728019
#
# Same as before.
#
</code></pre>

<hr>
<h2 id='accessD.wp'>Obtain whole resolution level of wavelet packet coefficients from a wavelet packet object (wp).</h2><span id='topic+accessD.wp'></span>

<h3>Description</h3>

<p>Get a whole resolution level's worth of coefficients from a <code><a href="#topic+wp">wp</a></code> wavelet packet object. To obtain packets of coefficients from a wavelet packet object you should use the <code><a href="#topic+getpacket">getpacket</a></code> collection of functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
accessD(wp, level, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessD.wp_+3A_wp">wp</code></td>
<td>
<p>Wavelet packet object</p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code id="accessD.wp_+3A_level">level</code></td>
<td>
<p>the resolution level that you wish to extract.</p>
</td></tr>
<tr><td><code id="accessD.wp_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The wavelet packet coefficients are actually stored in a straightforward manner in a matrix component of a <code><a href="#topic+wp">wp</a></code> object so it would not be too difficult to extract whole resolution levels yourself. However, this routine makes it easier to do.
</p>


<h3>Value</h3>

<p>A vector containing the coefficients that you wanted to extract. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+getpacket">getpacket</a></code>
</p>

<hr>
<h2 id='accessD.wpst'>Get coefficients from a non-decimated wavelet packet object (wpst) in time order.</h2><span id='topic+accessD.wpst'></span>

<h3>Description</h3>

<p>The coefficients from a non-decimated wavelet packet object, <code><a href="#topic+wpst">wpst</a></code>, are stored in a particular order in the wpst component of the wpstobj object. This function extracts all the coefficients corresponding to a particular wavelet packet in time order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wpst'
accessD(wpst, level, index, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessD.wpst_+3A_wpst">wpst</code></td>
<td>
<p>Non-decimated wavelet packet object from which you wish to extract time-ordered coefficients.</p>
</td></tr>
<tr><td><code id="accessD.wpst_+3A_level">level</code></td>
<td>
<p>The resolution level that you wish to extract. This can range from zero (the coarsest coefficients) to nlevelsWT-1(wstobj) which are the finest scale coefficients.</p>
</td></tr>
<tr><td><code id="accessD.wpst_+3A_index">index</code></td>
<td>
<p>The wavelet packet index that you require (sequency ordering). This can range from 0 (father wavelet coeffcients) to <code>2^(nlevelsWT - level) - 1</code>, i.e. the maximum is dependent on the resolution level.</p>
</td></tr>
<tr><td><code id="accessD.wpst_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+wpst">wpst</a></code> function performs a non-decimated wavelet packet transform. This function extracts the coefficients at a particular resolution level specified by level in time order. 
</p>
<p>It is possible to extract the individual packets (before interweaving, i.e. the direct result of multiple applications of the packet operators) by using the <code><a href="#topic+getpacket.wpst">getpacket.wpst</a></code> function.</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G.P., Sapatinas, T. and Sawczenko, A. Statistical modelling using undecimated wavelet transforms. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpst">wpst</a></code>, <code>wpst.object</code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+getpacket.wpst">getpacket.wpst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Get the 4th level of coefficients from a decomposition
#
dat &lt;- rnorm(128)
accessD(wpst(dat), level=4, index=3)
</code></pre>

<hr>
<h2 id='accessD.wst'>Get mother wavelet coefficients from a packet ordered non-decimated wavelet object (wst).</h2><span id='topic+accessD.wst'></span>

<h3>Description</h3>

<p>The mother wavelet coefficients from a packet ordered non-decimated wavelet object, <code><a href="#topic+wst">wst</a></code>, are stored in a matrix. This function extracts all the coefficients corresponding to a particular resolution level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
accessD(wst, level, aspect = "Identity", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessD.wst_+3A_wst">wst</code></td>
<td>
<p>Packet ordered non-decimated wavelet object from which you wish to extract the mother wavelet coefficients.</p>
</td></tr>
<tr><td><code id="accessD.wst_+3A_level">level</code></td>
<td>
<p>The level that you wish to extract. This can range from zero (the coarsest coefficients) to nlevelsWT(wstobj) which returns the original data. </p>
</td></tr>
<tr><td><code id="accessD.wst_+3A_aspect">aspect</code></td>
<td>
<p>Function to apply to coefficient before return.
Supplied as a character argument which gets converted to a function.
For example, &quot;Mod&quot; which returns the absolute value of complex-valued
coefficients.</p>
</td></tr>
<tr><td><code id="accessD.wst_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+wst">wst</a></code> function performs a packet-ordered non-decimated wavelet transform. This function extracts all the mother wavelet coefficients at a particular resolution level specified by <code>level</code>.
</p>
<p>Note that coefficients returned by this function are in <em>packet order</em>. They can be used <em>as is</em> but for many applications it might be more useful to deal with the coefficients in packets: see the function <code><a href="#topic+getpacket.wst">getpacket.wst</a></code> for further details. 
</p>
<p>Note that all the coefficients here are those of mother wavelets. The non-decimated transform efficiently computes all possible shifts of the discrete wavelet transform computed by <code><a href="#topic+wd">wd</a></code>.
</p>


<h3>Value</h3>

<p>A vector of the extracted coefficients. 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G.P. and Silverman, B.W. The stationary wavelet transform and some statistical applications. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+getpacket.wst">getpacket.wst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Get the 4th level of mother wavelet coefficients from a decomposition
#
dat &lt;- rnorm(128)
accessD(wst(dat), level=4)
</code></pre>

<hr>
<h2 id='addpkt'>Add a wavelet packet box to an already set up time-frequency plot</h2><span id='topic+addpkt'></span>

<h3>Description</h3>

<p>This function assumes that a high-level plot has already been set
up using <code><a href="#topic+plotpkt">plotpkt</a></code>. Given that this function plots
a wavelet packet box at a given level, packet index and with
particular shading and color and optionally plotting a sequence of
coefficients at that location rather than a shaded box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addpkt(level, index, density, col, yvals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addpkt_+3A_level">level</code></td>
<td>
<p>The level at which the box or yvals are plotted</p>
</td></tr>
<tr><td><code id="addpkt_+3A_index">index</code></td>
<td>
<p>The packet index at which the box of yvals are plotted</p>
</td></tr>
<tr><td><code id="addpkt_+3A_density">density</code></td>
<td>
<p>The density of the shading of the box</p>
</td></tr>
<tr><td><code id="addpkt_+3A_col">col</code></td>
<td>
<p>The color of the box</p>
</td></tr>
<tr><td><code id="addpkt_+3A_yvals">yvals</code></td>
<td>
<p>If this argument is missing then a shaded coloured box is
drawn, otherwise a time series of <code>yvals</code> is plotted where
the box would have been.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisplot">basisplot</a></code>,<code><a href="#topic+basisplot.BP">basisplot.BP</a></code>,
<code><a href="#topic+basisplot.wp">basisplot.wp</a></code>, <code><a href="#topic+plotpkt">plotpkt</a></code>, <code><a href="#topic+plot.nvwp">plot.nvwp</a></code></p>

<hr>
<h2 id='AutoBasis'>Run Coifman-Wickerhauser best basis algorithm on wavelet packet object</h2><span id='topic+AutoBasis'></span>

<h3>Description</h3>

<p>Runs the Coifman-Wickerhauser best basis algorithm on a wavelet packet
object. Packets not in the basis are replaced by vectors of NAs.
Superceded by the <code><a href="#topic+MaNoVe">MaNoVe</a></code> functions.
</p>


<h3>Details</h3>

<p>Superceded by the <code><a href="#topic+MaNoVe">MaNoVe</a></code> functions (which run in C code).
</p>


<h3>Value</h3>

<p>A wp class object which contains the select basis. All packets that are
not in the basis get replaced by vectors of NAs.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+MaNoVe">MaNoVe</a></code></p>

<hr>
<h2 id='av.basis'>Perform basis averaging for wst class object</h2><span id='topic+av.basis'></span>

<h3>Description</h3>

<p><b>Note:</b> that this function is not for direct user use. This function
is a helper routine for the <code><a href="#topic+AvBasis.wst">AvBasis.wst</a></code> function which is
the one that should be used by users.
</p>
<p>This function works by recursion, essentially it merges the current
levels C coefficients from one packet shift with its associated
D coefficients, does the same for the other packet shift and then
averages the two reconstructions to provide the C coefficients for
the next level up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av.basis(wst, level, ix1, ix2, filter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="av.basis_+3A_wst">wst</code></td>
<td>
<p>The <code><a href="#topic+wst.object">wst.object</a></code> that you wish to basis average</p>
</td></tr>
<tr><td><code id="av.basis_+3A_level">level</code></td>
<td>
<p>The resolution level the function is currently operating at</p>
</td></tr>
<tr><td><code id="av.basis_+3A_ix1">ix1</code></td>
<td>
<p>Which &quot;left&quot; packet in the level you are accessing</p>
</td></tr>
<tr><td><code id="av.basis_+3A_ix2">ix2</code></td>
<td>
<p>Which &quot;right&quot; packet</p>
</td></tr>
<tr><td><code id="av.basis_+3A_filter">filter</code></td>
<td>
<p>The wavelet filter details, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all, see help page for <code><a href="#topic+AvBasis.wst">AvBasis.wst</a></code>.
</p>


<h3>Value</h3>

<p>Returns the average basis reconstruction of a <code><a href="#topic+wst.object">wst.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+AvBasis">AvBasis</a></code>, <code><a href="#topic+AvBasis.wst">AvBasis.wst</a></code>,
<code><a href="#topic+conbar">conbar</a></code>, <code><a href="#topic+rotateback">rotateback</a></code>,
<code><a href="#topic+getpacket">getpacket</a></code></p>

<hr>
<h2 id='AvBasis'>Basis averaging (&quot;inversion&quot;)</h2><span id='topic+AvBasis'></span>

<h3>Description</h3>

<p>Average of whole collection of basis functions. 
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist. For the <code><a href="#topic+wst">wst</a></code> class object this generic function uses  <code><a href="#topic+AvBasis.wst">AvBasis.wst</a></code>. In the future we hope to add methods for  <code><a href="#topic+wp">wp</a></code> and  <code><a href="#topic+wpst">wpst</a></code> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AvBasis(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AvBasis_+3A_...">...</code></td>
<td>
<p>See individual help pages for details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See individual method help pages for operation and examples. 
</p>


<h3>Value</h3>

<p>A vector containing the average of the representation over all bases. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6.0 Copyright Guy Nason 1995 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+AvBasis.wst">AvBasis.wst</a></code>
</p>

<hr>
<h2 id='AvBasis.wst'>Perform basis averaging for (packet-ordered) non-decimated wavelet transform.</h2><span id='topic+AvBasis.wst'></span>

<h3>Description</h3>

<p>Perform basis averaging for (packet-ordered) non-decimated wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
AvBasis(wst, Ccode=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AvBasis.wst_+3A_wst">wst</code></td>
<td>
<p>An object of class <code><a href="#topic+wst">wst</a></code> that contains coefficients of a packet ordered non-decimated wavelet transform (e.g. produced by the <code><a href="#topic+wst">wst</a></code> function.</p>
</td></tr>
<tr><td><code id="AvBasis.wst_+3A_ccode">Ccode</code></td>
<td>
<p>If TRUE then fast compiled C code is used to perform the transform. If FALSE then S code is used. Almost always use the default TRUE option. (It is conceivable that some implementation can not use the C code and so this option permits use of the slower S code).</p>
</td></tr>
<tr><td><code id="AvBasis.wst_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The packet-ordered non-decimated wavelet transform computed by <code><a href="#topic+wst">wst</a></code> computes the coefficients of an input vector with respect to a library of all shifts of wavelet basis functions at all scales. Here &quot;all shifts&quot; means all integral shifts with respect to the finest scale coefficients, and &quot;all scales&quot; means all dyadic scales from 0 (the coarsest) to J-1 (the finest) where <code>2^J = n</code> where <code>n</code> is the number of data points of the input vector. As such the packet-ordered non-decimated wavelet transform contains a library of all possible shifted wavelet bases.
</p>
<p><code>Basis selection</code> It is possible to select a particular basis and invert that particular representation. In WaveThresh a basis is selected by creating a <code>nv</code> (node.vector) class object which identifies the basis. Then the function <code><a href="#topic+InvBasis">InvBasis</a></code> takes the wavelet representation and the node.vector and inverts the representation with respect to the selected basis. The two functions <code><a href="#topic+MaNoVe">MaNoVe</a></code> and <code><a href="#topic+numtonv">numtonv</a></code> create a node.vector: the first by using a <code>Coifman-Wickerhauser</code> minimum entropy best-basis algorithm and the second by basis index. 
</p>
<p><b>Basis averaging</b>. Rather than select a basis it is often useful to preserve information from all of the bases. For examples, in curve estimation, after <a href="#topic+threshold">threshold</a>ing a wavelet representation the coefficients are coefficients of an estimate of the truth with respect to all of the shifted basis functions. Rather than select <em>one</em> of them we can average over all estimates. This sometimes gives a better curve estimate and can, for examples, get rid of Gibbs effects. See Coifman and Donoho (1995) for more information on how to do curve estimation using the packet ordered non-decimated wavelet transform, thresholding and basis averaging. 
</p>
<p>Further it might seem that inverting each wavelet transform and averaging might be a computationally expensive operation: since each wavelet inversion costs order <code class="reqn">n</code> operations and there are n different bases and so you might think that the overall order is <code class="reqn">n^2</code>.
It turns out that since many of the coarser scale basis functions are duplicated between bases there is redundancy in the non-decimated transform. Coifman and Donoho's TI-denoising algorithm makes use of this redundancy which results in an algorithm which only takes order <code class="reqn">n \log n</code> operations. 
</p>
<p>For an examples of denoising using the packet-ordered non-decimated wavelet transform and basis averaging see Johnstone and Silverman, 1997. The WaveThresh implementation of the basis averaging algorithm is to be found in Nason and Silverman, 1995 
</p>


<h3>Value</h3>

<p>A vector containing the average of the wavelet representation over all the basis functions. The length of the vector is <code>2^nlev</code> where <code>nlev</code> is the number of levels in the input <code>wst</code> object.
</p>


<h3>RELEASE</h3>

<p>Version 3.6.0 Copyright Guy Nason 1995</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+av.basis">av.basis</a></code>,
<code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+MaNoVe">MaNoVe</a></code>,  <code><a href="#topic+numtonv">numtonv</a></code>, <code><a href="#topic+InvBasis">InvBasis</a></code>, <code><a href="#topic+wavegrow">wavegrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y
#
# Now take the packet-ordered non-decimated wavelet transform
#
tdwst &lt;- wst(test.data)
#
# Now "invert" it using basis averaging
#
tdwstAB &lt;- AvBasis(tdwst)
#
# Let's compare it to the original
#
sum( (tdwstAB - test.data)^2)
#
# [1] 9.819351e-17 
#
# Very small. They're essentially same.
#
# See the threshold.wst help page for an
# an examples of using basis averaging in curve estimation.
</code></pre>

<hr>
<h2 id='AvBasis.wst2D'>Perform basis averaging for (packet-ordered) 2D non-decimated wavelet transform.</h2><span id='topic+AvBasis.wst2D'></span>

<h3>Description</h3>

<p>Perform basis averaging for (packet-ordered) 2D non-decimated wavelet transform. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst2D'
AvBasis(wst2D, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AvBasis.wst2D_+3A_wst2d">wst2D</code></td>
<td>
<p>An object of class <code><a href="#topic+wst2D">wst2D</a></code> that contains coefficients of a packet ordered 2D non-decimated wavelet transform (e.g. produced by the <code><a href="#topic+wst2D">wst2D</a></code> function.</p>
</td></tr>
<tr><td><code id="AvBasis.wst2D_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The packet-ordered 2D non-decimated wavelet transform computed by <code><a href="#topic+wst2D">wst2D</a></code> computes the coefficients of an input matrix with respect to a library of all shifts of wavelet basis functions at all scales. Here &quot;all shifts&quot; means all integral shifts with respect to the finest scale coefficients with shifts in both the horizontal and vertical directions, and &quot;all scales&quot; means all dyadic scales from 0 (the coarsest) to J-1 (the finest) where <code>2^J = n</code> where <code>n</code> is the dimension of the input matrix. As such the packet-ordered 2D non-decimated wavelet transform contains a library of all possible shifted wavelet bases.
</p>
<p><b>Basis averaging</b>. Rather than select <em>a</em> basis it is often useful to preserve information from all of the bases. For examples, in curve estimation, after thresholding, the coefficients are coefficients of an estimate of the truth with respect to all of the shifted basis functions. Rather than select one of them we can average over all estimates. This sometimes gives a better curve estimate and can, for examples, get rid of Gibbs effects. See Coifman and Donoho (1995) for more information on how to do curve estimation using the packet ordered non-decimated wavelet transform, thresholding and basis averaging. See Lang et al. (1995) for further details of surface/image estimation using the 2D non-decimated DWT. 
</p>


<h3>Value</h3>

<p>A square matrix of dimension $2^nlevelsWT$ containing the average-basis &ldquo;reconstruction&rdquo; of the <code><a href="#topic+wst2D">wst2D</a></code> object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst2D">wst2D</a></code>, <code><a href="#topic+wst2D.object">wst2D.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
#test.data &lt;- matrix(rnorm(16), 4,4)
#
# Now take the 2D packet ordered DWT 
#
#tdwst2D &lt;- wst2D(test.data)
#
# Now "invert" it using basis averaging
#
#tdwstAB &lt;- AvBasis(tdwst2D)
#
# Let's compare it to the original
#
#sum( (tdwstAB - test.data)^2)
#
# [1] 1.61215e-17
#
# Very small. They're essentially same.
#
</code></pre>

<hr>
<h2 id='BabyECG'>Physiological data time series.</h2><span id='topic+BabyECG'></span>

<h3>Description</h3>

<p>Two linked medical time series containing 2048 observations sampled every 16 seconds recorded from 21:17:59 to 06:27:18. Both these time series were recorded from the same 66 day old infant by Prof. Peter Fleming, Dr Andrew Sawczenko and Jeanine Young of the Institute of Child Health, Royal Hospital for Sick Children, Bristol. <code>BabyECG</code>, is a record of the infant's heart rate (in beats per minute). BabySS is a record of the infant's sleep state on a scale of 1 to 4 as determined by a trained expert monitoring EEG (brain) and EOG (eye-movement). The sleep state codes are 1=quiet sleep, 2=between quiet and active sleep, 3=active sleep, 4=awake.
</p>


<h3>Format</h3>

<p>The <code>BabyECG</code> time series is a nice examples of a non-stationary time series whose spectral (time-scale) properties vary over time. The function <code><a href="#topic+ewspec">ewspec</a></code> can be used to anaylse this time series to inspect the variation in the power of the series over time and scales. 
</p>
<p>The <code>BabySS</code> time series is a useful independent time series that can be associated with changing power in the <code>BabyECG</code> series. See the discussion in Nason, von Sachs and Kroisandt.
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>SEE ALSO</h3>

<p><code><a href="#topic+ewspec">ewspec</a></code></p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>Source</h3>

<p>Institute of Child Health, Royal Hospital for Sick Children, Bristol.</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (1998). Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum. <em>Technical Report</em>, Department of Mathematics University of Bristol/ Fachbereich Mathematik, Kaiserslautern. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BabyECG)
data(BabySS)
#
# Plot the BabyECG data with BabySS overlaid
#

# Note the following code does some clever scaling to get the two

# time series overlaid.

#

myhrs &lt;- c(22, 23, 24, 25, 26, 27, 28, 29, 30)

mylab &lt;- c("22", "23", "00", "01", "02", "03", "04", "05", "06")

initsecs &lt;- 59 + 60 * (17 + 60 * 21)

mysecs &lt;- (myhrs * 3600)

secsat &lt;- (mysecs - initsecs)/16

mxy &lt;- max(BabyECG)

mny &lt;- min(BabyECG)

ro &lt;- range(BabySS)

no &lt;- ((mxy - mny) * (BabySS - ro[1]))/(ro[2] - ro[1]) + mny

rc &lt;- 0:4

nc &lt;- ((mxy - mny) * (rc - ro[1]))/(ro[2] - ro[1]) + mny

## Not run: plot(1:length(BabyECG), BabyECG, xaxt = "n", type = "l", xlab = 
	"Time (hours)", ylab = "Heart rate (beats per minute)")
## End(Not run)

## Not run: lines(1:length(BabyECG), no, lty = 3)

## Not run: axis(1, at = secsat, labels = mylab)

## Not run: axis(4, at = nc, labels = as.character(rc))

#

# Sleep state is the right hand axis

#
#
</code></pre>

<hr>
<h2 id='BabySS'>Physiological data time series.</h2><span id='topic+BabySS'></span>

<h3>Description</h3>

<p>Two linked medical time series containing 2048 observations sampled every 16 seconds recorded from 21:17:59 to 06:27:18. Both these time series were recorded from the same 66 day old infant by Prof. Peter Fleming, Dr Andrew Sawczenko and Jeanine Young of the Institute of Child Health, Royal Hospital for Sick Children, Bristol. <code>BabyECG</code>, is a record of the infant's heart rate (in beats per minute). <code>BabySS</code> is a record of the infant's sleep state on a scale of 1 to 4 as determined by a trained expert monitoring EEG (brain) and EOG (eye-movement). The sleep state codes are 1=quiet sleep, 2=between quiet and active sleep, 3=active sleep, 4=awake.
</p>


<h3>Format</h3>

<p>The <code>BabyECG</code> time series is a nice examples of a non-stationary time series whose spectral (time-scale) properties vary over time. The function <code><a href="#topic+ewspec">ewspec</a></code> can be used to anaylse this time series to inspect the variation in the power of the series over time and scales. 
</p>
<p>The <code>BabySS</code> time series is a useful independent time series that can be associated with changing power in the <code>BabyECG</code> series. See the discussion in Nason, von Sachs and Kroisandt.
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>SEE ALSO</h3>

<p><code><a href="#topic+ewspec">ewspec</a></code>
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>Source</h3>

<p>Institute of Child Health, Royal Hospital for Sick Children, Bristol.</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (1998). Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum. <em>Technical Report</em>, Department of Mathematics University of Bristol/ Fachbereich Mathematik, Kaiserslautern. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BabyECG)
data(BabySS)
#

# Plot the BabyECG data with BabySS overlaid

#

# Note the following code does some clever scaling to get the two

# time series overlaid.

#

myhrs &lt;- c(22, 23, 24, 25, 26, 27, 28, 29, 30)

mylab &lt;- c("22", "23", "00", "01", "02", "03", "04", "05", "06")

initsecs &lt;- 59 + 60 * (17 + 60 * 21)

mysecs &lt;- (myhrs * 3600)

secsat &lt;- (mysecs - initsecs)/16

mxy &lt;- max(BabyECG)

mny &lt;- min(BabyECG)

ro &lt;- range(BabySS)

no &lt;- ((mxy - mny) * (BabySS - ro[1]))/(ro[2] - ro[1]) + mny

rc &lt;- 0:4

nc &lt;- ((mxy - mny) * (rc - ro[1]))/(ro[2] - ro[1]) + mny

## Not run: plot(1:length(BabyECG), BabyECG, xaxt = "n", type = "l", xlab = 
	"Time (hours)", ylab = "Heart rate (beats per minute)")
## End(Not run)

## Not run: lines(1:length(BabyECG), no, lty = 3)

## Not run: axis(1, at = secsat, labels = mylab)

## Not run: axis(4, at = nc, labels = as.character(rc))

#

# Sleep state is the right hand axis

#
#
</code></pre>

<hr>
<h2 id='basisplot'>Generic basis plot function</h2><span id='topic+basisplot'></span>

<h3>Description</h3>

<p>Plots a representation of a time-frequency plane and then plots the locations,
and sometimes time series representations of coefficients, for the packets
in the basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basisplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basisplot_+3A_x">x</code></td>
<td>
<p>basis to plot</p>
</td></tr>
<tr><td><code id="basisplot_+3A_...">...</code></td>
<td>
<p>various arguments to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing, usually
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisplot.BP">basisplot.BP</a></code>, <code><a href="#topic+basisplot.wp">basisplot.wp</a></code></p>

<hr>
<h2 id='basisplot.BP'>Plot time-frequency plane and basis slots associated with basis object</h2><span id='topic+basisplot.BP'></span>

<h3>Description</h3>

<p>The <code>x</code> objects store basis information obtained through the
<code><a href="#topic+makewpstDO">makewpstDO</a></code> object. This function plots where the basis packets
are on the time frequency plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BP'
basisplot(x, num=min(10, length(BP$level)), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basisplot.BP_+3A_x">x</code></td>
<td>
<p>The <code>BP</code> class object, possibly coming from the BP component
of the object returned by <code><a href="#topic+makewpstDO">makewpstDO</a></code> that you wish
to plot</p>
</td></tr>
<tr><td><code id="basisplot.BP_+3A_num">num</code></td>
<td>
<p>The number of packets that you wish to add to the plot</p>
</td></tr>
<tr><td><code id="basisplot.BP_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing of note
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+makewpstDO">makewpstDO</a></code>,<code><a href="#topic+Best1DCols">Best1DCols</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example in help for \code{\link{makewpstDO}}
#
</code></pre>

<hr>
<h2 id='basisplot.wp'>Function to graphically select a wavelet packet basis</h2><span id='topic+basisplot.wp'></span>

<h3>Description</h3>

<p>Note, one or two (depending on the state of <code>draw.mode</code>) graphics
windows with mouse-clickable interfaces have to open to use this function.
</p>
<p>Graphically select a wavelet packet basis associated with a 
wavelet packet object. Left-click selects packets, right click
exits the routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
basisplot(x, draw.mode=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basisplot.wp_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+wp.object">wp.object</a></code> for which you wish to select
a basis graphically for.</p>
</td></tr>
<tr><td><code id="basisplot.wp_+3A_draw.mode">draw.mode</code></td>
<td>
<p>If TRUE then TWO graphics windows have to be open.
Every time a packet is selected in the packet selection window,
a representation of the wavelet packet basis function is drawn
in the other window</p>
</td></tr>
<tr><td><code id="basisplot.wp_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wavelet packet basis described in WaveThresh using the node vector
object (class from <code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code>) which for wavelet packets
is <code>nvwp</code>. This function takes a <code><a href="#topic+wp.object">wp.object</a></code> object
and graphically depicts all possible basis function locations. The user
is then invited to click on different packets, these change colour.
When finished, the user right clicks on the graphic and the selected
basis is returned.
</p>
<p><em>Note that the routine does not check to see whether the basis is
legal. You have to do this.</em> A legal basis can select packets from
different levels, however you can't select packets that both cover the
same packet index, however every packet index has to be covered.
</p>
<p>A better function <em>would</em> check basis legality!
</p>


<h3>Value</h3>

<p>An object of class <code>nvwp</code> which contains the specification
for the basis. 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+addpkt">addpkt</a></code>, <code><a href="#topic+InvBasis">InvBasis</a></code>, <code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code>, <code><a href="#topic+plotpkt">plotpkt</a></code>,
<code><a href="#topic+wp">wp</a></code></p>

<hr>
<h2 id='BAYES.THR'>Bayesian wavelet thresholding.</h2><span id='topic+BAYES.THR'></span>

<h3>Description</h3>

<p>This function carries out Bayesian wavelet thresholding of noisy data, using the BayesThresh method of Abramovich, Sapatinas, &amp; Silverman (1998). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BAYES.THR(data, alpha = 0.5, beta = 1, filter.number = 8, family =
"DaubLeAsymm", bc = "periodic", dev = var, j0 = 5, plotfn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BAYES.THR_+3A_data">data</code></td>
<td>
<p>A vector of length a power of two, containing noisy data to be thresholded.</p>
</td></tr>
<tr><td><code id="BAYES.THR_+3A_alpha">alpha</code>, <code id="BAYES.THR_+3A_beta">beta</code></td>
<td>
<p>Hyperparameters which determine the priors placed on the wavelet coefficients. Both alpha and beta take positive values; see Abramovich, Sapatinas, &amp; Silverman (1998) or Chipman &amp; Wolfson (1999) for more details on selecting <code>alpha</code> and <code>beta</code>.</p>
</td></tr>
<tr><td><code id="BAYES.THR_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments. 
</p>
<p>For the &ldquo;wavelets on the interval&rdquo; (<code>bc="interval"</code>) transform the filter number ranges from 1 to 8. See the table of filter coefficients indexed after the reference to Cohen, Daubechies and Vial, (1993).</p>
</td></tr>
<tr><td><code id="BAYES.THR_+3A_family">family</code></td>
<td>
<p>Specifies the family of wavelets that you want to use. Two popular options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot; but see the help for <a href="#topic+filter.select">filter.select</a> for more possibilities. 
</p>
<p>This argument is ignored for the &ldquo;wavelets on the interval&rdquo; transform (<code>bc="interval"</code>).</p>
</td></tr>
<tr><td><code id="BAYES.THR_+3A_bc">bc</code></td>
<td>
<p>Specifies the boundary handling. If <code>bc="periodic"</code> the default, then the function you decompose is assumed to be periodic on it's interval of definition, if <code>bc="symmetric"</code> then the function beyond its boundaries is assumed to be a symmetric reflection of the function in the boundary. The symmetric option was the implicit default in releases prior to 2.2. If<code>bc=="interval"</code> then the &ldquo;wavelets on the interval algorithm&rdquo; due to Cohen, Daubechies and Vial is used. (The <code>WaveThresh</code> implementation of the &ldquo;wavelets on the interval transform&rdquo; was coded by Piotr Fryzlewicz, Department of Mathematics, Wroclaw University of Technology, Poland; this code was largely based on code written by Markus Monnerjahn, RHRK, Universitat Kaiserslautern; integration into <code>WaveThresh</code> by <code>GPN</code>).</p>
</td></tr> 
<tr><td><code id="BAYES.THR_+3A_dev">dev</code></td>
<td>
<p>This argument supplies the function to be used to compute the spread of the absolute values coefficients. The function supplied must return a value of spread on the variance scale (i.e. not standard deviation) such as the <code>var()</code> function. A popular, useful and robust alternative is the <code>madmad</code> function.</p>
</td></tr> 
<tr><td><code id="BAYES.THR_+3A_j0">j0</code></td>
<td>
<p>The primary resolution level. While BayesThresh thresholds at all resolution levels, j0 is used in assessing the universal threshold which is used in the empirical Bayes estimation of hyperparameters.</p>
</td></tr>
<tr><td><code id="BAYES.THR_+3A_plotfn">plotfn</code></td>
<td>
<p>If TRUE, BAYES.THR draws the noisy data and the thresholded function estimate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A mixture prior consisting of a zero-mean normal distribution and a point mass at zero is placed on each wavelet coefficient. The empirical coefficients are then calculated and the priors updated to give posterior distributions for each coefficient. The thresholded value of each coefficient is the median of that coefficient's posterior distribution. See Abramovich, Sapatinas, &amp; Silverman (1998) for more details of the procedure; the help page for <code><a href="#topic+threshold.wd">threshold.wd</a></code> has more information about wavelet thresholding in general. 
</p>
<p>The function <code>wave.band</code> uses the same priors to compute posterior credible intervals for the regression function, using the method described by Barber, Nason, &amp; Silverman (2001). 
</p>


<h3>Value</h3>

<p>A vector containing the thresholded estimate of the function from which the data was drawn. 
</p>


<h3>RELEASE</h3>

<p>3.9.5
Code by Fanis Sapatinas/Felix Abramovich
Documentation by Stuart Barber 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+threshold.wd">threshold.wd</a></code>, <code><a href="#topic+wd">wd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some noisy test data and plot it.
#
blocks.data &lt;- DJ.EX(n=512, noisy=TRUE)$blocks
#
# Now try BAYES.THR with the default parameters.
#
blocks.thr &lt;- BAYES.THR(blocks.data, plotfn=TRUE)
#
# The default wavelet is Daubechies' least asymmetric wavelet 
# with 8 vanishing moments; quite a smooth wavelet. Since the 
# flat sections are still rather noisy, try Haar wavelets:
# 
blocks.thr &lt;- BAYES.THR(blocks.data, plotfn=TRUE, filter.number=1,
        family = "DaubExPhase") 
#
# To show the importance of a sensible prior, consider alpha = 4, 
# beta = 1 (which implies a smoother prior than the default). 
#
blocks.thr &lt;- BAYES.THR(blocks.data, plotfn=TRUE, filter.number=1,
        family = "DaubExPhase", alpha=4, beta=1)
#
# Here, the extreme values of the function are being smoothed towards zero.
#
</code></pre>

<hr>
<h2 id='Best1DCols'>Extract the best (one-dimensional) nondecimated WP packets</h2><span id='topic+Best1DCols'></span>

<h3>Description</h3>

<p>This function takes the whole set of nondecimated wavelet packets and
selects those packets that correlate best with the &quot;response&quot; groups.
The idea is to reduce the large dimensionality (number of packets) into
something more manageable which can then be fed into a proper discriminator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Best1DCols(w2d, mincor=    0.69999999999999996)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Best1DCols_+3A_w2d">w2d</code></td>
<td>
<p>An object that gets returned from a call to the
<code><a href="#topic+wpst2discr">wpst2discr</a></code> function which turns a wpst class
object into a regular multivariate matrix</p>
</td></tr>
<tr><td><code id="Best1DCols_+3A_mincor">mincor</code></td>
<td>
<p>The threshold above which variables (packets) 
get included into the
final mix if their correlation with the groups variable
is higher than this value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not intended for direct user use.
In this function, the w2d object contains a matrix where each
column contains the coefficients of a single packet from a
non-decimated wavelet packet transform. The number of rows of the
matrix is the same as the original time series and hence each
column can be correlated with a separate groups variable that
contains the group membership of a separate variable which changes
over time. Those packet columns that have correlation greater
than the <code>mincor</code> value are extracted and returned
in the <code>BasisMatrix</code> item of the returned list. 
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of levels of the nondecimated wavelet packet
encapsulator, w2d</p>
</td></tr>
<tr><td><code>BasisMatrix</code></td>
<td>
<p>The highest correlating packets, sorted according to
decreasing correlation</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>The levels corresponding to the selected packets</p>
</td></tr>
<tr><td><code>pkt</code></td>
<td>
<p>The packet indices corresponding to the selected packets</p>
</td></tr>
<tr><td><code>basiscoef</code></td>
<td>
<p>The sorted correlations</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>The groups time series</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+makewpstDO">makewpstDO</a></code>,<code><a href="#topic+wpst2discr">wpst2discr</a></code></p>

<hr>
<h2 id='bestm'>
Function called by makewpstRO to identify which packets are individually
good for correlating with a response
</h2><span id='topic+bestm'></span>

<h3>Description</h3>

<p>This function is used when you have a huge number of packets where you
want to identify which ones are, individually, candidates for the good
prediction of a response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestm(w2mobj, y, percentage = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bestm_+3A_w2mobj">w2mobj</code></td>
<td>

<p>The w2m object that contains the packets you wish to preselect
</p>
</td></tr>
<tr><td><code id="bestm_+3A_y">y</code></td>
<td>

<p>The response time series
</p>
</td></tr>
<tr><td><code id="bestm_+3A_percentage">percentage</code></td>
<td>

<p>The percentage of the w2m packets that you wish to select
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function naively addresses a very common problem. The object
w2mobj contains a huge number of variables which might shed some light
on the response object <code>y</code>. The problem is that the dimensionality
of <code>w2mobj</code> is larger than that of the length of the series <code>y</code>.
</p>
<p>The solution here is to choose a large, but not huge, subset of the variables
that might be potentially useful in correlating with <code>y</code>, discard the
rest, and return the &quot;best&quot; or preselected variables. Then the dimensionality
is reduced and more sophisticated methods can be used to perform better
quality modelling of the response <code>y</code> on the packets in <code>w2mobj</code>.
</p>


<h3>Value</h3>

<p>A list of class w2m with the following components:
</p>
<table role = "presentation">
<tr><td><code>m</code></td>
<td>
<p>A matrix containing the select packets (as columns), reordered
so that the best packets come first</p>
</td></tr>
<tr><td><code>ixvec</code></td>
<td>
<p>A vector which indexes the best packets into the original
supplied matrix</p>
</td></tr>
<tr><td><code>pktix</code></td>
<td>
<p>The original wavelet packet indices corresponding to each packet</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>As <code>pktix</code> but for the wavelet packet levels</p>
</td></tr>
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of resolution levels in the original wavelet
packet object</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>The ordered correlations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> G P Nason </p>


<h3>See Also</h3>

<p><code><a href="#topic+makewpstRO">makewpstRO</a></code></p>

<hr>
<h2 id='BMdiscr'>Subsidiary routine for makewpstDO function</h2><span id='topic+BMdiscr'></span>

<h3>Description</h3>

<p>Function actually performs discrimination on reduced variable set supplied to
it from <code><a href="#topic+Best1DCols">Best1DCols</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BMdiscr(BP)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BMdiscr_+3A_bp">BP</code></td>
<td>
<p>An list of the same format as returned by <code><a href="#topic+Best1DCols">Best1DCols</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not intended for direct user use
</p>


<h3>Value</h3>

<p>Returns a list of objects: essentially the input argument <code>BP</code>
and the return value from a call to the <code>lda</code> function which
performs the discrimination operation.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+Best1DCols">Best1DCols</a></code>,<code><a href="#topic+makewpstDO">makewpstDO</a></code></p>

<hr>
<h2 id='c2to4'>Take integer, represent in binary, then think of and return that
representation in base 4</h2><span id='topic+c2to4'></span>

<h3>Description</h3>

<p>Not designed, or really useful, for casual user use!
</p>
<p>For example: take the integer 5. In binary this is 101. Then, this
representation in base 4 is 16+1 =17.
</p>
<p>This function is used by <code><a href="#topic+accessD.wpst">accessD.wpst</a></code> to help it access
coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2to4(index)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c2to4_+3A_index">index</code></td>
<td>
<p>The integer you wish to convert</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>The converted number
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessD.wpst">accessD.wpst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>c2to4(5)
</code></pre>

<hr>
<h2 id='CanUseMoreThanOneColor'>Deprecated  function</h2><span id='topic+CanUseMoreThanOneColor'></span>

<h3>Description</h3>

<p>Not used any more. This function used to interrogate the display device
to see whether more than one color could be used. The function is set
to return true whether of not the display device actually has this capability.
It is used in the <code><a href="#topic+plot.wp">plot.wp</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CanUseMoreThanOneColor()
</code></pre>


<h3>Details</h3>

<p>Description says it all.
</p>


<h3>Value</h3>

<p>This function always returns TRUE
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.wp">plot.wp</a></code></p>

<hr>
<h2 id='checkmyews'>Check a LSW spectrum through repeated simulation and empirical averages</h2><span id='topic+checkmyews'></span>

<h3>Description</h3>

<p>Given a LSW spectrum this function simulates <code>nsim</code> realizations,
estimates the spectrum, and then averages the results. The large
sample averages should converge to the original spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkmyews(spec, nsim=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkmyews_+3A_spec">spec</code></td>
<td>
<p>The LSW spectrum</p>
</td></tr>
<tr><td><code id="checkmyews_+3A_nsim">nsim</code></td>
<td>
<p>The number of realizations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A LSW spectrum obtained as the average of <code>nsim</code> simulations
from the <code>spec</code> spectrum.</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+cns">cns</a></code>,<code><a href="#topic+LSWsim">LSWsim</a></code>, <code><a href="#topic+ewspec">ewspec</a></code></p>

<hr>
<h2 id='Chires5'>Subsid routine for denproj (calcs scaling function coefs without cov)</h2><span id='topic+Chires5'></span>

<h3>Description</h3>

<p>A subsidiary routine for <code><a href="#topic+denproj">denproj</a></code>. Not intended for direct
user use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Chires5(x, tau=1, J, filter.number=10, family="DaubLeAsymm", nT=20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Chires5_+3A_x">x</code></td>
<td>
<p>The data (random sample for density estimation)</p>
</td></tr>
<tr><td><code id="Chires5_+3A_tau">tau</code></td>
<td>
<p>Fine tuning parameter</p>
</td></tr>
<tr><td><code id="Chires5_+3A_j">J</code></td>
<td>
<p>Resolution level</p>
</td></tr>
<tr><td><code id="Chires5_+3A_filter.number">filter.number</code></td>
<td>
<p>The smoothness of the wavelet, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="Chires5_+3A_family">family</code></td>
<td>
<p>The family of the wavelet, see <code><a href="stats.html#topic+family">family</a></code></p>
</td></tr>
<tr><td><code id="Chires5_+3A_nt">nT</code></td>
<td>
<p>The number of iterations in the Daubechies-Lagarias algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As description
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>The scaling function coefficients</p>
</td></tr>
<tr><td><code>klim</code></td>
<td>
<p>The integer translates of the scaling functions used</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The primary resolution, calculated in code as tau*2^J</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>The usual filter information, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The length of the data <code>x</code></p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>A list containing components: <code>p</code>, as above, <code>tau</code>
as input and <code>J</code> as above. This summarizes the resolution
information</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Herrick</p>


<h3>See Also</h3>

<p><code><a href="#topic+Chires6">Chires6</a></code>,<code><a href="#topic+denproj">denproj</a></code></p>

<hr>
<h2 id='Chires6'>Subsid routine for denproj (calcs scaling function coefs with cov)</h2><span id='topic+Chires6'></span>

<h3>Description</h3>

<p>Function is essentially the same as <code><a href="#topic+Chires5">Chires5</a></code>
but also returns covariances between coefficients.
A subsidiary routine for <code><a href="#topic+denproj">denproj</a></code>. Not intended for direct
user use. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Chires6(x, tau=1, J, filter.number=10, family="DaubLeAsymm", nT=20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Chires6_+3A_x">x</code></td>
<td>
<p>The data (random sample for density estimation)</p>
</td></tr>
<tr><td><code id="Chires6_+3A_tau">tau</code></td>
<td>
<p>Fine tuning parameter</p>
</td></tr>
<tr><td><code id="Chires6_+3A_j">J</code></td>
<td>
<p>Resolution level</p>
</td></tr>
<tr><td><code id="Chires6_+3A_filter.number">filter.number</code></td>
<td>
<p>The smoothness of the wavelet, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="Chires6_+3A_family">family</code></td>
<td>
<p>The family of the wavelet, see <code><a href="stats.html#topic+family">family</a></code></p>
</td></tr>
<tr><td><code id="Chires6_+3A_nt">nT</code></td>
<td>
<p>The number of iterations in the Daubechies-Lagarias algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As description
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>The scaling function coefficients</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>The coefficients' covariance matrix</p>
</td></tr>
<tr><td><code>klim</code></td>
<td>
<p>The integer translates of the scaling functions used</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The primary resolution, calculated in code as tau*2^J</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>The usual filter information, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The length of the data <code>x</code></p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>A list containing components: <code>p</code>, as above, <code>tau</code>
as input and <code>J</code> as above. This summarizes the resolution
information</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Herrick</p>


<h3>See Also</h3>

<p><code><a href="#topic+Chires6">Chires6</a></code>,<code><a href="#topic+denproj">denproj</a></code></p>

<hr>
<h2 id='cns'>Create new zeroed spectrum.</h2><span id='topic+cns'></span>

<h3>Description</h3>

<p>Part of a two-stage function suite designed to simulate locally stationary wavelet processes in conjunction with the LSWsim function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cns(n, filter.number=1, family="DaubExPhase")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cns_+3A_n">n</code></td>
<td>
<p>The length of the simulated process that you want to produce. Must be a power of two (for this software).</p>
</td></tr>
<tr><td><code id="cns_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments. </p>
</td></tr>
<tr><td><code id="cns_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simple routine merely computes the time-ordered non-decimated wavelet transform of a zero vector of the same length as the eventual simulated series that you wish to produce. 
</p>
<p>If you look at this routine you will see that it is extremely simple. First, it checks to see whether the n that you supplied is a power of two. If it is then it creates a zero vector of that length. This is then non-decimated wavelet transformed with the appropriate wavelet. 
</p>
<p>The output can then be processed and then finally supplied to LSWsim for process simulation.
</p>


<h3>Value</h3>

<p>An object of class: <code><a href="#topic+wd">wd</a></code>, and, in fact, of the non-decimated variety. All wavelet coefficients of this are zero.  
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+LSWsim">LSWsim</a></code>, <code><a href="#topic+ewspec">ewspec</a></code> 
</p>

<hr>
<h2 id='compare.filters'>Compares two filters. </h2><span id='topic+compare.filters'></span>

<h3>Description</h3>

<p>Compares two filters (such as those returned from <code><a href="#topic+filter.select">filter.select</a></code>). This function returns TRUE is they are the same otherwise returns FALSE. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.filters(f1,f2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare.filters_+3A_f1">f1</code></td>
<td>
<p>Filter, such as that returned by <code><a href="#topic+filter.select">filter.select</a></code> </p>
</td></tr>
<tr><td><code id="compare.filters_+3A_f2">f2</code></td>
<td>
<p>Filter, such as that returned by <code><a href="#topic+filter.select">filter.select</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A very simple function. It only needs to check that the <code>family</code> and <code>filter.number</code> components of the filter are the same. 
</p>


<h3>Value</h3>

<p>If <code>f1</code> and <code>f2</code> are the same the function returns TRUE, otherwise it returns FALSE. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.select">filter.select</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Create three filters!
#
filt1 &lt;- filter.select(4, family="DaubExPhase")
filt2 &lt;- filter.select(3, family="DaubExPhase")
filt3 &lt;- filter.select(4, family="DaubLeAsymm")
#
# Now let us see if they are the same...
#
compare.filters(filt1, filt2)
# [1] FALSE
compare.filters(filt1, filt3)
# [1] FALSE
compare.filters(filt2, filt3)
# [1] FALSE
#
# Nope, (what a surprise) they weren't. How about
#
compare.filters(filt1, filt1)
# [1] TRUE
#
# Yes, they were the same!
</code></pre>

<hr>
<h2 id='compgrot'>Compute empirical shift for time ordered non-decimated transforms.</h2><span id='topic+compgrot'></span>

<h3>Description</h3>

<p>Computes the empirical shift required for time-ordered non-decimated transform coefficients to bring them into time order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compgrot(J, filter.number, family)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compgrot_+3A_j">J</code></td>
<td>
<p>The <code>number of levels</code> in the non-decimated transform where coefficients are to be time-aligned.</p>
</td></tr>
<tr><td><code id="compgrot_+3A_filter.number">filter.number</code></td>
<td>
<p>The wavelet filter number to be used, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="compgrot_+3A_family">family</code></td>
<td>
<p>The wavelet family, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time-ordered non-decimated transform coefficients when raw are not in exact time alignment due to the phase of the underlying wavelet. This function returns the shifts that are necessary to apply to each resolution level in the transform to bring back each set of time-ordered coefficients into time alignment. Note that the shifts returned are approximate shifts which work for any Daubechies wavelet. More accurate shifts can be computed using detailed knowledge of the particular wavelet used. 
</p>
<p>Each shift is &quot;to the left&quot;. I.e. higher indexed coefficients should take the place of lower-indexed coefficients. Periodic boundaries are assumed. 
</p>
<p>This realignment is mentioned in Walden and Contreras Cristan, (1997) and Nason, Sapatinas and Sawczenko, (1998). 
</p>


<h3>Value</h3>

<p>A vector containing the shifts that need to be applied to each scale level to return them to the correct time alignment.
</p>
<p>There are <code>J</code> entries in the vector. The first entry corresponds to the shift required for the finest level coefficients (i.e. level <code>J-1</code>) and the last entry corresponds to the coarsest level (i.e. level 0). Entry <code>j</code> corresponds to the shift required for scale level <code>J-j</code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1997 </p>


<h3>Note</h3>

<p>GROT was the shop started by Reginald Perrin. Unfortunately, GROT stands for &quot;Guy ROTation&quot;. </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+wpst">wpst</a></code>, <code>wpst.object</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's see how the resolution levels have to be shifted 
#
compgrot(4, filter.number=10, family="DaubExPhase")
#[1]  2  6 15 31
#
# In other words. Scale level 3 needs to be shifted two units.
# Scale level 2 needs to be shifted 6 units
# Scale level 1 needs to be shifted 15 units
# Scale level 0 needs to be shifted 31 units.
</code></pre>

<hr>
<h2 id='compress'>Compress objects</h2><span id='topic+compress'></span>

<h3>Description</h3>

<p>Compress objects.
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist. For the <code><a href="#topic+imwd">imwd</a></code> class object this generic function uses <code><a href="#topic+compress.imwd">compress.imwd</a></code>. There is a default compression method: <code><a href="#topic+compress.default">compress.default</a></code> that works on vectors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compress(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compress_+3A_...">...</code></td>
<td>
<p>See individual help pages for details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See individual method help pages for operation and examples
</p>


<h3>Value</h3>

<p>A compressed version of the input. 
</p>


<h3>RELEASE</h3>

<p>Version 2.0 Copyright Guy Nason 1993</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+compress.default">compress.default</a></code>, <code><a href="#topic+compress.imwd">compress.imwd</a></code>, <code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+imwdc.object">imwdc.object</a></code>, <code><a href="#topic+threshold.imwd">threshold.imwd</a></code> 
</p>

<hr>
<h2 id='compress.default'>Do &quot;zero&quot; run-length encoding compression of a vector of numbers. </h2><span id='topic+compress.default'></span>

<h3>Description</h3>

<p>Efficiently compress a vector containing many zeroes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
compress(v, verbose=FALSE,...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compress.default_+3A_v">v</code></td>
<td>
<p>The vector that you wish to compress. This compression function is efficient at compressing vectors with many zeroes, but is not a <em>general</em> compression routine.</p>
</td></tr>
<tr><td><code id="compress.default_+3A_verbose">verbose</code></td>
<td>
<p>If<code>TRUE</code> then this routine prints out the degree of compression achieved. </p>
</td></tr>
<tr><td><code id="compress.default_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Images are large objects. Thresholded 2d wavelet objects (<code><a href="#topic+imwd">imwd</a></code>) are also large, but many of their elements are zero. compress.default takes a vector, decides whether compression is necessary and if it is makes an object of class <code>compressed</code> containing the nonzero elements and their position in the original vector. 
</p>
<p>The decision whether to compress the vector or not depends on two things, first the number of non-zero elements in the vector (r, say), and second the length of the vector (n, say). Since the position and value of the non-zero elements is stored we will need to store 2r values for the non-zero elements. So compression takes place if <code>2r &lt; n</code>. 
</p>
<p>This function is the default method for the generic function <code><a href="#topic+compress">compress</a></code>. It can be invoked by calling compress for an object of the appropriate class, or directly by calling compress.default regardless of the class of the object. 
</p>


<h3>Value</h3>

<p>An object of class compressed if <code>compression</code> took place, otherwise a an object of class <code>uncompressed</code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Note</h3>

<p>Sometimes the compressed object can be larger than the original. This usually only happens for small objects, so it doesn't really matter. 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+compress">compress</a></code>,  <code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+threshold.imwd">threshold.imwd</a></code>,
<code><a href="#topic+uncompress">uncompress</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Compress a vector with lots of zeroes
#
compress(c(rep(0,100),99))
#$position:
#[1] 101
#
#$values:
#[1] 99
#
#$original.length:
#[1] 101
#
#attr(, "class"):
#[1] "compressed"
#
# Try to compress a vector with not many zeroes
#
compress(1:10)
#$vector:
#[1]  1 2  3  4  5  6  7  8  9 10
#
#attr(, "class"):
#[1] "uncompressed"
#
#
</code></pre>

<hr>
<h2 id='compress.imwd'>Compress a (thresholded) imwd class object by removing zeroes. </h2><span id='topic+compress.imwd'></span>

<h3>Description</h3>

<p>Compress a (thresholded) <code>imwd</code> class object by removing zeroes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwd'
compress(x, verbose=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compress.imwd_+3A_x">x</code></td>
<td>
<p>Object to compress. Compression only does anything on <code>thresholded</code> <code><a href="#topic+imwd.object">imwd.object</a></code>. </p>
</td></tr>
<tr><td><code id="compress.imwd_+3A_verbose">verbose</code></td>
<td>
<p>If this is true then report on compression activity.</p>
</td></tr>
<tr><td><code id="compress.imwd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Thresholded <code><a href="#topic+imwd">imwd</a></code> objects are usually very large and contain many zero elements. This function compresses these objects into smaller <code><a href="#topic+imwd">imwd</a></code> objects by using the <code><a href="#topic+compress.default">compress.default</a></code> function which removing the zeroes. This function is a method for the generic function <code><a href="#topic+compress">compress</a></code> for class <code><a href="#topic+imwd">imwd</a></code> objects. It can be invoked by calling <code><a href="#topic+compress">compress</a></code> for an object of the appropriate class, or directly by calling <code><a href="#topic+compress.imwd">compress.imwd</a></code> regardless of the class of the object
</p>


<h3>Value</h3>

<p>An object of type &quot;<code>imwdc</code>&quot; representing the compressed imwd object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+compress">compress</a></code>, <code><a href="#topic+compress.default">compress.default</a></code>, <code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+imwdc.object">imwdc.object</a></code>, <code><a href="#topic+threshold.imwd">threshold.imwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The user shouldn't need to use this function directly as the
# \code{\link{threshold.imwd}} function calls it
# automatically.
#
</code></pre>

<hr>
<h2 id='conbar'>Performs inverse DWT reconstruction step</h2><span id='topic+conbar'></span>

<h3>Description</h3>

<p>Wrapper to the C function <code>conbar</code> which is the main function
in WaveThresh to do filter convolution/reconstruction with data.
Although users use the <code><a href="#topic+wr">wr</a></code> function to perform a complete
inverse discrete wavelet transform (DWT) this function repeatedly uses
the <code>conbar</code> routine, once for each level to reconstruct the next finest
level. The C <code>conbar</code> routine is possibly the most frequently utilized
by WaveThresh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conbar(c.in, d.in, filter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conbar_+3A_c.in">c.in</code></td>
<td>
<p>The father wavelet coefficients that you wish to reconstruct in this level's convolution.</p>
</td></tr>
<tr><td><code id="conbar_+3A_d.in">d.in</code></td>
<td>
<p>The mother wavelet coefficients that you wish to reconstruct in this level's convolution.</p>
</td></tr>
<tr><td><code id="conbar_+3A_filter">filter</code></td>
<td>
<p>A given filter that you wish to use in the level reconstruction. This should be the output from the <code><a href="#topic+filter.select">filter.select</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+wr">wr</a></code> function performs the inverse wavelet transform on an
<code><a href="#topic+wd.object">wd.object</a></code> class object.
</p>
<p>Internally, the <code><a href="#topic+wr">wr</a></code> function uses the C <code>conbar</code> function.
Other functions also make use of <code>conbar</code> and some R functions also would
benefit from using the fast C code of the <code>conbar</code> reconstruction hence
this WaveThresh function.
Some of the other functions that use conbar are listed in the SEE ALSO section.
Many other functions call C code that then uses the C version of <code>conbar</code>.
</p>


<h3>Value</h3>

<p>A vector containing the reconstructed coefficients.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+av.basis">av.basis</a></code>
<code><a href="#topic+InvBasis.wp">InvBasis.wp</a></code>
<code><a href="#topic+wr">wr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's generate some test data, just some 32 normal variates.
#
v &lt;- rnorm(32)
#
# Now take the wavelet transform with default filter arguments (which
# are filter.number=10, family="DaubLeAsymm")
#
vwd &lt;- wd(v)
#
# Now, let's take an arbitrary level, say 2, and reconstruct level 3
# scaling function coefficients
#
c.in &lt;- accessC(vwd, lev=2)
d.in &lt;- accessD(vwd, lev=2)
#
conbar(c.in, d.in, filter.select(filter.number=10, family="DaubLeAsymm"))
#[1] -0.50368115  0.04738620 -0.90331807  1.08497622  0.90490528  0.06252717
#[7]  2.55894899 -1.26067508
#
# Ok, this was the pure reconstruction from using only level 2 information.
#
# Let's check this against the "original" level 3 coefficients (which get
# stored on the decomposition step in wd)
#
accessC(vwd, lev=3)
#[1] -0.50368115  0.04738620 -0.90331807  1.08497622  0.90490528  0.06252717
#[7]  2.55894899 -1.26067508
#
# Yep, the same numbers!
#
</code></pre>

<hr>
<h2 id='convert'>Convert one type of wavelet object into another. </h2><span id='topic+convert'></span>

<h3>Description</h3>

<p>Convert one type of wavelet object into another. 
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist: 
</p>
<p><code><a href="#topic+convert.wd">convert.wd</a></code> is used to convert non-decimated <code><a href="#topic+wd">wd</a></code> objects into <code><a href="#topic+wst">wst</a></code> objects. 
<code><a href="#topic+convert.wst">convert.wst</a></code> is used to convert <code><a href="#topic+wst">wst</a></code> objects into non-decimated <code><a href="#topic+wd">wd</a></code> objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_+3A_...">...</code></td>
<td>
<p>See individual help pages for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See individual method help pages for operation and examples. 
</p>


<h3>Value</h3>

<p>An object containing the converted representation. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6.0 Copyright Guy Nason 1995 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+convert.wd">convert.wd</a></code>, <code><a href="#topic+convert.wst">convert.wst</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>. 
</p>

<hr>
<h2 id='convert.wd'>Convert a non-decimated wd object into a wst object. </h2><span id='topic+convert.wd'></span>

<h3>Description</h3>

<p>Convert a time-ordered non-decimated wavelet transform object into a packet-ordered non-decimated wavelet transform object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
convert(wd, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.wd_+3A_wd">wd</code></td>
<td>
<p>The <code><a href="#topic+wd">wd</a></code> class object that you wish to convert.</p>
</td></tr>
<tr><td><code id="convert.wd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In WaveThresh3 a non-decimated wavelet transform can be ordered in two different ways: as a time-ordered or packet-ordered representation. The coefficients in the two objects are <em>exactly the same</em> it is just their internal representation and ordering which is different. The two different representations are useful in different situations. The packet-ordering is useful for curve estimation applications and the time-ordering is useful for time series applications. 
</p>
<p>See Nason, Sapatinas and Sawczenko, 1998 for further details on ordering and weaving. 
</p>
<p>Note that the input object must be of the non-decimated type. In other words the type component of the input object must BE &quot;<code>station</code>&quot;. 
Once the input object has been converted the output can be used with any of the functions suitable for the <code><a href="#topic+wst.object">wst.object</a></code>. 
</p>
<p>The <code><a href="#topic+getarrvec">getarrvec</a></code> function actually computes the permutation to weave coefficients from one ordering to another. 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wst">wst</a></code> containing exactly the same information as the input object but ordered differently as a packet-ordered object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+convert">convert</a></code>, <code><a href="#topic+getarrvec">getarrvec</a></code>, <code><a href="#topic+levarr">levarr</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate a sequence of 32 random normals (say) and take their
# \code{time-ordered non-decimated wavelet transform}
#
myrand &lt;- wd(rnorm(32), type="station")
#
# Print out the result (to verify the class and type of the object)
#
#myrand
#Class 'wd' : Discrete Wavelet Transform Object:
#       ~~  : List with 8 components with names
#              C D nlevelsWT fl.dbase filter type bc date 
#
#$ C and $ D are LONG coefficient vectors !
#
#Created on : Tue Sep 29 12:17:53 1998 
#Type of decomposition:  station 
#
#summary(.):
#----------
#Levels:  5 
#Length of original:  32 
#Filter was:  Daub cmpct on least asymm N=10 
#Boundary handling:  periodic 
#Transform type:  station 
#Date:  Tue Sep 29 12:17:53 1998 
#
# Yep, the myrand object is of class: \code{\link{wd.object}}.
#
# Now let's convert it to class \code{\link{wst}}. The object
# gets returned and, as usual in S, is printed.
#
convert(myrand)
#Class 'wst' : Stationary Wavelet Transform Object:
#       ~~~  : List with 5 components with names
#              wp Carray nlevelsWT filter date 
#
#$wp and $Carray are the coefficient matrices
#
#Created on : Tue Sep 29 12:17:53 1998 
#
#summary(.):
#----------
#Levels:  5 
#Length of original:  32 
#Filter was:  Daub cmpct on least asymm N=10 
#Date:  Tue Sep 29 12:17:53 1998 
#
# Yes. The returned object is of class \code{\link{wst.object}}.
# I.e. it has been converted successfully.
</code></pre>

<hr>
<h2 id='convert.wst'>Convert a non-decimated wst object into a wd object. </h2><span id='topic+convert.wst'></span>

<h3>Description</h3>

<p>Convert a packed-ordered non-decimated wavelet transform object into a time-ordered non-decimated wavelet transform object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
convert(wst, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.wst_+3A_wst">wst</code></td>
<td>
<p>The <code><a href="#topic+wst">wst</a></code> class object that you wish to convert.</p>
</td></tr>
<tr><td><code id="convert.wst_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In WaveThresh3 a non-decimated wavelet transform can be ordered in two different ways: as a time-ordered or packet-ordered representation. The coefficients in the two objects are <em>exactly the same</em> it is just their internal representation and ordering which is different. The two different representations are useful in different situations. The packet-ordering is useful for curve estimation applications and the time-ordering is useful for time series applications. 
</p>
<p>See Nason, Sapatinas and Sawczenko, 1998 for further details on ordering and weaving. 
</p>
<p>Note that the input object must be of the non-decimated type. In other words the type component of the input object must be &quot;<code>station</code>&quot;. 
Once the input object has been converted the output can be used with any of the functions suitable for the <code><a href="#topic+wd.object">wd.object</a></code>.
</p>
<p>The actual weaving permutation for shuffling coefficients from one representation to another is achieved by the <code><a href="#topic+getarrvec">getarrvec</a></code> function.  
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wd">wd</a></code> containing exactly the same information as the input object but ordered differently as a packet-ordered object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+convert">convert</a></code>, <code><a href="#topic+getarrvec">getarrvec</a></code>, <code><a href="#topic+levarr">levarr</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate a sequence of 32 random normals (say) and take their
# \code{packed-ordered non-decimated wavelet transform}
#
myrand &lt;- wst(rnorm(32))
#
# Print out the result (to verify the class and type of the object)
#
#myrand
#Class 'wst' : Stationary Wavelet Transform Object:
#       ~~~  : List with 8 components with names
#              wp Carray nlevelsWT filter date 
#
#$WP and $Carray are the coefficient matrices

#
#Created on : Tue Sep 29 12:29:45 1998 
#
#summary(.):
#----------
#Levels:  5 
#Length of original:  32 
#Filter was:  Daub cmpct on least asymm N=10 
#Boundary handling:  periodic 

#Date:  Tue Sep 29 12:29:45 1998 
#
# Yep, the myrand object is of class: \code{\link{wst.object}}.
#
# Now let's convert it to class \code{\link{wd}}. The object
# gets returned and, as usual in S, is printed.
#
convert(myrand)
#Class 'wd' : Discrete Wavelet Transform Object:
#       ~~  : List with 8 components with names
#              C D nlevelsWT fl.dbase filter type bc date 
#
#$ C and $ D are LONG coefficient vectors !
#
#Created on : Tue Sep 29 12:29:45 1998 
#Type of decomposition:  station 
#
#summary(.):
#----------
#Levels:  5 
#Length of original:  32 
#Filter was:  Daub cmpct on least asymm N=10 
#Boundary handling:  periodic 
#Transform type:  station 
#Date:  Tue Sep 29 12:29:45 1998 
#
# The returned object is of class \code{\link{wd}} with a
# type of "station".
# I.e. it has been converted successfully.
</code></pre>

<hr>
<h2 id='ConvertMessage'>Print out a text message about an object which is from old version of WaveThresh</h2><span id='topic+ConvertMessage'></span>

<h3>Description</h3>

<p>Print out text message about an object being from an old version of WaveThresh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvertMessage()</code></pre>


<h3>Arguments</h3>

<p>None</p>


<h3>Details</h3>

<p>Description says all!
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+IsEarly.default">IsEarly.default</a></code>,<code><a href="#topic+IsEarly">IsEarly</a></code></p>

<hr>
<h2 id='Crsswav'>Wrapper to C code version of rsswav</h2><span id='topic+Crsswav'></span>

<h3>Description</h3>

<p>Crsswav is called by <code><a href="#topic+WaveletCV">WaveletCV</a></code> which is itself
called by <code><a href="#topic+threshold.wd">threshold.wd</a></code> to carry out its cross-validation
policy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Crsswav(noisy, value = 1, filter.number = 10, family = "DaubLeAsymm",
    thresh.type = "hard", ll = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Crsswav_+3A_noisy">noisy</code></td>
<td>
<p>A vector of dyadic (power of two) length that contains the noisy data that you wish to compute the averaged RSS for.</p>
</td></tr>
<tr><td><code id="Crsswav_+3A_value">value</code></td>
<td>
<p>The specified threshold.</p>
</td></tr>
<tr><td><code id="Crsswav_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to perform wavelet shrinkage by cross-validation.</p>
</td></tr>
<tr><td><code id="Crsswav_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="Crsswav_+3A_thresh.type">thresh.type</code></td>
<td>
<p>this option specifies the thresholding type which can be &quot;hard&quot; or &quot;soft&quot;.</p>
</td></tr>
<tr><td><code id="Crsswav_+3A_ll">ll</code></td>
<td>
<p>The primary resolution that you wish to assume. No wavelet coefficients that are on coarser scales than ll will be thresholded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Same value as for <code><a href="#topic+rsswav">rsswav</a></code>
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsswav">rsswav</a></code>, <code><a href="#topic+WaveletCV">WaveletCV</a></code></p>

<hr>
<h2 id='cthresh'>Estimate real signal using complex-valued wavelets </h2><span id='topic+cthresh'></span>

<h3>Description</h3>

<p>Implements the multiwavelet style and empirical Bayes shrinkage procedures described in Barber &amp; Nason (2004) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cthresh(data, j0 = 3, dwwt, dev = madmad, rule = "hard", 
    filter.number = 3.1, family = "LinaMayrand", plotfn = FALSE,  
    TI = FALSE, details = FALSE, policy = "mws", code = "NAG", tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cthresh_+3A_data">data</code></td>
<td>
<p>The data to be analysed. This should be real-valued and of length a power of two.</p>
</td></tr>
<tr><td><code id="cthresh_+3A_j0">j0</code></td>
<td>
<p>Primary resolution level; no thresholding is done below this level.</p>
</td></tr>
<tr><td><code id="cthresh_+3A_dwwt">dwwt</code></td>
<td>
<p>description to come</p>
</td></tr>
<tr><td><code id="cthresh_+3A_dev">dev</code></td>
<td>
<p>A function to be used to estimate the noise level of the data. The function supplied must return a value of spread on the variance scale (i.e. not standard deviation) such as the var() function. A popular, useful and robust alternative is the madmad function.</p>
</td></tr>
<tr><td><code id="cthresh_+3A_rule">rule</code></td>
<td>
<p>The type of thresholding done. If policy = &quot;mws&quot;, available rules are &quot;hard&quot; or &quot;soft&quot;; if policy = &quot;ebayes&quot;, then rule can be &quot;hard&quot;, &quot;soft&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="cthresh_+3A_filter.number">filter.number</code>, <code id="cthresh_+3A_family">family</code></td>
<td>
<p>These parameters specify the wavelet used. See <code><a href="#topic+filter.select">filter.select</a></code> for details. 
</p>
<p>Also, if filter.number = 5, estimation is done with all the complex-valued wavelets with 5 vanishing moments and the results averaged. If filter.number = 0, then he averaging is over all available complex-valued wavelets.</p>
</td></tr>
<tr><td><code id="cthresh_+3A_plotfn">plotfn</code></td>
<td>
<p>If <code>plotfn = true</code>, then a plot of the noisy data and estimated signal are produced.</p>
</td></tr>
<tr><td><code id="cthresh_+3A_ti">TI</code></td>
<td>
<p>If TI = T, then the non-decimated transform is used. See the help pages for wd and wst for more on the non-decimated transform.</p>
</td></tr>
<tr><td><code id="cthresh_+3A_details">details</code></td>
<td>
<p>If <code>details = FALSE</code> (the default), only the estimate of the underlying signal is returned. If <code>details = TRUE</code>, many other details are also returned.</p>
</td></tr>
<tr><td><code id="cthresh_+3A_policy">policy</code></td>
<td>
<p>Controls the type of thresholding done. Available policies are multiwavelet style (policy = &quot;mws&quot;) and empirical Bayes (policy = &quot;ebayes&quot;).</p>
</td></tr>
<tr><td><code id="cthresh_+3A_code">code</code></td>
<td>
<p>Tells cthresh whether external C or NAG code is available to help with the calculations.</p>
</td></tr>
<tr><td><code id="cthresh_+3A_tol">tol</code></td>
<td>
<p>A tolerance parameter used in searching for prior parameters if the empirical Bayes policy is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a real-valued signal is decomposed using a complex-valued wavelet (like the Lina-Mayrand wavelets supplied by filter.select), then the wavelet coefficients are also complex-valued. Wavelet shrinkage can still be used to estimate the signal, by asking the question &quot;which coefficients are small (and represent noise) and which are large (and represent signal)?&quot; Two methods of determining which coefficients are small and which are large are proposed by Barber &amp; Nason (2004). One is &quot;multiwavelet style&quot; thresholding (similar to that in Downie &amp; Silverman (1998) where the coefficients are treated like the coefficients of a multiwavelet). Here, the &quot;size&quot; of the wavelet coefficient is determined as modulus of a standardised version of the coefficient. The standardisation is by the square root of the covariance matrix of the coefficient. A Bayesian method is to place a mixture prior on each coefficient. The prior has two components: a bivariate normal and a point mass at (0,0). The parameters are determined by an empirical Bayes argument and then the prior is updated by the data. 
</p>


<h3>Value</h3>

<p>Either a vector containing the estimated signal (if details = FALSE), or a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The original data as supplied to cthresh.</p>
</td></tr>
<tr><td><code>data.wd</code></td>
<td>
<p>The wavelet decomposition of the data.</p>
</td></tr>
<tr><td><code>thr.wd</code></td>
<td>
<p>The thresholded version of data.wd.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimate of the underlying signal.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>The covariance matrices induced by the wavelet transform. See <code>make.dwwt</code> for more details.</p>
</td></tr>
<tr><td><code>sigsq</code></td>
<td>
<p>The estimate of the variance of the noise which corrupted the data.</p>
</td></tr>
<tr><td><code>rule</code></td>
<td>
<p>Which thresholding rule was used</p>
</td></tr> 
<tr><td><code>EBpars</code></td>
<td>
<p>The empirical Bayes parameters found by the function find.parameters. Only present if the &quot;ebayes&quot; policy was used.</p>
</td></tr>
<tr><td><code>wavelet</code></td>
<td>
<p>A list with components filter.number and family which, when supplied to <code>link{filter.select}</code>, determine the wavelet used to decompose the data.</p>
</td></tr></table>


<h3>RELEASE</h3>

<p>Part of the CThresh addon to WaveThresh. Copyright Stuart Barber and Guy Nason 2004.</p>


<h3>Note</h3>

<p>The estimates returned by cthresh have an imaginary component. In practice, this component is usually negligible. 
</p>


<h3>Author(s)</h3>

<p>Stuart Barber</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+find.parameters">find.parameters</a></code>, <code><a href="#topic+make.dwwt">make.dwwt</a></code>, <code><a href="#topic+test.dataCT">test.dataCT</a></code>, and the undocumented functions in CThresh. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Make up some noisy data
#
y &lt;- example.1()$y
ynoise &lt;- y + rnorm(512, sd=0.1)
#
# Do complex-valued wavelet shrinkage with decimated wavelets
#
est1 &lt;- cthresh(ynoise, TI=FALSE)
#
# Do complex-valued wavelet shrinkage with nondecimated wavelets
#
est2 &lt;- cthresh(ynoise, TI=TRUE)
#
#
#
plot(1:512, y, lty=2, type="l")
lines(1:512, est1, col=2)
lines(1:512, est2, col=3)
</code></pre>

<hr>
<h2 id='Cthreshold'>Calls C code to threshold wd class object.</h2><span id='topic+Cthreshold'></span>

<h3>Description</h3>

<p>A routine that calls a C code function to do thresholding. This is really a test routine to call a C thresholding function (Cthreshold) and the user is advised to use the R based generic thresholding function
<code><a href="#topic+threshold">threshold</a></code> and/or its methods as they contain a wider range of thresholding options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cthreshold(wd, thresh.type = "soft", value = 0, levels = 3:(nlevelsWT(wd) - 1)) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cthreshold_+3A_wd">wd</code></td>
<td>
<p>The wavelet object that you wish to threshold.</p>
</td></tr>
<tr><td><code id="Cthreshold_+3A_thresh.type">thresh.type</code></td>
<td>
<p>The type of thresholding. This can be &quot;soft&quot; or &quot;hard&quot;. See <code><a href="#topic+threshold">threshold</a></code> and methods for further details.</p>
</td></tr>
<tr><td><code id="Cthreshold_+3A_value">value</code></td>
<td>
<p>The threshold value that you want to be used (e.g. for hard thresholding wavelet coefficients whose absolute value is less than</p>
</td></tr>
<tr><td><code id="Cthreshold_+3A_levels">levels</code></td>
<td>
<p>The resolution levels that you wish to compute the threshold on and apply the threshold to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For general use it is recommended to use the
<code><a href="#topic+threshold">threshold</a></code> functions as they have a wider variety of options
and also work for more complex varieties of wavelet transforms
(i.e. non-decimated, complex-valued, etc).
However, in the right, limited, situation this function can be useful.
This function directly calls the C thresholding function Cthreshold().
The C function is used by routines that operate on behalf of the function
that carries out two-fold cross validation in C (<code><a href="#topic+CWCV">CWCV</a></code>) which
is also accessible using the <code>policy="cv"</code> option too
<code><a href="#topic+threshold.wd">threshold.wd</a></code>
</p>
<p>This function can be used by the user. It might be a bit faster than
<code><a href="#topic+threshold.wd">threshold.wd</a></code> but mostly because it is simpler and does less checking than
<code><a href="#topic+threshold.wd">threshold.wd</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+wd.object">wd.object</a></code> class object, but containing thresholded coefficients.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+threshold">threshold</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See copious examples in the help to threshold.wd
#
</code></pre>

<hr>
<h2 id='CWavDE'>Simple wavelet density estimator with hard thresholding</h2><span id='topic+CWavDE'></span>

<h3>Description</h3>

<p>This function implements the density estimator with hard thresholding
described by Hall, P. and Patil, P. (1995) Formulae for mean integrated squared
error of nonlinear wavelet-based density estimators,
<em>Ann. Statist.</em>, <b>23</b>, 905-928.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CWavDE(x, Jmax, threshold=0, nout=100, primary.resolution=1, filter.number=10,
	family="DaubLeAsymm", verbose=0, SF=NULL, WV=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CWavDE_+3A_x">x</code></td>
<td>
<p>Vector of real numbers. This is the data for which you want
a density estimate for</p>
</td></tr>
<tr><td><code id="CWavDE_+3A_jmax">Jmax</code></td>
<td>
<p>The maximum resolution of wavelets</p>
</td></tr>
<tr><td><code id="CWavDE_+3A_threshold">threshold</code></td>
<td>
<p>The hard threshold value for the wavelet coefficients</p>
</td></tr>
<tr><td><code id="CWavDE_+3A_nout">nout</code></td>
<td>
<p>The number of ordinates in the density estimate</p>
</td></tr>
<tr><td><code id="CWavDE_+3A_primary.resolution">primary.resolution</code></td>
<td>
<p>The usual wavelet density estimator primary
resolution</p>
</td></tr>
<tr><td><code id="CWavDE_+3A_filter.number">filter.number</code></td>
<td>
<p>The wavelet filter number, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="CWavDE_+3A_family">family</code></td>
<td>
<p>The wavelet family, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="CWavDE_+3A_verbose">verbose</code></td>
<td>
<p>The level of reporting performed by the function, legit
values are 0, 1 or 2, with 2 being more reports</p>
</td></tr>
<tr><td><code id="CWavDE_+3A_sf">SF</code></td>
<td>
<p>Scaling function values in format as returned by
<code><a href="#topic+draw.default">draw.default</a></code></p>
</td></tr>
<tr><td><code id="CWavDE_+3A_wv">WV</code></td>
<td>
<p>Wavelet function values in format as returned by
<code><a href="#topic+draw.default">draw.default</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the description.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>A vector of length <code>nout</code> that covers the range of the
input data <code>x</code>, plus some more depending on the
support of the wavelet and the primary resolution.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A vector of length <code>nout</code> that contains the output
wavelet density estimate</p>
</td></tr>
<tr><td><code>sfix</code></td>
<td>
<p>The integer values of the translates of the scaling functions
used in the estimate</p>
</td></tr>
<tr><td><code>wvixmin</code></td>
<td>
<p>As for sfix, but a vector of length <code>Jmax</code> which
contains the minimum integer wavelet translates</p>
</td></tr>
<tr><td><code>wvixmax</code></td>
<td>
<p>As for wvixmin, but with the maxima</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's generate a bi-modal artificial set of data.
#
x &lt;- c( rnorm(100), rnorm(100, 10))
#
# Now perform simple wavelet density estimate
#
wde &lt;- CWavDE(x, Jmax=10, threshold=1)
#
# Plot results
#
## Not run: plot(wde$x, wde$y, type="l")
</code></pre>

<hr>
<h2 id='CWCV'>C Wavelet Cross-validation</h2><span id='topic+CWCV'></span>

<h3>Description</h3>

<p>Two-fold wavelet shrinkage cross-validation (in C) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CWCV(ynoise, ll, x = 1:length(ynoise), filter.number = 10, family = 
	"DaubLeAsymm", thresh.type = "soft", tol = 0.01,
	maxits=500, verbose = 0, 
	plot.it = TRUE, interptype = "noise")

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CWCV_+3A_ynoise">ynoise</code></td>
<td>
<p>A vector of dyadic (power of two) length that contains the noisy data that you wish to apply wavelet shrinkage by cross-validation to.</p>
</td></tr>
<tr><td><code id="CWCV_+3A_ll">ll</code></td>
<td>
<p>The primary resolution that you wish to assume. No wavelet coefficients that are on coarser scales than ll will be thresholded.</p>
</td></tr>
<tr><td><code id="CWCV_+3A_x">x</code></td>
<td>
<p>This function is capable of producing informative plots. It can be useful to supply the x values corresponding to the ynoise values. Further this argument is returned by this function which can be useful for later processors.</p>
</td></tr>
<tr><td><code id="CWCV_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to perform wavelet shrinkage by cross-validation.</p>
</td></tr>
<tr><td><code id="CWCV_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="CWCV_+3A_thresh.type">thresh.type</code></td>
<td>
<p>this option specifies the thresholding type which can be &quot;hard&quot; or &quot;soft&quot;.</p>
</td></tr>
<tr><td><code id="CWCV_+3A_tol">tol</code></td>
<td>
<p>this specifies the convergence tolerance for the cross-validation optimization routine (a golden section search).</p>
</td></tr>
<tr><td><code id="CWCV_+3A_maxits">maxits</code></td>
<td>
<p>maximum number of iterations for the cross-validation optimization routine (a golden section search).</p>
</td></tr>
<tr><td><code id="CWCV_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the computations progress. Such messages are generally annoying so it is turned off by default</p>
</td></tr>
<tr><td><code id="CWCV_+3A_plot.it">plot.it</code></td>
<td>
<p>If this is TRUE then plots of the universal threshold (used to obtain an upper bound on the cross-validation threshold) reconstruction and the resulting cross-validation estimate are produced.</p>
</td></tr>
<tr><td><code id="CWCV_+3A_interptype">interptype</code></td>
<td>
<p>Can take two values noise or normal. This option controls how cross-validation compares the estimate formed by leaving out the data with the &quot;left-out&quot; data. If interptype=&quot;noise&quot; then two noisy values are averaged to compare with the estimated curve in between, otherwise if interptype=&quot;normal&quot; then the curve estimate is averaged either side of a noisy left-out point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the two-fold cross-validated wavelet shrunk estimate given the noisy data ynoise according to the description given in Nason, 1996. 
</p>
<p>You must specify a primary resolution given by <code>ll</code>. This must be specified individually on each data set and can itself be estimated using cross-validation (although I haven't written the code to do this). 
</p>
<p><b>Note</b>. The two-fold cross-validation method performs very badly if the input data is correlated. In this case I would advise using the methods proposed in Donoho and Johnstone, 1995 or Johnstone and Silverman, 1997 which can be carried out in WaveThresh using the <code><a href="#topic+threshold">threshold</a></code> function using the <code>policy="sure"</code> option. 
</p>


<h3>Value</h3>

<p>A list with the following components 
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>This is just the x that was input. It gets passed through more or less for convenience for the user.</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>A copy of the input ynoise noisy data.</p>
</td></tr>
<tr><td><code>xvwr</code></td>
<td>
<p>The cross-validated wavelet shrunk estimate.</p>
</td></tr>
<tr><td><code>yuvtwr</code></td>
<td>
<p>The universal thresholded version (note this is merely a starting point for the cross-validation algorithm. It should not be ta    ken seriously as an estimate. In particular its estimate of variance is likely to be inflated.) </p>
</td></tr>
<tr><td><code>xvthresh</code></td>
<td>
<p>The cross-validated threshold</p>
</td></tr>
<tr><td><code>xvdof</code></td>
<td>
<p>The number of non-zero coefficients in the cross-validated shrunk wavelet object (which is not returned).</p>
</td></tr>
<tr><td><code>uvdof</code></td>
<td>
<p>The number of non-zero coefficients in the universal threshold shrunk wavelet object (which also is not returned)</p>
</td></tr>
<tr><td><code>xkeep</code></td>
<td>
<p>always returns NULL!</p>
</td></tr>
<tr><td><code>fkeep</code></td>
<td>
<p>always returns NULL!</p>
</td></tr>
</table>


<h3>RELEASE</h3>

<p>Version 3.0 Copyright Guy Nason 1994 </p>


<h3>Note</h3>

<p>Plots of the universal and cross-validated shrunk estimates might be plotted if <code>plot.it=TRUE.</code></p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+threshold">threshold</a></code>. <code><a href="#topic+threshold.wd">threshold.wd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# This function is best used via the policy="cv" option in
# the threshold.wd function.
# See examples there.
#
</code></pre>

<hr>
<h2 id='dclaw'>Claw distribution</h2><span id='topic+dclaw'></span><span id='topic+rclaw'></span><span id='topic+pclaw'></span>

<h3>Description</h3>

<p>Random generation, density and cumulative probability for the claw distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rclaw(n)
dclaw(x)
pclaw(q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dclaw_+3A_n">n</code></td>
<td>
<p>Number of draws from <code>rclaw</code> distribution</p>
</td></tr>
<tr><td><code id="dclaw_+3A_x">x</code></td>
<td>
<p>Vector of ordinates</p>
</td></tr>
<tr><td><code id="dclaw_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The claw distribution is a normal mixture distribution, introduced in Marron &amp; Wand (1992).
Marron, J.S. &amp; Wand, M.P. (1992). Exact Mean Integrated Squared Error.
<em>Ann. Stat.</em>, <b>20</b>, 712&ndash;736.
</p>


<h3>Value</h3>

<p>Random samples (rclaw), density (dclaw) or probability (pclaw)
of the claw distribution.
</p>


<h3>Author(s)</h3>

<p>David Herrick</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the claw density on the interval [-3,3]
x &lt;- seq(from=-3, to=3, length=500)
## Not run: plot(x, dclaw(x), type="l")
</code></pre>

<hr>
<h2 id='dencvwd'>
Calculate variances of wavlet coefficients of a p.d.f.
</h2><span id='topic+dencvwd'></span>

<h3>Description</h3>

<p>Calculates the variances of the empirical wavelet coefficients by performing a 2D wavelet decomposition on the covariance matrix of the empirical scaling function coefficients of the probability density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dencvwd(hrproj, filter.number=hrproj$filter$filter.number,
    family=hrproj$filter$family, type="wavelet", bc="zero",
    firstk=hrproj$klim, RetFather=TRUE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dencvwd_+3A_hrproj">hrproj</code></td>
<td>
<p>Output from <code><a href="#topic+denproj">denproj</a></code> with <code>covar=T</code> argument.</p>
</td></tr>
<tr><td><code id="dencvwd_+3A_filter.number">filter.number</code></td>
<td>
<p>The filter number of the wavelet basis to be used.
This argument should not be altered from the default, as it is tied
to the <code>hrproj</code> argument</p>
</td></tr>
<tr><td><code id="dencvwd_+3A_family">family</code></td>
<td>
<p>The family of wavelets to use.
This argument should not be altered.</p>
</td></tr>
<tr><td><code id="dencvwd_+3A_type">type</code></td>
<td>
<p>The type of decomposition to be performed. This argument should not be altered.</p>
</td></tr>
<tr><td><code id="dencvwd_+3A_bc">bc</code></td>
<td>
<p>The type of boundary conditions to be used.
For density estimation this should always be zero.</p>
</td></tr>
<tr><td><code id="dencvwd_+3A_firstk">firstk</code></td>
<td>
<p>The bounds on the translation index of the empirical scaling function coefficients.</p>
</td></tr>
<tr><td><code id="dencvwd_+3A_retfather">RetFather</code></td>
<td>
<p>Ignore this.</p>
</td></tr>
<tr><td><code id="dencvwd_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE the function will be chatty. Note that comments are only availble for part of the algorithm, so might not be very enlightening.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is basically <code><a href="#topic+imwd">imwd</a></code> adapted to handle zero
boundary conditions, except that only the variances are returned,
i.e. the diagonals of the covariance matrices produced.
Note that this code is not very efficient.
The full covariance matrices of all levels of coefficients are calculated,
and then the diagonals are extracted.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wd.object">wd.object</a></code>, but the contents are not a
standard wavelet transform, ie the object is used to hold other information
which organisationally is arranged like a wavelet tranform, ie variances of
coefficients. 
</p>


<h3>Author(s)</h3>

<p>David Herrick</p>


<h3>See Also</h3>

<p><code><a href="#topic+denproj">denproj</a></code>,<code><a href="#topic+imwd">imwd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data from the claw density, find the 
# empirical scaling function coefficients and covariances and then decompose
# both to give wavelet coefficients and their variances.

data &lt;- rclaw(100)
datahr &lt;- denproj(data, J=8, filter.number=2,family="DaubExPhase", covar=TRUE)
data.wd &lt;- denwd(datahr)
## Not run: plotdenwd(data.wd, top.level=(datahr$res$J-1))

datavar &lt;- dencvwd(datahr)
## Not run: plotdenwd(datavar, top.level=(datahr$res$J-1)) 
</code></pre>

<hr>
<h2 id='denplot'>Calculate plotting information for a density estimate.</h2><span id='topic+denplot'></span>

<h3>Description</h3>

<p>Calculates plotting information for a wavelet density estimate from high level
scaling function coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denplot(wr, coef, nT=20, lims, n=50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denplot_+3A_wr">wr</code></td>
<td>
<p>Scaling function coefficients, usually at some high level and
usually smoothed (thresholded).</p>
</td></tr>
<tr><td><code id="denplot_+3A_coef">coef</code></td>
<td>
<p>The output from <code><a href="#topic+denproj">denproj</a></code> for this analysis,
i.e. the object containing the empirical scaling function coefficients.
This is required because of the information it contains about the wavelet
filter used, the resolution of the projection,
and the bounds on the translation index of the scaling function coefficients.</p>
</td></tr>
<tr><td><code id="denplot_+3A_lims">lims</code></td>
<td>
<p>Vector containing the minimum and maximum x values required on the
plot.</p>
</td></tr>
<tr><td><code id="denplot_+3A_nt">nT</code></td>
<td>
<p>The number of iterations to be performed in the
Daubechies-Lagarias algorithm,
which is used to evaluate the scaling functions of the specified
wavelet basis at the plotting points.</p>
</td></tr>
<tr><td><code id="denplot_+3A_n">n</code></td>
<td>
<p>The number of points at which the density estimate is to be evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density estimate is evaluated at <code>n</code> points between the values
in <code>lims</code>. This function can be used to plot the empirical
scaling function density estimate by entering
<code>wr=coef$coef</code>, but since the empirical coefficients are usually found
at some very high resolution,
such a plot will be very noisy and not very informative.
This function will be of much more use as and when
thresholding function are included in this density estimation package.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The points at which the density estimate is evaluated.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The values of the density estimate at the points in <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Herrick</p>


<h3>See Also</h3>

<p><code><a href="#topic+denproj">denproj</a></code>,<code><a href="#topic+rclaw">rclaw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data from the claw density and find the 
# empirical scaling function coefficients at a lowish resolution and plot
# the resulting density estimate
data &lt;- rclaw(100)
datahr &lt;- denproj(data, J=3, filter.number=2,family="DaubExPhase")
datapl &lt;- denplot(datahr$coef, datahr, lims=c(-3,3), n=1000)
## Not run: plot(datapl, type="l")
</code></pre>

<hr>
<h2 id='denproj'>Calculate empirical scaling function coefficients of a p.d.f.</h2><span id='topic+denproj'></span>

<h3>Description</h3>

<p>Calculates empirical scaling function coefficients of the probability
density function from sample of data from that density,
usually at some &quot;high&quot; resoloution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denproj(x, tau=1, J, filter.number=10, family="DaubLeAsymm", covar=FALSE, nT=20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denproj_+3A_x">x</code></td>
<td>
<p>Vector containing the data. This can be of any length.</p>
</td></tr>
<tr><td><code id="denproj_+3A_j">J</code></td>
<td>
<p>The resolution level at which the empirical scaling function
coefficients are to be calculated.</p>
</td></tr>
<tr><td><code id="denproj_+3A_tau">tau</code></td>
<td>
<p>This parameter allows non-dyadic resolutions to be used,
since the resolution is specified as <code>tau * 2J</code>.</p>
</td></tr>
<tr><td><code id="denproj_+3A_filter.number">filter.number</code></td>
<td>
<p>The filter number of the wavelet basis to be used.</p>
</td></tr>
<tr><td><code id="denproj_+3A_family">family</code></td>
<td>
<p>The family of wavelets to use, can be &quot;DaubExPhase&quot; or
&quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="denproj_+3A_covar">covar</code></td>
<td>
<p>Logical variable. If TRUE then covariances of the empirical
scaling function coefficients are also calculated.</p>
</td></tr>
<tr><td><code id="denproj_+3A_nt">nT</code></td>
<td>
<p>The number of iterations to be performed in the
Daubechies-Lagarias algorithm,
which is used to evaluate the scaling functions of the specified wavelet basis at the data points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This projection of data onto a high resolution wavelet space is described in
detail in Chapter 3 of Herrick (2000).
The maximum and minimum values of <code>k</code> for which the empirical scaling
function coefficient is non-zero are determined and
the coefficients calculated for all k between these limits as
<code>sum(phiJk(xi))/n</code>.
The scaling functions are evaluated at the data points efficiently,
using the Daubechies-Lagarias algorithm (Daubechies &amp; Lagarias (1992)).
Coded kindly by Brani Vidakovic.
</p>
<p>Herrick, D.R.M. (2000) Wavelet Methods for Curve and Surface Estimation. PhD Thesis, University of Bristol.
</p>
<p>Daubechies, I. &amp; Lagarias, J.C. (1992). Two-Scale Difference Equations II. Local Regularity, Infinite Products of Matrices and Fractals. SIAM Journal on Mathematical Analysis, 24(4), 1031&ndash;1079.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>A vector containing the empirical scaling function coefficients. This starts with the first non-zero coefficient, ends with the last non-zero coefficient and contains all coefficients, including zeros, in between.</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>Matrix containing the covariances, if requested.</p>
</td></tr>
<tr><td><code>klim</code></td>
<td>
<p>The maximum and minimum values of k for which the empirical
scaling function coefficients cJk are non-zero.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The primary resolution <code>tau * 2J</code>.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>A list containing the filter.number and family specified inthe function call.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The length of the data vector x.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>A list containing the values of <code>p</code>, <code>tau</code> and <code>J</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Herrick</p>


<h3>See Also</h3>

<p><code><a href="#topic+Chires5">Chires5</a></code>, <code><a href="#topic+Chires6">Chires6</a></code>, <code><a href="#topic+denwd">denwd</a></code>,
<code><a href="#topic+denwr">denwr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data from the claw density and find the 
# empirical scaling function coefficients
data &lt;- rclaw(100)
datahr &lt;- denproj(data, J=8, filter.number=4,family="DaubLeAsymm")
</code></pre>

<hr>
<h2 id='denwd'>Wavelet decomposition of empirical scaling function coefficients of a p.d.f.  </h2><span id='topic+denwd'></span>

<h3>Description</h3>

<p>Performs wavelet decomposition on the empirical scaling function coefficients of the probability density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denwd(coef)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denwd_+3A_coef">coef</code></td>
<td>
<p>Output from <code><a href="#topic+denproj">denproj</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The empirical scaling function coefficients are decomposed using the DWT with zero boundary conditions.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wd.object">wd.object</a></code>
</p>


<h3>Author(s)</h3>

<p>David Herrick</p>


<h3>See Also</h3>

<p><code><a href="#topic+denproj">denproj</a></code>,<code><a href="#topic+plotdenwd">plotdenwd</a></code>,<code><a href="#topic+wd">wd</a></code>,
<code><a href="#topic+denwr">denwr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data from the claw density, find the empirical
# scaling function coefficients, decompose them and plot
# the resulting wavelet coefficients
 
data &lt;- rclaw(100)
datahr &lt;- denproj(data, J=8, filter.number=2,family="DaubExPhase")
data.wd &lt;- denwd(datahr)
## Not run: plotdenwd(data.wd, top.level=(datahr$res$J-1))
</code></pre>

<hr>
<h2 id='denwr'>Wavelet reconstruction for density estimation.  </h2><span id='topic+denwr'></span>

<h3>Description</h3>

<p>Performs wavelet reconstruction for density estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denwr(wd, start.level=0, verbose=FALSE, bc=wd$bc,
    return.object=FALSE, filter.number=wd$filter$filter.number,
    family=wd$filter$family)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denwr_+3A_wd">wd</code></td>
<td>
<p>Wavelet decomposition object to reconstruct</p>
</td></tr>
<tr><td><code id="denwr_+3A_start.level">start.level</code></td>
<td>
<p>The level you wish to start the reconstruction at.
This is usually the first level (level 0).
Note that this option assumes the coarsest level is labelled 0,
so it is best to think of this argument as
&quot;the number of levels up from the coarsest level to start the
reconstruction&quot;.</p>
</td></tr>
<tr><td><code id="denwr_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the
computations progress. Such messages are generally annoying
so it is turned off by default.</p>
</td></tr>
<tr><td><code id="denwr_+3A_bc">bc</code></td>
<td>
<p>The boundary conditions used. These should be determined by those
used to create the supplied <code><a href="#topic+wd.object">wd.object</a></code> object.
In the case of density estimation they are &quot;zero&quot;.</p>
</td></tr>
<tr><td><code id="denwr_+3A_filter.number">filter.number</code></td>
<td>
<p>The filter number of the wavelet used to do the
reconstruction. Again, as for bc, you should probably leave this argument alone.</p>
</td></tr>
<tr><td><code id="denwr_+3A_family">family</code></td>
<td>
<p>The type of wavelet used to do the reconstruction. You can change this argument from the default but it is probably NOT wise.</p>
</td></tr>
<tr><td><code id="denwr_+3A_return.object">return.object</code></td>
<td>
<p>If this is FALSE then the top level of the reconstruction
is returned (this is the reconstructed function at the highest
resolution). Otherwise, if it is TRUE, the whole wd
reconstructed object is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the same as <code><a href="#topic+wr.wd">wr.wd</a></code>,
except that it can handle zero boundary conditions.
</p>


<h3>Value</h3>

<p>Either a vector containing the top level reconstruction or an object of
class <code><a href="#topic+wd.object">wd.object</a></code> containing the results of the reconstruction.
</p>


<h3>Author(s)</h3>

<p>David Herrick</p>

<hr>
<h2 id='DJ.EX'>Produce Donoho and Johnstone test functions</h2><span id='topic+DJ.EX'></span>

<h3>Description</h3>

<p>Function to produce the blocks, bumps, Doppler and heavisine functions described by Donoho and Johnstone (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DJ.EX(n=1024, signal=7, rsnr=7, noisy=FALSE, plotfn=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DJ.EX_+3A_n">n</code></td>
<td>
<p>Number of samples of the function required.</p>
</td></tr>
<tr><td><code id="DJ.EX_+3A_signal">signal</code></td>
<td>
<p>A factor that multiples the function values.</p>
</td></tr>
<tr><td><code id="DJ.EX_+3A_rsnr">rsnr</code></td>
<td>
<p>If Gaussian noise is to be added to the functions
then this argument specifies the root signal to noise ratio.</p>
</td></tr>
<tr><td><code id="DJ.EX_+3A_noisy">noisy</code></td>
<td>
<p>If TRUE then Gaussian noise is added to the signal so that the root signal to noise ratio is <code>rsnr</code>.
If FALSE then just the signals are returned.</p>
</td></tr>
<tr><td><code id="DJ.EX_+3A_plotfn">plotfn</code></td>
<td>
<p>If TRUE then a plot is produced. If FALSE no plot is produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Donoho and Johnstone test functions were designed to reproduce various features to be found in real world signals such as jump discontinuities (blocks), spikes (the NMR-like bumps), varying frequency behaviour (Doppler) and jumps/spikes in smooth signals (heavisine).
These functions are most often used for testing wavelet shrinkage methods and comparing them to other nonparametric regression techniques.
(Donoho, D.L. and Johnstone, I.M. (1994), Ideal spatial adaptation by wavelet
shrinkage. <em>Biometrika</em>, <b>81</b>, 425&ndash;455).
</p>
<p>Another version of the Doppler function can be found in the standalone
<code><a href="#topic+doppler">doppler</a></code> function.
</p>
<p>Another function for this purpose is the Piecewise Polynomial created in Nason and Silverman (1994) an encapsulated in WaveThresh by <code><a href="#topic+example.1">example.1</a></code>
(Nason, G.P. and Silverman, B.W. (1994) The discrete wavelet transform in
S, <em>J. Comput. Graph. Statist.</em>, <b>3</b>, 163&ndash;191.
</p>
<p><em>NOTE: This function might not give exactly the same function values as the equivalent function in WaveLab</em>
</p>


<h3>Value</h3>

<p>A list with four components: blocks, bumps, heavi and doppler containing the sampled signal values for the four types of Donoho and Johnstone test functions. Each of these are deemed to be sampled on an equally spaced grid from 0 to 1.
</p>


<h3>Author(s)</h3>

<p>Theofanis Sapatinas</p>


<h3>See Also</h3>

<p><code><a href="#topic+doppler">doppler</a></code>,<code><a href="#topic+example.1">example.1</a></code>, <code><a href="#topic+threshold">threshold</a></code>, <code><a href="#topic+wd">wd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Show a picture of the four test functions with the default args
#
## Not run: DJ.EX(plotfn=TRUE)
</code></pre>

<hr>
<h2 id='dof'>Compute number of non-zero coefficients in wd object</h2><span id='topic+dof'></span>

<h3>Description</h3>

<p>Compute number of non-zero coefficients in <code><a href="#topic+wd">wd</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dof(wd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dof_+3A_wd">wd</code></td>
<td>
<p>A <code>wavelet decomposition</code> object (such as that returned by the <code><a href="#topic+wd">wd</a></code> function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Very simple function that counts the number of non-zero coefficients in a <code><a href="#topic+wd">wd</a></code> class object. 
</p>


<h3>Value</h3>

<p>An integer that represents the number of non-zero coefficients in the input <code><a href="#topic+wd">wd</a></code> object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.0 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+threshold">threshold</a></code>, <code><a href="#topic+threshold.wd">threshold.wd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's generate some purely random numbers!!
#
myrandom &lt;- rnorm(512)
#
# Take the discrete wavelet transform
#
myrandomWD &lt;- wd(myrandom)
#
# How many coefficients are non-zero?
#
dof(myrandomWD)
# [1] 512
#
# All of them were nonzero!
#
# Threshold it
#
myrandomWDT &lt;- threshold(myrandomWD, policy="universal")
#
# Now lets see how many are nonzero
#
dof(myrandomWDT)
# [1] 8
#
# Wow so 504 of the coefficients were set to zero! Spooky!
#
</code></pre>

<hr>
<h2 id='doppler'>Evaluate the Donoho and Johnstone Doppler signal.
</h2><span id='topic+doppler'></span>

<h3>Description</h3>

<p>This function evaluates and returns the Doppler signal from Donoho and Johnstone, (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doppler(t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doppler_+3A_t">t</code></td>
<td>
<p>The domain of the Doppler function (where you wish to evaluate this
Doppler function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates and returns the Doppler signal from Donoho and Johnstone, (1994).
(Donoho, D.L. and Johnstone, I.M. (1994), Ideal spatial adaptation by wavelet
shrinkage. <em>Biometrika</em>, <b>81</b>, 425&ndash;455).
</p>
<p>Another version of this function can be found in <code><a href="#topic+DJ.EX">DJ.EX</a></code>.
</p>


<h3>Value</h3>

<p>A vector of the same length as the input vector containing the Doppler signal
at <code>t</code>
</p>


<h3>Author(s)</h3>

<p>Arne Kovac</p>


<h3>See Also</h3>

<p><code><a href="#topic+DJ.EX">DJ.EX</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Evalute the Doppler signal at 100 arbitrarily spaced points.
#
tt &lt;- sort(runif(100))
dopp &lt;- doppler(tt)
## Not run: plot(tt, dopp, type="l")
</code></pre>

<hr>
<h2 id='draw'>Draw wavelets or scaling functions.</h2><span id='topic+draw'></span>

<h3>Description</h3>

<p>Draws the mother wavelet or scaling function associated with an object. 
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist. The following functions are used for the following objects: 
</p>

<dl>
<dt>imwd.object</dt><dd><p>the <code><a href="#topic+draw.imwd">draw.imwd</a></code> function is used.</p>
</dd>
<dt>imwdc.object</dt><dd><p>the <code><a href="#topic+draw.imwdc">draw.imwdc</a></code> function is used.</p>
</dd>
<dt>wd.object</dt><dd><p>the <code><a href="#topic+draw.wd">draw.wd</a></code> function is used.</p>
</dd>
<dt>wp.object</dt><dd><p>the <code><a href="#topic+draw.wp">draw.wp</a></code> function is used.</p>
</dd>
<dt>wst.object</dt><dd><p>the <code><a href="#topic+draw.wst">draw.wst</a></code> function is used.</p>
</dd>
</dl>

<p>All of the above method functions use the <code><a href="#topic+draw.default">draw.default</a></code> function which is the function which actually does the drawing. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_+3A_...">...</code></td>
<td>
<p>methods may have additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See individual method help pages for operation and examples.
</p>


<h3>Value</h3>

<p>If the <code>plot.it</code> argument is supplied then the draw functions tend to return the coordinates of what they were meant to draw and don't actually draw anything. 
</p>


<h3>RELEASE</h3>

<p>Version 2 Copyright Guy Nason 1993</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw.default">draw.default</a></code>, <code><a href="#topic+draw.imwd">draw.imwd</a></code>, <code><a href="#topic+draw.imwdc">draw.imwdc</a></code>, <code><a href="#topic+draw.wd">draw.wd</a></code>, <code><a href="#topic+draw.wp">draw.wp</a></code>, <code><a href="#topic+draw.wst">draw.wst</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+imwdc.object">imwdc.object</a></code>, <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+wp.object">wp.object</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>. 
</p>

<hr>
<h2 id='draw.default'>Draw picture of a wavelet or scaling function. </h2><span id='topic+draw.default'></span>

<h3>Description</h3>

<p>This function can produce pictures of one- or two-dimensional wavelets or scaling functions at various levels of resolution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
draw(filter.number = 10, family = "DaubLeAsymm", resolution = 8192,
    verbose = FALSE, plot.it = TRUE, main = "Wavelet Picture", sub = zwd$
    filter$name, xlab = "x", ylab = "psi", dimension = 1, twodplot
     = persp, enhance = TRUE, efactor = 0.05, scaling.function = FALSE, 
	type="l",
    ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.default_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the index number of the wavelet or scaling function you want to draw (from within the wavelet family).</p>
</td></tr>
<tr><td><code id="draw.default_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to draw. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="draw.default_+3A_resolution">resolution</code></td>
<td>
<p>specifies the resolution that the wavelet or scaling function is computed to. It does not necessarily mean that you see all of these points as if the enhance option is TRUE then some function points are omitted.</p>
</td></tr>
<tr><td><code id="draw.default_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the computations progress. Such messages are generally annoying so it is turned off by default.</p>
</td></tr>
<tr><td><code id="draw.default_+3A_plot.it">plot.it</code></td>
<td>
<p>If TRUE then this function attempts to plot the function (i.e. draw it on a graphics device which should be active). If FALSE then this function returns the coordinates of the object that would have been plotted.</p>
</td></tr>
<tr><td><code id="draw.default_+3A_main">main</code></td>
<td>
<p>a main title for the plot</p>
</td></tr>
<tr><td><code id="draw.default_+3A_sub">sub</code></td>
<td>
<p>a subtitle for the plot.</p>
</td></tr>
<tr><td><code id="draw.default_+3A_xlab">xlab</code></td>
<td>
<p>a label string for the x-axis</p>
</td></tr>
<tr><td><code id="draw.default_+3A_ylab">ylab</code></td>
<td>
<p>a label string for the y-axis</p>
</td></tr>
<tr><td><code id="draw.default_+3A_dimension">dimension</code></td>
<td>
<p>whether to make a picture of the one-dimensional wavelet or the two-dimensional wavelet.</p>
</td></tr>
<tr><td><code id="draw.default_+3A_twodplot">twodplot</code></td>
<td>
<p>which function to use to produce the two-dimensional plot if dimension=2. The function you supply should accept data just like the contour or persp functions supplied with S-Plus.</p>
</td></tr>
<tr><td><code id="draw.default_+3A_enhance">enhance</code></td>
<td>
<p>If this argument is TRUE then the plot is enhanced in the following way. Many of Daubechies' compactly supported wavelets are near to zero on a reasonable proportion of their support. So if such a wavelet is plotted quite a lot of it looks to be near zero and the interesting detail seems quite small. This function chooses a nice range on which to plot the central parts of the function and the function is plotted on this range.</p>
</td></tr>
<tr><td><code id="draw.default_+3A_efactor">efactor</code></td>
<td>
<p>Variable which controls the range of plotting associated with the enhance option above. Any observations smaller than efactor times the range of the absolute function values are deemed to be too small. Then the largest range of &ldquo;non-small&rdquo; values is selected to be plotted.</p>
</td></tr>
<tr><td><code id="draw.default_+3A_scaling.function">scaling.function</code></td>
<td>
<p>If this argument is TRUE the scaling function is plotted otherwise the mother wavelet is plotted.</p>
</td></tr>
<tr><td><code id="draw.default_+3A_type">type</code></td>
<td>
<p>The <code>type</code> argument supplied to the plot command</p>
</td></tr>
<tr><td><code id="draw.default_+3A_...">...</code></td>
<td>
<p>other arguments you can supply to the plot routine embedded within this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm underlying this function produces a picture of the wavelet or scaling function by first building a <code>wavelet decomposition</code> object of the correct size (i.e. <code>correct resolution</code>) and setting all entries equal to zero. Then one coefficient at a carefully selected resolution level is set to one and the decomposition is inverted to obtain a picture of the wavelet. 
</p>


<h3>Value</h3>

<p>If <code>plot.it=FALSE</code> then usually a list containing coordinates of the object that <em>would</em> have been plotted is returned. This can be useful if you don't want S-Plus to do the plotting or you wish to use the coordinates of the wavelets for other purposes.</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Note</h3>

<p>A plot is produced of the wavelet or scaling function if <code>plot.it=TRUE</code>.</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+ScalingFunction">ScalingFunction</a></code>,<code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+wr">wr</a></code>, <code><a href="#topic+wr.wd">wr.wd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# First make sure that your favourite graphics device is open
# otherwise S-Plus will complain.
#
# Let's draw a one-dimensional Daubechies least-asymmetric wavelet
# N=10
#
## Not run: draw.default(filter.number=10, family="DaubLeAsymm")
#
# Wow. What a great picture!
#
# Now how about a one-dimensional Daubechies extremal-phase scaling function
# with N=2
#
## Not run: draw.default(filter.number=2, family="DaubExPhase")
#
# Excellent! Now how about a two-dimensional Daubechies least-asymmetric
# N=6 wavelet
#
# N.b. we'll also reduce the resolution down a bit. If we used the default
# resolution of 8192 this would be probably too much for most computers.
#
## Not run: draw.default(filter.number=6, family="DaubLeAsymm", dimension=2, res=256)
#
# What a pretty picture!
</code></pre>

<hr>
<h2 id='draw.imwd'>Draw mother wavelet associated with an imwd object. </h2><span id='topic+draw.imwd'></span>

<h3>Description</h3>

<p>This function draws the mother wavelet associated with an <code><a href="#topic+imwd.object">imwd.object</a></code> &mdash; a two-dimensional wavelet decomposition. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwd'
draw(wd, resolution=128, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.imwd_+3A_wd">wd</code></td>
<td>
<p>The <code><a href="#topic+imwd">imwd</a></code> class object whose associated wavelet you wish to draw. </p>
</td></tr>
<tr><td><code id="draw.imwd_+3A_resolution">resolution</code></td>
<td>
<p>The resolution at which the computation is done to compute the wavelet picture. Generally the resolution should be lower for two-dimensional wavelets since the number of computations is proportional to the square of the resolution (the DWT is still O(n) though).</p>
</td></tr>
<tr><td><code id="draw.imwd_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the <code><a href="#topic+draw.default">draw.default</a></code> function which does the drawing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the <code>filter</code> component from the <code><a href="#topic+imwd">imwd</a></code> object (which is constructed using the <code><a href="#topic+filter.select">filter.select</a></code> function) to decide which wavelet to draw. Once decided the <code><a href="#topic+draw.default">draw.default</a></code> function is used to actually do the drawing. 
</p>


<h3>Value</h3>

<p>If the plot.it argument is set to <code>TRUE</code> then nothing is returned. Otherwise, as with <code><a href="#topic+draw.default">draw.default</a></code>, the coordinates of what would have been plotted are returned. 
</p>


<h3>RELEASE</h3>

<p>Version 2 Copyright Guy Nason 1993 </p>


<h3>Note</h3>

<p>If the <code>plot.it</code> argument is<code>TRUE</code> (which it is by default) a plot of the mother wavelet or scaling function is plotted on the active graphics device.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+draw.default">draw.default</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's use the lennon test image
#
data(lennon)
## Not run: image(lennon)
#
# Now let's do the 2D discrete wavelet transform using Daubechies'
# least-asymmetric wavelet N=6
#
lwd &lt;- imwd(lennon, filter.number=6)
#
# And now draw the wavelet that did this transform
#
## Not run: draw(lwd)
#
# A nice little two-dimensional wavelet!
#

</code></pre>

<hr>
<h2 id='draw.imwdc'>Draw mother wavelet associated with an imwdc object. </h2><span id='topic+draw.imwdc'></span>

<h3>Description</h3>

<p>This function draws the mother wavelet associated with an <code><a href="#topic+imwdc.object">imwdc.object</a></code> &mdash; a compressed two-dimensional wavelet decomposition. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwdc'
draw(wd, resolution=128, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.imwdc_+3A_wd">wd</code></td>
<td>
<p>The <code><a href="#topic+imwd">imwd</a></code> class object whose associated wavelet you wish to draw. (I know its called wd, sorry).</p>
</td></tr>
<tr><td><code id="draw.imwdc_+3A_resolution">resolution</code></td>
<td>
<p>The resolution at which the computation is done to compute the wavelet picture. Generally the resolution should be lower for two-dimensional wavelets since the number of computations is proportional to the square of the resolution (the DWT is still O(n) though).</p>
</td></tr>
<tr><td><code id="draw.imwdc_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the <code><a href="#topic+draw.default">draw.default</a></code> function which does the drawing.</p>
</td></tr> </table>


<h3>Details</h3>

<p>This function extracts the <code>filter</code> component from the <code><a href="#topic+imwd">imwd</a></code> object (which is constructed using the <code><a href="#topic+filter.select">filter.select</a></code> function) to decide which wavelet to draw. Once decided the <code><a href="#topic+draw.default">draw.default</a></code> function is used to actually do the drawing. 
</p>


<h3>Value</h3>

<p>If the <code>plot.it</code> argument is set to <code>TRUE</code> then nothing is returned. Otherwise, as with <code><a href="#topic+draw.default">draw.default</a></code>, the coordinates of what would have been plotted are returned. 
</p>


<h3>RELEASE</h3>

<p>Version 2 Copyright Guy Nason 1993 </p>


<h3>Note</h3>

<p>If the <code>plot.it</code> argument is <code>TRUE</code> (which it is by default) a plot of the mother wavelet or scaling function is plotted on the active graphics device. 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+imwdc.object">imwdc.object</a></code>, <code><a href="#topic+draw.default">draw.default</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's use the lennon test image
#
data(lennon)
## Not run: image(lennon)
#
# Now let's do the 2D discrete wavelet transform using Daubechies'
# least-asymmetric wavelet N=6
#
lwd &lt;- imwd(lennon, filter.number=6)
#
# Now let's threshold the 2D DWT
# The resultant class of object is imwdc object.
#
lwdT &lt;- threshold(lwd)
#
# And now draw the wavelet that did this transform
#
## Not run: draw(lwdT)
#
# A nice little two-dimensional wavelet!
#
</code></pre>

<hr>
<h2 id='draw.mwd'>Draws a wavelet or scaling function used to compute an &lsquo;mwd&rsquo; object </h2><span id='topic+draw.mwd'></span>

<h3>Description</h3>

<p>Draws picture of one wavelet or scaling function associated with the multiple wavelet decomposition object. <code><a href="#topic+mwd.object">mwd.object</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mwd'
draw(mwd, phi = 0, psi = 0, return.funct = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.mwd_+3A_mwd">mwd</code></td>
<td>
<p>The <code><a href="#topic+mwd">mwd</a></code> class object whose associated wavelet or scaling function you wish to draw. </p>
</td></tr>
<tr><td><code id="draw.mwd_+3A_phi">phi</code></td>
<td>
<p>description not yet available</p>
</td></tr>
<tr><td><code id="draw.mwd_+3A_psi">psi</code></td>
<td>
<p>If <code>phi</code> is non-zero then the &lsquo;phi&rsquo;-th scaling function of the wavelet family used for mwd will be plotted. <code>phi</code> must be between 0 and <code>mwd$filter$nphi</code>.</p>
</td></tr>
<tr><td><code id="draw.mwd_+3A_return.funct">return.funct</code></td>
<td>
<p>If true then the vector used as phi/psi in the plot command is returned.</p>
</td></tr>
<tr><td><code id="draw.mwd_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the <code>plot</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is usual to specify just one of phi and psi. IF neither phi nor psi are specified then phi=1 is the default. An error is generated if both phi=0 and psi=0 or if both are nonzero. 
</p>


<h3>Value</h3>

<p>If the <code>return.funct</code> argument is set to <code>TRUE</code> then the function values in the plot are returned otherwise <code>NULL</code> is returned. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie 1995-6).</p>


<h3>Note</h3>

<p>If the <code>return.funct</code> argument is <code>FALSE</code> a plot of the mother wavelet or scaling function is plotted on the active graphics device. 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.mwd">accessC.mwd</a></code>, <code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mfilter.select">mfilter.select</a></code>, <code><a href="#topic+mwd">mwd</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+mwr">mwr</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>, <code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Do a multiple wavelet decomposition on vector: ynoise
#
ynoise &lt;- rnorm(512, sd = 0.1)
ymwd &lt;- mwd(ynoise,filter.type="Geronimo")
#
# Draw a picture of the second Geronimo wavelet.
#
## Not run: draw(ymwd,psi=2)
#
#
</code></pre>

<hr>
<h2 id='draw.wd'>Draw mother wavelet or scaling function associated with wd object. </h2><span id='topic+draw.wd'></span>

<h3>Description</h3>

<p>This function draws the mother wavelet or scaling function associated with a <code><a href="#topic+wd.object">wd.object</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
draw(wd, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.wd_+3A_wd">wd</code></td>
<td>
<p>The <code><a href="#topic+wd">wd</a></code> class object whose associated wavelet or scaling function you wish to draw. </p>
</td></tr>
<tr><td><code id="draw.wd_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the <code><a href="#topic+draw.default">draw.default</a></code> function which does the drawing. In particular, arguments can be set to choose between drawing the mother wavelet and scaling function, to set the resolution of the plot, to choose between drawing one and two dimensional pictures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the filter component from the <code><a href="#topic+wd">wd</a></code> object (which is constructed using the <code><a href="#topic+filter.select">filter.select</a></code> function) to decide which wavelet to draw. Once decided the <code><a href="#topic+draw.default">draw.default</a></code> function is used to actually do the drawing. 
</p>


<h3>Value</h3>

<p>If the <code>plot.it</code> argument is set to TRUE then nothing is returned. Otherwise, as with <code><a href="#topic+draw.default">draw.default</a></code>, the coordinates of what would have been plotted are returned. 
</p>


<h3>RELEASE</h3>

<p>Version 2 Copyright Guy Nason 1993 </p>


<h3>Note</h3>

<p>If the <code>plot.it</code> argument is <code>TRUE</code> (which it is by default) a plot of the mother wavelet or scaling function is plotted on the active graphics device.</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+draw.default">draw.default</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y
## Not run: ts.plot(test.data)
#
# Now do the discrete wavelet transform of the data using the Daubechies
# least-asymmetric wavelet N=10 (the default arguments in
# wd).
#
tdwd &lt;- wd(test.data)
#
# What happens if we try to draw this new tdwd object?
#
## Not run: draw(tdwd)
#
# We get a picture of the wavelet that did the transform
#

</code></pre>

<hr>
<h2 id='draw.wp'>Draw wavelet packet associated with a wp object.</h2><span id='topic+draw.wp'></span>

<h3>Description</h3>

<p>This function draws a wavelet packet associated with a <code><a href="#topic+wp.object">wp.object</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
draw(wp, level, index, plot.it=TRUE, main, sub, xlab, ylab, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.wp_+3A_wp">wp</code></td>
<td>
<p>The <code><a href="#topic+wp">wp</a></code> class object whose associated wavelet packet you wish to draw. </p>
</td></tr>
<tr><td><code id="draw.wp_+3A_level">level</code></td>
<td>
<p>The resolution level of wavelet packet in the wavelet packet decomposition that you wish to draw (corresponds to scale).</p>
</td></tr>
<tr><td><code id="draw.wp_+3A_index">index</code></td>
<td>
<p>The packet index of the wavelet packet in the wavelet packet decomposition that you wish to draw (corresponds to number of oscillations).</p>
</td></tr>
<tr><td><code id="draw.wp_+3A_plot.it">plot.it</code></td>
<td>
<p>If TRUE then the wavelet packet is plotted on the active graphics device. If FALSE then the y-coordinates of the packet are returned. Note that x-coordinates are not returned (the packet is periodic on its range anyway). </p>
</td></tr>
<tr><td><code id="draw.wp_+3A_main">main</code></td>
<td>
<p>The main argument for the plot</p>
</td></tr>
<tr><td><code id="draw.wp_+3A_sub">sub</code></td>
<td>
<p>The subtitle for the plot</p>
</td></tr>
<tr><td><code id="draw.wp_+3A_xlab">xlab</code></td>
<td>
<p>The labels for the x axis</p>
</td></tr>
<tr><td><code id="draw.wp_+3A_ylab">ylab</code></td>
<td>
<p>The labels for the y axis</p>
</td></tr>
<tr><td><code id="draw.wp_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the <code><a href="#topic+drawwp.default">drawwp.default</a></code> function which does the drawing. In particular, arguments can be set to choose between drawing the mother wavelet and scaling function, to set the resolution of the plot, to choose between drawing one and two dimensional pictures. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the filter component from the <code><a href="#topic+wp">wp</a></code> object (which is constructed using the <code><a href="#topic+filter.select">filter.select</a></code> function) to decide which wavelet packet family to draw. Once decided the <code><a href="#topic+drawwp.default">drawwp.default</a></code> function is used to actually do the drawing. </p>


<h3>Value</h3>

<p>If the <code>plot.it</code> argument is set to <code>TRUE</code> then nothing is returned. Otherwise, if <code>plot.it</code> is set to <code>FALSE</code> the coordinates of what would have been plotted are returned. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 Copyright Guy Nason 1998 </p>


<h3>Note</h3>

<p>If the <code>plot.it</code> argument is <code>TRUE</code> (which it is by default) a plot of the appropriate wavelet packet is plotted on the active graphics device.</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+wp">wp</a></code>, <code><a href="#topic+wp.object">wp.object</a></code>, <code><a href="#topic+drawwp.default">drawwp.default</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y
## Not run: ts.plot(test.data)
#
# Now do the wavelet packet transform of the data using the Daubechies
# least-asymmetric wavelet N=10 (the default arguments in
# wp).
#
tdwp &lt;- wp(test.data)
#
# What happens if we try to draw this new tdwp object?
#
## Not run: draw(tdwd, level=4, index=12)
</code></pre>

<hr>
<h2 id='draw.wst'>Draw mother wavelet or scaling function associated with wst object.</h2><span id='topic+draw.wst'></span>

<h3>Description</h3>

<p>This function draws the mother wavelet or scaling function associated with a  <code><a href="#topic+wst.object">wst.object</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
draw(wst, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.wst_+3A_wst">wst</code></td>
<td>
<p>The <code><a href="#topic+wst">wst</a></code> class object whose associated wavelet or scaling function you wish to draw. </p>
</td></tr>
<tr><td><code id="draw.wst_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the <code><a href="#topic+draw.default">draw.default</a></code> function which does the drawing. In particular, arguments can be set to choose between drawing the mother wavelet and scaling function, to set the resolution of the plot, to choose between drawing one and two dimensional pictures. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the <code>filter</code> component from the <code><a href="#topic+wst">wst</a></code> object (which is constructed using the <code><a href="#topic+filter.select">filter.select</a></code> function) to decide which wavelet packet family to draw. Once decided the <code><a href="#topic+draw.default">draw.default</a></code> function is used to actually do the drawing. </p>


<h3>Value</h3>

<p>If the <code>plot.it</code> argument is set to <code>TRUE</code> then nothing is returned. Otherwise, Otherwise, as with <code><a href="#topic+draw.default">draw.default</a></code>, the coordinates of what would have been plotted are returned. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1995 </p>


<h3>Note</h3>

<p>If the <code>plot.it</code> argument is <code>TRUE</code> (which it is by default) a plot of the appropriate wavelet packet is plotted on the active graphics device.</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+draw.default">draw.default</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y
## Not run: ts.plot(test.data)
#
# Now do the \code{packet-ordered non-decimated DWT}  of the data using the Daubechies
# least-asymmetric wavelet N=10 (the default arguments in \code{\link{wst}}).
#
tdwst &lt;- wst(test.data)
#
# What happens if we try to draw this new tdwst object?
#
## Not run: draw(tdwst)
#
# We get a picture of the wavelet that did the transform
#
</code></pre>

<hr>
<h2 id='drawbox'>Draw a shaded coloured box</h2><span id='topic+drawbox'></span>

<h3>Description</h3>

<p>Simply draws a box with bottom left corner at (x,y), or width w and height
h with shading of density and colour of col.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawbox(x,y,w,h,density,col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawbox_+3A_x">x</code></td>
<td>
<p>The bottom left x coordinate of the box</p>
</td></tr>
<tr><td><code id="drawbox_+3A_y">y</code></td>
<td>
<p>The bottom left y coordinate of the box</p>
</td></tr>
<tr><td><code id="drawbox_+3A_w">w</code></td>
<td>
<p>The width of the box</p>
</td></tr>
<tr><td><code id="drawbox_+3A_h">h</code></td>
<td>
<p>The height of the box</p>
</td></tr>
<tr><td><code id="drawbox_+3A_density">density</code></td>
<td>
<p>The shading density of the box</p>
</td></tr>
<tr><td><code id="drawbox_+3A_col">col</code></td>
<td>
<p>The colour of the box</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+addpkt">addpkt</a></code></p>

<hr>
<h2 id='drawwp.default'>Subsidiary routine that actually computes wavelet packet values</h2><span id='topic+drawwp.default'></span>

<h3>Description</h3>

<p>Function computes the values of a given wavelet packet on a discrete
grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawwp.default(level, index, filter.number = 10, family = "DaubLeAsymm",
    resolution = 64 * 2^level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawwp.default_+3A_level">level</code></td>
<td>
<p>The resolution level of the packet you want</p>
</td></tr>
<tr><td><code id="drawwp.default_+3A_index">index</code></td>
<td>
<p>The packet index of the packet you want</p>
</td></tr>
<tr><td><code id="drawwp.default_+3A_filter.number">filter.number</code></td>
<td>
<p>The type of wavelet you want, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="drawwp.default_+3A_family">family</code></td>
<td>
<p>The family of wavelet you want, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="drawwp.default_+3A_resolution">resolution</code></td>
<td>
<p>The number of ordinates at which you want the wavelet packet</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function works by computing a wavelet packet transform of a zero vector.
Then inserting a single one somewhere in the desired packet, and then
inverts the transform.
</p>


<h3>Value</h3>

<p>A vector containing the &quot;y&quot; values of the required wavelet packet. 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw.wp">draw.wp</a></code>,<code><a href="#topic+InvBasis">InvBasis</a></code>,
<code><a href="#topic+nlevelsWT">nlevelsWT</a></code>,
<code><a href="#topic+putpacket">putpacket</a></code>,
<code><a href="#topic+wp">wp</a></code></p>

<hr>
<h2 id='ewspec'>Compute evolutionary wavelet spectrum estimate.</h2><span id='topic+ewspec'></span>

<h3>Description</h3>

<p>This function computes the evolutionary wavelet spectrum (EWS) estimate from a time series (or non-decimated wavelet transform of a time series). The estimate is computed by taking the non-decimated wavelet transform of the time series data, taking its modulus; smoothing using TI-wavelet shrinkage and then correction for the redundancy caused by use of the non-decimated wavelet transform. Options below beginning with smooth. are passed directly to the TI-wavelet shrinkage routines. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewspec(x, filter.number = 10, family = "DaubLeAsymm",
    UseLocalSpec = TRUE, DoSWT = TRUE, WPsmooth = TRUE,
    verbose = FALSE, smooth.filter.number = 10,
    smooth.family = "DaubLeAsymm",
    smooth.levels = 3:(nlevelsWT(WPwst) - 1), smooth.dev = madmad,
    smooth.policy = "LSuniversal", smooth.value = 0, smooth.by.level = FALSE,
    smooth.type = "soft", smooth.verbose = FALSE,
    smooth.cvtol = 0.01, smooth.cvnorm = l2norm,
    smooth.transform = I, smooth.inverse = I)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ewspec_+3A_x">x</code></td>
<td>
<p>The time series that you want to analyze. (See DETAILS below on how to supply preprocessed versions of the time series which bypass early parts of the ewspec function). </p>
</td></tr>
<tr><td><code id="ewspec_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the index of the wavelet used in the analysis of the time series (i.e. the wavelet basis functions used to model the time series). For Daubechies compactly supported wavelets the filter number is the number of vanishing moments. </p>
</td></tr>
<tr><td><code id="ewspec_+3A_family">family</code></td>
<td>
<p>This selects the wavelet family to use in the analysis of the time series (i.e. which wavelet family to use to model the time series). Only use the Daubechies compactly supported wavelets <code>DaubExPhase</code> and <code>DaubLeAsymm</code>. </p>
</td></tr>
<tr><td><code id="ewspec_+3A_uselocalspec">UseLocalSpec</code></td>
<td>
<p>If you input a time series for <code>x</code> then this argument should always be <code>T</code>. (However, you can precompute the modulus of the non-decimated wavelet transform yourself and supply it as <code>x</code> in which case the <code><a href="#topic+LocalSpec">LocalSpec</a></code> call within this function is not necessary and you can set UseLocalSpec equal to <code>F</code>). </p>
</td></tr>
<tr><td><code id="ewspec_+3A_doswt">DoSWT</code></td>
<td>
<p>If you input a time series for <code>x</code> then this argument should always be <code>T</code>. (However, you can precompute the non-decimated wavelet transform yourself and supply it as <code>x</code> in which case the <code>wd</code> call within the function will not be necessary and you can set DoSWT equal to <code>F</code>). </p>
</td></tr>
<tr><td><code id="ewspec_+3A_wpsmooth">WPsmooth</code></td>
<td>
<p>Normally a wavelet periodogram is smoothed before it is corrected. Use <code>WPsmooth=F</code> is you do not want any wavelet periodogram smoothing (correction is still done). </p>
</td></tr>
<tr><td><code id="ewspec_+3A_verbose">verbose</code></td>
<td>
<p>If this option is <code>T</code> then informative messages are printed as the function progresses. </p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.filter.number">smooth.filter.number</code></td>
<td>
<p>This selects the index number of the wavelet that smooths each scale of the wavelet periodogram. See <code><a href="#topic+filter.select">filter.select</a></code> for further details on which wavelets you can use. Generally speaking it is a good idea to use a smoother wavelet for smoothing than the one you used for analysis (above) but since one still wants local smoothing it is best not to use a wavelet that is much smoother. </p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.family">smooth.family</code></td>
<td>
<p>This selects the wavelet family that smooths each scale of the wavelet periodogram. See <code>filter.select</code> for further details on which wavelets you can use. There is no need to use the same family as you used to analyse the time series. </p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.levels">smooth.levels</code></td>
<td>
<p>The levels to smooth when performing the TI-wavelet shrinkage smoothing. </p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.dev">smooth.dev</code></td>
<td>
<p>The method for estimating the variance of the empirical wavelet coefficients for smoothing purposes. </p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.policy">smooth.policy</code></td>
<td>
<p>The recipe for smoothing: determines how the threshold is chosen. See <code><a href="#topic+threshold">threshold</a></code> for TI-smoothing and choice of potential policies. For EWS estimation <code>LSuniversal</code> is recommended for thi Chi-squared nature of the periodogram coefficients. However, if the coefficients are transformed (using <code>smooth.transform</code> and <code>smooth.inverse</code>) then other, more standard, policies may be appropriate. </p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.value">smooth.value</code></td>
<td>
<p>When a manual policy is being used this argument is used to supply a threshold value. See <code>threshold</code> for more information. </p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.by.level">smooth.by.level</code></td>
<td>
<p>If <code>TRUE</code> then the wavelet shrinkage is performed by computing and applying a separate threshold to each level in the non-decimated wavelet transform of each scale. Note that each scale in the EWS is smoothed separately and independently: and each smooth consists of taking the (second-stage) non-decimated wavelet transform and applying a threshold to each level of a wavelet transformed scale. 
</p>
<p>If <code>FALSE</code> then the same threshold is applied to the non-decimated wavelet transform of a scale. Different thresholds may be computed for different scales (in the time series model) but the threshold will be the same for each level arising from the non-decimated transform of a scale. 
</p>
<p>Note: a <code>scale</code> refers to a set of coefficients coming from a particular scale of the non-decimated wavelet transform of the time series data that <code>models</code> the time series. A <code>level</code> refers to the levels of wavelet coefficients obtained from taking the non-decimated wavelet transform of a particular scale.</p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.type">smooth.type</code></td>
<td>
<p>The type of shrinkage: either &quot;hard&quot; or &quot;soft&quot;. </p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.verbose">smooth.verbose</code></td>
<td>
<p>If <code>T</code> then informative messages concerning the TI-transform wavelet shrinkage are printed.</p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.cvtol">smooth.cvtol</code></td>
<td>
<p>If cross-validated wavelet shrinkage (<code>smooth.policy="cv"</code>) is used then this argument supplies the cross-validation tolerance. </p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.cvnorm">smooth.cvnorm</code></td>
<td>
<p>no description for object</p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.transform">smooth.transform</code></td>
<td>
<p>The transform function to use to transform the wavelet periodogram estimate. The wavelet periodogram coefficients are typically chi-squared in nature, a <code>log</code> transform can pull the coefficients towards normality so that a <code>smooth.policy</code> for Gaussian data could be used (e.g. <code>universal</code>). </p>
</td></tr>
<tr><td><code id="ewspec_+3A_smooth.inverse">smooth.inverse</code></td>
<td>
<p>the inverse transform of <code>smooth.transform</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes an estimate of the evolutionary wavelet spectrum of a time series according to the paper by Nason, von Sachs and Kroisandt. The function works as follows: 
</p>

<dl>
<dt>1</dt><dd><p>The non-decimated wavelet transform of the series is computed.</p>
</dd> 
<dt>2</dt><dd><p>The squared modulus of the non-decimated wavelet transform is computed (this is the raw wavelet periodogram, which is returned).</p>
</dd> 
<dt>3</dt><dd><p>The squared modulus is smoothed using TI-wavelet shrinkage.</p>
</dd> 
<dt>4</dt><dd><p>The smoothed coefficients are corrected using the inverse of the inner product matrix of the discrete non-decimated autocorrelation wavelets (produced using the ipndacw function).</p>
</dd> 
</dl>

<p>To display the EWS use the <code>plot</code>function on the <code>S</code> component, see the examples below. 
</p>
<p>It is possible to supply the non-decimated wavelet transform of the time series and set <code>DoSWT=F</code> or to supply the squared modulus of the non-decimated wavelet transform using <code><a href="#topic+LocalSpec">LocalSpec</a></code> and setting <code>UseLocalSpec=F</code>. This facility saves time because the function is then only used for smoothing and correction. 
</p>


<h3>Value</h3>

<p>A list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>S</code></td>
<td>
<p>The evolutionary wavelet spectral estimate of the input <code>x</code>. This object is of class <code><a href="#topic+wd">wd</a></code> and so can be plotted, printed in the usual way. </p>
</td></tr>
<tr><td><code>WavPer</code></td>
<td>
<p>The raw wavelet periodogram of the input <code>x</code>. The EWS estimate (above) is the smoothed corrected version of the wavelet periodgram. The wavelet periodogram is of class <code><a href="#topic+wd">wd</a></code> and so can be plotted, printed in the usual way. </p>
</td></tr>
<tr><td><code>rm</code></td>
<td>
<p>This is the matrix A from the paper by Nason, von Sachs and Kroisandt. Its inverse is used to correct the raw wavelet periodogram. This matrix is computed using the <code><a href="#topic+ipndacw">ipndacw</a></code> function. </p>
</td></tr>
<tr><td><code>irm</code></td>
<td>
<p>The inverse of the matrix A from the paper by Nason, von Sachs and Kroisandt. It is used to correct the raw wavelet periodogram.</p>
</td></tr> 
</table>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (1998). Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum. <em>Technical Report</em>, Department of Mathematics University of Bristol/ Fachbereich Mathematik, Kaiserslautern. </p>


<h3>See Also</h3>

<p><code>Baby Data</code>, <code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+ipndacw">ipndacw</a></code>, <code><a href="#topic+LocalSpec">LocalSpec</a></code>, <code><a href="#topic+threshold">threshold</a></code> <code><a href="#topic+wd">wd</a></code> <code><a href="#topic+wd.object">wd.object</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Apply the EWS estimate function to the baby data
#
</code></pre>

<hr>
<h2 id='example.1'>Compute and return piecewise polynomial coordinates.
</h2><span id='topic+example.1'></span>

<h3>Description</h3>

<p>This function computes and returns the coordinates of the piecewise polynomial described by Nason and Silverman, 1994. This function is a useful test function for evaluating wavelet shrinkage methodology as it contains smooth parts, a discontinuity and it is periodic.
</p>
<p>(Nason, G.P. and Silverman, B.W. (1994) The discrete wavelet transform in
S, <em>J. Comput. Graph. Statist.</em>, <b>3</b>, 163&ndash;191.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.1()
</code></pre>


<h3>Arguments</h3>

<p>None
</p>


<h3>Details</h3>

<p>This function computes and returns the x and y coordinates of the piecewise polynomial function described in Nason and Silverman, 1994.
The formula for the piecewise polynomial (which is piecewise cubic) is given in Nason and Silverman, 1994.
</p>
<p>The piecewise polynomial returned is a discrete sample on 512 equally spaced points between 0 and 1 (including 0 but excluding 1).
</p>
<p>The Donoho and Johnstone test functions can be generated using the
<code><a href="#topic+DJ.EX">DJ.EX</a></code> function.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>a vector of length 512 containing the ordered x ordinates of the piecewise polynomial.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a vector of length 512 containing the corresponding y ordinates of the piecewise polynomial.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+DJ.EX">DJ.EX</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate the piecewise polynomial 
#
test.data &lt;- example.1()$y
## Not run: ts.plot(test.data)
</code></pre>

<hr>
<h2 id='filter.select'>Provide wavelet filter coefficients.</h2><span id='topic+filter.select'></span>

<h3>Description</h3>

<p>This function stores the filter coefficients necessary for doing a discrete wavelet transform (and its inverse), including complex-valued compactly supported
wavelets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.select(filter.number, family="DaubLeAsymm", constant=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter.select_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the desired filter, an integer that takes a value dependent upon the family that you select.
For the complex-valued wavelets in the Lina-Mayrand family, the filter number takes the form x.y where x is the number of vanishing moments (3, 4, or 5) and y is the solution number (1 for x = 3 or 4 vanishing moments; 1, 2, 3, or 4 for x = 5 vanishing moments). Note: this argument has a different meaning
for Littlewood-Paley wavelets, see the note below in the Details section.</p>
</td></tr>
<tr><td><code id="filter.select_+3A_family">family</code></td>
<td>

<p>This selects the basic family that the wavelet comes from. The choices are <b>DaubExPhase</b> for Daubechies' extremal phase wavelets, <b>DaubLeAsymm</b> for Daubechies' &ldquo;least-asymmetric&rdquo; wavelets,
<b>Coiflets</b> for Coiflets,
<b>Lawton</b> for Lawton's complex-valued wavelets (equivalent to Lina-Mayrand 3.1 wavelets), <b>LittlewoodPaley</b> for a approximation to Littlewood-Paley wavelets, or <b>LinaMayrand</b> for the Lina-Mayrand family of complex-valued Daubechies' wavelets.</p>
</td></tr>
<tr><td><code id="filter.select_+3A_constant">constant</code></td>
<td>
<p>This constant is applied as a multiplier to all the coefficients. It can be a vector, and so you can adapt the filter coefficients to be whatever you want. (This is feature of negative utility, or &ldquo;there is less to this than meets the eye&rdquo; as my old PhD supervisor would say [GPN]).</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function contains at least three types of filter. Two types can be selected with family set to DaubExPhase, these wavelets are the Haar wavelet (selected by filter.number=1 within this family) and Daubechies &ldquo;extremal phase&rdquo; wavelets selected by filter.numbers ranging from 2 to 10). Setting family to DaubLeAsymm gives you Daubechies least asymmetric wavelets, but here the filter number ranges from 4 to 10. For Daubechies wavelets, filter.number corresponds to the N of that paper, the wavelets become more regular as the filter.number increases, but they are all of compact support. 
</p>
<p>With family equal to &ldquo;Coiflets&rdquo; the function supports
filter numbers ranging from 1 to 5. Coiflets are wavelets where the
scaling function also has vanishing moments.
</p>
<p>With family equal to &ldquo;LinaMayrand&rdquo;, the function returns complex-valued Daubechies wavelets. For odd numbers of vanishing moments, there are symmetric complex-valued wavelets i this family, and for five or more vanishing moments there are multiple distinct complex-valued wavelets, distinguished by their (arbitrary) solution number. At present, Lina-Mayrand wavelets 3.1, 4.1, 5.1, 5.2, 5.3, and 5.4 are available in WaveThresh.
</p>
<p>Setting family equal to &ldquo;Lawton&rdquo; chooses complex-valued wavelets. The only wavelet available is the one with &ldquo;filter.number&rdquo; equal to 3. 
</p>
<p>With family equal to &ldquo;LittlewoodPaley&rdquo; the Littlewood-Paley wavelet
is used. The scaling function is also the same as (or at least proportional
to, depending on your normalization) that of the Shannon scaling
function, so its an approximation to the Shannon wavelet transform.
The &ldquo;filter.number&rdquo; argument has a special meaning for the Littlewood-Paley
wavelets: it does not represent vanishing moments here. Instead, it
controls the number of filter taps in the quadrature mirror filter:
typically longer values are better, up to the length of the series.
Increasing it higher than the length of the series does not usually have
much effect. Note: extreme caution should be taken with the
Littlewood-Paley wavelet. This implementation is pure time-domain and
as such can only be thought of as an approximation to a complete
Shannon/LP implementation. For example, in actuality the wavelets
are NOT finite impluse response filters like with Daubechies wavelets.
This means that it is possible for an infinite number of Littlewood Paley
wavelet coefficients to be nonzero. However, computers can not store
an infinite number of coefficients and some will be lost. This is most
noticeable with functions with discontinuities and other homogeneities
but it can also happen with some smooth functions. A way to check how &quot;bad&quot;
is can be is to transform your desired function followed immediately by
the inverse transform and compare the original with the resultant sequence.
</p>
<p>The function <code><a href="#topic+compare.filters">compare.filters</a></code> can be used to compare two filters. 
</p>


<h3>Value</h3>

<p>Alist is returned with four components describing the filter: 
</p>
<table role = "presentation">
<tr><td><code>H</code></td>
<td>
<p>A vector containing the filter coefficients.</p>
</td></tr> 
<tr><td><code>G</code></td>
<td>
<p>A vector containing filter coefficients (if Lawton or Lina-Mayrand wavelets are selected, otherwise this is NULL).</p>
</td></tr> 
<tr><td><code>name</code></td>
<td>
<p>A character string containing the name of the filter.</p>
</td></tr> 
<tr><td><code>family</code></td>
<td>
<p>A character string containing the family of the filter.</p>
</td></tr> 
<tr><td><code>filter.number</code></td>
<td>
<p>The filter number used to select the filter from within a family.</p>
</td></tr> 
</table>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994, This version
originally part of the cthresh release which was merged into
wavethresh in Oct 2012. Original cthresh version due to Stuart
Barber </p>


<h3>Note</h3>

<p>The (Daubechies) filter coefficients should always sum to sqrt(2). This is a useful check on their validity. </p>


<h3>Author(s)</h3>

<p>Stuart Barber and G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr">wr</a></code>, <code><a href="#topic+wr.wd">wr.wd</a></code>, <code><a href="#topic+accessC">accessC</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+compare.filters">compare.filters</a></code>, <code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+imwr">imwr</a></code>, <code><a href="#topic+threshold">threshold</a></code>, <code><a href="#topic+draw">draw</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This function is usually called by others.
#However, on occasion you may wish to look at the coefficients themselves.

#
# look at the filter coefficients for N=4 (by default Daubechies'
# least-asymmetric wavelets.)
#
filter.select(4)
#$H:
#[1] -0.07576571 -0.02963553  0.49761867  0.80373875  0.29785780
#[6] -0.09921954 -0.01260397  0.03222310
#
#$G:
#NULL
#
#$name:
#[1] "Daub cmpct on least asymm N=4"
#
#$family:
#[1] "DaubLeAsymm"
#
#$filter.number:
#[1] 4
</code></pre>

<hr>
<h2 id='find.parameters'>Find estimates of prior parameters</h2><span id='topic+find.parameters'></span>

<h3>Description</h3>

<p>Estimate the prior parameters for the complex empirical Bayes shrinkage procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.parameters(data.wd, dwwt, j0, code, tol, Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.parameters_+3A_data.wd">data.wd</code></td>
<td>
<p>Wavelet decomposition of the data being analysed.</p>
</td></tr>
<tr><td><code id="find.parameters_+3A_dwwt">dwwt</code></td>
<td>
<p>The diagonal elements of the matrix Wt(W). See <code><a href="#topic+make.dwwt">make.dwwt</a></code> for details.</p>
</td></tr>
<tr><td><code id="find.parameters_+3A_j0">j0</code></td>
<td>
<p>Primary resolution level, as discussed in the help for threshold.wd</p>
</td></tr>
<tr><td><code id="find.parameters_+3A_code">code</code></td>
<td>
<p>Tells the function whether to use NAG code for the search (code=&quot;NAG&quot;), R/S-plus for the search with C code to evaluate the likelihood (code=&quot;C&quot;), or R/S-plus code for all calculations (code=&quot;R&quot; or code=&quot;S&quot;). Setting code=&quot;NAG&quot; is strongly recommended.</p>
</td></tr>
<tr><td><code id="find.parameters_+3A_tol">tol</code></td>
<td>
<p>A tolerance parameter which bounds the mixing weight away from zero and one and the correlation between real and imaginary parts of the prior away from plus or minus one.</p>
</td></tr>
<tr><td><code id="find.parameters_+3A_sigma">Sigma</code></td>
<td>
<p>The covariance matrix of the wavelet coefficients of white noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The complex empirical Bayes (CEB) shrinkage procedure described by Barber &amp; Nason (2004) places independent mixture priors on each complex-valued wavelet coefficient. This routine finds marginal maximum likelihood estimates of the prior parameters. If the NAG library is available, routine E04JYF is used otherwise the search is done using optimize (in R) or nlminb (in S-plus). In the latter case, the likelihood values should be computed externally using the C code supplied as part of the CThresh package - although a pure R / S-plus version is available, it is very slow. This function will not usually be called directly by the user, but is called from within cthresh.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>pars</code></td>
<td>
<p>Estimates of the prior parameters. Each row of this matrix contains the following parameter estimates for one level of the transform: mixing weight; variance of the real part of the wavelet coefficients; covariance between the real and imaginary parts; variance of the imaginary part of the wavelet coefficients. Note that for levels below the primary resolution, this search is not done and the matrix is full of zeros.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>The covariance matrix as supplied to the function.</p>
</td></tr>
</table>


<h3>RELEASE</h3>

<p>Part of the CThresh addon to WaveThresh. Copyright Stuart Barber and Guy Nason 2004.
</p>


<h3>Note</h3>

<p>There may be warning messages from the NAG routine E04JYF. If the indicator variable IFAIL is equal to 5, 6, 7, or 8, then a solution has been found but there is doubt over the convergence. For IFAIL = 5, it is likely that the correct solution has been found, while IFAIL = 8 means that you should have little confidence in the parameter estimates. For more details, see the NAG software documentation available online at
<code>http://www.nag.co.uk/numeric/fl/manual19/pdf/E04/e04jyf_fl19.pdf</code>
</p>


<h3>Author(s)</h3>

<p>Stuart Barber</p>


<h3>See Also</h3>

<p><code><a href="#topic+cthresh">cthresh</a></code>
</p>

<hr>
<h2 id='first.last'>Build a first/last database for wavelet transforms.</h2><span id='topic+first.last'></span>

<h3>Description</h3>

<p>This function is not intended for user use, but is used by various functions involved in computing and displaying wavelet transforms. It basically constructs &quot;bookeeping&quot; vectors that <code>WaveThresh</code> uses for working out where coefficient vectors begin and end. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first.last(LengthH, DataLength, type, bc="periodic", current.scale=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="first.last_+3A_lengthh">LengthH</code></td>
<td>
<p>Length of the filter used to produce a wavelet decomposition.</p>
</td></tr> 
<tr><td><code id="first.last_+3A_datalength">DataLength</code></td>
<td>
<p>Length of the data before transforming. This must be a power of 2, say <code class="reqn">2^m</code>.</p>
</td></tr> 
<tr><td><code id="first.last_+3A_type">type</code></td>
<td>
<p>The type of wavelet transform. Can be &quot;wavelet&quot; or &quot;periodic&quot;</p>
</td></tr>
<tr><td><code id="first.last_+3A_bc">bc</code></td>
<td>
<p>This character string argument determines how the boundaries of the the function are to be handled. The permitted values are <code>periodic</code> or <code>symmetric</code>. </p>
</td></tr>
<tr><td><code id="first.last_+3A_current.scale">current.scale</code></td>
<td>
<p>Can handle a different initial scale, but usually
left at the default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose you begin with <code class="reqn">2^m=2048</code> coefficients. At the next level you would expect 1024 smoothed data coefficients, and 1024 wavelet coefficients, and if <code>bc="periodic"</code> this is indeed what happens. However, if <code>bc="symmetric"</code> you actually need more than 1024 (as the wavelets extend over the edges). The first last database keeps track of where all these &quot;extras&quot; appear and also where they are located in the packed vectors C and D of pyramidal coefficients within wavelet structures. 
</p>
<p>For examples, given a <code>first.last.c row</code> of 
</p>
<p style="text-align: center;"><code class="reqn">-2 3 20</code>
</p>

<p>The actual coefficients would be 
</p>
<p style="text-align: center;"><code class="reqn">c_{-2}, c_{-1}, c_{0}, c_{1}, c_{2}, c_{3}</code>
</p>

<p>In other words, there are 6 coefficients, starting at -2 and ending at 3, and the first of these (<code class="reqn">c_{-2}</code>) appears at an offset of 20 from the beginning of the <code>$C</code> component vector of the wavelet structure. 
</p>
<p>You can &ldquo;do&rdquo; <code>first.last</code> in your head for <code>periodic</code> boundary handling but for more general boundary treatments (e.g. <code>symmetric</code>) <code>first.last</code> is indispensable.
</p>


<h3>Value</h3>

<p>A first/last database structure, a list containing the following information: 
</p>
<table role = "presentation">
<tr><td><code>first.last.c</code></td>
<td>
<p>A (m+1)x3 matrix. The first column specifies the real index of the first coefficient of the smoothed data at a level, the 2nd column is the real index of the last coefficient, the last column specifies the offset of the first smoothed datum at that level. The offset is used by the C code to work out where the beginning of the sequence is within a packed vector of the pyramid structure. The first and 2nd columns can be used to work out how many numbers there are at a level. If <code>bc="periodic"</code> then the pyramid is a true power of 2 pyramid, that is it starts with a power of 2, and the next level is half of the previous. If <code>bc="symmetric"</code> then the pyramid is nearly exactly a power of 2, but not quite, see the Details section for why this is so. </p>
</td></tr>
<tr><td><code>ntotal</code></td>
<td>
<p>The total number of smoothed data/original data points.</p>
</td></tr> 
<tr><td><code>first.last.d</code></td>
<td>
<p>A mx3 matrix. As for <code>first.last.c</code> but for the wavelet coefficients packed as the D component of a wavelet structure.</p>
</td></tr> 
<tr><td><code>ntotal.d</code></td>
<td>
<p>The total number of wavelet coefficients.</p>
</td></tr> 
</table>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G.P. and Silverman, B.W. (1994). The discrete wavelet transform in S.</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr">wr</a></code>, <code><a href="#topic+wr.wd">wr.wd</a></code>, <code><a href="#topic+accessC">accessC</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+filter.select">filter.select</a></code>. <code><a href="#topic+imwd">imwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#If you're twisted then you may just want to look at one of these.
#
first.last(length(filter.select(2)), 64)
#$first.last.c:
#First Last Offset
#[1,]     0    0    126
#[2,]     0    1    124
#[3,]     0    3    120
#[4,]     0    7    112
#[5,]     0   15     96
#[6,]     0   31     64
#[7,]     0   63      0
#
#$ntotal:
#[1] 127
#
#$first.last.d:
#First Last Offset
#[1,]     0    0     62
#[2,]     0    1     60
#[3,]     0    3     56
#[4,]     0    7     48
#[5,]     0   15     32
#[6,]     0   31      0
#
#$ntotal.d:
#[1] 63
#
#
</code></pre>

<hr>
<h2 id='first.last.dh'>Build special first/last database for some wavelet density functions</h2><span id='topic+first.last.dh'></span>

<h3>Description</h3>

<p>This function builds a special first/last database for some of the
wavelet density estimation functions written by David Herrick and
described in his PhD thesis.
</p>
<p>See <code><a href="#topic+first.last">first.last</a></code> to see what this kind of function does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first.last.dh(LengthH, DataLength, type = "wavelet", bc = "periodic",
    firstk = c(0, DataLength - 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="first.last.dh_+3A_lengthh">LengthH</code></td>
<td>
<p>The length of the smoothing (C) filter</p>
</td></tr>
<tr><td><code id="first.last.dh_+3A_datalength">DataLength</code></td>
<td>
<p>The length of the data that you wish to transform</p>
</td></tr>
<tr><td><code id="first.last.dh_+3A_type">type</code></td>
<td>
<p>The type of wavelet transform, <code>wavelet</code> or <code>station</code>
for decimated and nondecimated transforms respectively.</p>
</td></tr>
<tr><td><code id="first.last.dh_+3A_bc">bc</code></td>
<td>
<p>Boundary conditions, <code>periodic</code> or <code>symmetric</code></p>
</td></tr>
<tr><td><code id="first.last.dh_+3A_firstk">firstk</code></td>
<td>
<p>The first k index, leave as default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all.
</p>


<h3>Value</h3>

<p>A list with several components in exactly the same format as
for <code><a href="#topic+first.last">first.last</a></code>.
</p>


<h3>Author(s)</h3>

<p>David Herrick</p>


<h3>See Also</h3>

<p><code><a href="#topic+dencvwd">dencvwd</a></code>,<code><a href="#topic+first.last">first.last</a></code>,<code><a href="#topic+wd.dh">wd.dh</a></code></p>

<hr>
<h2 id='firstdot'>Return the location of the first period character within a character string (for a vector of strings of arbitrary length). </h2><span id='topic+firstdot'></span>

<h3>Description</h3>

<p>Returns the index of the location of the first period character within a character string for a series of strings in a vector of character string of arbitrary length). 
</p>
<p>This is a subsidiary routine for <code><a href="#topic+rmget">rmget</a></code> and not really intended for user use. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstdot(s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="firstdot_+3A_s">s</code></td>
<td>
<p>Vector of character strings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A very simple function. It searches through a character string for the first period character and the returns the position of that period character. It performs this search for each of the character strings in the input vector. 
</p>


<h3>Value</h3>

<p>A vector of integers of the same length as the input vector. Each integer in the output vector is the index position of the first period character in the corresponding character string in the input vector. If a character string does not contain a period character then the corresponding output integer is zero. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (1998). Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum. <em>Technical Report</em>, Department of Mathematics University of Bristol/ Fachbereich Mathematik, Kaiserslautern.</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmget">rmget</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's find the first dot in the following strings...
#
firstdot("mary.had.a.little.lamb")
#[1] 5
#
# I.e. the first period was after "mary" -- the fifth character
#
# This following string doesn't have any periods in it.
#
firstdot("StellaArtois")
#[1] 0
#
# The function works on vectors of character strings
#
TopCricketAve &lt;- c("Don.Bradman", "Graeme.Pollock", "George.Headley",
	"Herbert.Sutcliffe", "Vinod.Kambli", "Javed.Miandad")
firstdot(TopCricketAve)
#[1] 4 7 7 8 6 6
</code></pre>

<hr>
<h2 id='FullWaveletCV'>Perform whole wavelet cross-validation in C code</h2><span id='topic+FullWaveletCV'></span>

<h3>Description</h3>

<p>Perform whole wavelet cross-validation in C code. This
routine equivalent to <code><a href="#topic+CWCV">CWCV</a></code> except that
more preparatory material is passed to C code for speed. 
</p>
<p>The major difference is that <b>only</b> the cross-validated wavelet
threshold is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FullWaveletCV(noisy, ll = 3, type = "soft", filter.number = 10, family =
    "DaubLeAsymm", tol = 0.01, verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FullWaveletCV_+3A_noisy">noisy</code></td>
<td>
<p>A vector of dyadic (power of two) length that contains the
noisy data that you wish to apply wavelet shrinkage by
cross-validation to.</p>
</td></tr>
<tr><td><code id="FullWaveletCV_+3A_ll">ll</code></td>
<td>
<p>The primary resolution that you wish to assume. No wavelet coefficients that are on coarser scales than ll will be thresholded.</p>
</td></tr>
<tr><td><code id="FullWaveletCV_+3A_type">type</code></td>
<td>
<p>this option specifies the thresholding type which can be &quot;hard&quot; or &quot;soft&quot;.</p>
</td></tr>
<tr><td><code id="FullWaveletCV_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to perform wavelet shrinkage by cross-validation.</p>
</td></tr>
<tr><td><code id="FullWaveletCV_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="FullWaveletCV_+3A_tol">tol</code></td>
<td>
<p>this specifies the convergence tolerance for the cross-validation optimization routine (a golden section search).</p>
</td></tr>
<tr><td><code id="FullWaveletCV_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the computations progress. Such messages are generally annoying so it is turned off by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>The cross-validated wavelet threshold.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+CWCV">CWCV</a></code></p>

<hr>
<h2 id='GenW'>Generate (inverse) discrete wavelet transform matrix.</h2><span id='topic+GenW'></span>

<h3>Description</h3>

<p>This function generates a matrix that can perform the discrete wavelet transform (useful for understanding the DWT but use the fast algorithm coded in <code><a href="#topic+wd">wd</a></code> for general use). The function returns the matrix for the inverse transform. Since the matrix is orthogonal transpose the matrix to obtain the forward transform matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenW(n=8, filter.number=10, family="DaubLeAsymm", bc="periodic")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenW_+3A_n">n</code></td>
<td>
<p>The order of the DWT matrix will be n times n. n should be a power of two.</p>
</td></tr> 
<tr><td><code id="GenW_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments.</p>
</td></tr> 
<tr><td><code id="GenW_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr> 
<tr><td><code id="GenW_+3A_bc">bc</code></td>
<td>
<p>boundary conditions to use. This can be <code>periodic</code> or <code>symmetric</code> depending on whether you want the returned matrix to assume periodic or symmetric end-reflection boundary conditions.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The discrete wavelet transform is usually computed using the fast pyramid algorithm of Mallat. However, the transform can be written in a matrix form and this is useful for understanding what the fast transform does. One wouldn't normally use the matrix for performing the transform but use the fast transform function <code><a href="#topic+wd">wd</a></code> instead. 
</p>
<p>The matrix returned by this function represents the inverse DWT. Since the matrix (and transform) is orthogonal one can obtain the matrix representation of the forward transform simply by transposing the matrix using the <code>t</code> function in S-Plus. 
</p>
<p>The returned matrix is organised as follows. The first column always corresponds to the linear combination corresponding to the scaling function coefficient (so the column is constant. The next <code>n/2</code> columns correspond to the finest scale wavelet coefficients; the next <code>n/4</code> columns to the next finest scale and so on until the last column which corresponds to the coarsest scale wavelet coefficients. 
</p>
<p>The matrix is computed by performing successive fast DWTs on unit vectors. 
</p>


<h3>Value</h3>

<p>A matrix of order <code>n</code> that contains the inverse discrete wavelet transform. 
</p>


<h3>RELEASE</h3>

<p>Version 3.2 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr">wr</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate the wavelet transform matrix corresponding to the Haar wavelet
# transform of order 8
#
haarmat &lt;- GenW(8, filter.number=1, family="DaubExPhase")
#
# Let's look at this matrix
#
#haarmat
#          [,1]       [,2]       [,3]       [,4]       [,5] [,6] [,7]       [,8] 
#[1,] 0.3535534  0.7071068  0.0000000  0.0000000  0.0000000  0.5  0.0  0.3535534
#[2,] 0.3535534 -0.7071068  0.0000000  0.0000000  0.0000000  0.5  0.0  0.3535534
#[3,] 0.3535534  0.0000000  0.7071068  0.0000000  0.0000000 -0.5  0.0  0.3535534
#[4,] 0.3535534  0.0000000 -0.7071068  0.0000000  0.0000000 -0.5  0.0  0.3535534
#[5,] 0.3535534  0.0000000  0.0000000  0.7071068  0.0000000  0.0  0.5 -0.3535534
#[6,] 0.3535534  0.0000000  0.0000000 -0.7071068  0.0000000  0.0  0.5 -0.3535534
#[7,] 0.3535534  0.0000000  0.0000000  0.0000000  0.7071068  0.0 -0.5 -0.3535534
#[8,] 0.3535534  0.0000000  0.0000000  0.0000000 -0.7071068  0.0 -0.5 -0.3535534
#
# As noted above the first column is the l.c. corresponding to the scaling
# function coefficient and then the l.c.s corresponding to the wavelet
# coefficients from the finest to the coarsest.
#
# The above matrix represented the inverse DWT. Let's compute the forward
# transform matrix representation:
#
#t(haarmat)
#          [,1]       [,2]       [,3]       [,4]       [,5]       [,6]       [,7]       [,8] 
#[1,] 0.3535534  0.3535534  0.3535534  0.3535534  0.3535534  0.3535534  0.3535534  0.3535534
#[2,] 0.7071068 -0.7071068  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000
#[3,] 0.0000000  0.0000000  0.7071068 -0.7071068  0.0000000  0.0000000  0.0000000  0.0000000
#[4,] 0.0000000  0.0000000  0.0000000  0.0000000  0.7071068 -0.7071068  0.0000000  0.0000000
#[5,] 0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.7071068 -0.7071068
#[6,] 0.5000000  0.5000000 -0.5000000 -0.5000000  0.0000000  0.0000000  0.0000000  0.0000000
#[7,] 0.0000000  0.0000000  0.0000000  0.0000000  0.5000000  0.5000000 -0.5000000 -0.5000000
#[8,] 0.3535534  0.3535534  0.3535534  0.3535534 -0.3535534 -0.3535534 -0.3535534 -0.3535534
#
#
</code></pre>

<hr>
<h2 id='getarrvec'>Compute and return weaving permutation for conversion from wst objects to wd class objects. </h2><span id='topic+getarrvec'></span>

<h3>Description</h3>

<p>Computes weaving permutation for conversion from <code><a href="#topic+wst">wst</a></code> objects to <code><a href="#topic+wd">wd</a></code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getarrvec(nlevels, sort=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getarrvec_+3A_nlevels">nlevels</code></td>
<td>
<p>The <code>number of levels</code> in the non-decimated transform for which the permutation is to be computed.</p>
</td></tr>
<tr><td><code id="getarrvec_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code> then compute permutation for indexing a <code><a href="#topic+wst">wst</a></code> object. If <code>FALSE</code> then compute permutation for indexing a <code>wd</code> object.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Conversion of <code><a href="#topic+wst">wst</a></code> objects into <code><a href="#topic+wd">wd</a></code> objects and vice versa can be carried out using the <code><a href="#topic+convert.wst">convert.wst</a></code> and <code><a href="#topic+convert.wd">convert.wd</a></code> functions. These latter functions depend on this getarrvec function to compute the permutation which maps coefficients from one ordering to the other. 
</p>
<p>This function returns a matrix which gives the necessary permutations for scale levels 1 to <code>nlevels-1</code>. If you want to get the permutation for the level 0 coefficients of the <code><a href="#topic+wst">wst</a></code> object you will have to call the <code><a href="#topic+levarr">levarr</a></code> function directly. 
</p>
<p>This permutation is described in Nason, Sapatinas and Sawczenko, 1998. 
</p>
<p>The function that actually computes the permutations is <code><a href="#topic+levarr">levarr</a></code>. This function just combines the results from <code><a href="#topic+levarr">levarr</a></code>. 
</p>


<h3>Value</h3>

<p>A matrix with <code>nlevel</code>s-1 columns. Column 1 corresponds to scale level <code>nlevels-1</code> in the <code><a href="#topic+wst">wst</a></code> object, and column <code>nlevels-1</code> corresponds to scale level 1 in the <code><a href="#topic+wst">wst</a></code> object. Replace <code><a href="#topic+wst">wst</a></code> by <code><a href="#topic+wd">wd</a></code> if <code>sort=FALSE</code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+convert">convert</a></code>, <code><a href="#topic+convert.wd">convert.wd</a></code>, <code><a href="#topic+convert.wst">convert.wst</a></code>, <code><a href="#topic+levarr">levarr</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+wpst">wpst</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# What would the permutation be for a wst
# object with 4 levels?
#
arrvec &lt;- getarrvec(4)
#arrvec
#      [,1] [,2] [,3] 
# [1,]    1    1    1
# [2,]    9    9    9
# [3,]    2    5    5
# [4,]   10   13   13
# [5,]    3    2    3
# [6,]   11   10   11
# [7,]    4    6    7
# [8,]   12   14   15
# [9,]    5    3    2
#[10,]   13   11   10
#[11,]    6    7    6
#[12,]   14   15   14
#[13,]    7    4    4
#[14,]   15   12   12
#[15,]    8    8    8
#[16,]   16   16   16
#
# The permutation for level 3 is in column 1
# The permutation for level 2 is in column 2
# The permutation for level 1 is in column 3.
#
# The following shows that the above is the right permutation (for level 2
# at least.
#
# Start off with some random normal data!
#
myrand &lt;- rnorm(1:16)
#
# Now take both the time ordered non-decimated wavelet
# transform and the packet ordered non-decimated wavelet
# transform.
#
myrwdS &lt;- wd(myrand, type="station")
myrwst &lt;- wst(myrand)
#
# Let's look at the level 2 coefficients of myrwdS
#
accessD(myrwdS, level=2)
# [1] -0.73280829 -0.97892279  1.33305777  1.46320165 -0.94790098
# [6] -1.39276215  0.40023757  0.82517249 -0.56317955 -0.89408713
#[11]  0.77166463  1.56204870 -0.34342230 -1.64133182  0.08235115
#[16]  1.05668106
#
# Let's look at the level 2 coefficients of myrwst
#
accessD(myrwst, level=2)
# [1] -0.73280829 -0.94790098 -0.56317955 -0.34342230  1.33305777
# [6]  0.40023757  0.77166463  0.08235115 -0.97892279 -1.39276215
#[11] -0.89408713 -1.64133182  1.46320165  0.82517249  1.56204870
#[16]  1.05668106
#
# O.k. So the coefficients are the same, but they are not in the
# same order as in myrwdS. So let's use the permutation in the
# second column of arrvec to reorder the myrwst coefficients
# to have the same order as the myrwdS ones
#
accessD(myrwst, level=2)[arrvec[,2]]
# [1] -0.73280829 -0.97892279  1.33305777  1.46320165 -0.94790098
# [6] -1.39276215  0.40023757  0.82517249 -0.56317955 -0.89408713
#[11]  0.77166463  1.56204870 -0.34342230 -1.64133182  0.08235115
#[16]  1.05668106
#
# These coefficients have the correct ordering.
</code></pre>

<hr>
<h2 id='getpacket'>Get a packet of coefficients from a wavelet object</h2><span id='topic+getpacket'></span>

<h3>Description</h3>

<p>This generic function extracts packets of coefficients from various types of wavelet objects. 
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist. For objects of class: 
</p>

<dl>
<dt>wp</dt><dd><p>use the <code><a href="#topic+getpacket.wp">getpacket.wp</a></code> method.</p>
</dd> 
<dt>wst</dt><dd><p>use the <code><a href="#topic+getpacket.wst">getpacket.wst</a></code> method.</p>
</dd> 
<dt>wpst</dt><dd><p>use the <code><a href="#topic+getpacket.wpst">getpacket.wpst</a></code> method.</p>
</dd>
</dl>

<p>See individual method help pages for operation and examples. 
</p>
<p>Use the <code><a href="#topic+accessC">accessC</a></code> and <code><a href="#topic+accessD">accessD</a></code> function to extract whole resolution levels of coefficients simultaneously. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getpacket(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getpacket_+3A_...">...</code></td>
<td>
<p>See individual help pages for details.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>The packet of coefficients requested. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+getpacket.wp">getpacket.wp</a></code>, <code><a href="#topic+getpacket.wst">getpacket.wst</a></code>, <code><a href="#topic+getpacket.wpst">getpacket.wpst</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+accessC">accessC</a></code>. 
</p>

<hr>
<h2 id='getpacket.wp'>Get packet of coefficients from a wavelet packet object (wp).</h2><span id='topic+getpacket.wp'></span>

<h3>Description</h3>

<p>This function extracts and returns a packet of coefficients from a wavelet packet (<code><a href="#topic+wp">wp</a></code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
getpacket(wp, level, index, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getpacket.wp_+3A_wp">wp</code></td>
<td>
<p>Wavelet packet object from which you wish to extract the packet from.</p>
</td></tr> 
<tr><td><code id="getpacket.wp_+3A_level">level</code></td>
<td>
<p>The resolution level of the coefficients that you wish to extract.</p>
</td></tr> 
<tr><td><code id="getpacket.wp_+3A_index">index</code></td>
<td>
<p>The index number within the resolution level of the packet of coefficients that you wish to extract.</p>
</td></tr> 
<tr><td><code id="getpacket.wp_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+wp">wp</a></code> produces a wavelet packet object. The coefficients in this structure can be organised into a binary tree with each node in the tree containing a packet of coefficients. 
</p>
<p>Each packet of coefficients is obtained by chaining together the effect of the <em>two packet operators</em> DG and DH: these are the high and low pass quadrature mirror filters of the Mallat pyramid algorithm scheme followed by decimation (see Mallat~(1989b)). 
</p>
<p>Starting with data <code class="reqn">c^J</code> at resolution level J containing
<code class="reqn">2^J</code> data points the wavelet packet algorithm operates as follows.
First DG and DH are applied to <code class="reqn">c^J</code> producing
<code class="reqn">d^{J-1}</code> and <code class="reqn">c^{J-1}</code> respectively.
Each of these sets of coefficients is of length one half of the original data:
i.e. <code class="reqn">2^{J-1}</code>.
Each of these sets of coefficients is a set of
<em>wavelet packet coefficients</em>.
The algorithm then applies both DG and DH to both
<code class="reqn">d^{J-1}</code> and <code class="reqn">c^{J-1}</code> to form a four sets of coefficients at level
J-2. Both operators are used again on the four sets to produce 8 sets, then again on the 8 sets to form 16 sets and so on. At level j=J,...,0 there are
<code class="reqn">2^{J-j}</code> packets of coefficients each containing <code class="reqn">2^j</code> coefficients. 
</p>
<p>This function enables whole packets of coefficients to be extracted at any resolution level. The index argument chooses a particular packet within each level and thus ranges from 0 (which always refer to the father wavelet coefficients), 1 (which always refer to the mother wavelet coefficients) up to <code class="reqn">2^{J-j}</code>. 
</p>


<h3>Value</h3>

<p>A vector containing the packet of wavelet packet coefficients that you wished to extract. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wp">wp</a></code>, <code><a href="#topic+putpacket.wp">putpacket.wp</a></code>, <code><a href="#topic+basisplot.wp">basisplot.wp</a></code>, <code><a href="#topic+draw.wp">draw.wp</a></code>, <code><a href="#topic+InvBasis.wp">InvBasis.wp</a></code>, <code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code>, <code>nlevelsWT.wp</code>, <code><a href="#topic+plot.wp">plot.wp</a></code>. <code><a href="#topic+threshold.wp">threshold.wp</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Take the wavelet packet transform of some random data
#
MyWP &lt;- wp(rnorm(1:512))
#
# The above data set was 2^9 in length. Therefore there are
# coefficients at resolution levels 0, 1, 2, ..., and 8.
#
# The high resolution coefficients are at level 8.
# There should be 256 DG coefficients and 256 DH coefficients
#
length(getpacket(MyWP, level=8, index=0))
#[1] 256
length(getpacket(MyWP, level=8, index=1))
#[1] 256
#
# The next command shows that there are only two packets at level 8
#
## Not run: getpacket(MyWP, level=8, index=2)
#Index was too high, maximum for this level is  1 
#Error in getpacket.wp(MyWP, level = 8, index = 2): Error occured
#Dumped
#
# There should be 4 coefficients at resolution level 2
#
# The father wavelet coefficients are (index=0)
getpacket(MyWP, level=2, index=0)
#[1] -0.9736576  0.5579501  0.3100629 -0.3834068
#
# The mother wavelet coefficients are (index=1)
#
#[1]  0.72871405  0.04356728 -0.43175307  1.77291483
#
# There will be 127 packets at this level.
#
</code></pre>

<hr>
<h2 id='getpacket.wpst'>Get packet of coefficients from a non-decimated wavelet packet object (wpst). </h2><span id='topic+getpacket.wpst'></span>

<h3>Description</h3>

<p>This function extracts and returns a packet of coefficients from a non-decimated wavelet packet (<code><a href="#topic+wpst">wpst</a></code>) object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wpst'
getpacket(wpst, level, index, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getpacket.wpst_+3A_wpst">wpst</code></td>
<td>
<p>Non-decimated wavelet packet object from which you wish to extract the packet from.</p>
</td></tr> 
<tr><td><code id="getpacket.wpst_+3A_level">level</code></td>
<td>
<p>The resolution level of the coefficients that you wish to extract. Can range from 0 to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wpst). The coefficients at level <code><a href="base.html#topic+nlevels">nlevels</a></code> are the data the created the <code>wpst.object</code>. 
</p>
</td></tr>
<tr><td><code id="getpacket.wpst_+3A_index">index</code></td>
<td>
<p>The index number within the resolution level of the packet of coefficients that you wish to extract. Index ranges from 0 to
<code class="reqn">(4^r)-1</code> where <code>r = nlevelsWT - level</code>. </p>
</td></tr>
<tr><td><code id="getpacket.wpst_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+wpst">wpst</a></code> transform produces a non-decimated wavelet packet object. This is a &quot;cross&quot; between a <code>wavelet packet</code> object and a <code>non-decimated wavelet</code> object. In other words the transform produces <em>wavelet packet</em> coefficients at every possible integer shift (unlike the ordinary wavelet packet transform which is aligned to a dyadic grid). 
</p>
<p>Each packet of coefficients is obtained by chaining together the effect of the two <em>packet operators</em> DG and DH: these are the high and low pass quadrature mirror filters of the Mallat pyramid algorithm scheme followed by both even <em>and</em> odd decimation. For a full description of this algorithm and how coefficients are stored within see Nason, Sapatinas and Sawczenko, 1998. 
</p>
<p>Note that this function extracts <em>packets</em>. If you want to obtain the wavelet packet coefficients for each shift you need to use the <code><a href="#topic+accessD.wpst">accessD.wpst</a></code>function. This function extracts particular wavelet packet coefficients for a particular shift. In particular, this function returns a number of coefficients dependent on the scale level requested whereas <code><a href="#topic+accessD.wpst">accessD.wpst</a></code> always returns a vector of coefficients of length equal to the input data that created the <code>wpst.object</code> initially. 
</p>


<h3>Value</h3>

<p>A vector containing the packet of non-decimated wavelet packet coefficients that you wished to extract. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessD.wpst">accessD.wpst</a></code>, <code><a href="#topic+wpst">wpst</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Create some random data
#
myrand &lt;- rnorm(16)
#myrand
# [1]  0.19268626 -0.41737181 -0.30806613  0.07435407  0.99871757
# [6] -0.58935121 -1.38049759 -0.13346631  1.55555403 -1.60581265
#[11]  0.14353621  1.21277774  1.13762337 -1.08577934 -0.29745609
#[16]  0.50977512
#
# Do the non-decimated wavelet packet transform
#
myrwpst &lt;- wpst(myrand)
#
# Let's access what is a level nlevelsWT(myrwpst)
#
getpacket(myrwpst, nlevelsWT(myrwpst), index=0)
# [1]  0.19268626 -0.41737181 -0.30806613  0.07435407  0.99871757
# [6] -0.58935121 -1.38049759 -0.13346631  1.55555403 -1.60581265
#[11]  0.14353621  1.21277774  1.13762337 -1.08577934 -0.29745609
#[16]  0.50977512
#
# I.e. the data that created the object.
#
# How about extracting the 3rd (last) packet at level 3?
#
getpacket(myrwpst, 3, index=3)
#[1] -2.660657144  0.688415755 -1.764060698  0.717267105 -0.206916242
#[6] -0.659983747  0.005836952 -0.196874007
#
# Of course, there are only 8 coefficients at this level.
</code></pre>

<hr>
<h2 id='getpacket.wst'>Get packet of coefficients from a packet ordered non-decimated wavelet object (wst).</h2><span id='topic+getpacket.wst'></span>

<h3>Description</h3>

<p>This function extracts and returns a packet of coefficients from a packet-ordered non-decimated wavelet object (<code><a href="#topic+wst">wst</a></code>) object. The <code><a href="#topic+wst">wst</a></code> objects are computed by the <code><a href="#topic+wst">wst</a></code> function amongst others. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
getpacket(wst, level, index, type="D", aspect, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getpacket.wst_+3A_wst">wst</code></td>
<td>
<p>Packet-ordered non-decimated wavelet object from which you wish to extract the packet from.</p>
</td></tr> 
<tr><td><code id="getpacket.wst_+3A_level">level</code></td>
<td>
<p>The resolution level of the coefficients that you wish to extract.</p>
</td></tr> 
<tr><td><code id="getpacket.wst_+3A_index">index</code></td>
<td>
<p>The index number within the resolution level of the packet of coefficients that you wish to extract.</p>
</td></tr> 
<tr><td><code id="getpacket.wst_+3A_type">type</code></td>
<td>
<p>This argument must be either &quot;<code>C</code>&quot; or &quot;<code>D</code>&quot;. If the argument is &quot;<code>C</code>&quot; then non-decimated father wavelet coefficients corresponding to the packet that you want are returned. If the argument is &quot;<code>D</code>&quot; then non-decimated mother wavelet coefficients are returned. </p>
</td></tr>
<tr><td><code id="getpacket.wst_+3A_aspect">aspect</code></td>
<td>
<p>Function applied to the coefficients before return.
This is suppled as a character string which gets converted to
a function to apply. For example, &quot;Mod&quot; for complex-valued
coefficients returns the absolute values.</p>
</td></tr>
<tr><td><code id="getpacket.wst_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+wst">wst</a></code> function produces a packet-ordered non-decimated wavelet object: <code><a href="#topic+wst">wst</a></code>. The coefficients in this structure can be organised into a binary tree with each node in the tree containing a packet of coefficients. 
</p>
<p>Each packet is obtained by repeated application of the usual DG quadrature mirror filter with both even and odd dyadic decimation. See the detailed description given in Nason and Silverman, 1995. 
</p>
<p>This function enables whole packets of coefficients to be extracted at any resolution level. The index argument chooses a particular packet within each level and thus ranges from 0 to <code class="reqn">2^{J-j}</code> for j=0,..., J-1. Each packet corresponds to the wavelet coefficients with respect to different origins. 
</p>
<p>Note that both mother and father wavelet coefficient at different shifts are available by using the type argument. 
</p>


<h3>Value</h3>

<p>A vector containing the packet of packet-ordered non-decimated wavelet coefficients that you wished to extract. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Take the packet-ordered non-decimated transform of some random data 
#
MyWST &lt;- wst(rnorm(1:512))
#
# The above data set was 2^9 in length. Therefore there are
# coefficients at resolution levels 0, 1, 2, ..., and 8.
#
# The high resolution coefficients are at level 8.
# There should be 256 coefficients at level 8 in index location 0 and 1.
#
length(getpacket(MyWST, level=8, index=0))
#[1] 256
length(getpacket(MyWST, level=8, index=1))
#[1] 256
#
# There are also 256 FATHER wavelet coefficients at each of these two indices
# (origins)
#
length(getpacket(MyWST, level=8, index=0, type="C"))
#[1] 256
length(getpacket(MyWST, level=8, index=1, type="C"))
#[1] 256
#
# There should be 4 coefficients at resolution level 2
#
getpacket(MyWST, level=2, index=0)
#[1] -0.92103095  0.70125471  0.07361174 -0.43467375
#
# Here are the equivalent father wavelet coefficients
#
getpacket(MyWST, level=2, index=0, type="C")
#[1] -1.8233506 -0.2550734  1.9613138  1.2391913
</code></pre>

<hr>
<h2 id='getpacket.wst2D'>Get packet of coefficients from a two-dimensional non-decimated wavelet object (wst2D).</h2><span id='topic+getpacket.wst2D'></span>

<h3>Description</h3>

<p>This function extracts and returns a packet of coefficients from a two-dimensional non-decimated wavelet (<code><a href="#topic+wst2D">wst2D</a></code>) object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst2D'
getpacket(wst2D, level, index, type="S", Ccode=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getpacket.wst2D_+3A_wst2d">wst2D</code></td>
<td>
<p>2D non-decimated wavelet object from which you wish to extract a packet from.</p>
</td></tr> 
<tr><td><code id="getpacket.wst2D_+3A_level">level</code></td>
<td>
<p>The resolution level of the coefficients that you wish to extract. Can range from 0 to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wpst)-1.</p>
</td></tr> 
<tr><td><code id="getpacket.wst2D_+3A_index">index</code></td>
<td>
<p>The index number within the resolution level of the packet of coefficients that you wish to extract. Index is a base-4 number which is r digits long. Each digit can be 0, 1, 2 or 3 corresponding to no shifts, horizontal shift, vertical shift or horizontal and vertical shifts. The number r indicates the depth of the resolution level from the data resolution i.e. where <code>r = nlevelsWT - level</code>.
</p>
<p>Where there is a string of more than one digit the left most digits correspond to finest scale shift selection, the right most digits to the coarser scales (I think).</p>
</td></tr>
<tr><td><code id="getpacket.wst2D_+3A_type">type</code></td>
<td>
<p>This is a one letter character string: one of &quot;S&quot;, &quot;H&quot;, &quot;V&quot; or &quot;D&quot; for the smooth coefficients, horizontal, vertical or diagonal detail.</p>
</td></tr> 
<tr><td><code id="getpacket.wst2D_+3A_ccode">Ccode</code></td>
<td>
<p>If <code>T</code> then fast C code is used to obtain the packet, otherwise slow SPlus code is used. Unless you have some special reason always use the C code (and leave the argument at its default).</p>
</td></tr> 
<tr><td><code id="getpacket.wst2D_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+wst2D">wst2D</a></code> function creates a <code><a href="#topic+wst2D">wst2D</a></code> class object. Starting with a smooth the operators H, G, GS and HS (where G, H are the usual Mallat operators and S is the shift-by-one operator) are operated first on the rows and then the columns: i.e. so each of the operators HH, HG, GH, GG, HSH, HSG, GSH, GSG HHS, GHS, HGS, GGS HSHS, HSGS, GSHS and GSGS are applied. Then the same collection of operators is applied to all the derived smooths, i.e. HH, HSH, HHS and HSHS. 
</p>
<p>So the next level is obtained from the previous level with basically HH, HG, GH and GG but with extra shifts in the horizontal, vertical and horizontal and vertical directions. The index provides a way to enumerate the paths through this tree where each smooth has 4 children and indexed by a number between 0 and 3. 
</p>
<p>Each of the 4 children has 4 components: a smooth, horizontal, vertical and diagonal detail, much in the same way as for the Mallat 2D wavelet transform implemented in the WaveThresh function <code><a href="#topic+imwd">imwd</a></code>. 
</p>


<h3>Value</h3>

<p>A matrix containing the packet of the 2D non-decimated wavelet coefficients that you require. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+putpacket.wst2D">putpacket.wst2D</a></code>, <code><a href="#topic+wst2D">wst2D</a></code>, <code><a href="#topic+wst2D.object">wst2D.object</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Create a random image. 
#
myrand &lt;- matrix(rnorm(16), nrow=4, ncol=4)
#myrand
#            [,1]       [,2]        [,3]       [,4] 
#[1,]  0.01692807  0.1400891 -0.38225727  0.3372708
#[2,] -0.79799841 -0.3306080  1.59789958 -1.0606204
#[3,]  0.29151629 -0.2028172 -0.02346776  0.5833292
#[4,] -2.21505532 -0.3591296 -0.39354119  0.6147043
#
# Do the 2D non-decimated wavelet transform
#
myrwst2D &lt;- wst2D(myrand)
#
# Let's access the finest scale detail, not shifted in the vertical
# direction.
#
getpacket(myrwst2D, nlevelsWT(myrwst2D)-1, index=0, type="V")
#           [,1]       [,2] 
#[1,] -0.1626819 -1.3244064
#
# Compare this to the ordinary 2D DWT for the vertical detail at this
# resolution level
imwd(myrand)[[lt.to.name( 1, "DC")]]
#[1] -0.1626819 -1.3244064  1.4113247 -0.7383336
#
# The same numbers but they're not in matrix format because
# imwd returns vectors not matrices.
#
# Now back to the wst2D object. Let's
# extract vertical detail again at level 1 but this time the horizontally
# shifted data.
#
getpacket(myrwst2D, level=1, index=1, type="V")
#           [,1]      [,2] 
#[1,] -0.5984427 0.2599445
#[2,] -0.6502002 1.8027955
#
# So, yes, different data. Now how about at a deeper resolution level.
# Lets have a horizontal shift, as before, for the level 1 but follow it
# with a diagonal shift and this time extract the smooth component:
#
getpacket(myrwst2D, level=0, index=13, type="S")
#           [,1] 
#[1,] -0.5459394
#
# Of course, only one number because this is at level 0
</code></pre>

<hr>
<h2 id='GetRSSWST'>Computes estimate of error for function estimate. </h2><span id='topic+GetRSSWST'></span>

<h3>Description</h3>

<p>Computes estimate of error for function estimate. Given noisy data and a threshold value this function uses Nason's 1996 two-fold cross-validation algorithm, but using packet ordered non-decimated wavelet transforms to compute two estimates of an underlying &ldquo;true&rdquo; function and uses them to compute an estimate of the error in estimating the truth. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetRSSWST(ndata, threshold, levels, family = "DaubLeAsymm", 
	filter.number = 10, type = "soft", norm = l2norm, verbose = 0, 
	InverseType = "average")

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetRSSWST_+3A_ndata">ndata</code></td>
<td>
<p>the noisy data. This is a vector containing the signal plus noise. The length of this vector should be a power of two.</p>
</td></tr> 
<tr><td><code id="GetRSSWST_+3A_threshold">threshold</code></td>
<td>
<p>the value of the threshold that you wish to compute the error of the estimate at</p>
</td></tr> 
<tr><td><code id="GetRSSWST_+3A_levels">levels</code></td>
<td>
<p>the levels over which you wish the threshold value to be computed (the threshold that is used in computing the estimate and error in the estimate). See the explanation for this argument in the <code><a href="#topic+threshold.wst">threshold.wst</a></code> function. </p>
</td></tr>
<tr><td><code id="GetRSSWST_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr> 
<tr><td><code id="GetRSSWST_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments.</p>
</td></tr> 
<tr><td><code id="GetRSSWST_+3A_type">type</code></td>
<td>
<p>whether to use hard or soft thresholding. See the explanation for this argument in the <code><a href="#topic+threshold.wst">threshold.wst</a></code> function.</p>
</td></tr>
<tr><td><code id="GetRSSWST_+3A_norm">norm</code></td>
<td>
<p>which measure of distance to judge the dissimilarity between the estimates. The functions <code><a href="#topic+l2norm">l2norm</a></code> and <code><a href="#topic+linfnorm">linfnorm</a></code> are suitable examples.</p>
</td></tr> 
<tr><td><code id="GetRSSWST_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then informative messages are printed during the progression of the function, otherwise they are not.</p>
</td></tr> 
<tr><td><code id="GetRSSWST_+3A_inversetype">InverseType</code></td>
<td>
<p>The possible options are &quot;average&quot; or &quot;minent&quot;. The former uses basis averaging to form estimates of the unknown function. The &quot;minent&quot; function selects a basis using the Coifman and Wickerhauser, 1992 algorithm to select a basis to invert.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function implements the component of the cross-validation method detailed by Nason, 1996 for computing an estimate of the error between an estimate and the &ldquo;truth&rdquo;. The difference here is that it uses the packet ordered non-decimated wavelet transform rather than the standard Mallat <code><a href="#topic+wd">wd</a></code> discrete wavelet transform. As such it is an examples of the translation-invariant denoising of Coifman and Donoho, 1995 but uses cross-validation to choose the threshold rather than SUREshrink. 
</p>
<p>Note that the procedure outlined above can use <code><a href="#topic+AvBasis">AvBasis</a></code> basis averaging or basis selection and inversion using the Coifman and Wickerhauser, 1992 best-basis algorithm 
</p>


<h3>Value</h3>

<p>A real number which is estimate of the error between estimate and truth at the given threshold. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1995 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+linfnorm">linfnorm</a></code>, <code><a href="#topic+linfnorm">linfnorm</a></code>, <code><a href="#topic+wstCV">wstCV</a></code>, <code><a href="#topic+wstCVl">wstCVl</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# This function performs the error estimation step for the
# \code{\link{wstCV}} function and so is not intended for
# user use. 
#


</code></pre>

<hr>
<h2 id='griddata+20objects'>Data interpolated to a grid objects.</h2><span id='topic+griddata+20objects'></span>

<h3>Description</h3>

<p>These are objects of classes 
</p>
<p><code>griddata</code>
</p>
<p>These objects store the results of interpolating a 1-D regression data set to a grid which is a power of two in length
</p>


<h3>Details</h3>

<p>The help page for <code><a href="#topic+makegrid">makegrid</a></code> and Kovac, (1997), p.81 give further details about how a <code>griddata</code> object is constructed. 
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate griddata object. 
</p>
<table role = "presentation">
<tr><td><code>gridt</code></td>
<td>
<p>a vector containing the values of the grid on the &quot;x&quot; axis.</p>
</td></tr>
<tr><td><code>gridy</code></td>
<td>
<p>a vector containing the values of the grid on the &quot;y&quot; axis. This vector has to be the same length as gridt. Typically the values in (<code>gridt, gridy</code>) are the results of interpolating arbitrary data (<code>x,y</code>) onto (<code>gridt, gridy</code>).</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Codes the value of the linear interpolant matrix for the corresponding entry in <code>gridt</code>. The value at each point corresponds to the proportion of the original data point pointed to by <code>Gindex</code> that contributes to the new value at the corresponding <code>gridt</code> value. See Kovac, (1997), page 81 for further information.</p>
</td></tr>
<tr><td><code>Gindex</code></td>
<td>
<p>Each entry in <code>Gindex</code> refers to one of the pairs in (<code>x,y</code>) which is contributing to the (<code>gridt, gridy</code>) interpolant. See previous help for <code>G</code>.</p>
</td></tr> 
</table>


<h3>GENERATION</h3>

<p>This class of objects is returned from the <code><a href="#topic+makegrid">makegrid</a></code> function to represent the results of interpolating a 1-D regression data set to a grid.</p>


<h3>METHODS</h3>

<p>The <code>griddata</code> class of objects really on has one function that uses it: <code><a href="#topic+irregwd">irregwd</a></code>.</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 Copyright Arne Kovac 1997
Copyright Guy Nason (help pages) 1999.  
</p>


<h3>SEE ALSO</h3>

<p><code><a href="#topic+makegrid">makegrid</a></code>, <code><a href="#topic+irregwd">irregwd</a></code>
</p>


<h3>Author(s)</h3>

<p>Arne Kovac</p>

<hr>
<h2 id='guyrot'>Cyclically rotate elements of a vector</h2><span id='topic+guyrot'></span>

<h3>Description</h3>

<p>This function shifts (or rotates) the elements of the input vector in a cyclic fashion (end periodicity is used).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guyrot(v, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guyrot_+3A_v">v</code></td>
<td>
<p>Vector whose elements you wish to rotate</p>
</td></tr>
<tr><td><code id="guyrot_+3A_n">n</code></td>
<td>
<p>Integer determining the amount to rotate, can be negative</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A very simple function which cyclically shifts the elements of a vector. Not necessarily intended as a top level user function but it is a useful little function.
</p>


<h3>Value</h3>

<p>A vector containing the shifted or rotated coefficients.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpst2discr">wpst2discr</a></code>,
<code><a href="#topic+wpstCLASS">wpstCLASS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Start off with an example vector
#
v &lt;- c(1,2,3,4,5,6)
#
# Rotate it one element to the right, rightmost element gets rotated round
# to be first element.
#
guyrot(v,1)
# [1] 6 1 2 3 4 5
#
# Rotate v two spaces to the left, leftmost two elements get rotated around
# to be new last elements
guyrot(v, -2)
#
# [1] 3 4 5 6 1 2
#
#
# Now issue a larger rotation, e.g. 19!
#
guyrot(v,19)
# [1] 6 1 2 3 4 5
#
# Its just the same as rotating by 1 since the input vector is of length 6
# and so rotating by 19 is the same as rotating by 6,6,6, and then 1!
#
</code></pre>

<hr>
<h2 id='HaarConcat'>Generate a concatenated Haar MA process</h2><span id='topic+HaarConcat'></span>

<h3>Description</h3>

<p>This function generates a particular set of four concatenated Haar MA
processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HaarConcat()
</code></pre>


<h3>Arguments</h3>

<p>None
</p>


<h3>Details</h3>

<p>This function generates a realization of particular kind of non-stationary time series probability model. The returned time series is the result of concatenating 4 time series each of length 128 from the Haar MA process generator
(<code><a href="#topic+HaarMA">HaarMA</a></code>) of orders 1, 2, 3 and 4.
The standard deviation of the innovations is 1.
This function was used to generate the figure of the concatenated Haar MA process in Nason, von Sachs and Kroisandt. It produces a kind of time series that can be sparsely represented by the wavelet machinery but at the same time is non-stationary.
</p>
<p>See Nason, von Sachs and Kroisandt (2000) Wavelet processes and adaptive
estimation of the evolutionary wavelet spectrum.
<em>J R Statist Soc, B</em>, <b>62</b>, 271-292.
</p>


<h3>Value</h3>

<p>A vector containing 512 observations from four concatenated Haar MA processes
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+HaarMA">HaarMA</a></code>,<code><a href="#topic+ewspec">ewspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate the concatenated Haar MA process.
#
MyHaarCC &lt;- HaarConcat()
#
# Plot it
#
## Not run: ts.plot(MyHaarCC)
</code></pre>

<hr>
<h2 id='HaarMA'>Generate Haar MA processes.</h2><span id='topic+HaarMA'></span>

<h3>Description</h3>

<p>This function generates an arbitrary number of observations from a Haar MA process of any order with a particular variance. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HaarMA(n, sd=1, order=5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HaarMA_+3A_n">n</code></td>
<td>
<p>The number of observations in the realization that you want to create. Note that n does NOT have to be a power of two.</p>
</td></tr>
<tr><td><code id="HaarMA_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the innovations.</p>
</td></tr> 
<tr><td><code id="HaarMA_+3A_order">order</code></td>
<td>
<p>The order of the Haar MA process.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>A Haar MA process is a special kind of time series moving-average (MA) process. A Haar MA process of order k is a MA process of order
<code class="reqn">2^k</code>. The coefficients of the Haar MA process are given by the filter coefficients of the discrete Haar wavelet at different scales. 
</p>
<p>For examples: the Haar MA process of order 1 is an MA process of order 2.
The coefficients are <code class="reqn">1/\sqrt{2}</code> and
<code class="reqn">-1/\sqrt{2}</code>.
The Haar MA process of order 2 is an MA process of order 4. The coefficients are 1/2, 1/2, -1/2, -1/2 and so on. It is possible to define other processes for other wavelets as well. 
</p>
<p>Any Haar MA process is a good examples of a (stationary) LSW process because it is sparsely representable by the locally-stationary wavelet machinery defined in Nason, von Sachs and Kroisandt.
</p>


<h3>Value</h3>

<p>A vector containing a realization of a Haar MA process of the specified order, standard deviation and number of observations. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (1998). Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum. <em>Technical Report</em>, Department of Mathematics University of Bristol/ Fachbereich Mathematik, Kaiserslautern.</p>


<h3>See Also</h3>

<p><code><a href="#topic+HaarConcat">HaarConcat</a></code>, <code><a href="#topic+ewspec">ewspec</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate a Haar MA process of order 1 (high frequency series)
#
MyHaarMA &lt;- HaarMA(n=151, sd=2, order=1)
#
# Plot it
#
## Not run: ts.plot(MyHaarMA)
#
# Generate another Haar MA process of order 3 (lower frequency), but of
# smaller variance
#
MyHaarMA2 &lt;- HaarMA(n=151, sd=1, order=3)
#
# Plot it
#
## Not run: ts.plot(MyHaarMA2)
#
# Let's plot them next to each other so that you can really see the
# differences.
# 
# Plot a vertical dotted line which indicates where the processes are
# joined
#
## Not run: ts.plot(c(MyHaarMA, MyHaarMA2))
## Not run: abline(v=152, lty=2)
</code></pre>

<hr>
<h2 id='image.wd'>Produce image representation of nondecimated wavelet transform</h2><span id='topic+image.wd'></span>

<h3>Description</h3>

<p>Produces a representation of a nondecimated wavelet transform (time-ordered)
as an image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
image(x, strut = 10, type = "D", transform = I, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image.wd_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+wd.object">wd.object</a></code> that you wish to image</p>
</td></tr>
<tr><td><code id="image.wd_+3A_strut">strut</code></td>
<td>
<p>The width of each coefficient in the image</p>
</td></tr>
<tr><td><code id="image.wd_+3A_type">type</code></td>
<td>
<p>Either &quot;C&quot; or &quot;D&quot; depending if you wish to image scaling
function or wavelet coefficients respectively</p>
</td></tr>
<tr><td><code id="image.wd_+3A_transform">transform</code></td>
<td>
<p>Apply a numerical transform to the coefficients before
display</p>
</td></tr>
<tr><td><code id="image.wd_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+logabs">logabs</a></code>, <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>,<code><a href="#topic+wd">wd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- wd(rnorm(256), type="station")
## Not run: image(tmp)
</code></pre>

<hr>
<h2 id='image.wst'>Produce image representation of a wst class object</h2><span id='topic+image.wst'></span>

<h3>Description</h3>

<p>Produces an image representation of the coefficients contained within
a <code><a href="#topic+wst.object">wst.object</a></code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
image(x, nv, strut = 10, type = "D", transform = I, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image.wst_+3A_x">x</code></td>
<td>
<p>The wst object you wish to image</p>
</td></tr>
<tr><td><code id="image.wst_+3A_nv">nv</code></td>
<td>
<p>An associated node vector, this argument is no longer used
and should be omitted (in the S version it permitted coloration
of particular bases)</p>
</td></tr>
<tr><td><code id="image.wst_+3A_strut">strut</code></td>
<td>
<p>The number of pixels/width that each coefficient should be
drawn with</p>
</td></tr>
<tr><td><code id="image.wst_+3A_type">type</code></td>
<td>
<p>Either &quot;C&quot; or &quot;D&quot; depending on whether you wish to image
scaling function coefficients or wavelet ones</p>
</td></tr>
<tr><td><code id="image.wst_+3A_transform">transform</code></td>
<td>
<p>A numerical transform you wish to apply to the coefficients
before imaging</p>
</td></tr>
<tr><td><code id="image.wst_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+logabs">logabs</a></code>,<code><a href="#topic+wst">wst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- wst(rnorm(1024))
## Not run: image(tmp)
## Not run: image(tmp, transform=logabs)
</code></pre>

<hr>
<h2 id='imwd'>Two-dimensional wavelet transform (decomposition). </h2><span id='topic+imwd'></span>

<h3>Description</h3>

<p>This function can perform two types of two-dimensional discrete wavelet transform (DWT). The standard transform (<code>type="wavelet"</code>) computes the 2D DWT according to Mallat's pyramidal algorithm (Mallat, 1989). The spatially ordered non-decimated 2D DWT (NDWT) (<code>type="station"</code>) contains all possible spatially shifted versions of the DWT. The order of computation of the DWT is O(n), and it is O(n log n) for the NDWT if n is the number of pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imwd(image, filter.number=10, family="DaubLeAsymm", type="wavelet",
bc="periodic", RetFather=TRUE, verbose=FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imwd_+3A_image">image</code></td>
<td>
<p>A square matrix containing the image data you wish to decompose. The sidelength of this matrix must be a power of 2.</p>
</td></tr> 
<tr><td><code id="imwd_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments.</p>
</td></tr>
<tr><td><code id="imwd_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="imwd_+3A_type">type</code></td>
<td>
<p>specifies the type of wavelet transform. This can be &quot;wavelet&quot; (default) in which case the standard 2D DWT is performed (as in previous releases of WaveThresh). If type is &quot;station&quot; then the 2D spatially-ordered non-decimated DWT is performed. At present, only periodic boundary conditions can be used with the 2D spatially ordered non-decimated wavelet transform.</p>
</td></tr>
<tr><td><code id="imwd_+3A_bc">bc</code></td>
<td>
<p>specifies the boundary handling. If bc==&quot;periodic&quot; the default, then the function you decompose is assumed to be periodic on it's interval of definition, if bc==&quot;symmetric&quot; then the function beyond its boundaries is assumed to be a symmetric reflection of the function in the boundary. The symmetric option was the implicit default in releases prior to 2.2. Note that only periodic boundary conditions are valid for the 2D spatially-ordered non-decimated wavelet transform.</p>
</td></tr>
<tr><td><code id="imwd_+3A_retfather">RetFather</code></td>
<td>
<p>If <code>TRUE</code> then this argument causes the scaling function coefficients at each resolution level to be returned as well as the wavelet coefficients. If <code>FALSE</code> then no scaling function coefficients are returned. The opportunity of returning father wavelet coefficients has been added since previous versions of WaveThresh.</p>
</td></tr>
<tr><td><code id="imwd_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the computations progress. Such messages are generally annoying so it is turned off by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 2D algorithm is essentially the application of many 1D filters. First, the columns are attacked with the smoothing (H) and bandpass (G) filters, and the rows of each of these resultant images are attacked again with each of G and H, this results in 4 images. Three of them, GG, GH, and HG correspond to the highest resolution wavelet coefficients. The HH image is a smoothed version of the original and can be further attacked in exactly the same way as the original image to obtain GG(HH), GH(HH), and HG(HH), the wavelet coefficients at the second highest resolution level and HH(HH) the twice-smoothed image, which then goes on to be further attacked. 
</p>
<p>If <code>RetFather=TRUE</code> then the results of the HH smooth (the scaling function coefficients) are returned additionally. 
</p>
<p>There are now two methods of handling &quot;boundary problems&quot;. If you know that your function is periodic (on it's interval) then use the bc=&quot;periodic&quot; option, if you think that the function is symmetric reflection about each boundary then use bc=&quot;symmetric&quot;. If you don't know then it is wise to experiment with both methods, in any case, if you don't have very much data don't infer too much about your decomposition! If you have loads of data then don't worry too much about the boundaries. It can be easier to interpret the wavelet coefficients from a bc=&quot;periodic&quot; decomposition, so that is now the default. 
</p>
<p>The spatially-ordered non-decimated DWT contains all spatial (toroidal circular) shifts of the standard DWT. 
</p>
<p>The standard DWT is orthogonal, the spatially-ordered non-decimated transform is most definitely not. This has the added disadvantage that non-decimated wavelet coefficients, even if you supply independent normal noise. This is unlike the standard DWT where the coefficients are independent (normal noise). 
</p>
<p>The two-dimensional packet-ordered non-decimated discrete wavelet transform is computed by the <code><a href="#topic+wst2D">wst2D</a></code> function. 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+imwd.object">imwd.object</a></code> containing the two-dimensional wavelet transform (possibly spatially-ordered non-decimated). 
</p>


<h3>RELEASE</h3>

<p>Version 3.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+filter.select">filter.select</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lennon)
#
# Let's use the lennon test image
#
## Not run: image(lennon)
#
# Now let's do the 2D discrete wavelet transform
#
lwd &lt;- imwd(lennon)
#
# Let's look at the coefficients
#
## Not run: plot(lwd)
</code></pre>

<hr>
<h2 id='imwd.object'>Two-dimensional wavelet decomposition objects.</h2><span id='topic+imwd.object'></span>

<h3>Description</h3>

<p>These are objects of classes 
</p>
<p><code>imwd</code>
</p>
<p>They represent a decomposition of an image with respect to a two-dimensional wavelet basis (or tight frame in the case of the two-dimensional (space-ordered) non-decimated wavelet decomposition). 
</p>


<h3>Details</h3>

<p>In previous releases the original image was stored as the &quot;original&quot; component of a imwd object. This is not done now as the resulting objects were excessively large. 
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate &lsquo;imwd&rsquo; object. 
</p>
<table role = "presentation">
<tr><td><code>nlevelsWT</code></td>
<td>
<p>number of levels in wavelet decomposition. If you raise 2 to the power of nlevels then you get the dimension of the image that you originally started with. </p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>If <code>type="wavelet"</code> then the image was decomposed according to the 2D Mallat pyramidal algorithm. If <code>type="station"</code> then the image was decomposed using the 2D spatially ordered non-decimated wavelet transform.</p>
</td></tr>
<tr><td><code>fl.dbase</code></td>
<td>
<p>The first last database associated with the decomposition. For images, this list is not very useful as each level's components is stored as a list component, rather than being packaged up in a single vector as in the 1D case. Nevertheless the internals still need to know about fl.dbase to get the computations correct. See the help for <code><a href="#topic+first.last">first.last</a></code> if you are a masochist. </p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>A filter object as returned by the <code><a href="#topic+filter.select">filter.select</a></code> function. This component records the filter used in the decomposition. The reconstruction routines use this component to find out what filter to use in reconstruction. </p>
</td></tr>
<tr><td><code>wNLx</code></td>
<td>
<p>The object will probably contain many components with names of this form. These are all the wavelet coefficients of the decomposition. In &quot;wNLx&quot; the &quot;N&quot; refers to the level number and the &quot;x&quot; refers to the direction of the coefficients with &quot;1&quot; being horizontal, &quot;2&quot; being vertical and &quot;3&quot; being diagonal and &quot;4&quot; corresonding to scaling function coefficients at the given resolution level. Note that the levels should be in numerically decreasing order, so if nlevelsWT is 5, then there will be w5L1, w5L2, w5L3 first, then down to w1L1, w1L2, and w1L3. Note that these coefficients store their data according to the <code><a href="#topic+first.last">first.last</a></code> database <code>fl.dbase$first.last.d</code>, so refer to them using this. 
Note that if <code>type="wavelet"</code> then images at level N are subimages of side length <code>2^N</code> pixels. If the type component is <code>"station"</code> then each coefficient subimage is of the same dimension as the input image used to create this object.</p>
</td></tr>
<tr><td><code>w0Lconstant</code></td>
<td>
<p>This is the coefficient of the bottom level scaling function coefficient. So for examples, if you used Haar wavelets this would be the sample mean of the data (scaled by some factor depending on the number of levels, nlevelsWT).</p>
</td></tr>
<tr><td><code>bc</code></td>
<td>
<p>This component details how the boundaries were treated in the decomposition.</p>
</td></tr> 
</table>


<h3>GENERATION</h3>

<p>This class of objects is returned from the <code><a href="#topic+imwd">imwd</a></code> function to represent a two-dimensional (possibly space-ordered non-decimated) wavelet decomposition of a function. Many other functions return an object of class imwd. 
</p>


<h3>METHODS</h3>

<p>The imwd class of objects has methods for the following generic functions: <code><a href="#topic+compress">compress</a></code>, <code><a href="#topic+draw">draw</a></code>, <code><a href="#topic+imwr">imwr</a></code>, <code><a href="#topic+nullevels.imwd">nullevels.imwd</a></code>, <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+threshold.imwd">threshold.imwd</a></code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>
</p>

<hr>
<h2 id='imwdc.object'>Two-dimensional compressed wavelet decomposition objects.</h2><span id='topic+imwdc.object'></span>

<h3>Description</h3>

<p>These are objects of classes 
</p>
<p><code>imwdc</code>
</p>
<p>They represent a decomposition of an image with respect to a two-dimensional wavelet basis 
</p>


<h3>Details</h3>

<p>In previous releases the original image was stored as the &quot;original&quot; component of a imwd object. This is not done now as the resulting objects were excessively large. 
</p>
<p>To uncompress this class of object back into an object of class <code><a href="#topic+imwd.object">imwd.object</a></code> use the <code><a href="#topic+uncompress.imwdc">uncompress.imwdc</a></code> function. 
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate &lsquo;imwdc&rsquo; object. 
</p>
<table role = "presentation">
<tr><td><code>nlevelsWT</code></td>
<td>
<p>number of levels in wavelet decomposition. If you raise 2 to the power of nlevels then you get the dimension of the image that you originally started with. </p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>If <code>type="wavelet"</code> then the image was decomposed according to the 2D Mallat pyramidal algorithm. If <code>type="station"</code> then the image was decomposed using the 2D spatially ordered non-decimated wavelet transform.</p>
</td></tr>
<tr><td><code>fl.dbase</code></td>
<td>
<p>The first last database associated with the decomposition. For images, this list is not very useful as each level's components is stored as a list component, rather than being packaged up in a single vector as in the 1D case. Nevertheless the internals still need to know about fl.dbase to get the computations correct. See the help for <code><a href="#topic+first.last">first.last</a></code> if you are a masochist. </p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>A filter object as returned by the <code><a href="#topic+filter.select">filter.select</a></code> function. This component records the filter used in the decomposition. The reconstruction routines use this component to find out what filter to use in reconstruction. </p>
</td></tr>
<tr><td><code>wNLx</code></td>
<td>
<p>The object will probably contain many components with names of this form. These are all the wavelet coefficients of the decomposition. In &quot;wNLx&quot; the &quot;N&quot; refers to the level number and the &quot;x&quot; refers to the direction of the coefficients with &quot;1&quot; being horizontal, &quot;2&quot; being vertical and &quot;3&quot; being diagonal. Note that imwdc objects do not contain scaling function coefficients. This would negate the point of having a compressed object.
</p>
<p>Each vector stores its coefficients using an object of class compressed, i.e. the vector is run-length encoded on zeroes.
</p>
<p>Note that the levels should be in numerically decreasing order, so if nlevelsWT is 5, then there will be w5L1, w5L2, w5L3 first, then down to w1L1, w1L2, and w1L3. Note that these coefficients store their data according to the <code><a href="#topic+first.last">first.last</a></code> database <code>fl.dbase$first.last.d</code>, so refer to them using this. 
</p>
<p>Note that if <code>type="wavelet"</code> then images at level N are subimages of side length <code>2^N</code> pixels. If the type component is <code>"station"</code> then each coefficient subimage is of the same dimension as the input image used to create this object.</p>
</td></tr>
<tr><td><code>w0Lconstant</code></td>
<td>
<p>This is the coefficient of the bottom level scaling function coefficient. So for examples, if you used Haar wavelets this would be the sample mean of the data (scaled by some factor depending on the number of levels, nlevelsWT).</p>
</td></tr>
<tr><td><code>bc</code></td>
<td>
<p>This component details how the boundaries were treated in the decomposition.</p>
</td></tr> 
</table>


<h3>GENERATION</h3>

<p>This class of objects is returned from the <code><a href="#topic+threshold.imwd">threshold.imwd</a></code> function to represent a thresholded two-dimensional wavelet decomposition of a function. Some other functions return an object of class imwdc.  
</p>


<h3>METHODS</h3>

<p>The imwd class of objects has methods for the following generic functions: <code><a href="#topic+draw">draw</a></code>, <code><a href="#topic+imwr">imwr</a></code>, <code><a href="#topic+nullevels">nullevels</a></code>, <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+threshold.imwdc">threshold.imwdc</a></code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code> <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+threshold.imwd">threshold.imwd</a></code>, <code><a href="#topic+uncompress.imwdc">uncompress.imwdc</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Perform the standard two-dimensional DWT
# on the lennon image.
#
data(lennon)

lwd &lt;- imwd(lennon)
#
# Now let's see how many horizontal detail coefficients there are at
# scale 6
#
length(lwd$w6L1)
# [1] 4096
#
# So the horizontal detail ``image'' at scale contains 64x64=4096 coefficients.
# A lot!
#
# Now, suppose we threshold this
# two-dimensional wavelet decomposition object
#
lwdT &lt;- threshold(lwd)
#
# First of all. What is the class of the detail coefficients now? 
#
class(lwdT$w6L1)
# [1] "compressed"
#
# Aha. So this set of coefficients got compressed using the
# compress.default function.
#
# How many coefficients are being stored here?
#
lwdT$w6L1
# $position:
# [1]  173 2829 2832 2846
#
# $values:
# [1]  141.5455 -190.2810 -194.5714 -177.1791
# 
# $original.length:
# [1] 4096
#
# attr(, "class"):
# [1] "compressed"
#
# Wow! Only 4 coefficients are not zero. Wicked compression!
</code></pre>

<hr>
<h2 id='imwr'>Inverse two-dimensional wavelet transform. </h2><span id='topic+imwr'></span>

<h3>Description</h3>

<p>Perform inverse two-dimensional wavelet transform using Mallat's, 1989 algorithm. 
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist. For the <code><a href="#topic+imwd">imwd</a></code> class object this generic function uses <code><a href="#topic+imwr.imwd">imwr.imwd</a></code>. For the <code>imwdc</code> class object this generic function uses <code><a href="#topic+imwr.imwdc">imwr.imwdc</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imwr(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imwr_+3A_...">...</code></td>
<td>
<p>See individual help pages for details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>See individual method help pages for operation and examples. 
</p>


<h3>Value</h3>

<p>A square matrix whose side length is a power of two that represents the inverse 2D wavelet transform of the input object x. 
</p>


<h3>RELEASE</h3>

<p>Version 2 Copyright Guy Nason 1993 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+imwr.imwd">imwr.imwd</a></code>, <code><a href="#topic+imwr.imwdc">imwr.imwdc</a></code>. 
</p>

<hr>
<h2 id='imwr.imwd'>Inverse two-dimensional discrete wavelet transform.</h2><span id='topic+imwr.imwd'></span>

<h3>Description</h3>

<p>This functions performs the reconstruction stage of Mallat's pyramid algorithm (i.e. the inverse discrete wavelet transform) for images. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwd'
imwr(imwd, bc=imwd$bc, verbose=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imwr.imwd_+3A_imwd">imwd</code></td>
<td>
<p>An object of class '<code><a href="#topic+imwd">imwd</a></code>'. This type of object is returned by '<code><a href="#topic+imwd">imwd</a></code>'.</p>
</td></tr>
<tr><td><code id="imwr.imwd_+3A_bc">bc</code></td>
<td>
<p>This argument specifies the boundary handling, it is best left to be the boundary handling specified by that in the supplied imwd (as is the default).</p>
</td></tr>
<tr><td><code id="imwr.imwd_+3A_verbose">verbose</code></td>
<td>
<p>If this argument is true then informative messages are printed detailing the computations to be performed</p>
</td></tr>
<tr><td><code id="imwr.imwd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of the algorithm are to be found in Mallat (1989). Similarly to the decomposition function, <code><a href="#topic+imwd">imwd</a></code> the inverse algorithm works by applying many 1D reconstruction algorithms to the coefficients. The filters in these 1D reconstructions are incorporated in the supplied <code><a href="#topic+imwd.object">imwd.object</a></code> and originally created by the <code><a href="#topic+filter.select">filter.select</a></code> function in WaveThresh3.
</p>
<p>This function is a method for the generic function <code><a href="#topic+imwr">imwr</a></code> for class <code><a href="#topic+imwd.object">imwd.object</a></code>. It can be invoked by calling <code><a href="#topic+imwr">imwr</a></code> for an object of the appropriate class, or directly by calling imwr.imwd regardless of the class of the object. 
</p>


<h3>Value</h3>

<p>A matrix, of dimension determined by the original data set supplied to the initial decomposition (more precisely, determined by the <code><a href="#topic+nlevelsWT">nlevelsWT</a></code> component of the <code><a href="#topic+imwd.object">imwd.object</a></code>). This matrix is the highest resolution level of the reconstruction. If a <code><a href="#topic+imwd">imwd</a></code> two-dimensional wavelet transform is followed immediately by a <code><a href="#topic+imwr">imwr</a></code> inverse two-dimensional wavelet transform then the returned matrix will be exactly the same as the original image. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+imwr">imwr</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Do a decomposition, then exact reconstruction
# Look at the error
#
test.image &lt;- matrix(rnorm(32*32), nrow=32)
#
# Test image is just some sort of  square matrix whose side length
# is a power of two.
#
max( abs(imwr(imwd(test.image)) - test.image))
# [1] 1.014611e-11
</code></pre>

<hr>
<h2 id='imwr.imwdc'>Inverse two-dimensional discrete wavelet transform. </h2><span id='topic+imwr.imwdc'></span>

<h3>Description</h3>

<p>Inverse two-dimensional discrete wavelet transform. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwdc'
imwr(imwd, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imwr.imwdc_+3A_imwd">imwd</code></td>
<td>
<p>An object of class <code>imwdc</code>. This type of object is returned by <code><a href="#topic+threshold.imwd">threshold.imwd</a></code> and is a <code><a href="#topic+compress.imwd">compress.imwd</a></code> compressed version of an <code><a href="#topic+imwd">imwd</a></code> object.</p>
</td></tr>
<tr><td><code id="imwr.imwdc_+3A_verbose">verbose</code></td>
<td>
<p>If this argument is true then informative messages are printed detailing the computations to be performed</p>
</td></tr>
<tr><td><code id="imwr.imwdc_+3A_...">...</code></td>
<td>
<p>other arguments to supply to the <code><a href="#topic+imwr">imwr</a></code> function which is called after uncompressing the imwdc object.</p>
</td></tr></table>


<h3>Details</h3>

<p>This function merely uncompresses the supplied <code><a href="#topic+imwdc.object">imwdc.object</a></code> and passes the resultant <code><a href="#topic+imwd">imwd</a></code> object to the <code><a href="#topic+imwr.imwd">imwr.imwd</a></code> function.
</p>
<p>This function is a method for the generic function <code><a href="#topic+imwr">imwr</a></code> for class <code><a href="#topic+imwdc.object">imwdc.object</a></code>. It can be invoked by calling <code><a href="#topic+imwr">imwr</a></code> for an object of the appropriate class, or directly by calling imwr.imwdc regardless of the class of the object. 
</p>


<h3>Value</h3>

<p>A matrix, of dimension determined by the original data set supplied to the initial decomposition (more precisely, determined by the <code><a href="#topic+nlevelsWT">nlevelsWT</a></code> component of the <code><a href="#topic+imwdc.object">imwdc.object</a></code>). This matrix is the highest resolution level of the reconstruction. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+compress.imwd">compress.imwd</a></code>, <code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+imwr">imwr</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Do a decomposition, thresholding, then exact reconstruction
# Look at the error
#

test.image &lt;- matrix(rnorm(32*32), nrow=32)

# Test image is just some sort of  square matrix whose side length
# is a power of two.
#
max( abs(imwr(threshold(imwd(test.image))) - test.image))
# [1] 62.34
#
# The answer is not zero (see contrasting examples in the help page for
# imwr.imwd because we have thresholded the
# 2D wavelet transform here).
</code></pre>

<hr>
<h2 id='InvBasis'>Generic basis inversion for libraries</h2><span id='topic+InvBasis'></span>

<h3>Description</h3>

<p>Will invert either a <code>wst</code> or <code>wp</code> object given that object
and some kind of basis specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InvBasis(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InvBasis_+3A_...">...</code></td>
<td>
<p>Usually a library representation and a basis specification</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says it all
</p>


<h3>Value</h3>

<p>The reconstruction.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+InvBasis.wp">InvBasis.wp</a></code>,<code><a href="#topic+InvBasis.wst">InvBasis.wst</a></code>,<code><a href="#topic+MaNoVe">MaNoVe</a></code>,<code><a href="#topic+numtonv">numtonv</a></code></p>

<hr>
<h2 id='InvBasis.wp'>Invert a wp library representation with a particular basis spec</h2><span id='topic+InvBasis.wp'></span>

<h3>Description</h3>

<p>Inverts a wp basis representation with a given basis specification,
for example an output from the <code><a href="#topic+MaNoVe">MaNoVe</a></code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
InvBasis(wp, nvwp, pktlist, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InvBasis.wp_+3A_wp">wp</code></td>
<td>
<p>The wavelet packet object you wish to invert.</p>
</td></tr>
<tr><td><code id="InvBasis.wp_+3A_nvwp">nvwp</code></td>
<td>
<p>A basis specification in the format of a node vector (wp) object,
obtained, eg by the <code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code> function</p>
</td></tr>
<tr><td><code id="InvBasis.wp_+3A_pktlist">pktlist</code></td>
<td>
<p>Another way of specifying the basis. If this argument is
not specified then it is generated automatically from the
<code>nvwp</code> argument. If it is specified then it overrides
the one generated by <code>nvwp</code></p>
</td></tr>
<tr><td><code id="InvBasis.wp_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE then informative messages are printed.</p>
</td></tr>
<tr><td><code id="InvBasis.wp_+3A_...">...</code></td>
<td>
<p>Other arguments, not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects arising from a <code><a href="#topic+wp.object">wp.object</a></code> specification
are a representation of a signal with respect to a library
of wavelet packet basis functions.
A particular basis specification can be obtained
using the <code><a href="#topic+numtonv">numtonv</a></code> function which can pick an indexed
basis function, or <code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code> which uses the
Coifman-Wickerhauser minimum entropy method to select a basis.
This function takes a <code><a href="#topic+wp.object">wp.object</a></code> and
a particular basis description (in a <code><a href="#topic+nv.object">nv.object</a></code> node vector
object) and inverts the representation with respect to that selected basis.
</p>
<p>The function can alternatively take a packet list <code>pktlist</code>
specification which
overrides the node vector if supplied. If the <code>pktlist</code> is missing
then one is generated internally from the <code>nvwp</code> object using the
<code><a href="#topic+print.nvwp">print.nvwp</a></code> function.
</p>


<h3>Value</h3>

<p>The inverted reconstruction
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+InvBasis">InvBasis</a></code>,<code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code>,<code><a href="#topic+numtonv">numtonv</a></code>,<code><a href="#topic+print.nvwp">print.nvwp</a></code>,<code><a href="#topic+wp">wp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The example in InvBasis.wst can be used here, but replaced wst by wp
#
</code></pre>

<hr>
<h2 id='InvBasis.wst'>Invert a wst library representation with a basis specification</h2><span id='topic+InvBasis.wst'></span>

<h3>Description</h3>

<p>Inverts a wst basis representation with a given basis specification,
for example an output from the <code><a href="#topic+MaNoVe">MaNoVe</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
InvBasis(wst, nv, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InvBasis.wst_+3A_wst">wst</code></td>
<td>
<p>The wst object that you wish to invert</p>
</td></tr>
<tr><td><code id="InvBasis.wst_+3A_nv">nv</code></td>
<td>
<p>The node vector, basis spec, that you want to pick out</p>
</td></tr>
<tr><td><code id="InvBasis.wst_+3A_...">...</code></td>
<td>
<p>Other arguments, that don't do anything here</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects arising from a <code><a href="#topic+wst.object">wst.object</a></code> specification
are a representation of a signal with respect to a library
of basis functions. A particular basis specification can be obtained
using the <code><a href="#topic+numtonv">numtonv</a></code> function which can pick an indexed
basis function, or <code><a href="#topic+MaNoVe.wst">MaNoVe.wst</a></code> which uses the
Coifman-Wickerhauser minimum entropy method to select a basis.
This function takes a <code><a href="#topic+wst.object">wst.object</a></code> and
a particular basis description (in a <code><a href="#topic+nv.object">nv.object</a></code> node vector
object) and inverts the representation with respect to that selected basis.
</p>


<h3>Value</h3>

<p>The inverted reconstruction
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+numtonv">numtonv</a></code>,<code><a href="#topic+nv.object">nv.object</a></code>,<code><a href="#topic+MaNoVe.wst">MaNoVe.wst</a></code>,<code><a href="#topic+threshold.wst">threshold.wst</a></code>,<code><a href="#topic+wst">wst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's generate a noisy signal
#
x &lt;- example.1()$y + rnorm(512, sd=0.2)
#
# You can plot this if you like
#
## Not run: ts.plot(x)
#
# Now take the nondecimated wavelet transform
#
xwst &lt;- wst(x)
#
# Threshold it
#
xwstT &lt;- threshold(xwst)
#
# You can plot this too if you like
#
## Not run: plot(xwstT)
#
# Now use Coifman-Wickerhauser to get a "good" basis
#
xwstTNV &lt;- MaNoVe(xwstT)
#
# Now invert the thresholded wst using this basis specification
#
xTwr &lt;- InvBasis(xwstT, xwstTNV)
#
# And plot the result, and superimpose the truth in dotted
#
## Not run: ts.plot(xTwr)
## Not run: lines(example.1()$y, lty=2)
</code></pre>

<hr>
<h2 id='ipd'>Inductance plethysmography data.</h2><span id='topic+ipd'></span>

<h3>Description</h3>

<p>Inductance plethysmography trace. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ipd)</code></pre>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>Source</h3>

<p>This data set contains 4096 observations of inductance plethsymography data sampled at 50Hz starting at 1229.98 seconds. This is a regular time series object. 
</p>
<p>I am grateful to David Moshal and Andrew Black of the Department of Anaesthesia, University of Bristol for permission to include this data set. 
</p>
<p>This data set was used in Nason, 1996 to illustrate noise reduction with wavelet shrinkage and using cross-validation for choosing the threshold. 
</p>
<p>A plethysmograph is an apparatus for measuring variations in the size of parts of the body. In this experiment the inductance plethysmograph consists of a coil of wire encapsulated in a belt. A radio-frequency carrier signal is passed through the wire and size variations change the inductance of the coil that can be detected as a change in voltage. When properly calibrated the output voltage of the inductance plethysmograph is proportional to the change in volume of the part of the body under examination. 
</p>
<p>It is of both clinical and scientific interest to discover how anaesthetics or analgesics may alter normal breathing patterns post-operatively. Sensors exist that measure blood oxygen saturation but by the time they indicate critically low levels the patient is often apnoeic (cease breathing) and in considerable danger. It is possible for a nurse to continually observe a patient but this is expensive, prone to error and requires training. In this examples the plethysmograph is arranged around the chest and abdomen of a set of patients and is used to measure the flow of air during breathing. The recordings below were made by the Department of Anaesthesia at the Bristol Royal Infirmary after the patients had undergone surgery under general anaesthetic. The data set (shown below) shows a section of plethysmograph recording lasting approximately 80 seconds. The two main sets of regular oscillations correspond to normal breathing. The disturbed behaviour in the centre of the plot where the normal breathing pattern disappears corresponds to the patient vomiting. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
data(ipd)
## Not run: ts.plot(ipd)
</code></pre>

<hr>
<h2 id='ipndacw'>Compute inner product matrix of discrete non-decimated autocorrelation wavelets.</h2><span id='topic+ipndacw'></span>

<h3>Description</h3>

<p>This function computes the inner product matrix of discrete non-decimated autocorrelation wavelets. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipndacw(J, filter.number = 10, family = "DaubLeAsymm", tol = 1e-100, verbose
         = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ipndacw_+3A_j">J</code></td>
<td>
<p>Dimension of inner product matrix required. This number should be a negative integer.</p>
</td></tr>
<tr><td><code id="ipndacw_+3A_filter.number">filter.number</code></td>
<td>
<p>The index of the wavelet used to compute the inner product matrix.</p>
</td></tr> 
<tr><td><code id="ipndacw_+3A_family">family</code></td>
<td>
<p>The family of wavelet used to compute the inner product matrix.</p>
</td></tr> 
<tr><td><code id="ipndacw_+3A_tol">tol</code></td>
<td>
<p>In the brute force computation for Daubechies compactly supported wavelets many inner product computations are performed. This tolerance discounts any results which are smaller than <code>tol</code> which effectively defines how long the inner product/autocorrelation products are.</p>
</td></tr>
<tr><td><code id="ipndacw_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then informative messages are printed. Some of these can be quite fun as the function tells you whether precomputed matrices are being used, how much computation needs to be done and so forth. </p>
</td></tr>
<tr><td><code id="ipndacw_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the inner product matrix of the discrete non-decimated autocorrelation wavelets. This matrix is used to correct the wavelet periodogram as a step to turning it into a evolutionary wavelet spectral estimate. The matrix returned by ipndacw is the one called A in the paper by Nason, von Sachs and Kroisandt. 
</p>
<p>For the Haar wavelet the matrix is computed by using the analytical formulae in the paper by Nason, von Sachs and Kroisandt and is hence very fast and efficient and can be used for large values of -J. 
</p>
<p>For other Daubechies compactly supported wavelets the matrix is computed directly by autocorrelating discrete non-decimated wavelets at different scales and then forming the inner products of these. A function that computes the autocorrelation wavelets themselves is <code><a href="#topic+PsiJ">PsiJ</a></code>. This <em>brute force</em> computation is slow and memory inefficient hence <code>ipndacw</code> contains a mechanism that stores any inner product matrix that it creates according to a naming scheme defined by the convention defined in <code><a href="#topic+rmname">rmname</a></code>. The stored matrices are assigned to the user-visible environment <code><a href="#topic+WTEnv">WTEnv</a></code>.
</p>
<p>These stored matrices can be used in future computations by the following automatic procedure: 
</p>

<dl>
<dt>1</dt><dd><p>The <code><a href="#topic+rmget">rmget</a></code> looks to see whether previous computations have been performed that might be useful.</p>
</dd>
<dt>2</dt><dd><p>If a matrix of higher order is discovered then the appropriate top-left submatrix is returned, otherwise...</p>
</dd>
<dt>3</dt><dd><p>If the right order of matrix is found it is returned, otherwise ...</p>
</dd>
<dt>4</dt><dd><p>If a matrix of <em>smaller</em> order is found it is used as the top-left submatrix of the answer. The remaining elements to the right of and below the submatrix are computed and then the whole matrix is returned, otherwise...</p>
</dd> 
<dt>5</dt><dd><p>If none are found then the whole matrix is computed in C and returned.</p>
</dd>
</dl>

<p>In this way a particular matrix for a given wavelet need only be computed once. 
</p>


<h3>Value</h3>

<p>A matrix of order (-J)x(-J) containing the inner product matrix of the discrete non-decimated autocorrelation matrices. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (1998). Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum. <em>Technical Report</em>, Department of Mathematics University of Bristol/ Fachbereich Mathematik, Kaiserslautern. </p>


<h3>See Also</h3>

<p><code><a href="#topic+ewspec">ewspec</a></code>, <code><a href="#topic+PsiJ">PsiJ</a></code>, <code><a href="#topic+rmname">rmname</a></code>, <code><a href="#topic+rmget">rmget</a></code>, <code><a href="#topic+filter.select">filter.select</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let us create the 4x4 inner product matrix for the Haar wavelet.
# We'll turn on the jolly verbose messages as well. 
#
ipndacw(-4, filter.number=1, family="DaubExPhase", verbose=TRUE)
#Computing ipndacw
#Calling haarmat
#Took  0.0699999  seconds
#       -1     -2     -3     -4 
#-1 1.5000 0.7500 0.3750 0.1875
#-2 0.7500 1.7500 1.1250 0.5625
#-3 0.3750 1.1250 2.8750 2.0625
#-4 0.1875 0.5625 2.0625 5.4375
#
# If we do this again it will use the precomputed version
#
ipndacw(-4, filter.number=1, family="DaubExPhase", verbose=TRUE)
#Computing ipndacw
#Returning precomputed version: using  4 
#Took  0.08  seconds
#       -1     -2     -3     -4 
#-1 1.5000 0.7500 0.3750 0.1875
#-2 0.7500 1.7500 1.1250 0.5625
#-3 0.3750 1.1250 2.8750 2.0625
#-4 0.1875 0.5625 2.0625 5.4375
#
# Let's use a smoother wavelet from the least-asymmetric family
# and generate the 6x6 version.
#
ipndacw(-6, filter.number=10, family="DaubLeAsymm", verbose=TRUE)
#Computing ipndacw
#Took  0.95  seconds
#             -1           -2           -3           -4           -5 
#-1 1.839101e+00 3.215934e-01 4.058155e-04 8.460063e-06 4.522125e-08
#-2 3.215934e-01 3.035353e+00 6.425188e-01 7.947454e-04 1.683209e-05
#-3 4.058155e-04 6.425188e-01 6.070419e+00 1.285038e+00 1.589486e-03
#-4 8.460063e-06 7.947454e-04 1.285038e+00 1.214084e+01 2.570075e+00
#-5 4.522125e-08 1.683209e-05 1.589486e-03 2.570075e+00 2.428168e+01
#-6 5.161675e-10 8.941666e-08 3.366416e-05 3.178972e-03 5.140150e+00
#             -6 
#-1 5.161675e-10
#-2 8.941666e-08
#-3 3.366416e-05
#-4 3.178972e-03
#-5 5.140150e+00
#-6 4.856335e+01
#
</code></pre>

<hr>
<h2 id='irregwd'>Irregular wavelet transform (decomposition).</h2><span id='topic+irregwd'></span>

<h3>Description</h3>

<p>This function performs the irregular wavelet transform as described in the paper by Kovac and Silverman. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irregwd(gd, filter.number=2, family="DaubExPhase", bc="periodic", verbose=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irregwd_+3A_gd">gd</code></td>
<td>
<p>A grid structure which is the output of the <code><a href="#topic+makegrid">makegrid</a></code> function.</p>
</td></tr>
<tr><td><code id="irregwd_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 2, the Daubechies extremal phase orthonormal compactly supported wavelet with 2 vanishing moments.</p>
</td></tr>
<tr><td><code id="irregwd_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. Two popular options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot; but see the help for <code><a href="#topic+filter.select">filter.select</a></code> for more possibilities.</p>
</td></tr>
<tr><td><code id="irregwd_+3A_bc">bc</code></td>
<td>
<p>specifies the boundary handling. If <code>bc="periodic"</code> the default, then the function you decompose is assumed to be periodic on it's interval of definition, if <code>bc="symmetric"</code> then the function beyond its boundaries is assumed to be a symmetric reflection of the function in the boundary. The symmetric option was the implicit default in releases prior to 2.2.</p>
</td></tr>
<tr><td><code id="irregwd_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the computations progress. Such messages are generally annoying so it is turned off by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If one has irregularly spaced one-dimensional regression data (t,y), say. Then the function <code><a href="#topic+makegrid">makegrid</a></code> interpolates this to a regular grid and then the standard wavelet transform is used to transform the interpolated data. However, unlike the standard wavelet denoising set-up the interpolated data, y, values are correlated. Hence the wavelet coefficients of the interpolated will be correlated (even after using an orthogonal transform). Hence, in particular, the variance of each wavelet coefficient may well be different and so this routine also computes those variances using a fast algorithm (related to the two-dimensional wavelet transform). 
</p>
<p>When thresholding with <code><a href="#topic+threshold.irregwd">threshold.irregwd</a></code> the threshold function makes use of the information about the variance of each coefficient to modify the variance locally on a coefficient by coefficient basis. 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+irregwd">irregwd</a></code> which is a list with the following components. 
</p>
<table role = "presentation">
<tr><td><code>C</code></td>
<td>
<p>Vector of sets of successively smoothed versions of the interpolated data (see description of equivalent component of <code><a href="#topic+wd.object">wd.object</a></code> for further information.)</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Vector of sets of wavelet coefficients of the interpolated data at different resolution levels. (see description of equivalent component of <code><a href="#topic+wd.object">wd.object</a></code> for further information.)</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Vector that aids in calculation of variances of wavelet coefficients (used by <code><a href="#topic+threshold.irregwd">threshold.irregwd</a></code>).</p>
</td></tr>
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of resolution levels. This depends on the length of the data vector. If <code>length(data)=2^m</code>, then there will be m resolution levels. This means there will be m levels of wavelet coefficients (indexed 0,1,2,...,(m-1)), and m+1 levels of smoothed data (indexed 0,1,2,...,m).</p>
</td></tr>
<tr><td><code>fl.dbase</code></td>
<td>
<p>There is more information stored in the C and D than is described above. In the decomposition &ldquo;extra&rdquo; coefficients are generated that help take care of the boundary effects, this database lists where these start and finish, so the &quot;true&quot; data can be extracted.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>A list containing information about the filter type: Contains the string &quot;wavelet&quot; or &quot;station&quot; depending on which type of transform was performed.</p>
</td></tr>
<tr><td><code>bc</code></td>
<td>
<p>How the boundaries were handled.</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>The date the transform was performed.</p>
</td></tr>
</table>


<h3>RELESASE</h3>

<p>3.9.4 Code Copyright Arne Kovac 1997
</p>


<h3>Author(s)</h3>

<p>Arne Kovac</p>


<h3>See Also</h3>

<p><code><a href="#topic+makegrid">makegrid</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.wd">wr.wd</a></code>, <code><a href="#topic+accessC">accessC</a></code>, <code><a href="#topic+accessc">accessc</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+putC">putC</a></code>, <code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+plot.irregwd">plot.irregwd</a></code>, <code><a href="#topic+threshold.irregwd">threshold.irregwd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See full examples at the end of the help for makegrid. 
#
</code></pre>

<hr>
<h2 id='irregwd.objects'>Irregular wavelet decomposition objects.</h2><span id='topic+irregwd.objects'></span>

<h3>Description</h3>

<p>These are objects of classes 
</p>
<p><code>wd</code>
</p>
<p>They represent a decomposition of a function with respect to a wavelet basis. The function will have been interpolated to a grid and these objects represent the discrete wavelet transform <code><a href="#topic+wd">wd</a></code>.
</p>


<h3>Details</h3>

<p>To retain your sanity the C and D coefficients should be extracted by the <code><a href="#topic+accessC">accessC</a></code> and <code><a href="#topic+accessD">accessD</a></code> functions and inserted using the <code><a href="#topic+putC">putC</a></code> and <code><a href="#topic+putD">putD</a></code> functions (or more likely, their methods), rather than by the <code>$</code> operator.
</p>
<p>One can use the <code><a href="#topic+accessc">accessc</a></code> function to obtain the <code>c</code> component. 
</p>
<p>Mind you, if you want to muck about with coefficients directly, then you'll have to do it yourself by working out what the fl.dbase list means (see <code><a href="#topic+first.last">first.last</a></code> for a description.) 
</p>


<h3>GENERATION</h3>

<p>This class of objects is returned from the <code><a href="#topic+irregwd">irregwd</a></code> function. Some other functions that process these kinds of objects also return this class of object (such as <code><a href="#topic+threshold.irregwd">threshold.irregwd</a></code>.)
</p>


<h3>METHODS</h3>

<p>The <code>irregwd</code> class of objects has methods for the following generic functions: <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="#topic+threshold">threshold</a></code>,
</p>


<h3>STRUCTURE</h3>

<p>All components in a legitimate &lsquo;irregwd&rsquo; are identical to the components in an ordinary <code><a href="#topic+wd.object">wd.object</a></code> with the exception of <code>type</code> component and with the addition of the following component: 
</p>

<dl>
<dt>c</dt><dd><p>vector that aids in the calculation of variances of wavelet coefficients (used by <code><a href="#topic+threshold.irregwd">threshold.irregwd</a></code>).</p>
</dd>
</dl>



<h3>RELEASE</h3>

<p>Version 3.9.4 Copyright Arne Kovac 1997, Help Copyright Guy Nason 2004 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+irregwd">irregwd</a></code>, <code><a href="#topic+threshold.irregwd">threshold.irregwd</a></code>, <code><a href="#topic+plot.irregwd">plot.irregwd</a></code>,<code><a href="#topic+wd">wd</a></code> 
</p>

<hr>
<h2 id='IsEarly'>Generic function to detect whether object is from an early version</h2><span id='topic+IsEarly'></span>

<h3>Description</h3>

<p>Generic function to detect whether object is from an early version of
WaveThresh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsEarly(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsEarly_+3A_x">x</code></td>
<td>
<p>The object you want to see whether its from an early version</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Returns TRUE if object is from an earlier version of WaveThresh, FALSE if
not.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+ConvertMessage">ConvertMessage</a></code>,<code><a href="#topic+IsEarly.default">IsEarly.default</a></code>,<code><a href="#topic+IsEarly">IsEarly</a></code>, <code><a href="#topic+IsEarly.wd">IsEarly.wd</a></code></p>

<hr>
<h2 id='IsEarly.default'>Detects whether object is from an earlier version of WaveThresh</h2><span id='topic+IsEarly.default'></span>

<h3>Description</h3>

<p>Detects whether object is from an earlier version of WaveThresh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
IsEarly(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsEarly.default_+3A_x">x</code></td>
<td>
<p>Object to discern</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method always returns FALSE, i.e. unless the object is of
a specific type handled by a particular method then it won't be from an
earlier version.
</p>


<h3>Value</h3>

<p>Always FALSE for the generic
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+IsEarly">IsEarly</a></code></p>

<hr>
<h2 id='IsEarly.wd'>Function to detect whether a wd object is from WaveThresh2 or not</h2><span id='topic+IsEarly.wd'></span>

<h3>Description</h3>

<p>Function to detect whether a wd object is from WaveThresh2 or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
IsEarly(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsEarly.wd_+3A_x">x</code></td>
<td>
<p>The wd object that you are trying to check</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function merely looks to see whether the wd object has a component
called date. If it does not then it is from version 2. This routine
is legacy and not very important anymore.
</p>


<h3>Value</h3>

<p>Returns TRUE if from an earlier version of WaveThresh (v2), returns
FALSE if not. 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+IsEarly">IsEarly</a></code></p>

<hr>
<h2 id='IsPowerOfTwo'>Decides whether vector elements are integral powers of two (returns NA if not).
</h2><span id='topic+IsPowerOfTwo'></span>

<h3>Description</h3>

<p>This function checks to see whether its input is a power of two. If it is then it returns that power otherwise it returns NA. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsPowerOfTwo(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsPowerOfTwo_+3A_n">n</code></td>
<td>
<p>Vector of numbers that are to be checked whether it is a power of two.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function takes the log of the input, divides this by log(2) and if the result is integral then it knows the input is true power of two. 
</p>


<h3>Value</h3>

<p>If <code>n</code> is a power of two, then the power is returned otherwise <code>NA</code> is returned. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6.0 Copyright Guy Nason 1995 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlevelsWT.default">nlevelsWT.default</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Try and see whether 1,2,3 or 4 are powers of two! 
#
IsPowerOfTwo(1:4)
# [1]  0  1 NA  2
#
# Yes, 1,2 and 4 are the 0, 1 and 2nd power of 2. However, 3 is not an
# integral power of two.
</code></pre>

<hr>
<h2 id='l2norm'>Compute L2 distance between two vectors of numbers. </h2><span id='topic+l2norm'></span>

<h3>Description</h3>

<p>Compute L2 distance between two vectors of numbers (square root of sum of squares of differences between two vectors). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l2norm(u,v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="l2norm_+3A_u">u</code></td>
<td>
<p>first vector of numbers</p>
</td></tr> 
<tr><td><code id="l2norm_+3A_v">v</code></td>
<td>
<p>second vector of numbers</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Function simply computes the L2 distance between two vectors and is implemented as 
</p>
<p><code>sqrt(sum((u-v)^2))</code>
</p>


<h3>Value</h3>

<p>A real number which is the L2 distance between two vectors. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1995</p>


<h3>Note</h3>

<p>This function would probably be more accurate if it used the Splus function <code>vecnorm</code>.</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+linfnorm">linfnorm</a></code>, <code><a href="#topic+wstCV">wstCV</a></code>, <code><a href="#topic+wstCVl">wstCVl</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# What is the L2 norm between the following sets of vectors
#
p &lt;- c(1,2,3,4,5)
q &lt;- c(1,2,3,4,5)
r &lt;- c(2,3,4,5,6)
l2norm(p,q)
# [1] 0
l2norm(q,r)
# [1] 2.236068
l2norm(r,p)
# [1] 2.236068
</code></pre>

<hr>
<h2 id='lennon'>John Lennon image.</h2><span id='topic+lennon'></span>

<h3>Description</h3>

<p>A 256x256 matrix. Each entry of the matrix contains an image intensity value. The whole matrix represents an image of John Lennon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lennon)
</code></pre>


<h3>Format</h3>

<p>A 256x256 matrix. Each entry of the matrix contains an image intensity value. The whole matrix represents an image of John Lennon
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>Source</h3>

<p>The John Lennon image was supplied uncredited on certain UNIX workstations as an examples image. I am not sure who the Copyright belongs to. Please let me know if you know
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# This command produces the image seen above.
#
# image(lennon)
#
</code></pre>

<hr>
<h2 id='levarr'>Subsidiary routine that generates a particular permutation</h2><span id='topic+levarr'></span>

<h3>Description</h3>

<p>Not intended for casual user use. This function is used to provide
the partition to reorder <code><a href="#topic+wst.object">wst.object</a></code> into <code><a href="#topic+wd.object">wd.object</a></code>
(nondecimated time ordered) objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levarr(v, levstodo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="levarr_+3A_v">v</code></td>
<td>
<p>the vector to permute</p>
</td></tr>
<tr><td><code id="levarr_+3A_levstodo">levstodo</code></td>
<td>
<p>the number of levels associated with the current
level in the object you wish to permute</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>A permutation of the <code>v</code> vector according to the number of levels
that need handling
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+getarrvec">getarrvec</a></code>, <code><a href="#topic+convert.wd">convert.wd</a></code>, <code><a href="#topic+convert.wst">convert.wst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>levarr(1:4, 3)
# [1] 1 3 2 4
</code></pre>

<hr>
<h2 id='linfnorm'>Compute L infinity distance between two vectors of numbers. </h2><span id='topic+linfnorm'></span>

<h3>Description</h3>

<p>Compute L infinity distance between two vectors of numbers (maximum absolute difference between two vectors). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linfnorm(u,v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linfnorm_+3A_u">u</code></td>
<td>
<p>first vector of numbers</p>
</td></tr> 
<tr><td><code id="linfnorm_+3A_v">v</code></td>
<td>
<p>second vector of numbers</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Function simply computes the L infinity distance between two vectors and is implemented as 
</p>
<p><code>max(abs(u-v))</code>
</p>


<h3>Value</h3>

<p>A real number which is the L infinity distance between two vectors. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1995 </p>


<h3>Note</h3>

<p>This function would probably be more accurate if it used the Splus function <code>vecnorm</code>.</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+l2norm">l2norm</a></code>, <code><a href="#topic+wstCV">wstCV</a></code>, <code><a href="#topic+wstCVl">wstCVl</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# What is the L infinity norm between the following sets of vectors
#
p &lt;- c(1,2,3,4,5)
q &lt;- c(1,2,3,4,5)
r &lt;- c(2,3,4,5,6)
linfnorm(p,q)
# [1] 0
linfnorm(q,r)
# [1] 1
linfnorm(r,p)
# [1] 1
</code></pre>

<hr>
<h2 id='LocalSpec'>Compute Nason and Silverman smoothed wavelet periodogram.</h2><span id='topic+LocalSpec'></span>

<h3>Description</h3>

<p>This function is obsolete. Use the function <code><a href="#topic+ewspec">ewspec</a></code>. Performs the Nason and Silverman smoothed wavelet periodogram as described in Nason and Silverman (1995). 
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist. For the wd class object this generic function uses <code><a href="#topic+LocalSpec.wd">LocalSpec.wd</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocalSpec(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LocalSpec_+3A_...">...</code></td>
<td>
<p>See individual help pages for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See individual method help pages for operation and examples. 
</p>


<h3>Value</h3>

<p>The LocalSpec of the wavelet object supplied. See method help files for examples. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+LocalSpec.wd">LocalSpec.wd</a></code> 
</p>

<hr>
<h2 id='LocalSpec.wd'>Compute Nason and Silverman raw or smoothed wavelet periodogram. </h2><span id='topic+LocalSpec.wd'></span>

<h3>Description</h3>

<p><em>This smoothing in this function is now obsolete</em>. You should now use the function <code><a href="#topic+ewspec">ewspec</a></code>.
</p>
<p>This function computes the Nason and Silverman raw or smoothed wavelet periodogram as described by Nason and Silverman (1995). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
LocalSpec(wdS, lsmooth="none", nlsmooth=FALSE, prefilter=TRUE,
  verbose=FALSE, lw.number=wdS$filter$filter.number,
  lw.family=wdS$filter$family, nlw.number=wdS$filter$filter.number,
  nlw.family=wdS$filter$family, nlw.policy="LSuniversal",
  nlw.levels=0:(nlevelsWT(wdS) - 1), nlw.type="hard", nlw.by.level=FALSE,
  nlw.value=0, nlw.dev=var, nlw.boundary=FALSE, nlw.verbose=FALSE,
  nlw.cvtol=0.01, nlw.Q=0.05, nlw.alpha=0.05, nlw.transform=I,
  nlw.inverse=I, debug.spectrum=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<p>Note that all options beginning &quot;nlw&quot; are only used if nlsmooth=T, i.e. iff NONLINEAR wavelet smoothing is used. 
</p>
<table role = "presentation">
<tr><td><code id="LocalSpec.wd_+3A_wds">wdS</code></td>
<td>
<p>The stationary wavelet transform object that you want to smooth or square.</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_lsmooth">lsmooth</code></td>
<td>
<p>Controls the LINEAR smoothing. There are three options: &quot;none&quot;, &quot;Fourier&quot; and &quot;wavelet&quot;. They are described below. Note that Fourier begins with a capital &quot;F&quot;.</p>
</td></tr>
<tr><td><code id="LocalSpec.wd_+3A_nlsmooth">nlsmooth</code></td>
<td>
<p>A switch to turn on (or off) the NONLINEAR wavelet shrinkage of (possibly LINEAR smoothed) local power coefficients. This option is either TRUE (to turn on the smoothing) or FALSE (to turn it off).</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_prefilter">prefilter</code></td>
<td>
<p>If TRUE then apply a prefilter to the actual stationary wavelet coefficients at each level. This is a low-pass filter that cuts off all frequencies above the highest frequency allowed by the (Littlewood-Paley) wavelet that bandpassed the current level coefficients. If FALSE then no prefilter is applied.</p>
</td></tr>
<tr><td><code id="LocalSpec.wd_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE then the function chats about what it is doing. Otherwise it is silent.</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_lw.number">lw.number</code></td>
<td>
<p>If wavelet LINEAR smoothing is used then this option controls the <code>filter number</code> of the wavelet within the family used to perform the LINEAR wavelet smoothing.</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_lw.family">lw.family</code></td>
<td>
<p>If wavelet LINEAR smoothing is used then this option controls the <code><a href="stats.html#topic+family">family</a></code> of the wavelet used to perform the LINEAR wavelet smoothing.</p>
</td></tr>
<tr><td><code id="LocalSpec.wd_+3A_nlw.number">nlw.number</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the <code>filter number</code> of the wavelet used to perform the wavelet shrinkage.</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_nlw.family">nlw.family</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the <code><a href="stats.html#topic+family">family</a></code> of the wavelet used to perform the wavelet shrinkage.</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_nlw.policy">nlw.policy</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the levels to use when performing wavelet shrinkage (see <code><a href="#topic+threshold.wd">threshold.wd</a></code> for different policy choices).</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_nlw.levels">nlw.levels</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the levels to use when performing wavelet shrinkage (see <code><a href="#topic+threshold.wd">threshold.wd</a></code> for a detailed description of how levels can be chosen).</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_nlw.type">nlw.type</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the type of thresholding used in the wavelet shrinkage (either &quot;hard&quot; or &quot;soft&quot;, but see <code><a href="#topic+threshold.wd">threshold.wd</a></code> for a list). </p>
</td></tr>
<tr><td><code id="LocalSpec.wd_+3A_nlw.by.level">nlw.by.level</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls whether level-by-level thresholding is used or if one threshold is chosen for all levels (see <code><a href="#topic+threshold.wd">threshold.wd</a></code>).</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_nlw.value">nlw.value</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls if a manual (or similar) policy is supplied to <code>nlw.policy</code> then the nlw.value option carries the manual threshold value (see <code><a href="#topic+threshold.wd">threshold.wd</a></code>). </p>
</td></tr>
<tr><td><code id="LocalSpec.wd_+3A_nlw.dev">nlw.dev</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the type of variance estimator that is used in wavelet shrinkages (see <code><a href="#topic+threshold.wd">threshold.wd</a></code>). One possibility is the Splus var() function, another is the WaveThresh function <code><a href="#topic+madmad">madmad</a></code>().</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_nlw.boundary">nlw.boundary</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls whether boundary coefficients are also thresholded (see <code><a href="#topic+threshold.wd">threshold.wd</a></code>).</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_nlw.verbose">nlw.verbose</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls whether the threshold function prints out messages as it thresholds levels (see <code><a href="#topic+threshold.wd">threshold.wd</a></code>).</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_nlw.cvtol">nlw.cvtol</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the optimization tolerance is cross-validation wavelet shrinkage is used (see <code><a href="#topic+threshold.wd">threshold.wd</a></code>)</p>
</td></tr>
<tr><td><code id="LocalSpec.wd_+3A_nlw.q">nlw.Q</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the Q value for wavelet shrinkage (see <code><a href="#topic+threshold.wd">threshold.wd</a></code>).</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_nlw.alpha">nlw.alpha</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the alpha value for wavelet shrinkage (see <code><a href="#topic+threshold.wd">threshold.wd</a></code>).</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_nlw.transform">nlw.transform</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls a transformation that is applied to the squared (and possibly linear smoothed) stationary wavelet coefficients before shrinkage. So, for examples, you might want to set <code>nlw.transform=log</code> to perform wavelet shrinkage on the logs of the squared (and possibly linear smoothed) stationary wavelet coefficients. </p>
</td></tr>
<tr><td><code id="LocalSpec.wd_+3A_nlw.inverse">nlw.inverse</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the inverse transformation that is applied to the wavelet shrunk coefficients before they are put back into the stationary wavelet transform structure. So, for examples, if the <code>nlw.transform</code> is <code>log()</code> you should set the inverse to <code>nlw.inverse=exp</code>.</p>
</td></tr> 
<tr><td><code id="LocalSpec.wd_+3A_debug.spectrum">debug.spectrum</code></td>
<td>
<p>If this option is <code>T</code> then spectrum plots are produced at each stage of the squaring/smoothing. Therefore if you put in the non-decimated wavelet transform of white noise you can get a fair idea of how the coefficients are filtered at each stage.</p>
</td></tr>
<tr><td><code id="LocalSpec.wd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>This smoothing in this function is now obsolete.</em> Use the function <code><a href="#topic+ewspec">ewspec</a></code> instead. However, this function is still useful for computing the raw periodogram. 
</p>
<p>This function attempts to produce a picture of local time-scale power of a signal. There are two main components to this function: linear smoothing of squared coefficients and non-linear smoothing of these. Neither, either or both of these components may be used to process the data. The function expects a non-decimated wavelet transform object (of class wd, type=&quot;station&quot;) such as that produced by the <code><a href="#topic+wd">wd</a></code>() function with the type option set to &quot;<code>station</code>&quot;. The following paragraphs describe the various methods of smoothing. 
</p>
<p><b>LINEAR SMOOTHING</b>. There are three varieties of linear smoothing. None simply squares the coefficients. Fourier and wavelet apply linear smoothing methods in accordance to the prescription given in Nason and Silverman (1995). Each level in the SWT corresponds to a band-pass filtering to a frequency range [sl, sh]. After squaring we obtain power in the range [0, 2sl] and [2sl, 2sh]. The linear smoothing gets rid of the power in [2sl, 2sh]. The Fourier method simply applies a discrete Fourier transform (rfft) and cuts off frequencies above 2sl. The wavelet method is a bit more suble. The DISCRETE wavelet transform is taken of a level (i) and all levels within the DWT, j, where j&gt;i are set to zero and then the inverse is taken. Approximately this performs the same operation as the Fourier method only faster. By default the same wavelets are used to perform the linear smoothing as were used to compute the stationary wavelet transform in the first place. This can be changed by altering <code>lw.number</code> and <code>lw.family</code>.  
</p>
<p><b>NONLINEAR SMOOTHING</b>. After either of the linear smoothing options above it is possible to use wavelet shrinkage upon each level in the squared (and possibly Fourier or wavelet linear smoothed) to denoise the coefficients. This process is akin to smoothing the ordinary periodogram. All the usual wavelet shrinkage options are available as <code>nlw</code>.* where * is one of the usual <code><a href="#topic+threshold.wd">threshold.wd</a></code> options. By default the same wavelets are used to perform the wavelet shrinkage as were used to compute the non-decimated wavelet transform. These wavelets can be replaced by altering <code>nlw.number</code> and <code>nlw.family</code>. Also, it is possible to transform the squared (and possibly smoothed coefficients) before applying wavelet shrinkage. The transformation is effected by supplying an appropriate transformation function (AND ITS INVERSE) to <code>nlw.transform</code> and <code>nlw.inverse</code>. (For examples, <code>nlw.transform=log</code> and<code> nlw.inverse=exp</code> might be a good idea). 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wd">wd</a></code> a time-ordered non-decimated wavelet transform. Each level of the returned object contains a smoothed wavelet periodogram. Note that this is <b>not</b> the <em>corrected</em> smoothed wavelet periodogram, or the <em>evolutionary wavelet spectrum</em>. Use the function <code><a href="#topic+ewspec">ewspec</a></code> to compute the evolutionary wavelet spectrum. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason and Silverman, (1995). </p>


<h3>See Also</h3>

<p><code><a href="#topic+ewspec">ewspec</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# This function is obsolete. See ewspec()
#
# Compute the raw periodogram of the BabyECG
# data using the Daubechies least-asymmetric wavelet $N=10$.
#
data(BabyECG)
babywdS &lt;- wd(BabyECG, filter.number=10, family="DaubLeAsymm", type="station")
babyWP &lt;- LocalSpec(babywdS, lsmooth = "none", nlsmooth = FALSE)
## Not run: plot(babyWP, main="Raw Wavelet Periodogram of Baby ECG")
#
# Note that the lower levels of this plot are too large. This is partly because
# there are "too many" coefficients at the lower levels. For a better
# picture of the local spectral properties of this time series see
# the examples section of ewspec
#
# Other results of this function can be seen in the paper by
# Nason and Silverman (1995) above.
#
</code></pre>

<hr>
<h2 id='LocalSpec.wst'>Obsolete function (use ewspec)</h2><span id='topic+LocalSpec.wst'></span>

<h3>Description</h3>

<p>This function computes a local spectra as described in Nason and Silverman
(1995). However, the function is obsolete and superceded by
<code><a href="#topic+ewspec">ewspec</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
LocalSpec(wst, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LocalSpec.wst_+3A_wst">wst</code></td>
<td>
<p>The wst object to perform local spectral analysis on</p>
</td></tr>
<tr><td><code id="LocalSpec.wst_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+LocalSpec.wd">LocalSpec.wd</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says it all.
</p>
<p>However, this function converts the <code><a href="#topic+wst.object">wst.object</a></code> object to
a nondecimated <code><a href="#topic+wd.object">wd.object</a></code> and then calls
<code><a href="#topic+LocalSpec.wd">LocalSpec.wd</a></code>.
</p>


<h3>Value</h3>

<p>Same value as <code><a href="#topic+LocalSpec.wd">LocalSpec.wd</a></code>.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+ewspec">ewspec</a></code></p>

<hr>
<h2 id='logabs'>
Take the logarithm of the squares of the argument
</h2><span id='topic+logabs'></span>

<h3>Description</h3>

<p>Take the log of the squares of the argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logabs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logabs_+3A_x">x</code></td>
<td>
<p>A number
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Just the logarithm of the square of the argument
</p>


<h3>Author(s)</h3>

<p>G P Nason
</p>


<h3>See Also</h3>

<p><code><a href="#topic+image.wd">image.wd</a></code>, <code><a href="#topic+image.wst">image.wst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logabs(3)
# [1] 1.098612
</code></pre>

<hr>
<h2 id='LSWsim'>Simulate arbitrary locally stationary wavelet process.</h2><span id='topic+LSWsim'></span>

<h3>Description</h3>

<p>Simulates an arbitrary LSW process given a spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LSWsim(spec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LSWsim_+3A_spec">spec</code></td>
<td>
<p>An object of class <code><a href="#topic+wd">wd</a></code> (the NDWT kind) which contains the spectral information for simulating your process. See examples below on how to create and manipulate this object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a spectral definition in spec to simulate a locally stationary wavelet process (defined by the Nason, von Sachs and Kroisandt, 2000, JRSSB paper). 
</p>
<p>The input object, <code>spec</code>, is a <code><a href="#topic+wd">wd</a></code> class object which contains a spectral description. In particular, all coefficients must be nonnegative and <code>LSWsim()</code> checks for this and returns an error if it is not so. Other than that the spectrum can contain pretty much anything. An object of this type can be easily created by the convenience routine <code><a href="#topic+cns">cns</a></code>. This creates an object of the correct structure but all elements are initially set to zero. The spectrum structure <code>spec</code> can then be filled by using the <code><a href="#topic+putD">putD</a></code> function. 
</p>
<p>The function works by first checking for non-negativity. Then it takes the square root of all coefficients. Then it multiplies all coefficients by a standard normal variate (from <code>rnorm()</code>) and multiples the finest level by 2, the next finest by 4, the next by 8 and so on. (This last scalar multiplication is intended to undo the effect of the average basis averaging which combines cofficients but divides by two at each combination). Finally, the modified spectral object is subjected to the <code><a href="#topic+convert">convert</a></code> function which converts the object from a <code><a href="#topic+wd">wd</a></code> time-ordered NWDT object to a <code><a href="#topic+wst">wst</a></code> packet-ordered object which can then be inverted using <code><a href="#topic+AvBasis">AvBasis</a></code>. 
</p>
<p>Note that the NDWT transforms in WaveThresh are periodic so that the process that one simulates with this function is also periodic. 
</p>


<h3>Value</h3>

<p>A vector simulated from the spectral description given in the <code>spec</code> description. The returned vector will exhibit the spectral characteristics defined by <code>spec</code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 2004 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+cns">cns</a></code>, <code><a href="#topic+AvBasis">AvBasis</a></code>, <code><a href="#topic+convert">convert</a></code>, <code><a href="#topic+ewspec">ewspec</a></code>, <code><a href="#topic+plot.wst">plot.wst</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Suppose we want to create a LSW process of length 1024 and with a spectral
# structure that has a squared sinusoidal character at level 4 and a burst of
# activity from time 800 for 100 observations at scale 9 (remember for a
# process of length 1024 there will be 9 resolution levels (since 2^10=1024)
# where level 9 is the finest and level 0 is the coarsest).
#
# First we will create an empty spectral structure for series of 1024 observations
#
#
myspec &lt;- cns(1024)
#
# If you plot it you'll get a null spectrum (since every spectral entry is zero)
#
## Not run: plot(myspec, main="My Spectrum")
#
#
# Now let's add the desired spectral structure
#
# First the squared sine (remember spectra are positive)
#
myspec &lt;- putD(myspec, level=4, sin(seq(from=0, to=4*pi, length=1024))^2)
#
# Let's create a burst of spectral info of size 1 from 800 to 900. Remember
# the whole vector has to be of length 1024.
#
burstat800 &lt;- c(rep(0,800), rep(1,100), rep(0,124))
#
# Insert this (00000111000) type vector into the spectrum at fine level 9
#
myspec &lt;- putD(myspec, level=9, v=burstat800)
#
# Now it's worth plotting this spectrum
#
## Not run: plot(myspec, main="My Spectrum")
#
# The squared sinusoid at level 4 and the burst at level 9 can clearly
# be seen
#
#
# Now simulate a random process with this spectral structure.
#
myLSWproc &lt;- LSWsim(myspec)
#
# Let's see what it looks like
#
## Not run: ts.plot(myLSWproc)
#
#
# The burst is very clear but the sinusoidal structure is less apparent.
# That's basically it.
#
# You could now play with the spectrum (ie alter it) or simulate another process
# from it.
#
# [The following is somewhat of an aside but useful to those more interested
# in the LSW scene. We could now ask, so what? So you can simulate an
# LSW process. How can I be sure that it is doing so correctly? Well, here is
# a partial, computational, answer. If you simulate many realisations from the
# same spectral structure, estimate its spectrum, and then average those
# estimates then the average should tend to the spectrum you supplied. Here is a
# little function to do this (just for Haar but this function could easily be
# developed to be more general):
#
checkmyews &lt;- function(spec, nsim=10){
        ans &lt;- cns(2^nlevelsWT(spec))
        for(i in 1:nsim)        {
                cat(".")
                LSWproc &lt;- LSWsim(spec)
                ews &lt;- ewspec(LSWproc, filter.number=1, family="DaubExPhase",
                        WPsmooth=F)
                ans$D &lt;- ans$D + ews$S$D
                ans$C &lt;- ans$C + ews$S$C
        }
        ans$D &lt;- ans$D/nsim
        ans$C &lt;- ans$C/nsim
        ans
}
# If you supply it with a spectral structure (like myspec)
# from above and do enough simulations you'll get something looking like
# the original myspec structure. E.g. try
#
## Not run: plot(checkmyews(myspec, nsim=100))
##
# for fun. This type of check also gives you some idea of how much data
# you really need for LSW estimation for given spectral structures.]
#
</code></pre>

<hr>
<h2 id='lt.to.name'>Convert desired level and orientation into code used by imwd</h2><span id='topic+lt.to.name'></span>

<h3>Description</h3>

<p>Function codes the name of a desired level and wavelet coefficient orientation into a string which is used by the 2D DWT functions to access and manipulate wavelet coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lt.to.name(level, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lt.to.name_+3A_level">level</code></td>
<td>
<p>Resolution level of coefficients that you want to extract or
manipulate.</p>
</td></tr>
<tr><td><code id="lt.to.name_+3A_type">type</code></td>
<td>
<p>One of CC, CD, DC or DD indicating smoothed, horizontal,
vertical or diagonal coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the 1D wavelet transform (and others) the
<code><a href="#topic+accessC">accessC</a></code> and <code><a href="#topic+accessD">accessD</a></code> function extracts wavelet
coefficients from 1D wavelet decomposition objects.
For <code><a href="#topic+imwd.object">imwd.object</a></code> class objects,
which are the 2D wavelet transforms of lattice objects (images)
the wavelet coefficients are stored within components of the list object
that underlies the imwd object.
</p>
<p>This function provides an easy way to specify a resolution level and
orientation in a human readable way and this function then produces the
character string necessary to access the wavelet coefficients in an imwd object.
</p>
<p>Note that this function <em>does not</em> actually extract any coefficients itself.
</p>


<h3>Value</h3>

<p>A character string which codes the level and type of coefficients.
It reads wXLY X is the resolution level and Y is an integer corresponding to the orientation (1=horizontal, 2=vertical, 3=diagonal, 4=smoothed).
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate the character string for the component of the imwd object
#
# The string associated with the diagonal detail at the third level...
#
lt.to.name(3, "DD")
# [1] "w3L3"
#
# Show how to access wavelet coefficients of imwd object.
#
# First, make up some data (using matrix/rnorm) and then subject it
# to an image wavelet transform.
#
tmpimwd &lt;- imwd(matrix(rnorm(64),64,64))
#
# Get the horizontal coefficients at the 2nd level
#
tmpimwd[[ lt.to.name(2, "CD") ]]
# [1]  6.962251e-13  4.937486e-12  3.712157e-12 -3.064831e-12  6.962251e-13
# [6]  4.937486e-12  3.712157e-12 -3.064831e-12  6.962251e-13  4.937486e-12
# [11]  3.712157e-12 -3.064831e-12  6.962251e-13  4.937486e-12  3.712157e-12
# [16] -3.064831e-12
#
#
# If you want the coefficients returned as a matrix use the matrix function,
# i.e.
#
matrix(tmpimwd[[ lt.to.name(2, "CD") ]], 4,4)
#              [,1]          [,2]          [,3]          [,4]
#[1,]  6.962251e-13  6.962251e-13  6.962251e-13  6.962251e-13
#[2,]  4.937486e-12  4.937486e-12  4.937486e-12  4.937486e-12
#[3,]  3.712157e-12  3.712157e-12  3.712157e-12  3.712157e-12
#[4,] -3.064831e-12 -3.064831e-12 -3.064831e-12 -3.064831e-12
#
# Note that the dimensions of the matrix depend on the resolution level
# that you extract and dim = 2^level
</code></pre>

<hr>
<h2 id='madmad'>Compute square of median absolute deviation (mad) function.</h2><span id='topic+madmad'></span>

<h3>Description</h3>

<p>This function simply returns the square of the median absolute deviation (mad) function in S-Plus. This is required for supply to the <code><a href="#topic+threshold">threshold</a></code> series of functions which require estimates of spread on the variance scale (not the standard deviation scale). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>madmad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="madmad_+3A_x">x</code></td>
<td>
<p>The vector for which you wish to compute the square of mad on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The square of the median absolute deviation of the coefficients supplied by <code>x</code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.4.1 Copyright Guy Nason 1994 </p>


<h3>Note</h3>

<p>Its a MAD MAD world!</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+threshold">threshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#
# Generate some normal data with mean 0 and sd of 8
# and we'll also contaminate it with an outlier of 1000000
# This is akin to signal wavelet coefficients mixing with the noise.
#
ContamNormalData &lt;- c(1000000, rnorm(1000, mean=0, sd=8))
#
# What is the variance of the data?
#
var(ContamNormalData)
# [1] 999000792
#
# Wow, a seriously unrobust answer!
#
# How about the median absolute deviation?
#
mad(ContamNormalData)
# [1] 8.14832
# 
# A much better answer!
#
# Now let's use madmad to get the answer on the variance scale 
#
madmad(ContamNormalData)
# [1] 66.39512
#
# The true variance was 64, so the 66.39512 was a much better answer
# than that returned by the call to the variance function.
</code></pre>

<hr>
<h2 id='make.dwwt'>Compute diagonal of the matrix WWT</h2><span id='topic+make.dwwt'></span>

<h3>Description</h3>

<p>Computes the values which specify the covariance structure of complex-valued wavelet coefficients. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.dwwt(nlevels, filter.number = 3.1, family = "LinaMayrand") 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.dwwt_+3A_nlevels">nlevels</code></td>
<td>
<p>The number of levels of the wavelet decomposition.</p>
</td></tr>
<tr><td><code id="make.dwwt_+3A_filter.number">filter.number</code>, <code id="make.dwwt_+3A_family">family</code></td>
<td>
<p>Specifies the wavelet used; see filter.select for more details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>If real-valued signals are decomposed by a discrete wavelet transform using a complex-valued Daubechies wavelet (as described by Lina &amp; Mayrand (1995)), the resulting coefficients are complex-valued. The covariance structure of these coefficients are determined by the diagonal entries of the matrix
<code class="reqn">WW^T</code>. This function computes these values for use in shrinkage. For more details, see Barber &amp; Nason (2004) 
</p>


<h3>Value</h3>

<p>A vector giving the diagonal elements of <code class="reqn">WW^T</code>. 
</p>


<h3>RELEASE</h3>

<p>Part of the CThresh addon to WaveThresh. Copyright Stuart Barber and Guy Nason 2004. </p>


<h3>Author(s)</h3>

<p>Stuart Barber</p>


<h3>See Also</h3>

<p><code><a href="#topic+cthresh">cthresh</a></code>
</p>

<hr>
<h2 id='makegrid'>Interpolate data to a grid.</h2><span id='topic+makegrid'></span>

<h3>Description</h3>

<p>This function takes a set of univariate (x,y) data with x arbitrary in (0,1) and linearly interpolates (x,y) to an equally spaced dyadic grid. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makegrid(t, y, gridn = 2^(floor(log(length(t)-1,2)) + 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makegrid_+3A_t">t</code></td>
<td>
<p>A vector of <code>x</code> data. Each of the entries of <code>x</code> must lie between 0 and 1.</p>
</td></tr> 
<tr><td><code id="makegrid_+3A_y">y</code></td>
<td>
<p>A vector of <code>y</code> data. Each entry of <code>y</code> corresponds to the same-positioned entry in <code>x</code> and so<code>y</code> must be of the same length as <code>x</code>. </p>
</td></tr>
<tr><td><code id="makegrid_+3A_gridn">gridn</code></td>
<td>
<p>The number of grid points in the dyadic grid that the (x,y) gets interpolated to. By default this is the next power of two larger than the length of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One method for performing wavelet regression on data that is not equally spaced nor of power of two length is that described in Kovac, (1997) and Kovac and Silverman, (2000). 
</p>
<p>The Kovac-Silverman algorithm linearly interpolates arbitrarily spaced (x,y) data to a dyadic grid and applies wavelet shrinkage to the interpolated data. However, if one assumes that the original data obeys a signal+noise model with iid data the interpolated data will be correlated due to the interpolation. This fact needs to be taken into account after taking the DWT and before thresholding one realizes that each coefficient has its own variance. The Kovac-Silverman algorithm computes this variance efficiently using knowledge of the interpolation scheme. 
</p>


<h3>Value</h3>

<p>An object of class <code>griddata</code>.
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 Copyright Arne Kovac 1997
Copyright Guy Nason (help pages) 1999</p>


<h3>Author(s)</h3>

<p>Arne Kovac</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessc">accessc</a></code>, <code><a href="#topic+irregwd">irregwd</a></code>, <code><a href="#topic+newsure">newsure</a></code>, <code><a href="#topic+plot.irregwd">plot.irregwd</a></code>, <code><a href="#topic+threshold.irregwd">threshold.irregwd</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some values in (0,1), then sort them (for plotting)
#
tt &lt;- sort(runif(100))
#
# Now evaluate the \code{\link{doppler}} function and add
# some noise.
#
yy &lt;- doppler(tt) + rnorm(100, 0, 0.15)
#
# Now make the grid with this data
#
yygrid &lt;- makegrid(t=tt, y=yy)
#
# Jolly good. Now let's take the wavelet transform of this gridded data.
# Note that we have to use the \code{\link{irregwd}} function
# of the gridded data as it computes the variances of the coefficients
# as well as the coefficients themselves.
#
yyirregwd &lt;- irregwd(yygrid)
#
# You might want to plot the coefficients
#
# If you want to see the actual coefficients you have to first convert
# the class of the yyirregwd object to a wd object and then use
# \code{\link{plot.wd}} like this
#
yyirregwd2 &lt;- yyirregwd
class(yyirregwd2) &lt;- "wd"
## Not run: plot(yyirregwd2)
#
# If you want to see the variance factors (essentially the coefficient
# variances divided by the overall variance). Then just use
# \code{\link{plot.irregwd}}
#
## Not run: plot(yyirregwd)
#
# Ok. So you've seen the coefficients. Now let's do some thresholding.
#
yy.thresh.sure &lt;- threshold(yyirregwd, policy="sure", type="soft", dev=madmad)
#
# And now do the reconstruct
#
yy.wr &lt;- wr(yy.thresh.sure)
#
# And you can even plot the answer on the new grid!
#
## Not run: plot(yygrid$gridt, yy.wr, type="l")
#
# And superimpose the original data!
#
## Not run: points(tt, yy)
#
# This is sort of \code{Doppler} like!
</code></pre>

<hr>
<h2 id='makewpstDO'>Help page for a function</h2><span id='topic+makewpstDO'></span>

<h3>Description</h3>

<p>Takes two time series: one a real-valued discrete-time time
series, timeseries, the other, groups, a time series containing factor levels. This function
performs a discriminant analysis of groups on a subset of the best-correlating
nondecimated wavelet packets of timeseries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makewpstDO(timeseries, groups, filter.number=10, family="DaubExPhase",
	mincor=0.69999999999999996)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makewpstDO_+3A_timeseries">timeseries</code></td>
<td>
<p>The time series which is the &lsquo;dependent variable&rsquo;,
ie discrimination will be performed on the variables extracted
from the non-decimated wavelet packet transform of this time series</p>
</td></tr>
<tr><td><code id="makewpstDO_+3A_groups">groups</code></td>
<td>
<p>The factor levels as a time series</p>
</td></tr>
<tr><td><code id="makewpstDO_+3A_filter.number">filter.number</code></td>
<td>
<p>The smoothness of the wavelet involved in the
nondecimated wavelet packet transform. See <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="makewpstDO_+3A_family">family</code></td>
<td>
<p>The wavelet family, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="makewpstDO_+3A_mincor">mincor</code></td>
<td>
<p>Variables from the nondecimated wavelet packet transform
with correlations less than this argument will be discarded in the
first pass, and not considered as possible useful discriminants</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the &lsquo;discrimination&rsquo; version of the 
&quot;Wavelet packet transfer function modelling of nonstationary series&quot;
by Guy Nason and Theofanis Sapatinas, <em>Statistics and Computing</em>,
<b>12</b>, 45-56.
</p>
<p>The function first takes the non-decimated wavelet packet transform
of <code>timeseries</code>
using the <code><a href="#topic+wpst">wpst</a></code> function. Then the set of nondecimated wavelet
packets is put into matrix form using the <code><a href="#topic+wpst2discr">wpst2discr</a></code>
function. The <code><a href="#topic+Best1DCols">Best1DCols</a></code> function selects those variables
from the matrix whose correlation with the <code>groups</code> time series
is greater than <code>mincor</code>. The selected variables are put into a
reduced matrix. 
</p>
<p>The next step, <code><a href="#topic+BMdiscr">BMdiscr</a></code>,
performs a linear discriminant analysis of the
<code>groups</code> values onto the reduced matrix. In principle, one could have
carried out a discriminant analysis using the full matrix of all the
packets, but the problem is not well-conditioned and computationally
efficient. The strategy adopted by Nason and Sapatinas is to do a
&quot;first pass&quot; to select a large number of &quot;likely&quot; variables that might
contribute something to discrimination, and then carry out a &quot;second pass&quot;
which performs a more detailed analysis to jointly determine which variables
are the key ones for discrimination. 
</p>
<p>Note, using the discriminant model developed here, it is possible to
use future values of <code>timeseries</code> and the model to predict future
values of <code>groups</code>. See example below.
</p>


<h3>Value</h3>

<p>An object of class <code>wpstDO</code>. This is a list containing the following
components.
</p>
<table role = "presentation">
<tr><td><code>BPd</code></td>
<td>
<p>Object returned from the <code><a href="#topic+BMdiscr">BMdiscr</a></code> function.
Contains the reduced matrix and the discriminant object</p>
</td></tr>
<tr><td><code>BP</code></td>
<td>
<p>Object returned from the <code><a href="#topic+Best1DCols">Best1DCols</a></code> function,
essentially the reduced matrix and the groups variable.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>The details of the wavelet filter used. This is used
if the other components are used to perform discrimination on
new data one needs to know what wavelet was used to perform
the original nondecimated wavelet packet transform.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisplot.BP">basisplot.BP</a></code>,
<code><a href="#topic+Best1DCols">Best1DCols</a></code>,
<code><a href="#topic+BMdiscr">BMdiscr</a></code>,
<code><a href="#topic+wpst">wpst</a></code>,
<code><a href="#topic+wpst2discr">wpst2discr</a></code>,
<code><a href="#topic+wpstCLASS">wpstCLASS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Use BabySS and BabyECG data for this example.
#
# Want to predict future values of BabySS from future values of BabyECG
#
# Build model on first 256 values of both
#
data(BabyECG)
data(BabySS)
BabyModel &lt;- makewpstDO(timeseries=BabyECG[1:256], groups=BabySS[1:256],
	mincor=0.5)
#
# The results (ie print out answer)
#BabyModel
#Stationary wavelet packet discrimination object
#Composite object containing components:[1] "BPd"    "BP"     "filter"
#Fisher's discrimination: done
#BP component has the following information
#BP class object. Contains "best basis" information
#Components of object:[1] "nlevelsWT"     "BasisMatrix" "level"       "pkt"         "basiscoef"
#[6] "groups"
#Number of levels  8
#List of "best" packets
#Level id Packet id Basis coef
#[1,]        4         0  0.7340580
#[2,]        5         0  0.6811251
#[3,]        6         0  0.6443167
#[4,]        3         0  0.6193434
#[5,]        7         0  0.5967620
#[6,]        0         3  0.5473777
#[7,]        1        53  0.5082849
#
# You can plot the select basis graphically using
#
## Not run: basisplot(BabyModel$BP)
#
# An interesting thing are the final "best" packets, these form the
# "reduced" matrix, and the final discrimination is done on this
# In this case 7 wavelet packets were identified as being good for
# univariate high correlation.
#
# In the second pass lda analysis, using the reduced matrix, the following
# turns up as the best linear discriminant vectors
#
# The discriminant variables can be obtained by typing
#BabyModel$BPd$dm$scaling
#LD1        LD2
#[1,] 5.17130434  1.8961807
#[2,] 1.56487144 -3.5025251
#[3,] 1.69328553  1.1585477
#[4,] 3.63362324  8.4543247
#[5,] 0.15202947 -0.4530523
#[6,] 0.35659009 -0.3850318
#[7,] 0.09429836 -0.1281240
#
#
# Now, suppose we get some new data for the BabyECG time series.
# For the purposes of this example, this is just the continuing example
# ie BabyECG[257:512]. We can use our new discriminant model to predict
# new values of BabySS
#
BabySSpred &lt;- wpstCLASS(newTS=BabyECG[257:512], BabyModel)
#
# Let's look at the first 10 (eg) values of this prediction
#
#BabySSpred$class[1:10]
#[1] 4 4 4 4 4 4 4 4 4 4
#Good. Now let's look at what the "truth" was:
#BabySS[257:267]
#[1] 4 4 4 4 4 4 4 4 4 4
#Good. However, the don't agree everywhere, let's do a cross classification
#between the prediction and the truth.
#
#&gt; table(tmp2$class, BabySS[257:512])
#
#      1   2   3   4
#  1   4   1   1   0
#  2 116   0  23   3
#  4   2  12   0  94
#
#So class 3 and 4 agree pretty much, but class 1 has been mispredicted at class
#2 a lot.
</code></pre>

<hr>
<h2 id='makewpstRO'>
Make a wavelet packet regression object from a dependent and independent
time series variable.
</h2><span id='topic+makewpstRO'></span>

<h3>Description</h3>

<p>The idea here is to try and build facilities to enable
a transfer function model along
the lines of that described by Nason and Sapatinas 2002 in
<em>Statistics and Computing</em>. The idea is to turn the
<code>timeseries</code> variable into a set of nondecimated wavelet packets
which are already pre-selected to have some semblance of relationship
to the <code>response</code> time series. The function does not actually
perform any regression, in contrast to the related <code><a href="#topic+makewpstDO">makewpstDO</a></code>
but returns a data frame which the user can use to build their own models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makewpstRO(timeseries, response, filter.number = 10,
    family = "DaubExPhase", trans = logabs, percentage = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makewpstRO_+3A_timeseries">timeseries</code></td>
<td>

<p>The dependent variable time series. This series is decomposed
using the <code><a href="#topic+wpst">wpst</a></code> function into nondecimated
wavelet packets, need to be a power of two length.
</p>
</td></tr>
<tr><td><code id="makewpstRO_+3A_response">response</code></td>
<td>

<p>The independent or response time series.
</p>
</td></tr>
<tr><td><code id="makewpstRO_+3A_filter.number">filter.number</code></td>
<td>

<p>The type of wavelet used within <code>family</code>, see
<code><a href="#topic+filter.select">filter.select</a></code>.
</p>
</td></tr>
<tr><td><code id="makewpstRO_+3A_family">family</code></td>
<td>

<p>The family of wavelet, see <code><a href="#topic+filter.select">filter.select</a></code>
</p>
</td></tr>
<tr><td><code id="makewpstRO_+3A_trans">trans</code></td>
<td>

<p>A transform to apply to the nondecimated wavelet packet
coefficients before any selection
</p>
</td></tr>
<tr><td><code id="makewpstRO_+3A_percentage">percentage</code></td>
<td>

<p>The top <code>percentage</code> of nondecimated wavelet packets
that correlated best with the <code>response</code> series will
be preselected.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea behind this methodology is that a <code>response</code>
time series might not be directly related to the dependent
<code>timeseries</code> time series, but it might be related to the
nondecimated wavelet packets of the <code>timeseries</code>, these packets
can pick out various features of the <code>timeseries</code> including
certain delays, oscillations and others. 
</p>
<p>The best packets (the number if controlled by <code>percentage</code>), those
that correlate best with <code>response</code> are selected and returned.
The <code>response</code> and the best nondecimated wavelet packets
are returned in a data frame object and then any convenient form of
statistical modeling can be used to build a model of the <code>response</code> in
terms of the packet variables. 
</p>
<p>Once a model has been built it can be interpreted in the usual way, but
with respect to nondecimated wavelet packets.
</p>
<p>Note that nondecimated wavelet packets are essential, as they are all
of the same length as the original response series. If a decimated
wavelet packet algorithm had been used then it is not clear what to
do with the &quot;gaps&quot;!
</p>
<p>If new <code>timeseries</code> data comes along the <code><a href="#topic+wpstREGR">wpstREGR</a></code>
function can be used to extract the identical packets as the ones
produced by this function (as the result of this function stores the
identities of these packets). Then the statistical modelling that
build the model from the output of this function, can be used to
predict future values of the <code>response</code> time series from future
values of the <code>timeseries</code> series.
</p>


<h3>Value</h3>

<p>An object of class <code>wpstRO</code> containing the following items
</p>
<table role = "presentation">
<tr><td><code>df</code></td>
<td>
<p>A data frame containing the <code>response</code> time series and
a number of columns/variables/packets that correlated with
response series. These are all entitled &quot;Xn&quot; where n is some
integer</p>
</td></tr> 
<tr><td><code>ixvec</code></td>
<td>
<p>A packet index vector. After taking the nondecimated wavelet
packet transform, all the packets are stored in a matrix. This
vector indicates those that were preselected</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>The original level from which the preselected vectors came from</p>
</td></tr>
<tr><td><code>pktix</code></td>
<td>
<p>Another index vector, this time referring to the original
wavelet packet object, not the matrix in which they subsequently
got stored</p>
</td></tr>
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of resolution levels in the original wavelet
packet object</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>The correlation vector. These are the values of the correlations
of the packets with the response, then sorted in terms of decreasing
absolute correlation</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>The wavelet filter details</p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>The transformation function actually used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G P Nason
</p>


<h3>References</h3>

<p>Nason, G.P. and Sapatinas, T. (2002) Wavelet packet transfer function
modeling of nonstationary time series. <em>Statistics and Computing</em>,
<b>12</b>, 45-56.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makewpstDO">makewpstDO</a></code>, <code><a href="#topic+wpst">wpst</a></code>, <code><a href="#topic+wpstREGR">wpstREGR</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BabyECG)
baseseries &lt;- BabyECG[1:256]
#
# Make up a FICTITIOUS response series!
#
response &lt;- BabyECG[6:261]*3+52
#
# Do the modeling
#
BabeModel &lt;- makewpstRO(timeseries=baseseries, response=response)
#Level: 0  ..........
#1  ..........
#2  ..........
#3  ..........
#4  ................
#5  
#6  
#7  
#
#Contains SWP coefficients
#Original time series length:  256 
#Number of bases:  25 
#Some basis selection performed
#       Level Pkt Index Orig Index      Score
#[1,]     5         0        497  0.6729833
#[2,]     4         0        481  0.6120771
#[3,]     6         0        505  0.4550616
#[4,]     3         0        449  0.4309924
#[5,]     7         0        509  0.3779385
#[6,]     1        53        310  0.3275428
#[7,]     2        32        417 -0.3274858
#[8,]     2        59        444 -0.2912863
#[9,]     3        16        465 -0.2649679
#[10,]     1       110        367  0.2605178
#etc. etc.
#
#
# Let's look at the data frame component
#
names(BabeModel$df)
# [1] "response" "X1"       "X2"       "X3"       "X4"       "X5"      
# [7] "X6"       "X7"       "X8"       "X9"       "X10"      "X11"     
#[13] "X12"      "X13"      "X14"      "X15"      "X16"      "X17"     
#[19] "X18"      "X19"      "X20"      "X21"      "X22"      "X23"     
#[25] "X24"      "X25"    
#
# Generate a formula including all of the X's (note we could use the .
# argument, but we later want to be more flexible
#
xnam &lt;- paste("X", 1:25, sep="")
fmla1 &lt;- as.formula(paste("response ~ ", paste(xnam, collapse= "+")))
#
# Now let's fit a linear model, the response on all the Xs
#
Babe.lm1 &lt;- lm(fmla1, data=BabeModel$df)
#
# Do an ANOVA to see what's what
#
anova(Babe.lm1)
#Analysis of Variance Table
#
#Response: response
#	Df Sum Sq Mean Sq  F value    Pr(&gt;F)    
#X1          1 214356  214356 265.7656 &lt; 2.2e-16 ***
#X2          1  21188   21188  26.2701 6.289e-07 ***
#X3          1  30534   30534  37.8565 3.347e-09 ***
#X4          1    312     312   0.3871 0.5344439    
#X5          1   9275    9275  11.4999 0.0008191 ***
#X6          1     35      35   0.0439 0.8343135    
#X7          1    195     195   0.2417 0.6234435    
#X8          1     94      94   0.1171 0.7324600    
#X9          1    331     331   0.4103 0.5224746    
#X10         1      0       0   0.0006 0.9810560    
#X11         1    722     722   0.8952 0.3450597    
#X12         1      0       0   0.0004 0.9850243    
#X13         1     77      77   0.0959 0.7570769    
#X14         1   2770    2770   3.4342 0.0651404 .  
#X15         1      6       6   0.0072 0.9326155   
#X16         1    389     389   0.4821 0.4881649    
#X17         1     44      44   0.0544 0.8157015    
#X18         1     44      44   0.0547 0.8152640    
#X19         1   4639    4639   5.7518 0.0172702 *  
#X20         1    490     490   0.6077 0.4364469    
#X21         1    389     389   0.4823 0.4880660    
#X22         1     85      85   0.1048 0.7463860    
#X23         1   1710    1710   2.1198 0.1467664    
#X24         1     12      12   0.0148 0.9033427    
#X25         1     82      82   0.1019 0.7498804    
#Residuals 230 185509     807                       
#---
#Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 
#
# Looks like X1, X2, X3, X5, X14 and X19 are "significant". Also throw in
# X4 as it was a highly ranked preselected variable, and refit
#
fmla2 &lt;- response ~ X1 + X2 + X3 + X4 + X5 + X14 + X19
Babe.lm2 &lt;- lm(fmla2, data=BabeModel$df)
#
# Let's see the ANOVA table for this
#
anova(Babe.lm2)
#Analysis of Variance Table
#
#Response: response
#	Df Sum Sq Mean Sq  F value    Pr(&gt;F)    
#X1          1 214356  214356 279.8073 &lt; 2.2e-16 ***
#X2          1  21188   21188  27.6581 3.128e-07 ***
#X3          1  30534   30534  39.8567 1.252e-09 ***
#X4          1    312     312   0.4076 0.5238034    
#X5          1   9275    9275  12.1075 0.0005931 ***
#X14         1   3095    3095   4.0405 0.0455030 *  
#X19         1   4540    4540   5.9259 0.0156263 *  
#Residuals 248 189989     766                       
#---
#Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 
#
# So, let's drop X4, refit, and then do ANOVA
#
Babe.lm3 &lt;- update(Babe.lm2, . ~ . -X4)
anova(Babe.lm3)
#
# After viewing this, drop X14
#
Babe.lm4 &lt;- update(Babe.lm3, . ~ . -X14)
anova(Babe.lm4)
#
# Let's plot the original series, and the "fitted" one
#
## Not run: ts.plot(BabeModel$df[["response"]])
## Not run: lines(fitted(Babe.lm4), col=2)
#
# Let's plot the wavelet packet basis functions associated with the model
#
## Not run: oldpar &lt;- par(mfrow=c(2,2))
## Not run: z &lt;- rep(0, 256)
## Not run: zwp &lt;- wp(z, filter.number=BabeModel$filter$filter.number,
    family=BabeModel$filter$family)
## End(Not run)
## Not run: draw(zwp, level=BabeModel$level[1], index=BabeModel$pktix[1], main="", sub="")
## Not run: draw(zwp, level=BabeModel$level[2], index=BabeModel$pktix[2], main="", sub="")
## Not run: draw(zwp, level=BabeModel$level[3], index=BabeModel$pktix[3], main="", sub="")
## Not run: draw(zwp, level=BabeModel$level[5], index=BabeModel$pktix[5], main="", sub="") 
## Not run: par(oldpar)
#
# Now let's do some prediction of future values of the response, given
# future values of the baseseries
#
newseries &lt;- BabyECG[257:512]
#
# Get the new data frame
#
newdfinfo &lt;- wpstREGR(newTS = newseries, wpstRO=BabeModel)
#
# Now use the best model (Babe.lm4) with the new data frame (newdfinfo)
# to predict new values of response
#
newresponse &lt;- predict(object=Babe.lm4, newdata=newdfinfo)
#
# What is the "true" response, well we made up a response earlier, so let's
# construct the true response for this future data (in your case you'll
# have a separate genuine response variable)
#
trucfictresponse &lt;- BabyECG[262:517]*3+52
#
# Let's see them plotted on the same plot
#
## Not run: ts.plot(trucfictresponse)
## Not run: lines(newresponse, col=2)
#
# On my plot they look tolerably close!
#
</code></pre>

<hr>
<h2 id='MaNoVe'>Make Node Vector (using Coifman-Wickerhauser best-basis type algorithm)</h2><span id='topic+MaNoVe'></span>

<h3>Description</h3>

<p>This generic function chooses a &ldquo;best-basis&rdquo; using the Coifman-Wickerhauser (1992) algorithm.  This function is generic.  Particular methods exist:
<code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code> and <code><a href="#topic+MaNoVe.wst">MaNoVe.wst</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaNoVe(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaNoVe_+3A_...">...</code></td>
<td>
<p>Methods may have other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all.
</p>


<h3>Value</h3>

<p>A node vector, which describes a particular basis specification relevant
to the kind of object that the function was applied to.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code>,
<code><a href="#topic+MaNoVe.wst">MaNoVe.wst</a></code>,
<code><a href="#topic+wp.object">wp.object</a></code>,
<code><a href="#topic+wst.object">wst.object</a></code>,
<code><a href="#topic+wp">wp</a></code>,
<code><a href="#topic+wst">wst</a></code></p>

<hr>
<h2 id='MaNoVe.wp'>Make Node Vector (using Coifman-Wickerhauser best-basis type algorithm) on wavelet packet object</h2><span id='topic+MaNoVe.wp'></span>

<h3>Description</h3>

<p>This method chooses a &quot;best-basis&quot; using the Coifman-Wickerhauser (1992)
algorithm applied to wavelet packet, <code><a href="#topic+wp.object">wp.object</a></code>, objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
MaNoVe(wp, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaNoVe.wp_+3A_wp">wp</code></td>
<td>
<p>The wp object for which you wish to find the best basis for.</p>
</td></tr>
<tr><td><code id="MaNoVe.wp_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to print out informative messages</p>
</td></tr>
<tr><td><code id="MaNoVe.wp_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>A wavelet packet node vector object of class <code>nvwp</code>,
a basis description. This can
be fed into a basis inversion using, say, the function
<code><a href="#topic+InvBasis">InvBasis</a></code>.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+InvBasis">InvBasis</a></code>,
<code><a href="#topic+MaNoVe">MaNoVe</a></code>,
<code><a href="#topic+MaNoVe.wst">MaNoVe.wst</a></code>,
<code><a href="#topic+wp.object">wp.object</a></code>,
<code><a href="#topic+wp">wp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example of use of this function in the examples section
# of the help of plot.wp
#
# A node vector vnv is created there that gets plotted.
#
</code></pre>

<hr>
<h2 id='MaNoVe.wst'>Make Node Vector (using Coifman-Wickerhauser best-basis type algorithm) on nondecimated wavelet transform object</h2><span id='topic+MaNoVe.wst'></span>

<h3>Description</h3>

<p>This method chooses a &quot;best-basis&quot; using the Coifman-Wickerhauser (1992)
algorithm applied to nondecimated wavelet transform,
<code><a href="#topic+wst.object">wst.object</a></code>, objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
MaNoVe(wst, entropy=Shannon.entropy, verbose=FALSE,
	stopper=FALSE, alg="C", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaNoVe.wst_+3A_wst">wst</code></td>
<td>
<p>The wst object for which you wish to find the best basis for.</p>
</td></tr>
<tr><td><code id="MaNoVe.wst_+3A_entropy">entropy</code></td>
<td>
<p>The function used for computing the entropy of a vector</p>
</td></tr>
<tr><td><code id="MaNoVe.wst_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to print out informative messages</p>
</td></tr>
<tr><td><code id="MaNoVe.wst_+3A_stopper">stopper</code></td>
<td>
<p>Whether the computations are temporarily stopped after
each packet. This can be useful in conjunction with the
<code>verbose</code> argument so as to see computations proceed one
packet at a time.</p>
</td></tr>
<tr><td><code id="MaNoVe.wst_+3A_alg">alg</code></td>
<td>
<p>If &quot;C&quot; then fast compiled C code is used (in which case
the <code>entropy</code> function is ignored and the C code uses
an internal Shannon entropy. Otherwise, slower R code is used
but an arbitrary <code>entropy</code> argument can be used</p>
</td></tr>
<tr><td><code id="MaNoVe.wst_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>A wavelet node vector object, of class <code>nv</code>,
a basis description. This can
be fed into a basis inversion using, say, the function
<code><a href="#topic+InvBasis">InvBasis</a></code>.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+InvBasis">InvBasis</a></code>,
<code><a href="#topic+MaNoVe">MaNoVe</a></code>,
<code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code>,
<code><a href="#topic+Shannon.entropy">Shannon.entropy</a></code>,
<code><a href="#topic+wst.object">wst.object</a></code>,
<code><a href="#topic+wst">wst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# What follows is a simulated denoising example. We first create our
# "true" underlying signal, v. Then we add some noise to it with a signal
# to noise ratio of 6. Then we take the packet-ordered non-decimated wavelet
# transform and then threshold that.
#
# Then, to illustrate this function, we compute a "best-basis" node vector
# and use that to invert the packet-ordered NDWT using this basis. As a
# comparison we also use the Average Basis method
# (cf Coifman and Donoho, 1995). 
#
# NOTE: It is IMPORTANT to note that this example DOES not necessarily
# use an appropriate or good threshold or necessarily the right underlying
# wavelet. I am trying to show the general idea and please do not "quote" this
# example in literature saying that this is the way that WaveThresh (or
# any of the associated authors whose methods it attempts to implement)
# does it. Proper denoising requires a lot of care and thought.
#
#
# Here we go....
#
# Create an example vector (the Donoho and Johnstone heavisine function)
#
v &lt;- DJ.EX()$heavi
#
# Add some noise with a SNR of 6
#
vnoise &lt;- v + rnorm(length(v), 0, sd=sqrt(var(v))/6)
#
# Take packet-ordered non-decimated wavelet transform (note default wavelet
# used which might not be the best option for denoising performance).
#
vnwst &lt;- wst(vnoise)
#
# Let's take a look at the wavelet coefficients of vnoise
#
## Not run: plot(vnwst)

#
# Wow! A huge number of coefficients, but mostly all noise.
#
#
# Threshold the resultant NDWT object.
# (Once again default arguments are used which are certainly not optimal).
#
vnwstT &lt;- threshold(vnwst)
#
# Let's have a look at the thresholded wavelet coefficients
#
## Not run: plot(vnwstT)

#
# Ok, a lot of the coefficients have been removed as one would expect with
# universal thresholding
#
#
# Now select packets for a basis using a Coifman-Wickerhauser algorithm
#
vnnv &lt;- MaNoVe(vnwstT)
#
# Let's have a look at which packets got selected
#
vnnv
# Level :  9  Action is  R (getpacket Index:  1 )
# Level :  8  Action is  L (getpacket Index:  2 )
# Level :  7  Action is  L (getpacket Index:  4 )
# Level :  6  Action is  L (getpacket Index:  8 )
# Level :  5  Action is  R (getpacket Index:  17 )
# Level :  4  Action is  L (getpacket Index:  34 )
# Level :  3  Action is  L (getpacket Index:  68 )
# Level :  2  Action is  R (getpacket Index:  137 )
# Level :  1  Action is  R (getpacket Index:  275 )
# There are  10  reconstruction steps
#
# So, its not the regular decimated wavelet transform!
#
# Let's invert the representation with respect to this basis defined by
# vnnv
#
vnwrIB &lt;- InvBasis(vnwstT, vnnv)
#
# And also, for completeness let's do an Average Basis reconstruction.
#
vnwrAB &lt;- AvBasis(vnwstT)
#
# Let's look at the Integrated Squared Error in each case.
#
sum( (v - vnwrIB)^2)
# [1] 386.2501
#
sum( (v - vnwrAB)^2)
# [1] 328.4520
#
# So, for this limited example the average basis method does better. Of course,
# for *your* simulation it could be the other way round. "Occasionally", the
# inverse basis method does better. When does this happen? A good question.
#
# Let's plot the reconstructions and also the original
#
## Not run: plot(vnwrIB, type="l")
## Not run: lines(vnwrAB, lty=2)
## Not run: lines(v, lty=3)

#
# The dotted line is the original. Neither reconstruction picks up the
# spikes in heavisine very well. The average basis method does track the
# original signal more closely though.
#
</code></pre>

<hr>
<h2 id='mfilter.select'>Provide filter coefficients for multiple wavelets.</h2><span id='topic+mfilter.select'></span>

<h3>Description</h3>

<p>This function returns the filter coefficients necessary for doing a discrete multiple wavelet transform (and its inverse). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfilter.select(type = "Geronimo")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mfilter.select_+3A_type">type</code></td>
<td>
<p>The name for the multiple wavelet basis. The two possible types are &quot;Geronimo&quot; and &quot;Donovan3&quot;</p>
</td></tr></table>
<p>. 
</p>


<h3>Details</h3>

<p>This function supplies the multiple wavelet filter coefficients required by the <code><a href="#topic+mwd">mwd</a></code> function.
</p>
<p>A multiple wavelet filter is somewhat different from a single wavelet filter. Firstly the filters are made up of matrices not single coefficients. Secondly there is no simple expression for the high pass coefficients G in terms of the low pass coefficients H, so both sets of coefficients must be specified. Note also that the transpose of the filter coefficients are used in the inverse transform, an unnecessary detail with scalar coefficients. There are two filters available at the moment. Geronimo is the default, and is recommended as it has been checked thoroughly. Donovan3 uses three orthogonal wavelets described in Donovan et al. but this coding has had little testing. 
</p>
<p>See Donovan, Geronimo and Hardin, 1996 and Geronimo, Hardin and Massopust, 1994. 
</p>
<p>This function fulfils the same purpose as the <code><a href="#topic+filter.select">filter.select</a></code> function does for the standard DWT <code><a href="#topic+wd">wd</a></code>. 
</p>


<h3>Value</h3>

<p>A list is returned with the following eight components which describe the filter:
</p>
<table role = "presentation">
<tr><td><code>type</code></td>
<td>
<p>The multiple wavelet basis type string.</p>
</td></tr> 
<tr><td><code>H</code></td>
<td>
<p>A vector containing the low pass filter coefficients.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>A vector containing the high pass pass filter coefficients.</p>
</td></tr> 
<tr><td><code>name</code></td>
<td>
<p>A character string containing the full name of the filter.</p>
</td></tr>
<tr><td><code>nphi</code></td>
<td>
<p>The number of scaling functions in the multiple wavelet basis.</p>
</td></tr> 
<tr><td><code>npsi</code></td>
<td>
<p>The number of wavelet functions in the multiple wavelet basis.</p>
</td></tr>
<tr><td><code>NH</code></td>
<td>
<p>The number of matrix coefficients in the filter. This is different from length(H).</p>
</td></tr>
<tr><td><code>ndecim</code></td>
<td>
<p>The decimation factor. I.e. the scale ratio between two successive resolution levels.</p>
</td></tr>
</table>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie 1995-6)</p>


<h3>Author(s)</h3>

<p>Tim Downie</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.mwd">accessC.mwd</a></code>, <code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+mwd">mwd</a></code>, <code><a href="#topic+mwr">mwr</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>, <code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This function is currently used by `mwr' and `mwd' in decomposing and
#reconstructing, however you can view the coefficients.
#
# look at the filter coefficients for Geronimo multiwavelet
#
mfilter.select()
#$type:
#[1] "Geronimo"
#
#$name:
#[1] "Geronimo Multiwavelets"
#
#$nphi:
#[1] 2
#
#$npsi:
#[1] 2
#
#$NH:
#[1] 4
#
#$ndecim:
#[1] 2
#$H:
# [1]  0.4242641  0.8000000 -0.0500000 -0.2121320  0.4242641  0.0000000
# [7]  0.4500000  0.7071068  0.0000000  0.0000000  0.4500000 -0.2121320
#[13]  0.0000000  0.0000000 -0.0500000  0.0000000
#
#$G:
# [1] -0.05000000 -0.21213203  0.07071068  0.30000000  0.45000000 -0.70710678
#
# [7] -0.63639610  0.00000000  0.45000000 -0.21213203  0.63639610 -0.30000000
#[13] -0.05000000  0.00000000 -0.07071068  0.00000000

</code></pre>

<hr>
<h2 id='mfirst.last'>Build a first/last database for multiple wavelet transforms. </h2><span id='topic+mfirst.last'></span>

<h3>Description</h3>

<p>This function is not intended for user use, but is used by various functions involved in computing and displaying multiple wavelet transforms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfirst.last(LengthH, nlevels, ndecim, type = "wavelet", bc = "periodic")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mfirst.last_+3A_lengthh">LengthH</code></td>
<td>
<p>Number of filter matrix coefficients.</p>
</td></tr> 
<tr><td><code id="mfirst.last_+3A_nlevels">nlevels</code></td>
<td>
<p>Number of levels in the decomposition</p>
</td></tr> 
<tr><td><code id="mfirst.last_+3A_ndecim">ndecim</code></td>
<td>
<p>The decimation scale factor for the multiple wavelet basis.</p>
</td></tr> 
<tr><td><code id="mfirst.last_+3A_type">type</code></td>
<td>
<p>Whether the transform is non-decimated or ordinary (wavelet). The non-decimated multiple wavelet transform is not yet supported.</p>
</td></tr>
<tr><td><code id="mfirst.last_+3A_bc">bc</code></td>
<td>
<p>This argument determines how the boundaries of the the function are to be handled. The permitted values are periodic or <code>symmetric</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose you begin with <code>2^m</code>=2048 coefficient vectors. At the next level you would expect 1024 smoothed data vectors, and 1024 wavelet vectors, and if <code>bc="periodic"</code> this is indeed what happens. However, if <code>bc="symmetric"</code> you actually need more than 1024 (as the wavelets extend over the edges). The first last database keeps track of where all these &quot;extras&quot; appear and also where they are located in the packed vectors C and D of pyramidal coefficients within wavelet structures. 
</p>
<p>For examples, given a <code>first.last.c</code> row of 
</p>
<p style="text-align: center;"><code class="reqn">-2 3 20</code>
</p>
 
<p>The &lsquo;position&rsquo; of the coefficient vectors would be 
</p>
<p style="text-align: center;"><code class="reqn">c_{-2}, c_{-1}, c_{0}, c_{1}, c_{2}, c_{3}</code>
</p>

<p>In other words, there are 6 coefficients, starting at -2 and ending at 3, and the first of these (<code class="reqn">c_{-2}</code>) appears at column 20 of the <code>$C</code> component matrix of the wavelet structure. 
</p>
<p>You can &ldquo;do&rdquo; first.last in your head for periodic boundary handling but for more general boundary treatments (e.g. symmetric) first.last is indispensable. 
</p>
<p>The numbers in first last databases were worked out from inequalities derived from: Daubechies, I. (1988). 
</p>


<h3>Value</h3>

<p>A first/last database structure, a list containing the following information: 
</p>
<table role = "presentation">
<tr><td><code>first.last.c</code></td>
<td>
<p>A <code>(m+1)x3</code> matrix. The first column specifies the real index of the first coefficient vector of the smoothed data at a level, the 2nd column is the real index of the last coefficient vector, the last column specifies the offset of the first smoothed datum at that level. The offset is used by the C code to work out where the beginning of the sequence is within a packed vector of the pyramid structure. The first and 2nd columns can be used to work out how many numbers there are at a level. If bc=&quot;periodic&quot; then the pyramid is a true power of 2 pyramid, that is it starts with a power of 2, and the next level is half of the previous. If bc=&quot;symmetric&quot; then the pyramid is nearly exactly a power of 2, but not quite, see the Details section for why this is so.</p>
</td></tr>
<tr><td><code>nvecs.c</code></td>
<td>
<p>The number of C coefficient vectors.</p>
</td></tr> 
<tr><td><code>first.last.d</code></td>
<td>
<p>A <code>mx3</code> matrix. As for <code>first.last.c</code> but for the wavelet coefficients packed as the D component of a wavelet structure.</p>
</td></tr>
<tr><td><code>nvecs.d</code></td>
<td>
<p>The number of <code>D</code> coefficient vectors.</p>
</td></tr> 
</table>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie 1995-6)</p>


<h3>Author(s)</h3>

<p>Tim Downie</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.mwd">accessC.mwd</a></code>, <code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+mwd">mwd</a></code>, <code><a href="#topic+mwr">mwr</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>, <code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#To see the housekeeping variables for a decomposition with
# 4 filter coefficient matices
# 5 resolution levels and a decimation scale of two
# use:
mfirst.last(4,5,2)
# $first.last.c:
#	 First Last Offset
# [1,]     0    0     62
# [2,]     0    1     60
# [3,]     0    3     56
# [4,]     0    7     48
# [5,]     0   15     32
# [6,]     0   31      0
# 
# $nvecs.c:
# [1] 63
# 
# $first.last.d:
#	 First Last Offset
# [1,]     0    0     30
# [2,]     0    1     28
# [3,]     0    3     24
# [4,]     0    7     16
# [5,]     0   15      0
# 
# $nvecs.d:
# [1] 31
</code></pre>

<hr>
<h2 id='modernise'>Generic function to upgrade a V2 WaveThresh object to V4</h2><span id='topic+modernise'></span>

<h3>Description</h3>

<p>Not really used in practice. The function <code><a href="#topic+IsEarly">IsEarly</a></code>
can be used to tell if an object comes from an earlier version of
wavethresh. Note that the earlier version only has a <code><a href="#topic+wd.object">wd.object</a></code>
class object so there is only a method for that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modernise(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modernise_+3A_...">...</code></td>
<td>
<p>Other objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>A modernised version of the object.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+IsEarly">IsEarly</a></code>,<code><a href="#topic+modernise.wd">modernise.wd</a></code></p>

<hr>
<h2 id='modernise.wd'>Modernise a wd class object</h2><span id='topic+modernise.wd'></span>

<h3>Description</h3>

<p>Upgrade a version 2 <code><a href="#topic+wd.object">wd.object</a></code> to version 4. 
The function <code><a href="#topic+IsEarly">IsEarly</a></code> can tell if the object comes from
an earlier version of WaveThresh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
modernise(wd, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modernise.wd_+3A_wd">wd</code></td>
<td>
<p>The wd object you wish to modernise</p>
</td></tr>
<tr><td><code id="modernise.wd_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all.
</p>


<h3>Value</h3>

<p>The modernised object.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>

<hr>
<h2 id='mpostfilter'>Multiwavelet postfilter</h2><span id='topic+mpostfilter'></span>

<h3>Description</h3>

<p>A multiwavelet postfilter turns a multivariate sequence into a univariate
sequence. As such, the postfilter is used
on the inverse transform, it is the inverse of an earlier used prefilter.
</p>
<p>Not intended for direct user use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpostfilter(C, prefilter.type, filter.type, 
    nphi, npsi, ndecim, nlevels, verbose = FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpostfilter_+3A_c">C</code></td>
<td>
<p>The multivariate sequence you wish to turn back into a univariate
one using the inverse of an earlier prefilter operation.</p>
</td></tr>
<tr><td><code id="mpostfilter_+3A_prefilter.type">prefilter.type</code></td>
<td>
<p>Controls the type of prefilter (see Tim Downie's 
PhD thesis, or references therein. Types include <code>Minimal</code>,
<code>Identity</code>, <code>Repeat</code>, <code>Interp</code>, <code>default</code>,
<code>Xia</code>, <code>Roach1</code>, <code>Roach3</code>, <code>Donovan3</code> or
<code>Linear</code></p>
</td></tr>
<tr><td><code id="mpostfilter_+3A_filter.type">filter.type</code></td>
<td>
<p>The type of multiwavelet: can be <code>Geronimo</code>
or <code>Donovan3</code></p>
</td></tr>
<tr><td><code id="mpostfilter_+3A_nphi">nphi</code></td>
<td>
<p>The number of father wavelets in the system</p>
</td></tr>
<tr><td><code id="mpostfilter_+3A_npsi">npsi</code></td>
<td>
<p>The number of mother wavelets in the system</p>
</td></tr>
<tr><td><code id="mpostfilter_+3A_ndecim">ndecim</code></td>
<td>
<p>The ndecim parameter (not apparently used here)</p>
</td></tr>
<tr><td><code id="mpostfilter_+3A_nlevels">nlevels</code></td>
<td>
<p>The number of levels in the multiwavelet transform</p>
</td></tr>
<tr><td><code id="mpostfilter_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE then informative messages are printed as the
function progresses</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>The appropriate postfiltered data.
</p>


<h3>Author(s)</h3>

<p>Tim Downie</p>


<h3>See Also</h3>

<p><code><a href="#topic+mprefilter">mprefilter</a></code>,<code><a href="#topic+mwd">mwd</a></code></p>

<hr>
<h2 id='mprefilter'>Multiwavelet prefilter</h2><span id='topic+mprefilter'></span>

<h3>Description</h3>

<p>A multiwavelet prefilter turns a univariate sequence into a bivariate
(in this case) sequence suitable for processing by a multiwavelet
transform, such as <code><a href="#topic+mwd">mwd</a></code>. As such, the prefilter is used
on the forward transform.
</p>
<p>Not intended for direct user use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mprefilter(data, prefilter.type, filter.type, nlevels, nvecs.c,
    nphi, npsi, ndecim, verbose = FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mprefilter_+3A_data">data</code></td>
<td>
<p>The univariate sequence that you wish to turn into a multivariate one</p>
</td></tr>
<tr><td><code id="mprefilter_+3A_prefilter.type">prefilter.type</code></td>
<td>
<p>Controls the type of prefilter (see Tim Downie's 
PhD thesis, or references therein. Types include <code>Minimal</code>,
<code>Identity</code>, <code>Repeat</code>, <code>Interp</code>, <code>default</code>,
<code>Xia</code>, <code>Roach1</code>, <code>Roach3</code>, <code>Donovan3</code> or
<code>Linear</code></p>
</td></tr>
<tr><td><code id="mprefilter_+3A_filter.type">filter.type</code></td>
<td>
<p>The type of multiwavelet: can be <code>Geronimo</code>
or <code>Donovan3</code></p>
</td></tr>
<tr><td><code id="mprefilter_+3A_nlevels">nlevels</code></td>
<td>
<p>The number of levels in the multiwavelet transform</p>
</td></tr>
<tr><td><code id="mprefilter_+3A_nvecs.c">nvecs.c</code></td>
<td>
<p>Parameter obtained from the mfirst.last function
related to the particular filters</p>
</td></tr>
<tr><td><code id="mprefilter_+3A_nphi">nphi</code></td>
<td>
<p>The number of father wavelets in the system</p>
</td></tr>
<tr><td><code id="mprefilter_+3A_npsi">npsi</code></td>
<td>
<p>The number of mother wavelets in the system</p>
</td></tr>
<tr><td><code id="mprefilter_+3A_ndecim">ndecim</code></td>
<td>
<p>The ndecim parameter (not apparently used here)</p>
</td></tr>
<tr><td><code id="mprefilter_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE then informative messages are printed as the
function progresses</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>The appropriate prefiltered data.
</p>


<h3>Author(s)</h3>

<p>Tim Downie</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpostfilter">mpostfilter</a></code>,<code><a href="#topic+mwd">mwd</a></code></p>

<hr>
<h2 id='mwd'>Discrete multiple wavelet transform (decomposition).</h2><span id='topic+mwd'></span>

<h3>Description</h3>

<p>This function performs the discrete multiple wavelet transform (DMWT). Using an adaption of Mallat's pyramidal algorithm. The DMWT gives vector wavelet coefficients. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mwd(data, prefilter.type = "default", filter.type = "Geronimo",
        bc ="periodic", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mwd_+3A_data">data</code></td>
<td>
<p>A vector containing the data you wish to decompose. The length of this vector must be a power of 2 times the dimension of the DMWT (multiplicity of wavelets).</p>
</td></tr>
<tr><td><code id="mwd_+3A_prefilter.type">prefilter.type</code></td>
<td>
<p>This chooses the method of preprocessing required. The arguments will depend on filter.type, but &quot;default&quot; will always work.</p>
</td></tr>
<tr><td><code id="mwd_+3A_filter.type">filter.type</code></td>
<td>
<p>Specifies which multi wavelet filter to use, The options are &quot;<code>Geronimo</code>&quot; (dimension 2) or &quot;<code>Donovan3</code>&quot; (dimension 3). The latter has not been tested fully and may contain bugs. See the function <code><a href="#topic+mfilter.select">mfilter.select</a></code> for further details.</p>
</td></tr> 
<tr><td><code id="mwd_+3A_bc">bc</code></td>
<td>
<p>specifies the boundary handling. If <code>bc=="periodic"</code> the default, then the function you decompose is assumed to be periodic on its interval of definition, if <code>bc=="symmetric"</code> then the function beyond its boundaries is assumed to be a symmetric reflection of the function in the boundary.</p>
</td></tr>
<tr><td><code id="mwd_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the computations progress. Such messages are generally annoying so it is turned off by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code implements Mallat's pyramid algorithm adapted for multiple wavelets using Xia, Geronimo, Hardin and Suter, 1996. The method takes a data vector of length <code>2^J*M</code>, and preprocesses it. This has two effects, firstly it puts the data into matrix form and then filters it so that the DMWT can operate more efficiently Most of the technical details are similar to the single wavelet transform except for the matrix algebra considerations, and the prefiltering process. See Downie and Silverman (1998) for further details and how this transform can be used in a statistical context.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+mwd">mwd</a></code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie 1996)</p>


<h3>Author(s)</h3>

<p>Tim Downie
</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.mwd">accessC.mwd</a></code>, <code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mfilter.select">mfilter.select</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+mwr">mwr</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>, <code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y
## Not run: ts.plot(test.data)
#
# Decompose test.data with multiple wavelet transform and
# plot the wavelet coefficients
#
tdmwd &lt;- mwd(test.data)
## Not run: plot(tdmwd)
#[1] 1.851894 1.851894 1.851894 1.851894 1.851894 1.851894 1.851894
#
# You should see a plot with wavelet coefficients like in
#\code{\link{plot.wd}} but at each coefficient position
# there are two coefficients in two different colours one for each of
# the wavelets at that position.
#
# Note the scale for each level is returned by the function.
</code></pre>

<hr>
<h2 id='mwd.object'>Multiple wavelet decomposition object (1D) </h2><span id='topic+mwd.object'></span>

<h3>Description</h3>

<p>These are objects of class 
</p>
<p><code>mwd</code>
</p>
<p>They represent a decomposition of a function with respect to a multiple wavelet basis. 
</p>


<h3>Details</h3>

<p>To retain your sanity the C and D coefficients should be extracted by the <code><a href="#topic+accessC">accessC</a></code> and <code><a href="#topic+accessD">accessD</a></code> functions and put using the <code><a href="#topic+putC">putC</a></code> and <code><a href="#topic+putD">putD</a></code> functions, rather than by the <code>$</code> operator. 
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate &lsquo;mwd&rsquo; object. 
</p>
<table role = "presentation">
<tr><td><code>C</code></td>
<td>
<p>a matrix containing each level's smoothed data, each column corresponding to one coefficient vector. The wavelet transform works by applying both a smoothing filter and a bandpass filter to the previous level's smoothed data. The top level contains data at the highest resolution level. Each of these levels are stored one after the other in this matrix. The matrix '<code>fl.dbase$first.last.c</code>' determines exactly which columns in the matrix, store each level.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>wavelet coefficient matrix. If you were to write down the discrete wavelet transform of a function then columns of D would be the vector coefficients of the wavelet basis function s. Like the C, they are also formed in a pyramidal manner, but stored in a linear matrix. The storage details are to be found in '<code>fl.dbase$first.last.d</code>'.</p>
</td></tr>
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of levels in the pyramidal decomposition that produces the coefficients. The precise number of levels depends on the number of different wavelet functions used and the preprocessing method used, as well as the number of data points used.</p>
</td></tr>
<tr><td><code>fl.dbase</code></td>
<td>
<p>The first last database associated with this decomposition. This is a list consisting of 2 integers, and 2 matrices. The matrices detail how the coefficients are stored in the C and D components of the &lsquo;mwd.object&rsquo;. See the help on <code><a href="#topic+mfirst.last">mfirst.last</a></code> for more information.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>a list containing the details of the filter that did the decomposition. See <code><a href="#topic+mfilter.select">mfilter.select</a></code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>either <code>"wavelet"</code> indicating that the ordinary multiple wavelet transform was performed or <code>"station"</code> indicating that the non-decimated multiple wavelet transform was done.</p>
</td></tr>
<tr><td><code>prefilter</code></td>
<td>
<p>Type of preprocessing or prefilter used. This will be specigic for the type of multiple wavelet used.</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>The date that the transform was performed or the mwd object was last modified.</p>
</td></tr>
<tr><td><code>bc</code></td>
<td>
<p>how the boundaries were handled</p>
</td></tr> 
</table>


<h3>GENERATION</h3>

<p>This class of objects is returned from the <code><a href="#topic+mwd">mwd</a></code> function to represent a multiple wavelet decomposition of a function. Many other functions return an object of class mwd.
</p>


<h3>METHODS</h3>

<p>The mwd class of objects has methods for the following generic functions: <code><a href="#topic+accessC">accessC</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+draw">draw</a></code>, <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+putC">putC</a></code>, <code><a href="#topic+putD">putD</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+threshold">threshold</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie, 1995-6). 
</p>


<h3>Author(s)</h3>

<p>Tim Downie</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.mwd">accessC.mwd</a></code>, <code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mfilter.select">mfilter.select</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+mwr">mwr</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>,<code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>

<hr>
<h2 id='mwr'>Multiple discrete wavelet transform (reconstruction). </h2><span id='topic+mwr'></span>

<h3>Description</h3>

<p>This function performs the reconstruction stage of Mallat's pyramid algorithm adapted for multiple wavelets (see Xia et al.(1996)), i.e. the discrete inverse <em>multiple</em> wavelet transform. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mwr(mwd, prefilter.type = mwd$prefilter, verbose = FALSE, start.level = 0,
	returnC = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mwr_+3A_mwd">mwd</code></td>
<td>
<p>A multiple wavelet decomposition object as returned by <code><a href="#topic+mwd">mwd</a></code>.</p>
</td></tr> 
<tr><td><code id="mwr_+3A_prefilter.type">prefilter.type</code></td>
<td>
<p>Usually best not to change this (i.e. not to use a different prefilter on the reconstruction to the one used on decomposition).</p>
</td></tr>
<tr><td><code id="mwr_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the computations progress. Such messages are generally annoying so it is turned off by default.</p>
</td></tr>
<tr><td><code id="mwr_+3A_start.level">start.level</code></td>
<td>
<p>The level you wish to start reconstruction at. The is usually the first (level 0).</p>
</td></tr> 
<tr><td><code id="mwr_+3A_returnc">returnC</code></td>
<td>
<p>If this is FALSE then a vector of the same length as the argument data supplied to the function <code><a href="#topic+mwd">mwd</a></code> that constructed the supplied <code><a href="#topic+mwd.object">mwd.object</a></code>. is returned, Ie. the reconstructed data. If true then the last level (highest resolution) C coefficients are returned in matrix form. This matrix has not been postprocessed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code implements Mallat's pyramid algorithm adapted for multiple wavelet decompositions (Xia et al. 1996). In the reconstruction the quadrature mirror filters G and H are supplied with C0 and D0, D1, ... D(J-1) (the wavelet coefficients) and rebuild C1,..., CJ. 
</p>
<p>The matrix CJ is postprocessed which returns the full reconstruction 
</p>
<p>If <code><a href="#topic+mwd.object">mwd.object</a></code> was obtained directly from <code><a href="#topic+mwd">mwd</a></code> then the original function can be reconstructued exactly. Usually, the <code><a href="#topic+mwd.object">mwd.object</a></code> has been modified in some way, for examples, some coefficients set to zero by <code><a href="#topic+threshold">threshold</a></code>. Mwr then reconstructs the function with that set of wavelet coefficients. 
</p>
<p>See also Downie and Silverman, 1998 
</p>


<h3>Value</h3>

<p>Either a vector containing the final reconstruction or a matrix containing unpostprocessed coefficients. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie 1996)</p>


<h3>Author(s)</h3>

<p>Tim Downie</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.mwd">accessC.mwd</a></code>, <code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mfilter.select">mfilter.select</a></code>, <code><a href="#topic+mwd">mwd</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>, <code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Decompose and then exactly reconstruct test.data
#
test.data &lt;- rnorm(128)
tdecomp &lt;- mwd(test.data)
trecons &lt;- mwr(tdecomp)
#
# Look at accuracy of reconstruction
max(abs(trecons - test.data))
#[1] 2.266631e-12
#
# See also the examples of using \code{\link{wr}} or mwr in
# the \code{examples} section of
# the help for \code{\link{threshold.mwd}}.
</code></pre>

<hr>
<h2 id='newsure'>Version of sure that acts as subsidiary for threshold.irregwd</h2><span id='topic+newsure'></span>

<h3>Description</h3>

<p>Version of the <code><a href="#topic+sure">sure</a></code> function used as a subsidiary for
<code><a href="#topic+threshold.irregwd">threshold.irregwd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newsure(s, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newsure_+3A_s">s</code></td>
<td>
<p>Vector of standard deviations of coefficients</p>
</td></tr>
<tr><td><code id="newsure_+3A_x">x</code></td>
<td>
<p>Vector of regular (ie non-normalized) coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>The SURE threshold 
</p>


<h3>Author(s)</h3>

<p>Arne Kovac</p>


<h3>See Also</h3>

<p><code><a href="#topic+sure">sure</a></code>, <code><a href="#topic+threshold.irregwd">threshold.irregwd</a></code></p>

<hr>
<h2 id='nlevelsWT'>Returns number of scale (resolution) levels.</h2><span id='topic+nlevelsWT'></span>

<h3>Description</h3>

<p>Returns the number of scales (or resolutions) in various wavelet objects and for some objects returns the number of scales that would result if processed by a wavelet routine. 
</p>
<p>This function is generic. 
</p>
<p>One methods exists at present as most wavelet objects store the number of levels as the <code>nlevelsWT</code> component. The method that exists is<code><a href="#topic+nlevelsWT.default">nlevelsWT.default</a></code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlevelsWT(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlevelsWT_+3A_...">...</code></td>
<td>
<p>See individual help pages for details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>See individual method help pages for operation and examples. 
</p>


<h3>Value</h3>

<p>An integer representing the number of levels associated with the object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6.0 Copyright Guy Nason 1995 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlevelsWT.default">nlevelsWT.default</a></code>
</p>

<hr>
<h2 id='nlevelsWT.default'>Returns number of levels associated with an object</h2><span id='topic+nlevelsWT.default'></span>

<h3>Description</h3>

<p>This function returns the number of scale levels associated with either a wavelet type object or an atomic object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
nlevelsWT(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlevelsWT.default_+3A_object">object</code></td>
<td>
<p>An object for which you wish to determine how many levels it has or is associated with.</p>
</td></tr> 
<tr><td><code id="nlevelsWT.default_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first checks to see whether the input object has a component called nlevelsWT. If it does then it returns the value of this component. If it does not then it takes the length of the object and then uses the <code><a href="#topic+IsPowerOfTwo">IsPowerOfTwo</a></code> function to return the power of two which equals the length (if any) or NA if the length of the object is not a power of two. 
</p>


<h3>Value</h3>

<p>The number of resolution (scale) levels associated with the object. 
</p>


<h3>Author(s)</h3>

<p>Version 3.6.0 Copyright Guy Nason 1995 </p>


<h3>See Also</h3>

<p><code><a href="#topic+nlevelsWT">nlevelsWT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data 
#
test.data &lt;- example.1()$y
#
# Now, this vector is 512 elements long. What number of levels would any
# wavelet object be that was associated with this vector?
#
nlevelsWT(test.data)
# [1] 9
#
# I.e. 2^9=512. Let's check by taking the wavelet transform of the
# test data and seeing how many levels it actually has
#
nlevelsWT(wd(test.data))
# [1] 9

</code></pre>

<hr>
<h2 id='nullevels'>Set whole resolution levels of coefficients equal to zero.</h2><span id='topic+nullevels'></span>

<h3>Description</h3>

<p>Generic function which sets whole resolution levels of coefficients equal to zero. 
</p>
<p>Particular methods exist. For objects of class: 
</p>

<dl>
<dt>imwd</dt><dd><p>use the <code><a href="#topic+nullevels.imwd">nullevels.imwd</a></code> method.</p>
</dd> 
<dt>wd</dt><dd><p>use the <code><a href="#topic+nullevels.wd">nullevels.wd</a></code> method. </p>
</dd>
<dt>wst</dt><dd><p>use the <code><a href="#topic+nullevels.wst">nullevels.wst</a></code> method.</p>
</dd> 
</dl>

<p>See individual method help pages for operation and examples. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullevels(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nullevels_+3A_...">...</code></td>
<td>
<p>See individual help pages for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as x but with the specified levels set to zero. 
</p>


<h3>RELEASE</h3>

<p>Version 3.8.1 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+nullevels.imwd">nullevels.imwd</a></code> <code><a href="#topic+nullevels.wd">nullevels.wd</a></code> <code><a href="#topic+nullevels.wst">nullevels.wst</a></code> <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+wd">wd</a></code> <code><a href="#topic+wst.object">wst.object</a></code> <code><a href="#topic+wst">wst</a></code> 
</p>

<hr>
<h2 id='nullevels.imwd'>Sets whole resolution levels of coefficients equal to zero in a imwd object.</h2><span id='topic+nullevels.imwd'></span>

<h3>Description</h3>

<p>Sets whole resolution levels of coefficients equal to zero in a <code><a href="#topic+imwd.object">imwd.object</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwd'
nullevels(imwd, levelstonull, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nullevels.imwd_+3A_imwd">imwd</code></td>
<td>
<p>An object of class <code><a href="#topic+imwd">imwd</a></code>.</p>
</td></tr> 
<tr><td><code id="nullevels.imwd_+3A_levelstonull">levelstonull</code></td>
<td>
<p>An integer vector specifying which resolution levels of coefficients of <code><a href="#topic+imwd">imwd</a></code> that you wish to set to zero. </p>
</td></tr>
<tr><td><code id="nullevels.imwd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting whole resolution levels of coefficients to zero can be very useful. For examples, one can construct a linear smoothing method by setting all coefficients above a particular resolution (the <em>primary resolution</em> equal to zero. Also setting particular levels equal to zero can also be useful for removing noise which is specific to a particular resolution level (as long as important signal is not also contained at that level). 
</p>
<p>Note that this function removes the horiztonal, diagonal and vertical detail coefficients at the resolution level specified. It does not remove the father wavelet coefficients at those resolution levels. 
</p>
<p>To remove individual coefficients on a systematic basis you probably want to look at the <code><a href="#topic+threshold">threshold</a></code> function. 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+imwd">imwd</a></code> where the coefficients in resolution levels specified by levelstonull have been set to zero. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.5 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+nullevels">nullevels</a></code>, <code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+threshold">threshold</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Do the wavelet transform of the Lennon image
#
data(lennon)
lenimwd &lt;- imwd(lennon)
#
# Set scales (resolution levels) 2, 4 and 6 equal to zero.
#
lenwdNL &lt;- nullevels(lenimwd, levelstonull=c(2,4,6))
#
# Now let's plot the coefficients using a nice blue-heat colour map
#
# You will see that coefficients at levels 2, 4 and 6 are black (i.e. zero)
# You can see that coefficients at other levels are unaffected and still
# show the Lennon coefficients.
#
## Not run: plot(lenwdNL)
</code></pre>

<hr>
<h2 id='nullevels.wd'>Sets whole resolution levels of coefficients equal to zero in a wd object.</h2><span id='topic+nullevels.wd'></span>

<h3>Description</h3>

<p>Sets whole resolution levels of coefficients equal to zero in a <code><a href="#topic+wd.object">wd.object</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
nullevels(wd, levelstonull, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nullevels.wd_+3A_wd">wd</code></td>
<td>
<p>An object of class <code><a href="#topic+wd">wd</a></code>.</p>
</td></tr> 
<tr><td><code id="nullevels.wd_+3A_levelstonull">levelstonull</code></td>
<td>
<p>An integer vector specifying which resolution levels of coefficients of <code><a href="#topic+wd">wd</a></code> that you wish to set to zero. </p>
</td></tr>
<tr><td><code id="nullevels.wd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting whole resolution levels of coefficients to zero can be very useful. For examples, one can construct a linear smoothing method by setting all coefficients above a particular resolution (the <em>primary resolution</em> equal to zero. Also setting particular levels equal to zero can also be useful for removing noise which is specific to a particular resolution level (as long as important signal is not also contained at that level). 
</p>
<p>Note that this function removes the horiztonal, diagonal and vertical detail coefficients at the resolution level specified. It does not remove the father wavelet coefficients at those resolution levels. 
</p>
<p>To remove individual coefficients on a systematic basis you probably want to look at the <code><a href="#topic+threshold">threshold</a></code> function. 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wd">wd</a></code> where the coefficients in resolution levels specified by <code>levelstonull</code> have been set to zero. 
</p>


<h3>RELEASE</h3>

<p>Version 3.8.1 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+nullevels">nullevels</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+threshold">threshold</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y
#
# Do wavelet transform of test.data and plot the wavelet coefficients
#
wds &lt;- wd(test.data)
## Not run: plot(wds)
#
# Now let us set all the coefficients in ODD resolution levels equal to zero!
#
# This is just to illustrate the capabilities of the function. I cannot
# imagine you wanting to do this in practice!
##
wdsnl &lt;- nullevels(wds, levelstonull = c(1, 3, 5, 7))
#
# Now let's plot the result
#
## Not run: plot(wdsnl, scaling = "by.level")
#
# Lo and behold the odd levels have been set to zero!
</code></pre>

<hr>
<h2 id='nullevels.wst'>Sets whole resolution levels of coefficients equal to zero in a wst object.</h2><span id='topic+nullevels.wst'></span>

<h3>Description</h3>

<p>Sets whole resolution levels of coefficients equal to zero in a <code><a href="#topic+wd">wd</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
nullevels(wst, levelstonull, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nullevels.wst_+3A_wst">wst</code></td>
<td>
<p>An object of class <code><a href="#topic+wst">wst</a></code>.</p>
</td></tr> 
<tr><td><code id="nullevels.wst_+3A_levelstonull">levelstonull</code></td>
<td>
<p>An integer vector specifying which resolution levels of coefficients of <code><a href="#topic+wst">wst</a></code> that you wish to set to zero. </p>
</td></tr>
<tr><td><code id="nullevels.wst_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting whole resolution levels of coefficients to zero can be very useful. For examples, one can construct a linear smoothing method by setting all coefficients above a particular resolution (the <em>primary resolution</em> equal to zero. Also setting particular levels equal to zero can also be useful for removing noise which is specific to a particular resolution level (as long as important signal is not also contained at that level). 
</p>
<p>To remove individual coefficients on a systematic basis you probably want to look at the <code><a href="#topic+threshold">threshold</a></code> function. 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wst">wst</a></code> where the coefficients in resolution levels specified by <code>levelstonull</code> have been set to zero. 
</p>


<h3>RELEASE</h3>

<p>Version 3.8.1 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+nullevels">nullevels</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+threshold">threshold</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Look at the examples for \code{\link{nullevels.wd}}.
# The operation is almost identical except that \code{\link{wst}}
# objects are replaced by \code{\link{wd}} ones. 
</code></pre>

<hr>
<h2 id='numtonv'>Convert an index number into a node vector object.</h2><span id='topic+numtonv'></span>

<h3>Description</h3>

<p>Convert an index number into a <code>node vector</code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numtonv(number, nlevels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numtonv_+3A_number">number</code></td>
<td>
<p>The index number of a particular basis within a wavelet object.</p>
</td></tr> 
<tr><td><code id="numtonv_+3A_nlevels">nlevels</code></td>
<td>
<p>The number of levels that the wavelet object has (can often be discovered using the <code><a href="base.html#topic+nlevels">nlevels</a></code> function). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A basis within a (e.g. non-decimated) wavelet object (such as a <code><a href="#topic+wst.object">wst.object</a></code>) is represented in WaveThresh by a <code>nv</code> or node vector. 
</p>
<p>A packet-ordered non-decimated wavelet transform object <code><a href="#topic+wst">wst</a></code> for short) which is the transform of a vector of length <code>n</code> contains <code>n</code> bases. Each basis can be indexed from 0 to <code>(n-1)</code> . 
</p>
<p>A <code><a href="#topic+wst.object">wst.object</a></code> is simply a fully populated binary tree. There are nlevels levels in the tree with a split at each level. The root of the tree is at level 0, there are two branches at level 1, four at level 2, eight at level 3 and so on. A path through the tree can be constructed by starting at the root and choosing &quot;left&quot; or &quot;right&quot; at each possible branch. For certain data situations this path is constructed using minimum entropy algorithms (for examples <code><a href="#topic+MaNoVe">MaNoVe</a></code>). This function (numtonv takes the numerical representation of a path and converts it into a <code>node.vector</code> form suitable for passing to <code><a href="#topic+InvBasis">InvBasis</a></code> to invert the representation according to a basis specicified by number.
</p>
<p>The least significant digit in number corresponds to deciding on the left/right decision at the fine leaves of the tree (high-frequency structure) and the
most significant digit in number corresponds to deciding on the left/right
decision at the root.
Therefore gradually incrementing number from 0 to
<code>2^{nlevels}-1</code> steps through all possible bases in the
<code><a href="#topic+wst">wst</a></code> object ranging from all decisions being made &quot;left&quot; to all decisions being made &quot;right&quot;.
The &quot;number&quot; dividied by <code>2^{nlevels}</code> corresponds exactly to the binary number epsilon in Nason and Silverman (1995). 
</p>


<h3>Value</h3>

<p>An object of class <code>nv</code> (node vector). This contains information about a path through a wavelet object (a basis in a wavelet object). 
</p>


<h3>RELEASE</h3>

<p>Version 3.6.0 Copyright Guy Nason 1995 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+MaNoVe">MaNoVe</a></code>, <code><a href="#topic+nv.object">nv.object</a></code>, <code><a href="#topic+InvBasis">InvBasis</a></code>, <code><a href="base.html#topic+nlevels">nlevels</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y
#
# Make it noisy
#
ynoise &lt;- test.data + rnorm(512, sd=0.1)
#
# Do packet ordered non-decimated wavelet transform
#
ynwst &lt;- wst(ynoise)
#
# Now threshold the coefficients
#
ynwstT &lt;- threshold(ynwst)
#
# Select basis number 9 (why not?)
#
NodeVector9 &lt;- numtonv(9, nlevelsWT(ynwstT))
#
# Let's print it out to see what it looks like
# (nb, if you're repeating this examples, the basis might be different
# as you may have generated different pseudo random noise to me)
#
NodeVector9
# Level :  8  Action is  R (getpacket Index:  1 )
# Level :  7  Action is  L (getpacket Index:  2 )
# Level :  6  Action is  L (getpacket Index:  4 )
# Level :  5  Action is  R (getpacket Index:  9 )
# Level :  4  Action is  L (getpacket Index:  18 )
# Level :  3  Action is  L (getpacket Index:  36 )
# Level :  2  Action is  L (getpacket Index:  72 )
# Level :  1  Action is  L (getpacket Index:  144 )
# Level :  0  Action is  L (getpacket Index:  288 )
# There are  9  reconstruction steps
#
# The print-out describes the tree through ynwstT that corresponds to
# basis 9.
#
# The NodeVector9 and ynwstT objects could now be supplied to
# InvBasis.wst for inverting ynwstT according
# to the NodeVector9 or basis number 9.
</code></pre>

<hr>
<h2 id='nv.object'>Node vector objects.</h2><span id='topic+nv.object'></span>

<h3>Description</h3>

<p>These are objects of classes 
</p>
<p><code>nv</code>
</p>
<p>They represent a basis in a packet-ordered non-decimated wavelet transform object. 
</p>


<h3>Details</h3>

<p>A <code>nv</code> object is a description of a basis which is a path through a packet ordered non-decimated wavelet transform. To view the basis just print it! See the examples in <code><a href="#topic+numtonv">numtonv</a></code> for a print out of its structure.
</p>
<p>A similar object exists for describing a basis in a wavelet packet object see nvwp. 
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate &lsquo;nv&rsquo; object. 
</p>
<table role = "presentation">
<tr><td><code>node.list</code></td>
<td>
<p>This is a complicated structure composed of one-dimensional array of <code>nv$nlevelsWT</code> lists. Each item in the array is itself a list having two components<code>$upperctrl</code> and <code>upperl</code>. Each component is described as follows:
</p>

<dl>
<dt>upperctrl</dt><dd><p>The &lsquo;upperctrl&rsquo; item in each is the most important. It consists of a vector of characters. Each character refers to a node in the non-decimated wavelet tree at that level and can only be one of the characters L (for left), R (for right) and S (for stop). Each character in the vector informs reconstruction algorithms that, to do the best thing (whatever the best thing is in any particular case, e.g. select the minimum entropy node downwards), you should select the left/right node or stop at the current node.</p>
</dd>
<dt>upperl</dt><dd><p>The &lsquo;upperl&rsquo; vector is in 1-1 correspondance with the &lsquo;upperctrl&rsquo; vector. Each entry is a number related in some way to the L/R/S entry. (For the minumum entropy this is the minmum entropy achieved by this selection).</p>
</dd>
<dt>nlevelsWT</dt><dd><p>The number of levels in the <code><a href="#topic+wst">wst</a></code> object that was involved in the creation of the <code>nv</code> object. Nv objects describe a basis relative to a packet ordered non-decimated wavelet transform object and thus must know the number of levels in that object.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>GENERATION</h3>

<p>This class of objects is returned from the <code><a href="#topic+MaNoVe.wst">MaNoVe.wst</a></code> and <code><a href="#topic+numtonv">numtonv</a></code> functions. The former returns the minimum entropy basis (most sparse basis) obtained using the Coifman-Wickerhauser, 1992 algorithm. The latter permits selection of a basis by an index number. 
</p>


<h3>METHODS</h3>

<p>The <code>nv</code> class of objects has methods for the following generic functions: print, <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>, <code><a href="#topic+InvBasis">InvBasis</a></code>, 
</p>


<h3>RELEASE</h3>

<p>Version 3.6.0 Copyright Guy Nason 1995
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+numtonv">numtonv</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>, <code><a href="#topic+InvBasis">InvBasis</a></code>, <code><a href="#topic+MaNoVe.wst">MaNoVe.wst</a></code>. 
</p>

<hr>
<h2 id='plot.imwd'>Draw a picture of the 2D wavelet coefficients using image</h2><span id='topic+plot.imwd'></span><span id='topic+plot.imwdc'></span>

<h3>Description</h3>

<p>This function images 2D the absolute values discrete wavelet transform coefficients arising from a <code><a href="#topic+imwd.object">imwd.object</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwd'
plot(x, scaling = "by.level", co.type = "abs",
	package = "R", plot.type = "mallat", arrangement = c(3, 3),
	transform = FALSE, tfunction = sqrt, ...)
## S3 method for class 'imwdc'
plot(x, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.imwd_+3A_x">x</code></td>
<td>
<p>The 2D imwd object you wish to depict</p>
</td></tr>
<tr><td><code id="plot.imwd_+3A_scaling">scaling</code></td>
<td>
<p>How coefficient scaling is performed. The options
are <code>by.level</code> to scale the coefficients independently
by level, anything else causes coefficients to be scaled
globally</p>
</td></tr>
<tr><td><code id="plot.imwd_+3A_co.type">co.type</code></td>
<td>
<p>Can be <code>"abs"</code> for the absolute values of the
coefficients to be plotted, can be <code>"mabs"</code> for the
negative absolute values or <code>"none"</code> for none of this.</p>
</td></tr>
<tr><td><code id="plot.imwd_+3A_package">package</code></td>
<td>
<p>Can be <code>"R"</code> for the R package, or <code>"S"</code>.
The latter does less interesting things and results in a simpler
plot</p>
</td></tr>
<tr><td><code id="plot.imwd_+3A_plot.type">plot.type</code></td>
<td>
<p>If this argument is <code>"mallat"</code> the coefficients
at different scales and orientations are packed into one image
and plotted, a format originating from Mallat's early papers on this.
The other possibility is <code>"cols"</code> which plots each combination
of scale and direction on a separate plot. This latter format is
useful for examining coefficients, especially at the coarser scales.</p>
</td></tr>
<tr><td><code id="plot.imwd_+3A_arrangement">arrangement</code></td>
<td>
<p>If <code>plot.type="cols"</code> then this argument
specifies how many rows and columns there are in the plot
array.</p>
</td></tr>
<tr><td><code id="plot.imwd_+3A_transform">transform</code></td>
<td>
<p>If FALSE then the coefficients are plotted as they
are (subject to the <code>co.type</code> argument above), if TRUE
then the transform function supplied by <code>tfunction</code> is
applied to the coefficients.</p>
</td></tr>
<tr><td><code id="plot.imwd_+3A_tfunction">tfunction</code></td>
<td>
<p>If <code>transform=TRUE</code> then this function gets applied
to transform the coefficients before plotting</p>
</td></tr>
<tr><td><code id="plot.imwd_+3A_verbose">verbose</code></td>
<td>
<p>Print out informative messages</p>
</td></tr>
<tr><td><code id="plot.imwd_+3A_...">...</code></td>
<td>
<p>Supply other arguments to the call to the <code>image</code> function.
This is very useful to, e.g., can the colours, or other aspects of
the image</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>If the <code>package="S"</code> argument is set then a matrix is returned
containing the image that would have been plotted (and this only works
if the <code>plot.type="mallat"</code> argument is set also.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+threshold.imwd">threshold.imwd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lennon)
lwd &lt;- imwd(lennon)
## Not run: plot(lwd)
## Not run: plot(lwd, col=grey(seq(from=0, to=1, length=100)), transform=TRUE)
</code></pre>

<hr>
<h2 id='plot.irregwd'>Plot variance factors of wavelet transform coefficients for irregularly spaced wavelet transform object</h2><span id='topic+plot.irregwd'></span>

<h3>Description</h3>

<p>This function plots the variance factors associated with the wavelet coefficients arising from a <code><a href="#topic+irregwd.objects">irregwd.objects</a></code>
irregularly spaced wavelet decomposition object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'irregwd'
plot(x, xlabels, first.level = 1,
	main = "Wavelet Decomposition Coefficients", scaling = "by.level",
	rhlab = FALSE, sub, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.irregwd_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+irregwd.objects">irregwd.objects</a></code>
object whose coefficients you wish to plot.</p>
</td></tr>
<tr><td><code id="plot.irregwd_+3A_xlabels">xlabels</code></td>
<td>
<p>A vector containing the &quot;true&quot; x-axis numbers that went
with the vector that was transformed to produce the
irregwd object supplied as the first argument to this function.
If this argument is missing then the function tries to make up a
sensible set of x-axis labels.</p>
</td></tr>
<tr><td><code id="plot.irregwd_+3A_first.level">first.level</code></td>
<td>
<p>The first resolution level to begin plotting at.
This argument can be quite useful when you want to supress some of
the coarser levels in the diagram.</p>
</td></tr>
<tr><td><code id="plot.irregwd_+3A_main">main</code></td>
<td>
<p>The main title of the plot.</p>
</td></tr>
<tr><td><code id="plot.irregwd_+3A_scaling">scaling</code></td>
<td>
<p>How you want the coefficients to be scaled.
The options are: <code>global</code> - one scale factor is chosen for
the whole plot. The scale factor depends on the variance factor to
be included on the plot that has the largest absolute value.
The global option is useful when comparing factors that might
appear anywhere in the plot;
<code>by.level</code> - a scale factor is chosen for each resolution level
in the plot. The scale factor for a level depends on the variance
factor in that level that has the largest absolute value.
The <code>by.level</code> option is useful when you wish to compare
coefficients within a resolution level.</p>
</td></tr>
<tr><td><code id="plot.irregwd_+3A_rhlab">rhlab</code></td>
<td>
<p>If <code>TRUE</code> then a set of labels is produced on the right
hand axis. The axis labels in this case refer to the scale factors
used to scale each level and correspond to value of the largest
variance factor (in absolute value) in each scale
(when <code>scaling=="by.level"</code>) or absolutely (when <code>scaling="global"</code>). If the <code>rhlab=FALSE</code> then no right hand axis labels are
produced.</p>
</td></tr>
<tr><td><code id="plot.irregwd_+3A_sub">sub</code></td>
<td>
<p>A subtitle for the plot.</p>
</td></tr>
<tr><td><code id="plot.irregwd_+3A_...">...</code></td>
<td>
<p>Other arguments supplied to the actual plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a plot similar in style to the ones in Donoho and Johnstone, 1994.
This function is basically the same as
<code><a href="#topic+plot.wd">plot.wd</a></code> except that variance factors and not coefficients
are plotted. A variance factor is a number that quantifies the variability of
a coefficient induced by the irregular design that was interpolated to
a regular grid by the <code><a href="#topic+makegrid">makegrid</a></code> function which is used the
by <code><a href="#topic+irregwd">irregwd</a></code> irregular wavelet transform function.
</p>
<p>High values of the variance factor correspond to large variance in the
wavelet coefficients but due to the irregular design,
not the original noise structure on the coefficients.
</p>


<h3>Value</h3>

<p>If <code>rhlab==TRUE</code> then the scaling factors applied to each
scale level are returned. Otherwise <code>NULL</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Arne Kovac</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The help for makegrid contains an example
# of using this function.
#
</code></pre>

<hr>
<h2 id='plot.mwd'>Use plot on an mwd object. </h2><span id='topic+plot.mwd'></span>

<h3>Description</h3>

<p>Plots the wavelet coefficients of a <code><a href="#topic+mwd">mwd</a></code> class object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mwd'
plot(x, first.level = 1, main = "Wavelet Decomposition Coefficients",
        scaling = "compensated", rhlab = FALSE, sub = x$filter$name,
	NotPlotVal = 0.05, xlab = "Translate", ylab = "Resolution level",
	return.scale = TRUE, colour = (2:(npsi + 1)), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mwd_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+mwd">mwd</a></code> object whose coefficients you wish to plot.</p>
</td></tr>
<tr><td><code id="plot.mwd_+3A_first.level">first.level</code></td>
<td>
<p>The first resolution level to begin plotting at. This argument can be quite useful when you want to supress some of the coarser levels in the diagram.</p>
</td></tr>
<tr><td><code id="plot.mwd_+3A_main">main</code></td>
<td>
<p>The main title of the plot.</p>
</td></tr> 
<tr><td><code id="plot.mwd_+3A_scaling">scaling</code></td>
<td>
<p>How you want the coefficients to be scaled. The options are: &quot;<code>global</code>&quot; - one scale factor is chosen for the whole plot. The scale factor depends on the coefficient to be included on the plot that has the largest absolute value. The global option is useful when comparing coefficients that might appear anywhere in the plot; &quot;<code>by.level</code>&quot; - a scale factor is chosen for each resolution level in the plot. The scale factor for a level depends on the coefficient in that level that has the largest absolute value. The &quot;<code>by.level</code>&quot; option is useful when you wish to compare coefficients within a resolution level. 
</p>
<p>The other option is &quot;<code>compensated</code>&quot; which is the same as &quot;<code>global</code>&quot; except for that finer scales' coefficients are scaled up by a factor of SQRT(2) for <code>compensated</code>. This latter options is sometimes useful. </p>
</td></tr>
<tr><td><code id="plot.mwd_+3A_rhlab">rhlab</code></td>
<td>
<p>If <code>T</code> then a set of labels is produced on the right hand axis. The axis labels in this case refer to the scale factors used to scale each level and correspond to value of the largest coefficient (in absolute value) in each scale (when <code>scaling=="by.level"</code>) or absolutely (when <code>scaling="global"</code>). If the <code>rhlab</code> argument is <code>FALSE</code> then no right hand axis labels are produced.</p>
</td></tr> 
<tr><td><code id="plot.mwd_+3A_sub">sub</code></td>
<td>
<p>A subtitle for the plot.</p>
</td></tr> 
<tr><td><code id="plot.mwd_+3A_notplotval">NotPlotVal</code></td>
<td>
<p>Doesn't seem to be implemented.</p>
</td></tr> 
<tr><td><code id="plot.mwd_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis</p>
</td></tr>
<tr><td><code id="plot.mwd_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis</p>
</td></tr> 
<tr><td><code id="plot.mwd_+3A_return.scale">return.scale</code></td>
<td>
<p>If true (default) the scale for each resolution level is returned</p>
</td></tr> 
<tr><td><code id="plot.mwd_+3A_colour">colour</code></td>
<td>
<p>A vector of length <code>mwd$npsi</code>, the values of which are the colours used to plot the coefficients, one for each distinct type of wavelet (with apologies to our American cousins for spelling colour correctly!)</p>
</td></tr> 
<tr><td><code id="plot.mwd_+3A_...">...</code></td>
<td>
<p>other arguments to be supplied to plot.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Produces a plot similar to the ones in Donoho and Johnstone, 1994. 
</p>
<p>Wavelet coefficients for each resolution level are plotted one above the other, with the high resolution coefficients at the bottom, and the low resolution at the top. Each vector is represented by <code>mwd$npsi</code> lines one for each element in the coefficient vector. If colour is supported by the device each element will be represented by a different coulour. The coefficients are plotted using the <code>segment</code> function, with a large positive coefficient being plotted above an imaginary horizontal centre line, and a large negative coefficient plotted below it. The position of a coefficient along a line is indicative of the wavelet basis function's translate number. 
</p>
<p>The resolution levels are labelled on the left-hand side axis, and the maximum values of the absolute values of the coefficients for the particular level form the right-hand side axis. 
</p>
<p>The levels of coefficients can be scaled in three ways. If you are not interested in comparing the relative scales of coefficients from different levels, then the default scaling option, &quot;<code>by.level</code>&quot; is what you need. This computes the maximum of the absolute value of the coefficients at a particular level and scales the so that the fit nicely onto the plot. For this option, each level is scaled <b>DIFFERENTLY</b>. To obtain a uniform scale for all the levels specify the &quot;<code>global</code>&quot; option to the <code>scaling</code> argument. This will allow you to make inter-level comparisons. 
</p>


<h3>Value</h3>

<p>Axis labels for each resolution level unless <code>return.scale=F</code> when <code>NULL</code> is returned. The axis values are the maximum of the absolute value of the coefficients at that resolution level. They are returned because they are sometimes hard to read on the plot. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie 1995-6). </p>


<h3>Note</h3>

<p>A plot of the coefficients contained within the <code><a href="#topic+mwd">mwd</a></code> object at each resolution level is produced.</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.mwd">accessC.mwd</a></code>, <code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mfilter.select">mfilter.select</a></code>, <code><a href="#topic+mwd">mwd</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+mwr">mwr</a></code>, <code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y
## Not run: ts.plot(test.data)
#
# Decompose test.data with multiple wavelet transform and
# plot the wavelet coefficients
#
tdmwd &lt;- mwd(test.data)
## Not run: plot(tdmwd)
#[1] 1.851894 1.851894 1.851894 1.851894 1.851894 1.851894 1.851894
#
# You should see a plot with wavelet coefficients like in
# plot.wd but at each coefficient position
# there are two coefficients in two different colours one for each of
# the wavelets at that position.
#
# Note the scale for each level is returned by the function. 
</code></pre>

<hr>
<h2 id='plot.nvwp'>Depict wavelet packet basis specfication</h2><span id='topic+plot.nvwp'></span>

<h3>Description</h3>

<p>The nvwp class object (generated from <code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code> for example)
contains a wavelet packet basis specification. This function produces
a graphical depiction of such a basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nvwp'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.nvwp_+3A_x">x</code></td>
<td>
<p>The wavelet packet node vector you wish to plot, nvwp class object</p>
</td></tr>
<tr><td><code id="plot.nvwp_+3A_...">...</code></td>
<td>
<p>Other arguments to the central plot function</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The vertical axis indicates the resolution level, the horizontal axes
indicates the packet index for the finest scales.
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code>,<code><a href="#topic+print.nvwp">print.nvwp</a></code>,<code><a href="#topic+wp">wp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- rnorm(512)
vwp &lt;- wp(v)
vnv &lt;- MaNoVe(vwp)
## Not run: plot(vnv)
</code></pre>

<hr>
<h2 id='plot.wd'>Plot wavelet transform coefficients.</h2><span id='topic+plot.wd'></span>

<h3>Description</h3>

<p>This function plots discrete wavelet transform coefficients arising from a <code><a href="#topic+wd">wd</a></code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
plot(x,xlabvals, xlabchars, ylabchars, first.level = 0,
	main = "Wavelet Decomposition Coefficients", scaling = "global",
	rhlab = FALSE, sub, NotPlotVal = 0.005, xlab = "Translate",
	ylab = "Resolution Level", 
	aspect = "Identity", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.wd_+3A_x">x</code></td>
<td>
<p>The wd class object you wish to plot</p>
</td></tr>
<tr><td><code id="plot.wd_+3A_xlabvals">xlabvals</code></td>
<td>
<p>A vector containing the &quot;true&quot; x-axis numbers that went with the vector that was transformed to produce the <code><a href="#topic+wd">wd</a></code> object supplied as the first argument to this function. If this argument is missing then the function tries to make up a sensible set of x-axis labels.</p>
</td></tr>
<tr><td><code id="plot.wd_+3A_xlabchars">xlabchars</code></td>
<td>
<p>Tickmark labels for the x axis</p>
</td></tr>
<tr><td><code id="plot.wd_+3A_ylabchars">ylabchars</code></td>
<td>
<p>Tickmark labels for the y axis</p>
</td></tr>
<tr><td><code id="plot.wd_+3A_first.level">first.level</code></td>
<td>
<p>The first resolution level to begin plotting at. This argument can be quite useful when you want to supress some of the coarser levels in the diagram.</p>
</td></tr>
<tr><td><code id="plot.wd_+3A_main">main</code></td>
<td>
<p>The main title of the plot.</p>
</td></tr>
<tr><td><code id="plot.wd_+3A_scaling">scaling</code></td>
<td>
<p>How you want the coefficients to be scaled. The options are: <code>global</code> - one scale factor is chosen for the whole plot. The scale factor depends on the coefficient to be included on the plot that has the largest absolute value. The <code>global</code> option is useful when comparing coefficients that might appear anywhere in the plot; <code>by.level</code> - a scale factor is chosen for each resolution level in the plot. The scale factor for a level depends on the coefficient in that level that has the largest absolute value. The <code>by.level</code> option is useful when you wish to compare coefficients within a resolution level.
</p>
<p>The two other options are compensated and super which are the same as <code>global</code> except for that finer scales' coefficients are scaled up by a factor of SQRT(2) for compensated and 2 for super. These latter two options are sometimes useful (more useful for non-decimated <code><a href="#topic+wd">wd</a></code> objects, where they act as a sort of <code><a href="#topic+ipndacw">ipndacw</a></code> matrix operator). </p>
</td></tr>
<tr><td><code id="plot.wd_+3A_rhlab">rhlab</code></td>
<td>
<p>If <code>TRUE</code> then a set of labels is produced on the right hand axis. The axis labels in this case refer to the scale factors used to scale each level and correspond to value of the largest coefficient (in absolute value) in each scale (when <code>scaling=="by.level"</code>) or absolutely (when <code>scaling="global"</code>). If the <code>rhlab</code> argument is <code>FALSE</code> then no right hand axis labels are produced.</p>
</td></tr> 
<tr><td><code id="plot.wd_+3A_sub">sub</code></td>
<td>
<p>A subtitle for the plot.</p>
</td></tr> 
<tr><td><code id="plot.wd_+3A_notplotval">NotPlotVal</code></td>
<td>
<p>This argument ensures that if all (scaled) coefficients in a resolution level are below <code>NotPlotVal</code> in absolute value then the whole resolution level is not plotted. This can be useful when plotting a <code><a href="#topic+wd">wd</a></code> object that is sparse (or has been thresholded and necessarily many coefficients might well be zero) as it speeds up the plot because whole levels do not have to be plotted (the function that does the plotting [<code>segments()</code>] is quite a slow function). Note that the value of <code>NotPlotVal</code> refers to <code>scaled</code> coefficients, those that have been scaled by this function (on any resolution level all coefficients are scaled to lie between -0.5 and 0.5).</p>
</td></tr> 
<tr><td><code id="plot.wd_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis</p>
</td></tr> 
<tr><td><code id="plot.wd_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis</p>
</td></tr> 
<tr><td><code id="plot.wd_+3A_aspect">aspect</code></td>
<td>
<p>This argument describes the name (as a character string) of a function to be applied to the coefficients before plotting. By default the argument is &quot;<code>Identity</code>&quot;, i.e. the coefficients are plotted <em>as is</em>. This argument is most useful when a complex-valued wavelets are plotted you could use &quot;<code>Mod</code>&quot; to plot the modulus of the coefficients, or &quot;<code>Re</code>&quot; to plot the real parts of the coefficients or &quot;<code>Arg</code>&quot; to plot the argument of the coefficients. Also, the <code>aspect</code> argument can be useful for the ordinary wavelet transforms as well if you are interested in a particular transform of the coefficients. </p>
</td></tr>
<tr><td><code id="plot.wd_+3A_...">...</code></td>
<td>
<p>fine tuning</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a plot similar to the ones in Donoho and Johnstone, 1994. 
</p>
<p>A wavelet decomposition of a signal consists of discrete wavelet coefficients at different scales (resolution levels) and locations. This function plots the coefficients as a pyramid (derived from Mallat's pyramid algorithm). See the examples below. 
</p>
<p>The resolution levels are stacked one above the other: coarse scale coefficients are always towards the top of the plot, fine scale coefficients are always located toward the bottom of the plot. The location of coefficients increases from left to right across the plot in synchrony with the input signal to the <code><a href="#topic+wd">wd</a></code> object. In other words the position of a coefficient along a line is indicative of the associated wavelet basis function's translate number. The actual coefficients are plotted using S-Plus's <code>segments()</code> function. This plots each coefficient as a vertical line with positive coefficients being plotted above an imaginary centre line and negative coefficients being plotted below. 
</p>
<p>The resolution levels are labelled on the left-hand side axis, and if <code>rhlab==T</code> the maximum values of the absolute values of the coefficients, for the particular level, are plotted on the right-hand axis. 
</p>
<p>The coefficients in the plot may be scaled in 4 ways. If you are interested in comparing coefficients in different levels then the default scaling option <code>scaling=="global"</code> is what you need. This works by finding the coefficient with the largest absolute value amongst all coeffients to be plotted and then scales all the other coefficients by the largest so that all coefficients lie in the range -1/2 to 1/2. The scaled coefficients are then plotted. If you are not interested in comparing relative resolution levels and want to see all that goes on within a particular scale then you should use the scaling option <code>scaling=="by.level"</code> which picks out the largest coefficient (in absolute value) from each level and scales each level separately. The &quot;<code>compensated</code>&quot; and super options are like the &quot;<code>global</code>&quot; option except that finer levels are scaled up (as discussed in the arguments list above): this can be useful when plotting non-decimated wavelet transform coefficients as it emphasizes the higher frequencies. 
</p>


<h3>Value</h3>

<p>If <code>rhlab==T</code> then the scaling factors applied to each scale level are returned. Otherwise NULL is returned. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 
</p>


<h3>Note</h3>

<p>A plot of the coefficients contained within the <code><a href="#topic+wd">wd</a></code> object is produced. </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y
## Not run: ts.plot(test.data)
#
# Decompose test.data and plot the wavelet coefficients
#
wds &lt;- wd(test.data)
## Not run: plot(wds)
#
# Now do the time-ordered non-decimated wavelet transform of the same thing
#
## Not run: wdS &lt;- wd(test.data, type="station")
## Not run: plot(wdS)
#
# Next examples
# ------------
# The chirp signal is also another good examples to use.
#
# Generate some test data
#
test.chirp &lt;- simchirp()$y
## Not run: ts.plot(test.chirp, main="Simulated chirp signal")
#
# Now let's do the time-ordered non-decimated wavelet transform.
# For a change let's use Daubechies least-asymmetric phase wavelet with 8
# vanishing moments (a totally arbitrary choice, please don't read
# anything into it).
#
chirpwdS &lt;- wd(test.chirp, filter.number=8, family="DaubLeAsymm", type="station")
## Not run: plot(chirpwdS, main="TOND WT of Chirp signal")
</code></pre>

<hr>
<h2 id='plot.wp'>Plot wavelet packet transform coefficients</h2><span id='topic+plot.wp'></span>

<h3>Description</h3>

<p>This function plots wavelet packet transform coefficients arising from a
<code><a href="#topic+wp.object">wp.object</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
plot(x, nvwp = NULL, main = "Wavelet Packet Decomposition", 
    sub, first.level = 5, scaling = "compensated", dotted.turn.on = 5, 
    color.force = FALSE, WaveletColor = 2, NodeVecColor = 3, 
    fast = FALSE, SmoothedLines = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.wp_+3A_x">x</code></td>
<td>
<p>The wp object whose coefficients you wish to plot.</p>
</td></tr>
<tr><td><code id="plot.wp_+3A_nvwp">nvwp</code></td>
<td>
<p>An optional associated wavelet packet node vector class object of
class <code>nvwp</code>.
This object is a list of packets in the wavelet packet table.
If this argument is specified then it is possible to highlight the
packets in the nvwp objects in a different color using the
<code>NodeVecColor</code> argument</p>
</td></tr>
<tr><td><code id="plot.wp_+3A_main">main</code></td>
<td>
<p>The main title of the plot.</p>
</td></tr>
<tr><td><code id="plot.wp_+3A_sub">sub</code></td>
<td>
<p>A subtitle for the plot.</p>
</td></tr>
<tr><td><code id="plot.wp_+3A_first.level">first.level</code></td>
<td>
<p>The first resolution level to begin plotting at.
This argument can be quite useful when you want to supress some
of the coarser levels in the diagram.</p>
</td></tr>
<tr><td><code id="plot.wp_+3A_scaling">scaling</code></td>
<td>
<p>How you want the coefficients to be scaled.
The options are: <code>global</code> - one scale factor is chosen for
the whole plot. The scale factor depends on the coefficient to be
included on the plot that has the largest absolute value.
The global option is useful when comparing coefficients that might
appear anywhere in the plot; <code>by.level</code> - a scale factor is
chosen for each resolution level in the plot.
The scale factor for a level depends on the coefficient in that level
that has the largest absolute value. The <code>by.level</code> option is
useful when you wish to compare coefficients within a resolution level.
The other option is <code>compensated</code> which is the same as global
except for that finer scales' coefficients are scaled up by a factor
of SQRT(2)
</p>
<p>I don't know why compensated is the default option? That is probably
silly!</p>
</td></tr>
<tr><td><code id="plot.wp_+3A_dotted.turn.on">dotted.turn.on</code></td>
<td>
<p>The plot usually includes some dotted vertical bars that
separate wavelet packets to make it clearer which packets are which.
This option controls the coarsest resolution level at which dotted
lines appear. All levels equal to and finer than this level will
receive the vertical dotted lines.</p>
</td></tr>
<tr><td><code id="plot.wp_+3A_color.force">color.force</code></td>
<td>
<p>If FALSE then some &quot;clever&quot; code in CanUseMoreThanOneColor tries to figure out how many colours can be used (THIS HAS NOT BEEN MADE TO WORK
IN R)  and hence whether colour can be used to pick out wavelet
packets or elements of a node vector.
This option was designed to work with S.
It doesn't work with R and so it is probably best to set
<code>color.force=T</code>. In this way no interrogation is done and the
lines/packets are plotted in the appropriate colours with no
questions asked.</p>
</td></tr>
<tr><td><code id="plot.wp_+3A_waveletcolor">WaveletColor</code></td>
<td>
<p>A colour specification for the colour for wavelet
coefficients. Wavelet coefficients are a component of wavelet packet
coefficients and this option allows them to be drawn in a different
color. In R you can use names like &quot;red&quot;, &quot;blue&quot; to select the colors.
In R you'll also need to set the color.force option to TRUE.</p>
</td></tr>
<tr><td><code id="plot.wp_+3A_nodeveccolor">NodeVecColor</code></td>
<td>
<p>If a nvwp object is supplied this option can force
coefficients that are part of that nvwp to be drawn in the specified
color. See the explanation for the <code>WaveletColor</code> option above
about specification in R.</p>
</td></tr>
<tr><td><code id="plot.wp_+3A_fast">fast</code></td>
<td>
<p>This option no longer does anything.</p>
</td></tr>
<tr><td><code id="plot.wp_+3A_smoothedlines">SmoothedLines</code></td>
<td>
<p>If TRUE then the scaling function coefficients are
drawn using lines (and look like mini versions of the original).
If FALSE then the scaling function coefficients are drawn using
the <code>segments</code> function and look like a coarser shadowy
version of the original.</p>
</td></tr>
<tr><td><code id="plot.wp_+3A_...">...</code></td>
<td>
<p>Other arguments to the plot command</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wavelet packet object contains wavelet packet coefficients of a signal
(usually obtained by the <code><a href="#topic+wp">wp</a></code> wavelet packet transform function).
Given a wavelet packet object wp it possesses <code>nlevelsWT(wp)</code>
resolution levels.
In WaveThresh the coarsest level is level 0 and the finest is level
nlevelsWT-1.
For wavelet packets the number of packets at level j is 2^(nlevelsWT-j).
</p>
<p>This function plots the wavelet packet coefficients. At the bottom of the plot
the original input function (if present) is plotted.
Then levels above the original plot successively coarser wavelet packet
coefficients. From the Mallat transform point of view smoothing goes up off
the the left of the picture and detail to the right.
The packets are indexed from 0 to the number of packets going from left to
right within each resolution level.
</p>
<p>The function has the ability to draw wavelet coefficients in a different color using the <code>WaveletColor</code> argument.
</p>
<p>Optionally, if a node vector wavelet packet object is also supplied, which
contains the specification of a basis selected from the packet table,
then packets in that node vector can be highlighted in a another colour determined by the
<code>NodeVecColor</code>.
</p>
<p>Packets are drawn on the plot and can be separated by vertical dotted lines.
The resolution levels at which this happens can be controlled by the
<code>dotted.turn.on</code> option.
The coarsest resolution level to be drawn is controlled by the
<code>first.level</code> option.
</p>


<h3>Value</h3>

<p>Nothing 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+MaNoVe">MaNoVe</a></code>, <code><a href="#topic+wp">wp</a></code>, <code><a href="#topic+wp.object">wp.object</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
v &lt;- DJ.EX()$blocks
#
# Let's plot these to see what they look like
#
## Not run: plot(v, type="l")
#
# Do a wavelet packet transform
#
vwp &lt;- wp(v)
#
# And create a node vector
#
vnv &lt;- MaNoVe(vwp)
#
# Now plot the wavelet packets with the associated node vector
#
## Not run: plot(vwp, vnv, color.force=T, WaveletColor="red", dotted.turn.on=7)
#
# The wavelet coefficients are plotted in red. Packets from the node vector
# are depicted in green. The node vector gets plotted after the wavelet
# coefficients so the green packets overlay the red (retry the plot command
# but without the vnv object to see just the
# wavelet coefficients). The vertical dotted lines start at resolution
# level 7.
#
#
</code></pre>

<hr>
<h2 id='plot.wst'>Plot packet-ordered non-decimated wavelet transform coefficients.
</h2><span id='topic+plot.wst'></span>

<h3>Description</h3>

<p>This function plots packet-ordered non-decimated wavelet transform
coefficients arising from a <code><a href="#topic+wst.object">wst.object</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
plot(x, main = "Nondecimated Wavelet (Packet) Decomposition", 
    sub, first.level = 5, scaling = "compensated", dotted.turn.on = 5, 
    aspect = "Identity", ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.wst_+3A_x">x</code></td>
<td>
<p>The wst object whose coefficients you wish to plot.</p>
</td></tr>
<tr><td><code id="plot.wst_+3A_main">main</code></td>
<td>
<p>The main title of the plot.</p>
</td></tr>
<tr><td><code id="plot.wst_+3A_sub">sub</code></td>
<td>
<p>A subtitle for the plot.</p>
</td></tr>
<tr><td><code id="plot.wst_+3A_first.level">first.level</code></td>
<td>
<p>The first resolution level to begin plotting at.
This argument can be quite useful when you want to suppress some of
the coarser levels in the diagram.</p>
</td></tr>
<tr><td><code id="plot.wst_+3A_scaling">scaling</code></td>
<td>
<p>How you want the coefficients to be scaled.
The options are: <code>global</code> - one scale factor is chosen for the
whole plot. The scale factor depends on the coefficient to be
included on the plot that has the largest absolute value.
The global option is useful when comparing coefficients that might
appear anywhere in the plot;
<code>by.level</code> - a scale factor is chosen for each resolution level
in the plot. The scale factor for a level depends on the coefficient
in that level that has the largest absolute value. The
<code>by.level</code> option is useful when you wish to compare coefficients
within a resolution level.
The other option is <code>compensated</code> which is the same as global
except for that finer scales' coefficients are scaled up by a factor
of SQRT(2)
</p>
<p>I don't know why compensated is the default option? It is a bit silly.</p>
</td></tr>
<tr><td><code id="plot.wst_+3A_dotted.turn.on">dotted.turn.on</code></td>
<td>
<p>The plot usually includes some dotted vertical bars that
separate wavelet packets to make it clearer which packets are which.
This option controls the coarsest resolution level at which dotted
lines appear. All levels equal to and finer than this level will
receive the vertical dotted lines.</p>
</td></tr>
<tr><td><code id="plot.wst_+3A_aspect">aspect</code></td>
<td>
<p>A transform to apply to the coefficients before plotting.
If the coefficients are complex-valued and aspect=&quot;Identity&quot; then
the modulus of the coefficients are plotted.</p>
</td></tr>
<tr><td><code id="plot.wst_+3A_...">...</code></td>
<td>
<p>Other arguments to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A packet-ordered non-decimated wavelet object contains coefficients
of a signal (usually obtained by the <code><a href="#topic+wst">wst</a></code>
packet-ordered non-decimated wavelet transform, but also
functions that derive such objects, such as <code><a href="#topic+threshold.wst">threshold.wst</a></code>).
</p>
<p>A packet-ordered nondecimated wavelet object, x,
possesses <code>nlevelsWT(x)</code> resolution levels.
In WaveThresh the coarsest level is level 0 and the finest is level
<code>nlevelsWT-1</code>. For packet-ordered nondecimated wavelet
the number of blocks (packets) at
level <code>j</code> is <code>2^(nlevelsWT-j)</code>.
</p>
<p>This function plots the coefficients.
At the bottom of the plot the original input function (if present) is plotted.
Then levels above the original plot successively coarser wavelet 
coefficients.
Each packet of coefficients is plotted within dotted vertical lines.
At the finest level there are two packets: one (the left one) correspond to
the wavelet coefficients that would be obtained using the (standard)
decimated wavelet transform function, <code><a href="#topic+wd">wd</a></code>,
and the other packet are those coefficients that would have been obtained
using the standard decimated wavelet transform after a unit cyclic shift.
</p>
<p>For coarser levels there are more packets corresponding to different cyclic
shifts (although the computation is not performed using shifting operations
the effect is the same). For full details see Nason and Silverman, 1995.
</p>
<p>Packets are drawn on the plot and can be separated by vertical dotted lines.
The resolution levels at which this happens can be controlled by the
<code>dotted.turn.on</code> option.
The coarsest resolution level to be drawn is controlled by
the <code>first.level option</code>.
</p>
<p><em>It should be noted that the packets referred to here are just the
blocks of nondecimated wavelet coefficients in a packet-ordering.
These are different to wavelet packets (produced by <code><a href="#topic+wp">wp</a></code>)
and nondecimated wavelet packets (produced by <code><a href="#topic+wpst">wpst</a></code>)</em>
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+MaNoVe">MaNoVe</a></code>,<code><a href="#topic+threshold.wst">threshold.wst</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
v &lt;- DJ.EX()$heavi
#
# Let's plot these to see what they look like
#
## Not run: plot(v, type="l")
#
# Do a packet-ordered non-decimated wavelet packet transform
#
vwst &lt;- wst(v)
#
# Now plot the coefficients
#
## Not run: plot(vwst)
#
# Note that the "original" function is at the bottom of the plot.
# The finest scale coefficients (two packets) are immediately above.
# Increasingly coarser scale coefficients are above that!
#
</code></pre>

<hr>
<h2 id='plot.wst2D'>Plot packet-ordered 2D non-decimated wavelet coefficients.</h2><span id='topic+plot.wst2D'></span>

<h3>Description</h3>

<p>This function plots packet-ordered 2D non-decimated wavelet coefficients arising from a <code><a href="#topic+wst2D">wst2D</a></code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst2D'
plot(x, plot.type="level", main="", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.wst2D_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+wst2D">wst2D</a></code> object whose coefficients you wish to plot.</p>
</td></tr>
<tr><td><code id="plot.wst2D_+3A_plot.type">plot.type</code></td>
<td>
<p>So far the only valid argument is &quot;level&quot; which plots coefficients a level at a time.</p>
</td></tr>
<tr><td><code id="plot.wst2D_+3A_main">main</code></td>
<td>
<p>The main title of the plot.</p>
</td></tr> 
<tr><td><code id="plot.wst2D_+3A_...">...</code></td>
<td>
<p>Any other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficients in a <code><a href="#topic+wst2D">wst2D</a></code> object are stored in a three-dimensional subarray called <code>wst2D</code>. The first index of the 3D array indexes the resolution level of coefficients: this function with <code>plot.type="level"</code> causes an image of coefficients to be plotted one for each resolution level. 
</p>
<p>The following corresponds to images produced on S+ graphics devices (e.g. image on <code>motif()</code>). Given a resolution level there are <code>4^(nlevelsWT-level)</code> packets within a level. Each packet can be addressed by a base-4 string of length <code>nlevels-level</code>. A zero corresponds to no shift, a 1 to a horizontal shift, a 2 to a vertical shift and a 3 to both a horizontal and vertical shift. 
</p>
<p>So, for examples, at resolution level <code>nlevelsWT-1</code> there are 4 sub-images each containing 4 sub-images. The main subimages correspond to (clockwise from bottom-left) no shift, horizontal shift, both shift and vertical shifts. The sub-images of the sub-images correspond to the usual smooth, horizontal detail, diagonal detail and vertical detail (clockwise, again from bottom left). Coarser resolution levels correspond to finer shifts! The following figure demonstrates the <code>nlevels-1</code> resolution level for the <code>ua</code> image (although the whole image has been rotated by 90 degrees clockwise for display here!):
</p>


<h3>Value</h3>

<p>A plot of the coefficients contained within the <code><a href="#topic+wst2D">wst2D</a></code> object is produced. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+getpacket.wst2D">getpacket.wst2D</a></code>, <code><a href="#topic+putpacket.wst2D">putpacket.wst2D</a></code>, <code><a href="#topic+wst2D">wst2D</a></code>, <code><a href="#topic+wst2D.object">wst2D.object</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The above picture is one of a series produced by 
#
#plot(uawst2D)
#
# Where the uawst2D object was produced in the EXAMPLES section
# of the help for \code{\link{wst2D}}
</code></pre>

<hr>
<h2 id='plotdenwd'>Plot the wavelet coefficients of a p.d.f.</h2><span id='topic+plotdenwd'></span>

<h3>Description</h3>

<p>Plots the wavelet coefficients of a density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotdenwd(wd, xlabvals, xlabchars, ylabchars, first.level=0,
	top.level=nlevelsWT(wd)-1,
	main="Wavelet Decomposition Coefficients", scaling="global",
	rhlab=FALSE, sub, NotPlotVal=0.005, xlab="Translate",
	ylab="Resolution Level", aspect="Identity", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotdenwd_+3A_wd">wd</code></td>
<td>
<p>Wavelet decomposition object, usually output from <code><a href="#topic+denwd">denwd</a></code>,
possibly thresholded.</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_xlabvals">xlabvals</code></td>
<td>
<p>X-axis values at which the <code>xlabchars</code> will be printed</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_xlabchars">xlabchars</code></td>
<td>
<p>The x-label characters to be plotted at <code>xlabvals</code></p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_ylabchars">ylabchars</code></td>
<td>
<p>The y-label characters</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_first.level">first.level</code></td>
<td>
<p>This specifies how many of the coarse levels of
coefficients are omitted from the plot.
The default value of 0 means that all levels are plotted.</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_top.level">top.level</code></td>
<td>
<p>This tells the plotting rountine the true resolution level of
the finest level of coefficients. The default results in the
coarsest level being labelled 0. The &quot;correct&quot; value can be
determined from the empirical scaling function coefficient object
(output from denproj) as in the example below.</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_main">main</code></td>
<td>
<p>The title of the plot.</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_scaling">scaling</code></td>
<td>
<p>The type of scaling applied to levels within the plot.
This can be &quot;compensated&quot;, &quot;by.level&quot; or &quot;global&quot;.
See <code><a href="#topic+plot.wd">plot.wd</a></code> for further details.</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_rhlab">rhlab</code></td>
<td>
<p>Determines whether the scale factors applied to each level
before plotting are printed as the right hand axis.</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_sub">sub</code></td>
<td>
<p>The plot subtitle</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_notplotval">NotPlotVal</code></td>
<td>
<p>If the maximum coefficient in a particular level is smaller than <code>NotPlotVal</code>, then the level is not plotted.</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_aspect">aspect</code></td>
<td>
<p>Function to apply to coefficients before plotting</p>
</td></tr>
<tr><td><code id="plotdenwd_+3A_...">...</code></td>
<td>
<p>Other arguments to the main plot routine</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically the same as
<code><a href="#topic+plot.wd">plot.wd</a></code> except that it copes with the zero boundary conditions
used in density estimation. Note that for large filter number wavelets the
high level coefficients will appear very squashed compared with the low
level coefficients. This is a consequence of the zero boundary conditions
and the use of the convention that each coefficient is plotted midway between
two coefficients at the next highest level, as in <code><a href="#topic+plot.wd">plot.wd</a></code>.
</p>


<h3>Value</h3>

<p>Axis labels to the right of the picture (scale factors).
These are returned as they are sometimes hard to read on the plot.
</p>


<h3>Author(s)</h3>

<p>David Herrick</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data from the claw density, find the empirical
# scaling function coefficients, decompose them and plot
# the resulting wavelet coefficients

data &lt;- rclaw(100)
datahr &lt;- denproj(data, J=8, filter.number=2, family="DaubExPhase")
data.wd &lt;- denwd(datahr)
## Not run: plotdenwd(data.wd, top.level=(datahr$res$J-1))
#
# Now use a smoother wavelet
#
datahr &lt;- denproj(data, J=8, filter.number=10, family="DaubLeAsymm")
data.wd &lt;- denwd(datahr)
## Not run: plotdenwd(data.wd, top.level=(datahr$res$J-1))
</code></pre>

<hr>
<h2 id='plotpkt'>Sets up a high level plot ready to show the time-frequency plane
and wavelet packet basis slots</h2><span id='topic+plotpkt'></span>

<h3>Description</h3>

<p>Sets up a high level plot ready to add wavelet packet slots using, 
e.g. <code><a href="#topic+addpkt">addpkt</a></code>. This function is used by several routines
to begin plotting graphical representations of the time-frequency plane
and spaces for packets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotpkt(J)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotpkt_+3A_j">J</code></td>
<td>
<p>The number of resolution levels associated with the wavelet
packet object you want to depict</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing of interest
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+addpkt">addpkt</a></code>, <code><a href="#topic+basisplot">basisplot</a></code>, <code><a href="#topic+basisplot.BP">basisplot.BP</a></code>, <code><a href="#topic+basisplot.wp">basisplot.wp</a></code>, <code><a href="#topic+plot.nvwp">plot.nvwp</a></code></p>

<hr>
<h2 id='print.BP'>Print top best basis information for BP class object</h2><span id='topic+print.BP'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+Best1DCols">Best1DCols</a></code> works out what are the best
packets in a selection of packets. This function prints out what the
best packet are.
</p>
<p>The <code><a href="#topic+Best1DCols">Best1DCols</a></code> is not intended for user use, and hence neither
is this print method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BP'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.BP_+3A_x">x</code></td>
<td>
<p>The BP object you wish to print</p>
</td></tr>
<tr><td><code id="print.BP_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+Best1DCols">Best1DCols</a></code></p>

<hr>
<h2 id='print.imwd'>Print out information about an imwd object in readable form. </h2><span id='topic+print.imwd'></span>

<h3>Description</h3>

<p>This function prints out information about an <code><a href="#topic+imwd.object">imwd.object</a></code> in a nice human-readable form. 
</p>
<p>Note that this function is automatically called by SPlus whenever the name of an <code><a href="#topic+imwd.object">imwd.object</a></code> is typed or whenever such an object is returned to the top level of the S interpreter. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwd'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.imwd_+3A_x">x</code></td>
<td>
<p>An object of class imwd that you wish to print out.</p>
</td></tr>
<tr><td><code id="print.imwd_+3A_...">...</code></td>
<td>
<p>This argument actually does nothing in this function! </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints out information about <code><a href="#topic+imwd">imwd</a></code> objects in nice readable format. 
</p>


<h3>Value</h3>

<p>The last thing this function does is call <code><a href="#topic+summary.imwd">summary.imwd</a></code> so the return value is whatever is returned by this function. 
</p>


<h3>RELEASE</h3>

<p>Version 3.0 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+summary.imwd">summary.imwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an imwd object.
#
tmp &lt;- imwd(matrix(0, nrow=32, ncol=32))
#
# Now get R to use print.imwd
#
tmp
# Class 'imwd' : Discrete Image Wavelet Transform Object:
#        ~~~~  : List with 27 components with names
#              nlevelsWT fl.dbase filter type bc date w4L4 w4L1 w4L2 w4L3
# w3L4 w3L1 w3L2 w3L3 w2L4 w2L1 w2L2 w2L3 w1L4 w1L1 w1L2 w1L3 w0L4 w0L1
# w0L2 w0L3 w0Lconstant 
#
# $ wNLx are LONG coefficient vectors !
#
# summary(.):
# ----------
# UNcompressed image wavelet decomposition structure
# Levels:  5 
# Original image was 32 x 32  pixels.
# Filter was:  Daub cmpct on least asymm N=10 
# Boundary handling:  periodic 

</code></pre>

<hr>
<h2 id='print.imwdc'>Print out information about an imwdc object in readable form. </h2><span id='topic+print.imwdc'></span>

<h3>Description</h3>

<p>This function prints out information about an <code><a href="#topic+imwdc.object">imwdc.object</a></code> in a nice human-readable form. 
</p>
<p>Note that this function is automatically called by SPlus whenever the name of an <code><a href="#topic+imwdc.object">imwdc.object</a></code> is typed or whenever such an object is returned to the top level of the S interpreter. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwdc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.imwdc_+3A_x">x</code></td>
<td>
<p>An object of class imwdc that you wish to print out.</p>
</td></tr>
<tr><td><code id="print.imwdc_+3A_...">...</code></td>
<td>
<p>This argument actually does nothing in this function! </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints out information about <code>imwdc</code> objects in nice readable format. 
</p>


<h3>Value</h3>

<p>The last thing this function does is call <code><a href="#topic+summary.imwdc">summary.imwdc</a></code> so the return value is whatever is returned by this function. 
</p>


<h3>RELEASE</h3>

<p>Version 2.2 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwdc.object">imwdc.object</a></code>, <code><a href="#topic+summary.imwdc">summary.imwdc</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an imwd object.
#
tmp &lt;- imwd(matrix(0, nrow=32, ncol=32))
#
# Now get R to use print.imwd
#
tmp
# Class 'imwd' : Discrete Image Wavelet Transform Object:
#        ~~~~  : List with 27 components with names
#              nlevelsWT fl.dbase filter type bc date w4L4 w4L1 w4L2 w4L3
# w3L4 w3L1 w3L2 w3L3 w2L4 w2L1 w2L2 w2L3 w1L4 w1L1 w1L2 w1L3 w0L4 w0L1
# w0L2 w0L3 w0Lconstant 
#
# $ wNLx are LONG coefficient vectors !
#
# summary(.):
# ----------
# UNcompressed image wavelet decomposition structure
# Levels:  5 
# Original image was 32 x 32  pixels.
# Filter was:  Daub cmpct on least asymm N=10 
# Boundary handling:  periodic 
</code></pre>

<hr>
<h2 id='print.mwd'>Use print() on a mwd object.</h2><span id='topic+print.mwd'></span>

<h3>Description</h3>

<p>This function prints out information about an <code><a href="#topic+mwd.object">mwd.object</a></code> in a nice human-readable form. 
</p>
<p>Note that this function is automatically called by SPlus whenever the name of an <code><a href="#topic+mwd.object">mwd.object</a></code> is typed or whenever such an object is returned to the top level of the S interpreter. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mwd'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mwd_+3A_x">x</code></td>
<td>
<p>An object of class mwd that you wish to print out.</p>
</td></tr> 
<tr><td><code id="print.mwd_+3A_...">...</code></td>
<td>
<p>This argument actually does nothing in this function!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints out information about <code><a href="#topic+mwd">mwd</a></code> objects in nice readable format. 
</p>


<h3>Value</h3>

<p>The last thing this function does is call <code><a href="#topic+summary.mwd">summary.mwd</a></code> so the return value is whatever is returned by this function. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie 1995-6) </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.mwd">accessC.mwd</a></code>, <code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mfilter.select">mfilter.select</a></code>,<code><a href="#topic+mwd">mwd</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+mwr">mwr</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an mwd object.
#
tmp &lt;- mwd(rnorm(32))
#
# Now get Splus to use print.mwd
#
tmp
# Class 'mwd' : Discrete Multiple Wavelet Transform Object:
#	 ~~~  : List with 10 components with names
#		 C D nlevelsWT ndata filter fl.dbase type bc prefilter date 
# 
# $ C and $ D are LONG coefficient vectors !
# 
# Created on : Tue Nov 16 13:16:07 GMT 1999 
# Type of decomposition:  wavelet 
# 
# summary:
# ----------
# Length of original:  32 
# Levels:  4 
# Filter was:  Geronimo Multiwavelets 
# Scaling fns:  2 
# Wavelet fns:  2 
# Prefilter:  default 
# Scaling factor:  2 
# Boundary handling:  periodic 
# Transform type:  wavelet 
# Date:  Tue Nov 16 13:16:07 GMT 1999 
</code></pre>

<hr>
<h2 id='print.nv'>Print a node vector object, also used by several other functions to
obtain packet list information</h2><span id='topic+print.nv'></span>

<h3>Description</h3>

<p>Ostensibly prints out node vector information, but also produces packet
indexing information for several functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nv'
print(x, printing = TRUE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.nv_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+nv.object">nv.object</a></code> that you wish to print</p>
</td></tr>
<tr><td><code id="print.nv_+3A_printing">printing</code></td>
<td>
<p>If FALSE then nothing is printed. This argument is
here because the results of the printing are also useful
to many other routines where you want the results but are not
bothered by actually seeing the results</p>
</td></tr>
<tr><td><code id="print.nv_+3A_verbose">verbose</code></td>
<td>
<p>Not actually used</p>
</td></tr>
<tr><td><code id="print.nv_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A node vector contains selected basis information, but this is stored
as a tree object. Hence, it is not immediately obvious which basis elements
have been stored. This function produces a list of the packets at each
resolution level that have been selected in the basis. This information
is so useful to other functions that the function is used even when
printing is not the primary objective.
</p>


<h3>Value</h3>

<p>A list containing two components: <code>indexlist</code> and <code>rvector</code>.
The former is a list of packets that were selected at each resolution
level. Rvector encodes a list of &quot;rotate/non-rotate&quot; instructions in binary.
At each selected packet level a decision has to be made whether to select
the LH or RH basis element, and this information is stored in <code>rvector</code>.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+InvBasis.wst">InvBasis.wst</a></code>,
<code><a href="#topic+nv.object">nv.object</a></code>,
<code><a href="#topic+plot.wp">plot.wp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- rnorm(128)
vwst &lt;- wst(v)
vnv &lt;- MaNoVe(vwst)
print(vnv)
#Level :  6  Action is  R (getpacket Index:  1 )
#Level :  5  Action is  L (getpacket Index:  2 )
#Level :  4  Action is  L (getpacket Index:  4 )
#Level :  3  Action is  R (getpacket Index:  9 )
#Level :  2  Action is  L (getpacket Index:  18 )
#There are  6  reconstruction steps
#
# The L or R indicate whether to move to the left or the right basis function
# when descending the node tree
#
#
</code></pre>

<hr>
<h2 id='print.nvwp'>Print a wavelet packet node vector object,
also used by several other functions to
obtain packet list information</h2><span id='topic+print.nvwp'></span>

<h3>Description</h3>

<p>Ostensibly prints out wavlet packet node vector information,
but also produces packet
indexing information for several functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nvwp'
print(x, printing = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.nvwp_+3A_x">x</code></td>
<td>
<p>The nvwp that you wish to print</p>
</td></tr>
<tr><td><code id="print.nvwp_+3A_printing">printing</code></td>
<td>
<p>If FALSE then nothing is printed. This argument is
here because the results of the printing are also useful
to many other routines where you want the results but are not
bothered by actually seeing the results</p>
</td></tr>
<tr><td><code id="print.nvwp_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A node vector contains selected basis information, but this is stored
as a tree object. Hence, it is not immediately obvious which basis elements
have been stored. This function produces a list of the packets at each
resolution level that have been selected in the basis. This information
is so useful to other functions that the function is used even when
printing is not the primary objective.
</p>


<h3>Value</h3>

<p>A list containing two components: <code>level</code> and <code>pkt</code>.
These are the levels and packet indices of the select packets in the basis.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+InvBasis.wp">InvBasis.wp</a></code>,
<code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code>,
<code><a href="#topic+plot.nvwp">plot.nvwp</a></code>,
<code><a href="#topic+plot.wp">plot.wp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- rnorm(128)
vwp &lt;- wp(v)
vnv &lt;- MaNoVe(vwp)
print(vnv)
#Level:  6  Packet:  1
#Level:  3  Packet:  0
#Level:  2  Packet:  4
#Level:  2  Packet:  13
#Level:  2  Packet:  15
#Level:  1  Packet:  5
#Level:  1  Packet:  10
#Level:  1  Packet:  13
#Level:  1  Packet:  14
#Level:  1  Packet:  15
#Level:  1  Packet:  16
#Level:  1  Packet:  20
#Level:  1  Packet:  21
#Level:  1  Packet:  24
#Level:  0  Packet:  8
#Level:  0  Packet:  9
#Level:  0  Packet:  12
#Level:  0  Packet:  13
#Level:  0  Packet:  14
#Level:  0  Packet:  15
#Level:  0  Packet:  22
#Level:  0  Packet:  23
#Level:  0  Packet:  24
#Level:  0  Packet:  25
#Level:  0  Packet:  34
#Level:  0  Packet:  35
#Level:  0  Packet:  36
#Level:  0  Packet:  37
#Level:  0  Packet:  38
#Level:  0  Packet:  39
#Level:  0  Packet:  44
#Level:  0  Packet:  45
#Level:  0  Packet:  46
#Level:  0  Packet:  47
#Level:  0  Packet:  50
#Level:  0  Packet:  51
#Level:  0  Packet:  56
#Level:  0  Packet:  57
#Level:  0  Packet:  58
#Level:  0  Packet:  59
</code></pre>

<hr>
<h2 id='print.w2d'>Print method for printing w2d class objects</h2><span id='topic+print.w2d'></span>

<h3>Description</h3>

<p>Prints information about a w2d class object. These objects are not typically
directly used by a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'w2d'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.w2d_+3A_x">x</code></td>
<td>
<p>The w2d class object that you wish to print info about</p>
</td></tr>
<tr><td><code id="print.w2d_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpst2discr">wpst2discr</a></code></p>

<hr>
<h2 id='print.w2m'>
Print a w2m class object
</h2><span id='topic+print.w2m'></span>

<h3>Description</h3>

<p>These objects are the matrix representation of a nondecimated wavelet
packet object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'w2m'
print(x, maxbasis = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.w2m_+3A_x">x</code></td>
<td>

<p>The w2m object to print
</p>
</td></tr>
<tr><td><code id="print.w2m_+3A_maxbasis">maxbasis</code></td>
<td>

<p>The maximum number of basis functions to report on
</p>
</td></tr>
<tr><td><code id="print.w2m_+3A_...">...</code></td>
<td>

<p>Other arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints out information about a w2m object. This function gets called
during <code><a href="#topic+makewpstRO">makewpstRO</a></code>, and so you can see its output in the
example code in that help function
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>G P Nason
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makewpstRO">makewpstRO</a></code>,<code><a href="#topic+wpst2m">wpst2m</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example in makewpstRO
#
</code></pre>

<hr>
<h2 id='print.wd'>Print out information about an wd object in readable form. </h2><span id='topic+print.wd'></span>

<h3>Description</h3>

<p>This function prints out information about an <code><a href="#topic+wd.object">wd.object</a></code> in a nice human-readable form. 
</p>
<p>Note that this function is automatically called by SPlus whenever the name of an <code><a href="#topic+wd.object">wd.object</a></code> is typed or whenever such an object is returned to the top level of the S interpreter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.wd_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+wd">wd</a></code> that you wish to print out.</p>
</td></tr>
<tr><td><code id="print.wd_+3A_...">...</code></td>
<td>
<p>This argument actually does nothing in this function!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints out information about <code><a href="#topic+wd">wd</a></code> objects in nice readable format. 
</p>


<h3>Value</h3>

<p>The last thing this function does is call <code><a href="#topic+summary.wd">summary.wd</a></code> so the return value is whatever is returned by this function.</p>


<h3>RELEASE</h3>

<p>Version 3.0 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+summary.wd">summary.wd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an wd object.
#
tmp &lt;- wd(rnorm(32))
#
# Now get R to use print.wd
#
tmp
# Class 'wd' : Discrete Wavelet Transform Object:
#        ~~  : List with 8 components with names
#               C D nlevelsWT fl.dbase filter type bc date 
#
# $ C and $ D are LONG coefficient vectors !
#
# Created on : Fri Oct 23 19:56:00 1998 
# Type of decomposition:  wavelet 
# 
# summary(.):
# ----------
# Levels:  5 
# Length of original:  32 
# Filter was:  Daub cmpct on least asymm N=10 
# Boundary handling:  periodic 
# Transform type:  wavelet 
# Date:  Fri Oct 23 19:56:00 1998 
#
#
</code></pre>

<hr>
<h2 id='print.wd3D'>Print out information about an wd3D object in a readable form.</h2><span id='topic+print.wd3D'></span>

<h3>Description</h3>

<p>This function prints out information about an <code><a href="#topic+wd3D.object">wd3D.object</a></code> in a readable form. 
</p>
<p>Note that this function is automatically called by SPlus whenever the name of an <code><a href="#topic+wd3D.object">wd3D.object</a></code> is typed or whenever such an object is returned to the top level of the S interpreter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd3D'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.wd3D_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+wd3D">wd3D</a></code> that you wish to print out.</p>
</td></tr>
<tr><td><code id="print.wd3D_+3A_...">...</code></td>
<td>
<p>This argument actually does nothing in this function!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints out information about <code><a href="#topic+wd3D">wd3D</a></code> objects in nice readable format. 
</p>


<h3>Value</h3>

<p>The last thing this function does is call <code><a href="#topic+summary.wd3D">summary.wd3D</a></code> so the return value is whatever is returned by this function.</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessD.wd3D">accessD.wd3D</a></code>, <code><a href="#topic+print.wd3D">print.wd3D</a></code>, <code><a href="#topic+putD.wd3D">putD.wd3D</a></code>, <code><a href="#topic+putDwd3Dcheck">putDwd3Dcheck</a></code>, <code><a href="#topic+summary.wd3D">summary.wd3D</a></code>, <code><a href="#topic+threshold.wd3D">threshold.wd3D</a></code>, <code><a href="#topic+wd3D">wd3D</a></code>, <code><a href="#topic+wd3D.object">wd3D.object</a></code>, <code><a href="#topic+wr3D">wr3D</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an wd3D object.
#
tmp &lt;- wd3D(array(rnorm(512), dim=c(8,8,8)))
#
# Now get R to use print.wd
#
tmp
#Class 'wd3d' : 3D DWT Object:
#       ~~~~  : List with 5 components with names
#              a filter.number family date nlevelsWT 
#
#$ a is the wavelet coefficient array
#Dimension of a is [1] 8 8 8
#
#Created on : Wed Oct 20 17:24:15 BST 1999 
#
#summary(.):
#----------
#Levels:  3 
#Filter number was:  10 
#Filter family was:  DaubLeAsymm 
#Date:  Wed Oct 20 17:24:15 BST 1999 
</code></pre>

<hr>
<h2 id='print.wp'>Print out information about an wd object in readable form. </h2><span id='topic+print.wp'></span>

<h3>Description</h3>

<p>This function prints out information about an <code><a href="#topic+wp.object">wp.object</a></code> in a nice human-readable form. 
</p>
<p>Note that this function is automatically called by SPlus whenever the name of an <code><a href="#topic+wp.object">wp.object</a></code> is typed or whenever such an object is returned to the top level of the S interpreter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.wp_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+wp">wp</a></code> that you wish to print out.</p>
</td></tr>
<tr><td><code id="print.wp_+3A_...">...</code></td>
<td>
<p>This argument actually does nothing in this function!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints out information about <code><a href="#topic+wp">wp</a></code> objects in nice readable format. 
</p>


<h3>Value</h3>

<p>The last thing this function does is call <code><a href="#topic+summary.wp">summary.wp</a></code> so the return value is whatever is returned by this function.</p>


<h3>RELEASE</h3>

<p>Version 3.0 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wp.object">wp.object</a></code>, <code><a href="#topic+summary.wp">summary.wp</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an wp object.
#
tmp &lt;- wp(rnorm(32))
#
# Now get Splus to use print.wp
#
tmp
#
# Now get Splus to use print.wp
#
# tmp
# Class 'wp' : Wavelet Packet Object:
#        ~~  : List with 4 components with names
#               wp nlevelsWT filter date 
# 
# $wp is the wavelet packet matrix
# 
# Created on : Fri Oct 23 19:59:01 1998 
# 
# summary(.):
# ----------
# Levels:  5 
# Length of original:  32 
# Filter was:  Daub cmpct on least asymm N=10 
</code></pre>

<hr>
<h2 id='print.wpst'>Prints out basic information about a wpst class object</h2><span id='topic+print.wpst'></span>

<h3>Description</h3>

<p>Prints out basic information about a wpst class object generated by
the, e.g., <code><a href="#topic+wpst">wpst</a></code> function.
</p>
<p><em>Note:</em> stationary wavelet packet objects are now known as nondecimated
wavelet packet objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wpst'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.wpst_+3A_x">x</code></td>
<td>
<p>The wpst object that you wish to print info about</p>
</td></tr>
<tr><td><code id="print.wpst_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpst">wpst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- rnorm(128)
vwpst &lt;- wpst(v)
## Not run: print(vwpst)
#Class 'wpst' : Stationary Wavelet Packet Transform Object:
#	~~~  : List with 5 components with names
#		wpst nlevelsWT avixstart filter date
#
#$wpst is a coefficient vector
#
#Created on : Fri Mar  5 15:06:56 2010
#
#summary(.):
#----------
#Levels:  7
#Length of original:  128
#Filter was:  Daub cmpct on least asymm N=10
#Date:  Fri Mar  5 15:06:56 2010
</code></pre>

<hr>
<h2 id='print.wpstCL'>Prints some information about a wpstCL object</h2><span id='topic+print.wpstCL'></span>

<h3>Description</h3>

<p>Prints basic information about a wpstCL object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wpstCL'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.wpstCL_+3A_x">x</code></td>
<td>
<p>wpstCL object to print info about</p>
</td></tr>
<tr><td><code id="print.wpstCL_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+makewpstDO">makewpstDO</a></code>,<code><a href="#topic+wpstCLASS">wpstCLASS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Use BabySS and BabyECG data for this example.
#
# Want to predict future values of BabySS from future values of BabyECG
#
# Build model on first 256 values of both
#
# See example in makewpstDO from which this one originates
#
data(BabyECG)
data(BabySS)
BabyModel &lt;- makewpstDO(timeseries=BabyECG[1:256], groups=BabySS[1:256],
	mincor=0.5)
#
# Now, suppose we get some new data for the BabyECG time series.
# For the purposes of this example, this is just the continuing example
# ie BabyECG[257:512]. We can use our new discriminant model to predict
# new values of BabySS
#
BabySSpred &lt;- wpstCLASS(newTS=BabyECG[257:512], BabyModel)
#
BabySSpred
#wpstCL class object
#Results of applying discriminator to time series
#Components:  BasisMatrix BasisMatrixDM wpstDO PredictedOP PredictedGroups 
</code></pre>

<hr>
<h2 id='print.wpstDO'>Print information about a wpstDO class object</h2><span id='topic+print.wpstDO'></span>

<h3>Description</h3>

<p>Prints out the type of object, prints out the object's names, then uses
<code><a href="#topic+print.BP">print.BP</a></code> to print out the best single packets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wpstDO'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.wpstDO_+3A_x">x</code></td>
<td>
<p>wpstDO object to print out</p>
</td></tr>
<tr><td><code id="print.wpstDO_+3A_...">...</code></td>
<td>
<p>Other information to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+makewpstDO">makewpstDO</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Use BabySS and BabyECG data for this example.
#
# Want to predict future values of BabySS from future values of BabyECG
#
# Build model on first 256 values of both
#
data(BabyECG)
data(BabySS)
BabyModel &lt;- makewpstDO(timeseries=BabyECG[1:256], groups=BabySS[1:256],
	mincor=0.5)
#
# The results (ie print out answer)
BabyModel
#Stationary wavelet packet discrimination object
#Composite object containing components:[1] "BPd"    "BP"     "filter"
#Fisher's discrimination: done
#BP component has the following information
#BP class object. Contains "best basis" information
#Components of object:[1] "nlevelsWT"     "BasisMatrix" "level"       "pkt"         "basiscoef"
#[6] "groups"
#Number of levels  8
#List of "best" packets
#Level id Packet id Basis coef
#[1,]        4         0  0.7340580
#[2,]        5         0  0.6811251
#[3,]        6         0  0.6443167
#[4,]        3         0  0.6193434
#[5,]        7         0  0.5967620
#[6,]        0         3  0.5473777
#[7,]        1        53  0.5082849
#
</code></pre>

<hr>
<h2 id='print.wpstRO'>
Print a wpstRO class object
</h2><span id='topic+print.wpstRO'></span>

<h3>Description</h3>

<p>Prints out a representation of an wpstRO object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wpstRO'
print(x, maxbasis = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.wpstRO_+3A_x">x</code></td>
<td>

<p>The wpstRO object to print
</p>
</td></tr>
<tr><td><code id="print.wpstRO_+3A_maxbasis">maxbasis</code></td>
<td>

<p>The maximum number of basis packets to report on
</p>
</td></tr>
<tr><td><code id="print.wpstRO_+3A_...">...</code></td>
<td>

<p>Other arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p> G P Nason </p>


<h3>See Also</h3>

<p><code><a href="#topic+makewpstRO">makewpstRO</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example in makewpstRO function
#
</code></pre>

<hr>
<h2 id='print.wst'>Print out information about an wst object in readable form.</h2><span id='topic+print.wst'></span>

<h3>Description</h3>

<p>This function prints out information about an
<code><a href="#topic+wst.object">wst.object</a></code> object in a nice human-readable form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.wst_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+wst.object">wst.object</a></code> object to print info on</p>
</td></tr>
<tr><td><code id="print.wst_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an wst object (a "nonsense" one for
# the example).
#
vwst &lt;- wst(DJ.EX()$heavi)
#
# Now get Splus/R to use print.wst
#
vwst
#Class 'wst' : Stationary Wavelet Transform Object:
#       ~~~  : List with 5 components with names
#              wp Carray nlevelsWT filter date 
#
#$wp and $Carray are the coefficient matrices
#
#Created on : Wed Sep 08 09:24:03 2004 
#
#summary(.):
#----------
#Levels:  10 
#Length of original:  1024 
#Filter was:  Daub cmpct on least asymm N=10 
#Date:  Wed Sep 08 09:24:03 2004 
</code></pre>

<hr>
<h2 id='print.wst2D'>Print out information about an wst2d object in a readable form.</h2><span id='topic+print.wst2D'></span>

<h3>Description</h3>

<p>This function prints out information about an <code><a href="#topic+wst2D.object">wst2D.object</a></code> in a nice human- readable form. 
</p>
<p>Note that this function is automatically called by SPlus whenever the name of an <code><a href="#topic+wst2D.object">wst2D.object</a></code> is typed or whenever such an object is returned to the top level of the S interpreter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst2D'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.wst2D_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+wst2D">wst2D</a></code> that you wish to print out.</p>
</td></tr>
<tr><td><code id="print.wst2D_+3A_...">...</code></td>
<td>
<p>This argument actually does nothing in this function!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints out information about <code><a href="#topic+wst2D">wst2D</a></code> objects in nice readable format. 
</p>


<h3>Value</h3>

<p>The last thing this function does is call <code><a href="#topic+summary.wst2D">summary.wst2D</a></code> so the return value is whatever is returned by this function.</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst2D.object">wst2D.object</a></code>, <code><a href="#topic+summary.wst2D">summary.wst2D</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# This examples uses the uawst2D object created in the EXAMPLES
# section of the help page for wst2D 
#
#uawst2D
#Class 'wst2D' : 2D Stationary Wavelet Transform Object:
#       ~~~~~  : List with 4 components with names
#              wst2D nlevelsWT filter date 
#
#$wst2D is the coefficient array
#
#Created on : Fri Nov  5 18:06:17 GMT 1999 
#
#summary(.):
#----------
#Levels:  8 
#Length of original:  256 x 256 
#Filter was:  Daub cmpct on least asymm N=10 
#Date:  Fri Nov  5 18:06:17 GMT 1999 
</code></pre>

<hr>
<h2 id='PsiJ'>Compute discrete autocorrelation wavelets.</h2><span id='topic+PsiJ'></span>

<h3>Description</h3>

<p>This function computes discrete autocorrelation wavelets. 
</p>
<p>The inner products of the discrete autocorrelation wavelets are computed by the routine <code><a href="#topic+ipndacw">ipndacw</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PsiJ(J, filter.number = 10, family = "DaubLeAsymm", tol = 1e-100,
    OPLENGTH=10^7, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PsiJ_+3A_j">J</code></td>
<td>
<p>Discrete autocorrelation wavelets will be computed for scales -1 up to scale J. This number should be a negative integer.</p>
</td></tr>
<tr><td><code id="PsiJ_+3A_filter.number">filter.number</code></td>
<td>
<p>The index of the wavelet used to compute the discrete autocorrelation wavelets.</p>
</td></tr>
<tr><td><code id="PsiJ_+3A_family">family</code></td>
<td>
<p>The family of wavelet used to compute the discrete autocorrelation wavelets.</p>
</td></tr>
<tr><td><code id="PsiJ_+3A_tol">tol</code></td>
<td>
<p>In the brute force computation for Daubechies compactly supported wavelets many inner product computations are performed. This tolerance discounts any results which are smaller than <code>tol</code> which effectively defines how long the inner product/autocorrelation products are.</p>
</td></tr>
<tr><td><code id="PsiJ_+3A_oplength">OPLENGTH</code></td>
<td>
<p>This integer variable defines some workspace of length OPLENGTH. The code uses this workspace. If the workspace is not long enough then the routine will stop and probably tell you what OPLENGTH should be set to.</p>
</td></tr>
<tr><td><code id="PsiJ_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then informative error messages are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the discrete autocorrelation wavelets. It does not have any direct use for time-scale analysis (e.g. <code><a href="#topic+ewspec">ewspec</a></code>). However, it is useful to be able to numerically compute the discrete autocorrelation wavelets for arbitrary wavelets and scales as there are still unanswered theoretical questions concerning the wavelets. The method is a brute force &ndash; a more elegant solution would probably be based on interpolatory schemes. 
</p>
<p><b>Horizontal scale</b>. This routine returns only the values of the discrete autocorrelation wavelets and not their horiztonal positions. Each discrete autocorrelation wavelet is compactly supported with the support determined from the compactly supported wavelet that generates it. See the paper by Nason, von Sachs and Kroisandt which defines the horiztonal scale (but basically the finer scale discrete autocorrelation wavelets are interpolated versions of the coarser ones. When one goes from scale j to j-1 (negative j remember) an extra point is inserted between all of the old points and the discrete autocorrelation wavelet value is computed there. Thus as J tends to negative infinity the numerical approximation tends towards the continuous autocorrelation wavelet. 
</p>
<p>This function stores any discrete autocorrelation wavelet sets that it computes. The storage mechanism is not as advanced as that for <code><a href="#topic+ipndacw">ipndacw</a></code> and its subsidiary routines <code><a href="#topic+rmget">rmget</a></code> and <code><a href="#topic+firstdot">firstdot</a></code> but helps a little bit. The <code><a href="#topic+Psiname">Psiname</a></code> function defines the naming convention for objects returned by this function. 
</p>
<p>Sometimes it is useful to have the discrete autocorrelation wavelets stored in matrix form. The <code><a href="#topic+PsiJmat">PsiJmat</a></code> does this. 
</p>
<p>Note: intermediate calculations are stored in a user-visible environment called <code><a href="#topic+WTEnv">WTEnv</a></code>. Previous versions of wavethresh stored this in the user's default data space (<code>.GlobalEnv</code>) but wavethresh did not ask permission
nor notify the user. You can make these objects persist if you wish.
</p>


<h3>Value</h3>

<p>A list containing -J components, numbered from 1 to -J. The [[j]]th component contains the discrete autocorrelation wavelet at scale j. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (1998). Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum. <code>echnical Report</code>, Department of Mathematics University of Bristol/ Fachbereich Mathematik, Kaiserslautern.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ewspec">ewspec</a></code>, <code><a href="#topic+ipndacw">ipndacw</a></code>, <code><a href="#topic+PsiJmat">PsiJmat</a></code>, <code><a href="#topic+Psiname">Psiname</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let us create the discrete autocorrelation wavelets for the Haar wavelet.
# We shall create up to scale 4.
#
PsiJ(-4, filter.number=1, family="DaubExPhase")
#Computing PsiJ
#Returning precomputed version
#Took  0.00999999  seconds
#[[1]]:
#[1] -0.5  1.0 -0.5
#
#[[2]]:
#[1] -0.25 -0.50  0.25  1.00  0.25 -0.50 -0.25
#
#[[3]]:
# [1] -0.125 -0.250 -0.375 -0.500 -0.125  0.250  0.625  1.000  0.625  0.250
#[11] -0.125 -0.500 -0.375 -0.250 -0.125
#
#[[4]]:
# [1] -0.0625 -0.1250 -0.1875 -0.2500 -0.3125 -0.3750 -0.4375 -0.5000 -0.3125
#[10] -0.1250  0.0625  0.2500  0.4375  0.6250  0.8125  1.0000  0.8125  0.6250
#[19]  0.4375  0.2500  0.0625 -0.1250 -0.3125 -0.5000 -0.4375 -0.3750 -0.3125
#[28] -0.2500 -0.1875 -0.1250 -0.0625
#
# You can plot the fourth component to get an idea of what the
# autocorrelation wavelet looks like.
#
# Note that the previous call stores the autocorrelation wavelet
# in Psi.4.1.DaubExPhase. This is mainly so that it doesn't have to
# be recomputed.  
#
# Note that the x-coordinates in the following are approximate.
#
## Not run: plot(seq(from=-1, to=1, length=length(Psi.4.1.DaubExPhase[[4]])),
	Psi.4.1.DaubExPhase[[4]], type="l",
	xlab = "t", ylab = "Haar Autocorrelation Wavelet")
## End(Not run)
#
#
# Now let us repeat the above for the Daubechies Least-Asymmetric wavelet
# with 10 vanishing moments.
# We shall create up to scale 6, a higher resolution version than last
# time.
#
p6 &lt;- PsiJ(-6, filter.number=10, family="DaubLeAsymm", OPLENGTH=5000)
p6
##[[1]]:
# [1]  3.537571e-07  5.699601e-16 -7.512135e-06 -7.705013e-15  7.662378e-05
# [6]  5.637163e-14 -5.010016e-04 -2.419432e-13  2.368371e-03  9.976593e-13
#[11] -8.684028e-03 -1.945435e-12  2.605208e-02  6.245832e-12 -6.773542e-02
#[16]  4.704777e-12  1.693386e-01  2.011086e-10 -6.209080e-01  1.000000e+00
#[21] -6.209080e-01  2.011086e-10  1.693386e-01  4.704777e-12 -6.773542e-02
#[26]  6.245832e-12  2.605208e-02 -1.945435e-12 -8.684028e-03  9.976593e-13
#[31]  2.368371e-03 -2.419432e-13 -5.010016e-04  5.637163e-14  7.662378e-05
#[36] -7.705013e-15 -7.512135e-06  5.699601e-16  3.537571e-07
#
#[[2]]
#	scale 2 etc. etc.
#
#[[3]]   scale 3 etc. etc.
#
#scales [[4]] and [[5]]...
#
#[[6]]
#...
#   remaining scale 6 elements...
#...
#[2371] -1.472225e-31 -1.176478e-31 -4.069848e-32 -2.932736e-41  6.855259e-33
#[2376]  5.540202e-33  2.286296e-33  1.164962e-42 -3.134088e-35  3.427783e-44
#[2381] -1.442993e-34 -2.480298e-44  5.325726e-35  9.346398e-45 -2.699644e-36
#[2386] -4.878634e-46 -4.489527e-36 -4.339365e-46  1.891864e-36  2.452556e-46
#[2391] -3.828924e-37 -4.268733e-47  4.161874e-38  3.157694e-48 -1.959885e-39
##
# Let's now plot the 6th component (6th scale, this is the finest
# resolution, all the other scales will be coarser representations)
#
#
# Note that the x-coordinates in the following are non-existant!
#
## Not run: ts.plot(p6[[6]], xlab = "t",
 ylab = "Daubechies N=10 least-asymmetric Autocorrelation Wavelet")
## End(Not run)
</code></pre>

<hr>
<h2 id='PsiJmat'>Compute discrete autocorrelation wavelets but return result in matrix form.</h2><span id='topic+PsiJmat'></span>

<h3>Description</h3>

<p>This function computes discrete autocorrelation wavelets using the <code><a href="#topic+PsiJ">PsiJ</a></code> function but it returns the results as a matrix rather than a list object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PsiJmat(J, filter.number = 10, family = "DaubLeAsymm", OPLENGTH=10^7)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PsiJmat_+3A_j">J</code></td>
<td>
<p>Discrete autocorrelation wavelets will be computed for scales -1 up to scale J. This number should be a negative integer.</p>
</td></tr>
<tr><td><code id="PsiJmat_+3A_filter.number">filter.number</code></td>
<td>
<p>The index of the wavelet used to compute the discrete autocorrelation wavelets.</p>
</td></tr>
<tr><td><code id="PsiJmat_+3A_family">family</code></td>
<td>
<p>The family of wavelet used to compute the discrete autocorrelation wavelets.</p>
</td></tr> 
<tr><td><code id="PsiJmat_+3A_oplength">OPLENGTH</code></td>
<td>
<p>This integer variable defines some workspace of length OPLENGTH. The code uses this workspace. If the workspace is not long enough then the routine will stop and probably tell you what OPLENGTH should be set to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrete autocorrelation wavelet values are computed using the <code><a href="#topic+PsiJ">PsiJ</a></code> function. This function merely organises them into a matrix form. 
</p>


<h3>Value</h3>

<p>A matrix containing -J rows and a number of columns less than OPLENGTH. Each row contains the values of the discrete autocorrelation wavelet for a different scale. Row one contains the scale -1 coefficients, row two contains the scale -2, and so on. 
</p>
<p>The number of columns is an odd number. The middle position of each row is the value of the discrete autocorrelation wavelet at zero &mdash; this is always 1. The discrete autocorrelation wavelet is symmetric about this point. 
</p>
<p><em>Important</em> Apart from the central element none of the other columns line up in this way. This could be improved upon. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (1998). Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum. <em>Technical Report</em>, Department of Mathematics University of Bristol/ Fachbereich Mathematik, Kaiserslautern. </p>


<h3>See Also</h3>

<p><code><a href="#topic+PsiJ">PsiJ</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# As a simple first examples we shall compute the matrix containing
# the discrete autocorrelation wavelets up to scale 3.
#
PsiJmat(-3, filter.number=1, family="DaubExPhase")
#Computing PsiJ
#Took  0.25  seconds
#       [,1]  [,2]   [,3] [,4]   [,5]  [,6]   [,7] [,8]   [,9] [,10]  [,11] 
#[1,]  0.000  0.00  0.000  0.0  0.000  0.00 -0.500    1 -0.500  0.00  0.000
#[2,]  0.000  0.00  0.000  0.0 -0.250 -0.50  0.250    1  0.250 -0.50 -0.250
#[3,] -0.125 -0.25 -0.375 -0.5 -0.125  0.25  0.625    1  0.625  0.25 -0.125
#     [,12]  [,13] [,14]  [,15] 
#[1,]   0.0  0.000  0.00  0.000
#[2,]   0.0  0.000  0.00  0.000
#[3,]  -0.5 -0.375 -0.25 -0.125
#
# Note that this contains 3 rows (since J=-3).
# Each row contains the same discrete autocorrelation wavelet at different
# scales and hence different resolutions.
# Compare to the output given by PsiJ for the
# equivalent wavelet and scales.
# Note also that apart from column 8 which contains 1 (the value of the
# ac wavelet at zero) none of the other columns line up. E.g. the value of
# this wavelet at 1/2 is -0.5: this appears in columns 9, 10 and 12
# we could have written it differently so that they should line up.
# I might do this in the future. 
#
#
# Let's compute the matrix containing the discrete autocorrelation
# wavelets up to scale 6 using Daubechies N=10 least-asymmetric
# wavelets.
#
P6mat &lt;- PsiJmat(-6, filter.number=10, family="DaubLeAsymm")
#
# What is the dimension of this matrix?
#
dim(P6mat)
#[1]    6 2395
#
# Hmmm. Pretty large, so we shan't print it out.
#
# However, these are the ac wavelets... Therefore if we compute their
# inner product we should get the same as if we used the ipndacw
# function directly.
#
P6mat 
#             [,1]         [,2]         [,3]         [,4]         [,5] 
#[1,] 1.839101e+00 3.215934e-01 4.058155e-04 8.460063e-06 4.522125e-08
#[2,] 3.215934e-01 3.035353e+00 6.425188e-01 7.947454e-04 1.683209e-05
#[3,] 4.058155e-04 6.425188e-01 6.070419e+00 1.285038e+00 1.589486e-03
#[4,] 8.460063e-06 7.947454e-04 1.285038e+00 1.214084e+01 2.570075e+00
#[5,] 4.522125e-08 1.683209e-05 1.589486e-03 2.570075e+00 2.428168e+01
#[6,] 5.161675e-10 8.941666e-08 3.366416e-05 3.178972e-03 5.140150e+00
#             [,6] 
#[1,] 5.161675e-10
#[2,] 8.941666e-08
#[3,] 3.366416e-05
#[4,] 3.178972e-03
#[5,] 5.140150e+00
#[6,] 4.856335e+01
#
# Let's check it against the ipndacw call
#
ipndacw(-6, filter.number=10, family="DaubLeAsymm")
#             -1           -2           -3           -4           -5 
#-1 1.839101e+00 3.215934e-01 4.058155e-04 8.460063e-06 4.522125e-08
#-2 3.215934e-01 3.035353e+00 6.425188e-01 7.947454e-04 1.683209e-05
#-3 4.058155e-04 6.425188e-01 6.070419e+00 1.285038e+00 1.589486e-03
#-4 8.460063e-06 7.947454e-04 1.285038e+00 1.214084e+01 2.570075e+00
#-5 4.522125e-08 1.683209e-05 1.589486e-03 2.570075e+00 2.428168e+01
#-6 5.161675e-10 8.941666e-08 3.366416e-05 3.178972e-03 5.140150e+00
#             -6 
#-1 5.161675e-10
#-2 8.941666e-08
#-3 3.366416e-05
#-4 3.178972e-03
#-5 5.140150e+00
#-6 4.856335e+01
#
# Yep, they're the same.
#
</code></pre>

<hr>
<h2 id='Psiname'>Return a PsiJ list object style name.</h2><span id='topic+Psiname'></span>

<h3>Description</h3>

<p>This function returns a character string according to a particular format for naming <code><a href="#topic+PsiJ">PsiJ</a></code> objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Psiname(J, filter.number, family)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Psiname_+3A_j">J</code></td>
<td>
<p>A negative integer representing the order of the <code><a href="#topic+PsiJ">PsiJ</a></code> object.</p>
</td></tr>
<tr><td><code id="Psiname_+3A_filter.number">filter.number</code></td>
<td>
<p>The index number of the wavelet used to build the <code><a href="#topic+PsiJ">PsiJ</a></code> object.</p>
</td></tr>
<tr><td><code id="Psiname_+3A_family">family</code></td>
<td>
<p>The wavelet family used to build the <code><a href="#topic+PsiJ">PsiJ</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some of the objects computed by <code><a href="#topic+PsiJ">PsiJ</a></code> take a long time to compute. Hence it is a good idea to store them and reuse them. This function generates a name according to a particular naming scheme that permits a search algorithm to easily find the matrices. 
</p>
<p>Each object has three defining characteristics: its <em>order</em>, <em>filter.number</em> and <em>family</em>. Each of these three characteristics are concatenated together to form a name. 
</p>
<p>This function performs exactly the same role as <code><a href="#topic+rmname">rmname</a></code> except for objects produced by <code><a href="#topic+PsiJ">PsiJ</a></code>. 
</p>


<h3>Value</h3>

<p>A character string containing the name of an object according to a particular naming scheme. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (1998). Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum. <em>Technical Report</em>, Department of Mathematics University of Bristol/ Fachbereich Mathematik, Kaiserslautern</p>


<h3>See Also</h3>

<p><code><a href="#topic+PsiJ">PsiJ</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# What's the name of the order 4 Haar PsiJ object?
#
Psiname(-4, filter.number=1, family="DaubExPhase")
#[1] "Psi.4.1.DaubExPhase"
#
# What's the name of the order 12 Daubechies least-asymmetric wavelet PsiJ
# with 7 vanishing moments?
#
Psiname(-12, filter.number=7, family="DaubLeAsymm")             
#[1] "Psi.12.7.DaubLeAsymm"
</code></pre>

<hr>
<h2 id='putC'>Put smoothed data (father wavelet) coefficients into wavelet structure</h2><span id='topic+putC'></span>

<h3>Description</h3>

<p>This generic function inserts smooths into various types of wavelet objects. 
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist. For objects of class: 
</p>

<dl>
<dt>wd</dt><dd><p>use the <code><a href="#topic+putC.wd">putC.wd</a></code> method.</p>
</dd>
<dt>wp</dt><dd><p>use the <code><a href="#topic+putC.wp">putC.wp</a></code> method.</p>
</dd> 
<dt>wst</dt><dd><p>use the <code><a href="#topic+putC.wst">putC.wst</a></code> method.</p>
</dd>
</dl>

<p>See individual method help pages for operation and examples. 
</p>
<p>See <code><a href="#topic+accessC">accessC</a></code> if you wish to <em>extract</em> father wavelet coefficients. See <code><a href="#topic+putD">putD</a></code> if you wish to insert <em>mother</em> wavelet coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>putC(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putC_+3A_...">...</code></td>
<td>
<p>See individual help pages for details.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A wavelet object of the same class as x with the new father wavelet coefficients inserted. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+putC.wd">putC.wd</a></code>, <code><a href="#topic+putC.wp">putC.wp</a></code>, <code><a href="#topic+putC.wst">putC.wst</a></code>, <code><a href="#topic+accessC">accessC</a></code>, <code><a href="#topic+putD">putD</a></code>. 
</p>

<hr>
<h2 id='putC.mwd'>Put smoothed data into wavelet structure </h2><span id='topic+putC.mwd'></span>

<h3>Description</h3>

<p>The smoothed and original data from a multiple wavelet decomposition structure, <code><a href="#topic+mwd.object">mwd.object</a></code>, (e.g. returned from <code><a href="#topic+mwd">mwd</a></code>) are packed into a single matrix in that structure. This function copies the <code><a href="#topic+mwd.object">mwd.object</a></code>, replaces some smoothed data in the copy, and then returns the copy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mwd'
putC(mwd, level, M, boundary = FALSE, index = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putC.mwd_+3A_mwd">mwd</code></td>
<td>
<p>Multiple wavelet decomposition structure whose coefficients you wish to replace.</p>
</td></tr>
<tr><td><code id="putC.mwd_+3A_level">level</code></td>
<td>
<p>The level that you wish to replace.</p>
</td></tr>
<tr><td><code id="putC.mwd_+3A_m">M</code></td>
<td>
<p>Matrix of replacement coefficients.</p>
</td></tr>
<tr><td><code id="putC.mwd_+3A_boundary">boundary</code></td>
<td>
<p>If <code>boundary</code> is <code>FALSE</code> then only the &quot;real&quot; data is replaced (and it is easy to predict the required length of <code>M</code>). If boundary is TRUE then you can replace the boundary values at a particular level as well (but it is hard to predict the required length of <code>M</code>, and the information has to be obtained from the <code>mfirst.last</code> database component of <code>mwd</code>).</p>
</td></tr>
<tr><td><code id="putC.mwd_+3A_index">index</code></td>
<td>
<p>If index is <code>TRUE</code> then the index numbers into the <code>mwd$C</code> array where the matrix <code>M</code> would be stored is returned. Otherwise, (default) the modified <code><a href="#topic+mwd.object">mwd.object</a></code> is returned.</p>
</td></tr>
<tr><td><code id="putC.mwd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+mwd">mwd</a></code> function produces a wavelet decomposition structure. 
</p>
<p>The need for this function is a consequence of the pyramidal structure of Mallat's algorithm and the memory efficiency gain achieved by storing the pyramid as a linear matrix of coefficients. PutC obtains information about where the smoothed data appears from the fl.dbase component of mwd, in particular the array <code>fl.dbase$first.last.c</code> which gives a complete specification of index numbers and offsets for <code>mwd$C</code>. 
</p>
<p>Note also that this function only <em>puts</em> information into <code><a href="#topic+mwd">mwd</a></code> class objects. To <em>extract</em> coefficients from <code><a href="#topic+mwd">mwd</a></code> structures you have to use the <code><a href="#topic+accessC.mwd">accessC.mwd</a></code> function. 
</p>
<p>See Downie and Silverman, 1998. 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+mwd.object">mwd.object</a></code> if <code>index</code> is <code>FALSE</code>, otherwise the index numbers indicating where the <code>M</code> matrix would have been inserted into the <code>mwd$C</code> object are returned. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie 1995-6). </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.mwd">accessC.mwd</a></code>, <code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mfilter.select">mfilter.select</a></code>, <code><a href="#topic+mwd">mwd</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+mwr">mwr</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>, <code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an mwd object
#
tmp &lt;- mwd(rnorm(32))
#
# Now let's examine the finest resolution smooth...
#
accessC(tmp, level=3)
#           [,1]       [,2]       [,3]       [,4]        [,5]      [,6] 
#[1,] -0.4669103 -1.3150580 -0.7094966 -0.1979214  0.32079986 0.5052254
#[2,] -0.7645379 -0.8680941  0.1004062  0.6633268 -0.05860848 0.5757286
#          [,7]       [,8] 
#[1,] 0.5187380  0.6533843
#[2,] 0.2864293 -0.4433788
#
# A matrix. There are two rows one for each father wavelet in this 
# two-ple multiple wavelet transform and at level 3 there are 2^3 columns.
#
# Let's set the coefficients of the first father wavelet all equal to zero
# for this examples
#
newcmat &lt;- accessC(tmp, level=3)
newcmat[1,] &lt;- 0
#
# Ok, let's insert it back at level 3
#
tmp2 &lt;- putC(tmp, level=3, M=newcmat)
#
# And check it
#
accessC(tmp2, level=3)   
#           [,1]       [,2]      [,3]      [,4]        [,5]      [,6]      [,7] 
#[1,]  0.0000000  0.0000000 0.0000000 0.0000000  0.00000000 0.0000000 0.0000000
#[2,] -0.7645379 -0.8680941 0.1004062 0.6633268 -0.05860848 0.5757286 0.2864293
#           [,8] 
#[1,]  0.0000000
#[2,] -0.4433788
#
# Yep, all the first father wavelet coefficients at level 3 are now zero.
</code></pre>

<hr>
<h2 id='putC.wd'>Puts a whole resolution level of father wavelet coeffients into wd wavelet object.</h2><span id='topic+putC.wd'></span>

<h3>Description</h3>

<p>Makes a copy of the <code><a href="#topic+wd">wd</a></code> object, replaces some father wavelet coefficients data in the copy, and then returns the copy. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
putC(wd, level, v, boundary=FALSE, index=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putC.wd_+3A_wd">wd</code></td>
<td>
<p>Wavelet decomposition object into which you wish to insert the father wavelet coefficients.</p>
</td></tr>
<tr><td><code id="putC.wd_+3A_level">level</code></td>
<td>
<p>the resolution level at which you wish to replace the father wavelet coefficients.</p>
</td></tr> 
<tr><td><code id="putC.wd_+3A_v">v</code></td>
<td>
<p>the replacement data, this should be of the correct length.</p>
</td></tr> 
<tr><td><code id="putC.wd_+3A_boundary">boundary</code></td>
<td>
<p>If <code>boundary</code> is <code>FALSE</code> then only &quot;real&quot; data is replaced. If boundary is <code>TRUE</code> then the boundary (bookeeping) elements are replaced as well. Information about the lengths of the vectors can be found in the <code><a href="#topic+first.last">first.last</a></code> database function and Nason and Silverman, 1994.</p>
</td></tr>
<tr><td><code id="putC.wd_+3A_index">index</code></td>
<td>
<p>If index is <code>TRUE</code> then the index numbers into the 1D array where the coefficient insertion would take place are returned. If index is <code>FALSE</code> (default) then the modified <code>wavelet decomposition</code> object is returned.</p>
</td></tr>
<tr><td><code id="putC.wd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+accessC">accessC</a></code> obtains the father wavelet coefficients for a particular level. The function <code>putC.wd</code> replaces father wavelet coefficients at a particular resolution level and returns a modified wd object reflecting the change.
</p>
<p>The need for this function is a consequence of the pyramidal structure of Mallat's algorithm and the memory efficiency gain achieved by storing the pyramid as a linear vector. <code>PutC.wd</code> obtains information about where the smoothed data appears from the <code>fl.dbase</code> component of an <code><a href="#topic+wd.object">wd.object</a></code>, in particular the array
</p>
<p><code>fl.dbase$first.last.c</code>
</p>
<p>which gives a complete specification of index numbers and offsets for 
</p>
<p><code>wd.object$C</code>.
</p>
<p>Note that this function is method for the generic function <code><a href="#topic+putC">putC</a></code>. When the <code><a href="#topic+wd.object">wd.object</a></code> is definitely a wd class object then you only need use the generic version of this function. 
</p>
<p>Note also that this function only puts information into <code><a href="#topic+wd">wd</a></code> class objects. To extract coefficients from a <code><a href="#topic+wd">wd</a></code> object you have to use the <code><a href="#topic+accessC">accessC</a></code> function (or more precisely, the <code><a href="#topic+accessC.wd">accessC.wd</a></code> method).
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+wd">wd</a></code> class object containing the modified father wavelet coefficients. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+putC">putC</a></code>, <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+accessC">accessC</a></code>,<code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+first.last">first.last</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an EMPTY wd object:
#
zero &lt;- rep(0, 16)
zerowd &lt;- wd(zero)
#
# Put some random father wavelet coefficients into the object at
# resolution level 2. For the decimated wavelet transform there
# are always 2^i coefficients at resolution level i. So we have to
# insert 4 coefficients
#
mod.zerowd &lt;- putC( zerowd, level=2, v=rnorm(4))
#
# If you use accessC on mod.zerowd you would see that there were only
# coefficients at resolution level 2 where you just put the coefficients.
#
# Now, for a time-ordered non-decimated wavelet transform object the
# procedure is exactly the same EXCEPT that there are going to be
# 16 coefficients at each resolution level. I.e.
#
# Create empty TIME-ORDERED NON-DECIMATED wavelet transform object
#
zerowdS &lt;- wd(zero, type="station")
#
# Now insert 16 random coefficients at resolution level 2
##
mod.zerowdS &lt;- putC(zerowdS, level=2, v=rnorm(16))
#
# Once more if you use accessC on mod.zerowdS you will see that there are
# only coefficients at resolution level 2.
</code></pre>

<hr>
<h2 id='putC.wp'>Warning function when trying to insert father wavelet coefficients into wavelet packet object (wp).</h2><span id='topic+putC.wp'></span>

<h3>Description</h3>

<p>There are no real smooths to insert in a <code><a href="#topic+wp">wp</a></code> wavelet packet object. This function returns an error message. To insert coefficients into a wavelet packet object you should use the <code><a href="#topic+putpacket">putpacket</a></code> collection of functions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
putC(wp, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putC.wp_+3A_wp">wp</code></td>
<td>
<p>Wavelet packet object.</p>
</td></tr> 
<tr><td><code id="putC.wp_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An error message! 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+putpacket">putpacket</a></code>, <code><a href="#topic+putpacket.wp">putpacket.wp</a></code>. 
</p>

<hr>
<h2 id='putC.wst'>Puts a whole resolution level of father wavelet coeffients into wst wavelet object.</h2><span id='topic+putC.wst'></span>

<h3>Description</h3>

<p>Makes a copy of the <code><a href="#topic+wst">wst</a></code> object, replaces a whole resolution level of father wavelet coefficients data in the copy, and then returns the copy. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
putC(wst, level, value, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putC.wst_+3A_wst">wst</code></td>
<td>
<p>Packet-ordered non-decimated wavelet object into which you wish to insert the father wavelet coefficients.</p>
</td></tr>
<tr><td><code id="putC.wst_+3A_level">level</code></td>
<td>
<p>the resolution level at which you wish to replace the father wavelet coefficients.</p>
</td></tr>
<tr><td><code id="putC.wst_+3A_value">value</code></td>
<td>
<p>the replacement data, this should be of the correct length.</p>
</td></tr>
<tr><td><code id="putC.wst_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+accessC.wst">accessC.wst</a></code> obtains the father wavelet coefficients for a particular level. The function <code>putC.wst</code> replaces father wavelet coefficients at a particular resolution level and returns a modified wst object reflecting the change. 
</p>
<p>For the non-decimated wavelet transforms the number of coefficients at each resolution level is the same and equal to <code>2^nlevelsWT</code> where <code>nlevels</code> is the number of levels in the <code><a href="#topic+wst.object">wst.object</a></code>. The number of coefficients at each resolution level is also, of course, the number of data points used to initially form the <code><a href="#topic+wst">wst</a></code> object in the first place. 
</p>
<p>Use the <code><a href="#topic+accessC.wst">accessC.wst</a></code> to extract whole resolution levels of father wavelet coefficients. Use <code><a href="#topic+accessD.wst">accessD.wst</a></code> and <code><a href="#topic+putD.wst">putD.wst</a></code> to extract/insert whole resolution levels of mother wavelet coefficients. Use the <code><a href="#topic+getpacket.wst">getpacket.wst</a></code> and <code><a href="#topic+putpacket.wst">putpacket.wst</a></code> functions to extract/insert packets of coefficients into a packet-ordered non-decimated wavelet object. 
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+wst">wst</a></code> class object containing the modified father wavelet coefficients
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+putC">putC</a></code>, <code><a href="#topic+accessD.wst">accessD.wst</a></code>, <code><a href="#topic+putD.wst">putD.wst</a></code>, <code><a href="#topic+getpacket.wst">getpacket.wst</a></code>, <code><a href="#topic+putpacket.wst">putpacket.wst</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an EMPTY wst object:
#
zero &lt;- rep(0, 16)
zerowst &lt;- wst(zero)
#
# Put some random father wavelet coefficients into the object at
# resolution level 2. For the non-decimated wavelet transform there
# are always 16 coefficients at every resolution level. 
#
mod.zerowst &lt;- putC( zerowst, level=2, v=rnorm(16))
#
# If you use accessC  on mod.zerowd you would see that there were only
# coefficients at resolution level 2 where you just put the coefficients.
</code></pre>

<hr>
<h2 id='putD'>Put mother wavelet coefficients into wavelet structure</h2><span id='topic+putD'></span>

<h3>Description</h3>

<p>This generic function inserts smooths into various types of wavelet objects. 
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist. For objects of class: 
</p>

<dl>
<dt>wd</dt><dd><p>use the <code><a href="#topic+putD.wd">putD.wd</a></code> method.</p>
</dd>
<dt>wp</dt><dd><p>use the <code><a href="#topic+putD.wp">putD.wp</a></code> method. </p>
</dd>
<dt>wst</dt><dd><p>use the <code><a href="#topic+putD.wst">putD.wst</a></code> method.</p>
</dd>
</dl>

<p>See individual method help pages for operation and examples. 
</p>
<p>See <code><a href="#topic+accessD">accessD</a></code> if you wish to <em>extract</em> mother wavelet coefficients. See <code><a href="#topic+putC">putC</a></code> if you wish to insert <em>father</em> wavelet coefficients. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>putD(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putD_+3A_...">...</code></td>
<td>
<p>See individual help pages for details.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A wavelet object of the same class as <code>x</code> with the new mother wavelet coefficients inserted. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+putD.wd">putD.wd</a></code>, <code><a href="#topic+putD.wp">putD.wp</a></code>, <code><a href="#topic+putD.wst">putD.wst</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+putC">putC</a></code>. 
</p>

<hr>
<h2 id='putD.mwd'>Put wavelet coefficients into multiple wavelet structure </h2><span id='topic+putD.mwd'></span>

<h3>Description</h3>

<p>The wavelet coefficients from a multiple wavelet decomposition structure, <code><a href="#topic+mwd.object">mwd.object</a></code>, (e.g. returned from <code><a href="#topic+mwd">mwd</a></code>) are packed into a single matrix in that structure. This function copies the <code><a href="#topic+mwd.object">mwd.object</a></code>, replaces some wavelet coefficients in the copy, and then returns the copy. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mwd'
putD(mwd, level, M, boundary = FALSE, index = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putD.mwd_+3A_mwd">mwd</code></td>
<td>
<p>Multiple wavelet decomposition structure whose coefficients you wish to replace.</p>
</td></tr>
<tr><td><code id="putD.mwd_+3A_level">level</code></td>
<td>
<p>The level that you wish to replace.</p>
</td></tr>
<tr><td><code id="putD.mwd_+3A_m">M</code></td>
<td>
<p>Matrix of replacement coefficients.</p>
</td></tr>
<tr><td><code id="putD.mwd_+3A_boundary">boundary</code></td>
<td>
<p>If <code>boundary</code> is <code>FALSE</code> then only the &quot;real&quot; data is replaced (and it is easy to predict the required length of <code>M</code>). If <code>boundary</code> is <code>TRUE</code> then you can replace the boundary values at a particular level as well (but it is hard to predict the required length of<code>M</code>, and the information has to be obtained from the <code>mfirst.last</code> database component of <code>mwd</code>).</p>
</td></tr>
<tr><td><code id="putD.mwd_+3A_index">index</code></td>
<td>
<p>If index is <code>TRUE</code> then the index numbers into the <code>mwd$D</code> array where the matrix <code>M</code> would be stored is returned. Otherwise, (default) the modified <code><a href="#topic+mwd.object">mwd.object</a></code> is returned. </p>
</td></tr>
<tr><td><code id="putD.mwd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+mwd">mwd</a></code> function produces a wavelet decomposition structure. 
</p>
<p>The need for this function is a consequence of the pyramidal structure of Mallat's algorithm and the memory efficiency gain achieved by storing the pyramid as a linear matrix of coefficients. PutD obtains information about where the wavelet coefficients appear from the fl.dbase component of mwd, in particular the array <code>fl.dbase$first.last.d</code> which gives a complete specification of index numbers and offsets for <code>mwd$D</code>. 
</p>
<p>Note also that this function only puts information into mwd class objects. To extract coefficients from mwd structures you have to use the accessD.mwd function. 
</p>
<p>See Downie and Silverman, 1998. 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+mwd.object">mwd.object</a></code> if index is <code>FALSE</code>, otherwise the index numbers indicating where the <code>M</code> matrix would have been inserted into the <code>mwd$D</code> object are returned. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie 1995-6). </p>


<h3>Author(s)</h3>

<p>Tim Downie</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.mwd">accessC.mwd</a></code>, <code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mfilter.select">mfilter.select</a></code>, <code><a href="#topic+mwd">mwd</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+mwr">mwr</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>, <code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an mwd object
#
tmp &lt;- mwd(rnorm(32))
#
# Now let's examine the finest resolution detail...
#
accessD(tmp, level=3)
#          [,1]       [,2]       [,3]      [,4]       [,5]        [,6] 
#[1,] 0.8465672  0.4983564  0.3408087 0.1340325  0.5917774 -0.06804291
#[2,] 0.6699962 -0.2535760 -1.0344445 0.2068644 -0.4912086  1.16039885
#           [,7]       [,8] 
#[1,] -0.6226445  0.2617596
#[2,] -0.4956576 -0.5555795
#
#
# A matrix. There are two rows one for each mother wavelet in this 
# two-ple multiple wavelet transform and at level 3 there are 2^3 columns.
#
# Let's set the coefficients of the first mother wavelet all equal to zero
# for this examples
#
newdmat &lt;- accessD(tmp, level=3)
newdmat[1,] &lt;- 0
#
# Ok, let's insert it back at level 3
#
tmp2 &lt;- putD(tmp, level=3, M=newdmat)
#
# And check it
#
accessD(tmp2, level=3)   
#          [,1]      [,2]      [,3]      [,4]       [,5]     [,6]       [,7] 
#[1,] 0.0000000  0.000000  0.000000 0.0000000  0.0000000 0.000000  0.0000000
#[2,] 0.6699962 -0.253576 -1.034445 0.2068644 -0.4912086 1.160399 -0.4956576
#           [,8] 
#[1,]  0.0000000
#[2,] -0.5555795
#
#
# Yep, all the first mother wavelet coefficients at level 3 are now zero.
</code></pre>

<hr>
<h2 id='putD.wd'>Puts a whole resolution level of mother wavelet coeffients into wd wavelet object.</h2><span id='topic+putD.wd'></span>

<h3>Description</h3>

<p>Makes a copy of the <code><a href="#topic+wd">wd</a></code> object, replaces some mother wavelet coefficients data in the copy, and then returns the copy. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
putD(wd, level, v, boundary=FALSE, index=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putD.wd_+3A_wd">wd</code></td>
<td>
<p>Wavelet decomposition object into which you wish to insert the mother wavelet coefficients.</p>
</td></tr>
<tr><td><code id="putD.wd_+3A_level">level</code></td>
<td>
<p>the resolution level at which you wish to replace the mother wavelet coefficients.</p>
</td></tr> 
<tr><td><code id="putD.wd_+3A_v">v</code></td>
<td>
<p>the replacement data, this should be of the correct length.</p>
</td></tr> 
<tr><td><code id="putD.wd_+3A_boundary">boundary</code></td>
<td>
<p>If <code>boundary</code> is <code>FALSE</code> then only &quot;real&quot; data is replaced. If boundary is <code>TRUE</code> then the boundary (bookeeping) elements are replaced as well. Information about the lengths of the vectors can be found in the <code><a href="#topic+first.last">first.last</a></code> database function and Nason and Silverman, 1994.</p>
</td></tr>
<tr><td><code id="putD.wd_+3A_index">index</code></td>
<td>
<p>If index is <code>TRUE</code> then the index numbers into the 1D array where the coefficient insertion would take place are returned. If index is <code>FALSE</code> (default) then the modified <code>wavelet decomposition</code> object is returned.</p>
</td></tr>
<tr><td><code id="putD.wd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+accessD">accessD</a></code> obtains the mother wavelet coefficients for a particular level. The function <code>putD.wd</code> replaces father wavelet coefficients at a particular resolution level and returns a modified wd object reflecting the change.
</p>
<p>The need for this function is a consequence of the pyramidal structure of Mallat's algorithm and the memory efficiency gain achieved by storing the pyramid as a linear vector. <code>PutD.wd</code> obtains information about where the smoothed data appears from the <code>fl.dbase</code> component of an <code><a href="#topic+wd.object">wd.object</a></code>, in particular the array 
</p>
<p><code>fl.dbase$first.last.d</code>
</p>
<p>which gives a complete specification of index numbers and offsets for 
</p>
<p><code>wd.object$D</code>.
</p>
<p>Note that this function is method for the generic function <code><a href="#topic+putD">putD</a></code>. When the <code><a href="#topic+wd.object">wd.object</a></code> is definitely a wd class object then you only need use the generic version of this function. 
</p>
<p>Note also that this function only puts information into <code><a href="#topic+wd">wd</a></code> class objects. To extract coefficients from a <code><a href="#topic+wd">wd</a></code> object you have to use the <code><a href="#topic+accessD">accessD</a></code> function (or more precisely, the <code><a href="#topic+accessD.wd">accessD.wd</a></code> method).
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+wd">wd</a></code> class object containing the modified mother wavelet coefficients. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+accessD">accessD</a></code>,<code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+first.last">first.last</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an EMPTY wd object:
#
zero &lt;- rep(0, 16)
zerowd &lt;- wd(zero)
#
# Put some random father wavelet coefficients into the object at
# resolution level 2. For the decimated wavelet transform there
# are always 2^i coefficients at resolution level i. So we have to
# insert 4 coefficients
#
mod.zerowd &lt;- putD( zerowd, level=2, v=rnorm(4))
#
# If you plot mod.zerowd you will see that there are only 
# coefficients at resolution level 2 where you just put the coefficients.
#
# Now, for a time-ordered non-decimated wavelet transform object the
# procedure is exactly the same EXCEPT that there are going to be
# 16 coefficients at each resolution level. I.e.
#
# Create empty TIME-ORDERED NON-DECIMATED wavelet transform object
#
zerowdS &lt;- wd(zero, type="station")
#
# Now insert 16 random coefficients at resolution level 2
#
mod.zerowdS &lt;- putD(zerowdS, level=2, v=rnorm(16))
#
# Once more if you plot mod.zerowdS then there will only be
# coefficients at resolution level 2.
</code></pre>

<hr>
<h2 id='putD.wd3D'>Put wavelet coefficient array into a 3D wavelet object</h2><span id='topic+putD.wd3D'></span>

<h3>Description</h3>

<p>This function put an array of wavelet coefficients, corresponding to a particular resolution level into a <code><a href="#topic+wd">wd</a></code> wavelet decomposition object. 
</p>
<p>The pyramid of coefficients in a wavelet decomposition (returned from the <code><a href="#topic+wd3D">wd3D</a></code> function, say) are packed into a single array in <code>WaveThresh3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd3D'
putD(x, v, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putD.wd3D_+3A_x">x</code></td>
<td>
<p>3D Wavelet decomposition object into which you wish to insert the wavelet coefficients.</p>
</td></tr>
<tr><td><code id="putD.wd3D_+3A_v">v</code></td>
<td>
<p>This argument is a list with the following components: 
</p>

<dl>
<dt>a</dt><dd><p>A 3-dimensional array with each dimension of length equal to two to the power of lev which is the level at which you wish to insert the coefficients into x.</p>
</dd>
<dt>lev</dt><dd><p>The level at which you wish to insert the coefficients into <code>x</code>.</p>
</dd> 
<dt>block</dt><dd><p>A character string indicating which coefficient block you wish to insert the coefficients into. This can be one of GGG, GGH, GHG, GHH, HGG, HGH, HHG. Additionally this can be HHH when the lev argument above is zero.</p>
</dd></dl>
</td></tr>
<tr><td><code id="putD.wd3D_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The need for this function is a consequence of the pyramidal structure of Mallat's algorithm and the memory efficiency gain achieved by storing the pyramid as an array. 
</p>
<p>Note that this function is a method for the generic function <code><a href="#topic+putD">putD</a></code>. 
</p>


<h3>Value</h3>

<p>A new <code><a href="#topic+wd3D.object">wd3D.object</a></code> is returned with the coefficients at level <code>lev</code> in block given by block are replaced by the contents of <code>a</code>, if <code>a</code> is of the correct dimensions! 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+accessD.wd3D">accessD.wd3D</a></code>, <code><a href="#topic+print.wd3D">print.wd3D</a></code>, <code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+putDwd3Dcheck">putDwd3Dcheck</a></code>, <code><a href="#topic+summary.wd3D">summary.wd3D</a></code>, <code><a href="#topic+threshold.wd3D">threshold.wd3D</a></code>, <code><a href="#topic+wd3D">wd3D</a></code>, <code><a href="#topic+wd3D.object">wd3D.object</a></code>, <code><a href="#topic+wr3D">wr3D</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
a &lt;- array(rnorm(8*8*8), dim=c(8,8,8))
#
# Perform the 3D DWT
#
awd3D &lt;- wd3D(a)
#
# Replace the second level coefficients by uniform random variables
# in block GGG (for some reason)
#
#
newsubarray &lt;- list(a = array(runif(4*4*4), dim=c(4,4,4)), lev=2, block="GGG")
awd3D &lt;- putD(awd3D,  v=newsubarray)
</code></pre>

<hr>
<h2 id='putD.wp'>Puts a whole resolution level of wavelet packet coeffients into wp wavelet object.</h2><span id='topic+putD.wp'></span>

<h3>Description</h3>

<p>Makes a copy of the <code><a href="#topic+wp">wp</a></code> object, replaces a whole resolution level of wavelet packet coefficients data in the copy, and then returns the copy. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
putD(wp, level, value, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putD.wp_+3A_wp">wp</code></td>
<td>
<p>Wavelet packet object into which you wish to insert the wavelet packet coefficients.</p>
</td></tr>
<tr><td><code id="putD.wp_+3A_level">level</code></td>
<td>
<p>the resolution level at which you wish to replace the wavelet packet coefficients.</p>
</td></tr> 
<tr><td><code id="putD.wp_+3A_value">value</code></td>
<td>
<p>the replacement data, this should be of the correct length.</p>
</td></tr> 
<tr><td><code id="putD.wp_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+accessD.wp">accessD.wp</a></code> obtains the wavelet packet coefficients for a particular level.
</p>
<p>For wavelet packet transforms the number of coefficients at each resolution level is the same and equal to <code>2^nlevelsWT</code> where <code>nlevels</code> is the number of levels in the <code><a href="#topic+wp.object">wp.object</a></code>. The number of coefficients at each resolution level is also, of course, the number of data points used to initially form the <code><a href="#topic+wp">wp</a></code> object in the first place. 
</p>
<p>Use the <code><a href="#topic+accessD.wp">accessD.wp</a></code> to extract whole resolution levels of wavelet packet coefficients. 
</p>
<p>We don't recommend that you use this function unless you really know what you are doing. Usually it is more convenient to manipulate individual <em>packets</em> of coefficients using <code><a href="#topic+getpacket">getpacket</a></code>/<code><a href="#topic+putpacket">putpacket</a></code> functions. If you must use this function to insert whole resolution levels of coefficients you must ensure that the data vector you supply is valid: i.e. contains packet coefficients in the right order. 
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+wp">wp</a></code> class object containing the modified wavelet packet coefficients. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wp.object">wp.object</a></code>, <code><a href="#topic+wp">wp</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+accessD.wp">accessD.wp</a></code>, <code><a href="#topic+getpacket.wp">getpacket.wp</a></code>, <code><a href="#topic+putpacket.wp">putpacket.wp</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an EMPTY wp object:
#
zero &lt;- rep(0, 16)
zerowp &lt;- wp(zero)
#
# Put some random mother wavelet coefficients into the object at
# resolution level 2. For the wavelet packet transform there
# are always 16 coefficients at every resolution level. 
#
mod.zerowp &lt;- putD( zerowp, level=2, v=rnorm(16))
#
# If you plot mod.zerowp you will see that there are only 
# coefficients at resolution level 2 where you just put the coefficients.
</code></pre>

<hr>
<h2 id='putD.wst'>Puts a whole resolution level of mother wavelet coeffients into wst wavelet object.</h2><span id='topic+putD.wst'></span>

<h3>Description</h3>

<p>Makes a copy of the <code><a href="#topic+wst">wst</a></code> object, replaces a whole resolution level of mother wavelet coefficients data in the copy, and then returns the copy. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
putD(wst, level, value, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putD.wst_+3A_wst">wst</code></td>
<td>
<p>Packet-ordered non-decimated wavelet object into which you wish to insert the mother wavelet coefficients.</p>
</td></tr>
<tr><td><code id="putD.wst_+3A_level">level</code></td>
<td>
<p>the resolution level at which you wish to replace the mother wavelet coefficients.</p>
</td></tr> 
<tr><td><code id="putD.wst_+3A_value">value</code></td>
<td>
<p>the replacement data, this should be of the correct length</p>
</td></tr>
<tr><td><code id="putD.wst_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr></table>


<h3>Details</h3>

<p>The function <code><a href="#topic+accessD.wst">accessD.wst</a></code> obtains the mother wavelet coefficients for a particular level. The function <code>putD.wst</code> replaces mother wavelet coefficients at a particular resolution level and returns a modified wst object reflecting the change. 
</p>
<p>For the non-decimated wavelet transforms the number of coefficients at each resolution level is the same and equal to <code>2^nlevelsWT</code> where <code>nlevels</code> is the number of levels in the <code><a href="#topic+wst.object">wst.object</a></code>. The number of coefficients at each resolution level is also, of course, the number of data points used to initially form the <code>wst</code> object in the first place. 
</p>
<p>Use the <code><a href="#topic+accessD.wst">accessD.wst</a></code> to extract whole resolution levels of mother wavelet coefficients. Use <code><a href="#topic+accessC.wst">accessC.wst</a></code> and <code><a href="#topic+putC.wst">putC.wst</a></code> to extract/insert whole resolution levels of father wavelet coefficients. Use the <code><a href="#topic+getpacket.wst">getpacket.wst</a></code> and <code><a href="#topic+putpacket.wst">putpacket.wst</a></code> functions to extract/insert packets of coefficients into a packet-ordered non-decimated wavelet object. 
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+wst">wst</a></code> class object containing the modified mother wavelet coefficients.
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+accessD.wst">accessD.wst</a></code>, <code><a href="#topic+putC.wst">putC.wst</a></code>, <code><a href="#topic+getpacket.wst">getpacket.wst</a></code>, <code><a href="#topic+putpacket.wst">putpacket.wst</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an EMPTY wst object:
#
zero &lt;- rep(0, 16)
zerowst &lt;- wst(zero)
#
# Put some random mother wavelet coefficients into the object at
# resolution level 2. For the non-decimated wavelet transform there
# are always 16 coefficients at every resolution level. 
#
mod.zerowst &lt;- putD( zerowst, level=2, v=rnorm(16))
#
# If you plot mod.zerowst you will see that there are only 
# coefficients at resolution level 2 where you just put the coefficients.
</code></pre>

<hr>
<h2 id='putDwd3Dcheck'>Check argument list for putD.wd3D</h2><span id='topic+putDwd3Dcheck'></span>

<h3>Description</h3>

<p>This function checks the argument list for <code><a href="#topic+putD.wd3D">putD.wd3D</a></code> and is not meant to be directly called by any user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>putDwd3Dcheck(lti, dima, block, nlx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putDwd3Dcheck_+3A_lti">lti</code></td>
<td>
<p>At which level of the <code><a href="#topic+wd3D.object">wd3D.object</a></code> you wish to insert a block of coefficients.</p>
</td></tr>
<tr><td><code id="putDwd3Dcheck_+3A_dima">dima</code></td>
<td>
<p>A vector, of length 3, which specifies the dimension of the block to insert.</p>
</td></tr> 
<tr><td><code id="putDwd3Dcheck_+3A_block">block</code></td>
<td>
<p>A character string which specifies which block is being inserted (one of GGG, GGH, GHG, GHH, HGG, HGH, HHG, or HHH).</p>
</td></tr>
<tr><td><code id="putDwd3Dcheck_+3A_nlx">nlx</code></td>
<td>
<p>The number of levels in the <code><a href="#topic+wd3D.object">wd3D.object</a></code> that you wish to insert the coefficients into (can be obtained using the <code><a href="#topic+nlevelsWT">nlevelsWT</a></code> function). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function merely checks that the dimensions and sizes of the array to be inserted into a <code><a href="#topic+wd3D.object">wd3D.object</a></code> using the <code><a href="#topic+putD.wd3D">putD.wd3D</a></code> function are correct. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+accessD.wd3D">accessD.wd3D</a></code>, <code><a href="#topic+print.wd3D">print.wd3D</a></code>, <code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+summary.wd3D">summary.wd3D</a></code>, <code><a href="#topic+threshold.wd3D">threshold.wd3D</a></code>, <code><a href="#topic+wd3D">wd3D</a></code>, <code><a href="#topic+wd3D.object">wd3D.object</a></code>, <code><a href="#topic+wr3D">wr3D</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Not intended to be used by the user!
#
</code></pre>

<hr>
<h2 id='putpacket'>Insert a packet of coefficients into a wavelet object. </h2><span id='topic+putpacket'></span>

<h3>Description</h3>

<p>This generic function inserts packets of coefficients into various types of wavelet objects. 
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist. For objects of class: 
</p>

<dl>
<dt>wp</dt><dd><p>use the <code><a href="#topic+putpacket.wp">putpacket.wp</a></code> method.</p>
</dd>
<dt>wst</dt><dd><p>use the <code><a href="#topic+putpacket.wst">putpacket.wst</a></code> method.</p>
</dd> 
<dt>wst2D</dt><dd><p>use the <code><a href="#topic+putpacket.wst2D">putpacket.wst2D</a></code> method.</p>
</dd>
</dl>

<p>See individual method help pages for operation and examples. 
</p>
<p>Use the <code><a href="#topic+putC">putC</a></code> and <code><a href="#topic+putD">putD</a></code> function to insert whole resolution levels of coefficients simultaneously. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>putpacket(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putpacket_+3A_...">...</code></td>
<td>
<p>See individual help pages for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A wavelet object of the same class as <code>x</code> the input object. The returned wavelet object is the same as the input except that the appropriate packet of coefficients supplied is replaced. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+putpacket.wp">putpacket.wp</a></code>, <code><a href="#topic+putpacket.wst">putpacket.wst</a></code>, <code><a href="#topic+putpacket.wst2D">putpacket.wst2D</a></code>, <code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+putC">putC</a></code>, <code><a href="#topic+wp.object">wp.object</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+wst2D.object">wst2D.object</a></code>. 
</p>

<hr>
<h2 id='putpacket.wp'>Inserts a packet of coefficients into a wavelet packet object (wp).</h2><span id='topic+putpacket.wp'></span>

<h3>Description</h3>

<p>This function inserts a packet of coefficients into a wavelet packet (<code><a href="#topic+wp">wp</a></code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
putpacket(wp, level, index, packet , ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putpacket.wp_+3A_wp">wp</code></td>
<td>
<p>Wavelet packet object into which you wish to put the packet.</p>
</td></tr> 
<tr><td><code id="putpacket.wp_+3A_level">level</code></td>
<td>
<p>The resolution level of the coefficients that you wish to insert.</p>
</td></tr>
<tr><td><code id="putpacket.wp_+3A_index">index</code></td>
<td>
<p>The index number within the resolution level of the packet of coefficients that you wish to insert.</p>
</td></tr>
<tr><td><code id="putpacket.wp_+3A_packet">packet</code></td>
<td>
<p>a vector of coefficients which is the packet you wish to insert.</p>
</td></tr> <tr><td><code id="putpacket.wp_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficients in this structure can be organised into a binary tree with each node in the tree containing a packet of coefficients. 
</p>
<p>Each packet of coefficients is obtained by chaining together the effect of the two <em>packet operators</em> DG and DH: these are the high and low pass quadrature mirror filters of the Mallat pyramid algorithm scheme followed by decimation (see Mallat (1989b)). 
</p>
<p>Starting with data <code class="reqn">c^J</code> at resolution level J containing
<code class="reqn">2^J</code> data points the wavelet packet algorithm operates as follows.
First DG and DH are applied to
<code class="reqn">c^J</code> producing <code class="reqn">d^{J-1}</code> and <code class="reqn">c^{J-1}</code> respectively.
Each of these sets of coefficients is of length one half of the original data: i.e. <code class="reqn">2^{J-1}</code>. Each of these sets of coefficients is a set of <em>wavelet packet coefficients</em>. The algorithm then applies both DG and DH to both
<code class="reqn">d^{J-1}</code> and <code class="reqn">c^{J-1}</code> to form a four sets of coefficients at
level J-2. Both operators are used again on the four sets to produce 8 sets, then again on the 8 sets to form 16 sets and so on.
At level j=J,...,0 there are <code class="reqn">2^{J-j}</code> packets of coefficients each
containing <code class="reqn">2^j</code> coefficients. 
</p>
<p>This function enables whole packets of coefficients to be inserted at any resolution level. The <code>index</code> argument chooses a particular packet within each level and thus ranges from 0 (which always refer to the father wavelet coefficients), 1 (which always refer to the mother wavelet coefficients) up to <code class="reqn">2^{J-j}</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wp.object">wp.object</a></code> which is the same as the input <code><a href="#topic+wp.object">wp.object</a></code> except it now has a modified packet of coefficients. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wp">wp</a></code>, <code><a href="#topic+getpacket.wp">getpacket.wp</a></code>. <code><a href="#topic+putpacket">putpacket</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Take the wavelet packet transform of some random data
#
MyWP &lt;- wp(rnorm(1:512))
#
# The above data set was 2^9 in length. Therefore there are
# coefficients at resolution levels 0, 1, 2, ..., and 8.
#
# The high resolution coefficients are at level 8.
# There should be 256 DG coefficients and 256 DH coefficients
#
length(getpacket(MyWP, level=8, index=0))
# [1] 256
length(getpacket(MyWP, level=8, index=1))
# [1] 256
#
# The next command shows that there are only two packets at level 8
#
#getpacket(MyWP, level=8, index=2)
# Index was too high, maximum for this level is  1 
# Error in getpacket.wp(MyWP, level = 8, index = 2): Error occured
# Dumped
#
# There should be 4 coefficients at resolution level 2
#
# The father wavelet coefficients are (index=0)
getpacket(MyWP, level=2, index=0)
# [1] -0.9736576  0.5579501  0.3100629 -0.3834068
#
# The mother wavelet coefficients are (index=1)
#
getpacket(MyWP, level=2, index=1)
# [1]  0.72871405  0.04356728 -0.43175307  1.77291483
#
# Well, that exercised the getpacket.wp
# function. Now that we know that level 2 coefficients have 4 coefficients
# let's insert some into the MyWP object.
#
MyWP &lt;- putpacket(MyWP, level=2, index=0, packet=c(21,32,67,89))
#
# O.k. that was painless. Now let's check that the correct coefficients
# were inserted.
#
getpacket(MyWP, level=2, index=0)
#[1] 21 32 67 89
#
# Yep. The correct coefficients were inserted.
</code></pre>

<hr>
<h2 id='putpacket.wst'>Put a packet of coefficients into a packet ordered non-decimated wavelet object (wst).</h2><span id='topic+putpacket.wst'></span>

<h3>Description</h3>

<p>This function inserts a packet of coefficients into a packet-ordered non-decimated wavelet object (<code><a href="#topic+wst">wst</a></code>) object. The <code><a href="#topic+wst">wst</a></code> objects are computed by the <code><a href="#topic+wst">wst</a></code> function amongst others. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
putpacket(wst, level, index, packet, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putpacket.wst_+3A_wst">wst</code></td>
<td>
<p>Packet-ordered non-decimated wavelet object into which you wish to insert the packet.</p>
</td></tr> 
<tr><td><code id="putpacket.wst_+3A_level">level</code></td>
<td>
<p>The resolution level of the coefficients that you wish to insert.</p>
</td></tr> 
<tr><td><code id="putpacket.wst_+3A_index">index</code></td>
<td>
<p>The index number within the resolution level of the packet of coefficients that you wish to insert.</p>
</td></tr>
<tr><td><code id="putpacket.wst_+3A_packet">packet</code></td>
<td>
<p>A vector of coefficients that you wish to insert into the <code><a href="#topic+wst">wst</a></code> object. The length that the packet has to may be determined by extracting the same packet of coefficients using the <code><a href="#topic+getpacket.wst">getpacket.wst</a></code> function and using the S-Plus length function to determine the length!</p>
</td></tr> 
<tr><td><code id="putpacket.wst_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function actually calls the <code><a href="#topic+putpacket.wp">putpacket.wp</a></code> to do the insertion.
</p>
<p>In the future this function will be extended to insert father wavelet coefficients as well. 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wst.object">wst.object</a></code> containing the packet ordered non-decimated wavelet coefficients that have been modified: i.e. with packet inserted.
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+getpacket.wst">getpacket.wst</a></code>, <code><a href="#topic+putpacket">putpacket</a></code>, <code><a href="#topic+putpacket.wp">putpacket.wp</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Take the packet-ordered non-decimated transform of some random data 
#
MyWST &lt;- wst(rnorm(1:512))
#
# The above data set was 2^9 in length. Therefore there are
# coefficients at resolution levels 0, 1, 2, ..., and 8.
#
# The high resolution coefficients are at level 8.
# There should be 256 coefficients at level 8 in index location 0 and 1.
#
length(getpacket(MyWST, level=8, index=0))
# [1] 256
length(getpacket(MyWST, level=8, index=1))
# [1] 256
#
# There should be 4 coefficients at resolution level 2
#
getpacket(MyWST, level=2, index=0)
# [1] -0.92103095  0.70125471  0.07361174 -0.43467375
#
# O.k. Let's insert the packet containing the numbers 19,42,21,32
#
NewMyWST &lt;- putpacket(MyWST, level=2, index=0, packet=c(19,42,31,32))
#
# Let's check that it put the numbers in correctly by reaccessing that
# packet...
#
getpacket(NewMyWST, level=2, index=0)
# [1] 19 42 31 32
#
# Yep. It inserted the packet correctly.
</code></pre>

<hr>
<h2 id='putpacket.wst2D'>Replace packet of coefficients in a two-dimensional non-decimated wavelet object (wst2D). </h2><span id='topic+putpacket.wst2D'></span>

<h3>Description</h3>

<p>This function replaces a packet of coefficients from a two-dimensional non-decimated wavelet (<code><a href="#topic+wst2D">wst2D</a></code>) object and returns the modified object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst2D'
putpacket(wst2D, level, index, type="S", packet, Ccode=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putpacket.wst2D_+3A_wst2d">wst2D</code></td>
<td>
<p>2D non-decimated wavelet object containing the coefficients you wish to replace.</p>
</td></tr>
<tr><td><code id="putpacket.wst2D_+3A_level">level</code></td>
<td>
<p>The resolution level of the coefficients that you wish to replace. Can range from 0 to <code>nlevelsWT(wpst)-1</code>.</p>
</td></tr>
<tr><td><code id="putpacket.wst2D_+3A_index">index</code></td>
<td>
<p>The index number within the resolution level of the packet of coefficients that you wish to replace. Index is a base-4 number which is <code>r</code> digits long. Each digit can be 0, 1, 2 or 3 corresponding to no shifts, horizontal shift, vertical shift or horizontal and vertical shifts. The number <code>r</code> indicates the depth of the resolution level from the data resolution i.e. where <code>r = nlevelsWT - level</code>.
</p>
<p>Where there is a string of more than one digit the left most digits correspond to finest scale shift selection, the right most digits to the coarser scales (I think).</p>
</td></tr>
<tr><td><code id="putpacket.wst2D_+3A_packet">packet</code></td>
<td>
<p>A square matrix of dimension <code>2^level</code> which contains the new coefficients that you wish to insert.</p>
</td></tr> <tr><td><code id="putpacket.wst2D_+3A_type">type</code></td>
<td>
<p>This is a one letter character string: one of &quot;S&quot;, &quot;H&quot;, &quot;V&quot; or &quot;D&quot; for the smooth coefficients, horizontal, vertical or diagonal detail.</p>
</td></tr>
<tr><td><code id="putpacket.wst2D_+3A_ccode">Ccode</code></td>
<td>
<p>If T then fast C code is used to obtain the packet, otherwise slow SPlus code is used. Unless you have some special reason always use the C code (and leave the argument at its default).</p>
</td></tr>
<tr><td><code id="putpacket.wst2D_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+wst2D">wst2D</a></code> function creates a <code><a href="#topic+wst2D">wst2D</a></code> class object. Starting with a smooth the operators H, G, GS and HS (where G, H are the usual Mallat operators and S is the shift-by-one operator) are operated first on the rows and then the columns: i.e. so each of the operators HH, HG, GH, GG, HSH, HSG, GSH, GSG HHS, GHS, HGS, GGS HSHS, HSGS, GSHS and GSGS are applied. Then the same collection of operators is applied to all the derived smooths, i.e. HH, HSH, HHS and HSHS. 
</p>
<p>So the next level is obtained from the previous level with basically HH, HG, GH and GG but with extra shifts in the horizontal, vertical and horizontal and vertical directions. The index provides a way to enumerate the paths through this tree where each smooth has 4 children and indexed by a number between 0 and 3. 
</p>
<p>Each of the 4 children has 4 components: a smooth, horizontal, vertical and diagonal detail, much in the same way as for the Mallat 2D wavelet transform implemented in the WaveThresh function <code><a href="#topic+imwd">imwd</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wst2D">wst2D</a></code> with coefficients at resolution level level, packet index and orientation given by type replaced by the matrix packet. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+getpacket.wst2D">getpacket.wst2D</a></code>, <code><a href="#topic+wst2D">wst2D</a></code>, <code><a href="#topic+wst2D.object">wst2D.object</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Create a random image. 
#
myrand &lt;- matrix(rnorm(16), nrow=4, ncol=4)
#myrand
#            [,1]       [,2]        [,3]       [,4] 
#[1,]  0.01692807  0.1400891 -0.38225727  0.3372708
#[2,] -0.79799841 -0.3306080  1.59789958 -1.0606204
#[3,]  0.29151629 -0.2028172 -0.02346776  0.5833292
#[4,] -2.21505532 -0.3591296 -0.39354119  0.6147043
#
# Do the 2D non-decimated wavelet transform
#
myrwst2D &lt;- wst2D(myrand)
#
# Let's access the finest scale detail, not shifted in the vertical
# direction.
#
getpacket(myrwst2D, nlevelsWT(myrwst2D)-1, index=0, type="V")
#           [,1]       [,2] 
#[1,] -0.1626819 -1.3244064
#[2,]  1.4113247 -0.7383336
#
# Let's put some zeros in instead...
#
zmat &lt;- matrix(c(0,0,0,0), 2,2)
newwst2D &lt;- putpacket(myrwst2D, nlevelsWT(myrwst2D)-1,
	index=0, packet=zmat, type="V")
#
# And now look at the same packet as before
#
getpacket(myrwst2D, nlevelsWT(myrwst2D)-1, index=0, type ="V")
#     [,1] [,2] 
#[1,]    0    0
#[2,]    0    0
#
# Yup, packet insertion o.k.
</code></pre>

<hr>
<h2 id='rcov'>Computes robust estimate of covariance matrix</h2><span id='topic+rcov'></span>

<h3>Description</h3>

<p>Computes a robust correlation matrix from x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcov(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcov_+3A_x">x</code></td>
<td>
<p>Matrix that you wish to find robust covariance of. Number of
variables is number of rows, number of observations is number
of columns. This is the opposite way round to the convention
expected by <code>var</code>, for example</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method originates from Huber's &quot;Robust Statistics&quot; book.
Note that the columns of <code>x</code> must be observations, this is the opposite
way around to the usual way for functions like <code>var</code>.
</p>


<h3>Value</h3>

<p>The robust covariance matrix
</p>


<h3>Author(s)</h3>

<p>Tim Downie</p>


<h3>See Also</h3>

<p><code><a href="#topic+threshold.mwd">threshold.mwd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# A standard normal data matrix with 3 variables, 100 observations
#
v &lt;- matrix(rnorm(100*3), nrow=3, ncol=100)
#
# Robust covariance
#
rcov(v)
</code></pre>

<hr>
<h2 id='rfft'>Real Fast Fourier transform</h2><span id='topic+rfft'></span>

<h3>Description</h3>

<p>Compute a real Fast Fourier transform of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfft(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rfft_+3A_x">x</code></td>
<td>
<p>The vector whose Fourier transform you wish to take</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a vector x this function computes the real continuous Fourier
transform of <code>x</code>, i.e. it regards <code>x</code> as points on a periodic
function on [0,1] starting at 0, and finding the coefficients of the functions
1,
<code class="reqn">\sqrt{2}\cos(2\pi t)</code>,
<code class="reqn">\sqrt{2}\sin(2\pi t)</code>, etc. that gives the expansion
of the interpolant of <code>x</code>. The number of terms in the expansion 
is the length of <code>x</code>. If <code>x</code> is of even length, the last
coefficient will be that of a cosine term with no matching sine.
</p>


<h3>Value</h3>

<p>Returns the Fourier coefficients
</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>See Also</h3>

<p><code><a href="#topic+LocalSpec.wd">LocalSpec.wd</a></code>,
<code><a href="#topic+rfftinv">rfftinv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(from=0, to=2*pi, length=150)
s1 &lt;- sin(10*x)
s2 &lt;- sin(7*x)
s &lt;- s1 + s2
w &lt;- rfft(s)
## Not run: ts.plot(w)
#
# Should see two peaks, corresponding to the two sines at different frequencies
#
</code></pre>

<hr>
<h2 id='rfftinv'>Inverse real FFT, inverse of rfft</h2><span id='topic+rfftinv'></span>

<h3>Description</h3>

<p>Inverse function of <code><a href="#topic+rfft">rfft</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfftinv(rz, n = length(rz))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rfftinv_+3A_rz">rz</code></td>
<td>
<p>The Fourier coefficients to invert</p>
</td></tr>
<tr><td><code id="rfftinv_+3A_n">n</code></td>
<td>
<p>The number of coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just the inverse function of <code><a href="#topic+rfft">rfft</a></code>.
</p>


<h3>Value</h3>

<p>The inverse FT of the input
</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfft">rfft</a></code></p>

<hr>
<h2 id='rfftwt'>Weight a Fourier series sequence by a set of weights</h2><span id='topic+rfftwt'></span>

<h3>Description</h3>

<p>Weight the real Fourier series <code>xrfft</code> of even length by a weight
sequence <code>wt</code>. The first term of <code>xrfft</code> is left alone, and the
weights are then applied to pairs of terms in <code>xrfft</code>. Note:
<code>wt</code> is half the length of <code>xrfft</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfftwt(xrfft, wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rfftwt_+3A_xrfft">xrfft</code></td>
<td>
<p>The Fourier series sequence to weight</p>
</td></tr>
<tr><td><code id="rfftwt_+3A_wt">wt</code></td>
<td>
<p>The weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>The weighted sequence
</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfft">rfft</a></code></p>

<hr>
<h2 id='rm.det'>Set coarse levels of a wavelets on the interval transform object to zero</h2><span id='topic+rm.det'></span>

<h3>Description</h3>

<p>Set the wavelet coefficients of certain coarse levels for a &quot;wavelets on
the interval&quot; object equal to zero. The operation of this function
is somewhat similar to the <code><a href="#topic+nullevels">nullevels</a></code> function, but for
objects associated with the &quot;wavelets on the interval code&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.det(wd.int.obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm.det_+3A_wd.int.obj">wd.int.obj</code></td>
<td>
<p>the object whose coarse levels you wish to set to zero</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;wavelets on the interval&quot; code is contained within the <code><a href="#topic+wd">wd</a></code>
function. All levels coarser than (but not including) the
<code>wd.int.obj$current.scale</code> are set to zero.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+wd.object">wd.object</a></code> of <code>type="interval"</code> containing the modified
input object with certain coarse levels set to zero.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>See Also</h3>

<p><code><a href="#topic+nullevels">nullevels</a></code>, <code><a href="#topic+wd">wd</a></code></p>

<hr>
<h2 id='rmget'>Search for existing ipndacw matrices. </h2><span id='topic+rmget'></span>

<h3>Description</h3>

<p>Returns the integer corresponding to the smallest order <code><a href="#topic+ipndacw">ipndacw</a></code> matrix of greater than or equal to order than the order, J requested. 
</p>
<p>Not really intended for user use. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmget(requestJ, filter.number, family)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmget_+3A_requestj">requestJ</code></td>
<td>
<p>A positive integer representing the order of the <code><a href="#topic+ipndacw">ipndacw</a></code> matrix that is <em>required</em>.</p>
</td></tr>
<tr><td><code id="rmget_+3A_filter.number">filter.number</code></td>
<td>
<p>The index number of the wavelet used to build the <code><a href="#topic+ipndacw">ipndacw</a></code> matrix that is required.</p>
</td></tr>
<tr><td><code id="rmget_+3A_family">family</code></td>
<td>
<p>The wavelet family used to build the <code><a href="#topic+ipndacw">ipndacw</a></code> matrix that is required.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Some of the matrices computed by <code><a href="#topic+ipndacw">ipndacw</a></code> take a long time to compute. Hence it is a good idea to store them and reuse them. 
</p>
<p>This function is asked to find an <code><a href="#topic+ipndacw">ipndacw</a></code> matrix of a particular order, <em>filter.number</em> and <em>family</em>. The function steps through all of the directories in the <code>search()</code> list collecting names of all <code><a href="#topic+ipndacw">ipndacw</a></code> matrices having the same <em>filter.number</em> and <em>family</em> characteristics. It then keeps any names where the <em>order</em> is larger than, or equal to, the requested order. This means that a suitable <code><a href="#topic+ipndacw">ipndacw</a></code> matrix of the same or larger order is visible in one of the <code>search()</code> directories. The matrix name with the smallest <code>order</code> is selected and the <em>order</em> of the matrix is returned. The routine that called this function can then <code>get()</code> the matrix and either use it &quot;as is&quot; or extract the top-left hand corner of it if <code>requestJ</code> is less than the order returned by this function. 
</p>
<p>If no such matrix, as described by the previous paragraph, exists then this function returns <code>NULL</code>. 
</p>
<p>This function calls the subsidiary routine <code><a href="#topic+firstdot">firstdot</a></code>. 
</p>


<h3>Value</h3>

<p>If a matrix of order larger than or equal to the requested order exists somewhere on the search path <em>and</em> the <code>filter.number</code> and <code><a href="stats.html#topic+family">family</a></code> is as specified then its order is returned. If more than one such matrix exists then the order of the smallest one larger than or equal to the requested one is returned.
</p>
<p>If no such matrix exists the function returns NULL. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (1998). Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum. <em>Technical Report</em>, Department of Mathematics University of Bristol/ Fachbereich Mathematik, Kaiserslautern.</p>


<h3>See Also</h3>

<p><code><a href="#topic+firstdot">firstdot</a></code>, <code><a href="#topic+ipndacw">ipndacw</a></code>, <code><a href="#topic+rmname">rmname</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Suppose there are no matrices in the search path.
#
# Let's look for the matrix rm.4.1.DaubExPhase (Haar wavelet matrix of
# order 4)
#
rmget(requestJ=4, filter.number=1, family="DaubExPhase")
#NULL
#
# I.e. a NULL return code. So there were no suitable matrices.
#
#If we create two Haar ipndacw matrix of order 7 and 8
#
ipndacw(-7, filter.number=1, family="DaubExPhase")
ipndacw(-8, filter.number=1, family="DaubExPhase")
#
# Now let's repeat the earlier search
#
rmget(requestJ=4, filter.number=1, family="DaubExPhase")
#[1] 7
#
# So, as we the smallest Haar ipndacw matrix available larger than
# the requested order of 4 is "7".
#
</code></pre>

<hr>
<h2 id='rmname'>Return a ipndacw matrix style name.</h2><span id='topic+rmname'></span>

<h3>Description</h3>

<p>This function returns a character string according to a particular format for naming <code><a href="#topic+ipndacw">ipndacw</a></code> matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmname(J, filter.number, family)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmname_+3A_j">J</code></td>
<td>
<p>A negative integer representing the order of the <code><a href="#topic+ipndacw">ipndacw</a></code> matrix.</p>
</td></tr> 
<tr><td><code id="rmname_+3A_filter.number">filter.number</code></td>
<td>
<p>The index number of the wavelet used to build the <code><a href="#topic+ipndacw">ipndacw</a></code> matrix.</p>
</td></tr> 
<tr><td><code id="rmname_+3A_family">family</code></td>
<td>
<p>The wavelet family used to build the <code><a href="#topic+ipndacw">ipndacw</a></code> matrix.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Some of the matrices computed by <code><a href="#topic+ipndacw">ipndacw</a></code> take a long time to compute. Hence it is a good idea to store them and reuse them. This function generates a name according to a particular naming scheme that permits a search algorithm to easily find the matrices. 
</p>
<p>Each matrix has three defining characteristics: its <em>order</em>, <em>filter.number</em> and <em>family</em>. Each of these three characteristics are concatenated together to form a name. 
</p>


<h3>Value</h3>

<p>A character string containing the name of a matrix according to a particular naming scheme. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (1998). Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum. <em>Technical Report</em>, Department of Mathematics University of Bristol/ Fachbereich Mathematik, Kaiserslautern. </p>


<h3>See Also</h3>

<p><code><a href="#topic+ewspec">ewspec</a></code>, <code><a href="#topic+ipndacw">ipndacw</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# What's the name of the order 4 Haar matrix?
#
rmname(-4, filter.number=1, family="DaubExPhase")
#[1] "rm.4.1.DaubExPhase"
#
# What's the name of the order 12 Daubechies least-asymmetric wavelet
# with 7 vanishing moments?
#
rmname(-12, filter.number=7, family="DaubLeAsymm")             
#[1] "rm.12.7.DaubLeAsymm"
</code></pre>

<hr>
<h2 id='rotateback'>Cyclically shift a vector one place to the right</h2><span id='topic+rotateback'></span>

<h3>Description</h3>

<p>Cyclically shifts the elements of a vector one place to the right. The right-most element becomes the first element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotateback(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotateback_+3A_v">v</code></td>
<td>
<p>The vector to shift</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subsidiary function used by the <code><a href="#topic+av.basis">av.basis</a></code>
function which is the R function component of the
<code><a href="#topic+AvBasis.wst">AvBasis.wst</a></code> function.
</p>


<h3>Value</h3>

<p>The rotated vector
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Here is a test vector
#
v &lt;- 1:10
#
# Apply this function
#
rotateback(v)
#[1] 10  1  2  3  4  5  6  7  8  9
#
# A silly little function really!
</code></pre>

<hr>
<h2 id='rsswav'>Compute mean residual sum of squares for odd prediction of even ordinates and vice versa</h2><span id='topic+rsswav'></span>

<h3>Description</h3>

<p>Compute mean of residual sum of squares (RSS) for odd prediction of even
ordinates and vice versa using wavelet shrinkage with a specified threshold.
This is a subsidiary routine of the <code><a href="#topic+WaveletCV">WaveletCV</a></code>
cross validation function.
A version implemented in C exists called <code><a href="#topic+Crsswav">Crsswav</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsswav(noisy, value = 1, filter.number = 10, family = "DaubLeAsymm", 
    thresh.type = "hard", ll = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rsswav_+3A_noisy">noisy</code></td>
<td>
<p>A vector of dyadic (power of two) length that contains the noisy data that you wish to compute the averaged RSS for.</p>
</td></tr>
<tr><td><code id="rsswav_+3A_value">value</code></td>
<td>
<p>The specified threshold.</p>
</td></tr>
<tr><td><code id="rsswav_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to perform wavelet shrinkage by cross-validation.</p>
</td></tr>
<tr><td><code id="rsswav_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="rsswav_+3A_thresh.type">thresh.type</code></td>
<td>
<p>this option specifies the thresholding type which can be &quot;hard&quot; or &quot;soft&quot;.</p>
</td></tr>
<tr><td><code id="rsswav_+3A_ll">ll</code></td>
<td>
<p>The primary resolution that you wish to assume. No wavelet coefficients that are on coarser scales than ll will be thresholded.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><b>Note</b>: a faster C based implementation of this function called
<code><a href="#topic+Crsswav">Crsswav</a></code> is available.
It takes the same arguments and returns the same values.
</p>
<p>Two-fold cross validation can be computed for a wd object using the &quot;cv&quot; policy option in <code><a href="#topic+threshold.wd">threshold.wd</a></code>.
As part of this procedure for each threshold value that the CV optimisation algorithm selects a RSS value must be computed (the CV optimisation algorithm seeks to minimize this RSS value).
</p>
<p>The RSS value computed is this. First, the even and odd indexed values are separated. The even values are used to construct an estimate of the odd true values using wavelet shrinkage with the given threshold. The sum of squares between the estimate and the noisy odds is computed. An equivalent calculation is performed by swapping the odds and evens. The two RSS values are then averaged and the average returned. This algorithm is described more fully in Nason, (1996).
</p>


<h3>Value</h3>

<p>A list with the following components
</p>
<table role = "presentation">
<tr><td><code>ssq</code></td>
<td>
<p>The RSS value that was computed</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The dof value computed on the thresholded wavelet transform of the
data with the given threshold and thresholding options. (Although this is not really used for anything).</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value argument that was specified.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the <code>thresh.type</code> argument that was specified.</p>
</td></tr>
<tr><td><code>lev</code></td>
<td>
<p>The vector <code>ll:(nlevelsWT(noisy)-1)</code> (i.e. the levels that were thresholded).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+Crsswav">Crsswav</a></code>,<code><a href="#topic+threshold.wd">threshold.wd</a></code>, <code><a href="#topic+WaveletCV">WaveletCV</a></code></p>

<hr>
<h2 id='ScalingFunction'>Compute scaling functions on internally predefined grid</h2><span id='topic+ScalingFunction'></span>

<h3>Description</h3>

<p>This is a subsidiary routine not intended to be called by a user:
use <code><a href="#topic+draw">draw</a></code> instead.
Generates scaling functions by inserting a Kronecker delta function
into the bottom of the inverse DWT and repeating the inverting steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScalingFunction(filter.number = 10, family = "DaubLeAsymm", resolution = 4096,
    itlevels = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ScalingFunction_+3A_filter.number">filter.number</code></td>
<td>
<p>The filter number of the associated wavelet. See
<code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="ScalingFunction_+3A_family">family</code></td>
<td>
<p>The family of the associated wavelet. See
<code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="ScalingFunction_+3A_resolution">resolution</code></td>
<td>
<p>The nominal resolution, the actual grid size might be
larger than this</p>
</td></tr>
<tr><td><code id="ScalingFunction_+3A_itlevels">itlevels</code></td>
<td>
<p>The number of complete filtering operations to generate
the answer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>A list containing the <code>x</code> and <code>y</code> values of the required
scaling function.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw">draw</a></code></p>

<hr>
<h2 id='Shannon.entropy'>Compute Shannon entropy</h2><span id='topic+Shannon.entropy'></span>

<h3>Description</h3>

<p>Computes Shannon entropy of the squares of a set of coefficients. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Shannon.entropy(v, zilchtol=1e-300)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Shannon.entropy_+3A_v">v</code></td>
<td>
<p>A vector of coefficients (e.g. wavelet coefficients).</p>
</td></tr> 
<tr><td><code id="Shannon.entropy_+3A_zilchtol">zilchtol</code></td>
<td>
<p>A small number. Any number smaller than this is considered to be zero for the purposes of this function.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function computes the Shannon entropy of the squares of a set of coefficients. The squares are used because we are only interested in the entropy of the energy of the coefficients, not their actual sign. 
</p>
<p>The entropy of the squares of <code>v</code> is given by <code>sum( v^2 * log(v^2) )</code>. In this implementation any zero coefficients (determined by being less than <code>zilchtol</code>) have a zero contribution to the entropy. 
</p>
<p>The Shannon entropy measures how &quot;evenly spread&quot; a set of numbers is. If the size of the entries in a vector is approximately evenly spread then the Shannon entropy is large. If the vector is sparsely populated or the entries are very different then the Shannon entropy is near zero. Note that the input vectors to this function usually have their norm normalized so that diversity of coefficients corresponds to sparsity. 
</p>


<h3>Value</h3>

<p>A number representing the Shannon entropy of the input vector. 
</p>


<h3>RELEASE</h3>

<p>Version 3.7.2 Copyright Guy Nason 1996 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+MaNoVe.wst">MaNoVe.wst</a></code>, <code><a href="#topic+wst">wst</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
#
# A sparse set
#
Shannon.entropy(c(1,0,0,0))
#0
#
# A evenly spread set
#
Shannon.entropy( rep( 1/ sqrt(4), 4 ))
#1.386294
</code></pre>

<hr>
<h2 id='simchirp'>Compute and return simulated chirp function.</h2><span id='topic+simchirp'></span>

<h3>Description</h3>

<p>This function computes and returns the coordinates of the reflected simulated chirp function described in Nason and Silverman, 1995. This function is a useful test function for evaluating wavelet shrinkage and time-scale analysis methodology as its frequency changes over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simchirp(n=1024)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simchirp_+3A_n">n</code></td>
<td>
<p>The number of ordinates from which to sample the chirp signal.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function computes and returns the x and y coordinates of the reflected chirp function described in Nason and Silverman, 1995. 
</p>
<p>The formula for the reflected simulated chirp is  *formula*
</p>
<p>The chirp returned is a discrete sample on <code>n</code> equally spaced points between -1 and 1. 
</p>


<h3>Value</h3>

<p>A list with two components: 
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>a vector of length <code>n</code> containing the ordered x ordinates of the chirp from -1 to 1.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a vector of length <code>n</code> containing the corresponding y ordinates of the chirp.</p>
</td></tr> 
</table>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate the chirp
#
test.data &lt;- simchirp()$y
## Not run: ts.plot(test.data)
</code></pre>

<hr>
<h2 id='ssq'>Compute sum of squares difference between two vectors</h2><span id='topic+ssq'></span>

<h3>Description</h3>

<p>Given two vectors, u and v, of length n, this function computes
<code class="reqn">\sum_{i=1}^n (u_i - v_i)^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssq(u,v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssq_+3A_u">u</code></td>
<td>
<p>One of the vectors</p>
</td></tr>
<tr><td><code id="ssq_+3A_v">v</code></td>
<td>
<p>The other of the vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>The sum of squares difference between the two vectors
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>Examples</h3>

<pre><code class='language-R'>ssq(c(1,2), c(3,4))
#[1] 8
</code></pre>

<hr>
<h2 id='summary.imwd'>Print out some basic information associated with an imwd object</h2><span id='topic+summary.imwd'></span>

<h3>Description</h3>

<p>Prints out the number of levels, the dimensions of the original image
from which the object came, the type of wavelet filter associated with
the decomposition, the type of boundary handling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwd'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.imwd_+3A_object">object</code></td>
<td>
<p>The object to print a summary about</p>
</td></tr>
<tr><td><code id="summary.imwd_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+threshold.imwd">threshold.imwd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(rnorm(32*32),nrow=32)
mimwd &lt;- imwd(m)
summary(mimwd)
#UNcompressed image wavelet decomposition structure
#Levels:  5 
#Original image was 32 x 32  pixels.
#Filter was:  Daub cmpct on least asymm N=10 
#Boundary handling:  periodic 
</code></pre>

<hr>
<h2 id='summary.imwdc'>Print out some basic information associated with an imwdc object</h2><span id='topic+summary.imwdc'></span>

<h3>Description</h3>

<p>Prints out the number of levels, the dimensions of the original image
from which the object came, the type of wavelet filter associated with
the decomposition, the type of boundary handling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwdc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.imwdc_+3A_object">object</code></td>
<td>
<p>The object to print a summary about</p>
</td></tr>
<tr><td><code id="summary.imwdc_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+threshold.imwd">threshold.imwd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(rnorm(32*32),nrow=32)
mimwd &lt;- imwd(m)
mimwdc &lt;- threshold(mimwd)
summary(mimwdc)
#Compressed image wavelet decomposition structure
#Levels:  5 
#Original image was 32 x 32  pixels.
#Filter was:  Daub cmpct on least asymm N=10 
#Boundary handling:  periodic 
</code></pre>

<hr>
<h2 id='summary.mwd'>Use summary() on a mwd object. </h2><span id='topic+summary.mwd'></span>

<h3>Description</h3>

<p>This function prints out more information about an <code><a href="#topic+mwd.object">mwd.object</a></code> in a nice human-readable form. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mwd'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mwd_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+mwd">mwd</a></code> that you wish to print out more information.</p>
</td></tr>
<tr><td><code id="summary.mwd_+3A_...">...</code></td>
<td>
<p>Any other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing of any particular interest.
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie 1995-6) </p>


<h3>Note</h3>

<p>Prints out information about <code><a href="#topic+mwd">mwd</a></code> objects in nice readable format.</p>


<h3>Author(s)</h3>

<p>Tim Downie</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.mwd">accessC.mwd</a></code>, <code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mfilter.select">mfilter.select</a></code>, <code><a href="#topic+mwd">mwd</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+mwr">mwr</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>, <code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+threshold.mwd">threshold.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an mwd object.
#
tmp &lt;- mwd(rnorm(32))
#
# Now get Splus to use summary.mwd
#
summary(tmp)
# Length of original:  32 
# Levels:  4 
# Filter was:  Geronimo Multiwavelets 
# Scaling fns:  2 
# Wavelet fns:  2 
# Prefilter:  default 
# Scaling factor:  2 
# Boundary handling:  periodic 
# Transform type:  wavelet 
# Date:  Tue Nov 16 13:55:26 GMT 1999 
</code></pre>

<hr>
<h2 id='summary.wd'>Print out some basic information associated with a wd object</h2><span id='topic+summary.wd'></span>

<h3>Description</h3>

<p>Prints out the number of levels, the length of the original vector
from which the object came, the type of wavelet filter associated with
the decomposition, the type of boundary handling, the transform type
and the date of production.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.wd_+3A_object">object</code></td>
<td>
<p>The object to print a summary about</p>
</td></tr>
<tr><td><code id="summary.wd_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vwd &lt;- wd(1:8)
summary(vwd)
#Levels:  3 
#Length of original:  8 
#Filter was:  Daub cmpct on least asymm N=10 
#Boundary handling:  periodic 
#Transform type:  wavelet 
#Date:  Mon Mar  8 21:30:32 2010 
</code></pre>

<hr>
<h2 id='summary.wd3D'>Print out some basic information associated with a wd3D object</h2><span id='topic+summary.wd3D'></span>

<h3>Description</h3>

<p>Prints out the number of levels, the type of wavelet filter associated with
the decomposition, and the date of production.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd3D'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.wd3D_+3A_object">object</code></td>
<td>
<p>The object to print a summary about</p>
</td></tr>
<tr><td><code id="summary.wd3D_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd3D">wd3D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>test.data.3D &lt;- array(rnorm(8*8*8), dim=c(8,8,8))
tdwd3D &lt;- wd3D(test.data.3D)
summary(tdwd3D)
#Levels:  3 
#Filter number was:  10 
#Filter family was:  DaubLeAsymm 
#Date:  Mon Mar  8 21:48:00 2010 
</code></pre>

<hr>
<h2 id='summary.wp'>Print out some basic information associated with a wp object</h2><span id='topic+summary.wp'></span>

<h3>Description</h3>

<p>Prints out the number of levels, the length of the original vector
from which the object came, the type of wavelet filter associated with
the decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.wp_+3A_object">object</code></td>
<td>
<p>The object to print a summary about</p>
</td></tr>
<tr><td><code id="summary.wp_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wp">wp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vwp &lt;- wp(rnorm(32))
summary(vwp)
#Levels:  5 
#Length of original:  32 
#Filter was:  Daub cmpct on least asymm N=10 
</code></pre>

<hr>
<h2 id='summary.wpst'>Print out some basic information associated with a wpst object</h2><span id='topic+summary.wpst'></span>

<h3>Description</h3>

<p>Prints out the number of levels, the length of the original vector
from which the object came, the type of wavelet filter associated with
the decomposition, and the date of production.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wpst'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.wpst_+3A_object">object</code></td>
<td>
<p>The object to print a summary about</p>
</td></tr>
<tr><td><code id="summary.wpst_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpst">wpst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vwpst &lt;- wpst(rnorm(32))
summary(vwpst)
#Levels:  5 
#Length of original:  32 
#Filter was:  Daub cmpct on least asymm N=10 
#Date:  Mon Mar  8 21:54:47 2010 
</code></pre>

<hr>
<h2 id='summary.wst'>Print out some basic information associated with a wst object</h2><span id='topic+summary.wst'></span>

<h3>Description</h3>

<p>Prints out the number of levels, the length of the original vector
from which the object came, the type of wavelet filter associated with
the decomposition, and the date of production.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.wst_+3A_object">object</code></td>
<td>
<p>The object to print a summary about</p>
</td></tr>
<tr><td><code id="summary.wst_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst">wst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vwst &lt;- wst(rnorm(32))
summary(vwst)
#Levels:  5 
#Length of original:  32 
#Filter was:  Daub cmpct on least asymm N=10 
#Date:  Mon Mar  8 21:56:12 2010 
</code></pre>

<hr>
<h2 id='summary.wst2D'>Print out some basic information associated with a wst2D object</h2><span id='topic+summary.wst2D'></span>

<h3>Description</h3>

<p>Prints out the number of levels, the dimensions  of the original image
from which the object came, the type of wavelet filter associated with
the decomposition, and the date of production.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst2D'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.wst2D_+3A_object">object</code></td>
<td>
<p>The object to print a summary about</p>
</td></tr>
<tr><td><code id="summary.wst2D_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst2D">wst2D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(rnorm(32*32), nrow=32)
mwst2D &lt;- wst2D(m)
summary(mwst2D)
#Levels:  5 
#Length of original:  32 x 32 
#Filter was:  Daub cmpct on least asymm N=10 
#Date:  Mon Mar  8 21:57:55 2010 
</code></pre>

<hr>
<h2 id='support'>Returns support of compactly supported wavelets.</h2><span id='topic+support'></span>

<h3>Description</h3>

<p>Returns the support for compactly supported wavelets. This information is useful for drawing wavelets for annotating axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>support(filter.number=10, family="DaubLeAsymm", m=0, n=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="support_+3A_filter.number">filter.number</code></td>
<td>
<p>The member index of a wavelet within the family.
For Daubechies' compactly supported wavelet this is the number of
vanishing moments which is related to the smoothness.
See <code><a href="#topic+filter.select">filter.select</a></code> for more information on the
wavelets.</p>
</td></tr>
<tr><td><code id="support_+3A_family">family</code></td>
<td>
<p>The family of wavelets.
See <code><a href="#topic+filter.select">filter.select</a></code> for more information on the wavelets.</p>
</td></tr>
<tr><td><code id="support_+3A_m">m</code></td>
<td>
<p>Optional scale value (in usual wavelet terminology this is j)</p>
</td></tr>
<tr><td><code id="support_+3A_n">n</code></td>
<td>
<p>Optional translation value (in usual wavelet terminology, this is k)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is useful to know the support of a wavelet when drawing it to annotate
labels. Other functions, such as wavelet density estimation
(<code><a href="#topic+CWavDE">CWavDE</a></code>), also use this information.
</p>


<h3>Value</h3>

<p>A list with the following components (each one is a single numeric value)
</p>
<table role = "presentation">
<tr><td><code>lh</code></td>
<td>
<p>Left hand support of the wavelet with scale m and translation n.
These values change as m and n (although when m=0 the function
confusingly returns the next coarser wavelet where you might
expect it to return the mother. The mother is indexed by m=-1)</p>
</td></tr>
<tr><td><code>rh</code></td>
<td>
<p>As lh but returns the rh end.</p>
</td></tr>
<tr><td><code>psi.lh</code></td>
<td>
<p>left hand end of the support interval for the mother wavelet
(remains unchanged no matter what m or n are)</p>
</td></tr>
<tr><td><code>psi.rh</code></td>
<td>
<p>right hand end of the support interval for the mother wavelet
(remains unchanged no matter what m or n are)</p>
</td></tr>
<tr><td><code>phi.lh</code></td>
<td>
<p>left hand end of the support interval for the father wavelet
(remains unchanged no matter what m or n are)</p>
</td></tr>
<tr><td><code>phi.rh</code></td>
<td>
<p>right hand end of the support interval for the father wavelet (remains unchanged no matter what m or n are)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+CWavDE">CWavDE</a></code>,
<code><a href="#topic+draw.default">draw.default</a></code>,
<code><a href="#topic+filter.select">filter.select</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# What is the support of a Haar wavelet?
#
support(filter.number=1, family="DaubExPhase", m=0, n=0)
#$lh
#[1] 0
#
#$rh
#[1] 2
#
#$psi.lh
#[1] 0
#
#$psi.rh
#[1] 1
#
#$phi.lh
#[1] 0
#
#$phi.rh
#[1] 1
#
# So the mother and father wavelet have support [0,1]
#
</code></pre>

<hr>
<h2 id='sure'>Computes the minimum of the SURE thresholding function</h2><span id='topic+sure'></span>

<h3>Description</h3>

<p>Computes the minimum of the SURE thresholding function for
wavelet shrinkage as described in Donoho, D.L. and Johnstone, I.M.
(1995) Adapting to unknown smoothness via wavelet shrinkage.
<em>J. Am. Statist. Ass.</em>, <b>90</b>, 1200-1224.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sure(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sure_+3A_x">x</code></td>
<td>
<p>Vector of (normalized) wavelet coefficients. Coefficients
should be supplied divided by their standard deviation, or
some robust measure of scale</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SURE is a method for unbiasedly estimating the risk of an estimator. Stein (1981) showed that for a nearly arbitrary, nonlinear biased estimator, one can estimate its loss unbiasedly. See the Donoho and Johnstone, 1995 for further references and explanation. This function minimizes formula (11) from that paper.
</p>


<h3>Value</h3>

<p>The absolute value of the wavelet coefficient that minimizes the
SURE criteria 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+threshold">threshold</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's create "pretend" vector of wavelet coefficients contaminated with
# "noise".
#
v &lt;- c(0.1, -0.2, 0.3, -0.4, 0.5, 99, 12, 6)
#
# Now, what's sure of this?
#
sure(v)
#
# [1] 0.5
#
#
# I.e. the large significant coefficients are 99, 12, 6 and the noise is
# anything less than this in abs value. So sure(v) is a good point to threshold
# at.
</code></pre>

<hr>
<h2 id='teddy'>Picture of a teddy bear's picnic.</h2><span id='topic+teddy'></span>

<h3>Description</h3>

<p>A 512x512 matrix. Each entry of the matrix contains an image intensity value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(teddy)
</code></pre>


<h3>Format</h3>

<p>A 512x512 matrix. Each entry of the matrix contains an image intensity value. The whole matrix represents an image of a teddy bear's picnic.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>Source</h3>

<p>Taken by Guy Nason. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# This command produces the image seen above.
#
# image(teddy)
#
</code></pre>

<hr>
<h2 id='test.dataCT'>Test functions for wavelet regression and thresholding </h2><span id='topic+test.dataCT'></span>

<h3>Description</h3>

<p>This function evaluates the &quot;blocks&quot;, &quot;bumps&quot;, &quot;heavisine&quot; and &quot;doppler&quot; test functions of Donoho &amp; Johnstone (1994b) and the piecewise polynomial test function of Nason &amp; Silverman (1994). The function also generates data sets consisting of the specified function plus uncorrelated normally distributed errors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.dataCT(type = "ppoly", n = 512, signal = 1, rsnr = 7, plotfn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.dataCT_+3A_type">type</code></td>
<td>
<p>Test function to be computed. Available types are &quot;ppoly&quot; (piecewise polynomial), &quot;blocks&quot;, &quot;bumps&quot;, &quot;heavi&quot; (heavisine), and &quot;doppler&quot;.</p>
</td></tr>
<tr><td><code id="test.dataCT_+3A_n">n</code></td>
<td>
<p>Number of equally spaced data points on which the function is evaluated. </p>
</td></tr>
<tr><td><code id="test.dataCT_+3A_signal">signal</code></td>
<td>
<p>Scaling parameter; the function will be scaled so that the standard deviation of the data points takes this value.</p>
</td></tr>
<tr><td><code id="test.dataCT_+3A_rsnr">rsnr</code></td>
<td>
<p>Root signal-to-noise ratio. Specifies the ratio of the standard deviation of the function to the standard deviation of the simulated errors.</p>
</td></tr>
<tr><td><code id="test.dataCT_+3A_plotfn">plotfn</code></td>
<td>
<p>If <code>plotfn=TRUE</code>, then the test function and the simulated data set are plotted</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The points at which the test function is evaluated.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The values taken by the test function.</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>The simulated data set.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of function generated, identical to the input parameter type.</p>
</td></tr>
<tr><td><code>rsnr</code></td>
<td>
<p>The root signal-to-noise ratio of the simulated data set, identical to the input parameter rsnr.</p>
</td></tr> 
</table>


<h3>Side effects</h3>

<p>If <code>plotfn=T</code>, the test function and data set are plotted.
</p>


<h3>RELEASE</h3>

<p>Part of the CThresh addon to WaveThresh. Copyright Stuart Barber and Guy Nason 2004. 
</p>


<h3>Author(s)</h3>

<p>Stuart Barber</p>

<hr>
<h2 id='threshold'>Threshold coefficients</h2><span id='topic+threshold'></span>

<h3>Description</h3>

<p>Modify coefficients by thresholding or shrinkage. 
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist for the following objects: 
</p>

<dl>
<dt>wd object</dt><dd><p>the <code><a href="#topic+threshold.wd">threshold.wd</a></code> function is used;</p>
</dd>
<dt>imwd object</dt><dd><p>the <code><a href="#topic+threshold.imwd">threshold.imwd</a></code> function is used;</p>
</dd>
<dt>imwdc object</dt><dd><p>the <code><a href="#topic+threshold.imwdc">threshold.imwdc</a></code> function is used;</p>
</dd>
<dt>irregwd object</dt><dd><p>the <code><a href="#topic+threshold.irregwd">threshold.irregwd</a></code> function is used;</p>
</dd>
<dt>wd3D object</dt><dd><p>the <code><a href="#topic+threshold.wd3D">threshold.wd3D</a></code> function is used;</p>
</dd> 
<dt>wp object</dt><dd><p>the <code><a href="#topic+threshold.wp">threshold.wp</a></code> function is used;</p>
</dd>
<dt>wst object</dt><dd><p>the <code><a href="#topic+threshold.wst">threshold.wst</a></code> function is used.</p>
</dd> 
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>threshold(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshold_+3A_...">...</code></td>
<td>
<p>See individual help pages for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See individual method help pages for operation and examples. 
</p>


<h3>Value</h3>

<p>Usually a copy of the input object but containing thresholded or shrunk coefficients. 
</p>


<h3>RELEASE</h3>

<p>Version 2 Copyright Guy Nason 1993 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+imwdc.object">imwdc.object</a></code>, <code>irregwd object</code>, <code><a href="#topic+threshold.imwd">threshold.imwd</a></code>, <code><a href="#topic+threshold.imwdc">threshold.imwdc</a></code>, <code><a href="#topic+threshold.irregwd">threshold.irregwd</a></code>, <code><a href="#topic+threshold.wd">threshold.wd</a></code>, <code><a href="#topic+threshold.wd3D">threshold.wd3D</a></code>, <code><a href="#topic+threshold.wp">threshold.wp</a></code>, <code><a href="#topic+threshold.wst">threshold.wst</a></code> <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+wd3D.object">wd3D.object</a></code>, <code><a href="#topic+wp.object">wp.object</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>. 
</p>

<hr>
<h2 id='threshold.imwd'>Threshold two-dimensional wavelet decomposition object</h2><span id='topic+threshold.imwd'></span>

<h3>Description</h3>

<p>This function provides various ways to threshold a <code><a href="#topic+imwd">imwd</a></code> class object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwd'
threshold(imwd, levels = 3:(nlevelsWT(imwd) - 1), type = "hard", policy = 
        "universal", by.level = FALSE, value = 0, dev = var, verbose = FALSE, 
        return.threshold = FALSE, compression = TRUE, Q = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshold.imwd_+3A_imwd">imwd</code></td>
<td>
<p>The two-dimensional wavelet decomposition object that you wish to threshold.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_levels">levels</code></td>
<td>
<p>a vector of integers which determines which scale levels are thresholded in the decomposition. Each integer in the vector must refer to a valid level in the <code><a href="#topic+imwd">imwd</a></code> object supplied. This is usually any integer from 0 to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wd)-1 inclusive. Only the levels in this vector contribute to the computation of the threshold and its application. (except for the <code>fdr</code> policy). </p>
</td></tr>  
<tr><td><code id="threshold.imwd_+3A_type">type</code></td>
<td>
<p>determines the type of thresholding this can be &quot;<code>hard</code>&quot; or &quot;<code>soft</code>&quot;.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_policy">policy</code></td>
<td>
<p>selects the technique by which the threshold value is selected. Each policy corresponds to a method in the literature. At present the different policies are: &quot;<code>universal</code>&quot;, &quot;<code>manual</code>&quot;, &quot;<code>fdr</code>&quot;, &quot;<code>probability</code>&quot;. The policies are described in detail below.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_by.level">by.level</code></td>
<td>
<p>If FALSE then a global threshold is computed on and applied to all scale levels defined in levels. If TRUE a threshold is computed and applied separately to each scale level.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_value">value</code></td>
<td>
<p>This argument conveys the user supplied threshold. If the <code>policy="manual"</code> then value is the actual threshold value; if <code>policy="probability"</code> then <code>value</code> conveys the the user supplied quantile level.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_dev">dev</code></td>
<td>
<p>this argument supplies the function to be used to compute the spread of the absolute values coefficients. The function supplied must return a value of spread on the variance scale (i.e. not standard deviation) such as the <code>var()</code> function. A popular, useful and robust alternative is the <code><a href="#topic+madmad">madmad</a></code> function.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE then the function prints out informative messages as it progresses.</p>
</td></tr> 
<tr><td><code id="threshold.imwd_+3A_return.threshold">return.threshold</code></td>
<td>
<p>If this option is TRUE then the actual <em>value</em> of the threshold is returned. If this option is FALSE then a thresholded version of the input is returned.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_compression">compression</code></td>
<td>
<p>If this option is TRUE then this function returns a comressed two-dimensional wavelet transform object of class <code>imwdc</code>. This can be useful as the resulting object will be smaller than if it was not compressed. The compression makes use of the fact that many coefficients in a thresholded object will be exactly zero. If this option is FALSE then a larger <code><a href="#topic+imwd">imwd</a></code> object will be returned.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_q">Q</code></td>
<td>
<p>Parameter for the false discovery rate <code>"fdr"</code> policy. </p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function thresholds or shrinks wavelet coefficients stored in a <code><a href="#topic+imwd">imwd</a></code> object and by default returns the coefficients in a modified <code>imwdc</code> object.
See the seminal papers by Donoho and Johnstone for explanations about thresholding. For a gentle introduction to wavelet thresholding (or shrinkage as it is sometimes called) see Nason and Silverman, 1994. For more details on each technique see the descriptions of each method below
</p>
<p>The basic idea of thresholding is very simple. In a signal plus noise model the wavelet transform of an image is very sparse, the wavelet transform of noise is not (in particular, if the noise is iid Gaussian then so if the noise contained in the wavelet coefficients).
Thus, since the image gets concentrated in few wavelet coefficients and the noise remains &quot;spread&quot; out it is &quot;easy&quot; to separate the signal from noise by keeping large coefficients (which correspond to true image) and delete the small ones (which correspond to noise). However, one has to have some idea of the noise level (computed using the dev option in threshold functions). If the noise level is very large then it is possible, as usual, that no image coefficients &quot;stick up&quot; above the noise. 
</p>
<p>There are many components to a successful thresholding procedure. Some components have a larger effect than others but the effect is not the same in all practical data situations. Here we give some rough practical guidance, although <em>you must refer to the papers below when using a particular technique</em>.
<b>You cannot expect to get excellent performance on all signals unless you fully understand the rationale and limitations of each method below</b>. I am not in favour of the &quot;black-box&quot; approach. The thresholding functions of WaveThresh3 are not a black box: experience and judgement are required! 
</p>
<p>Some issues to watch for: 
</p>

<dl>
<dt>levels</dt><dd><p>The default of <code>levels = 3:(wd$nlevelsWT - 1)</code> for the <code>levels</code> option most certainly does not work globally for all data problems and situations. The level at which thresholding begins (i.e. the given threshold and finer scale wavelets) is called the <em>primary resolution</em> and is unique to a particular problem. In some ways choice of the primary resolution is very similar to choosing the bandwidth in kernel regression albeit on a logarithmic scale. See Hall and Patil, (1995) and Hall and Nason (1997) for more information. For each data problem you need to work out which is the best primary resolution. This can be done by gaining experience at what works best, or using prior knowledge. It is possible to &quot;automatically&quot; choose a &quot;best&quot; primary resolution using cross-validation (but not in WaveThresh). 
</p>
<p>Secondly the levels argument computes and applies the threshold at the levels specified in the <code>levels</code> argument. It does this for all the levels specified. Sometimes, in wavelet shrinkage, the threshold is computed using only the finest scale coefficients (or more precisely the estimate of the overall noise level). If you want your threshold variance estimate only to use the finest scale coefficients (e.g. with universal thresholding) then you will have to apply the <code>threshold.imwd</code> function twice. Once (with levels set equal to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wd)-1) and with <code>return.threshold=TRUE</code> to return the threshold computed on the finest scale and then apply the threshold function with the <code>manual</code> option supplying the value of the previously computed threshold as the <code>value</code> options. </p>
</dd>
</dl>
<p>Note that the fdr policy does its own thing. 
</p>
<dl>
<dt>by.level</dt><dd><p>for a <code><a href="#topic+wd">wd</a></code> object which has come from data with noise that is correlated then you should have a threshold computed for each resolution level. See the paper by Johnstone and Silverman, 1997.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>imwdc</code> if the <code>compression</code> option above is TRUE, otherwise a <code><a href="#topic+imwd">imwd</a></code> object is returned. In either case the returned object contains the thresholded coefficients. Note that if the <code>return.threshold</code> option is set to TRUE then the threshold values will be returned rather than the thresholded object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason and others 1997 </p>


<h3>Note</h3>

<p>This section gives a brief description of the different thresholding policies available. For further details see the <em>associated papers</em>. If there is no paper available then a small description is provided here. More than one policy may be good for problem, so experiment! They are arranged here in alphabetical order:
</p>

<dl>
<dt>fdr</dt><dd><p>See Abramovich and Benjamini, 1996. Contributed by Felix Abramovich.</p>
</dd>
<dt>manual</dt><dd><p>specify a user supplied threshold using <code>value</code> to pass the value of the threshold. The <code>value</code> argument should be a vector. If it is of length 1 then it is replicated to be the same length as the <code>levels</code> vector, otherwise it is repeated as many times as is necessary to be the <code>levels</code> vector's length. In this way, different thresholds can be supplied for different levels. Note that the <code>by.level</code> option has no effect with this policy.</p>
</dd>
<dt>probability</dt><dd><p>The <code>probability</code> policy works as follows. All coefficients that are smaller than the valueth quantile of the coefficients are set to zero. If <code>by.level</code> is false, then the quantile is computed for all coefficients in the levels specified by the &quot;levels&quot; vector; if <code>by.level</code> is true, then each level's quantile is estimated separately. The probability policy is pretty stupid - do not use it.</p>
</dd>
<dt>universal</dt><dd><p>See Donoho and Johnstone, 1995.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>The FDR code segments were kindly donated by Felix Abramovich. </p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+imwdc.object">imwdc.object</a></code>. <code><a href="#topic+threshold">threshold</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's use the lennon test image
#
data(lennon)
## Not run: image(lennon)
#
# Now let's do the 2D discrete wavelet transform
#
lwd &lt;- imwd(lennon)
#
# Let's look at the coefficients
#
## Not run: plot(lwd)
#
# Now let's threshold the coefficients
#
lwdT &lt;- threshold(lwd)
#
# And let's plot those the thresholded coefficients
#
## Not run: plot(lwdT)
#
# Note that the only remaining coefficients are down in the bottom
# left hand corner of the plot. All the others (black) have been set
# to zero (i.e. thresholded).
</code></pre>

<hr>
<h2 id='threshold.imwdc'>Threshold two-dimensional compressed wavelet decomposition object</h2><span id='topic+threshold.imwdc'></span>

<h3>Description</h3>

<p>This function provides various ways to threshold a <code>imwdc</code> class object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwdc'
threshold(imwdc, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshold.imwdc_+3A_imwdc">imwdc</code></td>
<td>
<p>The two-dimensional compressed wavelet decomposition object that you wish to threshold.</p>
</td></tr>
<tr><td><code id="threshold.imwdc_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE then the function prints out informative messages as it progresses.</p>
</td></tr>
<tr><td><code id="threshold.imwdc_+3A_...">...</code></td>
<td>
<p>other arguments passed to the <code><a href="#topic+threshold.imwd">threshold.imwd</a></code> function to control the thresholding characteristics such as policy, type of thresholding etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs exactly the same function as <code><a href="#topic+threshold.imwd">threshold.imwd</a></code> except is accepts objects of class <code>imwdc</code> rather than imwd. Indeed, this function physically calls the <code><a href="#topic+threshold.imwd">threshold.imwd</a></code> function after using the <code><a href="#topic+uncompress">uncompress</a></code> function to convert the input <code>imwdc</code> object into a <code><a href="#topic+imwd">imwd</a></code> object. 
</p>


<h3>Value</h3>

<p>An object of class <code>imwdc</code> if the compression option is supplied and set to TRUE, otherwise a <code><a href="#topic+imwd">imwd</a></code> object is returned. In either case the returned object contains the thresholded coefficients. Note that if the <code>return.threshold</code> option is set to TRUE then the threshold values will be returned rather than the thresholded object. </p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason and others 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>The FDR code segments were kindly donated by Felix Abramovich. </p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+imwdc.object">imwdc.object</a></code>, <code><a href="#topic+threshold">threshold</a></code>, <code><a href="#topic+uncompress">uncompress</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See examples in \code{\link{threshold.imwd}}.
#
</code></pre>

<hr>
<h2 id='threshold.irregwd'>hold irregularly spaced wavelet decomposition object</h2><span id='topic+threshold.irregwd'></span>

<h3>Description</h3>

<p>This function provides various ways to threshold a <code><a href="#topic+irregwd">irregwd</a></code> class object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'irregwd'
threshold(irregwd,
    levels = 3:(nlevelsWT(wd) - 1), type = "hard", policy = "universal",
    by.level = FALSE, value = 0, dev = var, boundary = FALSE,
    verbose = FALSE, return.threshold = FALSE, 
    force.sure=FALSE, cvtol = 0.01, Q = 0.05, alpha=0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshold.irregwd_+3A_irregwd">irregwd</code></td>
<td>
<p>The irregularly spaced wavelet decomposition object that you wish to threshold.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_levels">levels</code></td>
<td>
<p>a vector of integers which determines which scale levels are thresholded in the decomposition. Each integer in the vector must refer to a valid level in the <code><a href="#topic+irregwd">irregwd</a></code> object supplied. This is usually any integer from 0 to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(irregwd)-1 inclusive. Only the levels in this vector contribute to the computation of the threshold and its application.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_type">type</code></td>
<td>
<p>determines the type of thresholding this can be &quot;hard&quot; or &quot;soft&quot;.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_policy">policy</code></td>
<td>
<p>selects the technique by which the threshold value is selected. Each policy corresponds to a method in the literature. At present the different policies are: <code>"universal"</code>, <code>"LSuniversal"</code>, <code>"sure"</code>, <code>"cv"</code>, <code>"fdr"</code>, <code>"op1"</code>, <code>"op2"</code>, <code>"manual"</code>, <code>"mannum"</code>, <code>"probability"</code>. A description of the policies can be obtained by clicking on the above links.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_by.level">by.level</code></td>
<td>
<p>If <code>FALSE</code> then a global threshold is computed on and applied to all scale levels defined in levels. If <code>TRUE</code> a threshold is computed and applied separately to each scale level.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_value">value</code></td>
<td>
<p>This argument conveys the user supplied threshold. If the <code>policy="manual"</code> then value is the actual threshold value.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_dev">dev</code></td>
<td>
<p>this argument supplies the function to be used to compute the spread of the absolute values coefficients. The function supplied must return a value of spread on the variance scale (i.e. not standard deviation) such as the <code>var()</code> function. A popular, useful and robust alternative is the <code><a href="#topic+madmad">madmad</a></code> function.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_boundary">boundary</code></td>
<td>
<p>If this argument is <code>TRUE</code> then the boundary bookeeping values are included for thresholding, otherwise they are not.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> then the function prints out informative messages as it progresses.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_return.threshold">return.threshold</code></td>
<td>
<p>If this option is <code>TRUE</code> then the actual <em>value</em> of the threshold is returned. If this option is <code>FALSE</code> then a thresholded version of the input is returned.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_force.sure">force.sure</code></td>
<td>
<p>If <code>TRUE</code> then the <code>SURE</code> threshold is computed on a vector even when that vector is very sparse. If <code>FALSE</code> then the normal SUREshrink procedure is followed whereby the universal threshold is used for sparse vectors of coefficients.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_cvtol">cvtol</code></td>
<td>
<p>Parameter for the cross-validation <code>"cv"</code> policy.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_q">Q</code></td>
<td>
<p>Parameter for the false discovery rate <code>"fdr"</code> policy.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_alpha">alpha</code></td>
<td>
<p>Parameter for Ogden and Parzen's first <code>"op1"</code> and <code>"op2"</code> policies.</p>
</td></tr>
<tr><td><code id="threshold.irregwd_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function thresholds or shrinks wavelet coefficients stored in a <code><a href="#topic+irregwd">irregwd</a></code> object and returns the coefficients in a modified <code><a href="#topic+irregwd">irregwd</a></code> object. The thresholding step is an essential component of denoising. 
</p>
<p>The basic idea of thresholding is very simple. In a signal plus noise model the wavelet transform of signal is very sparse, the wavelet transform of noise is not (in particular, if the noise is iid Gaussian then so if the noise contained in the wavelet coefficients). Thus since the signal gets concentrated in the wavelet coefficients and the noise remains &quot;spread&quot; out it is &quot;easy&quot; to separate the signal from noise by keeping large coefficients (which correspond to signal) and delete the small ones (which correspond to noise). However, one has to have some idea of the noise level (computed using the dev option in threshold functions). If the noise level is very large then it is possible, as usual, that no signal &quot;sticks up&quot; above the noise. 
</p>
<p>For thresholding of an <em>irregularly spaced wavelet decomposition</em> things are a little different. The original data are irregularly spaced (i.e. [x,y] where the <code class="reqn">x_i</code> are irregularly spaced) and even if one assumes iid error on the original data once this has been interpolated to a grid by the <code><a href="#topic+makegrid">makegrid</a></code> function the interpolated data values are not independent. The <code><a href="#topic+irregwd">irregwd</a></code> function computes the wavelet transform of the interpolated data but also computes the variance of each coefficient using a fast transform. This variance information is stored in the c component of <code><a href="#topic+irregwd">irregwd</a></code> objects and this function, <code>threshold.irregwd</code>, makes use of this variance information when thresholding each coefficient. For more details see Kovac and Silverman, 2000 
</p>
<p>Some issues to watch for: 
</p>

<dl>
<dt>levels</dt><dd><p>The default of <code>levels = 3:(wd$nlevelsWT - 1)</code> for the <code>levels</code> option most certainly does not work globally for all data problems and situations. The level at which thresholding begins (i.e. the given threshold and finer scale wavelets) is called the <em>primary resolution</em> and is unique to a particular problem.
In some ways choice of the primary resolution is very similar to choosing the bandwidth in kernel regression albeit on a logarithmic scale. See Hall and Patil, (1995) and Hall and Nason (1997) for more information. For each data problem you need to work out which is the best primary resolution. This can be done by gaining experience at what works best, or using prior knowledge. It is possible to &quot;automatically&quot; choose a &quot;best&quot; primary resolution using cross-validation (but not yet in WaveThresh).
</p>
<p>Secondly the levels argument computes and applies the threshold at the levels specified in the levels argument. It does this for all the levels specified. Sometimes, in wavelet shrinkage, the threshold is computed using only the finest scale coefficients (or more precisely the estimate of the overall noise level).
If you want your threshold variance estimate only to use the finest scale coefficients (e.g. with universal thresholding) then you will have to apply the <code>threshold.wd</code> function twice. Once (with levels set equal to <code>nlevelsWT</code>(wd)-1 and with <code>return.threshold=TRUE</code> to return the threshold computed on the finest scale and then apply the threshold function with the manual option supplying the value of the previously computed threshold as the value options.</p>
</dd>
<dt>by.level</dt><dd><p>for a <code><a href="#topic+wd">wd</a></code> object which has come from data with noise that is correlated then you should have a threshold computed for each resolution level. See the paper by Johnstone and Silverman, 1997.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code><a href="#topic+irregwd">irregwd</a></code>. This object contains the thresholded wavelet coefficients. Note that if the <code>return.threshold</code> option is set to <code>TRUE</code> then the threshold values will be returned rather than the thresholded object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>Arne Kovac</p>


<h3>See Also</h3>

<p><code><a href="#topic+makegrid">makegrid</a></code>, <code><a href="#topic+irregwd">irregwd</a></code>, <code><a href="#topic+irregwd">irregwd</a></code> object, <code><a href="#topic+accessc">accessc</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See main examples of these functions in the help to makegrid
#
</code></pre>

<hr>
<h2 id='threshold.mwd'>Use threshold on an mwd object. </h2><span id='topic+threshold.mwd'></span>

<h3>Description</h3>

<p>Applies hard or soft thresholding to multiple wavelet decomposition object mwd.object.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mwd'
threshold(mwd, levels = 3:(nlevelsWT(mwd) - 1), type = "hard",
    policy = "universal", boundary = FALSE, verbose = FALSE,
    return.threshold = FALSE, threshold = 0, covtol = 1e-09, 
    robust = TRUE, return.chisq = FALSE,
    bivariate = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshold.mwd_+3A_mwd">mwd</code></td>
<td>
<p>The multiple wavelet decomposition object that you wish to threshold.</p>
</td></tr>
<tr><td><code id="threshold.mwd_+3A_levels">levels</code></td>
<td>
<p>a vector of integers which determines which scale levels are thresholded in the decomposition. Each integer in the vector must refer to a valid level in the <code><a href="#topic+mwd">mwd</a></code> object supplied. This is usually any integer from 0 to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wd)-1 inclusive. Only the levels in this vector contribute to the computation of the threshold and its application. </p>
</td></tr>
<tr><td><code id="threshold.mwd_+3A_type">type</code></td>
<td>
<p>determines the type of thresholding this can be &quot;<code>hard</code>&quot; or &quot;<code>soft</code>&quot;.</p>
</td></tr>
<tr><td><code id="threshold.mwd_+3A_policy">policy</code></td>
<td>
<p>selects the technique by which the threshold value is selected. Each policy corresponds to a method in the literature. At present the different policies are &quot;<code>universal</code>&quot;, &quot;<code>manual</code>&quot;, &quot;<code>single</code>&quot;. The policies are described in detail below. </p>
</td></tr>
<tr><td><code id="threshold.mwd_+3A_boundary">boundary</code></td>
<td>
<p>If this argument is <code>TRUE</code> then the boundary bookeeping values are included for thresholding, otherwise they are not. </p>
</td></tr>
<tr><td><code id="threshold.mwd_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> then the function prints out informative messages as it progresses. </p>
</td></tr>
<tr><td><code id="threshold.mwd_+3A_return.threshold">return.threshold</code></td>
<td>
<p>If this option is <code>TRUE</code> then the actual <em>value</em> of the threshold is returned. If this option is FALSE then a thresholded version of the input is returned.</p>
</td></tr>
<tr><td><code id="threshold.mwd_+3A_threshold">threshold</code></td>
<td>
<p>This argument conveys the user supplied threshold. If the <code>policy="manual"</code> then <code>value</code> is the actual threshold value. Any other <code>policy</code> means that the <code>threshold</code> value is ignored.</p>
</td></tr>
<tr><td><code id="threshold.mwd_+3A_covtol">covtol</code></td>
<td>
<p>The tolerance for what constitutes a singular variance matrix. If smallest eigenvalue of the estimated variance matrix is less than <code>covtol</code> then it is assumed to be singular and no thresholding is done at that level. Note: do not confuse <code>covtol</code> with <code>cvtol</code> an argument in <code><a href="#topic+threshold.wd">threshold.wd</a></code>.</p>
</td></tr> 
<tr><td><code id="threshold.mwd_+3A_robust">robust</code></td>
<td>
<p>If TRUE the variance matrix at each level is estimated using a robust method (mad) otherwise it is estimated using var().</p>
</td></tr>
<tr><td><code id="threshold.mwd_+3A_return.chisq">return.chisq</code></td>
<td>
<p>If TRUE the vector of values to be thresholded is returned. These values are a quadratic form of each coefficient vector, and under normal assumptions the noise component will have a chi-squared distribution (see Downie and Silverman 1996). </p>
</td></tr>
<tr><td><code id="threshold.mwd_+3A_bivariate">bivariate</code></td>
<td>
<p>this line is in construction</p>
</td></tr>
<tr><td><code id="threshold.mwd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Thresholding modifies the coefficients within a <code><a href="#topic+mwd.object">mwd.object</a></code>. The modification can be performed either with a &quot;hard&quot; or &quot;soft&quot; thresholding selected by the type argument. 
</p>
<p>Unless policy=&quot;single&quot;, the following method is applied. The columns of
<code>mwd$D</code> are taken as coefficient vectors <code class="reqn">D_{j,k}</code>.
From these
<code class="reqn">\chi^2_{j,k}=D_{j,k} \cdot V_j^{-1}</code>.
<code class="reqn">D_{j,k}</code> is computed, where
<code class="reqn">V_j^{-1}</code> is the inverse of the estimated variance of the coefficient vectors in that level (j).
<code class="reqn">\chi^2_{j,k}</code> is a positive scalar which is to be thresholded in a
similar manner to univariate hard or soft thresholding.
To obtain the new values of <code class="reqn">D_{j,k}</code> shrink the vector by the
same proportion as was the corresponding <code class="reqn">\chi^2_{j,k}</code> term. 
i
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+mwd">mwd</a></code>. This object contains the thresholded wavelet coefficients. Note that if the <code>return.threshold</code> option is set to TRUE then the threshold values will be returned, or if <code>return.chisq</code> the vector of values to be thresholded will be returned, rather than the thresholded object.</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Tim Downie 1995-6). </p>


<h3>Note</h3>

<p>POLICIES 
</p>

<dl>
<dt>single</dt><dd><p>If <code>policy="single"</code> then univariate thresholding is applied to each element of D as in (Strela et al 1999).</p>
</dd> 
<dt>universal</dt><dd><p>The <code>universal</code> threshold is computed using 2log(n) (See Downie &amp; Silverman 1996) where n is the number of coefficient vectors to be thresholded.</p>
</dd>
<dt>manual</dt><dd><p>The &quot;<code>manual</code>&quot; policy is simple. You supply a <code>threshold</code> value to the threshold argument and hard or soft thresholding is performed using that value</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tim Downie</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.mwd">accessC.mwd</a></code>, <code><a href="#topic+accessD.mwd">accessD.mwd</a></code>, <code><a href="#topic+draw.mwd">draw.mwd</a></code>, <code><a href="#topic+mfirst.last">mfirst.last</a></code>, <code><a href="#topic+mfilter.select">mfilter.select</a></code>, <code><a href="#topic+mwd">mwd</a></code>, <code><a href="#topic+mwd.object">mwd.object</a></code>, <code><a href="#topic+mwr">mwr</a></code>, <code><a href="#topic+plot.mwd">plot.mwd</a></code>, <code><a href="#topic+print.mwd">print.mwd</a></code>, <code><a href="#topic+putC.mwd">putC.mwd</a></code>, <code><a href="#topic+putD.mwd">putD.mwd</a></code>, <code><a href="#topic+summary.mwd">summary.mwd</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.mwd">wr.mwd</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y 
## Not run: ts.plot(test.data)
#
# Generate some noisy data
#
ynoise &lt;- test.data + rnorm(512, sd=0.1)
##
# Plot it
#
## Not run: ts.plot(ynoise)
#
# Now take the discrete multiple wavelet transform
# N.b. I have no idea if the default wavelets here are appropriate for
# this particular examples. 
#
ynmwd &lt;- mwd(ynoise)
## Not run: plot(ynwd)
# [1] 2.020681 2.020681 2.020681 2.020681 2.020681 2.020681 2.020681
#
# Now do thresholding. We'll use the default arguments.
#
ynmwdT &lt;- threshold(ynmwd)
#
# And let's plot it
#
## Not run: plot(ynmwdT)
#
# Let us now see what the actual estimate looks like
#
ymwr &lt;- wr(ynmwdT)
#
# Here's the estimate... 
#
## Not run: ts.plot(ywr1)
</code></pre>

<hr>
<h2 id='threshold.wd'>Threshold (DWT) wavelet decomposition object</h2><span id='topic+threshold.wd'></span>

<h3>Description</h3>

<p>This function provides various ways to threshold a <code><a href="#topic+wd">wd</a></code> class object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
threshold(wd, levels = 3:(nlevelsWT(wd) - 1), type = "soft", policy = "sure",
        by.level = FALSE, value = 0, dev = madmad, boundary = FALSE, verbose = FALSE,
        return.threshold = FALSE, force.sure = FALSE, cvtol = 0.01,
	cvmaxits=500, Q = 0.05, OP1alpha = 0.05, 
        alpha = 0.5, beta = 1, C1 = NA, C2 = NA, C1.start = 100,
	al.check=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshold.wd_+3A_wd">wd</code></td>
<td>
<p>The DWT wavelet decomposition object that you wish to threshold.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_levels">levels</code></td>
<td>
<p>a vector of integers which determines which scale levels are thresholded in the decomposition. Each integer in the vector must refer to a valid level in the <code><a href="#topic+wd">wd</a></code> object supplied. This is usually any integer from 0 to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wd)-1 inclusive. Only the levels in this vector contribute to the computation of the threshold and its application.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_type">type</code></td>
<td>
<p>determines the type of thresholding this can be &quot;hard&quot; or &quot;soft&quot;.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_policy">policy</code></td>
<td>
<p>selects the technique by which the threshold value is selected. Each policy corresponds to a method in the literature. At present the different policies are: &quot;<code>universal</code>&quot;, &quot;<code>LSuniversal</code>&quot;, &quot;<code><a href="#topic+sure">sure</a></code>&quot;, &quot;<code>BayesThresh</code>&quot;, &quot;<code>cv</code>&quot;, &quot;<code>fdr</code>&quot;, &quot;<code>op1</code>&quot;, &quot;<code>op2</code>&quot;, &quot;<code>manual</code>&quot;, &quot;<code>mannum</code>&quot; and &quot;<code>probability</code>&quot;. The policies are described in detail below.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_by.level">by.level</code></td>
<td>
<p>If FALSE then a global threshold is computed on and applied to all scale levels defined in <code>levels</code>. If TRUE a threshold is computed and applied separately to each scale level.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_value">value</code></td>
<td>
<p>This argument conveys the user supplied threshold. If the <code>policy="manual"</code> then <code>value</code> is the actual threshold value; if the <code>policy="mannum"</code> then <code>value</code> conveys the total number of ordered coefficients kept (from the largest); if <code>policy="probability"</code> then <code>value</code> conveys the the user supplied quantile level.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_dev">dev</code></td>
<td>
<p>this argument supplies the function to be used to compute the spread of the absolute values coefficients. The function supplied must return a value of spread on the variance scale (i.e. not standard deviation) such as the <code>var()</code> function. A popular, useful and robust alternative is the <code><a href="#topic+madmad">madmad</a></code> function.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_boundary">boundary</code></td>
<td>
<p>If this argument is TRUE then the boundary bookeeping values are included for thresholding, otherwise they are not.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE then the function prints out informative messages as it progresses.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_return.threshold">return.threshold</code></td>
<td>
<p>If this option is TRUE then the actual <em>value</em> of the threshold is returned. If this option is FALSE then a thresholded version of the input is returned.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_force.sure">force.sure</code></td>
<td>
<p>If TRUE then the <code><a href="#topic+sure">sure</a></code> threshold is computed on a vector even when that vector is very sparse. If FALSE then the normal SUREshrink procedure is followed whereby the universal threshold is used for sparse vectors of coefficients.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_cvtol">cvtol</code></td>
<td>
<p>Parameter for the cross-validation <code>"cv"</code> policy.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_cvmaxits">cvmaxits</code></td>
<td>
<p>Maximum number of iterations allowed for the cross-validation <code>"cv"</code> policy.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_q">Q</code></td>
<td>
<p>Parameter for the false discovery rate <code>"fdr"</code> policy.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_op1alpha">OP1alpha</code></td>
<td>
<p>Parameter for Ogden and Parzen's first &quot;<code>op1</code>&quot; and <code>"op2"</code> policies.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_alpha">alpha</code></td>
<td>
<p>Parameter for BayesThresh <code>"BayesThresh"</code> policy.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_beta">beta</code></td>
<td>
<p>Parameter for BayesThresh <code>"BayesThresh"</code> policy.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_c1">C1</code></td>
<td>
<p>Parameter for BayesThresh <code>"BayesThresh"</code> policy.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_c2">C2</code></td>
<td>
<p>Parameter for BayesThresh <code>"BayesThresh"</code> policy.</p>
</td></tr> 
<tr><td><code id="threshold.wd_+3A_c1.start">C1.start</code></td>
<td>
<p>Parameter for BayesThresh <code>"BayesThresh"</code> policy.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_al.check">al.check</code></td>
<td>
<p>If TRUE then the function checks that the levels are
in ascending order. If they are not then this can be an
indication that the default level arguments are not appropriate
for this data set (<code>wd</code> object). However, a strange order
might be appropriate for some reason if deliberately set, so setting
this argument equal to FALSE turns off the check and warning.</p>
</td></tr>
<tr><td><code id="threshold.wd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function thresholds or shrinks wavelet coefficients stored in a <code><a href="#topic+wd">wd</a></code> object and returns the coefficients in a modified <code><a href="#topic+wd">wd</a></code> object. See the seminal papers by Donoho and Johnstone for explanations about thresholding. For a gentle introduction to wavelet thresholding (or shrinkage as it is sometimes called) see Nason and Silverman, 1994. For more details on each technique see the descriptions of each method below 
</p>
<p>The basic idea of thresholding is very simple. In a signal plus noise model the wavelet transform of signal is very sparse, the wavelet transform of noise is not (in particular, if the noise is iid Gaussian then so if the noise contained in the wavelet coefficients). Thus since the signal gets concentrated in the wavelet coefficients and the noise remains &quot;spread&quot; out it is &quot;easy&quot; to separate the signal from noise by keeping large coefficients (which correspond to signal) and delete the small ones (which correspond to noise). However, one has to have some idea of the noise level (computed using the dev option in threshold functions). If the noise level is very large then it is possible, as usual, that no signal &quot;sticks up&quot; above the noise. 
</p>
<p>There are many components to a successful thresholding procedure. Some components have a larger effect than others but the effect is not the same in all practical data situations. Here we give some rough practical guidance, although <em>you must refer to the papers below when using a particular technique.</em> <b>You cannot expect to get excellent performance on all signals unless you fully understand the rationale and limitations of each method below.</b> I am not in favour of the &quot;black-box&quot; approach. The thresholding functions of WaveThresh3 are not a black box: experience and judgement are required! 
</p>
<p>Some issues to watch for: 
</p>

<dl>
<dt>levels</dt><dd><p>The default of <code>levels = 3:(wd$nlevelsWT - 1)</code> for the <code>levels</code> option most certainly does not work globally for all data problems and situations. The level at which thresholding begins (i.e. the given threshold and finer scale wavelets) is called the <em>primary resolution</em> and is unique to a particular problem. In some ways choice of the primary resolution is very similar to choosing the bandwidth in kernel regression albeit on a logarithmic scale. See Hall and Patil, (1995) and Hall and Nason (1997) for more information. For each data problem you need to work out which is the best primary resolution. This can be done by gaining experience at what works best, or using prior knowledge. It is possible to &quot;automatically&quot; choose a &quot;best&quot; primary resolution using cross-validation (but not in WaveThresh). 
</p>
<p>Secondly the levels argument computes and applies the threshold at the levels specified in the <code>levels</code> argument. It does this for all the levels specified. Sometimes, in wavelet shrinkage, the threshold is computed using only the finest scale coefficients (or more precisely the estimate of the overall noise level). If you want your threshold variance estimate only to use the finest scale coefficients (e.g. with universal thresholding) then you will have to apply the <code>threshold.wd</code> function twice. Once (with levels set equal to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wd)-1 and with <code>return.threshold=TRUE</code> to return the threshold computed on the finest scale and then apply the threshold function with the manual option supplying the value of the previously computed threshold as the value options.
</p>
<p>Thirdly, if you apply wavelet shrinkage to a small data set then you need to ensure you've chosen the <code>levels</code> argument appropriately. For example,
if your original data was of length 8, then the associated <code>wd</code>
wavelet decomposition object will only have levels 0, 1 and 2. So, the default
argument for levels (starting at 3 and higher) will almost certainly
be wrong. The code now warns for these situations.
</p>
</dd> 
<dt>by.level</dt><dd><p>for a <code><a href="#topic+wd">wd</a></code> object which has come from data with noise that is correlated then you should have a threshold computed for each resolution level. See the paper by Johnstone and Silverman, 1997.</p>
</dd> 
</dl>



<h3>Value</h3>

<p>An object of class <code><a href="#topic+wd">wd</a></code>. This object contains the thresholded wavelet coefficients. Note that if the <code>return.threshold</code> option is set to TRUE then the threshold values will be returned rather than the thresholded object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason and others 1997 </p>


<h3>Note</h3>

<p>POLICIES 
This section gives a brief description of the different thresholding policies available. For further details see <em>the associated papers</em>. If there is no paper available then a small description is provided here. More than one policy may be good for problem, so experiment! They are arranged here in alphabetical order: 
</p>

<dl>
<dt>BayesThresh</dt><dd><p>See Abramovich, Silverman and Sapatinas, (1998). Contributed by Felix Abramovich and Fanis Sapatinas.</p>
</dd>
<dt>cv</dt><dd><p>See Nason, 1996.</p>
</dd>
<dt>fdr</dt><dd><p>See Abramovich and Benjamini, 1996. Contributed by Felix Abramovich.</p>
</dd>
<dt>LSuniversal</dt><dd><p>See Nason, von Sachs and Kroisandt, 1998. This is used for smoothing of a wavelet periodogram and shouldn't be used generally.</p>
</dd>
<dt>manual</dt><dd><p>specify a user supplied threshold using <code>value</code> to pass the value of the threshold. The <code>value</code> argument should be a vector. If it is of length 1 then it is replicated to be the same length as the <code>levels</code> vector, otherwise it is repeated as many times as is necessary to be the <code>levels</code> vector's length. In this way, different thresholds can be supplied for different levels. Note that the <code>by.level</code> option has no effect with this policy.</p>
</dd>
<dt>mannum</dt><dd><p>You decided how many of the largest (in absolute value) coefficients that you want to keep and supply this number in value.</p>
</dd>
<dt>op1</dt><dd><p>See Ogden and Parzen, 1996. Contributed by Todd Ogden.</p>
</dd>
<dt>op2</dt><dd><p>See Ogden and Parzen, 1996. Contributed by Todd Ogden.</p>
</dd>
<dt>probability</dt><dd><p>The <code>probability</code> policy works as follows. All coefficients that are smaller than the valueth quantile of the coefficients are set to zero. If <code>by.level</code> is false, then the quantile is computed for all coefficients in the levels specified by the &quot;levels&quot; vector; if <code>by.level</code> is true, then each level's quantile is estimated separately. The probability policy is pretty stupid - do not use it.</p>
</dd>
<dt>sure</dt><dd><p>See Donoho and Johnstone, 1994.</p>
</dd>
<dt>universal</dt><dd><p>See Donoho and Johnstone, 1995.</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Various code segments detailed above were kindly donated by Felix Abramovich, Theofanis Sapatinas and Todd Ogden. </p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+wr">wr</a></code>, <code><a href="#topic+wr.wd">wr.wd</a></code>, <code><a href="#topic+threshold">threshold</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y
## Not run: ts.plot(test.data)
#
# Generate some noisy data
#
ynoise &lt;- test.data + rnorm(512, sd=0.1)
#
# Plot it
#
## Not run: ts.plot(ynoise)
#
# Now take the discrete wavelet transform
# N.b. I have no idea if the default wavelets here are appropriate for
# this particular examples. 
#
ynwd &lt;- wd(ynoise)
## Not run: plot(ynwd)
#
# Now do thresholding. We'll use a universal policy, 
# and madmad deviance estimate on the finest
# coefficients and return the threshold. We'll also get it to be verbose
# so we can watch the process.
#
ynwdT1 &lt;- threshold(ynwd, policy="universal", dev=madmad,
		levels= nlevelsWT(ynwd)-1, return.threshold=TRUE,
	verbose=TRUE)
# threshold.wd:
# Argument checking
# Universal policy...All levels at once
# Global threshold is:  0.328410967430135 
#
# Why is this the threshold? Well in this case n=512 so sqrt(2*log(n)),
# the universal threshold,
# is equal to 3.53223. Since the noise is about 0.1 (because that's what
# we generated it to be) the threshold is about 0.353.
#
# Now let's apply this threshold to all levels in the noisy wavelet object
#
ynwdT1obj &lt;- threshold(ynwd, policy="manual", value=ynwdT1,
	levels=0:(nlevelsWT(ynwd)-1))
#
# And let's plot it
#
## Not run: plot(ynwdT1obj)
#
# You'll see that a lot of coefficients have been set to zero, or shrunk.
#
# Let's try a Bayesian examples this time!
#
ynwdT2obj &lt;- threshold(ynwd, policy="BayesThresh")
#
# And plot the coefficients
#
## Not run: plot(ynwdT2obj)
#
# Let us now see what the actual estimates look like
#
ywr1 &lt;- wr(ynwdT1obj)
ywr2 &lt;- wr(ynwdT2obj)
#
# Here's the estimate using universal thresholding
#
## Not run: ts.plot(ywr1)
#
# Here's the estimate using BayesThresh 
#
## Not run: ts.plot(ywr2)
</code></pre>

<hr>
<h2 id='threshold.wd3D'>Threshold 3D DWT object</h2><span id='topic+threshold.wd3D'></span>

<h3>Description</h3>

<p>This function provides various ways to threshold a <code><a href="#topic+wd3D">wd3D</a></code> class object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd3D'
threshold(wd3D, levels = 3:(nlevelsWT(wd3D) - 1), type = "hard", policy = 
        "universal", by.level = FALSE, value = 0, dev = var, verbose = FALSE, 
        return.threshold = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshold.wd3D_+3A_wd3d">wd3D</code></td>
<td>
<p>The 3D DWT wavelet decomposition object that you wish to threshold.</p>
</td></tr>
<tr><td><code id="threshold.wd3D_+3A_levels">levels</code></td>
<td>
<p>a vector of integers which determines which scale levels are thresholded in the decomposition. Each integer in the vector must refer to a valid level in the <code><a href="#topic+wd3D">wd3D</a></code> object supplied. This is usually any integer from 0 to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wd3D)-1 inclusive. Only the levels in this vector contribute to the computation of the threshold and its application. </p>
</td></tr>
<tr><td><code id="threshold.wd3D_+3A_type">type</code></td>
<td>
<p>determines the type of thresholding this can be &quot;<code>hard</code>&quot; or &quot;<code>soft</code>&quot;.</p>
</td></tr>
<tr><td><code id="threshold.wd3D_+3A_policy">policy</code></td>
<td>
<p>selects the technique by which the threshold value is selected. Each policy corresponds to a method in the literature. At present the different policies are: &quot;<code>universal</code>&quot; and &quot;<code>manual</code>&quot;. The policies are described in detail <code>below</code>.</p>
</td></tr> 
<tr><td><code id="threshold.wd3D_+3A_by.level">by.level</code></td>
<td>
<p>If FALSE then a global threshold is computed on and applied to all scale levels defined in <code>levels</code>. If TRUE a threshold is computed and applied separately to each scale level.</p>
</td></tr>
<tr><td><code id="threshold.wd3D_+3A_value">value</code></td>
<td>
<p>This argument conveys the user supplied threshold. If the <code>policy="manual"</code> then value is the actual threshold value.</p>
</td></tr> 
<tr><td><code id="threshold.wd3D_+3A_dev">dev</code></td>
<td>
<p>this argument supplies the function to be used to compute the spread of the absolute values coefficients. The function supplied must return a value of spread on the variance scale (i.e. not standard deviation) such as the <code>var()</code> function. A popular, useful and robust alternative is the <code><a href="#topic+madmad">madmad</a></code> function.</p>
</td></tr>
<tr><td><code id="threshold.wd3D_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE then the function prints out informative messages as it progresses.</p>
</td></tr>
<tr><td><code id="threshold.wd3D_+3A_return.threshold">return.threshold</code></td>
<td>
<p>If this option is TRUE then the actual <em>value</em> of the threshold is returned. If this option is FALSE then a thresholded version of the input is returned.</p>
</td></tr> 
<tr><td><code id="threshold.wd3D_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function thresholds or shrinks wavelet coefficients stored in a <code><a href="#topic+wd3D">wd3D</a></code> object and returns the coefficients in a modified <code><a href="#topic+wd3D">wd3D</a></code> object. See the seminal papers by Donoho and Johnstone for explanations about thresholding. For a gentle introduction to wavelet thresholding (or shrinkage as it is sometimes called) see Nason and Silverman, 1994. For more details on each technique see the descriptions of each method below 
</p>
<p>The basic idea of thresholding is very simple. In a signal plus noise model the wavelet transform of signal is very sparse, the wavelet transform of noise is not (in particular, if the noise is iid Gaussian then so if the noise contained in the wavelet coefficients). Thus since the signal gets concentrated in the wavelet coefficients and the noise remains &quot;spread&quot; out it is &quot;easy&quot; to separate the signal from noise by keeping large coefficients (which correspond to signal) and delete the small ones (which correspond to noise). However, one has to have some idea of the noise level (computed using the dev option in threshold functions). If the noise level is very large then it is possible, as usual, that no signal &quot;sticks up&quot; above the noise. 
</p>
<p>There are many components to a successful thresholding procedure. Some components have a larger effect than others but the effect is not the same in all practical data situations. Here we give some rough practical guidance, although <em>you must refer to the papers below when using a particular technique.</em> <b>You cannot expect to get excellent performance on all signals unless you fully understand the rationale and limitations of each method below.</b> I am not in favour of the &quot;black-box&quot; approach. The thresholding functions of WaveThresh3 are not a black box: experience and judgement are required! 
</p>
<p>Some issues to watch for: 
</p>

<dl>
<dt>levels</dt><dd><p>The default of <code>levels = 3:(wd$nlevelsWT - 1)</code> for the <code>levels</code> option most certainly does not work globally for all data problems and situations. The level at which thresholding begins (i.e. the given threshold and finer scale wavelets) is called the <em>primary resolution</em> and is unique to a particular problem. In some ways choice of the primary resolution is very similar to choosing the bandwidth in kernel regression albeit on a logarithmic scale. See Hall and Patil, (1995) and Hall and Nason (1997) for more information. For each data problem you need to work out which is the best primary resolution. This can be done by gaining experience at what works best, or using prior knowledge. It is possible to &quot;automatically&quot; choose a &quot;best&quot; primary resolution using cross-validation (but not in WaveThresh). 
</p>
<p>Secondly the levels argument computes and applies the threshold at the levels specified in the <code>levels</code> argument. It does this for all the levels specified. Sometimes, in wavelet shrinkage, the threshold is computed using only the finest scale coefficients (or more precisely the estimate of the overall noise level). If you want your threshold variance estimate only to use the finest scale coefficients (e.g. with universal thresholding) then you will have to apply the <code>threshold.wd</code> function twice. Once (with levels set equal to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wd)-1 and with <code>return.threshold=TRUE</code> to return the threshold computed on the finest scale and then apply the threshold function with the manual option supplying the value of the previously computed threshold as the value options. </p>
</dd>
<dt>by.level</dt><dd><p>for a <code><a href="#topic+wd">wd</a></code> object which has come from data with noise that is correlated then you should have a threshold computed for each resolution level. See the paper by Johnstone and Silverman, 1997.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code><a href="#topic+wd3D">wd3D</a></code>. This object contains the thresholded wavelet coefficients. Note that if the return.threshold option is set to TRUE then the threshold values will be returned rather than the thresholded object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 Copyright Guy Nason 1997.</p>


<h3>Note</h3>

<p>POLICIES
</p>
<p>This section gives a brief description of the different thresholding policies available. For further details <em>see the associated papers</em>. If there is no paper available then a small description is provided here. More than one policy may be good for problem, so experiment! They are arranged here in alphabetical order: 
</p>

<dl>
<dt>manual</dt><dd><p>specify a user supplied threshold using value to pass the value of the threshold. The value argument should be a vector. If it is of length 1 then it is replicated to be the same length as the <code>levels</code> vector, otherwise it is repeated as many times as is necessary to be the <code>levels</code> vector's length. In this way, different thresholds can be supplied for different levels. Note that the <code>by.level</code> option has no effect with this policy. </p>
</dd>
<dt>universal</dt><dd><p>See Donoho and Johnstone, 1995.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+threshold">threshold</a></code>, <code><a href="#topic+accessD.wd3D">accessD.wd3D</a></code>, <code><a href="#topic+print.wd3D">print.wd3D</a></code>, <code><a href="#topic+putD.wd3D">putD.wd3D</a></code>, <code><a href="#topic+putDwd3Dcheck">putDwd3Dcheck</a></code>, <code><a href="#topic+summary.wd3D">summary.wd3D</a></code>, <code><a href="#topic+threshold.wd3D">threshold.wd3D</a></code>, <code><a href="#topic+wd3D.object">wd3D.object</a></code>, <code><a href="#topic+wr3D">wr3D</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- array(rnorm(8*8*8), dim=c(8,8,8))
testwd3D &lt;- wd3D(test.data)
#
# Now let's threshold
#
testwd3DT &lt;- threshold(testwd3D, levels=1:2)
#
# That's it, one can apply wr3D now to reconstruct
# if you like!
#
</code></pre>

<hr>
<h2 id='threshold.wp'>Threshold wavelet packet decomposition object</h2><span id='topic+threshold.wp'></span>

<h3>Description</h3>

<p>This function provides various ways to threshold a <code><a href="#topic+wp">wp</a></code> class object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wp'
threshold(wp, levels = 3:(nlevelsWT(wp) - 1), dev = madmad,
	policy = "universal", value = 0, by.level = FALSE, type = "soft",
	verbose = FALSE, return.threshold = FALSE, cvtol = 0.01, cvnorm = l2norm, 
	add.history = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshold.wp_+3A_wp">wp</code></td>
<td>
<p>The wavelet packet object that you wish to threshold.</p>
</td></tr>
<tr><td><code id="threshold.wp_+3A_levels">levels</code></td>
<td>
<p>a vector of integers which determines which scale levels are thresholded in the decomposition. Each integer in the vector must refer to a valid level in the <code><a href="#topic+wd">wd</a></code> object supplied. This is usually any integer from 0 to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wp)-1 inclusive. Only the levels in this vector contribute to the computation of the threshold and its application. </p>
</td></tr>
<tr><td><code id="threshold.wp_+3A_policy">policy</code></td>
<td>
<p>selects the technique by which the threshold value is selected. Each policy corresponds to a method in the literature. At present the different policies are: &quot;<code>universal</code>&quot; and &quot;<code>manual</code>&quot;. The policies are described in detail <code>below</code>.</p>
</td></tr> 
<tr><td><code id="threshold.wp_+3A_by.level">by.level</code></td>
<td>
<p>If FALSE then a global threshold is computed on and applied to all scale levels defined in <code>levels</code>. If TRUE a threshold is computed and applied separately to each scale level.</p>
</td></tr>
<tr><td><code id="threshold.wp_+3A_value">value</code></td>
<td>
<p>This argument conveys the user supplied threshold. If the <code>policy="manual"</code> then value is the actual threshold value.</p>
</td></tr> 
<tr><td><code id="threshold.wp_+3A_dev">dev</code></td>
<td>
<p>this argument supplies the function to be used to compute the spread of the absolute values coefficients. The function supplied must return a value of spread on the variance scale (i.e. not standard deviation) such as the <code>var()</code> function. A popular, useful and robust alternative is the <code><a href="#topic+madmad">madmad</a></code> function.</p>
</td></tr>
<tr><td><code id="threshold.wp_+3A_type">type</code></td>
<td>
<p>determines the type of thresholding this can be &quot;<code>hard</code>&quot; or &quot;<code>soft</code>&quot;.</p>
</td></tr> 
<tr><td><code id="threshold.wp_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE then the function prints out informative messages as it progresses.</p>
</td></tr>
<tr><td><code id="threshold.wp_+3A_return.threshold">return.threshold</code></td>
<td>
<p>If this option is TRUE then the actual <em>value</em> of the threshold is returned. If this option is FALSE then a thresholded version of the input is returned.</p>
</td></tr> 
<tr><td><code id="threshold.wp_+3A_cvtol">cvtol</code></td>
<td>
<p>Not used, but reserved for future use</p>
</td></tr>
<tr><td><code id="threshold.wp_+3A_cvnorm">cvnorm</code></td>
<td>
<p>Not used, but reserved for future use</p>
</td></tr>
<tr><td><code id="threshold.wp_+3A_add.history">add.history</code></td>
<td>
<p>if <code>TRUE</code> then a history statement is added to the object for displaying.</p>
</td></tr> 
<tr><td><code id="threshold.wp_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function thresholds or shrinks wavelet coefficients stored in a <code><a href="#topic+wp">wp</a></code> object and returns the coefficients in a modified <code><a href="#topic+wp">wp</a></code> object. See the seminal papers by Donoho and Johnstone for explanations about thresholding. For a gentle introduction to wavelet thresholding (or shrinkage as it is sometimes called) see Nason and Silverman, 1994. For more details on each technique see the descriptions of each method below 
</p>
<p>The basic idea of thresholding is very simple. In a signal plus noise model the wavelet transform of signal is very sparse, the wavelet transform of noise is not (in particular, if the noise is iid Gaussian then so if the noise contained in the wavelet coefficients). Thus since the signal gets concentrated in the wavelet coefficients and the noise remains &quot;spread&quot; out it is &quot;easy&quot; to separate the signal from noise by keeping large coefficients (which correspond to signal) and delete the small ones (which correspond to noise). However, one has to have some idea of the noise level (computed using the dev option in threshold functions). If the noise level is very large then it is possible, as usual, that no signal &quot;sticks up&quot; above the noise. 
</p>
<p>There are many components to a successful thresholding procedure. Some components have a larger effect than others but the effect is not the same in all practical data situations. Here we give some rough practical guidance, although <em>you must refer to the papers below when using a particular technique.</em> <b>You cannot expect to get excellent performance on all signals unless you fully understand the rationale and limitations of each method below.</b> I am not in favour of the &quot;black-box&quot; approach. The thresholding functions of WaveThresh3 are not a black box: experience and judgement are required! 
</p>
<p>Some issues to watch for: 
</p>

<dl>
<dt>levels</dt><dd><p>The default of <code>levels = 3:(wd$nlevelsWT - 1)</code> for the <code>levels</code> option most certainly does not work globally for all data problems and situations. The level at which thresholding begins (i.e. the given threshold and finer scale wavelets) is called the <em>primary resolution</em> and is unique to a particular problem. In some ways choice of the primary resolution is very similar to choosing the bandwidth in kernel regression albeit on a logarithmic scale. See Hall and Patil, (1995) and Hall and Nason (1997) for more information. For each data problem you need to work out which is the best primary resolution. This can be done by gaining experience at what works best, or using prior knowledge. It is possible to &quot;automatically&quot; choose a &quot;best&quot; primary resolution using cross-validation (but not in WaveThresh). 
</p>
<p>Secondly the levels argument computes and applies the threshold at the levels specified in the <code>levels</code> argument. It does this for all the levels specified. Sometimes, in wavelet shrinkage, the threshold is computed using only the finest scale coefficients (or more precisely the estimate of the overall noise level). If you want your threshold variance estimate only to use the finest scale coefficients (e.g. with universal thresholding) then you will have to apply the <code>threshold.wp</code> function twice. Once (with levels set equal to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wd)-1 and with <code>return.threshold=TRUE</code> to return the threshold computed on the finest scale and then apply the threshold function with the manual option supplying the value of the previously computed threshold as the value options. </p>
</dd>
<dt>by.level</dt><dd><p>for a <code><a href="#topic+wd">wd</a></code> object which has come from data with noise that is correlated then you should have a threshold computed for each resolution level. See the paper by Johnstone and Silverman, 1997.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code><a href="#topic+wp">wp</a></code>. This object contains the thresholded wavelet coefficients. Note that if the <code>return.threshold</code> option is set to TRUE then the threshold values will be returned rather than the thresholded object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason and others1997.</p>


<h3>Note</h3>

<p>POLICIES
</p>
<p>This section gives a brief description of the different thresholding policies available. For further details <em>see the associated papers</em>. If there is no paper available then a small description is provided here. More than one policy may be good for problem, so experiment! They are arranged here in alphabetical order: 
</p>

<dl>
<dt>universal</dt><dd><p>See Donoho and Johnstone, 1995.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wp">wp</a></code>, <code><a href="#topic+wp.object">wp.object</a></code>, <code><a href="#topic+InvBasis">InvBasis</a></code>, <code><a href="#topic+MaNoVe">MaNoVe</a></code>, <code><a href="#topic+threshold">threshold</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y
## Not run: ts.plot(test.data)
#
# Generate some noisy data
#
ynoise &lt;- test.data + rnorm(512, sd=0.1)
#
# Plot it
#
## Not run: ts.plot(ynoise)
#
# Now take the discrete wavelet packet transform
# N.b. I have no idea if the default wavelets here are appropriate for
# this particular examples. 
#
ynwp &lt;- wp(ynoise)
#
# Now do thresholding. We'll use a universal policy, 
# and madmad deviance estimate on the finest
# coefficients and return the threshold. We'll also get it to be verbose
# so we can watch the process.
#
ynwpT1 &lt;- threshold(ynwp, policy="universal", dev=madmad)
#
# This is just another wp object. Is it sensible?
# Probably not as we have just thresholded the scaling function coefficients
# as well. So the threshold might be more sensibly computed on the wavelet
# coefficients at the finest scale and then this threshold applied to the
# whole wavelet tree??
</code></pre>

<hr>
<h2 id='threshold.wst'>Threshold (NDWT) packet-ordered non-decimated wavelet decomposition object</h2><span id='topic+threshold.wst'></span>

<h3>Description</h3>

<p>This function provides various ways to threshold a <code><a href="#topic+wst">wst</a></code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
threshold(wst, levels = 3:(nlevelsWT(wst) - 1), dev = madmad, policy = 
	"universal", value = 0, by.level = FALSE, type = "soft", verbose
	 = FALSE, return.threshold = FALSE, cvtol = 0.01, cvnorm = l2norm, 
	add.history = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshold.wst_+3A_wst">wst</code></td>
<td>
<p>The packet ordered non-decimated wavelet decomposition object that you wish to threshold.</p>
</td></tr>
<tr><td><code id="threshold.wst_+3A_levels">levels</code></td>
<td>
<p>a vector of integers which determines which scale levels are thresholded in the decomposition. Each integer in the vector must refer to a valid level in the <code><a href="#topic+wst">wst</a></code> object supplied. This is usually any integer from 0 to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wst)-1 inclusive. Only the levels in this vector contribute to the computation of the threshold and its application. </p>
</td></tr>
<tr><td><code id="threshold.wst_+3A_dev">dev</code></td>
<td>
<p>this argument supplies the function to be used to compute the spread of the absolute values coefficients. The function supplied must return a value of spread on the variance scale (i.e. not standard deviation) such as the <code>var()</code> function. A popular, useful and robust alternative is the <code><a href="#topic+madmad">madmad</a></code> function</p>
</td></tr>
<tr><td><code id="threshold.wst_+3A_policy">policy</code></td>
<td>
<p>selects the technique by which the threshold value is selected. Each policy corresponds to a method in the literature. At present the different policies are: &quot;<code>universal</code>&quot;, &quot;<code>LSuniversal</code>&quot;, &quot;<code><a href="#topic+sure">sure</a></code>&quot;, &quot;<code>cv</code>&quot;, &quot;<code>manual</code>&quot;, The policies are described in detail <code>below</code>. </p>
</td></tr>
<tr><td><code id="threshold.wst_+3A_value">value</code></td>
<td>
<p>This argument conveys the user supplied threshold. If the <code>policy="manual"</code> then value is the actual threshold value.</p>
</td></tr>
<tr><td><code id="threshold.wst_+3A_by.level">by.level</code></td>
<td>
<p>If FALSE then a global threshold is computed on and applied to all scale levels defined in <code>levels</code>. If TRUE a threshold is computed and applied separately to each scale level.</p>
</td></tr>
<tr><td><code id="threshold.wst_+3A_type">type</code></td>
<td>
<p>determines the type of thresholding this can be &quot;<code>hard</code>&quot; or &quot;<code>soft</code>&quot;.</p>
</td></tr>
<tr><td><code id="threshold.wst_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE then the function prints out informative messages as it progresses.</p>
</td></tr> 
<tr><td><code id="threshold.wst_+3A_return.threshold">return.threshold</code></td>
<td>
<p>If this option is TRUE then the actual <em>value</em> of the threshold is returned. If this option is FALSE then a thresholded version of the input is returned.</p>
</td></tr>
<tr><td><code id="threshold.wst_+3A_cvtol">cvtol</code></td>
<td>
<p>Parameter for the cross-validation &quot;<code>cv</code>&quot; policy.</p>
</td></tr> 
<tr><td><code id="threshold.wst_+3A_cvnorm">cvnorm</code></td>
<td>
<p>A function to compute the distance between two vectors. Two useful possibilities are <code><a href="#topic+l2norm">l2norm</a></code> and <code><a href="#topic+linfnorm">linfnorm</a></code>. Selection of different metrics causes the cross-validation denoising method to optimize for different criteria.</p>
</td></tr>
<tr><td><code id="threshold.wst_+3A_add.history">add.history</code></td>
<td>
<p>If <code>TRUE</code> then the thresholding operation details are add to the returned <code><a href="#topic+wst">wst</a></code> object. This can be useful when later tracing how an object has been treated.</p>
</td></tr> 
<tr><td><code id="threshold.wst_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function thresholds or shrinks wavelet coefficients stored in a <code><a href="#topic+wst">wst</a></code> object and returns the coefficients in a modified <code><a href="#topic+wst">wst</a></code> object. The thresholding step is an essential component of denoising using the <code>packet-ordered non-decimated wavelet transform</code>. If the denoising is carried out using the <code><a href="#topic+AvBasis">AvBasis</a></code> basis averaging technique then this software is an implementation of the Coifman and Donoho translation-invariant (TI) denoising. (Although it is the denoising technique which is translation invariant, not the packet ordered non-decimated transform, which is translation equivariant). However, the <code>threshold.wst</code> algorithm can be used in other denoising techniques in conjunction with the basis selection and inversion functions <code><a href="#topic+MaNoVe">MaNoVe</a></code> and <code><a href="#topic+InvBasis">InvBasis</a></code>.
</p>
<p>The basic idea of thresholding is very simple. In a signal plus noise model the wavelet transform of signal is very sparse, the wavelet transform of noise is not (in particular, if the noise is iid Gaussian then so if the noise contained in the wavelet coefficients). Thus since the signal gets concentrated in the wavelet coefficients and the noise remains &quot;spread&quot; out it is &quot;easy&quot; to separate the signal from noise by keeping large coefficients (which correspond to signal) and delete the small ones (which correspond to noise). However, one has to have some idea of the noise level (computed using the dev option in threshold functions). If the noise level is very large then it is possible, as usual, that no signal &quot;sticks up&quot; above the noise. 
</p>
<p>Many of the pragmatic comments for successful thresholding given in the help for <code><a href="#topic+threshold.wd">threshold.wd</a></code> hold true here: after all non-decimated wavelet transforms are merely organized collections of standard (decimated) discrete wavelet transforms. We reproduce some of the issues relevant to thresholding <code><a href="#topic+wst">wst</a></code> objects. 
</p>
<p>Some issues to watch for: 
</p>

<dl>
<dt>levels</dt><dd><p>The default of <code>levels = 3:(nlevelsWT(wd) - 1)</code> for the <code>levels</code> option most certainly does not work globally for all data problems and situations. The level at which thresholding begins (i.e. the given threshold and finer scale wavelets) is called the <code>primary resolution</code> and is unique to a particular problem. In some ways choice of the primary resolution is very similar to choosing the bandwidth in kernel regression albeit on a logarithmic scale. See Hall and Patil, (1995) and Hall and Nason (1997) for more information. For each data problem you need to work out which is the best primary resolution. This can be done by gaining experience at what works best, or using prior knowledge. It is possible to &quot;automatically&quot; choose a &quot;best&quot; primary resolution using cross-validation (but not yet in WaveThresh). 
</p>
<p>Secondly the levels argument computes and applies the threshold at the levels specified in the <code>levels</code> argument. It does this for all the levels specified. Sometimes, in wavelet shrinkage, the threshold is computed using only the finest scale coefficients (or more precisely the estimate of the overall noise level). If you want your threshold variance estimate only to use the finest scale coefficients (e.g. with universal thresholding) then you will have to apply the <code>threshold.wd</code> function twice. Once (with levels set equal to <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>(wd)-1 and with <code>return.threshold=TRUE</code> to return the threshold computed on the finest scale and then apply the threshold function with the <code>manual</code> option supplying the value of the previously computed threshold as the <code>value</code> options. </p>
</dd>
<dt>by.level</dt><dd><p>for a <code><a href="#topic+wd">wd</a></code> object which has come from data with noise that is correlated then you should have a threshold computed for each resolution level. See the paper by Johnstone and Silverman, 1997.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code><a href="#topic+wst">wst</a></code>. This object contains the thresholded wavelet coefficients. Note that if the <code>return.threshold</code> option is set to TRUE then the threshold values will be returned rather than the thresholded object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1997 </p>


<h3>Note</h3>

<p>This section gives a brief description of the different thresholding policies available. For further details <em>see the associated papers</em>. If there is no paper available then a small description is provided here. More than one policy may be good for problem, so experiment! Some of the policies here were specifically adapted to the This section gives a brief description of the different thresholding policies available. For further details see the associated papers. If there is no paper available then a small description is provided here. More than one policy may be good for problem, so experiment! Some of the policies here were specifically adapted to the <code><a href="#topic+wst.object">wst.object</a></code> but some weren't so beware. They are arranged here in alphabetical order:
</p>

<dl>
<dt>cv</dt><dd><p>See Nason, 1996.</p>
</dd>
<dt>LSuniversal</dt><dd><p>See Nason, von Sachs and Kroisandt, 1998. This is used for smoothing of a wavelet periodogram and shouldn't be used generally.</p>
</dd>
<dt>manual</dt><dd><p>specify a user supplied threshold using <code>value</code> to pass the value of the threshold. The <code>value</code> argument should be a vector. If it is of length 1 then it is replicated to be the same length as the <code>levels</code> vector, otherwise it is repeated as many times as is necessary to be the levels vector's length. In this way, different thresholds can be supplied for different levels. Note that the <code>by.level</code> option has no effect with this policy.</p>
</dd><dt>sure</dt><dd><p>See Donoho and Johnstone, 1994 and Johnstone and Silverman, 1997.</p>
</dd>
<dt>universal</dt><dd><p>See Donoho and Johnstone, 1995.</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+AvBasis">AvBasis</a></code>, <code><a href="#topic+AvBasis.wst">AvBasis.wst</a></code>, <code><a href="#topic+InvBasis">InvBasis</a></code>, <code><a href="#topic+InvBasis.wst">InvBasis.wst</a></code>, <code><a href="#topic+MaNoVe">MaNoVe</a></code>,<code><a href="#topic+MaNoVe.wst">MaNoVe.wst</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+threshold">threshold</a></code>. 
</p>

<hr>
<h2 id='TOgetthrda1'>Subsidiary routines for Ogden and Parzen's wavelet shrinkage methods</h2><span id='topic+TOgetthrda1'></span><span id='topic+TOgetthrda2'></span><span id='topic+TOkolsmi.chi2'></span><span id='topic+TOonebyone1'></span><span id='topic+TOonebyone2'></span><span id='topic+TOshrinkit'></span>

<h3>Description</h3>

<p>Corresponds to the wavelet thresholding routine developed by
Ogden and Parzen (1994) Data dependent wavelet thresholding in nonparametric
regression with change-point applications. <em>Tech Rep 176</em>,
University of South Carolina, Department of Statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOgetthrda1(dat, alpha)
TOgetthrda2(dat, alpha)
TOkolsmi.chi2(dat)
TOonebyone1(dat, alpha)
TOonebyone2(dat, alpha)
TOshrinkit(coeffs, thresh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TOgetthrda1_+3A_dat">dat</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="TOgetthrda1_+3A_alpha">alpha</code></td>
<td>
<p>a p-value, generally smoothing parameter</p>
</td></tr>
<tr><td><code id="TOgetthrda1_+3A_coeffs">coeffs</code></td>
<td>
<p>Some coefficients to be shrunk</p>
</td></tr>
<tr><td><code id="TOgetthrda1_+3A_thresh">thresh</code></td>
<td>
<p>a threshold</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not intended for direct use.
</p>


<h3>Value</h3>

<p>Various depending on the function
</p>


<h3>Author(s)</h3>

<p>Todd Ogden</p>


<h3>See Also</h3>

<p><code><a href="#topic+TOthreshda1">TOthreshda1</a></code>,<code><a href="#topic+TOthreshda2">TOthreshda2</a></code>,<code><a href="#topic+threshold">threshold</a></code></p>

<hr>
<h2 id='TOthreshda1'>Data analytic wavelet thresholding routine</h2><span id='topic+TOthreshda1'></span>

<h3>Description</h3>

<p>This function might be better called using the regular
<code><a href="#topic+threshold">threshold</a></code> function using the <code>op1</code> policy.
</p>
<p>Corresponds to the wavelet thresholding routine developed by
Ogden and Parzen (1994) Data dependent wavelet thresholding in nonparametric
regression with change-point applications. <em>Tech Rep 176</em>,
University of South Carolina, Department of Statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOthreshda1(ywd, alpha = 0.05, verbose = FALSE, return.threshold = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TOthreshda1_+3A_ywd">ywd</code></td>
<td>
<p>The <code><a href="#topic+wd.object">wd.object</a></code> that you wish to threshold.</p>
</td></tr>
<tr><td><code id="TOthreshda1_+3A_alpha">alpha</code></td>
<td>
<p>The smoothing parameter which is a p-value </p>
</td></tr>
<tr><td><code id="TOthreshda1_+3A_verbose">verbose</code></td>
<td>
<p>Whether messages get printed</p>
</td></tr>
<tr><td><code id="TOthreshda1_+3A_return.threshold">return.threshold</code></td>
<td>
<p>If TRUE then the threshold value gets returned
rather than the actual thresholded object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The TOthreshda1 method operates by testing the max of each set of squared       
wavelet coefficients to see if it behaves as the nth order statistic of   
a set of independent chi^2(1) r.v.'s.  If not, it is removed, and the    
max of the remaining subset is tested, continuing in this fashion until   
the max of the subset is judged not to be significant.  
</p>
<p>In this situation, the level of the hypothesis tests, alpha, has default  
value 0.05.  Note that the choice of alpha controls the smoothness of     
the resulting wavelet estimator &ndash; in general, a relatively large alpha   
makes it easier to include coefficients, resulting in a more wiggly       
estimate; a smaller alpha will make it more difficult to include          
coefficients, yielding smoother estimates.         
</p>


<h3>Value</h3>

<p>Returns the threshold value if <code>return.threshold==TRUE</code> otherwise
returns the shrunk set of wavelet coefficients.
</p>


<h3>Author(s)</h3>

<p>Todd Ogden</p>


<h3>See Also</h3>

<p><code><a href="#topic+threshold">threshold</a></code>,<code><a href="#topic+TOthreshda2">TOthreshda2</a></code>, <code><a href="#topic+wd">wd</a></code></p>

<hr>
<h2 id='TOthreshda2'>Data analytic wavelet thresholding routine</h2><span id='topic+TOthreshda2'></span>

<h3>Description</h3>

<p>This function might be better called using the regular
<code><a href="#topic+threshold">threshold</a></code> function using the <code>op2</code> policy.
</p>
<p>Corresponds to the wavelet thresholding routine developed by
Ogden and Parzen (1994) Data dependent wavelet thresholding in nonparametric
regression with change-point applications. <em>Tech Rep 176</em>,
University of South Carolina, Department of Statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOthreshda2(ywd, alpha = 0.05, verbose = FALSE, return.threshold = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TOthreshda2_+3A_ywd">ywd</code></td>
<td>
<p>The <code><a href="#topic+wd.object">wd.object</a></code> that you wish to threshold.</p>
</td></tr>
<tr><td><code id="TOthreshda2_+3A_alpha">alpha</code></td>
<td>
<p>The smoothing parameter which is a p-value </p>
</td></tr>
<tr><td><code id="TOthreshda2_+3A_verbose">verbose</code></td>
<td>
<p>Whether messages get printed</p>
</td></tr>
<tr><td><code id="TOthreshda2_+3A_return.threshold">return.threshold</code></td>
<td>
<p>If TRUE then the threshold value gets returned
rather than the actual thresholded object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The TOthreshda2 method operates in a similar fashion to
<code><a href="#topic+TOthreshda1">TOthreshda1</a></code> except that it takes the cumulative sum     
of squared coefficients, creating a sample &quot;Brownian bridge&quot; process,     
and then using the standard Kolmogorov-Smirnov statistic in testing.  
</p>
<p>In this situation, the level of the hypothesis tests, alpha, has default  
value 0.05.  Note that the choice of alpha controls the smoothness of     
the resulting wavelet estimator &ndash; in general, a relatively large alpha   
makes it easier to include coefficients, resulting in a more wiggly       
estimate; a smaller alpha will make it more difficult to include          
coefficients, yielding smoother estimates.         
</p>


<h3>Value</h3>

<p>Returns the threshold value if <code>return.threshold==TRUE</code> otherwise
returns the shrunk set of wavelet coefficients.
</p>


<h3>Author(s)</h3>

<p>Todd Ogden</p>


<h3>See Also</h3>

<p><code><a href="#topic+threshold">threshold</a></code>,<code><a href="#topic+TOthreshda1">TOthreshda1</a></code>, <code><a href="#topic+wd">wd</a></code></p>

<hr>
<h2 id='tpwd'>Tensor product 2D wavelet transform</h2><span id='topic+tpwd'></span>

<h3>Description</h3>

<p>Performs the tensor product 2D wavelet transform. This is a
related, but different, 2D wavelet transform compared to
<code><a href="#topic+imwd">imwd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpwd(image, filter.number = 10, family = "DaubLeAsymm", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpwd_+3A_image">image</code></td>
<td>
<p>The image  you wish to subject to the tensor product WT</p>
</td></tr>
<tr><td><code id="tpwd_+3A_filter.number">filter.number</code></td>
<td>
<p>The smoothness of wavelet, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="tpwd_+3A_family">family</code></td>
<td>
<p>The wavelet family you wish to use</p>
</td></tr>
<tr><td><code id="tpwd_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not you wish to print out informative messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transform works by first taking the regular 1D wavelet
transform across all columns in the image and storing these coefficients
line by line back into the image. Then to this new image we apply
the regular 1D wavelet transform across all rows in the image.
</p>
<p>Hence, the top-left coefficient is the smoothed version both horizontally
and vertically. The left-most row contains the image smoothed horiztonally,
but then detail picked up amongst the horizontal smooths vertically.
</p>
<p>Suggested by Rainer von Sachs.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>tpwd</code></td>
<td>
<p>A matrix with the same dimensions as the input <code>image</code>,
but containing the tensor product wavelet transform coefficients.</p>
</td></tr>
<tr><td><code>filter.number</code></td>
<td>
<p>The filter number used</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The wavelet family used</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of transform used</p>
</td></tr>
<tr><td><code>bc</code></td>
<td>
<p>The boundary conditions used</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>When the transform occurred</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>,<code><a href="#topic+tpwr">tpwr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lennon)
ltpwd &lt;- tpwd(lennon)
## Not run: image(log(abs(ltpwd$tpwd)), col=grey(seq(from=0, to=1, length=100)))
</code></pre>

<hr>
<h2 id='tpwr'>Inverse tensor product 2D wavelet transform.</h2><span id='topic+tpwr'></span>

<h3>Description</h3>

<p>Performs the inverse transform to <code><a href="#topic+tpwd">tpwd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpwr(tpwdobj, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpwr_+3A_tpwdobj">tpwdobj</code></td>
<td>
<p>An object which is a list which contains the items
indicated in the return value of <code><a href="#topic+tpwd">tpwd</a></code></p>
</td></tr>
<tr><td><code id="tpwr_+3A_verbose">verbose</code></td>
<td>
<p>Whether informative messages are printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the inverse transform to <code><a href="#topic+tpwd">tpwd</a></code>.
</p>


<h3>Value</h3>

<p>A matrix, or image, containing the inverse tensor product wavelet
transform of the image contained in the <code>tpwd</code> component of the
<code>tpwdobj</code> object.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwr">imwr</a></code>,<code><a href="#topic+tpwd">tpwd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lennon)
ltpwd &lt;- tpwd(lennon)
#
# now perform the inverse and compare to the original
#
ltpwr &lt;- tpwr(ltpwd)
sum((ltpwr - lennon)^2)
# [1] 9.22802e-10
</code></pre>

<hr>
<h2 id='uncompress'>Uncompress objects</h2><span id='topic+uncompress'></span>

<h3>Description</h3>

<p>Uncompress objects.
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist. For the <code><a href="#topic+imwdc.object">imwdc.object</a></code> class object this
generic function uses <code><a href="#topic+uncompress.imwdc">uncompress.imwdc</a></code>.
There is a default uncompression method:
<code><a href="#topic+uncompress.default">uncompress.default</a></code> that works on vectors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncompress(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uncompress_+3A_...">...</code></td>
<td>
<p>See individual help pages for details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See individual method help pages for operation and examples
</p>


<h3>Value</h3>

<p>A uncompressed version of the input. 
</p>


<h3>RELEASE</h3>

<p>Version 2.0 Copyright Guy Nason 1993</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncompress.default">uncompress.default</a></code>, <code><a href="#topic+uncompress.imwdc">uncompress.imwdc</a></code>, <code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+imwd.object">imwd.object</a></code>, <code><a href="#topic+imwdc.object">imwdc.object</a></code>, <code><a href="#topic+threshold.imwd">threshold.imwd</a></code> 
</p>

<hr>
<h2 id='uncompress.default'>Undo zero run-length encoding for a vector.</h2><span id='topic+uncompress.default'></span>

<h3>Description</h3>

<p>This function inverts the action carried out by the
<code><a href="#topic+compress.default">compress.default</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
uncompress(v, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uncompress.default_+3A_v">v</code></td>
<td>
<p>The object to uncompress</p>
</td></tr>
<tr><td><code id="uncompress.default_+3A_verbose">verbose</code></td>
<td>
<p>Print an informative message whilst executing</p>
</td></tr>
<tr><td><code id="uncompress.default_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse of <code><a href="#topic+compress.default">compress.default</a></code>
</p>


<h3>Value</h3>

<p>The uncompressed, reinstated, vector.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+compress.default">compress.default</a></code>, <code><a href="#topic+uncompress">uncompress</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>uncompress(compress(c(1, rep(0,99), 1)))
#[1] 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
#[38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
#[75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
</code></pre>

<hr>
<h2 id='uncompress.imwdc'>Uncompress an imwdc class object</h2><span id='topic+uncompress.imwdc'></span>

<h3>Description</h3>

<p>An <code><a href="#topic+imwdc.object">imwdc.object</a></code> is a run-length encoded object, essentially
has all zeroes removed and only non-zero elements stored. This function
undoes the compression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwdc'
uncompress(x, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uncompress.imwdc_+3A_x">x</code></td>
<td>
<p>The object to uncompress</p>
</td></tr>
<tr><td><code id="uncompress.imwdc_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE then print out messages</p>
</td></tr>
<tr><td><code id="uncompress.imwdc_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all, inverse of <code><a href="#topic+compress.imwd">compress.imwd</a></code> function.
</p>


<h3>Value</h3>

<p>The uncompressed <code><a href="#topic+imwd.object">imwd.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+compress.imwd">compress.imwd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lennon)
#
# Do 2D wavelet transform on lennon image
#
lwd &lt;- imwd(lennon)
#
# Do threshold the wavelet coefficients, a lot of zeroes are present
#
lmdT &lt;- threshold(lwd)
#
# What is the class of the thresholded object?
#
class(lmdT)
#[1] "imwdc"
#
# note that the coefficients are stored efficiently in the imwdc class object
#
uncompress(lmdT)
#Class 'imwd' : Discrete Image Wavelet Transform Object:
#~~~~  : List with 30 components with names
#nlevelsWT fl.dbase filter w0Lconstant bc type w0L1 w0L2 w0L3 w1L1 w1L2
#w1L3 w2L1 w2L2 w2L3 w3L1 w3L2 w3L3 w4L1 w4L2 w4L3 w5L1 w5L2 w5L3 w6L1
#w6L2 w6L3 w7L1 w7L2 w7L3
#
#$ wNLx are LONG coefficient vectors !
#
#summary(.):
#----------
#UNcompressed image wavelet decomposition structure
#Levels:  8
#Original image was 256 x 256  pixels.
#Filter was:  Daub cmpct on least asymm N=10
#Boundary handling:  periodic
</code></pre>

<hr>
<h2 id='wavegrow'>Interactive graphical tool to grow a wavelet synthesis</h2><span id='topic+wavegrow'></span>

<h3>Description</h3>

<p>Use mouse to select which wavelets to enter a wavelet synthesis,
continually plot the reconstruction and the wavelet tableaux.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wavegrow(n = 64, filter.number = 10, family = "DaubLeAsymm", type = "wavelet",
    random = TRUE, read.value = TRUE, restart = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wavegrow_+3A_n">n</code></td>
<td>
<p>Number of points in the decomposition</p>
</td></tr>
<tr><td><code id="wavegrow_+3A_filter.number">filter.number</code></td>
<td>
<p>The wavelet filter.number to use,
see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="wavegrow_+3A_family">family</code></td>
<td>
<p>The wavelet family to use in the reconstruction</p>
</td></tr>
<tr><td><code id="wavegrow_+3A_type">type</code></td>
<td>
<p>If <code>"wavelet"</code> then carry out the regular wavelet
transform, otherwise if <code>"station"</code> do the nondecimated
transform.</p>
</td></tr>
<tr><td><code id="wavegrow_+3A_random">random</code></td>
<td>
<p>If <code>TRUE</code> then iid Gaussian coefficients are inserted
into the tableaux. If <code>FALSE</code> and <code>read.value=TRUE</code>
then the user is promoted for a value, otherwise the value
1 is inserted into the tableaux at the selected point.</p>
</td></tr>
<tr><td><code id="wavegrow_+3A_read.value">read.value</code></td>
<td>
<p>If <code>TRUE</code> then a value is read and used to insert
that size of wavelet coefficient at the selected point. If <code>FALSE</code>
then a coefficient of size 1 is inserted.</p>
</td></tr>
<tr><td><code id="wavegrow_+3A_restart">restart</code></td>
<td>
<p>If <code>TRUE</code> then after a coefficient has been inserted,
and plots done, the next selection causes all the coefficients
to be reset to zero and a single coefficient inserted. This actually
has the overall action of being able to select a coefficient
location and view the size and shape of the wavelet produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can perform many slightly different actions. However,
the basic idea is for a tableaux of wavelet coefficients to be displayed
in one graphics window, and the reconstruction of those coefficients
to be displayed in another graphics window.
</p>
<p>Hence, two graphics windows, capable of plotting and mouse interaction
(e.g. X11, windows or quartz) with the locator function, are required to
be active.
</p>
<p>When the function starts up an initial random tableaux is displayed and
its reconstruction.
</p>
<p>The next step is for the user to select coefficients on the tableaux.
What happens next specifically depends on the arguments above. By default
selecting a coefficient causes that coefficient scale and location to
be identified, then a random sample is taken from a N(0,1) random variable
and assigned to that coefficient. Hence, the tableaux is updated, the
reconstruction with the new coefficient computed and both are plotted.
</p>
<p>If <code>type="wavelet"</code> is used then decimated wavelets are used,
if <code>type="station"</code> then the time-ordered non-decimated wavelets
are used.
</p>
<p>If <code>random=FALSE</code> then new values for the coefficients are either
selected (by asking the user for input) if <code>read.value=TRUE</code> or
the value of 1 is input. 
</p>
<p>If <code>restart=TRUE</code> then the function merely displays the wavelet
associated with the selected coefficient. Hence, this option is useful
to demonstrate to people how wavelets from different points of the
tableaux have different sizes, scales and locations.
</p>
<p>If the mouse locator function is exited (this can be a right-click in some
windowing systems, or pressing ESCAPE) then the function asks whether the
user wishes to continue. If not then the function returns the current
tableux. Hence, this function can be useful for users to build their
own tabeleaux.
</p>


<h3>Value</h3>

<p>The final tableaux.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code></p>

<hr>
<h2 id='WaveletCV'>Wavelet cross-validation</h2><span id='topic+WaveletCV'></span>

<h3>Description</h3>

<p>Two-fold wavelet shrinkage cross-validation (there is a faster C based
version <code><a href="#topic+CWCV">CWCV</a></code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WaveletCV(ynoise, x = 1:length(ynoise), filter.number = 10, family = 
	"DaubLeAsymm", thresh.type = "soft", tol = 0.01, verbose = 0, 
	plot.it = TRUE, ll=3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WaveletCV_+3A_ynoise">ynoise</code></td>
<td>
<p>A vector of dyadic (power of two) length that contains the
noisy data that you wish to apply wavelet shrinkage by
cross-validation to.</p>
</td></tr>
<tr><td><code id="WaveletCV_+3A_x">x</code></td>
<td>
<p>This function is capable of producing informative plots.
It can be useful to supply the x values corresponding to the
<code>ynoise</code> values.
Further this argument is returned by this function which can
be useful for later processors.</p>
</td></tr>
<tr><td><code id="WaveletCV_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to perform wavelet shrinkage by cross-validation.</p>
</td></tr>
<tr><td><code id="WaveletCV_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="WaveletCV_+3A_thresh.type">thresh.type</code></td>
<td>
<p>this option specifies the thresholding type which can be &quot;hard&quot; or &quot;soft&quot;.</p>
</td></tr>
<tr><td><code id="WaveletCV_+3A_tol">tol</code></td>
<td>
<p>this specifies the convergence tolerance for the cross-validation optimization routine (a golden section search).</p>
</td></tr>
<tr><td><code id="WaveletCV_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the computations progress. Such messages are generally annoying so it is turned off by default.</p>
</td></tr>
<tr><td><code id="WaveletCV_+3A_plot.it">plot.it</code></td>
<td>
<p>If this is TRUE then plots of the universal threshold (used to obtain an upper bound on the cross-validation threshold) reconstruction and the resulting cross-validation estimate are produced.</p>
</td></tr>
<tr><td><code id="WaveletCV_+3A_ll">ll</code></td>
<td>
<p>The primary resolution that you wish to assume. No wavelet coefficients that are on coarser scales than ll will be thresholded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Note:</b> a faster C based implementation of this function called
<code><a href="#topic+CWCV">CWCV</a></code> is available.
It takes the same arguments (although it has one extra minor argument) and returns the same values.
</p>
<p>Compute the two-fold cross-validated wavelet shrunk estimate given the noisy data ynoise according to the description given in Nason, 1996.
</p>
<p>You must specify a primary resolution given by <code>ll</code>. This must be specified individually on each data set and can itself be estimated using cross-validation (although I haven't written the code to do this).
</p>
<p>Note. The two-fold cross-validation method performs very badly if the input data is correlated. In this case I would advise using other methods.
</p>


<h3>Value</h3>

<p>A list with the following components
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>This is just the x that was input. It gets passed through more or less for convenience for the user.</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>A copy of the input ynoise noisy data.</p>
</td></tr>
<tr><td><code>xvwr</code></td>
<td>
<p>The cross-validated wavelet shrunk estimate.</p>
</td></tr>
<tr><td><code>yuvtwr</code></td>
<td>
<p>The universal thresholded version (note this is merely a starting point for the cross-validation algorithm. It should not be taken seriously as an estimate. In particular its estimate of variance is likely to be inflated.)</p>
</td></tr>
<tr><td><code>xvthresh</code></td>
<td>
<p>The cross-validated threshold</p>
</td></tr>
<tr><td><code>uvthresh</code></td>
<td>
<p>The universal threshold (again, don't take this value too seriously. You might get better performance using the threshold function directly with specialist options.</p>
</td></tr>
<tr><td><code>xvdof</code></td>
<td>
<p>The number of non-zero coefficients in the cross-validated shrunk wavelet object (which is not returned).</p>
</td></tr>
<tr><td><code>uvdof</code></td>
<td>
<p>The number of non-zero coefficients in the universal threshold shrunk wavelet object (which also is not returned)</p>
</td></tr>
<tr><td><code>xkeep</code></td>
<td>
<p>always returns NULL!</p>
</td></tr>
<tr><td><code>fkeep</code></td>
<td>
<p>always returns NULL!</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+CWCV">CWCV</a></code>,<code><a href="#topic+Crsswav">Crsswav</a></code>,<code><a href="#topic+rsswav">rsswav</a></code>,<code><a href="#topic+threshold.wd">threshold.wd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# This function is best used via the policy="cv" option in
# the threshold.wd function.
# See examples there.
#
</code></pre>

<hr>
<h2 id='wd'>Wavelet transform (decomposition).</h2><span id='topic+wd'></span>

<h3>Description</h3>

<p>This function can perform two types of discrete wavelet transform (DWT). The standard DWT computes the DWT according to Mallat's pyramidal algorithm (Mallat, 1989) (it also has the ability to compute the <em>wavelets on the interval</em> transform of Cohen, Daubechies and Vial, 1993).
</p>
<p>The non-decimated DWT (NDWT) contains all possible shifted versions of the DWT. The order of computation of the DWT is O(n), and it is O(n log n) for the NDWT if n is the number of data points. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wd(data, filter.number=10, family="DaubLeAsymm", type="wavelet",
bc="periodic", verbose=FALSE, min.scale=0, precond=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wd_+3A_data">data</code></td>
<td>
<p>A vector containing the data you wish to decompose. The length of this vector must be a power of 2.</p>
</td></tr>
<tr><td><code id="wd_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments. 
</p>
<p>For the &ldquo;wavelets on the interval&rdquo; (<code>bc="interval"</code>) transform the filter number ranges from 1 to 8. See the table of filter coefficients indexed after the reference to Cohen, Daubechies and Vial, 1993.</p>
</td></tr>
<tr><td><code id="wd_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. Two popular options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot; but see the help for <code><a href="#topic+filter.select">filter.select</a></code> for more possibilities.
</p>
<p>This argument is ignored for the &ldquo;wavelets on the interval&rdquo; transform (<code>bc="interval"</code>).
</p>
<p>Note that, as of version 4.6.1 you can use the Lina-Mayrand complex-valued
wavelets.
</p>
</td></tr> 
<tr><td><code id="wd_+3A_type">type</code></td>
<td>
<p>specifies the type of wavelet transform. This can be &quot;wavelet&quot; (default) in which case the standard DWT is performed (as in previous releases of WaveThresh). If type is &quot;station&quot; then the non-decimated DWT is performed. At present, only periodic boundary conditions can be used with the non-decimated wavelet transform.</p>
</td></tr>
<tr><td><code id="wd_+3A_bc">bc</code></td>
<td>
<p>specifies the boundary handling. If <code>bc="periodic"</code> the default, then the function you decompose is assumed to be periodic on it's interval of definition, if <code>bc="symmetric"</code> then the function beyond its boundaries is assumed to be a symmetric reflection of the function in the boundary. The symmetric option was the implicit default in releases prior to 2.2. If <code>bc=="interval"</code> then the &ldquo;wavelets on the interval algorithm&rdquo; due to Cohen, Daubechies and Vial is used. (The <code>WaveThresh</code> implementation of the &ldquo;wavelets on the interval transform&rdquo; was coded by Piotr Fryzlewicz, Department of Mathematics, Wroclaw University of Technology, Poland; this code was largely based on code written by Markus Monnerjahn, RHRK, Universitat Kaiserslautern; integration into <code>WaveThresh</code> by <code>GPN</code>. See the nice project report by Piotr on this piece of code). </p>
</td></tr>
<tr><td><code id="wd_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the computations progress. Such messages are generally annoying so it is turned off by default.</p>
</td></tr>
<tr><td><code id="wd_+3A_min.scale">min.scale</code></td>
<td>
<p>Only used for the &ldquo;wavelets on the interval transform&rdquo;. The wavelet algorithm starts with fine scale data and iteratively coarsens it. This argument controls how many times this iterative procedure is applied by specifying at which scale level to stop decomposiing. </p>
</td></tr>
<tr><td><code id="wd_+3A_precond">precond</code></td>
<td>
<p>Only used for the &ldquo;wavelets on the interval transform&rdquo;. This argument specifies whether preconditioning is applied (called prefiltering in Cohen, Daubechies and Vial, 1993.) Preconditioning ensures that sequences like 1,1,1,1 or 1,2,3,4 map to zero high pass coefficients. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If type==&quot;wavelet&quot; then the code implements Mallat's pyramid algorithm (Mallat 1989). For more details of this implementation see Nason and Silverman, 1994. Essentially it works like this: you start off with some data cm, which is a real vector of length <code class="reqn">2^m</code>, say. 
</p>
<p>Then from this you obtain two vectors of length <code class="reqn">2^(m-1)</code>.
One of these is a set of smoothed data, c(m-1), say. This looks like a smoothed version of cm. The other is a vector, d(m-1), say. This corresponds to the detail removed in smoothing cm to c(m-1). More precisely, they are the coefficients of the wavelet expansion corresponding to the highest resolution wavelets in the expansion. Similarly, c(m-2) and d(m-2) are obtained from c(m-1), etc. until you reach c0 and d0. 
</p>
<p>All levels of smoothed data are stacked into a single vector for memory efficiency and ease of transport across the SPlus-C interface. 
</p>
<p>The smoothing is performed directly by convolution with the wavelet filter
(<code>filter.select(n)$H</code>, essentially low- pass filtering), and then dyadic decimation (selecting every other datum, see Vaidyanathan (1990)). The detail extraction is performed by the mirror filter of H, which we call G and is a bandpass filter. G and H are also known quadrature mirror filters. 
</p>
<p>There are now two methods of handling &quot;boundary problems&quot;. If you know that your function is periodic (on it's interval) then use the bc=&quot;periodic&quot; option, if you think that the function is symmetric reflection about each boundary then use bc=&quot;symmetric&quot;. You might also consider using the &quot;wavelets on the interval&quot; transform which is suitable for data arising from a function that is known to be defined on some compact interval, see Cohen, Daubechies, and Vial, 1993. If you don't know then it is wise to experiment with both methods, in any case, if you don't have very much data don't infer too much about your decomposition! If you have loads of data then don't infer too much about the boundaries. It can be easier to interpret the wavelet coefficients from a bc=&quot;periodic&quot; decomposition, so that is now the default. Numerical Recipes implements some of the wavelets code, in particular we have compared our code to &quot;wt1&quot; and &quot;daub4&quot; on page 595. We are pleased to announce that our code gives the same answers! The only difference that you might notice is that one of the coefficients, at the beginning or end of the decomposition, always appears in the &quot;wrong&quot; place. This is not so, when you assume periodic boundaries you can imagine the function defined on a circle and you can basically place the coefficient at the beginning or the end (because there is no beginning or end, as it were). 
</p>
<p>The non-deciated DWT contains all circular shifts of the standard DWT. Naively imagine that you do the standard DWT on some data using the Haar wavelets. Coefficients 1 and 2 are added and difference, and also coefficients 3 and 4; 5 and 6 etc. If there is a discontinuity between 1 and 2 then you will pick it up within the transform. If it is between 2 and 3 you will loose it. So it would be nice to do the standard DWT using 2 and 3; 4 and 5 etc. In other words, pick up the data and rotate it by one position and you get another transform. You can do this in one transform that also does more shifts at lower resolution levels. There are a number of points to note about this transform. 
</p>
<p>Note that a time-ordered non-decimated wavelet transform object may be converted into a <code>packet-ordered non-decimated wavelet transform</code> object (and vice versa) by using the <code><a href="#topic+convert">convert</a></code> function. 
</p>
<p>The NDWT is translation equivariant. The DWT is neither translation invariant or equivariant. The standard DWT is orthogonal, the non-decimated transform is most definitely not. This has the added disadvantage that non-decimated wavelet coefficients, even if you supply independent normal noise. This is unlike the standard DWT where the coefficients are independent (normal noise). 
</p>
<p>You might like to consider growing wavelet syntheses using the
<code><a href="#topic+wavegrow">wavegrow</a></code> function.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wd">wd</a></code>.
</p>
<p>For boundary conditions apart from <code>bc="interval"</code> this object is a list with the following components. 
</p>
<table role = "presentation">
<tr><td><code>C</code></td>
<td>
<p>Vector of sets of successively smoothed data. The pyramid structure of Mallat is stacked so that it fits into a vector. The function <code><a href="#topic+accessC">accessC</a></code> should be used to extract a set for a particular level.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Vector of sets of wavelet coefficients at different resolution levels. Again, Mallat's pyramid structure is stacked into a vector. The function <code><a href="#topic+accessD">accessD</a></code> should be used to extract the coefficients for a particular resolution level.</p>
</td></tr> 
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of resolution levels. This depends on the length of the data vector. If <code>length(data)=2^m</code>, then there will be m resolution levels. This means there will be m levels of wavelet coefficients (indexed 0,1,2,...,(m-1)), and m+1 levels of smoothed data (indexed 0,1,2,...,m). </p>
</td></tr>
<tr><td><code>fl.dbase</code></td>
<td>
<p>There is more information stored in the C and D than is described above. In the decomposition &ldquo;extra&rdquo; coefficients are generated that help take care of the boundary effects, this database lists where these start and finish, so the &quot;true&quot; data can be extracted.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>A list containing information about the filter type: Contains the string &quot;wavelet&quot; or &quot;station&quot; depending on which type of transform was performed. </p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>The date the transform was performed.</p>
</td></tr>
<tr><td><code>bc</code></td>
<td>
<p>How the boundaries were handled.</p>
</td></tr>
</table>
<p>If the &ldquo;wavelets on the interval&rdquo; transform is used (i.e. <code>bc="interval"</code>) then the internal structure of the wd object is changed as follows. 
</p>

<ul>
<li><p>The coefficient vectors C and D have been replaced by a single vector <code>transformed.vector</code>. The new single vector contains just the transformed coefficients: i.e. the wavelet coefficients down to a particular scale (determined by <code>min.scale</code> above). The scaling function coefficients are stored first in the array (there will be <code>2^min.scale</code> of them. Then the wavelet coefficients are stored as consecutive vectors coarsest to finest of length <code>2^min.scale</code>, <code>2^(min.scale+1)</code> up to a vector which is half of the length of the original data.)
</p>
<p>In any case the user is recommended to use the functions <code><a href="#topic+accessC">accessC</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+putC">putC</a></code> and <code><a href="#topic+putD">putD</a></code> to access coefficients from the <code><a href="#topic+wd">wd</a></code> object. 
</p>
</li>
<li><p>The extra component <code>current.scale</code> records to which level the transform has been done (usually this is <code>min.scale</code> as specified in the arguments).
</p>
</li>
<li><p>The extra component <code>filters.used</code> is a vector of integers that record which filter index was used as each level of the decomposition. At coarser scales sometimes a wavelet with shorter support is needed. 
</p>
</li>
<li><p>The extra logical component <code>preconditioned</code> specifies whether preconditioning was turned on or off.
</p>
</li>
<li><p>The component <code>fl.dbase</code> is still present but only contains data corresponding to the storage of the coefficients that are present in <code>transformed.vector</code>. In particular, since only one scale of the father wavelet coefficients is stored the component <code>first.last.c</code> of <code>fl.dbase</code> is now a three-vector containing the indices of the first and last entries of the father wavelet coefficients and the offset of where they are stored in <code>transformed.vector</code>. Likewise, the component <code>first.last.d</code> of <code>fl.dbase</code> is still a matrix but there are now only rows for each scale level in the <code>transformed.vector</code> (something like <code>nlevelsWT(wd)-wd$current.scale</code>). 
</p>
</li>
<li><p>The <code>filter</code> coefficient is also slightly different as the filter coefficients are no longer stored here (since they are hard coded into the wavelets on the interval transform.) 
</p>
</li></ul>



<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 Integration of &ldquo;wavelets on the interval&rdquo; code by Piotr Fryzlewicz and Markus Monnerjahn was at Version 3.9.6, 1999. </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd.int">wd.int</a></code>, <code><a href="#topic+wr">wr</a></code>, <code><a href="#topic+wr.int">wr.int</a></code>, <code><a href="#topic+wr.wd">wr.wd</a></code>, <code><a href="#topic+accessC">accessC</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+putC">putC</a></code>, <code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+plot.wd">plot.wd</a></code>, <code><a href="#topic+threshold">threshold</a></code>, <code><a href="#topic+wavegrow">wavegrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
test.data &lt;- example.1()$y
## Not run: ts.plot(test.data)
#
# Decompose test.data and plot the wavelet coefficients
#
wds &lt;- wd(test.data)
## Not run: plot(wds)
#
# Now do the time-ordered non-decimated wavelet transform of the same thing
#
wdS &lt;- wd(test.data, type="station")
## Not run: plot(wdS)
#
# Next examples
# ------------
# The chirp signal is also another good examples to use.
#
# Generate some test data
#
test.chirp &lt;- simchirp()$y
## Not run: ts.plot(test.chirp, main="Simulated chirp signal")
#
# Now let's do the time-ordered non-decimated wavelet transform.
# For a change let's use Daubechies least-asymmetric phase wavelet with 8
# vanishing moments (a totally arbitrary choice, please don't read
# anything into it).
#
chirpwdS &lt;- wd(test.chirp, filter.number=8, family="DaubLeAsymm", type="station")
## Not run: plot(chirpwdS, main="TOND WT of Chirp signal")
#
# Note that the coefficients in this plot are exactly the same as those
# generated by the packet-ordered non-decimated wavelet transform
# except that they are in a different order on each resolution level.
# See Nason, Sapatinas and Sawczenko, 1998
# for further information.
</code></pre>

<hr>
<h2 id='wd.dh'>Compute specialized wavelet transform for density estimation</h2><span id='topic+wd.dh'></span>

<h3>Description</h3>

<p>Computes the discrete wavelet transform, but with zero boundary conditions
especially for density estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wd.dh(data, filter.number = 10, family = "DaubLeAsymm", type = "wavelet",
    bc = "periodic", firstk = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wd.dh_+3A_data">data</code></td>
<td>
<p>The father wavelet coefficients</p>
</td></tr>
<tr><td><code id="wd.dh_+3A_filter.number">filter.number</code></td>
<td>
<p>The smoothness of the underlying wavelet to use,	
see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="wd.dh_+3A_family">family</code></td>
<td>
<p>The wavelet family to use, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="wd.dh_+3A_type">type</code></td>
<td>
<p>The type of wavelet to use</p>
</td></tr>
<tr><td><code id="wd.dh_+3A_bc">bc</code></td>
<td>
<p>Type of boundarie conditions</p>
</td></tr>
<tr><td><code id="wd.dh_+3A_firstk">firstk</code></td>
<td>
<p>A parameter that originates from <code><a href="#topic+denproj">denproj</a></code></p>
</td></tr>
<tr><td><code id="wd.dh_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then informative messages are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a subsidiary routine, not intended for direct user use for density
estimation. The main routines for wavelet density estimation are
<code><a href="#topic+denwd">denwd</a></code>, <code><a href="#topic+denproj">denproj</a></code>, <code><a href="#topic+denwr">denwr</a></code>.
</p>
<p>The input to this function should be projected father wavelet coefficients
as computed by <code><a href="#topic+denproj">denproj</a></code>, but usually supplied to this function
by <code><a href="#topic+denwd">denwd</a></code>.
</p>
<p>Thresholding should be carried out by the user independently of these
functions.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wd">wd</a></code>, but assumed on the basis of
zero boundary conditions.
</p>


<h3>Author(s)</h3>

<p>David Herrick</p>


<h3>See Also</h3>

<p><code><a href="#topic+denproj">denproj</a></code>,
<code><a href="#topic+denwd">denwd</a></code></p>

<hr>
<h2 id='wd.int'>Computes &quot;wavelets on the interval&quot; transform</h2><span id='topic+wd.int'></span>

<h3>Description</h3>

<p>This function actually computes the &quot;wavelets on the interval&quot; transform. 
</p>
<p><b>NOTE:</b> It is not recommended that the casual user call this function. The &quot;wavelets on the interval&quot; transform is best called in <code>WaveThresh</code> via the <code><a href="#topic+wd">wd</a></code> function with the argument bc argument set to <code>"interval"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wd.int(data, preferred.filter.number, min.scale, precond)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wd.int_+3A_data">data</code></td>
<td>
<p>The data that you wish to apply the &quot;wavelets on the interval&quot; transform to.</p>
</td></tr>
<tr><td><code id="wd.int_+3A_preferred.filter.number">preferred.filter.number</code></td>
<td>
<p>Which wavelet to use to do the transform. This is an integer ranging from 1 to 8. See the Cohen, Daubeches and Vial (1993) paper. Wavelets that do not &quot;overlap&quot; a boundary are just like the ordinary Daubechies' wavelets.</p>
</td></tr>
<tr><td><code id="wd.int_+3A_min.scale">min.scale</code></td>
<td>
<p>At which resolution level to transform to.</p>
</td></tr>
<tr><td><code id="wd.int_+3A_precond">precond</code></td>
<td>
<p>If true performs preconditioning of the input vector to try and ensure that simple polynomial sequences (less than in order to the wavelet used) map to zero elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(The <code>WaveThresh</code> implementation of the &ldquo;wavelets on the interval transform&rdquo; was coded by Piotr Fryzlewicz, Department of Mathematics, Wroclaw University of Technology, Poland; this code was largely based on code written by Markus Monnerjahn, RHRK, Universitat Kaiserslautern; integration into WaveThresh by GPN). 
</p>
<p>See the help on the &quot;wavelets on the interval code&quot; in the <code><a href="#topic+wd">wd</a></code> help page. 
</p>


<h3>Value</h3>

<p>A list containing the wavelet transform of the <code>data</code>. We again emphasize that this list is not intended for human consumption, use the <code><a href="#topic+wd">wd</a></code> function with the correct <code>bc="interval"</code> argument. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Piotr Fryzlewicz and Markus Monnerjahn 1995-9). </p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr">wr</a></code>, <code><a href="#topic+wr.int">wr.int</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The user is expected to call the wr
# for inverting a "wavelets on the interval transform" and not to use
# this function explicitly
#
</code></pre>

<hr>
<h2 id='wd.object'>Wavelet decomposition objects</h2><span id='topic+wd.object'></span>

<h3>Description</h3>

<p>These are objects of classes 
</p>
<p><code>wd</code>
</p>
<p>They represent a decomposition of a function with respect to a wavelet basis (or tight frame in the case of the (time-ordered) non-decimated wavelet decomposition). 
</p>


<h3>Details</h3>

<p>To retain your sanity the C and D coefficients should be extracted by the <code><a href="#topic+accessC">accessC</a></code> and <code><a href="#topic+accessD">accessD</a></code> functions and inserted using the <code><a href="#topic+putC">putC</a></code> and <code><a href="#topic+putD">putD</a></code> functions (or more likely, their methods), rather than by the <code>$</code> operator.
</p>
<p>Mind you, if you want to muck about with coefficients directly, then you'll have to do it yourself by working out what the fl.dbase list means (see <code><a href="#topic+first.last">first.last</a></code> for a description.)
</p>
<p>Note the <em>time-ordered non-decimated wavelet transform</em> used to be called the <em>stationary wavelet transform</em>. In fact, the non-decimated transform has several possible names and has been reinvented many times. There are two versions of the non-decimated transform: the coefficients are the same in each version just ordered differently within a resolution level. The two transforms are 
</p>

<ul>
<li><p>The function <code><a href="#topic+wd">wd</a></code>() with an argument <code>type="station"</code> computes the <em>time-ordered</em> non-decimated transform (see Nason and Silverman, 1995) which is useful in time-series applications (see e.g. Nason, von Sachs and Kroisandt, 1998).
</p>
</li>
<li><p>The function <code><a href="#topic+wst">wst</a></code>() computes the packets ordered non-decimated transform is useful for curve estimation type applications (see e.g. Coifman and Donoho, 1995). 
</p>
</li></ul>



<h3>Value</h3>

<p>The following components must be included in a legitimate &lsquo;wd&rsquo; object. 
</p>
<table role = "presentation">
<tr><td><code>C</code></td>
<td>
<p>a vector containing each level's smoothed data. The wavelet transform works by applying both a smoothing filter and a bandpass filter to the previous level's smoothed data. The top level contains data at the highest resolution level. Each of these levels are stored one after the other in this vector. The matrix 
</p>
<p><code>fl.dbase$first.last.c</code>
</p>
<p>determines exactly where each level is stored in the vector. Likewise, coefficients stored when the NDWT has been used should only be extracted using the &ldquo;access&rdquo; and &ldquo;put&rdquo; functions below.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>wavelet coefficients. If you were to write down the discrete wavelet transform of a function then these D would be the coefficients of the wavelet basis functions. Like the C, they are also formed in a pyramidal manner, but stored in a linear array. The storage details are to be found in 
</p>
<p><code>fl.dbase$first.last.d</code>
</p>
<p>Likewise, coefficients stored when the NDWT has been used should only be extracted using the &ldquo;access&rdquo; and &ldquo;put&rdquo; functions below. </p>
</td></tr>
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of levels in the pyramidal decomposition that produces the coefficients. If you raise 2 to the power of nlevels you get the number of data points used in the decomposition.</p>
</td></tr>
<tr><td><code>fl.dbase</code></td>
<td>
<p>The first last database associated with this decomposition. This is a list consisting of 2 integers, and 2 matrices. The matrices detail how the coefficients are stored in the C and D components of the &lsquo;wd.object&rsquo;. See the help on <code><a href="#topic+first.last">first.last</a></code> for more information. </p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>a list containing the details of the filter that did the decomposition</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>either <b>wavelet</b> indicating that the ordinary wavelet transform was performed or <b>station</b> indicating that the time-ordered non-decimated wavelet transform was done.</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>The date that the transform was performed or the wd was modified.</p>
</td></tr>
<tr><td><code>bc</code></td>
<td>
<p>how the boundaries were handled</p>
</td></tr>
</table>


<h3>GENERATION</h3>

<p>This class of objects is returned from the <code><a href="#topic+wd">wd</a></code> function to represent a (possibly time-ordered non-decimated) wavelet decomposition of a function. Many other functions return an object of class wd.
</p>


<h3>METHODS</h3>

<p>The wd class of objects has methods for the following generic functions: <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="#topic+threshold">threshold</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+draw">draw</a></code>.
</p>


<h3>RELAEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wst">wst</a></code>
</p>

<hr>
<h2 id='wd3D'>Three-dimensional discrete wavelet transform</h2><span id='topic+wd3D'></span>

<h3>Description</h3>

<p>This function performs the 3D version of Mallat's discrete wavelet transform (see Mallat, 1989, although this paper does not describe in detail the 3D version the extension is trivial). The function assumes
<em>periodic</em> boundary conditions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wd3D(a, filter.number=10, family="DaubLeAsymm")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wd3D_+3A_a">a</code></td>
<td>
<p>A three-dimensional array constructed using the S-Plus <code>array()</code> function. Each dimension of the array should be equal to the same power of two.</p>
</td></tr>
<tr><td><code id="wd3D_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments.</p>
</td></tr>
<tr><td><code id="wd3D_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. Two popular options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot; but see the help for <code><a href="#topic+filter.select">filter.select</a></code> for more possibilities.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function implements a straightforward extension of Mallat's, (1989) one- and two-dimensional DWT. The algorithm recursively applies all possible combinations of the G and H detail and smoothing filters to each of the dimensions thus forming 8 different sub-blocks which we label HHH, GHH, HGH, GGH, HHG, GHG, HGG, and GGG. The algorithm recurses on the HHH component of each level (these are the father wavelet coefficients). 
</p>
<p>Making an analogy to the 2D transform where HH, HG, HG and GG is produced at each resolution level: the HG and GH correspond to &quot;horizontal&quot; and &quot;vertical&quot; detail and GG corresponds to &quot;diagonal detail&quot;. The GGG corresponds to the 3D &quot;diagonal&quot; version, HGG corresponds to smoothing in dimension 1 and &quot;diagonal&quot; detail in dimensions 2 and 3, and so on. I don't think there are words in the English language which adequately describe &quot;diagonal&quot; in 3D &mdash; maybe cross detail? 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wd3D">wd3D</a></code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 Copyright Guy Nason 1997</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+accessD.wd3D">accessD.wd3D</a></code>, <code><a href="#topic+print.wd3D">print.wd3D</a></code>, <code><a href="#topic+putD.wd3D">putD.wd3D</a></code>, <code><a href="#topic+putDwd3Dcheck">putDwd3Dcheck</a></code>, <code><a href="#topic+summary.wd3D">summary.wd3D</a></code>, <code><a href="#topic+threshold.wd3D">threshold.wd3D</a></code>, <code><a href="#topic+wd3D.object">wd3D.object</a></code>, <code><a href="#topic+wr3D">wr3D</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data: 512 standard normal observations in an 8x8x8
# array.
#
test.data.3D &lt;- array(rnorm(8*8*8), dim=c(8,8,8))
#
# Now do the 3D wavelet transform
#
tdwd3D &lt;- wd3D(test.data.3D)
#
# See examples explaining  the 3D wavelet transform.
#
</code></pre>

<hr>
<h2 id='wd3D.object'>Three-dimensional wavelet object</h2><span id='topic+wd3D.object'></span>

<h3>Description</h3>

<p>These are objects of classes 
</p>
<p>wd3D
</p>
<p>They contain the 3D discrete wavelet transform of a 3D array (with each dimension being the same dyadic size). 
</p>


<h3>Details</h3>

<p>To retain your sanity the wavelet coefficients at any resolution level in directions, GGG, GGH, GHG, GHH, HGG, HGH, HHG should be extracted by the <code><a href="#topic+accessD">accessD</a></code>() function and inserted using the <code><a href="#topic+putD">putD</a></code> function rather than by the <code>$</code> operator.
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate &lsquo;wd&rsquo; object. 
</p>
<table role = "presentation">
<tr><td><code>a</code></td>
<td>
<p>a three-dimensional array containing the 3D discrete wavelet coefficients. The coefficients are stored in a pyramid structure for efficiency.</p>
</td></tr>
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of levels in the pyramidal decomposition that produces the coefficients. If you raise 2 to the power of nlevels you get the number of data points used in each dimension of the decomposition.</p>
</td></tr>
<tr><td><code>filter.number</code></td>
<td>
<p>the number of the wavelet family that did the DWT.</p>
</td></tr> 
<tr><td><code>family</code></td>
<td>
<p>the family of wavelets that did the DWT.</p>
</td></tr> 
<tr><td><code>date</code></td>
<td>
<p>the date that the transform was computed.</p>
</td></tr>
</table>


<h3>generation</h3>

<p>This class of objects is returned from the wd3D function to represent a three-dimensional DWT of a 3D array. Other functions return an object of class wd3D.
</p>


<h3>methods</h3>

<p>The wd3D class of objects has methods for the following generic functions: <code><a href="#topic+accessD">accessD</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+putD">putD</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+threshold">threshold</a></code>.
</p>


<h3>release</h3>

<p>Version 3.9.6 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd3D">wd3D</a></code>, <code><a href="#topic+accessD.wd3D">accessD.wd3D</a></code>, <code><a href="#topic+print.wd3D">print.wd3D</a></code>, <code><a href="#topic+putD.wd3D">putD.wd3D</a></code>, <code><a href="#topic+putDwd3Dcheck">putDwd3Dcheck</a></code>, <code><a href="#topic+summary.wd3D">summary.wd3D</a></code>, <code><a href="#topic+threshold.wd3D">threshold.wd3D</a></code>, <code><a href="#topic+wr3D">wr3D</a></code>. 
</p>

<hr>
<h2 id='Whistory'>Obsolete function supposedly detailed history of object</h2><span id='topic+Whistory'></span>

<h3>Description</h3>

<p>The original idea behind this obsolete function was to interrogate
an object and return the modifications that had been successively
applied to the function. The reason for this was that after a long
data analysis session one would end up with a whole set of, e.g.,
thresholded or otherwise modified objects and it would have been convenient
for each object not only to store its current value but also the history
of how it got to be that value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Whistory(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Whistory_+3A_...">...</code></td>
<td>
<p>Arguments to pass to method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>No return value, although function was meant to print out a list
times and dates when the object was modified.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+Whistory.wst">Whistory.wst</a></code></p>

<hr>
<h2 id='Whistory.wst'>Obsolete function: as Whistory, but for wst objects</h2><span id='topic+Whistory.wst'></span>

<h3>Description</h3>

<p>Obsolete function, see <code><a href="#topic+Whistory">Whistory</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst'
Whistory(wst, all=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Whistory.wst_+3A_wst">wst</code></td>
<td>
<p>The object that you want to display the history for</p>
</td></tr>
<tr><td><code id="Whistory.wst_+3A_all">all</code></td>
<td>
<p>Print the whole history list</p>
</td></tr>
<tr><td><code id="Whistory.wst_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing, but history information is printed.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+Whistory">Whistory</a></code></p>

<hr>
<h2 id='wp'>Wavelet packet transform. </h2><span id='topic+wp'></span>

<h3>Description</h3>

<p>This function computes a wavelet packet transform (computed by the complete binary application of the DH and DG packet operators, as opposed to the Mallat discrete wavelet transform which only recurses on the DH operator [low pass]). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wp(data, filter.number=10, family="DaubLeAsymm", verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wp_+3A_data">data</code></td>
<td>
<p>A vector containing the data you wish to decompose. The length of this vector must be a power of 2.</p>
</td></tr>
<tr><td><code id="wp_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments.</p>
</td></tr>
<tr><td><code id="wp_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="wp_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> then (un)helpful messages are printed during the execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The paper by Nason, Sapatinas and Sawczenko, 1998 details this implementation of the wavelet packet transform. A more thorough reference is Wickerhauser, 1994. 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wp">wp</a></code> which contains the (decimated) wavelet packet coefficients. 
</p>


<h3>RELEASE</h3>

<p>Version 3.0 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessC.wp">accessC.wp</a></code>, <code><a href="#topic+accessD.wp">accessD.wp</a></code>, <code><a href="#topic+basisplot.wp">basisplot.wp</a></code>, <code><a href="#topic+draw.wp">draw.wp</a></code>,<code><a href="#topic+drawwp.default">drawwp.default</a></code>, <code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+getpacket.wp">getpacket.wp</a></code>, <code><a href="#topic+InvBasis.wp">InvBasis.wp</a></code>, <code><a href="#topic+MaNoVe.wp">MaNoVe.wp</a></code>, <code><a href="#topic+plot.wp">plot.wp</a></code>, <code><a href="#topic+print.wp">print.wp</a></code>, <code><a href="#topic+putC.wp">putC.wp</a></code>, <code><a href="#topic+putD.wp">putD.wp</a></code>, <code><a href="#topic+putpacket.wp">putpacket.wp</a></code>, <code><a href="#topic+summary.wp">summary.wp</a></code>, <code><a href="#topic+threshold.wp">threshold.wp</a></code>, <code><a href="#topic+wp.object">wp.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- rnorm(128)
vwp &lt;- wp(v)

</code></pre>

<hr>
<h2 id='wp.object'>Wavelet Packet decomposition objects.</h2><span id='topic+wp.object'></span>

<h3>Description</h3>

<p>These are objects of classes <code>wp</code> They represent a decomposition of a function with respect to a set of wavelet packet functions. 
</p>


<h3>Details</h3>

<p>To retain your sanity we recommend that wavelet packets be extracted in one of two ways: 
</p>

<ul>
<li><p>use <code><a href="#topic+getpacket.wp">getpacket.wp</a></code> to obtain individual packets.
</p>
</li>
<li><p>use <code><a href="#topic+accessD.wp">accessD.wp</a></code> to obtain all coefficients at a particular resolution level.
</p>
</li></ul>

<p>You can obtain the coefficients directly from the <code>wp$wp</code> component but you have to understand their organization described above. 
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate &lsquo;wp&rsquo; object. 
</p>
<table role = "presentation">
<tr><td><code>wp</code></td>
<td>
<p>a matrix containing the wavelet packet coefficients. Each row of the matrix contains coefficients with respect to a particular resolution level. There are <code>nlevelsWT(wp)+1</code> rows in the matrix. Row <code>nlevels(wp)+1</code> (the &ldquo;bottom&rdquo;) row contains the &ldquo;original&rdquo; data used to produce the wavelet packet coefficients. Rows <code>nlevels</code>(wp) to row 1 contain coefficients at resolution levels <code>nlevels(wp)-1</code> to 0 (so the first row contains coefficients at resolution level 0). 
</p>
<p>The columns contain the coefficients with respect to packets. A different packet length exists at each resolution level. The packet length at resolution level <code>i</code> is given by <code>2^i</code>. However, the <code><a href="#topic+getpacket.wp">getpacket.wp</a></code> function should be used to access individual packets from a <code><a href="#topic+wp">wp</a></code> object.</p>
</td></tr>
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of levels in the wavelet packet decomposition. If you raise 2 to the power of nlevels you get the number of data points used in the decomposition. </p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>a list containing the details of the filter that did the decomposition (equivalent to the return value from the <code><a href="#topic+filter.select">filter.select</a></code> function). </p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>The date that the transform was performed or the wp was modified.</p>
</td></tr> 
</table>


<h3>GENERATION</h3>

<p>This class of objects is returned from the <code><a href="#topic+wp">wp</a></code> function to represent a wavelet packet decomposition of a function. Many other functions return an object of class wp. 
</p>


<h3>METHODS</h3>

<p>The wp class of objects has methods for the following generic functions: <code><a href="#topic+InvBasis">InvBasis</a></code>, <code><a href="#topic+MaNoVe">MaNoVe</a></code>, <code><a href="#topic+accessC">accessC</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+basisplot">basisplot</a></code>, <code><a href="#topic+draw">draw</a></code>. <code><a href="#topic+getpacket">getpacket</a></code>, <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>, <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+putC">putC</a></code>, <code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+putpacket">putpacket</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+threshold">threshold</a></code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wp">wp</a></code>
</p>

<hr>
<h2 id='wpst'>Non-decimated wavelet packet transform. </h2><span id='topic+wpst'></span>

<h3>Description</h3>

<p>This function computes the non-decimated wavelet packet transform as described by Nason, Sapatinas and Sawczenko, 1998. The non-decimated wavelet packet transform (NWPT) contains all possible shifted versions of the wavelet packet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wpst(data, filter.number=10, family="DaubLeAsymm", FinishLevel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wpst_+3A_data">data</code></td>
<td>
<p>A vector containing the data you wish to decompose. The length of this vector must be a power of 2.</p>
</td></tr>
<tr><td><code id="wpst_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments.</p>
</td></tr>
<tr><td><code id="wpst_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="wpst_+3A_finishlevel">FinishLevel</code></td>
<td>
<p>At which level to stop decomposing. The full decomposition
decomposes to level 0, but you could stop earlier.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function computes the packet-ordered non-decimated wavelet packet transform of data as described by Nason, Sapatinas and Sawczenko, 1998. It assumes periodic boundary conditions. The order of computation of the NWPT is
<code class="reqn">O(n^2)</code> if n is the number of input data points. 
</p>
<p>Packets can be extracted from the <code>wpst.object</code> produced by this function using the <code><a href="#topic+getpacket.wpst">getpacket.wpst</a></code> function. Whole resolution levels of non-decimated wavelet packet coefficients in time order can be obtained by using the <code><a href="#topic+accessD.wpst">accessD.wpst</a></code> function. 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wpst">wpst</a></code> containing the discrete packet-ordered non-decimated wavelet packet coefficients. 
</p>


<h3>RELEASE</h3>

<p>Version 3.8.8 Copyright Guy Nason 1997 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+accessD.wpst">accessD.wpst</a></code>, <code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+getpacket">getpacket</a></code>, <code><a href="#topic+getpacket.wpst">getpacket.wpst</a></code>,
<code><a href="#topic+makewpstDO">makewpstDO</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- rnorm(128)
vwpst &lt;- wpst(v)
</code></pre>

<hr>
<h2 id='wpst2discr'>Reshape/reformat packet coefficients into a multivariate data set</h2><span id='topic+wpst2discr'></span>

<h3>Description</h3>

<p>The packet coefficients of a nondecimated wavelet packet object are stored
internally in an efficient form. This function takes the nondecimated
wavelet packets and stores them as a matrix (multivariate data set).
Each column in the returned matrix corresponds to an individual packet,
each row corresponds to a time index in the original packet or time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wpst2discr(wpstobj, groups)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wpst2discr_+3A_wpstobj">wpstobj</code></td>
<td>
<p>A wpst class object, output from <code><a href="#topic+wpst">wpst</a></code> say</p>
</td></tr>
<tr><td><code id="wpst2discr_+3A_groups">groups</code></td>
<td>
<p>A time series containing the group membership at each time point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says it all
</p>


<h3>Value</h3>

<p>An object of class w2d which is a list containing the following
items:
</p>
<table role = "presentation">
<tr><td><code>m</code></td>
<td>
<p>The matrix containing columns of packet information.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>Passes through the <code>group</code> argument from input.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>Each column corresponds to a packet, this vector contains the
information on which resolution level each packet comes from</p>
</td></tr>
<tr><td><code>pktix</code></td>
<td>
<p>Like for <code>level</code> but for packet indices</p>
</td></tr>
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of resolution levels in total, from the wpst object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+makewpstDO">makewpstDO</a></code>, <code><a href="#topic+wpst">wpst</a></code></p>

<hr>
<h2 id='wpst2m'>
Converts a nondecimated wavelet packet object to a (large) matrix with
packets stored as columns
</h2><span id='topic+wpst2m'></span>

<h3>Description</h3>

<p>Takes a nondecimated wavelet packet transform, takes the packets one packet
at a time and stores them in a matrix. The packets are rotated on extraction
and storage in the matrix in an attempt to align them, they are also
optionally transformed by <code>trans</code>. The rotation is performed
by <code><a href="#topic+compgrot">compgrot</a></code>. 
</p>
<p>Note that the coefficients are of some series, not the basis functions
themselves. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wpst2m(wpstobj, trans = identity)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wpst2m_+3A_wpstobj">wpstobj</code></td>
<td>

<p>The nondecimated wavelet packet object to store
</p>
</td></tr>
<tr><td><code id="wpst2m_+3A_trans">trans</code></td>
<td>

<p>The optional transform to apply to the coefficients
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>A list, of class w2m, with the following components:
</p>
<table role = "presentation">
<tr><td><code>m</code></td>
<td>
<p>The matrix containing the packets</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>A vector containing the levels from where the packets in m
come from</p>
</td></tr>
<tr><td><code>pktix</code></td>
<td>
<p>A vector containing the packet indices from where the packets in m
come from</p>
</td></tr>
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of resolution levels from the original wpst object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G P Nason
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makewpstRO">makewpstRO</a></code>, <code><a href="#topic+print.w2m">print.w2m</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Not intended to be directly used by users
#
</code></pre>

<hr>
<h2 id='wpstCLASS'>
Predict values using new time series values via a non-decimated wavelet packet
discrimination object.
</h2><span id='topic+wpstCLASS'></span>

<h3>Description</h3>

<p>Given a timeseries (<code>timeseries</code>) and another time series
of categorical values (<code>groups</code>) the <code><a href="#topic+makewpstDO">makewpstDO</a></code> produces
a model that permits discrimination of the <code>groups</code> series using
a discriminant analysis based on a restricted set of non-decimated
wavelet packet coefficients of <code>timeseries</code>. The current function
enables new <code>timeseries</code> data, to be used in conjunction with
the model to generate new, predicted, values of the <code>groups</code> time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wpstCLASS(newTS, wpstDO)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wpstCLASS_+3A_newts">newTS</code></td>
<td>
<p>A new segment of time series values, of the same time series
that was used as the dependent variable used to construct the
wpstDO object</p>
</td></tr>
<tr><td><code id="wpstCLASS_+3A_wpstdo">wpstDO</code></td>
<td>
<p>An object that uses values of a dependent time series to
build a discriminatory model of a groups time series. Output
from the <code><a href="#topic+makewpstDO">makewpstDO</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the same nondecimated wavelet packet (NDWPT) transform
of the <code>newTS</code> data that was used to analyse the original <code>timeseries</code>
and the details of this transform are stored within the <code>wpstDO</code>
object. Then, using information that was recorded in <code>wpstDO</code>
the packets with the same level/index are extracted from the new NDWPT 
and formed into a matrix. Then the linear discriminant variables,
again stored in <code>wpstDO</code> are used to form predictors of the
original <code>groups</code> time series, ie new values of <code>groups</code>
that correspond to the new values of <code>timeseries</code>.
</p>


<h3>Value</h3>

<p>The prediction using the usual R <code>predict.lda</code> function. The
predicted values are stored in the <code>class</code> component of that list.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+makewpstDO">makewpstDO</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example at the end of help page for makewpstDO
#
</code></pre>

<hr>
<h2 id='wpstREGR'>Construct data frame using new time series using information
from a previously constructed wpstRO object
</h2><span id='topic+wpstREGR'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+makewpstRO">makewpstRO</a></code> function takes two time series,
performs a nondecimated wavelet packet transform with the &quot;dependent&quot;
variable one, stores the &quot;best&quot; packets (those that individually correlate
with the response series) and returns the data frame that contains the
response and the best packets. The idea is that the user then performs
some kind of modelling between response and packets. This function takes
a new &quot;dependent&quot; series and returns the best packets in a new data frame
in the same format as the old one. The idea is that the model and the new
data frame can be used together to predict new values for the response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wpstREGR(newTS, wpstRO)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wpstREGR_+3A_newts">newTS</code></td>
<td>
<p>The new &quot;dependent&quot; time series
</p>
</td></tr>
<tr><td><code id="wpstREGR_+3A_wpstro">wpstRO</code></td>
<td>
<p>The previously constructed wpstRO object made by
<code><a href="#topic+makewpstRO">makewpstRO</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description says it all
</p>


<h3>Value</h3>

<p>New values of the response time series
</p>


<h3>Author(s)</h3>

<p>G P Nason
</p>


<h3>References</h3>

<p>See reference to Nason and Sapatinas paper in the help for
<code><a href="#topic+makewpstRO">makewpstRO</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makewpstRO">makewpstRO</a></code>, <code><a href="#topic+wpst">wpst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See extended example in makewpstRO help, includes example of using this fn
#
</code></pre>

<hr>
<h2 id='wr'>Wavelet reconstruction (inverse DWT).</h2><span id='topic+wr'></span>

<h3>Description</h3>

<p>Performs inverse discrete wavelet transform. 
</p>
<p>This function is generic. 
</p>
<p>Particular methods exist. For the <code><a href="#topic+wd">wd</a></code> class object this generic function uses <code><a href="#topic+wr.wd">wr.wd</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wr(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wr_+3A_...">...</code></td>
<td>
<p>See individual help pages for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See individual method help pages for operation and examples. 
</p>


<h3>Value</h3>

<p>Usually the wavelet reconstruction of x. Although the return value varies with the precise method used. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wd.object">wd.object</a></code>, <code><a href="#topic+wr.wd">wr.wd</a></code> 
</p>

<hr>
<h2 id='wr.int'>Computes inverse &quot;wavelets on the interval&quot; transform. </h2><span id='topic+wr.int'></span>

<h3>Description</h3>

<p>This function actually computes the inverse of the &quot;wavelets on the interval&quot; transform. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'int'
wr(wav.int.object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wr.int_+3A_wav.int.object">wav.int.object</code></td>
<td>
<p>A list with components defined by the return from the <code><a href="#topic+wd.int">wd.int</a></code> function.</p>
</td></tr>
<tr><td><code id="wr.int_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(The WaveThresh implementation of the &ldquo;wavelets on the interval transform&rdquo; was coded by Piotr Fryzlewicz, Department of Mathematics, Wroclaw University of Technology, Poland; this code was largely based on code written by Markus Monnerjahn, RHRK, Universitat Kaiserslautern; integration into WaveThresh by <code>GPN</code>).
</p>
<p>See the help on the &quot;wavelets on the interval code&quot; in the wd help page.
</p>


<h3>Value</h3>

<p>The inverse wavelet transform of the wav.int.object supplied. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 (Although Copyright Piotr Fryzlewicz and Markus Monnerjahn 1995-9).</p>


<h3>Note</h3>

<p>It is not recommended that the casual user call this function. The &quot;wavelets on the interval&quot; transform is best called in <code>WaveThresh</code> via the <code><a href="#topic+wd">wd</a></code> function with the argument bc argument set to &quot;<code>interval</code>&quot;. 
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz and Markus Monnerjahn</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd.int">wd.int</a></code>, <code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr">wr</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The user is expected to call the wr
# for inverting a "wavelets on the interval transform".
#
</code></pre>

<hr>
<h2 id='wr.mwd'>Multiple wavelet reconstruction for mwd objects</h2><span id='topic+wr.mwd'></span>

<h3>Description</h3>

<p>This function is method for the <code><a href="base.html#topic+function">function</a></code> to
apply the inverse multiple wavelet transform for <code><a href="#topic+mwd.object">mwd.object</a></code>
objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mwd'
wr(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wr.mwd_+3A_...">...</code></td>
<td>
<p>Arguments to the <code><a href="#topic+mwr">mwr</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is merely a wrapper for <code><a href="#topic+mwr">mwr</a></code>
</p>


<h3>Value</h3>

<p>The same return value as for <code><a href="#topic+mwr">mwr</a></code>.
</p>


<h3>Author(s)</h3>

<p>Tim Downie</p>


<h3>See Also</h3>

<p><code><a href="#topic+mwd">mwd</a></code>,
<code><a href="#topic+mwr">mwr</a></code></p>

<hr>
<h2 id='wr.wd'>Wavelet reconstruction for wd class objects (inverse discrete wavelet transform). </h2><span id='topic+wr.wd'></span>

<h3>Description</h3>

<p>This function performs the reconstruction stage of Mallat's pyramid algorithm (Mallat 1989), i.e. the discrete inverse wavelet transform. The actual transform is performed by some C code, this is dynamically linked into S (if your machine can do this). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wd'
wr(wd, start.level = 0, verbose = FALSE, bc = wd$bc,
	return.object = FALSE, filter.number = wd$filter$filter.number,
	family = wd$filter$family, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wr.wd_+3A_wd">wd</code></td>
<td>
<p>A wavelet decomposition object as returned by <code><a href="#topic+wd">wd</a></code>, and described in the help for that function and the help for <code><a href="#topic+wd.object">wd.object</a></code>.</p>
</td></tr>
<tr><td><code id="wr.wd_+3A_start.level">start.level</code></td>
<td>
<p>The level you wish to start reconstruction at. The is usually the first (level 0). This argument is ignored for a wd object computed using the &ldquo;wavelets on the interval&rdquo; transform (i.e. using the <code>bc="interval"</code> option of <code><a href="#topic+wd">wd</a></code>.</p>
</td></tr>
<tr><td><code id="wr.wd_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the computations progress. Such messages are generally annoying so it is turned off by default.</p>
</td></tr>
<tr><td><code id="wr.wd_+3A_bc">bc</code></td>
<td>
<p>The boundary conditions used. Usually these are determined by those used to create the supplied wd object, but you sometimes change them with possibly silly results.</p>
</td></tr>
<tr><td><code id="wr.wd_+3A_filter.number">filter.number</code></td>
<td>
<p>The filter number of the wavelet used to do the reconstruction. Again, as for bc, you should probably leave this argument alone. Ignored if the bvc component of the <code><a href="#topic+wd">wd</a></code> object is &quot;<code>interval</code>&quot;.</p>
</td></tr> 
<tr><td><code id="wr.wd_+3A_family">family</code></td>
<td>
<p>The type of wavelet used to do the reconstruction. You can change this argument from the default but it is probably NOT wise. Ignored if the bvc component of the <code><a href="#topic+wd">wd</a></code> object is &quot;<code>interval</code>&quot;.</p>
</td></tr> 
<tr><td><code id="wr.wd_+3A_return.object">return.object</code></td>
<td>
<p>If this is F then the top level of the reconstruction is returned (this is the reconstructed function at the highest resolution). Otherwise if it is T the whole wd reconstructed object is returned. Ignored if the <code>bvc</code> component of the <code><a href="#topic+wd">wd</a></code> object is &quot;<code>interval</code>&quot;.</p>
</td></tr> 
<tr><td><code id="wr.wd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code implements Mallat's inverse pyramid algorithm. In the reconstruction the quadrature mirror filters G and H are supplied with c0 and d0, d1, ... d(m- 1) (the wavelet coefficients) and rebuild c1,..., cm. 
</p>
<p>If the <code>bc</code> component of the <code><a href="#topic+wd">wd</a></code> object is &quot;<code>interval</code>&quot; then the <code>wr.int</code> function which implements the inverse &ldquo;wavelet on the interval&rdquo; transform due to Cohen, Daubechies and Vial, 1993 is used instead. 
</p>


<h3>Value</h3>

<p>Either a vector containing the top level reconstruction or an object of class wd containing the results of the reconstruction, details to be found in help for <code><a href="#topic+wd.object">wd.object</a></code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3 Copyright Guy Nason 1994
Integration of &ldquo;wavelets on the interval&rdquo; code by Piotr Fryzlewicz and Markus Monnerjahn was at Version 3.9.6, 1999. </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wd">wd</a></code>, <code><a href="#topic+wr.int">wr.int</a></code>, <code><a href="#topic+accessC">accessC</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+plot.wd">plot.wd</a></code>, <code><a href="#topic+threshold">threshold</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Take the wd object generated in the examples to wd (called wds)
#
# Invert this wd object
#
#yans &lt;- wr(wds)
#
# Compare it to the original, called y
#
#sum((yans-y)^2)
#[1] 9.805676e-017
#
# A very small number
#
</code></pre>

<hr>
<h2 id='wr3D'>Inverse DWT for 3D DWT object. </h2><span id='topic+wr3D'></span>

<h3>Description</h3>

<p>Performs the inverse DWT for <code><a href="#topic+wd3D.object">wd3D.object</a></code>, i.e. 3D DWT objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wr3D(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wr3D_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+wd3D.object">wd3D.object</a></code> 3D DWT object as returned by <code><a href="#topic+wd3D">wd3D</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code implements a 3D version of Mallat's inverse pyramid algorithm. 
</p>


<h3>Value</h3>

<p>A 3D array containing the inverse 3D DWT of obj. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.6 Copyright Guy Nason 1997</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wr">wr</a></code>, <code><a href="#topic+accessD.wd3D">accessD.wd3D</a></code>, <code><a href="#topic+print.wd3D">print.wd3D</a></code>, <code><a href="#topic+putD.wd3D">putD.wd3D</a></code>, <code><a href="#topic+putDwd3Dcheck">putDwd3Dcheck</a></code>, <code><a href="#topic+summary.wd3D">summary.wd3D</a></code>, <code><a href="#topic+threshold.wd3D">threshold.wd3D</a></code>, <code><a href="#topic+wd3D">wd3D</a></code>, <code><a href="#topic+wd3D.object">wd3D.object</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Now let's take the object generated by the last stage in the EXAMPLES
# section of threshold.wd3D and invert it!
#
#testwr &lt;- wr3D(testwd3DT)
#
# You'll find that testwr is an array of dimension 8x8x8!
#
</code></pre>

<hr>
<h2 id='wst'>Packet-ordered non-decimated wavelet transform.</h2><span id='topic+wst'></span>

<h3>Description</h3>

<p>Computes the packet-ordered non-decimated wavelet transform (TI-transform). This algorithm is functionally equivalent to the time-ordered non-decimated wavelet transform (computed by <code><a href="#topic+wd">wd</a></code> with the <code>type="station"</code> argument). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wst(data, filter.number=10, family="DaubLeAsymm", verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wst_+3A_data">data</code></td>
<td>
<p>A vector containing the data you wish to decompose. The length of this vector must be a power of 2.</p>
</td></tr>
<tr><td><code id="wst_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments.
</p>
<p>Note: as of version 4.6 you can use the Lina-Mayrand complex-valued
compactly supported wavelets.
</p>
</td></tr>
<tr><td><code id="wst_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="wst_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the computations progress. Such messages are generally annoying so it is turned off by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The packet-ordered non-decimated wavelet transform is more properly known as the TI-transform described by Coifman and Donoho, 1995. A description of this implementation can be found in Nason and Silverman, 1995. 
</p>
<p>The coefficients produced by this transform are exactly the same as those produced by the <code><a href="#topic+wd">wd</a></code> function with the <code>type="station"</code> option <em>except</em> in that function the coefficients are <em>time-ordered</em>. In the <code>wst</code> function the coefficients are produced by a wavelet packet like algorithm with a <em>cyclic rotation</em> step instead of processing with the father wavelet mirror filter at each level. 
</p>
<p>The coefficients produced by this function are useful in curve estimation problems in conjunction with the thresholding function <code><a href="#topic+threshold.wst">threshold.wst</a></code> and either of the inversion functions <code><a href="#topic+AvBasis.wst">AvBasis.wst</a></code> and <code><a href="#topic+InvBasis.wst">InvBasis.wst</a></code> The coefficients produced by the <code>time-ordered non-decimated wavelet transform</code> are more useful for time series applications: e.g. the evolutionary wavelet spectrum computation performed by <code><a href="#topic+ewspec">ewspec</a></code>. 
Note that a time-ordered non-decimated wavelet transform object may be converted into a packet-ordered non-decimated wavelet transform object (and vice versa) by using the <code><a href="#topic+convert">convert</a></code> function. 
</p>


<h3>Value</h3>

<p>An object of class: <code><a href="#topic+wst">wst</a></code>. The help for the <code><a href="#topic+wst">wst</a></code> describes the intricate structure of this class of object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1995 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+threshold.wst">threshold.wst</a></code>, <code><a href="#topic+AvBasis.wst">AvBasis.wst</a></code>, <code><a href="#topic+InvBasis.wst">InvBasis.wst</a></code>, <code><a href="#topic+filter.select">filter.select</a></code>, <code><a href="#topic+convert">convert</a></code>, <code><a href="#topic+ewspec">ewspec</a></code>, <code><a href="#topic+plot.wst">plot.wst</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's look at the packet-ordered non-decimated wavelet transform
# of the data we used to do the time-ordered non-decimated wavelet
# transform exhibited in the help page for wd. 
#
test.data &lt;- example.1()$y
#
# Plot it to see what it looks like (piecewise polynomial)
#
## Not run: ts.plot(test.data)
#
# Now let's do the packet-ordered non-decimated wavelet transform.
#
TDwst &lt;- wst(test.data)
#
# And let's plot it....
#
## Not run: plot(TDwst)
#
# The coefficients in this plot at each resolution level are the same
# as the ones in the non-decimated transform plot in the wd
# help page except they are in a different order. For more information
# about how the ordering works in each case see
# Nason, Sapatinas and Sawczenko, 1998. 
# 
# Next examples
# ------------
# The chirp signal is also another good examples to use.
#
#
# Generate some test data
#
test.chirp &lt;- simchirp()$y
## Not run: ts.plot(test.chirp, main="Simulated chirp signal")
#
# Now let's do the packet-ordered non-decimated wavelet transform.
# For a change let's use Daubechies extremal phase wavelet with 6
# vanishing moments (a totally arbitrary choice, please don't read
# anything into it).
#
chirpwst &lt;- wst(test.chirp, filter.number=6, family="DaubExPhase")
## Not run: plot(chirpwst, main="POND WT of Chirp signal")
</code></pre>

<hr>
<h2 id='wst.object'>(Packet ordered) Nondecimated wavelet transform decomposition objects.</h2><span id='topic+wst.object'></span>

<h3>Description</h3>

<p>These are objects of class <code>wst</code> They represent a decomposition of a function with respect to a set of (all possible) shifted wavelets. 
</p>


<h3>Details</h3>

<p>To retain your sanity we recommend that the coefficients from a <code>wst</code> object be extracted in one of two ways: 
</p>

<ul>
<li><p>use <code><a href="#topic+getpacket.wst">getpacket.wst</a></code> to obtain individual packets of either father or mother wavelet coefficients.
</p>
</li>
<li><p>use <code><a href="#topic+accessD.wst">accessD.wst</a></code> to obtain all mother coefficients at a particular resolution level.
</p>
</li>
<li><p>use <code><a href="#topic+accessC.wst">accessC.wst</a></code> to obtain all father coefficients at a particular resolution level.
</p>
</li></ul>

<p>You can obtain the coefficients directly from the <code>wst$wp</code> component (mother) or <code>wst$Carray</code> component (father) but you have to understand their organization described above. 
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate &lsquo;wst&rsquo; object. 
</p>
<table role = "presentation">
<tr><td><code>wp</code></td>
<td>
<p>a matrix containing the packet ordered non-decimated wavelet coefficients. Each row of the matrix contains coefficients with respect to a particular resolution level. There are <code>nlevelsWT(wst)+1</code> rows in the matrix. Row <code>nlevels(wst)+1</code> (the &ldquo;bottom&rdquo;) row contains the &ldquo;original&rdquo; data used to produce the wavelet packet coefficients. Rows <code>nlevels(wst)</code> to row 1 contain coefficients at resolution levels <code>nlevels(wst)-1</code> to 0 (so the first row contains coefficients at resolution level 0).
</p>
<p>The columns contain the coefficients with respect to packets. A different packet length exists at each resolution level. The packet length at resolution level <code>i</code> is given by <code>2^i</code>. However, the <code><a href="#topic+getpacket.wst">getpacket.wst</a></code> function should be used to access individual packets from a <code><a href="#topic+wst">wst</a></code> object.</p>
</td></tr>
<tr><td><code>Carray</code></td>
<td>
<p>A matrix of the same dimensions and format as <code>wp</code> but containing the father wavelet coefficients.</p>
</td></tr>
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of levels in the decomposition. If you raise 2 to the power of <code>nlevels</code> you get the number of data points used in the decomposition.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>a list containing the details of the filter that did the decomposition (equivalent to the return value from the <code><a href="#topic+filter.select">filter.select</a></code> function).</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>The date that the transform was performed or the wst was modified.</p>
</td></tr> 
</table>


<h3>GENERATION</h3>

<p>This class of objects is returned from the <code><a href="#topic+wst">wst</a></code> function which computes the <em>packets-ordered</em> non-decimated wavelet transform (effectively all possible shifts of the standard discrete wavelet transform). 
</p>
<p>Many other functions return an object of class <code>wst</code>. 
</p>


<h3>METHODS</h3>

<p>The wst class of objects has methods for the following generic functions: <code><a href="#topic+AvBasis">AvBasis</a></code>, <code><a href="#topic+InvBasis">InvBasis</a></code>, <code><a href="#topic+LocalSpec">LocalSpec</a></code>, <code><a href="#topic+MaNoVe">MaNoVe</a></code>, <code><a href="#topic+accessC">accessC</a></code>, <code><a href="#topic+accessD">accessD</a></code>, <code><a href="#topic+convert">convert</a></code>, <code><a href="#topic+draw">draw</a></code>. <code><a href="#topic+getpacket">getpacket</a></code>. <code><a href="graphics.html#topic+image">image</a></code>. <code><a href="#topic+nlevelsWT">nlevelsWT</a></code>, <code><a href="#topic+nullevels">nullevels</a></code>, <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+putC">putC</a></code>, <code><a href="#topic+putD">putD</a></code>, <code><a href="#topic+putpacket">putpacket</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+threshold">threshold</a></code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst">wst</a></code>
</p>

<hr>
<h2 id='wst2D'>(Packet-ordered) 2D non-decimated wavelet transform.</h2><span id='topic+wst2D'></span>

<h3>Description</h3>

<p>This function computes the (packet-ordered) 2D non-decimated wavelet transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wst2D(m, filter.number=10, family="DaubLeAsymm")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wst2D_+3A_m">m</code></td>
<td>
<p>A matrix containing the image data that you wish to decompose. Each dimension of the matrix must be the same power of 2.</p>
</td></tr>
<tr><td><code id="wst2D_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments.</p>
</td></tr>
<tr><td><code id="wst2D_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. Two popular options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot; but see the help for <code><a href="#topic+filter.select">filter.select</a></code> for more possibilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>wst2D</code> computes the (packet-ordered) 2D non-decimated discrete wavelet transform. Such a transform may be used in wavelet shrinkage of images using the <code><a href="#topic+AvBasis.wst2D">AvBasis.wst2D</a></code> function to perform an &quot;average-basis&quot; inverse. Such a transform was used to denoise images in the paper by Lang, Guo, Odegard, Burrus and Wells, 1995. 
</p>
<p>The algorithm works by mixing the HH, GH, HG and GG image operators of the 2D (decimated) discrete wavelet transform (see Mallat, 1989 and the implementation in WaveThresh called <code><a href="#topic+imwd">imwd</a></code>) with the shift operator S (as documented in Nason and Silverman, 1995) to form new operators (as given in the help to <code><a href="#topic+getpacket.wst2D">getpacket.wst2D</a></code>). 
</p>
<p>Subimages can be obtained and replaced using the <code><a href="#topic+getpacket.wst2D">getpacket.wst2D</a></code> and <code><a href="#topic+putpacket.wst2D">putpacket.wst2D</a></code> functions. 
</p>
<p>This function is a 2D analogue of the (packet-ordered) non-decimated discrete wavelet transform implemented in WaveThresh as <code><a href="#topic+wst">wst</a></code>. 
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+wst2D">wst2D</a></code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.5 Copyright Guy Nason 1998</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+AvBasis.wst2D">AvBasis.wst2D</a></code>, <code><a href="#topic+getpacket.wst2D">getpacket.wst2D</a></code>, <code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+plot.wst2D">plot.wst2D</a></code>, <code><a href="#topic+print.wst2D">print.wst2D</a></code>, <code><a href="#topic+putpacket.wst2D">putpacket.wst2D</a></code>, <code><a href="#topic+summary.wst2D">summary.wst2D</a></code>, <code><a href="#topic+wst2D.object">wst2D.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# We shall use the lennon image.
#
data(lennon)
#
#
# Now let's apply the (packet-ordered) 2D non-decimated DWT to it...
# (using the default wavelets)
#
uawst2D &lt;- wst2D(lennon)
#
# One can use the function plot.wst2D to get
# a picture of all the resolution levels. However, let's just look at them
# one at a time.
#
# How many levels does our uawst2D object have? 
#
nlevelsWT(uawst2D)
#[1] 8
#
# O.k. Let's look at resolution level 7
#
## Not run: image(uawst2D$wst2D[8,,])
#
#
# There are four main blocks here (each of 256x256 pixels) which themselves
# contain four sub-blocks. The primary blocks correspond to the no shift,
# horizontal shift, vertical shift and "horizontal and vertical" shifts
# generated by the shift S operator. Within each of the 256x256 blocks
# we have the "usual" Mallat smooth, horizontal, vertical and diagonal
# detail, with the smooth in the top left of each block.
#
# Let's extract the smooth, with no shifts at level 7 and display it
#
## Not run: image(getpacket(uawst2D, level=7, index=0, type="S"))
#
#
# Now if we go two more resolution levels deeper we have now 64x64 blocks
# which contain 32x32 subblocks corresponding to the smooth, horizontal,
# vertical and diagonal detail. 
#
#
# Groovy eh?
</code></pre>

<hr>
<h2 id='wst2D.object'>(Packet ordered) Two-dimensional nondecimated wavelet transform decomposition objects.</h2><span id='topic+wst2D.object'></span>

<h3>Description</h3>

<p>These are objects of class <code>wst2D</code> They represent a decomposition of a function with respect to a set of (all possible) shifted two-dimensional wavelets. They are a 2D extension of the <code><a href="#topic+wst.object">wst.object</a></code>. 
</p>


<h3>Details</h3>

<p>To retain your sanity we recommend that the coefficients from a <code>wst2D</code> object be extracted or replaced using 
</p>

<ul>
<li><p><code><a href="#topic+getpacket.wst2D">getpacket.wst2D</a></code> to obtain individual packets of either father or mother wavelet coefficients.
</p>
</li>
<li><p><code><a href="#topic+putpacket.wst2D">putpacket.wst2D</a></code> to insert coefficients.
</p>
</li></ul>

<p>You can obtain the coefficients directly from the <code>wst2D$wst2D</code> component but you have to understand their organization described above.</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate <code>wst2D</code> object. 
</p>
<table role = "presentation">
<tr><td><code>wst2D</code></td>
<td>
<p>This a three-dimensional array. Suppose that the original image that created the <code>wst2D</code> object is n x n. Then the dimension of the <code>wst2D</code> array is [ nlevelsWT, 2n, 2n]. The first index of the array refers to the resolution level of the array with &quot;resolution level = index - 1&quot; (so, e.g. the coarsest scale detailed is stored at index 1 and the finest at index nlevels). For a given resolution level (selected first index) the associated 2n x 2n matrix contains the two-dimensional non-decimated wavelet coefficients for that level packed as follows. 
</p>
<p>At the finest resolution level the 2n x 2n coefficient image may be broken up into four n x n subimages. Each of the four images corresponds to data shifts in the horizontal and vertical directions. The top left image corresponds to &ldquo;no shift&rdquo; and indeed the top left image corresponds to the coefficients obtained using the decimated 2D wavelet transform as obtained using the <code><a href="#topic+imwd">imwd</a></code> function. The top right image corresponds to a horizontal data shift; the bottom left to a vertical data shift and the bottom right corresponds to both horizontal and vertical data shift. 
</p>
<p>Within each of the four n x n images named in the previous paragraph are again 4 subimages each of dimension n/2 x n/2. These correspond to (starting at the top left and moving clockwise) the smooth (CC), horizontal detail (DC), diagonal detail (DD) and vertical detail (CD). 
</p>
<p>At coarser resolution levels the coefficients are smaller submatrices corresponding to various levels of data shifts and types of detail (smooth, horizontal, vertical, diagonal). 
</p>
<p>We strongly recommend the use of the <code><a href="#topic+getpacket.wst2D">getpacket.wst2D</a></code> and <code><a href="#topic+putpacket.wst2D">putpacket.wst2D</a></code> functions to remove and replace coefficients from <code>wst2D</code></p>
</td></tr></table>
<p> objects.
</p>
<table role = "presentation">
<tr><td><code>nlevelsWT</code></td>
<td>
<p>The number of levels in the decomposition. If you raise 2 to the power of 2 <code>nlevels</code> you get the number of data points used in the decomposition.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>a list containing the details of the filter that did the decomposition (equivalent to the return value from the <code><a href="#topic+filter.select">filter.select</a></code> function).</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>The date that the transform was performed or the <code>wst2D</code> was modified.</p>
</td></tr> 
</table>


<h3>GENERATION</h3>

<p>This class of objects is returned from the <code><a href="#topic+wst2D">wst2D</a></code> function which computes the <em>packets-ordered</em> two-dimensional non-decimated wavelet transform (effectively all possible shifts of the standard two-dimensional discrete wavelet transform). 
</p>
<p>Many other functions return an object of class <code>wst2D</code>. 
</p>


<h3>METHODS</h3>

<p>The wst2D class of objects has methods for the following generic functions: <code><a href="#topic+AvBasis">AvBasis</a></code>, <code><a href="#topic+getpacket">getpacket</a></code>. <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+putpacket">putpacket</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+wst2D">wst2D</a></code>
</p>

<hr>
<h2 id='wstCV'>Performs two-fold cross-validation estimation using packet-ordered non-decimated wavelet transforms and one, global, threshold. </h2><span id='topic+wstCV'></span>

<h3>Description</h3>

<p>Performs Nason's 1996 two-fold cross-validation estimation using packet-ordered non-decimated wavelet transforms and one, global, threshold. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wstCV(ndata, ll = 3, type = "soft", filter.number = 10, family = 
	"DaubLeAsymm", tol = 0.01, verbose = 0, plot.it = FALSE, norm = 
	l2norm, InverseType = "average", uvdev = madmad)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wstCV_+3A_ndata">ndata</code></td>
<td>
<p>the noisy data. This is a vector containing the signal plus noise. The length of this vector should be a power of two.</p>
</td></tr>
<tr><td><code id="wstCV_+3A_ll">ll</code></td>
<td>
<p>the primary resolution for this estimation. Note that the primary resolution is <em>problem-specific</em>: you have to find out which is the best value.</p>
</td></tr>
<tr><td><code id="wstCV_+3A_type">type</code></td>
<td>
<p>whether to use hard or soft thresholding. See the explanation for this argument in the <code><a href="#topic+threshold.wst">threshold.wst</a></code> function.</p>
</td></tr>
<tr><td><code id="wstCV_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments.</p>
</td></tr>
<tr><td><code id="wstCV_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="wstCV_+3A_tol">tol</code></td>
<td>
<p>the cross-validation tolerance which decides when an estimate is sufficiently close to the truth (or estimated to be so).</p>
</td></tr>
<tr><td><code id="wstCV_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then informative messages are printed during the progression of the function, otherwise they are not.</p>
</td></tr>
<tr><td><code id="wstCV_+3A_plot.it">plot.it</code></td>
<td>
<p>If <code>TRUE</code> then a plot of the progress of optimising the error estimate for different values of the threshold is generated as the algorithm proceeds. The algorithm tries to minimize the error estimate so you should see a &ldquo;bowl&rdquo; developing. After each iteration the error estimate is plotted with the iteration number so you should see the numbers tend to the bottom of the bowl.</p>
</td></tr>
<tr><td><code id="wstCV_+3A_norm">norm</code></td>
<td>
<p>which measure of distance to judge the dissimilarity between the estimates. The functions <code><a href="#topic+l2norm">l2norm</a></code> and <code><a href="#topic+linfnorm">linfnorm</a></code> are suitable examples.</p>
</td></tr>
<tr><td><code id="wstCV_+3A_inversetype">InverseType</code></td>
<td>
<p>The possible options are &quot;average&quot; or &quot;minent&quot;. The former uses basis averaging to form estimates of the unknown function. The &quot;minent&quot; function selects a basis using the Coifman and Wickerhauser, 1992 algorithm to select a basis to invert.</p>
</td></tr>
<tr><td><code id="wstCV_+3A_uvdev">uvdev</code></td>
<td>
<p>Universal thresholding is used to generate an upper bound for the ideal threshold. This argument provides the function that computes an estimate of the variance of the noise for use with the universal threshold calculation (see <code><a href="#topic+threshold.wst">threshold.wst</a></code>).</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function implements the cross-validation method detailed by Nason, 1996 for computing an estimate of the error between an estimate and the &ldquo;truth&rdquo;. The difference here is that it uses the <code>packet ordered non-decimated wavelet transform</code> rather than the standard Mallat <code><a href="#topic+wd">wd</a></code> discrete wavelet transform. As such it is an examples of the translation-invariant denoising of Coifman and Donoho, 1995 but uses cross-validation to choose the threshold rather than SUREshrink. 
</p>
<p>Note that the procedure outlined above can use <code><a href="#topic+AvBasis">AvBasis</a></code> basis averaging or basis selection and inversion using the Coifman and Wickerhauser, 1992 best-basis algorithm 
</p>


<h3>Value</h3>

<p>A list returning the results of the cross-validation algorithm. The list includes the following components: 
</p>
<table role = "presentation">
<tr><td><code>ndata</code></td>
<td>
<p>a copy of the input noisy data</p>
</td></tr>
<tr><td><code>xvwr</code></td>
<td>
<p>a reconstruction of the best estimate computed using this algorithm. It is the inverse (computed depending on what the InverseType argument was) of the <code>xvwrWSTt</code> component. </p>
</td></tr>
<tr><td><code>xvwrWSTt</code></td>
<td>
<p>a thresholded version of the packet-ordered non-decimated wavelet transform of the noisy data using the best threshold discovered by this cross-validation algorithm.</p>
</td></tr>
<tr><td><code>uvt</code></td>
<td>
<p>the universal threshold used as the upper bound for the algorithm that tries to discover the optimal cross-validation threshold. The lower bound is always zero.</p>
</td></tr>
<tr><td><code>xvthresh</code></td>
<td>
<p>the best threshold as discovered by cross-validation. Note that this is one number, the global threshold. The <code><a href="#topic+wstCVl">wstCVl</a></code> function should be used to compute a level-dependent threshold. </p>
</td></tr>
<tr><td><code>xkeep</code></td>
<td>
<p>a vector containing the various thresholds used by the optimisation algorithm in trying to determine the best one. The length of this vector cannot be pre-determined but depends on the noisy data, thresholding method, and optimisation tolerance. </p>
</td></tr>
<tr><td><code>fkeep</code></td>
<td>
<p>a vector containing the value of the estimated error used by the optimisation algorithm in trying to minimize the estimated error. The length, like that of xkeep cannot be predetermined for the same reasons.</p>
</td></tr>
</table>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1995</p>


<h3>Note</h3>

<p>If <code>plot.it</code> is <code>TRUE</code> then a plot indicating the progression of the optimisation algorithm is plotted. 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetRSSWST">GetRSSWST</a></code>, <code><a href="#topic+linfnorm">linfnorm</a></code>, <code><a href="#topic+linfnorm">linfnorm</a></code>, <code><a href="#topic+threshold.wst">threshold.wst</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+wstCVl">wstCVl</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Example PENDING
#
</code></pre>

<hr>
<h2 id='wstCVl'>Performs two-fold cross-validation estimation using packet-ordered non-decimated wavelet transforms and a (vector) level-dependent threshold. </h2><span id='topic+wstCVl'></span>

<h3>Description</h3>

<p>Performs Nason's 1996 two-fold cross-validation estimation using packet-ordered non-decimated wavelet transforms and a (vector) level-dependent threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wstCVl(ndata, ll = 3, type = "soft", filter.number = 10, family = "DaubLeAsymm",
	tol = 0.01, verbose = 0, plot.it = FALSE, norm = l2norm, InverseType = "average",
	uvdev = madmad)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wstCVl_+3A_ndata">ndata</code></td>
<td>
<p>the noisy data. This is a vector containing the signal plus noise. The length of this vector should be a power of two.</p>
</td></tr>
<tr><td><code id="wstCVl_+3A_ll">ll</code></td>
<td>
<p>the primary resolution for this estimation. Note that the primary resolution is <em>problem-specific</em>: you have to find out which is the best value.</p>
</td></tr>
<tr><td><code id="wstCVl_+3A_type">type</code></td>
<td>
<p>whether to use hard or soft thresholding. See the explanation for this argument in the <code><a href="#topic+threshold.wst">threshold.wst</a></code> function.</p>
</td></tr>
<tr><td><code id="wstCVl_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments.</p>
</td></tr>
<tr><td><code id="wstCVl_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="wstCVl_+3A_tol">tol</code></td>
<td>
<p>the cross-validation tolerance which decides when an estimate is sufficiently close to the truth (or estimated to be so).</p>
</td></tr>
<tr><td><code id="wstCVl_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then informative messages are printed during the progression of the function, otherwise they are not.</p>
</td></tr>
<tr><td><code id="wstCVl_+3A_plot.it">plot.it</code></td>
<td>
<p>Whether or not to produce a plot indicating progress.</p>
</td></tr>
<tr><td><code id="wstCVl_+3A_norm">norm</code></td>
<td>
<p>which measure of distance to judge the dissimilarity between the estimates. The functions <code><a href="#topic+l2norm">l2norm</a></code> and <code><a href="#topic+linfnorm">linfnorm</a></code> are suitable examples.</p>
</td></tr>
<tr><td><code id="wstCVl_+3A_inversetype">InverseType</code></td>
<td>
<p>The possible options are &quot;average&quot; or &quot;minent&quot;. The former uses basis averaging to form estimates of the unknown function. The &quot;minent&quot; function selects a basis using the Coifman and Wickerhauser, 1992 algorithm to select a basis to invert.</p>
</td></tr>
<tr><td><code id="wstCVl_+3A_uvdev">uvdev</code></td>
<td>
<p>Universal thresholding is used to generate an upper bound for the ideal threshold. This argument provides the function that computes an estimate of the variance of the noise for use with the universal threshold calculation (see <code><a href="#topic+threshold.wst">threshold.wst</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements a modified version of the cross-validation method detailed by Nason, 1996 for computing an estimate of the error between an estimate and the &ldquo;truth&rdquo;. The difference here is that it uses the packet ordered non-decimated wavelet transform rather than the standard Mallat wd discrete wavelet transform. As such it is an examples of the translation-invariant denoising of Coifman and Donoho, 1995 but uses cross-validation to choose the threshold rather than SUREshrink. 
</p>
<p>Further, this function computes level-dependent thresholds. That is, it can compute a different threshold for each resolution level. 
</p>
<p>Note that the procedure outlined above can use <code><a href="#topic+AvBasis">AvBasis</a></code> basis averaging or basis selection and inversion using the Coifman and Wickerhauser, 1992 best-basis algorithm 
</p>


<h3>Value</h3>

<p>A list returning the results of the cross-validation algorithm. The list includes the following components: 
</p>
<table role = "presentation">
<tr><td><code>ndata</code></td>
<td>
<p>a copy of the input noisy data</p>
</td></tr>
<tr><td><code>xvwr</code></td>
<td>
<p>a reconstruction of the best estimate computed using this algorithm. It is the inverse (computed depending on what the InverseType argument was) of the <code>xvwrWSTt</code> component.</p>
</td></tr> 
<tr><td><code>xvwrWSTt</code></td>
<td>
<p>a thresholded version of the packet-ordered non-decimated wavelet transform of the noisy data using the best threshold discovered by this cross-validation algorithm.</p>
</td></tr> 
<tr><td><code>uvt</code></td>
<td>
<p>the universal threshold used as the upper bound for the algorithm that tries to discover the optimal cross-validation threshold. The lower bound is always zero.</p>
</td></tr>
<tr><td><code>xvthresh</code></td>
<td>
<p>the best threshold as discovered by cross-validation. Note that this is vector, a level-dependent threshold with one threshold value for each resolution level. The first entry corresponds to level <code>ll</code>, the last entry corresponds to level <code>nlevelsWT(ndata)-1</code> and the entries in between linearly to the levels in between. The <code><a href="#topic+wstCV">wstCV</a></code> function should be used to compute a global threshold.</p>
</td></tr>
<tr><td><code>optres</code></td>
<td>
<p>The results from performing the optimisation using the <code>nlminb</code> function from Splus. This object contains many interesting components with information about how the optimisation went. See the <code>nlminb</code> help page for information.</p>
</td></tr>
</table>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1995 
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetRSSWST">GetRSSWST</a></code>, <code><a href="#topic+linfnorm">linfnorm</a></code>, <code><a href="#topic+linfnorm">linfnorm</a></code>, <code><a href="#topic+threshold.wst">threshold.wst</a></code>, <code><a href="#topic+wst">wst</a></code>, <code><a href="#topic+wst.object">wst.object</a></code>, <code><a href="#topic+wstCV">wstCV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Example PENDING
#
</code></pre>

<hr>
<h2 id='WTEnv'>Environment that exists to store intermediate calculations for re-use within the same R session.</h2><span id='topic+WTEnv'></span>

<h3>Description</h3>

<p>Environment that stores results of long calculations so that they can be made available for immediate reuse.
</p>


<h3>Details</h3>

<p>This environment is created on package load by wavethresh. The results of some intermediate calculations get stored in here (notably by
<code><a href="#topic+PsiJ">PsiJ</a></code>, <code><a href="#topic+PsiJmat">PsiJmat</a></code> and <code><a href="#topic+ipndacw">ipndacw</a></code>). The
reason for this is that the calculations are typically lengthy and it saves
wavethresh time to search the <code>WTEnv</code> for pre-computed results.
For example, <code><a href="#topic+ipndacw">ipndacw</a></code> computes matrices of various orders.
Matrices of low order form the upper-left corner of matrices of higher order
so higher order matrix calculations can make use of the lower order instances.
</p>
<p>A similar functionality was present in wavethresh in versions 4.6.1 and
prior to this. In previous versions computations were saved in the users
current data directory. However, the user was never notified about this
nor permission sought. 
</p>
<p>The environment <code>WTEnv</code> disappears when the package disappears
and the R session stops - and results of all intermediate calculations
disappear too. This might not matter if you never use the larger objects
(as it will not take much time to recompute). 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+ipndacw">ipndacw</a></code>, <code><a href="#topic+PsiJ">PsiJ</a></code>, <code><a href="#topic+PsiJmat">PsiJmat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See what it is
#
WTEnv
#&lt;environment: 0x102fc3830&gt;
#
# Compute something that uses the environment
#
fred &lt;- PsiJ(-5)
#
# Now let's see what got put in
#
ls(envir=WTEnv)
#[1] "Psi.5.10.DaubLeAsymm"
</code></pre>

<hr>
<h2 id='wvcvlrss'>Computes estimate of error for function estimate. </h2><span id='topic+wvcvlrss'></span>

<h3>Description</h3>

<p>This function is merely a call to the <code><a href="#topic+GetRSSWST">GetRSSWST</a></code> function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wvcvlrss(threshold, ndata, levels, type, filter.number, family, norm, 
	verbose, InverseType)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wvcvlrss_+3A_threshold">threshold</code></td>
<td>
<p>the value of the threshold that you wish to compute the error of the estimate at</p>
</td></tr>
<tr><td><code id="wvcvlrss_+3A_ndata">ndata</code></td>
<td>
<p>the noisy data. This is a vector containing the signal plus noise. The length of this vector should be a power of two.</p>
</td></tr>
<tr><td><code id="wvcvlrss_+3A_levels">levels</code></td>
<td>
<p>the levels over which you wish the threshold value to be computed (the threshold that is used in computing the estimate and error in the estimate). See the explanation for this argument in the <code><a href="#topic+threshold.wst">threshold.wst</a></code> function. </p>
</td></tr>
<tr><td><code id="wvcvlrss_+3A_type">type</code></td>
<td>
<p>whether to use hard or soft thresholding. See the explanation for this argument in the <code><a href="#topic+threshold.wst">threshold.wst</a></code> function.</p>
</td></tr>
<tr><td><code id="wvcvlrss_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments.</p>
</td></tr>
<tr><td><code id="wvcvlrss_+3A_family">family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="wvcvlrss_+3A_norm">norm</code></td>
<td>
<p>which measure of distance to judge the dissimilarity between the estimates. The functions <code><a href="#topic+l2norm">l2norm</a></code> and <code><a href="#topic+linfnorm">linfnorm</a></code> are suitable examples.</p>
</td></tr> 
<tr><td><code id="wvcvlrss_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then informative messages are printed during the progression of the function, otherwise they are not.</p>
</td></tr>
<tr><td><code id="wvcvlrss_+3A_inversetype">InverseType</code></td>
<td>
<p>The possible options are &quot;average&quot; or &quot;minent&quot;. The former uses basis averaging to form estimates of the unknown function. The &quot;minent&quot; function selects a basis using the Coifman and Wickerhauser, 1992 algorithm to select a basis to invert.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is merely a call to the <code><a href="#topic+GetRSSWST">GetRSSWST</a></code> function with a few arguments interchanged. In particular, the first two arguments are interchanged. This is to make life easier for use with the <code>nlminb</code> function which expects the first argument of the function it is trying to optimise to be the variable that the function is optimised over. 
</p>


<h3>Value</h3>

<p>A real number which is estimate of the error between estimate and truth at the given threshold. 
</p>


<h3>RELEASE</h3>

<p>Version 3.6 Copyright Guy Nason 1995 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetRSSWST">GetRSSWST</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# This function performs the error estimation step for the
# wstCVl function and so is not intended for
# user use. 
#
</code></pre>

<hr>
<h2 id='wvmoments'>Compute moments of wavelets or scaling function</h2><span id='topic+wvmoments'></span>

<h3>Description</h3>

<p>Numerically compute moments of wavelets or scaling function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wvmoments(filter.number = 10, family = "DaubLeAsymm", moment = 0,
    scaling.function = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wvmoments_+3A_filter.number">filter.number</code></td>
<td>
<p>The smoothness of wavelet or scaling function to
compute moments for, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="wvmoments_+3A_family">family</code></td>
<td>
<p>The wavelet family to use, see <code><a href="#topic+filter.select">filter.select</a></code></p>
</td></tr>
<tr><td><code id="wvmoments_+3A_moment">moment</code></td>
<td>
<p>The moment to compute</p>
</td></tr>
<tr><td><code id="wvmoments_+3A_scaling.function">scaling.function</code></td>
<td>
<p>If <code>FALSE</code> then a wavelet is used in the
moment calculation, alternatively if <code>TRUE</code> the associated
scaling function is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a wavelet <code class="reqn">\psi(x)</code> this function computes the
mth moment <code class="reqn">\int x^m \psi(x) \, dx</code>.
</p>
<p>Note that for low order moments the integration function often fails for
the usual numerical reasons (this never happened in S!). It might be that
fiddling with the tolerances will improve this situation.
</p>


<h3>Value</h3>

<p>An object of class <code>integrate</code> containing the integral and other
pieces of interesting information about the moments calculation.
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw.default">draw.default</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>wvmoments(filter.number=5, family="DaubExPhase", moment=5)
#-1.317600 with absolute error &lt; 7.5e-05
</code></pre>

<hr>
<h2 id='wvrelease'>Prints out the release number of the WaveThresh package</h2><span id='topic+wvrelease'></span>

<h3>Description</h3>

<p>PRints out the release number of the WaveThresh package, and some
copyright info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wvrelease()
</code></pre>


<h3>Arguments</h3>

<p>None.</p>


<h3>Details</h3>

<p>Description says all
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>Examples</h3>

<pre><code class='language-R'>wvrelease()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
