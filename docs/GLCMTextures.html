<!DOCTYPE html><html><head><title>Help for package GLCMTextures</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GLCMTextures}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#glcm_metrics'><p>Calculates the GLCM Texture Metrics from a GLCM</p></a></li>
<li><a href='#glcm_textures'><p>Calculates GLCM texture metrics of a Raster Layer</p></a></li>
<li><a href='#make_glcm'><p>Creates a symmetrical normalized GLCM for a given matrix and shift</p></a></li>
<li><a href='#quantize_raster'><p>Quantizes raster to a set number of discrete levels</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>GLCM Textures of Raster Layers</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates grey level co-occurrence matrix (GLCM) based texture measures (Hall-Beyer (2017) <a href="https://prism.ucalgary.ca/bitstream/handle/1880/51900/texture%20tutorial%20v%203_0%20180206.pdf">https://prism.ucalgary.ca/bitstream/handle/1880/51900/texture%20tutorial%20v%203_0%20180206.pdf</a>; Haralick et al. (1973) &lt;<a href="https://doi.org/10.1109%2FTSMC.1973.4309314">doi:10.1109/TSMC.1973.4309314</a>&gt;) of raster layers using a sliding rectangular window. It also includes functions to quantize a raster into grey levels as well as tabulate a glcm and calculate glcm texture metrics for a matrix.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ailich/GLCMTextures/issues">https://github.com/ailich/GLCMTextures/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>terra</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, raster</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ailich.github.io/GLCMTextures/">https://ailich.github.io/GLCMTextures/</a>,
<a href="https://github.com/ailich/GLCMTextures">https://github.com/ailich/GLCMTextures</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-22 20:32:34 UTC; socce</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Ilich <a href="https://orcid.org/0000-0003-1758-8499"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Ilich &lt;ailich@usf.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-22 20:53:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='glcm_metrics'>Calculates the GLCM Texture Metrics from a GLCM</h2><span id='topic+glcm_metrics'></span>

<h3>Description</h3>

<p>Calculates the GLCM Texture Metrics from a GLCM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcm_metrics(
  GLCM,
  metrics = c("glcm_contrast", "glcm_dissimilarity", "glcm_homogeneity", "glcm_ASM",
    "glcm_entropy", "glcm_mean", "glcm_variance", "glcm_correlation", "glcm_SA")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glcm_metrics_+3A_glcm">GLCM</code></td>
<td>
<p>A numeric matrix representing a Normalized GLCM.</p>
</td></tr>
<tr><td><code id="glcm_metrics_+3A_metrics">metrics</code></td>
<td>
<p>A vector of texture metrics to return. Valid entries include &quot;glcm_contrast&quot;, &quot;glcm_dissimilarity&quot;, &quot;glcm_homogeneity&quot;, &quot;glcm_ASM&quot;, &quot;glcm_entropy&quot;, &quot;glcm_mean&quot;, &quot;glcm_variance&quot;, &quot;glcm_correlation&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GLCM based texture measures as a numeric vector.
</p>


<h3>References</h3>

<p>Hall-Beyer, M., 2017. GLCM Texture: A Tutorial v. 3.0. University of Calgary, Alberta, Canada.
</p>
<p>Haralick, R.M., Shanmugam, K., Dinstein, I., 1973. Textural features for image classification. IEEE Transactions on Systems, Man, and Cybernetics 610–621. https://doi.org/10.1109/TSMC.1973.4309314
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_matrix&lt;- matrix(data=c(2,0,1,3,0,0,0,3,2), nrow = 3, ncol=3)
horizontal_glcm&lt;- make_glcm(test_matrix, n_levels = 4,
shift = c(1,0), normalize = TRUE)
metrics&lt;-glcm_metrics(horizontal_glcm, metrics= c("glcm_contrast",
"glcm_dissimilarity", "glcm_homogeneity", "glcm_ASM",
"glcm_entropy", "glcm_mean", "glcm_variance", "glcm_correlation"))
</code></pre>

<hr>
<h2 id='glcm_textures'>Calculates GLCM texture metrics of a Raster Layer</h2><span id='topic+glcm_textures'></span>

<h3>Description</h3>

<p>Calculates GLCM texture metrics of a RasterLayer over a sliding rectangular window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcm_textures(
  r,
  w = c(3, 3),
  n_levels,
  shift = list(c(1, 0), c(1, 1), c(0, 1), c(-1, 1)),
  metrics = c("glcm_contrast", "glcm_dissimilarity", "glcm_homogeneity", "glcm_ASM",
    "glcm_entropy", "glcm_mean", "glcm_variance", "glcm_correlation", "glcm_SA"),
  quantization,
  min_val = NULL,
  max_val = NULL,
  maxcell = Inf,
  na.rm = FALSE,
  include_scale = FALSE,
  filename = NULL,
  overwrite = FALSE,
  wopt = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glcm_textures_+3A_r">r</code></td>
<td>
<p>A single layer SpatRaster or RasterLayer. If already quantized set quantization to &quot;none&quot;. The valid range of values for a quantized raster is from 0 to n_levels-1 (e.g. a raster with 32 grey levels would have a valid range of 0-31).</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_w">w</code></td>
<td>
<p>A vector of length 2 specifying the dimensions of the rectangular window to use where the first number is the number of rows and the second number is the number of columns. Window size must be an odd number.</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_n_levels">n_levels</code></td>
<td>
<p>Number of grey levels used in the quantization (Typically set to 16 or 32).</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_shift">shift</code></td>
<td>
<p>A vector of length 2, or a list of vectors each of length 2 specifying the relationship between neighboring pixel to the reference pixel. The first number represents the shift in the x direction and the second number represents the shift in the y direction, where up and right are positive. For example c(1,0) is the pixel directly to the right. The GLCM is made symmetrical by counting each pair twice, once &quot;forwards&quot; and once &quot;backwards&quot; by interchanging reference and neighbor pixels. Therefore a shift directly to the right c(1,0) is equivalent to a shift directly to the left c(-1,0). To average over &quot;all directions&quot; you can use shift=list(c(1,0), c(1,1), c(0,1), c(-1,1)), which is the default.</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_metrics">metrics</code></td>
<td>
<p>A vector of glcm texture metrics to return. Valid entries include &quot;glcm_contrast&quot;, &quot;glcm_dissimilarity&quot;, &quot;glcm_homogeneity&quot;, &quot;glcm_ASM&quot; (angular second moment), &quot;glcm_entropy&quot;, &quot;glcm_mean&quot;, &quot;glcm_variance&quot;, &quot;glcm_correlation&quot;, &quot;glcm_SA&quot; (Sum Average).</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_quantization">quantization</code></td>
<td>
<p>quantization method (either &quot;equal range&quot;, &quot;equal prob&quot;, or &quot;none&quot;). &quot;equal range&quot; quantization will create bins that cover a range of equal size. &quot;equal prob&quot; performs equal probability quantization and will use quantiles to create bins with approximately equal number of samples. &quot;none&quot; means the layer has already been quantized.</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_min_val">min_val</code></td>
<td>
<p>minimum value for equal range quantization (if not supplied, the minimum value of the raster is used)</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_max_val">max_val</code></td>
<td>
<p>maximum value for equal range quantization (if not supplied, the maximum value of the raster is used)</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer used to take a regular sample for quantization if &quot;equal prob&quot; is used (default is Inf)</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds (default=FALSE)</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_include_scale">include_scale</code></td>
<td>
<p>Logical indicating whether to append window size to the layer names (default = FALSE).</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_filename">filename</code></td>
<td>
<p>character Output filename. Can be a single filename, or as many filenames as there are layers to write a file for each layer</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If TRUE, filename is overwritten (default is FALSE).</p>
</td></tr>
<tr><td><code id="glcm_textures_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in writeRaster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatRaster or Raster* Object
</p>


<h3>References</h3>

<p>Hall-Beyer, M., 2017. GLCM Texture: A Tutorial v. 3.0. University of Calgary, Alberta, Canada.
</p>
<p>Haralick, R.M., Shanmugam, K., Dinstein, I., 1973. Textural features for image classification. IEEE Transactions on Systems, Man, and Cybernetics 610–621. https://doi.org/10.1109/TSMC.1973.4309314
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r&lt;- rast(volcano, extent= ext(2667400, 2667400 + ncol(volcano)*10,
6478700, 6478700 + nrow(volcano)*10), crs = "EPSG:27200")
txt &lt;- glcm_textures(r, w = c(3,5), n_levels = 16,
quantization = "equal prob", shift = list(c(1, 0), c(1, 1),
c(0, 1), c(-1, 1)))
plot(txt)
</code></pre>

<hr>
<h2 id='make_glcm'>Creates a symmetrical normalized GLCM for a given matrix and shift</h2><span id='topic+make_glcm'></span>

<h3>Description</h3>

<p>Creates a symmetrical normalized GLCM for a given matrix and shift
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_glcm(x, n_levels, shift, na.rm = FALSE, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_glcm_+3A_x">x</code></td>
<td>
<p>a matrix of integers representing quantized values. The valid range of values is from 0 to n_levels-1 (e.g. a matrix with 32 grey levels would have a valid range of 0-31).</p>
</td></tr>
<tr><td><code id="make_glcm_+3A_n_levels">n_levels</code></td>
<td>
<p>Number of grey levels used in the quantization</p>
</td></tr>
<tr><td><code id="make_glcm_+3A_shift">shift</code></td>
<td>
<p>A vector of length 2 specifying the relationship between neighboring pixel to the reference pixel. The first number represents the shift in the x direction and the second number represents the shift in the y direction, where up and right are positive. For example c(1,0) is the pixel directly to the right. The GLCM is made symmetrical by counting each pair twice, once &quot;forwards&quot; and once &quot;backwards&quot; by interchanging reference and neighbor pixels. Therefore a shift directly to the right c(1,0) is equivalent to a shift directly to the left c(-1,0)</p>
</td></tr>
<tr><td><code id="make_glcm_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds (default=FALSE)</p>
</td></tr>
<tr><td><code id="make_glcm_+3A_normalize">normalize</code></td>
<td>
<p>a logical specifying whether to normalize the counts to probabilities by dividing by the sum of the GLCM (TRUE, the default) or to express the GLCM as counts (FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric GLCM as a matrix
</p>


<h3>References</h3>

<p>Hall-Beyer, M., 2017. GLCM Texture: A Tutorial v. 3.0. University of Calgary, Alberta, Canada.
</p>
<p>Haralick, R.M., Shanmugam, K., Dinstein, I., 1973. Textural features for image classification. IEEE Transactions on Systems, Man, and Cybernetics 610–621. https://doi.org/10.1109/TSMC.1973.4309314
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_matrix&lt;- matrix(data=c(2,0,1,3,0,0,0,3,2), nrow = 3, ncol=3)
# Tabulate a GLCM of counts
horizontal_glcm_counts&lt;- make_glcm(test_matrix, n_levels = 4, shift = c(1,0), normalize = FALSE)
# Calculate a normalized GLCM of probabilities
horizontal_glcm_norm&lt;- make_glcm(test_matrix, n_levels = 4, shift = c(1,0), normalize = TRUE)
</code></pre>

<hr>
<h2 id='quantize_raster'>Quantizes raster to a set number of discrete levels</h2><span id='topic+quantize_raster'></span>

<h3>Description</h3>

<p>Quantizes raster to a set number of discrete levels starting at 0. There are 2 methods of quantization are available: &quot;uniform&quot; and &quot;equal prob&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantize_raster(
  r,
  n_levels,
  method,
  min_val = NULL,
  max_val = NULL,
  maxcell = Inf,
  filename = NULL,
  overwrite = FALSE,
  wopt = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantize_raster_+3A_r">r</code></td>
<td>
<p>A single layer SpatRaster or RasterLayer.</p>
</td></tr>
<tr><td><code id="quantize_raster_+3A_n_levels">n_levels</code></td>
<td>
<p>number of levels to quantize to</p>
</td></tr>
<tr><td><code id="quantize_raster_+3A_method">method</code></td>
<td>
<p>quantization method (either &quot;equal range&quot; or &quot;equal prob&quot;). &quot;equal range&quot; quantization will create bins that cover a range of equal size. &quot;equal prob&quot; performs equal probability quantization and will use quantiles to create bins with approximately equal number of samples.</p>
</td></tr>
<tr><td><code id="quantize_raster_+3A_min_val">min_val</code></td>
<td>
<p>minimum value for equal range quantization (if not supplied, the minimum value of the raster is used)</p>
</td></tr>
<tr><td><code id="quantize_raster_+3A_max_val">max_val</code></td>
<td>
<p>maximum value for equal range quantization (if not supplied, the maximum value of the raster is used)</p>
</td></tr>
<tr><td><code id="quantize_raster_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer used to take a regular sample of x if &quot;equal prob&quot; is used (default is Inf)</p>
</td></tr>
<tr><td><code id="quantize_raster_+3A_filename">filename</code></td>
<td>
<p>character Output filename.</p>
</td></tr>
<tr><td><code id="quantize_raster_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If TRUE, filename is overwritten (default is FALSE).</p>
</td></tr>
<tr><td><code id="quantize_raster_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in writeRaster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equal probability quantization is the method recommended in Haralick et al., 1973. However, equal range may be more desirable if making comparisons across several different rasters where you need the gray levels to correspond in a consistent way to the original data, as you can supply the global max/min or the theoretical max/min values that could occur. When equal probability quantization is used, quantiles are generated using type 8 as recommended by Hyndman and Fan (1996). This method provides estimates that are approximately median-unbiased regardless of the distribution of x.
</p>


<h3>Value</h3>

<p>a single layer SpatRaster or RasterLayer with integer values ranging from 0 to n_levels-1
</p>


<h3>References</h3>

<p>Haralick, R.M., Shanmugam, K., Dinstein, I., 1973. Textural features for image classification. IEEE Transactions on Systems, Man, and Cybernetics 610–621. https://doi.org/10.1109/TSMC.1973.4309314
</p>
<p>Hyndman, R.J., Fan, Y., 1996. Sample Quantiles in Statistical Packages. The American Statistician 50, 361–365. https://doi.org/10.1080/00031305.1996.10473566
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r&lt;- rast(volcano, extent= ext(2667400, 2667400 + ncol(volcano)*10,
6478700, 6478700 + nrow(volcano)*10),
crs = "EPSG:27200")
rq1 &lt;- quantize_raster(r = r, n_levels = 16, method = "equal prob")
rq2 &lt;- quantize_raster(r = r, n_levels = 16, method = "equal range")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
