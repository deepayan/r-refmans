<!DOCTYPE html><html lang="en"><head><title>Help for package polysat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {polysat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Accessors'>
<p>Accessor and Replacement Functions for &quot;gendata&quot; Objects</p></a></li>
<li><a href='#alleleCorrelations'>
<p>Assign Alleles to Isoloci Based on Distribution of Genotypes</p></a></li>
<li><a href='#alleleDiversity'>
<p>Retrieve and Count Unique Alleles</p></a></li>
<li><a href='#AllopolyTutorialData'>
<p>Simulated Allotetraploid Data</p></a></li>
<li><a href='#assignClones'>
<p>Group Individuals Based on a Distance Threshold</p></a></li>
<li><a href='#Bruvo.distance'><p>Genetic Distance Metric of Bruvo et al.</p></a></li>
<li><a href='#Bruvo2.distance'>
<p>Distance Measure of Bruvo et al. under Genome Loss and Addition</p></a></li>
<li><a href='#calcPopDiff'>
<p>Estimate Population Differentiation Statistics</p></a></li>
<li><a href='#catalanAlleles'>
<p>Sort Alleles into Isoloci</p></a></li>
<li><a href='#deleteSamples'>
<p>Remove Samples or Loci from an Object</p></a></li>
<li><a href='#deSilvaFreq'>
<p>Estimate Allele Frequencies with EM Algorithm</p></a></li>
<li><a href='#editGenotypes'>
<p>Edit Genotypes Using the Data Editor</p></a></li>
<li><a href='#estimatePloidy'>
<p>Estimate Ploidies Based on Allele Counts</p></a></li>
<li><a href='#FCRinfo'><p>Additional Data on Rubus Samples</p></a></li>
<li><a href='#find.missing.gen'>
<p>Find Missing Genotypes</p></a></li>
<li><a href='#freq.to.genpop'>
<p>Convert Allele Frequencies for Adegenet</p></a></li>
<li><a href='#genambig-class'><p>Class &quot;genambig&quot;</p></a></li>
<li><a href='#genambig.to.genbinary'>
<p>Convert Between Genotype Object Classes</p></a></li>
<li><a href='#genbinary-class'><p>Class &quot;genbinary&quot;</p></a></li>
<li><a href='#gendata-class'><p>Class &quot;gendata&quot;</p></a></li>
<li><a href='#gendata.to.genind'>
<p>Convert Data to genind Format</p></a></li>
<li><a href='#genIndex'>
<p>Find All Unique Genotypes for a Locus</p></a></li>
<li><a href='#genotypeDiversity'>
<p>Genotype Diversity Statistics</p></a></li>
<li><a href='#genotypeProbs'>
<p>Calculate Probabilities of Unambiguous Genotypes</p></a></li>
<li><a href='#Internal+20Functions'><p>Internal Functions in polysat</p></a></li>
<li><a href='#isMissing'>
<p>Determine Whether Genotypes Are Missing</p></a></li>
<li><a href='#Lynch.distance'>
<p>Calculate Band-Sharing Dissimilarity Between Genotypes</p></a></li>
<li><a href='#meandist.from.array'>
<p>Tools for Working With Pairwise Distance Arrays</p></a></li>
<li><a href='#meandistance.matrix'><p>Mean Pairwise Distance Matrix</p></a></li>
<li><a href='#merge-methods'><p> Merge Two Genotype Objects into One</p></a></li>
<li><a href='#mergeAlleleAssignments'>
<p>Merge Allele Assignment Matrices</p></a></li>
<li><a href='#PIC'>
<p>Polymorphic Information Content</p></a></li>
<li><a href='#pld'>
<p>Accessor, Replacement, and Manipulation Functions for <code>"ploidysuper"</code> Objects</p></a></li>
<li><a href='#ploidysuper-class'><p>Class <code>"ploidysuper"</code> and Subclasses</p></a></li>
<li><a href='#plotSSAllo'>
<p>Perform Allele Assignments across Entire Dataset</p></a></li>
<li><a href='#read.ATetra'>
<p>Read File in ATetra Format</p></a></li>
<li><a href='#read.GeneMapper'>
<p>Read GeneMapper Genotypes Tables</p></a></li>
<li><a href='#read.GenoDive'>
<p>Import Genotype Data from GenoDive File</p></a></li>
<li><a href='#read.POPDIST'>
<p>Read Genotype Data in POPDIST Format</p></a></li>
<li><a href='#read.SPAGeDi'>
<p>Read Genotypes in SPAGeDi Format</p></a></li>
<li><a href='#read.STRand'>
<p>Read Genotypes Produced by STRand Software</p></a></li>
<li><a href='#read.Structure'>
<p>Read Genotypes and Other Data from a Structure File</p></a></li>
<li><a href='#read.Tetrasat'>
<p>Read Data from a TETRASAT Input File</p></a></li>
<li><a href='#recodeAllopoly'>
<p>Create a New <code>genambig</code> Dataset with Loci Split into Isoloci</p></a></li>
<li><a href='#reformatPloidies'>
<p>Convert Ploidy Format of a Dataset</p></a></li>
<li><a href='#simAllopoly'>
<p>Generate Simulated Datasets</p></a></li>
<li><a href='#simgen'><p>Randomly Generated Data for Learning polysat</p></a></li>
<li><a href='#simpleFreq'>
<p>Simple Allele Frequency Estimator</p></a></li>
<li><a href='#testgenotypes'><p>Rubus Genotype Data for Learning polysat</p></a></li>
<li><a href='#viewGenotypes'>
<p>Print Genotypes to the Console</p></a></li>
<li><a href='#write.ATetra'>
<p>Write Genotypes in ATetra Format</p></a></li>
<li><a href='#write.freq.SPAGeDi'>
<p>Create a File of Allele Frequencies for SPAGeDi</p></a></li>
<li><a href='#write.GeneMapper'>
<p>Write Genotypes to a Table Similarly to ABI GeneMapper</p></a></li>
<li><a href='#write.GenoDive'>
<p>Write a File in GenoDive Format</p></a></li>
<li><a href='#write.POPDIST'>
<p>Write Genotypes to a POPDIST File</p></a></li>
<li><a href='#write.SPAGeDi'>
<p>Write Genotypes in SPAGeDi Format</p></a></li>
<li><a href='#write.Structure'><p>Write Genotypes in Structure 2.3 Format</p></a></li>
<li><a href='#write.Tetrasat'>
<p>Write Genotype Data in Tetrasat Format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.7-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-20</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Polyploid Microsatellite Analysis</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, utils, grDevices, graphics, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ade4, adegenet, ape</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of tools to handle microsatellite data of
 any ploidy (and samples of mixed ploidy) where allele copy number is not
 known in partially heterozygous genotypes.  It can import and export data in
 ABI 'GeneMapper', 'Structure', 'ATetra', 'Tetrasat'/'Tetra', 'GenoDive', 'SPAGeDi',
 'POPDIST', 'STRand', and binary presence/absence formats.  It can calculate
 pairwise distances between individuals using a stepwise mutation model or
 infinite alleles model, with or without taking ploidies and allele frequencies
 into account.  These distances can be used for the calculation of clonal
 diversity statistics or used for further analysis in R.  Allelic diversity
 statistics and Polymorphic Information Content are also available.  polysat can 
 assist the user in estimating the ploidy of samples, and it can estimate allele 
 frequencies in populations, calculate pairwise or global differentiation statistics 
 based on those frequencies, and export allele frequencies to 'SPAGeDi' and 'adegenet'.  
 Functions are also included for assigning alleles to isoloci in cases where one pair 
 of microsatellite primers amplifies alleles from two or more independently
 segregating isoloci.  polysat is described by Clark and Jasieniuk (2011)
 &lt;<a href="https://doi.org/10.1111%2Fj.1755-0998.2011.02985.x">doi:10.1111/j.1755-0998.2011.02985.x</a>&gt; and Clark and Schreier (2017)
 &lt;<a href="https://doi.org/10.1111%2F1755-0998.12639">doi:10.1111/1755-0998.12639</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lvclark/polysat/wiki">https://github.com/lvclark/polysat/wiki</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-23 12:54:33 UTC; Lindsay</td>
</tr>
<tr>
<td>Author:</td>
<td>Lindsay V. Clark <a href="https://orcid.org/0000-0002-3881-9252"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alistair J. Hall <a href="https://orcid.org/0000-0001-9293-8909"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Handunnethi Nihal de Silva [ctb],
  Tyler William Smith
    <a href="https://orcid.org/0000-0001-7683-2653"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lindsay V. Clark &lt;Lindsay.Clark@seattlechildrens.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-23 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Accessors'>
Accessor and Replacement Functions for &quot;gendata&quot; Objects
</h2><span id='topic+Samples'></span><span id='topic+Samples+3C-'></span><span id='topic+Loci'></span><span id='topic+Loci+3C-'></span><span id='topic+PopInfo'></span><span id='topic+PopInfo+3C-'></span><span id='topic+PopNames'></span><span id='topic+PopNames+3C-'></span><span id='topic+Ploidies'></span><span id='topic+Ploidies+3C-'></span><span id='topic+Usatnts'></span><span id='topic+Usatnts+3C-'></span><span id='topic+Description'></span><span id='topic+Description+3C-'></span><span id='topic+Missing'></span><span id='topic+Missing+3C-'></span><span id='topic+Genotype'></span><span id='topic+Genotype+3C-'></span><span id='topic+Genotypes'></span><span id='topic+Genotypes+3C-'></span><span id='topic+PopNum'></span><span id='topic+PopNum+3C-'></span><span id='topic+Present'></span><span id='topic+Present+3C-'></span><span id='topic+Absent'></span><span id='topic+Absent+3C-'></span>

<h3>Description</h3>

<p>The accessor functions return information that is contained, either
directly or indirectly, in the slots of a <code>gendata</code> object.  The
replacement functions alter information in one or more slots as appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Samples(object, populations, ploidies)
Samples(object) &lt;- value
Loci(object, usatnts, ploidies)
Loci(object) &lt;- value
PopInfo(object)
PopInfo(object) &lt;- value
PopNames(object)
PopNames(object) &lt;- value
PopNum(object, popname)
PopNum(object, popname) &lt;- value
Ploidies(object, samples, loci)
Ploidies(object) &lt;- value
Usatnts(object)
Usatnts(object) &lt;- value
Description(object)
Description(object) &lt;- value
Missing(object)
Missing(object) &lt;- value
Present(object)
Present(object) &lt;- value
Absent(object)
Absent(object) &lt;- value
Genotype(object, sample, locus)
Genotype(object, sample, locus) &lt;- value
Genotypes(object, samples = Samples(object), loci = Loci(object))
Genotypes(object, samples = Samples(object), loci = Loci(object)) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Accessors_+3A_object">object</code></td>
<td>

<p>An object of the class <code>gendata</code> or one of its subclasses.
</p>
</td></tr>
<tr><td><code id="Accessors_+3A_populations">populations</code></td>
<td>

<p>A character or numeric vector indicating from which populations to return
samples. (optional)
</p>
</td></tr>
<tr><td><code id="Accessors_+3A_ploidies">ploidies</code></td>
<td>

<p>A numeric vector indicating ploidies, if only samples or loci with a certain
ploidy should be returned.  (optional)
</p>
</td></tr>
<tr><td><code id="Accessors_+3A_sample">sample</code></td>
<td>
<p>A character string or number indicating the name or number
of the sample whose genotype should be returned.</p>
</td></tr>
<tr><td><code id="Accessors_+3A_locus">locus</code></td>
<td>
<p>A character string or number indicating the name or number
of the locus whose genotype should be returned.</p>
</td></tr>
<tr><td><code id="Accessors_+3A_samples">samples</code></td>
<td>
<p>A character or numeric vector indicating samples for
which to return genotypes or ploidies. (optional)</p>
</td></tr>
<tr><td><code id="Accessors_+3A_loci">loci</code></td>
<td>
<p>A character or numeric vector indicating loci for which to
return genotypes or ploidies.  (optional)</p>
</td></tr>
<tr><td><code id="Accessors_+3A_usatnts">usatnts</code></td>
<td>
<p>A numeric vector indicating microsatellite repeat
lengths, where only loci of those repeat lengths should be returned.
(optional)</p>
</td></tr>
<tr><td><code id="Accessors_+3A_popname">popname</code></td>
<td>
<p>Chacter string or vector.  The name(s) of the
population(s) for which to retrieve or replace the corresponding
<code>PopInfo</code> number(s).  The replacement function should only be
used for one population at a time.</p>
</td></tr>
<tr><td><code id="Accessors_+3A_value">value</code></td>
<td>

<ul>
<li><p> For <code>Samples</code>: a character vector of sample names.
</p>
</li>
<li><p> For <code>Loci</code>: a character vector of locus names.
</p>
</li>
<li><p> For <code>PopInfo</code>: A numeric vector (integer or can be coerced to
integer) indicating the population identities of samples.
</p>
</li>
<li><p> For <code>PopNames</code>: A character vector indicating the names of
populations.
</p>
</li>
<li><p> For <code>PopNum</code>: A number (integer or can be coerced to integer)
that should be the new population number associated with
<code>popname</code>.
</p>
</li>
<li><p> For <code>Ploidies</code>: A numeric vector or matrix (integer or can be coerced to
integer) indicating the ploidy of each sample, locus, and/or the
dataset.  See <code><a href="#topic+reformatPloidies">reformatPloidies</a></code> and
<code>"<a href="#topic+ploidysuper-class">ploidysuper</a>"</code>.
</p>
</li>
<li><p> For <code>Usatnts</code>: A numeric vector (integer or can be coerced to
integer) indicating the repeat type of each microsatellite locus.
Dinucleotide repeats should be represented with <code>2</code>,
trinucleotide repeat with <code>3</code>, and so on.  If the alleles for a
given locus are already stored in terms of repeat number rather than
fragment length in nucleotides, the <code>Usatnts</code> value for that
locus should be <code>1</code>.
</p>
</li>
<li><p> For <code>Description</code>: A character string or character vector
describing the dataset.
</p>
</li>
<li><p> For <code>Missing</code>: A symbol (usually an integer) to be used to
indicate missing data.
</p>
</li>
<li><p> For <code>Present</code>: A symbol (usually an integer) to be used to
indicate the presence of an allele.
</p>
</li>
<li><p> For <code>Absent</code>: A symbol (usually an integer) to be used to
indicate the absence of an allele.
</p>
</li>
<li><p> For <code>Genotype</code>: a vector of alleles, if the object is of class
<code>genambig</code>.
</p>
</li>
<li><p> For <code>Genotypes</code>: A list of vectors (genotypes), of the same
dimensionality as <code>c(length(samples), length(loci))</code>, if the
object is of class <code>genambig</code>.  If the object is of class
<code>genbinary</code>, <code>value</code> should be a matrix, with column names
of the form <code>"locus.allele"</code>.  See
<code><a href="#topic+Genotypes+3C-+2Cgenbinary-method">Genotypes&lt;-,genbinary-method</a></code> for more information.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Samples&lt;-</code> and <code>Loci&lt;-</code> can only be used to change sample
and locus names, not to add or remove samples and loci from the
dataset.
</p>
<p>For slots that require integer values, numerical values used in
replacement functions will be coerced to integers.  The replacement
functions also ensure that all slots remain properly indexed.
</p>
<p>The <code>Missing&lt;-</code> function finds any genotypes with the old missing
data symbol and changes them to the new missing data symbol, then
assigns the new symbol to the slot that indicates what the missing
data symbol is.  <code>Present&lt;-</code> and <code>Absent&lt;-</code> work similarly for
the <code>genbinary</code> class.
</p>
<p>The <code>Genotype</code> access and replacement functions deal with
individual genotypes, which are vectors in the <code>genambig</code> class.
The <code>Genotypes</code> access and replacement functions deal with lists
of genotypes.
</p>
<p>The <code>PopInfo&lt;-</code> replacement function also adds elements to
<code>PopNames(object)</code> if necessary in order to have names for all of
the populations.  These will be of the form <code>"Pop"</code> followed by
the population number, and can be later edited using
<code>PopNames&lt;-</code>.
</p>
<p>The <code>PopNum&lt;-</code> replacement function first finds all samples in
the population <code>popname</code>, and replaces the number in
<code>PopInfo(object)</code> for those samples with <code>value</code>.  It then
inserts <code>NA</code> into the original <code>PopNames</code> slot that
contained <code>popname</code>, and inserts <code>popname</code> into
<code>PopNames(object)[value]</code>.  If this results in two populations
being merged into one, a message is printed to the console.
</p>


<h3>Value</h3>

<p><code>PopInfo</code>, <code>PopNames</code>, <code>Missing</code>, <code>Description</code>,
<code>Usatnts</code>, <code>Ploidies</code> and <code>Genotypes</code> simply return the
contents of the slots of the same names (or in the case of
<code>Ploidies</code>, <code>object@Ploidies@pld</code> is returned). <code>Samples</code> and
<code>Loci</code> return character vectors taken from the <code>names</code> of
other slots (<code>PopInfo</code> and <code>Usatnts</code>,
respectively; the initialization and replacement methods ensure that
these slots are always named according to samples and
loci). <code>PopNum</code> returns an integer vector indicating the
population number(s) of the population(s) named in <code>popname</code>.
<code>Genotype</code> returns a single genotype for a given sample and
locus, which is a vector whose exact form will depend on the class of
<code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deleteSamples">deleteSamples</a></code>, <code><a href="#topic+deleteLoci">deleteLoci</a></code>,
<code><a href="#topic+viewGenotypes">viewGenotypes</a></code>, <code><a href="#topic+editGenotypes">editGenotypes</a></code>,
<code><a href="#topic+isMissing">isMissing</a></code>, <code><a href="#topic+estimatePloidy">estimatePloidy</a></code>,
<code><a href="#topic+merge">merge,gendata,gendata-method</a></code>, <code><a href="#topic+gendata-class">gendata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a new genambig (subclass of gendata) object to manipulate
mygen &lt;- new("genambig", samples=c("a", "b", "c"), loci=c("locG",
"locH"))

# retrieve the sample and locus names
Samples(mygen)
Loci(mygen)

# change some of the sample and locus names
Loci(mygen) &lt;- c("lG", "lH")
Samples(mygen)[2] &lt;- "b1"

# describe the dataset
Description(mygen) &lt;- "Example dataset for documentation."

# name some populations and assign samples to them
PopNames(mygen) &lt;- c("PopL", "PopK")
PopInfo(mygen) &lt;- c(1,1,2)
# now we can retrieve samples by population
Samples(mygen, populations="PopL")
# we can also adjust the numbers if we want to make them
# match another dataset
PopNum(mygen, "PopK") &lt;- 3
PopNames(mygen)
PopInfo(mygen)
# change the population identity of just one sample
PopInfo(mygen)["b1"] &lt;- 3

# indicate that both loci are dinucleotide repeats
Usatnts(mygen) &lt;- c(2,2)

# indicate that all samples are tetraploid
Ploidies(mygen) &lt;- 4
# or
Ploidies(mygen) &lt;- rep(4, times = length(Samples(mygen)) * length(Loci(mygen)))
# actually, one sample is triploid
Ploidies(mygen)["c",] &lt;- 3
# view ploidies
Ploidies(mygen)

# view the genotype array as it currently is: filled with missing
# values
Genotypes(mygen)
# fill in the genotypes
Genotypes(mygen, loci="lG") &lt;- list(c(120, 124, 130, 136), c(122, 120),
                                    c(128, 130, 134))
Genotypes(mygen, loci="lH") &lt;- list(c(200, 202, 210), c(206, 208, 210,
                                                        214),
                                    c(208))
# genotypes can also be edited or retrieved by sample
Genotypes(mygen, samples="a")
# fix a single genotype
Genotype(mygen, "a", "lH") &lt;- c(200, 204, 210)
# retrieve a single genotype
Genotype(mygen, "c", "lG")

# change a genotype to being missing
Genotype(mygen, "c", "lH") &lt;- Missing(mygen)
# show the current missing data symbol
Missing(mygen)
# an example of genotypes where one contains the missing data symbol
Genotypes(mygen, samples="c")
# change the missing data symbol
Missing(mygen) &lt;- as.integer(-1)
# now look at the genotypes
Genotypes(mygen, samples="c")

</code></pre>

<hr>
<h2 id='alleleCorrelations'>
Assign Alleles to Isoloci Based on Distribution of Genotypes
</h2><span id='topic+alleleCorrelations'></span><span id='topic+testAlGroups'></span>

<h3>Description</h3>

<p>Where a single locus represents two or more independent isoloci (as in
an allopolyploid, or a diploidized autopolyploid), these two functions
can be used in sequence to assign alleles to isoloci.
<code>alleleCorrelations</code> uses K-means and UPGMA clustering of pairwise p-values
from Fisher's exact test to make initial groupings of alleles into
putative isoloci.  <code>testAlGroups</code> is then used to check those
groupings against individual genotypes, and adjust the assignments if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alleleCorrelations(object, samples = Samples(object), locus = 1,
                   alpha = 0.05, n.subgen = 2, n.start = 50)

testAlGroups(object, fisherResults, SGploidy=2, samples=Samples(object),
             null.weight=0.5, tolerance=0.05, swap = TRUE,
             R = 100, rho = 0.95, T0 = 1, maxreps = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alleleCorrelations_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+genambig-class">genambig</a>"</code> or <code>"<a href="#topic+genbinary-class">genbinary</a>"</code>
object containing the data to analyze.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_samples">samples</code></td>
<td>

<p>An optional character or numeric vector indicating which samples to analyze.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_locus">locus</code></td>
<td>

<p>A single character string or integer indicating which locus to analyze.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_alpha">alpha</code></td>
<td>

<p>The significance threshold, before multiple correction, for determining
whether two alleles are significantly correlated.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_n.subgen">n.subgen</code></td>
<td>

<p>The number of subgenomes (number of isoloci) for this locus.  This would
be <code>2</code> for an allotetraploid or <code>3]</code> for an allohexaploid.  For an 
allo-octoploid, the value would be <code>2</code> if there were two tetraploid 
subgenomes, or <code>4</code> if there were four diploid subgenomes.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_n.start">n.start</code></td>
<td>

<p>Integer, passed directly to the <code>nstart</code> argument of the R base
function <code>kmeans</code>.  Lowering this number will speed up computation
time, whereas increasing it will improve the probability of finding the
correct allele assignments.  The default value of 50 should work well in
most cases.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_fisherresults">fisherResults</code></td>
<td>

<p>A list output from <code>alleleCorrelations</code>.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_sgploidy">SGploidy</code></td>
<td>

<p>The ploidy of each subgenome (each isolocus).  This is <code>2</code> for an
allotetraploid, an allohexaploid, or an allo-octoploid with four tetraploid 
subgenomes, or <code>4</code> for an allo-octoploid with
two tetraploid genomes.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_null.weight">null.weight</code></td>
<td>

<p>Numeric, indicating how genotypes with potential null alleles should
be counted when looking for signs of homoplasy.  <code>null.weight</code>
should be <code>0</code> if null
alleles are expected to be common, and <code>1</code> if there are no null
alleles in the dataset.  The default of <code>0.5</code> was chosen to reflect
the fact that the presence of null alleles is generally unknown.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_tolerance">tolerance</code></td>
<td>

<p>The proportion of genotypes that are allowed to be in disagreement
with the allele assignments.  This is the proportion of genotypes
that are expected to have meiotic error or scoring error.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_swap">swap</code></td>
<td>

<p>Boolean indicating whether or not to use the allele swapping algorithm
before checking for homoplasy.  TRUE will yield more accurate results
in most cases, but FALSE may be preferable for loci with null or 
homoplasious alleles at high frequency.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_r">R</code></td>
<td>

<p>Simulated annealing parameter for the allele swapping algorithm.
Indicates how many swaps to attempt in each rep (<em>i.e.</em> how many
swaps to attempt before changing the temperature).
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_rho">rho</code></td>
<td>

<p>Simulated annealing parameter for the allele swapping algorithm.
Factor by which to reduce the temperature at the end of each rep.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_t0">T0</code></td>
<td>

<p>Simulated annealing parameter for the allele swapping algorithm.
Starting temperature.
</p>
</td></tr>
<tr><td><code id="alleleCorrelations_+3A_maxreps">maxreps</code></td>
<td>

<p>Simulated annealing parameter for the allele swapping algorithm.
Maximum number of reps if convergence is not achieved.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions implement a novel methodology, introduced in
<span class="pkg">polysat</span> version 1.4 and updated in version 1.6, for cases where 
one pair of microsatellite
primers amplifies alleles at two or more independently-segregating loci
(referred to here as isoloci).  This is not typically the case with new
autopolyploids, in which all copies of a locus have equal chances of
pairing with each other at meiosis.  It is, however, frequently the case
with allopolyploids, in which there are two homeologous subgenomes that
do not pair (or infrequently pair) at meiosis, or ancient
autopolyploids, in which duplicated chromosomes have diverged to the
point of no longer pairing at meiosis.
</p>
<p>Within the two functions there are four major steps:
</p>

<ol>
<li> <p><code>alleleCorrelations</code> checks to see if there are any alleles
that are present in every genotype in the dataset.  Such invariable
alleles are assumed to be fixed at one isolocus (which is not
necessarily true, but may be corrected by
<code>testAlGroups</code> in steps 4 and 5).
If present, each invariable allele is assigned to its own isolocus.
If there are more invariable alleles than isoloci, the function throws
an error.  If only one isolocus remains, all remaining (variable) alleles are
assigned to that isolocus.  If there are as many invariable alleles as
isoloci, all remaining (variable) alleles are assigned to all isoloci
(<em>i.e.</em> they are considered homoplasious because they cannot be
assigned).
</p>
</li>
<li><p> If, after step 1, two or more isoloci remain
without alleles assigned to them, correlations between alleles are
tested by <code>alleleCorrelations</code>.  The dataset is converted
to <code>"genbinary"</code> if not
already in that format, and a Fisher's exact test, with negative
association (odds ratio being less than one) as the alternative
hypothesis, is performed between
each pair of columns (alleles) in the genotype matrix.  The p-value of
this test between each pair of alleles is stored in a square matrix,
and zeros are inserted into the diagonal of the matrix.  K-means
clustering and UPGMA are then performed on the square matrix of
p-values, and the
clusters that are produced represent initial assignments of alleles
to isoloci.  
</p>
</li>
<li><p> The output of <code>alleleCorrelations</code> is then passed to
<code>testAlGroups</code>.  If the results of K-means clustering and UPGMA
were not identical, <code>testAlGroups</code> checks both sets of
assignments against all genotypes in the dataset.  For a genotype to
be consistent with a set of assignments, it should have at least one
allele and no more than <code>SGploidy</code> alleles belonging to each
isolocus.  The set of assignments that is consistent with the greatest
number of genotypes is chosen, or in the case of a tie, the set of
assignments produced by K-means clustering.
</p>
</li>
<li><p> If <code>swap = TRUE</code> and the assignments chosen in the previous 
step are inconsistent with some genotypes, <code>testAlGroups</code> attempts
to swap the isoloci of single alleles, using a simulated annealing 
(Bertsimas and Tsitsiklis 1993) algorithm to search for a new set of 
assignments that is consistent with as many genotypes as possible.
At each step, an allele is chosen at random to be moved to a different
isolocus (which is also chosen at random if there are more than two
isoloci).  If the new set of allele assignments is consistent with an equal or 
greater number of genotypes than the previous set of assignments, the new
set is retained.  If the new set is consistent with fewer genotypes than
the old set, there is a small probability of retaining the new set, 
dependent on how much worse the new set of assignments is and what the
current &ldquo;temperature&rdquo; of the algorithm is.  After <code>R</code> allele
swapping attempts, the temperature is lowered, reducing the probability 
of retaining a set of allele assignments that is worse than the previous set.
A new rep of <code>R</code> swapping attempts then begins.
If a set of allele assignments is found that is consistent with all genotypes,
the algorithm stops immediately.  Otherwise it stops if no changes are made
during an entire rep of <code>R</code> swap attempts, or if <code>maxreps</code> reps
are performed.
</p>
</li>
<li> <p><code>testAlGroups</code> then checks through all genotypes to look
for signs of homoplasy, meaning single alleles that should be assigned
to more than one isolocus.  For each genotype, there should be no more
than <code>SGploidy</code> alleles assigned to each isolocus.  Additionally,
if there are no null alleles, each genotype should have at least one
allele belonging to each isolocus.  Each time a genotype is
encountered that does not meet these criteria, the a score is
increased for all alleles that might be homoplasious.  (The second
criterion is not checked if <code>null.weight = 0</code>.)  This score
starts at zero and is increased by 1 if there are too many alleles per
isolocus or by <code>null.weight</code> if an isolocus has no alleles.  Once
all genotypes have been checked, the allele with the highest score is
considered to be homoplasious and is added to the other isolocus.  (In
a hexaploid or higher, which isolocus the allele is added to depends on the
genotypes that were found to be inconsistent with the allele
assignments, and which isolocus or isoloci the allele could have
belonged to in order to fix the assignment.)  Allele scores are reset
to zero and all alleles are then
checked again with the new set of allele assignments.  The process is
repeated until the proportion of genotypes that are inconsistent with
the allele assignments is at or below <code>tolerance</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>Both functions return lists.  For <code>alleleCorrelations</code>:
</p>
<table role = "presentation">
<tr><td><code>locus</code></td>
<td>
<p>The name of the locus that was analyzed.</p>
</td></tr>
<tr><td><code>clustering.method</code></td>
<td>
<p>The method that was ultimately used to
produce <code>value$Kmeans.groups</code> and <code>value$UPGMA.groups</code>.
Either <code>"K-means and UPGMA"</code> or <code>"fixed alleles"</code>.</p>
</td></tr>
<tr><td><code>significant.neg</code></td>
<td>
<p>Square matrix of logical values indicating
whether there was significant negative correlation between each pair
of alleles, after multiple testing correction by Holm-Bonferroni.</p>
</td></tr>
<tr><td><code>significant.pos</code></td>
<td>
<p>Square matrix of logical values indicating
whether there was significant positive correlation between each pair
of alleles, after multiple testing correction by Holm-Bonferroni.</p>
</td></tr>
<tr><td><code>p.values.neg</code></td>
<td>
<p>Square matrix of p-values from Fisher's exact test
for negative correlation between each pair of alleles.</p>
</td></tr>
<tr><td><code>p.values.pos</code></td>
<td>
<p>Square matrix of p-values from Fisher's exact test
for positive correlation between each pair of alleles.</p>
</td></tr>
<tr><td><code>odds.ratio</code></td>
<td>
<p>Square matrix of the odds ratio estimate from
Fisher's exact test for each pair of alleles.</p>
</td></tr>
<tr><td><code>Kmeans.groups</code></td>
<td>
<p>Matrix with <code>n.subgen</code> rows, and as many
columns as there are alleles in the dataset.  <code>1</code> indicates that
a given allele belongs to a given isolocus, and <code>0</code> indicates
that it does not.  These are the groupings determined by K-means
clustering.</p>
</td></tr>
<tr><td><code>UPGMA.groups</code></td>
<td>
<p>Matrix in the same format as
<code>value$Kmeans.groups</code>, showing groupings determined by UPGMA.</p>
</td></tr>
<tr><td><code>heatmap.dist</code></td>
<td>
<p>Square matrix like <code>value$p.values.neg</code> but
with zeros inserted on the diagonal.  This is the matrix that was used
for K-means clustering and UPGMA.  This matrix can be passed to the
<code>heatmap</code> function in R to visualize the clusters.</p>
</td></tr>
<tr><td><code>totss</code></td>
<td>
<p>Total sums of squares output from K-means clustering.</p>
</td></tr>
<tr><td><code>betweenss</code></td>
<td>
<p>Sums of squares between clusters output from K-means
clustering.  <code>value$betweenss/value$totss</code> can be used as an
indication of clustering quality.</p>
</td></tr>
<tr><td><code>gentable</code></td>
<td>
<p>The table indicating presence/absence of each allele in
each genotype.</p>
</td></tr>
</table>
<p>For <code>testAlGroups</code>:
</p>
<table role = "presentation">
<tr><td><code>locus</code></td>
<td>
<p>Name of the locus that was tested.</p>
</td></tr>
<tr><td><code>SGploidy</code></td>
<td>
<p>The ploidy of each subgenome, taken from the
<code>SGploidy</code> argument that was passed to <code>testAlGroups</code>.</p>
</td></tr>
<tr><td><code>assignments</code></td>
<td>
<p>Matrix with as many rows as there are isoloci, and as many
columns as there are alleles in the dataset.  <code>1</code> indicates that
a given allele belongs to a given isolocus, and <code>0</code> indicates
that it does not.</p>
</td></tr>
<tr><td><code>proportion.inconsistent.genotypes</code></td>
<td>
<p>A number ranging from zero to one 
indicating the proportion of genotypes from the dataset that are inconsistent
with <code>assignments</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>alleleCorrelations</code> will print a warning to the console or to the
standard output stream if a significant positive correlation is found
between any pair of alleles.  (This is not a &ldquo;warning&rdquo; in the
technical sense usually used in R, because it can occur by random
chance and I did not want it to cause <span class="pkg">polysat</span> to fail package
checks.)  You can see which allele pair(s) caused this warning by
looking at <code>value$significant.pos</code>.  If you receive this warning for
many loci, consider that there may be population structure in your
dataset, and that you might split the dataset into multiple
populations to test seperately.  If it happens at just a few loci,
check to make sure there are not scoring problems such as stutter
peaks being miscalled as alleles.  If it only happens at one locus and
you can't find any evidence of scoring problems, two alleles may have
been positively correlated simply from random chance, and the warning
can be ignored.
</p>
<p><code>alleleCorrelations</code> can also produce an actual warning stating
&ldquo;Quick-TRANSfer stage steps exceeded maximum&rdquo;.  This warning
is produced internally by <code><a href="stats.html#topic+kmeans">kmeans</a></code> and may occur if many
genotypes are similar, as in mapping populations.  It can be safely
ignored.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Clark, L. V. and Drauch Schreier, A. (2017) Resolving microsatellite genotype ambiguity in
populations of allopolyploid and diploidized autopolyploid organisms
using negative correlations between allelic variables. <em>Molecular Ecology Resources</em>, 
<b>17</b>, 1090&ndash;1103.  DOI: 10.1111/1755-0998.12639.
</p>
<p>Bertsimas, D. and Tsitsiklis, J.(1993) Simulated annealing. <em>Statistical Science</em>
<b>8</b>, 10&ndash;15.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recodeAllopoly">recodeAllopoly</a></code>, <code><a href="#topic+mergeAlleleAssignments">mergeAlleleAssignments</a></code>,
<code><a href="#topic+catalanAlleles">catalanAlleles</a></code>, <code><a href="#topic+processDatasetAllo">processDatasetAllo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># randomly generate example data for an allotetraploid
mydata &lt;- simAllopoly(n.alleles=c(5,5), n.homoplasy=1)
viewGenotypes(mydata)

# test allele correlations
# n.start is lowered in this example to speed up computation time
myCorr &lt;- alleleCorrelations(mydata, n.subgen=2, n.start=10)
myCorr$Kmeans.groups
myCorr$clustering.method
if(!is.null(myCorr$heatmap.dist)) heatmap(myCorr$heatmap.dist)

# check individual genotypes 
# (low maxreps used in order to speed processing time for this example)
myRes &lt;- testAlGroups(mydata, myCorr, SGploidy=2, maxreps = 5)
myRes$assignments
myRes2 &lt;- testAlGroups(mydata, myCorr, SGploidy=2, swap = FALSE)
myRes2$assignments
</code></pre>

<hr>
<h2 id='alleleDiversity'>
Retrieve and Count Unique Alleles
</h2><span id='topic+alleleDiversity'></span>

<h3>Description</h3>

<p><code>alleleDiversity</code> returns the number of unique alleles and/or a
list of vectors of all unique alleles, indexed by locus and population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alleleDiversity(genobject, samples = Samples(genobject),
                loci = Loci(genobject), alleles = TRUE, counts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alleleDiversity_+3A_genobject">genobject</code></td>
<td>

<p>An object of the class <code>"genambig"</code>.
</p>
</td></tr>
<tr><td><code id="alleleDiversity_+3A_samples">samples</code></td>
<td>

<p>Optional.  A character or numeric vector indicating samples to include
in the analysis.
</p>
</td></tr>
<tr><td><code id="alleleDiversity_+3A_loci">loci</code></td>
<td>

<p>Optional.  A character or numeric vector indicating loci to include in
the analysis.
</p>
</td></tr>
<tr><td><code id="alleleDiversity_+3A_alleles">alleles</code></td>
<td>

<p>Boolean, indicating whether or not to return the alleles themselves.
</p>
</td></tr>
<tr><td><code id="alleleDiversity_+3A_counts">counts</code></td>
<td>

<p>Boolean, indicating whether or not to return the number of unique alleles.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Under default settings, a list is returned:
</p>
<table role = "presentation">
<tr><td><code>alleles</code></td>
<td>
<p>A two dimensional list.  The first dimension is indexed
by population, with the additional element &ldquo;overall&rdquo;
representing the entire dataset.  The second dimension is indexed by
locus.  Each element of the list is a vector, containing all unique
alleles found for that population and locus.
<code>Missing(genobject)</code> is not counted as an allele.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>A matrix, indexed in the same way as <code>alleles</code>.
Each element of the matrix is an integer indicating how many alleles
were found at that population and locus.</p>
</td></tr>
</table>
<p>If the argument <code>alleles</code> or <code>counts</code> is set to <code>FALSE</code>,
then only one of the above list elements is returned.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genotypeDiversity">genotypeDiversity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a dataset for this example
mygen &lt;- new("genambig", samples=c("a","b","c","d"), loci=c("E","F"))
PopInfo(mygen) &lt;- c(1,1,2,2)
Genotypes(mygen, loci="E") &lt;- list(c(122,132),c(122,124,140),
                                   c(124,130,132),c(132,136))
Genotypes(mygen, loci="F") &lt;- list(c(97,99,111),c(113,115),
                                   c(99,113),c(111,115))

# look at unique alleles
myal &lt;- alleleDiversity(mygen)
myal$counts
myal$alleles
myal$alleles[["Pop1","E"]]
myal$alleles[["overall","F"]]
</code></pre>

<hr>
<h2 id='AllopolyTutorialData'>
Simulated Allotetraploid Data
</h2><span id='topic+AllopolyTutorialData'></span>

<h3>Description</h3>

<p>This is a simulated microsatellite dataset for seven loci and 303 individuals.  
It is intended to be used
with the tutorial &ldquo;Assigning alleles to isoloci in <span class="pkg">polysat</span>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("AllopolyTutorialData")</code></pre>


<h3>Format</h3>

<p>A <code>"<a href="#topic+genambig-class">genambig</a>"</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AllopolyTutorialData)
summary(AllopolyTutorialData)
viewGenotypes(AllopolyTutorialData, samples=1:10, loci=1)
</code></pre>

<hr>
<h2 id='assignClones'>
Group Individuals Based on a Distance Threshold
</h2><span id='topic+assignClones'></span>

<h3>Description</h3>

<p><code>assignClones</code> uses a distance matrix such as that produced by
<code><a href="#topic+meandistance.matrix">meandistance.matrix</a></code> or <code><a href="#topic+meandistance.matrix2">meandistance.matrix2</a></code>
to place individuals into groups representing asexually-related ramets,
or any other grouping based on a distance threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignClones(d, samples = dimnames(d)[[1]], threshold = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assignClones_+3A_d">d</code></td>
<td>

<p>A symmetrical, square matrix containing genetic distances between
individuals.  Both dimensions should be named according to the names
of the individuals (samples).  A matrix produced by
<code>meandistance.matrix</code> or <code>meandistance.matrix2</code> when
<code>all.distances = FALSE</code>, or the matrix that is the second item in
the list produced if <code>all.distances = TRUE</code>, will be in the right
format. <code><a href="#topic+meandist.from.array">meandist.from.array</a></code> will also produce a matrix
in the correct format.
</p>
</td></tr>
<tr><td><code id="assignClones_+3A_samples">samples</code></td>
<td>

<p>A character vector containing the names of samples to analyze.  This
should be all or a subset of the names of <code>d</code>.
</p>
</td></tr>
<tr><td><code id="assignClones_+3A_threshold">threshold</code></td>
<td>

<p>A number indicating the maximum distance between two individuals that
will be placed into the same group.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function groups individuals very similarly to the software GenoType
(Meirmans and van Tienderen, 2004).  If a distance matrix from
<span class="pkg">polysat</span> is exported to GenoType, the results will be the same as
those from <code>assignClones</code> assuming the same threshold is used.  Note
that GenoType requires that
distances be integers rather than decimals, so you will have to
multiply the distances produced by <span class="pkg">polysat</span> by a large number and
round them to the nearest integer if you wish to export them to GenoType.
When comparing the
results of <code>assignClones</code> and GenoType using my own data, the only
differences I have seen have been the result of rounding; a decimal that
was slightly above the threshold in when analyzed in R was rounded down
to the threshold when analyzed in GenoType.
</p>
<p>Note that when using a distance threshold of zero (the default), it is
advisable to exclude all samples with missing data, in order to prevent
the merging of non-identical clones.  At higher thresholds, some missing
data are allowable, but samples that have missing data at many loci should
be excluded.
</p>
<p>The <code>write.table</code> function can be used for exporting the results to
GenoDive.  See the R documentation for information on how to
make a tab-delimited file with no header.
</p>


<h3>Value</h3>

<p>A numeric vector, named by <code>samples</code>.  Each clone or group is given
a number, and the number for each sample indicates the clone or group
to which it belongs.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Meirmans, P. G. and Van Tienderen, P. H. (2004) GENOTYPE and GENODIVE:
two programs for the analysis of genetic diversity of asexual
organisms. <em>Molecular Ecology Notes</em> <b>4</b>, 792&ndash;794.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genotypeDiversity">genotypeDiversity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up a simple matrix with three samples
test &lt;- matrix(c(0,0,.5,0,0,.5,.5,.5,0), ncol=3, nrow=3)
abc &lt;- c("a", "b", "c")
dimnames(test) &lt;- list(abc,abc)

# assign clones with a threshold of zero or 0.5
assignClones(test)
assignClones(test, threshold=0.5)
</code></pre>

<hr>
<h2 id='Bruvo.distance'>Genetic Distance Metric of Bruvo et al.</h2><span id='topic+Bruvo.distance'></span>

<h3>Description</h3>

<p>This function calculates the distance between two individuals at one
microsatellite locus using a method based on that of Bruvo
<em>et al.</em> (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bruvo.distance(genotype1, genotype2, maxl=10, usatnt=2, missing=-9)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bruvo.distance_+3A_genotype1">genotype1</code></td>
<td>
<p>A vector of alleles for one individual at one
locus.  Allele length is in nucleotides or repeat count.  Each
unique allele corresponds to one element in the vector, and the
vector is no longer than it needs to be to contain all unique
alleles for this individual at this locus.</p>
</td></tr>
<tr><td><code id="Bruvo.distance_+3A_genotype2">genotype2</code></td>
<td>
<p>A vector of alleles for another individual at the
same locus.</p>
</td></tr>
<tr><td><code id="Bruvo.distance_+3A_maxl">maxl</code></td>
<td>
<p>If both individuals have more than this number of
alleles at this locus, <code>NA</code> is returned instead of a
numerical distance.</p>
</td></tr>
<tr><td><code id="Bruvo.distance_+3A_usatnt">usatnt</code></td>
<td>
<p>Length of the repeat at this locus.  For example
<code>usatnt=2</code> for dinucleotide repeats, and <code>usatnt=3</code>
for trinucleotide repeats.  If the alleles in <code>genotype1</code>
and <code>genotype2</code> are expressed in repeat count instead of
nucleotides, set <code>usatnt=1</code>.</p>
</td></tr>
<tr><td><code id="Bruvo.distance_+3A_missing">missing</code></td>
<td>
<p>A numerical value that, when in the first allele
position, indicates missing data. <code>NA</code> is returned if this
value is found in either genotype.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since allele copy number is frequently unknown in polyploid
microsatellite data, Bruvo <em>et al.</em> developed a measure of genetic
distance similar to band-sharing indices used with dominant data,
but taking into account mutational distances between alleles.  A
matrix is created containing all differences in repeat count between
the alleles of two individuals at one locus.  These differences are
then geometrically transformed to reflect the probabilities of
mutation from one allele to another.  The matrix is then searched to
find the minimum sum if each allele from one individual is paired to
one allele from the other individual.  This sum is divided by the
number of alleles per individual.
</p>
<p>If one genotype has more alleles than the other, &lsquo;virtual alleles&rsquo; must
be created so that both genotypes are the same length.  There are
three options for the value of these virtual alleles, but
<code>Bruvo.distance</code> only implements the simplest one, assuming that it is
not known whether differences in ploidy arose from genome addition or
genome loss.  Virtual alleles are set to infinity, such that the
geometric distance between any allele and a virtual allele is 1.
</p>
<p>In the original publication by Bruvo <em>et al.</em> (2004), ambiguous
genotypes were dealt with by calculating the distance for all possible
unambiguous genotype combinations and averaging across all of them
equally.  When <code>Bruvo.distance</code> is called from
<code>meandistance.matrix</code>, ploidy is unknown and all genotypes are
simply treated as if they had one copy of each allele.  When
<code>Bruvo.distance</code> is called from <code>meandistance.matrix2</code>, the
analysis is truer to the original, in that ploidy is known and all
possible unambiguous genotype combinations are considered.  However,
instead of all possible unambiguous genotypes being weighted equally,
in <code>meandistance.matrix2</code> they are weighted based on allele
frequencies and selfing rate, since some unambiguous genotypes are
more likely than others.
</p>


<h3>Value</h3>

<p>A number ranging from 0 to 1, with 0 indicating identical
genotypes, and 1 being a theoretical maximum distance if all alleles
from <code>genotype1</code> differed by an infinite number of repeats from all
alleles in <code>genotype2</code>.  <code>NA</code> is returned if both genotypes have
more than <code>maxl</code> alleles or if either genotype has the symbol for
missing data as its first allele.
</p>


<h3>Note</h3>

<p>The processing time is a function of the factorial of the number of
alleles, since each possible combination of allele pairs must be
evaluated.  For genotypes with a sufficiently large number of alleles,
it may be more efficient to estimate distances manually by creating
the matrix in Excel and visually picking out the shortest distances
between alleles.  This is the purpose of the <code>maxl</code> argument.  On my
personal computer, if both genotypes had more than nine alleles, the
calculation could take an hour or more, and so this is the default
limit.  In this case, <code>Bruvo.distance</code> returns <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark</p>


<h3>References</h3>

<p>Bruvo, R., Michiels, N. K., D'Sousa, T. G., and Schulenberg, H. (2004)
A simple method for calculation of microsatellite genotypes
irrespective of ploidy level. <em>Molecular Ecology</em> <b>13</b>, 2101-2106.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meandistance.matrix">meandistance.matrix</a></code>, <code><a href="#topic+Lynch.distance">Lynch.distance</a></code>,
<code><a href="#topic+Bruvo2.distance">Bruvo2.distance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Bruvo.distance(c(202,206,210,220),c(204,206,216,222))
  Bruvo.distance(c(202,206,210,220),c(204,206,216,222),usatnt=4)
  Bruvo.distance(c(202,206,210,220),c(204,206,222))
  Bruvo.distance(c(202,206,210,220),c(204,206,216,222),maxl=3)
  Bruvo.distance(c(202,206,210,220),c(-9))
</code></pre>

<hr>
<h2 id='Bruvo2.distance'>
Distance Measure of Bruvo et al. under Genome Loss and Addition
</h2><span id='topic+Bruvo2.distance'></span>

<h3>Description</h3>

<p>This is an inter-individual distance measure similar to
<code><a href="#topic+Bruvo.distance">Bruvo.distance</a></code>, except that where genotypes have different
numbers of alleles, virtual alleles are equal to those from the longer
and/or shorter genotype, rather than being equal to infinity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bruvo2.distance(genotype1, genotype2, maxl = 7, usatnt = 2,
                missing = -9, add = TRUE, loss = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bruvo2.distance_+3A_genotype1">genotype1</code></td>
<td>

<p>A numeric vector representing the genotype of one individual at one
locus.  This type of vector is produced by the <code><a href="#topic+Genotype">Genotype</a></code>
method for <code>"genambig"</code> objects.
</p>
</td></tr>
<tr><td><code id="Bruvo2.distance_+3A_genotype2">genotype2</code></td>
<td>

<p>The second genotype for the distance calculation, in the same format as
<code>genotype1</code>.
</p>
</td></tr>
<tr><td><code id="Bruvo2.distance_+3A_maxl">maxl</code></td>
<td>

<p>The maximum number of alleles that either genotype can have.  If it is
exceeded, <code>NA</code> is returned.  This argument exists to prevent
computations that would take in excess of an hour; see
<code><a href="#topic+Bruvo.distance">Bruvo.distance</a></code>.
</p>
</td></tr>
<tr><td><code id="Bruvo2.distance_+3A_usatnt">usatnt</code></td>
<td>

<p>The microsatellite repeat type for the locus.  <code>2</code> for dinucleotide
repeats, <code>3</code> for dinucleotide repeats, <code>1</code> if the alleles are
already coded as repeat numbers, etc.  See <code><a href="#topic+Usatnts">Usatnts</a></code>.
</p>
</td></tr>
<tr><td><code id="Bruvo2.distance_+3A_missing">missing</code></td>
<td>

<p>The symbol that indicates missing data for a given sample and locus.
See <code><a href="#topic+Missing">Missing</a></code>.
</p>
</td></tr>
<tr><td><code id="Bruvo2.distance_+3A_add">add</code></td>
<td>

<p><code>TRUE</code> if the model of genome addition is being used, and
<code>FALSE</code> if it is not.  If this model is used, the shorter genotype
will have virtual alleles added from the same genotype.
</p>
</td></tr>
<tr><td><code id="Bruvo2.distance_+3A_loss">loss</code></td>
<td>

<p><code>TRUE</code> if the model of genome loss is being used, and <code>FALSE</code>
if it is not.  If this model is used, the shorter genotype will have
virtual alleles added from the longer genotype.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bruvo <em>et al.</em> (2004) describe multiple methods for calculating
genetic distances between individuals of different ploidy.  (See
&ldquo;Special cases&rdquo; starting on page 2102 of the paper.)  The
original <code>Bruvo.distance</code> function in <span class="pkg">polysat</span> uses the method
described for systems with complex changes in ploidy, adding virtual
alleles equal to infinity to the shorter genotype to make it the same
length as the longer genotype.  This method, however, can exaggerate
distances between individuals of different ploidy, particularly when
used with <code><a href="#topic+meandistance.matrix2">meandistance.matrix2</a></code> as opposed to
<code><a href="#topic+meandistance.matrix">meandistance.matrix</a></code>.
</p>
<p><code>Bruvo2.distance</code> calculates distances between individuals under
the models of genome addition and genome loss.  If <code>add = TRUE</code> and
<code>loss = TRUE</code>, the distance produced is equal to that of equation 6
in the paper.
</p>
<p>If <code>add = TRUE</code> and <code>loss = FALSE</code>, the distance calculated is
that under genome addition only.  Likewise if <code>add = FALSE</code> and
<code>loss = TRUE</code> the distance is calculated under genome loss only.
The latter distance should be greater than the former.  If both were averaged
together, they would give the identical result to that produced when
<code>add = TRUE</code> and <code>loss = TRUE</code>.  All three distances will be
less than that produced by <code>Bruvo.distance</code>.
</p>
<p>If both genotypes have the same number of alleles, they are passed to
<code>Bruvo.distance</code> for the calculation.  This also happens if
<code>add = FALSE</code> and <code>loss = FALSE</code>.  Otherwise, if the genotypes have
different numbers of alleles, all possible genotypes with virtual
alleles are enumerated and passed to <code>Bruvo.distance</code> one by one, and
the results averaged.
</p>
<p>The number of different genotypes simulated under genome loss or genome
addition is <code class="reqn">l^d</code>, where <code class="reqn">l</code> is the length of the genotype from
which virtual alleles are being taken, and <code class="reqn">d</code> is the difference in
length between the longer and shorter genotype.  For example, under
genome addition for a diploid individual with alleles 1 and 2 being
compared to a tetraploid individual, the genotypes 1211, 1212, 1221, and
1222 will each be used once to represent the diploid individual.
</p>


<h3>Value</h3>

<p>A decimal between 0 and 1, with 0 indicating complete identity of two
genotypes, and 1 indicating maximum dissimilarity.  <code>NA</code> is
returned if one or both genotypes are missing or if <code>maxl</code> is exceeded.
</p>


<h3>Note</h3>

<p>Figure 1B and 1C of Bruvo <em>et al.</em> (2004) illustrate an example of
this distance measure.  To perform the identical calculation to that
listed directly under equation 6, you would type:
</p>
<p><code>Bruvo2.distance(c(20,23,24), c(20,24,26,43), usatnt=1)</code>
</p>
<p>However, you will notice that the result, 0.401, is slightly different from that
given in the paper.  This is due to an error in the paper.  For the
distance under genome loss when the virtual allele is 26, the result
should be 1 instead of 1.75.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Bruvo, R., Michiels, N. K., D'Sousa, T. G., and Schulenberg, H. (2004)
A simple method for calculation of microsatellite genotypes
irrespective of ploidy level. <em>Molecular Ecology</em> <b>13</b>, 2101&ndash;2106.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lynch.distance">Lynch.distance</a></code>, <code><a href="#topic+Bruvo.distance">Bruvo.distance</a></code>,
<code><a href="#topic+meandistance.matrix2">meandistance.matrix2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Bruvo2.distance(c(102,104), c(104,104,106,110))
Bruvo2.distance(c(102,104), c(104,104,106,110), add = FALSE)
Bruvo2.distance(c(102,104), c(104,104,106,110), loss = FALSE)
</code></pre>

<hr>
<h2 id='calcPopDiff'>
Estimate Population Differentiation Statistics
</h2><span id='topic+calcFst'></span><span id='topic+calcPopDiff'></span>

<h3>Description</h3>

<p>Given a data frame of allele frequencies and population sizes,
<code>calcPopDiff</code> calculates a matrix of pairwise <code class="reqn">F_{ST}</code>, 
<code class="reqn">G_{ST}</code>, Jost's <code class="reqn">D</code>, or <code class="reqn">R_{ST}</code> values, or a single global
value for any of these four statistics.
<code>calcFst</code> is a wrapper for <code>calcPopDiff</code> to allow backwards
compatibility with previous versions of <span class="pkg">polysat</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcPopDiff(freqs, metric, pops = row.names(freqs), 
            loci = unique(gsub("\\..*$", "", names(freqs))), global = FALSE,
            bootstrap = FALSE, n.bootstraps = 1000, object = NULL)

calcFst(freqs, pops = row.names(freqs),
        loci = unique(gsub("\\..*$", "", names(freqs))), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcPopDiff_+3A_freqs">freqs</code></td>
<td>

<p>A data frame of allele frequencies and population sizes such as that
produced by <code>simpleFreq</code> or <code>deSilvaFreq</code>.  Each population 
is in one row, and a
column called <code>Genomes</code> (or multiple columns containing the locus
names and &ldquo;Genomes&rdquo; seperated by a period) contains the relative
size of each
population.  All other columns contain allele frequencies.  The names of
these columns are the locus name and allele name, separated by a period.
</p>
</td></tr>
<tr><td><code id="calcPopDiff_+3A_metric">metric</code></td>
<td>

<p>The population differentiation statistic to estimate.  Can be &ldquo;Fst&rdquo;,
&ldquo;Gst&rdquo;, &ldquo;Jost's D&rdquo;, or &ldquo;Rst&rdquo;.
</p>
</td></tr>
<tr><td><code id="calcPopDiff_+3A_pops">pops</code></td>
<td>

<p>A character vector.  Populations to analyze, which should be
a subset of <code>row.names(freqs)</code>.
</p>
</td></tr>
<tr><td><code id="calcPopDiff_+3A_loci">loci</code></td>
<td>

<p>A character vector indicating which loci to analyze.  These should be a
subset of the locus names as used in the column names of <code>freqs</code>.
</p>
</td></tr>
<tr><td><code id="calcPopDiff_+3A_global">global</code></td>
<td>

<p>Boolean.  If <code>TRUE</code>, a single global statistic will be estimated across all
populations.  If <code>FALSE</code>, pairwise statistics will be estimated between 
populations.
</p>
</td></tr>
<tr><td><code id="calcPopDiff_+3A_bootstrap">bootstrap</code></td>
<td>

<p>Boolean.  If <code>TRUE</code>, a set of replicates bootstrapped across loci will be returned.  If
<code>FALSE</code>, a single value will be returned for each pair of populations (if 
<code>global = FALSE</code>) or for the whole set (if <code>global = TRUE</code>).
</p>
</td></tr>
<tr><td><code id="calcPopDiff_+3A_n.bootstraps">n.bootstraps</code></td>
<td>

<p>Integer.  The number of bootstrap replicates to perform.  Ignored if 
<code>bootstrap = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="calcPopDiff_+3A_object">object</code></td>
<td>

<p>A <code>"genambig"</code> or <code>"genbinary"</code> object with the <code>Usatnts</code> slot filled in.
Required for <code>metric = "Rst"</code> only.
</p>
</td></tr>
<tr><td><code id="calcPopDiff_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code>calcPopDiff</code> (<em>i.e.</em> <code>global</code>,
<code>bootstrap</code>, and/or <code>n.bootstraps</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>metric = "Fst"</code> or <code>calcFst</code>:
</p>
<p><code class="reqn">H_S</code> and <code class="reqn">H_T</code> are estimate directly from allele frequencies
for each locus for each pair of populations, then averaged across loci.  
Wright's <code class="reqn">F_{ST}</code> is then calculated for each pair of populations as 
<code class="reqn">\frac{H_T - H_S}{H_T}</code>.
</p>
<p><code class="reqn">H</code> values (expected heterozygosities for populations and combined
populations) are calculated as one minus the sum of all squared allele
frequencies at a locus.  To calculte <code class="reqn">H_T</code>, allele frequencies between two
populations are averaged before the calculation.  To calculate <code class="reqn">H_S</code>, <code class="reqn">H</code>
values are averaged after the calculation.  In both cases, the averages
are weighted by the relative sizes of the two populations (as indicated
by <code>freqs$Genomes</code>).
</p>
<p>For <code>metric = "Gst"</code>:
</p>
<p>This metric is similar to <code class="reqn">F_{ST}</code>, but mean allele frequencies and 
mean expected heterozygosities are not weighted by population size.  Additionally,
unbiased estimators of <code class="reqn">H_S</code> and <code class="reqn">H_T</code> are used according to Nei
and Chesser (1983; equations 15 and 16, reproduced also in Jost (2008)).
Instead of using twice the harmonic mean of the number of individuals in the two
subpopulations as described by Nei and Chesser (1983), the harmonic mean of the
number of allele copies in the two subpopulations (taken from <code>freq$Genomes</code>)
is used, in order to allow for polyploidy.
<code class="reqn">G_{ST}</code> is estimated for each locus and then averaged across loci.
</p>
<p>For <code>metric = "Jost's D"</code>:
</p>
<p>The unbiased estimators of <code class="reqn">H_S</code> and <code class="reqn">H_T</code> and calculated as 
with <code class="reqn">G_{ST}</code>, without weighting by population size.  They are then used 
to estimate <code class="reqn">D</code> at each locus according to Jost (2008; equation 12):
</p>
<p style="text-align: center;"><code class="reqn">2 * \frac{H_T - H_S}{1 - H_S}</code>
</p>

<p>Values of <code class="reqn">D</code> are then averaged across loci.
</p>
<p>For <code>metric = "Rst"</code>:
</p>
<p><code class="reqn">R_{ST}</code> is estimated on a per-locus basis according to Slatkin (1995),
but with populations weighted equally regardless of size. Values are then averaged
across loci.
</p>
<p>For each locus:
</p>
<p style="text-align: center;"><code class="reqn">S_w = \frac{1}{d} * \sum_j^d{\frac{\sum_i{\sum_{i' &lt; i}{p_{ij} * p_{i'j} * n_j^2 * (a_i - a_{i'})^2}}}{n_j * (n_j - 1)}}</code>
</p>

<p style="text-align: center;"><code class="reqn">\bar{S} = \frac{\sum_i{\sum_{i' &lt; i}{\bar{p}_i * \bar{p}_{i'} * n^2 * (a_i - a_{i'})^2}}}{n * (n-1)}</code>
</p>

<p style="text-align: center;"><code class="reqn">R_{ST} = \frac{\bar{S} - S_w}{\bar{S}}</code>
</p>

<p>where <code class="reqn">d</code> is the number of populations, <code class="reqn">j</code> is an individual population, <code class="reqn">i</code> and 
<code class="reqn">i'</code> are individual alleles, <code class="reqn">p_{ij}</code> is the frequency of an allele in a population,
<code class="reqn">n_j</code> is the number of allele copies in a population, <code class="reqn">a_i</code> is the size of an allele
expressed in number of repeat units, <code class="reqn">\bar{p}_i</code> is an allele frequency averaged across
populations (with populations weighted equally), and <code class="reqn">n</code> is the total number of allele copies
across all populations.
</p>


<h3>Value</h3>

<p>If <code>global = FALSE</code> and <code>bootstrap = FALSE</code>, a square matrix containing <code class="reqn">F_{ST}</code>, <code class="reqn">G_{ST}</code>, <code class="reqn">D</code>, or <code class="reqn">R_{ST}</code> values.  
The rows and columns of the matrix are both named by population.
</p>
<p>If <code>global = TRUE</code> and <code>bootstrap = FALSE</code>, a single value indicating the <code class="reqn">F_{ST}</code>, <code class="reqn">G_{ST}</code>, <code class="reqn">D</code>, or <code class="reqn">R_{ST}</code> value.
</p>
<p>If <code>global = TRUE</code> and <code>bootstrap = TRUE</code>, a vector of bootstrapped replicates of <code class="reqn">F_{ST}</code>, <code class="reqn">G_{ST}</code>, <code class="reqn">D</code>, or <code class="reqn">R_{ST}</code>.
</p>
<p>If <code>global = FALSE</code> and <code>bootstrap = TRUE</code>, a square two-dimensional list, with rows and columns named by population.  Each item is
a vector of bootstrapped values for <code class="reqn">F_{ST}</code>, <code class="reqn">G_{ST}</code>, <code class="reqn">D</code>, or <code class="reqn">R_{ST}</code> for that pair of populations.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Nei, M. (1973) Analysis of gene diversity in subdivided populations.
<em>Proceedings of the National Academy of Sciences of the United
States of America</em> <b>70</b>, 3321&ndash;3323.
</p>
<p>Nei, M. and Chesser, R. (1983) Estimation of fixation indices and gene diversities.
<em>Annals of Human Genetics</em> <b>47</b>, 253&ndash;259.
</p>
<p>Jost, L. (2008) <code class="reqn">G_{ST}</code> and its relatives to not measure differentiation.
<em>Molecular Ecology</em> <b>17</b>, 4015&ndash;4026.
</p>
<p>Slatkin, M. (1995) A measure of population subdivision based on microsatellite 
allele frequencies.  <em>Genetics</em> <b>139</b>, 457&ndash;462.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simpleFreq">simpleFreq</a></code>, <code><a href="#topic+deSilvaFreq">deSilvaFreq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a data set (typically done by reading files)
mygenotypes &lt;- new("genambig", samples = paste("ind", 1:6, sep=""),
                   loci = c("loc1", "loc2"))
Genotypes(mygenotypes, loci = "loc1") &lt;- list(c(206), c(208,210),
                                              c(204,206,210),
    c(196,198,202,208), c(196,200), c(198,200,202,204))
Genotypes(mygenotypes, loci = "loc2") &lt;- list(c(130,134), c(138,140),
                                              c(130,136,140),
    c(138), c(136,140), c(130,132,136))
PopInfo(mygenotypes) &lt;- c(1,1,1,2,2,2)
mygenotypes &lt;- reformatPloidies(mygenotypes, output="sample")
Ploidies(mygenotypes) &lt;- c(2,2,4,4,2,4)
Usatnts(mygenotypes) &lt;- c(2,2)

# calculate allele frequencies
myfreq &lt;- simpleFreq(mygenotypes)

# calculate pairwise differentiation statistics
myfst &lt;- calcPopDiff(myfreq, metric = "Fst")
mygst &lt;- calcPopDiff(myfreq, metric = "Gst")
myD &lt;- calcPopDiff(myfreq, metric = "Jost's D")
myrst &lt;- calcPopDiff(myfreq, metric = "Rst", object = mygenotypes)

# examine the results
myfst
mygst
myD
myrst

# get global statistics
calcPopDiff(myfreq, metric = "Fst", global = TRUE)
calcPopDiff(myfreq, metric = "Gst", global = TRUE)
calcPopDiff(myfreq, metric = "Jost's D", global = TRUE)
calcPopDiff(myfreq, metric = "Rst", global = TRUE, object = mygenotypes)
</code></pre>

<hr>
<h2 id='catalanAlleles'>
Sort Alleles into Isoloci
</h2><span id='topic+catalanAlleles'></span>

<h3>Description</h3>

<p><code>catalanAlleles</code> uses genotypes present in a <code>"genambig"</code>
object to sort alleles from one locus into two or more isoloci in an
allopolyploid or diploidized autopolyploid species.  Alleles are
determined to belong to different
isoloci if they are both present in a fully homozygous genotype.  If
necessary, heterozygous genotypes are also examined to resolve remaining
alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catalanAlleles(object, samples = Samples(object), locus = 1,
               n.subgen = 2, SGploidy = 2, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="catalanAlleles_+3A_object">object</code></td>
<td>

<p>A <code>"genambig"</code> object containing the dataset to analyze.  All
individuals should be the same ploidy, although the function does not
access the <code>Ploidies</code> slot.  Missing data are allowed.  For the
locus to be examined, no genotype should have fewer than <code>n.subgen</code>
alleles or more than <code>n.subgen*SGploidy</code> alleles.
</p>
</td></tr>
<tr><td><code id="catalanAlleles_+3A_samples">samples</code></td>
<td>

<p>Optional argument indicating samples to be analyzed.  Can be integer or
character, as with other <span class="pkg">polysat</span> functions.
</p>
</td></tr>
<tr><td><code id="catalanAlleles_+3A_locus">locus</code></td>
<td>

<p>An integer or character string indicating which locus to analyze.
Cannot be a vector greater than length 1.  (The function will only
analyze one locus at a time.)
</p>
</td></tr>
<tr><td><code id="catalanAlleles_+3A_n.subgen">n.subgen</code></td>
<td>

<p>The number of isoloci (number of subgenomes).  For example, <code>2</code>
for an allotetraploid,
and <code>3</code> for an allohexaploid (three diploid genomes).
</p>
</td></tr>
<tr><td><code id="catalanAlleles_+3A_sgploidy">SGploidy</code></td>
<td>

<p>The ploidy of each genome.  Only one value is allowed; all genomes
must be the same ploidy.  <code>2</code> indicates that each subgenome is
diploid (as in an allotetraploid, or an allohexaploid with three diploid
genomes).
</p>
</td></tr>
<tr><td><code id="catalanAlleles_+3A_verbose">verbose</code></td>
<td>

<p>Boolean.  Indicates whether results, and if applicable, problematic
genotypes, should be printed to the console.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>catalanAlleles</code> implements and extends an approach used by Catalan
<em>et al.</em> (2006) that sorts alleles from a duplicated microsatellite
locus into two or more isoloci (homeologous loci on different
subgenomes).  First, fully homozygous genotypes are identified and used
in analysis.  If a genotype has as many alleles as there are subgenomes
(for example, a genotype with two alleles in an allotetraploid species),
it is assumed to be fully homozygous and the alleles are assumed to
belong to different subgenomes.  If some alleles remain unassigned after
examination of all fully homozygous genotypes, heterozygous genotypes
are also examined to attempt to assign those remaining alleles.
</p>
<p>For example, in an allotetraploid, if a genotype contains one unassigned
allele, and all other
alleles in the genotype are known to belong to one isolocus, the
unassigned allele can be assigned to the other isolocus.  Or, if two
alleles in a genotype belong to one isolocus, one allele belongs to the
other isolocus, and one allele is unassigned, the unassigned allele can
be assigned to the latter isolocus.  The function follows such logic
(which can be extended to higher ploidies) until all alleles can be
assigned, or returns a text string saying that
the allele assignments were unresolvable.
</p>
<p>It is important to note that this method assumes no null alleles and no
homoplasy across isoloci.  If the function encounters evidence of
either it will not return allele assignments.  Null alleles and
homoplasy are real possibilities in any dataset, which means that this
method simply will not work for some microsatellite loci.
</p>
<p>(Null alleles are those that do not produce a PCR amplicon, usually
because of a mutation in the primer binding site.  Alleles that exhibit
homoplasy are those that produce amplicons of the same size, despite not
being identical by descent.  Specifically, homoplasy between alleles from
different isoloci will interfere with the Catalan method of allele
assignment.)
</p>


<h3>Value</h3>

<p>A list containing the following items:
</p>
<table role = "presentation">
<tr><td><code>locus</code></td>
<td>
<p>A character string giving the name of the locus.</p>
</td></tr>
<tr><td><code>SGploidy</code></td>
<td>
<p>A number giving the ploidy of each subgenome.
Identical to the <code>SGploidy</code> argument.</p>
</td></tr>
<tr><td><code>assignments</code></td>
<td>
<p>If assignments cannot be made, a character string
describing the problem.  Otherwise, a matrix with <code>n.subgen</code>
rows and a labeled column for each allele, with a <code>1</code> if the
allele belongs to that subgenome and a <code>0</code> if it does not.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Aside from homoplasy and null alleles, stochastic effects may prevent
the minimum combination of genotypes needed to resolve all alleles
from being present in the dataset.  For a typical allotetraploid
dataset, 50 to 100 samples will be needed, whereas an
allohexaploid dataset may require over 100 samples.  In simulations,
allo-octoploid datasets with two tetraploid genomes were unresolvable
even with 10,000 samples due to the low probability of finding full
homozygotes.  Additionally, loci are less likely to be resolvable if
they have many alleles or if one isolocus is monomorphic.
</p>
<p>Although determination of allele copy number by is not needed (or
expected) for <code>catalanAlleles</code> as it was in the originally
published Catalan method, it is still very important that the
genotypes be high quality.  Even a single scoring error can cause the
method to fail, including allelic dropout, contamination between
samples, stutter peaks miscalled as alleles, and PCR artifacts
miscalled as alleles.  Poor quality loci (those that require some
&ldquo;artistic&rdquo; interpretation of gels or electropherograms) are
unlikely to work with this method.  Individual genotypes that are of
questionable quality should be discarded before running the function.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Catalan, P., Segarra-Moragues, J. G., Palop-Esteban, M., Moreno, C. and
Gonzalez-Candelas, F. (2006) A Bayesian approach for discriminating
among alternative inheritance hypotheses in plant polyploids: the
allotetraploid origin of genus Borderea (Dioscoreaceae).
<em>Genetics</em> <b>172</b>, 1939&ndash;1953.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alleleCorrelations">alleleCorrelations</a></code>, <code><a href="#topic+mergeAlleleAssignments">mergeAlleleAssignments</a></code>,
<code><a href="#topic+recodeAllopoly">recodeAllopoly</a></code>, <code><a href="#topic+simAllopoly">simAllopoly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make the default simulated allotetraploid dataset
mydata &lt;- simAllopoly()

# resolve the alleles
myassign &lt;- catalanAlleles(mydata)
</code></pre>

<hr>
<h2 id='deleteSamples'>
Remove Samples or Loci from an Object
</h2><span id='topic+deleteSamples'></span><span id='topic+deleteLoci'></span>

<h3>Description</h3>

<p>These functions remove samples or loci from all relevant slots of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteSamples(object, samples)
deleteLoci(object, loci)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deleteSamples_+3A_object">object</code></td>
<td>

<p>An object containing the dataset of interest.  Generally an object of
some subclass of <code>gendata</code>.
</p>
</td></tr>
<tr><td><code id="deleteSamples_+3A_samples">samples</code></td>
<td>

<p>A numerical or character vector of samples to be removed.
</p>
</td></tr>
<tr><td><code id="deleteSamples_+3A_loci">loci</code></td>
<td>

<p>A numerical or character vector of loci to be removed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are generic functions with methods for <code>genambig</code>,
<code>genbinary</code>, and
<code>gendata</code> objects.  The methods for the subclasses remove samples
or loci
from the <code>@Genotypes</code> slot, then pass the object to the method for
<code>gendata</code>, which removes samples or loci from the <code>@PopInfo</code>,
<code>@Ploidies</code>, and/or <code>@Usatnts</code> slots, as appropriate.  The
<code>@PopNames</code> slot is left untouched even if an entire population is
deleted, in order to preserve the connection between the numbers in
<code>@PopInfo</code> and the names in <code>@PopNames</code>.
</p>
<p>If your intent is to experiment with excluding samples or loci, it may
be a better idea to create character vectors of samples and loci that
you want to use and then use these vectors as the <code>samples</code> and
<code>loci</code> arguments for analysis or export functions.
</p>


<h3>Value</h3>

<p>An object identical to <code>object</code>, but with the specified samples or
loci removed.
</p>


<h3>Note</h3>

<p>These functions are somewhat redundant with the subscripting function
<code>"["</code>, which also works for all <code>gendata</code> objects.  However,
they may be more convenient depending on whether the user prefers to
specify the samples and loci to use or to
exclude.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Samples">Samples</a></code>, <code><a href="#topic+Loci">Loci</a></code>,
<code><a href="#topic+merge+2Cgendata+2Cgendata-method">merge,gendata,gendata-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up genambig object
mygen &lt;- new("genambig", samples = c("ind1", "ind2", "ind3", "ind4"),
             loci = c("locA", "locB", "locC", "locD"))

# delete a sample
Samples(mygen)
mygen &lt;- deleteSamples(mygen, "ind1")
Samples(mygen)

# delete some loci
Loci(mygen)
mygen &lt;- deleteLoci(mygen, c("locB", "locC"))
Loci(mygen)
</code></pre>

<hr>
<h2 id='deSilvaFreq'>
Estimate Allele Frequencies with EM Algorithm
</h2><span id='topic+deSilvaFreq'></span>

<h3>Description</h3>

<p>This function uses the method of De Silva <em>et al.</em> (2005) to
estimate allele frequencies under polysomic inheritance with a known
selfing rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deSilvaFreq(object, self, samples = Samples(object),
            loci = Loci(object), initNull = 0.15,
            initFreq = simpleFreq(object[samples, loci]),
            tol = 1e-08, maxiter = 1e4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deSilvaFreq_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+genambig-class">genambig</a>"</code> or <code>"<a href="#topic+genbinary-class">genbinary</a>"</code>
object containing the dataset of
interest.  All ploidies for <code>samples</code> and <code>loci</code> should be the
same, and this should be an
even number.  <code>PopInfo</code> must also be filled in for <code>samples</code>.
</p>
</td></tr>
<tr><td><code id="deSilvaFreq_+3A_self">self</code></td>
<td>

<p>A number between 1 and 0, indicating the rate of selfing.
</p>
</td></tr>
<tr><td><code id="deSilvaFreq_+3A_samples">samples</code></td>
<td>

<p>An optional character vector indicating a subset of samples to use in
the calculation.
</p>
</td></tr>
<tr><td><code id="deSilvaFreq_+3A_loci">loci</code></td>
<td>

<p>An optional character vector indicating a subset of loci for which to
calculate allele frequencies.
</p>
</td></tr>
<tr><td><code id="deSilvaFreq_+3A_initnull">initNull</code></td>
<td>

<p>A single value or numeric vector indicating initial frequencies to use
for the null allele at each locus.
</p>
</td></tr>
<tr><td><code id="deSilvaFreq_+3A_initfreq">initFreq</code></td>
<td>

<p>A data frame containing allele frequencies (for non-null loci) to use
for initialization.  This needs to be in the same format as the output
of <code><a href="#topic+simpleFreq">simpleFreq</a></code> with a single &ldquo;Genomes&rdquo; column
(similarly to the format of the
output of <code>deSilvaFreq</code>).  By default, the function will do a quick
estimation of allele frequencies using <code>simpleFreq</code> and then
initialize the EM algorithm at these frequencies.
</p>
</td></tr>
<tr><td><code id="deSilvaFreq_+3A_tol">tol</code></td>
<td>

<p>The tolerance level for determining when the results have converged.
Where <code>p2</code> and <code>p1</code> are the current and previous vectors of allele
frequencies, respectively, the EM algorithm stops if
<code>sum(abs(p2-p1)/(p2+p1)) &lt;= tol</code>.
</p>
</td></tr>
<tr><td><code id="deSilvaFreq_+3A_maxiter">maxiter</code></td>
<td>

<p>The maximum number of iterations that will be performed for each locus and 
population.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of the SAS code from the supplementary material of De Silva
<em>et al.</em>
(2005) is translated directly into the R code for this function.  The
SIMSAMPLE (or CreateRandomSample in the SAS code) function is omitted
so that the actual allelic phenotypes from the dataset can be used
instead of simulated phenotypes.  <code>deSilvaFreq</code>
loops through each locus and population, and in each loop tallies the
number of alleles and sets up matrices using GENLIST, PHENLIST, RANMUL, SELFMAT,
and CONVMAT as described in the paper.
Frequencies of each allelic phenotype are then tallied
across all samples in that population with non-missing data at the
locus.  Initial allele
frequencies for that population and locus are then extraced from
<code>initFreq</code> and adjusted according to <code>initNull</code>.  The EM
iteration then begins for that population and locus, as described in the
paper (EXPECTATION, GPROBS, and MAXIMISATION).
</p>
<p>Each repetition of the EM algorithm includes an expectation and
maximization step.  The expectation step uses allele frequencies and the
selfing rate to
calculate expected genotype frequencies, then uses observed phenotype
frequencies and expected genotype frequencies to estimate genotype
frequencies for the population.  The maximization step uses the
estimated genotype frequencies to calculate a new set of allele
frequencies.  The process is repeated until allele frequencies
converge.
</p>
<p>In addition to returning a data frame of allele frequencies,
<code>deSilvaFreq</code> also prints to the console the number of EM
repetitions used for each population and locus.  When each locus and
each population is begun, a message is printed to the console so that
the user can monitor the progress of the computation.
</p>


<h3>Value</h3>

<p>A data frame containing the estimated allele frequencies.  The row names
are population names from <code>PopNames(object)</code>.  The first column
shows how many genomes each population has.  All other columns represent
alleles (including one null allele per locus).  These column names are
the locus name and allele name separated by a period.
</p>


<h3>Note</h3>

<p>It is possible to exceed memory limits for R if a locus has too many
alleles in a population (e.g. 15 alleles in a tetraploid if the memory
limit is 1535 Mb, see <code>memory.limit</code>).
</p>
<p>De Silva <em>et al.</em> mention that their estimation method could be
extended to the case of disomic inheritence.  A method for disomic
inheritence is not implemented here, as it would require knowledge of
which alleles belong to which isoloci.
</p>
<p>De Silva <em>et al.</em> also suggest a means of
estimating the selfing rate with a least-squares method.  Using the
notation in the source code, this would be:
</p>
<p><code>lsq &lt;- smatt %*% EP - rvec</code>
</p>
<p><code>self &lt;- as.vector((t(EP - rvec) %*% lsq)/(t(lsq) %*% lsq))</code>
</p>
<p>However, in my experimentation with this calculation, it sometimes
yields selfing rates greater than one.  For this reason,
it is not implemented here.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>De Silva, H. N., Hall, A. J., Rikkerink, E., and Fraser, L. G. (2005)
Estimation of allele frequencies in polyploids under
certain patterns of inheritance.  <em>Heredity</em> <b>95</b>, 327&ndash;334
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simpleFreq">simpleFreq</a></code>, <code><a href="#topic+write.freq.SPAGeDi">write.freq.SPAGeDi</a></code>,
<code><a href="#topic+GENLIST">GENLIST</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## An example with a long run time due to the number of alleles

# create a dataset for this example
mygen &lt;- new("genambig", samples=c(paste("A", 1:100, sep=""),
                                   paste("B", 1:100, sep="")),
             loci=c("loc1", "loc2"))
PopNames(mygen) &lt;- c("PopA", "PopB")
PopInfo(mygen) &lt;- c(rep(1, 100), rep(2, 100))
mygen &lt;- reformatPloidies(mygen, output="one")
Ploidies(mygen) &lt;- 4
Usatnts(mygen) &lt;- c(2, 2)
Description(mygen) &lt;- "An example for allele frequency calculation."

# create some genotypes at random for this example
for(s in Samples(mygen)){
    Genotype(mygen, s, "loc1") &lt;- sample(seq(120, 140, by=2),
                                         sample(1:4, 1))
}
for(s in Samples(mygen)){
    Genotype(mygen, s, "loc2") &lt;- sample(seq(130, 156, by=2),
                                         sample(1:4, 1))
}
# make one genotype missing
Genotype(mygen, "B4", "loc2") &lt;- Missing(mygen)

# view the dataset
summary(mygen)
viewGenotypes(mygen)

# calculate the allele frequencies if the rate of selfing is 0.2
myfrequencies &lt;- deSilvaFreq(mygen, self=0.2)

# view the results
myfrequencies

## End(Not run)

## An example with a shorter run time, for checking that the funciton
## is working.  Genotype simulation is also a bit more realistic here.

# Create a dataset for the example.
mygen &lt;- new("genambig", samples=paste("A", 1:100, sep=""), loci="loc1")
PopNames(mygen) &lt;- "PopA"
PopInfo(mygen) &lt;- rep(1, 100)
mygen &lt;- reformatPloidies(mygen, output="one")
Ploidies(mygen) &lt;- 4
Usatnts(mygen) &lt;- 2
for(s in Samples(mygen)){
    alleles &lt;- unique(sample(c(122,124,126,0), 4, replace=TRUE,
                             prob = c(0.3, 0.2, 0.4, 0.1)))
    Genotype(mygen, s, "loc1") &lt;- alleles[alleles != 0]
    if(length(Genotype(mygen, s, "loc1"))==0)
        Genotype(mygen, s, "loc1") &lt;- Missing(mygen)
}

# We have created a random mating populations with four alleles
# including one null.  The allele frequencies are given in the
# 'prob' argument.

# Estimate allele frequencies
myfreq &lt;- deSilvaFreq(mygen, self=0.01)
myfreq
</code></pre>

<hr>
<h2 id='editGenotypes'>
Edit Genotypes Using the Data Editor
</h2><span id='topic+editGenotypes'></span>

<h3>Description</h3>

<p>The genotypes from an object of one of the subclasses of <code>gendata</code>
are converted to a data frame (if necessary), then displayed in the data
editor.  After
the user makes the desired edits and closes the data editor window, the
new genotypes are written to the <code>gendata</code> object and the object is
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editGenotypes(object, maxalleles = max(Ploidies(object)),
              samples = Samples(object), loci = Loci(object))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="editGenotypes_+3A_object">object</code></td>
<td>

<p>An object of the class <code>genambig</code> or <code>genbinary</code>.  Contains
the genotypes to be edited.
</p>
</td></tr>
<tr><td><code id="editGenotypes_+3A_maxalleles">maxalleles</code></td>
<td>

<p>Numeric.  The maximum number of alleles found in any given genotype.
The method
for <code>genambig</code> requires this information in order to determine how
many columns to put in the data frame.
</p>
</td></tr>
<tr><td><code id="editGenotypes_+3A_samples">samples</code></td>
<td>

<p>Character or numeric vector indicating which samples to edit.
</p>
</td></tr>
<tr><td><code id="editGenotypes_+3A_loci">loci</code></td>
<td>

<p>Character or numeric vector indicating which loci to edit.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for <code>genambig</code> lists sample and locus names in each row
in order to identify the genotypes.  However, only the alleles
themselves should be edited.  NA values and duplicate alleles in the
data editor will be
omitted from the genotype vectors that are written back to the
<code>genambig</code> object.
</p>


<h3>Value</h3>

<p>An object identical to <code>object</code> but with edited genotypes.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+viewGenotypes">viewGenotypes</a></code>, <code><a href="#topic+Genotype+3C-">Genotype&lt;-</a></code>,
<code><a href="#topic+Genotypes+3C-">Genotypes&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){  #this line included for automated checking on CRAN

# set up "genambig" object to edit
mygen &lt;- new("genambig", samples = c("a", "b", "c"),
             loci = c("loc1", "loc2"))
Genotypes(mygen, loci="loc1") &lt;- list(c(133, 139, 142),
                                      c(130, 136, 139, 145),
                                      c(136, 142))
Genotypes(mygen, loci="loc2") &lt;- list(c(202, 204), Missing(mygen),
                                      c(200, 206, 208))
mygen &lt;- reformatPloidies(mygen, output="one")
Ploidies(mygen) &lt;- 4

# open up the data editor
mygen &lt;- editGenotypes(mygen)

# view the results of your edits
viewGenotypes(mygen)

}
</code></pre>

<hr>
<h2 id='estimatePloidy'>
Estimate Ploidies Based on Allele Counts
</h2><span id='topic+estimatePloidy'></span>

<h3>Description</h3>

<p><code>estimatePloidy</code> calculates the maximum and mean number of unique
alleles for each sample across a given set of loci.  These values are
presented in a data editor, along with other pertinent information, so
that the user can then edit the ploidy values for the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimatePloidy(object, extrainfo, samples = Samples(object), 
               loci = Loci(object))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimatePloidy_+3A_object">object</code></td>
<td>

<p>The object containing genotype data, and to which ploidies will be written.
</p>
</td></tr>
<tr><td><code id="estimatePloidy_+3A_extrainfo">extrainfo</code></td>
<td>

<p>A named or unnamed vector or data frame containing extra information
(such as morphological or flow cytometry data) to
display in the data editor, to assist with making decisions about
ploidy.  If unnamed, the vector (or the rows of the data frame) is
assumed to be in the same order as <code>samples</code>.  An array can also be
given as an argument here, and will be coerced to a data frame.
</p>
</td></tr>
<tr><td><code id="estimatePloidy_+3A_samples">samples</code></td>
<td>

<p>A numeric or character vector indicating a subset of samples to evaluate.
</p>
</td></tr>
<tr><td><code id="estimatePloidy_+3A_loci">loci</code></td>
<td>

<p>A numeric or character vector indicating a subset of loci to use in the
calculation of mean and maximum allele number.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>estimatePloidy</code> is a generic function with methods written for
the <code>genambig</code> and <code>genbinary</code> classes.
</p>
<p>If the <code>Ploidies</code> slot of <code>object</code> is not already a
<code>"ploidysample"</code> object, the function will first convert the
<code>Ploidies</code> slot to this format, deleting any data that is currently
there.  (Ploidies must be indexed by sample and not by locus.)  If
ploidies were already in the <code>"ploidysample"</code> format, any ploidy
data already in the object is retained and put into the table (see
below).
</p>
<p>Population identities are displayed in the table only if more than one
population identity is found in the dataset.  Likewise, the current
ploidies of the dataset are only displayed if there is more than one
ploidy level already found in <code>Ploidies(object)</code>.
</p>
<p>Missing genotypes are ignored; maximum and mean allele counts are only
calculted across genotypes that are not missing.  If all genotypes for a
given sample are missing, <code>NA</code> is displayed in the corresponding
cells in the data editor.
</p>
<p>The default values for <code>new.ploidy</code> are the maximum number of
alleles per locus for each sample.
</p>


<h3>Value</h3>

<p><code>object</code> is returned, with <code>Ploidies(object)</code> now equal to the
values set in the <code>new.ploidy</code> column of the data editor.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genambig-class">genambig</a></code>, <code><a href="#topic+genbinary-class">genbinary</a></code>,
<code><a href="#topic+Ploidies">Ploidies</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){ #this line included for automated checking on CRAN

# create a dataset for this example
mygen &lt;- new("genambig", samples=c("a", "b", "c"),
             loci=c("loc1", "loc2"))
Genotypes(mygen, loci="loc1") &lt;- list(c(122, 126, 128), c(124, 130),
                                      c(120, 122, 124))
Genotypes(mygen, loci="loc2") &lt;- list(c(140, 148), c(144, 150), Missing(mygen))

# estimate the ploidies
mygen &lt;- estimatePloidy(mygen)

# view the ploidies
Ploidies(mygen)

}

</code></pre>

<hr>
<h2 id='FCRinfo'>Additional Data on Rubus Samples</h2><span id='topic+FCRinfo'></span>

<h3>Description</h3>

<p>For 20 <em>Rubus</em> samples, contains colors and symbols to use for
plotting data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FCRinfo)</code></pre>


<h3>Format</h3>

<p>Data frame.  <code>FCRinfo$Plot.color</code> contains character
strings of the colors to be used to represent species groups.
<code>FCR.info$Plot.symbol</code> contains integers to be passed to
<code>pch</code> to designate the symbol used to represent each individual.
These reflect chloroplast haplotypes.</p>


<h3>Source</h3>

<p>Clark, L. V. and Jasieniuk, M. (2012)  Spontaneous
hybrids between native and exotic <em>Rubus</em> in the Western United
States produce offspring both by apomixis and by sexual
recombination. <em>Heredity</em> <b>109</b>, 320&ndash;328.  Data available
at: <a href="https://doi.org/10.5061/dryad.m466f">doi:10.5061/dryad.m466f</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+testgenotypes">testgenotypes</a></code></p>

<hr>
<h2 id='find.missing.gen'>
Find Missing Genotypes
</h2><span id='topic+find.missing.gen'></span>

<h3>Description</h3>

<p>This function returns a data frame listing the locus and sample names of
all genotypes with missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.missing.gen(object, samples = Samples(object),
                 loci = Loci(object))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.missing.gen_+3A_object">object</code></td>
<td>

<p>A <code>genambig</code> or <code>genbinary</code> object containing the genotypes of
interest.
</p>
</td></tr>
<tr><td><code id="find.missing.gen_+3A_samples">samples</code></td>
<td>

<p>A character vector of all samples to be searched.  Must be a subset of
<code>Samples(object)</code>.
</p>
</td></tr>
<tr><td><code id="find.missing.gen_+3A_loci">loci</code></td>
<td>

<p>A character vector of all loci to be searched.  Must be a subset of
<code>Loci(object)</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with no row names.  The first column is named
&ldquo;Locus&rdquo; and the second column is named &ldquo;Sample&rdquo;.  Each
row represents one missing genotype, and gives the locus and sample
of that genotype.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isMissing">isMissing</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up the genotype data
samples &lt;- paste("ind", 1:4, sep="")
samples
loci &lt;- paste("loc", 1:3, sep="")
loci
testgen &lt;- new("genambig", samples = samples, loci = loci)
Genotypes(testgen, loci="loc1") &lt;- list(c(-9), c(102,104),
                                        c(100,106,108,110,114),
                                        c(102,104,106,110,112))
Genotypes(testgen, loci="loc2") &lt;- list(c(77,79,83), c(79,85), c(-9),
                                        c(83,85,87,91))
Genotypes(testgen, loci="loc3") &lt;- list(c(122,128), c(124,126,128,132),
                                        c(120,126), c(124,128,130))

# look up which samples*loci have missing genotypes
find.missing.gen(testgen)

</code></pre>

<hr>
<h2 id='freq.to.genpop'>
Convert Allele Frequencies for Adegenet
</h2><span id='topic+freq.to.genpop'></span>

<h3>Description</h3>

<p>Given a data frame of allele frequencies such as that produced by
<code>simpleFreq</code> or <code>deSilvaFreq</code>, <code>freq.to.genpop</code> creates a
data frame of allele counts that can be read by the <code>as.genpop</code>
function in the package <span class="pkg">adegenet</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq.to.genpop(freqs, pops = row.names(freqs),
               loci =
                unique(as.matrix(as.data.frame(strsplit(names(freqs),
                split = ".", fixed = TRUE), stringsAsFactors = FALSE))[1, ]))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="freq.to.genpop_+3A_freqs">freqs</code></td>
<td>

<p>A data frame of allele frequencies.  Row names are population names.
The first column is called <code>"Genomes"</code> and indicates the size of
each population in terms of number of haploid genomes.  All other column
names are the locus and allele separated by a period.  These columns
contain the frequencies of each allele in each population.  For each
locus and population, all frequencies should total to 1.
</p>
</td></tr>
<tr><td><code id="freq.to.genpop_+3A_pops">pops</code></td>
<td>

<p>An optional character vector indicating the names of populations to use.
</p>
</td></tr>
<tr><td><code id="freq.to.genpop_+3A_loci">loci</code></td>
<td>

<p>An optional character vector indicating the names of loci to use.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">adegenet</span> expects one ploidy for the entire dataset.  Therefore, data
frames of allele frequencies with multiple &ldquo;Genomes&rdquo; columns,
such as those produced when ploidy varies by locus, are not allowed as
the <code>freqs</code> argument.
</p>


<h3>Value</h3>

<p>A data frame with row and column names identical to those in
<code>freqs</code>, minus the <code>"Genomes"</code> column and any columns for loci
not included in <code>loci</code>.  Allele frequencies are converted to counts
by multiplying by the values in the <code>"Genomes"</code> column and rounding
to the nearest integer.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Jombart, T.  (2008)  adegenet: a R package for the multivariate analysis
of genetic markers.  <em>Bioinformatics</em> <b>24</b>, 1403-1405.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simpleFreq">simpleFreq</a></code>, <code><a href="#topic+deSilvaFreq">deSilvaFreq</a></code>,
<code><a href="#topic+write.freq.SPAGeDi">write.freq.SPAGeDi</a></code>, <code><a href="#topic+gendata.to.genind">gendata.to.genind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a simple allele frequency table
# (usually done with simpleFreq or deSilvaFreq)
myfreq &lt;- data.frame(row.names=c("popA","popB"), Genomes=c(120,100),
                     locG.152=c(0.1,0.4), locG.156=c(0.5, 0.3),
                     locG.160=c(0.4, 0.3), locK.179=c(0.15, 0.25),
                     locK.181=c(0.35, 0.6), locK.183=c(0.5, 0.15))
myfreq

# convert to adegenet format
gpfreq &lt;- freq.to.genpop(myfreq)
gpfreq

## Not run: 
# If you have adegenet installed, you can now make this into a
# genpop object.
require(adegenet)
mygenpop &lt;- genpop(gpfreq, ploidy=as.integer(4), type="codom")

# examine the object that has been created
mygenpop
popNames(mygenpop)
mygenpop@tab
mygenpop@all.names

# Perform a distance calculation with the object
dist.genpop(mygenpop)

## End(Not run)
</code></pre>

<hr>
<h2 id='genambig-class'>Class &quot;genambig&quot;</h2><span id='topic+genambig-class'></span><span id='topic+deleteLoci+2Cgenambig-method'></span><span id='topic+deleteSamples+2Cgenambig-method'></span><span id='topic+editGenotypes+2Cgenambig-method'></span><span id='topic+estimatePloidy+2Cgenambig-method'></span><span id='topic+Genotype+2Cgenambig-method'></span><span id='topic+Genotype+3C-+2Cgenambig-method'></span><span id='topic+Genotypes+2Cgenambig-method'></span><span id='topic+Genotypes+3C-+2Cgenambig-method'></span><span id='topic+initialize+2Cgenambig-method'></span><span id='topic+isMissing+2Cgenambig-method'></span><span id='topic+Loci+3C-+2Cgenambig-method'></span><span id='topic+Missing+3C-+2Cgenambig-method'></span><span id='topic+Samples+3C-+2Cgenambig-method'></span><span id='topic+summary+2Cgenambig-method'></span><span id='topic+show+2Cgenambig-method'></span><span id='topic+viewGenotypes+2Cgenambig-method'></span><span id='topic++5B+2Cgenambig-method'></span>

<h3>Description</h3>

<p>Objects of this class store microsatellite datasets in which allele copy
number is ambiguous.  Genotypes are stored as a two-dimensional list of
vectors, each vector containing all unique alleles for a given sample at
a given locus.  <code>genambig</code> is a subclass of <code>gendata</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("genambig",
  samples, loci, ...)</code>.  This automatically sets up a two-dimensional
list in the <code>Genotypes</code> slot, with <code>dimnames=list(samples,
  loci)</code>.  This array-list is initially populated with the missing data
symbol.  All other slots are given initial values according to the
<code>initialize</code> method for <code>gendata</code>.  Data can then be inserted
into the slots using the replacement functions (see
<code><a href="#topic+Samples">Accessors</a></code>).
</p>


<h3>Slots</h3>


<dl>
<dt><code>Genotypes</code>:</dt><dd><p>Object of class <code>"array"</code>.  The first
dimension of the array represents and is named by samples, while
the second dimension represents and is named by loci.  Each
element of the array can contain a vector.  Each vector should
contain each unique allele for the genotype once.  If an array
element contains a vector of length 1 containing only the symbol
that is in the <code>Missing</code> slot, this indicates missing data
for that sample and locus.</p>
</dd>
<dt><code>Description</code>:</dt><dd><p>Object of class <code>"character"</code>.  This
stores a description of the dataset for the user's convenience.</p>
</dd>
<dt><code>Missing</code>:</dt><dd><p>Object of class <code>"ANY"</code>.  A symbol to be
used to indicate missing data in the <code>Genotypes</code> slot.  This is
the integer <code>-9</code> by default.</p>
</dd>
<dt><code>Usatnts</code>:</dt><dd><p>Object of class <code>"integer"</code>.  A vector,
named by loci.  Each element indicates the repeat type of the
locus.  <code>2</code> indicates dinucleotide repeats, <code>3</code>
indicates trinucleotide repeats, and so on.  If the alleles stored
in the <code>Genotypes</code> slot for a given locus are already written
in terms of repeat number, the <code>Usatnts</code> value for that locus
should be <code>1</code>.  In other words, all alleles for a locus can be
divided by the number in <code>Usatnts</code> to give alleles expressed in
terms of relative repeat number.</p>
</dd>
<dt><code>Ploidies</code>:</dt><dd><p>Object of class <code>"integer"</code>.  A vector,
named by samples.  This stores the ploidy of each sample.  <code>NA</code>
indicates unknown ploidy.  See <code><a href="#topic+Ploidies+3C-">Ploidies&lt;-</a></code> and
<code><a href="#topic+estimatePloidy">estimatePloidy</a></code> for ways to fill this slot.</p>
</dd>
<dt><code>PopInfo</code>:</dt><dd><p>Object of class <code>"integer"</code>.  A vector,
named by samples, containing the population identity of each sample. </p>
</dd>
<dt><code>PopNames</code>:</dt><dd><p>Object of class <code>"character"</code>.  A
vector containing names for all populations.  The position of a
population name in the vector indicates the integer used to
represent that population in <code>PopInfo</code>. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+gendata-class">gendata</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>For more information on any of these methods, see the help files of
their respective generic functions.
</p>

<dl>
<dt>deleteLoci</dt><dd><p><code>signature(object = "genambig")</code>: Removes
columns in the array in the <code>Genotypes</code> slot corresponding to
the locus names supplied, then passes the arguments to the method
for <code>gendata</code>.</p>
</dd>
<dt>deleteSamples</dt><dd><p><code>signature(object = "genambig")</code>: Removes
rows in the array in the <code>Genotypes</code> slot corresponding to
the sample names supplied, then passes the arguments to the method
for <code>gendata</code>.</p>
</dd>
<dt>editGenotypes</dt><dd><p><code>signature(object = "genambig")</code>: Each
vector in the <code>Genotypes</code> slot is placed into the row of a
data frame, along with the sample and locus name for this vector.
The data frame is then opened in the Data Editor so that the user
can make changes.  When the Data Editor window is closed, vectors
are extracted back out of the data frame and written to the
<code>Genotypes</code> slot.</p>
</dd>
<dt>estimatePloidy</dt><dd><p><code>signature(object = "genambig")</code>:
Calculates the length of each genotype vector (excluding those
with the missing data symbol), and creates a data frame showing
the maximum and mean number of alleles per locus for each sample.
This data frame is then opened in the Data Editor, where the user
may edit ploidy levels.  Once the Data Editor is closed, the
<code>genambig</code> object is returned with the new values written to
the <code>Ploidies</code> slot.</p>
</dd>
<dt>Genotype</dt><dd><p><code>signature(object = "genambig")</code>: Retrieves a
single genotype vector, as specified by <code>sample</code> and
<code>locus</code> arguments. </p>
</dd>
<dt>Genotype&lt;-</dt><dd><p><code>signature(object = "genambig")</code>: Replaces a
single genotype vector. </p>
</dd>
<dt>Genotypes</dt><dd><p><code>signature(object = "genambig")</code>: Retrieves a
two-dimensional list of genotype vectors. </p>
</dd>
<dt>Genotypes&lt;-</dt><dd><p><code>signature(object = "genambig")</code>: Replaces a
one- or two-dimensional list of genotype vectors.</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "genambig")</code>: When
<code>new</code> is called to create a new <code>genambig</code> object, the
<code>initialize</code> method sets up a two dimensional list in the
<code>Genotypes</code> slot indexed by sample and locus, and fills this
list with the missing data symbol.  The <code>initialize</code> method
for <code>gendata</code> is then called. </p>
</dd>
<dt>isMissing</dt><dd><p><code>signature(object = "genambig")</code>: Given a set of
samples and loci, each position in the array in the <code>Genotypes</code>
slot is checked to see if it matches the missing data value.  A single
Boolean value or an array of Boolean values is returned.</p>
</dd>
<dt>Loci&lt;-</dt><dd><p><code>signature(object = "genambig")</code>: For changing
the names of loci.  The names are changed in the second dimension
of the array in the <code>Genotypes</code> slot, and then the
<code>Loci&lt;-</code> method for <code>gendata</code> is called. </p>
</dd>
<dt>Missing&lt;-</dt><dd><p><code>signature(object = "genambig")</code>: For changing
the missing data symbol.  All elements of the <code>Genotypes</code> array
that match the current missing data symbol are changed to the new
missing data symbol.  The <code>Missing&lt;-</code> method for <code>gendata</code>
is then called.</p>
</dd>
<dt>Samples&lt;-</dt><dd><p><code>signature(object = "genambig")</code>: For changing
the names of samples.  The names are changed in the first dimension
of the array in the <code>Genotypes</code> slot, and then the
<code>Samples&lt;-</code> method for <code>gendata</code> is called.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "genambig")</code>: Prints the
dataset description (<code>Description</code> slot) to the console as
well as the number of missing genotypes, then calls the
<code>summary</code> method for <code>gendata</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "genambig")</code>: Prints the
data to the console, formatted to make it more legible. The
genotype for each locus is shown as the size of each allele,
separated by a '/'. The SSR motif length ('Usatnts'), ploidies,
population names, and population membership ('PopInfo') are
displayed if they exist.</p>
</dd>
<dt>viewGenotypes</dt><dd><p><code>signature(object = "genambig")</code>: Prints a
tab-delimited table of samples, loci, and genotype vectors to the console.</p>
</dd>
<dt>&quot;[&quot;</dt><dd><p><code>signature(x = "genambig", i = "ANY", j = "ANY")</code>:
For subscipting <code>genambig</code> objects.  Should be of the form
<code>mygenambig[mysamples, myloci]</code>.  Returns a <code>genambig</code>
object.  The <code>Genotypes</code> slot
is replaced by one containing only samples <code>i</code> and loci
<code>j</code>.  Likewise, the <code>PopInfo</code> and <code>Ploidies</code> slots
are truncated to contain only samples <code>i</code>, and the
<code>Usatnts</code> slot is truncated to contain only loci
<code>j</code>.  Other slots are left unaltered.</p>
</dd>
<dt>merge</dt><dd><p><code>signature(x = "genambig", y = "genambig")</code>:
Merges two genotypes objects together.  See
<code><a href="#topic+merge+2Cgenambig+2Cgenambig-method">merge,genambig,genambig-method</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Lindsay V. Clark, Tyler W. Smith
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gendata-class">gendata</a></code>, <code><a href="#topic+Samples">Accessors</a></code>,
<code><a href="#topic+merge+2Cgenambig+2Cgenambig-method">merge,genambig,genambig-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># display class definition
showClass("genambig")

# create a genambig object
mygen &lt;- new("genambig", samples=c("a", "b", "c", "d"),
             loci=c("L1", "L2", "L3"))
# add some genotypes
Genotypes(mygen)[,"L1"] &lt;- list(c(133, 139, 145), c(142, 154),
                                c(130, 142, 148), Missing(mygen))
Genotypes(mygen, loci="L2") &lt;- list(c(105, 109, 113), c(111, 117),
                                    c(103, 115), c(105, 109, 113))
Genotypes(mygen, loci="L3") &lt;- list(c(254, 258), Missing(mygen),
                                    c(246, 250, 262), c(250, 258))

# see a summary of the object
summary(mygen)
# display some of the genotypes
viewGenotypes(mygen[c("a", "b", "c"),])
</code></pre>

<hr>
<h2 id='genambig.to.genbinary'>
Convert Between Genotype Object Classes
</h2><span id='topic+genambig.to.genbinary'></span><span id='topic+genbinary.to.genambig'></span>

<h3>Description</h3>

<p>These functions convert back and forth between the <code>genambig</code> and
<code>genbinary</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genambig.to.genbinary(object, samples = Samples(object),
                      loci = Loci(object))

genbinary.to.genambig(object, samples = Samples(object),
                      loci = Loci(object))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genambig.to.genbinary_+3A_object">object</code></td>
<td>

<p>The object containing the genetic dataset.  A <code>genambig</code> object for
<code>genambig.to.genbinary</code>, or a <code>genbinary</code> object for
<code>genbinary.to.genambig</code>.
</p>
</td></tr>
<tr><td><code id="genambig.to.genbinary_+3A_samples">samples</code></td>
<td>

<p>An optional character vector indicating samples to include in the new object.
</p>
</td></tr>
<tr><td><code id="genambig.to.genbinary_+3A_loci">loci</code></td>
<td>

<p>An optional character vector indicating loci to include in the new object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots <code>Description</code>, <code>Ploidies</code>, <code>Usatnts</code>,
<code>PopNames</code>, and <code>PopInfo</code> are transferred as-is from the old
object to the new.  The value in the
<code>Genotypes</code> slot is converted from one format to the other, with
preservation of allele names.
</p>


<h3>Value</h3>

<p>For <code>genambig.to.genbinary</code>: a <code>genbinary</code> object containing
all of the data from <code>object</code>.  <code>Missing</code>, <code>Present</code>,
and <code>Absent</code> are set at their default values.
</p>
<p>For <code>genbinary.to.genambig</code>: a <code>genambig</code> object containing
all of the data from <code>object</code>.  <code>Missing</code> is at the default
value.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genambig-class">genambig</a></code>, <code><a href="#topic+genbinary-class">genbinary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up a genambig object for this example
mygen &lt;- new("genambig", samples = c("A", "B", "C", "D"),
             loci = c("locJ", "locK"))
PopNames(mygen) &lt;- c("PopQ", "PopR")
PopInfo(mygen) &lt;- c(1,1,2,2)
Usatnts(mygen) &lt;- c(2,2)
Genotypes(mygen, loci="locJ") &lt;- list(c(178, 184, 186), c(174,186),
                                      c(182, 188, 190),
                                      c(182, 184, 188))
Genotypes(mygen, loci="locK") &lt;- list(c(133, 135, 141),
                                      c(131, 135, 137, 143),
                                      Missing(mygen), c(133, 137))

# convert it to a genbinary object
mygenB &lt;- genambig.to.genbinary(mygen)

# check the results
viewGenotypes(mygenB)
viewGenotypes(mygen)
PopInfo(mygenB)

# convert back to a genambig object
mygenA &lt;- genbinary.to.genambig(mygenB)
viewGenotypes(mygenA)

# note: identical(mygen, mygenA) returns FALSE, because the alleles
# origninally input are not stored as integers, while the alleles
# produced by genbinary.to.genambig are integers.

  </code></pre>

<hr>
<h2 id='genbinary-class'>Class &quot;genbinary&quot;</h2><span id='topic+genbinary-class'></span><span id='topic+Absent+2Cgenbinary-method'></span><span id='topic+Absent+3C-+2Cgenbinary-method'></span><span id='topic+Genotype+2Cgenbinary-method'></span><span id='topic+Genotypes+2Cgenbinary-method'></span><span id='topic+Genotypes+3C-+2Cgenbinary-method'></span><span id='topic+initialize+2Cgenbinary-method'></span><span id='topic+Missing+3C-+2Cgenbinary-method'></span><span id='topic+Present+2Cgenbinary-method'></span><span id='topic+Present+3C-+2Cgenbinary-method'></span><span id='topic+Samples+3C-+2Cgenbinary-method'></span><span id='topic+Loci+3C-+2Cgenbinary-method'></span><span id='topic+isMissing+2Cgenbinary-method'></span><span id='topic+summary+2Cgenbinary-method'></span><span id='topic+editGenotypes+2Cgenbinary-method'></span><span id='topic+viewGenotypes+2Cgenbinary-method'></span><span id='topic+deleteSamples+2Cgenbinary-method'></span><span id='topic+deleteLoci+2Cgenbinary-method'></span><span id='topic++5B+2Cgenbinary-method'></span><span id='topic+estimatePloidy+2Cgenbinary-method'></span>

<h3>Description</h3>

<p>This is a subclass of <code>gendata</code> that allows genotypes to be stored
as a matrix indicating the presence and absence of alleles.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("genbinary",
  samples, loci, ...)</code>.  After objects are initialized with sample and
locus names, data can be added to slots using the replacement functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Genotypes</code>:</dt><dd><p>Object of class <code>"matrix"</code>.  Row names
of the matrix are sample names.  Each column name is a locus name
and an allele separated by a period (<em>e.g.</em>
<code>"loc1.124"</code>); each column represents on allele.  The number of
alleles per locus is not limited and can be expanded even after
entering initial data.  Each element of the matrix must be equal to
either <code>Present(object)</code>, <code>Absent(object)</code>, or
<code>Missing(object)</code>.  These symbols indicate, respectively, that
a sample has an allele, that a sample does not have an allele, or
that data for the sample at that locus are missing.</p>
</dd>
<dt><code>Present</code>:</dt><dd><p>Object of class <code>"ANY"</code>.  The integer
<code>1</code> by default.  This symbol is used in the <code>Genotypes</code>
slot to indicate the presence of an allele in a sample. </p>
</dd>
<dt><code>Absent</code>:</dt><dd><p>Object of class <code>"ANY"</code>.  The integer
<code>0</code> by default.  This symbol is used in the <code>Genotypes</code>
slot to indicate the absence of an allele in a sample. </p>
</dd>
<dt><code>Description</code>:</dt><dd><p>Object of class <code>"character"</code>.  A
character string or vector describing the dataset, for the
convenience of the user. </p>
</dd>
<dt><code>Missing</code>:</dt><dd><p>Object of class <code>"ANY"</code>.  The integer
<code>-9</code> by default.  This symbol is used in the <code>Genotypes</code>
slot to indicate that data are missing for a given sample and locus.</p>
</dd>
<dt><code>Usatnts</code>:</dt><dd><p>Object of class <code>"integer"</code>.  A vector,
named by loci.  This indicates the repeat length of each locus.
<code>2</code> indicates dinucleotide repeats, <code>3</code>
indicates trinucleotide repeats, and so on.  If the alleles stored
in the column names of the <code>Genotypes</code> slot for a given locus
are already written
in terms of repeat number, the <code>Usatnts</code> value for that locus
should be <code>1</code>.  In other words, all alleles for a locus can be
divided by the number in <code>Usatnts</code> to give alleles expressed in
terms of relative repeat number. </p>
</dd>
<dt><code>Ploidies</code>:</dt><dd><p>Object of class <code>"integer"</code>.  A vector,
named by samples.  This indicates the ploidy of each sample.</p>
</dd>
<dt><code>PopInfo</code>:</dt><dd><p>Object of class <code>"integer"</code>.  A vector,
named by samples.  This indicates the population identity of each
sample. </p>
</dd>
<dt><code>PopNames</code>:</dt><dd><p>Object of class <code>"character"</code>.  Names
of each population.  The position of the population name in the
vector corresponds to the number used to represent that population
in the <code>PopInfo</code> slot.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+gendata-class">gendata</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>Absent</dt><dd><p><code>signature(object = "genbinary")</code>: Returns the
symbol used to indicate that a given allele is absent in a given
sample. </p>
</dd>
<dt>Absent&lt;-</dt><dd><p><code>signature(object = "genbinary")</code>: Changes the
symbol used to indicate that a given allele is absent in a given
sample.  The matrix in the <code>Genotypes</code> slot is searched for
the old symbol, which is replaced by the new.  The new symbol is
then written to the <code>Absent</code> slot. </p>
</dd>
<dt>Genotype</dt><dd><p><code>signature(object = "genbinary")</code>: Returns a
matrix containing the genotype for a given sample and locus (by a
call to <code>Genotypes</code>). </p>
</dd>
<dt>Genotypes</dt><dd><p><code>signature(object = "genbinary")</code>: Returns the
matrix stored in the <code>Genotypes</code> slot, or a subset as specified
by the <code>samples</code> and <code>loci</code> arguments.</p>
</dd>
<dt>Genotypes&lt;-</dt><dd><p><code>signature(object = "genbinary")</code>: A method
for adding or replacing genotype data in the object.  Note that
allele columns cannot be removed from the matrix in the
<code>Genotypes</code> slot using this method, although an entire column
could be filled with zeros in order to effectively remove an
allele from the dataset.  If the order of rows in <code>value</code>
(the matrix containing values to be assigned to the
<code>Genotypes</code> slot) is not identical to <code>Samples(object)</code>,
the <code>samples</code> argument should be used to indicate row order.
Row names in <code>value</code> are ignored.  The <code>loci</code> argument can
be left at the default, even if only a subset of loci are being
assigned.  Column names of <code>value</code> are important, and should be
the locus name and allele name separated by a period, as they are in
the <code>Genotypes</code> slot.  After checking that the column name is
valid, the method checks for whether the column name already exists or
not in the <code>Genotypes</code> slot.  If it does exist, data from that
column are replaced with data from <code>value</code>.  If not, a column is
added to the matrix in the <code>Genotypes</code> slot for the new allele.  If
the column is new and data are not being written for samples, the method
automatically fills in <code>Missing</code> or <code>Absent</code> symbols for
additional samples, depending on whether or not data for the locus
appear to be missing for the sample or not.</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "genbinary")</code>: Sets up a
<code>genbinary</code> object when <code>new("genbinary")</code> is called.  If
<code>samples</code> or <code>loci</code> arguments are missing, these are
filled in with dummy values (<code>"ind1", "ind2", "loc1",
      "loc2"</code>).  The matrix is then set up in the <code>Genotypes</code>
slot.  Sample names are used for row names, and there are zero
columns.  The <code>initialize</code> method for <code>gendata</code> is then
called.</p>
</dd>
<dt>Missing&lt;-</dt><dd><p><code>signature(object = "genbinary")</code>: Replaces
all elements in matrix in the <code>Genotypes</code> slot containing the
old <code>Missing</code> symbol with the new <code>Missing</code> symbol.  The
method for <code>gendata</code> is then called to replace the value in the
<code>Missing</code> slot.</p>
</dd>
<dt>Present</dt><dd><p><code>signature(object = "genbinary")</code>: Returns the
symbol used to indicate that a given allele is present in a given
sample. </p>
</dd>
<dt>Present&lt;-</dt><dd><p><code>signature(object = "genbinary")</code>: Changes the
symbol used for indicating that a given allele is present in a given
sample.  The symbol is first replaced in the <code>Genotypes</code> slot,
and then in the <code>Present</code> slot.</p>
</dd>
<dt>Samples&lt;-</dt><dd><p><code>signature(object = "genbinary")</code>: Changes sample
names in the dataset.  Changes the row names in the <code>Genotypes</code>
slot, then calls the method for <code>gendata</code> to change the names in
the <code>PopInfo</code> and <code>Ploidies</code> slots.</p>
</dd>
<dt>Loci&lt;-</dt><dd><p><code>signature(object = "genbinary")</code>: Changes locus
names in the dataset.  Replaces the locus portion of the column names
in the <code>Genotypes</code> slot, then calls the method for <code>gendata</code>
to change the names in the <code>Usatnts</code> slot.</p>
</dd>
<dt>isMissing</dt><dd><p><code>signature(object = "genbinary")</code>: Returns Boolean
values, by sample and locus, indicating whether genotypes are missing.
If there are any missing data symbols within the genotype, it is
considered missing.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "genbinary")</code>: Prints
description of dataset and number of missing genotypes, then calls the
method for <code>gendata</code> to print additional information.</p>
</dd>
<dt>editGenotypes</dt><dd><p><code>signature(object = "genbinary")</code>: Opens the
genotype matrix in the Data Editor for editing.  Useful for making
minor changes, although allele columns cannot be added using this method.</p>
</dd>
<dt>viewGenotypes</dt><dd><p><code>signature(object = "genbinary")</code>: Prints the
genotype matrix to the console, one locus at a time.</p>
</dd>
<dt>deleteSamples</dt><dd><p><code>signature(object = "genbinary")</code>: Removes the
specified samples from the genotypes matrix, then calls the method for
<code>gendata</code>.</p>
</dd>
<dt>deleteLoci</dt><dd><p><code>signature(object = "genbinary")</code>: Removes the
specified loci from the genotypes matrix, then calls the method for
<code>gendata</code>.</p>
</dd>
<dt>&quot;[&quot;</dt><dd><p><code>signature(x = "genbinary", i = "ANY", j = "ANY")</code>:
Subscripting method.  Returns a <code>genbinary</code> object with a subset
of the samples and/or loci from <code>x</code>.  Usage:
<code>genobject[samples,loci]</code>.</p>
</dd>
<dt>estimatePloidy</dt><dd><p><code>signature(object = "genbinary")</code>: Creates a
data frame of mean and maximum number of alleles per sample, which is
then opened in the Data Editor so that the user can manually specify
the ploidy of each sample.  Ploidies are then written to the
<code>Ploidies</code> slot of the object.</p>
</dd>
<dt>merge</dt><dd><p><code>signature(x = "genbinary", y = "genbinary")</code>: Merges
two genotype objects together.  See
<code><a href="#topic+merge+2Cgenbinary+2Cgenbinary-method">merge,genbinary,genbinary-method</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gendata-class">gendata</a></code>, <code><a href="#topic+Samples">Accessors</a></code>,
<code><a href="#topic+genambig-class">genambig</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># show the class definition
showClass("genbinary")

# create a genbinary object
mygen &lt;- new("genbinary", samples = c("indA", "indB", "indC", "indD"),
             loci = c("loc1", "loc2"))
Description(mygen) &lt;- "Example genbinary object for the documentation."
Usatnts(mygen) &lt;- c(2,3)
PopNames(mygen) &lt;- c("Maine", "Indiana")
PopInfo(mygen) &lt;- c(1,1,2,2)
Genotypes(mygen) &lt;- matrix(c(1,1,0,0, 1,0,0,1, 0,0,1,1,
                             1,-9,1,0, 0,-9,0,1, 1,-9,0,1, 0,-9,1,1),
   nrow=4, ncol=7, dimnames = list(NULL,
   c("loc1.140", "loc1.144", "loc1.150",
     "loc2.97", "loc2.100", "loc2.106", "loc2.109")))

# view all of the data in the object
mygen
</code></pre>

<hr>
<h2 id='gendata-class'>Class &quot;gendata&quot;</h2><span id='topic+gendata-class'></span><span id='topic+deleteLoci+2Cgendata-method'></span><span id='topic+deleteSamples+2Cgendata-method'></span><span id='topic+Description+2Cgendata-method'></span><span id='topic+Description+3C-+2Cgendata-method'></span><span id='topic+initialize+2Cgendata-method'></span><span id='topic+Loci+2Cgendata+2Cmissing+2Cmissing-method'></span><span id='topic+Loci+2Cgendata+2Cnumeric+2Cmissing-method'></span><span id='topic+Loci+2Cgendata+2Cmissing+2Cnumeric-method'></span><span id='topic+Loci+2Cgendata+2Cnumeric+2Cnumeric-method'></span><span id='topic+Loci+3C-+2Cgendata-method'></span><span id='topic+Missing+2Cgendata-method'></span><span id='topic+Missing+3C-+2Cgendata-method'></span><span id='topic+Ploidies+2Cgendata-method'></span><span id='topic+Ploidies+3C-+2Cgendata-method'></span><span id='topic+PopInfo+2Cgendata-method'></span><span id='topic+PopInfo+3C-+2Cgendata-method'></span><span id='topic+PopNames+2Cgendata-method'></span><span id='topic+PopNames+3C-+2Cgendata-method'></span><span id='topic+PopNum+2Cgendata+2Ccharacter-method'></span><span id='topic+PopNum+3C-+2Cgendata+2Ccharacter-method'></span><span id='topic+Samples+2Cgendata+2Ccharacter+2Cmissing-method'></span><span id='topic+Samples+2Cgendata+2Ccharacter+2Cnumeric-method'></span><span id='topic+Samples+2Cgendata+2Cmissing+2Cmissing-method'></span><span id='topic+Samples+2Cgendata+2Cmissing+2Cnumeric-method'></span><span id='topic+Samples+2Cgendata+2Cnumeric+2Cmissing-method'></span><span id='topic+Samples+2Cgendata+2Cnumeric+2Cnumeric-method'></span><span id='topic+Samples+3C-+2Cgendata-method'></span><span id='topic+summary+2Cgendata-method'></span><span id='topic+Usatnts+2Cgendata-method'></span><span id='topic+Usatnts+3C-+2Cgendata-method'></span><span id='topic++5B+2Cgendata-method'></span>

<h3>Description</h3>

<p>This is a superclass for other classes that contain population
genetic datasets.  It has slots for population information, ploidy,
microsatellite repeat lengths, and a missing data symbol, but does not
have a slot to store genotypes.  Sample and locus names are stored as
the <code>names</code> of vectors in the slots.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("gendata", samples, loci, ...)</code>.
The missing data symbol will be set to <code>-9</code> by default.  The
default initial value for <code>PopNames</code> is a
character vector of length 0, and for <code>Description</code> is the string
<code>"Insert dataset description here"</code>.  The default initial value for
the <code>Ploidies</code> slot is a <code>"<a href="#topic+ploidymatrix-class">ploidymatrix</a>"</code>
object, containing a matrix filled with <code>NA</code> and named by samples
in the first dimension and loci in the second dimension.  For
other slots, vectors filled with <code>NA</code> will be generated and will be
named by samples (for <code>PopInfo</code>) or loci (for
<code>Usatnts</code>).  The slots can then be edited
using the methods described below.
</p>
<p>Note that in most cases you will want to instead create an
object from one of <code>gendata</code>'s subclasses, such as <code>genambig</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Description</code>:</dt><dd><p>Object of class <code>"character"</code>.  One
or more character strings to name or describe the dataset. </p>
</dd>
<dt><code>Missing</code>:</dt><dd><p>Object of class <code>"ANY"</code>.  A value to
indicate missing data in the genotypes of the dataset.  <code>-9</code>
by default. </p>
</dd>
<dt><code>Usatnts</code>:</dt><dd><p>Object of class <code>"integer"</code>.  This
vector must be named by locus names.  Each element should be the
length of the microsatellite repeat for that locus, given in nucleotides.
For example, <code>2</code> would indicate a locus with dinucleotide
repeats, and <code>3</code> would indicate a locus with trinucleotide
repeats.  <code>1</code> should be used for mononucleotide repeats OR if
alleles for that locus are already expressed in terms of repeat
number rather than nucleotides.  To put it another way, if you
divided the number used to represent an allele by the corresponding
number in <code>Usatnts</code> (and rounded if necessary), the result would
be the number of repeats (plus some additional length for flanking regions). </p>
</dd>
<dt><code>Ploidies</code>:</dt><dd><p>Object of class <code>"ploidysuper"</code>.  This
object will contain a <code>pld</code> slot that is a matrix named by
samples and loci, a vector named by samples or loci, or a single
value, depending on the subclass.  Each element is an integer that
represents ploidy.  <code>NA</code> indicates unknown ploidy. </p>
</dd>
<dt><code>PopInfo</code>:</dt><dd><p>Object of class <code>"integer"</code>.  This
vector also must be named by sample names.  Each element
represents the number of the population to which each sample belongs. </p>
</dd>
<dt><code>PopNames</code>:</dt><dd><p>Object of class <code>"character"</code>.  An
unnamed vector containing the name of each population.  If a
number from <code>PopInfo</code> is used to index <code>PopNames</code>, it
should find the correct population name.  For example, if the
first element of <code>PopNames</code> is <code>"ABC"</code>, then any samples
with <code>1</code> as their <code>PopInfo</code> value belong to population
<code>"ABC"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>deleteLoci</dt><dd><p><code>signature(object = "gendata")</code>: Permanently
remove loci from the dataset.  This removes elements from <code>Usatnts</code>. </p>
</dd>
<dt>deleteSamples</dt><dd><p><code>signature(object = "gendata")</code>:
Permanently remove samples from the dataset.  This removes
elements from <code>PopInfo</code> and <code>Ploidies</code>. </p>
</dd>
<dt>Description</dt><dd><p><code>signature(object = "gendata")</code>: Returns the
character vector in the <code>Description</code> slot.</p>
</dd>
<dt>Description&lt;-</dt><dd><p><code>signature(object = "gendata")</code>: Assigns a
new value to the character vector in the <code>Description</code> slot.</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "gendata")</code>: This is
called when the <code>new("gendata")</code> function is used.  A new
<code>gendata</code> object is created with sample and locus names used
to index the appropriate slots. </p>
</dd>
<dt>Loci</dt><dd><p><code>signature(object = "gendata", usatnts =
	"missing", ploidies="missing")</code>: Returns a character vector
containing all locus
names for the object.  The method accomplishes this by returning
<code>names(object@Usatnts)</code>. </p>
</dd>
<dt>Loci</dt><dd><p><code>signature(object = "gendata", usatnts =
	"numeric", ploidies = "missing")</code>: Returns a character vector
of all loci for a given
set of repeat lengths.  For example, if <code>usatnts = 2</code> all
loci with dinucleotide repeats will be returned.</p>
</dd>
<dt>Loci</dt><dd><p><code>signature(object= "gendata", usatnts = "missing",
    ploidies = "numeric")</code>: Returns a character vector of all loci for a
given set of ploidies. Only works if <code>object@Ploidies</code> is a
<code>"<a href="#topic+ploidylocus-class">ploidylocus</a>"</code> object.</p>
</dd>
<dt>Loci</dt><dd><p><code>signature(object = "gendata", usatnts = "numeric",
ploidies = "numeric")</code>: Returns a character vector of all loci that have
one of the indicated repeat types and one of the indicated ploidies.
Only works if <code>object@Ploidies</code> is a <code>"ploidylocus"</code> object.</p>
</dd>
<dt>Loci&lt;-</dt><dd><p><code>signature(object = "gendata")</code>: Assigns new
names to loci in the dataset (changes <code>names(object@Usants)</code>.
Should not be used for adding or removing loci.</p>
</dd>
<dt>Missing</dt><dd><p><code>signature(object = "gendata")</code>: Returns the
missing data symbol from <code>object@Missing</code>. </p>
</dd>
<dt>Missing&lt;-</dt><dd><p><code>signature(object = "gendata")</code>: Assigns a new
value to <code>object@Missing</code> (changes the missing data symbol).</p>
</dd>
<dt>Ploidies</dt><dd><p><code>signature(object = "gendata", samples = "ANY",
    loci = "ANY")</code>: Returns the
ploidies in the dataset (<code>object@Ploidies</code>), indexed by
sample and locus if applicable.. </p>
</dd>
<dt>Ploidies&lt;-</dt><dd><p><code>signature(object = "gendata")</code>: Assigns new
values to ploidies of samples in the dataset. The assigned values
are coerced to integers by the method.  Names in the assigned
vector or matrix are ignored; sample and/or locus names already
present in the <code>gendata</code> object are used instead.</p>
</dd>
<dt>PopInfo</dt><dd><p><code>signature(object = "gendata")</code>: Returns the
population numbers of samples in the dataset  (<code>object@PopInfo</code>). </p>
</dd>
<dt>PopInfo&lt;-</dt><dd><p><code>signature(object = "gendata")</code>: Assigns new
population numbers to samples in the dataset.  The assigned values
are coerced to integers by the method.  Names in the assigned
vector are ignored; sample names already present in the
<code>gendata</code> object are used instead. </p>
</dd>
<dt>PopNames</dt><dd><p><code>signature(object = "gendata")</code>: Returns a
character vector of population names (<code>object@PopNames</code>). </p>
</dd>
<dt>PopNames&lt;-</dt><dd><p><code>signature(object = "gendata")</code>: Assigns new
names to populations. </p>
</dd>
<dt>PopNum</dt><dd><p><code>signature(object = "gendata",
	popname="character")</code>: Returns the number corresponding to a
population name.</p>
</dd>
<dt>PopNum&lt;-</dt><dd><p><code>signature(object = "gendata", popname =
	"character")</code>: Changes the population number for a given
population name, merging it with an existing population of that
number if applicable.</p>
</dd>
<dt>Samples</dt><dd><p><code>signature(object = "gendata", populations =
	"character", ploidies = "missing")</code>: Returns all sample names
for a given set of population names. </p>
</dd>
<dt>Samples</dt><dd><p><code>signature(object = "gendata", populations =
	"character", ploidies = "numeric")</code>: Returns all sample names
for a given set of population names and ploidies.  Only samples
that fit both criteria will be returned. </p>
</dd>
<dt>Samples</dt><dd><p><code>signature(object = "gendata", populations =
	"missing", ploidies = "missing")</code>: Returns all sample names. </p>
</dd>
<dt>Samples</dt><dd><p><code>signature(object = "gendata", populations =
	"missing", ploidies = "numeric")</code>: Returns all sample names for
a given set of ploidies. Only works if <code>object@Ploidies</code> is a
<code>"<a href="#topic+ploidysample-class">ploidysample</a>"</code> object.</p>
</dd>
<dt>Samples</dt><dd><p><code>signature(object = "gendata", populations =
	"numeric", ploidies = "missing")</code>: Returns all sample names for
a given set of population numbers. </p>
</dd>
<dt>Samples</dt><dd><p><code>signature(object = "gendata", populations =
	"numeric", ploidies = "numeric")</code>: Returns all sample names for
a given set of population numbers and ploidies.  Only samples that
fit both criteria will be returned.  Only works if
<code>object@Ploidies</code> is a <code>"ploidysample"</code> object.</p>
</dd>
<dt>Samples&lt;-</dt><dd><p><code>signature(object = "gendata")</code>: Assigns new
names to samples.  This edits both <code>names(object@PopInfo)</code> and
<code>names(object@Ploidies)</code>.  It should not be used for adding
or removing samples from the dataset.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "gendata")</code>: Prints some
informaton to the console, including the numbers of samples, loci,
and populations, the ploidies present, and the types of
microsatellite repeats present.</p>
</dd>
<dt>Usatnts</dt><dd><p><code>signature(object = "gendata")</code>: Returns
microsatellite repeat lengths for loci in the dataset
(<code>object@Usatnts</code>). </p>
</dd>
<dt>Usatnts&lt;-</dt><dd><p><code>signature(object = "gendata")</code>: Assigns new
values to microsatellite repeat lengths of loci
(<code>object@Usatnts</code>).  The assigned values
are coerced to integers by the method.  Names in the assigned
vector are ignored; locus names already present in the
<code>gendata</code> object are used instead. </p>
</dd>
<dt>&quot;[&quot;</dt><dd><p><code>signature(x = "gendata", i = "ANY", j = "ANY")</code>:
Subscripts the data by a subset of samples and/or loci.  Should be
used in the format <code>mygendata[mysamples, myloci]</code>.  Returns a
<code>gendata</code> object with <code>PopInfo</code>, <code>Ploidies</code>, and
<code>Usatnts</code> truncated to only contain the samples and loci
listed in <code>i</code> and <code>j</code>, respectively.
<code>Description</code>, <code>Missing</code>, and <code>PopNames</code> are left
unaltered.</p>
</dd>
<dt>merge</dt><dd><p><code>signature(x = "gendata", y = "gendata")</code>: Merges
two genotype objects.  See <code><a href="#topic+merge+2Cgendata+2Cgendata-method">merge,gendata,gendata-method</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genambig-class">genambig</a></code>, <code><a href="#topic+genbinary-class">genbinary</a></code>,
<code><a href="#topic+Samples">Accessors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># show class definition
showClass("gendata")

# create an object of the class gendata
# (in reality you would want to create an object belonging to one of the
# subclasses, but the procedure is the same)
mygen &lt;- new("gendata", samples = c("a", "b", "c"),
             loci = c("loc1", "loc2"))
Description(mygen) &lt;- "An example for the documentation"
Usatnts(mygen) &lt;- c(2,3)
PopNames(mygen) &lt;- c("PopV", "PopX")
PopInfo(mygen) &lt;- c(2,1,2)
Ploidies(mygen) &lt;- c(2,2,4,2,2,2)

# view a summary of the object
summary(mygen)
</code></pre>

<hr>
<h2 id='gendata.to.genind'>
Convert Data to genind Format
</h2><span id='topic+gendata.to.genind'></span>

<h3>Description</h3>

<p>This is a function for exporting data to the package <span class="pkg">adegenet</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendata.to.genind(object, samples = Samples(object), loci = Loci(object))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gendata.to.genind_+3A_object">object</code></td>
<td>

<p>A <code>"genambig"</code> or (preferably) a <code>"genbinary"</code> object.  
</p>
</td></tr>
<tr><td><code id="gendata.to.genind_+3A_samples">samples</code></td>
<td>

<p>A character vector indicating the samples to include in the output.
</p>
</td></tr>
<tr><td><code id="gendata.to.genind_+3A_loci">loci</code></td>
<td>

<p>A character vector indicating the loci to include in the output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gendata.to.genind</code> converts a <code>"genambig"</code> or
<code>"genbinary"</code> object to a <code>"genind"</code> object using the package
<span class="pkg">adegenet</span>.  Each individual must have a single ploidy.  
Ploidy and population information are carried over to the new
object.  Data will be coded as presence/absence in the new object.  The
locus names in the new object are locus and allele names
seperated by a hyphen.
</p>
<p><span class="pkg">adegenet</span> must be installed in order to use this function.
</p>


<h3>Value</h3>

<p>A genetic dataset in the <code>"genind"</code> class, ready for use in
<span class="pkg">adegenet</span>. 
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><a href="http://adegenet.r-forge.r-project.org/">http://adegenet.r-forge.r-project.org/</a>
</p>
<p>Jombart, T.  (2008)  adegenet: a R package for the multivariate analysis
of genetic markers.  <em>Bioinformatics</em> <b>24</b>, 1403&ndash;1405.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+freq.to.genpop">freq.to.genpop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a "genambig" object
mydata &lt;- new("genambig", samples=c("a","b","c","d"), loci=c("e","f"))
PopNames(mydata) &lt;- c("G","H")
PopInfo(mydata) &lt;- c(1,1,2,2)
mydata &lt;- reformatPloidies(mydata, output="one")
Ploidies(mydata) &lt;- 3
Genotypes(mydata, loci="e") &lt;- list(c(100),c(100,102),
                                    c(98,102,104),c(102,106))
Genotypes(mydata, loci="f") &lt;- list(c(200,202,204),Missing(mydata),
                                    c(210,212),c(204,210,214))

# convert to "genind"; not tested as it takes several seconds to load adegenet

if(require("adegenet")){
  mydata2 &lt;- gendata.to.genind(mydata)
  mydata2@tab
  locNames(mydata2)
  indNames(mydata2)
  popNames(mydata2)
  pop(mydata2)
}

</code></pre>

<hr>
<h2 id='genIndex'>
Find All Unique Genotypes for a Locus
</h2><span id='topic+genIndex'></span><span id='topic+genIndex+2Cgenambig-method'></span><span id='topic+genIndex+2Carray-method'></span>

<h3>Description</h3>

<p>This function will return all unique genotypes for a given locus (ignoring allele
order, but taking copy number into account) and return those genotypes as well 
as an index indicating which genotype(s) each individual has.  This is a generic function
with methods for <code>"<a href="#topic+genambig-class">genambig</a>"</code> objects and for arrays.  The array 
method is primarily intended for internal use with <code><a href="#topic+meandistance.matrix2">meandistance.matrix2</a></code>,
processing the output of <code><a href="#topic+genotypeProbs">genotypeProbs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genIndex(object, locus)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genIndex_+3A_object">object</code></td>
<td>

<p>Typically, a <code>"genambig"</code> object.  A two-dimentional list (array) can also be
used here, where samples are in the first dimension and loci in the second dimension
and each element of the list is output from <code>genotypeProbs</code>.
</p>
</td></tr>
<tr><td><code id="genIndex_+3A_locus">locus</code></td>
<td>

<p>A character string or integer indicating which locus to process.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table role = "presentation">
<tr><td><code>uniquegen</code></td>
<td>
<p>A list, where each element in the list is a vector indicating a
unique genotype that was found.</p>
</td></tr>
<tr><td><code>genindex</code></td>
<td>
<p>For <code>"genambig"</code> objects, an integer vector, with one value per sample.
This is the index of that sample's genotype in <code>uniquegen</code>.  For arrays, a list with
one element per sample.  Each element is a vector of indices of that sample's possible 
genotypes in <code>uniquegen</code>, in the same order as in the <code>genotypeProbs</code> output.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meandistance.matrix">meandistance.matrix</a></code> uses the <code>"genambig"</code> method internally.
</p>
<p><code><a href="#topic+.unal1loc">.unal1loc</a></code>, <code><a href="#topic+assignClones">assignClones</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simgen)
genIndex(simgen, 1)
</code></pre>

<hr>
<h2 id='genotypeDiversity'>
Genotype Diversity Statistics
</h2><span id='topic+genotypeDiversity'></span><span id='topic+Shannon'></span><span id='topic+Simpson'></span><span id='topic+Simpson.var'></span>

<h3>Description</h3>

<p><code>genotypeDiversity</code> calculates diversity statistics based on
genotype frequencies, using a distance matrix to assign individuals to
genotypes.  The <code>Shannon</code> and <code>Simpson</code> functions are also
available to calculate these statistics directly from a vector
of frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genotypeDiversity(genobject, samples = Samples(genobject),
                  loci = Loci(genobject),
                  d = meandistance.matrix(genobject, samples, loci,
                                          all.distances = TRUE,
                                          distmetric = Lynch.distance),
                  threshold = 0, index = Shannon, ...)

Shannon(p, base = exp(1))

Simpson(p)

Simpson.var(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genotypeDiversity_+3A_genobject">genobject</code></td>
<td>

<p>An object of the class <code>"genambig"</code> (or more generally,
<code>"gendata"</code> if a value is supplied to <code>d</code>).  If there is more
than one population, the <code>PopInfo</code> slot should be filled in.
<code>genobject</code>
is the dataset to be analyzed, although the genotypes themselves will
not be used if <code>d</code> has already been calculated.  Missing genotypes,
however, will indicate individuals that should be skipped in the analysis.
</p>
</td></tr>
<tr><td><code id="genotypeDiversity_+3A_samples">samples</code></td>
<td>

<p>An optional character vector indicating a subset of samples to analyze.
</p>
</td></tr>
<tr><td><code id="genotypeDiversity_+3A_loci">loci</code></td>
<td>

<p>An optional character vector indicating a subset of loci to analyze.
</p>
</td></tr>
<tr><td><code id="genotypeDiversity_+3A_d">d</code></td>
<td>

<p>A list such as that produced by <code><a href="#topic+meandistance.matrix">meandistance.matrix</a></code> or
<code><a href="#topic+meandistance.matrix2">meandistance.matrix2</a></code> when <code>all.distances = TRUE</code>.  The
first item in the list is a three dimensional array, with the first
dimension indexed by locus and the second and third dimensions indexed
by sample.  These are genetic distances between samples, by locus.  The
second item in the list is the distance matrix averaged across loci.
This mean matrix will be used only if all loci are being analyzed.  If
<code>loci</code> is a subset of the loci found in <code>d</code>, the mean matrix
will be recalculated.
</p>
</td></tr>
<tr><td><code id="genotypeDiversity_+3A_threshold">threshold</code></td>
<td>

<p>The maximum genetic distance between two samples that can be considered
to be the same genotype.
</p>
</td></tr>
<tr><td><code id="genotypeDiversity_+3A_index">index</code></td>
<td>

<p>The diversity index to calculate.  This should be <code>Shannon</code>,
<code>Simpson</code>, or a user-defined function that takes as its first
argument a vector of frequencies that sum to one.
</p>
</td></tr>
<tr><td><code id="genotypeDiversity_+3A_...">...</code></td>
<td>

<p>Additional arguments to pass to <code>index</code>, for example the
<code>base</code> argument for <code>Shannon</code>.
</p>
</td></tr>
<tr><td><code id="genotypeDiversity_+3A_p">p</code></td>
<td>
<p>A vector of counts.</p>
</td></tr>
<tr><td><code id="genotypeDiversity_+3A_base">base</code></td>
<td>

<p>The base of the logarithm for calculating the Shannon index.  This is
<code>exp(1)</code> for the natural log, or <code>2</code> for log base 2.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>genotypeDiversity</code> runs <code><a href="#topic+assignClones">assignClones</a></code> on distance
matrices for individual loci and then for all loci, for each seperate
population.  The results of <code>assignClones</code> are used to
calculate a vector of genotype frequencies, which is passed to
<code>index</code>.
</p>
<p><code>Shannon</code> calculates the Shannon index, which is:
</p>
<p style="text-align: center;"><code class="reqn">-\sum \frac{p_i}{N}\ln(\frac{p_i}{N})</code>
</p>

<p>(or log base 2 or any other base, using the <code>base</code> argument) given
a vector <code class="reqn">p</code> of genotype counts, where <code class="reqn">N</code> is the sum of those counts.
</p>
<p><code>Simpson</code> calculates the Simpson index, which is:
</p>
<p style="text-align: center;"><code class="reqn">\sum \frac{p_{i}(p_{i} - 1)}{N(N - 1)}</code>
</p>

<p><code>Simpson.var</code> calculates the variance of the Simpson index:
</p>
<p style="text-align: center;"><code class="reqn">\frac{4N(N-1)(N-2)\sum p_{i}^3 + 2N(N-1)\sum p_{i}^2 -
    2N(N-1)(2N-3)(\sum p_{i}^2)^2}{[N(N-1)]^2}</code>
</p>

<p>The variance of the Simpson index can be used to calculate a confidence
interval, for example the results of <code>Simpson</code> plus or minus twice
the square root of the results of <code>Simpson.var</code> would be the 95%
confidence interval.
</p>


<h3>Value</h3>

<p>A matrix of diversity index results, with populations in rows and
loci in columns.  The final column is called <code>"overall"</code> and gives
the results when all loci are analyzed together.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Shannon, C. E. (1948) A mathematical theory of communication.
<em>Bell System Technical Journal</em> <b>27</b>:379&ndash;423 and 623&ndash;656.
</p>
<p>Simpson, E. H. (1949) Measurement of diversity.  <em>Nature</em>
<b>163</b>:688.
</p>
<p>Lowe, A., Harris, S. and Ashton, P. (2004) <em>Ecological Genetics:
Design, Analysis, and Application</em>.  Wiley-Blackwell.
</p>
<p>Arnaud-Haond, S., Duarte, M., Alberto, F. and Serrao, E. A.  (2007)
Standardizing methods to address clonality in population studies.
<em>Molecular Ecology</em> <b>16</b>:5115&ndash;5139.
</p>
<p><a href="http://www.comparingpartitions.info/index.php?link=Tut4">http://www.comparingpartitions.info/index.php?link=Tut4</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assignClones">assignClones</a></code>, <code><a href="#topic+alleleDiversity">alleleDiversity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up dataset
mydata &lt;- new("genambig", samples=c("a","b","c"), loci=c("F","G"))
Genotypes(mydata, loci="F") &lt;- list(c(115,118,124),c(115,118,124),
                                   c(121,124))
Genotypes(mydata, loci="G") &lt;- list(c(162,170,174),c(170,172),
                                    c(166,180,182))
Usatnts(mydata) &lt;- c(3,2)

# get genetic distances
mydist &lt;- meandistance.matrix(mydata, all.distances=TRUE)

# calculate diversity under various conditions
genotypeDiversity(mydata, d=mydist)
genotypeDiversity(mydata, d=mydist, base=2)
genotypeDiversity(mydata, d=mydist, threshold=0.3)
genotypeDiversity(mydata, d=mydist, index=Simpson)
genotypeDiversity(mydata, d=mydist, index=Simpson.var)
</code></pre>

<hr>
<h2 id='genotypeProbs'>
Calculate Probabilities of Unambiguous Genotypes
</h2><span id='topic+genotypeProbs'></span>

<h3>Description</h3>

<p>Given an ambiguous genotype and either a data frame of allele
frequencies or a vector of genotype probabilities,
<code>genotypeProbs</code> calculates all possible unambiguous genotypes and
their probabilities of being the true genotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genotypeProbs(object, sample, locus, freq = NULL, gprob = NULL,
              alleles = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genotypeProbs_+3A_object">object</code></td>
<td>

<p>An object of class <code>"genambig"</code>.  The <code>Ploidies</code> and
<code>PopInfo</code> slots must be filled in for the sample and locus of interest.
</p>
</td></tr>
<tr><td><code id="genotypeProbs_+3A_sample">sample</code></td>
<td>

<p>Number or character string indicating the sample to evaluate.
</p>
</td></tr>
<tr><td><code id="genotypeProbs_+3A_locus">locus</code></td>
<td>

<p>Character string indicating the locus to evaluate.
</p>
</td></tr>
<tr><td><code id="genotypeProbs_+3A_freq">freq</code></td>
<td>

<p>A data frame of allele frequencies, such as that produced by
<code><a href="#topic+simpleFreq">simpleFreq</a></code> or <code><a href="#topic+deSilvaFreq">deSilvaFreq</a></code>.  This argument
should only be provided if the selfing rate is zero.
</p>
</td></tr>
<tr><td><code id="genotypeProbs_+3A_gprob">gprob</code></td>
<td>

<p>A vector of genotype probabilities based on allele frequencies and
selfing rate.  This is generated by <code><a href="#topic+meandistance.matrix2">meandistance.matrix2</a></code> and
passed to <code>genotypeProbs</code> only if the selfing rate is greater
than zero.
</p>
</td></tr>
<tr><td><code id="genotypeProbs_+3A_alleles">alleles</code></td>
<td>

<p>An integer vector of all alleles.  This argument should only be used
if <code>gprob</code> is also being used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily designed to be called by
<code>meandistance.matrix2</code>, in order to calculate distances between all
possible unambiguous genotypes.  Ordinary users won't use
<code>genotypeProbs</code> unless they are designing a new analysis.
</p>
<p>The genotype analyzed is <code>Genotype(object, sample, locus)</code>.  If
the genotype is unambiguous (fully heterozygous or homozygous), a single
unambiguous genotype is returned with a probability of one.
</p>
<p>If the genotype is ambiguous (partially heterozygous), a recursive
algorithm is used to generate all possible unambiguous genotypes (all
possible duplications of alleles in the genotype, up to the ploidy of
the individual.)
</p>
<p><b>If the <code>freq</code> argument is supplied:</b>
</p>
<p>The probability of each unambiguous genotype is then calculated from
the allele frequencies of the individual's population, under the
assumption of random mating.  Allele frequencies are normalized so that
the frequencies of the alleles in the ambiguous genotype sum to one;
this converts
each frequency to the probability of the allele being present in more
than one copy.  The product of these probabilities is multiplied by the
appropriate polynomial coefficient to calculate the probability of the
unambiguous genotype.
</p>
<p style="text-align: center;"><code class="reqn">p = \prod_{i=1}^n f_{i}^{c_i} * \frac{(k-n)!}{\prod_{i=1}^n c_i!}</code>
</p>

<p>where <em>p</em> is the probability of the unambiguous genotype, <em>n</em>
is the number
of alleles in the ambiguous genotype, <em>f</em> is the normalized frequency of
each allele, <em>c</em> is the number of duplicated copies (total number of
copies minus one) of the allele in the unambiguous genotype, and <em>k</em> is
the ploidy of the individual.
</p>
<p><b>If the <code>gprob</code> and <code>alleles</code> arguments are supplied:</b>
</p>
<p>The probabilities of all possible genotypes in the population have
already been calculated, based on allele frequencies and selfing rate.
This is done in <code>meandistance.matrix2</code> using code from De Silva
<em>et al.</em> (2005).
Probabilities for the genotypes of interest (those that the ambiguous
genotype could represent) are normalized to sum to 1, in order to give
the conditional probabilities of the possible genotypes.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>probs</code></td>
<td>
<p>A vector containing the probabilities of each unambiguous
genotype.</p>
</td></tr>
<tr><td><code>genotypes</code></td>
<td>
<p>A matrix.  Each row represents one genotype, and the
number of columns is equal to the ploidy of the individual.  Each
element of the matrix is an allele.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>De Silva, H. N., Hall, A. J., Rikkerink, E., and Fraser, L. G. (2005)
Estimation of allele frequencies in polyploids under
certain patterns of inheritance.  <em>Heredity</em> <b>95</b>, 327&ndash;334
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meandistance.matrix2">meandistance.matrix2</a></code>,
<code><a href="#topic+GENLIST">GENLIST</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a data set and define ploidies
data(testgenotypes)
Ploidies(testgenotypes) &lt;- c(8,8,8,4,8,8,rep(4,14))
# get allele frequencies
tfreq &lt;- simpleFreq(testgenotypes)

# see results of genotypeProbs under different circumstances
Genotype(testgenotypes, "FCR7", "RhCBA15")
genotypeProbs(testgenotypes, "FCR7", "RhCBA15", tfreq)
Genotype(testgenotypes, "FCR10", "RhCBA15")
genotypeProbs(testgenotypes, "FCR10", "RhCBA15", tfreq)
Genotype(testgenotypes, "FCR1", "RhCBA15")
genotypeProbs(testgenotypes, "FCR1", "RhCBA15", tfreq)
Genotype(testgenotypes, "FCR2", "RhCBA23")
genotypeProbs(testgenotypes, "FCR2", "RhCBA23", tfreq)
Genotype(testgenotypes, "FCR3", "RhCBA23")
genotypeProbs(testgenotypes, "FCR3", "RhCBA23", tfreq)

</code></pre>

<hr>
<h2 id='Internal+20Functions'>Internal Functions in polysat</h2><span id='topic+G'></span><span id='topic+INDEXG'></span><span id='topic+GENLIST'></span><span id='topic+RANMUL'></span><span id='topic+SELFMAT'></span><span id='topic+.unal1loc'></span><span id='topic+fixloci'></span>

<h3>Description</h3>

<p>The internal functions <code>G</code>, <code>INDEXG</code>, <code>GENLIST</code>,
<code>RANMUL</code>, and <code>SELFMAT</code>
are used for calculating
genotype probabilities under partial selfing.  The internal function
<code>.unal1loc</code> finds all unique alleles at a single locus.  The internal
function <code>fixloci</code> converts locus names to a format that will be
compatible as column headers for allele frequency tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G(q, n)
INDEXG(ag1, na1, m2)
GENLIST(ng, na1, m2)
RANMUL(ng, na1, ag, m2)
SELFMAT(ng, na1, ag, m2)
.unal1loc(object, samples, locus)
fixloci(loci, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Internal+2B20Functions_+3A_q">q</code></td>
<td>
<p>Integer.</p>
</td></tr>
<tr><td><code id="Internal+2B20Functions_+3A_n">n</code></td>
<td>
<p>Integer.</p>
</td></tr>
<tr><td><code id="Internal+2B20Functions_+3A_ag1">ag1</code></td>
<td>
<p>A vector representing an unambiguous genotype.</p>
</td></tr>
<tr><td><code id="Internal+2B20Functions_+3A_na1">na1</code></td>
<td>
<p>Integer. The number of alleles, including a null.</p>
</td></tr>
<tr><td><code id="Internal+2B20Functions_+3A_m2">m2</code></td>
<td>
<p>Integer.  The ploidy.</p>
</td></tr>
<tr><td><code id="Internal+2B20Functions_+3A_ng">ng</code></td>
<td>
<p>Integer.  The number of genotypes.</p>
</td></tr>
<tr><td><code id="Internal+2B20Functions_+3A_ag">ag</code></td>
<td>
<p>An array of genotypes such as that produced by
<code>.genlist</code>.</p>
</td></tr>
<tr><td><code id="Internal+2B20Functions_+3A_object">object</code></td>
<td>
<p>A <code>"genambig"</code> object.</p>
</td></tr>
<tr><td><code id="Internal+2B20Functions_+3A_samples">samples</code></td>
<td>
<p>Optional, a numeric or character vector indicating
which samples to use.</p>
</td></tr>
<tr><td><code id="Internal+2B20Functions_+3A_locus">locus</code></td>
<td>
<p>A character string or number indicating which locus to
use.</p>
</td></tr>
<tr><td><code id="Internal+2B20Functions_+3A_loci">loci</code></td>
<td>
<p>A character vector of locus names.</p>
</td></tr>
<tr><td><code id="Internal+2B20Functions_+3A_warn">warn</code></td>
<td>
<p>Boolean indicating whether a warning should be issued if 
locus names are changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>G</code> returns
</p>
<p style="text-align: center;"><code class="reqn">\frac{(n+q)!}{(q+1)! * (n-1)!}</code>
</p>

<p><code>INDEXG</code> returns an integer indicating the row containing a
particular genotype in the matrix produced by <code>GENLIST</code>.
</p>
<p><code>GENLIST</code> returns an array with dimensions <code>ng, m2</code>,
containing all possible unambiguous genotypes, one in each row.  The null
allele is the highest-numbered allele.
</p>
<p><code>RANMUL</code> returns a list.  The first item is a vector of
polynomial coefficients for calculating genotype frequencies under
random mating.  The second is an array
showing how many copies of each allele each genotype has.
</p>
<p><code>SELFMAT</code> returns the selfing matrix.  Parental genotypes are
represented in rows, and offspring genotypes in columns.  The numbers
indicate relative amounts of offspring genotypes produced when the
parental genotypes are self-fertilized.
</p>
<p><code>.unal1loc</code> returns a vector containing all unique alleles, not
including <code>Missing(object)</code>.
</p>
<p><code>fixloci</code> returns a character vector of corrected locus names.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark</p>


<h3>References</h3>

<p>De Silva, H. N., Hall, A. J., Rikkerink, E., and Fraser, L. G. (2005)
Estimation of allele frequencies in polyploids under
certain patterns of inheritance.  <em>Heredity</em> <b>95</b>, 327&ndash;334
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deSilvaFreq">deSilvaFreq</a></code>, <code><a href="#topic+meandistance.matrix2">meandistance.matrix2</a></code>,
<code><a href="#topic+genotypeProbs">genotypeProbs</a></code>, <code><a href="#topic+genambig.to.genbinary">genambig.to.genbinary</a></code>,
<code><a href="#topic+alleleDiversity">alleleDiversity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculation of genotype probabilities in a tetraploid with four
# alleles plus a null, and a selfing rate of 0.5.  This is a translation
# of code in the supplementary material of De Silva et al. (2005).
m2 &lt;- 4
m &lt;- m2/2
na1 &lt;- 5
self &lt;- 0.5
ng &lt;- na1
for(j in 2:m2){
    ng &lt;- ng*(na1+j-1)/j
}
ag &lt;- polysat:::GENLIST(ng, na1, m2)
temp &lt;- polysat:::RANMUL(ng, na1, ag, m2)
rmul &lt;- temp[[1]]
arep &lt;- temp[[2]]
rm(temp)
smat &lt;- polysat:::SELFMAT(ng, na1, ag, m2)
smatdiv &lt;- (polysat:::G(m-1,m+1))^2
p1 &lt;- c(0.1, 0.4, 0.2, 0.2, 0.1) # allele frequencies

# GPROBS subroutine
rvec &lt;- rep(0,ng)
for(g in 1:ng){
    rvec[g] &lt;- rmul[g]
    for(j in 1:m2){
        rvec[g] &lt;- rvec[g]*p1[ag[g,j]]
    }
}
id &lt;- diag(nrow=ng)
smatt &lt;- smat/smatdiv
s3 &lt;- id - self * smatt
s3inv &lt;- solve(s3)
gprob &lt;- (1-self) * s3inv %*% rvec
# gprob is a vector of probabilities of the seventy genotypes.
</code></pre>

<hr>
<h2 id='isMissing'>
Determine Whether Genotypes Are Missing
</h2><span id='topic+isMissing'></span>

<h3>Description</h3>

<p><code>isMissing</code> returns Boolean values indicating whether the genotypes
for a given set of samples and loci are missing from the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isMissing(object, samples = Samples(object), loci = Loci(object))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isMissing_+3A_object">object</code></td>
<td>

<p>An object of one of the subclasses of <code>gendata</code>, containing the
genotypes to be tested.
</p>
</td></tr>
<tr><td><code id="isMissing_+3A_samples">samples</code></td>
<td>

<p>A character or numeric vector indicating samples to be tested.
</p>
</td></tr>
<tr><td><code id="isMissing_+3A_loci">loci</code></td>
<td>

<p>A character or numeric vector indicating loci to be tested.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>isMissing</code> is a generic function with methods for <code>genambig</code>
and <code>genbinary</code> objects.
</p>
<p>For each genotype in a <code>genambig</code> object, the function evaluates and returns
<code>Genotype(object, sample, locus)[1] == Missing(object)</code>.  For a
<code>genbinary</code> object, <code>TRUE %in% (Genotype(object, sample,
  locus) == Missing(object))</code> is returned for the genotype.  If only
one sample and locus are being evaluated, this is the Boolean value that
is returned.  If multiple samples and/or loci are being evaluated, the
function creates an array of Boolean values and recursively calls itself
to fill in the result for each element of the array.
</p>


<h3>Value</h3>

<p>If both <code>samples</code> and <code>loci</code> are of length 1, a single
Boolean value is returned, <code>TRUE</code> if the genotype is missing, and
<code>FALSE</code> if it isn't.  Otherwise, the function returns a named
array with samples in the first dimension and loci in the second
dimension, filled with Boolean values indicating whether the genotype
for each sample*locus combination is missing.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Missing">Missing</a></code>, <code><a href="#topic+Missing+3C-">Missing&lt;-</a></code>, <code><a href="#topic+Genotype">Genotype</a></code>, 
<code><a href="#topic+find.missing.gen">find.missing.gen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up a genambig object for this example
mygen &lt;- new("genambig", samples=c("a", "b"), loci=c("locD", "locE"))
Genotypes(mygen) &lt;- array(list(c(122, 126), c(124, 128, 134),
                               Missing(mygen), c(156, 159)),
                          dim=c(2,2))
viewGenotypes(mygen)

# test if some individual genotypes are missing
isMissing(mygen, "a", "locD")
isMissing(mygen, "a", "locE")

# test an array of genotypes
isMissing(mygen, Samples(mygen), Loci(mygen))

</code></pre>

<hr>
<h2 id='Lynch.distance'>
Calculate Band-Sharing Dissimilarity Between Genotypes
</h2><span id='topic+Lynch.distance'></span>

<h3>Description</h3>

<p>Given two genotypes in the form of vectors of unique alleles, a
dissimilarity is calculated as:
1 - (number of alleles in common)/(average number of alleles per genotype).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lynch.distance(genotype1, genotype2, usatnt = NA, missing = -9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lynch.distance_+3A_genotype1">genotype1</code></td>
<td>

<p>A vector containing all alleles for a particular sample and locus.
Each allele is only present once in the vector.
</p>
</td></tr>
<tr><td><code id="Lynch.distance_+3A_genotype2">genotype2</code></td>
<td>

<p>A vector of the same form as <code>genotype1</code>, for another sample at the
same locus.
</p>
</td></tr>
<tr><td><code id="Lynch.distance_+3A_usatnt">usatnt</code></td>
<td>

<p>The microsatellite repeat length for this locus (ignored by the function).
</p>
</td></tr>
<tr><td><code id="Lynch.distance_+3A_missing">missing</code></td>
<td>

<p>The symbol used to indicate missing data in either genotype vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lynch (1990) defines a simple measure of similarity between DNA
fingerprints.  This is 2 times the number of bands that two fingerprints
have in common, divided by the total number of bands that the two genotypes
have.  <code>Lynch.distance</code> returns a dissimilarity, which is 1 minus
the similarity.
</p>


<h3>Value</h3>

<p>If the first element of either or both input genotypes is equal to
<code>missing</code>, NA is returned.
</p>
<p>Otherwise, a numerical value is returned.  This is one minus the
similarity.  The similarity is calculated as the number of alleles that
the two genotypes have in common divided by the mean length of the two
genotypes.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Lynch, M.  (1990)  The similarity index and DNA fingerprinting.
<em>Molecular Biology and Evolution</em> <b>7</b>, 478-484.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bruvo.distance">Bruvo.distance</a></code>,
<code><a href="#topic+meandistance.matrix">meandistance.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Lynch.distance(c(100,102,104), c(100,104,108))
Lynch.distance(-9, c(102,104,110))
Lynch.distance(c(100), c(100,104,106))
</code></pre>

<hr>
<h2 id='meandist.from.array'>
Tools for Working With Pairwise Distance Arrays
</h2><span id='topic+meandist.from.array'></span><span id='topic+find.na.dist'></span><span id='topic+find.na.dist.not.missing'></span>

<h3>Description</h3>

<p><code>meandist.from.array</code> produces a mean distance matrix from an array of
pairwise distances by locus, such as that produced by
<code>meandistance.matrix</code> when <code>all.distances=TRUE</code>.  <code>find.na.dist</code>
finds missing distances in such an array, and
<code>find.na.dist.not.missing</code> finds missing distances that aren't the
result of missing genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meandist.from.array(distarray, samples = dimnames(distarray)[[2]],
loci = dimnames(distarray)[[1]])

find.na.dist(distarray, samples = dimnames(distarray)[[2]],
loci = dimnames(distarray)[[1]])

find.na.dist.not.missing(object, distarray,
samples = dimnames(distarray)[[2]], loci = dimnames(distarray)[[1]])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meandist.from.array_+3A_distarray">distarray</code></td>
<td>

<p>A three-dimensional array of pairwise distances between samples, by
locus.  Loci are represented in the first dimension, and samples are
represented in the second and third dimensions.  Dimensions are named
accordingly.  Such an array is the first element of the list produced by
<code>meandistance.matrix</code> if <code>all.distances=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="meandist.from.array_+3A_samples">samples</code></td>
<td>

<p>Character vector.  Samples to analyze.
</p>
</td></tr>
<tr><td><code id="meandist.from.array_+3A_loci">loci</code></td>
<td>

<p>Character vector.  Loci to analyze.
</p>
</td></tr>
<tr><td><code id="meandist.from.array_+3A_object">object</code></td>
<td>

<p>A <code>genambig</code> object.  Typically the
genotype object that was used to produce <code>distarray</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>find.na.dist.not.missing</code> is primarily intended to locate distances
that were not calculated by <code>Bruvo.distance</code> because both genotypes
had too many alleles (more than <code>maxl</code>).  The user may wish to
estimate these distances manually and fill them into the array, then
recalculate the mean matrix using <code>meandist.from.array</code>.
</p>


<h3>Value</h3>

<p><code>meandist.from.array</code> returns a matrix, with both rows and columns
named by samples, of distances averaged across loci.
</p>
<p><code>find.na.dist</code> and <code>find.na.dist.not.missing</code> both return data
frames with three columns: Locus, Sample1, and Sample2.  Each row
represents the index in the array of an element containing NA.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meandistance.matrix">meandistance.matrix</a></code>, <code><a href="#topic+Bruvo.distance">Bruvo.distance</a></code>,
<code><a href="#topic+find.missing.gen">find.missing.gen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up the genotype data
samples &lt;- paste("ind", 1:4, sep="")
samples
loci &lt;- paste("loc", 1:3, sep="")
loci
testgen &lt;- new("genambig", samples=samples, loci=loci)
Genotypes(testgen, loci="loc1") &lt;- list(c(-9), c(102,104),
                                        c(100,106,108,110,114),
                                        c(102,104,106,110,112))
Genotypes(testgen, loci="loc2") &lt;- list(c(77,79,83), c(79,85), c(-9),
                                        c(83,85,87,91))
Genotypes(testgen, loci="loc3") &lt;- list(c(122,128), c(124,126,128,132),
                                        c(120,126), c(124,128,130))
Usatnts(testgen) &lt;- c(2,2,2)

# look up which samples*loci have missing genotypes
find.missing.gen(testgen)

# get the three-dimensional distance array and the mean of the array
gendist &lt;- meandistance.matrix(testgen, distmetric=Bruvo.distance,
                                maxl=4, all.distances=TRUE)
# look at the distances for loc1, where there is missing data and long genotypes
gendist[[1]]["loc1",,]

# look up all missing distances in the array
find.na.dist(gendist[[1]])

# look up just the missing distances that don't result from missing genotypes
find.na.dist.not.missing(testgen, gendist[[1]])

# Copy the array to edit the new copy
newDistArray &lt;- gendist[[1]]
# calculate the distances that were NA from genotype lengths exceeding maxl
# (in reality, if this were too computationally intensive you might estimate
# it manually instead)
subDist &lt;- Bruvo.distance(c(100,106,108,110,114), c(102,104,106,110,112))
subDist
# insert this distance into the correct positions
newDistArray["loc1","ind3","ind4"] &lt;- subDist
newDistArray["loc1","ind4","ind3"] &lt;- subDist
# calculate the new mean distance matrix
newMeanMatrix &lt;- meandist.from.array(newDistArray)
# look at the difference between this matrix and the original.
newMeanMatrix
gendist[[2]]
</code></pre>

<hr>
<h2 id='meandistance.matrix'>Mean Pairwise Distance Matrix</h2><span id='topic+meandistance.matrix'></span><span id='topic+meandistance.matrix2'></span>

<h3>Description</h3>

<p>Given a <code>genambig</code> object, <code>meandistance.matrix</code>
produces a symmetrical matrix of
pairwise distances between samples, averaged across all loci.  An
array of all distances prior to averaging may also be produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meandistance.matrix(object, samples = Samples(object),
                    loci = Loci(object), all.distances=FALSE,
                    distmetric = Bruvo.distance, progress = TRUE,
                    ...)
meandistance.matrix2(object, samples = Samples(object),
                     loci = Loci(object),
                     freq = simpleFreq(object, samples, loci), self = 0,
                     all.distances = FALSE, distmetric = Bruvo.distance,
                     progress = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meandistance.matrix_+3A_object">object</code></td>
<td>
<p>A <code>genambig</code> object containing the genotypes to be
analyzed.  If <code>distmetric = Bruvo.distance</code>, the <code>Usatnts</code>
slot should be filled in.  For <code>meandistance.matrix2</code>,
<code>Ploidies</code> and <code>PopInfo</code> are also required.</p>
</td></tr>
<tr><td><code id="meandistance.matrix_+3A_samples">samples</code></td>
<td>
<p>A character vector of samples to be analyzed.  These
should be all or a subset of the sample names used in <code>object</code>.</p>
</td></tr>
<tr><td><code id="meandistance.matrix_+3A_loci">loci</code></td>
<td>
<p>A character vector of loci to be analyzed.  These should
be all or a subset of the loci names used in <code>object</code>.</p>
</td></tr>
<tr><td><code id="meandistance.matrix_+3A_freq">freq</code></td>
<td>
<p>A data frame of allele frequencies such as that produced
by <code><a href="#topic+simpleFreq">simpleFreq</a></code> or <code><a href="#topic+deSilvaFreq">deSilvaFreq</a></code>.</p>
</td></tr>
<tr><td><code id="meandistance.matrix_+3A_self">self</code></td>
<td>
<p>A number ranging from 0 to 1, indicating the rate of selfing.</p>
</td></tr>
<tr><td><code id="meandistance.matrix_+3A_all.distances">all.distances</code></td>
<td>
<p>If <code>FALSE</code>, only the mean distance matrix will be
returned.  If <code>TRUE</code>, a list will be returned containing an array of
all distances by locus and sample as well as the mean distance matrix.</p>
</td></tr>
<tr><td><code id="meandistance.matrix_+3A_distmetric">distmetric</code></td>
<td>
<p>The function to be used to calculate distances
between genotypes.  <code>Bruvo.distance</code>, <code>Lynch.distance</code>, or
a distance function written by the user.</p>
</td></tr>
<tr><td><code id="meandistance.matrix_+3A_progress">progress</code></td>
<td>
<p>If <code>TRUE</code>, loci and samples will be printed to
the console as distances are calculated, so that the user can
monitor the progress of the computation.</p>
</td></tr>
<tr><td><code id="meandistance.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments (such as <code>maxl</code>, <code>add</code>, and
<code>loss</code>) to pass to <code>distmetric</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each distance for the three-dimensional array is calculated only once,
to save computation time.  Since the array (and resulting mean matrix)
is symmetrical, the distance is written to two positions in the array
at once.
</p>
<p><code>meandistance.matrix</code> uses ambiguous genotypes exactly as they
are, whereas <code>meandistance.matrix2</code> uses
<code><a href="#topic+genotypeProbs">genotypeProbs</a></code> to calculate all possible unambiguous
genotypes and their probabilities under random mating or partial
selfing.  The distance
between each possible pair of unambiguous genotypes for the two
samples is calculated with <code>distmetric</code> and weighted by the
product of the probabilities of the two gentoypes.  As you might
expect, <code>meandistance.matrix2</code> takes longer to process a given
<code>"genambig"</code> object than <code>meandistance.matrix</code> does.
Additionally, the distance between two identical ambiguous genotypes
will be zero when calculated with <code>meandistance.matrix</code>, and
greater than zero when calculated with <code>meandistance.matrix2</code>,
due to potential differences in copy number of the alleles.
</p>
<p>When <code>Bruvo.distance</code> is used,
<code>meandistance.matrix2</code> exaggerates distances between individuals
of different ploidy as compared to <code>meandistance.matrix</code>.  The
use of <code>Bruvo2.distance</code> with <code>meandistance.matrix2</code>
allows individuals with different ploidies to have similar
inter-individual distances to those between individuals of the same ploidy.
In general, it will be desirable to use <code>Bruvo.distance</code> with
<code>meandistance.matrix</code> for complex datasets with high ploidy
levels, or <code>Bruvo.distance2</code> with <code>meandistance.matrix2</code> for
hexaploid or lower datasets (based on how long it takes my personal
computer to perform these calculations) where changes in ploidy are
due to genome doubling or genome loss.  If all individuals have the
same ploidy, <code>Bruvo.distance</code> and <code>Bruvo2.distance</code> will
give identical results regardless of whether
<code>meandistance.matrix</code> or <code>meandistance.matrix2</code> is used.
</p>
<p><code>meandistance.matrix2</code> does not allow a genotype to have more
alleles than the ploidy of the individual (as listed in the
<code>Ploidies</code> slot).  Additionally, if <code>self</code> is greater than
zero, each population may only have one ploidy at each locus.
</p>


<h3>Value</h3>

<p>A symmetrical matrix containing pairwise distances between all
samples, averaged across all loci.  Row and column names of the matrix
will be the sample names provided in the <code>samples</code> argument.  If
<code>all.distances=TRUE</code>, a list will be produced containing the above
matrix as well as a three-dimensional array containing all distances
by locus and sample.  The array is the first item in the list, and the
mean matrix is the second.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bruvo.distance">Bruvo.distance</a></code>, <code><a href="#topic+Bruvo2.distance">Bruvo2.distance</a></code>,
<code><a href="#topic+Lynch.distance">Lynch.distance</a></code>, <code><a href="#topic+meandist.from.array">meandist.from.array</a></code>,
<code><a href="#topic+GENLIST">GENLIST</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a list of genotype data
mygendata &lt;- new("genambig", samples = c("ind1","ind2","ind3","ind4"),
                 loci = c("locus1","locus2","locus3","locus4"))
Genotypes(mygendata) &lt;-
  array(list(c(124,128,138),c(122,130,140,142),c(122,132,136),c(122,134,140),
             c(203,212,218),c(197,206,221),c(215),c(200,218),
             c(140,144,148,150),c(-9),c(146,150),c(152,154,158),
             c(233,236,280),c(-9),c(-9),c(-9)))
Usatnts(mygendata) &lt;- c(2,3,2,1)

# make index vectors of data to use
myloci &lt;- c("locus1","locus2","locus3")
mysamples &lt;- c("ind1","ind2","ind4")

# calculate array and matrix
mymat &lt;- meandistance.matrix(mygendata, mysamples, myloci,
                             all.distances=TRUE)
# view the results
mymat[[1]]["locus1",,]
mymat[[1]]["locus2",,]
mymat[[1]]["locus3",,]
mymat[[2]]

# add addtional info needed for meandistance.matrix2
mygendata &lt;- reformatPloidies(mygendata, output="one")
Ploidies(mygendata) &lt;- 4
PopInfo(mygendata) &lt;- c(1,1,1,1)

# calculate distances taking allele freqs into account
mymat2 &lt;- meandistance.matrix2(mygendata, mysamples, myloci)
mymat2
# now do the same under selfing
mymat3 &lt;- meandistance.matrix2(mygendata, mysamples, myloci, self=0.3)
mymat3
</code></pre>

<hr>
<h2 id='merge-methods'> Merge Two Genotype Objects into One </h2><span id='topic+merge'></span><span id='topic+merge-methods'></span><span id='topic+merge+2Cgenambig+2Cgenambig-method'></span><span id='topic+merge+2Cgendata+2Cgendata-method'></span><span id='topic+merge+2Cgenbinary+2Cgenbinary-method'></span>

<h3>Description</h3>

<p>The generic function <code>merge</code> has methods defined in polysat to
merge two genotype objects of the same class.  Each method has optional
<code>samples</code> and <code>loci</code> arguments for specifying subsets of
samples and loci to be included in the merged object.  Each method also
has an optional <code>overwrite</code> argument to specify which of the two
objects should not be used in the case of conflicting data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge-methods_+3A_x">x</code></td>
<td>
<p>One of the objects to be merged.  For the methods defined for
<span class="pkg">polysat</span> this should be of class <code>"gendata"</code> or one of its
subclasses.
</p>
</td></tr>
<tr><td><code id="merge-methods_+3A_y">y</code></td>
<td>

<p>The other object to be merged.  Should be of the same class as
<code>x</code>.  <code>y@Ploidies</code> must also be of the same class as
<code>x@Ploidies</code>.
</p>
</td></tr>
<tr><td><code id="merge-methods_+3A_...">...</code></td>
<td>

<p>Additional arguments specific to the method.
</p>
</td></tr>
</table>


<h3>Methods</h3>

<p>The methods for <code>merge</code> in polysat have four additional
arguments: <code>objectm, samples, loci, overwrite</code>.
</p>
<p>The <code>samples</code> and <code>loci</code> arguments can specify, using
character vectors, a subset of the samples and loci found in
<code>x</code> and <code>y</code> to write to the object that is returned.
</p>
<p>If <code>overwrite = "x"</code>, data from the second object will be used
wherever there is contradicting data.  Likewise if <code>overwrite =
    "y"</code>, data from the first object will be used wherever there is
contradicting data.  If no <code>overwrite</code> argument is given, then
any contradicting data between the two objects will produce an error
indicating where the contradicting data were found.
</p>
<p>The <code>objectm</code> argument is primarily for internal use (most
users will not need it).  If this argument is not
provided, a new genotype object is created and data from <code>x</code>
and <code>y</code> are written to it.  If <code>objectm</code> is
provided, this is the object to which data will be written, and the
object that will be returned.
</p>

<dl>
<dt><code>signature(x = "genambig", y = "genambig")</code></dt><dd>
<p>This method merges the genotype data from <code>x</code> and <code>y</code>.  If the
missing data symbols differ between the objects, <code>overwrite</code> is
used to determine which missing data symbol to use, and all missing data
symbols in the overwritten object are converted.  If <code>overwrite</code> is
not provided and the missing data symbols differ between the objects, an
error will be given.  The genotypes are then filled in.  If certain
sample*locus combinations do not exist in either object (<code>x</code> and
<code>y</code> have different samples as well as different loci), missing data
symbols are left in these positions.  Again, for genotypes,
<code>overwrite</code> determines which object to preferentially use for data
and whether to give an error if there is a disagreement.
</p>
<p>The <code>merge</code> method for <code>gendata</code> is then called.
</p>
</dd>
<dt><code>signature(x = "genbinary", y = "genbinary")</code></dt><dd>
<p>This method also merges genotype data for <code>x</code> and <code>y</code>, then
calls the method for <code>gendata</code>.  <code>Missing</code>, <code>Present</code>,
and <code>Absent</code> are checked for consistency between objects similarly
to what happens with <code>Missing</code> in the <code>genambig</code> method.
Genotypes are then written to the merged object, and consistency between
genotypes is checked.
</p>
</dd>
<dt><code>signature(x = "gendata", y = "gendata")</code></dt><dd>
<p>This method merges data about ploidy, repeat length, and population
identity, as well as writing one or both dataset descriptions to the
merged object.
</p>
<p>The same population numbers can have different meanings in
<code>PopInfo(x)</code> and <code>PopInfo(y)</code>.  The unique <code>PopNames</code> are
used instead to determine population identity, and the <code>PopInfo</code>
numbers are changed if necessary.  Therefore, it is important for
identical populations to be named the same way in both objects, but not
important for identical populations to have the same number in both objects.
</p>
</dd>
</dl>

<hr>
<h2 id='mergeAlleleAssignments'>
Merge Allele Assignment Matrices
</h2><span id='topic+mergeAlleleAssignments'></span>

<h3>Description</h3>

<p>In cases where multiple populations are used separately to assign
alleles to homeologous loci, <code>mergeAlleleAssignments</code> is used to
consolidate the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeAlleleAssignments(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeAlleleAssignments_+3A_x">x</code></td>
<td>

<p>A list, where each element is in the format of results produced by
<code><a href="#topic+catalanAlleles">catalanAlleles</a></code> or <code><a href="#topic+testAlGroups">testAlGroups</a></code>; see example.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list in similar format to <code>x</code>, but with only one element per locus.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testAlGroups">testAlGroups</a></code>, <code><a href="#topic+catalanAlleles">catalanAlleles</a></code>,
<code><a href="#topic+recodeAllopoly">recodeAllopoly</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List of allele assignment results for this example; normally these
# would be produced by other functions evaluating a genetic dataset.
# The example below is for an allotetraploid.

# Locus L1 is a well-behaved locus with no homoplasy.
myresults &lt;- list(list(locus="L1", SGploidy=2,
                  assignments=matrix(c(1,0,0,1,1,0,0,1,0,1), nrow=2,
                  ncol=5, dimnames=list(NULL,
                  c("124","128","130","134","138")))),
                  list(locus="L1", SGploidy=2,
                  assignments=matrix(c(0,1,1,0,1,0,0,1), nrow=2, ncol=4,
                  dimnames=list(NULL, c("124","128","132","140")))),
                  list(locus="L1", SGploidy=2,
                  assignments=matrix(c(0,1,1,0,0,1,1,0), nrow=2, ncol=4,
                  dimnames=list(NULL, c("126","128","130","132")))),
# Locus L2 is unresolvable because there are no shared alleles between
# populations.
                  list(locus="L2", SGploidy=2,
                  assignments=matrix(c(1,0,1,0,0,1), nrow=2, ncol=3,
                  dimnames=list(NULL, c("205","210","225")))),
                  list(locus="L2", SGploidy=2,
                  assignments=matrix(c(1,0,0,1,0,1,1,0), nrow=2, ncol=4,
                  dimnames=list(NULL, c("195","215","220","230")))),
# Locus L3 has homoplasy that makes it unresolvable.
                  list(locus="L3", SGploidy=2,
                  assignments=matrix(c(1,0,0,1,0,1,1,0), nrow=2, ncol=4,
                  dimnames=list(NULL, c("153","159","168","171")))),
                  list(locus="L3", SGploidy=2,
                  assignments=matrix(c(1,0,0,1,1,0,0,1), nrow=2, ncol=4,
                  dimnames=list(NULL, c("153","156","165","171")))),
# Locus L4 has homoplasy, but the results can still be merged.
                  list(locus="L4", SGploidy=2,
                  assignments=matrix(c(1,0,1,0,0,1,0,1,0,1), nrow=2, ncol=5,
                  dimnames=list(NULL, c("242","246","254","260","264")))),
                  list(locus="L4", SGploidy=2,
                  assignments=matrix(c(1,0,0,1,1,0,0,1,0,1), nrow=2, ncol=5,
                  dimnames=list(NULL, c("242","246","250","254","260"))))
                  )
myresults

# merge within loci
mergedresults &lt;- mergeAlleleAssignments(myresults)
mergedresults
</code></pre>

<hr>
<h2 id='PIC'>
Polymorphic Information Content
</h2><span id='topic+PIC'></span>

<h3>Description</h3>

<p>Given a set of allele frequencies, this function estimates the Polymorphic Information Content (PIC) 
for each locus, within and/or across populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PIC(freqs, pops = row.names(freqs), loci = unique(as.matrix(as.data.frame(
    strsplit(names(freqs), split = ".", fixed = TRUE), 
    stringsAsFactors = FALSE))[1, ]), bypop = TRUE, overall = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PIC_+3A_freqs">freqs</code></td>
<td>

<p>A data frame of allele frequencies, such as those output by <code><a href="#topic+simpleFreq">simpleFreq</a></code> and 
<code><a href="#topic+deSilvaFreq">deSilvaFreq</a></code>.
</p>
</td></tr>
<tr><td><code id="PIC_+3A_pops">pops</code></td>
<td>

<p>An optional characer vector containing names of populations to include.
</p>
</td></tr>
<tr><td><code id="PIC_+3A_loci">loci</code></td>
<td>

<p>An optional character vector containing names of loci to include.
</p>
</td></tr>
<tr><td><code id="PIC_+3A_bypop">bypop</code></td>
<td>

<p>If <code>TRUE</code>, PIC will be estimated separately for each population.
</p>
</td></tr>
<tr><td><code id="PIC_+3A_overall">overall</code></td>
<td>

<p>If <code>TRUE</code>, mean allele frequencies will be estimated across all populations (weighted
by population size) and used to estimate overall PIC values for each locus.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PIC is estimated as:
</p>
<p style="text-align: center;"><code class="reqn">1 - (\sum_{i = 1}^{n} p_{i}^{2}) - \sum_{i = 1}^{n - 1} \sum_{j = i + 1}^{n} 2p_{i}^{2}p_{j}^{2}</code>
</p>

<p>according to Botstein et al. (1980), where <code class="reqn">p_i</code> and <code class="reqn">p_j</code> are allele frequencies at alleles 
<em>i</em> and <em>j</em>, respectively, and <code class="reqn">n</code> is the number of alleles.
</p>
<p>The higher this value is, the more useful a marker is for distinguishing individuals and understanding
relationships among them.
</p>


<h3>Value</h3>

<p>A matrix, with loci in columns, and populations and/or &ldquo;Overall&rdquo; in rows.  Each element of
the matrix contains a PIC value.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Botstein, M., White, R. L., Skolnick, M. and Davis, R. W. (1980) Construction of 
a genetic linkage map in man using restriction fragment length polymorphisms.  
<em>American Journal of Human Genetics</em> <b>32</b>, 314&ndash;331.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alleleDiversity">alleleDiversity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate allele frequencies for this example
myfreq &lt;- data.frame(row.names = c("pop1", "pop2"), 
                     Genomes = c(20,30),
                     loc1.124 = c(0.1, 0.25),
                     loc1.126 = c(0.2, 0),
                     loc1.128 = c(0.05, 0.4),
                     loc1.130 = c(0.3, 0.1),
                     loc1.132 = c(0.1, 0.1),
                     loc1.134 = c(0.25, 0.15),
                     loc2.150 = c(0.4, 0.5),
                     loc2.155 = c(0.3, 0.2),
                     loc2.160 = c(0.3, 0.3))

# estimate PIC
PIC(myfreq)

</code></pre>

<hr>
<h2 id='pld'>
Accessor, Replacement, and Manipulation Functions for <code>"ploidysuper"</code> Objects
</h2><span id='topic+pld'></span><span id='topic+pld+3C-'></span><span id='topic+plCollapse'></span>

<h3>Description</h3>

<p><code>pld</code> accesses and replaces the <code>pld</code> slot of objects of 
<code>"<a href="#topic+ploidysuper-class">ploidysuper</a>"</code> subclasses.  <code>plCollapse</code> tests
whether an object of one of these classes can be converted to an object
of a simpler one of these classes, and optionally returns the converted
object.  These are generic functions with methods for the subclasses of
<code>"ploidysuper"</code>.  These functions are primarily for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pld(object, samples, loci)
pld(object) &lt;- value
plCollapse(object, na.rm, returnvalue)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pld_+3A_object">object</code></td>
<td>

<p>A <code>"ploidysuper"</code> object.
</p>
</td></tr>
<tr><td><code id="pld_+3A_samples">samples</code></td>
<td>

<p>An optional character or numeric vector indexing the samples for which
to return ploidy values.
</p>
</td></tr>
<tr><td><code id="pld_+3A_loci">loci</code></td>
<td>

<p>An optional character or numeric vector indexing the loci for which
to return ploidy values.
</p>
</td></tr>
<tr><td><code id="pld_+3A_value">value</code></td>
<td>

<p>A numeric vector or matrix that can be coerced to integers.  These
represent the ploidies to store in the <code>object@pld</code> slot.
</p>
</td></tr>
<tr><td><code id="pld_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean.  If <code>TRUE</code>, <code>NA</code> values are ignored when
testing to see if the ploidy format can be simplified.  If the sample,
locus, or entire dataset all has one ploidy aside from <code>NA</code>, the
<code>NA</code> values will be overwritten by that ploidy when simplifying
the ploidy format.  If <code>FALSE</code>, <code>NA</code> is treated as a unique
ploidy.
</p>
</td></tr>
<tr><td><code id="pld_+3A_returnvalue">returnvalue</code></td>
<td>
<p>Boolean.  If <code>TRUE</code>, a <code>"ploidysuper"</code>
object will be returned if the ploidy format can be simplified, and
<code>FALSE</code> will be returned if it cannot be simplified.  If
<code>FALSE</code>, only <code>TRUE</code> or <code>FALSE</code> will be returned to
indicate if the ploidy format can be simplified or not.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pld</code> returns the vector or matrix containing the ploidy values.
This is the contents of <code>object@pld</code>.
</p>
<p><code>plCollapse</code> either returns a Boolean value indicating whether the
ploidy can be changed to a simpler format, or a new <code>"ploidysuper"</code>
object with all of the ploidy data of <code>object</code> put into a simpler
format.  If <code>object</code> is a <code>"ploidymatrix"</code> object, a
<code>"ploidysample"</code>, <code>"ploidylocus"</code>, or <code>"ploidyone"</code>
object can be returned depending on how many unique ploidy values there
are and how they are distributed.  If <code>object</code> is a
<code>"ploidysample"</code> or <code>"ploidylocus"</code> object, a
<code>"ploidyone"</code> object can be returned.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reformatPloidies">reformatPloidies</a></code>, <code><a href="#topic+Ploidies">Ploidies</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- new("ploidymatrix", samples=c("a","b","c"),
            loci=c("l1","l2","l3"))
pld(test)       # view the ploidies
pld(test) &lt;- 2  # make it diploid at all samples and loci
pld(test)["a",] &lt;- c(2,4,4) # change the ploidies for sample a
pld(test, samples=c("a","b")) # view ploidies at a subset of samples

# test to see if the ploidies can be simplified
p &lt;- plCollapse(test, na.rm=FALSE, returnvalue=TRUE)
p
# now change a ploidy and repeat the test
pld(test)["a","l1"] &lt;- 4
p &lt;- plCollapse(test, na.rm=FALSE, returnvalue=TRUE)
p
# change something else and collapse it further
pld(p)["a"] &lt;- 2
p2 &lt;- plCollapse(p, na.rm=FALSE, returnvalue=TRUE)
p2

# if na.rm=FALSE, NA values are not ignored:
pld(test)["a","l1"] &lt;- NA
pld(test)
plCollapse(test, na.rm=FALSE, returnvalue=TRUE)
# NA values are ignored with na.rm=TRUE
plCollapse(test, na.rm=TRUE, returnvalue=TRUE)
</code></pre>

<hr>
<h2 id='ploidysuper-class'>Class <code>"ploidysuper"</code> and Subclasses</h2><span id='topic+ploidysuper-class'></span><span id='topic+ploidymatrix-class'></span><span id='topic+ploidysample-class'></span><span id='topic+ploidylocus-class'></span><span id='topic+ploidyone-class'></span><span id='topic+pld+2Cploidymatrix-method'></span><span id='topic+pld+2Cploidysample-method'></span><span id='topic+pld+2Cploidylocus-method'></span><span id='topic+pld+2Cploidyone-method'></span><span id='topic+pld+3C-+2Cploidymatrix-method'></span><span id='topic+pld+3C-+2Cploidysample-method'></span><span id='topic+pld+3C-+2Cploidylocus-method'></span><span id='topic+pld+3C-+2Cploidyone-method'></span><span id='topic+plCollapse+2Cploidymatrix+2Clogical+2Clogical-method'></span><span id='topic+plCollapse+2Cploidysample+2Clogical+2Clogical-method'></span><span id='topic+plCollapse+2Cploidylocus+2Clogical+2Clogical-method'></span><span id='topic+plCollapse+2Cploidyone+2Clogical+2Clogical-method'></span>

<h3>Description</h3>

<p>These classes contain ploidy data indexed by sample, locus, both, or
neither.  They are intended to go in the <code><a href="#topic+Ploidies">Ploidies</a></code> slot of
<code>"<a href="#topic+gendata-class">gendata</a>"</code> objects.
</p>


<h3>Objects from the Class</h3>

<p><code>"ploidysuper"</code> is a virtual
class: No objects may be created from it.
</p>
<p>Objects of the subclasses <code>"ploidymatrix"</code>, <code>"ploidysample"</code>,
<code>"ploidylocus"</code>, and <code>"ploidyone"</code> can be created with the
call <code>new(ploidyclass, samples, loci, ...)</code>, where
<code>ploidyclass</code> is a character string of one of the class names, and
<code>samples</code> and <code>loci</code> are character vectors naming samples and
loci, respectively.  The latter two arguments are optional depending on
the class (whether ploidies are indexed by sample and/or locus).  The
typical user will not have to create an object in this way, because other
functions in <span class="pkg">polysat</span> will do it for you.</p>


<h3>Slots</h3>


<dl>
<dt><code>pld</code>:</dt><dd><p>The only slot for objects of these classes.  For
<code>"ploidymatrix"</code>, this is a matrix of integers, indexed in
the first dimension by sample name and in the second dimension by
locus name.  Each element represents the ploidy at a given sample
and locus.  For <code>"ploidysample"</code> and <code>"ploidylocus"</code>,
the slot is an integer vector, named by sample or locus and
indicating the ploidy at each sample or locus, respectively.  For
<code>"ploidyone"</code>, the slot contains a single integer
representing the ploidy for the entire dataset.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>pld</dt><dd><p><code>signature(object= "ploidymatrix")</code>: Returns the
contents of <code>object@pld</code>: a matrix of ploidies indexed by sample
and locus.  The <code>samples</code> and <code>loci</code> arguments can be used,
optionally, to only return a subset of ploidies.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reformatPloidies">reformatPloidies</a></code>, <code><a href="#topic+pld">pld</a></code>,
<code><a href="#topic+plCollapse">plCollapse</a></code>, <code><a href="#topic+gendata-class">gendata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("ploidysuper")
</code></pre>

<hr>
<h2 id='plotSSAllo'>
Perform Allele Assignments across Entire Dataset
</h2><span id='topic+plotSSAllo'></span><span id='topic+plotParamHeatmap'></span><span id='topic+processDatasetAllo'></span>

<h3>Description</h3>

<p><code>processDatasetAllo</code> runs <code><a href="#topic+alleleCorrelations">alleleCorrelations</a></code> on every locus in 
a <code>"<a href="#topic+genambig-class">genambig</a>"</code> object, then runs <code><a href="#topic+testAlGroups">testAlGroups</a></code> on every locus
using several user-specified parameter sets.  It chooses a single best set of allele assignments
for each locus, and produces plots to help the user evaluate assignment quality.
<code>plotSSAllo</code> assists the user in evaluating the quality of allele assignments by plotting
the results of K-means clustering.  <code>plotParamHeatmap</code> assists the user in choosing the
best parameter set for <code>testAlGroups</code> for each locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSSAllo(AlCorrArray)
plotParamHeatmap(propMat, popname = "AllInd", col = grey.colors(12)[12:1], main = "")
processDatasetAllo(object, samples = Samples(object), loci = Loci(object),
                   n.subgen = 2, SGploidy = 2, n.start = 50, alpha = 0.05,
                   parameters = data.frame(tolerance     = c(0.05, 0.05,  0.05, 0.05),
                                           swap          = c(TRUE, FALSE, TRUE, FALSE),
                                           null.weight   = c(0.5,  0.5,   0,    0)),
                   plotsfile = "alleleAssignmentPlots.pdf", usePops = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSSAllo_+3A_alcorrarray">AlCorrArray</code></td>
<td>

<p>A two-dimensional list, where each item in the list is the output of <code>alleleCorrelations</code>.
The first dimension represents loci, and the second dimension represents populations.  Both 
dimensions are named.  This is the <code>$AlCorrArray</code> output of <code>processDatasetAllo</code>.
</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_propmat">propMat</code></td>
<td>
<p>A two-dimensional array, with loci in the first dimension and parameter sets in the
second dimension, indicating the proportion of alleles that were found to be homoplasious by <code>testAlGroups</code>
or the proportion of genotypes that could not be recoded using a given set of allele assignments.
This can be the <code>$propHomoplasious</code> output of <code>processDatasetAllo</code>, indexed by a single population.  If a 
three-dimensional array is provided, it will be indexed in the second dimension by <code>popname</code>.  The 
<code>$propHomoplMerged</code> or <code>$missRate</code> output of <code>processDatasetAllo</code> may also be passed to this argument.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_popname">popname</code></td>
<td>
<p>The name of the population corresponding to the data in <code>propMat</code>.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_col">col</code></td>
<td>
<p>The color scale for representing the proportion of loci that are homoplasious or the proportion of 
genotypes that are missing.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_main">main</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_object">object</code></td>
<td>
<p>A <code>"genambig"</code> object.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_samples">samples</code></td>
<td>
<p>An optional character vector indicating which samples to include in analysis.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_loci">loci</code></td>
<td>
<p>An optional character vector indicating which loci to include in analysis.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_n.subgen">n.subgen</code></td>
<td>
<p>The number of isoloci into which each locus should be split.  Passed directly to 
<code>alleleCorrelations</code>.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_sgploidy">SGploidy</code></td>
<td>
<p>The ploidy of each isolocus.  Passed directly to <code>testAlGroups</code>.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_n.start">n.start</code></td>
<td>
<p>Passed directly to the <code>nstart</code> argument of <code>kmeans</code>.  See <code><a href="#topic+alleleCorrelations">alleleCorrelations</a></code>.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_alpha">alpha</code></td>
<td>
<p>The significance threshold for determining whether two alleles are significantly correlated.  Used
primarily for identifying potentially problematic positive correlations.  Passed directly to <code>alleleCorrelations</code>.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_parameters">parameters</code></td>
<td>
<p>Data frame indicating parameter sets to pass to <code>testAlGroups</code>.  Each row is one set of parameters.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_plotsfile">plotsfile</code></td>
<td>
<p>A PDF output file name for drawing plots to help assess assignment quality.  Can be <code>NULL</code> if no
plots are desired.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_usepops">usePops</code></td>
<td>
<p>If <code>TRUE</code>, population assignments are taken from the <code>PopInfo</code> slot of <code>object</code>, and 
populations are analyzed separately with <code>alleleCorrelations</code> and <code>testAlGroups</code>, before merging the 
results with <code>mergeAlleleAssignments</code>.</p>
</td></tr>
<tr><td><code id="plotSSAllo_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>testAlGroups</code> for adjusting the simulated annealing algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotSSAllo</code> produces a plot of loci by population, with the sums-of-squares ratio on the x-axis and the evenness of allele distribution
on the y-axis (see Value).  Locus names are written directly on the plot.  If there are multiple population names, locus names are colored
by population, and a legend is provided for colors.  Loci with high-quality allele clustering are expected to be in the upper-right
quadrant of the plot.  If locus names are in italics, it indicates that positive correlations were found between some alleles, indicating
population structure or scoring error that could interfere with assignment quality.
</p>
<p><code>plotParamHeatmap</code> produces an image to indicate the proportion of alleles found to be homoplasious, or the proportion of genotypes that
could not be unambiguously recoded using allele assignments, for each locus and
parameter set for a given population (when looking at homoplasy) or merged across populations (for homoplasy or the proportion of non-recodeable
genotypes).  Darker colors indicate more homoplasy or more genotypes that could not be recoded.  
The word &ldquo;best&rdquo; indicates, for each
locus, the parameter set that found the least homoplasy or smallest number of non-recodeable genotypes.
</p>
<p>By default, <code>processDatasetAllo</code> generates a PDF file containing output from <code>plotSSAllo</code> and <code>plotParamHeatmap</code>,
as well as heatmaps of the <code>$heatmap.dist</code> output of <code>alleleCorrelations</code> for each locus and population.
Heatmaps are not plotted for loci where an allele is present in all individuals.  <code>processDatasetAllo</code> also
generates a list of R objects containing allele assignments under different parameters, as well as statistics for evaluating 
clustering quality and choosing the optimal parameter sets, as described below.
</p>


<h3>Value</h3>

<p><code>plotSSAllo</code> draws a plot and invisibly returns a list:
</p>
<table role = "presentation">
<tr><td><code>ssratio</code></td>
<td>
<p>A two-dimensional array with loci in the first dimension and populations in the second dimension.
Each value is the sums-of-squares between isoloci divided by the total sums-of-squares, as output by K-means
clustering.  If K-means clustering was not performed, the value is zero.</p>
</td></tr>
<tr><td><code>evenness</code></td>
<td>
<p>An array of the same dimensions as <code>$ssratio</code>, containing values to indicate how evenly
alleles are distributed among isoloci as determined by K-means clustering.  This is:
</p>
<p style="text-align: center;"><code class="reqn">1 - \sum_{1}^{i}{(\frac{a_{i}}{A})^2}</code>
</p>

<p>where <code class="reqn">i</code> is the number of isoloci, <code class="reqn">a_i</code> is the number of alleles for a given isolocus, and <code class="reqn">A</code>
is the total number of alleles for the locus.</p>
</td></tr>
<tr><td><code>max.evenness</code></td>
<td>
<p>The maximum possible value for <code>$evenness</code>, given the number of isoloci.</p>
</td></tr>
<tr><td><code>min.evenness</code></td>
<td>
<p>The minimum possible value for <code>$evenness</code>, given the number of isoloci and alleles.</p>
</td></tr>
<tr><td><code>posCor</code></td>
<td>
<p>An array of the same dimensions as <code>$ssratio</code>, containing <code>TRUE</code> if there were any
positive correlations between alleles, and <code>FALSE</code> if not.</p>
</td></tr>
</table>
<p><code>processDatasetAllo </code> returns a list:
</p>
<table role = "presentation">
<tr><td><code>AlCorrArray</code></td>
<td>
<p>A two-dimensional list with loci in the first dimension and populations in the second
dimension, giving the results of <code>alleleCorrelations</code>.</p>
</td></tr>
<tr><td><code>TAGarray</code></td>
<td>
<p>A three-dimensional list with loci in the first dimension, populations in the second dimension,
and parameter sets in the third dimension, giving the results of <code>testAlGroups</code>.</p>
</td></tr>
<tr><td><code>plotSS</code></td>
<td>
<p>The output of <code>plotSSAllo</code>.</p>
</td></tr>
<tr><td><code>propHomoplasious</code></td>
<td>
<p>A three-dimensional array, with the same dimensions as <code>$TAGarray</code>, indicating 
the proportion of alleles that were found to be homoplasious for each locus, population, and parameter set.</p>
</td></tr>
<tr><td><code>mergedAssignments</code></td>
<td>
<p>A two-dimensional list, with loci in the first dimension and parameter sets in the
second dimension, containing allele assignments merged across populations.  This is the output of 
<code><a href="#topic+mergeAlleleAssignments">mergeAlleleAssignments</a></code>.</p>
</td></tr>
<tr><td><code>propHomoplMerged</code></td>
<td>
<p>A two-dimensional array, of the same dimensions as <code>$mergedAssignments</code>, indicating
the proportion of alleles that were homoplasious, for each locus and parameter set, for allele assignments that
were merged across populations.</p>
</td></tr>
<tr><td><code>missRate</code></td>
<td>
<p>A matrix with the same dimensions as <code>$mergedAssignments</code> indicating the proportion of 
non-missing genotypes from the original dataset that cannot be unambiguously recoded, without invoking
aneuploidy, using the merged allele assignments from each parameter set for each locus.</p>
</td></tr>
<tr><td><code>bestAssign</code></td>
<td>
<p>A one-dimensional list with a single best set of allele assignments, from <code>$mergedAssignments</code>, 
for each locus.  The best set of assignments is chosen using <code>$missRate</code>, then in the case of a tie using 
<code>$propHomoplMerged</code>, then in the case of a tie using the parameter set that was listed first.</p>
</td></tr>
</table>
<p><code>plotParamHeatmap</code> draws a plot and does not return anything.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Clark, L. V. and Drauch Schreier, A. (2017) Resolving microsatellite genotype ambiguity in
populations of allopolyploid and diploidized autopolyploid organisms
using negative correlations between allelic variables. <em>Molecular Ecology Resources</em>, 
<b>17</b>, 1090&ndash;1103.  DOI: 10.1111/1755-0998.12639.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alleleCorrelations">alleleCorrelations</a></code>, <code><a href="#topic+recodeAllopoly">recodeAllopoly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get example dataset
data(AllopolyTutorialData)

# data cleanup
mydata &lt;- deleteSamples(AllopolyTutorialData, c("301", "302", "303"))
PopInfo(mydata) &lt;- rep(1:2, each = 150)
Genotype(mydata, 43, 2) &lt;- Missing(mydata)

# allele assignments
# R is set to 10 here to speed processing for example.  It should typically be left at the default.
myassign &lt;- processDatasetAllo(mydata, loci = c("Loc3", "Loc6"),
                               plotsfile = NULL, usePops = TRUE, R = 10,
                               parameters = data.frame(tolerance = c(0.5, 0.5), 
                               swap = c(TRUE, FALSE),
                               null.weight = c(0.5, 0.5)))

# view best assignments for each locus
myassign$bestAssign
                               
# plot K-means results
plotSSAllo(myassign$AlCorrArray)

# plot proportion of homoplasious alleles
plotParamHeatmap(myassign$propHomoplasious, "Pop1")
plotParamHeatmap(myassign$propHomoplasious, "Pop2")
plotParamHeatmap(myassign$propHomoplMerged, "Merged across populations")

# plot proportion of missing data, after recoding, for each locus and parameter set
plotParamHeatmap(myassign$missRate, main = "Missing data:")
</code></pre>

<hr>
<h2 id='read.ATetra'>
Read File in ATetra Format
</h2><span id='topic+read.ATetra'></span>

<h3>Description</h3>

<p>Given a file formatted for the software ATetra, <code>read.ATetra</code>
produces a <code>genambig</code> object containing genotypes, population
identities, population names, and a dataset description from the file.
Ploidy in the <code>genambig</code> object is automatically set to
<code>4</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ATetra(infile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.ATetra_+3A_infile">infile</code></td>
<td>

<p>Character string.  A file path to the file to be read.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.ATetra</code> reads text files in the exact format specified by
the ATetra documentation.  Note that this format only allows tetraploid
data and that there can be no missing data.
</p>


<h3>Value</h3>

<p>A <code>genambig</code> object as described above.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><a href="http://www.vub.ac.be/APNA/ATetra_Manual-1-1.pdf">http://www.vub.ac.be/APNA/ATetra_Manual-1-1.pdf</a>
</p>
<p>van Puyvelde, K., van Geert, A. and Triest, L.  (2010)  ATETRA, a new
software program to analyze tetraploid microsatellite data: comparison
with TETRA and TETRASAT.  <em>Molecular Ecology Resources</em>
<b>10</b>, 331&ndash;334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.ATetra">write.ATetra</a></code>, <code><a href="#topic+read.Tetrasat">read.Tetrasat</a></code>,
<code><a href="#topic+read.GeneMapper">read.GeneMapper</a></code>,
<code><a href="#topic+read.Structure">read.Structure</a></code>, <code><a href="#topic+read.GenoDive">read.GenoDive</a></code>,
<code><a href="#topic+read.SPAGeDi">read.SPAGeDi</a></code>, <code><a href="#topic+read.POPDIST">read.POPDIST</a></code>,
<code><a href="#topic+read.STRand">read.STRand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a file to be read
# (this would normally be done in a text editor or with ATetra's Excel template)
myfile &lt;- tempfile()

cat("TIT,Sample Rubus Data for ATetra", "LOC,1,CBA15",
"POP,1,1,Commonwealth", "IND,1,1,1,CMW1,197,208,211,213",
"IND,1,1,2,CMW2,197,207,211,212", "IND,1,1,3,CMW3,197,208,212,219",
"IND,1,1,4,CMW4,197,208,212,219", "IND,1,1,5,CMW5,197,208,211,212",
"POP,1,2,Fall Creek Lake", "IND,1,2,6,FCR4,197,207,211,212",
"IND,1,2,7,FCR7,197,208,212,218", "IND,1,2,8,FCR14,197,207,212,218",
"IND,1,2,9,FCR15,197,208,211,212", "IND,1,2,10,FCR16,197,208,211,212",
"IND,1,2,11,FCR17,197,207,212,218","LOC,2,CBA23","POP,2,1,Commonwealth",
"IND,2,1,1,CMW1,98,100,106,125","IND,2,1,2,CMW2,98,125,,",
"IND,2,1,3,CMW3,98,126,,","IND,2,1,4,CMW4,98,106,119,127",
"IND,2,1,5,CMW5,98,106,125,","POP,2,2,Fall Creek Lake",
"IND,2,2,6,FCR4,98,125,,","IND,2,2,7,FCR7,98,106,126,",
"IND,2,2,8,FCR14,98,127,,","IND,2,2,9,FCR15,98,108,117,",
"IND,2,2,10,FCR16,98,125,,","IND,2,2,11,FCR17,98,126,,","END",
file = myfile, sep = "\n")

# Read the file and examine the data
exampledata &lt;- read.ATetra(myfile)
summary(exampledata)
PopNames(exampledata)
viewGenotypes(exampledata)
</code></pre>

<hr>
<h2 id='read.GeneMapper'>
Read GeneMapper Genotypes Tables
</h2><span id='topic+read.GeneMapper'></span>

<h3>Description</h3>

<p>Given a vector of filepaths to tab-delimited text files containing
genotype data in the ABI GeneMapper Genotypes Table format,
<code>read.GeneMapper</code> produces a <code>genambig</code> object containing
the genotype data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.GeneMapper(infiles, forceInteger=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.GeneMapper_+3A_infiles">infiles</code></td>
<td>

<p>A character vector of paths to the files to be read.
</p>
</td></tr>
<tr><td><code id="read.GeneMapper_+3A_forceinteger">forceInteger</code></td>
<td>

<p>Boolean.  If <code>TRUE</code>, alleles will be coerced to integers.  This is
particularly useful for stripping any white space from allels and
preventing alleles from being imported as character strings.  If
<code>FALSE</code>, alleles will be imported as numeric or character values,
depending on the content of the input file(s).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.GeneMapper</code> can read the genotypes tables that are exported
by the Applied Biosystems GeneMapper software.  The only alterations
to the files that the user may have to make are 1) delete
any rows with missing data or fill in <code>-9</code> in the first allele slot for
that row, 2) make sure that all allele names are numeric
representations of fragment length (no question marks or dashes), and
3) put sample names into the Sample Name column, if the names that you
wish to use in analysis are not already there.  Each file should have
the standard header row produced by the software.  If any sample has
more than one genotype listed for a given locus, only the last
genotype listed will be used.
</p>
<p>The file format is simple enough that the user can easily create files
manually if GeneMapper is not the software used in allele calling.
The files are tab-delimited text files.  There should be a header row
with column names.  The column labeled &ldquo;Sample Name&rdquo; should contain
the names of the samples, and the column labeled &ldquo;Marker&rdquo; should
contain the names of the loci.  You can have as many or as few columns as
needed to contain the alleles, and each of these columns should be
labeled &ldquo;Allele X&rdquo; where X is a number unique to each column.  Row
labels and any other columns are ignored.  For any given sample, each
allele is listed only once and is given as an integer that is the
length of the fragment in nucleotides.  Duplicate alleles in the same
row are ignored by <code>read.GeneMapper</code>.  Alleles are separated by
tabs.  If you have more allele columns than alleles for any given
sample, leave the extra cells blank so that <code>read.table</code> will
read them as <code>NA</code>.  Example data files in this format are
included in the package.
</p>
<p><code>read.GeneMapper</code> will read all of your data at once.  It takes
as its first argument a character vector containing paths to all of
the files to be read.  How the data are distributed over these files
does not matter.  The function finds all unique sample names and all
unique markers across all the files, and automatically puts a missing
data symbol into the list if a particular sample and locus combination
is not found.  Rows in which all allele cells are blank should NOT be
included in the input files; either delete these rows or put the
missing data symbol into the first allele cell.
</p>
<p>Sample and locus names must be consistent within and across the
files.  The object that is produced is indexed by these names.
</p>
<p>If <code>forceInteger=FALSE</code>, alleles can be non-numeric values.  Some
functionality of <span class="pkg">polysat</span> will be lost in this case, but it could
allow for the import of SNP data, for example.
</p>


<h3>Value</h3>

<p>A <code>genambig</code> object containing genotypes from the files, stored as
vectors of unique alleles in its <code>Genotypes</code> slot.  Other slots are
left at the default values.
</p>


<h3>Note</h3>

<p>A &lsquo;subscript out of bounds&rsquo; error may mean that a sample name
or marker was left blank in one of the input files.  A &lsquo;NAs
introduced by coercion&rsquo; warning when <code>forceInteger=TRUE</code> means that a
non-numeric, non-whitespace character was included in one of the
allele fields of the file(s), in which case the file(s) should be
carefully checked and re-imported.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>GeneMapper website: <a href="https://www.thermofisher.com/order/catalog/product/4475073">https://www.thermofisher.com/order/catalog/product/4475073</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genambig-class">genambig</a></code>, <code><a href="#topic+read.Structure">read.Structure</a></code>,
<code><a href="#topic+read.GenoDive">read.GenoDive</a></code>, <code><a href="#topic+read.SPAGeDi">read.SPAGeDi</a></code>,
<code><a href="#topic+read.Tetrasat">read.Tetrasat</a></code>, <code><a href="#topic+read.ATetra">read.ATetra</a></code>,
<code><a href="#topic+write.GeneMapper">write.GeneMapper</a></code>, <code><a href="#topic+read.POPDIST">read.POPDIST</a></code>,
<code><a href="#topic+read.STRand">read.STRand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a table of data
gentable &lt;- data.frame(Sample.Name=rep(c("ind1","ind2","ind3"),2),
                       Marker=rep(c("loc1","loc2"), each=3),
                       Allele.1=c(202,200,204,133,133,130),
                       Allele.2=c(206,202,208,136,142,136),
                       Allele.3=c(NA,208,212,145,148,NA),
                       Allele.4=c(NA,216,NA,151,157,NA)
                       )
# create a file (inspect this file in a text editor or spreadsheet
# software to see the required format)
myfile &lt;- tempfile()
write.table(gentable, file=myfile, quote=FALSE, sep="\t",
            na="", row.names=FALSE, col.names=TRUE)

# read the file
mygenotypes &lt;- read.GeneMapper(myfile)

# inspect the results
viewGenotypes(mygenotypes)
</code></pre>

<hr>
<h2 id='read.GenoDive'>
Import Genotype Data from GenoDive File
</h2><span id='topic+read.GenoDive'></span>

<h3>Description</h3>

<p><code>read.GenoDive</code> takes a text file in the format for the software
GenoDive and produces a <code>genambig</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.GenoDive(infile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.GenoDive_+3A_infile">infile</code></td>
<td>

<p>A character string.  The path to the file to be read.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GenoDive is a Mac-only program for population genetic analysis that
allows for polyploid data.  <code>read.GenoDive</code> imports data from text
files formatted for this program.
</p>
<p>The first line of the file is a comment line, which is written to the
<code>Description</code> slot of the <code>genambig</code> object.
On the second line, separated by tabs, are the number of individuals,
number of populations, number of loci, maximum ploidy
(ignored), and number of digits used to code alleles.
</p>
<p>The following lines contain the names of populations, which are written
to the <code>PopNames</code> slot of the <code>genambig</code> object.  After that is a
header line for the genotype data.  This line contains, separated by
tabs, column headers for populations, clones (optional), and
individuals, followed by the name of each locus.  The locus names for the
genotype object are derived from this line.
</p>
<p>Each individual is on one line following the genotype header line.
Separated by tabs are the population number, the clone number
(optional), the individual name (used as the sample name in the output)
and the genotypes at each locus.  Alleles at one locus are concatenated
together in one string without any characters to separate them.  Each
allele must have the same number of digits, although leading zeros can
be omitted.
</p>
<p>If the only alleles listed for a particular individual and locus are
zeros, this is interpreted by <code>read.GenoDive</code> as missing data, and
<code>Missing(object)</code> (the default, <code>-9</code>) is written in that
genotype slot in the <code>genambig</code> object.
GenoDive allows for a genotype to be partially missing but <span class="pkg">polysat</span> does
not; therefore, if an allele is coded as zero but other alleles are
recorded for that sample and locus, the output genotype will just
contain the alleles that are present, with the zeros thrown out.
</p>


<h3>Value</h3>

<p>A <code>genambig</code> object containing the data from the file.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Meirmans, P. G. and Van Tienderen, P. H. (2004) GENOTYPE and GENODIVE:
two programs for the analysis of genetic diversity of asexual
organisms. <em>Molecular Ecology Notes</em> <b>4</b>, 792-794.
</p>
<p><a href="http://www.bentleydrummer.nl/software/software/GenoDive.html">http://www.bentleydrummer.nl/software/software/GenoDive.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.GeneMapper">read.GeneMapper</a></code>, <code><a href="#topic+write.GenoDive">write.GenoDive</a></code>,
<code><a href="#topic+read.Tetrasat">read.Tetrasat</a></code>, <code><a href="#topic+read.ATetra">read.ATetra</a></code>,
<code><a href="#topic+read.Structure">read.Structure</a></code>,
<code><a href="#topic+read.SPAGeDi">read.SPAGeDi</a></code>, <code><a href="#topic+read.POPDIST">read.POPDIST</a></code>,
<code><a href="#topic+read.STRand">read.STRand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data file (normally done in a text editor or spreadsheet software)
myfile &lt;- tempfile()
cat(c("example comment line", "5\t2\t2\t3\t2", "pop1", "pop2",
      "pop\tind\tloc1\tloc2", "1\tJohn\t102\t1214",
      "1\tPaul\t202\t0", "2\tGeorge\t101\t121213",
      "2\tRingo\t10304\t131414","1\tYoko\t10303\t120014"),
    file = myfile, sep = "\n")

# import file data
exampledata &lt;- read.GenoDive(myfile)

# view data
summary(exampledata)
viewGenotypes(exampledata)
exampledata
</code></pre>

<hr>
<h2 id='read.POPDIST'>
Read Genotype Data in POPDIST Format
</h2><span id='topic+read.POPDIST'></span>

<h3>Description</h3>

<p><code>read.POPDIST</code> reads one or more text files formatted for the
software POPDIST and produces a <code>"genambig"</code> object containing
genotypes, ploidies, and population identities from the file(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.POPDIST(infiles)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.POPDIST_+3A_infiles">infiles</code></td>
<td>

<p>A character vector of file paths to be read.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The format for the software POPDIST is a modified version of the
popular Genepop format.  The first line is a comment line, followed by
a list of locus names, each on a separate line or on one line
separated by commas.  A line starting with
the string &ldquo;Pop&rdquo; (&ldquo;pop&rdquo; and &ldquo;POP&rdquo; are also recognized)
indicates the beginning of data for one population.  Each individual
is then represented on one line, with the population name and
individual genotype separated by a tab followed by a comma.  Genotypes
for different
loci are separated by a tab or space.  Each allele must be coded by
two digits.  Zeros (&ldquo;00&rdquo;) indicate missing data, either for an
entire locus or for a partially heterozygous genotype.  Partially
heterozygous genotypes can also be represented by the arbitrary
duplication of alleles.
</p>
<p>If more than one file is read at once, locus names must be consistent
across all files.  Locus and population names should not start with &ldquo;Pop&rdquo;,
&ldquo;pop&rdquo;, or &ldquo;POP&rdquo;, as <code>read.POPDIST</code> searches for these
character strings in order to identify the lines that delimit populations.
</p>


<h3>Value</h3>

<p>A <code>"genambig"</code> object.  The <code>Description</code> slot of the object
is taken from the comment line of the first file.  Locus names are taken
from the files, and samples are given numbers instead of names.  Each
genotype consists of all unique non-zero integers for a given sample and
locus.  The <code>Ploidies</code> slot is filled in based on how many alleles
are present at each locus of each sample (the number of characters
for the genotype, divided by two).  <code><a href="#topic+reformatPloidies">reformatPloidies</a></code> is
used internally by the function to collapse the ploidies to the simplest
format.  Population names are taken from the
individual genotype lines, and population identities are recorded based
on how the individuals are delimited by &ldquo;Pop&rdquo; lines.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Tomiuk, J., Guldbrandtsen, B. and Loeschcke, B.  (2009)  Genetic
similarity of polyploids: a new version of the computer program POPDIST
(version 1.2.0) considers intraspecific genetic differentiation.
<em>Molecular Ecology Resources</em> <b>9</b>, 1364-1368.
</p>
<p>Guldbrandtsen, B., Tomiuk, J. and Loeschcke, B.  (2000) POPDIST version
1.1.1: A program to calculate population genetic distance and identity
measures.  <em>Journal of Heredity</em> <b>91</b>, 178-179.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.POPDIST">write.POPDIST</a></code>, <code><a href="#topic+read.Tetrasat">read.Tetrasat</a></code>,
<code><a href="#topic+read.ATetra">read.ATetra</a></code>, <code><a href="#topic+read.Structure">read.Structure</a></code>,
<code><a href="#topic+read.SPAGeDi">read.SPAGeDi</a></code>, <code><a href="#topic+read.GeneMapper">read.GeneMapper</a></code>,
<code><a href="#topic+read.GenoDive">read.GenoDive</a></code>, <code><a href="#topic+read.STRand">read.STRand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a file to read (this is typically done in a text editor)
myfile &lt;- tempfile()
cat("An example for the read.POPDIST documentation.",
"abcR",
"abcQ",
"Pop",
"Piscataqua\t, 0204 0505",
"Piscataqua\t, 0404 0307",
"Piscataqua\t, 050200 030509",
"Pop",
"Salmon Falls\t, 1006\t0805",
"Salmon Falls\t, 0510\t0308",
"Pop",
"Great Works\t, 050807 030800",
"Great Works\t, 0000 0408",
"Great Works\t, 0707 0305",
file=myfile, sep="\n")

# View the file in the R console (or open it in a text editor)
cat(readLines(myfile), sep="\n")

# Read the file into a "genambig" object
fishes &lt;- read.POPDIST(myfile)

# View the data in the object
summary(fishes)
PopNames(fishes)
PopInfo(fishes)
Ploidies(fishes)
viewGenotypes(fishes)
</code></pre>

<hr>
<h2 id='read.SPAGeDi'>
Read Genotypes in SPAGeDi Format
</h2><span id='topic+read.SPAGeDi'></span>

<h3>Description</h3>

<p><code>read.SPAGeDi</code> can read a text file formatted for the SPAGeDi
software and return a <code>genambig</code> object,
as well as optionally returning a data frame of spatial coordinates.
The <code>genambig</code> object includes genotypes, ploidies, and population
identities (from the category column, if present) from the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.SPAGeDi(infile, allelesep = "/", returnspatcoord = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.SPAGeDi_+3A_infile">infile</code></td>
<td>

<p>A character string indicating the path of the file to read.
</p>
</td></tr>
<tr><td><code id="read.SPAGeDi_+3A_allelesep">allelesep</code></td>
<td>

<p>The character that is used to delimit alleles within genotypes, or
<code>""</code> if alleles have a fixed number of digits and are not delimited
by any character.  Other examples shown in section 3.2.1 of the SPAGeDi
1.3 manual include <code>"/"</code>, <code>" "</code>, <code>", "</code>, <code>"."</code>, and
<code>"--"</code>.
</p>
</td></tr>
<tr><td><code id="read.SPAGeDi_+3A_returnspatcoord">returnspatcoord</code></td>
<td>

<p>Boolean.  Indicates whether a data frame should be returned containing
the spatial coordinates columns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SPAGeDi offers a lot of flexibility in how data files are formatted.
<code>read.SPAGeDi</code> accomodates most of that flexibility.  The primary
exception is that alleles must be delimited in the same way across all
genotypes, as specified by <code>allelesep</code>.  Comment lines beginning
with <code>//</code>, as well as blank lines, are ignored by
<code>read.SPAGeDi</code> just as they are by SPAGeDi.
</p>
<p><code>read.SPAGeDi</code> is not designed to read dominant data (see section
3.2.2 of the SPAGeDi 1.3 manual).  However, see
<code>genbinary.to.genambig</code> for a way to read this type
of data after some simple manipulation in a spreadsheet program.
</p>
<p>The first line of a SPAGeDi file contains information that is used by
<code>read.SPAGeDi</code>.  The ploidy as specified in the 6th position of the
first line is ignored, and is instead calculated by counting alleles for
each individual (including zeros on the right, but not the left, side of
the genotype).  The number of digits specified in the 5th position of
the first line is only used if <code>allelesep=""</code>.  All other values
in the first line are important for the function.
</p>
<p>If the only alleles found for a particular individual and locus are
zeros, the genotype is interpreted as missing.  Otherwise, zeros on the
left side of a genotype are ignored, and zeros on the right side of a
genotype are used in calculating the ploidy but are not included in the
genotype object that is returned.  If <code>allelesep=""</code>,
<code>read.SPAGeDi</code> checks that the number of characters in the genotype
can be evenly divided by the number of digits per allele.  If not, zeros
are added to the left of the genotype string before splitting it into
alleles.
</p>
<p>The <code>Ploidies</code> slot of the <code>"genambig"</code> object that is created
is initially indexed by both sample and locus, with ploidy being
written to the slot on a per-genotype basis.  After all genotypes have
been imported, <code><a href="#topic+reformatPloidies">reformatPloidies</a></code> is used to convert
<code>Ploidies</code> to the simplest possible format before the object is returned.
</p>


<h3>Value</h3>

<p>Under the default where <code>returnspatcoord=FALSE</code>, a <code>genambig</code>
object is returned.  Alleles are formatted as integers.  The
<code>Ploidies</code> slot is filled in according to the number of alleles
per genotype, ignoring zeros on the left.  If the first line of the
file indicates that there are more than zero categories, the category
column is used to fill in the <code>PopNames</code> and <code>PopInfo</code> slots.
</p>
<p>Otherwise, a list is returned:
</p>
<table role = "presentation">
<tr><td><code>SpatCoord</code></td>
<td>
<p>A data frame of spatial coordinates,
unchanged from the file.  The format of each column is determined under
the default <code>read.table</code> settings.  Row names are individual names
from the file.  Column names are the same as in the file.</p>
</td></tr>
<tr><td><code>Dataset</code></td>
<td>
<p>A <code>genambig</code> object as described above.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><a href="https://ebe.ulb.ac.be/ebe/SPAGeDi.html">https://ebe.ulb.ac.be/ebe/SPAGeDi.html</a>
</p>
<p>Hardy, O. J. and Vekemans, X. (2002) SPAGeDi: a versatile computer
program to analyse spatial genetic structure at the individual or
population levels.  <em>Molecular Ecology Notes</em> <b>2</b>, 618&ndash;620.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.SPAGeDi">write.SPAGeDi</a></code>, <code><a href="#topic+genbinary.to.genambig">genbinary.to.genambig</a></code>,
<code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="#topic+read.GeneMapper">read.GeneMapper</a></code>,
<code><a href="#topic+read.GenoDive">read.GenoDive</a></code>, <code><a href="#topic+read.Structure">read.Structure</a></code>,
<code><a href="#topic+read.ATetra">read.ATetra</a></code>, <code><a href="#topic+read.Tetrasat">read.Tetrasat</a></code>,
<code><a href="#topic+read.POPDIST">read.POPDIST</a></code>, <code><a href="#topic+read.STRand">read.STRand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a file to read (usually done with spreadsheet software or a
# text editor):
myfile &lt;- tempfile()
cat("// here's a comment line at the beginning of the file",
"5\t0\t-2\t2\t2\t4",
"4\t5\t10\t50\t100",
"Ind\tLat\tLong\tloc1\tloc2",
"ind1\t39.5\t-120.8\t00003133\t00004040",
"ind2\t39.5\t-120.8\t3537\t4246",
"ind3\t42.6\t-121.1\t5083332\t40414500",
"ind4\t38.2\t-120.3\t00000000\t41430000",
"ind5\t38.2\t-120.3\t00053137\t00414200",
"END",
sep="\n", file=myfile)

# display the file
cat(readLines(myfile), sep="\n")

# read the file
mydata &lt;- read.SPAGeDi(myfile, allelesep = "",
returnspatcoord = TRUE)

# view the data
mydata
viewGenotypes(mydata[[2]])

</code></pre>

<hr>
<h2 id='read.STRand'>
Read Genotypes Produced by STRand Software
</h2><span id='topic+read.STRand'></span>

<h3>Description</h3>

<p>This function reads in data in a format derived from the &ldquo;BTH&rdquo;
format for exporting genotypes from the allele calling software STRand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.STRand(file, sep = "\t", popInSam = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.STRand_+3A_file">file</code></td>
<td>

<p>A text string indicating the file to read.
</p>
</td></tr>
<tr><td><code id="read.STRand_+3A_sep">sep</code></td>
<td>

<p>Field delimiter for the file.  Tab by default.
</p>
</td></tr>
<tr><td><code id="read.STRand_+3A_popinsam">popInSam</code></td>
<td>

<p>Boolean.  If <code>TRUE</code>, fields from the &ldquo;Pop&rdquo; and &ldquo;Ind&rdquo;
columns will be concatenated to create a sample name.  If <code>FALSE</code>,
only the &ldquo;Ind&rdquo; column will be used for sample names.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not read the files directly produced from STRand, but
requires some simple clean-up in spreadsheet software.  The BTH format
in STRand produces two columns per locus.  One of these columns should
be deleted so that there is just one column per locus.  Loci names
should remain in the column headers.  The column containing sample names
should be deleted or renamed &ldquo;Ind&rdquo;.  A
&ldquo;Pop&rdquo; column will need to be added, containing population names.
An &ldquo;Ind&rdquo; column is also necessary, containing either full sample
names or a sample suffix to be concatenated with the population name
(see <code>popInSam</code> argument).
</p>
<p>STRand adds an asterisk to the end of any genotype with more than two
alleles.  <code>read.STRand</code> will automatically strip this asterisk out
of the genotype.
</p>
<p>Missing data is indicated by a zero in the file.
</p>


<h3>Value</h3>

<p>A <code>"genambig"</code> object containing genotypes, locus and sample names,
population names, and population identities from the file.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><a href="https://vgl.ucdavis.edu/STRand">https://vgl.ucdavis.edu/STRand</a>
</p>
<p>Toonen, R. J. and Hughes, S. (2001) Increased Throughput for Fragment
Analysis on ABI Prism 377 Automated Sequencer Using a Membrane Comb
and STRand Software.  <em>Biotechniques</em> <b>31</b>, 1320&ndash;1324.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="#topic+read.GeneMapper">read.GeneMapper</a></code>,
<code><a href="#topic+read.GenoDive">read.GenoDive</a></code>, <code><a href="#topic+read.Structure">read.Structure</a></code>,
<code><a href="#topic+read.ATetra">read.ATetra</a></code>, <code><a href="#topic+read.Tetrasat">read.Tetrasat</a></code>,
<code><a href="#topic+read.POPDIST">read.POPDIST</a></code>, <code><a href="#topic+read.SPAGeDi">read.SPAGeDi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate file to read
strtemp &lt;- data.frame(Pop=c("P1","P1","P2","P2"),
                      Ind=c("a","b","a","b"),
                      LocD=c("0","172/174","170/172/178*","172/176"),
                      LocG=c("130/136/138/142*","132/136","138","132/140/144*"))
myfile &lt;- tempfile()
write.table(strtemp, file=myfile, sep="\t",
            row.names=FALSE, quote=FALSE)

# read the file
mydata &lt;- read.STRand(myfile)
viewGenotypes(mydata)
PopNames(mydata)

# alternative example with popInSam=FALSE
strtemp$Ind &lt;- c("OH1","OH5","MT4","MT7")
write.table(strtemp, file=myfile, sep="\t",
            row.names=FALSE, quote=FALSE)
mydata &lt;- read.STRand(myfile, popInSam=FALSE)
Samples(mydata)
PopNames(mydata)
</code></pre>

<hr>
<h2 id='read.Structure'>
Read Genotypes and Other Data from a Structure File
</h2><span id='topic+read.Structure'></span>

<h3>Description</h3>

<p><code>read.Structure</code> creates a <code>genambig</code> object by reading a text
file formatted for the software Structure.  <code>Ploidies</code> and
<code>PopInfo</code> (if
available) are also written to the object, and data from additional
columns can optionally be extracted as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.Structure(infile, ploidy, missingin = -9, sep = "\t",
               markernames = TRUE, labels = TRUE, extrarows = 1,
               popinfocol = 1, extracols = 1, getexcols = FALSE,
               ploidyoutput="one")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.Structure_+3A_infile">infile</code></td>
<td>

<p>Character string.  The file path to be read.
</p>
</td></tr>
<tr><td><code id="read.Structure_+3A_ploidy">ploidy</code></td>
<td>

<p>Integer.  The ploidy of the file, <em>i.e.</em> how many rows there
are for each individual.
</p>
</td></tr>
<tr><td><code id="read.Structure_+3A_missingin">missingin</code></td>
<td>

<p>The symbol used to represent missing data in the Structure file.
</p>
</td></tr>
<tr><td><code id="read.Structure_+3A_sep">sep</code></td>
<td>

<p>The character used to delimit the fields of the Structure file (tab by default).
</p>
</td></tr>
<tr><td><code id="read.Structure_+3A_markernames">markernames</code></td>
<td>

<p>Boolean, indicating whether the file has a header containing marker names.
</p>
</td></tr>
<tr><td><code id="read.Structure_+3A_labels">labels</code></td>
<td>

<p>Boolean, indicating whether the file has a column containing sample names.
</p>
</td></tr>
<tr><td><code id="read.Structure_+3A_extrarows">extrarows</code></td>
<td>

<p>Integer.  The number of extra rows that the file has, not counting
marker names.  This could include rows for recessive alleles,
inter-marker distances, or phase information.
</p>
</td></tr>
<tr><td><code id="read.Structure_+3A_popinfocol">popinfocol</code></td>
<td>

<p>Integer.  The column number (after the labels column, if present)
where the data to be used for <code>PopInfo</code> are stored.  Can be
<code>NA</code> to indicate that <code>PopInfo</code> should not be extracted from
the file.
</p>
</td></tr>
<tr><td><code id="read.Structure_+3A_extracols">extracols</code></td>
<td>

<p>Integer.  The number of extra columns that the file has, not counting
sample names (labels) but counting the column to be used for
<code>PopInfo</code>.  This could include PopData, PopFlag, LocData,
Phenotype, or any other extra columns.
</p>
</td></tr>
<tr><td><code id="read.Structure_+3A_getexcols">getexcols</code></td>
<td>

<p>Boolean, indicating whether the function should return the data from any
extra columns.
</p>
</td></tr>
<tr><td><code id="read.Structure_+3A_ploidyoutput">ploidyoutput</code></td>
<td>

<p>This argument determines what is assigned to the <code>Ploidies</code> slot
of the <code>"genambig"</code> dataset that is output.  It should be a
string, either <code>"one"</code>, <code>"samplemax"</code>, or
<code>"matrix"</code>.  This indicates, respectively, that <code>ploidy</code>
should be used as the ploidy of the entire dataset, that the maximum
number of alleles for each sample should be used as the ploidy of that
sample, or that ploidies should be stored as a matrix of allele counts
for each sample*locus.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current version of <code>read.Structure</code> does not support the
ONEROWPERIND option in the file format.  Each locus must only have one
column.  If your data are in ONEROWPERIND format, it should be fairly
simple to manipulate it in a spreadsheet program so that it can be read
by <code>read.GeneMapper</code> instead.
</p>
<p><code>read.Structure</code> uses <code>read.table</code> to initially read the file into a
data frame, then extracts information from the data frame.  Because of
this, any header rows (particularly the one containing marker names)
should have leading tabs (or spaces if <code>sep=" "</code>) so that the marker
names align correctly with their corresponding genotypes.  You should be
able to open the file in a spreadsheet program and have everything align
correctly.
</p>
<p>If the file does not contain sample names, set <code>labels=FALSE</code>.  The
samples will be numbered instead, and if you like you can use the
<code>Samples&lt;-</code> function to edit the sample names of the genotype object after
import.  Likewise, if <code>markernames=FALSE</code>, the
loci will be numbered automatically by the column names that
<code>read.table</code> creates, but these can also be edited after the fact.
</p>
<p>The <code>Ploidies</code> slot of the <code>"genambig"</code> object that is created
is initially indexed by both sample and locus, with ploidy being
written to the slot on a per-genotype basis.  After all genotypes have
been imported, <code><a href="#topic+reformatPloidies">reformatPloidies</a></code> is used to convert
<code>Ploidies</code> to the simplest possible format before the object is returned.
</p>


<h3>Value</h3>

<p>If <code>getexcols=FALSE</code>, the function returns only a <code>genambig</code> object.
</p>
<p>If <code>getexcols=TRUE</code>, the function returns a list with two elements.  The
first, named <code>ExtraCol</code>, is a data frame, where the row names are the
sample names and each column is one of the extra columns from the file
(but with each sample only once instead of being repeated <code>ploidy</code>
number of times).  The second element is named <code>Dataset</code> and is the
genotype object described above.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><a href="https://web.stanford.edu/group/pritchardlab/structure_software/release_versions/v2.3.4/structure_doc.pdf">https://web.stanford.edu/group/pritchardlab/structure_software/release_versions/v2.3.4/structure_doc.pdf</a>
</p>
<p>Hubisz, M. J., Falush, D., Stephens, M. and Pritchard, J. K. (2009)
Inferring weak population structure with the assistance of sample
group information.  <em>Molecular Ecology Resources</em> <b>9</b>,
1322&ndash;1332.
</p>
<p>Falush, D., Stephens, M. and Pritchard, J. K.  (2007)
Inferences of population structure using multilocus genotype data:
dominant markers and null alleles.  <em>Molecular Ecology Notes</em>
<b>7</b>, 574&ndash;578.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.Structure">write.Structure</a></code>, <code><a href="#topic+read.GeneMapper">read.GeneMapper</a></code>,
<code><a href="#topic+read.Tetrasat">read.Tetrasat</a></code>, <code><a href="#topic+read.ATetra">read.ATetra</a></code>,
<code><a href="#topic+read.GenoDive">read.GenoDive</a></code>,
<code><a href="#topic+read.SPAGeDi">read.SPAGeDi</a></code>, <code><a href="#topic+read.POPDIST">read.POPDIST</a></code>,
<code><a href="#topic+read.STRand">read.STRand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a file to read (normally done in a text editor or spreadsheet
# software)
myfile &lt;- tempfile()
cat("\t\tRhCBA15\tRhCBA23\tRhCBA28\tRhCBA14\tRUB126\tRUB262\tRhCBA6\tRUB26",
    "\t\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    "WIN1B\t1\t197\t98\t152\t170\t136\t208\t151\t99",
    "WIN1B\t1\t208\t106\t174\t180\t166\t208\t164\t99",
    "WIN1B\t1\t211\t98\t182\t187\t184\t208\t174\t99",
    "WIN1B\t1\t212\t98\t193\t170\t203\t208\t151\t99",
    "WIN1B\t1\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    "WIN1B\t1\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    "WIN1B\t1\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    "WIN1B\t1\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    "MCD1\t2\t208\t100\t138\t160\t127\t202\t151\t124",
    "MCD1\t2\t208\t102\t153\t168\t138\t207\t151\t134",
    "MCD1\t2\t208\t106\t157\t180\t162\t211\t151\t137",
    "MCD1\t2\t208\t110\t159\t187\t127\t215\t151\t124",
    "MCD1\t2\t208\t114\t168\t160\t127\t224\t151\t124",
    "MCD1\t2\t208\t124\t193\t160\t127\t228\t151\t124",
    "MCD1\t2\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    "MCD1\t2\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    "MCD2\t2\t208\t98\t138\t160\t136\t202\t150\t120",
    "MCD2\t2\t208\t102\t144\t174\t145\t214\t150\t132",
    "MCD2\t2\t208\t105\t148\t178\t136\t217\t150\t135",
    "MCD2\t2\t208\t114\t151\t184\t136\t227\t150\t120",
    "MCD2\t2\t208\t98\t155\t160\t136\t202\t150\t120",
    "MCD2\t2\t208\t98\t157\t160\t136\t202\t150\t120",
    "MCD2\t2\t208\t98\t163\t160\t136\t202\t150\t120",
    "MCD2\t2\t208\t98\t138\t160\t136\t202\t150\t120",
    "MCD3\t2\t197\t100\t172\t170\t159\t213\t174\t134",
    "MCD3\t2\t197\t106\t174\t178\t193\t213\t176\t132",
    "MCD3\t2\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    "MCD3\t2\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    "MCD3\t2\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    "MCD3\t2\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    "MCD3\t2\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    "MCD3\t2\t-9\t-9\t-9\t-9\t-9\t-9\t-9\t-9",
    sep="\n",file=myfile)

# view the file
cat(readLines(myfile), sep="\n")

# read the structure file into genotypes and populations
testdata &lt;- read.Structure(myfile, ploidy=8)

# examine the results
testdata
</code></pre>

<hr>
<h2 id='read.Tetrasat'>
Read Data from a TETRASAT Input File
</h2><span id='topic+read.Tetrasat'></span>

<h3>Description</h3>

<p>Given a file containing genotypes in the TETRASAT format,
<code>read.Tetrasat</code> produces a <code>genambig</code> object containing
genotypes and population identities from the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.Tetrasat(infile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.Tetrasat_+3A_infile">infile</code></td>
<td>

<p>A character string of the file path to be read.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.Tetrasat</code> reads text files that are in the exact format
specified by the software TETRASAT  and TETRA (see references for more
information).  This is similar to the file format for GenePop but allows
for up to four alleles per locus.  All alleles must be coded by two
digits.  Another difference between the TETRASAT and GenePop formats is
that in TETRASAT the sample name and genotypes are not separated by a
comma, because the columns of data have fixed widths.
</p>
<p>Since TETRASAT files also contain information about which samples belong
to which populations, this information is put into the <code>PopInfo</code>
slot of the <code>genambig</code> object.  Population names are not taken from
the file.  The <code>Ploidies</code> slot is
filled with the number 4 (using the <code>"<a href="#topic+ploidyone-class">ploidyone</a>"</code>
class), because all individuals should be tetraploid.
The first line of the file is put into the <code>Description</code> slot.
</p>
<p>Locus names should not contain the letters &quot;pop&quot;, uppercase or lowercase,
adjacent to each other.
</p>


<h3>Value</h3>

<p>A <code>genambig</code> object containing data from the file.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Markwith, S. H., Stewart, D. J. and Dyer, J. L.  (2006)
TETRASAT: a program for the population analysis of
allotetraploid microsatellite data. <em>Molecular Ecology Notes</em>
<b>6</b>, 586-589.
</p>
<p>Liao, W. J., Zhu, B. R., Zeng, Y. F. and Zhang, D. Y.  (2008)
TETRA: an improved program for population genetic analysis of
allotetraploid microsatellite data.  <em>Molecular Ecology Resources</em>
<b>8</b>, 1260&ndash;1262.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.GeneMapper">read.GeneMapper</a></code>, <code><a href="#topic+write.Tetrasat">write.Tetrasat</a></code>,
<code><a href="#topic+read.ATetra">read.ATetra</a></code>, <code><a href="#topic+read.GenoDive">read.GenoDive</a></code>,
<code><a href="#topic+read.Structure">read.Structure</a></code>,
<code><a href="#topic+read.SPAGeDi">read.SPAGeDi</a></code>, <code><a href="#topic+read.POPDIST">read.POPDIST</a></code>,
<code><a href="#topic+read.STRand">read.STRand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example with defined data:
myfile &lt;- tempfile()
cat("Sample Data", "A1_Gtype", "A10_Gtype", "B1_Gtype", "D7_Gtype",
"D9_Gtype", "D12_Gtype", "Pop",
"BCRHE 1             0406     04040404 0208     02020202 03030303 0710",
"BCRHE 10            0406     04040404 07070707 02020202 0304     0710",
"BCRHE 2             04040404 04040404 0708     02020202 010305   0710",
"BCRHE 3             04040404 04040404 02020202 0203     03030303 0809",
"BCRHE 4             04040404 04040404 0608     0203     03030303 070910",
"BCRHE 5             04040404 04040404 0208     02020202 03030303 050710",
"BCRHE 6             0304     04040404 0207     02020202 03030303 07070707",
"BCRHE 7             0406     04040404 0708     02020202 03030303 07070707",
"BCRHE 8             0304     04040404 0203     0203     03030303 0709",
"BCRHE 9             0406     04040404 0708     02020202 03030303 0710",
"Pop",
"BR 1                0406     04040404 05050505 02020202 03030303 1012",
"BR 10               030406   04040404 0607     02020202 03030303 1011",
"BR 2                030406   04040404 07070707 02020202 03030303 09090909",
"BR 3                010304   04040404 07070707 02020202 03030303 09090909",
"BR 4                030406   04040404 07070707 0203     03030303 10101010",
"BR 5                030406   04040404 07070707 02020202 03030303 10101010",
"BR 6                0406     04040404 0507     0203     03030303 10101010",
"BR 7                0304     04040404 0809     02020202 03030303 070910",
"BR 8                030406   04040404 07070707 02020202 03030303 070910",
"BR 9                0406     04040404 07070707 02020202 03030303 07070707",
sep="\n", file=myfile)
mydata2 &lt;- read.Tetrasat(myfile)

summary(mydata2)
viewGenotypes(mydata2, loci="B1_Gtype")
</code></pre>

<hr>
<h2 id='recodeAllopoly'>
Create a New <code><a href="#topic+genambig-class">genambig</a></code> Dataset with Loci Split into Isoloci
</h2><span id='topic+recodeAllopoly'></span>

<h3>Description</h3>

<p>Given a <code>"<a href="#topic+genambig-class">genambig</a>"</code> object and a list of allele
assignments such as those produced by <code><a href="#topic+testAlGroups">testAlGroups</a></code> or
<code><a href="#topic+catalanAlleles">catalanAlleles</a></code>, <code>recodeAllopoly</code> will generate a
new <code>"genambig"</code> object, with genotypes split according to which
alleles belong to which isoloci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recodeAllopoly(object, x, allowAneuploidy = TRUE,
               samples = Samples(object), loci = Loci(object))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recodeAllopoly_+3A_object">object</code></td>
<td>

<p>A <code>"genambig"</code> object containing the dataset that needs to be re-coded.
</p>
</td></tr>
<tr><td><code id="recodeAllopoly_+3A_x">x</code></td>
<td>

<p>A list.  Each item in the list should itself be a list, in the format
output by <code>testAlGroups</code>, <code>catalanAlleles</code>, or
<code><a href="#topic+mergeAlleleAssignments">mergeAlleleAssignments</a></code>.  Each sub-list
has three items: <code>$locus</code> is the name of the locus,
<code>$SGploidy</code> is an integer indicating the ploidy of each subgenome
(<em>e.g.</em> <code>2</code> for an allotetraploid), and <code>$assignments</code> is
a matrix of ones and zeros indicating which alleles belong to which isoloci.
</p>
</td></tr>
<tr><td><code id="recodeAllopoly_+3A_allowaneuploidy">allowAneuploidy</code></td>
<td>

<p>Boolean.  This controls what happens when the function encounters
genotypes that have more alleles than are possible for a given
isolocus.  (For example, the genotype has four alleles, but three belong
to isolocus 1 and one belongs to isolocus 2.)  If <code>TRUE</code>, the
individual is assumed to be aneuploid at that locus, and its ploidy is
adjusted only for that locus.  If <code>FALSE</code>, missing data are recorded.
</p>
</td></tr>
<tr><td><code id="recodeAllopoly_+3A_samples">samples</code></td>
<td>

<p>An optional character vector indicating which samples to analyze and output.
</p>
</td></tr>
<tr><td><code id="recodeAllopoly_+3A_loci">loci</code></td>
<td>

<p>An optional character vector indicating which loci to analyze and output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The same locus may appear more than once in <code>x</code>, for example if
distinct populations were analyzed separately to produce the
allele assignments.  If this is the case, <code>recodeAllopoly</code> will
internally use <code>mergeAlleleAssignments</code> to consolidate items in
<code>x</code> with the same locus name.  Loci that are in <code>x</code> but not
<code>object</code> are ignored with a warning.  Loci that are in
<code>object</code> but not <code>x</code> are retained in the output of the
function, but not re-coded.
</p>
<p>This function allows homoplasy, and uses process-of-elimination to try
to determine which isoloci the homoplasious alleles belong to.  In cases
where genotypes cannot be determined for certain due to homoplasy,
missing data are inserted.
</p>
<p>If a genotype has more alleles than should be possible (<em>e.g.</em> five
alleles in an allotetraploid), the genotype is skipped and will be
output as missing data for all corresponding isoloci.
</p>


<h3>Value</h3>

<p>A <code>"genambig"</code> object, with loci that are in <code>x</code> split into
the appropriate number of isoloci.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Clark, L. V. and Drauch Schreier, A. (2017) Resolving microsatellite genotype ambiguity in
populations of allopolyploid and diploidized autopolyploid organisms
using negative correlations between alleles. <em>Molecular Ecology Resources</em>, 
<b>17</b>, 1090&ndash;1103.  DOI: 10.1111/1755-0998.12639.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a dataset for this example
testdata &lt;- new("genambig", samples = paste("S", 1:9, sep = ""),
                loci = c("L1", "L2","L3"))
Genotypes(testdata, loci="L1") &lt;-
    list(c(120,124),c(124,126,130),c(120,126),c(126,132,134),
         c(120,124,130,132),c(120,126,130),c(120,132,134),
         c(120,124,126,130),c(120,132,138))
Genotypes(testdata, loci="L2") &lt;-
    list(c(210,219,222,225),c(216,228),c(210,213,219,222),c(213,222,225,228),
         c(210,213,216,219),c(222,228),c(213),c(210,216),c(219,222,228))
Genotypes(testdata, loci="L3") &lt;-
    list(c(155,145,153),c(157,155),c(151,157,159,165),c(147,151),c(149,153,157),
         c(149,157),c(153,159,161),c(163,165),c(147,163,167))
viewGenotypes(testdata)

# generate allele assignments for this example
myAssign &lt;- list(list(locus="L1", SGploidy=2,
             assignments=matrix(c(1,0,0,1,1,1,0,1,1,0,1,1), nrow=2,
                                ncol=6, dimnames=list(NULL,
                                  c("120","124","126","130","132","134")))),
    list(locus="L2", SGploidy=2,
         assignments=matrix(c(1,1,1,1,1,1,1,0,1,0,1,0,0,1), nrow=2, ncol=7,
    dimnames=list(NULL,c("210","213","216","219","222","225","228")))),
    list(locus="L3", SGploidy=2, assignments="No assignment"))
myAssign

# recode the dataset
splitdata &lt;- recodeAllopoly(testdata, myAssign)

# view results
viewGenotypes(splitdata)
Ploidies(splitdata)

</code></pre>

<hr>
<h2 id='reformatPloidies'>
Convert Ploidy Format of a Dataset
</h2><span id='topic+reformatPloidies'></span>

<h3>Description</h3>

<p>This function changes the class of the object in the <code>Ploidies</code>
slot of a <code>"gendata"</code> object.  (See the four subclasses described
in <code>"<a href="#topic+ploidysuper-class">ploidysuper</a>"</code>.)  Existing ploidy data can either
be erased or, if possible, used in the new format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reformatPloidies(object, output = "collapse", na.rm = FALSE, erase = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reformatPloidies_+3A_object">object</code></td>
<td>

<p>A <code>"gendata"</code> object.
</p>
</td></tr>
<tr><td><code id="reformatPloidies_+3A_output">output</code></td>
<td>

<p>A character string indicating the desired result of the conversion:
<code>"matrix"</code> if ploidies should be indexed by both sample and locus,
<code>"sample"</code> if ploidies should be indexed only by sample,
<code>"locus"</code> if ploidies should be indexed only by locus, <code>"one"</code>
if there should be one ploidy for the entire dataset, or
<code>"collapse"</code> if ploidies should be converted to the simplest
possible format.
</p>
</td></tr>
<tr><td><code id="reformatPloidies_+3A_na.rm">na.rm</code></td>
<td>

<p>Boolean.  If <code>FALSE</code>, <code>NA</code> is treated as a unique ploidy.  If
<code>TRUE</code>, <code>NA</code> values are ignored assuming that each sample
and/or locus has only one ploidy otherwise.  This argument is passed
directly to <code><a href="#topic+plCollapse">plCollapse</a></code>.
</p>
</td></tr>
<tr><td><code id="reformatPloidies_+3A_erase">erase</code></td>
<td>

<p>Boolean.  If <code>TRUE</code>, the new <code>Ploidies</code> slot is simply filled
with <code>NA</code> instead of existing ploidy values from <code>object</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a versatile function that can accomplish several tasks
relating to the format of ploidies in the dataset:
</p>
<p>If you wish to change how ploidy is indexed, but don't care about
keeping any data in the <code>Ploidies</code> slot, set <code>erase=TRUE</code>
and <code>output</code> to <code>"matrix"</code>, <code>"sample"</code>, <code>"locus"</code>,
or <code>"one"</code>.
</p>
<p>If you wish to keep ploidy data while moving from a simpler format to
a more complex format (<em>i.e.</em> from <code>"one"</code> to any other
format, or from <code>"sample"</code> or <code>"locus"</code> to <code>"matrix"</code>),
leave <code>erase=FALSE</code> and set <code>output</code> to the desired format.
Existing data will be duplicated to fill out the new format.  For
example, if ploidies were indexed by sample and you change to matrix
format, the ploidy that had previously been recorded for each sample
will be duplicated for each locus.
</p>
<p>If you wish to keep ploidy data while performing any other format
conversions (<em>e.g.</em> <code>"matrix"</code> to <code>"sample"</code> or
<code>"sample"</code> to <code>"locus"</code>), the function will check that there
is one unique ploidy for each sample, locus, or the entire dataset (as
appropriate), and will produce an error if the conversion cannot be
done without a loss of information.
</p>
<p>If you wish to keep ploidy data and convert to the simplest possible
format, set <code>output="collapse"</code>.  The function will automatically
determine the simplest format for conversion without loss of data.
(The <code>read</code> functions in <span class="pkg">polysat</span> that take ploidy data from
the input file use this option.)
</p>


<h3>Value</h3>

<p>A <code>"gendata"</code> object that is a copy of <code>object</code> but with the
<code>Ploidies</code> slot converted to a new class.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plCollapse">plCollapse</a></code>, <code>"<a href="#topic+ploidysuper-class">ploidysuper</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a new "genambig" object for this example
testdata &lt;- new("genambig")
Ploidies(testdata)

## If you need to reformat before you have entered any ploidy
## information:

# convert from matrix to sample format
testdata &lt;- reformatPloidies(testdata, output="sample")
Ploidies(testdata)

## If you have entered ploidy information but realized you can use a
## simpler format:

# Enter some ploidies
Ploidies(testdata)[1] &lt;- 2
Ploidies(testdata)

# Convert from "sample" to "one" with na.rm=TRUE
testdata &lt;- reformatPloidies(testdata, na.rm=TRUE, output="one")
Ploidies(testdata)

## If you change your mind and want to go back to a more complex format

# Convert from "one" to "locus"
testdata &lt;- reformatPloidies(testdata, output="locus")
Ploidies(testdata)
</code></pre>

<hr>
<h2 id='simAllopoly'>
Generate Simulated Datasets
</h2><span id='topic+simAllopoly'></span>

<h3>Description</h3>

<p>Given the number of subgenomes, the ploidy of each subgenome, and
optionally, allele frequencies, <code>simAllopoly</code> will generate a
<code>"genambig"</code> object containing simulated data for one locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simAllopoly(ploidy = c(2, 2), n.alleles = c(4, 4), n.homoplasy = 0,
            n.null.alleles=rep(0, length(ploidy)), alleles = NULL,
            freq = NULL, meiotic.error.rate=0, nSam = 100, locname = "L1")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simAllopoly_+3A_ploidy">ploidy</code></td>
<td>

<p>A vector of integers, with one value for each subgenome, indicating the
ploidy of that subgenome.  For example, <code>c(2,2)</code> indicates an
allotetraploid.  An allohexaploid, with three diploid subgenomes,
would be coded as <code>c(2,2,2)</code>.
</p>
</td></tr>
<tr><td><code id="simAllopoly_+3A_n.alleles">n.alleles</code></td>
<td>

<p>A vector, in similar format to the previous argument, indicating how
many different unique alleles there are for each isolocus.  Ignored if
<code>alleles</code> is provided.
</p>
</td></tr>
<tr><td><code id="simAllopoly_+3A_n.homoplasy">n.homoplasy</code></td>
<td>

<p>A single value indicating how many homoplasious alleles there are.
Ignored if <code>alleles</code> is provided.  This value should not be greater
than any value in <code>n.alleles</code>.  If <code>freq</code> is provided, the
frequency or frequencies at the end of each vector will be the
frequencies of homopolasious alleles.
</p>
</td></tr>
<tr><td><code id="simAllopoly_+3A_n.null.alleles">n.null.alleles</code></td>
<td>

<p>A vector, in similar format to <code>ploidy</code> and <code>n.alleles</code>,
indicating how many null alleles there are for each isolocus.  Ignored
if <code>alleles</code> is provided.  These values should not be greater
than <code>n.alleles</code>.  If <code>freq</code> is provided, the
frequency or frequencies at the beginning of each vector will be the
null allele frequencies.
</p>
</td></tr>
<tr><td><code id="simAllopoly_+3A_alleles">alleles</code></td>
<td>

<p>Optional.  A list of vectors of allele names (which are usually
expressed as integers, but can also be character strings if desired).
Each element of the list contains the allele names for the corresponding
isolocus.  Zero indicates a null allele.  Allele names that are
identical between isoloci will be treated as homoplasious.  If this argument is not
provided, alleles will be named as described in &ldquo;Details&rdquo;.
</p>
</td></tr>
<tr><td><code id="simAllopoly_+3A_freq">freq</code></td>
<td>

<p>Optional.  A list of vectors of allele frequencies.  If <code>alleles</code>
is provided, all of the vectors must match in length between the two
lists.  Otherwise, the lengths of the vectors much match the values in
<code>n.alleles</code>.  If <code>freq</code> is not provided, it will be randomly
generated.
</p>
</td></tr>
<tr><td><code id="simAllopoly_+3A_meiotic.error.rate">meiotic.error.rate</code></td>
<td>

<p>A single value ranging from 0 to 0.5.  The probability of a gamete
containing a meiotic error involving this locus.  See &ldquo;Details&rdquo;.
</p>
</td></tr>
<tr><td><code id="simAllopoly_+3A_nsam">nSam</code></td>
<td>

<p>A single value indicating the number of samples to generate.
</p>
</td></tr>
<tr><td><code id="simAllopoly_+3A_locname">locname</code></td>
<td>

<p>The name for the locus.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>alleles=NULL</code>, allele names will be generated in the format
<code>A-1, A-2, B-1, B-2</code> etc., where A and B refer to separate
subgenomes.  Homoplasious alleles will be named <code>H-1, H-2</code>, etc.
</p>
<p>Meiotic errors, as simulated by <code>simAllopoly</code>, always result in
balanced aneuploidy, <em>i.e.</em> one copy of an isolocus will be
replaced by an additional copy of a different isolocus.  This is
simulated on a per-gamete basis, so each gamete can have a maximum of
one meiotic error per locus, but an individual could potentially be
derived from two error-containing gametes.  Note that in homozygotes and
partial heterozygotes, it may not be possible to detect aneuploidy by
examining the genotype; this phenomenon lowers the apparent rate of
aneuploidy in the dataset.
</p>
<p>If alleles are provided by the user with the <code>alleles</code> argument,
zero (for sets of numeric alleles) or <code>"N"</code> (for sets of character
alleles) indicates a null allele.  The null allele will be
simulated at the frequency specified, but will not be shown in the
output dataset.  Genotypes with no non-null alleles are recorded as missing.
</p>


<h3>Value</h3>

<p>A <code>"genambig"</code> object.
</p>


<h3>Note</h3>

<p>Unlike the code supplied in the file <code>extdata/simgen.R</code>, all
genotypes in a dataset generated by this function will be of the same
ploidy.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Clark, L. V. and Drauch Schreier, A. (2017) Resolving microsatellite genotype ambiguity in
populations of allopolyploid and diploidized autopolyploid organisms
using negative correlations between alleles. <em>Molecular Ecology Resources</em>, 
<b>17</b>, 1090&ndash;1103.  DOI: 10.1111/1755-0998.12639.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alleleCorrelations">alleleCorrelations</a></code>, <code><a href="#topic+catalanAlleles">catalanAlleles</a></code>,
<code><a href="#topic+simgen">simgen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate an allotetraploid dataset with no homoplasy.
# One isolocus has five alleles, while the other has eight.
test &lt;- simAllopoly(n.alleles=c(5,8))

# Generate an allo-octoploid dataset with two tetraploid subgenomes, ten
# alleles per subgenome, including one homoplasious allele.
test2 &lt;- simAllopoly(ploidy=c(4,4), n.alleles=c(10,10), n.homoplasy=1)

# Generate an allotetraploid dataset, and manually define allele names
# and frequencies.
test3 &lt;- simAllopoly(alleles=list(c(120,124,126),c(130,134,138,140)),
                         freq=list(c(0.4,0.3,0.3),c(0.25,0.25,0.25,0.25)))

# Generate an autotetraploid dataset with seven alleles
test4 &lt;- simAllopoly(ploidy=4, n.alleles=7)

# Generate an allotetraploid dataset with a null allele at high frequency
test5 &lt;- simAllopoly(n.null.alleles=c(1,0),
                      freq=list(c(0.5,0.1,0.1,0.3), c(0.25,0.25,0.4,0.1)))
</code></pre>

<hr>
<h2 id='simgen'>Randomly Generated Data for Learning polysat</h2><span id='topic+simgen'></span>

<h3>Description</h3>

<p><code>genambig</code> object containing simulated data from three
populations with 100 individuals each, at three loci.  Individuals
are a random mixture of diploids and tetraploids.  Genotypes were
generated according to pre-set allele frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simgen)</code></pre>


<h3>Format</h3>

<p>A <code>genambig</code> object with data in the <code>Genotypes</code>,
<code>PopInfo</code>, <code>PopNames</code>, <code>Ploidies</code> and <code>Usatnts</code>
slots.  This is saved as an .RData file.  <code>simgen</code> was created
using the code found in the &ldquo;simgen.R&rdquo; file in the
&ldquo;extdata&rdquo; directory of the polysat package installation.  This
code may be useful for inspiration on how to create a simulated dataset.</p>


<h3>Source</h3>

<p>simulated data</p>


<h3>See Also</h3>

<p><code><a href="#topic+testgenotypes">testgenotypes</a></code>,
<code><a href="#topic+genambig-class">genambig</a></code></p>

<hr>
<h2 id='simpleFreq'>
Simple Allele Frequency Estimator
</h2><span id='topic+simpleFreq'></span>

<h3>Description</h3>

<p>Given genetic data, allele frequencies by population are calculated.
This estimation method assumes polysomic inheritance.  For genotypes
with allele copy number ambiguity, all alleles are assumed to have an
equal chance of being present in multiple copies.  This function is best
used to generate initial values for more complex allele frequency
estimation methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleFreq(object, samples = Samples(object), loci = Loci(object))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simpleFreq_+3A_object">object</code></td>
<td>

<p>A <code>genbinary</code> or <code>genambig</code> object containing genotype data.
No <code>NA</code> values are allowed for <code>PopInfo(object)[samples]</code> or
<code>Ploidies(object,samples,loci)</code>. (Population identity and ploidy are
needed for allele frequency calculation.)
</p>
</td></tr>
<tr><td><code id="simpleFreq_+3A_samples">samples</code></td>
<td>

<p>An optional character vector of samples to include in the calculation.
</p>
</td></tr>
<tr><td><code id="simpleFreq_+3A_loci">loci</code></td>
<td>

<p>An optional character vector of loci to include in the calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>object</code> is of class <code>genambig</code>, it is converted to a
<code>genbinary</code> object before allele frequency calculations take
place.  Everything else being equal, the function will work more quickly
if it is supplied with a <code>genbinary</code> object.
</p>
<p>For
each sample*locus, a conversion factor is generated that is the ploidy
of the sample (and/or locus) as specified in <code>Ploidies(object)</code>
divided by the number of
alleles that the sample has at that locus.  Each allele is then
considered to be present in as many copies as the conversion factor
(note that this is not necessarily an integer).  The number of copies of
an allele is totaled for the population and is divided by the total
number of genomes in the population (minus missing data at the locus)
in order to calculate allele frequency.
</p>
<p>A major assumption of this calculation method is that each allele in a
partially heterozygous genotype has an equal chance of being present in
more than one copy.  This is almost never true, because common alleles
in a population are more likely to be partially homozygous in an
individual.  The result is that the frequency of common alleles is
underestimated and the frequency of rare alleles is overestimated.  Also
note that the level of inbreeding in the population has an effect on the
relationship between genotype frequencies and allele frequencies, but is
not taken into account in this calculation.
</p>


<h3>Value</h3>

<p>Data frame, where each population is in one row.  If each sample in
<code>object</code> has only one ploidy, the first column of the data frame is
called <code>Genomes</code> and contains the number of genomes in each
population.  Otherwise, there is a
<code>Genomes</code> column for each locus.  Each remaining column contains
frequencies for one allele.
Columns are named by locus and allele, separated by a period.  Row names
are taken from <code>PopNames(object)</code>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genbinary-class">genbinary</a></code>, <code><a href="#topic+genambig-class">genambig</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a data set for this example
mygen &lt;- new("genambig", samples = paste("ind", 1:6, sep=""),
             loci = c("loc1", "loc2"))
mygen &lt;- reformatPloidies(mygen, output="sample")
Genotypes(mygen, loci="loc1") &lt;- list(c(206),c(208,210),c(204,206,210),
    c(196,198,202,208),c(196,200),c(198,200,202,204))
Genotypes(mygen, loci="loc2") &lt;- list(c(130,134),c(138,140),c(130,136,140),
    c(138),c(136,140),c(130,132,136))
PopInfo(mygen) &lt;- c(1,1,1,2,2,2)
Ploidies(mygen) &lt;- c(2,2,4,4,2,4)

# calculate allele frequencies
myfreq &lt;- simpleFreq(mygen)

# look at the results
myfreq

# an example where ploidy is indexed by locus instead
mygen2 &lt;- new("genambig", samples = paste("ind", 1:6, sep=""),
             loci = c("loc1", "loc2"))
mygen2 &lt;- reformatPloidies(mygen2, output="locus")
PopInfo(mygen2) &lt;- 1
Ploidies(mygen2) &lt;- c(2,4)
Genotypes(mygen2, loci="loc1") &lt;- list(c(198), c(200,204), c(200),
                                       c(198,202), c(200), c(202,204))
Genotypes(mygen2, loci="loc2") &lt;- list(c(140,144,146), c(138,144),
                                       c(136,138,144,148), c(140),
                                       c(140,142,146,150),
                                       c(142,148,150))
myfreq2 &lt;- simpleFreq(mygen2)
myfreq2
</code></pre>

<hr>
<h2 id='testgenotypes'>Rubus Genotype Data for Learning polysat</h2><span id='topic+testgenotypes'></span>

<h3>Description</h3>

<p><code>genambig</code> object containing alleles of 20 <em>Rubus</em>
samples at three microsatellite loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(testgenotypes)</code></pre>


<h3>Format</h3>

<p>A <code>genambig</code> object with data in the <code>Genotypes</code>,
<code>PopInfo</code>, <code>PopNames</code>, and <code>Usatnts</code> slots.  This is
saved as a .RData file.  Population identities are used here to
indicate two different species.</p>


<h3>Source</h3>

<p>Clark, L. V. and Jasieniuk, M. (2012)  Spontaneous
hybrids between native and exotic <em>Rubus</em> in the Western United
States produce offspring both by apomixis and by sexual
recombination. <em>Heredity</em> <b>109</b>, 320&ndash;328.  Data available
at: <a href="https://doi.org/10.5061/dryad.m466f">doi:10.5061/dryad.m466f</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+FCRinfo">FCRinfo</a></code>, <code><a href="#topic+simgen">simgen</a></code>,
<code><a href="#topic+genambig-class">genambig</a></code></p>

<hr>
<h2 id='viewGenotypes'>
Print Genotypes to the Console
</h2><span id='topic+viewGenotypes'></span>

<h3>Description</h3>

<p><code>viewGenotypes</code> prints a tab-delimited table of samples, loci, and
alleles to the console so that genotypes can be easily viewed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewGenotypes(object, samples = Samples(object), loci = Loci(object))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viewGenotypes_+3A_object">object</code></td>
<td>

<p>An object of
one of the <code>gendata</code> subclasses, containing genotypes to be
viewed.
</p>
</td></tr>
<tr><td><code id="viewGenotypes_+3A_samples">samples</code></td>
<td>

<p>A numerical or character vector indicating which samples to display.
</p>
</td></tr>
<tr><td><code id="viewGenotypes_+3A_loci">loci</code></td>
<td>

<p>A numerical or character vector indicating which loci to display.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>viewGenotypes</code> is a generic function with methods for
<code>genambig</code> and <code>genbinary</code> objects.
</p>
<p>For a <code>genambig</code> object, a header line indicating sample, locus,
and allele columns is printed.
Genotypes are printed below this.  Genotypes are ordered first by locus
and second by sample.
</p>
<p>For a <code>genbinary</code> object, the presence/absence matrix is printed,
organized by locus.  After the matrix for one locus is printed, a blank
line is inserted and the matrix for the next locus is printed.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Genotypes">Genotypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a dataset for this example
mygen &lt;- new("genambig", samples=c("ind1", "ind2", "ind3", "ind4"),
             loci=c("locA", "locB"))
Genotypes(mygen) &lt;- array(list(c(98, 104, 108), c(100, 104, 110, 114),
                               c(102, 108, 110), Missing(mygen),
                               c(132, 135), c(138, 141, 147),
                               c(135, 141, 144), c(129, 150)),
                          dim=c(4,2))

# view the genotypes
viewGenotypes(mygen)

</code></pre>

<hr>
<h2 id='write.ATetra'>
Write Genotypes in ATetra Format
</h2><span id='topic+write.ATetra'></span>

<h3>Description</h3>

<p><code>write.ATetra</code> uses genotype and population information contained
in a <code>genambig</code> object to create a
text file of genotypes in the ATetra format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.ATetra(object, samples = Samples(object),
             loci = Loci(object), file = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.ATetra_+3A_object">object</code></td>
<td>

<p>A <code>genambig</code> object containing the dataset of interest.  Genotypes,
population identities, population names, and the dataset description are
used for creating the file.  Ploidies must be set to 4.
</p>
</td></tr>
<tr><td><code id="write.ATetra_+3A_samples">samples</code></td>
<td>

<p>A character vector of samples to write to the file.  This is a subset
of <code>Samples(object)</code>.
</p>
</td></tr>
<tr><td><code id="write.ATetra_+3A_loci">loci</code></td>
<td>

<p>A character vector of loci to write to the file.  This is a subset of
<code>Loci(object)</code>.
</p>
</td></tr>
<tr><td><code id="write.ATetra_+3A_file">file</code></td>
<td>

<p>A character string indicating the path and name to which to write the file.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that missing data are not allowed in ATetra, although
<code>write.ATetra</code> will still process missing data.  When it does so, it
leaves all alleles blank in the file for that particular sample and
locus, and also prints a warning indicating which sample and locus had
missing data.
</p>


<h3>Value</h3>

<p>A file is written but no value is returned.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><a href="http://www.vub.ac.be/APNA/ATetra_Manual-1-1.pdf">http://www.vub.ac.be/APNA/ATetra_Manual-1-1.pdf</a>
</p>
<p>van Puyvelde, K., van Geert, A. and Triest, L.  (2010)  ATETRA, a new
software program to analyze tetraploid microsatellite data: comparison
with TETRA and TETRASAT.  <em>Molecular Ecology Resources</em>
<b>10</b>, 331-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.ATetra">read.ATetra</a></code>, <code><a href="#topic+write.Tetrasat">write.Tetrasat</a></code>,
<code><a href="#topic+write.GeneMapper">write.GeneMapper</a></code>, <code><a href="#topic+write.POPDIST">write.POPDIST</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up sample data (usually done by reading files)
mysamples &lt;- c("ind1", "ind2", "ind3", "ind4")
myloci &lt;- c("loc1", "loc2")
mygendata &lt;- new("genambig", samples=mysamples, loci=myloci)
mygendata &lt;- reformatPloidies(mygendata, output="one")
Genotypes(mygendata, loci="loc1") &lt;- list(c(202,204), c(204),
                                          c(200,206,208,212),
                                          c(198,204,208))
Genotypes(mygendata, loci="loc2") &lt;- list(c(78,81,84),
                                          c(75,90,93,96,99),
                                          c(87), c(-9))
PopInfo(mygendata) &lt;- c(1,2,1,2)
PopNames(mygendata) &lt;- c("this pop", "that pop")
Ploidies(mygendata) &lt;- 4
Description(mygendata) &lt;- "Example for write.ATetra."

## Not run: 
# write an ATetra file
write.ATetra(mygendata, file="atetratest.txt")

# view the file
cat(readLines("atetratest.txt"),sep="\n")

## End(Not run)


</code></pre>

<hr>
<h2 id='write.freq.SPAGeDi'>
Create a File of Allele Frequencies for SPAGeDi
</h2><span id='topic+write.freq.SPAGeDi'></span>

<h3>Description</h3>

<p>A table of allele frequencies such as that produced by <code>simpleFreq</code>
or <code>deSilvaFreq</code> is used to calculate average allele frequencies
for the entire dataset.  These are then written in a format that can be
read by the software SPAGeDi.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.freq.SPAGeDi(freqs, usatnts, file = "", digits = 2,
                   pops = row.names(freqs),
  loci = unique(as.matrix(as.data.frame(strsplit(names(freqs), split =
  ".", fixed = TRUE), stringsAsFactors = FALSE))[1, ]))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.freq.SPAGeDi_+3A_freqs">freqs</code></td>
<td>

<p>A data frame of population sizes and allele frequencies, such as that
produced by <code>simpleFreq</code> or <code>deSilvaFreq</code>.  Populations are in
rows, and alleles are in columns.  A column is needed containing
population sizes in number of genomes; this may either be a single
column called &ldquo;Genomes&rdquo; or multiple columns named by the locus
and &ldquo;Genomes&rdquo;, sepearated by a period.  All other columns contain
allele frequencies.  The column
names for these should be the locus and allele separated by a period.
</p>
</td></tr>
<tr><td><code id="write.freq.SPAGeDi_+3A_usatnts">usatnts</code></td>
<td>

<p>An integer vector containing the lengths of the microsatellite repeats
for the loci in the table.  In most cases, if <code>object</code> is the
<code>"gendata"</code> object used to generate <code>freqs</code>, then you should set
<code>usatnts = Usatnts(object)</code>.  This is needed to convert allele
names in the same way that <code>write.SPAGeDi</code> converts allele names.
</p>
</td></tr>
<tr><td><code id="write.freq.SPAGeDi_+3A_file">file</code></td>
<td>

<p>The name of the file to write.
</p>
</td></tr>
<tr><td><code id="write.freq.SPAGeDi_+3A_digits">digits</code></td>
<td>

<p>The number of digits to use to represent each allele.  This should be
the same as that used in <code>write.SPAGeDi</code>, so that allele names are
consistent between the two files.
</p>
</td></tr>
<tr><td><code id="write.freq.SPAGeDi_+3A_pops">pops</code></td>
<td>

<p>An optional character vector indicating a subset of populations from the
table to use in calculating mean allele frequencies.
</p>
</td></tr>
<tr><td><code id="write.freq.SPAGeDi_+3A_loci">loci</code></td>
<td>

<p>An optional character vector indicating a subset of loci to write to the
file.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For some calculations of inter-individual relatedness and kinship
coefficients, SPAGeDi can read a file of allele frequencies to use in
the calculation.  <code>write.freq.SPAGeDi</code> puts allele frequencies from
<span class="pkg">polysat</span> into this format.
</p>
<p>A weighted average of allele frequencies is calculated across all
populations (or those specified by <code>pops</code>).  The average is
weighted by population size as specified in the &ldquo;Genomes&rdquo; column
of <code>freqs</code>.
</p>
<p>Allele names are converted to match those produced by
<code>write.SPAGeDi</code>.  Alleles are divided by the numbers in
<code>usatnts</code> in order to convert fragment length in nucleotides to
repeat numbers.  If necessary, <code>10^(digits-1)</code> is repeatedly
subtracted from all alleles until they can be represented using the
right number of digits.
</p>
<p>The file produced is tab-delimited and contains two columns per locus.
The first column contains the locus name followed by all allele names,
and the second column contains the number of alleles followed by the
allele frequencies.
</p>


<h3>Value</h3>

<p>A file is written but no value is returned.
</p>


<h3>Note</h3>

<p>SPAGeDi can already estimate allele frequencies in a way that is
identical to that of <code>simpleFreq</code>.  Therefore, if you have allele
frequencies produced by <code>simpleFreq</code>, there is not much sense in
exporting them to SPAGeDi.  <code>deSilvaFreq</code>, however, is a more
advanced and accurate allele frequency estimation than what is
available in SPAGeDi v1.3.  <code>write.freq.SPAGeDi</code> exists primarily to
export allele frequencies from <code>deSilvaFreq</code>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><a href="https://ebe.ulb.ac.be/ebe/SPAGeDi.html">https://ebe.ulb.ac.be/ebe/SPAGeDi.html</a>
</p>
<p>Hardy, O. J. and Vekemans, X. (2002) SPAGeDi: a versatile computer
program to analyse spatial genetic structure at the individual or
population levels.  <em>Molecular Ecology Notes</em> <b>2</b>, 618-620.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.SPAGeDi">write.SPAGeDi</a></code>, <code><a href="#topic+deSilvaFreq">deSilvaFreq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set up a genambig object to use in this example
mygen &lt;- new("genambig", samples=c(paste("G", 1:30, sep=""),
                                   paste("R", 1:50, sep="")),
             loci=c("afrY", "ggP"))
PopNames(mygen) &lt;- c("G", "R")
PopInfo(mygen) &lt;- c(rep(1, 30), rep(2, 50))
mygen &lt;- reformatPloidies(mygen, output="one")
Ploidies(mygen) &lt;- 4
Usatnts(mygen) &lt;- c(2, 2)

# randomly create genotypes according to pre-set allele frequencies
for(s in Samples(mygen, populations=1)){
    Genotype(mygen, s, "afrY") &lt;-
        unique(sample(c(140, 142, 146, 150, 152), 4, TRUE,
                      c(.30, .12, .26, .08, .24)))
    Genotype(mygen, s, "ggP") &lt;-
        unique(sample(c(210, 214, 218, 220, 222), 4, TRUE,
                      c(.21, .13, .27, .07, .32)))
}
for(s in Samples(mygen, populations=2)){
    Genotype(mygen, s, "afrY") &lt;-
        unique(sample(c(140, 142, 144, 150, 152), 4, TRUE,
                      c(.05, .26, .17, .33, .19)))
    Genotype(mygen, s, "ggP") &lt;-
        unique(sample(c(212, 214, 220, 222, 224), 4, TRUE,
                      c(.14, .04, .36, .20, .26)))
}

# write a SPAGeDi file
write.SPAGeDi(mygen, file="SPAGdataFreqExample.txt")

# calculate allele frequenies
myfreq &lt;- deSilvaFreq(mygen, self = 0.05)

# write allele frequencies file
write.freq.SPAGeDi(myfreq, usatnts=Usatnts(mygen),
file="SPAGfreqExample.txt")

## End(Not run)


</code></pre>

<hr>
<h2 id='write.GeneMapper'>
Write Genotypes to a Table Similarly to ABI GeneMapper
</h2><span id='topic+write.GeneMapper'></span>

<h3>Description</h3>

<p>Given a <code>genambig</code> object,
<code>write.GeneMapper</code> writes a text file of a table containing columns
for sample name, locus, and alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.GeneMapper(object, file = "", samples = Samples(object),
                 loci = Loci(object))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.GeneMapper_+3A_object">object</code></td>
<td>

<p>A <code>genambig</code> object containing genotype data to write to the file.
The <code>Ploidies</code> slot is used for determining how many allele
columns to make.
</p>
</td></tr>
<tr><td><code id="write.GeneMapper_+3A_file">file</code></td>
<td>

<p>Character string.  The path to which to write the file.
</p>
</td></tr>
<tr><td><code id="write.GeneMapper_+3A_samples">samples</code></td>
<td>

<p>Character vector.  Samples to write to the file.  This should be a
subset of <code>Samples(object)</code>.
</p>
</td></tr>
<tr><td><code id="write.GeneMapper_+3A_loci">loci</code></td>
<td>

<p>Character vector.  Loci to write to the file.  This should be a subset
of <code>Loci(object)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although I do not know of any population genetic software other than
<span class="pkg">polysat</span> that will
read this data format directly, the ABI GeneMapper Genotypes Table
format is a convenient way for the user to store microsatellite
genotype data and view it in a text editor or spreadsheet software.
Each row contains the sample name, locus name, and alleles separated
by tabs.
</p>
<p>The number of allele columns needed is detected by the maximum value
of <code>Ploidies(object,samples,loci)</code>.  The function will add additional
columns if it encounters genotypes with more than this number of
alleles.
</p>
<p><code>write.GeneMapper</code> handles missing data in a very simple way, in
that it writes the missing data symbol directly to the table as though
it were an allele.  If you want missing data to be represented
differently in the table, you can open it in spreadsheet software and
use find/replace or conditional formatting to locate missing data.
</p>
<p>The file that is produced can be read back into R directly by
<code><a href="#topic+read.GeneMapper">read.GeneMapper</a></code>, and therefore may be a convenient way to backup
genotype data for future analysis and manipulation in <span class="pkg">polysat</span>.
(<code><a href="base.html#topic+save">save</a></code> can also be used to backup an R object more directly,
including population and other information.)  This can also enable the
user to edit genotype data in spreadsheet software, if the
<code><a href="#topic+editGenotypes">editGenotypes</a></code> function is not sufficient.
</p>


<h3>Value</h3>

<p>A file is written but no value is returned.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>GeneMapper website: <a href="https://www.thermofisher.com/order/catalog/product/4475073">https://www.thermofisher.com/order/catalog/product/4475073</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.GeneMapper">read.GeneMapper</a></code>, <code><a href="#topic+write.Structure">write.Structure</a></code>,
<code><a href="#topic+write.GenoDive">write.GenoDive</a></code>, <code><a href="#topic+write.Tetrasat">write.Tetrasat</a></code>,
<code><a href="#topic+write.ATetra">write.ATetra</a></code>, <code><a href="#topic+write.POPDIST">write.POPDIST</a></code>,
<code><a href="#topic+write.SPAGeDi">write.SPAGeDi</a></code>, <code><a href="#topic+editGenotypes">editGenotypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a genotype object (usually done by reading a file)
mysamples &lt;- c("ind1", "ind2", "ind3", "ind4")
myloci &lt;- c("loc1", "loc2")
mygendata &lt;- new("genambig", samples=mysamples, loci=myloci)
mygendata &lt;- reformatPloidies(mygendata, output="one")
Genotypes(mygendata, loci="loc1") &lt;- list(c(202,204), c(204),
                                          c(200,206,208,212),
                                          c(198,204,208))
Genotypes(mygendata, loci="loc2") &lt;- list(c(78,81,84),
                                          c(75,90,93,96,99),
                                          c(87), c(-9))
Ploidies(mygendata) &lt;- 6

## Not run: 
# write a GeneMapper file
write.GeneMapper(mygendata, "exampleGMoutput.txt")

# view the file with read.table
read.table("exampleGMoutput.txt", sep="\t", header=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='write.GenoDive'>
Write a File in GenoDive Format
</h2><span id='topic+write.GenoDive'></span>

<h3>Description</h3>

<p><code>write.GenoDive</code> uses data from a <code>genambig</code> object to
create a file formatted for the software GenoDive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.GenoDive(object, digits = 2, file = "",
               samples = Samples(object), loci = Loci(object))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.GenoDive_+3A_object">object</code></td>
<td>

<p>A <code>genambig</code> object containing genotypes, ploidies, population
identities, microsatellite repeat lengths, and description for the
dataset of interest.
</p>
</td></tr>
<tr><td><code id="write.GenoDive_+3A_digits">digits</code></td>
<td>

<p>An integer indicating how many digits to use to represent each allele
(usually 2 or 3).
</p>
</td></tr>
<tr><td><code id="write.GenoDive_+3A_file">file</code></td>
<td>

<p>A character string of the file path to which to write.
</p>
</td></tr>
<tr><td><code id="write.GenoDive_+3A_samples">samples</code></td>
<td>

<p>A character vector of samples to include in the file.  A subset of
<code>Samples(object)</code>.
</p>
</td></tr>
<tr><td><code id="write.GenoDive_+3A_loci">loci</code></td>
<td>

<p>A character vector of loci to include in the file.  A subset of
<code>Loci(object)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of individuals, number of populations, number of loci, and
maximum ploidy of the sample are calculated automatically and entered in
the second line of the file.  If the maximum ploidy needs to be reduced
by random removal of alleles, it is possible to do this in the software
GenoDive after importing the data.  The <code>genambig</code> object should
not have individuals with more alleles than the highest ploidy level
listed in its <code>Ploidies</code> slot.
</p>
<p>Several steps happen in order to convert alleles to the right format.
First, all instances of the missing data symbol are replaced with zero.
Alleles are then divided by the numbers provided in
<code>Usatnts(object)</code> (and rounded down if necessary) in order to
convert them from nucleotides to repeat numbers.  If the alleles are
still too big to be represented by the number of digits specified,
<code>write.GenoDive</code> repeatedly subtracts a number (<code>10^(digits-1)</code>; 10
if <code>digits=2</code>) from all alleles at a locus until the alleles are small
enough.  Alleles are then converted to characters, and a leading zero is
added to an allele if it does not have enough digits.  These alleles are
concatenated at each locus so that each sample*locus genotype is an
uninterrupted string of numbers.
</p>


<h3>Value</h3>

<p>A file is written but no value is returned.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Meirmans, P. G. and Van Tienderen P. H. (2004) GENOTYPE and GENODIVE:
two programs for the analysis of genetic diversity of asexual
organisms. <em>Molecular Ecology Notes</em> <b>4</b>, 792-794.
</p>
<p><a href="http://www.bentleydrummer.nl/software/software/GenoDive.html">http://www.bentleydrummer.nl/software/software/GenoDive.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.GenoDive">read.GenoDive</a></code>, <code><a href="#topic+write.Structure">write.Structure</a></code>,
<code><a href="#topic+write.ATetra">write.ATetra</a></code>, <code><a href="#topic+write.Tetrasat">write.Tetrasat</a></code>,
<code><a href="#topic+write.GeneMapper">write.GeneMapper</a></code>, <code><a href="#topic+write.POPDIST">write.POPDIST</a></code>,
<code><a href="#topic+write.SPAGeDi">write.SPAGeDi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up the genotype object (usually done by reading a file)
mysamples &lt;- c("Mal", "Inara", "Kaylee", "Simon", "River", "Zoe",
               "Wash", "Jayne", "Book")
myloci &lt;- c("loc1", "loc2")
mygendata &lt;- new("genambig", samples=mysamples, loci=myloci)
mygendata &lt;- reformatPloidies(mygendata, output="sample")
Genotypes(mygendata, loci="loc1") &lt;- list(c(304,306), c(302,310),
                                          c(306), c(312,314),
    c(312,314), c(308,310), c(312), c(302,308,310), c(-9))
Genotypes(mygendata, loci="loc2") &lt;- list(c(118,133), c(121,130),
                                          c(122,139), c(124,133),
    c(118,124), c(121,127), c(124,136), c(124,127,136), c(121,130))
Usatnts(mygendata) &lt;- c(2,3)
PopNames(mygendata) &lt;- c("Core","Outer Rim")
PopInfo(mygendata) &lt;- c(2,1,2,1,1,2,2,2,1)
Ploidies(mygendata) &lt;- c(2,2,2,2,2,2,2,3,2)
Description(mygendata) &lt;- "Serenity crew"

## Not run: 
# write files (use file="" to write to the console instead)
write.GenoDive(mygendata, digits=2, file="testGenoDive2.txt")
write.GenoDive(mygendata, digits=3, file="testGenoDive3.txt")

## End(Not run)

</code></pre>

<hr>
<h2 id='write.POPDIST'>
Write Genotypes to a POPDIST File
</h2><span id='topic+write.POPDIST'></span>

<h3>Description</h3>

<p><code>write.POPDIST</code> uses data from a <code>"genambig"</code> object to write
a file formatted for the software POPDIST.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.POPDIST(object, samples = Samples(object),
              loci = Loci(object), file = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.POPDIST_+3A_object">object</code></td>
<td>

<p>A <code>"genambig"</code> object.  <code>Ploidies</code> and <code>PopInfo</code> are
required, and if provided <code>Usatnts</code> may be used to convert alleles
to repeat number in order to represent each allele with two digits.
Locus names and <code>PopNames</code> are used in the file, but sample
names are not.
</p>
</td></tr>
<tr><td><code id="write.POPDIST_+3A_samples">samples</code></td>
<td>

<p>An optional character vector of samples to use.  Must be a subset of
<code>Samples(object)</code>.
</p>
</td></tr>
<tr><td><code id="write.POPDIST_+3A_loci">loci</code></td>
<td>

<p>An optional character vector of loci to use.  Must be a subset of
<code>Loci(object)</code>.
</p>
</td></tr>
<tr><td><code id="write.POPDIST_+3A_file">file</code></td>
<td>

<p>Character string.  File path to which to write.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>POPDIST is a program that calculates inter-population distance measures,
some of which are available for polyploid samples with allele copy
number ambiguity.  Each population must be of uniform ploidy, but
different populations may have different ploidies.
</p>
<p>Two types of warning messages may be printed by <code>write.POPDIST</code>.
The first indicates that a population contains individuals of more than
one ploidy.  In this case a file is still written, but POPDIST may not
be able to read it.  Separate populations with different ploidies are
okay.  The second type of warning indicates that an individual has more
alleles than its ploidy level.  If this occurs, alleles are randomly
removed from the genotype that is written to the file.
</p>
<p>If necessary, <code>write.POPDIST</code> converts alleles into a two-digit
format, similarly to <code>write.Tetrasat</code>.  If the value of any allele
for a given locus is greater than 99, the function first checks to see
if the locus has a <code>Usatnts</code> value greater than 1, and if so
divides all alleles by this value and rounds down.  If the locus still
has alleles with more than two digits, a multiple of 10 is subtracted
from all alleles.  A zero is placed in front of any allele with one digit.
</p>


<h3>Value</h3>

<p>A file is written but no value is returned.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Tomiuk, J., Guldbrandtsen, B. and Loeschcke, B.  (2009)  Genetic
similarity of polyploids: a new version of the computer program POPDIST
(version 1.2.0) considers intraspecific genetic differentiation.
<em>Molecular Ecology Resources</em> <b>9</b>, 1364-1368.
</p>
<p>Guldbrandtsen, B., Tomiuk, J. and Loeschcke, B.  (2000) POPDIST version
1.1.1: A program to calculate population genetic distance and identity
measures.  <em>Journal of Heredity</em> <b>91</b>, 178&ndash;179.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.POPDIST">read.POPDIST</a></code>, <code><a href="#topic+write.Tetrasat">write.Tetrasat</a></code>,
<code><a href="#topic+write.ATetra">write.ATetra</a></code>, <code><a href="#topic+write.SPAGeDi">write.SPAGeDi</a></code>,
<code><a href="#topic+write.GenoDive">write.GenoDive</a></code>, <code><a href="#topic+write.Structure">write.Structure</a></code>,
<code><a href="#topic+write.GeneMapper">write.GeneMapper</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a "genambig" object containing the dataset
mygen &lt;- new("genambig", samples=c("a", "b", "c", "d"),
             loci=c("loc1", "loc27"))
mygen &lt;- reformatPloidies(mygen, output="sample")
Description(mygen) &lt;- "Some example data for POPDIST"
PopInfo(mygen) &lt;- c(1,1,2,2)
PopNames(mygen) &lt;- c("Old Orchard Beach", "York Beach")
Ploidies(mygen) &lt;- c(2,2,4,4)
Usatnts(mygen) &lt;- c(2,2)
Genotypes(mygen, loci="loc1") &lt;- list(c(128, 134), c(130),
                                      Missing(mygen), c(126, 128, 132))
Genotypes(mygen, loci="loc27") &lt;- list(c(209,211), c(207,217),
                                       c(207,209,215,221), c(211,223))

## Not run: 
# write the file
write.POPDIST(mygen, file="forPOPDIST.txt")

# view the file
cat(readLines("forPOPDIST.txt"), sep="\n")

## End(Not run)


</code></pre>

<hr>
<h2 id='write.SPAGeDi'>
Write Genotypes in SPAGeDi Format
</h2><span id='topic+write.SPAGeDi'></span>

<h3>Description</h3>

<p><code>write.SPAGeDi</code> uses data contained in a <code>genambig</code> object
to create a file that can be read by the software SPAGeDi.  The
user controls how the genotypes are formatted, and can provide a data
frame of spatial coordinates for each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.SPAGeDi(object, samples = Samples(object),
              loci = Loci(object), allelesep = "/",
              digits = 2, file = "",
              spatcoord = data.frame(X = rep(1, length(samples)),
                                     Y = rep(1, length(samples)),
                                     row.names = samples))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.SPAGeDi_+3A_object">object</code></td>
<td>

<p>A <code>genambig</code> object containing genotypes, ploidies, population
identities, and microsatellite repeat lengths for the dataset of
interest.
</p>
</td></tr>
<tr><td><code id="write.SPAGeDi_+3A_samples">samples</code></td>
<td>

<p>Character vector.  Samples to write to the file.  Must be a subset of
<code>Samples(object)</code>.
</p>
</td></tr>
<tr><td><code id="write.SPAGeDi_+3A_loci">loci</code></td>
<td>

<p>Character vector.  Loci to write to the file.  Must be a subset of
<code>Loci(object)</code>.
</p>
</td></tr>
<tr><td><code id="write.SPAGeDi_+3A_allelesep">allelesep</code></td>
<td>

<p>The character that will be used to separate alleles within a genotype.
If each allele should instead be a fixed number of digits, with no
characters to delimit alleles, set <code>allelesep = ""</code>.
</p>
</td></tr>
<tr><td><code id="write.SPAGeDi_+3A_digits">digits</code></td>
<td>

<p>Integer.  The number of digits used to represent each allele.
</p>
</td></tr>
<tr><td><code id="write.SPAGeDi_+3A_file">file</code></td>
<td>

<p>A character string indicating the path to which the file should be
written.
</p>
</td></tr>
<tr><td><code id="write.SPAGeDi_+3A_spatcoord">spatcoord</code></td>
<td>

<p>Data frame.  Spatial coordinates of each sample.  Column names are used
for column names in the file.  Row names indicate sample, or if absent
it is assumed that the rows are in the same order as <code>samples</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Categories column of the SPAGeDi file that is produced contains
information from the <code>PopNames</code> and <code>PopInfo</code> slots of
<code>object</code>; the population name for each sample is written to the
column.
</p>
<p>The first line of the file contains the number of individuals, number of
categories, number of spatial coordinates, number of loci, number of
digits for coding alleles, and maximum ploidy, and is generated
automatically from the data provided.
</p>
<p>The function does not write distance intervals to the file, but instead
writes <code>0</code> to the second line.
</p>
<p>All alleles for a given locus are divided by the <code>Usatnts</code> value
for that locus, after all missing data symbols have been replaced with
zeros.  If necessary, a multiple of 10 is subtracted from all
alleles at a locus in order to get the alleles down to the right number
of digits.
</p>
<p>If a genotype has fewer alleles than the <code>Ploidies</code> value for
that sample and locus, zeros are added up to the ploidy.  If the
genotype has more
alleles than the ploidy, a random subset of alleles is used and a
warning is printed.  If the genotype has only one allele (is fully
heterozygous), then that allele is replicated to the ploidy of the
individual.  Genotypes are then concatenated into strings,
delimited by <code>allelesep</code>.  If <code>allelesep=""</code>, leading zeros
are first added to alleles as necessary to make them the right number of
digits.
</p>


<h3>Value</h3>

<p>A file is written but no value is returned.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><a href="https://ebe.ulb.ac.be/ebe/SPAGeDi.html">https://ebe.ulb.ac.be/ebe/SPAGeDi.html</a>
</p>
<p>Hardy, O. J. and Vekemans, X. (2002) SPAGeDi: a versatile computer
program to analyse spatial genetic structure at the individual or
population levels.  <em>Molecular Ecology Notes</em> <b>2</b>, 618&ndash;620.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.SPAGeDi">read.SPAGeDi</a></code>, <code><a href="#topic+write.freq.SPAGeDi">write.freq.SPAGeDi</a></code>,
<code><a href="#topic+write.GenoDive">write.GenoDive</a></code>,
<code><a href="#topic+write.Structure">write.Structure</a></code>, <code><a href="#topic+write.GeneMapper">write.GeneMapper</a></code>,
<code><a href="#topic+write.ATetra">write.ATetra</a></code>, <code><a href="#topic+write.Tetrasat">write.Tetrasat</a></code>, 
<code><a href="#topic+write.POPDIST">write.POPDIST</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up data to write (usually read from a file)
mygendata &lt;- new("genambig", samples = c("ind1","ind2","ind3","ind4"),
                 loci = c("loc1", "loc2"))
mygendata &lt;- reformatPloidies(mygendata, output="sample")
Genotypes(mygendata, samples="ind1") &lt;- list(c(102,106,108),c(207,210))
Genotypes(mygendata, samples="ind2") &lt;- list(c(104),c(204,210))
Genotypes(mygendata, samples="ind3") &lt;- list(c(100,102,108),c(201,213))
Genotypes(mygendata, samples="ind4") &lt;- list(c(102,112),c(-9))
Ploidies(mygendata) &lt;- c(3,2,2,2)
Usatnts(mygendata) &lt;- c(2,3)
PopNames(mygendata) &lt;- c("A", "B")
PopInfo(mygendata) &lt;- c(1,1,2,2)
myspatcoord &lt;- data.frame(X=c(27,29,24,30), Y=c(44,41,45,46),
                          row.names=c("ind1","ind2","ind3","ind4"))

## Not run: 
# write a file
write.SPAGeDi(mygendata, spatcoord = myspatcoord,
              file="SpagOutExample.txt")

## End(Not run)

</code></pre>

<hr>
<h2 id='write.Structure'>Write Genotypes in Structure 2.3 Format</h2><span id='topic+write.Structure'></span>

<h3>Description</h3>

<p>Given a dataset stored in a <code>genambig</code> object,
<code>write.Structure</code> produces a text file of the genotypes in a format
readable by Structure 2.2 and higher.  The user specifies the overall
ploidy of the file, while the ploidy of each sample is extracted from
the <code>genambig</code> object.  <code>PopInfo</code> and other data can
optionally be written to the file as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.Structure(object, ploidy, file="",
                samples = Samples(object), loci = Loci(object),
                writepopinfo = TRUE, extracols = NULL,
                missingout = -9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.Structure_+3A_object">object</code></td>
<td>
<p>A <code>genambig</code> object containing the data to write to
the file.  There must be non-<code>NA</code> values of <code>Ploidies</code>
(and <code>PopInfo</code> if <code>writepopinfo == TRUE</code>) for
<code>samples</code>.</p>
</td></tr>
<tr><td><code id="write.Structure_+3A_ploidy">ploidy</code></td>
<td>
<p>PLOIDY for Structure, <em>i.e.</em> how many rows per individual
to write.</p>
</td></tr>
<tr><td><code id="write.Structure_+3A_file">file</code></td>
<td>
<p>A character string specifying where the file should be written.</p>
</td></tr>
<tr><td><code id="write.Structure_+3A_samples">samples</code></td>
<td>
<p>An optional character vector listing the names of samples to be
written to the file.</p>
</td></tr>
<tr><td><code id="write.Structure_+3A_loci">loci</code></td>
<td>
<p>An optional character vector listing the names of the loci to be
written to the file.</p>
</td></tr>
<tr><td><code id="write.Structure_+3A_writepopinfo">writepopinfo</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, indicating whether to
write values from the <code>PopInfo</code> slot of <code>object</code> to the file.</p>
</td></tr>
<tr><td><code id="write.Structure_+3A_extracols">extracols</code></td>
<td>
<p>An array, with the first dimension names
corresponding to <code>samples</code>, of PopData, PopFlag, LocData, Phenotype,
or other values to be included in the extra columns in the file.</p>
</td></tr>
<tr><td><code id="write.Structure_+3A_missingout">missingout</code></td>
<td>
<p>The number used to indicate missing data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Structure 2.2 and higher can process autopolyploid microsatellite data,
although 2.3.3 or higher is recommended for its improvements on
polyploid handling.  The input format of Structure requires that
each locus take up one column and that each individual take up as
many rows as the parameter PLOIDY.  Because of the multiple rows per
sample, each sample name must be duplicated, as well as any
population, location, or phenotype data.  Partially heterozygous
genotypes also must have one arbitrary allele duplicated up to the
ploidy of the sample, and samples that have a lower ploidy than that
used in the file (for mixed polyploid data sets) must have a missing
data symbol inserted to fill in the extra rows.  Additionally, if
some samples have more alleles than PLOIDY (if you are using a lower
PLOIDY to save processing time, or if there are extra alleles from
scoring errors), some alleles must be randomly removed from the data.
<code>write.Structure</code> performs this duplication, insertion, and random
deletion of data.
</p>
<p>The sample names from <code>samples</code> will be used as row
names in the Structure file.  Each sample name should only be in the
vector <code>samples</code> once, because <code>write.Structure</code> will duplicate
the sample names a number of times as dictated by <code>ploidy</code>.
</p>
<p>In writing genotypes to the file, <code>write.Structure</code> compares the number
of alleles in the genotype, the ploidy of the sample*locus as stored in
<code>Ploidies</code>, and the ploidy of the file as stored in
<code>ploidy</code>, and does one of six things (for a given sample x and
locus loc):
</p>
<p>1) If <code>Ploidies(object,x,loc)</code> is greater than or equal to
<code>ploidy</code>, and
<code>length(Genotype(object, x, loc))</code> is equal to <code>ploidy</code>, the
genotype data are used as is.
</p>
<p>2) If <code>Ploidies(object,x,loc)</code> is greater than or equal to
<code>ploidy</code>, and
<code>length(Genotype(object, x, loc))</code> is less than <code>ploidy</code>,
the first allele is
duplicated as many times as necessary for there to be as many alleles
as <code>ploidy</code>.
</p>
<p>3) If <code>Ploidies(object,x,loc)</code> is greater than or equal to
<code>ploidy</code>, and <code>length(Genotype(object, x, loc))</code> is greater
than <code>ploidy</code>, a random sample of
the alleles, without replacement, is used as the genotype.
</p>
<p>4) If <code>Ploidies(object,x,loc)</code> is less than <code>ploidy</code>, and
<code>length(Genotype(object, x, loc))</code> is equal to
<code>Ploidies(object,x,loc)</code>, the genotype
data are used as is and missing data symbols are inserted in the extra
rows.
</p>
<p>5) If <code>Ploidies(object,x,loc)</code> is less than <code>ploidy</code>, and
<code>length(Genotype(object, x, loc))</code> is less than
<code>Ploidies(object,x,loc)</code>, the first
allele is duplicated as many times as necessary for there to be as
many alleles as <code>Ploidies(object,x,loc)</code>, and missing data symbols
are inserted in the extra rows.
</p>
<p>6) If <code>Ploidies(object,x,loc)</code> is less than <code>ploidy</code>, and
<code>length(Genotype(object, x, loc))</code> is greater than
<code>Ploidies(object,x,loc)</code>, a random
sample, without replacement, of <code>Ploidies(object)[x]</code> alleles is
used, and
missing data symbols are inserted in the extra rows. (Alleles are
removed even though there is room for them in the file.)
</p>
<p>Two of the header rows that are optional for Structure are written by
<code>write.Structure</code>.  These are &lsquo;Marker Names&rsquo;, containing the
names of loci supplied in <code>gendata</code>, and &lsquo;Recessive
Alleles&rsquo;, which contains the missing data symbol once for each locus.
This indicates to the program that all alleles are codominant with
copy number ambiguity.
</p>


<h3>Value</h3>

<p>No value is returned, but instead a file is written at the path specified.
</p>


<h3>Note</h3>

<p>If <code>extracols</code> is a character array, make sure none of the
elements contain white space.</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark</p>


<h3>References</h3>

<p><a href="https://web.stanford.edu/group/pritchardlab/structure_software/release_versions/v2.3.4/structure_doc.pdf">https://web.stanford.edu/group/pritchardlab/structure_software/release_versions/v2.3.4/structure_doc.pdf</a>
</p>
<p>Hubisz, M. J., Falush, D., Stephens, M. and Pritchard, J. K. (2009)
Inferring weak population structure with the assistance of sample
group information.  <em>Molecular Ecology Resources</em> <b>9</b>, 1322-1332.
</p>
<p>Falush, D., Stephens, M. and Pritchard, J. K.  (2007)
Inferences of population structure using multilocus genotype data:
dominant markers and null alleles.  <em>Molecular Ecology Notes</em>
<b>7</b>, 574-578.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.Structure">read.Structure</a></code>, <code><a href="#topic+write.GeneMapper">write.GeneMapper</a></code>,
<code><a href="#topic+write.GenoDive">write.GenoDive</a></code>, <code><a href="#topic+write.SPAGeDi">write.SPAGeDi</a></code>,
<code><a href="#topic+write.ATetra">write.ATetra</a></code>, <code><a href="#topic+write.Tetrasat">write.Tetrasat</a></code>,
<code><a href="#topic+write.POPDIST">write.POPDIST</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># input genotype data (this is usually done by reading a file)
mygendata &lt;- new("genambig", samples = c("ind1","ind2","ind3",
                                         "ind4","ind5","ind6"),
                 loci = c("locus1","locus2"))
Genotypes(mygendata) &lt;- array(list(c(100,102,106,108,114,118),c(102,110),
                      c(98,100,104,108,110,112,116),c(102,106,112,118),
                      c(104,108,110),c(-9),
                      c(204),c(206,208,210,212,220,224,226),
                      c(202,206,208,212,214,218),c(200,204,206,208,212),
                      c(-9),c(202,206)),
                 dim=c(6,2))
Ploidies(mygendata) &lt;- c(6,6,6,4,4,4)
# Note that some of the above genotypes have more or fewer alleles than
# the ploidy of the sample.

# create a vector of sample names to be used.  Note that this excludes
#  ind6.
mysamples &lt;- c("ind1","ind2","ind3","ind4","ind5")

# Create an array containing data for additional columns to be written
# to the file.  You might also prefer to just read this and the ploidies
# in from a file.
myexcols &lt;- array(data=c(1,2,1,2,1,1,1,0,0,0),dim=c(5,2),
                  dimnames=list(mysamples, c("PopData","PopFlag")))

# Write the Structure file, with six rows per individual.
# Since outfile="", the data will be written to the console instead of a file.
write.Structure(mygendata, 6, "", samples = mysamples, writepopinfo = FALSE,
                extracols = myexcols)
</code></pre>

<hr>
<h2 id='write.Tetrasat'>
Write Genotype Data in Tetrasat Format
</h2><span id='topic+write.Tetrasat'></span>

<h3>Description</h3>

<p>Given a <code>genambig</code> object,
<code>write.Tetrasat</code> creates a file that can be read by the software
Tetrasat and Tetra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.Tetrasat(object, samples = Samples(object),
               loci = Loci(object), file = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.Tetrasat_+3A_object">object</code></td>
<td>

<p>A <code>genambig</code> object containing the dataset of interest.  Genotypes,
population identities, microsatellite repeat lengths, and the dataset
description of <code>object</code> are used by the function.
</p>
</td></tr>
<tr><td><code id="write.Tetrasat_+3A_samples">samples</code></td>
<td>

<p>A character vector of samples to write to the file.  Should be a subset
of <code>Samples(object)</code>.
</p>
</td></tr>
<tr><td><code id="write.Tetrasat_+3A_loci">loci</code></td>
<td>

<p>A character vector of loci to write to the file.  Should be a subset of
<code>Loci(object)</code>.
</p>
</td></tr>
<tr><td><code id="write.Tetrasat_+3A_file">file</code></td>
<td>

<p>A character string indicating the file to which to write.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tetrasat files are space-delimited text files in which all alleles at a
locus are concatenated into a string eight characters long.  Population
names or numbers are not used in the file, but samples are ordered by
population, with the line &ldquo;Pop&rdquo; delimiting populations.
</p>
<p><code>write.Tetrasat</code> divides each allele by the length of the repeat and
rounds down in order to convert alleles to repeat numbers.  If
necessary, it subtracts a multiple of 10 from all alleles at a locus to
make all allele values less than 100, or puts a zero in front of the
number if it only has one digit.  If the individual is fully homozygous
at a locus, the single allele is repeated four times.  If any genotype
has more than four alleles, <code>write.Tetrasat</code> picks a random sample of
four alleles without replacement, and prints a warning.  Missing data
are represented by blank spaces.
</p>
<p>Sample names should be a maximum of 20 characters long in order for the
file to be read correctly by Tetrasat or Tetra.
</p>


<h3>Value</h3>

<p>A file is written but no value is returned.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Markwith, S. H., Stewart, D. J. and Dyer, J. L.  (2006)
TETRASAT: a program for the population analysis of
allotetraploid microsatellite data. <em>Molecular Ecology Notes</em>
<b>6</b>, 586-589.
</p>
<p>Liao, W. J., Zhu, B. R., Zeng, Y. F. and Zhang, D. Y.  (2008)
TETRA: an improved program for population genetic analysis of
allotetraploid microsatellite data.  <em>Molecular Ecology Resources</em>
<b>8</b>, 1260&ndash;1262.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.Tetrasat">read.Tetrasat</a></code>,
<code><a href="#topic+write.GeneMapper">write.GeneMapper</a></code>, <code><a href="#topic+write.ATetra">write.ATetra</a></code>,
<code><a href="#topic+write.POPDIST">write.POPDIST</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up sample data (usually done by reading files)
mysamples &lt;- c("ind1", "ind2", "ind3", "ind4")
myloci &lt;- c("loc1", "loc2")
mygendata &lt;- new("genambig", samples = mysamples, loci = myloci)
mygendata &lt;- reformatPloidies(mygendata, output="one")
Usatnts(mygendata) &lt;- c(2, 3)
Genotypes(mygendata, loci="loc1") &lt;- list(c(202,204), c(204),
                                          c(200,206,208,212),
                                          c(198,204,208))
Genotypes(mygendata, loci="loc2") &lt;- list(c(78,81,84),
                                          c(75,90,93,96,99),
                                          c(87), c(-9))
PopInfo(mygendata) &lt;- c(1,2,1,2)
Description(mygendata) &lt;- "An example for write.Tetrasat."
Ploidies(mygendata) &lt;- 4

## Not run: 
# write a Tetrasat file
write.Tetrasat(mygendata, file="tetrasattest.txt")

# view the file
cat(readLines("tetrasattest.txt"),sep="\n")

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
