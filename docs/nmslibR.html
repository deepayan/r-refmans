<!DOCTYPE html><html><head><title>Help for package nmslibR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nmslibR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#import_internal'><p>import internal functions from the KernelKnn package</p></a></li>
<li><a href='#inner_kernel_function'><p>inner function to compute kernels, extract weights and return predictions</p></a></li>
<li><a href='#KernelKnn_nmslib'><p>Approximate Kernel k nearest neighbors using the nmslib library</p></a></li>
<li><a href='#KernelKnnCV_nmslib'><p>Approximate Kernel k nearest neighbors (cross-validated) using the nmslib library</p></a></li>
<li><a href='#mat_2scipy_sparse'><p>conversion of an R matrix to a scipy sparse matrix</p></a></li>
<li><a href='#NMSlib'><p>Non metric space library</p></a></li>
<li><a href='#TO_scipy_sparse'><p>conversion of an R sparse matrix to a scipy sparse matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Non Metric Space (Approximate) Library</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-01</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlampros/nmslibR/issues">https://github.com/mlampros/nmslibR/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlampros/nmslibR">https://github.com/mlampros/nmslibR</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A Non-Metric Space Library ('NMSLIB' <a href="https://github.com/nmslib/nmslib">https://github.com/nmslib/nmslib</a>) wrapper, which according to the authors "is an efficient cross-platform similarity search library and a toolkit for evaluation of similarity search methods. The goal of the 'NMSLIB' <a href="https://github.com/nmslib/nmslib">https://github.com/nmslib/nmslib</a> Library is to create an effective and comprehensive toolkit for searching in generic non-metric spaces. Being comprehensive is important, because no single method is likely to be sufficient in all cases. Also note that exact solutions are hardly efficient in high dimensions and/or non-metric spaces. Hence, the main focus is on approximate methods". The wrapper also includes Approximate Kernel k-Nearest-Neighbor functions based on the 'NMSLIB' <a href="https://github.com/nmslib/nmslib">https://github.com/nmslib/nmslib</a> 'Python' Library.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2.0)</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>python3-dev: apt-get install -y python3-dev (deb),
python3-pip: apt-get install -y python3-pip (deb), numpy: pip3
install numpy (deb), scipy: pip3 install scipy (deb), nmslib:
pip3 install --no-binary :all: nmslib (deb)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.2.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.7), reticulate, R6, Matrix, KernelKnn, utils,
lifecycle</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.8.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/reticulate:</td>
<td>list( packages = list( list(package = "nmslib", pip
= TRUE), list(package = "scipy", pip = TRUE) ) )</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-01 19:08:34 UTC; lampros</td>
</tr>
<tr>
<td>Author:</td>
<td>Lampros Mouselimis
    <a href="https://orcid.org/0000-0002-8024-1546"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  B. Naidan [cph] (Author of the Non-Metric Space Library (NMSLIB)),
  L. Boytsov [cph] (Author of the Non-Metric Space Library (NMSLIB)),
  Yu. Malkov [cph] (Author of the Non-Metric Space Library (NMSLIB)),
  B. Frederickson [cph] (Author of the Non-Metric Space Library (NMSLIB)),
  D. Novak [cph] (Author of the Non-Metric Space Library (NMSLIB))</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lampros Mouselimis &lt;mouselimislampros@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-01 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='import_internal'>import internal functions from the KernelKnn package</h2><span id='topic+import_internal'></span>

<h3>Description</h3>

<p>import internal functions from the KernelKnn package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_internal(function_name)
</code></pre>

<hr>
<h2 id='inner_kernel_function'>inner function to compute kernels, extract weights and return predictions</h2><span id='topic+inner_kernel_function'></span>

<h3>Description</h3>

<p>inner function to compute kernels, extract weights and return predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_kernel_function(y_matrix, dist_matrix, Levels, weights_function, h)
</code></pre>

<hr>
<h2 id='KernelKnn_nmslib'>Approximate Kernel k nearest neighbors using the nmslib library</h2><span id='topic+KernelKnn_nmslib'></span>

<h3>Description</h3>

<p>Approximate Kernel k nearest neighbors using the nmslib library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KernelKnn_nmslib(
  data,
  y,
  TEST_data = NULL,
  k = 5,
  h = 1,
  weights_function = NULL,
  Levels = NULL,
  Index_Params = NULL,
  Time_Params = NULL,
  space = "l1",
  space_params = NULL,
  method = "hnsw",
  data_type = "DENSE_VECTOR",
  dtype = "FLOAT",
  index_filepath = NULL,
  print_progress = FALSE,
  num_threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KernelKnn_nmslib_+3A_data">data</code></td>
<td>
<p>either a matrix or a scipy sparse matrix</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_y">y</code></td>
<td>
<p>a numeric vector specifying the response variable (in classification the labels must be numeric from 1:Inf). The length of <em>y</em> must equal the rows of the <em>data</em> parameter</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_test_data">TEST_data</code></td>
<td>
<p>a test dataset (in case of a matrix the <em>TEST_data</em> should have equal number of columns with the <em>data</em>). It is assumed that the <em>TEST_data</em> is an unlabeled dataset</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_k">k</code></td>
<td>
<p>an integer. The number of neighbours to return</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_h">h</code></td>
<td>
<p>the bandwidth (applicable if the weights_function is not NULL, defaults to 1.0)</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_weights_function">weights_function</code></td>
<td>
<p>there are various ways of specifying the kernel function. See the details section.</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_levels">Levels</code></td>
<td>
<p>a numeric vector. In case of classification the unique levels of the response variable are necessary</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_index_params">Index_Params</code></td>
<td>
<p>a list of (optional) parameters to use in indexing (when creating the index)</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_time_params">Time_Params</code></td>
<td>
<p>a list of parameters to use in querying. Setting <em>Time_Params</em> to NULL will reset</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_space">space</code></td>
<td>
<p>a character string (optional). The metric space to create for this index. Page 31 of the manual (see <em>references</em>) explains all available inputs</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_space_params">space_params</code></td>
<td>
<p>a list of (optional) parameters for configuring the space. See the <em>references</em> manual for more details.</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_method">method</code></td>
<td>
<p>a character string specifying the index method to use</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_data_type">data_type</code></td>
<td>
<p>a character string. One of 'DENSE_UINT8_VECTOR', 'DENSE_VECTOR', 'OBJECT_AS_STRING' or 'SPARSE_VECTOR'</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_dtype">dtype</code></td>
<td>
<p>a character string. Either 'FLOAT' or 'INT'</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_index_filepath">index_filepath</code></td>
<td>
<p>a character string specifying the path to a file, where an existing index is saved</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_print_progress">print_progress</code></td>
<td>
<p>a boolean (either TRUE or FALSE). Whether or not to display progress bar</p>
</td></tr>
<tr><td><code id="KernelKnn_nmslib_+3A_num_threads">num_threads</code></td>
<td>
<p>an integer. The number of threads to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three possible ways to specify the <em>weights function</em>, 1st option : if the weights_function is NULL then a simple k-nearest-neighbor is performed. 2nd option : the weights_function is one of 'uniform', 'triangular', 'epanechnikov', 'biweight', 'triweight', 'tricube', 'gaussian', 'cosine', 'logistic', 'gaussianSimple', 'silverman', 'inverse', 'exponential'. The 2nd option can be extended by combining kernels from the existing ones (adding or multiplying). For instance, I can multiply the tricube with the gaussian kernel by giving 'tricube_gaussian_MULT' or I can add the previously mentioned kernels by giving 'tricube_gaussian_ADD'. 3rd option : a user defined kernel function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
  if (reticulate::py_available(initialize = FALSE)) {
    if (reticulate::py_module_available("nmslib")) {

      library(nmslibR)

      x = matrix(runif(1000), nrow = 100, ncol = 10)

      y = runif(100)

      out = KernelKnn_nmslib(data = x, y = y, k = 5)
    }
  }
}, silent=TRUE)
</code></pre>

<hr>
<h2 id='KernelKnnCV_nmslib'>Approximate Kernel k nearest neighbors (cross-validated) using the nmslib library</h2><span id='topic+KernelKnnCV_nmslib'></span>

<h3>Description</h3>

<p>Approximate Kernel k nearest neighbors (cross-validated) using the nmslib library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KernelKnnCV_nmslib(
  data,
  y,
  k = 5,
  folds = 5,
  h = 1,
  weights_function = NULL,
  Levels = NULL,
  Index_Params = NULL,
  Time_Params = NULL,
  space = "l1",
  space_params = NULL,
  method = "hnsw",
  data_type = "DENSE_VECTOR",
  dtype = "FLOAT",
  index_filepath = NULL,
  print_progress = FALSE,
  num_threads = 1,
  seed_num = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KernelKnnCV_nmslib_+3A_data">data</code></td>
<td>
<p>a numeric matrix</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_y">y</code></td>
<td>
<p>a numeric vector specifying the response variable (in classification the labels must be numeric from 1:Inf). The length of <em>y</em> must equal the rows of the <em>data</em> parameter</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_k">k</code></td>
<td>
<p>an integer. The number of neighbours to return</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_folds">folds</code></td>
<td>
<p>the number of cross validation folds (must be greater than 1)</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_h">h</code></td>
<td>
<p>the bandwidth (applicable if the weights_function is not NULL, defaults to 1.0)</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_weights_function">weights_function</code></td>
<td>
<p>there are various ways of specifying the kernel function. See the details section.</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_levels">Levels</code></td>
<td>
<p>a numeric vector. In case of classification the unique levels of the response variable are necessary</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_index_params">Index_Params</code></td>
<td>
<p>a list of (optional) parameters to use in indexing (when creating the index)</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_time_params">Time_Params</code></td>
<td>
<p>a list of parameters to use in querying. Setting <em>Time_Params</em> to NULL will reset</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_space">space</code></td>
<td>
<p>a character string (optional). The metric space to create for this index. Page 31 of the manual (see <em>references</em>) explains all available inputs</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_space_params">space_params</code></td>
<td>
<p>a list of (optional) parameters for configuring the space. See the <em>references</em> manual for more details.</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_method">method</code></td>
<td>
<p>a character string specifying the index method to use</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_data_type">data_type</code></td>
<td>
<p>a character string. One of 'DENSE_UINT8_VECTOR', 'DENSE_VECTOR', 'OBJECT_AS_STRING' or 'SPARSE_VECTOR'</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_dtype">dtype</code></td>
<td>
<p>a character string. Either 'FLOAT' or 'INT'</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_index_filepath">index_filepath</code></td>
<td>
<p>a character string specifying the path to a file, where an existing index is saved</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_print_progress">print_progress</code></td>
<td>
<p>a boolean (either TRUE or FALSE). Whether or not to display progress bar</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_num_threads">num_threads</code></td>
<td>
<p>an integer. The number of threads to use</p>
</td></tr>
<tr><td><code id="KernelKnnCV_nmslib_+3A_seed_num">seed_num</code></td>
<td>
<p>a numeric value specifying the seed of the random number generator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three possible ways to specify the <em>weights function</em>, 1st option : if the weights_function is NULL then a simple k-nearest-neighbor is performed. 2nd option : the weights_function is one of 'uniform', 'triangular', 'epanechnikov', 'biweight', 'triweight', 'tricube', 'gaussian', 'cosine', 'logistic', 'gaussianSimple', 'silverman', 'inverse', 'exponential'. The 2nd option can be extended by combining kernels from the existing ones (adding or multiplying). For instance, I can multiply the tricube with the gaussian kernel by giving 'tricube_gaussian_MULT' or I can add the previously mentioned kernels by giving 'tricube_gaussian_ADD'. 3rd option : a user defined kernel function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

x = matrix(runif(1000), nrow = 100, ncol = 10)

y = runif(100)

out = KernelKnnCV_nmslib(x, y, k = 5, folds = 5)


## End(Not run)
</code></pre>

<hr>
<h2 id='mat_2scipy_sparse'>conversion of an R matrix to a scipy sparse matrix</h2><span id='topic+mat_2scipy_sparse'></span>

<h3>Description</h3>

<p>conversion of an R matrix to a scipy sparse matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_2scipy_sparse(x, format = "sparse_row_matrix")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat_2scipy_sparse_+3A_x">x</code></td>
<td>
<p>a data matrix</p>
</td></tr>
<tr><td><code id="mat_2scipy_sparse_+3A_format">format</code></td>
<td>
<p>a character string. Either <em>&quot;sparse_row_matrix&quot;</em> or <em>&quot;sparse_column_matrix&quot;</em></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the user to convert an R matrix to a scipy sparse matrix. This is useful because the <em>nmslibR</em> package accepts only <em>python</em> sparse matrices as input.
</p>


<h3>References</h3>

<p>https://docs.scipy.org/doc/scipy/reference/sparse.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
  if (reticulate::py_available(initialize = FALSE)) {
    if (reticulate::py_module_available("scipy")) {

      library(nmslibR)

      set.seed(1)

      x = matrix(runif(1000), nrow = 100, ncol = 10)

      res = mat_2scipy_sparse(x)

      print(dim(x))

      print(res$shape)
    }
  }
}, silent=TRUE)
</code></pre>

<hr>
<h2 id='NMSlib'>Non metric space library</h2><span id='topic+NMSlib'></span>

<h3>Description</h3>

<p>Non metric space library
</p>
<p>Non metric space library
</p>


<h3>Usage</h3>

<pre><code class='language-R'># init &lt;- NMSlib$new(input_data, Index_Params = NULL, Time_Params = NULL,
#                           space='l1', space_params = NULL, method = 'hnsw',
#                           data_type = 'DENSE_VECTOR', dtype = 'FLOAT',
#                           index_filepath = NULL, load_data = FALSE,
#                           print_progress = FALSE)
</code></pre>


<h3>Details</h3>

<p><em>input_data</em> parameter : In case of numeric data the <em>input_data</em> parameter should be either an R matrix object or a scipy sparse matrix. Additionally, the <em>input_data</em> parameter can be a list including more than one matrices / sparse-matrices having the same number of columns ( this is ideal for instance if the user wants to include both a train and a test dataset in the created index )
</p>
<p>the <em>Knn_Query</em> function finds the approximate K nearest neighbours of a vector in the index
</p>
<p>the <em>knn_Query_Batch</em> Performs multiple queries on the index, distributing the work over a thread pool
</p>
<p>the <em>save_Index</em> function saves the index to disk
</p>
<p>If the <em>index_filepath</em> parameter is not NULL then an existing index will be loaded
</p>
<p><em>Incrementally</em> updating an already saved (and loaded) index is <em>not</em> possible (see: https://github.com/nmslib/nmslib/issues/73)
</p>


<h3>Methods</h3>


<dl>
<dt><code>NMSlib$new(input_data, Index_Params = NULL, Time_Params = NULL, space='l1',
                        space_params = NULL, method = 'hnsw', data_type = 'DENSE_VECTOR',
                        dtype = 'FLOAT', index_filepath = NULL, load_data = FALSE,
                        print_progress = FALSE)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Knn_Query(query_data_row, k = 5)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>knn_Query_Batch(query_data, k = 5, num_threads = 1)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>save_Index(filename, save_data = FALSE)</code></dt><dd></dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>NMSlib$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Knn_Query"><code>NMSlib$Knn_Query()</code></a>
</p>
</li>
<li> <p><a href="#method-knn_Query_Batch"><code>NMSlib$knn_Query_Batch()</code></a>
</p>
</li>
<li> <p><a href="#method-save_Index"><code>NMSlib$save_Index()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>NMSlib$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>NMSlib$new(
  input_data,
  Index_Params = NULL,
  Time_Params = NULL,
  space = "l1",
  space_params = NULL,
  method = "hnsw",
  data_type = "DENSE_VECTOR",
  dtype = "FLOAT",
  index_filepath = NULL,
  load_data = FALSE,
  print_progress = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input_data</code></dt><dd><p>the input data. See <em>details</em> for more information</p>
</dd>
<dt><code>Index_Params</code></dt><dd><p>a list of (optional) parameters to use in indexing (when creating the index)</p>
</dd>
<dt><code>Time_Params</code></dt><dd><p>a list of parameters to use in querying. Setting <em>Time_Params</em> to NULL will reset</p>
</dd>
<dt><code>space</code></dt><dd><p>a character string (optional). The metric space to create for this index. Page 31 of the manual (see <em>references</em>) explains all available inputs</p>
</dd>
<dt><code>space_params</code></dt><dd><p>a list of (optional) parameters for configuring the space. See the <em>references</em> manual for more details.</p>
</dd>
<dt><code>method</code></dt><dd><p>a character string specifying the index method to use</p>
</dd>
<dt><code>data_type</code></dt><dd><p>a character string. One of 'DENSE_UINT8_VECTOR', 'DENSE_VECTOR', 'OBJECT_AS_STRING' or 'SPARSE_VECTOR'</p>
</dd>
<dt><code>dtype</code></dt><dd><p>a character string. Either 'FLOAT' or 'INT'</p>
</dd>
<dt><code>index_filepath</code></dt><dd><p>a character string specifying the path to a file, where an existing index is saved</p>
</dd>
<dt><code>load_data</code></dt><dd><p>a boolean. If TRUE then besides the index also the saved data will be loaded. This parameter is used when the <em>index_filepath</em> parameter is not NULL (see the web links in the <em>references</em> section for more details). The user might also have to specify the <em>skip_optimized_index</em> parameter of the <em>Index_Params</em> in the &quot;init&quot; method</p>
</dd>
<dt><code>print_progress</code></dt><dd><p>a boolean (either TRUE or FALSE). Whether or not to display progress bar</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Knn_Query"></a>



<h4>Method <code>Knn_Query()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>NMSlib$Knn_Query(query_data_row, k = 5, include_query_data_row_index = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query_data_row</code></dt><dd><p>a vector to query for</p>
</dd>
<dt><code>k</code></dt><dd><p>an integer. The number of neighbours to return</p>
</dd>
<dt><code>include_query_data_row_index</code></dt><dd><p>a boolean. If TRUE then the index of the query data row will be returned as well. It currently defaults to FALSE which means the first matched index is excluded from the results (this parameter will be removed in version 1.1.0 and the output behavior of the function will be changed too - see the deprecation warning)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-knn_Query_Batch"></a>



<h4>Method <code>knn_Query_Batch()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>NMSlib$knn_Query_Batch(query_data, k = 5, num_threads = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query_data</code></dt><dd><p>the query_data parameter should be of the same type with the <em>input_data</em> parameter. Queries to query for</p>
</dd>
<dt><code>k</code></dt><dd><p>an integer. The number of neighbours to return</p>
</dd>
<dt><code>num_threads</code></dt><dd><p>an integer. The number of threads to use</p>
</dd>
</dl>

</div>


<hr>
<a id="method-save_Index"></a>



<h4>Method <code>save_Index()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>NMSlib$save_Index(filename, save_data = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>a character string specifying the path. The filename to save ( in case of the <em>save_Index</em> method ) or the filename to load ( in case of the <em>load_Index</em> method )</p>
</dd>
<dt><code>save_data</code></dt><dd><p>a boolean. If TRUE then besides the index also the data will be saved (see the web links in the <em>references</em> section for more details)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NMSlib$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://github.com/nmslib/nmslib/blob/master/manual/latex/manual.pdf
</p>
<p>https://github.com/nmslib/nmslib/blob/master/python_bindings/notebooks/search_vector_dense_optim.ipynb
</p>
<p>https://github.com/nmslib/nmslib/blob/master/python_bindings/notebooks/search_vector_dense_nonoptim.ipynb
</p>
<p>https://github.com/nmslib/nmslib/issues/356
</p>
<p>https://github.com/nmslib/nmslib/blob/master/manual/methods.md
</p>
<p>https://github.com/nmslib/nmslib/blob/master/manual/spaces.md
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
  if (reticulate::py_available(initialize = FALSE)) {
    if (reticulate::py_module_available("nmslib")) {

      library(nmslibR)

      set.seed(1)
      x = matrix(runif(1000), nrow = 100, ncol = 10)

      init_nms = NMSlib$new(input_data = x)


      # returns a 1-dimensional vector (index, distance)
      #--------------------------------------------------

      init_nms$Knn_Query(query_data_row = x[1, ], k = 5)


      # returns knn's for all data
      #---------------------------

      all_dat = init_nms$knn_Query_Batch(x, k = 5, num_threads = 1)
    }
  }
}, silent=TRUE)
</code></pre>

<hr>
<h2 id='TO_scipy_sparse'>conversion of an R sparse matrix to a scipy sparse matrix</h2><span id='topic+TO_scipy_sparse'></span>

<h3>Description</h3>

<p>conversion of an R sparse matrix to a scipy sparse matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TO_scipy_sparse(R_sparse_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TO_scipy_sparse_+3A_r_sparse_matrix">R_sparse_matrix</code></td>
<td>
<p>an R sparse matrix. Acceptable input objects are either a <em>dgCMatrix</em> or a <em>dgRMatrix</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the user to convert either an R <em>dgCMatrix</em> or a <em>dgRMatrix</em> to a scipy sparse matrix (<em>scipy.sparse.csc_matrix</em> or <em>scipy.sparse.csr_matrix</em>). This is useful because the <em>nmslibR</em> package accepts besides an R dense matrix also python sparse matrices as input.
</p>
<p>The <em>dgCMatrix</em> class is a class of sparse numeric matrices in the compressed, sparse, <em>column-oriented format</em>. The <em>dgRMatrix</em> class is a class of sparse numeric matrices in the compressed, sparse, <em>column-oriented format</em>.
</p>


<h3>References</h3>

<p>https://stat.ethz.ch/R-manual/R-devel/library/Matrix/html/dgCMatrix-class.html, https://stat.ethz.ch/R-manual/R-devel/library/Matrix/html/dgRMatrix-class.html, https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.html#scipy.sparse.csc_matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
  if (reticulate::py_available(initialize = FALSE)) {
    if (reticulate::py_module_available("scipy")) {

      if (Sys.info()["sysname"] != 'Darwin') {

        library(nmslibR)


        # 'dgCMatrix' sparse matrix
        #--------------------------

        data = c(1, 0, 2, 0, 0, 3, 4, 5, 6)

        dgcM = Matrix::Matrix(data = data, nrow = 3,

                              ncol = 3, byrow = TRUE,

                              sparse = TRUE)

        print(dim(dgcM))

        res = TO_scipy_sparse(dgcM)

        print(res$shape)


        # 'dgRMatrix' sparse matrix
        #--------------------------

        dgrM = as(dgcM, "RsparseMatrix")

        print(dim(dgrM))

        res_dgr = TO_scipy_sparse(dgrM)

        print(res_dgr$shape)
      }
    }
  }
}, silent=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
