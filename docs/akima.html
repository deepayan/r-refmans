<!DOCTYPE html><html lang="en"><head><title>Help for package akima</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {akima}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#akima'>
<p>Waveform Distortion Data for Bivariate Interpolation</p></a></li>
<li><a href='#akima760'>
<p>Sample data from Akima's Bicubic Spline Interpolation code (TOMS 760)</p></a></li>
<li><a href='#aspline'><p>Univariate Akima interpolation</p></a></li>
<li><a href='#bicubic'>
<p>Bivariate Interpolation for Data on a Rectangular grid</p></a></li>
<li><a href='#bicubic.grid'>
<p>Bicubic Interpolation for Data on a Rectangular grid</p></a></li>
<li><a href='#bilinear'>
<p>Bilinear Interpolation for Data on a Rectangular grid</p></a></li>
<li><a href='#bilinear.grid'>
<p>Bilinear Interpolation for Data on a Rectangular grid</p></a></li>
<li><a href='#franke.data'>
<p>Test datasets from Franke for interpolation of scattered data</p></a></li>
<li><a href='#interp'><p>Gridded Bivariate Interpolation for Irregular Data</p></a></li>
<li><a href='#interp.old'><p>Gridded Bivariate Interpolation for Irregular Data</p></a></li>
<li><a href='#interp2xyz'><p>From interp() Result, Produce 3-column Matrix</p></a></li>
<li><a href='#interpp'>
<p>Pointwise Bivariate Interpolation for Irregular Data</p></a></li>
<li><a href='#interpp.old'>
<p>Pointwise Bivariate Interpolation for Irregular Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.6-3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-25</td>
</tr>
<tr>
<td>Title:</td>
<td>Interpolation of Irregularly and Regularly Spaced Data</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Several cubic spline interpolation methods of H. Akima for irregular and
  regular gridded data are available through this package, both for the bivariate case
  (irregular data: ACM 761, regular data: ACM 760) and univariate case (ACM 433 and ACM 697).
  Linear interpolation of irregular gridded data is also covered by reusing D. J. Renkas
  triangulation code which is part of Akimas Fortran code. A bilinear interpolator
  for regular grids was also added for comparison with the bicubic interpolator on
  regular grids.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.acm.org/publications/policies/software-copyright-notice">ACM</a> | file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sp</td>
</tr>
<tr>
<td>Enhances:</td>
<td>tripack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-26 13:46:13 UTC; agebhard</td>
</tr>
<tr>
<td>Author:</td>
<td>Hiroshi Akima [aut, cph] (Fortran code (TOMS 760, 761, 697 and 433)),
  Albrecht Gebhardt [aut, cre, cph] (R port (interp*, bicubic*
    functions), bilinear code),
  Thomas Petzold [ctb, cph] (aspline function),
  Martin Maechler [ctb, cph] (interp2xyz function + enhancements),
  YYYY Association for Computing Machinery, Inc. [cph] (covers code from
    TOMS 760, 761, 697 and 433)</td>
</tr>
<tr>
<td>License_restricts_use:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-27 13:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='akima'>
Waveform Distortion Data for Bivariate Interpolation
</h2><span id='topic+akima'></span>

<h3>Description</h3>

<p><code>akima</code> is a list with components <code>x</code>, <code>y</code> and <code>z</code> which
represents a smooth surface of <code>z</code> values at selected points
irregularly distributed in the <code>x-y</code> plane.
</p>
<p>The data was taken from a study of waveform distortion in
electronic circuits, described in:
Hiroshi Akima, &quot;A Method of Bivariate Interpolation and
Smooth Surface Fitting Based on Local Procedures&quot;, 
CACM,
Vol. 17, No. 1, January 1974, pp. 18-20.
</p>


<h3>References</h3>

<p>Hiroshi Akima, &quot;A Method of Bivariate Interpolation and
Smooth Surface Fitting for Irregularly Distributed Data
Points&quot;, 
ACM Transactions on Mathematical Software,
Vol. 4, No. 2, June 1978, pp. 148-159.
Copyright 1978, Association for Computing Machinery, Inc.,
reprinted by permission.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rgl)
data(akima)
# data
rgl.spheres(akima$x,akima$z , akima$y,0.5,color="red")
rgl.bbox()
# bivariate linear interpolation
# interp:
akima.li &lt;- interp(akima$x, akima$y, akima$z, 
                   xo=seq(min(akima$x), max(akima$x), length = 100),
                   yo=seq(min(akima$y), max(akima$y), length = 100))
# interp surface:
rgl.surface(akima.li$x,akima.li$y,akima.li$z,color="green",alpha=c(0.5))
# interpp:
akima.p &lt;- interpp(akima$x, akima$y, akima$z,
                    runif(200,min(akima$x),max(akima$x)),
                    runif(200,min(akima$y),max(akima$y)))
# interpp points:
rgl.points(akima.p$x,akima.p$z , akima.p$y,size=4,color="yellow")

# bivariate spline interpolation
# data
rgl.spheres(akima$x,akima$z , akima$y,0.5,color="red")
rgl.bbox()
# bivariate cubic spline interpolation
# interp:
akima.si &lt;- interp(akima$x, akima$y, akima$z, 
                   xo=seq(min(akima$x), max(akima$x), length = 100),
                   yo=seq(min(akima$y), max(akima$y), length = 100),
                   linear = FALSE, extrap = TRUE)
# interp surface:
rgl.surface(akima.si$x,akima.si$y,akima.si$z,color="green",alpha=c(0.5))
# interpp:
akima.sp &lt;- interpp(akima$x, akima$y, akima$z,
                    runif(200,min(akima$x),max(akima$x)),
                    runif(200,min(akima$y),max(akima$y)),
                   linear = FALSE, extrap = TRUE)
# interpp points:
rgl.points(akima.sp$x,akima.sp$z , akima.sp$y,size=4,color="yellow")


## End(Not run)
</code></pre>

<hr>
<h2 id='akima760'>
Sample data from Akima's Bicubic Spline Interpolation code (TOMS 760)
</h2><span id='topic+akima760'></span>

<h3>Description</h3>

<p><code>akima760</code> is a list with vector components <code>x</code>, <code>y</code> and a matrix <code>z</code> which
represents a smooth surface of <code>z</code> values at the points
of a regular grid spanned by the vectors <code>x</code> and <code>y</code>.
</p>


<h3>References</h3>

<p>Hiroshi Akima, &quot;
</p>
<p>&quot;, 
ACM Transactions on Mathematical Software,
Vol. 22, No. 3, September 1996, pp. 357-361.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rgl)
data(akima)
# data
rgl.spheres(akima760$x,akima760$z , akima760$y,0.5,color="red")
rgl.bbox()
# bivariate linear interpolation
# interp:
akima.li &lt;- interp(akima$x, akima$y, akima$z, 
                   xo=seq(min(akima$x), max(akima$x), length = 100),
                   yo=seq(min(akima$y), max(akima$y), length = 100))
# interp surface:
rgl.surface(akima.li$x,akima.li$y,akima.li$z,color="green",alpha=c(0.5))
# interpp:
akima.p &lt;- interpp(akima$x, akima$y, akima$z,
                    runif(200,min(akima$x),max(akima$x)),
                    runif(200,min(akima$y),max(akima$y)))
# interpp points:
rgl.points(akima.p$x,akima.p$z , akima.p$y,size=4,color="yellow")

# bivariate spline interpolation
# data
rgl.spheres(akima$x,akima$z , akima$y,0.5,color="red")
rgl.bbox()
# bivariate cubic spline interpolation
# interp:
akima.si &lt;- interp(akima$x, akima$y, akima$z, 
                   xo=seq(min(akima$x), max(akima$x), length = 100),
                   yo=seq(min(akima$y), max(akima$y), length = 100),
                   linear = FALSE, extrap = TRUE)
# interp surface:
rgl.surface(akima.si$x,akima.si$y,akima.si$z,color="green",alpha=c(0.5))
# interpp:
akima.sp &lt;- interpp(akima$x, akima$y, akima$z,
                    runif(200,min(akima$x),max(akima$x)),
                    runif(200,min(akima$y),max(akima$y)),
                   linear = FALSE, extrap = TRUE)
# interpp points:
rgl.points(akima.sp$x,akima.sp$z , akima.sp$y,size=4,color="yellow")


## End(Not run)
</code></pre>

<hr>
<h2 id='aspline'>Univariate Akima interpolation</h2><span id='topic+aspline'></span>

<h3>Description</h3>

<p>The function returns a list of points which smoothly
interpolate given data points, similar to a curve drawn by hand.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  aspline(x, y=NULL, xout, n = 50, ties = mean, method="original", degree=3) </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aspline_+3A_x">x</code>, <code id="aspline_+3A_y">y</code></td>
<td>
<p>vectors giving the coordinates of the points to be
interpolated.  Alternatively a single plotting structure can be
specified: see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>.</p>
</td></tr>
<tr><td><code id="aspline_+3A_xout">xout</code></td>
<td>
<p>an optional set of values specifying where interpolation
is to take place.</p>
</td></tr>
<tr><td><code id="aspline_+3A_n">n</code></td>
<td>
<p>If <code>xout</code> is not specified, interpolation takes place at
<code>n</code> equally spaced points spanning the interval [<code>min(x)</code>,
<code>max(x)</code>].</p>
</td></tr>
<tr><td><code id="aspline_+3A_ties">ties</code></td>
<td>
<p>Handling of tied <code>x</code> values.  Either a function
with a single vector argument returning a single number result or
the string <code>"ordered"</code>.</p>
</td></tr>
<tr><td><code id="aspline_+3A_method">method</code></td>
<td>
<p>either <code>"original"</code> method after Akima (1970) or
<code>"improved"</code> method after Akima (1991)</p>
</td></tr>
<tr><td><code id="aspline_+3A_degree">degree</code></td>
<td>
<p>if improved algorithm is selected: degree of the
polynomials for the interpolating function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original algorithm is based on a piecewise function composed of a
set of polynomials, each of degree three, at most, and applicable to
successive interval of the given points. In this method, the slope of
the curve is determined at each given point locally, and each
polynomial representing a portion of the curve between a pair of given
points is determined by the coordinates of and the slopes at the
points.  </p>


<h3>Value</h3>

<p>A list with components <code>x</code> and <code>y</code>,
containing <code>n</code> coordinates which interpolate the given data
points.  </p>


<h3>References</h3>

<p>Akima, H. (1970) A new method of interpolation
and smooth curve fitting based on local procedures,
J. ACM <b>17</b>(4), 589-602
</p>
<p>Akima, H. (1991) A Method of Univariate Interpolation that Has
the Accuracy of a Third-degree Polynomial. ACM Transactions on
Mathematical Software, <b>17</b>(3), 341-366.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+approx">approx</a></code>, <code><a href="stats.html#topic+spline">spline</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## regular spaced data
x &lt;- 1:10
y &lt;- c(rnorm(5), c(1,1,1,1,3))

xnew &lt;- seq(-1, 11, 0.1)
plot(x, y, ylim=c(-3, 3), xlim=range(xnew))
lines(spline(x, y, xmin=min(xnew), xmax=max(xnew), n=200), col="blue")

lines(aspline(x, y, xnew), col="red")
lines(aspline(x, y, xnew, method="improved"), col="black", lty="dotted")
lines(aspline(x, y, xnew, method="improved", degree=10), col="green", lty="dashed")

## irregular spaced data
x &lt;- sort(runif(10, max=10))
y &lt;- c(rnorm(5), c(1,1,1,1,3))

xnew &lt;- seq(-1, 11, 0.1)
plot(x, y, ylim=c(-3, 3), xlim=range(xnew))
lines(spline(x, y, xmin=min(xnew), xmax=max(xnew), n=200), col="blue")

lines(aspline(x, y, xnew), col="red")
lines(aspline(x, y, xnew, method="improved"), col="black", lty="dotted")
lines(aspline(x, y, xnew, method="improved", degree=10), col="green", lty="dashed")

## an example of Akima, 1991
x &lt;- c(-3, -2, -1, 0,  1,  2, 2.5, 3)
y &lt;- c( 0,  0,  0, 0, -1, -1, 0,   2)

plot(x, y, ylim=c(-3, 3))
lines(spline(x, y, n=200), col="blue")

lines(aspline(x, y, n=200), col="red")
lines(aspline(x, y, n=200, method="improved"), col="black", lty="dotted")
lines(aspline(x, y, n=200, method="improved", degree=10), col="green", lty="dashed")
</code></pre>

<hr>
<h2 id='bicubic'>
Bivariate Interpolation for Data on a Rectangular grid
</h2><span id='topic+bicubic'></span>

<h3>Description</h3>

<p>The description in the Fortran code says:
</p>
<p>This subroutine performs interpolation of a bivariate function,
z(x,y), on a rectangular grid in the x-y plane.  It is based on
the revised Akima method.
</p>
<p>In this subroutine, the interpolating function is a piecewise
function composed of a set of bicubic (bivariate third-degree)
polynomials, each applicable to a rectangle of the input grid
in the x-y plane.  Each polynomial is determined locally.
</p>
<p>This subroutine has the accuracy of a bicubic polynomial, i.e.,
it interpolates accurately when all data points lie on a
surface of a bicubic polynomial.
</p>
<p>The grid lines can be unevenly spaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicubic(x, y, z, x0, y0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bicubic_+3A_x">x</code></td>
<td>

<p>a vector containing the <code>x</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bicubic_+3A_y">y</code></td>
<td>

<p>a vector containing the <code>y</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bicubic_+3A_z">z</code></td>
<td>

<p>a matrix containing the <code>z[i,j]</code> data values for the grid points (<code>x[i]</code>,<code>y[j]</code>).
</p>
</td></tr>
<tr><td><code id="bicubic_+3A_x0">x0</code></td>
<td>

<p>vector of <code>x</code> coordinates used to interpolate at.
</p>
</td></tr>
<tr><td><code id="bicubic_+3A_y0">y0</code></td>
<td>

<p>vector of <code>y</code> coordinates used to interpolate at.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functiuon is a R interface to Akima's Rectangular-Grid-Data
Fitting algorithm (TOMS 760). The algorithm has the accuracy of a bicubic
(bivariate third-degree) polynomial.
</p>


<h3>Value</h3>

<p>This function produces a list of interpolated points:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>vector of <code>x</code> coordinates.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector of <code>y</code> coordinates.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>vector of interpolated data <code>z</code>.</p>
</td></tr>
</table>
<p>If you need an output grid, see <code><a href="#topic+bicubic.grid">bicubic.grid</a></code>.
</p>


<h3>Note</h3>

<p>Use <code><a href="#topic+interp">interp</a></code> for the general case of irregular gridded data!
</p>


<h3>References</h3>

<p>Akima, H. (1996) Rectangular-Grid-Data
Surface Fitting that Has the Accuracy of a
Bicubic Polynomial,
J. ACM <b>22</b>(3), 357-361
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp">interp</a></code>, <code><a href="#topic+bicubic.grid">bicubic.grid</a></code>


</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(akima760)
# interpolate at the diagonal of the grid [0,8]x[0,10]
akima.bic &lt;- bicubic(akima760$x,akima760$y,akima760$z,
                     seq(0,8,length=50), seq(0,10,length=50))
plot(sqrt(akima.bic$x^2+akima.bic$y^2), akima.bic$z, type="l")

</code></pre>

<hr>
<h2 id='bicubic.grid'>
Bicubic Interpolation for Data on a Rectangular grid
</h2><span id='topic+bicubic.grid'></span>

<h3>Description</h3>

<p>The description in the Fortran code says:
</p>
<p>This subroutine performs interpolation of a bivariate function,
z(x,y), on a rectangular grid in the x-y plane.  It is based on
the revised Akima method.
</p>
<p>In this subroutine, the interpolating function is a piecewise
function composed of a set of bicubic (bivariate third-degree)
polynomials, each applicable to a rectangle of the input grid
in the x-y plane.  Each polynomial is determined locally.
</p>
<p>This subroutine has the accuracy of a bicubic polynomial, i.e.,
it interpolates accurately when all data points lie on a
surface of a bicubic polynomial.
</p>
<p>The grid lines can be unevenly spaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicubic.grid(x,y,z,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)),
             nx=40,ny=40,dx=NULL,dy=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bicubic.grid_+3A_x">x</code></td>
<td>

<p>a vector containing the <code>x</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_y">y</code></td>
<td>

<p>a vector containing the <code>y</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_z">z</code></td>
<td>

<p>a matrix containing the <code>z[i,j]</code> data values for the grid points (<code>x[i]</code>,<code>y[j]</code>).
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_xlim">xlim</code></td>
<td>

<p>vector of length 2 giving lower and upper limit for range <code>x</code>
coordinates used for  output grid.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_ylim">ylim</code></td>
<td>

<p>vector of length 2 giving lower and upper limit for range of <code>y</code>
coordinates used for  output grid.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_nx">nx</code></td>
<td>

<p>output grid dimension in <code>x</code> direction.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_ny">ny</code></td>
<td>

<p>output grid dimension in <code>y</code> direction.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_dx">dx</code></td>
<td>

<p>output grid spacing in <code>x</code> direction, not used by default,
overrides <code>nx</code> if specified.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_dy">dy</code></td>
<td>

<p>output grid spacing in <code>y</code> direction, not used by default,
overrides <code>ny</code> if specified..
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functiuon is a R interface to Akima's Rectangular-Grid-Data
Fitting algorithm (TOMS 760). The algorithm has the accuracy of a bicubic
(bivariate third-degree) polynomial.
</p>


<h3>Value</h3>

<p>This function produces a grid of interpolated points, feasible to be
used directly with <code><a href="graphics.html#topic+image">image</a></code> and <code><a href="graphics.html#topic+contour">contour</a></code>:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>vector of <code>x</code> coordinates of the output grid.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector of <code>y</code> coordinates of the output grid.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>matrix of interpolated data for the output grid.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+interp">interp</a></code> for the general case of irregular gridded data!
</p>


<h3>References</h3>

<p>Akima, H. (1996) Rectangular-Grid-Data
Surface Fitting that Has the Accuracy of a
Bicubic Polynomial,
J. ACM <b>22</b>(3), 357-361
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp">interp</a></code>, <code><a href="#topic+bicubic">bicubic</a></code>


</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(akima760)
# interpolate at a grid [0,8]x[0,10]
akima.bic &lt;- bicubic.grid(akima760$x,akima760$y,akima760$z)
zmin &lt;- min(akima.bic$z, na.rm=TRUE)
zmax &lt;- max(akima.bic$z, na.rm=TRUE)
breaks &lt;- pretty(c(zmin,zmax),10)
colors &lt;- heat.colors(length(breaks)-1)
image(akima.bic, breaks=breaks, col=colors)
contour(akima.bic, levels=breaks,  add=TRUE)
</code></pre>

<hr>
<h2 id='bilinear'>
Bilinear Interpolation for Data on a Rectangular grid
</h2><span id='topic+bilinear'></span>

<h3>Description</h3>

<p>This is an implementation of a bilinear interpolating function.
</p>
<p>For a point (x0,y0) contained in a rectangle (x1,y1),(x2,y1),
(x2,y2),(x1,y2) and x1&lt;x2, y1&lt;y2, the first step is to get z()
at locations (x0,y1) and (x0,y2) as convex linear combinations
z(x0,y*)=a*z(x1,y*)+(1-a)*z(x2,y*) where a=(x2-x1)/(x0-x1) for
y*=y1,y2. In a second step z(x0,y0) is calculated as convex linear
combination between z(x0,y1) and z(x0,y2) as
z(x0,y1)=b*z(x0,y1)+(1-b)*z(x0,y2)  where b=(y2-y1)/(y0-y1).
</p>
<p>Finally, z(x0,y0) is a convex linear combination of the z values at
the corners of the containing  rectangle with weights according to
the distance from (x0,y0) to these corners.
</p>
<p>The grid lines can be unevenly spaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bilinear(x, y, z, x0, y0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bilinear_+3A_x">x</code></td>
<td>

<p>a vector containing the <code>x</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bilinear_+3A_y">y</code></td>
<td>

<p>a vector containing the <code>y</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bilinear_+3A_z">z</code></td>
<td>

<p>a matrix containing the <code>z[i,j]</code> data values for the grid points (<code>x[i]</code>,<code>y[j]</code>).
</p>
</td></tr>
<tr><td><code id="bilinear_+3A_x0">x0</code></td>
<td>

<p>vector of <code>x</code> coordinates used to interpolate at.
</p>
</td></tr>
<tr><td><code id="bilinear_+3A_y0">y0</code></td>
<td>

<p>vector of <code>y</code> coordinates used to interpolate at.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function produces a list of interpolated points:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>vector of <code>x</code> coordinates.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector of <code>y</code> coordinates.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>vector of interpolated data <code>z</code>.</p>
</td></tr>
</table>
<p>If you need an output grid, see <code><a href="#topic+bilinear.grid">bilinear.grid</a></code>.
</p>


<h3>Note</h3>

<p>Use <code><a href="#topic+interpp">interpp</a></code> for the general case of irregular gridded data!
</p>


<h3>References</h3>

<p>Pascal Getreuer,
Linear Methods for Image Interpolation,
Image Processing On Line, 2011,
http://www.ipol.im/pub/art/2011/g_lmii/article.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp">interp</a></code>, <code><a href="#topic+bilinear.grid">bilinear.grid</a></code>, <code><a href="#topic+bicubic.grid">bicubic.grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(akima760)
# interpolate at the diagonal of the grid [0,8]x[0,10]
akima.bil &lt;- bilinear(akima760$x,akima760$y,akima760$z,
                     seq(0,8,length=50), seq(0,10,length=50))
plot(sqrt(akima.bil$x^2+akima.bil$y^2), akima.bil$z, type="l")
</code></pre>

<hr>
<h2 id='bilinear.grid'>
Bilinear Interpolation for Data on a Rectangular grid
</h2><span id='topic+bilinear.grid'></span>

<h3>Description</h3>

<p>This is an implementation of a bilinear interpolating function.
</p>
<p>For a point (x0,y0) contained in a rectangle (x1,y1),(x2,y1),
(x2,y2),(x1,y2) and x1&lt;x2, y1&lt;y2, the first step is to get z()
at locations (x0,y1) and (x0,y2) as convex linear combinations
z(x0,y*)=a*z(x1,y*)+(1-a)*z(x2,y*) where a=(x2-x1)/(x0-x1) for
y*=y1,y2. In a second step z(x0,y0) is calculated as convex linear
combination between z(x0,y1) and z(x0,y2) as
z(x0,y1)=b*z(x0,y1)+(1-b)*z(x0,y2)  where b=(y2-y1)/(y0-y1).
</p>
<p>Finally, z(x0,y0) is a convex linear combination of the z values at
the corners of the containing  rectangle with weights according to
the distance from (x0,y0) to these corners.
</p>
<p>The grid lines can be unevenly spaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bilinear.grid(x,y,z,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)),
                         nx=40,ny=40,dx=NULL,dy=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bilinear.grid_+3A_x">x</code></td>
<td>

<p>a vector containing the <code>x</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_y">y</code></td>
<td>

<p>a vector containing the <code>y</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_z">z</code></td>
<td>

<p>a matrix containing the <code>z[i,j]</code> data values for the grid points (<code>x[i]</code>,<code>y[j]</code>).
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_xlim">xlim</code></td>
<td>

<p>vector of length 2 giving lower and upper limit for range <code>x</code>
coordinates used for  output grid.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_ylim">ylim</code></td>
<td>

<p>vector of length 2 giving lower and upper limit for range of <code>y</code>
coordinates used for  output grid.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_nx">nx</code></td>
<td>

<p>output grid dimension in <code>x</code> direction.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_ny">ny</code></td>
<td>

<p>output grid dimension in <code>y</code> direction.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_dx">dx</code></td>
<td>

<p>output grid spacing in <code>x</code> direction, not used by default,
overrides <code>nx</code> if specified.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_dy">dy</code></td>
<td>

<p>output grid spacing in <code>y</code> direction, not used by default,
overrides <code>ny</code> if specified..
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function produces a grid of interpolated points, feasible to be
used directly with <code><a href="graphics.html#topic+image">image</a></code> and <code><a href="graphics.html#topic+contour">contour</a></code>:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>vector of <code>x</code> coordinates of the output grid.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector of <code>y</code> coordinates of the output grid.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>matrix of interpolated data for the output grid.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+interp">interp</a></code> for the general case of irregular gridded data!
</p>


<h3>References</h3>

<p>Pascal Getreuer,
Linear Methods for Image Interpolation,
Image Processing On Line, 2011,
http://www.ipol.im/pub/art/2011/g_lmii/article.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp">interp</a></code>, <code><a href="#topic+bicubic">bicubic</a></code>


</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(akima760)
# interpolate at a grid [0,8]x[0,10]
akima.bil &lt;- bilinear.grid(akima760$x,akima760$y,akima760$z)
zmin &lt;- min(akima.bil$z, na.rm=TRUE)
zmax &lt;- max(akima.bil$z, na.rm=TRUE)
breaks &lt;- pretty(c(zmin,zmax),10)
colors &lt;- heat.colors(length(breaks)-1)
image(akima.bil, breaks=breaks, col=colors)
contour(akima.bil, levels=breaks, add=TRUE)
</code></pre>

<hr>
<h2 id='franke.data'>
Test datasets from Franke for interpolation of scattered data
</h2><span id='topic+franke.data'></span><span id='topic+franke.fn'></span><span id='topic+franke'></span>

<h3>Description</h3>

<p><code>franke.data</code> generates the test datasets from Franke, 1979, see references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>franke.data(fn = 1, ds = 1, data)
franke.fn(x, y, fn = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="franke.data_+3A_fn">fn</code></td>
<td>

<p>function number, from 1 to 5.
</p>
</td></tr>
<tr><td><code id="franke.data_+3A_x">x</code></td>
<td>
<p>'x' value</p>
</td></tr>
<tr><td><code id="franke.data_+3A_y">y</code></td>
<td>
<p>'y' value</p>
</td></tr>
<tr><td><code id="franke.data_+3A_ds">ds</code></td>
<td>

<p>data set number, from 1 to 3. Dataset 1 consists of 100 points,
dataset 2 of 33 points and dataset 3 of 25 points scattered in the
square <code class="reqn">[0,1]\times[0,1]</code>. (and partially slightly
outside).
</p>
</td></tr>
<tr><td><code id="franke.data_+3A_data">data</code></td>
<td>

<p>A list of dataframes with 'x' and 'y' to choose from, dataset
<code>franke</code> should be used here.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These datasets are mentioned in [Akima 1996] as testbed for the
irregular scattered data interpolator.
</p>
<p>Franke used the five functions:
</p>
<p style="text-align: center;"><code class="reqn">0.75e^{-\frac{(9x-2)^2+(9y-2)^2}{4}}+
    0.75e^{-\frac{(9x+1)^2}{49}-\frac{9y+1}{10}}+
    0.5e^{-\frac{(9x-7)^2+(9y-3)^2}{4}}-
      0.2e^{-((9x-4)^2-(9y-7)^2)}
    </code>
</p>

<p style="text-align: center;"><code class="reqn">\frac{\mbox{tanh}(9y-9x)+1}{9}</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac{1.25+\cos(5.4y)}{6(1+(3x-1)^2)}</code>
</p>

<p style="text-align: center;"><code class="reqn">e^{-\frac{81((x-0.5)^2+\frac{(y-0.5)^2}{16})}{3}}</code>
</p>

<p style="text-align: center;"><code class="reqn">e^{-\frac{81((x-0.5)^2+\frac{(y-0.5)^2}{4})}{3}}</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac{\sqrt{64-81((x-0.5)^2+(y-0.5)^2)}}{9}-0.5</code>
</p>

<p>and evaluated them on different more or less dense grids over <code class="reqn">[0,1]\times[0,1]</code>.
</p>


<h3>Value</h3>

<p>A data frame with components
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>'x' coordinate</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>'y' coordinate</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>'z' value</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The datasets have to be generated via <code>franke.data</code> before
use, the dataset <code>franke</code> only contains a list of 3 dataframes of
'x' and 'y' coordinates for the above mentioned irregular grids.
Do not forget to load the <code>franke</code> dataset first.
</p>
<p>The 'x' and 'y' values have been taken out of [Akima 1996].
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt,
</p>


<h3>References</h3>

<p>FRANKE, R., (1979). A critical comparison of some methods for interpolation
of scattered data. Tech. Rep. NPS-53-79-003, Dept. of Mathematics, Naval
Postgraduate School, Monterey, Calif.
</p>
<p>Akima, H. (1996). Algorithm 761: scattered-data surface fitting that has
the accuracy of a cubic polynomial.
ACM Transactions on Mathematical Software <b>22</b>, 362&ndash;371.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp">interp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate Frankes data set for function 2 and dataset 3:
data(franke)
F23 &lt;- franke.data(2,3,franke)
str(F23)
</code></pre>

<hr>
<h2 id='interp'>Gridded Bivariate Interpolation for Irregular Data</h2><span id='topic+interp'></span>

<h3>Description</h3>

<p>These functions implement bivariate interpolation onto a grid
for irregularly spaced input data.  Bilinear or bicubic spline
interpolation is applied using different versions of algorithms from
Akima.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp(x, y=NULL, z, xo=seq(min(x), max(x), length = nx),
       yo=seq(min(y), max(y), length = ny),
       linear = TRUE, extrap=FALSE, duplicate = "error", dupfun = NULL,
       nx = 40, ny = 40,
       jitter = 10^-12, jitter.iter = 6, jitter.random = FALSE,
       remove = !linear)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp_+3A_x">x</code></td>
<td>

<p>vector of x-coordinates of data points or a
<code>SpatialPointsDataFrame</code> object.
Missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="interp_+3A_y">y</code></td>
<td>

<p>vector of y-coordinates of data points.
Missing values are not accepted.
</p>
<p>If left as NULL indicates that <code>x</code> should be a
<code>SpatialPointsDataFrame</code> and <code>z</code> names the variable of
interest in this dataframe.
</p>
</td></tr>
<tr><td><code id="interp_+3A_z">z</code></td>
<td>

<p>vector of z-coordinates of data points or a character variable
naming the variable of interest in the
<code>SpatialPointsDataFrame</code> <code>x</code>.
</p>
<p>Missing values are not accepted.
</p>
<p><code>x</code>, <code>y</code>, and <code>z</code> must be the same length
(execpt if <code>x</code> is a <code>SpatialPointsDataFrame</code>) and may
contain no fewer than four points. The points of <code>x</code> and
<code>y</code> should not be collinear, i.e, they should not fall on the same line
(two vectors <code>x</code> and <code>y</code> such that <code>y = ax + b</code> for
some <code>a</code>, <code>b</code> will not produce menaningful results). Some
heuristics is built in to avoid this case by adding small jitter to
<code>x</code> and <code>y</code> when the number of <code>NA</code> values in the
result exceeds 10%.
</p>
<p><code>interp</code> is
meant for cases in which you have <code>x</code>, <code>y</code> values
scattered over a plane and a <code>z</code> value for each.  If, instead,
you are trying to evaluate a mathematical function, or get a
graphical interpretation of relationships that can be described by a
polynomial, try <code>outer()</code>.
</p>
</td></tr>
<tr><td><code id="interp_+3A_xo">xo</code></td>
<td>

<p>vector of x-coordinates of output grid.  The default is 40 points
evenly spaced over the range of <code>x</code>.  If extrapolation is not being
used (<code>extrap=FALSE</code>, the default), <code>xo</code> should have a
range that is close to or inside of the range of <code>x</code> for the
results to be meaningful.
</p>
</td></tr>
<tr><td><code id="interp_+3A_yo">yo</code></td>
<td>
<p>vector of y-coordinates of output grid; analogous to
<code>xo</code>, see above.</p>
</td></tr>
<tr><td><code id="interp_+3A_linear">linear</code></td>
<td>
<p>logical &ndash; indicating wether linear or spline
interpolation should be used.</p>
</td></tr>
<tr><td><code id="interp_+3A_extrap">extrap</code></td>
<td>

<p>logical flag: should extrapolation be used outside of the
convex hull determined by the data points?</p>
</td></tr>
<tr><td><code id="interp_+3A_duplicate">duplicate</code></td>
<td>
<p>character string indicating how to handle duplicate
data points. Possible values are
</p>

<dl>
<dt><code>"error"</code></dt><dd><p>produces an error message,</p>
</dd>
<dt><code>"strip"</code></dt><dd><p>remove duplicate z values,</p>
</dd>
<dt> <code>"mean"</code>,<code>"median"</code>,<code>"user"</code></dt><dd><p>calculate
mean , median or user defined function (<code>dupfun</code>) of duplicate
z values.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="interp_+3A_dupfun">dupfun</code></td>
<td>
<p>a function, applied to duplicate points if
<code>duplicate= "user"</code>.</p>
</td></tr>
<tr><td><code id="interp_+3A_nx">nx</code></td>
<td>
<p>dimension of output grid in x direction</p>
</td></tr>
<tr><td><code id="interp_+3A_ny">ny</code></td>
<td>
<p>dimension of output grid in y direction</p>
</td></tr>
<tr><td><code id="interp_+3A_jitter">jitter</code></td>
<td>
<p>Jitter of amount of <code>diff(range(XX))*jitter</code> (XX=x
or y) will be added to coordinates if collinear points are
detected. Afterwards interpolation will be tried once again.
</p>
<p>Note that the jitter is not generated randomly unless
<code>jitter.random</code> is set to <code>TRUE</code>. This ensures
reproducable result. <code><a href="tripack.html#topic+tri.mesh">tri.mesh</a></code> of package
<code>tripack</code> uses the same jitter mechanism. That means you can
plot the triangulation on top of the interpolation and see the
same triangulation as used for interpolation, see examples below.
</p>
</td></tr>
<tr><td><code id="interp_+3A_jitter.iter">jitter.iter</code></td>
<td>
<p>number of iterations to retry with jitter, amount
will be multiplied in each iteration by <code>iter^1.5</code></p>
</td></tr>
<tr><td><code id="interp_+3A_jitter.random">jitter.random</code></td>
<td>
<p>logical, see <code>jitter</code>, defaults to
<code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="interp_+3A_remove">remove</code></td>
<td>
<p>logical, indicates whether Akimas removal of thin triangles along
the border of the convex hull should be performed, experimental setting!
defaults to <code>!linear</code>, so it will be left out for linear interpolation
by default. For some point configurations it is the only
available option to skip this removal step.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>linear</code> is <code>TRUE</code> (default), linear
interpolation is used in the triangles bounded by data points.
Cubic interpolation is done if <code>linear</code> is set to <code>FALSE</code>.
If <code>extrap</code> is <code>FALSE</code>, z-values for points outside the
convex hull are returned as <code>NA</code>.
No extrapolation can be performed for the linear case.
</p>
<p>The <code>interp</code> function handles duplicate <code>(x,y)</code> points
in different ways. As default it will stop with an error message. But
it can give duplicate points an unique <code>z</code> value according to the
parameter <code>duplicate</code> (<code>mean</code>,<code>median</code> or any other
user defined function).
</p>
<p>The triangulation scheme used by <code>interp</code> works well if <code>x</code>
and <code>y</code> have similar scales but will appear stretched if they have
very different scales.  The spreads of <code>x</code> and <code>y</code> must be
within four orders of magnitude of each other for <code>interp</code> to work.
</p>


<h3>Value</h3>

<p>list with 3 components:
</p>
<table role = "presentation">
<tr><td><code>x</code>, <code>y</code></td>
<td>

<p>vectors of x- and y- coordinates of output grid, the same as the input
argument <code>xo</code>, or <code>yo</code>, if present.  Otherwise, their
default, a vector 40 points evenly spaced over the range of the
input <code>x</code>.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>

<p>matrix of fitted z-values.  The value <code>z[i,j]</code> is computed
at the x,y point <code>xo[i], yo[j]</code>. <code>z</code> has
dimensions <code>length(xo)</code> times <code>length(yo)</code>.</p>
</td></tr>
</table>
<p>If input is a <code>SpatialPointsDataFrame</code> a
<code>SpatialPixelssDataFrame</code> is returned.
</p>


<h3>Note</h3>

<p><code>interp</code> uses Akimas new Fortran code (ACM 761) from 1996 in the revised
version by Renka from 1998 for spline interpolation, the triangulation
(based on Renkas tripack) is reused for linear interpolation. In this
newer version Akima switched from his own triangulation to Renkas
tripack (ACM 751).
</p>
<p>Note that earlier versions (up to version 0.5-12) as well as S-Plus
used the old Fortran code from Akima 1978 (ACM 526).
</p>
<p>The resulting structure is suitable for input to the
functions <code><a href="graphics.html#topic+contour">contour</a></code> and <code><a href="graphics.html#topic+image">image</a></code>.  Check
the requirements of these functions when choosing values  for
<code>xo</code> and <code>yo</code>.
</p>


<h3>References</h3>

<p>Akima, H. (1978). A Method of Bivariate Interpolation and
Smooth Surface Fitting for Irregularly Distributed Data Points.
ACM Transactions on Mathematical Software <b>4</b>, 148-164.
</p>
<p>Akima, H. (1996). Algorithm 761: scattered-data surface fitting that has
the accuracy of a cubic polynomial.
ACM Transactions on Mathematical Software <b>22</b>, 362&ndash;371.
</p>
<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>
<p>R. J. Renka and Ron Brown (1998). Remark on algorithm 761.
ACM Transactions on Mathematical Software.
<b>24</b>, 383-385.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+image">image</a></code>,
<code><a href="stats.html#topic+approx">approx</a></code>, <code><a href="stats.html#topic+spline">spline</a></code>,
<code><a href="#topic+aspline">aspline</a></code>,
<code><a href="base.html#topic+outer">outer</a></code>, <code><a href="base.html#topic+expand.grid">expand.grid</a></code>,
<code>link{franke.data}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(akima)
plot(y ~ x, data = akima, main = "akima example data")
with(akima, text(x, y, formatC(z,dig=2), adj = -0.1))

## linear interpolation
akima.li &lt;- interp(akima$x, akima$y, akima$z)
li.zmin &lt;- min(akima.li$z,na.rm=TRUE)
li.zmax &lt;- max(akima.li$z,na.rm=TRUE)
breaks &lt;- pretty(c(li.zmin,li.zmax),10)
colors &lt;- heat.colors(length(breaks)-1)
with(akima.li, image  (x,y,z, breaks=breaks, col=colors))
with(akima.li,contour(x,y,z, levels=breaks, add=TRUE))
points (akima, pch = 3)

## increase smoothness (using finer grid):
akima.smooth &lt;-
    with(akima, interp(x, y, z, nx=100, ny=100))
si.zmin &lt;- min(akima.smooth$z,na.rm=TRUE)
si.zmax &lt;- max(akima.smooth$z,na.rm=TRUE)
breaks &lt;- pretty(c(si.zmin,si.zmax),10)
colors &lt;- heat.colors(length(breaks)-1)

image  (akima.smooth, main = "interp(&lt;akima data&gt;, *) on finer grid",
        breaks=breaks, col=colors)
contour(akima.smooth, add = TRUE, levels=breaks, col = "thistle")
points(akima, pch = 3, cex = 2, col = "blue")

## use triangulation package to show underlying triangulation:
## Not run: 
if(library(tripack, logical.return=TRUE))
   plot(tri.mesh(akima), add=TRUE, lty="dashed")

## End(Not run)
## use only 15 points (interpolation only within convex hull!)
akima.part &lt;- with(akima, interp(x[1:15], y[1:15], z[1:15]))
p.zmin &lt;- min(akima.part$z,na.rm=TRUE)
p.zmax &lt;- max(akima.part$z,na.rm=TRUE)
breaks &lt;- pretty(c(p.zmin,p.zmax),10)
colors &lt;- heat.colors(length(breaks)-1)

image(akima.part, breaks=breaks, col=colors)
title("interp() on subset of only 15 points")
contour(akima.part, levels=breaks, add=TRUE)
points(akima$x[1:15],akima$y[1:15], col = "blue")

## spline interpolation
akima.spl &lt;- with(akima, interp(x, y, z, nx=100, ny=100, linear=FALSE))

contour(akima.spl, main = "smooth  interp(*, linear = FALSE)")
points(akima)

full.pal &lt;- function(n) hcl(h = seq(340, 20, length = n))
cool.pal &lt;- function(n) hcl(h = seq(120, 0, length = n) + 150)
warm.pal &lt;- function(n) hcl(h = seq(120, 0, length = n) - 30)

filled.contour(akima.spl, color.palette = full.pal,
        plot.axes = { axis(1); axis(2);
                      title("smooth  interp(*, linear = FALSE)");
                      points(akima, pch = 3, col= hcl(c=100, l = 20))})
## no extrapolation!

## Not run: 
    ## interp can handle spatial point dataframes created by the sp package:
    library(sp)
    data(meuse)
    coordinates(meuse) &lt;- ~x+y
    ## argument z has to be named, y has to be omitted!
    z &lt;- interp(meuse,z="zinc",nx=100,ny=150)
    spplot(z,"zinc")
    z &lt;- interp(meuse,z="zinc",nx=100,ny=150,linear=FALSE)
    spplot(z,"zinc")

## End(Not run)

## Not run: 
### An example demonstrating the problems that occur for rectangular
### gridded data.
###
require(tripack)
### Create irregularly spaced sample data on even values of x and y
### (the "14" makes it irregular spacing).
x   &lt;- c(seq(2,10,2),14)
nx  &lt;- length(x)
y   &lt;- c(seq(2,10,2),14)
ny  &lt;- length(y)
nxy &lt;- nx*ny
xy  &lt;- expand.grid(x,y)
colnames(xy) &lt;- c("x","y")
### prepare a dataframe for interp
df  &lt;- cbind(xy,z=rnorm(nxy))
### and a matrix for bicubic and bilinear
z   &lt;- matrix(df$z,nx,ny)

old.par &lt;- par(mfrow=c(2,2))
### First: bicubic spline interpolation:
### This is Akimas bicubic spline implementation for regular gridded
### data:
iRbic &lt;- bicubic.grid(x,y,z,nx=250,ny=250)
### Note that this interpolation tends to extreme values in large cells.
### Therefore zmin and zmax are taken from here to generate the same
### color scheme for the next plots.
zmin &lt;- min(iRbic$z, na.rm=TRUE)
zmax &lt;- max(iRbic$z, na.rm=TRUE)
breaks &lt;- pretty(c(zmin,zmax),10)
colors &lt;- heat.colors(length(breaks)-1)
image(iRbic,breaks=breaks,col = colors)
contour(iRbic,col="black",levels=breaks,add=TRUE)
points(xy$x,xy$y)
title(main="bicubic interpolation",
      xlab="bcubic.grid(...)",
      sub="Akimas regular grid version, ACM 760")

### Now Akima splines with accurracy of bicubic polynomial
### for irregular gridded data:
iRspl &lt;- with(df,interp(x,y,z,linear=FALSE,nx=250,ny=250))
### Note that the triangulation is created by adding small amounts
### of jitter to the coordinates, resulting in an unique triangulation.
### This jitter is not randomly choosen to get reproducable results.
### tri.mesh() from package tripack uses the same code and so produces the
### same triangulation.
image(iRspl,breaks=breaks,col = colors)
contour(iRspl,col="black",levels=breaks,add=TRUE)
plot(tri.mesh(xy$x,xy$y),col="white",add=TRUE)
title(main="bicubic* interpolation",
      xlab="interp(...,linear=FALSE)",
      ylab="*: accuracy of bicubic polynomial"
      sub="Akimas irregular grid version, ACM 761")

### Just for comparison an implementation of bilinear interpolation,
### only applicable to regular gridded data:
iRbil &lt;- bilinear.grid(x,y,z,nx=250,ny=250)
### Note the lack of differentiability at grid cell borders.
image(iRbil,breaks=breaks,col = colors)
contour(iRbil,col="black",levels=breaks,add=TRUE)
points(xy$x,xy$y)
title(main="bilinear interpolation",
      xlab="bilinear.grid(...)",
      sub="only works for regular grid")

### Linear interpolation using the same triangulation as
### Akima bicubic splines for irregular gridded data.
iRlin &lt;- with(df,interp(x,y,z,linear=TRUE,nx=250,ny=250))
### Note how the triangulation influences the interpolation.
### For this rectangular gridded dataset the triangulation
### in each rectangle is arbitraryly choosen from two possible
### solutions, hence the interpolation would change drastically
### when the triangulation changes. For this reason interp()
### is not meant for regular (rectangular) gridded data!
image(iRlin,breaks=breaks,col = colors)
contour(iRlin,col="black",levels=breaks,add=TRUE)
plot(tri.mesh(xy$x,xy$y),col="white",add=TRUE)
title(main="linear interpolation",
      xlab="interp(...,linear=TRUE)",
      sub="same triangulation as Akima irregular grid")

### And now four times Akima 761 with random jitter for
### triangulation correction, note that now interp() and tri.mesh()
### need the same random seed to produce identical triangulations!
for(i in 1:4){
    set.seed(42+i)
    iRspl &lt;- with(df,interp(x,y,z,linear=FALSE,nx=250,ny=250,jitter.random=TRUE))
    image(iRspl,breaks=breaks,col = colors)
    contour(iRspl,col="black",levels=breaks,add=TRUE)
    set.seed(42+i)
    plot(tri.mesh(xy$x,xy$y,jitter.random=TRUE),col="white",add=TRUE)
    title(main="bicubic* interpolation",
          xlab="interp(...,linear=FALSE)",
          ylab="random jitter added",
          sub="Akimas irregular grid version, ACM 761")
}
par(old.par)


## End(Not run)
### Use all datasets from Franke, 1979:
data(franke)
for(i in 1:5)
    for(j in 1:3){
        FR &lt;- franke.data(i,j,franke)
        IL &lt;- with(FR, interp(x,y,z,linear=FALSE))
        image(IL)
        contour(IL,add=TRUE)
        with(FR,points(x,y))
    }
</code></pre>

<hr>
<h2 id='interp.old'>Gridded Bivariate Interpolation for Irregular Data</h2><span id='topic+interp.new'></span><span id='topic+interp.old'></span>

<h3>Description</h3>

<p>These functions implement bivariate interpolation onto a grid
for irregularly spaced input data. These functions are only for
backward compatibility, use <code><a href="#topic+interp">interp</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp.old(x, y, z, xo= seq(min(x), max(x), length = 40),
           yo=seq(min(y), max(y), length = 40), ncp = 0,
           extrap=FALSE, duplicate = "error", dupfun = NULL)
interp.new(x, y, z, xo = seq(min(x), max(x), length = 40),
           yo = seq(min(y), max(y), length = 40), linear = FALSE,
           ncp = NULL, extrap=FALSE, duplicate = "error", dupfun = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp.old_+3A_x">x</code></td>
<td>

<p>vector of x-coordinates of data points or a
<code>SpatialPointsDataFrame</code> object.
Missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="interp.old_+3A_y">y</code></td>
<td>

<p>vector of y-coordinates of data points.
Missing values are not accepted.
</p>
<p>If left as NULL indicates that <code>x</code> should be a
<code>SpatialPointsDataFrame</code> and <code>z</code> names the variable of
interest in this dataframe.
</p>
</td></tr>
<tr><td><code id="interp.old_+3A_z">z</code></td>
<td>

<p>vector of z-coordinates of data points or a character variable
naming the variable of interest in the
<code>SpatialPointsDataFrame</code> <code>x</code>.
</p>
<p>Missing values are not accepted.
</p>
<p><code>x</code>, <code>y</code>, and <code>z</code> must be the same length
(execpt if <code>x</code> is a <code>SpatialPointsDataFrame</code>) and may
contain no fewer than four points. The points of <code>x</code> and
<code>y</code> cannot be collinear, i.e, they cannot fall on the same line
(two vectors <code>x</code> and <code>y</code> such that <code>y = ax + b</code> for
some <code>a</code>, <code>b</code> will not be accepted). <code>interp</code> is
meant for cases in which you have <code>x</code>, <code>y</code> values
scattered over a plane and a <code>z</code> value for each.  If, instead,
you are trying to evaluate a mathematical function, or get a
graphical interpretation of relationships that can be described by a
polynomial, try <code>outer()</code>.
</p>
</td></tr>
<tr><td><code id="interp.old_+3A_xo">xo</code></td>
<td>

<p>vector of x-coordinates of output grid.  The default is 40 points
evenly spaced over the range of <code>x</code>.  If extrapolation is not being
used (<code>extrap=FALSE</code>, the default), <code>xo</code> should have a
range that is close to or inside of the range of <code>x</code> for the
results to be meaningful.
</p>
</td></tr>
<tr><td><code id="interp.old_+3A_yo">yo</code></td>
<td>
<p>vector of y-coordinates of output grid; analogous to
<code>xo</code>, see above.</p>
</td></tr>
<tr><td><code id="interp.old_+3A_linear">linear</code></td>
<td>
<p>logical &ndash; indicating wether linear or spline
interpolation should be used. supersedes old <code>ncp</code> parameter</p>
</td></tr>
<tr><td><code id="interp.old_+3A_ncp">ncp</code></td>
<td>

<p>deprecated, use parameter <code>linear</code>. Now only used by
<code>interp.old()</code>.
</p>
<p>old meaning was:
number of additional points to be used in computing partial
derivatives at each data point.
<code>ncp</code> must be either <code>0</code> (partial derivatives are not used), or at
least 2 but smaller than the number of data points (and smaller than
25).
</p>
</td></tr>
<tr><td><code id="interp.old_+3A_extrap">extrap</code></td>
<td>

<p>logical flag: should extrapolation be used outside of the
convex hull determined by the data points?</p>
</td></tr>
<tr><td><code id="interp.old_+3A_duplicate">duplicate</code></td>
<td>
<p>character string indicating how to handle duplicate
data points. Possible values are
</p>

<dl>
<dt><code>"error"</code></dt><dd><p>produces an error message,</p>
</dd>
<dt><code>"strip"</code></dt><dd><p>remove duplicate z values,</p>
</dd>
<dt> <code>"mean"</code>,<code>"median"</code>,<code>"user"</code></dt><dd><p>calculate
mean , median or user defined function (<code>dupfun</code>) of duplicate
z values.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="interp.old_+3A_dupfun">dupfun</code></td>
<td>
<p>a function, applied to duplicate points if
<code>duplicate= "user"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="#topic+interp">interp</a></code>
</p>


<h3>Value</h3>

<p>list with 3 components:
</p>
<table role = "presentation">
<tr><td><code>x</code>, <code>y</code></td>
<td>

<p>vectors of x- and y- coordinates of output grid, the same as the input
argument <code>xo</code>, or <code>yo</code>, if present.  Otherwise, their
default, a vector 40 points evenly spaced over the range of the
input <code>x</code>.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>

<p>matrix of fitted z-values.  The value <code>z[i,j]</code> is computed
at the x,y point <code>xo[i], yo[j]</code>. <code>z</code> has
dimensions <code>length(xo)</code> times <code>length(yo)</code>.</p>
</td></tr>
</table>
<p>If input is a <code>SpatialPointsDataFrame</code> a
<code>SpatialPixelssDataFrame</code> is returned.
</p>


<h3>Note</h3>

<p><code>interp.new</code> is deprecated and <code>interp.old</code> will soon be
deprecated.
</p>


<h3>References</h3>

<p>Akima, H. (1978). A Method of Bivariate Interpolation and
Smooth Surface Fitting for Irregularly Distributed Data Points.
ACM Transactions on Mathematical Software <b>4</b>, 148-164.
</p>
<p>Akima, H. (1996). Algorithm 761: scattered-data surface fitting that has
the accuracy of a cubic polynomial.
ACM Transactions on Mathematical Software <b>22</b>, 362&ndash;371.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+image">image</a></code>,
<code><a href="stats.html#topic+approx">approx</a></code>, <code><a href="stats.html#topic+spline">spline</a></code>,
<code><a href="#topic+aspline">aspline</a></code>,
<code><a href="base.html#topic+outer">outer</a></code>, <code><a href="base.html#topic+expand.grid">expand.grid</a></code>.
</p>

<hr>
<h2 id='interp2xyz'>From interp() Result, Produce 3-column Matrix</h2><span id='topic+interp2xyz'></span>

<h3>Description</h3>

<p>From an <code><a href="#topic+interp">interp</a>()</code> result, produce a 3-column matrix
or <code><a href="base.html#topic+data.frame">data.frame</a></code> <code>cbind(x, y, z)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp2xyz(al, data.frame = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp2xyz_+3A_al">al</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> as produced from <code><a href="#topic+interp">interp</a>()</code>.</p>
</td></tr>
<tr><td><code id="interp2xyz_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating if result should be
<a href="base.html#topic+data.frame">data.frame</a> or matrix (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix (or data.frame) with three columns, called
<code>"x"</code>, <code>"y"</code>, <code>"z"</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, Jan.18, 2013
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+expand.grid">expand.grid</a>()</code> is the &ldquo;essential ingredient&rdquo; of
<code>interp2xyz()</code>.
</p>
<p><code><a href="#topic+interp">interp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(akima)
ak.spl &lt;- with(akima, interp(x, y, z, linear = FALSE,
                             xo= seq(0,25, length=100),
                             yo= seq(0,20, length= 96)))
str(ak.spl)# list (x[i], y[j], z = &lt;matrix&gt;[i,j])

## Now transform to simple  (x,y,z)  matrix / data.frame :
str(am &lt;- interp2xyz(ak.spl))
str(ad &lt;- interp2xyz(ak.spl, data.frame=TRUE))
## and they are the same:
stopifnot( am == ad | (is.na(am) &amp; is.na(ad)) )
</code></pre>

<hr>
<h2 id='interpp'>
Pointwise Bivariate Interpolation for Irregular Data
</h2><span id='topic+interpp'></span>

<h3>Description</h3>

<p>These functions implement bivariate interpolation onto a set of points
for irregularly spaced input data. These functions are only for
backward compatibility, use <code><a href="#topic+interpp">interpp</a></code> instead.
</p>
<p>If <code>linear</code> is \codeTRUE, linear
interpolation is used in the triangles bounded by data points, otherwise
cubic interpolation is done.
</p>
<p>If <code>extrap</code> is <code>FALSE</code>, z-values for points outside the
convex hull are returned as <code>NA</code>. No extrapolation can be
performed for linear interpolation.
</p>
<p>The <code>interpp</code> function handles duplicate <code>(x,y)</code> points in
different ways. As default it will stop with an error message. But it
can give duplicate points an unique <code>z</code> value according to the
parameter <code>duplicate</code> (<code>mean</code>,<code>median</code> or any other
user defined function).
</p>
<p>The triangulation scheme used by <code>interp</code> works well if <code>x</code>
and <code>y</code> have similar scales but will appear stretched if they
have very different scales.  The spreads of <code>x</code> and <code>y</code> must
be within four orders of magnitude of each other for <code>interpp</code> to
work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpp(x, y=NULL, z, xo, yo=NULL, linear=TRUE, extrap=FALSE,
        duplicate = "error", dupfun = NULL,
        jitter = 10^-12, jitter.iter = 6, jitter.random = FALSE,
        remove = !linear)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpp_+3A_x">x</code></td>
<td>

<p>vector of x-coordinates of data points or a
<code>SpatialPointsDataFrame</code> object.
Missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="interpp_+3A_y">y</code></td>
<td>

<p>vector of y-coordinates of data points.
Missing values are not accepted.
</p>
<p>If left as NULL indicates that <code>x</code> should be a
<code>SpatialPointsDataFrame</code> and <code>z</code> names the variable of
interest in this dataframe.
</p>
</td></tr>
<tr><td><code id="interpp_+3A_z">z</code></td>
<td>

<p>vector of z-coordinates of data points or a character variable
naming the variable of interest in the
<code>SpatialPointsDataFrame</code> <code>x</code>.
</p>
<p>Missing values are not accepted.
</p>
<p><code>x</code>, <code>y</code>, and <code>z</code> must be the same length
(execpt if <code>x</code> is a <code>SpatialPointsDataFrame</code>) and may
contain no fewer than four points. The points of <code>x</code> and <code>y</code>
cannot be collinear, i.e, they cannot fall on the same line (two vectors
<code>x</code> and <code>y</code> such that <code>y = ax + b</code> for some <code>a</code>,
<code>b</code> will not be accepted).
</p>
</td></tr>
<tr><td><code id="interpp_+3A_xo">xo</code></td>
<td>

<p>vector of x-coordinates of points at which to evaluate the interpolating
function. If <code>x</code> is a <code>SpatialPointsDataFrame</code> this has
also to be a <code>SpatialPointsDataFrame</code>.
</p>
</td></tr>
<tr><td><code id="interpp_+3A_yo">yo</code></td>
<td>

<p>vector of y-coordinates of points at which to evaluate the interpolating
function.
</p>
<p>If operating on <code>SpatialPointsDataFrame</code>s this is left as <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="interpp_+3A_linear">linear</code></td>
<td>
<p>logical &ndash; indicating wether linear or spline
interpolation should be used.
</p>
</td></tr>
<tr><td><code id="interpp_+3A_extrap">extrap</code></td>
<td>

<p>logical flag: should extrapolation be used outside of the
convex hull determined by the data points? Not possible for linear
interpolation.</p>
</td></tr>
<tr><td><code id="interpp_+3A_duplicate">duplicate</code></td>
<td>

<p>indicates how to handle duplicate data points. Possible values are
<code>"error"</code> - produces an error message, <code>"strip"</code> - remove
duplicate z values, <code>"mean"</code>,<code>"median"</code>,<code>"user"</code>  -
calculate  mean , median or user defined function of duplicate z
values.
</p>
</td></tr>
<tr><td><code id="interpp_+3A_dupfun">dupfun</code></td>
<td>

<p>this function is applied to duplicate points if <code>duplicate="user"</code>
</p>
</td></tr>
<tr><td><code id="interpp_+3A_jitter">jitter</code></td>
<td>
<p>Jitter of amount of <code>diff(range(XX))*jitter</code> (XX=x
or y) will be added to coordinates if collinear points are
detected. Afterwards interpolation will be tried once again.
</p>
<p>Note that the jitter is not generated randomly unless
<code>jitter.random</code> is set to <code>TRUE</code>. This ensures
reproducable result. <code><a href="tripack.html#topic+tri.mesh">tri.mesh</a></code> of package
<code>tripack</code> uses the same jitter mechanism. That means you can
plot the triangulation on top of the interpolation and see the
same triangulation as used for interpolation, see examples below.
</p>
</td></tr>
<tr><td><code id="interpp_+3A_jitter.iter">jitter.iter</code></td>
<td>
<p>number of iterations to retry with jitter, amount
will be increased in each iteration by <code>iter^1.5</code></p>
</td></tr>
<tr><td><code id="interpp_+3A_jitter.random">jitter.random</code></td>
<td>
<p>logical, see <code>jitter</code>, defaults to
<code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="interpp_+3A_remove">remove</code></td>
<td>
<p>logical, indicates whether Akimas removal of thin triangles along
the border of the convex hull should be performed, experimental setting!
defaults to <code>!linear</code>, so it will be left out for linear interpolation
by default. For some point configurations it is the only
available option to skip this removal step.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with 3 components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>

<p>vector of x-coordinates of output points, the same as the input
argument <code>xo</code>.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>vector of y-coordinates of output points, the same as the input
argument <code>yo</code>.
</p>
</td></tr>
<tr><td><code>z</code></td>
<td>

<p>fitted z-values.  The value <code>z[i]</code> is computed
at the x,y point <code>x[i], y[i]</code>.
</p>
</td></tr>
</table>
<p>If input is <code>SpatialPointsDataFrame</code> than an according
<code>SpatialPointsDataFrame</code> is returned.
</p>


<h3>NOTE</h3>

<p>Use <code>interp</code> if interpolation on a regular grid is wanted.
</p>
<p>See <code><a href="#topic+interp">interp</a></code> for more details.
</p>


<h3>References</h3>

<p>Akima, H. (1978). A Method of Bivariate Interpolation and
Smooth Surface Fitting for Irregularly Distributed Data Points.
ACM Transactions on Mathematical Software,
<b>4</b>, 148-164.
</p>
<p>Akima, H. (1996). Algorithm 761: scattered-data surface fitting that has
the accuracy of a cubic polynomial.
ACM Transactions on Mathematical Software,
<b>22</b>, 362-371.
</p>
<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>
<p>R. J. Renka and Ron Brown (1998). Remark on algorithm 761.
ACM Transactions on Mathematical Software.
<b>24</b>, 383-385.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+image">image</a></code>,
<code><a href="stats.html#topic+approxfun">approxfun</a></code>, <code><a href="stats.html#topic+splinefun">splinefun</a></code>,
<code><a href="base.html#topic+outer">outer</a></code>, <code><a href="base.html#topic+expand.grid">expand.grid</a></code>,
<code><a href="#topic+interp">interp</a></code>, <code><a href="#topic+aspline">aspline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(akima)
# linear interpolation at points (1,2), (5,6) and (10,12)
akima.lip&lt;-interpp(akima$x, akima$y, akima$z,c(1,5,10),c(2,6,12))
akima.lip$z
# spline interpolation at the same locations
akima.sip&lt;-interpp(akima$x, akima$y, akima$z,c(1,5,10),c(2,6,12),
  linear=FALSE)
akima.sip$z
## Not run: 
    ## interaction with sp objects:
    library(sp)
    ## take 30 sample points out of meuse grid:
    data(meuse.grid)
    m0 &lt;- meuse.grid[sample(1:3103,30),]
    coordinates(m0) &lt;- ~x+y
    ## interpolate on this 30 points:
    ## note: both "meuse" and "m0" are sp objects
    ## (SpatialPointsDataFrame) !!
    ## arguments z and xo have to given, y has to be omitted!
    ipp &lt;- interpp(meuse,z="zinc",xo=m0)
    spplot(ipp)

## End(Not run)
</code></pre>

<hr>
<h2 id='interpp.old'>
Pointwise Bivariate Interpolation for Irregular Data
</h2><span id='topic+interpp.old'></span><span id='topic+interpp.new'></span>

<h3>Description</h3>

<p>If <code>ncp</code> is zero, linear
interpolation is used in the triangles bounded by data points.
Cubic interpolation is done if partial derivatives are used.
If <code>extrap</code> is <code>FALSE</code>, z-values for points outside the convex hull are
returned as <code>NA</code>.
No extrapolation can be performed if <code>ncp</code> is zero.
</p>
<p>The <code>interpp</code> function handles duplicate <code>(x,y)</code> points in
different ways. As default it will stop with an error message. But it
can give duplicate points an unique <code>z</code> value according to the
parameter <code>duplicate</code> (<code>mean</code>,<code>median</code> or any other
user defined function).
</p>
<p>The triangulation scheme used by <code>interp</code> works well if <code>x</code> and <code>y</code> have
similar scales but will appear stretched if they have very different
scales.  The spreads of <code>x</code> and <code>y</code> must be within four orders of magnitude
of each other for <code>interpp</code> to work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpp.old(x, y, z, xo, yo, ncp = 0, extrap = FALSE,
                    duplicate = "error", dupfun = NULL)
interpp.new(x, y, z, xo, yo, extrap = FALSE,
                    duplicate = "error", dupfun = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpp.old_+3A_x">x</code></td>
<td>

<p>vector of x-coordinates of data points or a
<code>SpatialPointsDataFrame</code> object.
Missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="interpp.old_+3A_y">y</code></td>
<td>

<p>vector of y-coordinates of data points.
Missing values are not accepted.
</p>
<p>If left as NULL indicates that <code>x</code> should be a
<code>SpatialPointsDataFrame</code> and <code>z</code> names the variable of
interest in this dataframe.
</p>
</td></tr>
<tr><td><code id="interpp.old_+3A_z">z</code></td>
<td>

<p>vector of z-coordinates of data points or a character variable
naming the variable of interest in the
<code>SpatialPointsDataFrame</code> <code>x</code>.
</p>
<p>Missing values are not accepted.
</p>
<p><code>x</code>, <code>y</code>, and <code>z</code> must be the same length
(execpt if <code>x</code> is a <code>SpatialPointsDataFrame</code>) and may contain no fewer
than four points. The points of <code>x</code> and <code>y</code>
cannot be collinear, i.e, they cannot fall on the same line (two vectors
<code>x</code> and <code>y</code> such that <code>y = ax + b</code> for some <code>a</code>, <code>b</code> will not be
accepted).
</p>
</td></tr>
<tr><td><code id="interpp.old_+3A_xo">xo</code></td>
<td>

<p>vector of x-coordinates of points at which to evaluate the interpolating
function. If <code>x</code> is a <code>SpatialPointsDataFrame</code> this has
also to be a <code>SpatialPointsDataFrame</code>.
</p>
</td></tr>
<tr><td><code id="interpp.old_+3A_yo">yo</code></td>
<td>

<p>vector of y-coordinates of points at which to evaluate the interpolating
function.
</p>
<p>If operating on <code>SpatialPointsDataFrame</code>s this is left as <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="interpp.old_+3A_ncp">ncp</code></td>
<td>

<p>deprecated, use parameter <code>linear</code>. Now only used by
<code>interpp.old()</code>.
</p>
<p>meaning was:
number of additional points to be used in computing partial
derivatives at each data point.
<code>ncp</code> must be either <code>0</code> (partial derivatives are not used, =
linear interpolation), or at
least 2 but smaller than the number of data points (and smaller than 25).
</p>
</td></tr>
<tr><td><code id="interpp.old_+3A_extrap">extrap</code></td>
<td>

<p>logical flag: should extrapolation be used outside of the
convex hull determined by the data points?</p>
</td></tr>
<tr><td><code id="interpp.old_+3A_duplicate">duplicate</code></td>
<td>

<p>indicates how to handle duplicate data points. Possible values are
<code>"error"</code> - produces an error message, <code>"strip"</code> - remove
duplicate z values, <code>"mean"</code>,<code>"median"</code>,<code>"user"</code>  -
calculate  mean , median or user defined function of duplicate z
values.
</p>
</td></tr>
<tr><td><code id="interpp.old_+3A_dupfun">dupfun</code></td>
<td>
<p>this function is applied to duplicate points if <code>duplicate="user"</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with 3 components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>

<p>vector of x-coordinates of output points, the same as the input
argument <code>xo</code>.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>vector of y-coordinates of output points, the same as the input
argument <code>yo</code>.
</p>
</td></tr>
<tr><td><code>z</code></td>
<td>

<p>fitted z-values.  The value <code>z[i]</code> is computed
at the x,y point <code>x[i], y[i]</code>.
</p>
</td></tr>
</table>
<p>If input is <code>SpatialPointsDataFrame</code> than an according
<code>SpatialPointsDataFrame</code> is returned.
</p>


<h3>NOTE</h3>

<p>Use <code>interp</code> if interpolation on a regular grid is wanted.
</p>
<p>The two versions  <code>interpp.old</code>  and <code>interpp.new</code> are now
deprecated, use <code><a href="#topic+interpp">interpp</a></code> instead, see details there.
</p>
<p>Earlier versions (pre 0.5-1) of <code>interpp</code> used the parameter
<code>ncp</code> to choose between linear and cubic interpolation, this is now done
by setting the logical parameter <code>linear</code>. Use of <code>ncp</code> is still
possible, but is deprecated.
</p>


<h3>References</h3>

<p>Akima, H. (1978). A Method of Bivariate Interpolation and
Smooth Surface Fitting for Irregularly Distributed Data Points.
ACM Transactions on Mathematical Software,
<b>4</b>, 148-164.
</p>
<p>Akima, H. (1996). Algorithm 761: scattered-data surface fitting that has
the accuracy of a cubic polynomial.
ACM Transactions on Mathematical Software,
<b>22</b>, 362-371.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+image">image</a></code>,
<code><a href="stats.html#topic+approxfun">approxfun</a></code>, <code><a href="stats.html#topic+splinefun">splinefun</a></code>,
<code><a href="base.html#topic+outer">outer</a></code>, <code><a href="base.html#topic+expand.grid">expand.grid</a></code>,
<code><a href="#topic+interp">interp</a></code>, <code><a href="#topic+aspline">aspline</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
