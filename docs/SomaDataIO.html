<!DOCTYPE html><html lang="en-US"><head><title>Help for package SomaDataIO</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SomaDataIO}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SomaDataIO-package'><p>SomaDataIO: Input/Output 'SomaScan' Data</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#adat-helpers'><p>Helpers to Extract Information from an ADAT</p></a></li>
<li><a href='#adat2eSet'><p>Convert ADAT to ExpressionSet Object</p></a></li>
<li><a href='#addAttributes'><p>Add Attributes to <code>soma_adat</code> Objects</p></a></li>
<li><a href='#addClass'><p>Add a Class to an Object</p></a></li>
<li><a href='#calc_eLOD'><p>Calculate Estimated Limit of Detection (eLOD)</p></a></li>
<li><a href='#cleanNames'><p>Clean Up Character String</p></a></li>
<li><a href='#Col.Meta'><p>Analyte Annotations, Col.Meta, and Row Info</p></a></li>
<li><a href='#diffAdats'><p>Diff Two ADAT Objects</p></a></li>
<li><a href='#getAnalyteInfo'><p>Get Analyte Annotation Information</p></a></li>
<li><a href='#getAnalytes'><p>Get Analytes</p></a></li>
<li><a href='#groupGenerics'><p>Group Generics for <code>soma_adat</code> Class Objects</p></a></li>
<li><a href='#is_intact_attr'><p>Are Attributes Intact?</p></a></li>
<li><a href='#is_seqFormat'><p>Test <code>AptName</code> Format</p></a></li>
<li><a href='#lift_adat'><p>Lift an ADAT Between Assay Versions</p></a></li>
<li><a href='#loadAdatsAsList'><p>Load ADAT files as a list</p></a></li>
<li><a href='#merge_clin'><p>Merge Clinical Data into SomaScan</p></a></li>
<li><a href='#params'><p>Common Parameters in <span class="pkg">SomaDataIO</span></p></a></li>
<li><a href='#parseHeader'><p>SomaLogic ADAT parser</p></a></li>
<li><a href='#pivotExpressionSet'><p>Convert to Long Format</p></a></li>
<li><a href='#read_adat'><p>Read (Load) SomaLogic ADATs</p></a></li>
<li><a href='#read_annotations'><p>Import a SomaLogic Annotations File</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rownames'><p>Helpers for Working With Row Names</p></a></li>
<li><a href='#SeqId'><p>Working with SomaLogic SeqIds</p></a></li>
<li><a href='#soma_adat'><p>The <code>soma_adat</code> Class and S3 Methods</p></a></li>
<li><a href='#SomaDataIO-deprecated'><p>Deprecated function(s) of the <span class="pkg">SomaDataIO</span> package</p></a></li>
<li><a href='#SomaScanObjects'><p>Example Data and Objects</p></a></li>
<li><a href='#transform'><p>Scale Transform <code>soma_adat</code> Columns/Rows</p></a></li>
<li><a href='#write_adat'><p>Write an ADAT to File</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Input/Output 'SomaScan' Data</td>
</tr>
<tr>
<td>Version:</td>
<td>6.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Load and export 'SomaScan' data via the
    'Standard BioTools, Inc.' structured text file
    called an ADAT ('*.adat'). For file format see
    <a href="https://github.com/SomaLogic/SomaLogic-Data/blob/main/README.md">https://github.com/SomaLogic/SomaLogic-Data/blob/main/README.md</a>.
    The package also exports auxiliary functions for
    manipulating, wrangling, and extracting relevant
    information from an ADAT object once in memory.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://somalogic.github.io/SomaDataIO/">https://somalogic.github.io/SomaDataIO/</a>, <a href="https://somalogic.com">https://somalogic.com</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SomaLogic/SomaDataIO/issues">https://github.com/SomaLogic/SomaDataIO/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr (&ge; 1.0.6), lifecycle (&ge; 1.0.0), magrittr (&ge;
2.0.1), methods, readxl (&ge; 1.3.1), tibble (&ge; 3.1.2), tidyr
(&ge; 1.1.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Biobase, ggplot2, knitr, purrr, recipes, rlang, rmarkdown,
spelling, testthat (&ge; 3.0.0), usethis (&ge; 2.0.1), withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Standard BioTools, Inc. 2025</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-06 20:07:58 UTC; cscheidel</td>
</tr>
<tr>
<td>Author:</td>
<td>Stu Field <a href="https://orcid.org/0000-0002-1024-5859"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Caleb Scheidel [cre],
  Standard BioTools, Inc. [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Caleb Scheidel &lt;calebjscheidel@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-07 00:40:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='SomaDataIO-package'>SomaDataIO: Input/Output 'SomaScan' Data</h2><span id='topic+SomaDataIO'></span><span id='topic+SomaDataIO-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Load and export 'SomaScan' data via the 'Standard BioTools, Inc.' structured text file called an ADAT ('*.adat'). For file format see <a href="https://github.com/SomaLogic/SomaLogic-Data/blob/main/README.md">https://github.com/SomaLogic/SomaLogic-Data/blob/main/README.md</a>. The package also exports auxiliary functions for manipulating, wrangling, and extracting relevant information from an ADAT object once in memory.
</p>


<h3>Details</h3>

<p>Load an ADAT file into the global workspace with a call
to <code><a href="#topic+read_adat">read_adat()</a></code>. This function parses the main data
table into a <code>data.frame</code> object and assigns the remaining data from
the file as object <code>attributes</code>, i.e. call <code>attributes(adat)</code>.
Other functions in the package are designed to make extracting,
manipulating, and wrangling data in the newly created <a href="#topic+soma_adat">soma_adat</a>
object more convenient.
</p>
<p>Those familiar with micro-array data analysis and associated packages, e.g.
<span class="pkg">Biobase</span>, will notice that the feature data (proteins) are arranged as
columns and the samples (arrays) are the rows. This is the
transpose of typical micro-array data. This conflict can be easily solved
using the transpose function, <code><a href="base.html#topic+t">t()</a></code>, which is part of the <code style="white-space: pre;">&#8288;base R&#8288;</code>.
In addition, those familiar with the standard <code>ExpressionSet</code> object,
available from <code>Bioconductor</code>, might find the functions <code><a href="#topic+adat2eSet">adat2eSet()</a></code> and
<code><a href="#topic+pivotExpressionSet">pivotExpressionSet()</a></code> particularly useful.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Caleb Scheidel <a href="mailto:calebjscheidel@gmail.com">calebjscheidel@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Stu Field <a href="mailto:stu.g.field@gmail.com">stu.g.field@gmail.com</a> (<a href="https://orcid.org/0000-0002-1024-5859">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Standard BioTools, Inc. [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://somalogic.github.io/SomaDataIO/">https://somalogic.github.io/SomaDataIO/</a>
</p>
</li>
<li> <p><a href="https://somalogic.com">https://somalogic.com</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/SomaLogic/SomaDataIO/issues">https://github.com/SomaLogic/SomaDataIO/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># a listing of all pkg functions
library(help = SomaDataIO)

# the `soma_adat` class
class(example_data)
is.soma_adat(example_data)

# Annotations Lookup Table
anno_tbl &lt;- getAnalyteInfo(example_data)
anno_tbl

# Find all analytes starting with "MMP" in `anno_tbl`
dplyr::filter(anno_tbl, grepl("^MMP", Target))
</code></pre>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='adat-helpers'>Helpers to Extract Information from an ADAT</h2><span id='topic+adat-helpers'></span><span id='topic+getAdatVersion'></span><span id='topic+getSomaScanVersion'></span><span id='topic+getSignalSpace'></span><span id='topic+checkSomaScanVersion'></span><span id='topic+getSomaScanLiftCCC'></span>

<h3>Description</h3>

<p>Retrieve elements of the <code>HEADER</code> attribute of a <code>soma_adat</code> object:
</p>
<p><code><a href="#topic+getAdatVersion">getAdatVersion()</a></code> determines the the ADAT version
number from a parsed ADAT header.
</p>
<p><code><a href="#topic+getSomaScanVersion">getSomaScanVersion()</a></code> determines the original SomaScan assay version
that generated RFU measurements within a <code>soma_adat</code> object.
</p>
<p><code><a href="#topic+checkSomaScanVersion">checkSomaScanVersion()</a></code> determines if the version of
is a recognized version of SomaScan.
</p>
<p>Table of SomaScan assay versions:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Version</strong>  </td><td style="text-align: center;"> <strong>Commercial Name</strong> </td><td style="text-align: right;"> <strong>Size</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>V4</code>         </td><td style="text-align: center;"> 5k                  </td><td style="text-align: right;"> 5284     </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>v4.1</code>       </td><td style="text-align: center;"> 7k                  </td><td style="text-align: right;"> 7596     </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>v5.0</code>       </td><td style="text-align: center;"> 11k                 </td><td style="text-align: right;"> 11083    </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code><a href="#topic+getSignalSpace">getSignalSpace()</a></code> determines the current signal space of
the RFU values, which may differ from the original SomaScan
signal space if the data have been lifted. See <code><a href="#topic+lift_adat">lift_adat()</a></code> and
<code>vignette("lifting-and-bridging", package = "SomaDataIO")</code>.
</p>
<p><code><a href="#topic+getSomaScanLiftCCC">getSomaScanLiftCCC()</a></code> accesses the lifting Concordance Correlation
Coefficients between various SomaScan versions. For more about
CCC metrics see <code><a href="#topic+lift_adat">lift_adat()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAdatVersion(x)

getSomaScanVersion(adat)

getSignalSpace(adat)

checkSomaScanVersion(ver)

getSomaScanLiftCCC(matrix = c("plasma", "serum"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adat-helpers_+3A_x">x</code></td>
<td>
<p>Either a <code>soma_adat</code> object with intact attributes or
the attributes themselves of a <code>soma_adat</code> object.</p>
</td></tr>
<tr><td><code id="adat-helpers_+3A_adat">adat</code></td>
<td>
<p>A <code>soma_adat</code> object (with intact attributes),
typically created using <code><a href="#topic+read_adat">read_adat()</a></code>.</p>
</td></tr>
<tr><td><code id="adat-helpers_+3A_ver">ver</code></td>
<td>
<p><code>character(1)</code>. The SomaScan version as a string.
<strong>Note:</strong> the <code>"v"</code>-prefix is case <em>in</em>sensitive.</p>
</td></tr>
<tr><td><code id="adat-helpers_+3A_matrix">matrix</code></td>
<td>
<p>Character. A string of (usually) either
<code>"serum"</code> or <code>"plasma"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>\link[=getAdatVersion]{getAdatVersion()}</code></td>
<td>
<p>The key-value of the <code>Version</code> as a string.</p>
</td></tr>
<tr><td><code>\link[=getSomaScanVersion]{getSomaScanVersion()}</code></td>
<td>
<p>The key-value of the <code>AssayVersion</code> as a string.</p>
</td></tr>
<tr><td><code>\link[=getSignalSpace]{getSignalSpace()}</code></td>
<td>
<p>The key-value of the <code>SignalSpace</code> as a string.</p>
</td></tr>
<tr><td><code>\link[=checkSomaScanVersion]{checkSomaScanVersion()}</code></td>
<td>
<p>Returns <code>NULL</code> (invisibly) if checks pass.</p>
</td></tr>
<tr><td><code>\link[=getSomaScanLiftCCC]{getSomaScanLiftCCC()}</code></td>
<td>
<p>Returns a tibble of either the
<code>serum</code> or <code>plasma</code> CCC between various versions of the SomaScan assay.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>References</h3>

<p>Lin, Lawrence I-Kuei. 1989. A Concordance Correlation
Coefficient to Evaluate Reproducibility. <strong>Biometrics</strong>. 45:255-268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getAdatVersion(example_data)

attr(example_data, "Header.Meta")$HEADER$Version &lt;- "99.9"
getAdatVersion(example_data)

ver &lt;- getSomaScanVersion(example_data)
ver

rfu_space &lt;- getSignalSpace(example_data)
rfu_space

is.null(checkSomaScanVersion(ver))

# plasma (default)
getSomaScanLiftCCC()

# serum
getSomaScanLiftCCC("serum")
</code></pre>

<hr>
<h2 id='adat2eSet'>Convert ADAT to ExpressionSet Object</h2><span id='topic+adat2eSet'></span>

<h3>Description</h3>

<p>Utility to convert a SomaLogic <code>soma_adat</code> object to an
<code>ExpressionSet</code> object via the <span class="pkg">Biobase</span> package
from <strong>Bioconductor</strong>:
<a href="https://www.bioconductor.org/packages/release/bioc/html/Biobase.html">https://www.bioconductor.org/packages/release/bioc/html/Biobase.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adat2eSet(adat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adat2eSet_+3A_adat">adat</code></td>
<td>
<p>A <code>soma_adat</code> class object as read into the R
environment using <code><a href="#topic+read_adat">read_adat()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <span class="pkg">Biobase</span> package is required and must be installed from
<strong>Bioconductor</strong> via the following at the R console:
</p>
<div class="sourceCode"><pre>if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}
BiocManager::install("Biobase", version = remotes::bioc_version())
</pre></div>


<h3>Value</h3>

<p>A Bioconductor object of class <code>ExpressionSet</code>.
</p>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>References</h3>

<p><a href="https://bioconductor.org/install/">https://bioconductor.org/install/</a>
</p>


<h3>See Also</h3>

<p>Other eSet: 
<code><a href="#topic+pivotExpressionSet">pivotExpressionSet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
eSet &lt;- adat2eSet(example_data)
class(eSet)
eSet

ft &lt;- Biobase::exprs(eSet)
head(ft[, 1:10L], 10L)

</code></pre>

<hr>
<h2 id='addAttributes'>Add Attributes to <code>soma_adat</code> Objects</h2><span id='topic+addAttributes'></span>

<h3>Description</h3>

<p>Adds a set of attributes, typically &quot;Header.Meta&quot; and &quot;Col.Meta&quot;,
to a <code>data.frame</code>, <code>tibble</code>, <code>soma_adat</code> or similar tabular object.
Existing attributes <code>data</code> are <em>not</em> over-written.
Typically untouched are:
</p>

<ul>
<li> <p><code>names</code>
</p>
</li>
<li> <p><code>class</code>
</p>
</li>
<li> <p><code>row.names</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>addAttributes(data, new.atts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addAttributes_+3A_data">data</code></td>
<td>
<p>The <em>receiving</em> <code>data.frame</code> object for new attributes.</p>
</td></tr>
<tr><td><code id="addAttributes_+3A_new.atts">new.atts</code></td>
<td>
<p>A <em>named</em> <code>list</code> object containing new attributes
to add to the existing ones.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame object corresponding to <code>data</code> but with the
attributes of <code>new.atts</code> grafted on to it.
Existing attribute names are <em>not</em> over-written.
</p>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+attr">attr()</a></code>, <code><a href="base.html#topic+setdiff">setdiff()</a></code>
</p>

<hr>
<h2 id='addClass'>Add a Class to an Object</h2><span id='topic+addClass'></span>

<h3>Description</h3>

<p>Utility to add (prepend) a class(es) to existing objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addClass(x, class)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addClass_+3A_x">x</code></td>
<td>
<p>The object to receive new class(es).</p>
</td></tr>
<tr><td><code id="addClass_+3A_class">class</code></td>
<td>
<p>Character. The name of additional class(es).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with new classes.
</p>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+class">class()</a></code>, <code><a href="base.html#topic+typeof">typeof()</a></code>, <code><a href="base.html#topic+structure">structure()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>class(iris)

addClass(iris, "new") |&gt; class()

addClass(iris, c("A", "B")) |&gt; class()    # 2 classes

addClass(iris, c("A", "data.frame")) |&gt; class()    # no duplicates

addClass(iris, c("data.frame", "A")) |&gt; class()    # re-orders if exists
</code></pre>

<hr>
<h2 id='calc_eLOD'>Calculate Estimated Limit of Detection (eLOD)</h2><span id='topic+calc_eLOD'></span>

<h3>Description</h3>

<p>Calculate the estimated limit of detection (eLOD) for SOMAmer reagent
analytes in the provided input data. The input data should be filtered to
include only buffer samples desired for eLOD calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_eLOD(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_eLOD_+3A_data">data</code></td>
<td>
<p>A <code>soma_adat</code>, <code>data.frame</code>, or <code>tibble</code> object including
SeqId columns (<code>seq.xxxxx.xx</code>) containing RFU values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>eLOD is calculated using the following steps:
</p>

<ol>
<li><p> For each SOMAmer, the median and adjusted median absolute
deviation (<code class="reqn">MAD_{Adjusted}</code>) are calculated, where
</p>
<p style="text-align: center;"><code class="reqn">MAD_{Adjusted} = 1.4826 * MAD</code>
</p>

<p>The 1.4826 is a set constant used to adjust the MAD to be reflective of
the standard deviation of the normal distribution.
</p>
</li>
<li><p> For each SOMAmer, calculate </p>
<p style="text-align: center;"><code class="reqn">eLOD = median + 3.3 * MAD_{Adjusted}</code>
</p>

</li></ol>

<p>Note: The eLOD is useful for non-core matrices, including cell lysate
and CSF, but should be used carefully for evaluating background signal in
plasma and serum.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> object with 2 columns: SeqId and eLOD.
</p>


<h3>Author(s)</h3>

<p>Caleb Scheidel, Christopher Dimapasok
</p>


<h3>Examples</h3>

<pre><code class='language-R'># filter data frame using vector of SampleId controls
df &lt;- withr::with_seed(101, {
  data.frame(
    SampleType = rep(c("Sample", "Buffer"), each = 10),
    SampleId = paste0("Sample_", 1:20),
    seq.20.1.100 = runif(20, 1, 100),
    seq.21.1.100 = runif(20, 1, 100),
    seq.22.2.100 = runif(20, 1, 100)
  )
})
sample_ids &lt;- paste0("Sample_", 11:20)
selected_samples &lt;- df |&gt; filter(SampleId %in% sample_ids)

selected_elod &lt;- calc_eLOD(selected_samples)
head(selected_elod)
## Not run: 
# filter `soma_adat` object to buffer samples
buffer_samples &lt;- example_data |&gt; filter(SampleType == "Buffer")

# calculate eLOD
buffer_elod &lt;- calc_eLOD(buffer_samples)
head(buffer_elod)

# use eLOD to calculate signal to noise ratio of samples
samples_median &lt;- example_data |&gt; dplyr::filter(SampleType == "Sample") |&gt;
  dplyr::summarise(across(starts_with("seq"), median, .names = "median_{col}")) |&gt;
  tidyr::pivot_longer(starts_with("median_"), names_to = "SeqId",
                      values_to = "median_signal") |&gt;
  dplyr::mutate(SeqId = gsub("median_seq", "seq", SeqId))

# analytes with signal to noise &gt; 2
ratios &lt;- samples_median |&gt;
  dplyr::mutate(signal_to_noise = median_signal / buffer_elod$eLOD) |&gt;
  dplyr::filter(signal_to_noise &gt; 2) |&gt;
  dplyr::arrange(desc(signal_to_noise))

head(ratios)

## End(Not run)
</code></pre>

<hr>
<h2 id='cleanNames'>Clean Up Character String</h2><span id='topic+cleanNames'></span>

<h3>Description</h3>

<p>Often the names, particularly within <code>soma_adat</code> objects,
are messy due to varying inputs, this function attempts to remedy this by
removing the following:
</p>

<ul>
<li><p> trailing/leading/internal whitespace
</p>
</li>
<li><p> non-alphanumeric strings (except underscores)
</p>
</li>
<li><p> duplicated internal dots (<code>..</code>), (<code>...</code>), etc.
</p>
</li>
<li><p> SomaScan normalization scale factor format
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cleanNames(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cleanNames_+3A_x">x</code></td>
<td>
<p>Character. String to clean up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cleaned up character string.
</p>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+trimws">trimws()</a></code>, <code><a href="base.html#topic+gsub">gsub()</a></code>, <code><a href="base.html#topic+sub">sub()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cleanNames("    sdkfj...sdlkfj.sdfii4994### ")

cleanNames("Hyb..Scale")
</code></pre>

<hr>
<h2 id='Col.Meta'>Analyte Annotations, Col.Meta, and Row Info</h2><span id='topic+Col.Meta'></span><span id='topic+colmeta'></span><span id='topic+annotations'></span><span id='topic+rowmeta'></span>

<h3>Description</h3>

<p>In a standard SomaLogic ADAT, the section of information that
sits directly above the measurement data (RFU data matrix) is
the column meta data (<code>Col.Meta</code>), which contains detailed information
and annotations about the analytes, <code><a href="#topic+SeqId">SeqId()</a></code>s, and their targets.
See section below for further information about available
fields and their descriptions. Use <code><a href="#topic+getAnalyteInfo">getAnalyteInfo()</a></code> to
obtain an object containing this information for programmatic analyses,
and use <code><a href="#topic+getMeta">getMeta()</a></code> to obtain the column names representing the
row-specific meta data about the samples (see section below).
</p>


<h3>Col Meta (Analyte Annotations)</h3>

<p>Information describing the <em>analytes</em> is found to the above
the data matrix in a standard SomaLogic ADAT. This information may
consist of the any or all of the following:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Field</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Example</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   SeqId </td><td style="text-align: left;"> SomaLogic sequence identifier </td><td style="text-align: left;"> 2182-54_1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SeqidVersion </td><td style="text-align: left;"> Version of SOMAmer sequence </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SomaId </td><td style="text-align: left;"> Target identifier, of the form SLnnnnnn (8 characters in length) </td><td style="text-align: left;"> SL000318 </td>
</tr>
<tr>
 <td style="text-align: left;">
   TargetFullName </td><td style="text-align: left;"> Target name curated for consistency with UniProt name </td><td style="text-align: left;"> Complement C4b </td>
</tr>
<tr>
 <td style="text-align: left;">
   Target </td><td style="text-align: left;"> SomaLogic Target Name </td><td style="text-align: left;"> C4b </td>
</tr>
<tr>
 <td style="text-align: left;">
   UniProt </td><td style="text-align: left;"> UniProt identifier(s) </td><td style="text-align: left;"> P0C0L4  P0C0L5 </td>
</tr>
<tr>
 <td style="text-align: left;">
   EntrezGeneID </td><td style="text-align: left;"> Entrez Gene Identifier(s) </td><td style="text-align: left;"> 720 721 </td>
</tr>
<tr>
 <td style="text-align: left;">
   EntrezGeneSymbol </td><td style="text-align: left;"> Entrez Gene Symbol names </td><td style="text-align: left;"> C4A C4B </td>
</tr>
<tr>
 <td style="text-align: left;">
   Organism </td><td style="text-align: left;"> Protein Source Organism </td><td style="text-align: left;"> Human </td>
</tr>
<tr>
 <td style="text-align: left;">
   Units </td><td style="text-align: left;"> Relative Fluorescence Units </td><td style="text-align: left;"> RFU </td>
</tr>
<tr>
 <td style="text-align: left;">
   Type </td><td style="text-align: left;"> SOMAmer target type </td><td style="text-align: left;"> Protein </td>
</tr>
<tr>
 <td style="text-align: left;">
   Dilution </td><td style="text-align: left;"> Dilution mix assignment </td><td style="text-align: left;"> 0.01% </td>
</tr>
<tr>
 <td style="text-align: left;">
   PlateScale_Reference </td><td style="text-align: left;"> PlateScale reference value </td><td style="text-align: left;"> 1378.85 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CalReference </td><td style="text-align: left;"> Calibration sample reference value </td><td style="text-align: left;"> 1378.85 </td>
</tr>
<tr>
 <td style="text-align: left;">
   medNormRef_ReferenceRFU </td><td style="text-align: left;"> Median normalization reference value </td><td style="text-align: left;"> 490.342 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Cal_V4_<code style="white-space: pre;">&#8288;&lt;YY&gt;_&lt;SSS&gt;_&lt;PPP&gt;&#8288;</code> </td><td style="text-align: left;"> Calibration scale factor (for given Year_Study_Plate) </td><td style="text-align: left;"> 0.64 </td>
</tr>
<tr>
 <td style="text-align: left;">
   ColCheck </td><td style="text-align: left;"> QC acceptance criteria across all plates/sets </td><td style="text-align: left;"> PASS </td>
</tr>
<tr>
 <td style="text-align: left;">
   QcReference_<code style="white-space: pre;">&#8288;&lt;LLLLL&gt;&#8288;</code> </td><td style="text-align: left;"> QC sample reference value (for given QC lot) </td><td style="text-align: left;"> PASS </td>
</tr>
<tr>
 <td style="text-align: left;">
   CalQcRatio_V4_<code style="white-space: pre;">&#8288;&lt;YY&gt;_&lt;SSS&gt;_&lt;PPP&gt;&#8288;</code> </td><td style="text-align: left;"> Post calibration median QC ratio to reference (for given Year_Study_Plate) </td><td style="text-align: left;"> 1.04 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Row Meta (Sample Annotations)</h3>

<p>Information describing the <em>samples</em> is typically found to the left of
the data matrix in a standard SomaLogic ADAT. This information may
consist of clinical information provided by the client, or run-specific
diagnostic information included for assay quality control. Below are
some examples of what may be present in this section:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Field</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Examples</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   PlateId </td><td style="text-align: left;"> Plate identifier </td><td style="text-align: left;"> V4-18-004_001, V4-18-004_002 </td>
</tr>
<tr>
 <td style="text-align: left;">
   ScannerID </td><td style="text-align: left;"> Scanner used to analyze slide </td><td style="text-align: left;"> SG12064173, SG14374437 </td>
</tr>
<tr>
 <td style="text-align: left;">
   PlatePosition </td><td style="text-align: left;"> Location on 96 well plate (A1-H12) </td><td style="text-align: left;"> A1, H12 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SlideId </td><td style="text-align: left;"> Agilent slide barcode </td><td style="text-align: left;"> 2.58E+11 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Subarray </td><td style="text-align: left;"> Agilent subarray (1 – 8) </td><td style="text-align: left;"> 1,8 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SampleId </td><td style="text-align: left;"> 1st form is Subject Identifier, 2nd form (calibrators, buffers) </td><td style="text-align: left;"> 2031 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SampleType </td><td style="text-align: left;"> 1st form for clinical samples (Sample), 2nd form as above </td><td style="text-align: left;"> Sample, QC, Calibrator, Buffer </td>
</tr>
<tr>
 <td style="text-align: left;">
   PercentDilution </td><td style="text-align: left;"> Highest concentration the SOMAmer dilution groups </td><td style="text-align: left;"> 20 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SampleMatrix </td><td style="text-align: left;"> Sample matrix </td><td style="text-align: left;"> Plasma-PPT </td>
</tr>
<tr>
 <td style="text-align: left;">
   Barcode </td><td style="text-align: left;"> 1D Barcode of aliquot </td><td style="text-align: left;"> S622225 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Barcode2d </td><td style="text-align: left;"> 2D Barcode of aliquot </td><td style="text-align: left;"> 1.91E+08 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SampleNotes </td><td style="text-align: left;"> Assay team sample observation </td><td style="text-align: left;"> Cloudy, Low sample volume, Reddish </td>
</tr>
<tr>
 <td style="text-align: left;">
   SampleDescription </td><td style="text-align: left;"> Supplemental sample information </td><td style="text-align: left;"> Plasma QC 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   AssayNotes </td><td style="text-align: left;"> Assay team run observation </td><td style="text-align: left;"> Beads aspirated, Leak/Hole, Smear </td>
</tr>
<tr>
 <td style="text-align: left;">
   TimePoint </td><td style="text-align: left;"> Sample time point </td><td style="text-align: left;"> Baseline </td>
</tr>
<tr>
 <td style="text-align: left;">
   ExtIdentifier </td><td style="text-align: left;"> Primary key for Subarray </td><td style="text-align: left;"> EXID40000000032037 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SsfExtId </td><td style="text-align: left;"> Primary key for sample </td><td style="text-align: left;"> EID102733 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SampleGroup </td><td style="text-align: left;"> Sample group </td><td style="text-align: left;"> A, B </td>
</tr>
<tr>
 <td style="text-align: left;">
   SiteId </td><td style="text-align: left;"> Collection site </td><td style="text-align: left;"> SomaLogic, Covance </td>
</tr>
<tr>
 <td style="text-align: left;">
   TubeUniqueID </td><td style="text-align: left;"> Unique tube identifier </td><td style="text-align: left;"> 1.12E+11 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CLI </td><td style="text-align: left;"> Cohort definition identifier </td><td style="text-align: left;"> CLI6006F001 </td>
</tr>
<tr>
 <td style="text-align: left;">
   HybControlNormScale </td><td style="text-align: left;"> Hybridization control scale factor </td><td style="text-align: left;"> 0.948304 </td>
</tr>
<tr>
 <td style="text-align: left;">
   RowCheck </td><td style="text-align: left;"> Normalization acceptance criteria for all row scale factors </td><td style="text-align: left;"> PASS, FLAG </td>
</tr>
<tr>
 <td style="text-align: left;">
   NormScale_0_5 </td><td style="text-align: left;"> Median signal normalization scale factor (0.5% mix) </td><td style="text-align: left;"> 1.02718 </td>
</tr>
<tr>
 <td style="text-align: left;">
   NormScale_0_005 </td><td style="text-align: left;"> Median signal normalization scale factor (0.005% mix) </td><td style="text-align: left;"> 1.119754 </td>
</tr>
<tr>
 <td style="text-align: left;">
   NormScale_20 </td><td style="text-align: left;"> Median signal normalization scale factor (20% mix) </td><td style="text-align: left;"> 0.996148 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># Annotations/Col.Meta
tbl &lt;- getAnalyteInfo(example_data)
tbl

# Row/sample Meta
r_m &lt;- getMeta(example_data)
head(r_m)

# Normalization Scale Factors
grep("NormScale", r_m, value = TRUE)

# adat subset
example_data[1:3, head(r_m)]
</code></pre>

<hr>
<h2 id='diffAdats'>Diff Two ADAT Objects</h2><span id='topic+diffAdats'></span>

<h3>Description</h3>

<p>Diff tool for the differences between two <code>soma_adat</code> objects.
When diffs of the table <em>values</em> are interrogated, <strong>only</strong>
the intersect of the column meta data or feature data is considered
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffAdats(adat1, adat2, tolerance = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diffAdats_+3A_adat1">adat1</code>, <code id="diffAdats_+3A_adat2">adat2</code></td>
<td>
<p>Two <code>soma_adat</code> objects to compare.</p>
</td></tr>
<tr><td><code id="diffAdats_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>. Differences smaller than tolerance are
not triggered. See <code><a href="base.html#topic+all.equal">all.equal()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly. Called for side effects.
</p>


<h3>Note</h3>

<p>Only diffs of the column name <em>intersect</em> are reported.
</p>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>Examples</h3>

<pre><code class='language-R'># subset `example_data` for speed
# all SeqIds from 2000 -&gt; 2999
seqs &lt;- grep("^seq\\.2[0-9]{3}", names(example_data), value = TRUE)
ex_data_small &lt;- head(example_data[, c(getMeta(example_data), seqs)], 10L)
dim(ex_data_small)

# no diff to itself
diffAdats(ex_data_small, ex_data_small)

# remove random column
rm &lt;- withr::with_seed(123, sample(1:ncol(ex_data_small), 1))
diffAdats(ex_data_small, ex_data_small[, -rm])

# randomly shuffle Subarray
diffAdats(ex_data_small, dplyr::mutate(ex_data_small, Subarray = sample(Subarray)))

# modify 2 RFUs randomly
new &lt;- ex_data_small
new[5L, c(rm, rm + 1L)] &lt;- 999
diffAdats(ex_data_small, new)
</code></pre>

<hr>
<h2 id='getAnalyteInfo'>Get Analyte Annotation Information</h2><span id='topic+getAnalyteInfo'></span><span id='topic+getTargetNames'></span><span id='topic+getFeatureData'></span>

<h3>Description</h3>

<p>Uses the <code>Col.Meta</code> attribute (analyte annotation data that appears above
the protein measurements in the <code style="white-space: pre;">&#8288;*.adat&#8288;</code> text file) of a <code>soma_adat</code> object,
adds the <code>AptName</code> column key, conducts a few sanity checks, and
generates a &quot;lookup table&quot; of analyte data that can be used for simple
manipulation and indexing of analyte annotation information.
Most importantly, the analyte column names of the <code>soma_adat</code>
(e.g. <code>seq.XXXX.XX</code>) become the <code>AptName</code> column of the lookup table and
represents the key index between the table and <code>soma_adat</code> from which it comes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAnalyteInfo(adat)

getTargetNames(tbl)

getFeatureData(adat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAnalyteInfo_+3A_adat">adat</code></td>
<td>
<p>A <code>soma_adat</code> object (with intact attributes),
typically created using <code><a href="#topic+read_adat">read_adat()</a></code>.</p>
</td></tr>
<tr><td><code id="getAnalyteInfo_+3A_tbl">tbl</code></td>
<td>
<p>A <code>tibble</code> object containing analyte target annotation
information. This is usually the result of a call to <code><a href="#topic+getAnalyteInfo">getAnalyteInfo()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> object with columns corresponding
to the column meta data entries in the <code>soma_adat</code>. One row per analyte.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getTargetNames()</code>: creates a lookup table (or dictionary) as a named list object of <code>AptNames</code>
and Target names in key-value pairs.
This is a convenient tool to quickly access a <code>TargetName</code> given
the <code>AptName</code> in which the key-value pairs map the <code>seq.XXXX.XX</code>
to its corresponding <code>TargetName</code> in <code>tbl</code>.
This structure which provides a convenient auto-completion mechanism at
the command line or for generating plot titles.
</p>
</li>
<li> <p><code>getFeatureData()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>. Please now use <code><a href="#topic+getAnalyteInfo">getAnalyteInfo()</a></code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAnalytes">getAnalytes()</a></code>, <code><a href="#topic+is_intact_attr">is_intact_attr()</a></code>, <code><a href="#topic+read_adat">read_adat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get Aptamer table
anno_tbl &lt;- getAnalyteInfo(example_data)
anno_tbl

# Use `dplyr::group_by()`
dplyr::tally(dplyr::group_by(anno_tbl, Dilution))  # print summary by dilution

# Columns containing "Target"
anno_tbl |&gt;
  dplyr::select(dplyr::contains("Target"))

# Rows of "Target" starting with MMP
anno_tbl |&gt;
  dplyr::filter(grepl("^MMP", Target))

# Target names
tg &lt;- getTargetNames(anno_tbl)

# how to use for plotting
feats &lt;- sample(anno_tbl$AptName, 6)
op &lt;- par(mfrow = c(2, 3))
sapply(feats, function(.x) plot(1:10, main = tg[[.x]]))
par(op)
</code></pre>

<hr>
<h2 id='getAnalytes'>Get Analytes</h2><span id='topic+getAnalytes'></span><span id='topic+getMeta'></span><span id='topic+getFeatures'></span>

<h3>Description</h3>

<p>Return the feature names (i.e. the column names for
SOMAmer reagent analytes) from a <code>soma_adat</code>.
S3 methods also exist for these classes:
</p>
<div class="sourceCode"><pre>#&gt; [1] getAnalytes.character  getAnalytes.data.frame getAnalytes.default   
#&gt; [4] getAnalytes.list       getAnalytes.matrix     getAnalytes.recipe    
#&gt; [7] getAnalytes.soma_adat 
#&gt; see '?methods' for accessing help and source code
</pre></div>
<p><code><a href="#topic+getMeta">getMeta()</a></code> returns the inverse, a character vector of string
names of <em>non</em>-analyte feature columns/variables, which typically
correspond to the clinical (&quot;meta&quot;) data variables.
S3 methods exist for these classes:
</p>
<div class="sourceCode"><pre>#&gt; [1] getMeta.character  getMeta.data.frame getMeta.default    getMeta.list      
#&gt; [5] getMeta.matrix     getMeta.soma_adat 
#&gt; see '?methods' for accessing help and source code
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>getAnalytes(x, n = FALSE, rm.controls = FALSE)

getMeta(x, n = FALSE)

getFeatures(x, n = FALSE, rm.controls = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAnalytes_+3A_x">x</code></td>
<td>
<p>Typically a <code>soma_adat</code> class object created using <code><a href="#topic+read_adat">read_adat()</a></code>.</p>
</td></tr>
<tr><td><code id="getAnalytes_+3A_n">n</code></td>
<td>
<p>Logical. Return an integer corresponding to the <em>length</em>
of the features?</p>
</td></tr>
<tr><td><code id="getAnalytes_+3A_rm.controls">rm.controls</code></td>
<td>
<p>Logical. Should all control and non-human analytes
(e.g. <code>HybControls</code>, <code>Non-Human</code>, <code>Non-Biotin</code>, <code>Spuriomer</code>) be removed
from the returned value?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+getAnalytes">getAnalytes()</a></code>: a character vector of ADAT feature (&quot;analyte&quot;) names.
</p>
<p><code><a href="#topic+getMeta">getMeta()</a></code>: a character vector of ADAT clinical (&quot;meta&quot;) data names.
</p>
<p>For both, if <code>n = TRUE</code>, an integer corresponding to the
<strong>length</strong> of the character vector.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getFeatures()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>. Please now use <code><a href="#topic+getAnalytes">getAnalytes()</a></code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.apt">is.apt()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># RFU feature variables
apts &lt;- getAnalytes(example_data)
head(apts)
getAnalytes(example_data, n = TRUE)

# vector string
bb &lt;- getAnalytes(names(example_data))
all.equal(apts, bb)

# create some control sequences
# ~~~~~~~~~ Spuriomer ~~~ HybControl ~~~
apts2 &lt;- c("seq.2053.2", "seq.2171.12", head(apts))
apts2
no_crtl &lt;- getAnalytes(apts2, rm.controls = TRUE)
no_crtl
setdiff(apts2, no_crtl)

# clinical variables
mvec &lt;- getMeta(example_data)
head(mvec, 10)
getMeta(example_data, n = TRUE)

# test 'data.frame' and 'character' S3 methods are identical
identical(getMeta(example_data), getMeta(names(example_data))) # TRUE
</code></pre>

<hr>
<h2 id='groupGenerics'>Group Generics for <code>soma_adat</code> Class Objects</h2><span id='topic+groupGenerics'></span><span id='topic+Math.soma_adat'></span><span id='topic+antilog'></span><span id='topic+Ops.soma_adat'></span><span id='topic+Summary.soma_adat'></span><span id='topic++3D+3D.soma_adat'></span>

<h3>Description</h3>

<p>S3 group generic methods to apply group specific prototype functions
to the RFU data <strong>only</strong> of <code>soma_adat</code> objects.
The clinical meta data are <em>not</em> transformed and remain unmodified in
the returned object (<code><a href="base.html#topic+Math">Math()</a></code> and <code><a href="base.html#topic+Ops">Ops()</a></code>) or are ignored for the
<code><a href="base.html#topic+Summary">Summary()</a></code> group. See <code><a href="base.html#topic+groupGeneric">groupGeneric()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'soma_adat'
Math(x, ...)

antilog(x, base = 10)

## S3 method for class 'soma_adat'
Ops(e1, e2 = NULL)

## S3 method for class 'soma_adat'
Summary(..., na.rm = FALSE)

## S3 method for class 'soma_adat'
e1 == e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupGenerics_+3A_x">x</code></td>
<td>
<p>The <code>soma_adat</code> class object to perform the transformation.</p>
</td></tr>
<tr><td><code id="groupGenerics_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the various group generics
as appropriate.</p>
</td></tr>
<tr><td><code id="groupGenerics_+3A_base">base</code></td>
<td>
<p>A positive or complex number: the base with respect to
which logarithms are computed.</p>
</td></tr>
<tr><td><code id="groupGenerics_+3A_e1">e1</code>, <code id="groupGenerics_+3A_e2">e2</code></td>
<td>
<p>Objects.</p>
</td></tr>
<tr><td><code id="groupGenerics_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. Should missing values be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>soma_adat</code> object with the same dimensions of the input
object with the feature columns transformed by the specified generic.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>antilog()</code>: performs the inverse or anti-log transform for a numeric vector of
<code>soma_adat</code> object. <strong>note:</strong> default is <code>base = 10</code>, which differs from
the <code><a href="base.html#topic+log">log()</a></code> default base <em>e</em>.
</p>
</li>
<li> <p><code>Ops(soma_adat)</code>: performs binary mathematical operations on class <code>soma_adat</code>. See <code><a href="base.html#topic+Ops">Ops()</a></code>.
</p>
</li>
<li> <p><code>Summary(soma_adat)</code>: performs summary calculations on class <code>soma_adat</code>. See <code><a href="base.html#topic+Summary">Summary()</a></code>.
</p>
</li>
<li> <p><code> == </code>: compares left- and right-hand sides of the operator <em>unless</em> the RHS
is also a <code>soma_adat</code>, in which case <code><a href="#topic+diffAdats">diffAdats()</a></code> is invoked.
</p>
</li></ul>


<h3>Math</h3>

<p>Group members:
</p>
<div class="sourceCode"><pre>#&gt;  [1] "abs"      "acos"     "acosh"    "asin"     "asinh"    "atan"    
#&gt;  [7] "atanh"    "ceiling"  "cos"      "cosh"     "cospi"    "cummax"  
#&gt; [13] "cummin"   "cumprod"  "cumsum"   "digamma"  "exp"      "expm1"   
#&gt; [19] "floor"    "gamma"    "lgamma"   "log"      "log10"    "log1p"   
#&gt; [25] "log2"     "sign"     "sin"      "sinh"     "sinpi"    "sqrt"    
#&gt; [31] "tan"      "tanh"     "tanpi"    "trigamma" "trunc"
</pre></div>
<p>Commonly used generics of this group include:
</p>

<ul>
<li> <p><code>log()</code>, <code>log10()</code>, <code>log2()</code>, <code>antilog()</code>,
<code>abs()</code>, <code>sign()</code>, <code>floor()</code>, <code>sqrt()</code>, <code>exp()</code>
</p>
</li></ul>



<h3>Ops</h3>

<p>Group members:
</p>
<div class="sourceCode"><pre>#&gt;  [1] "+"   "-"   "*"   "^"   "%%"  "%/%" "/"   "=="  "&gt;"   "&lt;"   "!="  "&lt;=" 
#&gt; [13] "&gt;="
</pre></div>
<p>Note that for the <code style="white-space: pre;">&#8288;`==`&#8288;</code> method if the RHS is also a <code>soma_adat</code>,
<code><a href="#topic+diffAdats">diffAdats()</a></code> is invoked which compares LHS vs. RHS.
Commonly used generics of this group include:
</p>

<ul>
<li> <p><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>==</code>, <code>&gt;</code>, <code>&lt;</code>
</p>
</li></ul>



<h3>Summary</h3>

<p>Group members:
</p>
<div class="sourceCode"><pre>#&gt; [1] "all"   "any"   "max"   "min"   "prod"  "range" "sum"
</pre></div>
<p>Commonly used generics of this group include:
</p>

<ul>
<li> <p><code>max()</code>, <code>min()</code>, <code>range()</code>, <code>sum()</code>, <code>any()</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+groupGeneric">groupGeneric()</a></code>, <code><a href="methods.html#topic+getGroupMembers">getGroupMembers()</a></code>, <code><a href="methods.html#topic+getGroup">getGroup()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># subset `example_data` for speed
# all SeqIds from 2000 -&gt; 2999
seqs &lt;- grep("^seq\\.2[0-9]{3}", names(example_data), value = TRUE)
ex_data_small &lt;- head(example_data[, c(getMeta(example_data), seqs)], 10L)
dim(ex_data_small)

ex_data_small$seq.2991.9

# Math Generics:
# -------------
# log-transformation
a &lt;- log(ex_data_small)
a$seq.2991.9

b &lt;- log10(ex_data_small)
b$seq.2991.9
isTRUE(all.equal(b, log(ex_data_small, base = 10)))

# floor
c &lt;- floor(ex_data_small)
c$seq.2991.9

# square-root
d &lt;- sqrt(ex_data_small)
d$seq.2991.9

# rounding
e &lt;- round(ex_data_small)
e$seq.2991.9

# inverse log
antilog(1:4)

alog &lt;- antilog(b)
all.equal(ex_data_small, alog)    # return `b` -&gt; linear space

# Ops Generics:
# -------------
plus1 &lt;- ex_data_small + 1
times2 &lt;- ex_data_small * 2

sq &lt;- ex_data_small^2
all.equal(sqrt(sq), ex_data_small)

gt100k &lt;- ex_data_small &gt; 100000
gt100k

ex_data_small == ex_data_small   # invokes diffAdats()

# Summary Generics:
# -------------
sum(ex_data_small)

any(ex_data_small &lt; 100)  # low RFU analytes

sum(ex_data_small &lt; 100)  # how many

min(ex_data_small)

min(ex_data_small, 0)

max(ex_data_small)

max(ex_data_small, 1e+7)

range(ex_data_small)
</code></pre>

<hr>
<h2 id='is_intact_attr'>Are Attributes Intact?</h2><span id='topic+is_intact_attr'></span><span id='topic+is.intact.attributes'></span>

<h3>Description</h3>

<p>This function runs a series of checks to determine
if a <code>soma_adat</code> object has a complete
set of attributes. If not, this indicates that the object has
been modified since the initial <code><a href="#topic+read_adat">read_adat()</a></code> call.
Checks for the presence of both &quot;Header.Meta&quot; and &quot;Col.Meta&quot; in the
attribute names. These entries are added during the
<code><a href="#topic+read_adat">read_adat()</a></code> call. Specifically, within these sections
it also checks for the presence of the following entries:
</p>

<dl>
<dt>&quot;Header.Meta&quot; section:</dt><dd><p>&quot;HEADER&quot;, &quot;COL_DATA&quot;, and &quot;ROW_DATA&quot;</p>
</dd>
<dt>&quot;Col.Meta&quot; section:</dt><dd><p>&quot;SeqId&quot;, &quot;Target&quot;, &quot;Units&quot;, and &quot;Dilution&quot;</p>
</dd>
</dl>

<p>If any of the above they are altered or missing, <code>FALSE</code> is returned.
</p>
<p><code><a href="#topic+is.intact.attributes">is.intact.attributes()</a></code> is <a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>.
It remains for backward compatibility and may be removed in the future.
You are encouraged to shift your code to <code><a href="#topic+is_intact_attr">is_intact_attr()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_intact_attr(adat, verbose = interactive())

is.intact.attributes(adat, verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_intact_attr_+3A_adat">adat</code></td>
<td>
<p>A <code>soma_adat</code> object to query.</p>
</td></tr>
<tr><td><code id="is_intact_attr_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should diagnostic information about failures
be printed to the console? If the default, see <code><a href="base.html#topic+interactive">interactive()</a></code>, is invoked,
only messages via direct calls are triggered. This prohibits messages
generated deep in the call stack from bubbling up to the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. <code>TRUE</code> if all checks pass, otherwise <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+attributes">attributes()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># checking attributes
my_adat &lt;- example_data
is_intact_attr(my_adat)           # TRUE
is_intact_attr(my_adat[, -303L])   # doesn't break atts; TRUE
attributes(my_adat)$Col.Meta$Target &lt;- NULL    # break attributes
is_intact_attr(my_adat)  # FALSE (Target missing)
</code></pre>

<hr>
<h2 id='is_seqFormat'>Test <code>AptName</code> Format</h2><span id='topic+is_seqFormat'></span>

<h3>Description</h3>

<p>Test whether an object is in the new <code>seq.XXXX.XX</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_seqFormat(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_seqFormat_+3A_x">x</code></td>
<td>
<p>The object to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether <code>x</code> contains <code>AptNames</code> consistent
with the new format, beginning with a <code>seq.</code> prefix.
</p>


<h3>Author(s)</h3>

<p>Stu Field, Eduardo Tabacman
</p>


<h3>Examples</h3>

<pre><code class='language-R'># character S3 method
is_seqFormat(names(example_data))   # no; meta data not ^seq.
is_seqFormat(tail(names(example_data), -20L))   # yes

# soma_adat S3 method
is_seqFormat(example_data)
</code></pre>

<hr>
<h2 id='lift_adat'>Lift an ADAT Between Assay Versions</h2><span id='topic+lift_adat'></span><span id='topic+is_lifted'></span>

<h3>Description</h3>

<p>The SomaScan platform continually improves its technical processes
between assay versions. The primary change of interest is content expansion,
and other protocol changes may be implemented including: changing reagents,
liquid handling equipment, and well volumes.
</p>
<p>Table of SomaScan assay versions:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Version</strong>  </td><td style="text-align: center;"> <strong>Commercial Name</strong> </td><td style="text-align: right;"> <strong>Size</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>V4</code>         </td><td style="text-align: center;"> 5k                  </td><td style="text-align: right;"> 5284     </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>v4.1</code>       </td><td style="text-align: center;"> 7k                  </td><td style="text-align: right;"> 7596     </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>v5.0</code>       </td><td style="text-align: center;"> 11k                 </td><td style="text-align: right;"> 11083    </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>However, for a given analyte, these technical upgrades can result
in minute measurement signal differences,
requiring a calibration (aka &quot;lifting&quot; or &quot;bridging&quot;) to bring RFUs into a
comparable signal space.
This is accomplished by applying an analyte-specific scalar,
a linear transformation, to each analyte RFU measurement (column).
If you have an annotations file (<code style="white-space: pre;">&#8288;*.xlsx&#8288;</code>) and wish to examine the
bridging scalars themselves, please see <code><a href="#topic+read_annotations">read_annotations()</a></code>.
</p>
<p>Lifting between SomaScan versions no longer requires an
annotations file containing lifting scalars. We now enable users to pass
a <code>bridge</code> parameter, indicating the direction of the bridge.
For example, to &quot;lift&quot; between <code style="white-space: pre;">&#8288;11k&#8288;</code> -&gt; <code style="white-space: pre;">&#8288;7k&#8288;</code>, you <em>must</em> be acting on
SomaScan data in <code style="white-space: pre;">&#8288;11k&#8288;</code> RFU space and would pass <code>bridge = "11k_to_7k"</code>.
Likewise, <code style="white-space: pre;">&#8288;7k&#8288;</code> -&gt; <code style="white-space: pre;">&#8288;5k&#8288;</code> requires <code>bridge = "7k_to_5k"</code>.
Lastly, you may also lift directly from <code style="white-space: pre;">&#8288;11k&#8288;</code> -&gt; <code style="white-space: pre;">&#8288;5k&#8288;</code>
(aka &quot;double-bridge&quot;) with <code>bridge = "11k_to_5k"</code>.
See below for all options for the <code>bridge</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lift_adat(
  adat,
  bridge = c("11k_to_7k", "11k_to_5k", "7k_to_11k", "7k_to_5k", "5k_to_11k", "5k_to_7k"),
  anno.tbl = deprecated()
)

is_lifted(adat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lift_adat_+3A_adat">adat</code></td>
<td>
<p>A <code>soma_adat</code> object (with intact attributes),
typically created using <code><a href="#topic+read_adat">read_adat()</a></code>.</p>
</td></tr>
<tr><td><code id="lift_adat_+3A_bridge">bridge</code></td>
<td>
<p>The direction of the lift (i.e. bridge).</p>
</td></tr>
<tr><td><code id="lift_adat_+3A_anno.tbl">anno.tbl</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Please now
use the <code>bridge</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matched samples across assay versions are used to calculate bridging
scalars. For each analyte, this scalar is computed as the ratio of
population <em>medians</em> across assay versions.
Please see the lifting vignette
<code>vignette("lifting-and-bridging", package = "SomaDataIO")</code>
for more details.
</p>


<h3>Value</h3>

<p><code><a href="#topic+lift_adat">lift_adat()</a></code>: A &quot;lifted&quot; <code>soma_adat</code> object corresponding to
the scaling requested in the <code>bridge</code> parameter. RFU values are
rounded to 1 decimal place to match standard SomaScan delivery format.
</p>
<p><code><a href="#topic+is_lifted">is_lifted()</a></code>: Logical. Whether the RFU values in a <code>soma_adat</code>
have been lifted from its original signal space to a new signal space.
</p>


<h3>Lin's CCC</h3>

<p>The Lin's Concordance Correlation Coefficient (CCC) is calculated
by computing the correlation between post-lift RFU values and the
RFU values generated on the original SomaScan version.
This CCC estimate is a measure of how well an analyte can be bridged
across SomaScan versions.
See <code>vignette("lifting-and-bridging", package = "SomaDataIO")</code>.
As with the lifting scalars, if you have an annotations file
you may view the analyte-specific CCC values via <code><a href="#topic+read_annotations">read_annotations()</a></code>.
Alternatively, <code><a href="#topic+getSomaScanLiftCCC">getSomaScanLiftCCC()</a></code> retrieves these values
from an internal object for both <code>"serum"</code> and <code>"plasma"</code>.
</p>


<h3>Analyte Setdiff</h3>


<ul>
<li><p> Newer versions of SomaScan typically have additional content, i.e.
new reagents added to the multi-plex assay that bind to additional proteins.
When lifting <em>to</em> a previous SomaScan version, new reagents that do <em>not</em>
exist in the &quot;earlier&quot; assay version assay are scaled by 1.0, and thus
maintained, unmodified in the returned object. Users may need to drop
these columns in order to combine these data with a previous study
from an earlier SomaScan version, e.g. with <code><a href="#topic+collapseAdats">collapseAdats()</a></code>.
</p>
</li>
<li><p> In the inverse scenario, lifting &quot;forward&quot; <em>from</em> a previous, lower-plex
version, there will be extra reference values that are unnecessary
to perform the lift, and a warning is triggered. The resulting data
consists of RFU data in the &quot;new&quot; signal space, but with fewer analytes
than would otherwise be expected (e.g. <code style="white-space: pre;">&#8288;11k&#8288;</code> space with only 5284
analytes; see example below).
</p>
</li></ul>



<h3>References</h3>

<p>Lin, Lawrence I-Kuei. 1989. A Concordance Correlation
Coefficient to Evaluate Reproducibility. <strong>Biometrics</strong>. 45:255-268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `example_data` is SomaScan (V4, 5k)
adat &lt;- head(example_data, 3L)
dim(adat)

getSomaScanVersion(adat)

getSignalSpace(adat)

# perform 'lift'
lift_11k &lt;- lift_adat(adat, "5k_to_11k")  # warning

is_lifted(lift_11k)

dim(lift_11k)

# attributes updated to reflect the 'lift'
attr(lift_11k, "Header")$HEADER$SignalSpace

attr(lift_11k, "Header")$HEADER$ProcessSteps
</code></pre>

<hr>
<h2 id='loadAdatsAsList'>Load ADAT files as a list</h2><span id='topic+loadAdatsAsList'></span><span id='topic+collapseAdats'></span>

<h3>Description</h3>

<p>Load a series of ADATs and return a list of <code>soma_adat</code>
objects, one for each ADAT file.
<code><a href="#topic+collapseAdats">collapseAdats()</a></code> concatenates a list of ADATs from <code><a href="#topic+loadAdatsAsList">loadAdatsAsList()</a></code>,
while maintaining the relevant attribute entries (mainly the <code>HEADER</code>
element). This makes writing out the final object possible without the
loss of <code>HEADER</code> information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadAdatsAsList(files, collapse = FALSE, verbose = interactive(), ...)

collapseAdats(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadAdatsAsList_+3A_files">files</code></td>
<td>
<p>A character string of files to load.</p>
</td></tr>
<tr><td><code id="loadAdatsAsList_+3A_collapse">collapse</code></td>
<td>
<p>Logical. Should the resulting list of ADATs be
collapsed into a single ADAT object?</p>
</td></tr>
<tr><td><code id="loadAdatsAsList_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should the function call be run in <em>verbose</em> mode.</p>
</td></tr>
<tr><td><code id="loadAdatsAsList_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+read_adat">read_adat()</a></code>.</p>
</td></tr>
<tr><td><code id="loadAdatsAsList_+3A_x">x</code></td>
<td>
<p>A list of <code>soma_adat</code> class objects returned from
<code><a href="#topic+loadAdatsAsList">loadAdatsAsList()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><strong>Note 1</strong>:</dt><dd><p>The default behavior is to &quot;vertically bind&quot;
(<code><a href="base.html#topic+rbind">rbind()</a></code>) on the  <em>intersect</em> of the column variables, with
unique columns silently dropped.</p>
</dd>
<dt><strong>Note 2</strong>:</dt><dd><p>If &quot;vertically binding&quot; on the column <em>union</em> is
desired, use <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>, however this results in <code>NAs</code> in
non-intersecting columns. For many files with little variable
intersection, a sparse RFU-matrix will result
(and will likely break ADAT attributes):
</p>
<div class="sourceCode r"><pre>adats &lt;- loadAdatsAsList(files)
union_adat &lt;- dplyr::bind_rows(adats, .id = "SourceFile")
</pre></div>
</dd>
</dl>



<h3>Value</h3>

<p>A list of ADATs named by <code>files</code>, each a <code>soma_adat</code> object
corresponding to an individual file in <code>files</code>. For <code><a href="#topic+collapseAdats">collapseAdats()</a></code>,
a single, collapsed <code>soma_adat</code> object.
</p>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_adat">read_adat()</a></code>
</p>
<p>Other IO: 
<code><a href="#topic+parseHeader">parseHeader</a>()</code>,
<code><a href="#topic+read_adat">read_adat</a>()</code>,
<code><a href="#topic+soma_adat">soma_adat</a></code>,
<code><a href="#topic+write_adat">write_adat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># only 1 file in directory
dir(system.file("extdata", package = "SomaDataIO"))

files &lt;- system.file("extdata", package = "SomaDataIO") |&gt;
  dir(pattern = "[.]adat$", full.names = TRUE) |&gt; rev()

adats &lt;- loadAdatsAsList(files)
class(adats)

# collapse into 1 ADAT
collapsed &lt;- collapseAdats(adats)
class(collapsed)

# Alternatively use `collapse = TRUE`

  loadAdatsAsList(files, collapse = TRUE)

</code></pre>

<hr>
<h2 id='merge_clin'>Merge Clinical Data into SomaScan</h2><span id='topic+merge_clin'></span>

<h3>Description</h3>

<p>Occasionally, additional clinical data is obtained <em>after</em> samples
have been submitted to SomaLogic, or even after 'SomaScan'
results have been delivered.
This requires the new clinical variables, i.e. non-proteomic, data to be
merged with 'SomaScan' data into a &quot;new&quot; ADAT prior to analysis.
<code><a href="#topic+merge_clin">merge_clin()</a></code> easily merges such clinical variables into an
existing <code>soma_adat</code> object and is a simple wrapper around <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_clin(x, clin_data, by = NULL, by_class = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_clin_+3A_x">x</code></td>
<td>
<p>A <code>soma_adat</code> object (with intact attributes),
typically created using <code><a href="#topic+read_adat">read_adat()</a></code>.</p>
</td></tr>
<tr><td><code id="merge_clin_+3A_clin_data">clin_data</code></td>
<td>
<p>One of 2 options:
</p>

<ul>
<li><p> a data frame containing clinical variables to merge into <code>x</code>, or
</p>
</li>
<li><p> a path to a file, typically a <code style="white-space: pre;">&#8288;*.csv&#8288;</code>,
containing clinical variables to merge into <code>x</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="merge_clin_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by.
See <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="merge_clin_+3A_by_class">by_class</code></td>
<td>
<p>If <code>clin_data</code> is a file path, a named character vector
of the variable and its class. This ensures the &quot;by-key&quot; is compatible
for the join. For example, <code>c(SampleId = "character")</code>.
See <code><a href="utils.html#topic+read.table">read.table()</a></code> for details about its <code>colClasses</code> argument, and
also the examples below.</p>
</td></tr>
<tr><td><code id="merge_clin_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functionality also exists as a command-line tool (R script) contained
in <code>merge_clin.R</code> that lives in the <code>cli/merge</code> system file directory.
Please see:
</p>

<ul>
<li> <p><code>dir(system.file("cli/merge", package = "SomaDataIO"), full.names = TRUE)</code>
</p>
</li>
<li> <p><code>vignette("cli-merge-tool", package = "SomaDataIO")</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>soma_adat</code> with new clinical variables merged.
</p>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># retrieve clinical data
clin_file &lt;- system.file("cli/merge", "meta.csv",
                         package = "SomaDataIO",
                         mustWork = TRUE)
clin_file

# view clinical data to be merged:
# 1) `group`
# 2) `newvar`
clin_df &lt;- read.csv(clin_file, colClasses = c(SampleId = "character"))
clin_df

# create mini-adat
apts &lt;- withr::with_seed(123, sample(getAnalytes(example_data), 2L))
adat &lt;- head(example_data, 9L) |&gt;   # 9 x 2
  dplyr::select(SampleId, all_of(apts))

# merge clinical variables
merged &lt;- merge_clin(adat, clin_df, by = "SampleId")
merged

# Alternative syntax:
#   1) pass file path
#   2) merge on different variable names
#   3) convert join type on-the-fly
clin_file2 &lt;- system.file("cli/merge", "meta2.csv",
                          package = "SomaDataIO",
                          mustWork = TRUE)

id_type &lt;- typeof(adat$SampleId)
merged2 &lt;- merge_clin(adat, clin_file2,                # file path
                      by = c(SampleId = "ClinKey"),    # join on 2 variables
                      by_class = c(ClinKey = id_type)) # match types
merged2
</code></pre>

<hr>
<h2 id='params'>Common Parameters in <span class="pkg">SomaDataIO</span></h2><span id='topic+params'></span>

<h3>Description</h3>

<p>The parameters below are commonly used throughout
the <span class="pkg">SomaDataIO</span> package.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="params_+3A_adat">adat</code></td>
<td>
<p>A <code>soma_adat</code> object (with intact attributes),
typically created using <code><a href="#topic+read_adat">read_adat()</a></code>.</p>
</td></tr>
<tr><td><code id="params_+3A_x">x</code></td>
<td>
<p>A <code>soma_adat</code> object (with intact attributes),
typically created using <code><a href="#topic+read_adat">read_adat()</a></code>.</p>
</td></tr>
<tr><td><code id="params_+3A_matrix">matrix</code></td>
<td>
<p>Character. A string of (usually) either
<code>"serum"</code> or <code>"plasma"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>soma_adat</code> class object.
</p>

<hr>
<h2 id='parseHeader'>SomaLogic ADAT parser</h2><span id='topic+parseHeader'></span>

<h3>Description</h3>

<p>Parses the header section of an ADAT file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseHeader(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parseHeader_+3A_file">file</code></td>
<td>
<p>Character. The elaborated path and file name of the
<code style="white-space: pre;">&#8288;*.adat&#8288;</code> file to be loaded into an R workspace environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of relevant file information required by <code><a href="#topic+read_adat">read_adat()</a></code>
in order to complete loading the ADAT file, including:
</p>
<table role = "presentation">
<tr><td><code>Header.Meta</code></td>
<td>
<p>list of notes and other information about the adat</p>
</td></tr>
<tr><td><code>Col.Meta</code></td>
<td>
<p>list of vectors that contain the column meta
data about individual analytes, includes information about the target
name and calibration and QC ratios</p>
</td></tr>
<tr><td><code>file_specs</code></td>
<td>
<p>list of values of the file parsing specifications</p>
</td></tr>
<tr><td><code>row_meta</code></td>
<td>
<p>character vector of the clinical variables; assay
information that is included in the adat output along with the RFU data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p>Other IO: 
<code><a href="#topic+loadAdatsAsList">loadAdatsAsList</a>()</code>,
<code><a href="#topic+read_adat">read_adat</a>()</code>,
<code><a href="#topic+soma_adat">soma_adat</a></code>,
<code><a href="#topic+write_adat">write_adat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "example_data10.adat",
                 package = "SomaDataIO", mustWork = TRUE)
header &lt;- parseHeader(f)
names(header)

header$Header.Meta

header$file_specs

header$row_meta

head(as.data.frame(header$Col.Meta))
</code></pre>

<hr>
<h2 id='pivotExpressionSet'>Convert to Long Format</h2><span id='topic+pivotExpressionSet'></span><span id='topic+meltExpressionSet'></span>

<h3>Description</h3>

<p>Utility to convert an <code>ExpressionSet</code> class object
from the &quot;wide&quot; data format to the &quot;long&quot; format via <code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer()</a></code>.
The <span class="pkg">Biobase</span> package is required for this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivotExpressionSet(eSet)

meltExpressionSet(eSet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivotExpressionSet_+3A_eset">eSet</code></td>
<td>
<p>An <code>ExpressionSet</code> class object, created using <code><a href="#topic+adat2eSet">adat2eSet()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> consisting of the long format
conversion of an <code>ExpressionSet</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>meltExpressionSet()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>. Please now use <code><a href="#topic+pivotExpressionSet">pivotExpressionSet()</a></code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p>Other eSet: 
<code><a href="#topic+adat2eSet">adat2eSet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# subset into a reduced mini-ADAT object
# 10 samples (rows)
# 5 clinical variables and 3 features (cols)
sub_adat &lt;- example_data[1:10, c(1:5, 35:37)]
ex_set   &lt;- adat2eSet(sub_adat)

# convert ExpressionSet object to long format
adat_long &lt;- pivotExpressionSet(ex_set)

</code></pre>

<hr>
<h2 id='read_adat'>Read (Load) SomaLogic ADATs</h2><span id='topic+read_adat'></span><span id='topic+read.adat'></span><span id='topic+is.soma_adat'></span>

<h3>Description</h3>

<p>The parse and load a <code style="white-space: pre;">&#8288;*.adat&#8288;</code> file as a <code>data.frame</code>-like object into
an R workspace environment. The class of the returned object is
a <code>soma_adat</code> object.
</p>
<p><code><a href="#topic+read.adat">read.adat()</a></code> is <a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>.
For backward compatibility it will likely never go away completely,
but you are strongly encouraged to shift your code to use <code><a href="#topic+read_adat">read_adat()</a></code>.
</p>
<p><code><a href="#topic+is.soma_adat">is.soma_adat()</a></code> checks whether an object is of class <code>soma_adat</code>.
See <code><a href="base.html#topic+inherits">inherits()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_adat(file, debug = FALSE, verbose = getOption("verbose"), ...)

read.adat(file, debug = FALSE, verbose = getOption("verbose"), ...)

is.soma_adat(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_adat_+3A_file">file</code></td>
<td>
<p>Character. The elaborated path and file name of the <code style="white-space: pre;">&#8288;*.adat&#8288;</code>
file to be loaded into an R workspace.</p>
</td></tr>
<tr><td><code id="read_adat_+3A_debug">debug</code></td>
<td>
<p>Logical. Used for debugging and development of an ADAT that
fails to load, particularly out-of-spec, poorly modified, or legacy ADATs.</p>
</td></tr>
<tr><td><code id="read_adat_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should the function call be run in <em>verbose</em>
mode, printing relevant diagnostic call information to the console.</p>
</td></tr>
<tr><td><code id="read_adat_+3A_...">...</code></td>
<td>
<p>Additional arguments passed ultimately to
<code><a href="utils.html#topic+read.delim">read.delim()</a></code>, or additional arguments passed to either
other S3 print or summary methods as required by those generics.</p>
</td></tr>
<tr><td><code id="read_adat_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>-like object of class <code>soma_adat</code>
consisting of SomaLogic RFU (feature) data and clinical meta data as
columns, and samples as rows. Row names are labeled with the unique ID
&quot;SlideId_Subarray&quot; concatenation. The sections of the ADAT header (e.g.,
&quot;Header.Meta&quot;, &quot;Col.Meta&quot;, ...) are stored as attributes (e.g.
<code>attributes(x)$Header.Meta</code>).
</p>
<p>Logical. Whether <code>x</code> inherits from class <code>soma_adat</code>.
</p>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.delim">read.delim()</a></code>
</p>
<p>Other IO: 
<code><a href="#topic+loadAdatsAsList">loadAdatsAsList</a>()</code>,
<code><a href="#topic+parseHeader">parseHeader</a>()</code>,
<code><a href="#topic+soma_adat">soma_adat</a></code>,
<code><a href="#topic+write_adat">write_adat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># path to *.adat file
# replace with your file path
adat_path &lt;- system.file("extdata", "example_data10.adat",
                         package = "SomaDataIO", mustWork = TRUE)
adat_path

my_adat &lt;- read_adat(adat_path)

is.soma_adat(my_adat)
</code></pre>

<hr>
<h2 id='read_annotations'>Import a SomaLogic Annotations File</h2><span id='topic+read_annotations'></span>

<h3>Description</h3>

<p>Import a SomaLogic Annotations File
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_annotations(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_annotations_+3A_file">file</code></td>
<td>
<p>A path to an annotations file location.
This is a sanctioned, versioned file provided by
Standard BioTools, Inc. and should be an <em>unmodified</em>
<code style="white-space: pre;">&#8288;*.xlsx&#8288;</code> file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> containing analyte-specific annotations and
related (e.g. lift/bridging) information, keyed on SomaLogic
<a href="#topic+SeqId">SeqId</a>, the unique SomaScan analyte identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # for example
  file &lt;- "~/Downloads/SomaScan_11K_Annotated_Content.xlsx"
  anno_tbl &lt;- read_annotations(file)

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+count'></span><span id='topic+rename'></span><span id='topic+slice_sample'></span><span id='topic+slice'></span><span id='topic+sample_frac'></span><span id='topic+sample_n'></span><span id='topic+filter'></span><span id='topic+mutate'></span><span id='topic+arrange'></span><span id='topic+group_by'></span><span id='topic+ungroup'></span><span id='topic+left_join'></span><span id='topic+anti_join'></span><span id='topic+full_join'></span><span id='topic+inner_join'></span><span id='topic+semi_join'></span><span id='topic+right_join'></span><span id='topic+unite'></span><span id='topic+separate'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter-joins">anti_join</a></code>, <code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="dplyr.html#topic+count">count</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+mutate-joins">full_join</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code>, <code><a href="dplyr.html#topic+mutate-joins">inner_join</a></code>, <code><a href="dplyr.html#topic+mutate-joins">left_join</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+rename">rename</a></code>, <code><a href="dplyr.html#topic+mutate-joins">right_join</a></code>, <code><a href="dplyr.html#topic+sample_n">sample_frac</a></code>, <code><a href="dplyr.html#topic+sample_n">sample_n</a></code>, <code><a href="dplyr.html#topic+filter-joins">semi_join</a></code>, <code><a href="dplyr.html#topic+slice">slice</a></code>, <code><a href="dplyr.html#topic+slice">slice_sample</a></code>, <code><a href="dplyr.html#topic+group_by">ungroup</a></code></p>
</dd>
<dt>tidyr</dt><dd><p><code><a href="tidyr.html#topic+separate">separate</a></code>, <code><a href="tidyr.html#topic+unite">unite</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rownames'>Helpers for Working With Row Names</h2><span id='topic+rownames'></span><span id='topic+rn2col'></span><span id='topic+col2rn'></span><span id='topic+has_rn'></span><span id='topic+rm_rn'></span><span id='topic+set_rn'></span><span id='topic+add_rowid'></span>

<h3>Description</h3>

<p>Easily move row names to a column and vice-versa without the unwanted
side-effects to object class and attributes. Drop-in replacement for
<code>tibble::rownames_to_column()</code> and <code>tibble::column_to_rownames()</code> which
can have undesired side-effects to complex object attributes.
Does not import any external packages, modify the environment, or change
the object (other than the desired column). When using <code><a href="#topic+col2rn">col2rn()</a></code>, if
explicit row names exist, they are overwritten with a warning. <code><a href="#topic+add_rowid">add_rowid()</a></code>
does <em>not</em> affect row names, which differs from <code>tibble::rowid_to_column()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rn2col(data, name = ".rn")

col2rn(data, name = ".rn")

has_rn(data)

rm_rn(data)

set_rn(data, value)

add_rowid(data, name = ".rowid")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rownames_+3A_data">data</code></td>
<td>
<p>An object that inherits from class <code>data.frame</code>. Typically
a <code>soma_adat</code> class object.</p>
</td></tr>
<tr><td><code id="rownames_+3A_name">name</code></td>
<td>
<p>Character. The name of the column to move.</p>
</td></tr>
<tr><td><code id="rownames_+3A_value">value</code></td>
<td>
<p>Character. The new set of names for the data frame.
If duplicates exist they are modified on-the-fly via <code><a href="base.html#topic+make.unique">make.unique()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All functions attempt to return an object of the same class as
the input with fully intact and unmodified attributes (aside from those
required by the desired action). <code><a href="#topic+has_rn">has_rn()</a></code> returns a scalar logical.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rn2col()</code>: moves the row names of <code>data</code> to an explicit column
whether they are explicit or implicit.
</p>
</li>
<li> <p><code>col2rn()</code>: is the inverse of <code><a href="#topic+rn2col">rn2col()</a></code>. If row names exist, they
will be overwritten (with warning).
</p>
</li>
<li> <p><code>has_rn()</code>: returns a boolean indicating whether the data frame
has explicit row names assigned.
</p>
</li>
<li> <p><code>rm_rn()</code>: removes existing row names, leaving only &quot;implicit&quot; row names.
</p>
</li>
<li> <p><code>set_rn()</code>: sets (and overwrites) existing row names for data frames only.
</p>
</li>
<li> <p><code>add_rowid()</code>: adds a sequential integer row identifier; starting at <code>1:nrow(data)</code>.
It does <em>not</em> remove existing row names currently, but may in the future
(please code accordingly).
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(a = 1:5, b = rnorm(5), row.names = LETTERS[1:5])
df
rn2col(df)              # default name is `.rn`
rn2col(df, "AptName")   # pass `name =`

# moving columns
df$mtcars &lt;- sample(names(mtcars), 5)
col2rn(df, "mtcars")   # with a warning

# Move back and forth easily
# Leaves original object un-modified
identical(df, col2rn(rn2col(df)))

# add "id" column
add_rowid(mtcars)

# remove row names
has_rn(mtcars)
mtcars2 &lt;- rm_rn(mtcars)
has_rn(mtcars2)
</code></pre>

<hr>
<h2 id='SeqId'>Working with SomaLogic SeqIds</h2><span id='topic+SeqId'></span><span id='topic+getSeqId'></span><span id='topic+regexSeqId'></span><span id='topic+locateSeqId'></span><span id='topic+seqid2apt'></span><span id='topic+apt2seqid'></span><span id='topic+is.apt'></span><span id='topic+is.SeqId'></span><span id='topic+matchSeqIds'></span><span id='topic+getSeqIdMatches'></span>

<h3>Description</h3>

<p>The <code>SeqId</code> is the cornerstone used to uniquely identify
SomaLogic analytes.
<code>SeqIds</code> follow the format <strong><code style="white-space: pre;">&#8288;&lt;Pool&gt;-&lt;Clone&gt;_&lt;Version&gt;&#8288;</code></strong>, for example
<code>"1234-56_7"</code> can be represented as:
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Pool</strong> </td><td style="text-align: center;"> <strong>Clone</strong> </td><td style="text-align: center;"> <strong>Version</strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>1234</code>   </td><td style="text-align: center;"> <code>56</code>      </td><td style="text-align: center;"> <code>7</code>
</td>
</tr>

</table>

<p>See <strong>Details</strong> below for the definition of each sub-unit.
The <strong><code style="white-space: pre;">&#8288;&lt;Pool&gt;-&lt;Clone&gt;&#8288;</code></strong> combination is sufficient to uniquely identify a
specific analyte and therefore versions are no longer provided (though
they may be present in legacy ADATs).
The tools below enable users to extract, test, identify, compare,
and manipulate <code>SeqIds</code> across assay runs and/or versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSeqId(x, trim.version = FALSE)

regexSeqId()

locateSeqId(x, trailing = TRUE)

seqid2apt(x)

apt2seqid(x)

is.apt(x)

is.SeqId(x)

matchSeqIds(x, y, order.by.x = TRUE)

getSeqIdMatches(x, y, show = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SeqId_+3A_x">x</code></td>
<td>
<p>Character. A vector of strings, usually analyte/feature column
names, <code>AptNames</code>, or <code>SeqIds</code>. For <code><a href="#topic+seqid2apt">seqid2apt()</a></code>, a vector <em>of</em> <code>SeqIds</code>.
For <code><a href="#topic+apt2seqid">apt2seqid()</a></code>, a character vector <em>containing</em> <code>SeqIds</code>.
For <code><a href="#topic+matchSeqIds">matchSeqIds()</a></code>, a vector of pattern matches containing <code>SeqIds</code>.
Can be <code>AptNames</code> with <code>GeneIDs</code>, the <code>seq.XXXX</code> format,
or even &quot;naked&quot; <code>SeqIds</code>.</p>
</td></tr>
<tr><td><code id="SeqId_+3A_trim.version">trim.version</code></td>
<td>
<p>Logical. Whether to remove the version number,
i.e. &quot;1234-56_7&quot; -&gt; &quot;1234-56&quot;. Primarily for legacy ADATs.</p>
</td></tr>
<tr><td><code id="SeqId_+3A_trailing">trailing</code></td>
<td>
<p>Logical. Should the regular expression explicitly specify
<em>trailing</em> <code>SeqId</code> pattern match, i.e. <code>"regex$"</code>?
This is the most common case and the default.</p>
</td></tr>
<tr><td><code id="SeqId_+3A_y">y</code></td>
<td>
<p>Character. A second vector of <code>AptNames</code> containing <code>SeqIds</code>
to match against those in contained in <code>x</code>.
For <code><a href="#topic+matchSeqIds">matchSeqIds()</a></code> these values are returned if there are matching elements.</p>
</td></tr>
<tr><td><code id="SeqId_+3A_order.by.x">order.by.x</code></td>
<td>
<p>Logical. Order the returned character string by
the <code>x</code> (first) argument?</p>
</td></tr>
<tr><td><code id="SeqId_+3A_show">show</code></td>
<td>
<p>Logical. Return the data frame visibly?</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
<strong>Pool:</strong>    </td><td style="text-align: left;"> ties back to the original well during <strong>SELEX</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Clone:</strong>   </td><td style="text-align: left;"> ties to the specific sequence within a pool </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Version:</strong> </td><td style="text-align: left;"> refers to custom modifications (optional/defunct)
</td>
</tr>

</table>


<dl>
<dt><code>AptName</code></dt><dd><p>a <code>SeqId</code> combined with a string, usually a <code>GeneId</code>- or
<code>seq.</code>-prefix, for convenient, human-readable
manipulation from within <code>R</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code><a href="#topic+getSeqId">getSeqId()</a></code>: a character vector of <code>SeqIds</code> captured from a string.
</p>
<p><code><a href="#topic+regexSeqId">regexSeqId()</a></code>: a regular expression (<code>regex</code>) string
pre-defined to match SomaLogic the <code>SeqId</code> pattern.
</p>
<p><code><a href="#topic+locateSeqId">locateSeqId()</a></code>: a data frame containing the <code>start</code> and <code>stop</code>
integer positions for <code>SeqId</code> matches at each value of <code>x</code>.
</p>
<p><code><a href="#topic+seqid2apt">seqid2apt()</a></code>: a character vector with the <code style="white-space: pre;">&#8288;seq.*&#8288;</code> prefix, i.e.
the inverse of <code><a href="#topic+getSeqId">getSeqId()</a></code>.
</p>
<p><code><a href="#topic+apt2seqid">apt2seqid()</a></code>: a character vector of <code>SeqIds</code>. <code><a href="#topic+is.SeqId">is.SeqId()</a></code> will
return <code>TRUE</code> for all elements.
</p>
<p><code><a href="#topic+is.apt">is.apt()</a></code>, <code><a href="#topic+is.SeqId">is.SeqId()</a></code>: Logical. <code>TRUE</code> or <code>FALSE</code>.
</p>
<p><code><a href="#topic+matchSeqIds">matchSeqIds()</a></code>: a character string corresponding to values
in <code>y</code> of the intersect of <code>x</code> and <code>y</code>. If no matches are
found, <code>character(0)</code>.
</p>
<p><code><a href="#topic+getSeqIdMatches">getSeqIdMatches()</a></code>: a <code class="reqn">n x 2</code> data frame, where <code>n</code> is the
length of the intersect of the matching <code>SeqIds</code>.
The data frame is named by the passed arguments, <code>x</code> and <code>y</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getSeqId()</code>: extracts/captures the the <code>SeqId</code> match from an analyte column identifier,
i.e. column name of an ADAT loaded with <code><a href="#topic+read_adat">read_adat()</a></code>. Assumes the
<code>SeqId</code> pattern occurs at the end of the string, which for
the vast majority of cases will be true. For edge cases, see the
<code>trailing</code> argument to <code><a href="#topic+locateSeqId">locateSeqId()</a></code>.
</p>
</li>
<li> <p><code>regexSeqId()</code>: generates a pre-formatted regular expression for
matching of <code>SeqIds</code>. Note the <em>trailing</em> match, which is most
commonly required, but <code><a href="#topic+locateSeqId">locateSeqId()</a></code> offers
an alternative to mach <em>anywhere</em> in a string.
Used internally in <em>many</em> utility functions
</p>
</li>
<li> <p><code>locateSeqId()</code>: generates a data frame of the positional <code>SeqId</code> matches. Specifically
designed to facilitate <code>SeqId</code> extraction via <code><a href="base.html#topic+substr">substr()</a></code>.
Similar to <code><a href="stringr.html#topic+str_locate">stringr::str_locate()</a></code>.
</p>
</li>
<li> <p><code>seqid2apt()</code>: converts a <code>SeqId</code> into anonymous-AptName format, i.e.
<code>1234-56</code> -&gt; <code>seq.1234.56</code>. Version numbers (<code style="white-space: pre;">&#8288;1234-56_ver&#8288;</code>)
are always trimmed when present.
</p>
</li>
<li> <p><code>apt2seqid()</code>: converts an anonymous-AptName into <code>SeqId</code> format, i.e.
<code>seq.1234.56</code> -&gt; <code>1234-56</code>. Version numbers (<code>seq.1234.56.ver</code>)
are always trimmed when present.
</p>
</li>
<li> <p><code>is.apt()</code>: regular expression match to determine if a string <em>contains</em>
a <code>SeqId</code>, and thus is probably an <code>AptName</code> format string. Both
legacy <code>EntrezGeneSymbol-SeqId</code> combinations or newer
so-called <code>"anonymous-AptNames"</code> formats (<code>seq.1234.45</code>) are matched.
</p>
</li>
<li> <p><code>is.SeqId()</code>: tests for <code>SeqId</code> format, i.e. values returned from <code><a href="#topic+getSeqId">getSeqId()</a></code>
will always return <code>TRUE</code>.
</p>
</li>
<li> <p><code>matchSeqIds()</code>: matches two character vectors on the basis of their
intersecting <code>SeqIds</code>. Note that elements in <code>y</code> not
containing a <code>SeqId</code> regular expression are silently dropped.
</p>
</li>
<li> <p><code>getSeqIdMatches()</code>: matches two character vectors on the basis of their intersecting <em>SeqIds</em>
only (irrespective of the <code>GeneID</code>-prefix). This produces a two-column
data frame which then can be used as to map between the two sets.
</p>
<p>The final order of the matches/rows is by the input
corresponding to the <em>first</em> argument (<code>x</code>).
</p>
<p>By default the data frame is invisibly returned to
avoid dumping excess output to the console (see the <code style="white-space: pre;">&#8288;show =&#8288;</code> argument.)
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+intersect">intersect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("ABDC.3948.48.2", "3948.88",
       "3948.48.2", "3948-48_2", "3948.48.2",
       "3948-48_2", "3948-88",
       "My.Favorite.Apt.3948.88.9")

tibble::tibble(orig       = x,
               SeqId      = getSeqId(x),
               SeqId_trim = getSeqId(x, TRUE),
               AptName    = seqid2apt(SeqId))

# Logical Matching
is.apt("AGR2.4959.2") # TRUE
is.apt("seq.4959.2")  # TRUE
is.apt("4959-2")      # TRUE
is.apt("AGR2")        # FALSE


# SeqId Matching
x &lt;- c("seq.4554.56", "seq.3714.49", "PlateId")
y &lt;- c("Group", "3714-49", "Assay", "4554-56")
matchSeqIds(x, y)
matchSeqIds(x, y, order.by.x = FALSE)

# vector of features
feats &lt;- getAnalytes(example_data)

match_df &lt;- getSeqIdMatches(feats[1:100], feats[90:500])  # 11 overlapping
match_df

a &lt;- utils::head(feats, 15)
b &lt;- withr::with_seed(99, sample(getSeqId(a)))   # =&gt; SeqId &amp; shuffle
(getSeqIdMatches(a, b))                          # sorted by first vector "a"
</code></pre>

<hr>
<h2 id='soma_adat'>The <code>soma_adat</code> Class and S3 Methods</h2><span id='topic+soma_adat'></span><span id='topic+print.soma_adat'></span><span id='topic+summary.soma_adat'></span><span id='topic++5B.soma_adat'></span><span id='topic++24.soma_adat'></span><span id='topic++5B+5B.soma_adat'></span><span id='topic++5B+3C-.soma_adat'></span><span id='topic++24+3C-.soma_adat'></span><span id='topic++5B+5B+3C-.soma_adat'></span><span id='topic+median.soma_adat'></span>

<h3>Description</h3>

<p>The <code>soma_adat</code> data structure is the primary internal <code>R</code> representation
of SomaScan data. A <code>soma_adat</code> is automatically created via <code><a href="#topic+read_adat">read_adat()</a></code>
when loading a <code style="white-space: pre;">&#8288;*.adat&#8288;</code> text file. It consists of a <code>data.frame</code>-like
object with leading columns as clinical variables and SomaScan RFU data
as the remaining variables. Two main attributes corresponding to analyte
and SomaScan run information contained in the <code style="white-space: pre;">&#8288;*.adat&#8288;</code> file are added:
</p>

<ul>
<li> <p><code>Header.Meta</code>: information about the SomaScan run, see <code><a href="#topic+parseHeader">parseHeader()</a></code>
or <code>attr(x, "Header.Meta")</code>
</p>
</li>
<li> <p><code>Col.Meta</code>: annotations information about the SomaScan reagents/analytes,
see <code><a href="#topic+getAnalyteInfo">getAnalyteInfo()</a></code> or <code>attr(x, "Col.Meta")</code>
</p>
</li>
<li> <p><code>file_specs</code>: parsing specifications for the ingested <code style="white-space: pre;">&#8288;*.adat&#8288;</code> file
</p>
</li>
<li> <p><code>row_meta</code>: the names of the non-RFU fields. See <code><a href="#topic+getMeta">getMeta()</a></code>.
</p>
</li></ul>

<p>See <code><a href="#topic+groupGenerics">groupGenerics()</a></code> for a details on <code><a href="base.html#topic+Math">Math()</a></code>, <code><a href="base.html#topic+Ops">Ops()</a></code>, and <code><a href="base.html#topic+Summary">Summary()</a></code>
methods that dispatch on class <code>soma_adat</code>.
<br /><br />
See <code><a href="#topic+reexports">reexports()</a></code> for a details on re-exported S3 generics from other
packages (mostly <code>dplyr</code> and <code>tidyr</code>) to enable S3 methods to be
dispatched on class <code>soma_adat</code>.
<br /><br />
Below is a list of <em>all</em> currently available S3 methods that dispatch on
the <code>soma_adat</code> class:
</p>
<div class="sourceCode"><pre>#&gt;  [1] [              [[             [[&lt;-           [&lt;-           
#&gt;  [5] ==             $              $&lt;-            anti_join     
#&gt;  [9] arrange        count          filter         full_join     
#&gt; [13] getAdatVersion getAnalytes    getMeta        group_by      
#&gt; [17] inner_join     is_seqFormat   left_join      Math          
#&gt; [21] median         merge          mutate         Ops           
#&gt; [25] print          rename         right_join     row.names&lt;-   
#&gt; [29] sample_frac    sample_n       select         semi_join     
#&gt; [33] separate       slice_sample   slice          summary       
#&gt; [37] Summary        transform      ungroup        unite         
#&gt; see '?methods' for accessing help and source code
</pre></div>
<p>The S3 <code><a href="base.html#topic+print">print()</a></code> method returns summary information parsed from the object
attributes, if present, followed by a dispatch to the <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
print method. Rownames are printed as the first column in the print method
only.
</p>
<p>The S3 <code><a href="base.html#topic+summary">summary()</a></code> method returns the following for each column of the ADAT
object containing SOMAmer data (clinical meta data is <em>excluded</em>):
</p>

<ul>
<li><p> Target (if available)
</p>
</li>
<li><p> Minimum value
</p>
</li>
<li><p> 1st Quantile
</p>
</li>
<li><p> Median
</p>
</li>
<li><p> Mean
</p>
</li>
<li><p> 3rd Quantile
</p>
</li>
<li><p> Maximum value
</p>
</li>
<li><p> Standard deviation
</p>
</li>
<li><p> Median absolute deviation (<code><a href="stats.html#topic+mad">mad()</a></code>)
</p>
</li>
<li><p> Interquartile range (<code><a href="stats.html#topic+IQR">IQR()</a></code>)
</p>
</li></ul>

<p>The S3 <code><a href="base.html#topic+Extract">Extract()</a></code> method is used for sub-setting a <code>soma_adat</code>
object and relies heavily on the <code>[</code> method that maintains the <code>soma_adat</code>
attributes intact <em>and</em> subsets the <code>Col.Meta</code> so that it is consistent
with the newly created object.
</p>
<p>S3 extraction via <code>$</code> is fully supported, however,
as opposed to the <code>data.frame</code> method, partial matching
is <em>not</em> allowed for class <code>soma_adat</code>.
</p>
<p>S3 extraction via <code>[[</code> is supported, however, we restrict
the usage of <code>[[</code> for <code>soma_adat</code>. Use only a numeric index (e.g. <code>1L</code>)
or a character identifying the column (e.g. <code>"SampleID"</code>).
Do not use <code style="white-space: pre;">&#8288;[[i,j]]&#8288;</code> syntax with <code>[[</code>, use <code>[</code> instead.
As with <code>$</code>, partial matching is <em>not</em> allowed.
</p>
<p>S3 assignment via <code>[</code> is supported for class <code>soma_adat</code>.
</p>
<p>S3 assignment via <code>$</code> is fully supported for class <code>soma_adat</code>.
</p>
<p>S3 assignment via <code>[[</code> is supported for class <code>soma_adat</code>.
</p>
<p>S3 <code><a href="stats.html#topic+median">median()</a></code> is <em>not</em> currently supported for the <code>soma_adat</code> class,
however a dispatch is in place to direct users to alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'soma_adat'
print(x, show_header = FALSE, ...)

## S3 method for class 'soma_adat'
summary(object, tbl = NULL, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'soma_adat'
x[i, j, drop = TRUE, ...]

## S3 method for class 'soma_adat'
x$name

## S3 method for class 'soma_adat'
x[[i, j, ..., exact = TRUE]]

## S3 replacement method for class 'soma_adat'
x[i, j, ...] &lt;- value

## S3 replacement method for class 'soma_adat'
x$i, j, ... &lt;- value

## S3 replacement method for class 'soma_adat'
x[[i, j, ...]] &lt;- value

## S3 method for class 'soma_adat'
median(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="soma_adat_+3A_x">x</code>, <code id="soma_adat_+3A_object">object</code></td>
<td>
<p>A <code>soma_adat</code> class object.</p>
</td></tr>
<tr><td><code id="soma_adat_+3A_show_header">show_header</code></td>
<td>
<p>Logical. Should all the <code style="white-space: pre;">&#8288;Header Data&#8288;</code> information
be displayed instead of the data frame (<code>tibble</code>) object?</p>
</td></tr>
<tr><td><code id="soma_adat_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="soma_adat_+3A_tbl">tbl</code></td>
<td>
<p>An annotations table. If <code>NULL</code> (default),
annotation information is extracted from the object itself (if possible).
Alternatively, the result of a call to <code><a href="#topic+getAnalyteInfo">getAnalyteInfo()</a></code>, from
which Target names can be extracted.</p>
</td></tr>
<tr><td><code id="soma_adat_+3A_digits">digits</code></td>
<td>
<p>Integer. Used for number formatting with <code><a href="base.html#topic+signif">signif()</a></code>.</p>
</td></tr>
<tr><td><code id="soma_adat_+3A_i">i</code>, <code id="soma_adat_+3A_j">j</code></td>
<td>
<p>Row and column indices respectively. If <code>j</code> is omitted,
<code>i</code> is used as the column index.</p>
</td></tr>
<tr><td><code id="soma_adat_+3A_drop">drop</code></td>
<td>
<p>Coerce to a vector if fetching one column via <code>tbl[, j]</code>.
Default <code>FALSE</code>, ignored when accessing a column via <code>tbl[j]</code>.</p>
</td></tr>
<tr><td><code id="soma_adat_+3A_name">name</code></td>
<td>
<p>A <a href="base.html#topic+name">name</a> or a string.</p>
</td></tr>
<tr><td><code id="soma_adat_+3A_exact">exact</code></td>
<td>
<p>Ignored with a <code><a href="base.html#topic+warning">warning()</a></code>.</p>
</td></tr>
<tr><td><code id="soma_adat_+3A_value">value</code></td>
<td>
<p>A value to store in a row, column, range or cell.</p>
</td></tr>
<tr><td><code id="soma_adat_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether <code>NA</code>
values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The set of S3 methods above return the <code>soma_adat</code> object with
the corresponding S3 method applied.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupGenerics">groupGenerics()</a></code>
</p>
<p>Other IO: 
<code><a href="#topic+loadAdatsAsList">loadAdatsAsList</a>()</code>,
<code><a href="#topic+parseHeader">parseHeader</a>()</code>,
<code><a href="#topic+read_adat">read_adat</a>()</code>,
<code><a href="#topic+write_adat">write_adat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># S3 print method
example_data

# show the header info (no RFU data)
print(example_data, show_header = TRUE)

# S3 summary method
# MMP analytes (4)
mmps &lt;- c("seq.2579.17", "seq.2788.55", "seq.2789.26", "seq.4925.54")
mmp_adat &lt;- example_data[, c("Sex", mmps)]
summary(mmp_adat)

# Summarize by group
mmp_adat |&gt;
  split(mmp_adat$Sex) |&gt;
  lapply(summary)

# Alternatively pass annotations with Target info
anno &lt;- getAnalyteInfo(mmp_adat)
summary(mmp_adat, tbl = anno)
</code></pre>

<hr>
<h2 id='SomaDataIO-deprecated'>Deprecated function(s) of the <span class="pkg">SomaDataIO</span> package</h2><span id='topic+SomaDataIO-deprecated'></span><span id='topic+getSomamers'></span><span id='topic+getSomamerData'></span>

<h3>Description</h3>

<p>These functions have either been
<a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a> or
<a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
in the current version of <span class="pkg">SomaDataIO</span> package.
They may eventually be completely removed, so
please re-code your scripts accordingly based on the
suggestions below:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Function</strong>       </td><td style="text-align: center;">                                    </td><td style="text-align: right;"> <strong>Now Use</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getSomamers">getSomamers()</a></code>    </td><td style="text-align: center;"> <a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a> </td><td style="text-align: right;"> <code><a href="#topic+getAnalytes">getAnalytes()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getSomamerData">getSomamerData()</a></code> </td><td style="text-align: center;"> <a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a> </td><td style="text-align: right;"> <code><a href="#topic+getAnalyteInfo">getAnalyteInfo()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>Some badges you may see in <span class="pkg">SomaDataIO</span>:
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>

<hr>
<h2 id='SomaScanObjects'>Example Data and Objects</h2><span id='topic+SomaScanObjects'></span><span id='topic+example_data'></span><span id='topic+ex_analytes'></span><span id='topic+ex_anno_tbl'></span><span id='topic+ex_target_names'></span>

<h3>Description</h3>

<p>The <code>example_data</code> object is intended to provide existing and prospective
SomaLogic customers with example data to enable analysis preparation prior
to receipt of SomaScan data, and also for those generally curious about the
SomaScan data deliverable. It is <strong>not</strong> intended to be used as a control
group for studies or provide any metrics for SomaScan data in general.
</p>


<h3>Format</h3>


<dl>
<dt>example_data</dt><dd><p>a <code>soma_adat</code> parsed via <code><a href="#topic+read_adat">read_adat()</a></code> containing
192 samples (see below for breakdown of sample type). There are 5318
columns containing 5284 analyte features and 34 clinical meta data fields.
These data have been pre-processed via the following steps:
</p>

<ul>
<li><p> hybridization normalized (all samples)
</p>
</li>
<li><p> calibrators and buffers median normalized
</p>
</li>
<li><p> plate scaled
</p>
</li>
<li><p> calibrated
</p>
</li>
<li><p> Adaptive Normalization by Maximum Likelihood (ANML) of
QC and clinical samples
</p>
</li></ul>

<p><strong>Note1:</strong> The <code>Age</code> and <code>Sex</code> (<code>M</code>/<code>F</code>) fields contain simulated values
designed to contain biological signal.
</p>
<div class="sourceCode"><pre>**Note2:** The `SampleType` column contains sample source/type information
and usually the `SampleType == Sample` represents the "client" samples.

**Note3:** The original source file can be found at
\url{https://github.com/SomaLogic/SomaLogic-Data}.
</pre></div>
</dd>
<dt>ex_analytes</dt><dd><p>character string of the analyte features contained
in the <code>soma_adat</code> object, derived from a call to <code><a href="#topic+getAnalytes">getAnalytes()</a></code>.</p>
</dd>
<dt>ex_anno_tbl</dt><dd><p>a lookup table corresponding to a
transposed data frame of the &quot;Col.Meta&quot; attribute of an ADAT, with an
index key field <code>AptName</code> included in column 1, derived from a call to
<code><a href="#topic+getAnalyteInfo">getAnalyteInfo()</a></code>.</p>
</dd>
<dt>ex_target_names</dt><dd><p>A lookup table mapping <code>SeqId</code> feature names -&gt;
target names contained in <code>example_data</code>. This object (or one like it) is
convenient at the console via auto-complete for labeling and/or creating
plot titles on the fly.</p>
</dd>
</dl>



<h3>Data Description</h3>

<p>The <code>example_data</code> object contains a SomaScan V4 study from healthy
normal individuals. The RFU measurements themselves and other identifiers
have been altered to protect personally identifiable information (PII),
but also retain underlying biological signal as much as possible.
There are 192 total EDTA-plasma samples across two 96-well plate runs
which are broken down by the following types:
</p>

<ul>
<li><p> 170 clinical samples (client study samples)
</p>
</li>
<li><p> 10 calibrators (replicate controls for combining data across runs)
</p>
</li>
<li><p> 6 QC samples (replicate controls used to assess run quality)
</p>
</li>
<li><p> 6 Buffer samples (no protein controls)
</p>
</li></ul>



<h3>Data Processing</h3>

<p>The standard V4 data normalization procedure for EDTA-plasma samples was
applied to this dataset. For more details on the data standardization process
see the Data Standardization and File Specification Technical Note. General
details are outlined above.
</p>


<h3>Source</h3>

<p><a href="https://github.com/SomaLogic/SomaLogic-Data">https://github.com/SomaLogic/SomaLogic-Data</a>
</p>
<p>Standard BioTools, Inc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># S3 print method
example_data

# print header info
print(example_data, show_header = TRUE)

class(example_data)

# Features/Analytes
head(ex_analytes, 20L)

# Feature info table (annotations)
ex_anno_tbl

# Search via `filter()`
dplyr::filter(ex_anno_tbl, grepl("^MMP", Target))

# Lookup table -&gt; targets
# MMP-9
ex_target_names$seq.2579.17

# gender hormone FSH
tapply(example_data$seq.3032.11, example_data$Sex, median)

# gender hormone LH
tapply(example_data$seq.2953.31, example_data$Sex, median)

# Target lookup
ex_target_names$seq.2953.31     # tab-completion at console

# Sample Type/Source
table(example_data$SampleType)

# Sex/Gender Variable
table(example_data$Sex)

# Age Variable
summary(example_data$Age)
</code></pre>

<hr>
<h2 id='transform'>Scale Transform <code>soma_adat</code> Columns/Rows</h2><span id='topic+transform'></span><span id='topic+transform.soma_adat'></span>

<h3>Description</h3>

<p>Scale the <em>i-th</em> row or column of a <code>soma_adat</code> object by the <em>i-th</em>
element of a vector. Designed to facilitate linear transformations
of <em>only</em> the analyte/RFU entries by scaling the data matrix.
If scaling the analytes/RFU (columns), <code>v</code> <em>must</em> have
<code>getAnalytes(adat, n = TRUE)</code> elements.
If scaling the samples (rows), <code>v</code> <em>must</em>
have <code style="white-space: pre;">&#8288;nrow(_data)&#8288;</code> elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'soma_adat'
transform(`_data`, v, dim = 2L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_+3A__data">_data</code></td>
<td>
<p>A <code>soma_adat</code> object.</p>
</td></tr>
<tr><td><code id="transform_+3A_v">v</code></td>
<td>
<p>A numeric vector of the appropriate length corresponding to <code>dim</code>.</p>
</td></tr>
<tr><td><code id="transform_+3A_dim">dim</code></td>
<td>
<p>Integer. The dimension to apply elements of <code>v</code> to.
<code>1</code> = rows; <code>2</code> = columns (default).</p>
</td></tr>
<tr><td><code id="transform_+3A_...">...</code></td>
<td>
<p>Currently not used but required by the S3 generic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the following operations (quickly):
</p>
<p>Columns:
</p>
<p style="text-align: center;"><code class="reqn">
  M_{nxp} = A_{nxp} * diag(v)_{pxp}
</code>
</p>

<p>Rows:
</p>
<p style="text-align: center;"><code class="reqn">
  M_{nxp} = diag(v)_{nxn} * A_{nxp}
</code>
</p>



<h3>Value</h3>

<p>A modified value of <code style="white-space: pre;">&#8288;_data&#8288;</code> with either the rows or columns
linearly transformed by <code>v</code>.
</p>


<h3>Note</h3>

<p>This method in intentionally naive, and assumes the user has
ordered <code>v</code> to match the columns/rows of <code style="white-space: pre;">&#8288;_data&#8288;</code> appropriately.
This must be done upstream.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+apply">apply()</a></code>, <code><a href="base.html#topic+sweep">sweep()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simplified example of underlying operations
M &lt;- matrix(1:12, ncol = 4)
M

v &lt;- 1:4
M %*% diag(v)    # transform columns

v &lt;- 1:3
diag(v) %*% M    # transform rows

# dummy ADAT example:
v    &lt;- c(2, 0.5)     # double seq1; half seq2
adat &lt;- data.frame(sample      = paste0("sample_", 1:3),
                   seq.1234.56 = c(1, 2, 3),
                   seq.9999.88 = c(4, 5, 6) * 10)
adat

# `soma_adat` to invoke S3 method dispatch
class(adat) &lt;- c("soma_adat", "data.frame")
trans &lt;- transform(adat, v)
data.frame(trans)
</code></pre>

<hr>
<h2 id='write_adat'>Write an ADAT to File</h2><span id='topic+write_adat'></span>

<h3>Description</h3>

<p>One can write an existing modified internal ADAT
(<code>soma_adat</code> R object) to an external file.
However the ADAT object itself <em>must</em> have intact
attributes, see <code><a href="#topic+is_intact_attr">is_intact_attr()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_adat(x, file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_adat_+3A_x">x</code></td>
<td>
<p>A <code>soma_adat</code> object (with intact attributes),
typically created using <code><a href="#topic+read_adat">read_adat()</a></code>.</p>
</td></tr>
<tr><td><code id="write_adat_+3A_file">file</code></td>
<td>
<p>Character. File path where the object should be written.
For example, extensions should be <code style="white-space: pre;">&#8288;*.adat&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ADAT specification <em>no longer</em> requires Windows
end of line (EOL) characters (<code style="white-space: pre;">&#8288;"\r\n"&#8288;</code>).
The current EOL spec is <code style="white-space: pre;">&#8288;"\n"&#8288;</code> which is commonly used in POSIX systems,
like MacOS and Linux.
Since the EOL affects the resulting checksum, ADATs written on
other systems generate slightly differing files.
Standardizing to <code style="white-space: pre;">&#8288;"\n"&#8288;</code> attempts to solve this issue.
For reference, see the EOL encoding for operating systems below:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
Symbol </td><td style="text-align: left;"> Platform    </td><td style="text-align: center;"> Character </td>
</tr>
<tr>
 <td style="text-align: left;">
LF     </td><td style="text-align: left;"> Linux       </td><td style="text-align: center;"> <code style="white-space: pre;">&#8288;"\n"&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
CR     </td><td style="text-align: left;"> MacOS       </td><td style="text-align: center;"> <code style="white-space: pre;">&#8288;"\r"&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
CRLF   </td><td style="text-align: left;"> DOS/Windows </td><td style="text-align: center;"> <code style="white-space: pre;">&#8288;"\r\n"&#8288;</code>
</td>
</tr>

</table>



<h3>Value</h3>

<p>Invisibly returns the input <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_adat">read_adat()</a></code>, <code><a href="#topic+is_intact_attr">is_intact_attr()</a></code>
</p>
<p>Other IO: 
<code><a href="#topic+loadAdatsAsList">loadAdatsAsList</a>()</code>,
<code><a href="#topic+parseHeader">parseHeader</a>()</code>,
<code><a href="#topic+read_adat">read_adat</a>()</code>,
<code><a href="#topic+soma_adat">soma_adat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># trim to 1 sample for speed
adat_out &lt;- head(example_data, 1L)

# attributes must(!) be intact to write
is_intact_attr(adat_out)

write_adat(adat_out, file = tempfile(fileext = ".adat"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
