<!DOCTYPE html><html lang="en"><head><title>Help for package CPAT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CPAT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.onAttach'><p>Package Attach Hook Function</p></a></li>
<li><a href='#+25s+25'><p>Concatenate (With Space)</p></a></li>
<li><a href='#+25s0+25'><p>Concatenate (Without Space)</p></a></li>
<li><a href='#andrews_test'><p>Univariate Andrews Test for End-of-Sample Structural Change</p></a></li>
<li><a href='#andrews_test_reg'><p>Multivariate Andrews' Test for End-of-Sample Structural Change</p></a></li>
<li><a href='#Andrews.test'><p>Andrews' Test for End-of-Sample Structural Change</p></a></li>
<li><a href='#banks'><p>Bank Portfolio Returns</p></a></li>
<li><a href='#CPAT_startup_message'><p>Create Package Startup Message</p></a></li>
<li><a href='#cpt_consistent_var'><p>Variance Estimation Consistent Under Change</p></a></li>
<li><a href='#CUSUM.test'><p>CUSUM Test</p></a></li>
<li><a href='#DE.test'><p>Darling-Erdös Test</p></a></li>
<li><a href='#dZn'><p>Rényi-Type Statistic Limiting Distribution Density Function</p></a></li>
<li><a href='#ff'><p>Fama-French Five Factors</p></a></li>
<li><a href='#get_lrv_vec'><p>Long-Run Variance Estimation With Possible Change Points</p></a></li>
<li><a href='#getLongRunWeights'><p>Weights for Long-Run Variance</p></a></li>
<li><a href='#HR.test'><p>Rényi-Type Test</p></a></li>
<li><a href='#HS.test'><p>Hidalgo-Seo Test</p></a></li>
<li><a href='#pdarling_erdos'><p>Darling-Erdös Statistic CDF</p></a></li>
<li><a href='#phidalgo_seo'><p>Hidalgo-Seo Statistic CDF</p></a></li>
<li><a href='#pkolmogorov'><p>Kolmogorov CDF</p></a></li>
<li><a href='#pZn'><p>Rènyi-Type Statistic CDF</p></a></li>
<li><a href='#qdarling_erdos'><p>Darling-Erdös Statistic Limiting Distribution Quantile Function</p></a></li>
<li><a href='#qhidalgo_seo'><p>Hidalgo-Seo Statistic Limiting Distribution Quantile Function</p></a></li>
<li><a href='#qkolmogorov'><p>Kolmogorov Distribution Quantile Function</p></a></li>
<li><a href='#qZn'><p>Rènyi-Type Statistic Quantile Function</p></a></li>
<li><a href='#rchangepoint'><p>Simulate Univariate Data With a Single Change Point</p></a></li>
<li><a href='#sim_de_stat'><p>Darling-Erdös Statistic Simulation</p></a></li>
<li><a href='#sim_hs_stat'><p>Hidalgo-Seo Statistic Simulation</p></a></li>
<li><a href='#sim_Vn'><p>CUSUM Statistic Simulation (Assuming Variance)</p></a></li>
<li><a href='#sim_Vn_stat'><p>CUSUM Statistic Simulation</p></a></li>
<li><a href='#sim_Zn'><p>Rènyi-Type Statistic Simulation (Assuming Variance)</p></a></li>
<li><a href='#sim_Zn_stat'><p>Rènyi-Type Statistic Simulation</p></a></li>
<li><a href='#stat_de'><p>Compute the Darling-Erdös Statistic</p></a></li>
<li><a href='#stat_hs'><p>Compute the Hidalgo-Seo Statistic</p></a></li>
<li><a href='#stat_Vn'><p>Compute the CUSUM Statistic</p></a></li>
<li><a href='#stat_Zn'><p>Compute the Rényi-Type Statistic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Change Point Analysis Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-12-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Curtis Miller &lt;cmiller@math.utah.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements several statistical tests for structural change, specifically the tests featured in Horváth, Rice and Miller (in press): CUSUM (with weighted/trimmed variants), Darling-Erdös, Hidalgo-Seo, Andrews, and the new Rényi-type test.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cointReg (&ge; 0.2), foreach (&ge; 1.4), doRNG (&ge; 1.7),
doParallel (&ge; 1.0), ggplot2 (&ge; 2.2), dplyr (&ge; 0.7),
tikzDevice (&ge; 0.12), testthat (&ge; 2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats (&ge; 3.2), utils (&ge; 3.2), grDevices (&ge; 3.2), Rdpack (&ge;
0.9), methods (&ge; 3.2), Rcpp (&ge; 0.12), purrr (&ge; 0.2)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-12-17 04:31:52 UTC; curtis</td>
</tr>
<tr>
<td>Author:</td>
<td>Curtis Miller [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-12-25 22:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='.onAttach'>Package Attach Hook Function</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>Hook triggered when package attached
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(lib, pkg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".onAttach_+3A_lib">lib</code></td>
<td>
<p>a character string giving the library directory where the package
defining the namespace was found</p>
</td></tr>
<tr><td><code id=".onAttach_+3A_pkg">pkg</code></td>
<td>
<p>a character string giving the name of the package</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::.onAttach(.libPaths()[1], "CPAT")
</code></pre>

<hr>
<h2 id='+25s+25'>Concatenate (With Space)</h2><span id='topic++25s+25'></span>

<h3>Description</h3>

<p>Concatenate and form strings (with space separation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %s% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25s+2B25_+3A_x">x</code></td>
<td>
<p>One object</p>
</td></tr>
<tr><td><code id="+2B25s+2B25_+3A_y">y</code></td>
<td>
<p>Another object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string combining <code>x</code> and <code>y</code> with a space separating them
</p>


<h3>Examples</h3>

<pre><code class='language-R'>`%s%` &lt;- CPAT:::`%s%`
"Hello" %s% "world"
</code></pre>

<hr>
<h2 id='+25s0+25'>Concatenate (Without Space)</h2><span id='topic++25s0+25'></span>

<h3>Description</h3>

<p>Concatenate and form strings (no space separation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %s0% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25s0+2B25_+3A_x">x</code></td>
<td>
<p>One object</p>
</td></tr>
<tr><td><code id="+2B25s0+2B25_+3A_y">y</code></td>
<td>
<p>Another object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string combining <code>x</code> and <code>y</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>`%s0%` &lt;- CPAT:::`%s0%`
"Hello" %s0% "world"
</code></pre>

<hr>
<h2 id='andrews_test'>Univariate Andrews Test for End-of-Sample Structural Change</h2><span id='topic+andrews_test'></span>

<h3>Description</h3>

<p>This implements Andrews' test for end-of-sample change, as described by
Andrews (2003). This test was derived for detecting a
change in univariate data. See (Andrews 2003) for
a description of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>andrews_test(x, M, pval = TRUE, stat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="andrews_test_+3A_x">x</code></td>
<td>
<p>Vector of the data to test</p>
</td></tr>
<tr><td><code id="andrews_test_+3A_m">M</code></td>
<td>
<p>Numeric index of the location of the first potential change point</p>
</td></tr>
<tr><td><code id="andrews_test_+3A_pval">pval</code></td>
<td>
<p>If <code>TRUE</code>, return a p-value</p>
</td></tr>
<tr><td><code id="andrews_test_+3A_stat">stat</code></td>
<td>
<p>If <code>TRUE</code>, return a test statistic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If both <code>pval</code> and <code>stat</code> are <code>TRUE</code>, a list
containing both; otherwise, a number for one or the other, depending
on which is <code>TRUE</code>
</p>


<h3>References</h3>

<p>Andrews DWK (2003).
&ldquo;End-of-Sample Instability Tests.&rdquo;
<em>Econometrica</em>, <b>71</b>(6), 1661&ndash;1694.
ISSN 00129682, 14680262, <a href="https://www.jstor.org/stable/1555535">https://www.jstor.org/stable/1555535</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::andrews_test(rnorm(1000), M = 900)
</code></pre>

<hr>
<h2 id='andrews_test_reg'>Multivariate Andrews' Test for End-of-Sample Structural Change</h2><span id='topic+andrews_test_reg'></span>

<h3>Description</h3>

<p>This implements Andrews' test for end-of-sample change, as described by
Andrews (2003). This test was derived for detecting a
change in multivarate data, aso originally described. See
(Andrews 2003) for a description of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>andrews_test_reg(formula, data, M, pval = TRUE, stat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="andrews_test_reg_+3A_formula">formula</code></td>
<td>
<p>The regression formula, which will be passed to
<code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="andrews_test_reg_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing the data</p>
</td></tr>
<tr><td><code id="andrews_test_reg_+3A_m">M</code></td>
<td>
<p>Numeric index of the location of the first potential change point</p>
</td></tr>
<tr><td><code id="andrews_test_reg_+3A_pval">pval</code></td>
<td>
<p>If <code>TRUE</code>, return a p-value</p>
</td></tr>
<tr><td><code id="andrews_test_reg_+3A_stat">stat</code></td>
<td>
<p>If <code>TRUE</code>, return a test statistic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If both <code>pval</code> and <code>stat</code> are <code>TRUE</code>, a list
containing both; otherwise, a number for one or the other, depending
on which is <code>TRUE</code>
</p>


<h3>References</h3>

<p>Andrews DWK (2003).
&ldquo;End-of-Sample Instability Tests.&rdquo;
<em>Econometrica</em>, <b>71</b>(6), 1661&ndash;1694.
ISSN 00129682, 14680262, <a href="https://www.jstor.org/stable/1555535">https://www.jstor.org/stable/1555535</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)
y &lt;- 1 + 2 * x + rnorm(1000)
df &lt;- data.frame(x, y)
CPAT:::andrews_test_reg(y ~ x, data = df, M = 900)
</code></pre>

<hr>
<h2 id='Andrews.test'>Andrews' Test for End-of-Sample Structural Change</h2><span id='topic+Andrews.test'></span>

<h3>Description</h3>

<p>Performs Andrews' test for end-of-sample structural change, as described in
(Andrews 2003). This function works for both univariate and
multivariate data depending on the nature of <code>x</code> and whether
<code>formula</code> is specified. This function is thus an interface to
<code><a href="#topic+andrews_test">andrews_test</a></code> and <code><a href="#topic+andrews_test_reg">andrews_test_reg</a></code>; see the
documentation of those functions for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Andrews.test(x, M, formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Andrews.test_+3A_x">x</code></td>
<td>
<p>Data to test for change in mean (either a vector or
<code>data.frame</code>)</p>
</td></tr>
<tr><td><code id="Andrews.test_+3A_m">M</code></td>
<td>
<p>Numeric index of the location of the first potential change point</p>
</td></tr>
<tr><td><code id="Andrews.test_+3A_formula">formula</code></td>
<td>
<p>The regression formula, which will be passed to
<code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>htest</code>-class object containing the results of the test
</p>


<h3>References</h3>

<p>Andrews DWK (2003).
&ldquo;End-of-Sample Instability Tests.&rdquo;
<em>Econometrica</em>, <b>71</b>(6), 1661&ndash;1694.
ISSN 00129682, 14680262, <a href="https://www.jstor.org/stable/1555535">https://www.jstor.org/stable/1555535</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Andrews.test(rnorm(1000), M = 900)
x &lt;- rnorm(1000)
y &lt;- 1 + 2 * x + rnorm(1000)
df &lt;- data.frame(x, y)
Andrews.test(df, y ~ x, M = 900)
</code></pre>

<hr>
<h2 id='banks'>Bank Portfolio Returns</h2><span id='topic+banks'></span>

<h3>Description</h3>

<p>Data set representing the returns of an industry portfolio representing the
banking industry based on company four-digit SIC codes, obtained from the
data library maintained by Kenneth French. Data ranges from July 1, 1926
to October 31, 2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>banks
</code></pre>


<h3>Format</h3>

<p>A data frame with 24099 rows and 1 variable:
</p>

<dl>
<dt>Banks</dt><dd><p>The return of a portfolio representing the banking industry</p>
</dd>
</dl>

<p>Row names are dates in YYYY-MM-DD format.</p>


<h3>Source</h3>

<p><a href="http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html">http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html</a>
</p>

<hr>
<h2 id='CPAT_startup_message'>Create Package Startup Message</h2><span id='topic+CPAT_startup_message'></span>

<h3>Description</h3>

<p>Makes package startup message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPAT_startup_message()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::CPAT_startup_message()
</code></pre>

<hr>
<h2 id='cpt_consistent_var'>Variance Estimation Consistent Under Change</h2><span id='topic+cpt_consistent_var'></span>

<h3>Description</h3>

<p>Estimate the variance (using the sum of squared errors) with an estimator
that is consistent when the mean changes at a known point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpt_consistent_var(x, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpt_consistent_var_+3A_x">x</code></td>
<td>
<p>A numeric vector for the data set</p>
</td></tr>
<tr><td><code id="cpt_consistent_var_+3A_k">k</code></td>
<td>
<p>The potential change point at which the data set is split</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{\sigma}^2_{T,t} = T^{-1}\left(\sum_{s = 1}^t \left(X_s -
      \bar{X}_t\right)^2 + \sum_{s = t + 1}^{T}\left(X_s - \tilde{X}_{T - t}
      \right)^2\right)</code>
</p>

<p>where <code class="reqn">\bar{X}_t = t^{-1}\sum_{s = 1}^t X_s</code> and <code class="reqn">\tilde{X}_{T - t} =
(T - t)^{-1} \sum_{s = t + 1}^{T} X_s</code>. In this implementation, <code class="reqn">T</code> is
computed automatically as <code>length(x)</code> and <code>k</code> corresponds to
<code class="reqn">t</code>, a potential change point.
</p>


<h3>Value</h3>

<p>The estimated change-consistent variance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::cpt_consistent_var(c(rnorm(500, mean = 0), rnorm(500, mean = 1)), k = 500)
</code></pre>

<hr>
<h2 id='CUSUM.test'>CUSUM Test</h2><span id='topic+CUSUM.test'></span>

<h3>Description</h3>

<p>Performs the (univariate) CUSUM test for change in mean, as described in
(Rice et al. ). This is effectively an interface to
<code><a href="#topic+stat_Vn">stat_Vn</a></code>; see its documentation for more details. p-values are
computed using <code><a href="#topic+pkolmogorov">pkolmogorov</a></code>, which represents the limiting
distribution of the statistic under the null hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CUSUM.test(x, use_kernel_var = FALSE, stat_plot = FALSE,
  kernel = "ba", bandwidth = "and")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CUSUM.test_+3A_x">x</code></td>
<td>
<p>Data to test for change in mean</p>
</td></tr>
<tr><td><code id="CUSUM.test_+3A_use_kernel_var">use_kernel_var</code></td>
<td>
<p>Set to <code>TRUE</code> to use kernel methods for long-run
variance estimation (typically used when the data is
believed to be correlated); if <code>FALSE</code>, then the
long-run variance is estimated using
<code class="reqn">\hat{\sigma}^2_{T,t} = T^{-1}\left(
\sum_{s = 1}^t \left(X_s - \bar{X}_t\right)^2 +
\sum_{s = t + 1}^{T}\left(X_s -
\tilde{X}_{T - t}\right)^2\right)</code>, where
<code class="reqn">\bar{X}_t = t^{-1}\sum_{s = 1}^t X_s</code> and
<code class="reqn">\tilde{X}_{T - t} = (T - t)^{-1}
\sum_{s = t + 1}^{T} X_s</code></p>
</td></tr>
<tr><td><code id="CUSUM.test_+3A_stat_plot">stat_plot</code></td>
<td>
<p>Whether to create a plot of the values of the statistic at
all potential change points</p>
</td></tr>
<tr><td><code id="CUSUM.test_+3A_kernel">kernel</code></td>
<td>
<p>If character, the identifier of the kernel function as used in
<span class="pkg">cointReg</span> (see <code><a href="cointReg.html#topic+getLongRunVar">getLongRunVar</a></code>); if
function, the kernel function to be used for long-run variance
estimation (default is the Bartlett kernel in <span class="pkg">cointReg</span>)</p>
</td></tr>
<tr><td><code id="CUSUM.test_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If character, the identifier for how to compute the
bandwidth as defined in <span class="pkg">cointReg</span> (see
<code><a href="cointReg.html#topic+getBandwidth">getBandwidth</a></code>); if function, a function
to use for computing the bandwidth; if numeric, the bandwidth
value to use (the default is to use Andrews' method, as used in
<span class="pkg">cointReg</span>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>htest</code>-class object containing the results of the test
</p>


<h3>References</h3>

<p>Rice G, Miller C, Horváth L (????).
&ldquo;A new class of change point test of Rényi type.&rdquo;
in-press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CUSUM.test(rnorm(1000))
CUSUM.test(rnorm(1000), use_kernel_var = TRUE, kernel = "bo",
           bandwidth = "nw")
</code></pre>

<hr>
<h2 id='DE.test'>Darling-Erdös Test</h2><span id='topic+DE.test'></span>

<h3>Description</h3>

<p>Performs the (univariate) Darling-Erdös test for change in mean, as described
in (Rice et al. ). This is effectively an interface
to <code><a href="#topic+stat_de">stat_de</a></code>; see its documentation for more details. p-values
are computed using <code><a href="#topic+pdarling_erdos">pdarling_erdos</a></code>, which represents the
limiting distribution of the test statistic under the null hypothesis when
<code>a</code> and <code>b</code> are chosen appropriately. (Change those parameters at
your own risk!)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DE.test(x, a = log, b = log, use_kernel_var = FALSE,
  stat_plot = FALSE, kernel = "ba", bandwidth = "and")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DE.test_+3A_x">x</code></td>
<td>
<p>Data to test for change in mean</p>
</td></tr>
<tr><td><code id="DE.test_+3A_a">a</code></td>
<td>
<p>The function that will be composed with
<code class="reqn">l(x) = (2 \log x)^{1/2}</code></p>
</td></tr>
<tr><td><code id="DE.test_+3A_b">b</code></td>
<td>
<p>The function that will be composed with
<code class="reqn">u(x) = 2 \log x + \frac{1}{2} \log \log x - \frac{1}{2} \log
\pi</code></p>
</td></tr>
<tr><td><code id="DE.test_+3A_use_kernel_var">use_kernel_var</code></td>
<td>
<p>Set to <code>TRUE</code> to use kernel methods for long-run
variance estimation (typically used when the data is
believed to be correlated); if <code>FALSE</code>, then the
long-run variance is estimated using
<code class="reqn">\hat{\sigma}^2_{T,t} = T^{-1}\left(
\sum_{s = 1}^t \left(X_s - \bar{X}_t\right)^2 +
\sum_{s = t + 1}^{T}\left(X_s -
\tilde{X}_{T - t}\right)^2\right)</code>, where
<code class="reqn">\bar{X}_t = t^{-1}\sum_{s = 1}^t X_s</code> and
<code class="reqn">\tilde{X}_{T - t} = (T - t)^{-1}
\sum_{s = t + 1}^{T} X_s</code></p>
</td></tr>
<tr><td><code id="DE.test_+3A_stat_plot">stat_plot</code></td>
<td>
<p>Whether to create a plot of the values of the statistic at
all potential change points</p>
</td></tr>
<tr><td><code id="DE.test_+3A_kernel">kernel</code></td>
<td>
<p>If character, the identifier of the kernel function as used in
<span class="pkg">cointReg</span> (see <code><a href="cointReg.html#topic+getLongRunVar">getLongRunVar</a></code>); if
function, the kernel function to be used for long-run variance
estimation (default is the Bartlett kernel in <span class="pkg">cointReg</span>)</p>
</td></tr>
<tr><td><code id="DE.test_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If character, the identifier for how to compute the
bandwidth as defined in <span class="pkg">cointReg</span> (see
<code><a href="cointReg.html#topic+getBandwidth">getBandwidth</a></code>); if function, a function
to use for computing the bandwidth; if numeric, the bandwidth
value to use (the default is to use Andrews' method, as used in
<span class="pkg">cointReg</span>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>htest</code>-class object containing the results of the test
</p>


<h3>References</h3>

<p>Rice G, Miller C, Horváth L (????).
&ldquo;A new class of change point test of Rényi type.&rdquo;
in-press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DE.test(rnorm(1000))
DE.test(rnorm(1000), use_kernel_var = TRUE, kernel = "bo", bandwidth = "nw")
</code></pre>

<hr>
<h2 id='dZn'>Rényi-Type Statistic Limiting Distribution Density Function</h2><span id='topic+dZn'></span>

<h3>Description</h3>

<p>Function for computing the value of the density function of the limiting
distribution of the Rényi-type statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dZn(x, summands = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dZn_+3A_x">x</code></td>
<td>
<p>Point at which to evaluate the density function (note that this
parameter is not vectorized)</p>
</td></tr>
<tr><td><code id="dZn_+3A_summands">summands</code></td>
<td>
<p>Number of summands to use in summation (the default should be
machine accurate)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the density function at <code class="reqn">x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::dZn(1)
</code></pre>

<hr>
<h2 id='ff'>Fama-French Five Factors</h2><span id='topic+ff'></span>

<h3>Description</h3>

<p>Data set containing the five factors described by
Fama and French (2015), from the data library maintained by
Kenneth French. Data ranges from July 1, 1963 to October
31, 2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff
</code></pre>


<h3>Format</h3>

<p>A data frame with 13679 rows and 6 variables:
</p>

<dl>
<dt>Mkt.RF</dt><dd><p>Market excess returns</p>
</dd>
<dt>RF</dt><dd><p>The risk-free rate of return</p>
</dd>
<dt>SMB</dt><dd><p>The return on a diversified portfolio of small stocks minus
return on a diversified portfolio of big stocks</p>
</dd>
<dt>HML</dt><dd><p>The return of a portfolio of stocks with a high
book-to-market (B/M) ratio minus the return of a portfolio
of stocks with a low B/M ratio</p>
</dd>
<dt>RMW</dt><dd><p>The return of a portfolio of stocks with robust profitability
minus a portfolio of stocks with weak profitability</p>
</dd>
<dt>CMA</dt><dd><p>The return of a portfolio of stocks with conservative
investment minus the return of a portfolio of stocks with
aggressive investment</p>
</dd>
</dl>

<p>Row names are dates in YYYYMMDD format.</p>


<h3>Source</h3>

<p><a href="http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html">http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html</a>
</p>

<hr>
<h2 id='get_lrv_vec'>Long-Run Variance Estimation With Possible Change Points</h2><span id='topic+get_lrv_vec'></span>

<h3>Description</h3>

<p>Computes the estimates of the long-run variance in a change point context, as
described in (Rice et al. ). By default it uses
kernel and bandwidth selection as used in the package <span class="pkg">cointReg</span>, though
changing the parameters <code>kernel</code> and <code>bandwidth</code> can change this
behavior. If <span class="pkg">cointReg</span> is not installed, the Bartlett internal (defined
internally) will be used and the bandwidth will be the square root of the
sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lrv_vec(dat, kernel = "ba", bandwidth = "and")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_lrv_vec_+3A_dat">dat</code></td>
<td>
<p>The data vector</p>
</td></tr>
<tr><td><code id="get_lrv_vec_+3A_kernel">kernel</code></td>
<td>
<p>If character, the identifier of the kernel function as used in
<span class="pkg">cointReg</span> (see <code><a href="cointReg.html#topic+getLongRunVar">getLongRunVar</a></code>); if
function, the kernel function to be used for long-run variance
estimation (default is the Bartlett kernel in <span class="pkg">cointReg</span>)</p>
</td></tr>
<tr><td><code id="get_lrv_vec_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If character, the identifier for how to compute the
bandwidth as defined in <span class="pkg">cointReg</span> (see
<code><a href="cointReg.html#topic+getBandwidth">getBandwidth</a></code>); if function, a function
to use for computing the bandwidth; if numeric, the bandwidth
value to use (the default is to use Andrews' method, as used in
<span class="pkg">cointReg</span>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of estimates of the long-run variance
</p>


<h3>References</h3>

<p>Rice G, Miller C, Horváth L (????).
&ldquo;A new class of change point test of Rényi type.&rdquo;
in-press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)
CPAT:::get_lrv_vec(x)
CPAT:::get_lrv_vec(x, kernel = "pa", bandwidth = "nw")
</code></pre>

<hr>
<h2 id='getLongRunWeights'>Weights for Long-Run Variance</h2><span id='topic+getLongRunWeights'></span>

<h3>Description</h3>

<p>Compute some weights for long-run variance. This code comes directly from the
source code of <span class="pkg">cointReg</span>; see <code><a href="cointReg.html#topic+getLongRunWeights">getLongRunWeights</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLongRunWeights(n, bandwidth, kernel = "ba")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLongRunWeights_+3A_n">n</code></td>
<td>
<p>Length of weights' vector</p>
</td></tr>
<tr><td><code id="getLongRunWeights_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A number for the bandwidth</p>
</td></tr>
<tr><td><code id="getLongRunWeights_+3A_kernel">kernel</code></td>
<td>
<p>The kernel function; see <code><a href="cointReg.html#topic+getLongRunVar">getLongRunVar</a></code>
for possible values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with components <code>w</code> containing the vector of weights and
<code>upper</code>, the index of the largest non-zero entry in <code>w</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::getLongRunWeights(10, 1)
</code></pre>

<hr>
<h2 id='HR.test'>Rényi-Type Test</h2><span id='topic+HR.test'></span>

<h3>Description</h3>

<p>Performs the (univariate) Rényi-type test for change in mean, as described in
(Rice et al. ). This is effectively an interface to
<code><a href="#topic+stat_Zn">stat_Zn</a></code>; see its documentation for more details. p-values are
computed using <code><a href="#topic+pZn">pZn</a></code>, which represents the limiting distribution
of the test statistic under the null hypothesis, which represents the
limiting distribution of the test statistic under the null hypothesis when
<code>kn</code> represents a sequence <code class="reqn">t_T</code> satisfying <code class="reqn">t_T \to \infty</code>
and <code class="reqn">t_T/T \to 0</code> as <code class="reqn">T \to \infty</code>. (<code><a href="base.html#topic+log">log</a></code> and
<code><a href="base.html#topic+sqrt">sqrt</a></code> should be good choices.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HR.test(x, kn = log, use_kernel_var = FALSE, stat_plot = FALSE,
  kernel = "ba", bandwidth = "and")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HR.test_+3A_x">x</code></td>
<td>
<p>Data to test for change in mean</p>
</td></tr>
<tr><td><code id="HR.test_+3A_kn">kn</code></td>
<td>
<p>A function corresponding to the trimming parameter <code class="reqn">t_T</code>; by
default, the square root function</p>
</td></tr>
<tr><td><code id="HR.test_+3A_use_kernel_var">use_kernel_var</code></td>
<td>
<p>Set to <code>TRUE</code> to use kernel methods for long-run
variance estimation (typically used when the data is
believed to be correlated); if <code>FALSE</code>, then the
long-run variance is estimated using
<code class="reqn">\hat{\sigma}^2_{T,t} = T^{-1}\left(
\sum_{s = 1}^t \left(X_s - \bar{X}_t\right)^2 +
\sum_{s = t + 1}^{T}\left(X_s -
\tilde{X}_{T - t}\right)^2\right)</code>, where
<code class="reqn">\bar{X}_t = t^{-1}\sum_{s = 1}^t X_s</code> and
<code class="reqn">\tilde{X}_{T - t} = (T - t)^{-1}
\sum_{s = t + 1}^{T} X_s</code>; if <code>custom_var</code> is not
<code>NULL</code>, this argument is ignored</p>
</td></tr>
<tr><td><code id="HR.test_+3A_stat_plot">stat_plot</code></td>
<td>
<p>Whether to create a plot of the values of the statistic at
all potential change points</p>
</td></tr>
<tr><td><code id="HR.test_+3A_kernel">kernel</code></td>
<td>
<p>If character, the identifier of the kernel function as used in
<span class="pkg">cointReg</span> (see <code><a href="cointReg.html#topic+getLongRunVar">getLongRunVar</a></code>); if
function, the kernel function to be used for long-run variance
estimation (default is the Bartlett kernel in <span class="pkg">cointReg</span>)</p>
</td></tr>
<tr><td><code id="HR.test_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If character, the identifier for how to compute the
bandwidth as defined in <span class="pkg">cointReg</span> (see
<code><a href="cointReg.html#topic+getBandwidth">getBandwidth</a></code>); if function, a function
to use for computing the bandwidth; if numeric, the bandwidth
value to use (the default is to use Andrews' method, as used in
<span class="pkg">cointReg</span>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>htest</code>-class object containing the results of the test
</p>


<h3>References</h3>

<p>Rice G, Miller C, Horváth L (????).
&ldquo;A new class of change point test of Rényi type.&rdquo;
in-press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HR.test(rnorm(1000))
HR.test(rnorm(1000), use_kernel_var = TRUE, kernel = "bo", bandwidth = "nw")
</code></pre>

<hr>
<h2 id='HS.test'>Hidalgo-Seo Test</h2><span id='topic+HS.test'></span>

<h3>Description</h3>

<p>Performs the (univariate) Hidalgo-Seo test for change in mean, as described
in (Rice et al. ). This is effectively an interface
to <code><a href="#topic+stat_hs">stat_hs</a></code>; see its documentation for more details. p-values
are computed using <code><a href="#topic+phidalgo_seo">phidalgo_seo</a></code>, which represents the limiting
distribution of the test statistic when the null hypothesis is true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HS.test(x, corr = TRUE, stat_plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HS.test_+3A_x">x</code></td>
<td>
<p>Data to test for change in mean</p>
</td></tr>
<tr><td><code id="HS.test_+3A_corr">corr</code></td>
<td>
<p>If <code>TRUE</code>, the long-run variance will be computed under the
assumption of correlated residuals; ignored if <code>custom_var</code>
is not <code>NULL</code> or <code>use_kernel_var</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="HS.test_+3A_stat_plot">stat_plot</code></td>
<td>
<p>Whether to create a plot of the values of the statistic at
all potential change points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>htest</code>-class object containing the results of the test
</p>


<h3>References</h3>

<p>Rice G, Miller C, Horváth L (????).
&ldquo;A new class of change point test of Rényi type.&rdquo;
in-press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.test(rnorm(1000))
HS.test(rnorm(1000), corr = FALSE)
</code></pre>

<hr>
<h2 id='pdarling_erdos'>Darling-Erdös Statistic CDF</h2><span id='topic+pdarling_erdos'></span>

<h3>Description</h3>

<p>CDF for the limiting distribution of the Darling-Erdös statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdarling_erdos(q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdarling_erdos_+3A_q">q</code></td>
<td>
<p>Quantile input to CDF</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code class="reqn">Z</code> is the random variable with this distribution, the
quantity <code class="reqn">P(Z \leq q)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::pdarling_erdos(0.1)
</code></pre>

<hr>
<h2 id='phidalgo_seo'>Hidalgo-Seo Statistic CDF</h2><span id='topic+phidalgo_seo'></span>

<h3>Description</h3>

<p>CDF of the limiting distribution of the Hidalgo-Seo statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phidalgo_seo(q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phidalgo_seo_+3A_q">q</code></td>
<td>
<p>Quantile input to CDF</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code class="reqn">Z</code> is the random variable following the limiting
distribution, the quantity <code class="reqn">P(Z \leq q)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::phidalgo_seo(0.1)
</code></pre>

<hr>
<h2 id='pkolmogorov'>Kolmogorov CDF</h2><span id='topic+pkolmogorov'></span>

<h3>Description</h3>

<p>CDF of the Kolmogorov distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkolmogorov(q, summands = ceiling(q * sqrt(72) + 3/2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkolmogorov_+3A_q">q</code></td>
<td>
<p>Quantile input to CDF</p>
</td></tr>
<tr><td><code id="pkolmogorov_+3A_summands">summands</code></td>
<td>
<p>Number of summands for infinite sum (the default should have
machine accuracy)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code class="reqn">Z</code> is the random variable following the Kolmogorov
distribution, the quantity <code class="reqn">P(Z \leq q)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::pkolmogorov(0.1)
</code></pre>

<hr>
<h2 id='pZn'>Rènyi-Type Statistic CDF</h2><span id='topic+pZn'></span>

<h3>Description</h3>

<p>CDF for the limiting distribution of the Rènyi-type statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pZn(q, summands = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pZn_+3A_q">q</code></td>
<td>
<p>Quantile input to CDF</p>
</td></tr>
<tr><td><code id="pZn_+3A_summands">summands</code></td>
<td>
<p>Number of summands for infinite sum; if <code>NULL</code>,
automatically determined</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code class="reqn">Z</code> is the random variable following the limiting
distribution, the quantity <code class="reqn">P(Z \leq q)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::pZn(0.1)
</code></pre>

<hr>
<h2 id='qdarling_erdos'>Darling-Erdös Statistic Limiting Distribution Quantile Function</h2><span id='topic+qdarling_erdos'></span>

<h3>Description</h3>

<p>Quantile function for the limiting distribution of the Darling-Erdös
statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdarling_erdos(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qdarling_erdos_+3A_p">p</code></td>
<td>
<p>The probability associated with the desired quantile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The quantile associated with <code>p</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::qdarling_erdos(0.5)
</code></pre>

<hr>
<h2 id='qhidalgo_seo'>Hidalgo-Seo Statistic Limiting Distribution Quantile Function</h2><span id='topic+qhidalgo_seo'></span>

<h3>Description</h3>

<p>Quantile function for the limiting distribution of the Hidalgo-Seo statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qhidalgo_seo(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qhidalgo_seo_+3A_p">p</code></td>
<td>
<p>The probability associated with the desired quantile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A The quantile associated with <code>p</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::qhidalgo_seo(0.5)
</code></pre>

<hr>
<h2 id='qkolmogorov'>Kolmogorov Distribution Quantile Function</h2><span id='topic+qkolmogorov'></span>

<h3>Description</h3>

<p>Quantile function for the Kolmogorov distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qkolmogorov(p, summands = 500, interval = c(0, 100),
  tol = .Machine$double.eps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qkolmogorov_+3A_p">p</code></td>
<td>
<p>Value of the CDF at the quantile</p>
</td></tr>
<tr><td><code id="qkolmogorov_+3A_summands">summands</code></td>
<td>
<p>Number of summands for infinite sum</p>
</td></tr>
<tr><td><code id="qkolmogorov_+3A_interval">interval</code>, <code id="qkolmogorov_+3A_tol">tol</code>, <code id="qkolmogorov_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to 
<code><a href="stats.html#topic+uniroot">uniroot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code><a href="stats.html#topic+uniroot">uniroot</a></code> for finding this quantity,
and many of the the accepted parameters are arguments for that function; see
its documentation for more details.
</p>


<h3>Value</h3>

<p>The quantile associated with <code>p</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::qkolmogorov(0.5)
</code></pre>

<hr>
<h2 id='qZn'>Rènyi-Type Statistic Quantile Function</h2><span id='topic+qZn'></span>

<h3>Description</h3>

<p>Quantile function for the limiting distribution of the Rènyi-type statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qZn(p, summands = 500, interval = c(0, 100),
  tol = .Machine$double.eps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qZn_+3A_p">p</code></td>
<td>
<p>Value of the CDF at the quantile</p>
</td></tr>
<tr><td><code id="qZn_+3A_summands">summands</code></td>
<td>
<p>Number of summands for infinite sum</p>
</td></tr>
<tr><td><code id="qZn_+3A_interval">interval</code>, <code id="qZn_+3A_tol">tol</code>, <code id="qZn_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to
<code><a href="stats.html#topic+uniroot">uniroot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code><a href="stats.html#topic+uniroot">uniroot</a></code> for finding this quantity,
and many of the the accepted parameters are arguments for that function; see
its documentation for more details.
</p>


<h3>Value</h3>

<p>The quantile associated with <code>p</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::qZn(0.5)
</code></pre>

<hr>
<h2 id='rchangepoint'>Simulate Univariate Data With a Single Change Point</h2><span id='topic+rchangepoint'></span>

<h3>Description</h3>

<p>This function simulates univariate data with a structural change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rchangepoint(n, changepoint = NULL, mean1 = 0, mean2 = 0,
  dist = rnorm, meanparam = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rchangepoint_+3A_n">n</code></td>
<td>
<p>An integer for the data set's sample size</p>
</td></tr>
<tr><td><code id="rchangepoint_+3A_changepoint">changepoint</code></td>
<td>
<p>An integer for where the change point occurs</p>
</td></tr>
<tr><td><code id="rchangepoint_+3A_mean1">mean1</code></td>
<td>
<p>The mean prior to the change point</p>
</td></tr>
<tr><td><code id="rchangepoint_+3A_mean2">mean2</code></td>
<td>
<p>The mean after the change point</p>
</td></tr>
<tr><td><code id="rchangepoint_+3A_dist">dist</code></td>
<td>
<p>The function with which random data will be generated</p>
</td></tr>
<tr><td><code id="rchangepoint_+3A_meanparam">meanparam</code></td>
<td>
<p>A string for the parameter in <code>dist</code> representing the
mean</p>
</td></tr>
<tr><td><code id="rchangepoint_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to dist</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates artificial change point data, where up to the
specified change point the data has one mean, and after the point it has a
different mean. By default, the function simulates standard Normal data with
no change. If <code>changepoint</code> is <code>NULL</code>, then by default the change
point will be at about the middle of the data.
</p>


<h3>Value</h3>

<p>A vector of the simulated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::rchangepoint(500)
CPAT:::rchangepoint(500, changepoint = 10, mean2 = 2, sd = 2)
CPAT:::rchangepoint(500, changepoint = 250, dist = rexp, meanparam = "rate",
                    mean1 = 1, mean2 = 2)
</code></pre>

<hr>
<h2 id='sim_de_stat'>Darling-Erdös Statistic Simulation</h2><span id='topic+sim_de_stat'></span>

<h3>Description</h3>

<p>Simulates multiple realizations of the Darling-Erdös statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_de_stat(size, a = log, b = log, use_kernel_var = FALSE,
  kernel = "ba", bandwidth = "and", n = 500, gen_func = rnorm,
  args = NULL, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_de_stat_+3A_size">size</code></td>
<td>
<p>Number of realizations to simulate</p>
</td></tr>
<tr><td><code id="sim_de_stat_+3A_a">a</code></td>
<td>
<p>The function that will be composed wit
<code class="reqn">l(x) = (2 \log(x))^{1/2}</code></p>
</td></tr>
<tr><td><code id="sim_de_stat_+3A_b">b</code></td>
<td>
<p>The function that will be composed with
<code class="reqn">u(x) = 2 \log(x) + \frac{1}{2} \log(\log(x)) -
\frac{1}{2}\log(pi)</code></p>
</td></tr>
<tr><td><code id="sim_de_stat_+3A_use_kernel_var">use_kernel_var</code></td>
<td>
<p>Set to <code>TRUE</code> to use kernel-based long-run
variance estimation (<code>FALSE</code> means this is not
employed)</p>
</td></tr>
<tr><td><code id="sim_de_stat_+3A_kernel">kernel</code></td>
<td>
<p>If character, the identifier of the kernel function as used in
the <span class="pkg">cointReg</span> (see documentation for
<code>cointReg::getLongRunVar</code>); if function, the kernel
function to be used for long-run variance estimation (default
is the Bartlett kernel in <span class="pkg">cointReg</span>); this parameter
has no effect if <code>use_kernel_var</code> is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="sim_de_stat_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If character, the identifier of how to compute the bandwidth
as defined in the <span class="pkg">cointReg</span> package (see
documentation for <code>cointReg::getLongRunVar</code>); if
function, a function to use for computing the bandwidth; if
numeric, the bandwidth to use (the default behavior is to
use the Andrews (1991) method, as
used in <span class="pkg">cointReg</span>); this parameter has no effect if
<code>use_kernel_var</code> is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="sim_de_stat_+3A_n">n</code></td>
<td>
<p>The sample size for each realization</p>
</td></tr>
<tr><td><code id="sim_de_stat_+3A_gen_func">gen_func</code></td>
<td>
<p>The function generating the random sample from which the
statistic is computed</p>
</td></tr>
<tr><td><code id="sim_de_stat_+3A_args">args</code></td>
<td>
<p>A list of arguments to be passed to <code>gen_func</code></p>
</td></tr>
<tr><td><code id="sim_de_stat_+3A_parallel">parallel</code></td>
<td>
<p>Whether to use the <span class="pkg">foreach</span> and <span class="pkg">doParallel</span>
packages to parallelize simulation (which needs to be
initialized in the global namespace before use)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>use_kernel_var</code> is set to <code>TRUE</code>, long-run variance estimation
using kernel-based techniques will be employed; otherwise, a technique
resembling standard variance estimation will be employed. Any technique
employed, though, will account for the potential break points, as described
in Rice et al. (). See the documentation for
<code><a href="#topic+stat_de">stat_de</a></code> for more details.
</p>
<p>The parameters <code>kernel</code> and <code>bandwidth</code> control parameters for
long-run variance estimation using kernel methods. These parameters will be
passed directly to <code><a href="#topic+stat_de">stat_de</a></code>.
</p>


<h3>Value</h3>

<p>A vector of simulated realizations of the Darling-Erdös statistic
</p>


<h3>References</h3>

<p>Andrews DWK (1991).
&ldquo;Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.&rdquo;
<em>Econometrica</em>, <b>59</b>(3), 817-858.
</p>
<p>Rice G, Miller C, Horváth L (????).
&ldquo;A new class of change point test of Rényi type.&rdquo;
in-press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::sim_de_stat(100)
CPAT:::sim_de_stat(100, use_kernel_var = TRUE,
                   gen_func = CPAT:::rchangepoint,
                   args = list(changepoint = 250, mean2 = 1))
</code></pre>

<hr>
<h2 id='sim_hs_stat'>Hidalgo-Seo Statistic Simulation</h2><span id='topic+sim_hs_stat'></span>

<h3>Description</h3>

<p>Simulates multiple realizations of the Hidalgo-Seo statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_hs_stat(size, corr = TRUE, gen_func = rnorm, args = NULL,
  n = 500, parallel = FALSE, use_kernel_var = FALSE, kernel = "ba",
  bandwidth = "and")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_hs_stat_+3A_size">size</code></td>
<td>
<p>Number of realizations to simulate</p>
</td></tr>
<tr><td><code id="sim_hs_stat_+3A_corr">corr</code></td>
<td>
<p>Whether long-run variance should be computed under the assumption
of correlated residuals</p>
</td></tr>
<tr><td><code id="sim_hs_stat_+3A_gen_func">gen_func</code></td>
<td>
<p>The function generating the random sample from which the
statistic is computed</p>
</td></tr>
<tr><td><code id="sim_hs_stat_+3A_args">args</code></td>
<td>
<p>A list of arguments to be passed to <code>gen_func</code></p>
</td></tr>
<tr><td><code id="sim_hs_stat_+3A_n">n</code></td>
<td>
<p>The sample size for each realization</p>
</td></tr>
<tr><td><code id="sim_hs_stat_+3A_parallel">parallel</code></td>
<td>
<p>Whether to use the <span class="pkg">foreach</span> and <span class="pkg">doParallel</span>
packages to parallelize simulation (which needs to be
initialized in the global namespace before use)</p>
</td></tr>
<tr><td><code id="sim_hs_stat_+3A_use_kernel_var">use_kernel_var</code></td>
<td>
<p>Set to <code>TRUE</code> to use kernel-based long-run
variance estimation (<code>FALSE</code> means this is not
employed); <em>TODO: NOT CURRENTLY IMPLEMENTED</em></p>
</td></tr>
<tr><td><code id="sim_hs_stat_+3A_kernel">kernel</code></td>
<td>
<p>If character, the identifier of the kernel function as used in
the <span class="pkg">cointReg</span> (see documentation for
<code>cointReg::getLongRunVar</code>); if function, the kernel
function to be used for long-run variance estimation (default
is the Bartlett kernel in <span class="pkg">cointReg</span>); this parameter
has no effect if <code>use_kernel_var</code> is <code>FALSE</code>;
<em>TODO: NOT CURRENTLY IMPLEMENTED</em></p>
</td></tr>
<tr><td><code id="sim_hs_stat_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If character, the identifier of how to compute the bandwidth
as defined in the <span class="pkg">cointReg</span> package (see
documentation for <code>cointReg::getLongRunVar</code>); if
function, a function to use for computing the bandwidth; if
numeric, the bandwidth to use (the default behavior is to
use the Andrews (1991) method, as
used in <span class="pkg">cointReg</span>); this parameter has no effect if
<code>use_kernel_var</code> is <code>FALSE</code>; <em>TODO: NOT
CURRENTLY IMPLEMENTED</em></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>corr</code> is <code>TRUE</code>, then the residuals of the data-generating
process are assumed to be correlated and the test accounts for this in
long-run variance estimation; see the documentation for <code><a href="#topic+stat_hs">stat_hs</a></code>
for more details. Otherwise, the sample variance is the estimate for the
long-run variance, as described in Hidalgo and Seo (2013).
</p>


<h3>Value</h3>

<p>A vector of simulated realizations of the Hidalgo-Seo statistic
</p>


<h3>References</h3>

<p>Andrews DWK (1991).
&ldquo;Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.&rdquo;
<em>Econometrica</em>, <b>59</b>(3), 817-858.
</p>
<p>Hidalgo J, Seo MH (2013).
&ldquo;Testing for structural stability in the whole sample.&rdquo;
<em>Journal of Econometrics</em>, <b>175</b>(2), 84 - 93.
ISSN 0304-4076, doi: <a href="http://doi.org/10.1016/j.jeconom.2013.02.008">10.1016/j.jeconom.2013.02.008</a>, <a href="http://www.sciencedirect.com/science/article/pii/S0304407613000626">http://www.sciencedirect.com/science/article/pii/S0304407613000626</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::sim_hs_stat(100)
CPAT:::sim_hs_stat(100, gen_func = CPAT:::rchangepoint, 
                   args = list(changepoint = 250, mean2 = 1))
</code></pre>

<hr>
<h2 id='sim_Vn'>CUSUM Statistic Simulation (Assuming Variance)</h2><span id='topic+sim_Vn'></span>

<h3>Description</h3>

<p>Simulates multiple realizations of the CUSUM statistic when the long-run
variance of the data is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_Vn(size, n = 500, gen_func = rnorm, sd = 1, args = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_Vn_+3A_size">size</code></td>
<td>
<p>Number of realizations to simulate</p>
</td></tr>
<tr><td><code id="sim_Vn_+3A_n">n</code></td>
<td>
<p>The sample size for each realization</p>
</td></tr>
<tr><td><code id="sim_Vn_+3A_gen_func">gen_func</code></td>
<td>
<p>The function generating the random sample from which the
statistic is computed</p>
</td></tr>
<tr><td><code id="sim_Vn_+3A_sd">sd</code></td>
<td>
<p>The square root of the second moment of the data</p>
</td></tr>
<tr><td><code id="sim_Vn_+3A_args">args</code></td>
<td>
<p>A list of arguments to be passed to <code>gen_func</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of simulated realizations of the CUSUM statistic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::sim_Vn(100)
CPAT:::sim_Vn(100, gen_func = CPAT:::rchangepoint,
              args = list(changepoint = 250, mean2 = 1))
</code></pre>

<hr>
<h2 id='sim_Vn_stat'>CUSUM Statistic Simulation</h2><span id='topic+sim_Vn_stat'></span>

<h3>Description</h3>

<p>Simulates multiple realizations of the CUSUM statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_Vn_stat(size, kn = function(n) {     1 }, tau = 0,
  use_kernel_var = FALSE, kernel = "ba", bandwidth = "and",
  n = 500, gen_func = rnorm, args = NULL, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_Vn_stat_+3A_size">size</code></td>
<td>
<p>Number of realizations to simulate</p>
</td></tr>
<tr><td><code id="sim_Vn_stat_+3A_kn">kn</code></td>
<td>
<p>A function returning a positive integer that is used in the
definition of the trimmed CUSUSM statistic effectively setting the
bounds over which the maximum is taken</p>
</td></tr>
<tr><td><code id="sim_Vn_stat_+3A_tau">tau</code></td>
<td>
<p>The weighting parameter for the weighted CUSUM statistic (defaults
to zero for no weighting)</p>
</td></tr>
<tr><td><code id="sim_Vn_stat_+3A_use_kernel_var">use_kernel_var</code></td>
<td>
<p>Set to <code>TRUE</code> to use kernel-based long-run
variance estimation (<code>FALSE</code> means this is not
employed)</p>
</td></tr>
<tr><td><code id="sim_Vn_stat_+3A_kernel">kernel</code></td>
<td>
<p>If character, the identifier of the kernel function as used in
the <span class="pkg">cointReg</span> (see documentation for
<code>cointReg::getLongRunVar</code>); if function, the kernel
function to be used for long-run variance estimation (default
is the Bartlett kernel in <span class="pkg">cointReg</span>); this parameter
has no effect if <code>use_kernel_var</code> is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="sim_Vn_stat_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If character, the identifier of how to compute the bandwidth
as defined in the <span class="pkg">cointReg</span> package (see
documentation for <code>cointReg::getLongRunVar</code>); if
function, a function to use for computing the bandwidth; if
numeric, the bandwidth to use (the default behavior is to
use the method described in (Andrews 1991),
as used in <span class="pkg">cointReg</span>); this parameter has no effect if
<code>use_kernel_var</code> is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="sim_Vn_stat_+3A_n">n</code></td>
<td>
<p>The sample size for each realization</p>
</td></tr>
<tr><td><code id="sim_Vn_stat_+3A_gen_func">gen_func</code></td>
<td>
<p>The function generating the random sample from which the
statistic is computed</p>
</td></tr>
<tr><td><code id="sim_Vn_stat_+3A_args">args</code></td>
<td>
<p>A list of arguments to be passed to <code>gen_func</code></p>
</td></tr>
<tr><td><code id="sim_Vn_stat_+3A_parallel">parallel</code></td>
<td>
<p>Whether to use the <span class="pkg">foreach</span> and <span class="pkg">doParallel</span>
packages to parallelize simulation (which needs to be
initialized in the global namespace before use)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This differs from <code>sim_Vn()</code> in that the long-run variance is estimated
with this function, while <code>sim_Vn()</code> assumes the long-run variance is
known. Estimation can be done in a variety of ways. If <code>use_kernel_var</code>
is set to <code>TRUE</code>, long-run variance estimation using kernel-based
techniques will be employed; otherwise, a technique resembling standard
variance estimation will be employed. Any technique employed, though, will
account for the potential break points, as described in
Rice et al. (). See the documentation for
<code><a href="#topic+stat_Vn">stat_Vn</a></code> for more details.
</p>
<p>The parameters <code>kernel</code> and <code>bandwidth</code> control parameters for
long-run variance estimation using kernel methods. These parameters will be
passed directly to <code><a href="#topic+stat_Vn">stat_Vn</a></code>.
</p>
<p>Versions of the CUSUM statistic, such as the weighted or trimmed statistics,
can be simulated with the function by passing values to <code>kn</code> and
<code>tau</code>; again, see the documentation for <code><a href="#topic+stat_Vn">stat_Vn</a></code>.
</p>


<h3>Value</h3>

<p>A vector of simulated realizations of the CUSUM statistic
</p>


<h3>References</h3>

<p>Andrews DWK (1991).
&ldquo;Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.&rdquo;
<em>Econometrica</em>, <b>59</b>(3), 817-858.
</p>
<p>Rice G, Miller C, Horváth L (????).
&ldquo;A new class of change point test of Rényi type.&rdquo;
in-press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::sim_Vn_stat(100)
CPAT:::sim_Vn_stat(100, kn = function(n) {floor(0.1 * n)}, tau = 1/3,
                   use_kernel_var = TRUE, gen_func = CPAT:::rchangepoint,
                   args = list(changepoint = 250, mean2 = 1))
</code></pre>

<hr>
<h2 id='sim_Zn'>Rènyi-Type Statistic Simulation (Assuming Variance)</h2><span id='topic+sim_Zn'></span>

<h3>Description</h3>

<p>Simulates multiple realizations of the Rènyi-type statistic when the long-run
variance of the data is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_Zn(size, kn, n = 500, gen_func = rnorm, args = NULL, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_Zn_+3A_size">size</code></td>
<td>
<p>Number of realizations to simulate</p>
</td></tr>
<tr><td><code id="sim_Zn_+3A_kn">kn</code></td>
<td>
<p>A function returning a positive integer that is used in the
definition of the Rènyi-type statistic effectively setting the
bounds over which the maximum is taken</p>
</td></tr>
<tr><td><code id="sim_Zn_+3A_n">n</code></td>
<td>
<p>The sample size for each realization</p>
</td></tr>
<tr><td><code id="sim_Zn_+3A_gen_func">gen_func</code></td>
<td>
<p>The function generating the random sample from which the
statistic is computed</p>
</td></tr>
<tr><td><code id="sim_Zn_+3A_args">args</code></td>
<td>
<p>A list of arguments to be passed to <code>gen_func</code></p>
</td></tr>
<tr><td><code id="sim_Zn_+3A_sd">sd</code></td>
<td>
<p>The square root of the second moment of the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of simulated realizations of the Rènyi-type statistic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::sim_Zn(100, kn = function(n) {floor(log(n))})
CPAT:::sim_Zn(100, kn = function(n) {floor(log(n))},
              gen_func = CPAT:::rchangepoint, args = list(changepoint = 250,
                                                          mean2 = 1))
</code></pre>

<hr>
<h2 id='sim_Zn_stat'>Rènyi-Type Statistic Simulation</h2><span id='topic+sim_Zn_stat'></span>

<h3>Description</h3>

<p>Simulates multiple realizations of the Rènyi-type statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_Zn_stat(size, kn = function(n) {     floor(sqrt(n)) },
  use_kernel_var = FALSE, kernel = "ba", bandwidth = "and",
  n = 500, gen_func = rnorm, args = NULL, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_Zn_stat_+3A_size">size</code></td>
<td>
<p>Number of realizations to simulate</p>
</td></tr>
<tr><td><code id="sim_Zn_stat_+3A_kn">kn</code></td>
<td>
<p>A function returning a positive integer that is used in the
definition of the Rènyi-type statistic effectively setting the
bounds over which the maximum is taken</p>
</td></tr>
<tr><td><code id="sim_Zn_stat_+3A_use_kernel_var">use_kernel_var</code></td>
<td>
<p>Set to <code>TRUE</code> to use kernel-based long-run
variance estimation (<code>FALSE</code> means this is not
employed)</p>
</td></tr>
<tr><td><code id="sim_Zn_stat_+3A_kernel">kernel</code></td>
<td>
<p>If character, the identifier of the kernel function as used in
the <span class="pkg">cointReg</span> (see documentation for
<code>cointReg::getLongRunVar</code>); if function, the kernel
function to be used for long-run variance estimation (default
is the Bartlett kernel in <span class="pkg">cointReg</span>); this parameter
has no effect if <code>use_kernel_var</code> is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="sim_Zn_stat_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If character, the identifier of how to compute the bandwidth
as defined in the <span class="pkg">cointReg</span> package (see
documentation for <code>cointReg::getLongRunVar</code>); if
function, a function to use for computing the bandwidth; if
numeric, the bandwidth to use (the default behavior is to
use the Andrews (1991) method, as
used in <span class="pkg">cointReg</span>); this parameter has no effect if
<code>use_kernel_var</code> is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="sim_Zn_stat_+3A_n">n</code></td>
<td>
<p>The sample size for each realization</p>
</td></tr>
<tr><td><code id="sim_Zn_stat_+3A_gen_func">gen_func</code></td>
<td>
<p>The function generating the random sample from which the
statistic is computed</p>
</td></tr>
<tr><td><code id="sim_Zn_stat_+3A_args">args</code></td>
<td>
<p>A list of arguments to be passed to <code>gen_func</code></p>
</td></tr>
<tr><td><code id="sim_Zn_stat_+3A_parallel">parallel</code></td>
<td>
<p>Whether to use the <span class="pkg">foreach</span> and <span class="pkg">doParallel</span>
packages to parallelize simulation (which needs to be
initialized in the global namespace before use)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This differs from <code>sim_Zn()</code> in that the long-run variance is estimated
with this function, while <code>sim_Zn()</code> assumes the long-run variance is
known. Estimation can be done in a variety of ways. If <code>use_kernel_var</code>
is set to <code>TRUE</code>, long-run variance estimation using kernel-based
techniques will be employed; otherwise, a technique resembling standard
variance estimation will be employed. Any technique employed, though, will
account for the potential break points, as described in
Rice et al. (). See the documentation for
<code><a href="#topic+stat_Zn">stat_Zn</a></code> for more details.
</p>
<p>The parameters <code>kernel</code> and <code>bandwidth</code> control parameters for
long-run variance estimation using kernel methods. These parameters will be
passed directly to <code><a href="#topic+stat_Zn">stat_Zn</a></code>.
</p>


<h3>Value</h3>

<p>A vector of simulated realizations of the Rènyi-type statistic
</p>


<h3>References</h3>

<p>Andrews DWK (1991).
&ldquo;Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.&rdquo;
<em>Econometrica</em>, <b>59</b>(3), 817-858.
</p>
<p>Rice G, Miller C, Horváth L (????).
&ldquo;A new class of change point test of Rényi type.&rdquo;
in-press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::sim_Zn_stat(100)
CPAT:::sim_Zn_stat(100, kn = function(n) {floor(log(n))},
            use_kernel_var = TRUE, gen_func = CPAT:::rchangepoint,
            args = list(changepoint = 250, mean2 = 1))
</code></pre>

<hr>
<h2 id='stat_de'>Compute the Darling-Erdös Statistic</h2><span id='topic+stat_de'></span>

<h3>Description</h3>

<p>This function computes the Darling-Erdös statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_de(dat, a = log, b = log, estimate = FALSE,
  use_kernel_var = FALSE, custom_var = NULL, kernel = "ba",
  bandwidth = "and", get_all_vals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_de_+3A_dat">dat</code></td>
<td>
<p>The data vector</p>
</td></tr>
<tr><td><code id="stat_de_+3A_a">a</code></td>
<td>
<p>The function that will be composed with
<code class="reqn">l(x) = (2 \log x)^{1/2}</code></p>
</td></tr>
<tr><td><code id="stat_de_+3A_b">b</code></td>
<td>
<p>The function that will be composed with
<code class="reqn">u(x) = 2 \log x + \frac{1}{2} \log \log x - \frac{1}{2} \log
\pi</code></p>
</td></tr>
<tr><td><code id="stat_de_+3A_estimate">estimate</code></td>
<td>
<p>Set to <code>TRUE</code> to return the estimated location of the
change point</p>
</td></tr>
<tr><td><code id="stat_de_+3A_use_kernel_var">use_kernel_var</code></td>
<td>
<p>Set to <code>TRUE</code> to use kernel methods for long-run
variance estimation (typically used when the data is
believed to be correlated); if <code>FALSE</code>, then the
long-run variance is estimated using
<code class="reqn">\hat{\sigma}^2_{T,t} = T^{-1}\left(
\sum_{s = 1}^t \left(X_s - \bar{X}_t\right)^2 +
\sum_{s = t + 1}^{T}\left(X_s -
\tilde{X}_{T - t}\right)^2\right)</code>, where
<code class="reqn">\bar{X}_t = t^{-1}\sum_{s = 1}^t X_s</code> and
<code class="reqn">\tilde{X}_{T - t} = (T - t)^{-1}
\sum_{s = t + 1}^{T} X_s</code></p>
</td></tr>
<tr><td><code id="stat_de_+3A_custom_var">custom_var</code></td>
<td>
<p>Can be a vector the same length as <code>dat</code> consisting of
variance-like numbers at each potential change point (so
each entry of the vector would be the &quot;best estimate&quot; of
the long-run variance if that location were where the
change point occured) or a function taking two parameters
<code>x</code> and <code>k</code> that can be used to generate this
vector, with <code>x</code> representing the data vector and
<code>k</code> the position of a potential change point; if
<code>NULL</code>, this argument is ignored</p>
</td></tr>
<tr><td><code id="stat_de_+3A_kernel">kernel</code></td>
<td>
<p>If character, the identifier of the kernel function as used in
<span class="pkg">cointReg</span> (see <code><a href="cointReg.html#topic+getLongRunVar">getLongRunVar</a></code>); if
function, the kernel function to be used for long-run variance
estimation (default is the Bartlett kernel in <span class="pkg">cointReg</span>)</p>
</td></tr>
<tr><td><code id="stat_de_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If character, the identifier for how to compute the
bandwidth as defined in <span class="pkg">cointReg</span> (see
<code><a href="cointReg.html#topic+getBandwidth">getBandwidth</a></code>); if function, a function
to use for computing the bandwidth; if numeric, the bandwidth
value to use (the default is to use Andrews' method, as used in
<span class="pkg">cointReg</span>)</p>
</td></tr>
<tr><td><code id="stat_de_+3A_get_all_vals">get_all_vals</code></td>
<td>
<p>If <code>TRUE</code>, return all values for the statistic at
every tested point in the data set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">\bar{A}_T(\tau, t_T)</code> is the weighted and trimmed CUSUM statistic
with weighting parameter <code class="reqn">\tau</code> and trimming parameter <code class="reqn">t_T</code> (see
<code><a href="#topic+stat_Vn">stat_Vn</a></code>), then the Darling-Erdös statistic is
</p>
<p style="text-align: center;"><code class="reqn">l(a_T) \bar{A}_T(1/2, 1) - u(b_T)</code>
</p>

<p>with <code class="reqn">l(x) = \sqrt{2 \log x}</code> and <code class="reqn">u(x) = 2 \log x + \frac{1}{2} \log
\log x - \frac{1}{2} \log \pi</code> (<code class="reqn">\log x</code> is the natural logarithm of
<code class="reqn">x</code>). The parameter <code>a</code> corresponds to <code class="reqn">a_T</code> and <code>b</code> to
<code class="reqn">b_T</code>; these are both <code>log</code> by default.
</p>
<p>See (Rice et al. ) to learn more.
</p>


<h3>Value</h3>

<p>If both <code>estimate</code> and <code>get_all_vals</code> are <code>FALSE</code>, the
value of the test statistic; otherwise, a list that contains the test
statistic and the other values requested (if both are <code>TRUE</code>,
the test statistic is in the first position and the estimated changg
point in the second)
</p>


<h3>References</h3>

<p>Rice G, Miller C, Horváth L (????).
&ldquo;A new class of change point test of Rényi type.&rdquo;
in-press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::stat_de(rnorm(1000))
CPAT:::stat_de(rnorm(1000), use_kernel_var = TRUE, bandwidth = "nw", kernel = "bo")
</code></pre>

<hr>
<h2 id='stat_hs'>Compute the Hidalgo-Seo Statistic</h2><span id='topic+stat_hs'></span>

<h3>Description</h3>

<p>This function computes the Hidalgo-Seo statistic for a change in mean model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_hs(dat, estimate = FALSE, corr = TRUE, get_all_vals = FALSE,
  custom_var = NULL, use_kernel_var = FALSE, kernel = "ba",
  bandwidth = "and")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_hs_+3A_dat">dat</code></td>
<td>
<p>The data vector</p>
</td></tr>
<tr><td><code id="stat_hs_+3A_estimate">estimate</code></td>
<td>
<p>Set to <code>TRUE</code> to return the estimated location of the
change point</p>
</td></tr>
<tr><td><code id="stat_hs_+3A_corr">corr</code></td>
<td>
<p>If <code>TRUE</code>, the long-run variance will be computed under the
assumption of correlated residuals; ignored if <code>custom_var</code>
is not <code>NULL</code> or <code>use_kernel_var</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="stat_hs_+3A_get_all_vals">get_all_vals</code></td>
<td>
<p>If <code>TRUE</code>, return all values for the statistic at
every tested point in the data set</p>
</td></tr>
<tr><td><code id="stat_hs_+3A_custom_var">custom_var</code></td>
<td>
<p>Can be a vector the same length as <code>dat</code> consisting of
variance-like numbers at each potential change point (so
each entry of the vector would be the &quot;best estimate&quot; of
the long-run variance if that location were where the
change point occured) or a function taking two parameters
<code>x</code> and <code>k</code> that can be used to generate this
vector, with <code>x</code> representing the data vector and
<code>k</code> the position of a potential change point; if
<code>NULL</code>, this argument is ignored</p>
</td></tr>
<tr><td><code id="stat_hs_+3A_use_kernel_var">use_kernel_var</code></td>
<td>
<p>Set to <code>TRUE</code> to use kernel methods for long-run
variance estimation (typically used when the data is
believed to be correlated); if <code>FALSE</code>, then the
long-run variance is estimated using
<code class="reqn">\hat{\sigma}^2_{T,t} = T^{-1}\left(
\sum_{s = 1}^t \left(X_s - \bar{X}_t\right)^2 +
\sum_{s = t + 1}^{T}\left(X_s -
\tilde{X}_{T - t}\right)^2\right)</code>, where
<code class="reqn">\bar{X}_t = t^{-1}\sum_{s = 1}^t X_s</code> and
<code class="reqn">\tilde{X}_{T - t} = (T - t)^{-1}
\sum_{s = t + 1}^{T} X_s</code>; if <code>custom_var</code> is not
<code>NULL</code>, this argument is ignored</p>
</td></tr>
<tr><td><code id="stat_hs_+3A_kernel">kernel</code></td>
<td>
<p>If character, the identifier of the kernel function as used in
<span class="pkg">cointReg</span> (see <code><a href="cointReg.html#topic+getLongRunVar">getLongRunVar</a></code>); if
function, the kernel function to be used for long-run variance
estimation (default is the Bartlett kernel in <span class="pkg">cointReg</span>)</p>
</td></tr>
<tr><td><code id="stat_hs_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If character, the identifier for how to compute the
bandwidth as defined in <span class="pkg">cointReg</span> (see
<code><a href="cointReg.html#topic+getBandwidth">getBandwidth</a></code>); if function, a function
to use for computing the bandwidth; if numeric, the bandwidth
value to use (the default is to use Andrews' method, as used in
<span class="pkg">cointReg</span>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a data set <code class="reqn">x_t</code> with <code class="reqn">n</code> observations, the test statistic is
</p>
<p style="text-align: center;"><code class="reqn">\max_{1 \leq s \leq n - 1} 	(\mathcal{LM}(s) - B_n)/A_n</code>
</p>

<p>where <code class="reqn">\hat{u}_t = x_t - \bar{x}</code> (<code class="reqn">\bar{x}</code> is the sample mean),
<code class="reqn">a_n = (2 \log \log n)^{1/2}</code>, <code class="reqn">b_n = a_n^2 - \frac{1}{2} \log \log
\log n - \log \Gamma (1/2)</code>, <code class="reqn">A_n = b_n / a_n^2</code>, <code class="reqn">B_n =
b_n^2/a_n^2</code>, <code class="reqn">\hat{\Delta} = \hat{\sigma}^2 = n^{-1} \sum_{t = 1}^{n}
\hat{u}_t^2</code>, and <code class="reqn">\mathcal{LM}(s) = n (n - s)^{-1} s^{-1}
\hat{\Delta}^{-1} \left( \sum_{t = 1}^{s} \hat{u}_t\right)^2</code>.
</p>
<p>If <code>corr</code> is <code>FALSE</code>, then the residuals are assumed to be
uncorrelated. Otherwise, the residuals are assumed to be correlated and
<code class="reqn">\hat{\Delta} = \hat{\gamma}(0) + 2 \sum_{j = 1}^{\lfloor \sqrt{n}
\rfloor} (1 - \frac{j}{\sqrt{n}}) \hat{\gamma}(j)</code> with <code class="reqn">\hat{\gamma}(j)
= \frac{1}{n}\sum_{t = 1}^{n - j} \hat{u}_t \hat{u}_{t + j}</code>.
</p>
<p>This statistic was presented in (Hidalgo and Seo 2013).
</p>


<h3>Value</h3>

<p>If both <code>estimate</code> and <code>get_all_vals</code> are <code>FALSE</code>, the
value of the test statistic; otherwise, a list that contains the test
statistic and the other values requested (if both are <code>TRUE</code>,
the test statistic is in the first position and the estimated change
point in the second)
</p>


<h3>References</h3>

<p>Hidalgo J, Seo MH (2013).
&ldquo;Testing for structural stability in the whole sample.&rdquo;
<em>Journal of Econometrics</em>, <b>175</b>(2), 84 - 93.
ISSN 0304-4076, doi: <a href="http://doi.org/10.1016/j.jeconom.2013.02.008">10.1016/j.jeconom.2013.02.008</a>, <a href="http://www.sciencedirect.com/science/article/pii/S0304407613000626">http://www.sciencedirect.com/science/article/pii/S0304407613000626</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::stat_hs(rnorm(1000))
CPAT:::stat_hs(rnorm(1000), corr = FALSE)
</code></pre>

<hr>
<h2 id='stat_Vn'>Compute the CUSUM Statistic</h2><span id='topic+stat_Vn'></span>

<h3>Description</h3>

<p>This function computes the CUSUM statistic (and can compute weighted/trimmed
variants, depending on the values of <code>kn</code> and <code>tau</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_Vn(dat, kn = function(n) {     1 }, tau = 0, estimate = FALSE,
  use_kernel_var = FALSE, custom_var = NULL, kernel = "ba",
  bandwidth = "and", get_all_vals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_Vn_+3A_dat">dat</code></td>
<td>
<p>The data vector</p>
</td></tr>
<tr><td><code id="stat_Vn_+3A_kn">kn</code></td>
<td>
<p>A function corresponding to the trimming parameter <code class="reqn">t_T</code> in the
trimmed CUSUM variant; by default, is a function returning 1 (for
no trimming)</p>
</td></tr>
<tr><td><code id="stat_Vn_+3A_tau">tau</code></td>
<td>
<p>The weighting parameter <code class="reqn">\tau</code> for the weighted CUSUM
statistic; by default, is 0 (for no weighting)</p>
</td></tr>
<tr><td><code id="stat_Vn_+3A_estimate">estimate</code></td>
<td>
<p>Set to <code>TRUE</code> to return the estimated location of the
change point</p>
</td></tr>
<tr><td><code id="stat_Vn_+3A_use_kernel_var">use_kernel_var</code></td>
<td>
<p>Set to <code>TRUE</code> to use kernel methods for long-run
variance estimation (typically used when the data is
believed to be correlated); if <code>FALSE</code>, then the
long-run variance is estimated using
<code class="reqn">\hat{\sigma}^2_{T,t} = T^{-1}\left(
\sum_{s = 1}^t \left(X_s - \bar{X}_t\right)^2 +
\sum_{s = t + 1}^{T}\left(X_s -
\tilde{X}_{T - t}\right)^2\right)</code>, where
<code class="reqn">\bar{X}_t = t^{-1}\sum_{s = 1}^t X_s</code> and
<code class="reqn">\tilde{X}_{T - t} = (T - t)^{-1}
\sum_{s = t + 1}^{T} X_s</code></p>
</td></tr>
<tr><td><code id="stat_Vn_+3A_custom_var">custom_var</code></td>
<td>
<p>Can be a vector the same length as <code>dat</code> consisting of
variance-like numbers at each potential change point (so
each entry of the vector would be the &quot;best estimate&quot; of
the long-run variance if that location were where the
change point occured) or a function taking two parameters
<code>x</code> and <code>k</code> that can be used to generate this
vector, with <code>x</code> representing the data vector and
<code>k</code> the position of a potential change point; if
<code>NULL</code>, this argument is ignored</p>
</td></tr>
<tr><td><code id="stat_Vn_+3A_kernel">kernel</code></td>
<td>
<p>If character, the identifier of the kernel function as used in
<span class="pkg">cointReg</span> (see <code><a href="cointReg.html#topic+getLongRunVar">getLongRunVar</a></code>); if
function, the kernel function to be used for long-run variance
estimation (default is the Bartlett kernel in <span class="pkg">cointReg</span>)</p>
</td></tr>
<tr><td><code id="stat_Vn_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If character, the identifier for how to compute the
bandwidth as defined in <span class="pkg">cointReg</span> (see
<code><a href="cointReg.html#topic+getBandwidth">getBandwidth</a></code>); if function, a function
to use for computing the bandwidth; if numeric, the bandwidth
value to use (the default is to use Andrews' method, as used in
<span class="pkg">cointReg</span>)</p>
</td></tr>
<tr><td><code id="stat_Vn_+3A_get_all_vals">get_all_vals</code></td>
<td>
<p>If <code>TRUE</code>, return all values for the statistic at
every tested point in the data set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definition of the statistic is
</p>
<p style="text-align: center;"><code class="reqn">T^{-1/2} \max_{1 \leq t \leq T} \hat{\sigma}_{t,T}^{-1} \left|
      \sum_{s = 1}^t X_s - \frac{t}{T}\sum_{s = 1}^T \right|</code>
</p>

<p>A more general version is
</p>
<p style="text-align: center;"><code class="reqn">T^{-1/2} \max_{t_T \leq t \leq T - t_T} \hat{\sigma}_{t,T}^{-1}
      \left(\frac{t}{T}
      \left(\frac{T - t}{T}\right)\right)^{\tau} \left| \sum_{s = 1}^t X_s -
      \frac{t}{T}\sum_{s = 1}^T \right|</code>
</p>

<p>The parameter <code>kn</code> corresponds to the trimming parameter <code class="reqn">t_T</code> and
the parameter <code>tau</code> corresponds to <code class="reqn">\tau</code>.
</p>
<p>See (Rice et al. ) for more details.
</p>


<h3>Value</h3>

<p>If both <code>estimate</code> and <code>get_all_vals</code> are <code>FALSE</code>, the
value of the test statistic; otherwise, a list that contains the test
statistic and the other values requested (if both are <code>TRUE</code>,
the test statistic is in the first position and the estimated change
point in the second)
</p>


<h3>References</h3>

<p>Rice G, Miller C, Horváth L (????).
&ldquo;A new class of change point test of Rényi type.&rdquo;
in-press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::stat_Vn(rnorm(1000))
CPAT:::stat_Vn(rnorm(1000), kn = function(n) {0.1 * n}, tau = 1/2)
CPAT:::stat_Vn(rnorm(1000), use_kernel_var = TRUE, bandwidth = "nw", kernel = "bo")
</code></pre>

<hr>
<h2 id='stat_Zn'>Compute the Rényi-Type Statistic</h2><span id='topic+stat_Zn'></span>

<h3>Description</h3>

<p>This function computes the Rényi-type statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_Zn(dat, kn = function(n) {     floor(sqrt(n)) }, estimate = FALSE,
  use_kernel_var = FALSE, custom_var = NULL, kernel = "ba",
  bandwidth = "and", get_all_vals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_Zn_+3A_dat">dat</code></td>
<td>
<p>The data vector</p>
</td></tr>
<tr><td><code id="stat_Zn_+3A_kn">kn</code></td>
<td>
<p>A function corresponding to the trimming parameter <code class="reqn">t_T</code>; by
default, the square root function</p>
</td></tr>
<tr><td><code id="stat_Zn_+3A_estimate">estimate</code></td>
<td>
<p>Set to <code>TRUE</code> to return the estimated location of the
change point</p>
</td></tr>
<tr><td><code id="stat_Zn_+3A_use_kernel_var">use_kernel_var</code></td>
<td>
<p>Set to <code>TRUE</code> to use kernel methods for long-run
variance estimation (typically used when the data is
believed to be correlated); if <code>FALSE</code>, then the
long-run variance is estimated using
<code class="reqn">\hat{\sigma}^2_{T,t} = T^{-1}\left(
\sum_{s = 1}^t \left(X_s - \bar{X}_t\right)^2 +
\sum_{s = t + 1}^{T}\left(X_s -
\tilde{X}_{T - t}\right)^2\right)</code>, where
<code class="reqn">\bar{X}_t = t^{-1}\sum_{s = 1}^t X_s</code> and
<code class="reqn">\tilde{X}_{T - t} = (T - t)^{-1}
\sum_{s = t + 1}^{T} X_s</code>; if <code>custom_var</code> is not
<code>NULL</code>, this argument is ignored</p>
</td></tr>
<tr><td><code id="stat_Zn_+3A_custom_var">custom_var</code></td>
<td>
<p>Can be a vector the same length as <code>dat</code> consisting of
variance-like numbers at each potential change point (so
each entry of the vector would be the &quot;best estimate&quot; of
the long-run variance if that location were where the
change point occured) or a function taking two parameters
<code>x</code> and <code>k</code> that can be used to generate this
vector, with <code>x</code> representing the data vector and
<code>k</code> the position of a potential change point; if
<code>NULL</code>, this argument is ignored</p>
</td></tr>
<tr><td><code id="stat_Zn_+3A_kernel">kernel</code></td>
<td>
<p>If character, the identifier of the kernel function as used in
<span class="pkg">cointReg</span> (see <code><a href="cointReg.html#topic+getLongRunVar">getLongRunVar</a></code>); if
function, the kernel function to be used for long-run variance
estimation (default is the Bartlett kernel in <span class="pkg">cointReg</span>)</p>
</td></tr>
<tr><td><code id="stat_Zn_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If character, the identifier for how to compute the
bandwidth as defined in <span class="pkg">cointReg</span> (see
<code><a href="cointReg.html#topic+getBandwidth">getBandwidth</a></code>); if function, a function
to use for computing the bandwidth; if numeric, the bandwidth
value to use (the default is to use Andrews' method, as used in
<span class="pkg">cointReg</span>)</p>
</td></tr>
<tr><td><code id="stat_Zn_+3A_get_all_vals">get_all_vals</code></td>
<td>
<p>If <code>TRUE</code>, return all values for the statistic at
every tested point in the data set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definition of the statistic is
</p>
<p style="text-align: center;"><code class="reqn">\max_{t_T \leq t \leq T - t_T} \hat{\sigma}_{t,T}^{-1}
      \left|t^{-1}\sum_{s = 1}^{t}X_s - (T - t)^{-1}\sum_{s = t + 1}^{T}
      X_s \right|</code>
</p>

<p>The parameter <code>kn</code> corresponds to the trimming parameter <code class="reqn">t_T</code>.
</p>


<h3>Value</h3>

<p>If both <code>estimate</code> and <code>get_all_vals</code> are <code>FALSE</code>, the
value of the test statistic; otherwise, a list that contains the test
statistic and the other values requested (if both are <code>TRUE</code>,
the test statistic is in the first position and the estimated change
point in the second)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPAT:::stat_Zn(rnorm(1000))
CPAT:::stat_Zn(rnorm(1000), kn = function(n) {floor(log(n))})
CPAT:::stat_Zn(rnorm(1000), use_kernel_var = TRUE, bandwidth = "nw",
               kernel = "bo")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
