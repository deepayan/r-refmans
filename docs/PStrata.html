<!DOCTYPE html><html><head><title>Help for package PStrata</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PStrata}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#make_stancode'><p><b>Stan</b> Code for <span class="pkg">PStrata</span> Models</p></a></li>
<li><a href='#make_standata'><p>Data for <span class="pkg">PStrata</span> Models</p></a></li>
<li><a href='#prior'><p>Prior functions</p></a></li>
<li><a href='#PSContrast'><p>Contrast of potential outcome for principal stratification analysis</p></a></li>
<li><a href='#PSFormula'><p>Set up a model formula for use in <span class="pkg">PStrata</span></p></a></li>
<li><a href='#PSObject'><p>Create a Principal Stratification Object</p></a></li>
<li><a href='#PSOutcome'><p>Estimated potential outcome for principal stratification analysis</p></a></li>
<li><a href='#PSSample'><p>Sample with <code>Stan</code></p></a></li>
<li><a href='#PStrata'><p>Principal Stratification Analysis for Data with Post-Randomization Intervention</p></a></li>
<li><a href='#PStrata-package'><p>PStrata: Principal STRATification Analysis for Data with Post-Randomization Confounding</p></a></li>
<li><a href='#PStrataInfo'><p>Create an object that defines the principal strata</p></a></li>
<li><a href='#sim_data_Cox'><p>Simulated Dataset for Survival Outcome (Cox Model)</p></a></li>
<li><a href='#sim_data_normal'><p>Simulated Dataset for Normal Outcome</p></a></li>
<li><a href='#survival'><p>The family function for survival data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Principal Stratification Analysis in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-02</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bo Liu &lt;bl226@duke.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimating causal effects in the presence of post-treatment confounding using principal stratification. 'PStrata' allows for customized monotonicity assumptions and exclusion restriction assumptions, with automatic full Bayesian inference supported by 'Stan'. The main function to use in this package is PStrata(), which provides posterior estimates of principal causal effect with uncertainty quantification. Visualization tools are also provided for diagnosis and interpretation. See Liu and Li (2023) &lt;<a href="https://arxiv.org/abs/2304.02740">arXiv:2304.02740</a>&gt; for details.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Collate:</td>
<td>PStrata-package.R PSFormula.R PStrataInfo.R survival.R prior.R
make_standata.R PSObject.R make_stancode.R PSSample.R PStrata.R
PSOutcome.R sim_data_normal.R sim_data_Cox.R PSContrast.R</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, rstan, lme4, abind, dplyr, purrr, stringr, stats</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-03 01:04:59 UTC; bo</td>
</tr>
<tr>
<td>Author:</td>
<td>Bo Liu [aut, cre],
  Fan Li [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-03 03:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='make_stancode'><b>Stan</b> Code for <span class="pkg">PStrata</span> Models</h2><span id='topic+make_stancode'></span>

<h3>Description</h3>

<p>Generate the <b>Stan</b> code corresponding to the model,
which is read by <b>Stan</b> to do sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_stancode(PSobject, filename = NULL, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_stancode_+3A_psobject">PSobject</code></td>
<td>
<p>an object of class <code>PSobject</code></p>
</td></tr>
<tr><td><code id="make_stancode_+3A_filename">filename</code></td>
<td>
<p>(optional) string. If not <code>NULL</code>, the stan file will be saved via
<code><a href="base.html#topic+cat">cat</a></code> in a text file named after the string supplied.</p>
</td></tr>
<tr><td><code id="make_stancode_+3A_debug">debug</code></td>
<td>
<p>only for testing in development mode. Will be removed in future release.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string, which can be printed on screen using <code><a href="base.html#topic+cat">cat</a></code>.
</p>

<hr>
<h2 id='make_standata'>Data for <span class="pkg">PStrata</span> Models</h2><span id='topic+make_standata'></span>

<h3>Description</h3>

<p>Generate data for <span class="pkg">PStrata</span> models to be passed to <b>Stan</b>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_standata(PSobject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_standata_+3A_psobject">PSobject</code></td>
<td>
<p>an object of class <code>PSObject</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of objects containing the required data to fit a
<span class="pkg">PStrata</span> model with <b>Stan</b>.
</p>

<hr>
<h2 id='prior'>Prior functions</h2><span id='topic+prior'></span><span id='topic+prior_flat'></span><span id='topic+prior_normal'></span><span id='topic+prior_t'></span><span id='topic+prior_cauchy'></span><span id='topic+prior_lasso'></span><span id='topic+prior_logistic'></span><span id='topic+prior_chisq'></span><span id='topic+prior_inv_chisq'></span><span id='topic+prior_exponential'></span><span id='topic+prior_gamma'></span><span id='topic+prior_inv_gamma'></span><span id='topic+prior_weibull'></span>

<h3>Description</h3>

<p>Define prior functions used in <code>PStrata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_flat()

prior_normal(mu = 0, sigma = 1)

prior_t(mu = 0, sigma = 1, df = 1)

prior_cauchy(mu = 0, sigma = 1)

prior_lasso(mu = 0, sigma = 1)

prior_logistic(mu = 0, sigma = 1)

prior_chisq(df = 1)

prior_inv_chisq(df = 1)

prior_exponential(beta = 1)

prior_gamma(alpha = 1, beta = 1)

prior_inv_gamma(alpha = 1, beta = 1)

prior_weibull(alpha = 1, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_+3A_mu">mu</code>, <code id="prior_+3A_sigma">sigma</code>, <code id="prior_+3A_df">df</code>, <code id="prior_+3A_alpha">alpha</code>, <code id="prior_+3A_beta">beta</code></td>
<td>
<p>parameters for the prior distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, including the following items.
</p>

<dl>
<dt>name</dt><dd><p>name of the distribution</p>
</dd>
<dt>type</dt><dd><p>type of the distribution, one character string of &quot;real&quot; or &quot;positive&quot;</p>
</dd>
<dt>args</dt><dd><p>a named list of all the input parameters</p>
</dd>
<dt>call</dt><dd><p>a function call object of the prior distribution on the parameters</p>
</dd>
</dl>


<hr>
<h2 id='PSContrast'>Contrast of potential outcome for principal stratification analysis</h2><span id='topic+PSContrast'></span>

<h3>Description</h3>

<p>Create an object that represents contrast of potential outcomes by treatment arms,
strata or time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSContrast(
  outcome,
  S = NULL,
  Z = NULL,
  T = NULL,
  type = c("all", "sequential", "cycle")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSContrast_+3A_outcome">outcome</code></td>
<td>
<p>an object of class <code>PSoutcome</code> or <code>PSContrast</code></p>
</td></tr>
<tr><td><code id="PSContrast_+3A_s">S</code></td>
<td>
<p>a vector denoting which strata to take contrasts. Default is <code>NULL</code> indicating
no contrasts are taken. Set to 'TRUE' to take contrasts between all strata.</p>
</td></tr>
<tr><td><code id="PSContrast_+3A_z">Z</code></td>
<td>
<p>a vector denoting which treatment arms to take contrasts. Default is <code>NULL</code> indicating
no contrasts are taken. Set to 'TRUE' to take contrasts between all treatment arms.</p>
</td></tr>
<tr><td><code id="PSContrast_+3A_t">T</code></td>
<td>
<p>a vector denoting which time points to take contrasts. Default is <code>NULL</code> indicating
no contrasts are taken. Set to 'TRUE' to take contrasts between all time points. This is used
only when 'object' is obtained under survival outcome.</p>
</td></tr>
<tr><td><code id="PSContrast_+3A_type">type</code></td>
<td>
<p>Either <code>"all"</code> (default), <code>"sequential"</code> or <code>"cycle"</code>.
If <code>"all"</code>, every pairwise contrasts are taken.
If <code>"sequential"</code>, contrasts are taken over every consecutive pairs.
If <code>"cycle"</code>, contrasts are taken over every consecutive pairs and also between the
first and the last levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>PSContrast</code> and <code>PSOutcome</code>, containing
</p>
<table>
<tr><td><code>outcome_array</code></td>
<td>
<p>A num_strata * num_treatment * num_iter array of contrast if the outcome type is non-survival
or a num_strata * num_treatment * num_time_points * num_iter array of contrast if the outcome type is survival.</p>
</td></tr>
<tr><td><code>is.survival</code></td>
<td>
<p>A boolean value, whether the outcome type is survival.</p>
</td></tr>
<tr><td><code>time_points</code></td>
<td>
<p>The time points at which the outcome is evaluated, if the outcome type is survival.</p>
</td></tr>
</table>
<p>The S3 method <code>summary</code> and <code>plot</code> can be applied to the returned object.
</p>

<hr>
<h2 id='PSFormula'>Set up a model formula for use in <span class="pkg">PStrata</span></h2><span id='topic+PSFormula'></span>

<h3>Description</h3>

<p>Set up a model formula for use in <span class="pkg">PStrata</span> package allowing users to specify
the treatment indicator, the post-randomization confounding variables, the outcome variable, and possibly the covariates.
For survival outcome, a censoring indicator is also specified.
Users can also define (potentially non-linear) transforms of the covariates and include random effects for clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSFormula(formula, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSFormula_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code> (or one that can be coerced to that class):
a symbolic description of the model to be fitted. The details of model specification are given in 'Details'.</p>
</td></tr>
<tr><td><code id="PSFormula_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two models are required for the principal stratification analysis: the principal stratum model and the outcome model.
</p>


<h4>General formula structure</h4>

<p>For the principal stratum model, the <code>formula</code> argument accepts formulas of the following syntax:
</p>
<p><code>treatment + postrand ~ terms</code>
</p>
<p>The <code>treatment</code> variable refers to the name of the binary treatment indicator.
The <code>postrand</code> variable refers to the name of the binary post-randomization confounding variable.
The <code>terms</code> part includes all of the predictors used for the principal stratum model.
</p>
<p>For the outcome model, the <code>formula</code> argument accepts formulas of the similar syntax:
</p>
<p><code>response [+ observed] ~ terms</code>
</p>
<p>The <code>response</code> variable refers to the name of the outcome variable.
The <code>terms</code> part includes all of the predictors used for the outcome model. 
The <code>observed</code> variable shall not be used for ordinary response.
When the true response is subject to right censoring (also called survival outcome in relevant literature),
the <code>response</code> variable should refer to the observed or censored response, and the <code>observed</code> variable should
be an indicator of whether the true response is observed. 
For example, suppose the true time for an event is <code class="reqn">T</code> and the time of censoring is <code class="reqn">C</code>,
Then, the <code>response</code> variable should refer to <code class="reqn">\min(T, C)</code>, the actual time of the event or censoring, whichever comes earlier,
and the indicator <code>observed</code> is 1 if <code class="reqn">T &lt; C</code> and 0 otherwise.
</p>
<p>The <code>terms</code> specified in the principal stratum model and the outcome model can be different.
</p>



<h4>Multiple post-randomization confounding variables</h4>

<p>If multiple post-randomization confounding variables exist, one can specify all of them using 
the following syntax:
</p>
<p><code>treatment + postrand_1 + postrand_2 + ... + postrand_n ~ terms</code>
</p>
<p>The post-randomization confounding variables are provided in place of <code>postrand_1</code> to
<code>postrand_n</code>. Up to this version, all of these variables should be binary indicators.
Note that the order of these post-randomization confounding variables will not
affect the result of the estimation of the parameters, but it will be important
in specifying other parameters, such as <code>strata</code> and <code>ER</code> (see <code><a href="#topic+PStrata">PStrata</a></code>).
</p>



<h4>Non-linear transformation of the predictors</h4>

<p>The syntax for the predictors follow the conventions as used in <code>link{formula}</code>.
The part <code>terms</code> consists of a series of terms concatenated by <code>+</code>, 
each term being the name of a variable, or the interaction of several variables separated by <code>:</code>.
</p>
<p>Apart from <code>+</code> and <code>:</code>, a number of other operators are also useful.
The <code>*</code> operator is a short-hand for factor crossing: 
<code>a*b</code> is interpreted as <code>a + b + a:b</code>.
The <code>^</code> operator means factor crossing to a specific degree. For example,
<code>(a + b + c)^2</code> is interpreted as <code>(a + b + c) * (a + b + c)</code>,
which is identical to <code>a + b + c + a:b + a:c + b:c</code>.
The <code>-</code> operator removes specified terms, so that <code>(a + b + c)^2 - a:b</code> is
identical to <code>a + b + c + a:c + b:c</code>.
The <code>-</code> operator can be also used to remove the intercept term, such as 
<code>x - 1</code>. One can also use <code>x + 0</code> to remove the intercept term.
</p>
<p>Arithmetic expressions such as <code>a + log(b)</code> are also legal.
However, arithmetic expressions may contain special symbols that are defined for other use, such as <code>+</code>, <code>*</code>, <code>^</code> and <code>-</code>.
To avoid confusion, the function <code><a href="base.html#topic+I">I</a>()</code> can be used to bracket portions where the operators should be interpreted in arithmetic sense.
For example, in <code>x + I(y + z)</code>, the term <code>y + z</code> is interpreted as the sum of <code>y</code> and <code>z</code>.
</p>



<h4>Group level random effect</h4>

<p>When effects assumed to vary across grouping variables are considered, one can 
specify such effects by adding terms in the form of <code>gterms | group</code>, where
<code>group</code> refers to the group indicator (usually a <code>factor</code>), and
<code>gterms</code> specifies the terms whose coefficients are group-specific, drawn 
from a population normal distribution. 
</p>
<p>The most common situation for group level random effect is to include group-specific
intercepts to account for unmeasured confounding. 
For example, <code>x + y + (1 | g)</code> specifies a model with population predictors
<code>x</code> and <code>y</code>, as well as random intercept for each level of <code>g</code>.
</p>
<p>For more complex random effect structures, refer to <code><a href="lme4.html#topic+lmer">lme4::lmer</a></code>.
However, structures other than simple random intercepts and slopes may lead to unexpected behaviors.
</p>



<h3>Value</h3>

<p><code>PSFormula</code> returns an object of class <code>PSFormula</code>, 
which is a <code>list</code> containing for following components.
</p>

<dl>
<dt><code>full_formula</code></dt><dd><p>input formula as is</p>
</dd>
<dt><code>data</code></dt><dd><p>input data frame</p>
</dd>
<dt><code>fixed_eff_formula</code></dt><dd><p>input formula with only fixed effects</p>
</dd>
<dt><code>response_names</code></dt><dd><p>character vector with names of variables that appear on the left hand side of input formula</p>
</dd>
<dt><code>has_random_effect</code></dt><dd><p>logical indicating whether random effects are specified in the input formula</p>
</dd>
<dt><code>has_intercept</code></dt><dd><p>logical indicating whether the input formula has an intercept</p>
</dd>
<dt><code>fixed_eff_names</code></dt><dd><p>character vector with names of all variables included as fixed effects</p>
</dd>
<dt><code>fixed_eff_count</code></dt><dd><p>integer indicating the number of variables (factors are converted to and counted as dummy variables)</p>
</dd>
<dt><code>fixed_eff_matrix</code></dt><dd><p>fixed-effect design matrix</p>
</dd>
<dt><code>random_eff_list</code></dt><dd><p>a list containing information for each random effect. 
Such information is a list with the corresponding design matrix, the term names and the factor levels.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="lme4.html#topic+lmer">lmer</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  X = 1:10, 
  Z = c(0,0,0,0,0,1,1,1,1,1),
  D = c(0,0,0,1,1,1,0,0,1,1),
  R = c(1,1,1,1,2,2,2,3,3,3)
 )
PSFormula(Z + D ~ X + I(X^2) + (1 | R), df)

</code></pre>

<hr>
<h2 id='PSObject'>Create a Principal Stratification Object</h2><span id='topic+PSObject'></span>

<h3>Description</h3>

<p>Create an object containing essential information to create the Stan file and 
data for Stan to draw posterior samples. Such information includes the specified
model for principal stratum and outcome, the type of outcome, assumptions,
and prior specification, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSObject(
  S.formula,
  Y.formula,
  Y.family,
  data = NULL,
  strata = NULL,
  ER = NULL,
  prior_intercept = prior_flat(),
  prior_coefficient = prior_normal(),
  prior_sigma = prior_inv_gamma(),
  prior_alpha = prior_inv_gamma(),
  prior_lambda = prior_inv_gamma(),
  prior_theta = prior_normal(),
  survival.time.points = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSObject_+3A_s.formula">S.formula</code>, <code id="PSObject_+3A_y.formula">Y.formula</code></td>
<td>
<p>an object of class &quot;<code><a href="#topic+PSFormula">PSFormula</a></code>&quot; (or an
object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; that can be coerced to
that class with <code>data</code> provided) specifying the model for principal
stratum and outcome respectively. See <code><a href="#topic+PSFormula">PSFormula</a></code> for details.</p>
</td></tr>
<tr><td><code id="PSObject_+3A_y.family">Y.family</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+family">family</a></code>&quot;: specifying the parametric
family of the model for the response and the link function. See the documentation
for <code><a href="stats.html#topic+glm">glm</a></code> for details on how such model fitting takes place.
Supported families and corresponding link functions are presented in 'Details' below.</p>
</td></tr>
<tr><td><code id="PSObject_+3A_data">data</code></td>
<td>
<p>(optional) a data frame object. This is required when either 
<code>S.formula</code> or <code>Y.formula</code> is a <code>formula</code> object, to coerce
it into a <code>PSFormula</code> object. When this happens, the data frame should 
contain all of the variables with names given in <code>S.formula</code> or <code>Y.formula</code>.</p>
</td></tr>
<tr><td><code id="PSObject_+3A_strata">strata</code>, <code id="PSObject_+3A_er">ER</code></td>
<td>
<p>arguments to define the principal strata. See <code><a href="#topic+PStrataInfo">PStrataInfo</a></code> for details.
</p>
<p>Alternatively, one can pass an object of class <code>PStrataInfo</code> to <code>strata</code>,
and <code>ER</code> will be ignored.</p>
</td></tr>
<tr><td><code id="PSObject_+3A_prior_intercept">prior_intercept</code>, <code id="PSObject_+3A_prior_coefficient">prior_coefficient</code>, <code id="PSObject_+3A_prior_sigma">prior_sigma</code>, <code id="PSObject_+3A_prior_alpha">prior_alpha</code>, <code id="PSObject_+3A_prior_lambda">prior_lambda</code>, <code id="PSObject_+3A_prior_theta">prior_theta</code></td>
<td>
<p>prior distribution for corresponding parameters in the model.</p>
</td></tr>
<tr><td><code id="PSObject_+3A_survival.time.points">survival.time.points</code></td>
<td>
<p>a vector of time points at which the estimated survival probability is evaluated 
(only used when the type of outcome is survival), or an integer specifying the number of time points to be
chosen. By default, the time points are chosen with equal distance from 0 to the 90% quantile of the observed
outcome.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The supported <code>family</code> objects include two types: native families for ordinary outcome and 
<code>survival</code> family for survival outcome.
</p>
<p>For ordinary outcome, the below families and links are supported. See <code><a href="stats.html#topic+family">family</a></code> for more details.
</p>

<table>
<tr>
 <td style="text-align: left;">
 <b>family</b> </td><td style="text-align: left;"> <b>link</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>binomial</code> </td><td style="text-align: left;"> <code>logit</code>, <code>probit</code>, <code>cauchit</code>, <code>log</code>, <code>cloglog</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>gaussian</code> </td><td style="text-align: left;"> <code>identity</code>, <code>log</code>, <code>inverse</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>Gamma</code> </td><td style="text-align: left;"> <code>inverse</code>, <code>identity</code>, <code>log</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>poisson</code> </td><td style="text-align: left;"> <code>log</code>, <code>identity</code>, <code>log</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>inverse.gamma</code> </td><td style="text-align: left;"> <code>1/mu^2</code>, <code>inverse</code>, <code>identity</code>, <code>log</code> 
</td>
</tr>

</table>

<p>The <code>quasi</code> family is not supported for the current version of the package.
</p>
<p>For survival outcome, the <code>family</code> object is created by 
<code>survival(method = "Cox", link = "identity")</code>, where <code>method</code> can be
either <code>"Cox"</code> for Weibull-Cox model or <code>"AFT"</code> for accelerated 
failure time model. See <code><a href="#topic+survival">survival</a></code> for more details. For the current
version, only <code>"identity"</code> is used as the link function.
</p>
<p>The <code>gaussian</code> family and the <code>survival</code> family with <code>method = "AFT"</code>
introduce an additional parameter <code>sigma</code> for the standard deviation, whose 
prior distribution is specified by <code>prior_sigma</code>. Similarly, <code>prior_alpha</code>
specifies the prior distribution of <code>alpha</code> for <code>Gamma</code> family, 
<code>prior_lambda</code> specifies the prior distribution of <code>theta</code> for <code>inverse.gaussian</code> family, 
and <code>prior_theta</code>
specifies the prior distribution of <code>theta</code> for <code>survival</code> family with <code>method = "Cox"</code>.
</p>
<p>The models for principal stratum <code>S.formula</code> and response <code>Y.formula</code>
also involve a linear combination of terms, where the prior distribution of
the intercept and coefficients are specified by <code>prior_intercept</code> and 
<code>prior_coefficient</code> respectively.
</p>


<h3>Value</h3>

<p>A list, containing important information describing the principal stratification model.
</p>
<table>
<tr><td><code>S.formula</code>, <code>Y.formula</code></td>
<td>
<p>A <code>PSFormula</code> object converted from the input <code>S.formula</code> and <code>Y.formula</code></p>
</td></tr>
<tr><td><code>Y.family</code></td>
<td>
<p>Same as input.</p>
</td></tr>
<tr><td><code>is.survival</code></td>
<td>
<p>A boolean value. <code>TRUE</code> if <code>Y.family</code> is <code>survival_Cox</code> or <code>survival_AFT</code>.</p>
</td></tr>
<tr><td><code>strata_info</code></td>
<td>
<p>A <code>PStrataInfo</code> object converted from the input <code>strata</code> and <code>ER</code>.</p>
</td></tr>
<tr><td><code>prior_intercept</code>, <code>prior_coefficient</code>, <code>prior_sigma</code>, <code>prior_alpha</code>, <code>prior_lambda</code>, <code>prior_theta</code></td>
<td>
<p>Same as input.</p>
</td></tr>
<tr><td><code>survival.time.points</code></td>
<td>
<p>A list of time points at which the estimated survival probability is evaluated.</p>
</td></tr>
<tr><td><code>SZDG_table</code></td>
<td>
<p>A matrix. Each row corresponds to a valid (stratum, treatment, confounder, group) combination.</p>
</td></tr>
<tr><td><code>Z_names</code></td>
<td>
<p>A character vector. The names of the levels of the treatment.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  Z = rbinom(10, 1, 0.5),
  D = rbinom(10, 1, 0.5),
  Y = rnorm(10),
  X = 1:10
)

PSObject(
  S.formula = Z + D ~ X,
  Y.formula = Y ~ X,
  Y.family = gaussian("identity"),
  data = df,
  strata = c(n = "00*", c = "01", a = "11*")
)

#------------------------------

PSObject(
  S.formula = Z + D ~ 1,
  Y.formula = Y ~ 1,
  Y.family = gaussian("identity"),
  data = sim_data_normal,
  strata = c(n = "00*", c = "01", a = "11*")
)

</code></pre>

<hr>
<h2 id='PSOutcome'>Estimated potential outcome for principal stratification analysis</h2><span id='topic+PSOutcome'></span>

<h3>Description</h3>

<p>Create an object useful to present the potential outcomes under each treatment arm
for each principal stratum. Contrasts between treatment arms or principal strata
are easy to obtain from this object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSOutcome(PStrataObj, type = c("probability", "RACE"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSOutcome_+3A_pstrataobj">PStrataObj</code></td>
<td>
<p>an object of class <code>PStrata</code> or <code>PStrata_survival</code></p>
</td></tr>
<tr><td><code id="PSOutcome_+3A_type">type</code></td>
<td>
<p>whether the causal estimand is survival probability or RACE, ignored for non-survival outcomes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of type <code>PSOutcome</code>, containing
</p>
<table>
<tr><td><code>outcome_array</code></td>
<td>
<p>A num_strata * num_treatment * num_iter array of mean outcome if the outcome type is non-survival
or a num_strata * num_treatment * num_time_points * num_iter array of mean outcome if the outcome type is survival.</p>
</td></tr>
<tr><td><code>is.survival</code></td>
<td>
<p>A boolean value, whether the outcome type is survival.</p>
</td></tr>
<tr><td><code>time_points</code></td>
<td>
<p>The time points at which the outcome is evaluated, if the outcome type is survival.</p>
</td></tr>
</table>
<p>The S3 method <code>summary</code> and <code>plot</code> can be applied to the returned object.
</p>

<hr>
<h2 id='PSSample'>Sample with <code>Stan</code></h2><span id='topic+PSSample'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution by calling <code><a href="rstan.html#topic+stan">stan</a></code>. 
Check <code><a href="rstan.html#topic+stan">stan</a></code> for details of the arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSSample(
  file,
  model_name = "anon_model",
  model_code = "",
  fit = NA,
  data = list(),
  pars = NA,
  chains = 4,
  iter = 2000,
  warmup = floor(iter/2),
  thin = 1,
  init = "random",
  seed = sample.int(.Machine$integer.max, 1),
  algorithm = c("NUTS", "HMC", "Fixed_param"),
  control = NULL,
  sample_file = NULL,
  diagnostic_file = NULL,
  save_dso = TRUE,
  verbose = FALSE,
  include = TRUE,
  cores = getOption("mc.cores", 1L),
  open_progress = interactive() &amp;&amp; !isatty(stdout()) &amp;&amp; !identical(Sys.getenv("RSTUDIO"),
    "1"),
  ...,
  boost_lib = NULL,
  eigen_lib = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSSample_+3A_file">file</code></td>
<td>

<p>The path to the Stan program to use.
<code>file</code> should be a character string file name or a connection that
<span class="rlang"><b>R</b></span> supports containing the text of a model specification in the Stan
modeling language.
</p>
<p>A model may also be specified directly as a character string using the
<code>model_code</code> argument, but we recommend always putting Stan programs
in separate files with a <code>.stan</code> extension.
</p>
<p>The <code>stan</code> function can also use the Stan program from an existing
<code>stanfit</code> object via the <code>fit</code> argument. When <code>fit</code> is
specified, the <code>file</code> argument is ignored.
</p>
</td></tr>
<tr><td><code id="PSSample_+3A_model_name">model_name</code></td>
<td>

<p>A string to use as the name of the model; defaults
to <code>"anon_model"</code>. However, the model name will be derived from
<code>file</code> or <code>model_code</code> (if <code>model_code</code> is the name
of a character string object) if <code>model_name</code> is not specified.
This is not a particularly important argument, although since it
affects the name used in printed messages, developers of other packages
that use <span class="pkg">rstan</span> to fit models may want to use informative names.
</p>
</td></tr>
<tr><td><code id="PSSample_+3A_model_code">model_code</code></td>
<td>

<p>A character string either containing the model definition or the name of
a character string object in the workspace. This argument is used only
if arguments <code>file</code> and <code>fit</code> are not specified.
</p>
</td></tr>
<tr><td><code id="PSSample_+3A_fit">fit</code></td>
<td>

<p>An instance of S4 class <code>stanfit</code> derived from a previous fit;
defaults to <code>NA</code>. If <code>fit</code> is not <code>NA</code>, the compiled model
associated with the fitted result is re-used; thus the time that would
otherwise be spent recompiling the C++ code for the model can be saved.
</p>
</td></tr>
<tr><td><code id="PSSample_+3A_data">data</code></td>
<td>
<p>A named <code>list</code> or <code>environment</code> providing the data for
the model, or a character vector for all the names of objects to use as data.
See the <strong>Passing data to Stan</strong> section below.</p>
</td></tr>
<tr><td><code id="PSSample_+3A_pars">pars</code></td>
<td>
<p>A character vector specifying parameters of interest to be saved.
The default is to save all parameters from the model.
If <code>include = TRUE</code>, only samples for parameters named in <code>pars</code>
are stored in the fitted results. Conversely, if <code>include = FALSE</code>,
samples for all parameters <em>except</em> those named in <code>pars</code> are
stored in the fitted results.</p>
</td></tr>
<tr><td><code id="PSSample_+3A_chains">chains</code></td>
<td>
<p>A positive integer specifying the number of Markov chains.
The default is 4.</p>
</td></tr>
<tr><td><code id="PSSample_+3A_iter">iter</code></td>
<td>
<p>A positive integer specifying the number of iterations for each
chain (including warmup). The default is 2000.</p>
</td></tr>
<tr><td><code id="PSSample_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying the number of warmup (aka burnin)
iterations per chain. If step-size adaptation is on (which it is by default),
this also controls the number of iterations for which adaptation is run (and
hence these warmup samples should not be used for inference). The number of
warmup iterations should be smaller than <code>iter</code> and the default is
<code>iter/2</code>.</p>
</td></tr>
<tr><td><code id="PSSample_+3A_thin">thin</code></td>
<td>
<p>A positive integer specifying the period for saving samples.
The default is 1, which is usually the recommended value. Unless your
posterior distribution takes up too much memory we do <em>not</em> recommend
thinning as it throws away information. The tradition of thinning when
running MCMC stems primarily from the use of samplers that require
a large number of iterations to achieve the desired effective sample size.
Because of the efficiency (effective samples per second) of
Hamiltonian Monte Carlo, rarely should this be necessary when using Stan.</p>
</td></tr>
<tr><td><code id="PSSample_+3A_init">init</code></td>
<td>

<p>Specification of initial values for all or some parameters.
Can be the digit <code>0</code>, the strings <code>"0"</code> or <code>"random"</code>,
a function that returns a named list, or a list of named lists:
</p>

<dl>
<dt><code>init="random"</code> (default):</dt><dd><p>Let Stan generate random initial values
for all parameters. The seed of the random number generator used by Stan
can be specified via the <code>seed</code> argument. If the seed for Stan is
fixed, the same initial values are used. The default is to randomly
generate initial values between <code>-2</code> and <code>2</code> <em>on the
unconstrained support</em>. The optional additional parameter <code>init_r</code> can
be set to some value other than <code>2</code> to change the range of the randomly
generated inits.</p>
</dd>
<dt><code>init="0", init=0</code>:</dt><dd><p>Initialize all parameters to zero on
the unconstrained support.</p>
</dd>
<dt>inits via list:</dt><dd><p>Set inital values by providing a list
equal in length to the number of chains. The elements of this list should
themselves be named lists, where each of these named lists has the name
of a parameter and is used to specify the initial values for that parameter
for the corresponding chain.</p>
</dd>
<dt>inits via function:</dt><dd><p>Set initial values by providing a function that
returns a list for specifying the initial values of parameters for a chain.
The function can take an optional parameter <code>chain_id</code> through which the
<code>chain_id</code> (if specified) or the integers from 1 to <code>chains</code> will be
supplied to the function for generating initial values.
See the <strong>Examples</strong> section below for examples of defining
such functions and using a list of lists for specifying initial values.</p>
</dd>
</dl>

<p>When specifying initial values via a <code>list</code> or <code>function</code>, any
parameters for which values are not specified will receive initial values
generated as described in the <code>init="random"</code> description above.
</p>
</td></tr>
<tr><td><code id="PSSample_+3A_seed">seed</code></td>
<td>
<p>The seed for random number generation. The default is generated
from 1 to the maximum integer supported by <span class="rlang"><b>R</b></span> on the machine. Even if
multiple chains are used, only one seed is needed, with other chains having
seeds derived from that of the first chain to avoid dependent samples.
When a seed is specified by a number, <code>as.integer</code> will be applied to it.
If <code>as.integer</code> produces <code>NA</code>, the seed is generated randomly.
The seed can also be specified as a character string of digits, such as
<code>"12345"</code>, which is converted to integer.
</p>
<p>Using <span class="rlang"><b>R</b></span>'s <code>set.seed</code> function to set the seed for Stan will not work.
</p>
</td></tr>
<tr><td><code id="PSSample_+3A_algorithm">algorithm</code></td>
<td>

<p>One of the sampling algorithms that are implemented in Stan.
The default and preferred algorithm is <code>"NUTS"</code>, which is
the No-U-Turn sampler variant of Hamiltonian Monte Carlo
(Hoffman and Gelman 2011, Betancourt 2017). Currently the other options
are <code>"HMC"</code> (Hamiltonian Monte Carlo), and <code>"Fixed_param"</code>.
When <code>"Fixed_param"</code> is used no MCMC sampling is performed
(e.g., for simulating with in the generated quantities block).
</p>
</td></tr>
<tr><td><code id="PSSample_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> of parameters to control the sampler's
behavior. It defaults to <code>NULL</code> so all the default values are used.
First, the following are adaptation parameters for sampling algorithms.
These are parameters used in Stan with similar names here.
</p>

<ul>
<li> <p><code>adapt_engaged</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>adapt_gamma</code> (<code>double</code>, positive, defaults to 0.05)
</p>
</li>
<li> <p><code>adapt_delta</code> (<code>double</code>, between 0 and 1, defaults to 0.8)
</p>
</li>
<li> <p><code>adapt_kappa</code> (<code>double</code>, positive, defaults to 0.75)
</p>
</li>
<li> <p><code>adapt_t0</code> (<code>double</code>, positive, defaults to 10)
</p>
</li>
<li> <p><code>adapt_init_buffer</code> (<code>integer</code>, positive, defaults to 75)
</p>
</li>
<li> <p><code>adapt_term_buffer</code> (<code>integer</code>, positive, defaults to 50)
</p>
</li>
<li> <p><code>adapt_window</code> (<code>integer</code>, positive, defaults to 25)
</p>
</li></ul>

<p>In addition, algorithm HMC (called 'static HMC' in Stan) and NUTS share the
following parameters:
</p>

<ul>
<li> <p><code>stepsize</code> (<code>double</code>, positive, defaults to 1)
Note: this controls the <em>initial</em> stepsize only, unless <code>adapt_engaged=FALSE</code>.
</p>
</li>
<li> <p><code>stepsize_jitter</code> (<code>double</code>, [0,1], defaults to 0)
</p>
</li>
<li> <p><code>metric</code> (<code>string</code>, one of &quot;unit_e&quot;, &quot;diag_e&quot;, &quot;dense_e&quot;,
defaults to &quot;diag_e&quot;)
</p>
</li></ul>

<p>For algorithm NUTS, we can also set:
</p>

<ul>
<li> <p><code>max_treedepth</code> (<code>integer</code>, positive, defaults to 10)
</p>
</li></ul>

<p>For algorithm HMC, we can also set:
</p>

<ul>
<li> <p><code>int_time</code> (<code>double</code>, positive)
</p>
</li></ul>

<p>For <code>test_grad</code> mode, the following parameters can be set:
</p>

<ul>
<li> <p><code>epsilon</code> (<code>double</code>, defaults to 1e-6)
</p>
</li>
<li> <p><code>error</code> (<code>double</code>, defaults to 1e-6)
</p>
</li></ul>

</td></tr>
<tr><td><code id="PSSample_+3A_sample_file">sample_file</code></td>
<td>
<p>An optional character string providing the name of a file.
If specified the draws for <em>all</em> parameters and other saved quantities
will be written to the file. If not provided, files are not created.
When the folder specified is not writable, <code>tempdir()</code> is used.
When there are multiple chains, an underscore and chain number are appended
to the file name.</p>
</td></tr>
<tr><td><code id="PSSample_+3A_diagnostic_file">diagnostic_file</code></td>
<td>
<p>An optional character string providing the name of a file.
If specified the diagnostics data for <em>all</em> parameters will be written
to the file. If not provided, files are not created. When the folder specified
is not writable, <code>tempdir()</code> is used. When there are multiple chains,
an underscore and chain number are appended to the file name.</p>
</td></tr>
<tr><td><code id="PSSample_+3A_save_dso">save_dso</code></td>
<td>
<p>Logical, with default <code>TRUE</code>, indicating whether the
dynamic shared object (DSO) compiled from the C++ code for the model
will be saved or not. If <code>TRUE</code>, we can draw samples from
the same model in another <span class="rlang"><b>R</b></span> session using the saved DSO (i.e.,
without compiling the C++ code again).
This parameter only takes effect if <code>fit</code> is not used; with
<code>fit</code> defined, the DSO from the previous run is used.
When <code>save_dso=TRUE</code>, the fitted object can be loaded from
what is saved previously and used for sampling, if the compiling is
done on the same platform, that is, same operating system and same
architecture (32bits or 64bits).</p>
</td></tr>
<tr><td><code id="PSSample_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>: flag indicating whether
to print intermediate output from Stan on the console, which might
be helpful for model debugging.</p>
</td></tr>
<tr><td><code id="PSSample_+3A_include">include</code></td>
<td>
<p>Logical scalar defaulting to <code>TRUE</code> indicating
whether to include or exclude the parameters given by the
<code>pars</code> argument. If <code>FALSE</code>, only entire multidimensional
parameters can be excluded, rather than particular elements of them.</p>
</td></tr>
<tr><td><code id="PSSample_+3A_cores">cores</code></td>
<td>

<p>The number of cores to use when executing the Markov chains in parallel.
The default is to use the value of the <code>"mc.cores"</code> option if it
has been set and otherwise to default to 1 core. However, we recommend
setting it to be as many processors as the hardware and RAM allow
(up to the number of chains). See <code><a href="parallel.html#topic+detectCores">detectCores</a></code>
if you don't know this number for your system.
</p>
</td></tr>
<tr><td><code id="PSSample_+3A_open_progress">open_progress</code></td>
<td>
<p>Logical scalar that only takes effect if
<code>cores &gt; 1</code> but is recommended to be <code>TRUE</code> in interactive
use so that the progress of the chains will be redirected to a file
that is automatically opened for inspection. For very short runs, the
user might prefer <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="PSSample_+3A_...">...</code></td>
<td>
<p>Other optional parameters:
</p>

<ul>
<li> <p><code>chain_id</code> (<code>integer</code>)
</p>
</li>
<li> <p><code>init_r</code> (<code>double</code>, positive)
</p>
</li>
<li> <p><code>test_grad</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>append_samples</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>refresh</code>(<code>integer</code>)
</p>
</li>
<li> <p><code>save_warmup</code>(<code>logical</code>)
</p>
</li>
<li><p> deprecated: <code>enable_random_init</code>(<code>logical</code>)
</p>
</li></ul>

<p><code>chain_id</code> can be a vector to specify the chain_id for all
chains or an integer. For the former case, they should be unique.
For the latter, the sequence of integers starting from the given
<code>chain_id</code> are used for all chains.
</p>
<p><code>init_r</code> is used only for generating random initial values,
specifically when <code>init="random"</code> or not all parameters
are initialized in the user-supplied list or function. If specified,
the initial values are simulated uniformly from interval
[-<code>init_r</code>, <code>init_r</code>] rather than using the default interval
(see the manual of (cmd)Stan).
</p>
<p><code>test_grad</code> (<code>logical</code>).
If <code>test_grad=TRUE</code>, Stan will not do any sampling. Instead,
the gradient calculation is tested and printed out and the fitted
<code>stanfit</code> object is in test gradient mode.  By default, it is
<code>FALSE</code>.
</p>
<p><code>append_samples</code> (<code>logical</code>).
Only relevant if <code>sample_file</code> is specified <em>and</em> is an
existing file. In that case, setting <code>append_samples=TRUE</code> will append
the samples to the existing file rather than overwriting the contents of
the file.
</p>
<p><code>refresh</code> (<code>integer</code>) can be used to
control how often the progress of the sampling is reported (i.e.
show the progress every <code>refresh</code> iterations).
By default, <code>refresh = max(iter/10, 1)</code>.
The progress indicator is turned off if <code>refresh &lt;= 0</code>.
</p>
<p>Deprecated: <code>enable_random_init</code> (<code>logical</code>) being <code>TRUE</code>
enables specifying initial values randomly when the initial
values are not fully specified from the user.
</p>
<p><code>save_warmup</code> (<code>logical</code>) indicates whether to
save draws during the warmup phase and defaults to <code>TRUE</code>. Some
memory related problems can be avoided by setting it to <code>FALSE</code>,
but some diagnostics are more limited if the warmup draws are not
stored.
</p>
</td></tr>
<tr><td><code id="PSSample_+3A_boost_lib">boost_lib</code></td>
<td>
<p>The path for an alternative version of the Boost C++
to use instead of the one in the <span class="pkg">BH</span> package.</p>
</td></tr>
<tr><td><code id="PSSample_+3A_eigen_lib">eigen_lib</code></td>
<td>
<p>The path for an alternative version of the Eigen C++
library to the one in <span class="pkg">RcppEigen</span>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class <code>rstan::stanfit</code>.
</p>

<hr>
<h2 id='PStrata'>Principal Stratification Analysis for Data with Post-Randomization Intervention</h2><span id='topic+PStrata'></span>

<h3>Description</h3>

<p>Perform pincipal stratification analysis when there are confounding variables
after randomization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PStrata(
  PSobject = NULL,
  S.formula,
  Y.formula,
  Y.family,
  data = NULL,
  strata = NULL,
  ER = NULL,
  prior_intercept = prior_flat(),
  prior_coefficient = prior_normal(),
  prior_sigma = prior_inv_gamma(),
  prior_alpha = prior_inv_gamma(),
  prior_lambda = prior_inv_gamma(),
  prior_theta = prior_normal(),
  survival.time.points = 50,
  filename = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PStrata_+3A_psobject">PSobject</code></td>
<td>
<p>an object of class <code><a href="#topic+PSObject">PSObject</a></code>. 
If left blank, the object is constructed using the following arguments.
See <code><a href="#topic+PSObject">PSObject</a></code> for details.</p>
</td></tr>
<tr><td><code id="PStrata_+3A_s.formula">S.formula</code>, <code id="PStrata_+3A_y.formula">Y.formula</code></td>
<td>
<p>an object of class &quot;<code><a href="#topic+PSFormula">PSFormula</a></code>&quot; (or an
object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; that can be coerced to
that class with <code>data</code> provided) specifying the model for principal
stratum and outcome respectively. See <code><a href="#topic+PSFormula">PSFormula</a></code> for details.</p>
</td></tr>
<tr><td><code id="PStrata_+3A_y.family">Y.family</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+family">family</a></code>&quot;: specifying the parametric
family of the model for the response and the link function. See the documentation
for <code><a href="stats.html#topic+glm">glm</a></code> for details on how such model fitting takes place.
Supported families and corresponding link functions are presented in 'Details' below.</p>
</td></tr>
<tr><td><code id="PStrata_+3A_data">data</code></td>
<td>
<p>(optional) a data frame object. This is required when either 
<code>S.formula</code> or <code>Y.formula</code> is a <code>formula</code> object, to coerce
it into a <code>PSFormula</code> object. When this happens, the data frame should 
contain all of the variables with names given in <code>S.formula</code> or <code>Y.formula</code>.</p>
</td></tr>
<tr><td><code id="PStrata_+3A_strata">strata</code>, <code id="PStrata_+3A_er">ER</code></td>
<td>
<p>arguments to define the principal strata. See <code><a href="#topic+PStrataInfo">PStrataInfo</a></code> for details.
</p>
<p>Alternatively, one can pass an object of class <code>PStrataInfo</code> to <code>strata</code>,
and <code>ER</code> will be ignored.</p>
</td></tr>
<tr><td><code id="PStrata_+3A_prior_intercept">prior_intercept</code>, <code id="PStrata_+3A_prior_coefficient">prior_coefficient</code>, <code id="PStrata_+3A_prior_sigma">prior_sigma</code>, <code id="PStrata_+3A_prior_alpha">prior_alpha</code>, <code id="PStrata_+3A_prior_lambda">prior_lambda</code>, <code id="PStrata_+3A_prior_theta">prior_theta</code></td>
<td>
<p>prior distribution for corresponding parameters in the model.</p>
</td></tr>
<tr><td><code id="PStrata_+3A_survival.time.points">survival.time.points</code></td>
<td>
<p>a vector of time points at which the estimated survival probability is evaluated 
(only used when the type of outcome is survival), or an integer specifying the number of time points to be
chosen. By default, the time points are chosen with equal distance from 0 to the 90% quantile of the observed
outcome.</p>
</td></tr>
<tr><td><code id="PStrata_+3A_filename">filename</code></td>
<td>
<p>(optional) string. If not <code>NULL</code>, the stan file will be saved via
<code><a href="base.html#topic+cat">cat</a></code> in a text file named after the string supplied.</p>
</td></tr>
<tr><td><code id="PStrata_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed into <code><a href="#topic+PSSample">PSSample</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PStrata</code> or <code>PStrata_survival</code>, 
which is a list containing 
</p>
<table>
<tr><td><code>PSobject</code></td>
<td>
<p>An object of <code>PSObject</code>.</p>
</td></tr>
<tr><td><code>post_samples</code></td>
<td>
<p>An object of class <code>rstan::stanfit</code> returned by <span class="pkg">Stan</span>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(abind)
PSobj &lt;- PSObject(
  S.formula = Z + D ~ 1,
  Y.formula = Y ~ 1,
  Y.family = gaussian("identity"),
  data = sim_data_normal,
  strata = c(n = "00*", c = "01", a = "11*")
)

PStrata(PSobj, cores = 2, chains = 2, iter = 200)

# Another example for survival data
PSobj &lt;- PSObject(
  S.formula = Z + D ~ 1,
  Y.formula = Y + delta ~ 1,
  Y.family = survival("Cox"),
  data = sim_data_Cox,
  strata = c(`never-taker` = "00*", complier = "01", `always-taker` = "11*")
)

PStrata(PSobj, cores = 2, chains = 2, iter = 200)

</code></pre>

<hr>
<h2 id='PStrata-package'>PStrata: Principal STRATification Analysis for Data with Post-Randomization Confounding</h2><span id='topic+PStrata-package'></span>

<h3>Description</h3>

<p>The <b>PStrata</b> package is designed for estimating causal effects in the presense of post-treatment confounding using principal stratification.
It provides an interface to fit the Bayesian principal stratification model, which is a complex mixture model, using <b>Stan</b>, a C++ package for obtaining full Bayesian inference.
The formula syntax is an extended version of the syntax applied in many regression functions and packages, such as <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code> and <span class="pkg"><a href="lme4.html#topic+lme4">lme4</a></span>, to provide a simple interface. 
A wide variety of distributions and link functions are supported, allowing users to fit linear, binary or count data, and survival models with principal stratification.
Further modeling options include multiple post-treatment confounding variables and cluster random effects.
The monotonicity and exclusion restriction assumptions can be easily applied, and
prior specifications are flexible and encourage users to reflect their prior belief.
In addition, all parameters can be inferred from the posterior distribution, which enables further analysis other than provided by the package.
A frequentist weighting-based triply-robust estimator is also implemented for both ordinary outcomes and survival outcomes.
</p>


<h3>Details</h3>

<p>The Bayesian principal stratification analysis relies on two models, the principal stratum model and the outcome model.
The main function of <span class="pkg">PStrata</span> is <code><a href="#topic+PStrata">PStrata</a></code>, which uses formula syntax to specify these models.
Based on the supplied formulas, data and additional information allowing users to specify assumptions and prior distributions,
it automatically generates the Stan code via <code><a href="#topic+make_stancode">make_stancode</a></code> and <code><a href="#topic+make_standata">make_standata</a></code>, and fits the model using <span class="pkg">Stan</span>.
</p>
<p>The estimated probability for each principal stratum and the estimated mean response are calculated with <span class="pkg">Stan</span> as it is faster and more space-efficient. 
However, a large number of post-processing methods can also be applied.
<code><a href="#topic+PStrata">summary</a></code> is perfectly suited for an overview of the estimated parameters, 
and <code><a href="#topic+PStrata">plot</a></code> provides visualization of the principal stratification and the outcome distribution.
</p>
<p>Because <span class="pkg">PStrata</span> heavily relies on <span class="pkg">Stan</span> for posterior sampling, a C++ compiler is required.
The program <span class="pkg">Rtools</span> (available on <a href="https://cran.r-project.org/bin/windows/Rtools/">https://cran.r-project.org/bin/windows/Rtools/</a>) comes with a C++ compiler for Windows.
On Mac, Xcode is suggested. For further instructions on how to get the compilers running, please refer to the prerequisites section at the <a href="https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started">RStan-Getting-Started</a> page.
</p>


<h3>References</h3>

<p>The Stan Development Team. Stan Modeling Language User's Guide and Reference Manual. <a href="https://mc-stan.org/users/documentation/">https://mc-stan.org/users/documentation/</a>
</p>
<p>Stan Development Team (2020). RStan: the R interface to Stan. R package version 2.21.2. <a href="https://mc-stan.org/">https://mc-stan.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PStrata">PStrata</a></code>
</p>

<hr>
<h2 id='PStrataInfo'>Create an object that defines the principal strata</h2><span id='topic+PStrataInfo'></span>

<h3>Description</h3>

<p><code>PStrataInfo</code> is a class of object that defines all principal strata
to be considered, by specifying the potential value of each post-randomization
confounding variable under each treatment arm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PStrataInfo(strata, ER = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PStrataInfo_+3A_strata">strata</code></td>
<td>
<p>a list or a vector defining all principal strata. Details of
the syntax are given in 'Details' below.</p>
</td></tr>
<tr><td><code id="PStrataInfo_+3A_er">ER</code></td>
<td>
<p>a vector indicating on which strata exclusion restriction is assumed. Details are
given in 'Details' below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since definition of the principal strata appears fundamental and essential in 
principal stratification analyses, the creation of such an object is designed
to be user-friendly - various ways are accommodated to create a <code>PStrataInfo</code>
object, some possibly preferable over others under different settings.
</p>
<p>There are mainly two ways to easily create a <code>PStrataInfo</code> object.
</p>


<h4>By string</h4>

<p>To define the principal strata by strings, the <code>strata</code> argument
should receive a named vector, each component being the description of one strata
with the name of that strata. The naming does not affect the actual inference,
but informative names can be helpful for users to distinguish among strata.
</p>
<p>Each stratum is defined by the potential values of the post-randomization confounding
variable <code class="reqn">D</code> under each treatment arm. By convention, assume that the K treatment arms are
numbered from 0 to K-1. Then, each stratum is defined by the tuple <code class="reqn">(D(0), \ldots, D(K-1))</code>,
which can be written compactly as a string. For example, under binary treatment,
the never-takers (i.e. <code class="reqn">D(0) = D(1) = 0</code>) can be represented by string <code>"00"</code> and 
the compliers (i.e. <code class="reqn">D(0) = 0, D(1) = 1</code>) can be represented by string <code>"01"</code>.
Note that the value that the post-randomization confounding variable can take is limited between 0 to 9
for the string to be parsed correctly. This should be more than enough in most of the applications, and
in cases where a number above 10 is needed, please create the <code>PStrataInfo</code> object by matrix (see below).
</p>
<p>When multiple post-randomization confounding variables exist, the string for each confounding variable
is concatenated with the symbol &quot;<code>|</code>&quot;. For example, if <code class="reqn">D_0</code> and <code class="reqn">D_1</code> are both binary 
post-randomization confounding variables, the stratum defined by <code class="reqn">D_0(0) = D_0(1) = 0, D_1(0) = 0, D_1(1) = 1</code>
can be represented by string <code>"00|11"</code>. The order of these confounding variables should be the same
as they appear in the <code>S.formula</code> parameter in <code><a href="#topic+PSObject">PSObject</a></code>.
</p>
<p>A common assumption in practice is the exclusion restriction (ER) assumption, which assumes that 
the causal effect of the treatment on the outcome is totally realized through the post-randomization 
confounding variables. For example, the ER assumption on the stratum of never-takers can be interpreted
as the outcome is identically distributed across the treated and control group, because all causal effect
of the treatment is realized through the post-randomization variable, which is the same (0) under both 
treatment arms. To assume ER for some stratum, simply put an asterisk &quot;<code>*</code>&quot; at the end of the string,
such as &quot;00*&quot; for the never-taker stratum. <em>Note that under the context of multiple post-randomization
variables, the package treats all such variables as a unity. The outcome is assumed to be identical under
different treatment arms only when all post-randomization variables remain the same under these treatment arms.</em>
</p>
<p>Another way to specify the stratum where ER is assumed is to use the <code>ER</code> argument. It either takes
a logical vector of the same length of <code>strata</code> with <code>TRUE</code> indicating ER is assumed and <code>FALSE</code>
otherwise, or takes a character vector with the names of all strata where ER is to be assumed upon.
When names to the strata are not provided in <code>strata</code>, the strata can be referred to by their 
canonical name, which is the string used to define the stratum with asterisks removed. For example, 
the strata <code>"00|11*"</code> can be referred to with name &quot;00|11&quot;.
</p>



<h4>By matrix</h4>

<p>To define the principal strata by matrices, the <code>strata</code> argument
should receive a named list, each component being a matrix. The number of rows matches the number
of post-randomization variables, and the number of columns matches that of possible treatment arms.
For any fixed row <code class="reqn">i</code>, column <code class="reqn">j</code> stores the potential value of the <code class="reqn">i</code>-th post-randomization
variable under treatment arm <code class="reqn">j</code>.
</p>
<p>When this approach is used, there is no shorthand to specify ER assumption. The <code>ER</code> argument is 
required to do this.
</p>

<p><b>Warning:</b> When ER assumption is specified in both <code>strata</code> and <code>ER</code> argument, the shorthand
notation for ER in <code>strata</code> is ignored, and a warning is given regardless of whether the specification
given by <code>strata</code> and <code>ER</code> actually match.
</p>


<h3>Value</h3>

<p>an object of class <code>PSStrataInfo</code>, which is a list of the following components.
</p>

<dl>
<dt>num_strata</dt><dd><p>number of principal strata defined</p>
</dd>
<dt>num_treatment</dt><dd><p>number of treatment arms</p>
</dd>
<dt>num_postrand_var</dt><dd><p>number of post-randomization variables</p>
</dd>
<dt>max_postrand_level</dt><dd><p>integer vector, the biggest number used by each post-randomization variable</p>
</dd>
<dt>strata_matrix</dt><dd><p>integer matrix, each row corresponding to one stratum and
each column corresponding to one treatment arm.
The matrix is designed only for internal use.
</p>
</dd>
<dt>ER_list</dt><dd><p>logical vector, each component corresponding to one stratum, indicating whether 
ER is assumed for the specific stratum</p>
</dd>
<dt>strata_names</dt><dd><p>character vector, the names of all strata</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>PStrataInfo(strata = c(n = "00*", c = "01", a = "11"))
PStrataInfo(
  strata = list(n = c(0, 0), c = c(0, 1), a = c(1, 1)), 
  ER = c(TRUE, FALSE, FALSE)
)
PStrataInfo(
  strata = list(n = c(0, 0), c = c(0, 1), a = c(1, 1)), 
  ER = c("n")
)

</code></pre>

<hr>
<h2 id='sim_data_Cox'>Simulated Dataset for Survival Outcome (Cox Model)</h2><span id='topic+sim_data_Cox'></span>

<h3>Description</h3>

<p>A dataset generated for illustration of the principal stratification analysis.
This dataset represents the common case of non-compliance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_data_Cox
</code></pre>


<h3>Format</h3>

<p>## 'sim_data_Cox'
A data frame with 1,000 rows and 7 columns:
</p>

<dl>
<dt>S</dt><dd><p>Principal Strata: &quot;never taker&quot;, &quot;complier&quot; or &quot;always taker&quot;</p>
</dd>
<dt>Z</dt><dd><p>Randomized treatment arm: 0 = control, 1 = treatment</p>
</dd>
<dt>D</dt><dd><p>Actual treatment arm: 0 = control, 1 = treatment</p>
</dd>
<dt>T</dt><dd><p>True outcome: event time</p>
</dd>
<dt>C</dt><dd><p>Censor time</p>
</dd>
<dt>delta</dt><dd><p>Event indicator. 1 means true outcome is observed; 0 means otherwise</p>
</dd>
<dt>Y</dt><dd><p>The observed event time or censor time</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset represents the scenario where actual treatment might not be in compliance
with the randomized (assigned) treatment. Defiers and always-takers are ruled out, leaving two
strata, &quot;never-taker&quot; and &quot;complier&quot; randomly sampled with 
probability 0.3, 0.7 respectively. The assigned treatment <code class="reqn">Z</code> is randomized
with 0.5 probability for either arm. The true event time <code class="reqn">T</code> is given by the following 
Weibull-Cox distribution
</p>

<dl>
<dt>never-taker</dt><dd><p><code class="reqn">Y \sim Weibull-Cox(theta = 1, mu = 0.3)</code></p>
</dd>
<dt>complier</dt><dd><p><code class="reqn">Y \sim Weibull-Cox(theta = 1, mu = 2 - 0.6*Z)</code></p>
</dd>
</dl>
<p> and the censor time <code class="reqn">C</code> is uniformly drawn between 0.5 and 2.
</p>
<p>The exclusion restriction assumption holds for never-takers in this
generated dataset.
</p>

<hr>
<h2 id='sim_data_normal'>Simulated Dataset for Normal Outcome</h2><span id='topic+sim_data_normal'></span>

<h3>Description</h3>

<p>A dataset generated for illustration of the principal stratification analysis.
This dataset represents the common case of non-compliance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_data_normal
</code></pre>


<h3>Format</h3>

<p>## 'sim_data_normal'
A data frame with 1,000 rows and 4 columns:
</p>

<dl>
<dt>S</dt><dd><p>Principal Strata: &quot;never taker&quot;, &quot;complier&quot; or &quot;always taker&quot;</p>
</dd>
<dt>Z</dt><dd><p>Randomized treatment arm: 0 = control, 1 = treatment</p>
</dd>
<dt>D</dt><dd><p>Actual treatment arm: 0 = control, 1 = treatment</p>
</dd>
<dt>Y</dt><dd><p>Outcome</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset represents the scenario where actual treatment might not be in compliance
with the randomized (assigned) treatment. Defiers are ruled out, leaving three
strata, &quot;never taker&quot;, &quot;complier&quot; and &quot;always taker&quot; randomly sampled with 
probability 0.3, 0.2 and 0.5 respectively. The assigned treatment <code class="reqn">Z</code> is randomized
with 0.5 probability for either arm. The outcome <code class="reqn">Y</code> is given by the following.
</p>

<dl>
<dt>never taker</dt><dd><p><code class="reqn">Y \sim N(3, 1)</code></p>
</dd>
<dt>complier</dt><dd><p><code class="reqn">Y \sim N(-1-Z, 0.5)</code></p>
</dd>
<dt>always taker</dt><dd><p><code class="reqn">Y \sim N(1, 2)</code></p>
</dd>
</dl>

<p>The exclusion restriction assumption holds for never takers and always takers in this
generated dataset.
</p>

<hr>
<h2 id='survival'>The family function for survival data</h2><span id='topic+survival'></span>

<h3>Description</h3>

<p>Construct a family object for survival data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survival(method = "Cox", link = "identity")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survival_+3A_method">method</code></td>
<td>
<p>the parametric method used for survival data. Can be Cox or AFT.</p>
</td></tr>
<tr><td><code id="survival_+3A_link">link</code></td>
<td>
<p>a link function, currently only identity is implemented and used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>family</code> object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
