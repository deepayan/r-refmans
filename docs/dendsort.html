<!DOCTYPE html><html><head><title>Help for package dendsort</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dendsort}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dendsort-package'><p>Modular Leaf Ordering Methods for Dendrogram Nodes</p></a></li>
<li><a href='#cal_length'><p>Recursive function to calculate the length of branches</p></a></li>
<li><a href='#cal_node_limit'><p>Calculate the x coordinates given a branch of dendrogram</p></a></li>
<li><a href='#cal_total_length'><p>Calculate the total length of lines to draw the dendrogram</p></a></li>
<li><a href='#dendsort'><p>Sorting and reordering dendrogram nodes</p></a></li>
<li><a href='#sample_tcga'><p>Sample data matrix from the integrated pathway analysis of gastric cancer from the Cancer Genome Atlas (TCGA) study</p></a></li>
<li><a href='#sort_average'><p>Sorting and reordering dendrogram nodes by average distances</p></a></li>
<li><a href='#sort_average_r'><p>Sorting and reordering dendrogram nodes by average distances in reverse</p></a></li>
<li><a href='#sort_smallest'><p>Sorting and reordering dendrogram nodes by the smallest value</p></a></li>
<li><a href='#sort_smallest_r'><p>Sorting and reordering dendrogram nodes by the smallest value in reverse</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Modular Leaf Ordering Methods for Dendrogram Nodes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of functions to optimize ordering of nodes in a dendrogram, without affecting the meaning of the dendrogram. A dendrogram can be sorted based on the average distance of subtrees, or based on the smallest distance value. These sorting methods improve readability and interpretability of tree structure, especially for tasks such as comparison of different distance measures or linkage types and identification of tight clusters and outliers. As a result, it also introduces more meaningful reordering for a coupled heatmap visualization. This method is described in "dendsort: modular leaf ordering methods for dendrogram representations in R", F1000Research 2014, 3: 177 &lt;<a href="https://doi.org/10.12688%2Ff1000research.4784.1">doi:10.12688/f1000research.4784.1</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, RColorBrewer, gplots, seriation, gapmap, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/evanbiederstedt/dendsort">https://github.com/evanbiederstedt/dendsort</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/evanbiederstedt/dendsort/issues">https://github.com/evanbiederstedt/dendsort/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evan Biederstedt &lt;evan.biederstedt@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-19 19:12:09 UTC; evanbiederstedt</td>
</tr>
<tr>
<td>Author:</td>
<td>Ryo Sakai [aut],
  Evan Biederstedt [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-20 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dendsort-package'>Modular Leaf Ordering Methods for Dendrogram Nodes</h2><span id='topic+dendsort-package'></span>

<h3>Description</h3>

<p>Modular Leaf Ordering Methods for Dendrogram Nodes
</p>


<h3>Details</h3>

<p>This package includes functions to optimize ordering of nodes in a dendrogram, without affecting the meaning of the dendrogram. 
A dendrogram can be sorted based on the average distance of subtrees, or based on the smallest distance value. These sorting 
methods improve readability and interpretability of tree structure, especially for tasks such as comparison of different 
distance measures or linkage types and identification of tight clusters and outliers. As a result, it also introduces more 
meaningful reordering for a coupled heatmap visualization.
</p>


<h3>Author(s)</h3>

<p>Ryo Sakai <a href="mailto:ryo.sakai@esat.kuleuven.be">ryo.sakai@esat.kuleuven.be</a>
</p>

<hr>
<h2 id='cal_length'>Recursive function to calculate the length of branches</h2><span id='topic+cal_length'></span>

<h3>Description</h3>

<p><code>cal_length</code> is a code modified from plotNode()
to calculate the length of lines to draw the branch of a dendrogram. This
function was developed to evaluate the use of ink for visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_length(x1, x2, subtree, center, nodePar, edgePar, horiz = FALSE, sum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal_length_+3A_x1">x1</code></td>
<td>
<p>A x coordinate<code>x1</code></p>
</td></tr>
<tr><td><code id="cal_length_+3A_x2">x2</code></td>
<td>
<p>Another x coordinate<code>x2</code></p>
</td></tr>
<tr><td><code id="cal_length_+3A_subtree">subtree</code></td>
<td>
<p>A dendrogram object.<code>subtree</code></p>
</td></tr>
<tr><td><code id="cal_length_+3A_center">center</code></td>
<td>
<p>A logical whether the dendrogram is centered.<code>center</code></p>
</td></tr>
<tr><td><code id="cal_length_+3A_nodepar">nodePar</code></td>
<td>
<p>A node parameter.<code>nodePar</code></p>
</td></tr>
<tr><td><code id="cal_length_+3A_edgepar">edgePar</code></td>
<td>
<p>An edge parameter.<code>edgePar</code></p>
</td></tr>
<tr><td><code id="cal_length_+3A_horiz">horiz</code></td>
<td>
<p>A logical about layout.<code>horiz</code></p>
</td></tr>
<tr><td><code id="cal_length_+3A_sum">sum</code></td>
<td>
<p>A sum of length.<code>sum</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>output The length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate sample data
set.seed(1234); par(mar=c(0,0,0,0))
x &lt;- rnorm(10, mean=rep(1:5, each=2), sd=0.4)
y &lt;- rnorm(10, mean=rep(c(1,2), each=5), sd=0.4)
dataFrame &lt;- data.frame(x=x, y=y, row.names=c(1:10))
#calculate Euclidian distance
distxy &lt;- dist(dataFrame)
#hierachical clustering "complete" linkage by default
hc &lt;- hclust(distxy)

total_length &lt;- cal_total_length(as.dendrogram(hc))

</code></pre>

<hr>
<h2 id='cal_node_limit'>Calculate the x coordinates given a branch of dendrogram</h2><span id='topic+cal_node_limit'></span>

<h3>Description</h3>

<p><code>cal_node_limit</code> is a code modified from plotNodeLimit()
to x coordinates of branches given a branch of dendrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_node_limit(x1, x2, subtree, center)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal_node_limit_+3A_x1">x1</code></td>
<td>
<p>A x coordinate<code>x1</code></p>
</td></tr>
<tr><td><code id="cal_node_limit_+3A_x2">x2</code></td>
<td>
<p>Another x coordinate<code>x2</code></p>
</td></tr>
<tr><td><code id="cal_node_limit_+3A_subtree">subtree</code></td>
<td>
<p>A dendrogram object.<code>subtree</code></p>
</td></tr>
<tr><td><code id="cal_node_limit_+3A_center">center</code></td>
<td>
<p>A logical whether the dendrogram is centered.<code>center</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A list of parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate sample data
set.seed(1234); par(mar=c(0,0,0,0))
x &lt;- rnorm(10, mean=rep(1:5, each=2), sd=0.4)
y &lt;- rnorm(10, mean=rep(c(1,2), each=5), sd=0.4)
dataFrame &lt;- data.frame(x=x, y=y, row.names=c(1:10))
#calculate Euclidian distance
distxy &lt;- dist(dataFrame)
#hierachical clustering "complete" linkage by default
hc &lt;- hclust(distxy)

total &lt;- cal_total_length(as.dendrogram(hc))

</code></pre>

<hr>
<h2 id='cal_total_length'>Calculate the total length of lines to draw the dendrogram</h2><span id='topic+cal_total_length'></span>

<h3>Description</h3>

<p><code>cal_total_length</code> is a code modified from plot.dendrogram()
to calculate the total length of lines to draw a dendrogram. This
function was developed to evaluate the use of ink for visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_total_length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal_total_length_+3A_x">x</code></td>
<td>
<p>A dendrogram object.<code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>output The total length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate sample data
set.seed(1234); par(mar=c(0,0,0,0))
x &lt;- rnorm(10, mean=rep(1:5, each=2), sd=0.4)
y &lt;- rnorm(10, mean=rep(c(1,2), each=5), sd=0.4)
dataFrame &lt;- data.frame(x=x, y=y, row.names=c(1:10))
#calculate Euclidian distance
distxy &lt;- dist(dataFrame)
#hierachical clustering "complete" linkage by default
hc &lt;- hclust(distxy)

total_length &lt;- cal_total_length(as.dendrogram(hc))

</code></pre>

<hr>
<h2 id='dendsort'>Sorting and reordering dendrogram nodes</h2><span id='topic+dendsort'></span>

<h3>Description</h3>

<p><code>dendsort</code> sorts a dendrogram object which is 
typically  a result of hierarchical clustering (hclust). The 
subtrees in the resulting dendrogram are sorted based on the 
average distance of subtrees at every merging point. The 
tighter cluster, in other words the cluster with smaller 
average distance, is placed on the left side of branch.  
When a leaf merge with a cluster, the leaf is placed on the 
right side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dendsort(d, isReverse = FALSE, type = "min")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dendsort_+3A_d">d</code></td>
<td>
<p>a dendrogram or hclust object.<code>d</code></p>
</td></tr>
<tr><td><code id="dendsort_+3A_isreverse">isReverse</code></td>
<td>
<p>logical indicating if the order should be reversed.Defaults to FALSE<code>isReverse</code></p>
</td></tr>
<tr><td><code id="dendsort_+3A_type">type</code></td>
<td>
<p>character indicating the type of sorting. Default to &quot;min&quot; <code>type</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A sorted dendrogram or hclust.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate sample data
set.seed(1234); par(mar=c(0,0,0,0))
x &lt;- rnorm(10, mean=rep(1:5, each=2), sd=0.4)
y &lt;- rnorm(10, mean=rep(c(1,2), each=5), sd=0.4)
dataFrame &lt;- data.frame(x=x, y=y, row.names=c(1:10))
#calculate Euclidian distance
distxy &lt;- dist(dataFrame)
#hierachical clustering "complete" linkage by default
hc &lt;- hclust(distxy)

#sort dendrogram
dd &lt;- dendsort(as.dendrogram(hc))
hc_sorted  &lt;- as.hclust(dd)

#sort in reverse, you can also pass hclust object
plot(dendsort(hc, isReverse=TRUE))

#sort by average distance
plot(dendsort(hc, type="average"))

#plot the result
par(mfrow = c(1, 3), mai=c(0.8,0.8,2,0.8))
plot(x, y, col="gray", pch=19, cex=2)
text(x, y, labels=as.character(1:10), cex=0.9)
plot(hc,main="before sorting", xlab="", sub="")
plot(hc_sorted, main="after sorting", xlab="", sub="")

</code></pre>

<hr>
<h2 id='sample_tcga'>Sample data matrix from the integrated pathway analysis of gastric cancer from the Cancer Genome Atlas (TCGA) study</h2><span id='topic+sample_tcga'></span>

<h3>Description</h3>

<p>a multivariate table obtained from the integrated pathway analysis of gastric cancer from the Cancer Genome Atlas (TCGA) study.
In this data set, each column represents a pathway consisting of a set of genes and each row represents a cohort of samples based
on specific clinical or genetic features. For each pair of a pathway and a feature, a continuous value of between 1 and -1 is
assigned to score positive or negative association, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sample_tcga)
</code></pre>


<h3>Format</h3>

<p>A data frame with 215 rows and 117 variables
</p>


<h3>Details</h3>

<p>We would like to thank Sheila Reynolds and Vesteinn Thorsson from the Institute for Systems Biology for sharing this sample data set.
</p>

<hr>
<h2 id='sort_average'>Sorting and reordering dendrogram nodes by average distances</h2><span id='topic+sort_average'></span>

<h3>Description</h3>

<p><code>sort_average</code> sorts a dendrogram object based on 
the average distance of its subtrees, recursively. 
The tighter cluster, in other words the cluster with smaller 
average distance, is placed on the left side of branch.  
When a leaf merge with a cluster, the leaf is placed on the 
right side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_average(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_average_+3A_d">d</code></td>
<td>
<p>A dendrogram object.<code>d</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A sorted dendrogram object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate sample data
set.seed(1234); par(mar=c(0,0,0,0))
x &lt;- rnorm(10, mean=rep(1:5, each=2), sd=0.4)
y &lt;- rnorm(10, mean=rep(c(1,2), each=5), sd=0.4)
dataFrame &lt;- data.frame(x=x, y=y, row.names=c(1:10))
#calculate Euclidian distance
distxy &lt;- dist(dataFrame)
#hierachical clustering "complete" linkage by default
hc &lt;- hclust(distxy)

#sort dendrogram
dd &lt;- dendsort(as.dendrogram(hc))
hc_sorted  &lt;- as.hclust(dd)

#sort in reverse, you can also pass hclust object
plot(dendsort(hc, isReverse=TRUE))

#sort by average distance
plot(dendsort(hc, type="average"))

#plot the result
par(mfrow = c(1, 3), mai=c(0.8,0.8,2,0.8))
plot(x, y, col="gray", pch=19, cex=2)
text(x, y, labels=as.character(1:10), cex=0.9)
plot(hc,main="before sorting", xlab="", sub="")
plot(hc_sorted, main="after sorting", xlab="", sub="")

</code></pre>

<hr>
<h2 id='sort_average_r'>Sorting and reordering dendrogram nodes by average distances in reverse</h2><span id='topic+sort_average_r'></span>

<h3>Description</h3>

<p><code>sort_average_r</code> sorts a dendrogram object in reverse based on 
the average distance of its subtrees, recursively. 
The tighter cluster, in other words the cluster with smaller 
average distance, is placed on the right side of branch.  
When a leaf merge with a cluster, the leaf is placed on the 
left side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_average_r(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_average_r_+3A_d">d</code></td>
<td>
<p>A dendrogram object.<code>d</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A sorted dendrogram object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate sample data
set.seed(1234); par(mar=c(0,0,0,0))
x &lt;- rnorm(10, mean=rep(1:5, each=2), sd=0.4)
y &lt;- rnorm(10, mean=rep(c(1,2), each=5), sd=0.4)
dataFrame &lt;- data.frame(x=x, y=y, row.names=c(1:10))
#calculate Euclidian distance
distxy &lt;- dist(dataFrame)
#hierachical clustering "complete" linkage by default
hc &lt;- hclust(distxy)

#sort dendrogram
dd &lt;- dendsort(as.dendrogram(hc))
hc_sorted  &lt;- as.hclust(dd)

#sort in reverse, you can also pass hclust object
plot(dendsort(hc, isReverse=TRUE))

#sort by average distance
plot(dendsort(hc, type="average"))

#plot the result
par(mfrow = c(1, 3), mai=c(0.8,0.8,2,0.8))
plot(x, y, col="gray", pch=19, cex=2)
text(x, y, labels=as.character(1:10), cex=0.9)
plot(hc,main="before sorting", xlab="", sub="")
plot(hc_sorted, main="after sorting", xlab="", sub="")

</code></pre>

<hr>
<h2 id='sort_smallest'>Sorting and reordering dendrogram nodes by the smallest value</h2><span id='topic+sort_smallest'></span>

<h3>Description</h3>

<p><code>sort_smallest</code> sorts a dendrogram object based on 
the smallest distance in its subtrees, recursively. 
The cluster with the smallest distance is placed on the left 
side of branch.When a leaf merge with a cluster, the leaf is 
placed on the right side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_smallest(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_smallest_+3A_d">d</code></td>
<td>
<p>A dendrogram object.<code>d</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A sorted dendrogram object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate sample data
set.seed(1234); par(mar=c(0,0,0,0))
x &lt;- rnorm(10, mean=rep(1:5, each=2), sd=0.4)
y &lt;- rnorm(10, mean=rep(c(1,2), each=5), sd=0.4)
dataFrame &lt;- data.frame(x=x, y=y, row.names=c(1:10))
#calculate Euclidian distance
distxy &lt;- dist(dataFrame)
#hierachical clustering "complete" linkage by default
hc &lt;- hclust(distxy)

#sort dendrogram
dd &lt;- dendsort(as.dendrogram(hc))
hc_sorted  &lt;- as.hclust(dd)

#sort in reverse, you can also pass hclust object
plot(dendsort(hc, isReverse=TRUE))

#sort by average distance
plot(dendsort(hc, type="average"))

#plot the result
par(mfrow = c(1, 3), mai=c(0.8,0.8,2,0.8))
plot(x, y, col="gray", pch=19, cex=2)
text(x, y, labels=as.character(1:10), cex=0.9)
plot(hc,main="before sorting", xlab="", sub="")
plot(hc_sorted, main="after sorting", xlab="", sub="")

</code></pre>

<hr>
<h2 id='sort_smallest_r'>Sorting and reordering dendrogram nodes by the smallest value in reverse</h2><span id='topic+sort_smallest_r'></span>

<h3>Description</h3>

<p><code>sort_smallest_r</code> sorts a dendrogram object in reverse
based on the smallest distance in its subtrees, recursively. 
The cluster with the smallest distance is placed on the right 
side of branch.When a leaf merge with a cluster, the leaf is 
placed on the left side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_smallest_r(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_smallest_r_+3A_d">d</code></td>
<td>
<p>A dendrogram object.<code>d</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A sorted dendrogram object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate sample data
set.seed(1234); par(mar=c(0,0,0,0))
x &lt;- rnorm(10, mean=rep(1:5, each=2), sd=0.4)
y &lt;- rnorm(10, mean=rep(c(1,2), each=5), sd=0.4)
dataFrame &lt;- data.frame(x=x, y=y, row.names=c(1:10))
#calculate Euclidian distance
distxy &lt;- dist(dataFrame)
#hierachical clustering "complete" linkage by default
hc &lt;- hclust(distxy)

#sort dendrogram
dd &lt;- dendsort(as.dendrogram(hc))
hc_sorted  &lt;- as.hclust(dd)

#sort in reverse, you can also pass hclust object
plot(dendsort(hc, isReverse=TRUE))

#sort by average distance
plot(dendsort(hc, type="average"))

#plot the result
par(mfrow = c(1, 3), mai=c(0.8,0.8,2,0.8))
plot(x, y, col="gray", pch=19, cex=2)
text(x, y, labels=as.character(1:10), cex=0.9)
plot(hc,main="before sorting", xlab="", sub="")
plot(hc_sorted, main="after sorting", xlab="", sub="")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
