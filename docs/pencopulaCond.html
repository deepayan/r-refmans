<!DOCTYPE html><html><head><title>Help for package pencopulaCond</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pencopulaCond}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pencopulaCond-package'><p>Estimating Non-Simplified Vine Copulas Using Penalized Splines</p></a></li>
<li><a href='#cal.Dvine'><p>Estimating Non-Simplified Vine Copulas Using Penalized Splines</p></a></li>
<li><a href='#cal.vine'><p>Estimating Non-Simplified Vine Copulas Using Penalized Splines</p></a></li>
<li><a href='#Derv1'><p>Calculating the first derivative of the pencopula likelihood function w.r.t. parameter b</p></a></li>
<li><a href='#Derv2'><p>Calculating the second order derivative with and without penalty.</p></a></li>
<li><a href='#distr.func.help'><p>These functions are used for calculating the integral of the</p>
B-spline density basis.</a></li>
<li><a href='#f.hat.val'><p>Calculating the actual fitted values 'f.hat.val' of the estimated density function</p></a></li>
<li><a href='#hierarch.bs'><p>Construction of the hierarchical B-spline density basis.</p></a></li>
<li><a href='#knots.start'><p>Calculating the knots.</p></a></li>
<li><a href='#marg.likelihood'><p>Calculating the marginal likelihood</p></a></li>
<li><a href='#my.bspline'><p>my.bspline</p></a></li>
<li><a href='#my.IC'><p>Calculating the AIC-value</p></a></li>
<li><a href='#my.loop'><p>Iterative loop for calculating the optimal coefficients 'b'.</p></a></li>
<li><a href='#my.positive.definite.solve'><p>my.positive.definite.solve</p></a></li>
<li><a href='#new.weights'><p>Calculating new weights b.</p></a></li>
<li><a href='#pen.log.like'><p>Calculating the log likelihood</p></a></li>
<li><a href='#penalty.matrix'><p>Calculating the penalty matrix P(lambda)</p></a></li>
<li><a href='#pencopula'><p>Calculating penalized (conditional) copula density with penalized hierarchical B-splines</p></a></li>
<li><a href='#pendenForm'><p>Formula interpretation and data transfer</p></a></li>
<li><a href='#plot.pencopula'><p>Plot the estimated copula density or copula distribution.</p></a></li>
<li><a href='#print.pencopula'><p>Printing the main results of the penalized copula density estimation</p></a></li>
<li><a href='#vine'><p>&quot;Estimating Non-Simplified Vine Copulas Using Penalized Splines&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimating Non-Simplified Vine Copulas Using Penalized Splines</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-05-31</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1), lattice, fda, latticeExtra, pacotest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>quadprog, doParallel, foreach, TSP, igraph</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimating Non-Simplified Vine Copulas Using Penalized Splines.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-05-31 14:17:51 UTC; cschellhase</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-05-31 19:29:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='pencopulaCond-package'>Estimating Non-Simplified Vine Copulas Using Penalized Splines</h2><span id='topic+pencopulaCond-package'></span>

<h3>Description</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> pencopulaCond</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-05-31</td>
</tr>
<tr>
 <td style="text-align: left;">
License: GPL (&gt;= 2)
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Simulating from a three-dimensional frank copula with
  #kendell's tau equal to 0.25, sample size N.set=100.
  #Please enlarge N.set for further studies.
  #require(copula)
  #N.set&lt;-100
  #cop &lt;- archmCopula(family = "frank", dim = 3, param =2.39)
  #parMarg&lt;-list(list(min=0,max=1),list(min=0,max=1),list(min=0,max=1))
  #distr.cop &lt;- mvdc(cop, margins=rep("unif",3), paramMargins = parMarg,marginsIdentical=TRUE)
  #c.X &lt;- rMvdc(mvdc=distr.cop, n=N.set)
  #Y &lt;- punif(c.X)
  #vine.copula&lt;-vine(Y,d=2,d2=2,D=4,D3=4,q=1,m=2,cores=1,lambda=c(10000,100))
</code></pre>

<hr>
<h2 id='cal.Dvine'>Estimating Non-Simplified Vine Copulas Using Penalized Splines</h2><span id='topic+cal.Dvine'></span>

<h3>Description</h3>

<p>Calculating the density of the estimated Dvine at the
point(s) val.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal.Dvine(obj,val)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal.Dvine_+3A_obj">obj</code></td>
<td>
<p>object of class 'penDvine', result of 'Dvine'.</p>
</td></tr>
<tr><td><code id="cal.Dvine_+3A_val">val</code></td>
<td>
<p>Values in which the current Dvine should be evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current Dvine is evaluated in val and the corresponding
density values are returned.</p>


<h3>Value</h3>

<p>The returing values are the density of the current Dvine at the
point(s) 'val'.</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='cal.vine'>Estimating Non-Simplified Vine Copulas Using Penalized Splines</h2><span id='topic+cal.vine'></span>

<h3>Description</h3>

<p>Calculating the density of the estimated regular vine at the
point(s) val.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal.vine(obj,val,cores)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal.vine_+3A_obj">obj</code></td>
<td>
<p>Vine object of class 'pencopula'.</p>
</td></tr>
<tr><td><code id="cal.vine_+3A_val">val</code></td>
<td>
<p>Values in which the current R-vine should be evaluated.</p>
</td></tr>
<tr><td><code id="cal.vine_+3A_cores">cores</code></td>
<td>
<p>Default=NULL, the number of cpu cores used for parallel computing can be specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current R-vine is evaluated in val and the corresponding
density values are returned.</p>


<h3>Value</h3>

<p>The returing values are the density of the current R-vine at the
point(s) 'val'.</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.
</p>

<hr>
<h2 id='Derv1'>Calculating the first derivative of the pencopula likelihood function w.r.t. parameter b</h2><span id='topic+Derv1'></span>

<h3>Description</h3>

<p>Calculating the first derivative of the pencopula likelihood function w.r.t. parameter b. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Derv1(penden.env,temp.lam=FALSE,temp.ck=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Derv1_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pencopula().</p>
</td></tr>
<tr><td><code id="Derv1_+3A_temp.lam">temp.lam</code></td>
<td>
<p>Calculating with temporal smoothing parameter lambda</p>
</td></tr>
<tr><td><code id="Derv1_+3A_temp.ck">temp.ck</code></td>
<td>
<p>Calculating with temporal weights ck of the spline basis functions</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Derv1.pen</code></td>
<td>
<p>first order derivation of the penalized likelihood.</p>
</td></tr>
</table>
<p>Derv1.pen is saved in the environment.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2013), Scandinavian Journal of Statistics 40(4), 685-705.
</p>
<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='Derv2'>Calculating the second order derivative with and without penalty.</h2><span id='topic+Derv2'></span>

<h3>Description</h3>

<p>Calculating the second order derivative with and without penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Derv2(penden.env, temp.lam = FALSE,temp.ck=FALSE,lam.fit=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Derv2_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pendensity()</p>
</td></tr>
<tr><td><code id="Derv2_+3A_temp.lam">temp.lam</code></td>
<td>
<p>Calculating with temporal smoothing parameter lambda</p>
</td></tr>
<tr><td><code id="Derv2_+3A_temp.ck">temp.ck</code></td>
<td>
<p>Calculating with temporal weights ck of the spline basis functions</p>
</td></tr>
<tr><td><code id="Derv2_+3A_lam.fit">lam.fit</code></td>
<td>
<p>Indicating if the iterations for a new lambda are running</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We approximate the second order derivative in this approach with the negative fisher information. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>Derv2.pen</code></td>
<td>
<p>second order derivative w.r.t. beta with penalty</p>
</td></tr>
<tr><td><code>Derv2.cal</code></td>
<td>
<p>second order derivative w.r.t. beta without
penalty. Needed for calculating of e.g. AIC.</p>
</td></tr>
</table>
<p>Derv2.cal and Derv2.pen are saved in the environment.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2013), Scandinavian Journal of Statistics 40(4), 685-705.
</p>
<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='distr.func.help'>These functions are used for calculating the integral of the
B-spline density basis.</h2><span id='topic+distr.func.help'></span><span id='topic+poly.part'></span>

<h3>Description</h3>

<p>These functions cooperate with each other for calculating the
integral of the B-spline density basis. functions. 'distr.func.help' is the main program, calling
'poly.part', calculating the integral of the B-spline density basis in sections between neighbouring knots. 'distr.func.help' calculates analytical functions of the integral. Therefore the function 'poly.part' is needed to construct these functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr.func.help(base,knots,penden.env,q,y,index)
poly.part(i,j,knots,help.env,q, yi=NULL, poly=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distr.func.help_+3A_base">base</code></td>
<td>
<p>values of the considered B-spline basis</p>
</td></tr>
<tr><td><code id="distr.func.help_+3A_knots">knots</code></td>
<td>
<p>knots of the considered B-spline basis</p>
</td></tr>
<tr><td><code id="distr.func.help_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pencopula()</p>
</td></tr>
<tr><td><code id="distr.func.help_+3A_q">q</code></td>
<td>
<p>degree of the B-Spline basis</p>
</td></tr>
<tr><td><code id="distr.func.help_+3A_y">y</code></td>
<td>
<p>data of the marginal B-spline basis</p>
</td></tr>
<tr><td><code id="distr.func.help_+3A_index">index</code></td>
<td>
<p>columns of the whole B-spline basis, each hierarchy level
is integrated separately</p>
</td></tr>
<tr><td><code id="distr.func.help_+3A_i">i</code></td>
<td>
<p>internal values for calculating the polynomials of each B-Spline</p>
</td></tr>
<tr><td><code id="distr.func.help_+3A_j">j</code></td>
<td>
<p>internal values for calculating the polynomials of each
B-Spline</p>
</td></tr>
<tr><td><code id="distr.func.help_+3A_help.env">help.env</code></td>
<td>
<p>internal environment of pencopula() for calculating
the integral</p>
</td></tr>
<tr><td><code id="distr.func.help_+3A_yi">yi</code></td>
<td>
<p>internal values for calculating the polynomials of each
B-Spline</p>
</td></tr>
<tr><td><code id="distr.func.help_+3A_poly">poly</code></td>
<td>
<p>internal value, TRUE/FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>distr.func.help</code></td>
<td>
<p>creating environment 'help.env', creating help points between each two neighbouring knots and calculates the integral each basis</p>
</td></tr>
<tr><td><code>poly.part</code></td>
<td>
<p>using in 'distr.func.help' for creating the polynomial functions of each interval of each two neighbouring knots</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='f.hat.val'>Calculating the actual fitted values 'f.hat.val' of the estimated density function</h2><span id='topic+f.hat.val'></span>

<h3>Description</h3>

<p>Calculating the actual fitted values of the response, depending on the actual parameter set b
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.hat.val(penden.env,cal=FALSE,temp=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f.hat.val_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pencopula()</p>
</td></tr>
<tr><td><code id="f.hat.val_+3A_cal">cal</code></td>
<td>
<p>if TRUE, the final weights of one iteration are used for
the calculation of the fitted values.</p>
</td></tr>
<tr><td><code id="f.hat.val_+3A_temp">temp</code></td>
<td>
<p>if TRUE, the iteration for optimal weights is still in
progress and the temporary weights are used for calculation of the
fitted values.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>f.hat.val</code></td>
<td>
<p>Fitted values for the current coefficents</p>
</td></tr></table>
<p>.
f.hat.val is saved in the environment.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2013), Scandinavian Journal of Statistics 40(4), 685-705.
</p>
<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='hierarch.bs'>Construction of the hierarchical B-spline density basis.</h2><span id='topic+hierarch.bs'></span>

<h3>Description</h3>

<p>Construction of the hierarchical B-spline density basis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarch.bs(x, d, plot.bsp, typ, penden.env, int=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierarch.bs_+3A_x">x</code></td>
<td>
<p>Marginal data for construction.</p>
</td></tr>
<tr><td><code id="hierarch.bs_+3A_d">d</code></td>
<td>
<p>Hierarchy level of the marginal hierarchical B-spline density.</p>
</td></tr>
<tr><td><code id="hierarch.bs_+3A_plot.bsp">plot.bsp</code></td>
<td>
<p>Default = FALSE. If TRUE, each B-spline basis is plotted.</p>
</td></tr>
<tr><td><code id="hierarch.bs_+3A_typ">typ</code></td>
<td>
<p>typ==1 without open B-splines at the boundary
typ==2 with open B-splines at the boundary.</p>
</td></tr>
<tr><td><code id="hierarch.bs_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pencopula().</p>
</td></tr>
<tr><td><code id="hierarch.bs_+3A_int">int</code></td>
<td>
<p>Default = FALSE. If TRUE, the integral of the hierarchical
B-spline density basis is calculated (used for the distribution
function of the estimation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the marginal hierarchical B-spline density basis is constructed for each
covariate 'B.tilde'.
</p>
<p>After the construction of each marginal basis, the
hierarchical B-spline density basis is built in the main program
pencopula(), using an object  'Index.basis.D' (saved in the
environment). 'Index.basis.D' notes which compenent of the marginal
basis has to be selected. In the main program the object
'tilde.Psi.d.D' is constructed. D refers to the maximum hierachy level
and 'd' is the hierarchy level of the marginal hierarchical B-spline.
</p>


<h3>Value</h3>

<table>
<tr><td><code>B.tilde</code></td>
<td>
<p>'B.tilde' is the hierarchical B-spline density basis,
returned by 'hierarch.bs'.</p>
</td></tr>
<tr><td><code>int.B.tilde</code></td>
<td>
<p>If 'int=TRUE', the integral of the hierachical
B-spline density basis is calculated and returned by 'hierarch.bs'.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='knots.start'>Calculating the knots.</h2><span id='topic+knots.start'></span><span id='topic+knots.transform'></span><span id='topic+knots.order'></span>

<h3>Description</h3>

<p>Calculating the equidistant knots for the estimation. Moreover,
transformation of the knots are possible.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  knots.start(penden.env)
  knots.transform(d,alpha = 0, symmetric = TRUE)
  knots.order(penden.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knots.start_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of
pencopula()</p>
</td></tr>
<tr><td><code id="knots.start_+3A_d">d</code></td>
<td>
<p>Hierarchy level of the marginal hierarchical B-spline basis.</p>
</td></tr>
<tr><td><code id="knots.start_+3A_alpha">alpha</code></td>
<td>
<p>Default = 0. Alpha is a tuning parameter, shifting the
knots.</p>
</td></tr>
<tr><td><code id="knots.start_+3A_symmetric">symmetric</code></td>
<td>
<p>Default = TRUE. If FALSE, the knots are selected
without symmetry.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Knots.order' sorts the knots in the order, in which they disappear
in the hierarchical B-spline basis.
</p>


<h3>Value</h3>

<table>
<tr><td><code>knots</code></td>
<td>
<p>Selected and sorted marginal knots for the estimation.</p>
</td></tr>
<tr><td><code>knots.help</code></td>
<td>
<p>Extended set of knots. It is needed for calculating the distribution
function, help points for the integration of the B-spline density basis.</p>
</td></tr>
<tr><td><code>k.order</code></td>
<td>
<p>Order of the knots, corresponding to their order in the
hierarchical B-spline density basis.</p>
</td></tr>
<tr><td><code>knots.t</code></td>
<td>
<p>The knots ordered with 'k.order' for further fucntions.</p>
</td></tr>
<tr><td><code>tilde.Psi.knots.d</code></td>
<td>
<p>Hierarchical B-Spline density basis for 'knots'.</p>
</td></tr>
<tr><td><code>tilde.Psi.knots.d.help</code></td>
<td>
<p>Hierarchical B-Spline density basis for
'knots.help'.</p>
</td></tr>
</table>
<p>All values are saved in the environment.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2013), Scandinavian Journal of Statistics 40(4), 685-705.
</p>
<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='marg.likelihood'>Calculating the marginal likelihood</h2><span id='topic+marg.likelihood'></span>

<h3>Description</h3>

<p>Calculating the marginal likelihood of paircopula().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marg.likelihood(penden.env,pen.likelihood,temp=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marg.likelihood_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of
paircopula().</p>
</td></tr>
<tr><td><code id="marg.likelihood_+3A_pen.likelihood">pen.likelihood</code></td>
<td>
<p>Actual penalized likelihood for calculation,
temporary or not.</p>
</td></tr>
<tr><td><code id="marg.likelihood_+3A_temp">temp</code></td>
<td>
<p>Default=FALSE, indicating if temporary values throughout
iteration are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>marg.log.like</code></td>
<td>
<p>Marginal log-likelihood, saved in the environment</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='my.bspline'>my.bspline</h2><span id='topic+my.bspline'></span><span id='topic+int.my.bspline'></span>

<h3>Description</h3>

<p>'my.bspline' Integrates the normal B-Spline basis to a B-spline density
basis. The dimension of the basis depends on the input of number of
knots 'k' and of the order of the B-spline basis 'q'. 'int.my.bspline'
is a function for transformation of open B-spline basis at the
boundary to become a B-spline basis density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my.bspline(h, q, knots, y, K, plot.bsp, typ)
int.my.bspline(help.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="my.bspline_+3A_h">h</code></td>
<td>
<p>if equidistant knots are used (default in pencopula()), h is the distance between two neighbouring knots</p>
</td></tr>
<tr><td><code id="my.bspline_+3A_q">q</code></td>
<td>
<p>selected order of the B-spline basis</p>
</td></tr>
<tr><td><code id="my.bspline_+3A_knots">knots</code></td>
<td>
<p>selected values for the knots</p>
</td></tr>
<tr><td><code id="my.bspline_+3A_y">y</code></td>
<td>
<p>values of the response variable</p>
</td></tr>
<tr><td><code id="my.bspline_+3A_k">K</code></td>
<td>
<p>the number of knots for the construction of the base</p>
</td></tr>
<tr><td><code id="my.bspline_+3A_plot.bsp">plot.bsp</code></td>
<td>
<p>Indicator variable TRUE/FALSE if the integrated
B-spline basis should be plotted</p>
</td></tr>
<tr><td><code id="my.bspline_+3A_typ">typ</code></td>
<td>
<p>typ==1 without open B-splines at the boundary
typ==2 with open B-splines at the boundary</p>
</td></tr>
<tr><td><code id="my.bspline_+3A_help.env">help.env</code></td>
<td>
<p>Internal environment of my.bspline().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly, the function constructs the B-spline basis to the given number
of knots 'K' and the given locations of the knots.
</p>


<h3>Value</h3>

<table>
<tr><td><code>base.den</code></td>
<td>
<p>The integrated B-Spline base of order q</p>
</td></tr>
<tr><td><code>stand.num</code></td>
<td>
<p>The coefficients for standardization of the ordinary B-Spline basis</p>
</td></tr>
<tr><td><code>knots.val</code></td>
<td>
<p>This return is a list. It consider of the used knots 'knots.val\$val', the help knots 'knots.val\$help' and the additional knots 'knots.val\$all', used for the construction of the base and the calculation of the distribution function of each B-Spline.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>The transformed value of K, due to used order 'q' and the input of 'K'</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2013), Scandinavian Journal of Statistics 40(4), 685-705.
</p>
<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='my.IC'>Calculating the AIC-value</h2><span id='topic+my.IC'></span>

<h3>Description</h3>

<p>Calculating the AIC-value and cAIC-value of the copula density estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my.IC(penden.env,temp=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="my.IC_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of
paircopula()</p>
</td></tr>
<tr><td><code id="my.IC_+3A_temp">temp</code></td>
<td>
<p>Default=FALSE, if TRUE temporary values of AIC and cAIC are calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AIC is calculated as
<code class="reqn">AIC(\lambda)= - 2*l({\bf u},\hat{\bf{b}}) + 2*df(\lambda)</code>
</p>
<p>cAIC is calculated as
<code class="reqn">cAIC(\lambda)= - 2*l({\bf u},\hat{\bf{b}}) + 2*df(\lambda) + \frac{2df(\lambda)(df(\lambda)+1)}{n-df(\lambda)-1} </code>
</p>
<p>BIC is calculated as
<code class="reqn">BIC(\lambda)= 2*l({\bf u},\hat{\bf{b}}) + 2*df(\lambda)*log(n)</code>
</p>


<h3>Value</h3>

<table>
<tr><td><code>AIC</code></td>
<td>
<p>sum of twice the negative non-penalized log likelihood and df(lambda)</p>
</td></tr>
<tr><td><code>cAIC</code></td>
<td>
<p>sum of twice the negative non-penalized log likelihood and df(lambda) and (2df(lambda)(df(lambda)+1))/(n-df(lambda)-1)</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>sum of twice the non-penalized log likelihood and log(n)*df(lambda)</p>
</td></tr>
</table>
<p>All values are saved in the environment.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2013), Scandinavian Journal of Statistics 40(4), 685-705.
</p>
<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='my.loop'>Iterative loop for calculating the optimal coefficients 'b'.</h2><span id='topic+my.loop'></span>

<h3>Description</h3>

<p>Calculating the optimal coefficients 'b' iteratively, using quadratic programing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my.loop(penden.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="my.loop_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pencopula()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'my.loop' optimates the log-likelihhod iteratively. Therefore, the
routine checks the relative chance in the weights and stops the
iteration, if the relative change of all weights 'b' is less than one
percent. During the calculations of new weights 'b' in the routine
'new.weights', most of the values are called '.temp'. This add on
unterlines the temporarily values. 'my.loop' checks the relative
change in the weights. If the change is greater than one percent, the
the real values are overwritten with the '.temp' values.
</p>


<h3>Value</h3>

<table>
<tr><td><code>liste</code></td>
<td>
<p>The results of each iteration are written in a matrix called 'liste',
saved in the environment. 'liste' contains the penalized
log-likelihood, the log-likelihood, 'lambda' and the weights 'b'.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='my.positive.definite.solve'>my.positive.definite.solve</h2><span id='topic+my.positive.definite.solve'></span>

<h3>Description</h3>

<p>Reverses a quadratic positive definite matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my.positive.definite.solve(A, eps = 1e-15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="my.positive.definite.solve_+3A_a">A</code></td>
<td>
<p>quadratic positive definite matrix</p>
</td></tr>
<tr><td><code id="my.positive.definite.solve_+3A_eps">eps</code></td>
<td>
<p>level of the lowest eigenvalue to consider</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The program makes an eigenvalue decomposition of the positive definite matrix A and searches all eigenvalues greater than eps. The value of return is the inverse matrix of A, constructed with the matrix product of the corresponding eigenvalues and eigenvectors. </p>


<h3>Value</h3>

<p>The return is the inverse matrix of A.</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='new.weights'>Calculating new weights b.</h2><span id='topic+new.weights'></span>

<h3>Description</h3>

<p>Calculating new weights b using quadratic programing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.weights(penden.env,start=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new.weights_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pencopula()</p>
</td></tr>
<tr><td><code id="new.weights_+3A_start">start</code></td>
<td>
<p>Default=FALSE, for the first calculation some specifications are introduced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the quadratic program does not find a new feasible solution, the whole
program terminates. For solving the quadratic program, we use the
function 'solve.QP' from the  R-package 'quadprog'.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ck.val.temp</code></td>
<td>
<p>Calculated new values for the weights 'b'. The add
on 'temp' means, that there is a check in the next step if the
weights 'b' have been converted or not. If converted, the new values
'ck.val.temp' are unnoted. If not converted, 'ck.val.temp' become
the ordinary 'ck.val' for the next iteration. This check is done in my.loop.</p>
</td></tr>
</table>
<p>'ck.val.temp' is saved in the environment.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2013), Scandinavian Journal of Statistics 40(4), 685-705.
</p>
<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='pen.log.like'>Calculating the log likelihood</h2><span id='topic+pen.log.like'></span>

<h3>Description</h3>

<p>Calculating the considered log likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen.log.like(penden.env,cal=FALSE,temp.lam=FALSE,temp.ck=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen.log.like_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of pencopula()</p>
</td></tr>
<tr><td><code id="pen.log.like_+3A_cal">cal</code></td>
<td>
<p>if TRUE, the final weights of one iteration are used for
the calculation of the penalized log likelihood.</p>
</td></tr>
<tr><td><code id="pen.log.like_+3A_temp.lam">temp.lam</code></td>
<td>
<p>Calculating with temporal smoothing parameter lambda</p>
</td></tr>
<tr><td><code id="pen.log.like_+3A_temp.ck">temp.ck</code></td>
<td>
<p>Calculating with temporal weights ck of the spline basis functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation depends on the estimated weights b, the penalized
hierarchical B-splines Phi and the penalty paramters lambda.
</p>


<h3>Value</h3>

<table>
<tr><td><code>pen.log.like</code></td>
<td>
<p>Penalized log likelihood of the copula density.</p>
</td></tr>
<tr><td><code>log.like</code></td>
<td>
<p>Log-Likelihood of the copula density.</p>
</td></tr>
</table>
<p>The values are saved in the environment.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2013), Scandinavian Journal of Statistics 40(4), 685-705.
</p>
<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='penalty.matrix'>Calculating the penalty matrix P(lambda)</h2><span id='topic+penalty.matrix'></span>

<h3>Description</h3>

<p>Calculating the penalty matrix P depends on the number of
covariates 'p', the order of differences to be penalized 'pen.order',
the number of observations 'n' and the penalty parameters 'lambda&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalty.matrix(penden.env, temp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalty.matrix_+3A_penden.env">penden.env</code></td>
<td>
<p>Containing all information, environment of
pencopula().</p>
</td></tr>
<tr><td><code id="penalty.matrix_+3A_temp">temp</code></td>
<td>
<p>If TRUE, the iteration for a new 'b' is not finished and a temporary penalty matrix is calculated, default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>DDD.sum</code></td>
<td>
<p>Penalty matrix P</p>
</td></tr>
</table>
<p>Matrix is saved in the environment.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2013), Scandinavian Journal of Statistics 40(4), 685-705.
</p>
<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='pencopula'>Calculating penalized (conditional) copula density with penalized hierarchical B-splines</h2><span id='topic+pencopula'></span>

<h3>Description</h3>

<p>Calculating penalized (conditional) copula density with penalized hierarchical B-splines </p>


<h3>Usage</h3>

<pre><code class='language-R'>pencopula(data,d=3,D=d,q=1,base="B-spline",max.iter=20,test.ind=FALSE,
         lambda=c(100,100),pen.order=2,data.frame=parent.frame(),cond=FALSE,
         fix.lambda=FALSE,id=NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pencopula_+3A_data">data</code></td>
<td>
<p>'data' contains the data. 'data' has to be a matrix or a
data.frame. The number of columns of 'data' is p.</p>
</td></tr>
<tr><td><code id="pencopula_+3A_d">d</code></td>
<td>
<p>refers to the hierachy level of the marginal hierarchical
B-spline, default is d=3.</p>
</td></tr>
<tr><td><code id="pencopula_+3A_d">D</code></td>
<td>
<p>referes to the maximum hierachy level, default is D=3. If
D&lt;d, it follows D&lt;-d.</p>
</td></tr>
<tr><td><code id="pencopula_+3A_q">q</code></td>
<td>
<p>degree of the marginal hierarchical B-spline.</p>
</td></tr>
<tr><td><code id="pencopula_+3A_base">base</code></td>
<td>
<p>By default, the used marginal basis is a
'B-spline'. Second possible option is 'Bernstein', using a Bernstein
polynomial basis.</p>
</td></tr>
<tr><td><code id="pencopula_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iteration, the default is max.iter=20.</p>
</td></tr>
<tr><td><code id="pencopula_+3A_test.ind">test.ind</code></td>
<td>
<p>Default=FALSE. If test.ind=TRUE, the fitted log-likelihood of each pair-copula is evaluated. If (&quot;log.like&quot;/&quot;n&quot;&lt;0.001), where &quot;n&quot; is the  sample size, the program set the corresponding pair copula as independence copula. We do not use this in our simulations or applications in the article.</p>
</td></tr>
<tr><td><code id="pencopula_+3A_lambda">lambda</code></td>
<td>
<p>p-dimensional vector of penalty parameters, the values
can be different. Default is lambda=c(100,100).</p>
</td></tr>
<tr><td><code id="pencopula_+3A_pen.order">pen.order</code></td>
<td>
<p>The order of differences for the penalization,
default is pen.order=2.</p>
</td></tr>
<tr><td><code id="pencopula_+3A_data.frame">data.frame</code></td>
<td>
<p>reference to the data. Default reference is the parent.frame().</p>
</td></tr>
<tr><td><code id="pencopula_+3A_cond">cond</code></td>
<td>
<p>Determining if a conditional copula is estimated. Default=FALSE, only suitable for p=3.</p>
</td></tr>
<tr><td><code id="pencopula_+3A_fix.lambda">fix.lambda</code></td>
<td>
<p>Default=FALSE, using the algorithm in the paper for estimating the optimal penalty parameter. If fix.lambda=TRUE, lambda is constant throughout the estimation.</p>
</td></tr>
<tr><td><code id="pencopula_+3A_id">id</code></td>
<td>
<p>Optional, one set id to any value. Especially important for simulations, starting with several starting values for lambda.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returning an object of class pencopula. The class pencopula consists of
the environment 'penden.env', which includes all calculated values of
the estimation approach.
For a fast overview of the main results, one can use the function 'print.pencopula()'.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2013), Scandinavian Journal of Statistics 40(4), 685-705.
</p>
<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='pendenForm'>Formula interpretation and data transfer</h2><span id='topic+pendenForm'></span>

<h3>Description</h3>

<p>Function 'pendenForm' interprets the input 'form' of the function pencopula(),transfers the data back to the main program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pendenForm(penden.env)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pendenForm_+3A_penden.env">penden.env</code></td>
<td>
<p>environment used in pendensity()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returning the values 'Y', the number of values 'n' and covariates 'p'.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='plot.pencopula'>Plot the estimated copula density or copula distribution.</h2><span id='topic+plot.pencopula'></span>

<h3>Description</h3>

<p>The function plots the estimated copula density or the
copula distrubtion for a paircopula, using the R-package 'lattice'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pencopula'
plot(x, val = NULL, marg = TRUE, plot = TRUE, int = FALSE,
main.txt = NULL, sub.txt = NULL, contour = FALSE, cond = NULL, cuts =
20, cex = 1, cex.axes = 1, cex.contour=1, xlab = NULL, ylab = NULL,
zlab=NULL, zlim=NULL, biv.margin=NULL, show.observ=FALSE,cond.cop=FALSE,
cond.par,margin.normal=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pencopula_+3A_x">x</code></td>
<td>
<p>object of class 'pencopula'.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_val">val</code></td>
<td>
<p>Default val = NULL, one can calculate the estimated density
in for p-dimensional vector, e.g. val=c(0.5,1) for the two
dimensional case.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_marg">marg</code></td>
<td>
<p>Default = TRUE, plotting the marginal densities.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_plot">plot</code></td>
<td>
<p>Default = TRUE, if 'FALSE' no plot is shown, e.g. for
calculations with val != NULL.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_int">int</code></td>
<td>
<p>Default = FALSE, if TRUE, the integral, i.e. the distribution of
the copula density is plotted.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_main.txt">main.txt</code></td>
<td>
<p>Default = NULL shows 'd', 'D', the values of lambda,
the penalty order and the degree of the B-splines.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_sub.txt">sub.txt</code></td>
<td>
<p>Default = NULL shows the log-likelihood, the penalized
log-likelihood and the AIC-value of the estimation.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_contour">contour</code></td>
<td>
<p>If TRUE, a contour plot is shown. Default = FALSE.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_cond">cond</code></td>
<td>
<p>Default = NULL, if the dimension of data 'p' is higher
than 2, one can plot a two-dimensional conditional plot. The user
specifies p-2 values for the plot, indicating with '-1'. So for a
three-dimensional plot, cond=c(0,-1,-1) shows the
density/distribution  ith fixed first covariate and the second
and third covariates vary.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_cuts">cuts</code></td>
<td>
<p>Number of cuts for the contour plots, if contour=TRUE.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_cex">cex</code></td>
<td>
<p>Default = 1, determing the size of the main of the plot.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_cex.axes">cex.axes</code></td>
<td>
<p>Default = 1, determing the size of the labels at the
axes.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_cex.contour">cex.contour</code></td>
<td>
<p>Default = 1, determing the size of the labels at the
cuts of the contourplot.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_xlab">xlab</code></td>
<td>
<p>Default = NULL and no text is printed at the xlab</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_ylab">ylab</code></td>
<td>
<p>Default = NULL and no text is printed at the ylab</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_zlab">zlab</code></td>
<td>
<p>Default = NULL and 'density' is printed at the zlab for
int=FALSE and 'distribution' for int=TRUE.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_zlim">zlim</code></td>
<td>
<p>For Default = NULL, the range of the estimated values determin zlim. Alternatively, one can suggest the range as a vector.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_biv.margin">biv.margin</code></td>
<td>
<p>Determines for which parameter the bivariate marginal distribution/density is presented.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_show.observ">show.observ</code></td>
<td>
<p>Default = FALSE. If TRUE, plotting the original observation
into a contourplot. For multivariate copulas the data corresponding
to 'biv.margin' is plotted. Show.observ is not possible in
combination with option 'cond'.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_cond.cop">cond.cop</code></td>
<td>
<p>Default=FALSE. If cond.cop=TRUE, the object x have to be condtional copula - this option will disapper as the object itself contains this information.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_cond.par">cond.par</code></td>
<td>
<p>If cond.cop=TRUE, the plot is created for the conditioning argument cond.par</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_margin.normal">margin.normal</code></td>
<td>
<p>Default = FALSE. If TRUE, the plot is presented with margins following standard normal distribution.</p>
</td></tr>
<tr><td><code id="plot.pencopula_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the two dimensional plots, a equidistant grid of 51 values between
0 and 1 is constructed. The plot consists of the density or
distribution values in this grid points. For plots of high dimensional
data (p&gt;2), one has to fix p-2 covariates (see 'cond').
</p>


<h3>Value</h3>

<p>If 'val' is not NULL, the function returns a matrix with the
calculated density or distribution values for the set 'val'.
</p>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='print.pencopula'>Printing the main results of the penalized copula density estimation</h2><span id='topic+print.pencopula'></span><span id='topic+print'></span>

<h3>Description</h3>

<p>Printing the call of the estimation, the used basis, lambda and
the corresponding values of AIC and BIC. Need an object of class pencopula.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pencopula'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pencopula_+3A_x">x</code></td>
<td>
<p>x has to be object of class pencopula</p>
</td></tr>
<tr><td><code id="print.pencopula_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

<hr>
<h2 id='vine'>&quot;Estimating Non-Simplified Vine Copulas Using Penalized Splines&quot;</h2><span id='topic+vine'></span>

<h3>Description</h3>

<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines</p>


<h3>Usage</h3>

<pre><code class='language-R'>vine(data,d=2,d2=2,D=4,D3=6,lambda=c(100,50),type="Rvine",order.Dvine=FALSE,m=2,
cores=NULL,q=1,mod.cond=TRUE,max.iter=51,fix.lambda=FALSE,RVM=NULL,cal.cond=FALSE,
id=NULL,test.ind=FALSE,test.cond=2,lambda.search=FALSE,lam1.vec=NULL,lam2.vec=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vine_+3A_data">data</code></td>
<td>
<p>'data' contains the data. 'data' has to be a matrix or a
data.frame with two columns.</p>
</td></tr>
<tr><td><code id="vine_+3A_d">d</code></td>
<td>
<p>refers to the hierachy level of the marginal hierarchical
B-spline for copulas in the first tree of the vine, default is d=2.</p>
</td></tr>
<tr><td><code id="vine_+3A_d2">d2</code></td>
<td>
<p>refers to the hierachy level of the marginal hierarchical
B-spline for copulas in the second tree and in the following trees of the vine, default is d2=2.</p>
</td></tr>
<tr><td><code id="vine_+3A_d">D</code></td>
<td>
<p>referes to the maximum hierachy level for copulas in the first tree of the vine, default is D=4. If
D&lt;d, it follows D&lt;-d.</p>
</td></tr>
<tr><td><code id="vine_+3A_d3">D3</code></td>
<td>
<p>referes to the maximum hierachy level for copulas in the second tree and in the following trees of the vine, default is D3=6.</p>
</td></tr>
<tr><td><code id="vine_+3A_lambda">lambda</code></td>
<td>
<p>Starting values for lambda, first start values for copulas in the first tree, second start value for copulas in the second tree and in the following trees of the vine, default is lambda=c(100,50).</p>
</td></tr>
<tr><td><code id="vine_+3A_type">type</code></td>
<td>
<p>Default is type=&quot;Rvine&quot;, fitting a regular vine copula. An alternative is type=&quot;Dvine&quot;, fitting a D-vine copula.</p>
</td></tr>
<tr><td><code id="vine_+3A_order.dvine">order.Dvine</code></td>
<td>
<p>Only relevant for type=&quot;Dvine&quot;. Indicating if the first level of the Dvine is
ordered, default order.Dvine=TRUE.</p>
</td></tr>
<tr><td><code id="vine_+3A_m">m</code></td>
<td>
<p>Indicating the order of differences to be penalised. Default is &quot;m=2&quot;.</p>
</td></tr>
<tr><td><code id="vine_+3A_cores">cores</code></td>
<td>
<p>Default=NULL, the number of cpu cores used for parallel computing can be specified.</p>
</td></tr>
<tr><td><code id="vine_+3A_q">q</code></td>
<td>
<p>Degree of B-splines. Default is q=1.</p>
</td></tr>
<tr><td><code id="vine_+3A_mod.cond">mod.cond</code></td>
<td>
<p>Default=TRUE. If mod.cond=FALSE each pair-copula in the vine is estimated as simplified copula. The argument test.cond varies the test for the simplyfing assumption, which is imported from the R-package pacotest.</p>
</td></tr>
<tr><td><code id="vine_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iteration, the default is max.iter=51.</p>
</td></tr>
<tr><td><code id="vine_+3A_fix.lambda">fix.lambda</code></td>
<td>
<p>Default=FALSE, using the algorithm in the paper for estimating the optimal penalty parameter. If fix.lambda=TRUE, lambda is constant throughout the estimation.</p>
</td></tr>
<tr><td><code id="vine_+3A_rvm">RVM</code></td>
<td>
<p>Default=NULL. If RVM is a RVine-Matrix, this matrix determines the structure of the vine.</p>
</td></tr>
<tr><td><code id="vine_+3A_cal.cond">cal.cond</code></td>
<td>
<p>Default=FALSE. If cal.cond=TRUE each copula in the second tree and in the following trees of the vine is estimated as conditional copula.</p>
</td></tr>
<tr><td><code id="vine_+3A_id">id</code></td>
<td>
<p>Optional, one set id to any value. Especially important for simulations, starting with several starting values for lambda.</p>
</td></tr>
<tr><td><code id="vine_+3A_test.ind">test.ind</code></td>
<td>
<p>Default=FALSE. If test.ind=TRUE, the fitted log-likelihood of each pair-copula is evaluated. If (&quot;log.like&quot;/&quot;n&quot;&lt;0.001), where &quot;n&quot; is the sample size, the program set the corresponding pair copula as independence copula. We do not use this in our simulations or applications in the article.</p>
</td></tr>
<tr><td><code id="vine_+3A_test.cond">test.cond</code></td>
<td>
<p>If test.cond=2, testType='ECORR' is chosen for the test of the simplyfing assumption as proposed in the article. There is an additional second test available in the R-package pactotest. testType=&quot;VI&quot; is chosen with test.cond=1.</p>
</td></tr>
<tr><td><code id="vine_+3A_lambda.search">lambda.search</code></td>
<td>
<p>TRUE/FALSE, indicating if a search about several starting values for lambda should be performed. If search is selected, the starting value 'lambda' does not work anymore.</p>
</td></tr>
<tr><td><code id="vine_+3A_lam1.vec">lam1.vec</code></td>
<td>
<p>Vector of candidate values for penalty parameter lambda for copulas in the first tree of the vine</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="vine_+3A_lam2.vec">lam2.vec</code></td>
<td>
<p>Vector of candidate values for penalty parameter lambda for copulas in the second tree and in the following trees of the vine</p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>The calculation of the vine is done stepwise. The specifications in 'vine' are done for every paircopula in the
vine with the identical specification. There is no option to change parameters for some pair-copulas.
</p>


<h3>Value</h3>

<p>Returning a list containing
</p>
<table>
<tr><td><code>vine</code></td>
<td>
<p>The estimated vine copula, an object of class 'pencopulaCond'</p>
</td></tr>
<tr><td><code>log.like</code></td>
<td>
<p>the estimated log-likelihood</p>
</td></tr>
<tr><td><code>log.like.vec</code></td>
<td>
<p>A vector with the estimated log.like.vec of each pair-copula</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>AIC value</p>
</td></tr>
<tr><td><code>AIC.vec</code></td>
<td>
<p>A vector with the estimated AIC of each pair-copula</p>
</td></tr>
<tr><td><code>cAIC</code></td>
<td>
<p>corrected AIC value</p>
</td></tr>
<tr><td><code>cAIC.vec</code></td>
<td>
<p>A vector with the estimated cAIC of each pair-copula</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Used d</p>
</td></tr>
<tr><td><code>d2</code></td>
<td>
<p>Used d2</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Used D</p>
</td></tr>
<tr><td><code>D3</code></td>
<td>
<p>Used D3</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>the used order of the first level (reported only for D-vines)</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Sequence seq(1:(dim(data)[2]))</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of observations, that is dim(data)[1]</p>
</td></tr>
<tr><td><code>base</code></td>
<td>
<p>Used basis function</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>Used degree of the B-spline basis</p>
</td></tr>
<tr><td><code>no.cond.dens</code></td>
<td>
<p>Estimated number of condtional copulas</p>
</td></tr>
<tr><td><code>pca</code></td>
<td>
<p>Indicating the used number of pca</p>
</td></tr>
<tr><td><code>D.struc</code></td>
<td>
<p>Used D.struc</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Selected type of the vine copula</p>
</td></tr>
<tr><td><code>VineMatrix</code></td>
<td>
<p>VineMatrix, reported for type=&quot;Rvine&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Schellhase &lt;cschellhase@wiwi.uni-bielefeld.de&gt;</p>


<h3>References</h3>

<p>Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2013), Scandinavian Journal of Statistics 40(4), 685-705.
</p>
<p>Estimating Non-Simplified Vine Copulas Using Penalized Splines, Schellhase, C. and Spanhel, F. (2017), Statistics and Computing.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
