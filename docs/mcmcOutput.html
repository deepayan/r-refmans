<!DOCTYPE html><html lang="en"><head><title>Help for package mcmcOutput</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mcmcOutput}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bigCrosscorr'>
<p>Cross-correlations for MCMC output</p></a></li>
<li><a href='#crosscorrPlot'>
<p>Plot image of correlation matrix</p></a></li>
<li><a href='#densityFolded'>
<p>Folded kernel density estimation</p></a></li>
<li><a href='#diagPlot'>
<p>Diagnostic graphics for class <code>mcmcOutput</code></p></a></li>
<li><a href='#discrepancyPlot'>
<p>Graphic comparison of observed vs simulated discrepancies</p></a></li>
<li><a href='#Get+20diagnostics'>
<p>Get diagnostic statistics</p></a></li>
<li><a href='#mcmcListExample'>
<p>An object of class <code>mcmc.list</code> produced by <code>rjags::coda.samples</code></p></a></li>
<li><a href='#mcmcOutput-class'>
<p>Conversion to class <code>mcmcOutput</code></p></a></li>
<li><a href='#plot.mcmcOutput'>
<p>Graphic display of marginal posterior probability distributions</p></a></li>
<li><a href='#postPriorOverlap'>
<p>Overlap between posterior and prior probability distributions.</p></a></li>
<li><a href='#summary.mcmcOutput'>
<p>Print and summary methods for objects of class <code>mcmcOutput</code></p></a></li>
<li><a href='#window.mcmcOutput'>
<p>Subsetting chains for <code>mcmcOutput</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions to Store, Manipulate and Display Markov Chain Monte
Carlo (MCMC) Output</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-16</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>HDInterval, coda, MASS</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mikemeredith/mcmcOutput">https://github.com/mikemeredith/mcmcOutput</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mikemeredith/mcmcOutput/issues">https://github.com/mikemeredith/mcmcOutput/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a class ('mcmcOutput') for efficiently storing and handling Markov chain Monte Carlo (MCMC) output, intended as an aid for those writing customized MCMC samplers. A range of constructor methods are provided covering common output formats. Functions are provided to generate summary and diagnostic statistics and to display histograms or density plots of posterior distributions, for the entire output, or subsets of draws, nodes, or parameters.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-16 11:29:29 UTC; User</td>
</tr>
<tr>
<td>Author:</td>
<td>Ngumbang Juat [cre],
  Mike Meredith [aut],
  John Kruschke [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ngumbang Juat &lt;ngumbangjuat@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-17 17:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='bigCrosscorr'>
Cross-correlations for MCMC output
</h2><span id='topic+bigCrosscorr'></span>

<h3>Description</h3>

<p>When MCMC output has hundreds of monitored nodes, the full cross-correlation matrix produced by <code>cor</code> is of little use. <code>bigCrossCorr</code> extracts and reports only those values greater than a given threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bigCrosscorr(x, big = 0.6, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bigCrosscorr_+3A_x">x</code></td>
<td>

<p>an object of any class with MCMC output that can be coerced to class <code>mcmcOutput</code>.
</p>
</td></tr>
<tr><td><code id="bigCrosscorr_+3A_big">big</code></td>
<td>

<p>only values below -big or above +big will be returned
</p>
</td></tr>
<tr><td><code id="bigCrosscorr_+3A_digits">digits</code></td>
<td>

<p>the number of decimal places to return
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 2 columns for the names of parameters and a 3rd column with the cross-correlation, sorted in order of decreasing absolute cross-correlation.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crosscorrPlot">crosscorrPlot</a></code>.
</p>

<hr>
<h2 id='crosscorrPlot'>
Plot image of correlation matrix
</h2><span id='topic+crosscorrPlot'></span>

<h3>Description</h3>

<p>Displays graphically the lower triangle of the correlation matrix among the columns of the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
crosscorrPlot(x, params=NULL, col, addSpace=c(0,0), ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crosscorrPlot_+3A_x">x</code></td>
<td>

<p>An object with MCMC chain values, of any class that can be coerced to <code>mcmcOutput</code>.
</p>
</td></tr>
<tr><td><code id="crosscorrPlot_+3A_params">params</code></td>
<td>

<p>An optional vector of column numbers or names; names are partially matched, so <code>params="alpha"</code> will match all of <code>alpha, alpha0, alpha[1], alphanew</code>; negative indices indicate parameters to exclude, positive and negative indices cannot be mixed.
</p>
</td></tr>
<tr><td><code id="crosscorrPlot_+3A_col">col</code></td>
<td>

<p>The colours to use to code the correlations; default is a blue-yellow-red ramp; NA correlations appear as white boxes.
</p>
</td></tr>
<tr><td><code id="crosscorrPlot_+3A_addspace">addSpace</code></td>
<td>

<p>A length-2 vector to add extra white space right and above the main display, eg, to provide extra space for long parameter names; units are the width of one box of the display. Unlike <code>mar</code>, this inserts space left of the legend and below the title.
</p>
</td></tr>
<tr><td><code id="crosscorrPlot_+3A_...">...</code></td>
<td>

<p>Additional graphical parameters, see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The usual graphical parameters can be added in the ... argument. Note the following:
</p>
<p>* <code>mar</code> : a vector of length 4 specifying the width of the margins below, left, above and right of the main plot; you will need to increase the margins to insert <code>xlab</code> or <code>ylab</code>; default <code>c(1,1,5,4)</code>; see the entry for <code>mar</code> at <code><a href="graphics.html#topic+par">par</a></code>.
</p>
<p>* <code>cex.axis</code> : controls the size of the parameter names, default 1.2.
</p>
<p>* <code>srt</code> : controls the rotation of the parameter names, 0 = horizontal, 90 = vertical, default 45.
</p>
<p>* <code>offset</code> : controls the distance of the start of the parameter names from the corner of the box in units of box width, default 0.2.
</p>
<p>* <code>tcl</code> : the length of the tick marks next to the parameter names in units of box widths, default 0.1.
</p>
<p>* <code>lwd.ticks</code> : line width for the tick marks, default 1.
</p>
<p>* <code>legendAsp</code> : aspect ratio for the legend, default 0.1.
</p>


<h3>Value</h3>

<p>Returns the correlation matrix invisibly.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a data frame of fake MCMC output:
mu0 &lt;- rnorm(3000)         # normal, mean zero
mu10 &lt;- rnorm(3000, rep(9:11, each=1000), 1) + mu0*0.5
  # approx normal, mean 10, correlated with mu0
fake &lt;- data.frame(
  mu0 = mu0,
  mu10 = mu10,
  sigma=rlnorm(3000),        # non-negative, skewed
  prob = plogis(1-mu0),      # probability, central mode, neg. correlation with mu0
  prob0 = rbeta(3000, 1,2),  # probability, mode = 0
  N = rpois(3000, rep(c(24, 18, 18), each=1000)),
                             # large integers (no zeros), poor mixing
  n = rpois(3000, 2),        # small integers (some zeros)
  const1 = rep(1, 3000))     # all values = 1
str(fake)

tmp &lt;- crosscorrPlot(fake)
round(tmp, 2)
crosscorrPlot(fake, main="Isn't this a really cool plot?")
crosscorrPlot(fake, main="A subset of parameters", params=c("mu", "prob", "N"))
crosscorrPlot(fake, main="Leave out 'sigma'", params=-3)
crosscorrPlot(fake, main="Just a few colours", col=c("blue","skyblue","pink","red"))
names(fake)[5] &lt;- "A_parameter_with_a_very_long_name"
crosscorrPlot(fake, main="Is there room?")
crosscorrPlot(fake, main="With addSpace=c(2,0)", addSpace=c(2,0))
</code></pre>

<hr>
<h2 id='densityFolded'>
Folded kernel density estimation
</h2><span id='topic+densityFolded'></span>

<h3>Description</h3>

<p>Parameters are often constrained to be greater than zero (eg, standard deviation) or within the range (0, 1) (eg, probabilities), but the function <code>density</code> often returns non-zero densities outside these ranges. Simple truncation does not work, as the area under the curve is &lt; 1. The function <code>densityFolded</code> attempts to identify these constraints and gives an appropriate density.
</p>
<p>If <code>x</code> is a matrix, detection of constraints and selection of bandwidth is applied to the pooled values, but a separate density curve is fitted to each column of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityFolded(x, bw = "nrd0", adjust = 1, from=NA, to=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="densityFolded_+3A_x">x</code></td>
<td>

<p>a numeric vector or matrix from which the estimate is to be computed; missing values not allowed. 
</p>
</td></tr>
<tr><td><code id="densityFolded_+3A_bw">bw</code></td>
<td>

<p>the smoothing bandwidth to be used; see <code><a href="stats.html#topic+density">density</a></code> for details.
</p>
</td></tr>
<tr><td><code id="densityFolded_+3A_adjust">adjust</code></td>
<td>

<p>the bandwidth used is actually <code>adjust*bw</code>.
</p>
</td></tr>
<tr><td><code id="densityFolded_+3A_from">from</code>, <code id="densityFolded_+3A_to">to</code></td>
<td>

<p>the lower and upper ends of the grid at which the density is to be estimated; if NA, range will cover the values in x; ignored and replaced with 0 or 1 if a constraint is detected.
</p>
</td></tr>
<tr><td><code id="densityFolded_+3A_...">...</code></td>
<td>

<p>other arguments passed to <code><a href="stats.html#topic+density">density</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following components:
</p>

<dl>
<dt>x </dt><dd><p>the n coordinates of the points where the density is estimated.</p>
</dd>
<dt>y	</dt><dd><p>a vector or matrix with the estimated density values.</p>
</dd>
<dt>bw </dt><dd><p>the bandwidth used.</p>
</dd>
<dt>n	</dt><dd><p>the sample size after elimination of missing values.</p>
</dd>
<dt>call </dt><dd><p>the call which produced the result.</p>
</dd>
<dt>data.name	</dt><dd><p>the deparsed name of the x argument.</p>
</dd>
</dl>

<p>If <code>y</code> is a vector, the output will have class <code><a href="stats.html#topic+density">density</a></code>.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)
oldpar &lt;- par(mfrow=2:1)

x1 &lt;- rnorm(1e4)            # no constraint on x1
plot(density(x1))
plot(densityFolded(x1))     # no difference

x2 &lt;- abs(rnorm(1e4))       # x2 &gt;= 0, with mode at 0
plot(density(x2))           # density &gt; 0 when x2 &lt; 0, mode around 0.2
abline(v=0, col='grey')
plot(densityFolded(x2))     # mode plotted correctly
abline(v=0, col='grey')

x3 &lt;- rbeta(1e4, 1.5, 1.5)  # 0 &lt;= x3 &lt;= 1
plot(density(x3))           # density &gt; 0 when x2 &lt; 0 and x2 &gt; 1
abline(v=0:1, col='grey')
plot(densityFolded(x3))
abline(v=0:1, col='grey')

x4 &lt;- rbeta(1e4, 1.5, 0.9)  # 0 &lt;= x4 &lt;= 1, with mode at 1
plot(density(x4))           # mode appears to be around 0.95
abline(v=0:1, col='grey')
plot(densityFolded(x4))     # mode plotted correctly
abline(v=0:1, col='grey')

# Try with a matrix
x5 &lt;- cbind(rbeta(1e4, 2,2), rbeta(1e4, 2,3), rbeta(1e4, 3,2))
plot(density(x5))
tmp &lt;- densityFolded(x5)
with(tmp, matplot(x, y, type='l'))

par(oldpar)
</code></pre>

<hr>
<h2 id='diagPlot'>
Diagnostic graphics for class <code>mcmcOutput</code>
</h2><span id='topic+diagPlot'></span><span id='topic+tracePlot'></span><span id='topic+densityPlot'></span><span id='topic+acfPlot'></span>

<h3>Description</h3>

<p>Display trace plots and density plots for the chains in the MCMC output. Each chain is plotted with a different colour. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagPlot(object, params, howMany, chains,
  maxRows=4, RhatBad=1.05, precision=c("MCEpc", "n.eff"), ask=NULL, ...)

tracePlot(object, layout=c(3,3), ask=NULL, ...)
densityPlot(object, layout=c(3,3), ask=NULL, ...)
acfPlot(object, lag.max=NULL, layout=c(3,3), ask=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagPlot_+3A_object">object</code></td>
<td>

<p>An object of any class with MCMC output that can be coerced to class <code>mcmcOutput</code>.
</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_params">params</code></td>
<td>

<p>An optional vector of column numbers or names; names are partially matched, so <code>params="alpha"</code> will match all of <code>alpha, alpha0, alpha[1], alphanew</code>; negative indices indicate parameters to exclude, positive and negative indices cannot be mixed.
</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_howmany">howMany</code></td>
<td>

<p>How many draws per chain to plot; if negative, the draws at the end of the chains will be plotted; default is to plot all.
</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_chains">chains</code></td>
<td>

<p>Which chains to plot, a numeric vector; default is to plot all.
</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_maxrows">maxRows</code></td>
<td>

<p>Maximum number of rows to display in one window; each row consists of a trace plot
and a density plot for one parameter.
</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_rhatbad">RhatBad</code></td>
<td>

<p>Threshold for Rhat; parameters with <code>Rhat &gt; RhatBad</code> are highlighted in red.
</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_precision">precision</code></td>
<td>

<p>The statistic to use for the precision, displayed above the density plot.
</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_layout">layout</code></td>
<td>

<p>a length-2 vector with the maximum number of rows and columns to display in the plotting frame.
</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_lag.max">lag.max</code></td>
<td>

<p>Maximum lag at which to calculate the acf.
</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_ask">ask</code></td>
<td>

<p>If <code>TRUE</code> and the number of parameters to plot is greater than <code>maxRows</code>, the user will be prompted before the next page of output is displayed. The default is to ask if the plotting device is the screen, not if it is a file.
</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_...">...</code></td>
<td>

<p>Additional graphical parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return nothing, used for their plotting side effects.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crosscorrPlot">crosscorrPlot</a></code>, <code><a href="#topic+postPlot">postPlot</a></code> for a histogram and summary statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a fake mcmcOutput object:
tmp &lt;- cbind(
  mu0 = rnorm(3000),         # normal, mean zero
  mu10 = rnorm(3000, rep(9:11, each=1000), 1),
                             # normal, mean 10, but poor mixing
  sigma=rlnorm(3000),        # non-negative, skewed
  `prob[1,1]` = rbeta(3000, 4, 4),  # probability, central mode
  `prob[1,2]` = 0.3,         # constant
  `prob[2,1]` = rbeta(3000, 1, 3),  # probability, mode = 0
  N = rpois(3000, rep(c(24, 18, 18), each=1000)),
                             # large integers (no zeros), poor mixing
  n = rpois(3000, 2),        # small integers (some zeros)
  allNA = NA,                # all values NA
  someNA = suppressWarnings(log(rnorm(3000, 2, 2))),
                             # some NaNs
  const1 = rep(1, 3000),     # all values = 1
  const3.2 = rep(10/3, 3000))# all values the same but not integer
( fake &lt;- mcmcOutput(tmp, nChains = 3) )
summary(fake)
diagPlot(fake)
diagPlot(fake, params=3:6, main="params = 3:6")
diagPlot(fake, params=c("mu", "prob"), main="params = c('mu', 'prob')")
diagPlot(fake, params=c("mu", "prob"), howMany=200, main="howMany = 200")
diagPlot(fake, params=c("mu", "prob"), howMany=50, main="howMany = 50")
diagPlot(fake, params=c("mu", "prob"), howMany=-200, main="howMany = -200")
diagPlot(fake, params=c("mu", "prob"), chains=1:2, main="chains = 1:2")
diagPlot(fake, params=c("mu", "prob"), chains=2, main="chains = 2") # 1 chain -&gt; no Rhat

tracePlot(fake, layout=c(2,2))
densityPlot(fake, xlab="value")
acfPlot(fake, lag.max=10, lwd=2)

# Use diagPlot with an mcmc.list object
data(mcmcListExample)
diagPlot(mcmcListExample)
diagPlot(mcmcListExample, main="example", params=1:3, precision="n.eff")

</code></pre>

<hr>
<h2 id='discrepancyPlot'>
Graphic comparison of observed vs simulated discrepancies
</h2><span id='topic+discrepancyPlot'></span>

<h3>Description</h3>

<p>One way to assess the fit of a model is to calculate the discrepancy between the observed data and the values predicted by the model. For binomial and count data, the discrepancy will not be zero because the data are integers while the predictions are continuous. To assess whether the observed discrepancy is acceptable, we simulate new data according to the model and calculate discrepancies for the simulated data.
</p>
<p>Function <code>discrepancyPlot</code> produces a scatter plot of the MCMC chains for observed vs simulated discrepancies and calculates and displays a p-value, the proportion of simulated discrepancy values that exceed the observed discrepancy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrepancyPlot(object, observed, simulated, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discrepancyPlot_+3A_object">object</code></td>
<td>

<p>An object of class <code>mcmcOutput</code>, or an object which can be coerced to <code>mcmcOutput</code>, with MCMC chains for observed and simulated discrepancies.
</p>
</td></tr>
<tr><td><code id="discrepancyPlot_+3A_observed">observed</code></td>
<td>

<p>character; the name of the parameter for the observed discrepancy.
</p>
</td></tr>
<tr><td><code id="discrepancyPlot_+3A_simulated">simulated</code></td>
<td>

<p>character; the name of the parameter for the simulated discrepancies.
</p>
</td></tr>
<tr><td><code id="discrepancyPlot_+3A_...">...</code></td>
<td>

<p>additional graphical parameters passed to the <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the proportion of simulated discrepancy values that exceed the observed discrepancy, often referred to as a &quot;Bayesian p-value&quot;.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get some data
data(mcmcListExample)
( mco &lt;- mcmcOutput(mcmcListExample) )
# Tobs and Tsim are the Freeman-Tukey discrepancy measures

discrepancyPlot(mco, observed="Tobs", simulated="Tsim") # defaults
discrepancyPlot(mco, observed="Tobs", simulated="Tsim",
    main="Salamanders", col='red')
</code></pre>

<hr>
<h2 id='Get+20diagnostics'>
Get diagnostic statistics
</h2><span id='topic+getMCE'></span><span id='topic+getNeff'></span><span id='topic+getRhat'></span>

<h3>Description</h3>

<p>These functions calculated diagnostic statistics for objects of class <code>mcmcOutput</code>. Optionally, only values that are worse than a predefined threshold will be returned, and values can be sorted so that the worst are at the start of the output vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMCE(x, pc=TRUE, bad=5, sort=TRUE)
getNeff(x, bad=10000, sort=TRUE)
getRhat(x, bad=1.1, sort=TRUE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Get+2B20diagnostics_+3A_x">x</code></td>
<td>

<p>an object of any class with MCMC output that can be coerced to class <code>mcmcOutput</code>.
</p>
</td></tr>
<tr><td><code id="Get+2B20diagnostics_+3A_pc">pc</code></td>
<td>

<p>if TRUE, the value of the MC error as a percentage of the posterior SD will be returned.
</p>
</td></tr>
<tr><td><code id="Get+2B20diagnostics_+3A_bad">bad</code></td>
<td>

<p>threshold for &quot;bad&quot; values: only values above this (for <code>getMCE</code> or <code>getRhat</code>) or below this (for <code>getNeff</code>) will be returned. If <code>bad = NA</code>, all values will be returned, including NAs.
</p>
</td></tr>
<tr><td><code id="Get+2B20diagnostics_+3A_sort">sort</code></td>
<td>

<p>if TRUE, the values will be sorted, with the worst at the top.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getRhat</code> returns the Brooks-Gelman-Rubin (BGR) convergence diagnostic (Brooks &amp; Gelman 1998), a non-parametric 'interval' estimator of the 'potential scale reduction factor' for MCMC output. Similar to the function <code>coda::gelman.diag</code>, but faster when thousands of parameters are involved and will not cause R to crash.
</p>
<p><code>getMCE</code> returns the Monte Carlo standard error calculated using the batch method of Lunn et al (2013, p77); see also Roberts (1996).
</p>
<p><code>getNeff</code> returns the effective number of draws taking account of autocorrelation within each chain. It is a wrapper for <code>coda::effectiveSize</code>.
</p>


<h3>Value</h3>

<p>A named vector with the values of the diagnostic. Values of NA will be excluded unless <code>bad = NA</code>. It may have length 0 if no values are bad.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith
</p>


<h3>References</h3>

<p>Brooks, S.P. &amp; Gelman, A. (1998) General methods for monitoring convergence of iterative simulations. <em>Journal of Computational and Graphical Statistics</em>, 7, 434-455.
</p>
<p>Lunn, D., Jackson, C., Best, N., Thomas, A., &amp; Spiegelhalter, D. (2013) <em>The BUGS book: a practical introduction to Bayesian analysis</em>, Chapman and Hall.
</p>
<p>Roberts, G.O. (1996). Markov chain concepts related to sampling algorithms. In <em>Markov Chain Monte Carlo in practice</em> (eds W.R. Gilks, D.J. Spiegelhalter &amp; S. Richardson). Chapman &amp; Hall, London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mcmcListExample)
mco &lt;- mcmcOutput(mcmcListExample)

getMCE(mco, bad=2)
getMCE(mco, bad=0)  # returns all except NAs
getMCE(mco, bad=NA)  # returns all including NAs
getMCE(mco, bad=NA, sort=FALSE)  # returns all, in original order

getNeff(mco, bad=2800)
getNeff(mco, bad=Inf)  # returns all except NAs
getNeff(mco, bad=NA)   # returns all including NAs

getRhat(mco)
getRhat(mco, bad=0)
getRhat(mco, bad=NA, sort=FALSE)

# Extract the values with 'bad' MCE and do plots:
( badNodes &lt;- names(getMCE(mco, bad=2)) )
( badMco &lt;- mco[badNodes] )
plot(badMco)
</code></pre>

<hr>
<h2 id='mcmcListExample'>
An object of class <code>mcmc.list</code> produced by <code>rjags::coda.samples</code>
</h2><span id='topic+mcmcListExample'></span>

<h3>Description</h3>

<p>This is the output of a basic occupancy model applied to detection/non-detection data for blue ridge salamanders (<em>Eurycea wilderae</em>) in Great Smoky Mountains National Park (MacKenzie et al, 2006 p99). Detections were recorded for 5 visits to each of 39 sites, and the data are the number of visits where the species was detected.
</p>
<p>The model has five parameters:
</p>

<dl>
<dt>psi </dt><dd><p>scalar, the probability of occupancy.</p>
</dd>
<dt>p </dt><dd><p><code>p[1,1]</code> is the probability of detection given presence; <code>p[2,2]</code> is a dummy variable with values drawn from a Beta(0.5,0.5) distribution; <code>p[1,2]</code> and <code>p[2,1]</code> are not defined, so <code>p</code> is a &quot;ragged array&quot;.</p>
</dd>
<dt>z </dt><dd><p>a vector of length 39, one value for each site.</p>
</dd>
<dt>Tobs </dt><dd><p>scalar, the Freeman-Tukey discrepancy for the observed data.</p>
</dd>
<dt>Tsim </dt><dd><p>scalar, the Freeman-Tukey discrepancy for the simulated data.</p>
</dd>
</dl>

<p>The number of nodes monitored is 44 (<code>p[1,2]</code> and <code>p[2,1]</code> are not monitored).
</p>
<p>Three MCMC chains were run, with 1000 adaptation iterations, 1000 burn-in, and 1000 iterations saved per chain after thinning by 10.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mcmcListExample")</code></pre>


<h3>Format</h3>

<p><code>mcmcListExample</code> is <code>mcmc.list</code> object as defined in package <span class="pkg">coda</span>.
</p>


<h3>References</h3>

<p>MacKenzie, D I; J D Nichols; A J Royle; K H Pollock; L L Bailey; J E Hines 2006. <em>Occupancy estimation and modeling : inferring patterns and dynamics of species occurrence</em>. Elsevier Publishing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mcmcListExample)
str(mcmcListExample)

# convert to class mcmcOutput
( mco &lt;- mcmcOutput(mcmcListExample) )
summary(mco)

# Extract with "$"
p &lt;- mco$p
str(p)
p[1:5,,]  # Elements of p not defined in the model are filled with NAs

# "[" with one index, produces new mcmcOutput object
head(mco[4:5])
print(mco[c("z[35]", "z[39]")])

# "[" with two indices
mco[1:5, "psi"]  # First 5 values for psi (chain #1)

# "[" with three indices
mco[1:5, 2, "psi"] # First 5 values for psi in chain #2

</code></pre>

<hr>
<h2 id='mcmcOutput-class'>
Conversion to class <code>mcmcOutput</code>
</h2><span id='topic+mcmcOutput-class'></span><span id='topic+mcmcOutput'></span><span id='topic+mcmcOutput.default'></span><span id='topic+mcmcOutput.mcmc.list'></span><span id='topic+mcmcOutput.mcmc'></span><span id='topic+mcmcOutput.jagsUI'></span><span id='topic+mcmcOutput.bugs'></span><span id='topic+mcmcOutput.rjags'></span><span id='topic+mcmcOutput.runjags'></span><span id='topic+mcmcOutput.matrix'></span><span id='topic+mcmcOutput.data.frame'></span>

<h3>Description</h3>

<p>Convert output containing MCMC chains to the class <code>mcmcOutput</code>. The function is generic, with methods for a range of input objects.
</p>
<p><code>print</code>, <code><a href="#topic+summary.mcmcOutput">summary</a></code>, <code><a href="#topic+plot.mcmcOutput">plot</a></code> and <code><a href="#topic+window.mcmcOutput">window</a></code> methods are available for the class. See also <code><a href="#topic+postPlot">postPlot</a></code>, <code><a href="#topic+discrepancyPlot">discrepancyPlot</a></code>, <code><a href="#topic+crosscorrPlot">crosscorrPlot</a></code>, <code><a href="#topic+postPriorOverlap">postPriorOverlap</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcOutput(object, ...)

## Default S3 method:
mcmcOutput(object, ...)

## S3 method for class 'mcmc.list'
mcmcOutput(object, header, ...)

## S3 method for class 'mcmc'
mcmcOutput(object, header, ...)

## S3 method for class 'jagsUI'
mcmcOutput(object, header, ...)

## S3 method for class 'bugs'
mcmcOutput(object, header, ...)

## S3 method for class 'rjags'
mcmcOutput(object, header, ...)

## S3 method for class 'runjags'
mcmcOutput(object, header, ...)

## S3 method for class 'matrix'
mcmcOutput(object, nChains=1, header, ...)

## S3 method for class 'data.frame'
mcmcOutput(object, nChains=1, header, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmcOutput-class_+3A_object">object</code></td>
<td>

<p>an object containing the MCMC chains; see Details.
</p>
</td></tr>
<tr><td><code id="mcmcOutput-class_+3A_header">header</code></td>
<td>

<p>text to use as the header by <code>print</code> and <code>summary</code> methods.
</p>
</td></tr>
<tr><td><code id="mcmcOutput-class_+3A_nchains">nChains</code></td>
<td>

<p>the number of chains.
</p>
</td></tr>
<tr><td><code id="mcmcOutput-class_+3A_...">...</code></td>
<td>

<p>named arguments to be passed to other methods (currently not used).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mcmcOutput</code> objects store the output from MCMC estimation runs in a compact and easily accessible format. Several customised extraction methods are available:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>$</code> </td><td style="text-align: left;">  : extracts arrays for individual parameters in the same way as a <code>sims.list</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>[</code> with 1 index </td><td style="text-align: left;">  : returns a new <code>mcmcOutput</code> object with the selected node(s). </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>[</code> with 2 indices </td><td style="text-align: left;">  : returns the selected row(s) and columns(s). </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>[</code> with 3 indices </td><td style="text-align: left;">  : behaves as an iterations x chains x nodes array.</td>
</tr>

</table>



<h3>Value</h3>

<p>An object of class <code>mcmcOutput</code>. This is a matrix with a column for the MCMC chain for each node monitored. The first 2 attributes in the list below must be present, the rest are optional but may be used by <code>print</code> or <code>summary</code> methods:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>nChains</code> </td><td style="text-align: left;">  the number of chains. </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>simsList</code> </td><td style="text-align: left;">  a list specifying which columns correspond to each parameter. </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>header</code> </td><td style="text-align: left;"> text to be displayed as the first line when the object is printed. </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>call</code> </td><td style="text-align: left;"> the original function call. </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>modelFile</code> </td><td style="text-align: left;"> the name of the original model file. </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>timeTaken</code> </td><td style="text-align: left;"> the time taken in seconds for the MCMC run. </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>runDate</code> </td><td style="text-align: left;"> an object of class <code>POSIXct</code> with the date of the MCMC run. </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Mike Meredith.
</p>

<hr>
<h2 id='plot.mcmcOutput'>
Graphic display of marginal posterior probability distributions
</h2><span id='topic+plot.mcmcOutput'></span><span id='topic+postPlot'></span>

<h3>Description</h3>

<p>Plot the posterior probability distribution(s) for the nodes of a <code>mmcmcOutput</code> object. <code>postPlot</code> is equivalent to <code>plot(mcmcOutput(object))</code>.
</p>
<p><em>Note the new argument <code>center</code> with options to display the mean, median or mode; this replaces the <code>showMode</code> argument. The argument <code>CRImass</code> replaces <code>credMass</code>.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcOutput'
plot(x, params, layout=c(3,3),
    center = c("mean", "median", "mode"), CRImass=0.95,
    compVal = NULL, ROPE = NULL, HDItextPlace = 0.7,
    showCurve = FALSE, shadeHDI = NULL, ...)


postPlot(object, params, layout=c(3,3),
    center = c("mean", "median", "mode"), CRImass=0.95,
    compVal = NULL, ROPE = NULL, HDItextPlace = 0.7,
    showCurve = FALSE, shadeHDI = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mcmcOutput_+3A_x">x</code></td>
<td>

<p>An object of class <code>mcmcOutput</code>.
</p>
</td></tr>
<tr><td><code id="plot.mcmcOutput_+3A_object">object</code></td>
<td>

<p>An object of any class that can be coerced to class <code>mcmcOutput</code>.
</p>
</td></tr>
<tr><td><code id="plot.mcmcOutput_+3A_params">params</code></td>
<td>

<p>An optional vector of column numbers or names; names are partially matched, so <code>params="alpha"</code> will match all of <code>alpha, alpha0, alpha[1], alphanew</code>; negative indices indicate parameters to exclude, positive and negative indices cannot be mixed.
</p>
</td></tr>
<tr><td><code id="plot.mcmcOutput_+3A_layout">layout</code></td>
<td>

<p>a length-2 vector with the maximum number of rows and columns to display in the plotting frame.
</p>
</td></tr>
<tr><td><code id="plot.mcmcOutput_+3A_center">center</code></td>
<td>

<p>the statistic to use to represent the central tendency.
</p>
</td></tr>
<tr><td><code id="plot.mcmcOutput_+3A_crimass">CRImass</code></td>
<td>

<p>the probability mass to include in credible intervals; set this to NULL to suppress plotting of credible intervals.
</p>
</td></tr>
<tr><td><code id="plot.mcmcOutput_+3A_compval">compVal</code></td>
<td>

<p>a single value for comparison with those plotted; the same value will be used for all the plots.
</p>
</td></tr>
<tr><td><code id="plot.mcmcOutput_+3A_rope">ROPE</code></td>
<td>

<p>a two element vector, such as <code>c(-1, 1)</code>, specifying the limits of the Region Of Practical Equivalence; the same value will be used for all the plots.
</p>
</td></tr>
<tr><td><code id="plot.mcmcOutput_+3A_hditextplace">HDItextPlace</code></td>
<td>

<p>a value in [0,1] that controls the horizontal position of the labels at the ends of the HDI bar.
</p>
</td></tr>
<tr><td><code id="plot.mcmcOutput_+3A_showcurve">showCurve</code></td>
<td>

<p>logical: if TRUE, the posterior density will be represented by a kernel density function instead of a histogram.
</p>
</td></tr>
<tr><td><code id="plot.mcmcOutput_+3A_shadehdi">shadeHDI</code></td>
<td>

<p>specifies a colour to shade the area under the curve corresponding to the HDI; NULL for no shading. Ignored if <code>showCurve = FALSE</code>. Use <code>colours()</code> to see a list of possible colours.
</p>
</td></tr>
<tr><td><code id="plot.mcmcOutput_+3A_...">...</code></td>
<td>

<p>graphical parameters and the <code>breaks</code> parameter for the histogram.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data are plotted either as a histogram (above) or, if <code>showCurve = TRUE</code>, as a fitted kernel density curve (below). The mean, median or mode of the distribution is displayed, depending on the parameter <code>center</code>. The Highest Density Interval (HDI) is shown as a horizontal bar, with labels for the ends of the interval.
</p>
<p><img src="../help/figures/plotPost1.jpg" alt="plotPost1.jpg" /> <br />
<br />
<img src="../help/figures/plotPost2.jpg" alt="plotPost2.jpg" />
</p>
<p>If a comparison value (<code>compVal</code>) is supplied, this is shown as a vertical green dotted line, together with the probability mass below and above this value. If values for a ROPE are supplied, these are shown as dark red vertical dashed lines, together with the percentage of probability mass within the ROPE.
</p>


<h3>Value</h3>

<p>Returns nothing. Used for its plotting side-effect.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith, based on code by John Kruschke.
</p>


<h3>See Also</h3>

<p>For details of the HDI calculation, see <code>hdi</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the example data set
data(mcmcListExample)
mco &lt;- mcmcOutput(mcmcListExample)
plot(mco)
plot(mco, "p")   # plots p[1,1], p[2,2] and psi
plot(mco, "p[")  # plots p[1,1] and p[2,2], not psi

# Generate some data
normal &lt;- rnorm(1e5, 2, 1)
postPlot(normal)
postPlot(normal, col='wheat', border='magenta')
postPlot(normal, CRImass=0.8, compVal=0, ROPE=c(-0.2,0.2),
    xlab="Response variable")
postPlot(normal, center="mode", showCurve=TRUE, compVal=5.5)

# For integers:
integers &lt;- rpois(1e5, 12)
postPlot(integers)

# A severely bimodal distribution:
bimodal &lt;- c(rnorm(1e5), rnorm(5e4, 7))
postPlot(bimodal)                  # A valid 95% CrI, but not HDI
postPlot(bimodal, showCurve=TRUE)  # Correct 95% HDI
postPlot(bimodal, showCurve=TRUE, shadeHDI='pink')

</code></pre>

<hr>
<h2 id='postPriorOverlap'>
Overlap between posterior and prior probability distributions.
</h2><span id='topic+postPriorOverlap'></span>

<h3>Description</h3>

<p>Calculates and displays the overlap between a posterior distribution (as a vector of values, typically draws from an MCMC process) and a prior distribution (as a vector of values or as a function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postPriorOverlap(x, prior, priorPars, breaks=NULL,
           hcols=c("skyblue", "yellow", "green", "white"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="postPriorOverlap_+3A_x">x</code></td>
<td>

<p>a vector of values drawn from the target distribution.
</p>
</td></tr>
<tr><td><code id="postPriorOverlap_+3A_prior">prior</code></td>
<td>

<p><em>either</em> a vector of values drawn from the prior distribution <em>or</em> the name for the density function of the distribution; standard R functions for this have a <code>d-</code> prefix, eg. <code>dbeta</code>.
</p>
</td></tr>
<tr><td><code id="postPriorOverlap_+3A_priorpars">priorPars</code></td>
<td>

<p>a named list of parameters to be passed to <code>prior</code> when it is a function ; see the examples. Ignored if <code>prior</code> is a numeric vector.
</p>
</td></tr>
<tr><td><code id="postPriorOverlap_+3A_breaks">breaks</code></td>
<td>

<p>controls the histogram break points or the number of bars; see <code><a href="graphics.html#topic+hist">hist</a></code>.
</p>
</td></tr>
<tr><td><code id="postPriorOverlap_+3A_hcols">hcols</code></td>
<td>

<p>a vector of four colours for the histograms: posterior, prior, overlap, and borders. See the Color Specification section of <code><a href="graphics.html#topic+par">par</a></code>
</p>
</td></tr>
<tr><td><code id="postPriorOverlap_+3A_...">...</code></td>
<td>

<p>other graphical parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the overlap, the area lying under the lower of the two density curves.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data
foo &lt;- rbeta(1e4, 5, 7)

# check overlap with a Beta(0.2, 0.2) prior:
postPriorOverlap(foo, dbeta, list(shape1=0.2, shape2=0.2))

# check overlap with a Uniform(0, 1) prior:
postPriorOverlap(foo, runif(1e6))
</code></pre>

<hr>
<h2 id='summary.mcmcOutput'>
Print and summary methods for objects of class <code>mcmcOutput</code>
</h2><span id='topic+summary.mcmcOutput'></span><span id='topic+sumryList'></span><span id='topic+print.mcmcOutput'></span>

<h3>Description</h3>

<p><code>summary</code> generates a data frame with summary and diagnostic statistics for each of the MCMC chains in the <code>mcmcOutput</code> object, and (if <code>verbose = TRUE</code>) prints a brief overview to the Console. The data frame will be displayed in the Console unless assigned to an object or passed to <code>View</code>.
</p>
<p><code>sumryList</code> generates summary and diagnostic statistics for each of the MCMC chains in the <code>mcmcOutput</code> object and returns them as a list-of-lists, see Value.
</p>
<p><em><code>summary</code> and <code>sumryList</code> now have a <code>CRItype="none"</code> option and arguments to include <code>overlap0</code> and <code>f</code> in the summary table.</em>
</p>
<p><code>print</code> displays characteristics of the <code>mcmcOutput</code> object. It does <em>not</em> display summaries of the values: for that use <code>summary</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcOutput'
summary(object, digits=3, median=TRUE, mode=FALSE,
    CRItype=c("hdi", "symmetrical", "none"),
    CRImass=0.95, Rhat=TRUE, MCEpc = TRUE, n.eff=FALSE,
    overlap0=FALSE, f=FALSE, verbose=TRUE, ...)

## S3 method for class 'mcmcOutput'
print(x, ...)

sumryList(object, median=TRUE, mode=FALSE,
    CRItype=c("hdi", "symmetrical", "none"),
    CRImass=0.95, Rhat=TRUE, MCEpc = TRUE, n.eff=FALSE,
    overlap0=FALSE, f=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mcmcOutput_+3A_x">x</code>, <code id="summary.mcmcOutput_+3A_object">object</code></td>
<td>

<p>an object of class <code>mcmcOutput</code>.
</p>
</td></tr>
<tr><td><code id="summary.mcmcOutput_+3A_digits">digits</code></td>
<td>

<p>the number of digits for rounding of values in the output.
</p>
</td></tr>
<tr><td><code id="summary.mcmcOutput_+3A_median">median</code></td>
<td>

<p>if TRUE, the median will be included as a column in the data frame produced.
</p>
</td></tr>
<tr><td><code id="summary.mcmcOutput_+3A_mode">mode</code></td>
<td>

<p>if TRUE, the mode will be included as a column in the data frame produced.
</p>
</td></tr>
<tr><td><code id="summary.mcmcOutput_+3A_critype">CRItype</code></td>
<td>

<p>if <code>hdi</code>, the credible interval will be a highest density interval; if <code>symmetrical</code>, a symmetrical CRI will be generated with <code>quantile</code>; ignored if <code>CRImass=NA</code>.
</p>
</td></tr>
<tr><td><code id="summary.mcmcOutput_+3A_crimass">CRImass</code></td>
<td>

<p>the probability mass to include in the credible interval; if <code>CRImass=NA</code>, no CRI will be included in the output.
</p>
</td></tr>
<tr><td><code id="summary.mcmcOutput_+3A_rhat">Rhat</code></td>
<td>

<p>if TRUE, estimates of Rhat will be included; ignored if only 1 chain or &lt; 100 values per chain. See <code><a href="#topic+getRhat">getRhat</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.mcmcOutput_+3A_mcepc">MCEpc</code></td>
<td>

<p>if TRUE, estimates of the Monte Carlo standard error as a percentage of the posterior SD will be included; ignored if &lt; 100 values per chain. See <code><a href="#topic+getMCE">getMCE</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.mcmcOutput_+3A_n.eff">n.eff</code></td>
<td>

<p>if TRUE, estimates of the effective number of draws allowing for autocorrelation will be included; ignored if &lt; 100 values per chain. See <code><a href="#topic+getNeff">getNeff</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.mcmcOutput_+3A_overlap0">overlap0</code></td>
<td>

<p>if TRUE, a column with TRUE/FALSE will be included, indicating whether the credible interval includes zero. Ignored if no CRI is calculated.
</p>
</td></tr>
<tr><td><code id="summary.mcmcOutput_+3A_f">f</code></td>
<td>

<p>if TRUE, a column with the proportion of the posterior with the same sign as the mean.
</p>
</td></tr>
<tr><td><code id="summary.mcmcOutput_+3A_verbose">verbose</code></td>
<td>

<p>if FALSE, suppresses output to the Console, other than the table of statistics.
</p>
</td></tr>
<tr><td><code id="summary.mcmcOutput_+3A_...">...</code></td>
<td>

<p>further arguments for the print or summary function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>print</code> returns <code>x</code> invisibly.
</p>
<p><code>summary</code> returns a data frame with columns for summary and diagnostic statistics and a row for each node; mean and SD are always included, other columns if selected. It has attributes for <code>nChains</code> and <code>simsList</code> derived from the input object. The output will appear in the Console unless assigned to an object or passed to <code>View</code>.
</p>
<p><code>sumryList</code> returns a list with a component for each statistic; each component is itself a list with the values for each parameter. See examples.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mcmcListExample)
mco &lt;- mcmcOutput(mcmcListExample)
mco  # equivalent to ...
print(mco)
summary(mco)
# just the summary data frame
summary(mco, verbose=FALSE)
# assign the output to an object
tmp &lt;- summary(mco, median=FALSE, CRItype="sym", CRImass=0.8,
    n.eff=TRUE, MCEpc=FALSE)
tmp

mcos &lt;- sumryList(mco)
str(mcos)
mcos$mean$p
mcos$MCEpc$z
</code></pre>

<hr>
<h2 id='window.mcmcOutput'>
Subsetting chains for <code>mcmcOutput</code> objects
</h2><span id='topic+window.mcmcOutput'></span>

<h3>Description</h3>

<p>The <code>window</code> method extracts the subset of the draws between <code>start</code> and <code>end</code>. Setting <code>thin = k</code> selects every <code>k</code>th observation starting from <code>start</code>.
</p>
<p>Use <code>window</code> to discard additional draws at the start of the chain if extra burn-in is required, or to reduce the size of the object by thinning. See the examples.
</p>
<p>Any previous burn-in or thinning is ignored (unlike the <code>coda::window.mcmc</code> method).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcOutput'
window(x, start=1, end=NULL, thin=1, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="window.mcmcOutput_+3A_x">x</code></td>
<td>

<p>an object of class <code>mcmcOutput</code>.
</p>
</td></tr>
<tr><td><code id="window.mcmcOutput_+3A_start">start</code></td>
<td>

<p>the first observation to retain.
</p>
</td></tr>
<tr><td><code id="window.mcmcOutput_+3A_end">end</code></td>
<td>

<p>the last observation to retain; if NULL, this is set to the end of the chain.
</p>
</td></tr>
<tr><td><code id="window.mcmcOutput_+3A_thin">thin</code></td>
<td>

<p>the interval between retained observations.
</p>
</td></tr>
<tr><td><code id="window.mcmcOutput_+3A_...">...</code></td>
<td>

<p>further arguments for other methods (not used).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>mcmcOutput</code> with the subset of observations.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mcmcListExample)
mco &lt;- mcmcOutput(mcmcListExample)
mco

new1 &lt;- window(mco, start=201) # Discard the first 200 draws in each chain
new1  # Now only 800 per chain.

new2 &lt;- window(mco, thin=3) # Retain only 1/3 of the draws
new2  # new2 is smaller; each chain reduced from 1000 to 333, total draws 999.

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
