<!DOCTYPE html><html><head><title>Help for package fairadapt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fairadapt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fairadapt-package'><p>fairadapt: Fair Data Adaptation with Quantile Preservation</p></a></li>
<li><a href='#adaptedData'><p>Convenience function for returning adapted data</p></a></li>
<li><a href='#compas'><p>COMPAS dataset.</p></a></li>
<li><a href='#computeQuants'><p>Compute Quantiles generic for the Quantile Learning step.</p></a></li>
<li><a href='#fairadapt'><p>Fairadapt</p></a></li>
<li><a href='#fairadaptBoot'><p>Fairadapt Boostrap wrapper</p></a></li>
<li><a href='#fairTwins'><p>Fair Twin Inspection convenience function.</p></a></li>
<li><a href='#gov_census'><p>Census information of US government employees.</p></a></li>
<li><a href='#graphModel'><p>Obtaining the graphical causal model (GCM)</p></a></li>
<li><a href='#predict.fairadapt'><p>Prediction function for new data from a saved <code>fairadapt</code> object.</p></a></li>
<li><a href='#predict.fairadaptBoot'><p>Prediction function for new data from a saved <code>fairadaptBoot</code> object.</p></a></li>
<li><a href='#quantFit'><p>Quality of quantile fit statistics.</p></a></li>
<li><a href='#rangerQuants'><p>Quantile Engine Constructor for the Quantile Learning step.</p></a></li>
<li><a href='#uni_admission'><p>University admission data of 1,000 students.</p></a></li>
<li><a href='#visualizeGraph'><p>Visualize Graphical Causal Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fair Data Adaptation with Quantile Preservation</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the fair data adaptation with quantile
    preservation described in Plecko &amp; Meinshausen (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1911.06685">doi:10.48550/arXiv.1911.06685</a>&gt;.
    The adaptation procedure uses the specified causal graph to pre-process the
    given training and testing data in such a way to remove the bias caused by
    the protected attribute. The procedure uses tree ensembles for quantile
    regression.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.7</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dplecko/fairadapt">https://github.com/dplecko/fairadapt</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dplecko/fairadapt/issues">https://github.com/dplecko/fairadapt/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ranger (&ge; 0.13.1), assertthat, quantreg, qrnn, igraph,
ggplot2, cowplot, scales</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.3), knitr, rmarkdown, rticles, mvtnorm,
magick, ggraph, pdftools, microbenchmark, xtable</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-09 18:13:59 UTC; dragoplecko</td>
</tr>
<tr>
<td>Author:</td>
<td>Drago Plecko [aut, cre],
  Nicolas Bennett [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Drago Plecko &lt;drago.plecko@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-09 18:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='fairadapt-package'>fairadapt: Fair Data Adaptation with Quantile Preservation</h2><span id='topic+fairadapt-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>An implementation of the fair data adaptation with quantile preservation described in Plecko &amp; Meinshausen (2019) <a href="https://arxiv.org/abs/1911.06685">arXiv:1911.06685</a>. The adaptation procedure uses the specified causal graph to pre-process the given training and testing data in such a way to remove the bias caused by the protected attribute. The procedure uses tree ensembles for quantile regression.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Drago Plecko <a href="mailto:drago.plecko@stat.math.ethz.ch">drago.plecko@stat.math.ethz.ch</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Nicolas Bennett <a href="mailto:nicolas.bennett@stat.math.ethz.ch">nicolas.bennett@stat.math.ethz.ch</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/dplecko/fairadapt">https://github.com/dplecko/fairadapt</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/dplecko/fairadapt/issues">https://github.com/dplecko/fairadapt/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adaptedData'>Convenience function for returning adapted data</h2><span id='topic+adaptedData'></span><span id='topic+adaptedData.fairadapt'></span><span id='topic+adaptedData.fairadaptBoot'></span>

<h3>Description</h3>

<p>Convenience function for returning adapted data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptedData(x, train = TRUE)

## S3 method for class 'fairadapt'
adaptedData(x, train = TRUE)

## S3 method for class 'fairadaptBoot'
adaptedData(x, train = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptedData_+3A_x">x</code></td>
<td>
<p>Object of class <code>fairadapt</code> or <code>fairadaptBoot</code>, a result of an
adaptation procedure.</p>
</td></tr>
<tr><td><code id="adaptedData_+3A_train">train</code></td>
<td>
<p>A logical indicating whether train data should be returned.
Defaults to <code>TRUE</code>. If <code>FALSE</code>, test data is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code>data.frame</code> when called on an <code>fairadapt</code> object, or a <code>list</code>
of <code>data.frame</code>s with the adapted data of length <code>n.boot</code>, when called on a
<code>fairadaptBoot</code> object.
</p>

<hr>
<h2 id='compas'>COMPAS dataset.</h2><span id='topic+compas'></span>

<h3>Description</h3>

<p>A real dataset from Broward County, Florida. Contains information on individuals
released on parole, and whether they reoffended within two years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compas
</code></pre>


<h3>Format</h3>

<p>A data frame with 1,000 rows and 9 variables:
</p>

<dl>
<dt>sex</dt><dd><p>sex of the individual</p>
</dd>
<dt>age</dt><dd><p>age, measured in years</p>
</dd>
<dt>race</dt><dd><p>race, binary with values Non-White and White</p>
</dd>
<dt>juv_fel_count</dt><dd><p>count of juvenile felonies</p>
</dd>
<dt>juv_misd_count</dt><dd><p>count of juvenile misdemeanors</p>
</dd>
<dt>juv_other_count</dt><dd><p>count of other juvenile offenses</p>
</dd>
<dt>priors_count</dt><dd><p>count of prior offenses</p>
</dd>
<dt>c_charge_degree</dt><dd><p>degree of charge, with two values, F (felony) and M (misdemeanor)</p>
</dd>
<dt>two_year_recid</dt><dd><p>a logical TRUE/FALSE indicator of recidivism within two years after parole start</p>
</dd>
</dl>


<hr>
<h2 id='computeQuants'>Compute Quantiles generic for the Quantile Learning step.</h2><span id='topic+computeQuants'></span>

<h3>Description</h3>

<p>Compute Quantiles generic for the Quantile Learning step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeQuants(x, data, newdata, ind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeQuants_+3A_x">x</code></td>
<td>
<p>Object with an associated <code>computeQuants()</code> method, to be used for
inferring quantiles.</p>
</td></tr>
<tr><td><code id="computeQuants_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing samples used in the quantile
regression.</p>
</td></tr>
<tr><td><code id="computeQuants_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code> containing counterfactual values for which
the quantiles need to be inferred.</p>
</td></tr>
<tr><td><code id="computeQuants_+3A_ind">ind</code></td>
<td>
<p>A <code>logical</code> vector of length <code>nrow(data)</code>, indicating which
samples have the baseline value of the protected attribute.</p>
</td></tr>
<tr><td><code id="computeQuants_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed down to respective method
functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of counterfactual values corresponding to <code>newdata</code>.
</p>

<hr>
<h2 id='fairadapt'>Fairadapt</h2><span id='topic+fairadapt'></span>

<h3>Description</h3>

<p>Implementation of fair data adaptation with quantile preservation
(Plecko &amp; Meinshausen 2019). Uses only plain <code>R</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fairadapt(
  formula,
  prot.attr,
  adj.mat,
  train.data,
  test.data = NULL,
  cfd.mat = NULL,
  top.ord = NULL,
  res.vars = NULL,
  quant.method = rangerQuants,
  visualize.graph = FALSE,
  eval.qfit = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fairadapt_+3A_formula">formula</code></td>
<td>
<p>Object of class <code>formula</code> describing the response and
the covariates.</p>
</td></tr>
<tr><td><code id="fairadapt_+3A_prot.attr">prot.attr</code></td>
<td>
<p>A value of class <code>character</code> describing the binary
protected attribute. Must be one of the entries of <code>colnames(adj.mat)</code>.</p>
</td></tr>
<tr><td><code id="fairadapt_+3A_adj.mat">adj.mat</code></td>
<td>
<p>Matrix of class <code>matrix</code> encoding the relationships in
the causal graph. <code>M[i,j] == 1L</code> implies the existence of an edge from
node i to node j. Must include all the variables appearing in the formula
object. When the <code>adj.mat</code> argument is set to <code>NULL</code>, then the
<code>top.ord</code> argument has to be supplied.</p>
</td></tr>
<tr><td><code id="fairadapt_+3A_train.data">train.data</code>, <code id="fairadapt_+3A_test.data">test.data</code></td>
<td>
<p>Training data &amp; testing data, both of class
<code>data.frame</code>. Test data is by default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fairadapt_+3A_cfd.mat">cfd.mat</code></td>
<td>
<p>Symmetric matrix of class <code>matrix</code> encoding the
bidirected edges in the causal graph. <code style="white-space: pre;">&#8288;M[i,j] == M[j, i] == 1L&#8288;</code>
implies the existence of a bidirected edge between nodes i and j. Must
include all the variables appearing in the formula object.</p>
</td></tr>
<tr><td><code id="fairadapt_+3A_top.ord">top.ord</code></td>
<td>
<p>A vector of class <code>character</code> describing the
topological ordering of the causal graph. Default value is <code>NULL</code>,
but this argument must be supplied if <code>adj.mat</code> is not specified.
Also must include all the variables appearing in the formula object.</p>
</td></tr>
<tr><td><code id="fairadapt_+3A_res.vars">res.vars</code></td>
<td>
<p>A vector of class <code>character</code> listing all the resolving
variables, which should not be changed by the adaption procedure. Default
value is <code>NULL</code>, corresponding to no resolving variables. Resolving
variables should be a subset of the descendants of the protected attribute.</p>
</td></tr>
<tr><td><code id="fairadapt_+3A_quant.method">quant.method</code></td>
<td>
<p>A function choosing the method used for quantile
regression. Default value is <code>rangerQuants</code> (using random forest
quantile regression). Other implemented options are <code>linearQuants</code> and
<code>mcqrnnQuants</code>. A custom function can be supplied by the user here,
and the associated method for the S3 generic <code>computeQuants</code> needs to be
added.</p>
</td></tr>
<tr><td><code id="fairadapt_+3A_visualize.graph">visualize.graph</code></td>
<td>
<p>A <code>logical</code> indicating whether the causal graph
should be plotted upon calling the <code>fairadapt()</code> function. Default
value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fairadapt_+3A_eval.qfit">eval.qfit</code></td>
<td>
<p>Argument indicating whether the quality of the quantile
regression fit should be computed using cross-validation. Default value is
<code>NULL</code>, but whenever a positive integer value is specified, then it is
interpreted as the number of folds used in the cross-validation procedure.</p>
</td></tr>
<tr><td><code id="fairadapt_+3A_...">...</code></td>
<td>
<p>Additional arguments forwarded to the function passed as
<code>quant.method</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure takes the training and testing data as an input, together with
the causal graph given by an adjacency matrix and the list of resolving
variables, which should be kept fixed during the adaptation procedure. The
procedure then calculates a fair representation of the data, after which
any classification method can be used. There are, however, several valid
training options yielding fair predictions, and the best of them can be
chosen with cross-validation. For more details we refer the user to the
original paper. Most of the running time is due to the quantile regression
step using the ranger package.
</p>


<h3>Value</h3>

<p>An object of class <code>fairadapt</code>, containing the original and
adapted training and testing data, together with the causal graph and some
additional meta-information.
</p>


<h3>References</h3>

<p>Plecko, D. &amp; Meinshausen, N. (2019).
Fair Data Adaptation with Quantile Preservation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_samp &lt;- 200
uni_dim &lt;- c(       "gender", "edu", "test", "score")
uni_adj &lt;- matrix(c(       0,     1,      1,       0,
                           0,     0,      1,       1,
                           0,     0,      0,       1,
                           0,     0,      0,       0),
                  ncol = length(uni_dim),
                  dimnames = rep(list(uni_dim), 2),
                  byrow = TRUE)

uni_ada &lt;- fairadapt(score ~ .,
  train.data = head(uni_admission, n = n_samp),
  test.data = tail(uni_admission, n = n_samp),
  adj.mat = uni_adj,
  prot.attr = "gender"
)

uni_ada

</code></pre>

<hr>
<h2 id='fairadaptBoot'>Fairadapt Boostrap wrapper</h2><span id='topic+fairadaptBoot'></span>

<h3>Description</h3>

<p>The <code>fairadapt()</code> function performs data adaptation, but does so only
once. Sometimes, it might be desirable to repeat this process, in order to be
able to make uncertainty estimates about the data adaptation that is
performed. The wrapper function <code>fairadaptBoot()</code> enables the user to do
so, by performing the <code>fairadapt()</code> procedure multiple times, and
keeping in memory the important multiple data transformations. For a worked
example of how to use <code>fairadaptBoot()</code> for uncertainty quantification,
see the <code>fairadapt</code> vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fairadaptBoot(
  formula,
  prot.attr,
  adj.mat,
  train.data,
  test.data = NULL,
  cfd.mat = NULL,
  top.ord = NULL,
  res.vars = NULL,
  quant.method = rangerQuants,
  keep.object = FALSE,
  n.boot = 100,
  rand.mode = c("finsamp", "quant", "both"),
  test.seed = 2022,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fairadaptBoot_+3A_formula">formula</code></td>
<td>
<p>Object of class <code>formula</code> describing the response and
the covariates.</p>
</td></tr>
<tr><td><code id="fairadaptBoot_+3A_prot.attr">prot.attr</code></td>
<td>
<p>A value of class <code>character</code> describing the binary
protected attribute. Must be one of the entries of <code>colnames(adj.mat)</code>.</p>
</td></tr>
<tr><td><code id="fairadaptBoot_+3A_adj.mat">adj.mat</code></td>
<td>
<p>Matrix of class <code>matrix</code> encoding the relationships in
the causal graph. <code>M[i,j] == 1L</code> implies the existence of an edge from
node i to node j. Must include all the variables appearing in the formula
object. When the <code>adj.mat</code> argument is set to <code>NULL</code>, then the
<code>top.ord</code> argument has to be supplied.</p>
</td></tr>
<tr><td><code id="fairadaptBoot_+3A_train.data">train.data</code>, <code id="fairadaptBoot_+3A_test.data">test.data</code></td>
<td>
<p>Training data &amp; testing data, both of class
<code>data.frame</code>. Test data is by default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fairadaptBoot_+3A_cfd.mat">cfd.mat</code></td>
<td>
<p>Symmetric matrix of class <code>matrix</code> encoding the
bidirected edges in the causal graph. <code style="white-space: pre;">&#8288;M[i,j] == M[j, i] == 1L&#8288;</code>
implies the existence of a bidirected edge between nodes i and j. Must
include all the variables appearing in the formula object.</p>
</td></tr>
<tr><td><code id="fairadaptBoot_+3A_top.ord">top.ord</code></td>
<td>
<p>A vector of class <code>character</code> describing the
topological ordering of the causal graph. Default value is <code>NULL</code>,
but this argument must be supplied if <code>adj.mat</code> is not specified.
Also must include all the variables appearing in the formula object.</p>
</td></tr>
<tr><td><code id="fairadaptBoot_+3A_res.vars">res.vars</code></td>
<td>
<p>A vector of class <code>character</code> listing all the resolving
variables, which should not be changed by the adaption procedure. Default
value is <code>NULL</code>, corresponding to no resolving variables. Resolving
variables should be a subset of the descendants of the protected attribute.</p>
</td></tr>
<tr><td><code id="fairadaptBoot_+3A_quant.method">quant.method</code></td>
<td>
<p>A function choosing the method used for quantile
regression. Default value is <code>rangerQuants</code> (using random forest
quantile regression). Other implemented options are <code>linearQuants</code> and
<code>mcqrnnQuants</code>. A custom function can be supplied by the user here,
and the associated method for the S3 generic <code>computeQuants</code> needs to be
added.</p>
</td></tr>
<tr><td><code id="fairadaptBoot_+3A_keep.object">keep.object</code></td>
<td>
<p>a <code>logical</code> scalar, indicating whether all the
<code>fairadapt</code> S3 objects built in bootstrap repetitions should be saved.</p>
</td></tr>
<tr><td><code id="fairadaptBoot_+3A_n.boot">n.boot</code></td>
<td>
<p>An integer corresponding to the umber of bootstrap iterations.</p>
</td></tr>
<tr><td><code id="fairadaptBoot_+3A_rand.mode">rand.mode</code></td>
<td>
<p>A string, taking values <code>"finsamp"</code>, <code>"quant"</code> or <code>"both"</code>,
corresponding to considering finite sample uncertainty, quantile
uncertainty, or both.</p>
</td></tr>
<tr><td><code id="fairadaptBoot_+3A_test.seed">test.seed</code></td>
<td>
<p>a seed for the randomness in breaking quantiles for the
discrete variables. This argument is only relevant when <code>rand.mode</code> equals
<code>"quant"</code> or <code>"both"</code> (otherwise ignored).</p>
</td></tr>
<tr><td><code id="fairadaptBoot_+3A_...">...</code></td>
<td>
<p>Additional arguments forwarded to the function passed as
<code>quant.method</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fairadaptBoot</code>, containing the original and
adapted training and testing data, together with the causal graph and some
additional meta-information.
</p>


<h3>References</h3>

<p>Plecko, D. &amp; Meinshausen, N. (2019).
Fair Data Adaptation with Quantile Preservation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_samp &lt;- 200
uni_dim &lt;- c(       "gender", "edu", "test", "score")
uni_adj &lt;- matrix(c(       0,     1,      1,       0,
                           0,     0,      1,       1,
                           0,     0,      0,       1,
                           0,     0,      0,       0),
                  ncol = length(uni_dim),
                  dimnames = rep(list(uni_dim), 2),
                  byrow = TRUE)

uni_ada &lt;- fairadaptBoot(score ~ .,
  train.data = head(uni_admission, n = n_samp),
  test.data = tail(uni_admission, n = n_samp),
  adj.mat = uni_adj,
  prot.attr = "gender",
  n.boot = 5
)

uni_ada

</code></pre>

<hr>
<h2 id='fairTwins'>Fair Twin Inspection convenience function.</h2><span id='topic+fairTwins'></span>

<h3>Description</h3>

<p>Fair Twin Inspection convenience function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fairTwins(x, train.id = seq_len(nrow(x$train)), test.id = NULL, cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fairTwins_+3A_x">x</code></td>
<td>
<p>Object of class <code>fairadapt</code>, a result of an adaptation
procedure.</p>
</td></tr>
<tr><td><code id="fairTwins_+3A_train.id">train.id</code></td>
<td>
<p>A vector of indices specifying which rows of the training
data should be displayed.</p>
</td></tr>
<tr><td><code id="fairTwins_+3A_test.id">test.id</code></td>
<td>
<p>A vector of indices specifying which rows of the test
data should be displayed.</p>
</td></tr>
<tr><td><code id="fairTwins_+3A_cols">cols</code></td>
<td>
<p>A <code>character</code> vector, subset of <code>names(train.data)</code>,
which specifies which subset of columns is to be displayed in the result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, containing the original and adapted values
of the requested individuals. Adapted columns have <code style="white-space: pre;">&#8288;_adapted&#8288;</code> appended
to their original name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_samp &lt;- 200
uni_dim &lt;- c(       "gender", "edu", "test", "score")
uni_adj &lt;- matrix(c(       0,     1,      1,       0,
                           0,     0,      1,       1,
                           0,     0,      0,       1,
                           0,     0,      0,       0),
                  ncol = length(uni_dim),
                  dimnames = rep(list(uni_dim), 2),
                  byrow = TRUE)

uni_ada &lt;- fairadapt(score ~ .,
  train.data = head(uni_admission, n = n_samp),
  test.data = tail(uni_admission, n = n_samp),
  adj.mat = uni_adj,
  prot.attr = "gender"
)

fairTwins(uni_ada, train.id = 1:5)
</code></pre>

<hr>
<h2 id='gov_census'>Census information of US government employees.</h2><span id='topic+gov_census'></span>

<h3>Description</h3>

<p>The dataset contains various demographic, education and work information
of the employees of the US government. The data is taken from the 2018
US Census data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gov_census
</code></pre>


<h3>Format</h3>

<p>A data frame with 204,309 rows and 17 variables:
</p>

<dl>
<dt>sex</dt><dd><p>gender of the employee</p>
</dd>
<dt>age</dt><dd><p>employee age in years</p>
</dd>
<dt>race</dt><dd><p>race of the employee</p>
</dd>
<dt>hispanic_origin</dt><dd><p>indicator of hispanic origin</p>
</dd>
<dt>citizenship</dt><dd><p>citizenship of the employee</p>
</dd>
<dt>nativity</dt><dd><p>indicator of nativity to the US</p>
</dd>
<dt>marital</dt><dd><p>marital status</p>
</dd>
<dt>family_size</dt><dd><p>size of the employee's family</p>
</dd>
<dt>children</dt><dd><p>number of children of the employee</p>
</dd>
<dt>education_level</dt><dd><p>education level measured in years</p>
</dd>
<dt>english_level</dt><dd></dd>
<dt>salary</dt><dd><p>yearly salary in US dollars</p>
</dd>
<dt>hours_worked</dt><dd><p>hours worked every week</p>
</dd>
<dt>weeks_worked</dt><dd><p>weeks worked in the given year</p>
</dd>
<dt>occupation</dt><dd><p>occupation classification</p>
</dd>
<dt>industry</dt><dd><p>industry classification</p>
</dd>
<dt>economic_region</dt><dd><p>economic region where the person is employed in the US</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.census.gov/programs-surveys/acs/microdata/documentation.html">https://www.census.gov/programs-surveys/acs/microdata/documentation.html</a>
</p>

<hr>
<h2 id='graphModel'>Obtaining the graphical causal model (GCM)</h2><span id='topic+graphModel'></span>

<h3>Description</h3>

<p>Obtaining the graphical causal model (GCM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphModel(adj.mat, cfd.mat = NULL, res.vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphModel_+3A_adj.mat">adj.mat</code></td>
<td>
<p>Matrix of class <code>matrix</code> encoding the relationships in
the causal graph. <code>M[i,j] == 1L</code> implies the existence of an edge from
node i to node j.</p>
</td></tr>
<tr><td><code id="graphModel_+3A_cfd.mat">cfd.mat</code></td>
<td>
<p>Symmetric matrix of class <code>matrix</code> encoding the
bidirected edges in the causal graph. <code style="white-space: pre;">&#8288;M[i,j] == M[j, i] == 1L&#8288;</code>
implies the existence of a bidirected edge between nodes i and j.</p>
</td></tr>
<tr><td><code id="graphModel_+3A_res.vars">res.vars</code></td>
<td>
<p>A vector of class <code>character</code> listing all the resolving
variables, which should not be changed by the adaption procedure. Default
value is <code>NULL</code>, corresponding to no resolving variables. Resolving
variables should be a subset of <code>colnames(adj.mat)</code>. Resolving
variables are marked with a different color in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>igraph</code>, containing the causal graphical,
with directed and bidirected edges.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj.mat &lt;- cfd.mat &lt;- array(0L, dim = c(3, 3))
colnames(adj.mat) &lt;- rownames(adj.mat) &lt;-
  colnames(cfd.mat) &lt;- rownames(cfd.mat) &lt;- c("A", "X", "Y")

adj.mat["A", "X"] &lt;- adj.mat["X", "Y"] &lt;-
  cfd.mat["X", "Y"] &lt;- cfd.mat["Y", "X"] &lt;- 1L

gcm &lt;- graphModel(adj.mat, cfd.mat, res.vars = "X")

</code></pre>

<hr>
<h2 id='predict.fairadapt'>Prediction function for new data from a saved <code>fairadapt</code> object.</h2><span id='topic+predict.fairadapt'></span>

<h3>Description</h3>

<p>Prediction function for new data from a saved <code>fairadapt</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fairadapt'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.fairadapt_+3A_object">object</code></td>
<td>
<p>Object of class <code>fairadapt</code>, a result of an adaptation
procedure.</p>
</td></tr>
<tr><td><code id="predict.fairadapt_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> containing the new data.</p>
</td></tr>
<tr><td><code id="predict.fairadapt_+3A_...">...</code></td>
<td>
<p>Additional arguments forwarded to <code>computeQuants()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>newdata</code> argument should be compatible with <code>adapt.test</code>
argument that was used when constructing the <code>fairadapt</code> object. In
particular, <code>newdata</code> should contain column names that appear in the <code>formula</code>
argument that was used when calling <code>fairadapt()</code> (apart from the outcome
variable on the LHS of the formula).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the adapted version of the new data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_samp &lt;- 200
uni_dim &lt;- c(       "gender", "edu", "test", "score")
uni_adj &lt;- matrix(c(       0,     1,      1,       0,
                           0,     0,      1,       1,
                           0,     0,      0,       1,
                           0,     0,      0,       0),
                  ncol = length(uni_dim),
                  dimnames = rep(list(uni_dim), 2),
                  byrow = TRUE)

uni_ada &lt;- fairadapt(score ~ .,
  train.data = head(uni_admission, n = n_samp),
  adj.mat = uni_adj,
  prot.attr = "gender"
)

predict(object = uni_ada, newdata = tail(uni_admission, n = n_samp))
</code></pre>

<hr>
<h2 id='predict.fairadaptBoot'>Prediction function for new data from a saved <code>fairadaptBoot</code> object.</h2><span id='topic+predict.fairadaptBoot'></span>

<h3>Description</h3>

<p>Prediction function for new data from a saved <code>fairadaptBoot</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fairadaptBoot'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.fairadaptBoot_+3A_object">object</code></td>
<td>
<p>Object of class <code>fairadapt</code>, a result of an adaptation
procedure.</p>
</td></tr>
<tr><td><code id="predict.fairadaptBoot_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> containing the new data.</p>
</td></tr>
<tr><td><code id="predict.fairadaptBoot_+3A_...">...</code></td>
<td>
<p>Additional arguments forwarded to <code>computeQuants()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>newdata</code> argument should be compatible with <code>adapt.test</code>
argument that was used when constructing the <code>fairadaptBoot</code> object. In
particular, <code>newdata</code> should contain column names that appear in the
<code>formula</code> argument that was used when calling <code>fairadaptBoot()</code> (apart from
the outcome variable on the LHS of the formula).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the adapted version of the new data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_samp &lt;- 200
uni_dim &lt;- c(       "gender", "edu", "test", "score")
uni_adj &lt;- matrix(c(       0,     1,      1,       0,
                           0,     0,      1,       1,
                           0,     0,      0,       1,
                           0,     0,      0,       0),
                  ncol = length(uni_dim),
                  dimnames = rep(list(uni_dim), 2),
                  byrow = TRUE)

uni_ada_boot &lt;- fairadaptBoot(score ~ .,
  train.data = head(uni_admission, n = n_samp),
  adj.mat = uni_adj,
  prot.attr = "gender",
  n.boot = 5,
  keep.object = TRUE
)

predict(object = uni_ada_boot, newdata = tail(uni_admission, n = n_samp))
</code></pre>

<hr>
<h2 id='quantFit'>Quality of quantile fit statistics.</h2><span id='topic+quantFit'></span>

<h3>Description</h3>

<p>Quality of quantile fit statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantFit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantFit_+3A_x">x</code></td>
<td>
<p>Object of class <code>fairadapt</code>, a result of an adaptation
procedure.</p>
</td></tr>
<tr><td><code id="quantFit_+3A_...">...</code></td>
<td>
<p>Ignored in this case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector, containing the average empirical loss for
the 25%, 50% and 75% quantile loss functions, for each variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_samp &lt;- 200
uni_dim &lt;- c(       "gender", "edu", "test", "score")
uni_adj &lt;- matrix(c(       0,     1,      1,       0,
                           0,     0,      1,       1,
                           0,     0,      0,       1,
                           0,     0,      0,       0),
                  ncol = length(uni_dim),
                  dimnames = rep(list(uni_dim), 2),
                  byrow = TRUE)

uni_ada &lt;- fairadapt(score ~ .,
  train.data = head(uni_admission, n = n_samp),
  test.data = tail(uni_admission, n = n_samp),
  adj.mat = uni_adj,
  prot.attr = "gender",
  eval.qfit = 3L
)

quantFit(uni_ada)
</code></pre>

<hr>
<h2 id='rangerQuants'>Quantile Engine Constructor for the Quantile Learning step.</h2><span id='topic+rangerQuants'></span><span id='topic+linearQuants'></span><span id='topic+mcqrnnQuants'></span>

<h3>Description</h3>

<p>There are several methods that can be used for the quantile learning step
in the <code>fairadapt</code> package. Each of the methods needs a specific
constructor. The constructor is a function that takes the data (with some
additional meta-information) and returns an object on which the
<code>computeQuants()</code> generic can be called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rangerQuants(data, A.root, ind, min.node.size = 20, ...)

linearQuants(
  data,
  A.root,
  ind,
  tau = c(0.001, seq(0.005, 0.995, by = 0.01), 0.999),
  ...
)

mcqrnnQuants(
  data,
  A.root,
  ind,
  tau = seq(0.005, 0.995, by = 0.01),
  iter.max = 500,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rangerQuants_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with data to be used for quantile
regression.</p>
</td></tr>
<tr><td><code id="rangerQuants_+3A_a.root">A.root</code></td>
<td>
<p>A <code>logical(1L)</code> indicating whether the protected
attribute <code>A</code> is a root node of the causal graph. Used for splitting the
quantile regression.</p>
</td></tr>
<tr><td><code id="rangerQuants_+3A_ind">ind</code></td>
<td>
<p>A <code>logical</code> vector of length <code>nrow(data)</code>, indicating
which
samples have the baseline value of the protected attribute.</p>
</td></tr>
<tr><td><code id="rangerQuants_+3A_min.node.size">min.node.size</code></td>
<td>
<p>Forwarded to <code><a href="ranger.html#topic+ranger">ranger::ranger()</a></code>.</p>
</td></tr>
<tr><td><code id="rangerQuants_+3A_...">...</code></td>
<td>
<p>Forwarded to further methods.</p>
</td></tr>
<tr><td><code id="rangerQuants_+3A_tau">tau</code></td>
<td>
<p>Forwarded to <code><a href="quantreg.html#topic+rq">quantreg::rq()</a></code> or <code><a href="qrnn.html#topic+mcqrnn">qrnn::mcqrnn.fit()</a></code>.</p>
</td></tr>
<tr><td><code id="rangerQuants_+3A_iter.max">iter.max</code></td>
<td>
<p>Forwarded to <code><a href="qrnn.html#topic+mcqrnn">qrnn::mcqrnn.fit()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within the package, there are 3 different methods implemented, which use
quantile regressors based on linear models, random forests and neural
networks. However, there is additional flexibility and the user can provide
her/his own quantile method. For this, the user needs to write (i) the
constructor which returns an S3 classed object (see examples below);
(ii) a method for the <code>computeQuants()</code> generic for the S3 class
returned in (i).
</p>
<p>The <code>rangerQuants()</code> function uses random forests
(<code>ranger</code> package) for quantile regression.
</p>
<p>The <code>linearQuants()</code> function uses linear quantile regression
(<code>quantreg</code> package) for the Quantile Learning step.
</p>
<p>The <code>mcqrnnQuants()</code> function uses  monotone quantile
regression neural networks (<code>mcqrnn</code> package) in the Quantile Learning step.
</p>


<h3>Value</h3>

<p>A <code>ranger</code> or a <code>rangersplit</code> S3 object, depending on the
value of the <code>A.root</code> argument, for <code>rangerQuants()</code>.
</p>
<p>A <code>rqs</code> or a <code>quantregsplit</code> S3 object, depending on the
value of the <code>A.root</code> argument, for <code>linearQuants()</code>.
</p>
<p>An <code> mcqrnn</code> S3 object for <code> mcqrnnQuants()</code>.
</p>

<hr>
<h2 id='uni_admission'>University admission data of 1,000 students.</h2><span id='topic+uni_admission'></span>

<h3>Description</h3>

<p>A simulated dataset containing the evaluation of students' abilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uni_admission
</code></pre>


<h3>Format</h3>

<p>A data frame with 1,000 rows and 4 variables:
</p>

<dl>
<dt>gender</dt><dd><p>the gender of the student</p>
</dd>
<dt>edu</dt><dd><p>educational achievement, for instance GPA</p>
</dd>
<dt>test</dt><dd><p>performance on a university admission test</p>
</dd>
<dt>score</dt><dd><p>overall final score measuring the quality of a candidate</p>
</dd>
</dl>


<hr>
<h2 id='visualizeGraph'>Visualize Graphical Causal Model</h2><span id='topic+visualizeGraph'></span>

<h3>Description</h3>

<p>Visualize Graphical Causal Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualizeGraph(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualizeGraph_+3A_x">x</code></td>
<td>
<p>Object of class <code>fairadapt</code>, a result of an adaptation
procedure.</p>
</td></tr>
<tr><td><code id="visualizeGraph_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the graph plotting function.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
