<!DOCTYPE html><html lang="en"><head><title>Help for package particles</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {particles}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#particles-package'><p>particles: A Graph Based Particle Simulator Based on D3-Force</p></a></li>
<li><a href='#center_force'><p>Center all particles around the origin without affecting velocity</p></a></li>
<li><a href='#collision_force'><p>Models particles as circles with a given radius and pushes overlapping particles apart</p></a></li>
<li><a href='#dominator_constraint'><p>Restrict child position based on parent position</p></a></li>
<li><a href='#evolve'><p>Move the simulation forward one or more steps</p></a></li>
<li><a href='#field_force'><p>Apply a vector field to particles</p></a></li>
<li><a href='#genesis'><p>Particle initialisation</p></a></li>
<li><a href='#impose'><p>Assign a force or constraint to a simulation</p></a></li>
<li><a href='#infinity_constraint'><p>Reposition particles outside a canvas so they wrap around</p></a></li>
<li><a href='#link_force'><p>Attract or repel linked particles</p></a></li>
<li><a href='#manybody_force'><p>Model attraction or repulsion between all particles in the system</p></a></li>
<li><a href='#map_force'><p>Apply a map to particles</p></a></li>
<li><a href='#mean_force'><p>Apply the mean velocity of all the neighbors to a particle</p></a></li>
<li><a href='#path_constraint'><p>Limit particle position to be along a path or outline</p></a></li>
<li><a href='#polygon_constraint'><p>Fixes particles to be inside a polygon</p></a></li>
<li><a href='#random_force'><p>Modify the velocity randomly at each step</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reset_force'><p>Reset the velocity verlet of particles to a fixed value</p></a></li>
<li><a href='#simulate'><p>Start a simulation based on a graph</p></a></li>
<li><a href='#simulation_modification'><p>Modify the particles in a simulation</p></a></li>
<li><a href='#trap_force'><p>Attract and trap particles within polygons</p></a></li>
<li><a href='#velocity_constraint'><p>Limits particles to a specific velocity range</p></a></li>
<li><a href='#x_constraint'><p>Fixes particles to a horizontal position</p></a></li>
<li><a href='#x_force'><p>Attract particles towards a horizontal position</p></a></li>
<li><a href='#y_constraint'><p>Fixes particles to a vertical position</p></a></li>
<li><a href='#y_force'><p>Attract particles towards a vertical position</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Graph Based Particle Simulator Based on D3-Force</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulating particle movement in 2D space has many
    application. The 'particles' package implements a particle simulator
    based on the ideas behind the 'd3-force' 'JavaScript' library.
    'particles' implements all forces defined in 'd3-force' as well as
    others such as vector fields, traps, and attractors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thomasp85/particles">https://github.com/thomasp85/particles</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/particles/issues">https://github.com/thomasp85/particles/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, dplyr, igraph, mgcv, rlang, stats, tidygraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggraph, knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/build/compilation-database:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-03 08:58:26 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Andrei Kashcha [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-03 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='particles-package'>particles: A Graph Based Particle Simulator Based on D3-Force</h2><span id='topic+particles-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Simulating particle movement in 2D space has many application. The 'particles' package implements a particle simulator based on the ideas behind the 'd3-force' 'JavaScript' library. 'particles' implements all forces defined in 'd3-force' as well as others such as vector fields, traps, and attractors.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Andrei Kashcha [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>See also the <a href="https://github.com/d3/d3-force">GitHub page</a> for
the original JavaScript implementation in D3 by Mike Bostock
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/thomasp85/particles">https://github.com/thomasp85/particles</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/particles/issues">https://github.com/thomasp85/particles/issues</a>
</p>
</li></ul>


<hr>
<h2 id='center_force'>Center all particles around the origin without affecting velocity</h2><span id='topic+center_force'></span>

<h3>Description</h3>

<p>This force repositions the particles at each generation so they are centered
around (0,0). It does not affect the velocity of the particles and are thus
mainly a guard against the whole body of particles drifting off.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the force and can be passed
along a call to <code><a href="#topic+wield">wield()</a></code>
</p>

<ul>
<li> <p><code>x</code> : The x position to center around (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>y</code> : The y position to center around (<em>tidy eval</em>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other forces: 
<code><a href="#topic+collision_force">collision_force</a></code>,
<code><a href="#topic+field_force">field_force</a></code>,
<code><a href="#topic+link_force">link_force</a></code>,
<code><a href="#topic+manybody_force">manybody_force</a></code>,
<code><a href="#topic+map_force">map_force</a></code>,
<code><a href="#topic+mean_force">mean_force</a></code>,
<code><a href="#topic+random_force">random_force</a></code>,
<code><a href="#topic+reset_force">reset_force</a></code>,
<code><a href="#topic+trap_force">trap_force</a></code>,
<code><a href="#topic+x_force">x_force</a></code>,
<code><a href="#topic+y_force">y_force</a></code>
</p>

<hr>
<h2 id='collision_force'>Models particles as circles with a given radius and pushes overlapping particles apart</h2><span id='topic+collision_force'></span>

<h3>Description</h3>

<p>This force pushes overlapping particles apart by assigning a radius to each
particle, treating them as circles, and searches for overlaps through an
optimised quad tree algorithm.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the force and can be passed
along a call to <code><a href="#topic+wield">wield()</a></code>
</p>

<ul>
<li> <p><code>strength</code> : A dampening of the repulsion between overlapping circles. This
allows the force to iterate towards the optimal solution through iterative
relaxation. Should be a number between 0 and 1. Defaults to 0.7
</p>
</li>
<li> <p><code>radius</code> : The radius of each particle. Defaults to 1 (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>n_iter</code> : The number of iterations to perform in the iterative relaxation.
Defaults to 1.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other forces: 
<code><a href="#topic+center_force">center_force</a></code>,
<code><a href="#topic+field_force">field_force</a></code>,
<code><a href="#topic+link_force">link_force</a></code>,
<code><a href="#topic+manybody_force">manybody_force</a></code>,
<code><a href="#topic+map_force">map_force</a></code>,
<code><a href="#topic+mean_force">mean_force</a></code>,
<code><a href="#topic+random_force">random_force</a></code>,
<code><a href="#topic+reset_force">reset_force</a></code>,
<code><a href="#topic+trap_force">trap_force</a></code>,
<code><a href="#topic+x_force">x_force</a></code>,
<code><a href="#topic+y_force">y_force</a></code>
</p>

<hr>
<h2 id='dominator_constraint'>Restrict child position based on parent position</h2><span id='topic+dominator_constraint'></span>

<h3>Description</h3>

<p>This constraint requires children to be positioned at a certain side of their
parent and with a certain distance. It can be used to enforce a layering of
particles for e.g. DAG and tree layouts.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the constraint and can be
passed along a call to <code><a href="#topic+impose">impose()</a></code>
</p>

<ul>
<li> <p><code>distance</code> : The minimum orthogonal distance to the parent. Default to <code>0</code>,
meaning that children are only required to be positioned to the specific
side of their parent. (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>angle</code> : The direction the children should be enforced to be relative to
their parent. Defaults to <code>-pi/2</code> which is equivalent to down. (<em>tidy eval</em>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+infinity_constraint">infinity_constraint</a></code>,
<code><a href="#topic+path_constraint">path_constraint</a></code>,
<code><a href="#topic+polygon_constraint">polygon_constraint</a></code>,
<code><a href="#topic+velocity_constraint">velocity_constraint</a></code>,
<code><a href="#topic+x_constraint">x_constraint</a></code>,
<code><a href="#topic+y_constraint">y_constraint</a></code>
</p>

<hr>
<h2 id='evolve'>Move the simulation forward one or more steps</h2><span id='topic+evolve'></span>

<h3>Description</h3>

<p>This is the function that move the simulation forward in time. It is possible
to either specify the number of steps that should be simulated or let the
simulation terminate as <code>alpha_min</code> is reached. Note that some values of
<code>alpha</code> and <code>alpha_target</code> does not allow alpha to converge to <code>alpha_min</code> so
letting the simulation self-terminate can result in an infinite loop. The
default settings will result in <code>alpha_min</code> being reached in 300 generations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evolve(simulation, steps = NULL, on_generation = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evolve_+3A_simulation">simulation</code></td>
<td>
<p>A simulation object</p>
</td></tr>
<tr><td><code id="evolve_+3A_steps">steps</code></td>
<td>
<p>The number of generations to progress or a function getting the
simulation object and returns <code>TRUE</code> if the simulation should proceed and
<code>FALSE</code> if it should stop. If <code>NULL</code> the simulation will run until
<code>alpha_min</code> has been reached.</p>
</td></tr>
<tr><td><code id="evolve_+3A_on_generation">on_generation</code></td>
<td>
<p>A function to be called after each generation has been
progressed. The function will get the current state of the simulation as the
first argument. If the function returns a simulation object it will replace
the current simulation from the next generation. In the case of any other
return type the return will be discarded and the function will have no effect
outside its side-effects.</p>
</td></tr>
<tr><td><code id="evolve_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>on_generation</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each generation in the simulation progress in the following manner:
</p>

<ol>
<li><p> Check whether the specified number of generations has been reached
</p>
</li>
<li><p> Check whether <code>alpha_min</code> has been reached
</p>
</li>
<li><p> If either 1. or 2. is true, terminate the simulation
</p>
</li>
<li><p> Apply the forces on the current particle positions and velocities in the
order they have been added
</p>
</li>
<li><p> Reduce the velocity according to the given <code>velocity_decay</code>
</p>
</li>
<li><p> Update the position and velocity based on any provided constraints
</p>
</li>
<li><p> Calculate the new particle positions based on the new velocity
</p>
</li>
<li><p> If given, call the <code>on_generation</code> function.
</p>
</li></ol>



<h3>Value</h3>

<p>A simulation object with updated positions and velocities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- tidygraph::create_notable('folkman')
sim &lt;- graph |&gt;
  simulate() |&gt;
  wield(link_force) |&gt;
  wield(manybody_force)

# Take 5 steps and tell about it
sim |&gt; evolve(5, function(sim) {
  cat('Generation: ', evolutions(sim), '\n', sep = '')
})

# Run evolution until alpha_min is reached
sim |&gt; evolve(NULL)

</code></pre>

<hr>
<h2 id='field_force'>Apply a vector field to particles</h2><span id='topic+field_force'></span>

<h3>Description</h3>

<p>This force adjusts the velocity of particles based on a supplied vector
field. The vector field can either be specified using x and y velocities, or
angle and magnitude. Velocity adjustments are calculated based on a bilinear
interpolation.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the force and can be passed
along a call to <code><a href="#topic+wield">wield()</a></code>
</p>

<ul>
<li> <p><code>x</code> : A matrix giving the velocity in the x direction at each grid point
</p>
</li>
<li> <p><code>y</code> : A matrix giving the velocity in the y direction at each grid point
</p>
</li>
<li> <p><code>angle</code> : A matrix giving the direction of the velocity at each grid point.
Will only be considered if <code>x</code> and <code>y</code> are missing.
</p>
</li>
<li> <p><code>vel</code> : A single numeric or a matrix of the same dimensions as <code>angle</code>
giving the magnitude of velocity at each grid point.
</p>
</li>
<li> <p><code>xlim</code> : The coordinate span of the vector field in the x direction.
</p>
</li>
<li> <p><code>ylim</code> : The coordinate span of the vector field in the y direction.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other forces: 
<code><a href="#topic+center_force">center_force</a></code>,
<code><a href="#topic+collision_force">collision_force</a></code>,
<code><a href="#topic+link_force">link_force</a></code>,
<code><a href="#topic+manybody_force">manybody_force</a></code>,
<code><a href="#topic+map_force">map_force</a></code>,
<code><a href="#topic+mean_force">mean_force</a></code>,
<code><a href="#topic+random_force">random_force</a></code>,
<code><a href="#topic+reset_force">reset_force</a></code>,
<code><a href="#topic+trap_force">trap_force</a></code>,
<code><a href="#topic+x_force">x_force</a></code>,
<code><a href="#topic+y_force">y_force</a></code>
</p>

<hr>
<h2 id='genesis'>Particle initialisation</h2><span id='topic+genesis'></span><span id='topic+phyllotactic_genesis'></span><span id='topic+predefined_genesis'></span><span id='topic+bigbang_genesis'></span><span id='topic+aquarium_genesis'></span><span id='topic+petridish_genesis'></span>

<h3>Description</h3>

<p>These functions are passed to the simulation and defines how the position and
velocity of the particles are initiated. The default is to lay out the nodes
in a phyllotactic arrangement (think sunflower seeds) and with no velocity,
which is also the default in d3-force.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyllotactic_genesis(radius = 10, angle = pi * (3 - sqrt(5)))

predefined_genesis(x, y, x_vel = 0, y_vel = 0)

bigbang_genesis(vel_min = 0, vel_max = 1)

aquarium_genesis(width = 10, height = 10, vel_min = 0, vel_max = 1)

petridish_genesis(max_radius = 10, vel_min = 0, vel_max = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genesis_+3A_radius">radius</code></td>
<td>
<p>The radius modifier (will be multiplied by the square root of the index of the particle)</p>
</td></tr>
<tr><td><code id="genesis_+3A_angle">angle</code></td>
<td>
<p>The angular difference between two adjacent particles</p>
</td></tr>
<tr><td><code id="genesis_+3A_x">x</code>, <code id="genesis_+3A_y">y</code></td>
<td>
<p>The columns holding (or value of) the position coordinates</p>
</td></tr>
<tr><td><code id="genesis_+3A_x_vel">x_vel</code>, <code id="genesis_+3A_y_vel">y_vel</code></td>
<td>
<p>The columns holding (or value of) the velocity verlets</p>
</td></tr>
<tr><td><code id="genesis_+3A_vel_min">vel_min</code>, <code id="genesis_+3A_vel_max">vel_max</code></td>
<td>
<p>The bounds of the uniformly distributed velocities</p>
</td></tr>
<tr><td><code id="genesis_+3A_width">width</code>, <code id="genesis_+3A_height">height</code></td>
<td>
<p>The size of the rectangle holding the particles</p>
</td></tr>
<tr><td><code id="genesis_+3A_max_radius">max_radius</code></td>
<td>
<p>The size of the disc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes the particle graph and returns a list with a
position and velocity element, each holding a matrix with two columns and a
row for each particle giving the x and y position and velocity respectively.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>phyllotactic_genesis()</code>: Initiates particles in a phyllotactic arrangement with zero velocity
</p>
</li>
<li> <p><code>predefined_genesis()</code>: Uses information from the node data to set position and velocity.
</p>
</li>
<li> <p><code>bigbang_genesis()</code>: Initiates particles at center position and a random velocity
</p>
</li>
<li> <p><code>aquarium_genesis()</code>: Places particles randomly in a rectangle and gives them a random velocity
</p>
</li>
<li> <p><code>petridish_genesis()</code>: Places particles randomly on a disc and gives them a random velocity
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># A contrieved example
graph &lt;- tidygraph::create_notable('bull')
genesis &lt;- phyllotactic_genesis()
genesis(graph)

# Usually used as an argument to simulate
graph |&gt;
  simulate(setup = phyllotactic_genesis())

</code></pre>

<hr>
<h2 id='impose'>Assign a force or constraint to a simulation</h2><span id='topic+impose'></span><span id='topic+reimpose'></span><span id='topic+unimpose'></span><span id='topic+wield'></span><span id='topic+rewield'></span><span id='topic+unwield'></span>

<h3>Description</h3>

<p>This function adds a new force/constraint to the simulation and trains the it
on the current particle graph. The parameters passed on to the training are
using tidy evaluation from the rlang package. Depending on the
force/constraint the data getting referenced is either the node or the edge
data of the particle graph. Both forces and constraints manipulate position
and velocity of the particles but they differ in when the are applied during
a generation. First forces are applied sequentially and the resulting
velocity is added to the resulting position after <code>velocity_decay</code> has been
applied. After this operation any constraint is imposed on the results. In
general, forces tends to calculate velocity adjustments, while constraints
modify position and velocity directly, but this difference is not in any way
enforced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impose(simulation, constraint, ..., name, include = TRUE)

reimpose(simulation, name, ...)

unimpose(simulation, name)

wield(simulation, force, ..., name, include = TRUE)

rewield(simulation, name, ...)

unwield(simulation, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impose_+3A_simulation">simulation</code></td>
<td>
<p>A simulation object</p>
</td></tr>
<tr><td><code id="impose_+3A_constraint">constraint</code></td>
<td>
<p>A constraint object</p>
</td></tr>
<tr><td><code id="impose_+3A_...">...</code></td>
<td>
<p>Parameters passed on to the training of the force or constraint</p>
</td></tr>
<tr><td><code id="impose_+3A_name">name</code></td>
<td>
<p>The name of the force. For use when accessing the force at a
later stage. If no name is given the force is accessible by its index in the
stack.</p>
</td></tr>
<tr><td><code id="impose_+3A_include">include</code></td>
<td>
<p>The particles to be affected by this force. Defaults to every
particle in the simulation (<em>tidy eval</em>)</p>
</td></tr>
<tr><td><code id="impose_+3A_force">force</code></td>
<td>
<p>A force object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>wield()</code> and <code>impose()</code> adds forces and constraints to the simulation
respectively. <code>unwield()</code> and <code>unimpose()</code> removes forces and constraints
based on name or index. <code>rewield()</code> and <code>reimpose()</code> modifies existing forces
and constraints based on name or index and retrains them.
</p>


<h3>Value</h3>

<p>A simulation with the force or constraint added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- tidygraph::create_notable('folkman')
graph |&gt;
  simulate() |&gt;
  wield(link_force)

</code></pre>

<hr>
<h2 id='infinity_constraint'>Reposition particles outside a canvas so they wrap around</h2><span id='topic+infinity_constraint'></span>

<h3>Description</h3>

<p>This constraint keeps particles inside of a defined area by positioning
exiting particles on the other side of the area. In effect this makes
particles that moves outside the upper bound reenter at the lower bound and
vice versa.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the constraint and can be
passed along a call to <code><a href="#topic+impose">impose()</a></code>
</p>

<ul>
<li> <p><code>xlim</code> : The left and right bound of the area
</p>
</li>
<li> <p><code>ylim</code> : The upper and lower bound of the area
</p>
</li></ul>



<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+dominator_constraint">dominator_constraint</a></code>,
<code><a href="#topic+path_constraint">path_constraint</a></code>,
<code><a href="#topic+polygon_constraint">polygon_constraint</a></code>,
<code><a href="#topic+velocity_constraint">velocity_constraint</a></code>,
<code><a href="#topic+x_constraint">x_constraint</a></code>,
<code><a href="#topic+y_constraint">y_constraint</a></code>
</p>

<hr>
<h2 id='link_force'>Attract or repel linked particles</h2><span id='topic+link_force'></span>

<h3>Description</h3>

<p>This force works between linked particles and either attracts or repel them
from each other depending on the value of the strength and distance
parameters. The force is stronger the longer the linked particles are from
each other, mimicking the mechanics of a rubber band.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the force and can be passed
along a call to <code><a href="#topic+wield">wield()</a></code>
</p>

<ul>
<li> <p><code>strength</code> : The attractive force between the linked particles. The default
weighs edges from low-degree particles higher
(<code>strength = 1 / (min(degree(from), degree(to)))</code>). (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>distance</code> : The desired distance between linked particles. Defaults to
<code>30</code> (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>n_iter</code> : The number of iteration towards the optimal solution per
generation. Higher values leads to faster convergence (measured in number
of generations) at the expense of longer computation time per generation.
Defaults to <code>1</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other forces: 
<code><a href="#topic+center_force">center_force</a></code>,
<code><a href="#topic+collision_force">collision_force</a></code>,
<code><a href="#topic+field_force">field_force</a></code>,
<code><a href="#topic+manybody_force">manybody_force</a></code>,
<code><a href="#topic+map_force">map_force</a></code>,
<code><a href="#topic+mean_force">mean_force</a></code>,
<code><a href="#topic+random_force">random_force</a></code>,
<code><a href="#topic+reset_force">reset_force</a></code>,
<code><a href="#topic+trap_force">trap_force</a></code>,
<code><a href="#topic+x_force">x_force</a></code>,
<code><a href="#topic+y_force">y_force</a></code>
</p>

<hr>
<h2 id='manybody_force'>Model attraction or repulsion between all particles in the system</h2><span id='topic+manybody_force'></span>

<h3>Description</h3>

<p>This force implements a n-body simulation using the Barnes-Hut approximation
for improved performance. An n-body simulation calculates attraction or
repulsion between all particles in a system based on their relative distances
and each particles capacity and can thus mimick gravity or electrostatic
repulsion.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the force and can be passed
along a call to <code><a href="#topic+wield">wield()</a></code>
</p>

<ul>
<li> <p><code>strength</code> : The attractive or repulsive force of the particles. If
positive the particle attracts, if negative the particle repulses. The
default is -30. (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>theta</code> : The Barnes-Hut criterion governing the precision of the
approximation. If 0, no approximation is made. Defaults to 0.9.
</p>
</li>
<li> <p><code>min_dist</code> : A lower distance threshold below which the forces will be
damped, in order to avoid explosive forces when two particles gets very
near each other.
</p>
</li>
<li> <p><code>max_dist</code> : A distance threshold above which the forces between particles
are ignored. Using this will result in more local changes.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other forces: 
<code><a href="#topic+center_force">center_force</a></code>,
<code><a href="#topic+collision_force">collision_force</a></code>,
<code><a href="#topic+field_force">field_force</a></code>,
<code><a href="#topic+link_force">link_force</a></code>,
<code><a href="#topic+map_force">map_force</a></code>,
<code><a href="#topic+mean_force">mean_force</a></code>,
<code><a href="#topic+random_force">random_force</a></code>,
<code><a href="#topic+reset_force">reset_force</a></code>,
<code><a href="#topic+trap_force">trap_force</a></code>,
<code><a href="#topic+x_force">x_force</a></code>,
<code><a href="#topic+y_force">y_force</a></code>
</p>

<hr>
<h2 id='map_force'>Apply a map to particles</h2><span id='topic+map_force'></span>

<h3>Description</h3>

<p>In mathematics, maps are a functions that translates its input into new
values. In the context of particles a map is a translation function that
translates the current particle positions to a new one
</p>


<h3>Details</h3>

<p>Normally a map has no notion of velocity — it simply translates positions. In
particles it is possible to decide whether positions should be modified
directly or whether the translation magnitude should be added to the velocity
verlet using the <code>fixed</code> parameter.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the force and can be passed
along a call to <code><a href="#topic+wield">wield()</a></code>
</p>

<ul>
<li> <p><code>map</code> : A function that accepts the particle position matrix and returns
the new positions in the same format.
</p>
</li>
<li> <p><code>fixed</code> : Logical. Should position be modified directly (<code>TRUE</code>) or should
the translation be added to the velocity verlet (<code>FALSE</code>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other forces: 
<code><a href="#topic+center_force">center_force</a></code>,
<code><a href="#topic+collision_force">collision_force</a></code>,
<code><a href="#topic+field_force">field_force</a></code>,
<code><a href="#topic+link_force">link_force</a></code>,
<code><a href="#topic+manybody_force">manybody_force</a></code>,
<code><a href="#topic+mean_force">mean_force</a></code>,
<code><a href="#topic+random_force">random_force</a></code>,
<code><a href="#topic+reset_force">reset_force</a></code>,
<code><a href="#topic+trap_force">trap_force</a></code>,
<code><a href="#topic+x_force">x_force</a></code>,
<code><a href="#topic+y_force">y_force</a></code>
</p>

<hr>
<h2 id='mean_force'>Apply the mean velocity of all the neighbors to a particle</h2><span id='topic+mean_force'></span>

<h3>Description</h3>

<p>This force takes the mean of all the neighbors (in the graph sense) of a
particle (and optionally itself) and applies it to itself.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the force and can be passed
along a call to <code><a href="#topic+wield">wield()</a></code>
</p>

<ul>
<li> <p><code>include_self</code> : Should the velocity of itself be included in the mean
calculation
</p>
</li>
<li> <p><code>mode</code> : How should neighbors be found? <code>'all'</code> uses all edges. <code>'out'</code>
only uses outbound edges, and <code>'in'</code> only uses inbound edges. Ignored for
undirected particle graphs
</p>
</li></ul>



<h3>See Also</h3>

<p>Other forces: 
<code><a href="#topic+center_force">center_force</a></code>,
<code><a href="#topic+collision_force">collision_force</a></code>,
<code><a href="#topic+field_force">field_force</a></code>,
<code><a href="#topic+link_force">link_force</a></code>,
<code><a href="#topic+manybody_force">manybody_force</a></code>,
<code><a href="#topic+map_force">map_force</a></code>,
<code><a href="#topic+random_force">random_force</a></code>,
<code><a href="#topic+reset_force">reset_force</a></code>,
<code><a href="#topic+trap_force">trap_force</a></code>,
<code><a href="#topic+x_force">x_force</a></code>,
<code><a href="#topic+y_force">y_force</a></code>
</p>

<hr>
<h2 id='path_constraint'>Limit particle position to be along a path or outline</h2><span id='topic+path_constraint'></span>

<h3>Description</h3>

<p>This constraint repositions particles to their closest point along a given
path and sets their velocity to zero.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the constraint and can be
passed along a call to <code><a href="#topic+impose">impose()</a></code>
</p>

<ul>
<li> <p><code>path</code> : A two column matrix giving the path, or a
list of matrices to use multiple disconnected paths.
</p>
</li>
<li> <p><code>closed</code> : Should the path close on itself. Defaults to <code>FALSE</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+dominator_constraint">dominator_constraint</a></code>,
<code><a href="#topic+infinity_constraint">infinity_constraint</a></code>,
<code><a href="#topic+polygon_constraint">polygon_constraint</a></code>,
<code><a href="#topic+velocity_constraint">velocity_constraint</a></code>,
<code><a href="#topic+x_constraint">x_constraint</a></code>,
<code><a href="#topic+y_constraint">y_constraint</a></code>
</p>

<hr>
<h2 id='polygon_constraint'>Fixes particles to be inside a polygon</h2><span id='topic+polygon_constraint'></span>

<h3>Description</h3>

<p>This constraint prevents particles from moving outside of one or more
polygons. If a particle ventures outside it will be moved back to its closest
point inside the specified polygon(s) and have its velocity set to zero.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the constraint and can be
passed along a call to <code><a href="#topic+impose">impose()</a></code>
</p>

<ul>
<li> <p><code>polygon</code> : A two column matrix giving the polygon, or a list of matrices
to use multiple polygons. Overlapping polygons will be subtracted from each
other so it is possible to define polygons with holes.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+dominator_constraint">dominator_constraint</a></code>,
<code><a href="#topic+infinity_constraint">infinity_constraint</a></code>,
<code><a href="#topic+path_constraint">path_constraint</a></code>,
<code><a href="#topic+velocity_constraint">velocity_constraint</a></code>,
<code><a href="#topic+x_constraint">x_constraint</a></code>,
<code><a href="#topic+y_constraint">y_constraint</a></code>
</p>

<hr>
<h2 id='random_force'>Modify the velocity randomly at each step</h2><span id='topic+random_force'></span>

<h3>Description</h3>

<p>This force applies a random velocity modification to all particles. The
modification is uniformly distributed and bound be the parameters provided
during initialisation.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the force and can be passed
along a call to <code><a href="#topic+wield">wield()</a></code>
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;xmin, xmax&#8288;</code> : The bounds of the modification in the horizontal direction
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;ymin, ymax&#8288;</code> : The bounds of the modification in the vertical direction
</p>
</li></ul>



<h3>See Also</h3>

<p>Other forces: 
<code><a href="#topic+center_force">center_force</a></code>,
<code><a href="#topic+collision_force">collision_force</a></code>,
<code><a href="#topic+field_force">field_force</a></code>,
<code><a href="#topic+link_force">link_force</a></code>,
<code><a href="#topic+manybody_force">manybody_force</a></code>,
<code><a href="#topic+map_force">map_force</a></code>,
<code><a href="#topic+mean_force">mean_force</a></code>,
<code><a href="#topic+reset_force">reset_force</a></code>,
<code><a href="#topic+trap_force">trap_force</a></code>,
<code><a href="#topic+x_force">x_force</a></code>,
<code><a href="#topic+y_force">y_force</a></code>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+filter'></span><span id='topic+slice'></span><span id='topic+mutate'></span><span id='topic+mutate_at'></span><span id='topic+mutate_all'></span><span id='topic+activate'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+mutate_all">mutate_all</a></code>, <code><a href="dplyr.html#topic+mutate_all">mutate_at</a></code>, <code><a href="dplyr.html#topic+slice">slice</a></code></p>
</dd>
<dt>tidygraph</dt><dd><p><code><a href="tidygraph.html#topic+activate">activate</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reset_force'>Reset the velocity verlet of particles to a fixed value</h2><span id='topic+reset_force'></span>

<h3>Description</h3>

<p>This force resets the velocity of particles at each generation. It can be
used if each generation should start from the same foundation rather than
accumulate as the simulation evolve. Particles where the parameters evaluates
to <code>NA</code> will ignore this force.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the force and can be passed
along a call to <code><a href="#topic+wield">wield()</a></code>
</p>

<ul>
<li> <p><code>xvel</code> : The x-velocity to reset to at each generation (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>yvel</code> : The y-velocity to reset to at each generation (<em>tidy eval</em>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other forces: 
<code><a href="#topic+center_force">center_force</a></code>,
<code><a href="#topic+collision_force">collision_force</a></code>,
<code><a href="#topic+field_force">field_force</a></code>,
<code><a href="#topic+link_force">link_force</a></code>,
<code><a href="#topic+manybody_force">manybody_force</a></code>,
<code><a href="#topic+map_force">map_force</a></code>,
<code><a href="#topic+mean_force">mean_force</a></code>,
<code><a href="#topic+random_force">random_force</a></code>,
<code><a href="#topic+trap_force">trap_force</a></code>,
<code><a href="#topic+x_force">x_force</a></code>,
<code><a href="#topic+y_force">y_force</a></code>
</p>

<hr>
<h2 id='simulate'>Start a simulation based on a graph</h2><span id='topic+simulate'></span><span id='topic+is.simulation'></span><span id='topic+simulation'></span><span id='topic+record'></span><span id='topic+clear_history'></span><span id='topic+get_history'></span><span id='topic+history_length'></span><span id='topic+reheat'></span><span id='topic+particles'></span><span id='topic+position'></span><span id='topic+velocity'></span><span id='topic+evolutions'></span>

<h3>Description</h3>

<p>This function initiates a simulation based on the provided graph and
parameters. Any graph structure with a <code><a href="tidygraph.html#topic+tbl_graph">tidygraph::as_tbl_graph()</a></code> method
is supported as input. This function does not start the simulation but merely
sets it up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate(
  graph,
  alpha = 1,
  alpha_min = 0.001,
  alpha_decay = 1 - alpha_min^(1/300),
  alpha_target = 0,
  velocity_decay = 0.4,
  setup = phyllotactic_genesis(),
  ...
)

is.simulation(x)

record(simulation, ...)

clear_history(simulation)

get_history(simulation, age = -1)

history_length(simulation)

reheat(simulation, alpha)

particles(simulation)

position(simulation)

velocity(simulation)

evolutions(simulation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_+3A_graph">graph</code></td>
<td>
<p>A graph in a format supported by tidygraph</p>
</td></tr>
<tr><td><code id="simulate_+3A_alpha">alpha</code></td>
<td>
<p>The starting alpha value. See Details.</p>
</td></tr>
<tr><td><code id="simulate_+3A_alpha_min">alpha_min</code></td>
<td>
<p>The minimum alpha value after which the simulation is
terminated. See Details.</p>
</td></tr>
<tr><td><code id="simulate_+3A_alpha_decay">alpha_decay</code></td>
<td>
<p>The speed at which the alpha value decreases. See Details.</p>
</td></tr>
<tr><td><code id="simulate_+3A_alpha_target">alpha_target</code></td>
<td>
<p>The alpha value that alpha drifts towards. See Details.</p>
</td></tr>
<tr><td><code id="simulate_+3A_velocity_decay">velocity_decay</code></td>
<td>
<p>The dampening factor of the system. See Details.</p>
</td></tr>
<tr><td><code id="simulate_+3A_setup">setup</code></td>
<td>
<p>A function that takes the particle graph and returns a start
position and velocity to each particle. <code>particles</code> provides a range of
<a href="#topic+genesis">genesis</a> functions to choose from.</p>
</td></tr>
<tr><td><code id="simulate_+3A_...">...</code></td>
<td>
<p>Additional parameters for the simulation (currently ignored)</p>
</td></tr>
<tr><td><code id="simulate_+3A_x">x</code>, <code id="simulate_+3A_simulation">simulation</code></td>
<td>
<p>A simulation object</p>
</td></tr>
<tr><td><code id="simulate_+3A_age">age</code></td>
<td>
<p>The version to retrieve. Positive numbers count from the
beginning, while negative numbers counts backwards from current version.
Defaults to <code>-1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simulation in the context of the particles package is a series of
equidistant steps where the velocity and position of each particle is
updated. A few global rules applies to this cycle irrespectively of the
forces added to the simulation. Once a simulation is initiated an <code>alpha</code>
value is defined (defaults to <code>1</code>). At each step this alpha value is
decreased according to its distance to the <code>alpha_target</code> (defaults to <code>0</code>)
and <code>alpha_decay</code> (defaults to ~<code>0.023</code>). Once the alpha value gets below
<code>alpha_min</code> (defaults to <code>0.001</code>) the simulation seizes to take additional
steps. The default values is adapted from the d3-force implementation and
corresponds to 300 steps. Conceptually the <code>alpha</code> progression can be seen
as a cooling off of the system as the value decreases quickly in the
beginning and then slowly reach the target value. If it is not intended to
have a system that cools off, simply set the <code>alpha_target</code> value to the same
as <code>alpha</code>. At each step, after the new particle velocities has been
calculated but before they have been applied to the positions, a dampening
factor (<code>velocity_decay</code>) is applied in order to simulate the gradual loss
of momentum. If this is not intended for the simulation, simply set the value
to <code>0</code>.
</p>


<h3>Value</h3>

<p>A simulation object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>record()</code>: Save the current state in the simulation's history
</p>
</li>
<li> <p><code>clear_history()</code>: Clear the current history from the simulation
</p>
</li>
<li> <p><code>get_history()</code>: Retrieve a simulation from the history
</p>
</li>
<li> <p><code>history_length()</code>: Get the number of versions stored in the history of the simulation
</p>
</li>
<li> <p><code>reheat()</code>: set the cooling of the simulation to a new value
</p>
</li>
<li> <p><code>particles()</code>: Extract the particle graph from a simulation
</p>
</li>
<li> <p><code>position()</code>: Extract the position coordinates from a simulation
</p>
</li>
<li> <p><code>velocity()</code>: Extract the velocity verlets from a simulation
</p>
</li>
<li> <p><code>evolutions()</code>: Get the number of generations the simulation has undergone
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- tidygraph::create_notable('folkman')
graph |&gt;
  simulate()

</code></pre>

<hr>
<h2 id='simulation_modification'>Modify the particles in a simulation</h2><span id='topic+simulation_modification'></span><span id='topic+add_particles'></span><span id='topic+replace_particles'></span><span id='topic+add_interaction'></span>

<h3>Description</h3>

<p>The particles that are modelled in a simulation are encoded as a <code>tbl_graph</code>,
giving support for the particles as well as their interactions (nodes and
edges in graph parlor). A simulation supports a subset of the tidygraph/dplyr
verbs in order to allow modification of the particles after they have been
included in the simulation. In general it is possible to add and remove
particles and interactions as well as modify the metadata associated with
them. The API follows the tidygraph API where <code>activate()</code> is used to select
either particles or interactions and subsequent operations are thus related
to the last activated datatype. The simulation is automatically retrained
after modifying the state of the particles and their interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_particles(.data, ..., interactions = NULL, setup = NULL)

replace_particles(.data, particles, setup = NULL)

add_interaction(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulation_modification_+3A_.data">.data</code></td>
<td>
<p>A simulation object</p>
</td></tr>
<tr><td><code id="simulation_modification_+3A_...">...</code></td>
<td>
<p>Parameters passed on to the main verbs in tidygraph/dplyr</p>
</td></tr>
<tr><td><code id="simulation_modification_+3A_interactions">interactions</code></td>
<td>
<p>A data.frame of interactions/edges to add along with the
particles</p>
</td></tr>
<tr><td><code id="simulation_modification_+3A_setup">setup</code></td>
<td>
<p>A function to calculate the starting conditions for the
particles. It receives all particles with the current position and
velocity encoded in the <code>x</code>, <code>y</code>, <code>x_vel</code>, and <code>y_vel</code> columns. New particle
will have NA. The function must return a position and velocity for all
particles even though the values for the current particles will be discarded.
If NULL it will use the genesis function used when creating the simulation.</p>
</td></tr>
<tr><td><code id="simulation_modification_+3A_particles">particles</code></td>
<td>
<p>A <code>tbl_graph</code> or an object coercible to one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simulation object
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+mutate_all">dplyr::mutate_at()</a></code>, <code><a href="dplyr.html#topic+mutate_all">dplyr::mutate_all()</a></code>,
<code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="tidygraph.html#topic+activate">tidygraph::activate()</a></code>,
<code><a href="tidygraph.html#topic+bind_graphs">tidygraph::bind_nodes()</a></code>, <code><a href="tidygraph.html#topic+bind_graphs">tidygraph::bind_edges()</a></code>
</p>

<hr>
<h2 id='trap_force'>Attract and trap particles within polygons</h2><span id='topic+trap_force'></span>

<h3>Description</h3>

<p>This force creates a trap based on any type of polygon that attracts
particles as long as they are outside the polygon, while leaving particles
inside the polygon unaffected. The trap as such has no walls and particles
are allowed to leave it, but they will be pulled back as soon as they exits
the polygon.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the force and can be passed
along a call to <code><a href="#topic+wield">wield()</a></code>
</p>

<ul>
<li> <p><code>polygon</code> : A two column matrix giving the corners of the polygon, or a
list of matrices to use multiple polygons. If multiple polygons are
overlapping it is considered a hole.
</p>
</li>
<li> <p><code>strength</code> : The attractive force applied to the particle. Particles are
attracted towards the closest part of the polygon, rather than the center,
and the attraction is stronger for particles moving away from the polygon
than for those moving towards it. (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>min_dist</code> : A lower distance threshold below which the strength is not
increased. The attraction of the trap falls of with the square of the
distance to the particle, so particles close by can get an enormous
attraction unless this threshold is set (so much that the shoot out of the
other side of the trap).
</p>
</li>
<li> <p><code>distance_falloff</code> : How should the attractive force deteriorate with the
distance between the polygon and the particle. Defaults to 2 (quadratic
falloff) (<em>tidy eval</em>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other forces: 
<code><a href="#topic+center_force">center_force</a></code>,
<code><a href="#topic+collision_force">collision_force</a></code>,
<code><a href="#topic+field_force">field_force</a></code>,
<code><a href="#topic+link_force">link_force</a></code>,
<code><a href="#topic+manybody_force">manybody_force</a></code>,
<code><a href="#topic+map_force">map_force</a></code>,
<code><a href="#topic+mean_force">mean_force</a></code>,
<code><a href="#topic+random_force">random_force</a></code>,
<code><a href="#topic+reset_force">reset_force</a></code>,
<code><a href="#topic+x_force">x_force</a></code>,
<code><a href="#topic+y_force">y_force</a></code>
</p>

<hr>
<h2 id='velocity_constraint'>Limits particles to a specific velocity range</h2><span id='topic+velocity_constraint'></span>

<h3>Description</h3>

<p>This constraint puts bounds on the magnitude of velocity a particle can have.
Particles where either end of the bound is NA ignores the constraint. If a
particle with no velocity is forced to have a velocity the direction will be
random.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the constraint and can be
passed along a call to <code><a href="#topic+impose">impose()</a></code>
</p>

<ul>
<li> <p><code>v</code> : The velocity allowed for the particle. (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>vmin</code> : The lowest permissible velocity. If <code>NULL</code> then <code>v</code> will be used. (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>vmax</code> : The highest permissible velocity. If <code>NULL</code> then <code>v</code> will be used. (<em>tidy eval</em>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+dominator_constraint">dominator_constraint</a></code>,
<code><a href="#topic+infinity_constraint">infinity_constraint</a></code>,
<code><a href="#topic+path_constraint">path_constraint</a></code>,
<code><a href="#topic+polygon_constraint">polygon_constraint</a></code>,
<code><a href="#topic+x_constraint">x_constraint</a></code>,
<code><a href="#topic+y_constraint">y_constraint</a></code>
</p>

<hr>
<h2 id='x_constraint'>Fixes particles to a horizontal position</h2><span id='topic+x_constraint'></span>

<h3>Description</h3>

<p>This constraint simply prevents particles from moving in the x direction. For
particles where the constraint evaluates to <code>NA</code> this constraint is ignored.
If the constraint is enforced the velocity in the x direction will be set to
<code>0</code>.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the constraint and can be
passed along a call to <code><a href="#topic+impose">impose()</a></code>
</p>

<ul>
<li> <p><code>x</code> : The position on the x-axis to fix to. (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>xmin</code> : The lowest permissible x-value. If <code>NULL</code> then <code>x</code> will be used. (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>xmax</code> : The highest permissible x-value. If <code>NULL</code> then <code>x</code> will be used. (<em>tidy eval</em>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+dominator_constraint">dominator_constraint</a></code>,
<code><a href="#topic+infinity_constraint">infinity_constraint</a></code>,
<code><a href="#topic+path_constraint">path_constraint</a></code>,
<code><a href="#topic+polygon_constraint">polygon_constraint</a></code>,
<code><a href="#topic+velocity_constraint">velocity_constraint</a></code>,
<code><a href="#topic+y_constraint">y_constraint</a></code>
</p>

<hr>
<h2 id='x_force'>Attract particles towards a horizontal position</h2><span id='topic+x_force'></span>

<h3>Description</h3>

<p>This force simply pulls particles towards a fixed position on the x-axis.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the force and can be passed
along a call to <code><a href="#topic+wield">wield()</a></code>
</p>

<ul>
<li> <p><code>strength</code> : The strength with which the attraction occurs (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>x</code> : The position on the x-axis to pull towards. (<em>tidy eval</em>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other forces: 
<code><a href="#topic+center_force">center_force</a></code>,
<code><a href="#topic+collision_force">collision_force</a></code>,
<code><a href="#topic+field_force">field_force</a></code>,
<code><a href="#topic+link_force">link_force</a></code>,
<code><a href="#topic+manybody_force">manybody_force</a></code>,
<code><a href="#topic+map_force">map_force</a></code>,
<code><a href="#topic+mean_force">mean_force</a></code>,
<code><a href="#topic+random_force">random_force</a></code>,
<code><a href="#topic+reset_force">reset_force</a></code>,
<code><a href="#topic+trap_force">trap_force</a></code>,
<code><a href="#topic+y_force">y_force</a></code>
</p>

<hr>
<h2 id='y_constraint'>Fixes particles to a vertical position</h2><span id='topic+y_constraint'></span>

<h3>Description</h3>

<p>This constraint simply prevents particles from moving in the y direction. For
particles where the constraint evaluates to <code>NA</code> this constraint is ignored.
If the constraint is enforced the velocity in the y direction will be set to
<code>0</code>.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the constraint and can be
passed along a call to <code><a href="#topic+impose">impose()</a></code>
</p>

<ul>
<li> <p><code>y</code> : The position on the y-axis to fix to. (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>ymin</code> : The lowest permissible y-value. If <code>NULL</code> then <code>y</code> will be used. (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>ymax</code> : The highest permissible y-value. If <code>NULL</code> then <code>y</code> will be used. (<em>tidy eval</em>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+dominator_constraint">dominator_constraint</a></code>,
<code><a href="#topic+infinity_constraint">infinity_constraint</a></code>,
<code><a href="#topic+path_constraint">path_constraint</a></code>,
<code><a href="#topic+polygon_constraint">polygon_constraint</a></code>,
<code><a href="#topic+velocity_constraint">velocity_constraint</a></code>,
<code><a href="#topic+x_constraint">x_constraint</a></code>
</p>

<hr>
<h2 id='y_force'>Attract particles towards a vertical position</h2><span id='topic+y_force'></span>

<h3>Description</h3>

<p>This force simply pulls particles towards a fixed position on the y-axis.
</p>


<h3>Training parameters</h3>

<p>The following parameters defines the training of the force and can be passed
along a call to <code><a href="#topic+wield">wield()</a></code>
</p>

<ul>
<li> <p><code>strength</code> : The strength with which the attraction occurs (<em>tidy eval</em>)
</p>
</li>
<li> <p><code>y</code> : The position on the y-axis to pull towards. (<em>tidy eval</em>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other forces: 
<code><a href="#topic+center_force">center_force</a></code>,
<code><a href="#topic+collision_force">collision_force</a></code>,
<code><a href="#topic+field_force">field_force</a></code>,
<code><a href="#topic+link_force">link_force</a></code>,
<code><a href="#topic+manybody_force">manybody_force</a></code>,
<code><a href="#topic+map_force">map_force</a></code>,
<code><a href="#topic+mean_force">mean_force</a></code>,
<code><a href="#topic+random_force">random_force</a></code>,
<code><a href="#topic+reset_force">reset_force</a></code>,
<code><a href="#topic+trap_force">trap_force</a></code>,
<code><a href="#topic+x_force">x_force</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
