<!DOCTYPE html><html><head><title>Help for package splitFeas</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {splitFeas}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#backtrack'><p>Backtracking Line Search</p></a></li>
<li><a href='#ddg'><p>Compute the approximate Hessian of the majorization.</p></a></li>
<li><a href='#dg'><p>Compute the gradient of the majorization.</p></a></li>
<li><a href='#mmqn_step'><p>MM-quasi-Newton step</p></a></li>
<li><a href='#nmsfp_mm'><p>MM algorithm for nonlinear multiple-sets split feasibility problem</p></a></li>
<li><a href='#nmsfp_mmqn'><p>MM algorithm (accelerated) for nonlinear multiple-sets split feasibility problem</p></a></li>
<li><a href='#nmsfp_sap'><p>Self-adaptive projection-type method algorithm for nonlinear multiple-sets split feasibility problem</p></a></li>
<li><a href='#nmsfp_sap_one_step'><p>One step of self-adaptive projection-type method for the NMSFP</p></a></li>
<li><a href='#project_ball'><p>Projection onto a ball</p></a></li>
<li><a href='#project_cube'><p>Project onto a cube</p></a></li>
<li><a href='#project_halfspace'><p>Projection onto a halfspace</p></a></li>
<li><a href='#project_square'><p>Project onto a square</p></a></li>
<li><a href='#proximity'><p>Proximity function</p></a></li>
<li><a href='#qnamm'><p>Quasi-Newton acceleration of MM algorithm</p></a></li>
<li><a href='#softmax'><p>Compute soft-max</p></a></li>
<li><a href='#split_feasibility'><p>split_feasibility</p></a></li>
<li><a href='#wood_inv_solve'><p>Compute the inverse approximate Hessian of the majorization using the Woodbury inversion formula.</p>
<code>wood_inv_solve</code> computes the inverse of the Hessian term of the majorization of the proximity function
using the Woodbury formula. The function <code>mmqn_step</code> invokes <code>wood_inv_solve</code> instead of ddg if the argument
<code>woodbury=TRUE</code>. This should be used when p &lt;&lt; n.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multi-Set Split Feasibility</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the majorization-minimization (MM) algorithm introduced by
    Xu, Chi, Yang, and Lange (2017) &lt;<a href="https://arxiv.org/abs/1612.05614">arXiv:1612.05614</a>&gt; for solving multi-set split feasibility problems. In the multi-set split feasibility problem, we seek to find a point x
    in the intersection of multiple closed sets and whose image under a mapping also must fall in the intersection of several closed sets.</td>
</tr>
<tr>
<td>Depends:</td>
<td>compiler, corpcor, matrixStats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-04-10 17:18:01 UTC; ecchi</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric C. Chi [aut, cre, cph],
  Jason Xu [ctb],
  Meng Yang [ctb],
  Kenneth Lange [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric C. Chi &lt;ecchi1105@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-04-11 08:15:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='backtrack'>Backtracking Line Search</h2><span id='topic+backtrack'></span>

<h3>Description</h3>

<p>Given a descent direction <code>backtrack</code> computes a step size that ensures sufficient decrease in an objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backtrack(x, dx, f, df, alpha = 0.01, beta = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backtrack_+3A_x">x</code></td>
<td>
<p>Current iterate</p>
</td></tr>
<tr><td><code id="backtrack_+3A_dx">dx</code></td>
<td>
<p>Descent direction</p>
</td></tr>
<tr><td><code id="backtrack_+3A_f">f</code></td>
<td>
<p>objective function</p>
</td></tr>
<tr><td><code id="backtrack_+3A_df">df</code></td>
<td>
<p>gradient of objective function</p>
</td></tr>
<tr><td><code id="backtrack_+3A_alpha">alpha</code></td>
<td>
<p>sufficient decrease parameter</p>
</td></tr>
<tr><td><code id="backtrack_+3A_beta">beta</code></td>
<td>
<p>sufficient decrease parameter</p>
</td></tr>
</table>

<hr>
<h2 id='ddg'>Compute the approximate Hessian of the majorization.</h2><span id='topic+ddg'></span>

<h3>Description</h3>

<p><code>ddg</code> computes the Hessian of the majorization of the proximity function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddg(x, v, w, hgrad)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddg_+3A_x">x</code></td>
<td>
<p>non-anchor point</p>
</td></tr>
<tr><td><code id="ddg_+3A_v">v</code></td>
<td>
<p>weights for first set of constraints</p>
</td></tr>
<tr><td><code id="ddg_+3A_w">w</code></td>
<td>
<p>weights for second set of constraints</p>
</td></tr>
<tr><td><code id="ddg_+3A_hgrad">hgrad</code></td>
<td>
<p>Handle for output mapping Jacobian</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
n &lt;- 10
p &lt;- 2
x &lt;- matrix(rnorm(p),p,1)
v &lt;- 1
w &lt;- 1
A &lt;- matrix(rnorm(n*p),n,p)
hgrad &lt;- function(x) {return(t(A))}
sol &lt;- ddg(x,v,w,hgrad)
</code></pre>

<hr>
<h2 id='dg'>Compute the gradient of the majorization.</h2><span id='topic+dg'></span>

<h3>Description</h3>

<p><code>dg</code> computes the gradient of the majorization of the proximity function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dg(x, xa, v, w, plist1, plist2, h, hgrad)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dg_+3A_x">x</code></td>
<td>
<p>non-anchor point</p>
</td></tr>
<tr><td><code id="dg_+3A_xa">xa</code></td>
<td>
<p>Anchor point</p>
</td></tr>
<tr><td><code id="dg_+3A_v">v</code></td>
<td>
<p>weights for first set of constraints</p>
</td></tr>
<tr><td><code id="dg_+3A_w">w</code></td>
<td>
<p>weights for second set of constraints</p>
</td></tr>
<tr><td><code id="dg_+3A_plist1">plist1</code></td>
<td>
<p>list of projection functions for first set of constraints; each takes a single point and returns its projection</p>
</td></tr>
<tr><td><code id="dg_+3A_plist2">plist2</code></td>
<td>
<p>list of projection functions for second set of constraints; each takes a single point and returns its projection</p>
</td></tr>
<tr><td><code id="dg_+3A_h">h</code></td>
<td>
<p>Function handle for output mapping</p>
</td></tr>
<tr><td><code id="dg_+3A_hgrad">hgrad</code></td>
<td>
<p>Handle for output mapping Jacobian</p>
</td></tr>
</table>

<hr>
<h2 id='mmqn_step'>MM-quasi-Newton step</h2><span id='topic+mmqn_step'></span>

<h3>Description</h3>

<p><code>mmqn_step</code> computes a single step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmqn_step(x, v, w, plist1, plist2, f, df, h, hgrad, woodbury = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmqn_step_+3A_x">x</code></td>
<td>
<p>Current iterate</p>
</td></tr>
<tr><td><code id="mmqn_step_+3A_v">v</code></td>
<td>
<p>weights for first set of constraints</p>
</td></tr>
<tr><td><code id="mmqn_step_+3A_w">w</code></td>
<td>
<p>weights for second set of constraints</p>
</td></tr>
<tr><td><code id="mmqn_step_+3A_plist1">plist1</code></td>
<td>
<p>list of projection functions for first set of constraints; each takes a single point and returns its projection</p>
</td></tr>
<tr><td><code id="mmqn_step_+3A_plist2">plist2</code></td>
<td>
<p>list of projection functions for second set of constraints; each takes a single point and returns its projection</p>
</td></tr>
<tr><td><code id="mmqn_step_+3A_f">f</code></td>
<td>
<p>objective function</p>
</td></tr>
<tr><td><code id="mmqn_step_+3A_df">df</code></td>
<td>
<p>gradient of objective function</p>
</td></tr>
<tr><td><code id="mmqn_step_+3A_h">h</code></td>
<td>
<p>Function handle for output mapping</p>
</td></tr>
<tr><td><code id="mmqn_step_+3A_hgrad">hgrad</code></td>
<td>
<p>Handle for output mapping Jacobian</p>
</td></tr>
<tr><td><code id="mmqn_step_+3A_woodbury">woodbury</code></td>
<td>
<p>Boolean: TRUE to use the Woodbury inversion formula</p>
</td></tr>
</table>

<hr>
<h2 id='nmsfp_mm'>MM algorithm for nonlinear multiple-sets split feasibility problem</h2><span id='topic+nmsfp_mm'></span>

<h3>Description</h3>

<p><code>nmsfp_mm</code> uses quasi-Newton updates to solve the nonlinear multiple-sets split feasibility problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmsfp_mm(x0, v, w, plist1, plist2, f, df, h, hgrad, tol = 1e-10,
  max_iter = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmsfp_mm_+3A_x0">x0</code></td>
<td>
<p>Initial iterate</p>
</td></tr>
<tr><td><code id="nmsfp_mm_+3A_v">v</code></td>
<td>
<p>weights for first set of constraints</p>
</td></tr>
<tr><td><code id="nmsfp_mm_+3A_w">w</code></td>
<td>
<p>weights for second set of constraints</p>
</td></tr>
<tr><td><code id="nmsfp_mm_+3A_plist1">plist1</code></td>
<td>
<p>list of projection functions for first set of constraints; each takes a single point and returns its projection</p>
</td></tr>
<tr><td><code id="nmsfp_mm_+3A_plist2">plist2</code></td>
<td>
<p>list of projection functions for second set of constraints; each takes a single point and returns its projection</p>
</td></tr>
<tr><td><code id="nmsfp_mm_+3A_f">f</code></td>
<td>
<p>objective function</p>
</td></tr>
<tr><td><code id="nmsfp_mm_+3A_df">df</code></td>
<td>
<p>gradient of objective function</p>
</td></tr>
<tr><td><code id="nmsfp_mm_+3A_h">h</code></td>
<td>
<p>Function handle for output mapping</p>
</td></tr>
<tr><td><code id="nmsfp_mm_+3A_hgrad">hgrad</code></td>
<td>
<p>Handle for output mapping Jacobian</p>
</td></tr>
<tr><td><code id="nmsfp_mm_+3A_tol">tol</code></td>
<td>
<p>Stopping tolerance</p>
</td></tr>
<tr><td><code id="nmsfp_mm_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>mmqn_step</code>
</p>

<hr>
<h2 id='nmsfp_mmqn'>MM algorithm (accelerated) for nonlinear multiple-sets split feasibility problem</h2><span id='topic+nmsfp_mmqn'></span>

<h3>Description</h3>

<p><code>nmsfp_mmqn</code> uses quasi-Newton updates to solve the nonlinear multiple-sets split feasibility problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmsfp_mmqn(x0, v, w, plist1, plist2, f, df, h, hgrad, qn = 5, tol = 1e-10,
  max_iter = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmsfp_mmqn_+3A_x0">x0</code></td>
<td>
<p>Initial iterate</p>
</td></tr>
<tr><td><code id="nmsfp_mmqn_+3A_v">v</code></td>
<td>
<p>weights for first set of constraints</p>
</td></tr>
<tr><td><code id="nmsfp_mmqn_+3A_w">w</code></td>
<td>
<p>weights for second set of constraints</p>
</td></tr>
<tr><td><code id="nmsfp_mmqn_+3A_plist1">plist1</code></td>
<td>
<p>list of projection functions for first set of constraints; each takes a single point and returns its projection</p>
</td></tr>
<tr><td><code id="nmsfp_mmqn_+3A_plist2">plist2</code></td>
<td>
<p>list of projection functions for second set of constraints; each takes a single point and returns its projection</p>
</td></tr>
<tr><td><code id="nmsfp_mmqn_+3A_f">f</code></td>
<td>
<p>objective function</p>
</td></tr>
<tr><td><code id="nmsfp_mmqn_+3A_df">df</code></td>
<td>
<p>gradient of objective function</p>
</td></tr>
<tr><td><code id="nmsfp_mmqn_+3A_h">h</code></td>
<td>
<p>Function handle for output mapping</p>
</td></tr>
<tr><td><code id="nmsfp_mmqn_+3A_hgrad">hgrad</code></td>
<td>
<p>Handle for output mapping Jacobian</p>
</td></tr>
<tr><td><code id="nmsfp_mmqn_+3A_qn">qn</code></td>
<td>
<p>number of secants</p>
</td></tr>
<tr><td><code id="nmsfp_mmqn_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance</p>
</td></tr>
<tr><td><code id="nmsfp_mmqn_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>mmqn_step</code>, <code>qnamm</code>
</p>

<hr>
<h2 id='nmsfp_sap'>Self-adaptive projection-type method algorithm for nonlinear multiple-sets split feasibility problem</h2><span id='topic+nmsfp_sap'></span>

<h3>Description</h3>

<p><code>nmsfp_sap</code> performs the self-adaptive projection-type method of Li et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmsfp_sap(x0, v, w, plist1, plist2, proj, f, df, h, hgrad, delta = 0.3,
  mu = 0.7, beta0 = 1, tol = 1e-10, max_iter = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmsfp_sap_+3A_x0">x0</code></td>
<td>
<p>Initial iterate</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_v">v</code></td>
<td>
<p>weights for first set of constraints</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_w">w</code></td>
<td>
<p>weights for second set of constraints</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_plist1">plist1</code></td>
<td>
<p>list of projection functions for first set of constraints; each takes a single point and returns its projection</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_plist2">plist2</code></td>
<td>
<p>list of projection functions for second set of constraints; each takes a single point and returns its projection</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_proj">proj</code></td>
<td>
<p>handle to projection operation.</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_f">f</code></td>
<td>
<p>objective function</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_df">df</code></td>
<td>
<p>gradient of objective function</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_h">h</code></td>
<td>
<p>Function handle for output mapping</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_hgrad">hgrad</code></td>
<td>
<p>Handle for output mapping Jacobian</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_delta">delta</code></td>
<td>
<p>step-size parameter</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_mu">mu</code></td>
<td>
<p>step-size parameter</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_beta0">beta0</code></td>
<td>
<p>initial</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_tol">tol</code></td>
<td>
<p>Tolerance</p>
</td></tr>
<tr><td><code id="nmsfp_sap_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
</table>

<hr>
<h2 id='nmsfp_sap_one_step'>One step of self-adaptive projection-type method for the NMSFP</h2><span id='topic+nmsfp_sap_one_step'></span>

<h3>Description</h3>

<p><code>nmsfp_sap_one_step</code> performs the self-adaptive projection-type method of Li et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmsfp_sap_one_step(x, delta, mu, tau, gamma, df, proj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmsfp_sap_one_step_+3A_x">x</code></td>
<td>
<p>current iterate</p>
</td></tr>
<tr><td><code id="nmsfp_sap_one_step_+3A_delta">delta</code></td>
<td>
<p>step-size parameter</p>
</td></tr>
<tr><td><code id="nmsfp_sap_one_step_+3A_mu">mu</code></td>
<td>
<p>step-size parameter</p>
</td></tr>
<tr><td><code id="nmsfp_sap_one_step_+3A_tau">tau</code></td>
<td>
<p>step-size parameter</p>
</td></tr>
<tr><td><code id="nmsfp_sap_one_step_+3A_gamma">gamma</code></td>
<td>
<p>step-size parameter</p>
</td></tr>
<tr><td><code id="nmsfp_sap_one_step_+3A_df">df</code></td>
<td>
<p>handle to gradient of objective function</p>
</td></tr>
<tr><td><code id="nmsfp_sap_one_step_+3A_proj">proj</code></td>
<td>
<p>handle to projection operation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Li, Han, and Zhang. (2013) A self-adaptive projection-type method for nonlinear 
multiple-sets split feasibility problem, Inverse Problems in Science and Engineering,
21(1):155-170.
</p>

<hr>
<h2 id='project_ball'>Projection onto a ball</h2><span id='topic+project_ball'></span>

<h3>Description</h3>

<p><code>project_ball</code> computes the Euclidean projection of a point onto a ball.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_ball(x, center, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_ball_+3A_x">x</code></td>
<td>
<p>Point to project</p>
</td></tr>
<tr><td><code id="project_ball_+3A_center">center</code></td>
<td>
<p>Center of the sphere</p>
</td></tr>
<tr><td><code id="project_ball_+3A_r">r</code></td>
<td>
<p>Radius of the sphere</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
p &lt;- 3
center &lt;- rnorm(p)
r &lt;- runif(1)
x &lt;- rnorm(p)
y &lt;- project_ball(x,center,r)
</code></pre>

<hr>
<h2 id='project_cube'>Project onto a cube</h2><span id='topic+project_cube'></span>

<h3>Description</h3>

<p><code>project_cube</code> computes the Euclidean projection of a point onto a cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_cube(x, center, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_cube_+3A_x">x</code></td>
<td>
<p>Point to project</p>
</td></tr>
<tr><td><code id="project_cube_+3A_center">center</code></td>
<td>
<p>Center of the square</p>
</td></tr>
<tr><td><code id="project_cube_+3A_r">r</code></td>
<td>
<p>Half the length of a side</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
p &lt;- 3
center &lt;- matrix(rnorm(p),p,1)
r &lt;- runif(1)
x &lt;- matrix(rnorm(p),p,1)
y &lt;- project_cube(x,center,r)
</code></pre>

<hr>
<h2 id='project_halfspace'>Projection onto a halfspace</h2><span id='topic+project_halfspace'></span>

<h3>Description</h3>

<p><code>project_halfspace</code> computes the Euclidean projection of a point onto a closed half-space.
The function returns the projection onto the set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_halfspace(x, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_halfspace_+3A_x">x</code></td>
<td>
<p>Point to project</p>
</td></tr>
<tr><td><code id="project_halfspace_+3A_a">a</code></td>
<td>
<p>is the normal vector</p>
</td></tr>
<tr><td><code id="project_halfspace_+3A_b">b</code></td>
<td>
<p>is the threshold</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
p &lt;- 3
a &lt;- matrix(rnorm(p),p,1)
a &lt;- a/norm(a,'f')
b &lt;- runif(1)
x &lt;- matrix(rnorm(p),p,1)
y &lt;- project_halfspace(x,a,b)
</code></pre>

<hr>
<h2 id='project_square'>Project onto a square</h2><span id='topic+project_square'></span>

<h3>Description</h3>

<p><code>project_square</code> computes the Euclidean projection of a point onto a square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_square(x, center, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_square_+3A_x">x</code></td>
<td>
<p>Point to project</p>
</td></tr>
<tr><td><code id="project_square_+3A_center">center</code></td>
<td>
<p>Center of the square</p>
</td></tr>
<tr><td><code id="project_square_+3A_r">r</code></td>
<td>
<p>Half the length of a side</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
p &lt;- 2
center &lt;- matrix(rnorm(p),p,1)
r &lt;- runif(1)
x &lt;- matrix(rnorm(p),p,1)
y &lt;- project_square(x,center,r)
</code></pre>

<hr>
<h2 id='proximity'>Proximity function</h2><span id='topic+proximity'></span>

<h3>Description</h3>

<p><code>proximity</code> computes the proximity function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proximity(x, v, w, plist1, plist2, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proximity_+3A_x">x</code></td>
<td>
<p>Current iterate</p>
</td></tr>
<tr><td><code id="proximity_+3A_v">v</code></td>
<td>
<p>weights for first set of constraints</p>
</td></tr>
<tr><td><code id="proximity_+3A_w">w</code></td>
<td>
<p>weights for second set of constraints</p>
</td></tr>
<tr><td><code id="proximity_+3A_plist1">plist1</code></td>
<td>
<p>list of projection functions for first set of constraints; each takes a single point and returns its projection</p>
</td></tr>
<tr><td><code id="proximity_+3A_plist2">plist2</code></td>
<td>
<p>list of projection functions for second set of constraints; each takes a single point and returns its projection</p>
</td></tr>
<tr><td><code id="proximity_+3A_h">h</code></td>
<td>
<p>Function handle for output mapping</p>
</td></tr>
</table>

<hr>
<h2 id='qnamm'>Quasi-Newton acceleration of MM algorithm</h2><span id='topic+qnamm'></span>

<h3>Description</h3>

<p><code>qnamm</code> performs Quasi-Newton acceleration of an MM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qnamm(x, fx_mm, qn, fx_obj, max_iter = 100, tol = 1e-06, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qnamm_+3A_x">x</code></td>
<td>
<p>initial iterate</p>
</td></tr>
<tr><td><code id="qnamm_+3A_fx_mm">fx_mm</code></td>
<td>
<p>MM algorithm map</p>
</td></tr>
<tr><td><code id="qnamm_+3A_qn">qn</code></td>
<td>
<p>number of secants</p>
</td></tr>
<tr><td><code id="qnamm_+3A_fx_obj">fx_obj</code></td>
<td>
<p>handle to objective function</p>
</td></tr>
<tr><td><code id="qnamm_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="qnamm_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance</p>
</td></tr>
<tr><td><code id="qnamm_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>fx_mm</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>H Zhou, D Alexander, and K Lange. (2011) A quasi-Newton acceleration method for high-dimensional optimization algorithms, Statistics and Computing, 21(2):261-273.
</p>

<hr>
<h2 id='softmax'>Compute soft-max</h2><span id='topic+softmax'></span>

<h3>Description</h3>

<p><code>softmax</code> returns the soft maximum of a collection of reals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>softmax(x, a = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="softmax_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="softmax_+3A_a">a</code></td>
<td>
<p>scaling factor</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
n &lt;- 10
x &lt;- rnorm(n)
softmax(x)
</code></pre>

<hr>
<h2 id='split_feasibility'>split_feasibility</h2><span id='topic+split_feasibility'></span><span id='topic+split_feasibility-package'></span>

<h3>Description</h3>

<p>split_feasibility
</p>

<hr>
<h2 id='wood_inv_solve'>Compute the inverse approximate Hessian of the majorization using the Woodbury inversion formula.
<code>wood_inv_solve</code> computes the inverse of the Hessian term of the majorization of the proximity function
using the Woodbury formula. The function <code>mmqn_step</code> invokes <code>wood_inv_solve</code> instead of ddg if the argument
<code>woodbury=TRUE</code>. This should be used when p &lt;&lt; n.</h2><span id='topic+wood_inv_solve'></span>

<h3>Description</h3>

<p>Compute the inverse approximate Hessian of the majorization using the Woodbury inversion formula.
<code>wood_inv_solve</code> computes the inverse of the Hessian term of the majorization of the proximity function
using the Woodbury formula. The function <code>mmqn_step</code> invokes <code>wood_inv_solve</code> instead of ddg if the argument
<code>woodbury=TRUE</code>. This should be used when p &lt;&lt; n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wood_inv_solve(x, v, w, hgrad, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wood_inv_solve_+3A_x">x</code></td>
<td>
<p>non-anchor point</p>
</td></tr>
<tr><td><code id="wood_inv_solve_+3A_v">v</code></td>
<td>
<p>weights for first set of constraints</p>
</td></tr>
<tr><td><code id="wood_inv_solve_+3A_w">w</code></td>
<td>
<p>weights for second set of constraints</p>
</td></tr>
<tr><td><code id="wood_inv_solve_+3A_hgrad">hgrad</code></td>
<td>
<p>Handle for output mapping Jacobian</p>
</td></tr>
<tr><td><code id="wood_inv_solve_+3A_df">df</code></td>
<td>
<p>Right hand side</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
