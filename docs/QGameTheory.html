<!DOCTYPE html><html><head><title>Help for package QGameTheory</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {QGameTheory}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bell'><p>Bell States</p></a></li>
<li><a href='#CNOT'><p>CNOT gate</p></a></li>
<li><a href='#col_count'><p>Number of columns of a vector/matrix</p></a></li>
<li><a href='#Fredkin'><p>Fredkin Gate</p></a></li>
<li><a href='#Hadamard'><p>Hadamard Gate</p></a></li>
<li><a href='#IDSDS'><p>Iterated Deletion of Strictly Dominated Strategies algorithm</p></a></li>
<li><a href='#init'><p>Initialization</p></a></li>
<li><a href='#levi_civita'><p>Levi-Civita symbol</p></a></li>
<li><a href='#NASH'><p>Nash Equilibrium</p></a></li>
<li><a href='#PayoffMatrix_QBOS'><p>Quantum Battle of the Sexes game: Payoff Matrix</p></a></li>
<li><a href='#PayoffMatrix_QHawkDove'><p>Quantum Hawk and Dove game: Payoff Matrix</p></a></li>
<li><a href='#PayoffMatrix_QPD'><p>Quantum Prisoner's Dilemma game: Payoff Matrix</p></a></li>
<li><a href='#Phase'><p>Phase Gate</p></a></li>
<li><a href='#PhaseDagger'><p>Hermitian Transpose of the Phase Gate</p></a></li>
<li><a href='#QBOS'><p>Quantum Battle of the Sexes game</p></a></li>
<li><a href='#QDuels_Alice_payoffs'><p>Quantum Two Person Duel game</p></a></li>
<li><a href='#QDuels_Bob_payoffs'><p>Quantum Two Person Duel game</p></a></li>
<li><a href='#QDuelsPlot1'><p>Quantum Two Person Duel game</p></a></li>
<li><a href='#QDuelsPlot2'><p>Quantum Two Person Duel game</p></a></li>
<li><a href='#QDuelsPlot3'><p>Quantum Two Person Duel game</p></a></li>
<li><a href='#QDuelsPlot4'><p>Quantum Two Person Duel game</p></a></li>
<li><a href='#QFT'><p>Quantum Fourier Transform</p></a></li>
<li><a href='#QHawkDove'><p>Quantum Hawk and Dove game</p></a></li>
<li><a href='#QMeasure'><p>Measurement</p></a></li>
<li><a href='#QMontyHall'><p>Quantum Monty Hall Problem</p></a></li>
<li><a href='#QNewcomb'><p>Quantum Newcomb's Paradox</p></a></li>
<li><a href='#QPD'><p>Quantum Prisoner's Dilemma game</p></a></li>
<li><a href='#QPennyFlip'><p>Quantum Penny Flip game</p></a></li>
<li><a href='#row_count'><p>Number of rows of a vector/matrix</p></a></li>
<li><a href='#Rx'><p>Rotation operation about x-axis of the Bloch sphere</p></a></li>
<li><a href='#Ry'><p>Rotation operation about y-axis of the Bloch sphere</p></a></li>
<li><a href='#Rz'><p>Rotation operation about z-axis of the Bloch sphere</p></a></li>
<li><a href='#sigmaX'><p>Pauli-X gate</p></a></li>
<li><a href='#sigmaY'><p>Pauli-Y gate</p></a></li>
<li><a href='#sigmaZ'><p>Pauli-Z gate</p></a></li>
<li><a href='#SWAP'><p>SWAP gate</p></a></li>
<li><a href='#T'><p>T gate</p></a></li>
<li><a href='#TDagger'><p>Hermitian Transpose of the T gate</p></a></li>
<li><a href='#Toffoli'><p>Toffoli gate</p></a></li>
<li><a href='#Walsh'><p>Walsh-Hadamard gate</p></a></li>
<li><a href='#Walsh16'><p>Walsh-Hadamard gate</p></a></li>
<li><a href='#Walsh32'><p>Walsh-Hadamard gate</p></a></li>
<li><a href='#Walsh4'><p>Walsh-Hadamard gate</p></a></li>
<li><a href='#Walsh8'><p>Walsh-Hadamard gate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Quantum Game Theory Simulator</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Indranil Ghosh</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Indranil Ghosh &lt;indranilg49@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, RColorBrewer, R.utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.4)</td>
</tr>
<tr>
<td>Description:</td>
<td>General purpose toolbox for simulating quantum versions of game theoretic models (Flitney and Abbott 2002) &lt;<a href="https://arxiv.org/abs/quant-ph/0208069">arXiv:quant-ph/0208069</a>&gt;. Quantum (Nielsen and Chuang 2010, ISBN:978-1-107-00217-3) versions of models that have been handled are: Penny Flip Game (David A. Meyer 1998) &lt;<a href="https://arxiv.org/abs/quant-ph/9804010">arXiv:quant-ph/9804010</a>&gt;, Prisoner's Dilemma (J. Orlin Grabbe 2005) &lt;<a href="https://arxiv.org/abs/quant-ph/0506219">arXiv:quant-ph/0506219</a>&gt;, Two Person Duel (Flitney and Abbott 2004) &lt;<a href="https://arxiv.org/abs/quant-ph/0305058">arXiv:quant-ph/0305058</a>&gt;, Battle of the Sexes (Nawaz and Toor 2004) &lt;<a href="https://arxiv.org/abs/quant-ph/0110096">arXiv:quant-ph/0110096</a>&gt;, Hawk and Dove Game (Nawaz and Toor 2010) &lt;<a href="https://arxiv.org/abs/quant-ph/0108075">arXiv:quant-ph/0108075</a>&gt;, Newcomb's Paradox (Piotrowski and Sladkowski 2002) &lt;<a href="https://arxiv.org/abs/quant-ph/0202074">arXiv:quant-ph/0202074</a>&gt; and Monty Hall Problem (Flitney and Abbott 2002) &lt;<a href="https://arxiv.org/abs/quant-ph/0109035">arXiv:quant-ph/0109035</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/indrag49/QGameTheory">https://github.com/indrag49/QGameTheory</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/indrag49/QGameTheory/issues">https://github.com/indrag49/QGameTheory/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-05 05:28:45 UTC; indranil</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-12 08:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='Bell'>Bell States</h2><span id='topic+Bell'></span>

<h3>Description</h3>

<p>The function builds one of the four Bell states, according to the input qubits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bell(qubit1, qubit2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bell_+3A_qubit1">qubit1</code></td>
<td>
<p>1st input qubit</p>
</td></tr>
<tr><td><code id="Bell_+3A_qubit2">qubit2</code></td>
<td>
<p>2nd input qubit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One of the Bell states as a vector depending on the input qubits.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Bell_state">https://en.wikipedia.org/wiki/Bell_state</a><br />
<a href="https://books.google.co.in/books?id=66TgFp2YqrAC&amp;pg=PA25&amp;redir_esc=y">https://books.google.co.in/books?id=66TgFp2YqrAC&amp;pg=PA25&amp;redir_esc=y</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Bell(Q$Q0, Q$Q0)
Bell(Q$Q0, Q$Q1)
Bell(Q$Q1, Q$Q0)
Bell(Q$Q1, Q$Q1)

</code></pre>

<hr>
<h2 id='CNOT'>CNOT gate</h2><span id='topic+CNOT'></span>

<h3>Description</h3>

<p>This function operates the CNOT gate on a conformable input matrix/vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CNOT(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CNOT_+3A_n">n</code></td>
<td>
<p>A vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the CNOT gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
CNOT(Q$I4)
CNOT(Q$Q11)

</code></pre>

<hr>
<h2 id='col_count'>Number of columns of a vector/matrix</h2><span id='topic+col_count'></span>

<h3>Description</h3>

<p>This function counts the number of columns of a vector or a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_count(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_count_+3A_m">M</code></td>
<td>
<p>A vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer that gives the number of columns in a vector or a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
col_count(Q$Q11)
col_count(Q$lambda4)
col_count(Q$I2)

</code></pre>

<hr>
<h2 id='Fredkin'>Fredkin Gate</h2><span id='topic+Fredkin'></span>

<h3>Description</h3>

<p>This function operates the Fredkin gate on a conformable input matrix/vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fredkin(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fredkin_+3A_n">n</code></td>
<td>
<p>A vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the Fredkin gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Fredkin(Q$I8)
Fredkin(Q$Q110)

</code></pre>

<hr>
<h2 id='Hadamard'>Hadamard Gate</h2><span id='topic+Hadamard'></span>

<h3>Description</h3>

<p>This function operates the Hadamard gate on a conformable input matrix/vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hadamard(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hadamard_+3A_n">n</code></td>
<td>
<p>A vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the Hadamard operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Hadamard(Q$Q0)
Hadamard(Q$I2)
Hadamard(Hadamard(Q$Q1))

</code></pre>

<hr>
<h2 id='IDSDS'>Iterated Deletion of Strictly Dominated Strategies algorithm</h2><span id='topic+IDSDS'></span>

<h3>Description</h3>

<p>This function applies the IDSDS algorithm to result in the equilibrium strategies based on the rationaility of the players. The input parameters are equal dimensional payoff matrices for the first and the second players.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IDSDS(P1, P2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IDSDS_+3A_p1">P1</code></td>
<td>
<p>Payoff matrix to Alice</p>
</td></tr>
<tr><td><code id="IDSDS_+3A_p2">P2</code></td>
<td>
<p>Payoff matrix to Bob</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of the equilibrium strategies based on the rationality of the players by application of the IDSDS algorithm on <code>P1</code> and <code>P2</code>.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1512.06808">https://arxiv.org/abs/1512.06808</a><br />
<a href="https://en.wikipedia.org/wiki/Strategic_dominance">https://en.wikipedia.org/wiki/Strategic_dominance</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Alice &lt;- matrix(c(8, 0, 3, 3, 2, 4, 2, 1, 3), ncol=3, byrow=TRUE)
Bob &lt;- matrix(c(6, 9, 8, 2, 1, 3, 8, 5, 1), ncol=3, byrow=TRUE)
IDSDS(Alice, Bob)

</code></pre>

<hr>
<h2 id='init'>Initialization</h2><span id='topic+init'></span>

<h3>Description</h3>

<p>Builds the parameters in the required environment after initialization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init()
</code></pre>


<h3>Value</h3>

<p>No return value, generates the required variables/parameters.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/Quant-ph/0512125.pdf">https://arxiv.org/pdf/Quant-ph/0512125.pdf</a><br />
<a href="https://arxiv.org/pdf/0910.4222.pdf">https://arxiv.org/pdf/0910.4222.pdf</a><br />
<a href="https://arxiv.org/pdf/Quant-ph/9703032.pdf">https://arxiv.org/pdf/Quant-ph/9703032.pdf</a><br />
<a href="https://en.wikipedia.org/wiki/Quantum_computing">https://en.wikipedia.org/wiki/Quantum_computing</a><br />
<a href="https://en.wikipedia.org/wiki/Qubit">https://en.wikipedia.org/wiki/Qubit</a><br />
<a href="https://en.wikipedia.org/wiki/Qutrit">https://en.wikipedia.org/wiki/Qutrit</a><br />
<a href="https://en.wikipedia.org/wiki/Clebsch%E2%80%93Gordan_coefficients_for_SU(3)">https://en.wikipedia.org/wiki/Clebsch%E2%80%93Gordan_coefficients_for_SU(3)</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Q$Q110
Q$Qt12
Q$Q_minus
Q$lambda4

</code></pre>

<hr>
<h2 id='levi_civita'>Levi-Civita symbol</h2><span id='topic+levi_civita'></span>

<h3>Description</h3>

<p>This function computes the Levi-Civita symbol depending on the permutations of the three inputs, lying in 0 to 2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levi_civita(i, j, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levi_civita_+3A_i">i</code></td>
<td>
<p>an integer 0, 1 or 2</p>
</td></tr>
<tr><td><code id="levi_civita_+3A_j">j</code></td>
<td>
<p>an integer 0, 1 or 2</p>
</td></tr>
<tr><td><code id="levi_civita_+3A_k">k</code></td>
<td>
<p>an integer 0, 1 or 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>0, 1 or -1 after computing the Levi-Civita symbol depending on the permutations of the three inputs 0, 1 and 2
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Levi-Civita_symbol">https://en.wikipedia.org/wiki/Levi-Civita_symbol</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
levi_civita(0, 2, 1)
levi_civita(1, 2, 0)
levi_civita(1, 2, 1)

</code></pre>

<hr>
<h2 id='NASH'>Nash Equilibrium</h2><span id='topic+NASH'></span>

<h3>Description</h3>

<p>This function finds out the Nash equilibria of the 2-D payoff matrix for the players. The input parameters are equal dimensional payoff matrices for the first and the second players.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NASH(P1, P2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NASH_+3A_p1">P1</code></td>
<td>
<p>Payoff matrix to Alice</p>
</td></tr>
<tr><td><code id="NASH_+3A_p2">P2</code></td>
<td>
<p>Payoff matrix to Bob</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cell positons of the Nash equilibrium/equilibria as a dataframe from the payoff matrices of the players.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1512.06808">https://arxiv.org/abs/1512.06808</a><br />
<a href="https://en.wikipedia.org/wiki/Nash_equilibrium">https://en.wikipedia.org/wiki/Nash_equilibrium</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Alice &lt;- matrix(c(4, 3, 2, 4, 4, 2, 1, 0, 3, 5, 3, 5, 2, 3, 1, 3), ncol=4, byrow=TRUE)
Bob &lt;- matrix(c(0, 2, 3, 8, 2, 1, 2, 2, 6, 5, 1, 0, 3, 2, 2, 3), ncol=4, byrow=TRUE)
NASH(Alice, Bob)

</code></pre>

<hr>
<h2 id='PayoffMatrix_QBOS'>Quantum Battle of the Sexes game: Payoff Matrix</h2><span id='topic+PayoffMatrix_QBOS'></span>

<h3>Description</h3>

<p>This function generates the payoff matrix for the Quantum Battle of Sexes game for all the four combinations of <code>p</code> and <code>q</code>. <code>moves</code> is a list of two possible strategies for each of the players and <code>alpha, beta, gamma</code> are the payoffs for the players corresponding to the choices available to them with the chain of inequalities, <code>alpha&gt;beta&gt;gamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PayoffMatrix_QBOS(moves, alpha, beta, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PayoffMatrix_QBOS_+3A_moves">moves</code></td>
<td>
<p>a list of matrices</p>
</td></tr>
<tr><td><code id="PayoffMatrix_QBOS_+3A_alpha">alpha</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="PayoffMatrix_QBOS_+3A_beta">beta</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="PayoffMatrix_QBOS_+3A_gamma">gamma</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The payoff matrices for the two players as two elements of a list.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/abs/quant-ph/0110096">https://arxiv.org/abs/quant-ph/0110096</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
moves &lt;- list(Q$I2, sigmaX(Q$I2))
PayoffMatrix_QBOS(moves, 5, 3, 1)

</code></pre>

<hr>
<h2 id='PayoffMatrix_QHawkDove'>Quantum Hawk and Dove game: Payoff Matrix</h2><span id='topic+PayoffMatrix_QHawkDove'></span>

<h3>Description</h3>

<p>This function generates the payoff matrix for the Quantum Hawk and Dove game for all the four combinations of <code>p</code> and <code>q</code>. <code>moves</code> is a list of two possible strategies for each of the players and <code>v, j, D</code> are the value of resource, cost of injury and cost of displaying respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PayoffMatrix_QHawkDove(moves, v, j, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PayoffMatrix_QHawkDove_+3A_moves">moves</code></td>
<td>
<p>a list of matrices</p>
</td></tr>
<tr><td><code id="PayoffMatrix_QHawkDove_+3A_v">v</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="PayoffMatrix_QHawkDove_+3A_j">j</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="PayoffMatrix_QHawkDove_+3A_d">D</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The payoff matrices for the two players as two elements of a list.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0108075.pdf">https://arxiv.org/pdf/quant-ph/0108075.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
moves &lt;- list(Q$I2, sigmaX(Q$I2))
PayoffMatrix_QHawkDove(moves, 50, -100, -10)

</code></pre>

<hr>
<h2 id='PayoffMatrix_QPD'>Quantum Prisoner's Dilemma game: Payoff Matrix</h2><span id='topic+PayoffMatrix_QPD'></span>

<h3>Description</h3>

<p>This function generates the payoff matrix for the Quantum Prisoner's Dilemma game . <code>moves</code> is a list of the possible strategies for each of the players and <code>w, x, y, z</code> are the payoffs for the players corresponding to the choices available to them with the chain of inequalities, <code>z&gt;w&gt;x&gt;y</code>.
This function also plots the probability distribution plots of the qubits for all the possible combinations of the strategies of the players.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PayoffMatrix_QPD(moves, w, x, y, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PayoffMatrix_QPD_+3A_moves">moves</code></td>
<td>
<p>a list of matrices</p>
</td></tr>
<tr><td><code id="PayoffMatrix_QPD_+3A_w">w</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="PayoffMatrix_QPD_+3A_x">x</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="PayoffMatrix_QPD_+3A_y">y</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="PayoffMatrix_QPD_+3A_z">z</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The payoff matrices for the two players as two elements of a list.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0004076.pdf">https://arxiv.org/pdf/quant-ph/0004076.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
moves &lt;- list(Q$I2, sigmaX(Q$I2), Hadamard(Q$I2), sigmaZ(Q$I2))
PayoffMatrix_QPD(moves, 3, 1, 0, 5)

</code></pre>

<hr>
<h2 id='Phase'>Phase Gate</h2><span id='topic+Phase'></span>

<h3>Description</h3>

<p>This function operates the Phase gate on a conformable input matrix/vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Phase(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Phase_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the Phase gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Phase(Q$I2)
Phase(Q$Q_plus)

</code></pre>

<hr>
<h2 id='PhaseDagger'>Hermitian Transpose of the Phase Gate</h2><span id='topic+PhaseDagger'></span>

<h3>Description</h3>

<p>This function operates the hermitian transpose of the Phase gate on a conformable input matrix/vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhaseDagger(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhaseDagger_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the operation of the hermitian transpose of the Phase gate on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Conj(t(Phase(Q$I2)))==PhaseDagger(Q$I2)
PhaseDagger(Q$Q_plus)

</code></pre>

<hr>
<h2 id='QBOS'>Quantum Battle of the Sexes game</h2><span id='topic+QBOS'></span>

<h3>Description</h3>

<p>This function returns the expected payoffs to Alice and Bob with respect to the probabilities <code>p</code> and <code>q</code>. <code>p+q</code> should equal 1 and <code>moves</code> is a list of two possible strategies for each of the players and <code>alpha, beta, gamma</code> are the payoffs for the players corresponding to the choices available to them with the chain of inequalities, <code>alpha&gt;beta&gt;gamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QBOS(p, q, moves, alpha, beta, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QBOS_+3A_p">p</code></td>
<td>
<p>a real number between 0 and 1 including the end points</p>
</td></tr>
<tr><td><code id="QBOS_+3A_q">q</code></td>
<td>
<p>a real number between 0 and 1 including the end points</p>
</td></tr>
<tr><td><code id="QBOS_+3A_moves">moves</code></td>
<td>
<p>alist of matrices</p>
</td></tr>
<tr><td><code id="QBOS_+3A_alpha">alpha</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QBOS_+3A_beta">beta</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QBOS_+3A_gamma">gamma</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector consisting of the Payoffs to Alice and Bob as its two elements depending on the inputs.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/abs/quant-ph/0110096">https://arxiv.org/abs/quant-ph/0110096</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
moves &lt;- list(Q$I2, sigmaX(Q$I2))
QBOS(0, 1, moves, 5, 3, 1)
QBOS(1, 1, moves, 5, 3, 1)
QBOS(0.5, 0.5, moves, 5, 3, 1)

</code></pre>

<hr>
<h2 id='QDuels_Alice_payoffs'>Quantum Two Person Duel game</h2><span id='topic+QDuels_Alice_payoffs'></span>

<h3>Description</h3>

<p>This function returns the expected payoff to Alice for three possible cases for the Quantum Duel game:
</p>

<ol>
<li><p> The game is continued for <code>n</code> rounds and none of the players shoots at the air.
</p>
</li>
<li><p> The game is continued for 2 rounds and Alice shoots at the air in her second round.
</p>
</li>
<li><p> The game is continued for 2 rounds and Bob shoots at the air in her second round.
</p>
</li></ol>

<p><code>Psi</code> is the initial state of the quantum game, <code>n</code> is the number of rounds, <code>a</code> is the probability of Alice missing the target, <code>b</code> is the probability of Bob missing the target, and <code>alpha1, alpha2, beta1, beta2</code> are arbitrary phase factors that lie in -pi to pi that control the outcome of a poorly performing player.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QDuels_Alice_payoffs(Psi, n, a, b, alpha1, alpha2, beta1, beta2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QDuels_Alice_payoffs_+3A_psi">Psi</code></td>
<td>
<p>a vector representing the initial quantum state</p>
</td></tr>
<tr><td><code id="QDuels_Alice_payoffs_+3A_n">n</code></td>
<td>
<p>an integer</p>
</td></tr>
<tr><td><code id="QDuels_Alice_payoffs_+3A_a">a</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuels_Alice_payoffs_+3A_b">b</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuels_Alice_payoffs_+3A_alpha1">alpha1</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuels_Alice_payoffs_+3A_alpha2">alpha2</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuels_Alice_payoffs_+3A_beta1">beta1</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuels_Alice_payoffs_+3A_beta2">beta2</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of the payoff value to Alice depending on three situations of the quantum duel game: 1) The game is continued for <code>n</code> rounds and none of the players shoots at the air, 2) The game is continued for 2 rounds and Alice shoots at the air in her second round and 3) The game is continued for 2 rounds and Bob shoots at the air in her second round.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0305058.pdf">https://arxiv.org/pdf/quant-ph/0305058.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
QDuels_Alice_payoffs(Q$Q11, 5, 0.666666, 0.5, 0, 0, 0.2, 0.7)
Qs &lt;- (Q$Q0+Q$Q1)/sqrt(2)
Psi &lt;- kronecker(Qs, Qs)
QDuels_Alice_payoffs(Psi, 5, 0.666666, 0.5, 0, 0, 0.2, 0.7)

</code></pre>

<hr>
<h2 id='QDuels_Bob_payoffs'>Quantum Two Person Duel game</h2><span id='topic+QDuels_Bob_payoffs'></span>

<h3>Description</h3>

<p>This function returns the expected payoff to Bob for three possible cases for the Quantum Duel game:
</p>

<ol>
<li><p> The game is continued for <code>n</code> rounds and none of the players shoots at the air.
</p>
</li>
<li><p> The game is continued for 2 rounds and Alice shoots at the air in her second round.
</p>
</li>
<li><p> The game is continued for 2 rounds and Bob shoots at the air in her second round.
</p>
</li></ol>

<p><code>Psi</code> is the initial state of the quantum game, <code>n</code> is the number of rounds, <code>a</code> is the probability of Alice missing the target, <code>b</code> is the probability of Bob missing the target, and <code>alpha1, alpha2, beta1, beta2</code> are arbitrary phase factors that lie in -pi to pi that control the outcome of a poorly performing player.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QDuels_Bob_payoffs(Psi, n, a, b, alpha1, alpha2, beta1, beta2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QDuels_Bob_payoffs_+3A_psi">Psi</code></td>
<td>
<p>a vector representing the initial quantum state</p>
</td></tr>
<tr><td><code id="QDuels_Bob_payoffs_+3A_n">n</code></td>
<td>
<p>an integer</p>
</td></tr>
<tr><td><code id="QDuels_Bob_payoffs_+3A_a">a</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuels_Bob_payoffs_+3A_b">b</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuels_Bob_payoffs_+3A_alpha1">alpha1</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuels_Bob_payoffs_+3A_alpha2">alpha2</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuels_Bob_payoffs_+3A_beta1">beta1</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuels_Bob_payoffs_+3A_beta2">beta2</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of the payoff value to Bob depending on three situations of the quantum duel game: 1) The game is continued for <code>n</code> rounds and none of the players shoots at the air, 2) The game is continued for 2 rounds and Alice shoots at the air in her second round and 3) The game is continued for 2 rounds and Bob shoots at the air in her second round.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0305058.pdf">https://arxiv.org/pdf/quant-ph/0305058.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
QDuels_Bob_payoffs(Q$Q11, 5, 0.666666, 0.5, 0, 0, 0.2, 0.7)
Qs &lt;- (Q$Q0+Q$Q1)/sqrt(2)
Psi &lt;- kronecker(Qs, Qs)
QDuels_Bob_payoffs(Psi, 5, 0.666666, 0.5, 0, 0, 0.2, 0.7)

</code></pre>

<hr>
<h2 id='QDuelsPlot1'>Quantum Two Person Duel game</h2><span id='topic+QDuelsPlot1'></span>

<h3>Description</h3>

<p>This function helps us to plot Alice's and Bob's expected payoffs as functions of <code>alpha1</code> and <code>alpha2</code>. <code>Psi</code> is the initial state of the quantum game, <code>n</code> is the number of rounds, <code>a</code> is the probability of Alice missing the target, <code>b</code> is the probability of Bob missing the target, and
<code>alpha1, alpha2, beta1, beta2</code> are arbitrary phase factors that lie in -pi to pi that control the outcome of a poorly performing player.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QDuelsPlot1(Psi, n, a, b, beta1, beta2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QDuelsPlot1_+3A_psi">Psi</code></td>
<td>
<p>a vector representing the initial quantum state</p>
</td></tr>
<tr><td><code id="QDuelsPlot1_+3A_n">n</code></td>
<td>
<p>an integer</p>
</td></tr>
<tr><td><code id="QDuelsPlot1_+3A_a">a</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuelsPlot1_+3A_b">b</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuelsPlot1_+3A_beta1">beta1</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuelsPlot1_+3A_beta2">beta2</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, plots Alice's and Bob's expected payoffs as functions of <code>alpha1</code> and <code>alpha2</code>.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0305058.pdf">https://arxiv.org/pdf/quant-ph/0305058.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
QDuelsPlot1(Q$Q10, 2, 0.66666, 0.5, 0.2, 0.8)

</code></pre>

<hr>
<h2 id='QDuelsPlot2'>Quantum Two Person Duel game</h2><span id='topic+QDuelsPlot2'></span>

<h3>Description</h3>

<p>This function helps us to plot Alice's and Bob's expected payoffs as functions of the number of rounds <code>n</code> played in a repeated quantum duel. <code>Psi</code> is the initial state of the quantum game, <code>n</code> is the number of rounds, <code>a</code> is the probability of Alice missing the target, <code>b</code> is the probability of Bob missing the target, and
<code>alpha1, alpha2, beta1, beta2</code> are arbitrary phase factors that lie in -pi to pi that control the outcome of a poorly performing player.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QDuelsPlot2(Psi, n, a, b, alpha1, alpha2, beta1, beta2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QDuelsPlot2_+3A_psi">Psi</code></td>
<td>
<p>a vector representing the initial quantum state</p>
</td></tr>
<tr><td><code id="QDuelsPlot2_+3A_n">n</code></td>
<td>
<p>an integer</p>
</td></tr>
<tr><td><code id="QDuelsPlot2_+3A_a">a</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuelsPlot2_+3A_b">b</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuelsPlot2_+3A_alpha1">alpha1</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuelsPlot2_+3A_alpha2">alpha2</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuelsPlot2_+3A_beta1">beta1</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuelsPlot2_+3A_beta2">beta2</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, plots Alice's and Bob's expected payoffs as functions of the number of rounds <code>n</code> played in a repeated quantum duel.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0305058.pdf">https://arxiv.org/pdf/quant-ph/0305058.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
QDuelsPlot2(Q$Q01, 10, 0.66666, 0.5, -pi/2, pi/4, 0.6, 0.4)

</code></pre>

<hr>
<h2 id='QDuelsPlot3'>Quantum Two Person Duel game</h2><span id='topic+QDuelsPlot3'></span>

<h3>Description</h3>

<p>This function helps us to plot the improvement in Alice's expected payoff as a function of <code>a</code> and <code>b</code>, if Alice chooses to fire at the air in her second shot, in a two round game. <code>Psi</code> is the initial state of the quantum game, <code>n</code> is the number of rounds, <code>a</code> is the probability of Alice missing the target, <code>b</code> is the probability of Bob missing the target, and
<code>alpha1, alpha2, beta1, beta2</code> are arbitrary phase factors that lie in -pi to pi that control the outcome of a poorly performing player.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QDuelsPlot3(Psi, alpha1, alpha2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QDuelsPlot3_+3A_psi">Psi</code></td>
<td>
<p>a vector representing the initial quantum state</p>
</td></tr>
<tr><td><code id="QDuelsPlot3_+3A_alpha1">alpha1</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuelsPlot3_+3A_alpha2">alpha2</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, plots the improvement in Alice's expected payoff as a function of <code>a</code> and <code>b</code>, if Alice chooses to fire at the air in her second shot, in a two round game.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0305058.pdf">https://arxiv.org/pdf/quant-ph/0305058.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Qs &lt;- (Q$Q0+Q$Q1)/sqrt(2)
Psi &lt;- kronecker(Q$Q1, Qs)
QDuelsPlot3(Psi, pi/3, pi/6)

</code></pre>

<hr>
<h2 id='QDuelsPlot4'>Quantum Two Person Duel game</h2><span id='topic+QDuelsPlot4'></span>

<h3>Description</h3>

<p>This function helps us to plot the improvement in Bob's expected payoff as a function of <code>a</code> and <code>b</code>, if Bob chooses to fire at the air in her second shot, in a two round game. <code>Psi</code> is the initial state of the quantum game, <code>n</code> is the number of rounds, <code>a</code> is the probability of Alice missing the target, <code>b</code> is the probability of Bob missing the target, and
<code>alpha1, alpha2, beta1, beta2</code> are arbitrary phase factors that lie in -pi to pi that control the outcome of a poorly performing player.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QDuelsPlot4(Psi, alpha1, alpha2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QDuelsPlot4_+3A_psi">Psi</code></td>
<td>
<p>a vector representing the initial quantum state</p>
</td></tr>
<tr><td><code id="QDuelsPlot4_+3A_alpha1">alpha1</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QDuelsPlot4_+3A_alpha2">alpha2</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, plots the improvement in Bob's expected payoff as a function of <code>a</code> and <code>b</code>, if Bob chooses to fire at the air in her second shot, in a two round game.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0305058.pdf">https://arxiv.org/pdf/quant-ph/0305058.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Qs &lt;- (Q$Q0+Q$Q1)/sqrt(2)
Psi &lt;- kronecker(Q$Q1, Qs)
QDuelsPlot4(Psi, pi/3, pi/6)

</code></pre>

<hr>
<h2 id='QFT'>Quantum Fourier Transform</h2><span id='topic+QFT'></span>

<h3>Description</h3>

<p>This function performs Quantum Fourier Transform for a given state <code>|y&gt;</code> from the computational basis to the Fourier basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QFT(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QFT_+3A_y">y</code></td>
<td>
<p>an integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector representing the Quantum Fourier transformation of the state <code>|y&gt;</code> from the computational basis to the Fourier basis.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://books.google.co.in/books?id=66TgFp2YqrAC&amp;pg=PA25&amp;redir_esc=y">https://books.google.co.in/books?id=66TgFp2YqrAC&amp;pg=PA25&amp;redir_esc=y</a><br />
<a href="https://en.wikipedia.org/wiki/Quantum_Fourier_transform">https://en.wikipedia.org/wiki/Quantum_Fourier_transform</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
QFT(5)

</code></pre>

<hr>
<h2 id='QHawkDove'>Quantum Hawk and Dove game</h2><span id='topic+QHawkDove'></span>

<h3>Description</h3>

<p>This function returns the expected payoffs to Alice and Bob with respect to the probabilities <code>p</code> and <code>q</code>. <code>p+q</code> should equal 1 and <code>moves</code> is a list of two possible strategies for each of the players and <code>v, j, D</code> are the value of resource, cost of injury and cost of displaying respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QHawkDove(p, q, moves, v, j, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QHawkDove_+3A_p">p</code></td>
<td>
<p>a real number between 0 and 1 including the end points</p>
</td></tr>
<tr><td><code id="QHawkDove_+3A_q">q</code></td>
<td>
<p>a real number between 0 and 1 including the end points</p>
</td></tr>
<tr><td><code id="QHawkDove_+3A_moves">moves</code></td>
<td>
<p>a list of matrics</p>
</td></tr>
<tr><td><code id="QHawkDove_+3A_v">v</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QHawkDove_+3A_j">j</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QHawkDove_+3A_d">D</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector consisting of the expected payoffs to Alice and Bob as its elements calculated according to the probabilities <code>p</code> and <code>q</code> provided as inputs.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0108075.pdf">https://arxiv.org/pdf/quant-ph/0108075.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
moves &lt;- list(Q$I2, sigmaX(Q$I2))
QHawkDove(0, 1, moves, 50, -100, -10)
QHawkDove(0, 0, moves, 50, -100, -10)

</code></pre>

<hr>
<h2 id='QMeasure'>Measurement</h2><span id='topic+QMeasure'></span>

<h3>Description</h3>

<p>This function performs a projective measurement of a quantum state <code>n</code>, in the computational basis and plots the corresponding probability distributions of the qubits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QMeasure(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QMeasure_+3A_n">n</code></td>
<td>
<p>a vector representing a quantum state</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, plots the probability distributions of the qubits after performing a projective measurement of a quantum state <code>n</code>.
</p>


<h3>References</h3>

<p><a href="https://books.google.co.in/books?id=66TgFp2YqrAC&amp;pg=PA25&amp;redir_esc=y">https://books.google.co.in/books?id=66TgFp2YqrAC&amp;pg=PA25&amp;redir_esc=y</a><br />
<a href="https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics">https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
QMeasure(Q$Q10110)

</code></pre>

<hr>
<h2 id='QMontyHall'>Quantum Monty Hall Problem</h2><span id='topic+QMontyHall'></span>

<h3>Description</h3>

<p>This function simulates the quantum version of the Monty Hall problem, by taking in <code>Psi_in</code> as the initial quantum state of the game, <code>gamma</code> lying in 0 to pi/2, <code>Ahat</code> and <code>Bhat</code> as the choice operators in SU(3) for Alice and Bob respectively as the inputs. It returns the expected payoffs to Alice and Bob after the end of the game.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QMontyHall(Psi_in, gamma, Ahat, Bhat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QMontyHall_+3A_psi_in">Psi_in</code></td>
<td>
<p>a vector representing the initial quantum state</p>
</td></tr>
<tr><td><code id="QMontyHall_+3A_gamma">gamma</code></td>
<td>
<p>a number between 0 and pi/2 including the end points</p>
</td></tr>
<tr><td><code id="QMontyHall_+3A_ahat">Ahat</code></td>
<td>
<p>a matrix lying in SU(3)</p>
</td></tr>
<tr><td><code id="QMontyHall_+3A_bhat">Bhat</code></td>
<td>
<p>a matrix lying in SU(3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector consisting of the expected payoffs to Alice and Bob as its elements depending on the input parameters.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0109035.pdf">https://arxiv.org/pdf/quant-ph/0109035.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Psi_in &lt;- kronecker(Q$Qt0, (Q$Qt00+Q$Qt11+Q$Qt22)/sqrt(3))
QMontyHall(Psi_in, pi/4, Q$Identity3, Q$Hhat)

</code></pre>

<hr>
<h2 id='QNewcomb'>Quantum Newcomb's Paradox</h2><span id='topic+QNewcomb'></span>

<h3>Description</h3>

<p>This function simulates the quantum version of the Newcomb's Paradox by taking in the choice of the qubit |0&gt; or |1&gt; by the supercomputer <code>Omega</code> and the probability <code>'probability'</code> with which Alice plays the spin flip operator. It returns the final state of the quantum game along with plotting the probability densities of the qubits of the final state after measurement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QNewcomb(Omega, probability)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QNewcomb_+3A_omega">Omega</code></td>
<td>
<p>|0&gt; or |1&gt;</p>
</td></tr>
<tr><td><code id="QNewcomb_+3A_probability">probability</code></td>
<td>
<p>a real number between 0 and 1 including the end points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The final state of the quantum game as a vector along with plotting the probability densities of the qubits of the final state after measurement.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0202074.pdf">https://arxiv.org/pdf/quant-ph/0202074.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
QNewcomb(Q$Q0, 0)
QNewcomb(Q$Q1, 0)
QNewcomb(Q$Q1, 0.7)

</code></pre>

<hr>
<h2 id='QPD'>Quantum Prisoner's Dilemma game</h2><span id='topic+QPD'></span>

<h3>Description</h3>

<p>This function returns the expected payoffs to Alice and Bob, with the strategy moves by Alice and Bob as two of the inputs. <code>w, x, y, z</code> are the payoffs to the players corresponding to the choices available to them with the chain of inequalities, <code>z&gt;w&gt;x&gt;y</code>.
This function also plots the probability distribution plots of the qubits for one of all the combinations of the strategies of the players.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QPD(U_Alice, U_Bob, w, x, y, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QPD_+3A_u_alice">U_Alice</code></td>
<td>
<p>a matrix lying in SU(2)</p>
</td></tr>
<tr><td><code id="QPD_+3A_u_bob">U_Bob</code></td>
<td>
<p>a matrix lying in SU(2)</p>
</td></tr>
<tr><td><code id="QPD_+3A_w">w</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QPD_+3A_x">x</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QPD_+3A_y">y</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="QPD_+3A_z">z</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector consisting of the expected payoffs to Alice and Bob as its elements according to the strategies played by Alice and Bob and also the payoff values.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0004076.pdf">https://arxiv.org/pdf/quant-ph/0004076.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
QPD(Hadamard(Q$I2), sigmaZ(Q$I2), 3, 1, 0, 5)

</code></pre>

<hr>
<h2 id='QPennyFlip'>Quantum Penny Flip game</h2><span id='topic+QPennyFlip'></span>

<h3>Description</h3>

<p>This function simulates the Quantum Penny Flip game by taking in the initial state of the game that is set by Alice and the strategies available to Alice and Bob. It returns the final state of the game along with the plot of the probability distribution of the qubits after measurement of the final state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QPennyFlip(initial_state, strategies_Alice, strategies_Bob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QPennyFlip_+3A_initial_state">initial_state</code></td>
<td>
<p>a vector representing the initial quantum state</p>
</td></tr>
<tr><td><code id="QPennyFlip_+3A_strategies_alice">strategies_Alice</code></td>
<td>
<p>a matrix lying in SU(2)</p>
</td></tr>
<tr><td><code id="QPennyFlip_+3A_strategies_bob">strategies_Bob</code></td>
<td>
<p>a matrix lying in SU(2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The final state of the game along with the plot of the probability distribution of the qubits after measurement of the final state by taking in the initial state of the game that is set by Alice and the strategies available to Alice and Bob as the inputs.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0208069.pdf">https://arxiv.org/pdf/quant-ph/0208069.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/9804010.pdf">https://arxiv.org/pdf/quant-ph/9804010.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
psi &lt;- (u+d)/sqrt(2)
S1 &lt;- sigmaX(Q$I2)
S2 &lt;- Q$I2
H &lt;- Hadamard(Q$I2)
SA &lt;- list(S1, S2)
SB &lt;- list(H)
QPennyFlip(psi, SA,SB)

</code></pre>

<hr>
<h2 id='row_count'>Number of rows of a vector/matrix</h2><span id='topic+row_count'></span>

<h3>Description</h3>

<p>This function counts the number of rows of a vector or a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_count(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_count_+3A_m">M</code></td>
<td>
<p>A vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer that gives the number of rows in a vector or a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
row_count(Q$Q01)
row_count(Q$lambda5)
row_count(Q$Qt12)

</code></pre>

<hr>
<h2 id='Rx'>Rotation operation about x-axis of the Bloch sphere</h2><span id='topic+Rx'></span>

<h3>Description</h3>

<p>This function operates the Rotation gate about the x-axis of the Bloch sphere by an angle <code>theta</code> on a conformable input matrix <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rx(n, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rx_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
<tr><td><code id="Rx_+3A_theta">theta</code></td>
<td>
<p>an angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a matrix after operating the Rotation gate about the x-axis of the Bloch sphere, by an angle <code>theta</code>, on a conformable input matrix or a vector <code>n</code>
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
<a href="http://www.physics.udel.edu/~msafrono/650/Lecture%204%20-%205.pdf">http://www.physics.udel.edu/~msafrono/650/Lecture%204%20-%205.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Rx(Q$Q0, pi/6)

</code></pre>

<hr>
<h2 id='Ry'>Rotation operation about y-axis of the Bloch sphere</h2><span id='topic+Ry'></span>

<h3>Description</h3>

<p>This function operates the Rotation gate about the y-axis of the Bloch sphere by an angle <code>theta</code> on a conformable input matrix <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ry(n, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ry_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
<tr><td><code id="Ry_+3A_theta">theta</code></td>
<td>
<p>an angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a matrix after operating the Rotation gate about the y-axis of the Bloch sphere, by an angle <code>theta</code>, on a conformable input matrix or a vector <code>n</code>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
<a href="http://www.physics.udel.edu/~msafrono/650/Lecture%204%20-%205.pdf">http://www.physics.udel.edu/~msafrono/650/Lecture%204%20-%205.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Ry(Q$Q1, pi/3)

</code></pre>

<hr>
<h2 id='Rz'>Rotation operation about z-axis of the Bloch sphere</h2><span id='topic+Rz'></span>

<h3>Description</h3>

<p>This function operates the Rotation gate about the z-axis of the Bloch sphere by an angle <code>theta</code> on a conformable input matrix <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rz(n, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rz_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
<tr><td><code id="Rz_+3A_theta">theta</code></td>
<td>
<p>an angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a matrix after operating the Rotation gate about the z-axis of the Bloch sphere, by an angle <code>theta</code>, on a conformable input matrix or a vector <code>n</code>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
<a href="http://www.physics.udel.edu/~msafrono/650/Lecture%204%20-%205.pdf">http://www.physics.udel.edu/~msafrono/650/Lecture%204%20-%205.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Rz(Q$Q1, pi)

</code></pre>

<hr>
<h2 id='sigmaX'>Pauli-X gate</h2><span id='topic+sigmaX'></span>

<h3>Description</h3>

<p>This function operates the Pauli-X gate on a conformable input matrix or a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmaX(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmaX_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the Pauli-X gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
<a href="http://www.physics.udel.edu/~msafrono/650/Lecture%204%20-%205.pdf">http://www.physics.udel.edu/~msafrono/650/Lecture%204%20-%205.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
sigmaX(Q$I2)
sigmaX(Hadamard(Q$I2))
sigmaX(Q$Q1)

</code></pre>

<hr>
<h2 id='sigmaY'>Pauli-Y gate</h2><span id='topic+sigmaY'></span>

<h3>Description</h3>

<p>This function operates the Pauli-Y gate on a conformable input matrix or a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmaY(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmaY_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the Pauli-Y gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
<a href="http://www.physics.udel.edu/~msafrono/650/Lecture%204%20-%205.pdf">http://www.physics.udel.edu/~msafrono/650/Lecture%204%20-%205.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
sigmaY(Q$I2)
sigmaY(Hadamard(Q$I2))
sigmaY(Q$Q0)

</code></pre>

<hr>
<h2 id='sigmaZ'>Pauli-Z gate</h2><span id='topic+sigmaZ'></span>

<h3>Description</h3>

<p>This function operates the Pauli-Z gate on a conformable input matrix or a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmaZ(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmaZ_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the Pauli-Z gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
<a href="http://www.physics.udel.edu/~msafrono/650/Lecture%204%20-%205.pdf">http://www.physics.udel.edu/~msafrono/650/Lecture%204%20-%205.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
sigmaZ(Q$I2)
sigmaZ(Hadamard(Q$I2))
sigmaZ(Q$Q0)

</code></pre>

<hr>
<h2 id='SWAP'>SWAP gate</h2><span id='topic+SWAP'></span>

<h3>Description</h3>

<p>This function operates the SWAP gate on a conformable input matrix or a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SWAP(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SWAP_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the SWAP gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
SWAP(Q$I4)
SWAP(Q$Q10)

</code></pre>

<hr>
<h2 id='T'>T gate</h2><span id='topic+T'></span>

<h3>Description</h3>

<p>This function operates the T gate on a conformable input matrix or a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the T gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
T(Q$I2)
T(Q$Q_minus)

</code></pre>

<hr>
<h2 id='TDagger'>Hermitian Transpose of the T gate</h2><span id='topic+TDagger'></span>

<h3>Description</h3>

<p>This function operates the hermitian transpose of the T gate on a conformable input matrix or a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TDagger(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TDagger_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the operation of the hermitian transpose of the T gate on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
TDagger(Q$I2)
TDagger(Q$Q_plus)

</code></pre>

<hr>
<h2 id='Toffoli'>Toffoli gate</h2><span id='topic+Toffoli'></span>

<h3>Description</h3>

<p>This function operates the Toffoli gate on a conformable input matrix or a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Toffoli(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Toffoli_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the Toffoli gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Toffoli(Q$I8)
Toffoli(Q$Q010)

</code></pre>

<hr>
<h2 id='Walsh'>Walsh-Hadamard gate</h2><span id='topic+Walsh'></span>

<h3>Description</h3>

<p>This function operates the Walsh-Hadamard gate on a conformable input matrix or a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Walsh(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Walsh_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the Walsh-Hadamard gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://en.wikipedia.org/wiki/Hadamard_transform">https://en.wikipedia.org/wiki/Hadamard_transform</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Walsh(Q$I2)
Walsh(Q$Q0)

</code></pre>

<hr>
<h2 id='Walsh16'>Walsh-Hadamard gate</h2><span id='topic+Walsh16'></span>

<h3>Description</h3>

<p>This function operates the Walsh-16 gate on a conformable input matrix or a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Walsh16(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Walsh16_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the Walsh-16 gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://en.wikipedia.org/wiki/Hadamard_transform">https://en.wikipedia.org/wiki/Hadamard_transform</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Walsh16(Q$I16)
Walsh16(Q$Q1001)

</code></pre>

<hr>
<h2 id='Walsh32'>Walsh-Hadamard gate</h2><span id='topic+Walsh32'></span>

<h3>Description</h3>

<p>This function operates the Walsh-32 gate on a conformable input matrix or a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Walsh32(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Walsh32_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the Walsh-32 gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://en.wikipedia.org/wiki/Hadamard_transform">https://en.wikipedia.org/wiki/Hadamard_transform</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Walsh32(Q$I32)
Walsh32(Q$Q10011)

</code></pre>

<hr>
<h2 id='Walsh4'>Walsh-Hadamard gate</h2><span id='topic+Walsh4'></span>

<h3>Description</h3>

<p>This function operates the Walsh-4 gate on a conformable input matrix or a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Walsh4(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Walsh4_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the Walsh-4 gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://en.wikipedia.org/wiki/Hadamard_transform">https://en.wikipedia.org/wiki/Hadamard_transform</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Walsh4(Q$I4)
Walsh4(Q$Q10)

</code></pre>

<hr>
<h2 id='Walsh8'>Walsh-Hadamard gate</h2><span id='topic+Walsh8'></span>

<h3>Description</h3>

<p>This function operates the Walsh-8 gate on a conformable input matrix or vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Walsh8(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Walsh8_+3A_n">n</code></td>
<td>
<p>a vector/matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector after performing the Walsh-8 gate operation on a conformable input matrix or a vector.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a><br />
<a href="http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf">http://www2.optics.rochester.edu/~stroud/presentations/muthukrishnan991/LogicGates.pdf</a><br />
<a href="https://arxiv.org/pdf/quant-ph/0506219.pdf">https://arxiv.org/pdf/quant-ph/0506219.pdf</a><br />
<a href="https://en.wikipedia.org/wiki/Hadamard_transform">https://en.wikipedia.org/wiki/Hadamard_transform</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init()
Walsh8(Q$I8)
Walsh8(Q$Q000)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
