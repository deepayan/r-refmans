<!DOCTYPE html><html><head><title>Help for package sodium</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sodium}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Authenticated+20encryption'><p>Authenticated Encryption</p></a></li>
<li><a href='#Diffie-Hellman'><p>Diffie-Hellman</p></a></li>
<li><a href='#Hash+20functions'><p>Hash Functions</p></a></li>
<li><a href='#Key+20generation'><p>Keypair Generation</p></a></li>
<li><a href='#Password+20storage'><p>Password Storage</p></a></li>
<li><a href='#Signatures'><p>Create and Verify Signatures</p></a></li>
<li><a href='#Simple+20encryption'><p>Anonymous Public-key Encryption (Sealed Box)</p></a></li>
<li><a href='#Sodium+20utilities'><p>Sodium Utilities</p></a></li>
<li><a href='#Stream+20ciphers'><p>Stream Ciphers</p></a></li>
<li><a href='#Symmetric+20encryption'><p>Symmetric Encryption and Tagging</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Modern and Easy-to-Use Crypto Library</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Bindings to 'libsodium' <a href="https://doc.libsodium.org/">https://doc.libsodium.org/</a>: a modern, 
    easy-to-use software library for encryption, decryption, signatures, password
    hashing and more. Sodium uses curve25519, a state-of-the-art Diffie-Hellman 
    function by Daniel Bernstein, which has become very popular after it was 
    discovered that the NSA had backdoored Dual EC DRBG.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/sodium/">https://docs.ropensci.org/sodium/</a> <a href="https://github.com/r-lib/sodium">https://github.com/r-lib/sodium</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/sodium/issues">https://github.com/r-lib/sodium/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>libsodium (&gt;= 1.0.3)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-20 12:47:21 UTC; jeroen</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeroen Ooms <a href="https://orcid.org/0000-0002-4035-0289"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeroen Ooms &lt;jeroen@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-20 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Authenticated+20encryption'>Authenticated Encryption</h2><span id='topic+Authenticated+20encryption'></span><span id='topic+auth_encrypt'></span><span id='topic+auth_decrypt'></span>

<h3>Description</h3>

<p>Exchange secure messages through curve25519 authenticated encryption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auth_encrypt(msg, key, pubkey, nonce = random(24))

auth_decrypt(bin, key, pubkey, nonce = attr(bin, "nonce"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Authenticated+2B20encryption_+3A_msg">msg</code></td>
<td>
<p>message to be encrypted</p>
</td></tr>
<tr><td><code id="Authenticated+2B20encryption_+3A_key">key</code></td>
<td>
<p>your own private key</p>
</td></tr>
<tr><td><code id="Authenticated+2B20encryption_+3A_pubkey">pubkey</code></td>
<td>
<p>other person's public key</p>
</td></tr>
<tr><td><code id="Authenticated+2B20encryption_+3A_nonce">nonce</code></td>
<td>
<p>non-secret unique data to randomize the cipher</p>
</td></tr>
<tr><td><code id="Authenticated+2B20encryption_+3A_bin">bin</code></td>
<td>
<p>encrypted ciphertext generated by <code>secure_send</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Authenticated encryption implements best practices for secure messaging.
It requires that both sender and receiver have a keypair and know each
other's public key. Each message gets authenticated with the key of the
sender and encrypted with the key of the receiver.
</p>
<p>Even though public keys are not confidential, you should not exchange them
over the same insecure channel you are trying to protect. If the connection
is being tampered with, the attacker could simply replace the key with another
one to hijack the interaction.
</p>
<p>Most people share their public key by posting them on their website or on a
public keyserver. Another alternative is having your public key signed by a
mutually trusted third party. HTTPS does this using Certificate Authorities.
</p>


<h3>References</h3>

<p><a href="https://libsodium.gitbook.io/doc/public-key_cryptography/authenticated_encryption">https://libsodium.gitbook.io/doc/public-key_cryptography/authenticated_encryption</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bob's keypair:
bob_key &lt;- keygen()
bob_pubkey &lt;- pubkey(bob_key)

# Alice's keypair:
alice_key &lt;- keygen()
alice_pubkey &lt;- pubkey(alice_key)

# Bob sends encrypted message for Alice:
msg &lt;- charToRaw("TTIP is evil")
ciphertext &lt;- auth_encrypt(msg, bob_key, alice_pubkey)

# Alice verifies and decrypts with her key
out &lt;- auth_decrypt(ciphertext, alice_key, bob_pubkey)
stopifnot(identical(out, msg))

# Alice sends encrypted message for Bob
msg &lt;- charToRaw("Let's protest")
ciphertext &lt;- auth_encrypt(msg, alice_key, bob_pubkey)

# Bob verifies and decrypts with his key
out &lt;- auth_decrypt(ciphertext, bob_key, alice_pubkey)
stopifnot(identical(out, msg))
</code></pre>

<hr>
<h2 id='Diffie-Hellman'>Diffie-Hellman</h2><span id='topic+Diffie-Hellman'></span><span id='topic+diffie_hellman'></span><span id='topic+diffie'></span>

<h3>Description</h3>

<p>The Diffie-Hellman key exchange method allows two parties that have no prior knowledge
of each other to jointly establish a shared secret key over an insecure channel. This
key can then be used to encrypt subsequent communications using a symmetric key cipher.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffie_hellman(key, pubkey)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Diffie-Hellman_+3A_key">key</code></td>
<td>
<p>your private key</p>
</td></tr>
<tr><td><code id="Diffie-Hellman_+3A_pubkey">pubkey</code></td>
<td>
<p>other person's public key</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Encryption methods as implemented in <a href="#topic+data_encrypt">data_encrypt</a> require that parties have a
shared secret key. But often we wish to establish a secure channel with a party we have
no prior relationship with. Diffie-hellman is a method for jointly agreeing on a shared
secret without ever exchanging the secret itself. Sodium implements
<a href="https://en.wikipedia.org/wiki/Curve25519">Curve25519</a>, a state-of-the-art Diffie-Hellman
function suitable for a wide variety of applications.
</p>
<p>The method conists of two steps (see examples). First, both parties generate a random private
key and derive the corresponding public key using <a href="#topic+pubkey">pubkey</a>. These public keys are not
confidential and can be exchanged over an insecure channel. After the public keys are exchanged,
both parties will be able to calculate the (same) shared secret by combining his/her own private
key with the other person's public key using <a href="#topic+diffie_hellman">diffie_hellman</a>.
</p>
<p>After the shared secret has been established, the private and public keys are disposed,
and parties can start encrypting communications based on the shared secret using e.g.
<a href="#topic+data_encrypt">data_encrypt</a>. Because the shared secret cannot be calculated using only the public
keys, the process is safe from eavesdroppers.
</p>


<h3>Value</h3>

<p>Returns a shared secret key which can be used in e.g. <a href="#topic+data_encrypt">data_encrypt</a>.
</p>


<h3>References</h3>

<p><a href="https://doc.libsodium.org/advanced/scalar_multiplication.html">https://doc.libsodium.org/advanced/scalar_multiplication.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bob generates keypair
bob_key &lt;- keygen()
bob_pubkey &lt;- pubkey(bob_key)

# Alice generates keypair
alice_key &lt;- keygen()
alice_pubkey &lt;- pubkey(alice_key)

# After Bob and Alice exchange pubkey they can both derive the secret
alice_secret &lt;- diffie_hellman(alice_key, bob_pubkey)
bob_secret &lt;- diffie_hellman(bob_key, alice_pubkey)
stopifnot(identical(alice_secret, bob_secret))
</code></pre>

<hr>
<h2 id='Hash+20functions'>Hash Functions</h2><span id='topic+Hash+20functions'></span><span id='topic+hash'></span><span id='topic+hashing'></span><span id='topic+scrypt'></span><span id='topic+argon2'></span><span id='topic+shorthash'></span><span id='topic+sha512'></span><span id='topic+sha256'></span>

<h3>Description</h3>

<p>Functions to calculate cryptographic hash of a message, with optionally a key for
HMAC applications. For storing passwords, use <a href="#topic+password_store">password_store</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hash(buf, key = NULL, size = 32)

scrypt(buf, salt = raw(32), size = 32)

argon2(buf, salt = raw(16), size = 32)

shorthash(buf, key)

sha512(buf, key = NULL)

sha256(buf, key = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hash+2B20functions_+3A_buf">buf</code></td>
<td>
<p>data to be hashed</p>
</td></tr>
<tr><td><code id="Hash+2B20functions_+3A_key">key</code></td>
<td>
<p>key for HMAC hashing. Optional, except for in <code>shorthash</code>.</p>
</td></tr>
<tr><td><code id="Hash+2B20functions_+3A_size">size</code></td>
<td>
<p>length of the output hash. Must be between 16 and 64 (recommended is 32)</p>
</td></tr>
<tr><td><code id="Hash+2B20functions_+3A_salt">salt</code></td>
<td>
<p>non-confidential random data to seed the algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic <code>hash</code> function is recommended for most applications. It uses
dynamic length
<a href="https://libsodium.gitbook.io/doc/hashing/generic_hashing">BLAKE2b</a>
where output size can be any value between 16 bytes (128bit) and 64 bytes (512bit).
</p>
<p>The <a href="#topic+scrypt">scrypt</a> hash function is designed to be CPU and memory expensive to protect
against brute force attacks. This algorithm is also used by the <a href="#topic+password_store">password_store</a>
function.
</p>
<p>The <a href="#topic+argon2">argon2</a> hash function is also designed to be CPU and memory expensive to protect
against brute force attacks. Argon2 is a password-hashing function that summarizes the
state of the art in the design of memory-hard functions
</p>
<p>The <code>shorthash</code> function is a special 8 byte (64 bit) hash based on
<a href="https://libsodium.gitbook.io/doc/hashing/short-input_hashing">SipHash-2-4</a>.
The output of this function is only 64 bits (8 bytes). It is useful for in e.g.
Hash tables, but it should not be considered collision-resistant.
</p>
<p>Hash functions can be used for HMAC by specifying a secret <code>key</code>. They key size
for <code>shorthash</code> is 16 bytes, for <code>sha256</code> it is 32 bytes and for <code>sha512</code>
it is 64 bytes. For <code>hash</code> the key size can be any value between 16 and 62,
recommended is at least 32.
</p>


<h3>References</h3>

<p><a href="https://libsodium.gitbook.io/doc/hashing/generic_hashing">https://libsodium.gitbook.io/doc/hashing/generic_hashing</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic hashing
msg &lt;- serialize(iris, NULL)
hash(msg)
sha256(msg)
sha512(msg)
scrypt(msg)

# Generate keys from passphrase
passphrase &lt;- charToRaw("This is super secret")
key &lt;- hash(passphrase)
shortkey &lt;- hash(passphrase, size = 16)
longkey &lt;- hash(passphrase, size = 64)

# HMAC (hashing with key)
hash(msg, key = key)
shorthash(msg, shortkey)
sha256(msg, key = key)
sha512(msg, key = longkey)
</code></pre>

<hr>
<h2 id='Key+20generation'>Keypair Generation</h2><span id='topic+Key+20generation'></span><span id='topic+keygen'></span><span id='topic+pubkey'></span>

<h3>Description</h3>

<p>Functions to generate a random private key and calculate the corresponding curve25519
public key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keygen(seed = random(32))

pubkey(key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Key+2B20generation_+3A_seed">seed</code></td>
<td>
<p>random data to seed the keygen</p>
</td></tr>
<tr><td><code id="Key+2B20generation_+3A_key">key</code></td>
<td>
<p>private key for which to calculate the public key</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Asymmetric methods rely on public-private keypairs. The private keys are secret and
should never be shared with anyone. The public key on the other hand is not confidential
and should be shared with the other parties. Public keys are typically published on the
users's website or posted in public directories or keyservers.
</p>
<p>The two main applications for public key cryptography are encryption and authentication.
</p>
<p>In public key encryption, data that is encrypted using a public key can only be
decrypted using the corresponding private key. This allows anyone to send somebody a
secure message by encrypting it with the receivers public key. The encrypted message
will only be readable by the owner of the corresponding private key. Basic encryption
is implemented in <a href="#topic+simple_encrypt">simple_encrypt</a>.
</p>
<p>Authentication works the other way around. In public key authentication, the owner of the
private key creates a 'signature' (an authenticated checksum) for a message in a way that
allows anyone who knows the user's public key to verify that this message was indeed signed
by the owner of the private key.
</p>
<p>If both sender and receiver know each other's public key, the two methods can be combined
so that each message going back and forth is signed by the sender and encrypted for the
receiver. This protects both against eavesdropping and MITM tampering, creating a fully
secure channel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create keypair
key &lt;- keygen()
pub &lt;- pubkey(key)

# Basic encryption
msg &lt;- serialize(iris, NULL)
ciphertext &lt;- simple_encrypt(msg, pub)
out &lt;- simple_decrypt(ciphertext, key)
stopifnot(identical(msg, out))
</code></pre>

<hr>
<h2 id='Password+20storage'>Password Storage</h2><span id='topic+Password+20storage'></span><span id='topic+password_store'></span><span id='topic+password'></span><span id='topic+password_verify'></span>

<h3>Description</h3>

<p>Wrapper that implements best practices for storing passwords based on scrypt with
a random salt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>password_store(password)

password_verify(hash, password)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Password+2B20storage_+3A_password">password</code></td>
<td>
<p>a string of length one with a password</p>
</td></tr>
<tr><td><code id="Password+2B20storage_+3A_hash">hash</code></td>
<td>
<p>a hash string of length one generated by <code>password_store</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="#topic+password_store">password_store</a> function returns an ASCII encoded string which contains
the result of a memory-hard, CPU-intensive hash function along with the automatically
generated salt and other parameters required to verify the password. Use
<a href="#topic+password_verify">password_verify</a> to verify a password from this string.
</p>


<h3>References</h3>

<p><a href="https://doc.libsodium.org/password_hashing/">https://doc.libsodium.org/password_hashing/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example password
password &lt;- "I like cookies"

# Hash is what you store in the database
hash &lt;- password_store(password)

# To verify the password when the user logs in
stopifnot(password_verify(hash, password))
</code></pre>

<hr>
<h2 id='Signatures'>Create and Verify Signatures</h2><span id='topic+Signatures'></span><span id='topic+sig_sign'></span><span id='topic+sig'></span><span id='topic+sig_verify'></span><span id='topic+sig_keygen'></span><span id='topic+sig_pubkey'></span>

<h3>Description</h3>

<p>Cryptographic signatures can be used to verify the integrity of a message using
the author's public key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_sign(msg, key)

sig_verify(msg, sig, pubkey)

sig_keygen(seed = random(32))

sig_pubkey(key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Signatures_+3A_msg">msg</code></td>
<td>
<p>message to sign</p>
</td></tr>
<tr><td><code id="Signatures_+3A_key">key</code></td>
<td>
<p>private key to sign message with</p>
</td></tr>
<tr><td><code id="Signatures_+3A_sig">sig</code></td>
<td>
<p>a signature generated by <code>signature_sign</code></p>
</td></tr>
<tr><td><code id="Signatures_+3A_pubkey">pubkey</code></td>
<td>
<p>a public key of the keypair used by the signature</p>
</td></tr>
<tr><td><code id="Signatures_+3A_seed">seed</code></td>
<td>
<p>random data to seed the keygen</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A signature is an authenticated checksum that can be used to check that a message
(any data) was created by a particular author and was not tampered with. The signature is
created using a private key and can be verified from the corresponding public key.
</p>
<p>Signatures are used when the message itself is not confidential but integrity is
important. A common use is for software repositories where maintainers include
a signature of the package index. This allows client package managers to verify
that the binaries were not modified by intermediate parties in the distribution
process.
</p>
<p>For confidential data, use authenticated encryption (<a href="#topic+auth_encrypt">auth_encrypt</a>)
which allows for sending signed and encrypted messages in a single method.
</p>
<p>Currently sodium requires a different type of key pairfor signatures  (ed25519)
than for encryption (curve25519).
</p>


<h3>References</h3>

<p><a href="https://doc.libsodium.org/public-key_cryptography/public-key_signatures.html">https://doc.libsodium.org/public-key_cryptography/public-key_signatures.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate keypair
key &lt;- sig_keygen()
pubkey &lt;- sig_pubkey(key)

# Create signature
msg &lt;- serialize(iris, NULL)
sig &lt;- sig_sign(msg, key)
sig_verify(msg, sig, pubkey)
</code></pre>

<hr>
<h2 id='Simple+20encryption'>Anonymous Public-key Encryption (Sealed Box)</h2><span id='topic+Simple+20encryption'></span><span id='topic+simple_encrypt'></span><span id='topic+simple_decrypt'></span>

<h3>Description</h3>

<p>Create an encrypted message (sealed box) from a curve25519 public key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_encrypt(msg, pubkey)

simple_decrypt(bin, key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simple+2B20encryption_+3A_msg">msg</code></td>
<td>
<p>message to be encrypted</p>
</td></tr>
<tr><td><code id="Simple+2B20encryption_+3A_pubkey">pubkey</code></td>
<td>
<p>public key of the receiver</p>
</td></tr>
<tr><td><code id="Simple+2B20encryption_+3A_bin">bin</code></td>
<td>
<p>encrypted ciphertext</p>
</td></tr>
<tr><td><code id="Simple+2B20encryption_+3A_key">key</code></td>
<td>
<p>private key of the receiver</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple public key encryption allows for sending anonymous encrypted messages to
a recipient given its public key. Only the recipient can decrypt these messages,
using its private key.
</p>
<p>While the recipient can verify the integrity of the message, it cannot verify the
identity of the sender. For sending authenticated encrypted messages, use
<a href="#topic+auth_encrypt">auth_encrypt</a> and <a href="#topic+auth_decrypt">auth_decrypt</a>.
</p>


<h3>References</h3>

<p><a href="https://doc.libsodium.org/public-key_cryptography/sealed_boxes.html">https://doc.libsodium.org/public-key_cryptography/sealed_boxes.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate keypair
key &lt;- keygen()
pub &lt;- pubkey(key)

# Encrypt message with pubkey
msg &lt;- serialize(iris, NULL)
ciphertext &lt;- simple_encrypt(msg, pub)

# Decrypt message with private key
out &lt;- simple_decrypt(ciphertext, key)
stopifnot(identical(out, msg))
</code></pre>

<hr>
<h2 id='Sodium+20utilities'>Sodium Utilities</h2><span id='topic+Sodium+20utilities'></span><span id='topic+bin2hex'></span><span id='topic+helpers'></span><span id='topic+hex2bin'></span><span id='topic+random'></span>

<h3>Description</h3>

<p>The functions <code>bin2hex</code> and <code>hex2bin</code> convert between binary (raw)
vectors and corresponding string in hexadecimal notation. The <code>random</code>
function generates <code>n</code> crypto secure random bytes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin2hex(bin)

hex2bin(hex, ignore = ":")

random(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sodium+2B20utilities_+3A_bin">bin</code></td>
<td>
<p>raw vector with binary data to convert to hex string</p>
</td></tr>
<tr><td><code id="Sodium+2B20utilities_+3A_hex">hex</code></td>
<td>
<p>a string with hexadecimal characters to parse into a binary (raw) vector.</p>
</td></tr>
<tr><td><code id="Sodium+2B20utilities_+3A_ignore">ignore</code></td>
<td>
<p>a string with characters to ignore from <code>hex</code>. See example.</p>
</td></tr>
<tr><td><code id="Sodium+2B20utilities_+3A_n">n</code></td>
<td>
<p>number of random bytes or numbers to generate</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Convert raw to hex string and back
test &lt;- charToRaw("test 123")
x &lt;- bin2hex(test)
y &lt;- hex2bin(x)
stopifnot(identical(test, y))
stopifnot(identical(x, paste(test, collapse = "")))

# Parse text with characters
x2 &lt;- paste(test, collapse = ":")
y2 &lt;- hex2bin(x2, ignore = ":")
stopifnot(identical(test, y2))
</code></pre>

<hr>
<h2 id='Stream+20ciphers'>Stream Ciphers</h2><span id='topic+Stream+20ciphers'></span><span id='topic+chacha20'></span><span id='topic+stream'></span><span id='topic+salsa20'></span><span id='topic+xsalsa20'></span>

<h3>Description</h3>

<p>Generate deterministic streams of random data based off a secret key and random nonce.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chacha20(size, key, nonce)

salsa20(size, key, nonce)

xsalsa20(size, key, nonce)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Stream+2B20ciphers_+3A_size">size</code></td>
<td>
<p>length of cipher stream in bytes</p>
</td></tr>
<tr><td><code id="Stream+2B20ciphers_+3A_key">key</code></td>
<td>
<p>secret key used by the cipher</p>
</td></tr>
<tr><td><code id="Stream+2B20ciphers_+3A_nonce">nonce</code></td>
<td>
<p>non-secret unique data to randomize the cipher</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You usually don't need to call these methods directly. For local encryption
use <a href="#topic+data_encrypt">data_encrypt</a>. For secure communication use <a href="#topic+simple_encrypt">simple_encrypt</a> or
<a href="#topic+auth_encrypt">auth_encrypt</a>.
</p>
<p>Random streams form the basis for most cryptographic methods. Based a shared secret
(the key) we generate a predictable random data stream of equal length as the message
we need to encrypt. Then we <a href="base.html#topic+xor">xor</a> the message data with this random stream,
which effectively inverts each byte in the message with probabiliy 0.5. The message
can be decrypted by re-generating exactly the same random data stream and <a href="base.html#topic+xor">xor</a>'ing
it back. See the examples.
</p>
<p>Each stream generator requires a <code>key</code> and a <code>nonce</code>. Both are required to re-generate
the same stream for decryption. The key forms the shared secret and should only known to
the trusted parties. The <code>nonce</code> is not secret and should be stored or sent along
with the ciphertext. The purpose of the <code>nonce</code> is to make a random stream unique
to protect gainst re-use attacks. This way you can re-use a your key to encrypt multiple
messages, as long as you never re-use the same nonce.
</p>


<h3>References</h3>

<p><a href="https://libsodium.gitbook.io/doc/advanced/stream_ciphers/xsalsa20">https://libsodium.gitbook.io/doc/advanced/stream_ciphers/xsalsa20</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Very basic encryption
myfile &lt;- file.path(R.home(), "COPYING")
message &lt;- readBin(myfile, raw(), file.info(myfile)$size)
passwd &lt;- charToRaw("My secret passphrase")

# Encrypt:
key &lt;- hash(passwd)
nonce8 &lt;- random(8)
stream &lt;- chacha20(length(message), key, nonce8)
ciphertext &lt;- base::xor(stream, message)

# Decrypt:
stream &lt;- chacha20(length(ciphertext), key, nonce8)
out &lt;- base::xor(ciphertext, stream)
stopifnot(identical(out, message))

# Other stream ciphers
stream &lt;- salsa20(10000, key, nonce8)
stream &lt;- xsalsa20(10000, key, random(24))

</code></pre>

<hr>
<h2 id='Symmetric+20encryption'>Symmetric Encryption and Tagging</h2><span id='topic+Symmetric+20encryption'></span><span id='topic+data_encrypt'></span><span id='topic+data_decrypt'></span><span id='topic+data_tag'></span>

<h3>Description</h3>

<p>Encryption with authentication using a 256 bit shared secret. Mainly useful for
encrypting local data. For secure communication use public-key encryption
(<a href="#topic+simple_encrypt">simple_encrypt</a> and <a href="#topic+auth_encrypt">auth_encrypt</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_encrypt(msg, key, nonce = random(24))

data_decrypt(bin, key, nonce = attr(bin, "nonce"))

data_tag(msg, key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Symmetric+2B20encryption_+3A_msg">msg</code></td>
<td>
<p>message to be encrypted</p>
</td></tr>
<tr><td><code id="Symmetric+2B20encryption_+3A_key">key</code></td>
<td>
<p>shared secret key used for both encryption and decryption</p>
</td></tr>
<tr><td><code id="Symmetric+2B20encryption_+3A_nonce">nonce</code></td>
<td>
<p>non-secret unique data to randomize the cipher</p>
</td></tr>
<tr><td><code id="Symmetric+2B20encryption_+3A_bin">bin</code></td>
<td>
<p>encrypted ciphertext</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Symmetric encryption uses a secret key to encode and decode a message. This can be
used to encrypt local data on disk, or as a building block for more complex methods.
</p>
<p>Because the same <code>secret</code> is used for both encryption and decryption, symmetric
encryption by itself is impractical for communication. For exchanging secure messages
with other parties, use assymetric (public-key) methods (see <a href="#topic+simple_encrypt">simple_encrypt</a> or
<a href="#topic+auth_encrypt">auth_encrypt</a>).
</p>
<p>The <code>nonce</code> is not confidential but required for decryption, and should be
stored or sent along with the ciphertext. The purpose of the <code>nonce</code> is to
randomize the cipher to protect gainst re-use attacks. This way you can use one
and the same secret for encrypting multiple messages.
</p>
<p>The <a href="#topic+data_tag">data_tag</a> function generates an authenticated hash that can be stored
alongside the data to be able to verify the integrity of the data later on. For
public key signatures see <code>sig_sign</code> instead.
</p>


<h3>References</h3>

<p><a href="https://libsodium.gitbook.io/doc/public-key_cryptography/authenticated_encryption">https://libsodium.gitbook.io/doc/public-key_cryptography/authenticated_encryption</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 256-bit key
key &lt;- sha256(charToRaw("This is a secret passphrase"))
msg &lt;- serialize(iris, NULL)

# Encrypts with random nonce
cipher &lt;- data_encrypt(msg, key)
orig &lt;- data_decrypt(cipher, key)
stopifnot(identical(msg, orig))

# Tag the message with your key (HMAC)
tag &lt;- data_tag(msg, key)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
