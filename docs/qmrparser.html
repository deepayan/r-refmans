<!DOCTYPE html><html><head><title>Help for package qmrparser</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qmrparser}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#qmrparser-package'>
<p>Parser Combinator in R</p></a></li>
<li><a href='#alternation'>
<p>Alternative phrases</p></a></li>
<li><a href='#charInSetParser'>
<p>Single character, belonging to a given set, token</p></a></li>
<li><a href='#charParser'>
<p>Specific single character token.</p></a></li>
<li><a href='#commentParser'>
<p>Comment token.</p></a></li>
<li><a href='#concatenation'>
<p>One phrase then another</p></a></li>
<li><a href='#dots'>
<p>Dots sequence token.</p></a></li>
<li><a href='#empty'>
<p>Empty token</p></a></li>
<li><a href='#eofMark'>
<p>End of file token</p></a></li>
<li><a href='#isDigit'>
<p>Is it a digit?</p></a></li>
<li><a href='#isHex'>
<p>Is it an hexadecimal digit?</p></a></li>
<li><a href='#isLetter'>
<p>Is it a letter?</p></a></li>
<li><a href='#isLowercase'>
<p>Is it a lower case?</p></a></li>
<li><a href='#isNewline'>
<p>Is it a new line character?</p></a></li>
<li><a href='#isSymbol'>
<p>Is it a symbol?</p></a></li>
<li><a href='#isUppercase'>
<p>Is it an upper case?</p></a></li>
<li><a href='#isWhitespace'>
<p>Is it a white space?</p></a></li>
<li><a href='#keyword'>
<p>Arbitrary given token.</p></a></li>
<li><a href='#numberFloat'>
<p>Floating-point number token.</p></a></li>
<li><a href='#numberInteger'>
<p>Integer number token.</p></a></li>
<li><a href='#numberNatural'>
<p>Natural number token.</p></a></li>
<li><a href='#numberScientific'>
<p>Number in scientific notation token.</p></a></li>
<li><a href='#option'>
<p>Optional parser</p></a></li>
<li><a href='#pcAxisCubeMake'>
<p>Creates PC-AXIS cube</p></a></li>
<li><a href='#pcAxisCubeToCSV'>
<p>Exports a PC-AXIS cube into CSV in several files.</p></a></li>
<li><a href='#pcAxisParser'>
<p>Parser for PC-AXIS format files</p></a></li>
<li><a href='#repetition0N'>
<p>Repeats one parser</p></a></li>
<li><a href='#repetition1N'>
<p>Repeats a parser, at least once.</p></a></li>
<li><a href='#separator'>
<p>Generic word separator token.</p></a></li>
<li><a href='#streamParser'>
<p>Generic interface for character processing, allowing forward and backwards translation.</p></a></li>
<li><a href='#streamParserFromFileName'>
<p>Creates a streamParser from a file name</p></a></li>
<li><a href='#streamParserFromString'>
<p>Creates a streamParser from a string</p></a></li>
<li><a href='#string'>
<p>Token string</p></a></li>
<li><a href='#symbolic'>
<p>Alphanumeric token.</p></a></li>
<li><a href='#whitespace'>
<p>White sequence token.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parser Combinator in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Juan Gea Rosat, Ramon Martínez Coscollà .</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juan Gea &lt;juangea@geax.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Basic functions for building parsers, with an application to PC-AXIS format files.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-23 15:11:51 UTC; local</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-24 00:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='qmrparser-package'>
Parser Combinator in R
</h2><span id='topic+qmrparser-package'></span><span id='topic+qmrparser'></span>

<h3>Description</h3>

<p>Basic functions for building parsers, with an application to PC-AXIS format files.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> qmrparser</td>
</tr>
<tr>
 <td style="text-align: left;">
Type:    </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date:    </td><td style="text-align: left;"> 2022-04-10</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 3)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad:</td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Collection of functions to build programs to read complex data files formats, with an application to the case of PC-AXIS format.
</p>


<h3>Author(s)</h3>

<p>Juan Gea Rosat, Ramon Martínez Coscollà 
</p>
<p>Maintainer: Juan Gea Rosat &lt;juangea@geax.net&gt;
</p>


<h3>References</h3>

<p>Parser combinator. 
<a href="https://en.wikipedia.org/wiki/Parser_combinator">https://en.wikipedia.org/wiki/Parser_combinator</a>
</p>
<p>Context-free grammar.
<a href="https://en.wikipedia.org/wiki/Context-free_grammar">https://en.wikipedia.org/wiki/Context-free_grammar</a>    
</p>
<p>PC-Axis file format.
<a href="https://www.scb.se/en/services/statistical-programs-for-px-files/px-file-format/">https://www.scb.se/en/services/statistical-programs-for-px-files/px-file-format/</a>
</p>
<p>Type <code>RShowDoc("index",package="qmrparser")</code> at the R command line to open the package vignette.
</p>
<p>Type <code> RShowDoc("qmrparser",package="qmrparser")</code> to open pdf developer guide.
</p>
<p>Source code used in literate programming can be found in folder 'noweb'.
</p>

<hr>
<h2 id='alternation'>
Alternative phrases
</h2><span id='topic+alternation'></span>

<h3>Description</h3>

<p>Applies parsers until one succeeds or all of them fail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  alternation(..., 
              action = function(s)   list(type="alternation",value=s), 
              error  = function(p,h) list(type="alternation",pos  =p,h=h) ) 
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alternation_+3A_...">...</code></td>
<td>
<p>list of alternative parsers to be executed</p>
</td></tr>
<tr><td><code id="alternation_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. It takes as input parameters information derived from parsers involved as parameters</p>
</td></tr>
<tr><td><code id="alternation_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. I takes two parameters:
</p>

<ul>
<li>  <p><code>p</code> 
</p>
<p>with position where parser, <code><a href="#topic+streamParser">streamParser</a></code>,  starts its recognition, obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code>
</p>
</li>
<li> <p><code>h</code>
</p>
<p>with information obtained from parsers involved as parameters, normally related with failure(s) position in component parsers.
</p>
<p>Its information depends on how parser involved as parameters are combined and on the <code>error</code> definition in these parsers.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>In case of success, <code>action</code> gets the <code>node</code> from the first parse to succeed.
</p>
<p>In case of failure, parameter <code>h</code> from <code>error</code> gets a list, with information about failure from all the parsers processed.
</p>


<h3>Value</h3>

<p>Anonymous functions, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From these input parameters, an anonymous function is constructed. This function admits just one parameter, stream, with <code><a href="#topic+streamParser">streamParser</a></code> class, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

# ok
stream  &lt;- streamParserFromString("123 Hello world")
( alternation(numberNatural(),symbolic())(stream) )[c("status","node")]


# fail
stream  &lt;- streamParserFromString("123 Hello world")
( alternation(string(),symbolic())(stream) )[c("status","node")]


</code></pre>

<hr>
<h2 id='charInSetParser'>
Single character, belonging to a given set, token
</h2><span id='topic+charInSetParser'></span>

<h3>Description</h3>

<p>Recognises a single character satisfying a predicate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  charInSetParser(fun,
                 action = function(s) list(type="charInSet",value=s), 
                 error  = function(p) list(type="charInSet",pos  =p)) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charInSetParser_+3A_fun">fun</code></td>
<td>
<p>Function to determine if character belongs to a set.
Argument &quot;fun&quot; is a signature function: character -&gt; logical (boolean)</p>
</td></tr>
<tr><td><code id="charInSetParser_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="charInSetParser_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# fail
stream  &lt;- streamParserFromString("H")
( charInSetParser(isDigit)(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("a")
( charInSetParser(isLetter)(stream) )[c("status","node")]


</code></pre>

<hr>
<h2 id='charParser'>
Specific single character token.
</h2><span id='topic+charParser'></span>

<h3>Description</h3>

<p>Recognises a specific single character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  charParser(char,
            action = function(s) list(type="char",value=s), 
            error  = function(p) list(type="char",pos  =p)) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charParser_+3A_char">char</code></td>
<td>
<p>character to be recognised</p>
</td></tr>
<tr><td><code id="charParser_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="charParser_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+keyword">keyword</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fail
stream  &lt;- streamParserFromString("H")
( charParser("a")(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("a")
( charParser("a")(stream) )[c("status","node")]

# ok 
( charParser("\U00B6")(streamParserFromString("\U00B6")) )[c("status","node")]

</code></pre>

<hr>
<h2 id='commentParser'>
Comment token.
</h2><span id='topic+commentParser'></span>

<h3>Description</h3>

<p>Recognises a comment, a piece of text delimited by two predefined tokens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  commentParser(beginComment,endComment,
          action = function(s) list(type="commentParser",value=s),
          error  = function(p) list(type="commentParser",pos  =p))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commentParser_+3A_begincomment">beginComment</code></td>
<td>
<p>String indicating comment beginning</p>
</td></tr>
<tr><td><code id="commentParser_+3A_endcomment">endComment</code></td>
<td>
<p>String indicating comment end</p>
</td></tr>
<tr><td><code id="commentParser_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="commentParser_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Characters preceded by \ are not considered as part of beginning of comment end.
</p>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# fail
stream  &lt;- streamParserFromString("123")
( commentParser("(*","*)")(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("(*123*)")
( commentParser("(*","*)")(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='concatenation'>
One phrase then another
</h2><span id='topic+concatenation'></span>

<h3>Description</h3>

<p>Applies to the recognition a parsers sequence. Recognition will succeed as long as all of them succeed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  concatenation(..., 
                action = function(s)   list(type="concatenation",value=s),
                error  = function(p,h) list(type="concatenation",pos=p ,h=h)) 
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concatenation_+3A_...">...</code></td>
<td>
<p>list of parsers to be executed</p>
</td></tr>
<tr><td><code id="concatenation_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. It takes as input parameters information derived from parsers involved as parameters</p>
</td></tr>
<tr><td><code id="concatenation_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. I takes two parameters:
</p>

<ul>
<li>  <p><code>p</code> 
</p>
<p>with position where parser, <code><a href="#topic+streamParser">streamParser</a></code>,  starts its recognition, obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code>
</p>
</li>
<li> <p><code>h</code>
</p>
<p>with information obtained from parsers involved as parameters, normally related with failure(s) position in component parsers.
</p>
<p>Its information depends on how parser involved as parameters are combined and on the <code>error</code> definition in these parsers.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>In case of success, parameter <code>s</code> from <code>action</code> gets a list with information about <code>node</code> from all parsers processed.
</p>
<p>In case of failure, parameter <code>h</code> from <code>error</code> gets the value returned by the failing parser.
</p>


<h3>Value</h3>

<p>Anonymous functions, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From these input parameters, an anonymous function is constructed. This function admits just one parameter, stream, with <code><a href="#topic+streamParser">streamParser</a></code> class, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# ok
stream  &lt;- streamParserFromString("123Hello world")
( concatenation(numberNatural(),symbolic())(stream) )[c("status","node")]


# fail
stream  &lt;- streamParserFromString("123 Hello world")
( concatenation(string(),symbolic())(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='dots'>
Dots sequence token.
</h2><span id='topic+dots'></span>

<h3>Description</h3>

<p>Recognises a sequence of an arbitrary number of dots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  dots(action = function(s) list(type="dots",value=s), 
       error  = function(p) list(type="dots",pos  =p)) 
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dots_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="dots_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# fail
stream  &lt;- streamParserFromString("Hello world")
( dots()(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("..")
( dots()(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='empty'>
Empty token
</h2><span id='topic+empty'></span>

<h3>Description</h3>

<p>Recognises a null token. This parser always succeeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  empty(action = function(s) list(type="empty",value=s), 
        error  = function(p) list(type="empty",pos  =p)) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empty_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="empty_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Details</h3>

<p><code>action</code> <code>s</code> parameter is always &quot;&quot;.
Error parameters exists for the sake of homogeneity with the rest of functions. It is not used.
</p>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# ok
stream  &lt;- streamParserFromString("Hello world")
( empty()(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("")
( empty()(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='eofMark'>
End of file token
</h2><span id='topic+eofMark'></span>

<h3>Description</h3>

<p>Recognises the end of input flux as a token.
</p>
<p>When applied, it does not make use of character and, therefore, end of input can be recognised several times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  eofMark(action = function(s) list(type="eofMark",value=s), 
          error  = function(p) list(type="eofMark",pos  =p ) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eofMark_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="eofMark_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>When succeeds, parameter <code>s</code> takes the value &quot;&quot;.
</p>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# fail
stream  &lt;- streamParserFromString("Hello world")
( eofMark()(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("")
( eofMark()(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='isDigit'>
Is it a digit?
</h2><span id='topic+isDigit'></span>

<h3>Description</h3>

<p>Checks whether a character is a digit: { 0 .. 9 }.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isDigit(ch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isDigit_+3A_ch">ch</code></td>
<td>
<p>character to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE, depending on the character being a digit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isDigit('9')
isDigit('a')
</code></pre>

<hr>
<h2 id='isHex'>
Is it an hexadecimal digit?
</h2><span id='topic+isHex'></span>

<h3>Description</h3>

<p>Checks whether a character is an hexadecimal digit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isHex(ch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isHex_+3A_ch">ch</code></td>
<td>
<p>character to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE, depending on character being an hexadecimal digit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isHex('+')
isHex('A')
isHex('a')
isHex('9')
</code></pre>

<hr>
<h2 id='isLetter'>
Is it a letter?
</h2><span id='topic+isLetter'></span>

<h3>Description</h3>

<p>Checks whether a character is a letter
</p>
<p>Restricted to ASCII character (does not process ñ, ç, accented vowels...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isLetter(ch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isLetter_+3A_ch">ch</code></td>
<td>
<p>character to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE, depending on the character being a letter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isLetter('A')
isLetter('a')
isLetter('9')
</code></pre>

<hr>
<h2 id='isLowercase'>
Is it a lower case?
</h2><span id='topic+isLowercase'></span>

<h3>Description</h3>

<p>Checks whether a character is a lower case.
</p>
<p>Restricted to ASCII character (does not process ñ, ç, accented vowels...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isLowercase(ch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isLowercase_+3A_ch">ch</code></td>
<td>
<p>character to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE, depending on character being a lower case character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isLowercase('A')
isLowercase('a')
isLowercase('9')
</code></pre>

<hr>
<h2 id='isNewline'>
Is it a new line character?
</h2><span id='topic+isNewline'></span>

<h3>Description</h3>

<p>Checks whether a character is a new line character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNewline(ch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNewline_+3A_ch">ch</code></td>
<td>
<p>character to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE, depending on character being a newline character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isNewline(' ')
isNewline('\n')
</code></pre>

<hr>
<h2 id='isSymbol'>
Is it a symbol?
</h2><span id='topic+isSymbol'></span>

<h3>Description</h3>

<p>Checks whether a character is a symbol, a special character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isSymbol(ch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isSymbol_+3A_ch">ch</code></td>
<td>
<p>character to be checked</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These characters are considered as symbols:  
</p>
<p>'!' , '%' , '&amp;' , '$' , '#' , '+' , '-' , '/' , ':' , '&lt;' , '=' , '&gt;' , '?' , '@' , '\' , '~' , '^' , '|' , '*'
</p>


<h3>Value</h3>

<p>TRUE/FALSE, depending on character being a symbol.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isSymbol('+')
isSymbol('A')
isSymbol('a')
isSymbol('9')
</code></pre>

<hr>
<h2 id='isUppercase'>
Is it an upper case?
</h2><span id='topic+isUppercase'></span>

<h3>Description</h3>

<p>Checks whether a character is an upper case.
</p>
<p>Restricted to ASCII character (does not process ñ, ç, accented vowels...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isUppercase(ch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isUppercase_+3A_ch">ch</code></td>
<td>
<p>character to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE, depending on character being an upper case character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isUppercase('A')
isUppercase('a')
isUppercase('9')
</code></pre>

<hr>
<h2 id='isWhitespace'>
Is it a white space?
</h2><span id='topic+isWhitespace'></span>

<h3>Description</h3>

<p>Checks whether a character belongs to the set {blank, tabulator, new line, carriage return, page break }.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isWhitespace(ch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isWhitespace_+3A_ch">ch</code></td>
<td>
<p>character to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE, depending on character belonging to the specified set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isWhitespace(' ')
isWhitespace('\n')
isWhitespace('a')
</code></pre>

<hr>
<h2 id='keyword'>
Arbitrary given token.
</h2><span id='topic+keyword'></span>

<h3>Description</h3>

<p>Recognises a given character sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  keyword(word,
          action = function(s) list(type="keyword",value=s), 
          error  = function(p) list(type="keyword",pos  =p)) 
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keyword_+3A_word">word</code></td>
<td>
<p>Symbol to be recognised.</p>
</td></tr>
<tr><td><code id="keyword_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="keyword_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# fail
stream  &lt;- streamParserFromString("Hello world")
( keyword("world")(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("world")
( keyword("world")(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='numberFloat'>
Floating-point number token.
</h2><span id='topic+numberFloat'></span>

<h3>Description</h3>

<p>Recognises a floating-point number, i.e., an integer with a decimal part. One of them (either integer or decimal part) must be present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  numberFloat(action = function(s) list(type="numberFloat",value=s), 
              error  = function(p) list(type="numberFloat",pos  =p)) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numberFloat_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="numberFloat_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# fail
stream  &lt;- streamParserFromString("Hello world")
( numberFloat()(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("-456.74")
( numberFloat()(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='numberInteger'>
Integer number token.
</h2><span id='topic+numberInteger'></span>

<h3>Description</h3>

<p>Recognises an integer, i.e., a natural number optionally preceded by a + or - sign.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  numberInteger(action = function(s) list(type="numberInteger",value=s), 
                error  = function(p) list(type="numberInteger",pos  =p)) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numberInteger_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="numberInteger_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# fail
stream  &lt;- streamParserFromString("Hello world")
( numberInteger()(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("-1234")
( numberInteger()(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='numberNatural'>
Natural number token.
</h2><span id='topic+numberNatural'></span>

<h3>Description</h3>

<p>A natural number is a sequence of digits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  numberNatural(action = function(s) list(type="numberNatural",value=s), 
                error  = function(p) list(type="numberNatural",pos  =p))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numberNatural_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="numberNatural_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# fail
stream  &lt;- streamParserFromString("Hello world")
( numberNatural()(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("123")
( numberNatural()(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='numberScientific'>
Number in scientific notation token.
</h2><span id='topic+numberScientific'></span>

<h3>Description</h3>

<p>Recognises a number in scientific notation, i.e., a floating-point number with an (optional) exponential part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  numberScientific(action = function(s) list(type="numberScientific",value=s), 
                   error  = function(p) list(type="numberScientific",pos=p)  ) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numberScientific_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="numberScientific_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# fail
stream  &lt;- streamParserFromString("Hello world")
( numberScientific()(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("-1234e12")
( numberScientific()(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='option'>
Optional parser
</h2><span id='topic+option'></span>

<h3>Description</h3>

<p>Applies a parser to the text. If it does not succeed, an empty token is returned.
</p>
<p>Optional parser never fails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  option(ap, 
         action = function(s  ) list(type="option",value=s    ), 
         error  = function(p,h) list(type="option",pos  =p,h=h)) 
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="option_+3A_ap">ap</code></td>
<td>
<p>Optional parser</p>
</td></tr>
<tr><td><code id="option_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. It takes as input parameters information derived from parsers involved as parameters</p>
</td></tr>
<tr><td><code id="option_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. I takes two parameters:
</p>

<ul>
<li>  <p><code>p</code> 
</p>
<p>with position where parser, <code><a href="#topic+streamParser">streamParser</a></code>,  starts its recognition, obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code>
</p>
</li>
<li> <p><code>h</code>
</p>
<p>with information obtained from parsers involved as parameters, normally related with failure(s) position in component parsers.
</p>
<p>Its information depends on how parser involved as parameters are combined and on the <code>error</code> definition in these parsers.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>In case of success, <code>action</code> gets the <code>node</code> returned by parser passed as optional. Otherwise, it gets the <code>node</code> corresponding to token <code><a href="#topic+empty">empty</a></code>: <code>list(type="empty" ,value="")</code>
</p>
<p>Function <code>error</code> is never called. It is defined as parameter for the sake of homogeneity with the rest of functions. 
</p>


<h3>Value</h3>

<p>Anonymous functions, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From these input parameters, an anonymous function is constructed. This function admits just one parameter, stream, with <code><a href="#topic+streamParser">streamParser</a></code> class, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# ok
stream  &lt;- streamParserFromString("123 Hello world")
( option(numberNatural())(stream) )[c("status","node")]


# ok
stream  &lt;- streamParserFromString("123 Hello world")
( option(string())(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='pcAxisCubeMake'>
Creates PC-AXIS cube
</h2><span id='topic+pcAxisCubeMake'></span>

<h3>Description</h3>

<p>From the constructed syntactical tree, structures in R are generated. These structures contain the PC-AXIS cube information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcAxisCubeMake(cstream) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcAxisCubeMake_+3A_cstream">cstream</code></td>
<td>
<p>tree returned by the PC-AXIS file syntactical analysis </p>
</td></tr>   
</table>


<h3>Value</h3>

<p>It returns a list with the following elements:
</p>
<table>
<tr><td><code>pxCube (data.frame)</code></td>
<td>


<table>
<tr>
 <td style="text-align: left;">
      headingLength </td><td style="text-align: left;"> Number of variables in "HEADING".</td>
</tr>
<tr>
 <td style="text-align: left;">
      StubLength    </td><td style="text-align: left;"> Number of variables in "STUB".</td>
</tr>
<tr>
 <td style="text-align: left;">
      frequency     </td><td style="text-align: left;"> Data frequency if "TIMEVAL" is present. </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>
</td></tr>
<tr><td><code>pxCubeVariable (data.frame)</code></td>
<td>


<table>
<tr>
 <td style="text-align: left;">
        variableName  </td><td style="text-align: left;"> Variable name.</td>
</tr>
<tr>
 <td style="text-align: left;">
        headingOrStud </td><td style="text-align: left;"> Indicator, whether the variable appears in "HEADING" or "STUB". </td>
</tr>
<tr>
 <td style="text-align: left;">
        codesYesNo    </td><td style="text-align: left;"> Indicator, whether there is "CODES" associated to the variable.</td>
</tr>
<tr>
 <td style="text-align: left;">
        valuesYesNo   </td><td style="text-align: left;"> Indicator, whether there is "VALUES" associated to the variable.</td>
</tr>
<tr>
 <td style="text-align: left;">
        variableOrder </td><td style="text-align: left;"> Variable order number in "HEADING" or "STUB"</td>
</tr>
<tr>
 <td style="text-align: left;">
        valueLength   </td><td style="text-align: left;"> Number of different "CODES" and/or  "VALUES" associated with the variable.</td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>
</td></tr>
<tr><td><code>pxCubeVariableDomain (data.frame)</code></td>
<td>


<table>
<tr>
 <td style="text-align: left;">
      variableName     </td><td style="text-align: left;"> Variable name.</td>
</tr>
<tr>
 <td style="text-align: left;">
      code             </td><td style="text-align: left;"> Value code when "CODES" is present.</td>
</tr>
<tr>
 <td style="text-align: left;">
      value            </td><td style="text-align: left;"> Value literal when "VALUES" is present.</td>
</tr>
<tr>
 <td style="text-align: left;">
      valueOrder       </td><td style="text-align: left;"> Variable order number in "CODES" and/or "VALUES".</td>
</tr>
<tr>
 <td style="text-align: left;">
      eliminationYesNo </td><td style="text-align: left;"> Indicator, whether the value for the variables is present in "ELIMINATION".</td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>
</td></tr>
<tr><td><code>pxCubeAttrN</code></td>
<td>
<p>data.frame list, one for each different parameters cardinalities appearing in &quot;keyword&quot; 
</p>

<ul>
<li><p>pxCubeAttrN$A0 (data.frame)
</p>

<table>
<tr>
 <td style="text-align: left;">
        keyword  </td><td style="text-align: left;">  Keyword.</td>
</tr>
<tr>
 <td style="text-align: left;">
        language </td><td style="text-align: left;">  Language code o "".</td>
</tr>
<tr>
 <td style="text-align: left;">
        length   </td><td style="text-align: left;">  Number of elements of value list.</td>
</tr>
<tr>
 <td style="text-align: left;">
        value    </td><td style="text-align: left;">  Associated data, keyword[language] = value.</td>
</tr>
<tr>
 <td style="text-align: left;">
   </td>
</tr>

</table>

</li>
<li><p>pxCubeAttrN$A1 (data.frame)
</p>

<table>
<tr>
 <td style="text-align: left;">
        keyword  </td><td style="text-align: left;"> Keyword.</td>
</tr>
<tr>
 <td style="text-align: left;">
        language </td><td style="text-align: left;"> Language code o "".</td>
</tr>
<tr>
 <td style="text-align: left;">
        arg1     </td><td style="text-align: left;"> Argument value.</td>
</tr>
<tr>
 <td style="text-align: left;">
        length   </td><td style="text-align: left;"> Number of elements of value list.</td>
</tr>
<tr>
 <td style="text-align: left;">
        value    </td><td style="text-align: left;"> Associated data , keyword[language](arg) = value.</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

</li>
<li><p>pxCubeAttrN$A2 (data.frame)
</p>

<table>
<tr>
 <td style="text-align: left;">
        keyword  </td><td style="text-align: left;"> Keyword.</td>
</tr>
<tr>
 <td style="text-align: left;">
        language </td><td style="text-align: left;"> Language code o "".</td>
</tr>
<tr>
 <td style="text-align: left;">
        arg1     </td><td style="text-align: left;"> Argument one value.</td>
</tr>
<tr>
 <td style="text-align: left;">
        arg2     </td><td style="text-align: left;"> Argument to value.</td>
</tr>
<tr>
 <td style="text-align: left;">
        length   </td><td style="text-align: left;"> Value list number of elements.</td>
</tr>
<tr>
 <td style="text-align: left;">
        value    </td><td style="text-align: left;"> Associated data , keyword[language](arg1,arg2) = value.</td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>

</li></ul>
</td></tr>
<tr><td><code>pxCubeData (data.frame)</code></td>
<td>


<table>
<tr>
 <td style="text-align: left;">
        StubLength + headingLength columns </td><td style="text-align: left;">, with variables values, ordered according to "STUB" and followed by those appearing in "HEADING".
        
        Variables names correspond to variable names.</td>
</tr>
<tr>
 <td style="text-align: left;">
        data </td><td style="text-align: left;"> associated value.</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>
</td></tr>
</table>
<p>Returned value short version is:
</p>
<pre>
Value:
 pxCube              (headingLength, StubLength)
 pxCubeVariable      (variableName , headingOrStud, codesYesNo, valuesYesNo, variableOrder, valueLength)
 pxCubeVariableDomain(variableName , code, value, valueOrder, eliminationYesNo)
 pxCubeAttr          -&gt; list pxCubeAttrN(key, {variableName} , value)
 pxCubeData          ({variableName}+, data)   varia signatura

</pre>


<h3>References</h3>

<p>PC-Axis file format. 
</p>
<p><a href="https://www.scb.se/en/services/statistical-programs-for-px-files/px-file-format/">https://www.scb.se/en/services/statistical-programs-for-px-files/px-file-format/</a>
</p>
<p>PC-Axis file format manual. Statistics of Finland.
</p>
<p><a href="https://tilastokeskus.fi/tup/pcaxis/tiedostomuoto2006_laaja_en.pdf">https://tilastokeskus.fi/tup/pcaxis/tiedostomuoto2006_laaja_en.pdf</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
    ## significant time reductions may be achieve by doing:
    library("compiler")
    enableJIT(level=3)
  
## End(Not run)
  
  name     &lt;- system.file("extdata","datInSFexample6_1.px", package = "qmrparser")
  
  stream   &lt;- streamParserFromFileName(name,encoding="UTF-8")
  
  cstream  &lt;-  pcAxisParser(stream)
  if ( cstream$status == 'ok' ) {
    cube &lt;- pcAxisCubeMake(cstream)
    
    ## Variables
    print(cube$pxCubeVariable)
    
    ## Data
    print(cube$pxCubeData)

  }
  
  ## Not run: 
      #
      # Error messages like
      #                " ... invalid multibyte string ... "
      # or warnings
      #                " input string ...  is invalid in this locale"
      #
      # For example, in Linux the error generated by this code:
       name     &lt;-     "https://www.ine.es/pcaxisdl//t20/e245/p04/a2009/l0/00000008.px" 
      stream   &lt;- streamParserFromString( readLines( name ) )    
      cstream  &lt;- pcAxisParser(stream)
      if ( cstream$status == 'ok' )  cube &lt;- pcAxisCubeMake(cstream)
      #
      # is caused by files with a non-readable 'encoding'.
      # In the case where it could be read, there may also be problems 
      # with string-handling functions, due to multibyte characters. 
      # In Windows, according to \code{link{Sys.getlocale}()},
      # file may be read but accents, ñ, ... may not be correctly recognised.
      #
      #
      # There are, at least, the following options:
      #  - File conversion to utf-8, from the OS, with
      # "iconv - Convert encoding of given files from one encoding to another"
      #
      #  - File conversion in R:
      name    &lt;- "https://www.ine.es/pcaxisdl//t20/e245/p04/a2009/l0/00000008.px" 
      stream   &lt;- streamParserFromString( iconv( readLines( name ), "IBM850", "UTF-8") )
      cstream  &lt;- pcAxisParser(stream)
      if ( cstream$status == 'ok' )  cube &lt;- pcAxisCubeMake(cstream)
      #
      # In the latter case, latin1 would also work, but accents, ñ, ... would not be
      # correctly read.
      #
      #  - Making the assumption that the file does not contain multibyte characters:
      #
      localeOld &lt;- Sys.getlocale("LC_CTYPE")
      Sys.setlocale(category = "LC_CTYPE", locale = "C")
      #
      name     &lt;-
        "https://www.ine.es/pcaxisdl//t20/e245/p04/a2009/l0/00000008.px" 
      stream   &lt;- streamParserFromString( readLines( name ) )
      cstream  &lt;- pcAxisParser(stream)
      if ( cstream$status == 'ok' )  cube &lt;- pcAxisCubeMake(cstream)
      #
      Sys.setlocale(category = "LC_CTYPE", locale = localeOld)
      #
      # However, some characters will not be correctly read (accents, ñ, ...)

    
## End(Not run)
    
</code></pre>

<hr>
<h2 id='pcAxisCubeToCSV'>
Exports a PC-AXIS cube into CSV in several files.
</h2><span id='topic+pcAxisCubeToCSV'></span>

<h3>Description</h3>

<p>It generates four csv files, plus four more depending on &quot;keyword&quot; parameters in PC-AXIS file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcAxisCubeToCSV(prefix,pcAxisCube) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcAxisCubeToCSV_+3A_prefix">prefix</code></td>
<td>
<p>prefix for files to be created</p>
</td></tr>
<tr><td><code id="pcAxisCubeToCSV_+3A_pcaxiscube">pcAxisCube</code></td>
<td>
<p>PC-AXIS cube</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Created files names are:
</p>

<ul>
<li><p>prefix+&quot;pxCube.csv&quot; 
</p>
</li>
<li><p>prefix+&quot;pxCubeVariable.csv&quot; 
</p>
</li>
<li><p>prefix+&quot;pxCubeVariableDomain.csv&quot; 
</p>
</li>
<li><p>prefix+&quot;pxCubeData.csv&quot; 
</p>
</li>
<li><p>prefix+&quot;pxCube&quot;+name+&quot;.csv&quot; With name = A0,A1,A2 ... 
</p>
</li></ul>



<h3>Value</h3>

<p>NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  name     &lt;- system.file("extdata","datInSFexample6_1.px", package = "qmrparser")
  stream   &lt;- streamParserFromFileName(name,encoding="UTF-8")
  cstream  &lt;-  pcAxisParser(stream)
  if ( cstream$status == 'ok' ) {
    cube &lt;- pcAxisCubeMake(cstream)
    
    pcAxisCubeToCSV(prefix="datInSFexample6_1",pcAxisCube=cube)     

    unlink("datInSFexample6_1*.csv")
  }
</code></pre>

<hr>
<h2 id='pcAxisParser'>
Parser for PC-AXIS format files
</h2><span id='topic+pcAxisParser'></span>

<h3>Description</h3>

<p>Reads and creates the syntactical tree from a PC-AXIS format file or text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    pcAxisParser(streamParser)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcAxisParser_+3A_streamparser">streamParser</code></td>
<td>
<p>stream parse associated to the file/text to be recognised</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Grammar definition, wider than the strict PC-AXIS definition
</p>
<pre>

 pcaxis        = { rule } , eof ;
 
 rule          = keyword                        ,
                 [ '[' , language      , ']' ]  , 
                 [ '(' , parameterList , ')' ]  , 
                 =                              , 
                 ruleRight                      ;
 
 parameterList = parameter ,  { ',' , parameterList  }  ;
 
 ruleRight     = string , string     , {       string } , ';'
               | string ,              { ',' , string } , ';'
               | number , sepearator , {     , number } , ( ';' | eof )
               | symbolic 
               | 'TLIST' , '(' , symbolic , 
                                ( ( ')' , { ',' , string }) 
                                  |
                                  ( ',' , string , '-' , string , ')' )
                                ) , ';'
               ; 
 
 keyword       = symbolic         ;
 
 language      = symbolic         ;
 
 parameter     = string           ;
 
 separator     = ' ' |  ',' | ';' ;
 
 eof           = ? eof ?          ;
 
 string        = ? string   ?     ;
 
 symbolic      = ? symbolic ?     ;
 
 number        = ? number   ?     ;
 </pre>
<p>Normally, this function is a previous step in order to eventually call <code>pcAxisCubeMake</code>:
</p>
<p><code>  
   cstream  &lt;- pcAxisParser(stream)
   if ( cstream$status == 'ok' )  cube &lt;- pcAxisCubeMake(cstream)
 </code>   
</p>


<h3>Value</h3>

<p>Returns a list with &quot;status&quot; &quot;node&quot;   &quot;stream&quot;:
</p>
<table>
<tr><td><code>status</code></td>
<td>
<p> &quot;ok&quot; or &quot;fail&quot;</p>
</td></tr>
<tr><td><code>stream</code></td>
<td>
<p>Stream situation after recognition</p>
</td></tr>
<tr><td><code>node</code></td>
<td>
<p>List, one node element for each &quot;keyword&quot; in PC-AXIS file.
Each node element is a list with: &quot;keyword&quot; &quot;language&quot; &quot;parameters&quot; &quot;ruleRight&quot;:
</p>

<ul>
<li><p>keyword  
</p>
<p>PC-AXIS keyword
</p>
</li>
<li><p>language 
</p>
<p>language code or &quot;&quot;
</p>
</li>
<li><p>parameters 
</p>
<p>null or string list with parenthesised values associated to keyword 
</p>
</li>
<li><p>ruleRight 
</p>
<p>is a list of two elements, &quot;type&quot;  &quot;value&quot; : 
</p>
<p>If type = &quot;symbol&quot;,         value =  symbol
</p>
<p>If type = &quot;liststring&quot;,     value =  string vector, originally delimited by &quot;,&quot; 
</p>
<p>If type = &quot;stringstring&quot;,   value =  string vector, originally delimited by blanks, new line, ...
</p>
<p>If type = &quot;list&quot;        ,   value =  numerical vector, originally delimited by &quot;,&quot; 
</p>
<p>If type = &quot;tlist&quot;       ,   value = (frequency, &quot;limit&quot; keyword , lower-limit , upper-limit) or (frequency, &quot;list&quot; keyword , periods list )    
</p>
</li></ul>
</td></tr>
</table>


<h3>References</h3>

<p>PC-Axis file format. 
</p>
<p><a href="https://www.scb.se/en/services/statistical-programs-for-px-files/px-file-format/">https://www.scb.se/en/services/statistical-programs-for-px-files/px-file-format/</a>
</p>
<p>PC-Axis file format manual. Statistics of Finland.
</p>
<p><a href="https://tilastokeskus.fi/tup/pcaxis/tiedostomuoto2006_laaja_en.pdf">https://tilastokeskus.fi/tup/pcaxis/tiedostomuoto2006_laaja_en.pdf</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
    ## significant time reductions may be achieve by doing:
    library("compiler")
    enableJIT(level=3)
  
## End(Not run)

  name     &lt;- system.file("extdata","datInSFexample6_1.px", package = "qmrparser")
  stream   &lt;- streamParserFromFileName(name,encoding="UTF-8")
  cstream  &lt;-  pcAxisParser(stream)
  if ( cstream$status == 'ok' ) {
    
    ## HEADING 
    print(Filter(function(e) e$keyword=="HEADING",cstream$node)[[1]] $ruleRight$value)  
  
    ## STUB
    print(Filter(function(e) e$keyword=="STUB",cstream$node)[[1]] $ruleRight$value)  
  
    ## DATA
    print(Filter(function(e) e$keyword=="DATA",cstream$node)[[1]] $ruleRight$value)
    
  }

  ## Not run: 
      #
      # Error messages like
      #                " ... invalid multibyte string ... "
      # or warnings
      #                " input string ...  is invalid in this locale"
      #
      # For example, in Linux the error generated by this code:
       name     &lt;-     "https://www.ine.es/pcaxisdl//t20/e245/p04/a2009/l0/00000008.px" 
      stream   &lt;- streamParserFromString( readLines( name ) )    
      cstream  &lt;- pcAxisParser(stream)
      if ( cstream$status == 'ok' )  cube &lt;- pcAxisCubeMake(cstream)
      #
      # is caused by files with a non-readable 'encoding'.
      # In the case where it could be read, there may also be problems 
      # with string-handling functions, due to multibyte characters. 
      # In Windows, according to \code{link{Sys.getlocale}()},
      # file may be read but accents, ñ, ... may not be correctly recognised.
      #
      #
      # There are, at least, the following options:
      #  - File conversion to utf-8, from the OS, with
      # "iconv - Convert encoding of given files from one encoding to another"
      #
      #  - File conversion in R:
      name    &lt;- "https://www.ine.es/pcaxisdl//t20/e245/p04/a2009/l0/00000008.px" 
      stream   &lt;- streamParserFromString( iconv( readLines( name ), "IBM850", "UTF-8") )
      cstream  &lt;- pcAxisParser(stream)
      if ( cstream$status == 'ok' )  cube &lt;- pcAxisCubeMake(cstream)
      #
      # In the latter case, latin1 would also work, but accents, ñ, ... would not be
      # correctly read.
      #
      #  - Making the assumption that the file does not contain multibyte characters:
      #
      localeOld &lt;- Sys.getlocale("LC_CTYPE")
      Sys.setlocale(category = "LC_CTYPE", locale = "C")
      #
      name     &lt;-
        "https://www.ine.es/pcaxisdl//t20/e245/p04/a2009/l0/00000008.px" 
      stream   &lt;- streamParserFromString( readLines( name ) )
      cstream  &lt;- pcAxisParser(stream)
      if ( cstream$status == 'ok' )  cube &lt;- pcAxisCubeMake(cstream)
      #
      Sys.setlocale(category = "LC_CTYPE", locale = localeOld)
      #
      # However, some characters will not be correctly read (accents, ñ, ...)

    
## End(Not run)

</code></pre>

<hr>
<h2 id='repetition0N'>
Repeats one parser  
</h2><span id='topic+repetition0N'></span>

<h3>Description</h3>

<p>Repeats a parser indefinitely, while it succeeds. It will return an empty token if the parser never succeeds, 
</p>
<p>Number of repetitions may be zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  repetition0N(rpa0, 
               action = function(s)            list(type="repetition0N",value=s   ), 
               error  = function(p,h) list(type="repetition0N",pos=p,h=h)) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repetition0N_+3A_rpa0">rpa0</code></td>
<td>
<p>parse to be applied iteratively</p>
</td></tr>   
<tr><td><code id="repetition0N_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. It takes as input parameters information derived from parsers involved as parameters</p>
</td></tr>
<tr><td><code id="repetition0N_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. I takes two parameters:
</p>

<ul>
<li>  <p><code>p</code> 
</p>
<p>with position where parser, <code><a href="#topic+streamParser">streamParser</a></code>,  starts its recognition, obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code>
</p>
</li>
<li> <p><code>h</code>
</p>
<p>with information obtained from parsers involved as parameters, normally related with failure(s) position in component parsers.
</p>
<p>Its information depends on how parser involved as parameters are combined and on the <code>error</code> definition in these parsers.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>In case of at least one success, <code>action</code> gets the <code>node</code> returned by the parser <code><a href="#topic+repetition1N">repetition1N</a></code> after applying the parser to be repeated. Otherwise, it gets the <code>node</code> corresponding to token <code><a href="#topic+empty">empty</a></code>: <code>list(type="empty" ,value="")</code>
</p>
<p>Function<code>error</code> is never called. It is defined as parameter for the sake of homogeneity with the rest of functions.
</p>


<h3>Value</h3>

<p>Anonymous functions, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From these input parameters, an anonymous function is constructed. This function admits just one parameter, stream, with <code><a href="#topic+streamParser">streamParser</a></code> class, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# ok
stream  &lt;- streamParserFromString("Hello world")
( repetition0N(symbolic())(stream) )[c("status","node")]


# ok
stream  &lt;- streamParserFromString("123 Hello world")
( repetition0N(symbolic())(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='repetition1N'>
Repeats a parser, at least once.
</h2><span id='topic+repetition1N'></span>

<h3>Description</h3>

<p>Repeats a parser application indefinitely while it is successful. It must succeed at least once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  repetition1N(rpa, 
               action = function(s)   list(type="repetition1N",value=s  ),
               error  = function(p,h) list(type="repetition1N",pos=p,h=h))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repetition1N_+3A_rpa">rpa</code></td>
<td>
<p> parse to be applied iteratively </p>
</td></tr>
<tr><td><code id="repetition1N_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. It takes as input parameters information derived from parsers involved as parameters</p>
</td></tr>
<tr><td><code id="repetition1N_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. I takes two parameters:
</p>

<ul>
<li>  <p><code>p</code> 
</p>
<p>with position where parser, <code><a href="#topic+streamParser">streamParser</a></code>,  starts its recognition, obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code>
</p>
</li>
<li> <p><code>h</code>
</p>
<p>with information obtained from parsers involved as parameters, normally related with failure(s) position in component parsers.
</p>
<p>Its information depends on how parser involved as parameters are combined and on the <code>error</code> definition in these parsers.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>In case of success, <code>action</code> gets a list with information about the <code>node</code> returned by the applied parser. List length equals the number of successful repetitions.
</p>
<p>In case of failure, parameter <code>h</code> from <code>error</code> gets error information returned by the first attempt of parser application.
</p>


<h3>Value</h3>

<p>Anonymous functions, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From these input parameters, an anonymous function is constructed. This function admits just one parameter, stream, with <code><a href="#topic+streamParser">streamParser</a></code> class, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# ok
stream  &lt;- streamParserFromString("Hello world")
( repetition1N(symbolic())(stream) )[c("status","node")]


# fail
stream  &lt;- streamParserFromString("123 Hello world")
( repetition1N(symbolic())(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='separator'>
Generic word separator token.
</h2><span id='topic+separator'></span>

<h3>Description</h3>

<p>Recognises a white character sequence, with comma or semicolon optionally inserted in the sequence.
Empty sequences are not allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separator(action = function(s) list(type="separator",value=s) , 
          error  = function(p) list(type="separator",pos  =p) ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separator_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="separator_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>A character is considered a white character when function <code><a href="#topic+isWhitespace">isWhitespace</a></code> returns TRUE
</p>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Note</h3>

<p> PC-Axis has accepted the delimiters comma, space, semicolon, tabulator.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ok
stream  &lt;- streamParserFromString("; Hello world")
( separator()(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString(" ")
( separator()(stream) )[c("status","node")]


# fail
stream  &lt;- streamParserFromString("Hello world")
( separator()(stream) )[c("status","node")]

# fail 
stream  &lt;- streamParserFromString("")
( separator()(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='streamParser'>
Generic interface for character processing, allowing forward and backwards translation.
</h2><span id='topic+streamParserNextChar'></span><span id='topic+streamParserNextChar'></span><span id='topic+streamParserNextCharSeq'></span><span id='topic+streamParserPosition'></span><span id='topic+streamParserClose'></span>

<h3>Description</h3>

<p>Generic interface for character processing. It allows going forward sequentially or backwards to a previous arbitrary position.
</p>
<p>Each one of these functions performs an operation on or obtains information from a character sequence (stream).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streamParserNextChar(stream)
streamParserNextCharSeq(stream)
streamParserPosition(stream)
streamParserClose(stream)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="streamParser_+3A_stream">stream</code></td>
<td>
<p>object containing information about the text to be processed and, specifically, about the next character to be read</p>
</td></tr>
</table>


<h3>Details</h3>

  
<ul>
<li><p>streamParserNextChar
</p>
<p>Reads next character, checking if position to be read is correct.
 
</p>
</li>
<li><p>streamParserNextCharSeq
</p>
<p>Reads next character, without checking if position to be read is correct. Implemented since it is faster than streamParserNextChar
</p>
</li>
<li><p>streamParserPosition
</p>
<p>Returns information about text position being read.
</p>
</li>
<li><p>streamParserClose
</p>
<p>Closes the stream  
</p>
</li></ul>



<h3>Value</h3>

<table>
<tr><td><code>streamParserNextChar and streamParserNextCharSeq</code></td>
<td>

<p>Three field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;eof&quot;
</p>
</li>
<li><p>char
</p>
<p>Character read (ok) or &quot;&quot; (eof)
</p>
</li>
<li><p>stream      
</p>
<p>With information about next character to be read or same position if end of file has been reached (&quot;eof&quot;)
</p>
</li></ul>

</td></tr>
<tr><td><code>streamParserPosition</code></td>
<td>

<p>Three field list:
</p>

<ul>
<li><p>fileName   
File name or &quot;&quot; if the stream is not associated with a file name
</p>
</li>
<li><p>line      
</p>
<p>line number
</p>
</li>
<li><p>linePos   
</p>
<p>character to be read position within its line
</p>
</li>
<li><p>streamPos
</p>
<p>character to be read position from the text beginning
</p>
</li></ul>

</td></tr>
<tr><td><code>streamParserClose</code></td>
<td>
<p>NULL</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+streamParserFromFileName">streamParserFromFileName</a></code>
<code><a href="#topic+streamParserFromString">streamParserFromString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
stream&lt;- streamParserFromString("Hello world")

cstream &lt;- streamParserNextChar(stream)

while( cstream$status == "ok" ) {
    print(streamParserPosition(cstream$stream))
    print(cstream$char)
    cstream &lt;- streamParserNextCharSeq(cstream$stream)
}

streamParserClose(stream)

</code></pre>

<hr>
<h2 id='streamParserFromFileName'>
Creates a streamParser from a file name
</h2><span id='topic+streamParserFromFileName'></span>

<h3>Description</h3>

<p>Creates a list of functions which allow streamParser manipulation (when defined from a file name)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streamParserFromFileName(fileName,encoding = getOption("encoding")) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="streamParserFromFileName_+3A_filename">fileName</code></td>
<td>
<p>file name</p>
</td></tr>
<tr><td><code id="streamParserFromFileName_+3A_encoding">encoding</code></td>
<td>
<p>file encoding</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+streamParser">streamParser</a>
</p>
<p>This function implementation uses function <a href="base.html#topic+seek">seek</a>.
</p>
<p>Documentation about this function states: 
</p>
<p>&quot;
Use of 'seek' on Windows is discouraged.  We have found so many
errors in the Windows implementation of file positioning that
users are advised to use it only at their own risk, and asked not
to waste the R developers' time with bug reports on Windows'
deficiencies.
&quot;
</p>
<p>If &quot;fileName&quot; is a url, <a href="base.html#topic+seek">seek</a> is not possible.
</p>
<p>In order to cover these situations, streamPaserFromFileName functions are converted in:
</p>
<p><code>
        <a href="#topic+streamParserFromString">streamParserFromString</a>(<a href="base.html#topic+readLines">readLines</a>( fileName, encoding=encoding))      
      </code>
</p>
<p>Alternatively, it can be used:
</p>
<p><code><a href="#topic+streamParserFromString">streamParserFromString</a></code> with:
<code>
        <a href="#topic+streamParserFromString">streamParserFromString</a>(<a href="base.html#topic+readLines">readLines</a>(fileName))
      </code>
</p>
<p>or
</p>
<p><code>
       <a href="#topic+streamParserFromString">streamParserFromString</a>(
                              <a href="base.html#topic+iconv">iconv</a>(<a href="base.html#topic+readLines">readLines</a>(fileName), encodingOrigen,encodingDestino)                          
                          )
     </code>
</p>
<p>Since streamParserFromFileName also uses <code><a href="base.html#topic+readChar">readChar</a></code>, this last option is the one advised in Linux if encoding is different from Latin-1 or UTF-8. As documentation states, <code><a href="base.html#topic+readChar">readChar</a></code> may generate problems if file is in a multi-byte non UTF-8 encoding:
</p>
<p>&quot;
'nchars' will be interpreted in bytes not characters in a
non-UTF-8 multi-byte locale, with a warning.
&quot;     
</p>


<h3>Value</h3>

<p>A list of four functions which allow stream manipulation:
</p>
<table>
<tr><td><code>streamParserNextChar</code></td>
<td>
<p>Function which takes a streamParser as argument and returns a <code>list(status,char,stream)</code></p>
</td></tr>
<tr><td><code>streamParserNextCharSeq</code></td>
<td>
<p>Function which takes a streamParser as argument and returns <code>list(status,char,stream)</code></p>
</td></tr>
<tr><td><code>streamParserPosition</code></td>
<td>
<p>Function which takes a streamParser as argument and returns position of next character to be read</p>
</td></tr>
<tr><td><code>streamParserClose</code></td>
<td>
<p>Closes the stream</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  name    &lt;- system.file("extdata","datInTest01.txt", package = "qmrparser")
  
  stream  &lt;- streamParserFromFileName(name)
  
  cstream &lt;- streamParserNextChar(stream)
  
  while( cstream$status == "ok" ) {
    print(streamParserPosition(cstream$stream))
    print(cstream$char)
    cstream &lt;- streamParserNextCharSeq(cstream$stream)
  }
  
  streamParserClose(stream)
  
</code></pre>

<hr>
<h2 id='streamParserFromString'>
Creates a streamParser from a string
</h2><span id='topic+streamParserFromString'></span>

<h3>Description</h3>

<p>Creates a list of functions which allow streamParser manipulation (when defined from a character string)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streamParserFromString(string) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="streamParserFromString_+3A_string">string</code></td>
<td>
<p>string to be recognised</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+streamParser">streamParser</a>
</p>


<h3>Value</h3>

<p>A list of four functions which allow stream manipulation:
</p>
<table>
<tr><td><code>streamParserNextChar</code></td>
<td>
<p>Functions which takes a streamParser as argument ant returns a <code>list(status,char,stream)</code></p>
</td></tr>
<tr><td><code>streamParserNextCharSeq</code></td>
<td>
<p>Function which takes a streamParser as argument and returns a <code>list(status,char,stream)</code></p>
</td></tr>
<tr><td><code>streamParserPosition</code></td>
<td>
<p>Function which takes a streamParser as argument and returns position of next character to be read</p>
</td></tr>
<tr><td><code>streamParserClose</code></td>
<td>
<p>Function which closes the stream</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># reads one character
streamParserNextChar(streamParserFromString("\U00B6"))

# reads a string
stream  &lt;- streamParserFromString("Hello world")

cstream &lt;- streamParserNextChar(stream)

while( cstream$status == "ok" ) {
    print(streamParserPosition(cstream$stream))
    print(cstream$char)
    cstream &lt;- streamParserNextCharSeq(cstream$stream)

streamParserClose(stream)
}

</code></pre>

<hr>
<h2 id='string'>
Token string
</h2><span id='topic+string'></span>

<h3>Description</h3>

<p>Any character sequence, by default using simple or double quotation marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string(isQuote= function(c) switch(c,'"'=,"'"=TRUE,FALSE),
       action = function(s) list(type="string",value=s), 
       error  = function(p) list(type="string",pos  =p)) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_+3A_isquote">isQuote</code></td>
<td>
<p>Predicate indicating whether a character begins and ends a string</p>
</td></tr>
<tr><td><code id="string_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="string_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Characters preceded by \ are not considered as part of string end.
</p>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# fail
stream  &lt;- streamParserFromString("Hello world")
( string()(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("'Hello world'")
( string()(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='symbolic'>
Alphanumeric token.
</h2><span id='topic+symbolic'></span>

<h3>Description</h3>

<p>Recognises an alphanumeric symbol. By default, a sequence of alphanumeric, numeric and dash symbols, beginning with an alphabetical character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbolic     (charFirst=isLetter,
              charRest=function(ch) isLetter(ch) || isDigit(ch) || ch == "-",
              action = function(s) list(type="symbolic",value=s), 
              error  = function(p) list(type="symbolic",pos  =p)) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbolic_+3A_charfirst">charFirst</code></td>
<td>
<p>Predicate of valid characters as first symbol character</p>
</td></tr>
<tr><td><code id="symbolic_+3A_charrest">charRest</code></td>
<td>
<p>Predicate of valid characters as the rest of symbol characters</p>
</td></tr>
<tr><td><code id="symbolic_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="symbolic_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# fail
stream  &lt;- streamParserFromString("123")
( symbolic()(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("abc123_2")
( symbolic()(stream) )[c("status","node")]

</code></pre>

<hr>
<h2 id='whitespace'>
White sequence token.
</h2><span id='topic+whitespace'></span>

<h3>Description</h3>

<p>Recognises a white character sequence (this sequence may be empty).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  whitespace(action = function(s) list(type="white",value=s), 
             error  = function(p) list(type="white",pos  =p) ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whitespace_+3A_action">action</code></td>
<td>
<p>Function to be executed if recognition succeeds. Character stream making up the token is passed as parameter to this function</p>
</td></tr>
<tr><td><code id="whitespace_+3A_error">error</code></td>
<td>
<p>Function to be executed if recognition does not succeed. Position of <code><a href="#topic+streamParser">streamParser</a></code> obtained with <code><a href="#topic+streamParserPosition">streamParserPosition</a></code> is passed as parameter to this function</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>A character is considered a white character when function <code><a href="#topic+isWhitespace">isWhitespace</a></code> returns TRUE
</p>


<h3>Value</h3>

<p>Anonymous function, returning a list.
</p>
<p><code>function(stream)</code> &ndash;&gt;  <code> list(status,node,stream) </code>
</p>
<p>From input parameters, an anonymous function is defined. This function admits just one parameter, stream, with type <code><a href="#topic+streamParser">streamParser</a></code>, and returns a three-field list:
</p>

<ul>
<li><p>status      
</p>
<p>&quot;ok&quot; or &quot;fail&quot; 
</p>
</li>
<li><p>node         
</p>
<p>With <code>action</code> or <code>error</code> function output, depending on the case
</p>
</li>
<li><p>stream      
</p>
<p>With information about the input, after success or failure in recognition
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# ok
stream  &lt;- streamParserFromString("Hello world")
( whitespace()(stream) )[c("status","node")]

# ok
stream  &lt;- streamParserFromString(" Hello world")
( whitespace()(stream) )[c("status","node")]

# ok 
stream  &lt;- streamParserFromString("")
(  whitespace()(stream) )[c("status","node")]

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
