<!DOCTYPE html><html><head><title>Help for package mateable</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mateable}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compatibility'><p>Make potentials object&ndash;mating type compatibility</p></a></li>
<li><a href='#dailyOMP'><p>Calculate daily outcrossed mating potential</p></a></li>
<li><a href='#ech2012'><p>Information about mating scene at sites eelr and nwlf in 2012.</p></a></li>
<li><a href='#kNearNeighbors'><p>Get k Nearest Neighbors</p></a></li>
<li><a href='#makeScene'><p>Create a matingScene object from a data frame</p></a></li>
<li><a href='#mateable-package'><p>Tools to simulate, manage, visualize, and jointly analyze spatially and</p>
temporally explicit datasets of mating potential</a></li>
<li><a href='#matingSummary'><p>Summarize a Mating Scene</p></a></li>
<li><a href='#overlap'><p>Pairwise Mating Timing Comparison</p></a></li>
<li><a href='#pairDist'><p>Distance Matrix for a mating scene</p></a></li>
<li><a href='#plot3DPotential'><p>graphical visualization of multiple mating potential objects</p></a></li>
<li><a href='#plot3DScene'><p>multi-dimensional visualization of mating scene object</p></a></li>
<li><a href='#plotPotential'><p>graphical visualization of a mating potential object</p></a></li>
<li><a href='#plotScene'><p>graphical visualization of a mating scene object</p></a></li>
<li><a href='#proximity'><p>Make potentials object&ndash;spatial proximity</p></a></li>
<li><a href='#receptivityByDay'><p>Mating Receptivity by Day</p></a></li>
<li><a href='#simulateScene'><p>Simulate a Mating Scene</p></a></li>
<li><a href='#synchrony'><p>Make potentials object&ndash;mating synchrony</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Assess Mating Potential in Space and Time</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-04</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stuart Wagenius &lt;stuart.wagenius@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stuartWagenius/mateable">https://github.com/stuartWagenius/mateable</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stuartWagenius/mateable/issues">https://github.com/stuartWagenius/mateable/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Simulate, manage, visualize, and analyze spatially and temporally 
    explicit datasets of mating potential. Implements methods to calculate 
    synchrony, proximity, and compatibility.Synchrony calculations are based on 
    methods described in Augspurger (1983) &lt;<a href="https://doi.org/10.2307%2F2387650">doi:10.2307/2387650</a>&gt;, 
    Kempenaers (1993) &lt;<a href="https://doi.org/10.2307%2F3676415">doi:10.2307/3676415</a>&gt;, Ison et al. (2014) 
    &lt;<a href="https://doi.org/10.3732%2Fajb.1300065">doi:10.3732/ajb.1300065</a>&gt;, and variations on these, as described.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>FNN, graphics, grDevices, Rcpp, sn, stats</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-04 00:04:41 UTC; SWagenius</td>
</tr>
<tr>
<td>Author:</td>
<td>Stuart Wagenius [cre, aut],
  Danny Hanson [aut],
  Amy Waananen [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-04 07:42:31 UTC</td>
</tr>
</table>
<hr>
<h2 id='compatibility'>Make potentials object&ndash;mating type compatibility</h2><span id='topic+compatibility'></span>

<h3>Description</h3>

<p>Calculate one of several measures of mating compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compatibility(scene, method, subject = "all", averageType = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compatibility_+3A_scene">scene</code></td>
<td>
<p>a matingScene object</p>
</td></tr>
<tr><td><code id="compatibility_+3A_method">method</code></td>
<td>
<p>either &quot;si_echinacea&quot; or &quot;dioecious&quot; see details for
further description</p>
</td></tr>
<tr><td><code id="compatibility_+3A_subject">subject</code></td>
<td>
<p>whether you want pair, individual, population, or all.
Specifying more than one is allowed.</p>
</td></tr>
<tr><td><code id="compatibility_+3A_averagetype">averageType</code></td>
<td>
<p>whether to calculate individual and population proximity
using the mean or median</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>method</code> is &quot;si_echinacea&quot; compatibility will be
calculated as sporophytic self incompatible (si) in the same manner as Echinacea
(and many other plants). For two individuals, they are incompatible if
they share any S alleles (columns s1 and s2) and they compatible otherwise.
When <code>method</code> is &quot;dioecious&quot; it is assumed that the column s1 will
contain either a 1 or 2 depending on the individual's sex. Thus, when
comparing two individuals, they are compatible if s1 of the first != s1
of the second, and s2 is ignored.
</p>


<h3>Value</h3>

<p>A potentials object containing one more more of the following, depending the
input for <code>subject</code>: <br />
If <code>subject</code> is &quot;population&quot; the return list will contain a numeric
value that has a range depending on the <code>method</code>. If
<code>subject</code> is &quot;pair&quot; the return list will contain a matrix
with all pairwise compatibilities. If <code>subject</code> is &quot;individual&quot;
the return list will contain a dataframe with a column containing IDs and
a column containing compatibility averages. If <code>subject</code> is &quot;all&quot;
the return list will contain all three of the items above.
</p>


<h3>Author(s)</h3>

<p>Danny Hanson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulateScene()
compatibility(pop, "si_echinacea")
</code></pre>

<hr>
<h2 id='dailyOMP'>Calculate daily outcrossed mating potential</h2><span id='topic+dailyOMP'></span>

<h3>Description</h3>

<p>dailyOMP generates an OMP object giving the daily outcrossed mating potential of individuals based on k nearest neighbors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dailyOMP(
  scene,
  k = 3,
  days = NULL,
  gamma = 1/13.3,
  nn.constant = FALSE,
  sum = FALSE,
  mean = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dailyOMP_+3A_scene">scene</code></td>
<td>
<p>a matingScene object</p>
</td></tr>
<tr><td><code id="dailyOMP_+3A_k">k</code></td>
<td>
<p>integer, number of nearest neighbors to use in calculating OMP</p>
</td></tr>
<tr><td><code id="dailyOMP_+3A_days">days</code></td>
<td>
<p>the day or range of days to calculate OMP for, default is all days in a scene (see Details)</p>
</td></tr>
<tr><td><code id="dailyOMP_+3A_gamma">gamma</code></td>
<td>
<p>parameter of exponential decay to be used in calculating OMP (defaults to 1/13)</p>
</td></tr>
<tr><td><code id="dailyOMP_+3A_nn.constant">nn.constant</code></td>
<td>
<p>logical; indicates whether the nearest neighbors used in calculations should be the nearest on a given day (<code>nn.constant = FALSE</code>) or the nearest neighbors over an entire season (<code>nn.constant = TRUE</code>)</p>
</td></tr>
<tr><td><code id="dailyOMP_+3A_sum">sum</code></td>
<td>
<p>logical; indicates if the return should be a sum of an individual's daily outcrossed mating potential over the range specified by days</p>
</td></tr>
<tr><td><code id="dailyOMP_+3A_mean">mean</code></td>
<td>
<p>logical; indicates if the return should be the mean of an individual's daily outcrossed mating potential over the range of days that the individual was receptive to mating</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Daily outcrossed mating potential is a weighted average of an individual's distance to their nearest neighbors on a given day (Wagenius et al. 2007). The days to calculate OMP for should be input as integers relative to the first day of flowering, as they are in the start and end columns of a matingScene object. If the number of ids receptive on a day is less than k, OMP will be calculated for the maximum number of neighbors.
</p>


<h3>Value</h3>

<p>a named matrix with a row for each id and a column for each day, and entries corresponding to ids' OMP each day
</p>


<h3>Author(s)</h3>

<p>Amy Waananen
</p>


<h3>References</h3>

<p>Wagenius, S., E. Lonsdorf, and C. Neuhauser. 2007. Patch aging and the S-Allee effect: breeding system effects on the demographic response of plants to habitat fragmentation. <em>American Naturalist</em> <strong>169</strong>:383-397.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeScene">makeScene</a></code>, <code><a href="#topic+proximity">proximity</a></code>, <code><a href="#topic+synchrony">synchrony</a></code>, <code><a href="#topic+receptivityByDay">receptivityByDay</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulateScene()
omp &lt;- dailyOMP(pop)
omp.1 &lt;- dailyOMP(pop, nn.constant = TRUE) # same nearest neighbors throughout the season
omp.2 &lt;- dailyOMP(pop, nn.constant = FALSE) # nearest flowering neighbors
</code></pre>

<hr>
<h2 id='ech2012'>Information about mating scene at sites eelr and nwlf in 2012.</h2><span id='topic+ech2012'></span>

<h3>Description</h3>

<p>This dataframe contains information about all 53 plants that flowered in 2012
at the sites  eelr (East Elk Lake Road) and Northwest of Landfill (nwlf). Kelly
Kapsar visited plants regularly to determine the starting and ending dates of
flowering on every head of every plant. The metadata for the phenology dataset
can be provide upon request to the maintainer. Plants were mapped with gps with
better than 6 cm precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ech2012
</code></pre>


<h3>Format</h3>

<p>A 53 x 6 data frame
</p>


<h3>Variables</h3>

<p>Variables:
</p>

<ul>
<li><p> tag, unique identifier for each plant
</p>
</li>
<li><p> pop, population corresponding to site
</p>
</li>
<li><p> firstDay, the first day that any head on the plant shed pollen
</p>
</li>
<li><p> lastDay, the last day that any head on the plant shed pollen
</p>
</li>
<li><p> Ecoord, the x-coordinate of each plant in meters
</p>
</li>
<li><p> Ncoord, the y-coordinate of each plant in meters
</p>
</li></ul>



<h3>References</h3>

<p>Wagenius, S. 2006. Scale-dependence of reproductive failure in
fragmented <em>Echinacea</em> populations. Ecology 87: 931-941.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dim(ech2012)
str(ech2012)
</code></pre>

<hr>
<h2 id='kNearNeighbors'>Get k Nearest Neighbors</h2><span id='topic+kNearNeighbors'></span>

<h3>Description</h3>

<p>Find the k nearest neighbors for all individuals in a population. This
function is simply a wrapper for <code>FNN::knn.dist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kNearNeighbors(scene, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kNearNeighbors_+3A_scene">scene</code></td>
<td>
<p>a matingScene object</p>
</td></tr>
<tr><td><code id="kNearNeighbors_+3A_k">k</code></td>
<td>
<p>integer of how many nearest neighbors to get</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix where the rows are all individuals and the columns are
their k nearest neighbors
</p>


<h3>See Also</h3>

<p><code><a href="FNN.html#topic+knn.dist">knn.dist</a></code>, <code><a href="#topic+proximity">proximity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulateScene(10)
kNearNeighbors(pop, 3)
</code></pre>

<hr>
<h2 id='makeScene'>Create a matingScene object from a data frame</h2><span id='topic+makeScene'></span>

<h3>Description</h3>

<p>Turns a data frame with information about temporal, spatial, or
genetic mating data into a matingScene object using a standard format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeScene(
  df,
  multiYear = FALSE,
  startCol = "start",
  endCol = "end",
  xCol = "x",
  yCol = "y",
  s1Col = "s1",
  s2Col = "s2",
  idCol = "id",
  otherCols = NULL,
  dateFormat = "%Y-%m-%d",
  split = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeScene_+3A_df">df</code></td>
<td>
<p>a data frame containing information about a mating scene,
namely coordinate of individuals in space, time, and mating type.</p>
</td></tr>
<tr><td><code id="makeScene_+3A_multiyear">multiYear</code></td>
<td>
<p>logical indicating whether or not to split the result into
a list by year</p>
</td></tr>
<tr><td><code id="makeScene_+3A_startcol">startCol</code></td>
<td>
<p>character name of column with start dates</p>
</td></tr>
<tr><td><code id="makeScene_+3A_endcol">endCol</code></td>
<td>
<p>character name of column with end dates</p>
</td></tr>
<tr><td><code id="makeScene_+3A_xcol">xCol</code></td>
<td>
<p>character name of column with x or E coordinates</p>
</td></tr>
<tr><td><code id="makeScene_+3A_ycol">yCol</code></td>
<td>
<p>character name of column with y or N coordinates</p>
</td></tr>
<tr><td><code id="makeScene_+3A_s1col">s1Col</code></td>
<td>
<p>character name of one column with S-allele</p>
</td></tr>
<tr><td><code id="makeScene_+3A_s2col">s2Col</code></td>
<td>
<p>character name of another column with S-alleles</p>
</td></tr>
<tr><td><code id="makeScene_+3A_idcol">idCol</code></td>
<td>
<p>character name for column with unique identifier</p>
</td></tr>
<tr><td><code id="makeScene_+3A_othercols">otherCols</code></td>
<td>
<p>character vector of column(s) to include besides the
necessary ones for the mating scene. If NULL, it will be ignored.</p>
</td></tr>
<tr><td><code id="makeScene_+3A_dateformat">dateFormat</code></td>
<td>
<p>character indicating either (1) the format of the start and end
date columns if those columns are characters or (2) the origin for the start
and end date columns if those columns are numeric. It is used in as.Date</p>
</td></tr>
<tr><td><code id="makeScene_+3A_split">split</code></td>
<td>
<p>character name for a column with values by which the result should be split</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input dataframe can contain information about locations of
individuals in 1, 2, or 3 dimensions of a mating scenes.
The function currently allows two spatial coordinates. The user specifies
the names of the columns and they will be saved xCol and yCol in the
matingScene object. MatingScene objects currently save temporal
coordinates for individuals as start and end date of mating activity
within a year. Mating type coordinates are saved as mating type alleles.
Columns are named id, start, end, x, y, s1, and s2 for
idCol, startCol, endCol, xCol, yCol, s1Col, and s2Col respectively.
The attributes &quot;t&quot;, &quot;s&quot;, and &quot;mt&quot; will be set to TRUE if the data frame
has temporal, spatial, or mating type data, respectively and
will be FALSE otherwise. The attribute originalNames contains all the
names of the columns in the original data frame.<br />
The start and end columns will be changed to integers relative to the start
day of the population. So the first day of the first individual to become
receptive will be 1 and so on. The attribute origin contains the
origin that can be used when converting the columns start and end
from integers to dates.<br />
If no temporal data are available except the year in which it was
collected and df is a multi-year data set, put the collection year into the
column labeled as startCol and set dateFormat = &quot;
the data appropriately.
</p>


<h3>Value</h3>

<p>a matingScene object, either a single dataframe in standard format
or a list of dataframes. Attributes of the matingScene object indicate the type of
information in the data frame, including the original column names,
and the origin of the date columns. If multiYear = TRUE,
the return value will be a list of matingScene data frames where each
element in the list represents one year. If split is specified, the return value will be a list of matingScene data frames where each element in the list represents a value of the specified variable. See details for more information
on attributes and how to work with multi-year data.
</p>


<h3>Author(s)</h3>

<p>Danny Hanson
</p>

<hr>
<h2 id='mateable-package'>Tools to simulate, manage, visualize, and jointly analyze spatially and
temporally explicit datasets of mating potential</h2><span id='topic+mateable-package'></span><span id='topic+mateable'></span>

<h3>Description</h3>

<p>This package facilitates the investigation of three dimensions of mating
potential. It provides a method for simulating populations and includes a
dataset.
</p>


<h3>Author(s)</h3>

<p>Stuart Wagenius, Danny Hanson, Amy Waananen
</p>


<h3>References</h3>

<p>Background: <a href="https://echinaceaProject.org/">https://echinaceaProject.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mateable)

pop &lt;- simulateScene()
pop

plotScene(pop)
plotScene(pop, "t")

plot3DScene(pop)

sync &lt;- synchrony(pop, "augs")
prox &lt;- proximity(pop, "maxPropSqrd")
plotPotential(sync)
plotPotential(prox, "ind")


str(ech2012)
ee &lt;- makeScene(ech2012, FALSE, "firstDay", "lastDay", "Ecoord", "Ncoord", idCol = "tagNo")

</code></pre>

<hr>
<h2 id='matingSummary'>Summarize a Mating Scene</h2><span id='topic+matingSummary'></span>

<h3>Description</h3>

<p>Create a summary of information contained within a matingScene object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matingSummary(
  scene,
  type = "auto",
  k = 1,
  compatMethod = "si_echinacea",
  as.data.frame = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matingSummary_+3A_scene">scene</code></td>
<td>
<p>a matingScene object</p>
</td></tr>
<tr><td><code id="matingSummary_+3A_type">type</code></td>
<td>
<p>character. whether to do a temporal (t), spatial (s), or mating
type (mt) summary. The default is &quot;auto&quot; which will automatically summarize
all mating information in scene</p>
</td></tr>
<tr><td><code id="matingSummary_+3A_k">k</code></td>
<td>
<p>integer. Which nearest neighbor to calculate (only for type == &quot;s&quot;)</p>
</td></tr>
<tr><td><code id="matingSummary_+3A_compatmethod">compatMethod</code></td>
<td>
<p>character indicating the method to use when calculating
compatiblity. Defaults to &quot;si_echinacea&quot;</p>
</td></tr>
<tr><td><code id="matingSummary_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>logical. If TRUE, returns summary as a dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list, list of lists, or dataframe containing summary information
including:<br />
temporal - year (year), population start date (popSt), mean individual start date
(meanSD), standard deviation of start (sdSD), mean duration (meanDur),
standard deviation of duration (sdDur), peakDay - day(s) on which highest
number of individuals were receptive (peak), mean end date (meanED),
standard deviation of end date (sdED), population end date (popEnd)<br />
spatial - minimum x (minX), minimum y (minY), maximum x (maxX),
maximum y (maxY), average distance to kth nearest neighbor as specified
by k (k&lt;n&gt; where n is the input for k)<br />
compatibility - number of mating types (nMatType), average number of
compatible mates (meanComp)<br />
If scene is a multi-year matingScene, then the output will be a list
of lists, one list for each year.
If <code>as.data.frame = TRUE</code>, the output will be a dataframe with columns containing summary information and, if applicable, an 'id' column identifying what portion of the matingSummary object it summarized. If the scene is a multi-year matingScene, then the output will be a list of dataframes, one list for each year.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eelr &lt;- makeScene(ech2012, startCol = "firstDay", endCol = "lastDay",
  xCol = "Ecoord", yCol = "Ncoord", idCol = "tagNo")
eelrSum &lt;- matingSummary(eelr)
eelrSum[c("minX", "minY", "maxX", "maxY")]
</code></pre>

<hr>
<h2 id='overlap'>Pairwise Mating Timing Comparison</h2><span id='topic+overlap'></span>

<h3>Description</h3>

<p>Get comparisons of mating timing between all pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap(scene, overlapOrTotal = c("overlap", "total"), compareToSelf = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_+3A_scene">scene</code></td>
<td>
<p>a matingScene object</p>
</td></tr>
<tr><td><code id="overlap_+3A_overlaportotal">overlapOrTotal</code></td>
<td>
<p>whether to calculate the number of days that each
pair was overlapping in mating receptivity or the total number of days
that either individual was receptive</p>
</td></tr>
<tr><td><code id="overlap_+3A_comparetoself">compareToSelf</code></td>
<td>
<p>whether or not to include self comparisons in the
return value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing all pairwise comparisons. If compareToSelf
is FALSE then there will be n rows and n-1 columns. <br />
To index result[i,j] where j &gt; i, use <code>result[i,j-1]</code>, where <code>result</code>
is the return value of overlap. There is one attribute &quot;idOrder&quot;
which holds the order of the id column in scene at the time of the function call.
This can be useful to find certain elements in the matrix (see examples). <br />
If scene is a multi-year matingScene, then overlap will return a list of matrices
(as described above) where each matrix represents one year.
</p>


<h3>Author(s)</h3>

<p>Danny Hanson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulateScene()
pop &lt;- pop[order(pop$start),]
daysSync &lt;- overlap(pop)
indices &lt;- which(attr(daysSync, "idOrder") %in% c(1, 4))
if (indices[1] &lt;= indices[2]) {
  daysSync[indices[1], indices[2]]
} else {
  daysSync[indices[1], indices[2]-1]
}
</code></pre>

<hr>
<h2 id='pairDist'>Distance Matrix for a mating scene</h2><span id='topic+pairDist'></span>

<h3>Description</h3>

<p>Compute all pairwise distances for a population. This function
is simply a wrapper for <code>dist</code> that returns only a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairDist(scene)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairDist_+3A_scene">scene</code></td>
<td>
<p>a matingScene object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of all pairwise comparisons with attributes for order of
identifiers (idOrder)
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulateScene()
distance &lt;- pairDist(pop)
</code></pre>

<hr>
<h2 id='plot3DPotential'>graphical visualization of multiple mating potential objects</h2><span id='topic+plot3DPotential'></span>

<h3>Description</h3>

<p>Visualize multiple dimensions of mating potential
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3DPotential(
  matPots,
  subject = NULL,
  density = TRUE,
  sub.ids = NULL,
  N = 3,
  sample = NA,
  text.cex = 0.7,
  pt.cex = 0.7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3DPotential_+3A_matpots">matPots</code></td>
<td>
<p>list, contains one or multiple mating potential objects representing unique potential dimensions</p>
</td></tr>
<tr><td><code id="plot3DPotential_+3A_subject">subject</code></td>
<td>
<p>character, indicates whether the subject to be visualized is individuals (<code>subject</code> = 'ind') or all pairwise interactions (<code>subject</code> = 'pair')</p>
</td></tr>
<tr><td><code id="plot3DPotential_+3A_density">density</code></td>
<td>
<p>logical, if TRUE (default), plots probability density over histogram</p>
</td></tr>
<tr><td><code id="plot3DPotential_+3A_sub.ids">sub.ids</code></td>
<td>
<p>vector, contains the IDs of individuals to be represented in pairwise potential plots</p>
</td></tr>
<tr><td><code id="plot3DPotential_+3A_n">N</code></td>
<td>
<p>integer, indicates the number of individuals to sample if sub.ids = 'random' (default N = 3)</p>
</td></tr>
<tr><td><code id="plot3DPotential_+3A_sample">sample</code></td>
<td>
<p>character, specifies how to sample individuals to be represented in pairwise potential plots. Possible values are &quot;random&quot; (default) or &quot;all&quot;. See details.</p>
</td></tr>
<tr><td><code id="plot3DPotential_+3A_text.cex">text.cex</code></td>
<td>
<p>specify text expansion factor (text size relative to device default)</p>
</td></tr>
<tr><td><code id="plot3DPotential_+3A_pt.cex">pt.cex</code></td>
<td>
<p>specify point expansion factor (point size relative to device default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The individuals to be represented in the pairwise potential plots can either be specified explicitly
through <code>sub.ids</code>, chosen randomly (<code>sample</code> = 'random'), or all individuals can be selected (<code>sample</code> = 'all').
The default is to randomly select 9 individuals. If multiple years are being plotted, the subset is sampled from all years
and the same individuals will be represented in each year, if possible.
</p>


<h3>Value</h3>

<p>No return value, called to draw a plot
</p>


<h3>Author(s)</h3>

<p>Amy Waananen
</p>


<h3>See Also</h3>

<p>see generic function <code><a href="graphics.html#topic+points">points</a></code> for values of <code>pch</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulateScene()
sync &lt;- synchrony(pop, "augs")
prox &lt;- proximity(pop, 'maxProp')
compat &lt;- compatibility(pop, 'si_echinacea')
plot3DPotential(list(sync,prox,compat), subject = 'ind')
</code></pre>

<hr>
<h2 id='plot3DScene'>multi-dimensional visualization of mating scene object</h2><span id='topic+plot3DScene'></span>

<h3>Description</h3>

<p>Visualize multiple dimensions of a mating scene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3DScene(
  scene,
  dimension = "auto",
  sub = NULL,
  N = 3,
  ycoord = "northing",
  xcoord = "easting",
  pch = 19,
  pt.cex = 0.7,
  label.cex = 0.7,
  mt1 = "F",
  mt2 = "M",
  plot.lim.zoom = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3DScene_+3A_scene">scene</code></td>
<td>
<p>a matingScene object</p>
</td></tr>
<tr><td><code id="plot3DScene_+3A_dimension">dimension</code></td>
<td>
<p>what dimension(s) of the mating scene should be visualized. Possible dimensions are 't' for temporal, 's' for spatial, 'mt' for mating type, and 'auto' (the default). For dimension = 'auto', all dimensions represented in the mating scene object will be plotted.</p>
</td></tr>
<tr><td><code id="plot3DScene_+3A_sub">sub</code></td>
<td>
<p>a subset of the population to plot; either a character indicating whether to subset a random sample (<code>sub</code>='random'), all individuals (<code>sub</code>='all'), or a vector containing the IDs of the individuals to subset.</p>
</td></tr>
<tr><td><code id="plot3DScene_+3A_n">N</code></td>
<td>
<p>if <code>sub</code> = 'random', the number of individuals to sample (default N = 3)</p>
</td></tr>
<tr><td><code id="plot3DScene_+3A_ycoord">ycoord</code></td>
<td>
<p>y-axis coordinate system label</p>
</td></tr>
<tr><td><code id="plot3DScene_+3A_xcoord">xcoord</code></td>
<td>
<p>x-axis coordinate system label</p>
</td></tr>
<tr><td><code id="plot3DScene_+3A_pch">pch</code></td>
<td>
<p>point type, defaults to pch = 19, solid filled in circle. If pch = NULL, individuals will be labeled by their id.</p>
</td></tr>
<tr><td><code id="plot3DScene_+3A_pt.cex">pt.cex</code></td>
<td>
<p>specify point expansion factor (point size relative to device default)</p>
</td></tr>
<tr><td><code id="plot3DScene_+3A_label.cex">label.cex</code></td>
<td>
<p>specify text expansion factor (text size relative to device default)</p>
</td></tr>
<tr><td><code id="plot3DScene_+3A_mt1">mt1</code></td>
<td>
<p>label for mating type '1', if dioecious; defaults to 'F'</p>
</td></tr>
<tr><td><code id="plot3DScene_+3A_mt2">mt2</code></td>
<td>
<p>label for mating type '2', if dioecious; defaults to 'M'</p>
</td></tr>
<tr><td><code id="plot3DScene_+3A_plot.lim.zoom">plot.lim.zoom</code></td>
<td>
<p>if TRUE, spatial plot limits for lists of scenes are set by the maximum from all scenes</p>
</td></tr>
<tr><td><code id="plot3DScene_+3A_...">...</code></td>
<td>
<p>optional arguments for the plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to draw a plot
</p>


<h3>Author(s)</h3>

<p>Amy Waananen
</p>


<h3>See Also</h3>

<p>see generic function <code><a href="graphics.html#topic+points">points</a></code> for values of <code>pch</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulateScene()
plot3DScene(pop)



</code></pre>

<hr>
<h2 id='plotPotential'>graphical visualization of a mating potential object</h2><span id='topic+plotPotential'></span>

<h3>Description</h3>

<p>Visualize mating potential
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPotential(
  matPot,
  subject = NULL,
  plotType = "auto",
  density = TRUE,
  sub.ids = NULL,
  N = 9,
  sample = "random",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPotential_+3A_matpot">matPot</code></td>
<td>
<p>a mating potential object</p>
</td></tr>
<tr><td><code id="plotPotential_+3A_subject">subject</code></td>
<td>
<p>character, either 'ind' or 'pair', indicating whether the subject being visualized is individuals or pairwise interactions</p>
</td></tr>
<tr><td><code id="plotPotential_+3A_plottype">plotType</code></td>
<td>
<p>character,  indicating what plots are to be displayed. See details. Options are histogram ('hist'), network diagram ('net'), and heatmap ('heat'). If mating potential object</p>
</td></tr>
<tr><td><code id="plotPotential_+3A_density">density</code></td>
<td>
<p>logical. If TRUE (default), plots probability density over histogram.</p>
</td></tr>
<tr><td><code id="plotPotential_+3A_sub.ids">sub.ids</code></td>
<td>
<p>a vector containing the ids of individuals to be represented in pairwise potential plots</p>
</td></tr>
<tr><td><code id="plotPotential_+3A_n">N</code></td>
<td>
<p>a positive number indicating the number of individuals to sample if sub.ids = 'random'</p>
</td></tr>
<tr><td><code id="plotPotential_+3A_sample">sample</code></td>
<td>
<p>a character string specifying how to choose a subset of individuals to be represented in pairwise potential plots. Possible values are &quot;random&quot; (default) or &quot;all&quot; (see details).</p>
</td></tr>
<tr><td><code id="plotPotential_+3A_...">...</code></td>
<td>
<p>optional arguments for the plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Options for <code>plotType</code> are 'hist' (histogram), 'net' (network diagram), 'heat' (heatmap), and 'auto'. Default value is 'auto':
if the mating potential object contains pairwise potential, 'auto' returns all plot types, otherwise it returns histograms of individual potential.
</p>
<p>The individuals to be represented in the pairwise potential plots can either be specified explicitly through <code>sub.ids</code>, chosen randomly
(<code>sample</code> = 'random'), or all individuals can be selected (<code>sample</code> = 'all'). The default is to randomly select 9 individuals.
If multiple years are being plotted, the subset is sampled from all years and the same individuals will be represented in each year, if possible.
If fewer than three individuals from the subset are available in a year, no network diagram or heatmap will be returned for that year.
</p>


<h3>Value</h3>

<p>No return value, called to draw plots
</p>


<h3>Author(s)</h3>

<p>Amy Waananen
</p>


<h3>See Also</h3>

<p>see generic function <code><a href="graphics.html#topic+points">points</a></code> for values of <code>pch</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulateScene()
sync &lt;- synchrony(pop, "augs")
plotPotential(sync)
</code></pre>

<hr>
<h2 id='plotScene'>graphical visualization of a mating scene object</h2><span id='topic+plotScene'></span>

<h3>Description</h3>

<p>Visualize a mating scene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotScene(
  scene,
  dimension = "auto",
  dailyPoints = TRUE,
  drawQuartiles = TRUE,
  sortBy = c("start", "end"),
  colorBy = NULL,
  sub = NULL,
  N = 3,
  label.sub = TRUE,
  xlab.spat = NULL,
  ylab.spat = NULL,
  pch = 19,
  pt.cex = 0.75,
  label.cex = 0.8,
  plot.lim.zoom = FALSE,
  quartile.lwd = 1,
  quartile.col = "gray55",
  peak.col = "gray27",
  labelID = FALSE,
  mt1 = "F",
  mt2 = "M",
  leg.ncol = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotScene_+3A_scene">scene</code></td>
<td>
<p>a matingScene object</p>
</td></tr>
<tr><td><code id="plotScene_+3A_dimension">dimension</code></td>
<td>
<p>what dimension(s) of the mating scene should be visualized. Possible dimensions are 't' for temporal, 's' for spatial, 'mt' for mating type, and 'auto' (the default). For dimension = 'auto', all dimensions represented in the mating scene object will be plotted.</p>
</td></tr>
<tr><td><code id="plotScene_+3A_dailypoints">dailyPoints</code></td>
<td>
<p>logical indicating whether daily counts of individuals should be displayed for plots of the temporal dimension</p>
</td></tr>
<tr><td><code id="plotScene_+3A_drawquartiles">drawQuartiles</code></td>
<td>
<p>logical indicating whether vertical lines should be drawn at population peak (see details) or quartiles</p>
</td></tr>
<tr><td><code id="plotScene_+3A_sortby">sortBy</code></td>
<td>
<p>character indicating which columns to sort segments of flowering schedule by. Defaults to 'start', then 'end'. Up to three variables may be specified.</p>
</td></tr>
<tr><td><code id="plotScene_+3A_colorby">colorBy</code></td>
<td>
<p>character optional, the name of a variable to use to assign color to segments or points.</p>
</td></tr>
<tr><td><code id="plotScene_+3A_sub">sub</code></td>
<td>
<p>a vector containing the ids of individuals to be highlighted in the plots or a character string specifying how to choose individuals to highlight. Possible values are &quot;random&quot; or &quot;all&quot;. If NULL, no subset will be identified in the plots.</p>
</td></tr>
<tr><td><code id="plotScene_+3A_n">N</code></td>
<td>
<p>a positive number, the number of individuals to sample if <code>sub</code> = 'random'</p>
</td></tr>
<tr><td><code id="plotScene_+3A_label.sub">label.sub</code></td>
<td>
<p>logical, indicating whether specified subset should be labeled</p>
</td></tr>
<tr><td><code id="plotScene_+3A_xlab.spat">xlab.spat</code></td>
<td>
<p>character label for x-axis of spatial dimension plots. If NULL, defaults to 'easting'.</p>
</td></tr>
<tr><td><code id="plotScene_+3A_ylab.spat">ylab.spat</code></td>
<td>
<p>character label for y-axis of spatial dimension plots. If NULL, defaults to 'northing'.</p>
</td></tr>
<tr><td><code id="plotScene_+3A_pch">pch</code></td>
<td>
<p>specify point type to be used in plots. Defaults to pch = 19 (filled-in circle). If NULL, points will be labeled with their id.</p>
</td></tr>
<tr><td><code id="plotScene_+3A_pt.cex">pt.cex</code></td>
<td>
<p>specify point expansion factor (point size relative to device default)</p>
</td></tr>
<tr><td><code id="plotScene_+3A_label.cex">label.cex</code></td>
<td>
<p>specify text expansion factor (text size relative to device default)</p>
</td></tr>
<tr><td><code id="plotScene_+3A_plot.lim.zoom">plot.lim.zoom</code></td>
<td>
<p>if TRUE, spatial plot limits for lists of scenes are set by the maximum from all scenes</p>
</td></tr>
<tr><td><code id="plotScene_+3A_quartile.lwd">quartile.lwd</code></td>
<td>
<p>if <code>drawQuartiles</code> = TRUE, specifies weight of quartile and peak lines relative to device default.</p>
</td></tr>
<tr><td><code id="plotScene_+3A_quartile.col">quartile.col</code></td>
<td>
<p>if <code>drawQuartiles</code> = TRUE, specifies color of quartile lines, defaults to 'gray81'.</p>
</td></tr>
<tr><td><code id="plotScene_+3A_peak.col">peak.col</code></td>
<td>
<p>if <code>drawQuartiles</code> = TRUE, specify color of peak lines, defaults to 'gray27'.</p>
</td></tr>
<tr><td><code id="plotScene_+3A_labelid">labelID</code></td>
<td>
<p>if TRUE, the y-axis will be labeled with the id of the corresponding segment.</p>
</td></tr>
<tr><td><code id="plotScene_+3A_mt1">mt1</code></td>
<td>
<p>label for mating type '1', if dioecious</p>
</td></tr>
<tr><td><code id="plotScene_+3A_mt2">mt2</code></td>
<td>
<p>label for mating type '2', if dioecious</p>
</td></tr>
<tr><td><code id="plotScene_+3A_leg.ncol">leg.ncol</code></td>
<td>
<p>number of columns to include in legend, if colorBy is not NULL</p>
</td></tr>
<tr><td><code id="plotScene_+3A_...">...</code></td>
<td>
<p>standard graphical parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Population peak is defined by when maximum number individuals were reproductively receptive on one day. If multiple days had the same maximum number, peak is defined as the median of these dates.
</p>


<h3>Value</h3>

<p>No return value, called to draw a plot
</p>


<h3>Author(s)</h3>

<p>Amy Waananen
</p>


<h3>See Also</h3>

<p>see <code><a href="#topic+plot3DScene">plot3DScene</a></code> to visualize multiple dimensions on one plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulateScene()
plotScene(pop)


</code></pre>

<hr>
<h2 id='proximity'>Make potentials object&ndash;spatial proximity</h2><span id='topic+proximity'></span>

<h3>Description</h3>

<p>Calculate one of several measures of spatial proximity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proximity(
  scene,
  method,
  averageType = "mean",
  subject = "all",
  zeroPotDist = NULL,
  k = 6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proximity_+3A_scene">scene</code></td>
<td>
<p>a matingScene object</p>
</td></tr>
<tr><td><code id="proximity_+3A_method">method</code></td>
<td>
<p>one of &quot;maxProp&quot;, &quot;maxPropSqrd&quot;, or 'knn.dist'; see details for
further description</p>
</td></tr>
<tr><td><code id="proximity_+3A_averagetype">averageType</code></td>
<td>
<p>whether to calculate individual and population proximity
using the mean or median</p>
</td></tr>
<tr><td><code id="proximity_+3A_subject">subject</code></td>
<td>
<p>whether you want pair, individual, population, or all.
Specifying more than one is allowed.</p>
</td></tr>
<tr><td><code id="proximity_+3A_zeropotdist">zeroPotDist</code></td>
<td>
<p>the distance at which potential should be equal to zero</p>
</td></tr>
<tr><td><code id="proximity_+3A_k">k</code></td>
<td>
<p>the number of the nearest neighbor to search, if <code>method</code> is &quot;knn.dist&quot;. Defaults to 6, but must be less than population size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method</code> is &quot;maxProp&quot; then proximity between two
individuals will be calculated as 1 - distance/max(distance).
If <code>method</code> is &quot;maxPropSqrd&quot; then proximity between two
individuals will be calculated as (1 - distance/max(distance))^2. If <code>method</code> is
&quot;knn.dist&quot; then the function This uses <code>FNN::knn.dist</code> to return the Euclidian distance of the kth nearest neighbor.
</p>


<h3>Value</h3>

<p>A potentials object containing one more more of the following, depending the
input for <code>subject</code>: <br />
If <code>subject</code> is &quot;population&quot; the return list will contain a numeric
value that has a range depending on the <code>method</code>. If
<code>subject</code> is &quot;pair&quot; the return list will contain a matrix
with all pairwise proximity comparisons. If <code>subject</code> is &quot;individual&quot;
the return list will contain a dataframe with a column containing IDs and
a column containing proximity values. If <code>subject</code> is &quot;all&quot;
the return list will contain all three of the items above.
</p>


<h3>Author(s)</h3>

<p>Danny Hanson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulateScene()
proximity(pop, "maxProp")
</code></pre>

<hr>
<h2 id='receptivityByDay'>Mating Receptivity by Day</h2><span id='topic+receptivityByDay'></span>

<h3>Description</h3>

<p>Create a matrix showing which individuals are receptive on a given day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>receptivityByDay(scene, summary = FALSE, nameDate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="receptivityByDay_+3A_scene">scene</code></td>
<td>
<p>a matingScene object</p>
</td></tr>
<tr><td><code id="receptivityByDay_+3A_summary">summary</code></td>
<td>
<p>logical, summarizes number of receptive individuals on each day</p>
</td></tr>
<tr><td><code id="receptivityByDay_+3A_namedate">nameDate</code></td>
<td>
<p>logical, if summary = TRUE, option to name indices of the vector by the date they represent (rather than named relative to first day of receptivity in a season)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if summary = FALSE (default), a matrix where the columns represent all mating days and the rows
represent all individuals in the population. If summary = TRUE, a named vector where each index gives the
number of receptive individuals on a given day and is named by the day it represents. If a matrix, the value at position
[i,j] will be TRUE if individual j was receptive on day i <br />
If scene is a multi-year matingScene, then receptivityByDay will return a list of matrices
(as described above) where each matrix represents one year.
</p>


<h3>Author(s)</h3>

<p>Danny Hanson, Amy Waananen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulateScene(size = 10)
receptivityByDay(pop)
</code></pre>

<hr>
<h2 id='simulateScene'>Simulate a Mating Scene</h2><span id='topic+simulateScene'></span>

<h3>Description</h3>

<p>simulateScene generates a matingScene object &ndash; a simulated population
in a standard format with individuals randomly assigned a mating schedule,
a location, and S-alleles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateScene(
  size = 30,
  meanSD = "2012-07-12",
  sdSD = 6,
  meanDur = 11,
  sdDur = 3,
  skSD = 0,
  xRange = c(0, 100),
  yRange = c(0, 100),
  distro = "unif",
  sAlleles = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateScene_+3A_size">size</code></td>
<td>
<p>integer number of plants</p>
</td></tr>
<tr><td><code id="simulateScene_+3A_meansd">meanSD</code></td>
<td>
<p>date mean start date</p>
</td></tr>
<tr><td><code id="simulateScene_+3A_sdsd">sdSD</code></td>
<td>
<p>date standard deviation of start date</p>
</td></tr>
<tr><td><code id="simulateScene_+3A_meandur">meanDur</code></td>
<td>
<p>numeric duration in days</p>
</td></tr>
<tr><td><code id="simulateScene_+3A_sddur">sdDur</code></td>
<td>
<p>standard deviation of duration in days</p>
</td></tr>
<tr><td><code id="simulateScene_+3A_sksd">skSD</code></td>
<td>
<p>skew of the start date of the population</p>
</td></tr>
<tr><td><code id="simulateScene_+3A_xrange">xRange</code></td>
<td>
<p>range of spatial extent of individuals along x-axis</p>
</td></tr>
<tr><td><code id="simulateScene_+3A_yrange">yRange</code></td>
<td>
<p>range of spatial extent of individuals along y-axis</p>
</td></tr>
<tr><td><code id="simulateScene_+3A_distro">distro</code></td>
<td>
<p>unimplemented</p>
</td></tr>
<tr><td><code id="simulateScene_+3A_salleles">sAlleles</code></td>
<td>
<p>integer count of S-Alleles that could be in the population</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matingScene data frame &ndash; see <code><a href="#topic+makeScene">makeScene</a></code>
</p>


<h3>Author(s)</h3>

<p>Stuart Wagenius
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeScene">makeScene</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulateScene()
</code></pre>

<hr>
<h2 id='synchrony'>Make potentials object&ndash;mating synchrony</h2><span id='topic+synchrony'></span>

<h3>Description</h3>

<p>Calculate one of a variety of measures of mating synchrony.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synchrony(
  scene,
  method,
  subject = "all",
  averageType = "mean",
  syncNN = 1,
  compareToSelf = FALSE,
  frame = "within",
  resolution = "daily"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synchrony_+3A_scene">scene</code></td>
<td>
<p>a matingScene object that includes the flowering schedule for the
scene of interest.</p>
</td></tr>
<tr><td><code id="synchrony_+3A_method">method</code></td>
<td>
<p>character, partial matching allowed, describing what type
of synchrony will be calculated. &quot;augspurger&quot; is based on the method
described in Augspurger (1983). &quot;kempenaers&quot; is based on the method
described in Kempenaers (1993). &quot;sync_prop&quot; will calculate individual
synchrony based on the proportion of the sum of all individuals' days
available to mate that coincided with the individual's days available for mating.
&quot;overlap&quot; is based on the method described in Ison et al. (2014) and will
calculate a synchrony value based on the number of days both
individuals were flowering divided by the number of days either individual
was available for mating. &quot;sync_nn&quot; gives the average of the kth nearest
neighbor, or rather the kth most synchronous individual. &quot;peak-n&quot; will
calculate the number of individuals receptive on the peak day
(day with highest mating receptivity) divided by the number of individuals
in the population. &quot;peak-observations&quot; will calculate the number of individuals
receptive on the peak day divided by the total number of observations -
this method is useful for comparing to data that has no information on
individuals. &quot;average-peak&quot; calculates the average (determined by argument
<code>averageType</code>) number of individuals receptive
per day divided by the maximum number of individuals receptive per day.
All &quot;simple&quot; methods do not have pairwise or individual values. &quot;mean_interactions&quot; gives the mean number of potential mating interactions an individual obtains per unit time for the period that the individual was flowering.</p>
</td></tr>
<tr><td><code id="synchrony_+3A_subject">subject</code></td>
<td>
<p>one of &quot;population&quot;, &quot;pairwise&quot;, &quot;individual&quot;, or &quot;all&quot;
- see Value for more details.</p>
</td></tr>
<tr><td><code id="synchrony_+3A_averagetype">averageType</code></td>
<td>
<p>character. Identifies whether to take the mean or median
when calculating averages</p>
</td></tr>
<tr><td><code id="synchrony_+3A_syncnn">syncNN</code></td>
<td>
<p>integer between 1 and n-1 (inclusive) or numeric between 0 and 1
(exclusive). The kth nearest neighbor to be averaged when
calculating population synchrony. If k is in (0,1) then the k*nth nearest neighbor
will be found</p>
</td></tr>
<tr><td><code id="synchrony_+3A_comparetoself">compareToSelf</code></td>
<td>
<p>logical. Whether or not to include self comparisons
when calculation synchrony. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="synchrony_+3A_frame">frame</code></td>
<td>
<p>the timeframe that synchrony is to be calculated over; options are 'within,'
for synchrony within a season, or 'between,' for synchrony across multiple seasons.
Defaults to 'within'.</p>
</td></tr>
<tr><td><code id="synchrony_+3A_resolution">resolution</code></td>
<td>
<p>if <code>method = sync_prop</code>, indicates whether temporal resolution
should be yearly or daily</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Measures of synchrony are based on methods described in Augspurger (1983),
Kempenaers (1983), and from Ison et al. (2014), as well
as variations on different factors of those measures.
</p>


<h3>Value</h3>

<p>A potentials object containing one more more of the following, depending the
input for <code>subject</code>: <br />
If <code>subject</code> is &quot;population&quot; <code>synchrony</code> will return a numeric
value that has a range depending on the <code>method</code>. If
<code>subject</code> is &quot;pairwise&quot; <code>synchrony</code> will return a matrix
with all pairwise synchrony comparisons. It is important to note two things:
[1] if <code>method</code> is set to &quot;sync_nn&quot; then the pairwise comparisons will
be in descending order and cannot be indexed by ID order. [2] if
<code>compareToSelf</code> is set to FALSE, the matrix will have dimensions 100
rows by 99 columns. Similar to <code><a href="#topic+overlap">overlap</a></code>, indexing will be
affected. If <code>subject</code> is &quot;individual&quot; <code>synchrony</code> will
returns a data frame with a row for id and a row for individual synchrony.
If <code>subject</code> is &quot;all&quot; <code>synchrony</code> will return a list
containing the values described above for population, pairwise, and
individual synchrony.
</p>


<h3>Author(s)</h3>

<p>Danny Hanson, Amy Waananen
</p>


<h3>References</h3>

<p>Augspurger, C.K. (1983) Phenology, flowering synchrony, and fruit set of
six neotropical shrubs. <em>Biotropica</em> <strong>15</strong>, 257-267. <br /><br />
Ison, J.L., S. Wagenius, D. Reitz., M.V. Ashley. (2014) Mating between
<em>Echinacea angustifolia</em> (Asteraceae) individuals increases with
their flowering synchrony and spatial proximity.
<em>American Journal of Botany</em> <strong>101</strong>, 180-189 <br /><br />
Kempenaers, B. (1993) The use of a breeding synchrony index.
<em>Ornis Scandinavica</em>, <strong>24</strong>, 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- simulateScene(size = 150)
synchrony(pop, "augs")

pop2 &lt;- simulateScene(size = 1234, sdDur = 5, sk = 1)
syncVals &lt;- synchrony(pop2, "sync_nn", "all", "median", 123)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
