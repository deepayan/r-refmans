<!DOCTYPE html><html lang="en"><head><title>Help for package rivnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rivnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rivnet-package'><p>Extract and Analyze Rivers from Elevation Data.</p></a></li>
<li><a href='#aggregate_river'><p>Aggregate a river</p></a></li>
<li><a href='#contour_to_shapefile'><p>Export catchment contour as shapefile</p></a></li>
<li><a href='#covariate_river'><p>Attribute covariates to nodes of a river network</p></a></li>
<li><a href='#extract_river'><p>Extract a river</p></a></li>
<li><a href='#get_riverweight'><p>Get raster values at specific river locations</p></a></li>
<li><a href='#hydro_river'><p>Assign hydraulic variables to a river network</p></a></li>
<li><a href='#locate_site'><p>Locate site in a river</p></a></li>
<li><a href='#path_velocities_river'><p>Calculate velocities along paths in a river</p></a></li>
<li><a href='#paths_river'><p>Find paths in a river</p></a></li>
<li><a href='#plot'><p>Plot a river</p></a></li>
<li><a href='#points_colorscale'><p>Draw points with a colorscale</p></a></li>
<li><a href='#rast_riverweight'><p>Compute upstream-averaged raster</p></a></li>
<li><a href='#river_to_AEM'><p>river_to_AEM</p></a></li>
<li><a href='#river_to_igraph'><p>river_to_igraph</p></a></li>
<li><a href='#river_to_shapefile'><p>Export river network as shapefile</p></a></li>
<li><a href='#river_to_SSN'><p>Transform river into SSN object</p></a></li>
<li><a href='#river-class'><p>river class</p></a></li>
<li><a href='#wigger'><p>River Wigger</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extract and Analyze Rivers from Elevation Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Seamless extraction of river networks from digital 
    elevation models data. The package allows analysis of digital 
	elevation models that can be either externally provided or
	downloaded from open source repositories (thus interfacing
	with the 'elevatr' package). Extraction is performed via the 
	'D8' flow direction algorithm of TauDEM (Terrain Analysis Using 
	Digital Elevation Models), thus interfacing with the 'traudem' 
	package. Resulting river networks are compatible with functions 
	from the 'OCNet' package. See Carraro (2023) 
	&lt;<a href="https://doi.org/10.5194%2Fhess-27-3733-2023">doi:10.5194/hess-27-3733-2023</a>&gt; for a presentation of the package.</td>
</tr>
<tr>
<td>Imports:</td>
<td>spam, raster, sf, terra, traudem (&ge; 1.0.3), elevatr, OCNet
(&ge; 1.1.0), methods, Rcpp (&ge; 1.0.9), curl, fields, parallelly
(&ge; 1.33.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, bookdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lucarraro.github.io/rivnet/">https://lucarraro.github.io/rivnet/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lucarraro/rivnet/issues">https://github.com/lucarraro/rivnet/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-12 12:22:15 UTC; carrarlu</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Carraro [cre, aut],
  University of Zurich [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Carraro &lt;luca.carraro@hotmail.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-12 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rivnet-package'>Extract and Analyze Rivers from Elevation Data.</h2><span id='topic+rivnet-package'></span><span id='topic+rivnet'></span>

<h3>Description</h3>

<p>Seamless extraction of river networks from digital 
elevation models data. The package allows analysis of digital 
elevation models that can be either externally provided or
downloaded from open source repositories (thus interfacing
with the <code>elevatr</code> package). Extraction is performed via the 
'D8' flow direction algorithm of TauDEM (Terrain Analysis Using 
Digital Elevation Models), thus interfacing with the <code>traudem</code> 
package. Resulting river networks are compatible with functions 
from the <code>OCNet</code> package.
</p>


<h3>Author(s)</h3>

<p>Luca Carraro (<a href="mailto:luca.carraro@hotmail.it">luca.carraro@hotmail.it</a>)
</p>

<hr>
<h2 id='aggregate_river'>Aggregate a river</h2><span id='topic+aggregate_river'></span>

<h3>Description</h3>

<p>Aggregates a river
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_river(river, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate_river_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object.</p>
</td></tr>
<tr><td><code id="aggregate_river_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>aggregate_OCN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an alias to <code><a href="OCNet.html#topic+aggregate_OCN">OCNet::aggregate_OCN</a></code>.
</p>


<h3>Value</h3>

<p>A <code>river</code> object. See <code>aggregate_OCN</code> for description of its structure.</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
 r &lt;- extract_river(outlet=c(637478,237413),
	DEM=fp)
r &lt;- aggregate_river(r)


</code></pre>

<hr>
<h2 id='contour_to_shapefile'>Export catchment contour as shapefile</h2><span id='topic+contour_to_shapefile'></span>

<h3>Description</h3>

<p>Export catchment contour as shapefile. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contour_to_shapefile(river, filename,  
                    EPSG = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contour_to_shapefile_+3A_river">river</code></td>
<td>
<p><code>river</code> object.</p>
</td></tr>
<tr><td><code id="contour_to_shapefile_+3A_filename">filename</code></td>
<td>
<p>Character. Output file name. It must contain the &quot;.shp&quot; extension.</p>
</td></tr>
<tr><td><code id="contour_to_shapefile_+3A_epsg">EPSG</code></td>
<td>
<p>EPSG code. Default is <code>NULL</code>, which does not produce a .prj file (i.e., the shapefile 
does not contain projection information).</p>
</td></tr>	
<tr><td><code id="contour_to_shapefile_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>writeVector</code> (e.g., <code>overwrite = TRUE</code> 
allows overwriting an existing shapefile).</p>
</td></tr>						
</table>


<h3>Value</h3>

<p>No output is produced. This function is used for its side effetcs.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+writeVector">terra::writeVector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra) # to use "vect"
fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
river &lt;- extract_river(outlet=c(637478,237413), DEM=fp)

tmpname &lt;- paste0(tempfile(), ".shp")
contour_to_shapefile(river, tmpname, overwrite = TRUE)

# read output
vv &lt;- vect(tmpname)
vv
plot(vv)


# export contour shapefile for multiple catchments
river &lt;- extract_river(outlet=data.frame(x=c(637478,629532),y=c(237413,233782)),
                   EPSG=21781, #CH1903/LV03 coordinate system
                   ext=c(6.2e5,6.6e5,2e5,2.5e5),
                   z=8)
				   
contour_to_shapefile(river, tmpname, overwrite = TRUE)
vv &lt;- vect(tmpname)
vv
plot(vv)

# add projection 
contour_to_shapefile(river, tmpname, 
					EPSG = 21781, 
					overwrite = TRUE)
vv &lt;- vect(tmpname)
vv					



</code></pre>

<hr>
<h2 id='covariate_river'>Attribute covariates to nodes of a river network</h2><span id='topic+covariate_river'></span>

<h3>Description</h3>

<p>Attributes covariate values from raster files to subcatchments of a <code>river</code> object. Both local and upstream-averaged 
covariate values are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariate_river(x, river, categorical = TRUE, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covariate_river_+3A_x">x</code></td>
<td>
<p><code>SpatRaster</code> object (obtained via <code>rast</code>) containing categorical or continuous variables from which covariates
are computed. Its coordinate system must be the same of <code>river</code>. Consider using <code>terra::project</code> to change
coordinate system.</p>
</td></tr> 
<tr><td><code id="covariate_river_+3A_river">river</code></td>
<td>
<p><code>river</code> object. It must have been aggregated (via <code>aggregate_river</code>).</p>
</td></tr>
<tr><td><code id="covariate_river_+3A_categorical">categorical</code></td>
<td>
<p>Logical. Is the covariate categorical (e.g. land cover classes)? If <code>x</code> consists of several
layers, it is possible to specify <code>categorical</code> as a vector of logicals (one per each layer); alternatively, 
the single value of <code>categorical</code> is applied to all layers of <code>x</code>.</p>
</td></tr>
<tr><td><code id="covariate_river_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. If <code>TRUE</code>, overwrite previously calculated covariates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>categorical = TRUE</code>, the number of columns of <code>SC$locCov</code>, <code>SC$upsCov</code> is equal to the number of 
unique values of <code>x</code> within the catchment. Column names are composed as <code>"y_z"</code>, where  <code>y = names(x)</code> and 
<code>z</code> are the unique values of <code>x</code>. Values correspond to the fraction of pixels (FD nodes) within the local/upstream
area that are covered by a given category (e.g., land cover type).
</p>
<p>If <code>categorical = FALSE</code>, <code>SC$locCov</code> and <code>SC$upsCov</code> have a single column named <code>names(x)</code>. Values 
correspond to the mean covariate value within the local/upstream reference area.
</p>
<p>If <code>x</code> has multiple layers, columns in the data frames are added sequentially. The same occurs if <code>covariate_river</code>
is run repeated times (for instance, to compute covariates for one <code>SpatRaster</code> object at a time) when <code>overwrite = FALSE</code>.
</p>


<h3>Value</h3>

<p>A <code>river</code> object. The following elements are added:
</p>
<table role = "presentation">
<tr><td><code>SC$locCov</code></td>
<td>
<p>Data frame of covariates evaluated as local values for each subcatchment (i.e., mean covariate value
within a catchment).</p>
</td></tr>
<tr><td><code>SC$upsCov</code></td>
<td>
<p>Data frame of covariates evaluated as upstream-averaged values for each subcatchment (i.e., mean 
covariate value within the area upstream of a given subcatchment, including the subcatchment itself).</p>
</td></tr>  
</table>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+rast">terra::rast</a></code>, <code><a href="terra.html#topic+project">terra::project</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 
fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
river &lt;- extract_river(outlet=c(637478,237413),
                       DEM=fp)
river &lt;- aggregate_river(river)

# land cover raster file (categorical)
r1 &lt;- terra::rast(system.file("extdata/landcover.tif", package="rivnet")) 
# legend: 1-urban; 2-agriculture; 3-forest; 4-improductive

river &lt;- covariate_river(r1, river)

plot(river$SC$locCov[ , 1], river) # fraction of urban area within a subcatchment
plot(river$SC$upsCov[ , 1], river) # fraction of upstream-averaged urban area  
 
# mean air temperature raster file (continuous) 
r2 &lt;- terra::rast(system.file("extdata/temperature.tif", package="rivnet"))

river &lt;- covariate_river(r2, river, categorical = FALSE)

plot(river$SC$locCov[, 5], river) # the layer has been added after the 4 previous ones
 
names(river$SC$locCov) 
 
 
	
 
</code></pre>

<hr>
<h2 id='extract_river'>Extract a river</h2><span id='topic+extract_river'></span>

<h3>Description</h3>

<p>Function that extracts a river network from elevation data via TauDEM's D8 flow direction
algorithm. It can return a river object and/or output from TauDEM functions as a raster file.
Elevation data can be either downloaded from the web or provided externally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_river(outlet, EPSG=NULL, ext=NULL, z=NULL, DEM=NULL,
  as.river=TRUE, as.rast=FALSE, filename=NULL, showPlot=FALSE,
  threshold_parameter=1000, n_processes=1, displayUpdates=0, src="aws",
  args_get_elev_raster=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_river_+3A_outlet">outlet</code></td>
<td>
<p>A vector, matrix or data frame expressing the coordinates of the river outlet(s)
(in the coordinate system identified by <code>EPSG</code>, or the same as in <code>DEM</code>, if the latter
is provided). If a vector, the odd components identify the longitudinal (x) coordinates, and the
even components the latitudinal (y) coordinates. If a matrix, it should have 2 columns (for x and
y coordinates respectively) and number of rows equal to the number of outlets. If a data frame,
it should have components <code>outlet$x</code>, <code>outlet$y</code> identifying the respective coordinates.</p>
</td></tr>
<tr><td><code id="extract_river_+3A_epsg">EPSG</code></td>
<td>
<p>EPSG code identifying the coordinate system used. See <a href="https://epsg.org/">https://epsg.org/</a>. It is
required if <code>DEM</code> is not specified, and not used otherwise. It is recommended to use projected
coordinate systems, so that lengths and areas in the river object are in metric units.</p>
</td></tr>
<tr><td><code id="extract_river_+3A_ext">ext</code></td>
<td>
<p>Vector expressing the extent of the region where elevation data are downloaded.
It must be in the form <code>c(xmin, xmax, ymin, ymax)</code>. Coordinates must be expressed in the
coordinate system identified by <code>EPSG</code>. It is required if <code>DEM</code> is not specified, and
not used otherwise.</p>
</td></tr>
<tr><td><code id="extract_river_+3A_z">z</code></td>
<td>
<p>Zoom level at which elevation data should be downloaded. See <code>get_elev_raster</code> for
details. It is required if <code>DEM</code> is not specified, and not used otherwise.</p>
</td></tr>
<tr><td><code id="extract_river_+3A_dem">DEM</code></td>
<td>
<p>Filename of the Digital Elevation Model raster file to be used.</p>
</td></tr>
<tr><td><code id="extract_river_+3A_as.river">as.river</code></td>
<td>
<p>Logical. Should a river object be created?</p>
</td></tr>
<tr><td><code id="extract_river_+3A_as.rast">as.rast</code></td>
<td>
<p>Logical. Should a raster file containing results from <code>traudem</code> functions output
be created?</p>
</td></tr>
<tr><td><code id="extract_river_+3A_filename">filename</code></td>
<td>
<p>Filename of the raster file produced if <code>as.rast=TRUE</code>. Only required if
<code>as.rast=TRUE</code>. It can be a single filename, or four filenames, in which case four different
raster files are produced. See Details.</p>
</td></tr>
<tr><td><code id="extract_river_+3A_showplot">showPlot</code></td>
<td>
<p>Logical. Should a plot of the calculated contributing area and extracted catchment
contour be produced?</p>
</td></tr>
<tr><td><code id="extract_river_+3A_threshold_parameter">threshold_parameter</code></td>
<td>
<p>Value passed to <code>taudem_threshold</code>. See example and 'traudem'
documentation for details.</p>
</td></tr>
<tr><td><code id="extract_river_+3A_n_processes">n_processes</code></td>
<td>
<p>Value passed to the <code>traudem</code> functions.</p>
</td></tr>
<tr><td><code id="extract_river_+3A_displayupdates">displayUpdates</code></td>
<td>
<p>Numeric. Possible values are <code>0</code>, <code>1</code>, <code>2</code>. If <code>0</code>, console output 
is suppressed (barring some messages from <code>elevatr::get_elev_raster</code>, if <code>DEM</code> is not provided). 
If <code>1</code>, succint console output is produced. If <code>2</code>, extensive  console output from 
<code>elevatr::get_elev_raster</code> and <code>traudem</code> functions is displayed. </p>
</td></tr>
<tr><td><code id="extract_river_+3A_src">src</code></td>
<td>
<p>Value passed to <code>get_elev_raster</code>. Deprecated.</p>
</td></tr>
<tr><td><code id="extract_river_+3A_args_get_elev_raster">args_get_elev_raster</code></td>
<td>
<p>List of additional parameters to be passed to <code>get_elev_raster</code>. 
Parameters included in this list override default options (for example, if two different zoom 
values are specified in <code>args_get_elev_raster$z</code> and <code>z</code>, then the latter is not considered. )</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper to <code>elevatr</code> and <code>traudem</code> functions, allowing a seamless extraction of
river networks from elevation data. The output <code>river</code> object is compatible with <code>OCNet</code> functions
(it is equivalent to an OCN produced by <code>landscape_OCN</code>).
</p>
<p>The workflow of TauDEM commands used is as follows:
<code>PitRemove</code> -&gt; <code>D8FlowDir</code> -&gt; <code>D8ContributingArea</code> -&gt; <code>StreamDefByThreshold</code> -&gt;
<code>MoveOutletsToStreams</code> -&gt; <code>D8ContributingArea</code>.
See <a href="https://hydrology.usu.edu/taudem/taudem5/index.html">https://hydrology.usu.edu/taudem/taudem5/index.html</a> for details on TauDEM.
</p>
<p>When <code>as.rast = TRUE</code>, a raster file is returned. It consists of four layers:
</p>

<dl>
<dt>fel</dt><dd><p>pit-filled elevation data</p>
</dd>
<dt>p</dt><dd><p>D8 flow directions</p>
</dd>
<dt>ad8</dt><dd><p>contributing area for the whole region</p>
</dd>
<dt>ssa</dt><dd><p>contributing area with respect to the outlet(s) used</p>
</dd>
</dl>

<p>The raster file is written via <code>terra::writeRaster</code>.
</p>
<p>If nested outlets are specified, the function ignores the upstream outlet.
</p>


<h3>Value</h3>

<p>A <code>river</code> object. See <code>create_OCN</code>, <code>landscape_OCN</code> for description of its structure.</p>


<h3>See Also</h3>

<p><code><a href="elevatr.html#topic+get_elev_raster">elevatr::get_elev_raster</a></code>, <code><a href="traudem.html#topic+taudem_threshold">traudem::taudem_threshold</a></code>,
<code><a href="OCNet.html#topic+create_OCN">OCNet::create_OCN</a></code>, <code><a href="OCNet.html#topic+landscape_OCN">OCNet::landscape_OCN</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# extract the river Wigger (Switzerland) from DEM raster file
# outlet coordinates are expressed in the CH1903/LV03 coordinate system
# (i.e. same as the DEM file)
 fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
 r &lt;- extract_river(outlet=c(637478,237413),
	DEM=fp)
r



# same as above but download DEM data via elevatr
r &lt;- extract_river(outlet=c(637478,237413),
	EPSG=21781, #CH1903/LV03 coordinate system
	ext=c(6.2e5,6.6e5,2e5,2.5e5),
	z=8)



# enhance resolution by increasing zoom
r2 &lt;- extract_river(outlet=c(637478,237413),
	EPSG=21781, #CH1903/LV03 coordinate system
	ext=c(6.2e5,6.6e5,2e5,2.5e5),
	z=9)
plot(r)
plot(r2)



# specify two outlets as a data frame
r &lt;- extract_river(outlet=data.frame(x=c(637478,629532),y=c(237413,233782)),
                    EPSG=21781, #CH1903/LV03 coordinate system
                    ext=c(6.2e5,6.6e5,2e5,2.5e5),
                    z=10, showPlot=TRUE)
plot(r)

r &lt;- aggregate_river(r)
plot(r, chooseCM = 2)  # display only the second catchment
# (i.e. that identified by the second outlet)



# effect of threshold_parameter
r &lt;- extract_river(outlet = c(637478, 237413),
                    EPSG = 21781, #CH1903/LV03 coordinate system
                    ext = c(6.2e5, 6.6e5, 2e5, 2.5e5),
                    z = 8, threshold_parameter = 50,
				    showPlot = TRUE)
plot(r) # if threshold_parameter is too small, the outlet might be located
# in a smaller river reach, and the extracted river network would be too small
# showPlot = TRUE can help identify what is going on

r &lt;- extract_river(outlet = c(637478, 237413),
                    EPSG = 21781, #CH1903/LV03 coordinate system
                    ext = c(6.2e5, 6.6e5, 2e5, 2.5e5),
                    z = 8, threshold_parameter = 1e5,
				    showPlot = TRUE)
plot(r) # if threshold_parameter is too large, the outlet pixel might not be
# located at all (for instance, in this case no cells have contributing area
# above threshold_parameter), hence throwing an error


</code></pre>

<hr>
<h2 id='get_riverweight'>Get raster values at specific river locations</h2><span id='topic+get_riverweight'></span>

<h3>Description</h3>

<p>Get values from a raster at specific locations in a river network. It can be used to 
extract relevant values from upstream-averaged rasters as produced by <code>rast_riverweight</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_riverweight(x, rst, river, args_locate_site = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_riverweight_+3A_x">x</code></td>
<td>
<p>Coordinate(s) of the location(s) of interest. These can be expressed as a 2-valued vector
(indicating longitudinal and latitudinal coordinate of the single point of interest&ndash;in the same
coordinate system as <code>rst</code> and <code>river</code>), a matrix or data frame (with two columns, for 
longitudinal and latitudinal coordinates, respectively, and as many rows as the number of points 
of interest). See examples.</p>
</td></tr>
<tr><td><code id="get_riverweight_+3A_rst">rst</code></td>
<td>
<p>A <code>SpatRaster</code> object as obtained by <code>rast_riverweight</code>.</p>
</td></tr>
<tr><td><code id="get_riverweight_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object generated via <code>aggregate_river</code>.</p>
</td></tr>
<tr><td><code id="get_riverweight_+3A_args_locate_site">args_locate_site</code></td>
<td>
<p>List of arguments to be passed to <code>locate_site</code>. See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns named after the layers of <code>rst</code>, and as many rows as the number of 
rows in <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rast_riverweight">rast_riverweight</a></code>, <code><a href="#topic+locate_site">locate_site</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wigger)

r1 &lt;- terra::rast(system.file("extdata/landcover.tif", package = "rivnet")) 
# legend: 1-urban; 2-agriculture; 3-forest; 4-improductive

r.exp &lt;- rast_riverweight(r1, wigger)

v1 &lt;- get_riverweight(c(641000, 226100), r.exp, wigger) # from vector
m &lt;- matrix(c(641000, 226100), 1, 2)
v2 &lt;- get_riverweight(m, r.exp, wigger) # from matrix
df &lt;- data.frame(m)
v3 &lt;- get_riverweight(df, r.exp, wigger) # from data frame

m2 &lt;- matrix(c(641000, 226100, 639600, 226100), 2, 2, byrow = TRUE)
v4 &lt;- get_riverweight(m2, r.exp , wigger) # from matrix multipoint


# use showPlot = TRUE from locate_site to check snapping of point to the river network
v1 &lt;- get_riverweight(c(641000, 226100), r.exp, wigger, 
					args_locate_site = list(showPlot = TRUE)) 


</code></pre>

<hr>
<h2 id='hydro_river'>Assign hydraulic variables to a river network</h2><span id='topic+hydro_river'></span>

<h3>Description</h3>

<p>Assign hydraulic variables (width, water depth, discharge, water velocity, ...) across a <code>river</code> object from measured values based on 
scaling relationships and/or uniform flow equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hydro_river(x, river, level = "AG", leopold = TRUE,
 expWidth = 0.5, expDepth = 0.4, expQ = 1,
 crossSection = "natural", ks = 30, minSlope = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hydro_river_+3A_x">x</code></td>
<td>
<p>Data frame containing measured hydraulic variables. It must consist of columns <code>data</code> (numeric values of width in m, depth in m or discharge in m^3 s^(-1)), <code>type</code> (containing the variable type: width (<code>"w"</code>), depth (<code>"d"</code>) or discharge (<code>"Q"</code>)), and <code>node</code> (ID of AG or RN nodes to where <code>data</code> have been measured). See details.</p>
</td></tr> 
<tr><td><code id="hydro_river_+3A_river">river</code></td>
<td>
<p><code>river</code> object. It must have been aggregated (via <code>aggregate_river</code>).</p>
</td></tr>
<tr><td><code id="hydro_river_+3A_level">level</code></td>
<td>
<p>Aggregation level at which the nodes in <code>x$node</code> are defined and at which hydraulic variables are calculated. Possible values are <code>"RN"</code>, <code>"AG"</code>. See <code><a href="OCNet.html#topic+OCNet">OCNet::OCNet</a></code> for details.</p>
</td></tr>
<tr><td><code id="hydro_river_+3A_leopold">leopold</code></td>
<td>
<p>Logical. Should scaling relationships of hydraulic variables with drainage area (in the spirit of Leopold and Maddock, 1953) be preferred over uniform flow (Gauchler-Strickler/Manning) relationships? See details.</p>
</td></tr>
<tr><td><code id="hydro_river_+3A_expwidth">expWidth</code></td>
<td>
<p>Exponent for the scaling relationship of width to drainage area. See details.</p>
</td></tr>
<tr><td><code id="hydro_river_+3A_expdepth">expDepth</code></td>
<td>
<p>Exponent for the scaling relationship of depth to drainage area. See details.</p>
</td></tr> 
<tr><td><code id="hydro_river_+3A_expq">expQ</code></td>
<td>
<p>Exponent for the scaling relationship of discharge to drainage area. See details.</p>
</td></tr> 
<tr><td><code id="hydro_river_+3A_crosssection">crossSection</code></td>
<td>
<p>Shape of the river cross-section (constant across the river network). Possible values are <code>"rectangular"</code>, <code>"natural"</code>, or a numeric value indicating the exponent of the width-depth relationship. See details.</p>
</td></tr>
<tr><td><code id="hydro_river_+3A_ks">ks</code></td>
<td>
<p>Roughness coefficient according to Gauchler-Strickler (in m^(1/3)s^(-1)). It is the inverse of Manning's roughness coefficient. It can be a single value (thus assumed constant for the whole river network), or a vector of length equal to the number of nodes at the specified <code>level</code> (one roughness coefficient value for each corresponding node).</p>
</td></tr> 
<tr><td><code id="hydro_river_+3A_minslope">minSlope</code></td>
<td>
<p>Minimum slope value, replacing null or <code>NaN</code> values of slope in the <code>river</code> object. If <code>NULL</code>, it is assumed equal to either <code>river$slope0</code> (if the river is an OCN) or to the minimum positive slope value at the selected <code>level</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a more complete version of <code>rivergeometry_OCN</code>.
</p>
<p><code>x</code> must consist of at least one width value and one value of either depth or discharge. All values included in <code>x$data</code> must be referred to the same time point, so that spatial interpolation can be performed. If the goal is assessing spatio-temporal changes in hydraulic variables, then <code>hydro_river</code> must be run independently for each time point. For each node, one cannot specify multiple values of the same variable type. Function <code>locate_site</code> can be used to attribute <code>x$node</code>.
</p>
<p>If <code>level = "AG"</code>, the drainage area values used for the power law relationships are calculated as <code>0.5*(river$AG$A + river$AG$AReach)</code>. If <code>level = "RN"</code>, <code>river$RN$A</code> is used.
</p>
<p>Width values in <code>x</code> are assumed to be measured at the water surface. If a single width value is provided, widths are calculated at all nodes from a power-law relationship on drainage area with exponent <code>expWidth</code> and such that width at the measured node is equal to the provided value. If multiple values of width are provided, the function fits a width-drainage area power law on the provided values. In this case, <code>expWidth</code> is not used and the output (fitted) width values at the measured nodes are generally different than the observed ones.  
</p>
<p>Depending on the type of depth and discharge data in <code>x</code>, the function behaves in eight different ways:
</p>

<ol>
<li><p> If one depth value and zero discharge values are provided, the Gauchler-Strickler uniform flow relationship (hereafter GS) is applied to find discharge at the node where depth was measured. Discharge values are then attributed to all nodes based on a power-law relationship vs. drainage area (hereafter PL) with exponent <code>expQ</code>. Finally, depth values at all nodes are derived from GS.
</p>
</li>
<li><p> If one discharge value and zero depth values are provided, discharge values are attributed to all nodes based on a PL with exponent <code>expQ</code>, and such that the value at the measurement node be equal to the observed one. Depth values at all nodes are then derived from GS. 
</p>
</li>
<li><p> If one discharge and one depth value are provided (not necessarily referred to the same node), discharge values are first attributed as in case 2. If <code>leopold = TRUE</code>, depth values are derived from a PL with exponent <code>expDepth</code>; conversely, GS is applied. 
</p>
</li>
<li><p> If multiple values of discharge and zero values of depth are provided, discharge values are attributed from a power-law fit on measured values vs. drainage area (heareafter PLF). Depth values are then obtained from GS.
</p>
</li>
<li><p> If multiple values of depth and zero values of discharge are provided, depth values are obtained by PLF. Discharge values are then calculated from GS.
</p>
</li>
<li><p> If multiple values of discharge and one value of depth are provided, discharge values are first computed as in case 4. Depth values are then obtained by either PF with exponent <code>expDepth</code> (if <code>leopold = TRUE</code>), or alternatively via GS.
</p>
</li>
<li><p> If multiple values of depth and one value of discharge are provided, depth values are first computed as in case 5. Discharge values are then obtained as in case 2 (if <code>leopold = TRUE</code>), or alternatively computed from GS.  
</p>
</li>
<li><p> If multiple values of both discharge and depth are provided, discharge values are computed as in case 4, and depth values are computed as in case 5.    
</p>
</li></ol>

<p>Cross-sections are assumed as vertically symmetric. If <code>crossSection = "natural"</code>, the relationship between width and depth at a cross-section is expressed by width ~ depth^0.65, as suggested by Leopold and Maddock (1953) (where width ~ discharge^0.26 and depth ~ discharge^0.4). Assuming <code>crossSection = 0</code> is equivalent to <code>"rectangular"</code> (width does not depend on depth), while <code>crossSection = 1</code> corresponds to an isosceles triangular cross-section.
</p>


<h3>Value</h3>

<p>A <code>river</code> object. The following elements are added to the list indicated by <code>level</code>:
</p>
<table role = "presentation">
<tr><td><code>width</code>, <code>depth</code>, <code>discharge</code></td>
<td>
<p>Values assigned at all nodes (see Details). Units are m, m, m^3 s^(-1), respectively.</p>
</td></tr>
<tr><td><code>velocity</code></td>
<td>
<p>Values in m s^(-1). Calculated by continuity (i.e., ratio between discharge and cross-sectional area).</p>
</td></tr> 
<tr><td><code>volume</code></td>
<td>
<p>Values in m^3. Calculated as cross-sectional area times length.</p>
</td></tr>
<tr><td><code>hydraulicRadius</code></td>
<td>
<p>Values in m. Calculated as the ratio between cross-sectional area and wetted perimeter.</p>
</td></tr>
<tr><td><code>shearStress</code></td>
<td>
<p>Values in N m^(-2). Shear stress exerted at the streambed by waterflow. Calculated as gamma*hydraulicRadius*slope, where gamma = 9806 N m^(-3) is the specific weight of water.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate_river">aggregate_river</a></code>, <code><a href="#topic+locate_site">locate_site</a></code>, <code><a href="OCNet.html#topic+rivergeometry_OCN">OCNet::rivergeometry_OCN</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 
fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
river &lt;- extract_river(outlet=c(637478,237413),
                       DEM=fp)
river &lt;- aggregate_river(river)

data &lt;- c(12.8,  6.7,  3.3,  1.1,  9.5,  0.8)
type &lt;- c("w",   "w",  "w",  "w",  "Q",  "d")
node &lt;- c( 46,   109,  181,  145,   46,   46) # assume these have been found via locate_site

x &lt;- data.frame(data=data, type=type, node=node)

river1 &lt;- hydro_river(x, river) # case 3
river2 &lt;- hydro_river(x, river, leopold = FALSE) # case 3 (depth calculated via GS)

plot(0.5*(river1$AG$A + river1$AG$AReach), river1$AG$depth) # Power law with exponent 0.4
plot(0.5*(river2$AG$A + river2$AG$AReach), 
	river2$AG$depth) # Higher depths in reaches with small slope

river3 &lt;- hydro_river(x, river, leopold = FALSE, minSlope = 0.002)
plot(0.5*(river1$AG$A + river1$AG$AReach), river1$AG$depth) # Variability is reduced

river &lt;- hydro_river(x[-5, ], river) # case 1
river &lt;- hydro_river(x[-6, ], river) # case 2

 
	 
 
</code></pre>

<hr>
<h2 id='locate_site'>Locate site in a river</h2><span id='topic+locate_site'></span>

<h3>Description</h3>

<p>Finds location of a site (with coordinates X, Y) within a <code>river</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate_site(X, Y = NULL, river, euclidean = TRUE, showPlot = FALSE, 
  xlim = NULL, ylim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locate_site_+3A_x">X</code></td>
<td>
<p>Either a list or a numeric value. If <code>X</code> is a list, it must contain the longitudinal and latitudinal 
coordinates of the site in columns <code>x</code> (or <code>X</code>) and <code>y</code> (or <code>Y</code>), respectively. If numeric, it represents 
the longitudinal coordinate of the site. Coordinate values must be given in the same coordinate system as the <code>river</code> object.</p>
</td></tr>
<tr><td><code id="locate_site_+3A_y">Y</code></td>
<td>
<p>Latitudinal coordinate of the site. If <code>X</code> is a list, it can contain the <code>river</code> object.</p>
</td></tr>
<tr><td><code id="locate_site_+3A_river">river</code></td>
<td>
<p><code>river</code> object where the site is to be located. It must have been aggregated (via <code>aggregate_river</code>).</p>
</td></tr>
<tr><td><code id="locate_site_+3A_euclidean">euclidean</code></td>
<td>
<p>Logical. Should the location of the site in the <code>river</code> be attributed &quot;as the crow flies&quot;? 
If <code>FALSE</code>, the downstream path from (<code>X</code>, <code>Y</code>) is followed until the river network is met.</p>
</td></tr>
<tr><td><code id="locate_site_+3A_showplot">showPlot</code></td>
<td>
<p>Logical. Should a close-up of the relocated site be shown?</p>
</td></tr>
<tr><td><code id="locate_site_+3A_xlim">xlim</code>, <code id="locate_site_+3A_ylim">ylim</code></td>
<td>
<p>Ranges of x- and y-axis limits for the plot. Only active if <code>showPlot = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies the node in the river network (at the RN and AG levels) that is closest to
an arbitrary site of coordinates <code>X</code>, <code>Y</code>. Only a single site can be processed per function call.
</p>
<p>Desired coordinates X, Y can be found in an interactive way by clicking on the river map and using 
function <code>locator</code>.
</p>
<p>Nodes at the RN level thus found can be defined as new breakpoints for reaches (see <code>aggregate_OCN</code> 
and argument <code>breakpoints</code>).
</p>


<h3>Value</h3>

<p>A list with objects:
</p>
<table role = "presentation">
<tr><td><code>FDode</code></td>
<td>
<p>index at the FD level of the node that is closest to (<code>X</code>, <code>Y</code>). This is generally not a node
that belongs to the river network.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>The distance between <code>FDnode</code> and <code>RNnode</code>, expressed either as Euclidean distance (if 
<code>euclidean = TRUE</code>), or as downstream distance alternatively.</p>
</td></tr>
<tr><td><code>RNode</code></td>
<td>
<p>index at the RN level of the relocated site.</p>
</td></tr>
<tr><td><code>AGode</code></td>
<td>
<p>index at the AG level of the relocated site.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>List of graphical parameters as produced by a call to <code><a href="graphics.html#topic+par">par</a></code> 
(only if <code>showPlot = TRUE</code>). This can be used to add features to the existing plot. Deprecated.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="OCNet.html#topic+aggregate_OCN">OCNet::aggregate_OCN</a></code>, <code><a href="graphics.html#topic+locator">locator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 fp &lt;- system.file("extdata/wigger.tif", package = "rivnet")
 r &lt;- extract_river(outlet = c(637478, 237413),
	                  DEM = fp)					  
 r &lt;- aggregate_river(r)
 
 X &lt;- 641329; Y &lt;- 227414 
 out1 &lt;- locate_site(X, Y, r, showPlot = TRUE) # as the crow flies
 out2 &lt;- locate_site(X, Y, r, showPlot = TRUE, euclidean = FALSE) # follow downstream path
 
 
 
  # define X, Y by clicking on the map
 if (interactive()) {
 fp &lt;- system.file("extdata/wigger.tif", package = "rivnet")
 r &lt;- extract_river(outlet = c(637478, 237413),
	                  DEM = fp)					  
 r &lt;- aggregate_river(r)
 plot(r)
 
 point &lt;- locator(1) # click on the map to define point
 locate_site(point$X, point$Y, r)
 
 # alternative: specify X as a list and pass river as second argument
 locate_site(point, r)
 }

</code></pre>

<hr>
<h2 id='path_velocities_river'>Calculate velocities along paths in a river</h2><span id='topic+path_velocities_river'></span>

<h3>Description</h3>

<p>Calculate mean water velocities along paths in a <code>river</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_velocities_river(river, level = c("RN", "AG"), 
  displayUpdates = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="path_velocities_river_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object. It must have been aggregated (via <code>aggregate_river</code>), and contain paths (via <code>paths_river</code> with <code>includeDownstreamNode = TRUE</code>) 
and velocities (via <code>hydro_river</code> or <code>rivergeometry_OCN</code>) at the desired aggregation level(s). See <code>level</code>.</p>
</td></tr>
<tr><td><code id="path_velocities_river_+3A_level">level</code></td>
<td>
<p>Aggregation level(s) at which path velocities should be calculated. Possible values are <code>"RN"</code>, <code>"AG"</code>, <code>c("RN","AG")</code>.</p>
</td></tr>
<tr><td><code id="path_velocities_river_+3A_displayupdates">displayUpdates</code></td>
<td>
<p>Logical. State if updates are printed on the console while <code>path_velocities_river</code> runs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Velocities are calculated by dividing the total distance (length of the downstream path joining two nodes) by the total time (sum of times taken to cover all nodes in between the origin and destination nodes; such times are calculated as length/velocity).
</p>
<p>Note that paths may or may not include the downstream node; this is controlled by option <code>includeDownstreamNode</code> in <code>paths_river</code>. Path velocities are calculated accordingly. 
In both cases, diagonal entries of <code>pathVelocity</code> are set equal to the respective node velocity. See example.   
</p>


<h3>Value</h3>

<p>A <code>river</code> object. The following element is added to the list indicated by <code>level</code>:
</p>
<table role = "presentation">
<tr><td><code>pathVelocities</code></td>
<td>
<p>It is a <code>spam</code> object. <code>pathVelocities[i, j]</code> is the mean water velocity along the downstream path from nodes <code>i</code> to <code>j</code>, and is null if the two nodes are not connected by such a path.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+paths_river">paths_river</a></code>, <code><a href="#topic+hydro_river">hydro_river</a></code>, <code><a href="OCNet.html#topic+rivergeometry_OCN">OCNet::rivergeometry_OCN</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 
fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
river &lt;- extract_river(outlet=c(637478,237413),
                       DEM=fp)
river &lt;- aggregate_river(river)
river &lt;- paths_river(river, includePaths = TRUE)
river &lt;- OCNet::rivergeometry_OCN(river) # simplified alternative to hydro_river
                                  # to attribute velocities at all RN and AG nodes
								  
river &lt;- path_velocities_river(river, level = "AG") # downstream nodes are not included in paths
river$AG$pathVelocities[176, 176] 
river$AG$pathVelocities[176, 174]
 # node 174 is immediately downstream of 176; if downstream nodes are not included 
 # in paths, the two velocities are equal

river2 &lt;- paths_river(river, includePaths = TRUE, includeDownstreamNode = TRUE)
river2 &lt;- path_velocities_river(river2, level = "AG") # now downstream nodes are included in paths
river2$AG$pathVelocities[176, 176] 
river2$AG$pathVelocities[176, 174]
 
 	
 
</code></pre>

<hr>
<h2 id='paths_river'>Find paths in a river</h2><span id='topic+paths_river'></span>

<h3>Description</h3>

<p>Find paths in a river
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paths_river(river, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paths_river_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object.</p>
</td></tr>
<tr><td><code id="paths_river_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>paths_OCN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an alias to <code><a href="OCNet.html#topic+paths_OCN">OCNet::paths_OCN</a></code>.
</p>


<h3>Value</h3>

<p>A <code>river</code> object. See <code>paths_OCN</code> for description of its structure.</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
 r &lt;- extract_river(outlet=c(637478,237413),
	DEM=fp)
r &lt;- aggregate_river(r)	
r &lt;- paths_river(r)


</code></pre>

<hr>
<h2 id='plot'>Plot a river </h2><span id='topic+plot'></span><span id='topic+plot+2Criver+2Cnumeric-method'></span><span id='topic+plot+2Cnumeric+2Criver-method'></span><span id='topic+plot+2Criver+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plots a <code>river</code> object</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'river,numeric'
plot(x, y, type, ...)
## S4 method for signature 'numeric,river'
plot(x, y, type, ...)
## S4 method for signature 'river,missing'
plot(x, type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>A <code>river</code> object (or a numeric vector if <code>y</code> is a <code>river</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>A numeric vector to be displayed (or a river if <code>x</code> is a numeric vector).
It is equivalent to <code>theme</code> in <code>draw_subcatchments_OCN</code> and <code>draw_thematic_OCN</code>. If <code>y</code> is specified, the river must
have been aggregated. See details.</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>Optional argument. If <code>type = "SC"</code> or <code>type = "subcatchments"</code>, <code>draw_subcatchments_OCN</code> is used (provided that
the <code>river</code> object is aggregated); if  <code>type = "elev2D"</code>, <code>draw_elev2D_OCN</code> is used; if <code>type = "contour"</code>, <code>draw_contour_OCN</code>
is used (provided that the <code>river</code> object contains the <code>CM</code> field as produced by <code>landscape_OCN</code> or <code>extract_river</code>); alternatively,
<code>draw_thematic_OCN</code> is used.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Arguments passed to the plotting functions <code>draw_simple_OCN</code>, <code>draw_contour_OCN</code>,
<code>draw_thematic_OCN</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an interface to the plotting functions <code>draw_simple_OCN</code>, <code>draw_elev2D_OCN</code>, <code>draw_contour_OCN</code>, <code>draw_subcatchments_OCN</code>,
<code>draw_thematic_OCN</code>. If the <code>river</code> object does not have an elevation field (i.e., it has been generated
by <code>create_OCN</code> or <code>create_general_contour_OCN</code>, but <code>landscape_OCN</code> has not
been run), the plotting function used is <code>draw_simple_OCN</code>. If the elevation field is present, but the river
has not been aggregated (via <code>aggregate_OCN</code> or <code>aggregate_river</code>), the default plotting function used is
<code>draw_contour_OCN</code>. If the river has been aggregated, <code>draw_subcatchments_OCN</code> or <code>draw_thematic_OCN</code> are used depending on <code>type</code>.
Elevation maps can be produced with <code>type = "elev2D"</code>, regardless of whether the river has been aggregated.
</p>
<p><em>Adding scale bar and north arrow.</em> Scale bar and north arrow can be added via <code>terra</code>'s functions <code><a href="terra.html#topic+sbar">terra::sbar</a></code> and <code><a href="terra.html#topic+north">terra::north</a></code>, respectively.
However, note that arguments <code>d</code> and <code>xy</code> must be specified by the user (because no <code>rast</code> object is plotted). See example.
</p>


<h3>See Also</h3>

<p><code><a href="OCNet.html#topic+draw_simple_OCN">OCNet::draw_simple_OCN</a></code>, <code><a href="OCNet.html#topic+draw_elev2D_OCN">OCNet::draw_elev2D_OCN</a></code>, <code><a href="OCNet.html#topic+draw_contour_OCN">OCNet::draw_contour_OCN</a></code>, 
<code><a href="OCNet.html#topic+draw_subcatchments_OCN">OCNet::draw_subcatchments_OCN</a></code>, <code><a href="OCNet.html#topic+draw_thematic_OCN">OCNet::draw_thematic_OCN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
r &lt;- extract_river(outlet=c(637478,237413),
	DEM=fp)
plot(r)	# equivalent to draw_contour_OCN


r &lt;- aggregate_river(r)
plot(r) # equivalent to draw_thematic_OCN
plot(r, type = "SC") # equivalent to draw_subcatchments_OCN
plot(r, type = "contour")	# equivalent to draw_contour_OCN 

# equivalent to draw_thematic_OCN with 'theme' specified
plot(r, r$AG$streamOrder, discreteLevels = TRUE)
plot(r$AG$streamOrder, r, discreteLevels = TRUE)  # swapping arguments is allowed

# equivalent to draw_subcatchments_OCN with 'theme' specified
plot(r, r$SC$Y, type = "SC", addLegend = FALSE)
plot(r$SC$Y, r,  type = "subcatchments", addLegend = FALSE)  # swapping arguments is allowed

# plot elevation map
plot(r, type = "elev2D", drawRiver = TRUE)
# now add scale bar and north arrow
library(terra)
# sbar() # this would throw an error
# north()# this would throw an error
sbar(d=1000, xy=c(min(r$FD$X), min(r$FD$Y)-r$cellsize)) # this works
north(d=1000, xy=c(max(r$FD$X)+r$cellsize, max(r$FD$Y))) # this works


</code></pre>

<hr>
<h2 id='points_colorscale'>Draw points with a colorscale</h2><span id='topic+points_colorscale'></span>

<h3>Description</h3>

<p>Draw points with values displayed as colors. Two different sets of values can be shown simultaneously: 
one in the background and one in the contour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points_colorscale(X, Y, values,
                  bg.palette = hcl.colors(1000, "Reds 3", rev=T),
                  col.palette = hcl.colors(1000, "Reds 3",rev=T),
                  bg.range = NULL, col.range = NULL,
                  pch = 21, cex = 2, lwd = 1.5, force.range = TRUE,
                  add.col.legend = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="points_colorscale_+3A_x">X</code>, <code id="points_colorscale_+3A_y">Y</code></td>
<td>
<p>Coordinates of the points to be displayed.</p>
</td></tr>
<tr><td><code id="points_colorscale_+3A_values">values</code></td>
<td>
<p>values of the quantity to be shown at the sampling sites. It can be a single vector
(colors are shown on the inside of the points), or a data frame (the first column
is related to colors on the inside, the second to colors on the outside of the points).</p>
</td></tr>
<tr><td><code id="points_colorscale_+3A_bg.palette">bg.palette</code>, <code id="points_colorscale_+3A_col.palette">col.palette</code></td>
<td>
<p>Color palettes for values on the inside and outside of the points, respectively.</p>
</td></tr>
<tr><td><code id="points_colorscale_+3A_bg.range">bg.range</code>, <code id="points_colorscale_+3A_col.range">col.range</code></td>
<td>
<p>Ranges for the legend for values on the inside and outside of the points, 
respectively. If not specified, the range of values (min-max) is used.</p>
</td></tr>
<tr><td><code id="points_colorscale_+3A_pch">pch</code>, <code id="points_colorscale_+3A_cex">cex</code>, <code id="points_colorscale_+3A_lwd">lwd</code></td>
<td>
<p>Same as in plot() (Note: only use values between 21-25 for pch).</p>
</td></tr>
<tr><td><code id="points_colorscale_+3A_force.range">force.range</code></td>
<td>
<p>Locical. If TRUE, values outside the range are constrained at the boundaries of 
the range; if FALSE, a transparent color is used.</p>
</td></tr>
<tr><td><code id="points_colorscale_+3A_add.col.legend">add.col.legend</code></td>
<td>
<p>Logical. Add a legend for values on the outside of the points?</p>
</td></tr>	
<tr><td><code id="points_colorscale_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>imagePlot</code> to draw the legend.</p>
</td></tr>						
</table>


<h3>Details</h3>

<p>A call to <code>points</code> is performed in the background. Therefore, a plot window must be open 
when this function is called.
</p>


<h3>Value</h3>

<p>No output is produced. This function is used for its side effetcs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
river &lt;- extract_river(outlet=c(637478,237413), DEM=fp)
river &lt;- aggregate_river(river)

# some random location of sampling sites, just to test the function
samplingSites &lt;- c(2,15,30,78,97,117,132,106,138,153,156,159,
                    263,176,215,189,11,70,79,87,45,209,26,213)
# we use drainage area as an example variable to be shown

# 1) the function must be called after "plot(river)"
plot(river)
points_colorscale(river$AG$X[samplingSites], river$AG$Y[samplingSites],
                   river$AG$A[samplingSites])

# 2) change color palette
plot(river)
points_colorscale(river$AG$X[samplingSites], river$AG$Y[samplingSites],
                  river$AG$A[samplingSites],
                  bg.palette = hcl.colors(1000, "Inferno"))

# 3) impose a different range
plot(river)
points_colorscale(river$AG$X[samplingSites], river$AG$Y[samplingSites],
                  river$AG$A[samplingSites],
                  bg.range = c(0, 1e8))

# 4) show values outside the range as transparent
plot(river)
points_colorscale(river$AG$X[samplingSites], river$AG$Y[samplingSites],
                  river$AG$A[samplingSites],
                  bg.range = c(0, 1e8), force.range = FALSE)

# 5) show values both on inside and outside of the points (
# drainage area at the upstream vs. downstream end of the reach)
plot(river)
points_colorscale(river$AG$X[samplingSites], river$AG$Y[samplingSites],
            data.frame(river$AG$A[samplingSites], 1.5*river$AG$A[samplingSites]),
            bg.range = c(0, 1e8), col.range = c(0, 1e8), 
            lwd = 4)# increase contour line so it's more visible
# specify same range for both bg.range and col.range
# otherwise they will be shown on different scale			


# 6) same as before, but show two different quantities: 
# drainage area (inside) vs. elevation (outside)
# use different color palettes and add legend for the second color palette
plot(river)
points_colorscale(river$AG$X[samplingSites], river$AG$Y[samplingSites],
            data.frame(river$AG$A[samplingSites], river$AG$Z[samplingSites]),
            col.palette = terrain.colors(1000),
            lwd = 4, add.col.legend = TRUE)

</code></pre>

<hr>
<h2 id='rast_riverweight'>Compute upstream-averaged raster</h2><span id='topic+rast_riverweight'></span>

<h3>Description</h3>

<p>Compute a raster file where each cell value is a weighted average of upstream values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rast_riverweight(x, river, 
                categorical = TRUE,
                weightNum = list(func = "exponential",
                                 mode = "flow-based",
                                 dist50 = 500,
                                 stream = FALSE,
                                 FA = FALSE),
                weightDen = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rast_riverweight_+3A_x">x</code></td>
<td>
<p><code>SpatRaster</code> object (obtained via <code>terra::rast</code>) containing categorical or continuous variables from which upstream averages are computed. Its coordinate system must be the same of <code>river</code>. Consider using <code>terra::project</code> to change
coordinate system.</p>
</td></tr> 
<tr><td><code id="rast_riverweight_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object generated via <code>aggregate_river</code>.</p>
</td></tr>
<tr><td><code id="rast_riverweight_+3A_categorical">categorical</code></td>
<td>
<p>Logical. Is the covariate categorical (e.g. land cover classes)? If <code>x</code> consists of several
layers, it is possible to specify <code>categorical</code> as a vector of logicals (one per each layer); alternatively, 
the single value of <code>categorical</code> is applied to all layers of <code>x</code>.</p>
</td></tr>
<tr><td><code id="rast_riverweight_+3A_weightnum">weightNum</code></td>
<td>
<p>List defining attributes of the numerator of the weighted average. See details. </p>
</td></tr>
<tr><td><code id="rast_riverweight_+3A_weightden">weightDen</code></td>
<td>
<p>List defining attributes of the denominator of the weighted average. If <code>NULL</code>, it is taken equal to <code>weightNum</code>. See details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lists <code>weightNum</code> and <code>weightDen</code> can include arguments <code>func</code>, <code>mode</code>, <code>stream</code>, <code>FA</code> and one between <code>dist50</code>, <code>distExponential</code>, <code>distCauchy</code>, <code>distLinear</code>, <code>expPower</code>. If not all of these arguments are provided, default values for <code>weightNum</code> are used (see examples).
</p>

<dl>
<dt><code>func</code></dt><dd><p>expresses the type of distance decay function used. It must be equal to one among <code>"exponential"</code>, <code>"cauchy"</code>, <code>"linear"</code>, <code>"power"</code>. Only for <code>weightDen</code>, the value <code>"unweighted"</code> is also allowed. Distance decay functions are defined as follows:
</p>

<dl>
<dt><code>"exponential"</code></dt><dd><p><code class="reqn">w(d)=\exp(1-d/d_E)</code></p>
</dd>
<dt><code>"cauchy"</code></dt><dd><p><code class="reqn">w(d)=d_C^2/(d^2 + d_C^2)</code></p>
</dd>
<dt><code>"linear"</code></dt><dd><p><code class="reqn">w(d)=\max(1-d/d_L, 0)</code></p>
</dd>
<dt><code>"power"</code></dt><dd><p><code class="reqn">w(d)=1/(1+d)^{e_P}</code></p>
</dd>
<dt><code>"unweighted"</code></dt><dd><p><code class="reqn">w(d)=1</code></p>
</dd>
</dl>

<p>where <code class="reqn">w</code> is the weight of a given source cell, <code class="reqn">d</code> the distance (see <code>mode</code>) from the source to the target cell, <code class="reqn">d_E</code>, <code class="reqn">d_C</code>, <code class="reqn">d_L</code> and <code class="reqn">e_P</code> are parameters. 
</p>
</dd>
<dt><code>mode</code></dt><dd><p>expresses the way upstream distances are computed. It must be equal to one between <code>"flow-based"</code> (distances computed along steepest descent paths) and <code>"euclidean"</code> (i.e., distances as the crow flies).</p>
</dd>
<dt><code>dist50</code>, <code>distExponential</code>, <code>distCauchy</code>, <code>distLinear</code>, <code>expPower</code></dt><dd><p>Parameters for the distance decay function expressed in <code>func</code>. Parameter <code>dist50</code> is the distance at which <code class="reqn">w = 0.5</code>, and it can be expressed for any choice of <code>func</code>. The other parameters are specific to a given type of <code>func</code>, and are equal to the respective parameters in the formulas above (i.e., <code>distExponential</code> = <code class="reqn">d_E</code>, <code>distCauchy</code> = <code class="reqn">d_C</code>, <code>distLinear</code> = <code class="reqn">d_L</code>, <code>expPower</code> = <code class="reqn">e_P</code>). All parameters but <code>expPower</code> are distances expressed in the same unit as <code>x</code> and <code>river</code>. <code>expPower</code> is a positive, dimensionless value; note that the value of <code>expPower</code> depends on the unit of <code>x</code> and <code>river</code> (e.g., if distances in <code>river</code> are expressed in km, the same <code>expPower</code> will yield a different distance decay function than if distances in <code>river</code> are in m).</p>
</dd>
<dt><code>stream</code></dt><dd><p>Logical. If <code>TRUE</code>, distances along the river network are not accounted for, that is, only distances (either along the steepest descent path or as the crow flies, depending on <code>mode</code>) from the source cell to the river network are considered. If <code>mode = "euclidean"</code>, this corresponds to the shortest planar distance between the source cell and any river network cell. This implies <code class="reqn">d = 0</code> for all source cells lying in the river network.</p>
</dd>
<dt><code>FA</code></dt><dd><p>Logical. Should flow-contributing areas (expressed as numbers of cells upstream of a source cell&ndash;including the source cell itself) be included as a multiplicative factor to <code class="reqn">w</code>?</p>
</dd>
</dl>

<p>To ensure computational efficiency for large and highly resolved rasters (note: it is the cell size of the <code>river</code> object that matters, not the resolution of <code>x</code>), it is recommended to use <code>func = "exponential"</code> (and/or <code>func = "exponential"</code> for <code>weightDen</code>) and <code>mode = "flow-based"</code>. Values of <code>stream</code> and <code>FA</code> do not affect computational speed.  
</p>


<h3>Value</h3>

<p>A <code>SpatRaster</code> object containing as many layers as the number of layers in <code>x</code>, each possibly multiplied by the number of unique categories featured in the layer (if the layer is categorical). If layer <code>y</code>  <code>x</code> is categorical, the corresponding layers in the output <code>SpatRaster</code> object are named <code>y_z</code>, where <code>z</code> is the value of a unique category in the original layer <code>y</code>. If layer <code>y</code> in <code>x</code> is continuous, the corresponding layer in the output <code>SpatRaster</code> object is also named <code>y</code>.
</p>
<p>The output <code>SpatRaster</code> object has the same extent and resolution (i.e., cell size) of the input <code>river</code> object.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate_river">aggregate_river</a></code>, <code><a href="terra.html#topic+rast">terra::rast</a></code>, <code><a href="terra.html#topic+project">terra::project</a></code>, <code><a href="#topic+get_riverweight">get_riverweight</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
data(wigger)

r1 &lt;- rast(system.file("extdata/landcover.tif", package = "rivnet")) 
# legend: 1-urban; 2-agriculture; 3-forest; 4-improductive

r.exp &lt;- rast_riverweight(r1, wigger)
plot(r.exp)


# unweighted denominator
r.unweighted &lt;- rast_riverweight(r1, wigger, 
					weightDen = list(func = "unweighted"))

# alternative distance decay functions (with same dist50)
# these take more time than the default func = "exponential"
r.cau &lt;- rast_riverweight(r1, wigger, 
						  weightNum = list(func = "cauchy"))
r.lin &lt;- rast_riverweight(r1, wigger, 
						  weightNum = list(func = "linear"))
r.pow &lt;- rast_riverweight(r1, wigger, 
						  weightNum = list(func = "power"))

# ignore distances on the river network
r.exp_S &lt;- rast_riverweight(r1, wigger, 
							weightNum = list(stream = TRUE))

# include flow accumulation in the weight
r.exp_FA &lt;- rast_riverweight(r1, wigger, 
							 weightNum = list(FA = TRUE))

# use Euclidean distances (takes more time)
# Euclidean distance from source to target
r.dO &lt;- rast_riverweight(r1, wigger, 
						 weightNum = list(mode = "euclidean"))
# Euclidean distance from source to river network
r.dOS &lt;- rast_riverweight(r1, wigger, 
						  weightNum = list(mode = "euclidean", 
										   stream = TRUE))

# specify exponential decay parameter in different ways
r.exp1 &lt;- rast_riverweight(r1, wigger, 
						   weightNum = list(dist50 = 1000*log(2)))
r.exp2 &lt;- rast_riverweight(r1, wigger, 
                           weightNum = list(distExponential = 1000))
identical(r.exp1, r.exp2)



</code></pre>

<hr>
<h2 id='river_to_AEM'>river_to_AEM</h2><span id='topic+river_to_AEM'></span>

<h3>Description</h3>

<p>Construct asymmetric eigenvector maps (AEM) from a river
</p>


<h3>Usage</h3>

<pre><code class='language-R'>river_to_AEM(river, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="river_to_AEM_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object.</p>
</td></tr>
<tr><td><code id="river_to_AEM_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>OCN_to_AEM</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an alias to <code><a href="OCNet.html#topic+OCN_to_AEM">OCNet::OCN_to_AEM</a></code>.
</p>


<h3>Value</h3>

<p>A <code>river</code> object. </p>


<h3>Examples</h3>

<pre><code class='language-R'>

 fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
 r &lt;- extract_river(outlet=c(637478, 237413),
	DEM = fp)
r &lt;- aggregate_river(r)
out.aem &lt;- river_to_AEM(r)


</code></pre>

<hr>
<h2 id='river_to_igraph'>river_to_igraph</h2><span id='topic+river_to_igraph'></span>

<h3>Description</h3>

<p>Transform a <code>river</code> in an <code>igraph</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>river_to_igraph(river, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="river_to_igraph_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object.</p>
</td></tr>
<tr><td><code id="river_to_igraph_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>OCN_to_igraph</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an alias to <code><a href="OCNet.html#topic+OCN_to_igraph">OCNet::OCN_to_igraph</a></code>.
</p>


<h3>Value</h3>

<p>An <code>igraph</code> object.</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
 r &lt;- extract_river(outlet=c(637478,237413),
	DEM=fp)
r &lt;- aggregate_river(r)	
g &lt;- river_to_igraph(r, level = "AG")
g

	
</code></pre>

<hr>
<h2 id='river_to_shapefile'>Export river network as shapefile</h2><span id='topic+river_to_shapefile'></span>

<h3>Description</h3>

<p>Export river network as shapefile. Reach attributes can be added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>river_to_shapefile(river, filename, atts = NULL, 
                    EPSG = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="river_to_shapefile_+3A_river">river</code></td>
<td>
<p><code>river</code> object. It must have been aggregated (via <code>aggregate_river</code>).</p>
</td></tr>
<tr><td><code id="river_to_shapefile_+3A_filename">filename</code></td>
<td>
<p>Character. Output file name. It must contain the &quot;.shp&quot; extension.</p>
</td></tr>
<tr><td><code id="river_to_shapefile_+3A_atts">atts</code></td>
<td>
<p>Attributes at AG level that can be exported. This should be a character vector, with entries 
corresponding to the names of fields within the <code>AG</code> sub-list of <code>river</code>. See example.</p>
</td></tr>
<tr><td><code id="river_to_shapefile_+3A_epsg">EPSG</code></td>
<td>
<p>EPSG code. Default is <code>NULL</code>, which does not produce a .prj file (i.e., the shapefile 
does not contain projection information).</p>
</td></tr>	
<tr><td><code id="river_to_shapefile_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>writeVector</code> (e.g., <code>overwrite = TRUE</code> 
allows overwriting an existing shapefile).</p>
</td></tr>						
</table>


<h3>Value</h3>

<p>No output is produced. This function is used for its side effetcs.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+writeVector">terra::writeVector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra) # to use "vect"
fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
river &lt;- extract_river(outlet=c(637478,237413), DEM=fp)
river &lt;- aggregate_river(river)

tmpname &lt;- paste0(tempfile(), ".shp")
river_to_shapefile(river, tmpname, overwrite = TRUE)

# read output
vv &lt;- vect(tmpname)
vv
plot(vv)


# add attributes to shapefile (drainage area, stream order)
river_to_shapefile(river, tmpname,
					atts = c("A", "streamOrder"), # same names as in river$AG
					overwrite = TRUE) 
vv &lt;- vect(tmpname)
vv

# add projection 
river_to_shapefile(river, tmpname, 
					EPSG = 21781, 
					overwrite = TRUE)
vv &lt;- vect(tmpname)
vv					



</code></pre>

<hr>
<h2 id='river_to_SSN'>Transform river into SSN object</h2><span id='topic+river_to_SSN'></span>

<h3>Description</h3>

<p>Transform a <code>river</code> in a <code>SpatialStreamNetwork</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>river_to_SSN(river, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="river_to_SSN_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object.</p>
</td></tr>
<tr><td><code id="river_to_SSN_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>OCN_to_SSN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an alias to <code><a href="OCNet.html#topic+OCN_to_SSN">OCNet::OCN_to_SSN</a></code>.
</p>


<h3>Value</h3>

<p>A <code>SpatialStreamNetwork</code> object if <code>importToR</code> is <code>TRUE</code>, otherwise <code>NULL</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
 r &lt;- extract_river(outlet=c(637478,237413),
	DEM=fp)
r &lt;- aggregate_river(r)	
s &lt;- river_to_SSN(r, level = "AG", obsSites = sample(r$AG$nNodes, 10),
	path = paste(tempdir(),"/river.ssn", sep = ""), importToR = TRUE)
plot(s)

	
</code></pre>

<hr>
<h2 id='river-class'>river class</h2><span id='topic+river'></span><span id='topic+river-class'></span><span id='topic+show+2Criver-method'></span><span id='topic++24+2Criver-method'></span><span id='topic++24+3C-+2Criver-method'></span><span id='topic+names+2Criver-method'></span><span id='topic++5B+5B+2Criver+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+5B+3C-+2Criver+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+5B+3C-+2Criver+2Ccharacter+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>A <code>river</code> object contains information on river attributes at different aggregation levels. It can represent a real river network 
(obtained via <code><a href="#topic+extract_river">extract_river</a></code>) or an optimal channel network (obtained via <code><a href="OCNet.html#topic+create_OCN">OCNet::create_OCN</a></code>).
</p>
<p>The content of a <code>river</code> object can be treated as a list, hence its objects and sublists can be accessed with both the <code>$</code> and <code>@</code> operators. 
</p>
<p>For information on the aggregation levels and on the content of a 
<code>river</code> object, see <code><a href="OCNet.html#topic+OCNet-package">OCNet::OCNet-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fp &lt;- system.file("extdata/wigger.tif", package="rivnet")
r &lt;- extract_river(outlet=c(637478,237413),
	DEM=fp)

show(r)
names(r)

# extract or replace parts of a river object
r$dimX
r@dimX
dim &lt;- r[["dimX"]]
r$dimX &lt;- 1
r[["dimX"]]
r[["dimX"]] &lt;- dim


</code></pre>

<hr>
<h2 id='wigger'>River Wigger</h2><span id='topic+wigger'></span>

<h3>Description</h3>

<p>It is built via 
</p>
<p><code>wigger &lt;- extract_river(outlet=c(637478,237413),
                    EPSG=21781, 
                    ext=c(6.2e5,6.6e5,2e5,2.5e5),
                    z=9)</code>
</p>
<p><code>wigger &lt;- aggregate_river(wigger, maxReachLength = 2500)</code>
</p>
<p><code>hydrodata &lt;- data.frame(data=c(8, 15), type=c("w","Q"), node=wigger$AG$outlet*c(1,1))</code>
</p>
<p><code>wigger &lt;- hydro_river(hydrodata, wigger)</code>
</p>
<p><code>r1 &lt;- rast(system.file("extdata/landcover.tif", package="rivnet"))</code>
</p>
<p><code>wigger &lt;- covariate_river(r1, wigger)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wigger)
</code></pre>


<h3>Format</h3>

<p>A <code>river</code> object. See <code><a href="#topic+extract_river">extract_river</a></code> documentation for details.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
