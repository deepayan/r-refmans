<!DOCTYPE html><html lang="en"><head><title>Help for package NLPwavelet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NLPwavelet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#NLPwavelet-package'>
<p>Bayesian Wavelet Analysis Using Non-local Priors</p></a></li>
<li><a href='#BNLPWA'><p>Bayesian Non-Local Prior-Based Wavelet Analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Wavelet Analysis Using Non-Local Priors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-09</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs Bayesian wavelet analysis using individual non-local priors as described in Sanyal &amp; Ferreira (2017) &lt;<a href="https://doi.org/10.1007%2Fs13571-016-0129-3">doi:10.1007/s13571-016-0129-3</a>&gt; and non-local prior mixtures as described in Sanyal (2025) &lt;<a href="https://doi.org/10.48550%2FarXiv.2501.18134">doi:10.48550/arXiv.2501.18134</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.14), wavethresh</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nilotpalsanyal.github.io/NLPwavelet/">https://nilotpalsanyal.github.io/NLPwavelet/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nilotpalsanyal/NLPwavelet/issues">https://github.com/nilotpalsanyal/NLPwavelet/issues</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-11 22:59:56 UTC; nsanyal</td>
</tr>
<tr>
<td>Author:</td>
<td>Nilotpal Sanyal [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nilotpal Sanyal &lt;nsanyal@utep.edu&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-13 10:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='NLPwavelet-package'>
Bayesian Wavelet Analysis Using Non-local Priors
</h2><span id='topic+NLPwavelet-package'></span><span id='topic+NLPwavelet'></span>

<h3>Description</h3>

<p>Performs Bayesian wavelet analysis using individual non-local priors as described in Sanyal &amp; Ferreira (2017) &lt;DOI:10.1007/s13571-016-0129-3&gt; and non-local prior mixtures as described in Sanyal (2025) &lt;DOI:10.48550/arXiv.2501.18134&gt;.
</p>


<h3>Details</h3>

<p>The main function is <code><a href="#topic+BNLPWA">BNLPWA</a></code>, which has arguments for specifying analysis using individual non-local priors or non-local prior mixtures and various hyperparameter specifications for the wavelet coefficients and scale parameters of the non-local priors. See the manual of <code><a href="#topic+BNLPWA">BNLPWA</a></code> for examples.
</p>


<h3>Author(s)</h3>

<p>Nilotpal Sanyal &lt;nsanyal@utep.edu&gt;
</p>
<p>Maintainer: Nilotpal Sanyal &lt;nsanyal@utep.edu&gt;
</p>


<h3>References</h3>

<p>Sanyal, Nilotpal. &quot;Nonlocal prior mixture-based Bayesian wavelet regression.&quot; arXiv preprint arXiv:2501.18134 (2025).
</p>
<p>Sanyal, Nilotpal, and Marco AR Ferreira. &quot;Bayesian wavelet analysis using nonlocal priors with an application to FMRI analysis.&quot; Sankhya B 79.2 (2017): 361-388.
</p>

<hr>
<h2 id='BNLPWA'>Bayesian Non-Local Prior-Based Wavelet Analysis</h2><span id='topic+BNLPWA'></span>

<h3>Description</h3>

<p><code>BNLPWA</code> is the main function of this package that performs Bayesian wavelet analysis using individual non-local priors as described in Sanyal &amp; Ferreira (2017) and non-local prior mixtures as described in Sanyal (2025). It currently works with one-dimensional data. The usage is described below.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BNLPWA(
  data, 
  func=NULL, 
  method=c("mixture","mom","imom"), 
  mixprob_dist=c("logit","genlogit","hypsec","gennormal"), 
  scale_dist=c("polynom","doubleexp"),
  r=1, 
  nu=1, 
  wave.family="DaubLeAsymm", 
  filter.number=6, 
  bc="periodic"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BNLPWA_+3A_data">data</code></td>
<td>
<p>Vector of noisy data.</p>
</td></tr>
<tr><td><code id="BNLPWA_+3A_func">func</code></td>
<td>
<p>Vector of true functional values. NULL by default. If available, they are used to compute and return mean squared error (MSE) of the estimates.</p>
</td></tr>
<tr><td><code id="BNLPWA_+3A_method">method</code></td>
<td>
<p>&quot;mixture&quot; for non-local prior mixture-based analysis, &quot;mom&quot; or &quot;imom&quot; for individual non-local prior-based analysis.</p>
</td></tr>
<tr><td><code id="BNLPWA_+3A_mixprob_dist">mixprob_dist</code></td>
<td>
<p>Specification for the mixture probabilities of the spike-and-slab prior. Equations given in the Details.</p>
</td></tr>
<tr><td><code id="BNLPWA_+3A_scale_dist">scale_dist</code></td>
<td>
<p>Specification for the scale parameters of the non-local priors. Equations given in the Details.</p>
</td></tr>
<tr><td><code id="BNLPWA_+3A_r">r</code></td>
<td>
<p>Integer specifying a) the order of the MOM prior or the shape parameter of the IMOM prior for individual non-local prior-based analysis, or b) the order of the MOM prior for non-local prior mixture-based analysis.</p>
</td></tr>
<tr><td><code id="BNLPWA_+3A_nu">nu</code></td>
<td>
<p>Integer specifying the shape parameter of the IMOM prior for non-local prior mixture-based analysis. Not used for individual non-local prior-based analysis.</p>
</td></tr>
<tr><td><code id="BNLPWA_+3A_wave.family">wave.family</code></td>
<td>
<p>The family of wavelets to use - &quot;DaubExPhase&quot; or &quot;DaubLeAsymm&quot;. Default is &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="BNLPWA_+3A_filter.number">filter.number</code></td>
<td>
<p>The number of vanishing moments of the wavelet. Default is 6.</p>
</td></tr>
<tr><td><code id="BNLPWA_+3A_bc">bc</code></td>
<td>
<p>The boundary condition to use - &quot;periodic&quot; or &quot;symmetric&quot;. Default is &quot;periodic&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Spike-and-slab prior for the wavelet coefficients</h4>

<p>For individual MOM prior-based analysis, the spike-and-slab prior for the wavelet coefficient <code class="reqn">d_{lj}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn"> d_{lj} \mid \gamma_l, \tau_l, \sigma^2, r \sim \gamma_l \; \text{MOM}(\tau_l, \sigma^2, r) + (1-\gamma_l) \; \delta(0), </code>
</p>

<p>for individual IMOM prior-based analysis, the spike-and-slab prior for the wavelet coefficient <code class="reqn">d_{lj}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn"> d_{lj} \mid \gamma_l, \tau_l, \sigma^2, r \sim \gamma_l \; \text{IMOM}(\tau_l, \sigma^2, r) + (1-\gamma_l) \; \delta(0), </code>
</p>

<p>and for non-local prior mixture-based analysis, the spike-and-slab prior for the wavelet coefficient <code class="reqn">d_{lj}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn"> d_{lj} \mid \gamma_l^{(1)}, \gamma_l^{(2)}, \tau_l^{(1)}, \tau_l^{(2)}, \sigma^2, r, \nu \sim \gamma_l^{(1)} \; \text{MOM}(\tau_l^{(1)}, r, \sigma^2) + (1-\gamma_l^{(1)})\gamma_l^{(2)} \;\text{IMOM}(\tau_l^{(2)}, \nu, \sigma^2) + (1-\gamma_l^{(1)})(1-\gamma_l^{(2)}) \; \delta(0), </code>
</p>

<p>where the density of the MOM prior is
</p>
<p style="text-align: center;"><code class="reqn"> mom(d_{lj} | \tau_{l}^{(1)},r,\sigma^{2}) = \widetilde{M}_{r} \left(\tau_{l}^{(1)}\sigma^{2}\right)^{-r-1/2} d_{lj}^{2r} \exp\left(-\frac{d_{lj}^{2}}{2\tau_{l}^{(1)}\sigma^{2}}\right), \quad r&gt;1, \tau_{l}^{(1)}&gt;0, \widetilde{M}_{r} = \frac{(2\pi)^{-1/2}}{(2r-1)!!} </code>
</p>

<p>and the density of the IMOM prior is
</p>
<p style="text-align: center;"><code class="reqn"> imom(d_{lj} | \tau_{l}^{(2)},\nu,\sigma^{2}) = \frac{\left(\tau_{l}^{(2)}\sigma^{2}\right)^{\nu/2}}{\Gamma(\nu/2)} |d_{lj}|^{-\nu-1} \exp\left( -\frac{\tau_{l}^{(2)}\sigma^{2}}{d_{lj}^{2}} \right),\quad \nu&gt;1, \tau_{l}^{(2)}&gt;0. </code>
</p>
 



<h4>Hyperparameter specifications</h4>

<p>For non-local prior mixture-based analysis, the available specifications for the mixture probabilities are
</p>

<ol>
<li> <p><b>Logit:</b> 
</p>
<p style="text-align: center;"><code class="reqn">
        \gamma_l^{(1)} = \frac{\exp(\theta^{\gamma}_{1} - \theta^{\gamma}_{2}l)}
        {1 + \exp(\theta^{\gamma}_{1} - \theta^{\gamma}_{2}l)}, \quad
        \theta^{\gamma}_{1} \in \mathbb{R}, \; \theta^{\gamma}_{2} &gt; 0
      </code>
</p>

<p style="text-align: center;"><code class="reqn">
        \gamma_l^{(2)} = \frac{\exp(\theta^{\gamma}_{3} - \theta^{\gamma}_{4}l)}
        {1 + \exp(\theta^{\gamma}_{3} - \theta^{\gamma}_{4}l)}, \quad
        \theta^{\gamma}_{3} \in \mathbb{R}, \; \theta^{\gamma}_{4} &gt; 0
      </code>
</p>

</li>
<li> <p><b>Generalized logit or Richards:</b> 
</p>
<p style="text-align: center;"><code class="reqn">
        \gamma_l^{(1)} = \frac{1}{[1 + \exp\{-(\theta^{\gamma}_{1} - \theta^{\gamma}_{2}l)\}]^{\theta^{\gamma}_{3}}}, \quad 
        \theta^{\gamma}_{1} \in \mathbb{R}, \; \theta^{\gamma}_{2},\theta^{\gamma}_{3} &gt; 0 
      </code>
</p>

<p style="text-align: center;"><code class="reqn">
        \gamma_l^{(2)} = \frac{1}{[1 + \exp\{-(\theta^{\gamma}_{4} - \theta^{\gamma}_{5}l)\}]^{\theta^{\gamma}_{6}}}, \quad
        \theta^{\gamma}_{4} \in \mathbb{R}, \; \theta^{\gamma}_{5},\theta^{\gamma}_{6} &gt; 0;
      </code>
</p>

</li>
<li> <p><b>Hyperbolic secant:</b>
</p>
<p style="text-align: center;"><code class="reqn">
        \gamma_l^{(1)} = \frac{2}{\pi} \arctan\left[\exp\left(\frac{\pi}{2} \left(\theta^{\gamma}_{1} - \theta^{\gamma}_{2}l\right)\right)\right], \quad
        \theta^{\gamma}_{1} \in \mathbb{R}, \; \theta^{\gamma}_{2} &gt; 0
      </code>
</p>

<p style="text-align: center;"><code class="reqn">
        \gamma_l^{(2)} = \frac{2}{\pi} \arctan\left[\exp\left(\frac{\pi}{2} \left(\theta^{\gamma}_{3} - \theta^{\gamma}_{4}l\right)\right)\right], \quad
        \theta^{\gamma}_{3} \in \mathbb{R}, \; \theta^{\gamma}_{4} &gt; 0
      </code>
</p>

</li>
<li> <p><b>Generalized normal:</b>
</p>
<p style="text-align: center;"><code class="reqn">
        \gamma_l^{(1)} = \frac{1}{2} + \text{sign}(\theta^{\gamma}_{1}-l) \frac{1}{2\Gamma(1/\theta^{\gamma}_{2})} 
        \gamma\left(1/\theta^{\gamma}_{2} ,\left|\frac{\theta^{\gamma}_{1}-l}{\theta^{\gamma}_{3}}\right|^{\theta^{\gamma}_{2}}\right), \quad 
        \theta^{\gamma}_{1} \in \mathbb{R}, \; \theta^{\gamma}_{2},\theta^{\gamma}_{3} &gt; 0
      </code>
</p>

<p style="text-align: center;"><code class="reqn">
        \gamma_l^{(2)} = \frac{1}{2} + \text{sign}(\theta^{\gamma}_{4}-l) \frac{1}{2\Gamma(1/\theta^{\gamma}_{5})} 
        \gamma\left(1/\theta^{\gamma}_{5} ,\left|\frac{\theta^{\gamma}_{4}-l}{\theta^{\gamma}_{6}}\right|^{\theta^{\gamma}_{5}}\right), \quad
        \theta^{\gamma}_{4} \in \mathbb{R}, \; \theta^{\gamma}_{5},\theta^{\gamma}_{6} &gt; 0
      </code>
</p>

</li></ol>

<p>For individual non-local prior based analysis, <code class="reqn">gamma_l</code> is defined likewise. 
</p>
<p>For non-local prior mixture-based analysis, the available specifications for the scale parameters are
</p>

<ol>
<li> <p><b>Polynomial decay:</b>
</p>
<p style="text-align: center;"><code class="reqn">
        \tau_{l}^{(1)} = \theta^{\tau}_{1} l^{-\theta^{\tau}_{2}}, \quad \theta^{\tau}_{1},\theta^{\tau}_{2} &gt; 0
      </code>
</p>

<p style="text-align: center;"><code class="reqn">
        \tau_{l}^{(2)} = \theta^{\tau}_{3} l^{-\theta^{\tau}_{4}}, \quad \theta^{\tau}_{3},\theta^{\tau}_{4} &gt; 0
      </code>
</p>

</li>
<li> <p><b>Double-exponential decay:</b>
</p>
<p style="text-align: center;"><code class="reqn">
        \tau_{l}^{(1)} = \theta^{\tau}_{1} \exp(-\theta^{\tau}_{2} l) + \theta^{\tau}_{3} \exp(-\theta^{\tau}_{4} l), \quad
        \theta^{\tau}_{1},\theta^{\tau}_{2},\theta^{\tau}_{3},\theta^{\tau}_{4} &gt; 0
      </code>
</p>

<p style="text-align: center;"><code class="reqn">
        \tau_{l}^{(2)} = \theta^{\tau}_{5} \exp(-\theta^{\tau}_{6} l) + \theta^{\tau}_{7} \exp(-\theta^{\tau}_{8} l), \quad
        \theta^{\tau}_{5},\theta^{\tau}_{6},\theta^{\tau}_{7},\theta^{\tau}_{8} &gt; 0
      </code>
</p>

</li></ol>

<p>For individual non-local prior based analysis, <code class="reqn">tau_l</code> is defined likewise.
</p>

<p>Note: The wavelet computations are performed by using the R package <span class="pkg">wavethresh</span>.
</p>


<h3>Value</h3>

<p>A list containing the following.
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The data vector.</p>
</td></tr>
<tr><td><code>func.post.mean</code></td>
<td>
<p>Posterior estimate (mean) of the function that generated the data.</p>
</td></tr>
<tr><td><code>wavelet.empirical</code></td>
<td>
<p>Empirical wavelet coefficients obtained by wavelet transformation of the data.</p>
</td></tr>
<tr><td><code>wavelet.post.mean</code></td>
<td>
<p>Posterior estimate (mean) of the true wavelet coefficients obtained by wavelet transformation of the underlying function. </p>
</td></tr>
<tr><td><code>hyperparam</code></td>
<td>
<p>Estimates of the hyperparameters that specify the spike-and-slab prior for the wavelet coefficients.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimate of the standard deviation of the error.</p>
</td></tr>
<tr><td><code>MSE.mean</code></td>
<td>
<p>Mean squared error of the estimates, computable only if true functional values are supplied in the input argument <code>func</code>. </p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p>System run-time of the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nilotpal Sanyal &lt;nsanyal@utep.edu&gt;
</p>
<p>Maintainer: Nilotpal Sanyal &lt;nsanyal@utep.edu&gt;
</p>


<h3>References</h3>

<p>Sanyal, Nilotpal. &quot;Nonlocal prior mixture-based Bayesian wavelet regression.&quot; arXiv preprint arXiv:2501.18134 (2025).
</p>
<p>Sanyal, Nilotpal, and Marco AR Ferreira. &quot;Bayesian wavelet analysis using nonlocal priors with an application to FMRI analysis.&quot; Sankhya B 79.2 (2017): 361-388.
</p>


<h3>See Also</h3>

<p><code><a href="wavethresh.html#topic+wd">wd</a></code>, <code><a href="wavethresh.html#topic+wr">wr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Using the well-known Doppler function to 
  # illustrate the use of the function BNLPWA

  # set seed for reproducibility
  set.seed(1)

  # Define the doppler function
  doppler &lt;- function(x) { 
    sqrt(x * (1 - x)) * sin((2 * pi * 1.05) / (x + 0.05)) 
  }

  # Generate true values over a grid of length an integer power of 2 
  n &lt;- 128  # Number of points
  x &lt;- seq(0, 1, length.out = n)
  true_signal &lt;- doppler(x) 

  # Add noise to generate data
  sigma &lt;- 0.2  # Noise level
  y &lt;- true_signal + rnorm(n, mean = 0, sd = sigma)

  # BNLPWA analysis based on MOM prior using logit specification
  # for the mixture probabilities and polynomial decay
  # specification for the scale parameter
  fit_mom &lt;- BNLPWA(data=y, func=true_signal, r=1, wave.family=
    "DaubLeAsymm", filter.number=6, bc="periodic", method="mom", 
    mixprob_dist="logit", scale_dist="polynom")

  plot(y,type="l",col="grey") # plot of data
  lines(fit_mom$func.post.mean,col="blue") # plot of posterior 
  # smoothed estimates
  fit_mom$MSE.mean

  
    # BNLPWA analysis using non-local prior mixtures using generalized 
    # logit (Richard's) specification for the mixture probabilities and 
    # double exponential decay specification for the scale parameter
    fit_mixture &lt;- BNLPWA(data=y, func=true_signal, r=1, nu=1, wave.family=
      "DaubLeAsymm", filter.number=6, bc="periodic", method="mixture", 
      mixprob_dist="genlogit", scale_dist="doubleexp")

    plot(y,type="l",col="grey") # plot of data
    lines(fit_mixture$func.post.mean,col="blue") # plot of posterior 
    # smoothed estimates
    fit_mixture$MSE.mean
  
  
  # Compare with other wavelet methods
  library(wavethresh)
  wd &lt;- wd(y, family="DaubLeAsymm", filter.number=6, bc="periodic")  # Wavelet decomposition  
  
  wd_thresh_universal &lt;- threshold(wd, policy="universal", type="hard")
  fit_universal &lt;- wr(wd_thresh_universal)
  MSE_universal &lt;- mean((true_signal-fit_universal)^2)
  MSE_universal

  wd_thresh_sure &lt;- threshold(wd, policy="sure", type="soft")
  fit_sure &lt;- wr(wd_thresh_sure)
  MSE_sure &lt;- mean((true_signal-fit_sure)^2)
  MSE_sure

  wd_thresh_BayesThresh &lt;- threshold(wd, policy="BayesThresh", type="hard")
  fit_BayesThresh &lt;- wr(wd_thresh_BayesThresh)
  MSE_BayesThresh &lt;- mean((true_signal-fit_BayesThresh)^2)
  MSE_BayesThresh

  wd_thresh_cv &lt;- threshold(wd, policy="cv", type="hard")
  fit_cv &lt;- wr(wd_thresh_cv)
  MSE_cv &lt;- mean((true_signal-fit_cv)^2)
  MSE_cv

  wd_thresh_fdr &lt;- threshold(wd, policy="fdr", type="hard")
  fit_fdr &lt;- wr(wd_thresh_fdr)
  MSE_fdr &lt;- mean((true_signal-fit_fdr)^2)
  MSE_fdr

  # Compare with non-wavelet methods
      # Kernel smoothing
  fit_ksmooth &lt;- ksmooth(x, y, kernel="normal", bandwidth=0.05)
  MSE_ksmooth &lt;- mean((true_signal-fit_ksmooth$y)^2)
  MSE_ksmooth
      # LOESS smoothing
  fit_loess &lt;- loess(y ~ x, span=0.1)  # Adjust span for more or less smoothing
  MSE_loess &lt;- mean((true_signal-predict(fit_loess))^2)
  MSE_loess
      # Cubic spline smoothing
  spline_fit &lt;- smooth.spline(x, y, spar=0.5)  # Adjust spar for smoothness
  MSE_spline &lt;- mean((true_signal-spline_fit$y)^2)
  MSE_spline
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
