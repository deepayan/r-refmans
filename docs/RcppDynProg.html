<!DOCTYPE html><html><head><title>Help for package RcppDynProg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RcppDynProg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RcppDynProg-package'><p>RcppDynProg</p></a></li>
<li><a href='#all_partitions'><p>Build all partitions into intervals.</p></a></li>
<li><a href='#const_cost'><p>const_cost</p></a></li>
<li><a href='#const_cost_logistic'><p>const_cost_logistic</p></a></li>
<li><a href='#const_costs'><p>const_costs</p></a></li>
<li><a href='#const_costs_logistic'><p>const_costs_logistic</p></a></li>
<li><a href='#lin_cost'><p>lin_cost</p></a></li>
<li><a href='#lin_cost_logistic'><p>lin_cost_logistic logistic deviance pricing</p></a></li>
<li><a href='#lin_costs'><p>lin_costs</p></a></li>
<li><a href='#lin_costs_logistic'><p>lin_costs_logistic deviance costs.</p></a></li>
<li><a href='#logistic_fits'><p>In sample logistic predictions (in link space).</p></a></li>
<li><a href='#logistic_solve1'><p>logistic_fit</p></a></li>
<li><a href='#piecewise_constant'><p>Piecewise constant fit.</p></a></li>
<li><a href='#piecewise_constant_coder'><p>Piecewise constant fit coder factory.</p></a></li>
<li><a href='#piecewise_linear'><p>Piecewise linear fit.</p></a></li>
<li><a href='#piecewise_linear_coder'><p>Piecewise linear fit coder factory.</p></a></li>
<li><a href='#score_solution'><p>compute the price of a partition solution (and check is valid).</p></a></li>
<li><a href='#solve_for_partition'><p>Solve for a piecewise linear partiton.</p></a></li>
<li><a href='#solve_for_partitionc'><p>Solve for a piecewise constant partiton.</p></a></li>
<li><a href='#solve_interval_partition'><p>solve_interval_partition interval partition problem.</p></a></li>
<li><a href='#solve_interval_partition_k'><p>solve_interval_partition interval partition problem with a bound on number of steps.</p></a></li>
<li><a href='#solve_interval_partition_no_k'><p>solve_interval_partition interval partition problem, no boun on the number of steps.</p></a></li>
<li><a href='#solve_interval_partition_R'><p>solve_interval_partition (R version)</p></a></li>
<li><a href='#summarize_input'><p>Summarize data (for debugging).</p></a></li>
<li><a href='#xlin_fits'><p>xlin_fits</p></a></li>
<li><a href='#xlin_fits_lm'><p>xlin_fits_R</p></a></li>
<li><a href='#xlin_fits_R'><p>xlin_fits_R</p></a></li>
<li><a href='#xlin_fits_V'><p>xlin_fits_R</p></a></li>
<li><a href='#xlin_pfits'><p>xlin_pfits</p></a></li>
<li><a href='#xlogistic_fits'><p>Out of sample logistic predictions (in link space).</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'Rcpp' Dynamic Programming</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/WinVector/RcppDynProg/">https://github.com/WinVector/RcppDynProg/</a>,
<a href="https://winvector.github.io/RcppDynProg/">https://winvector.github.io/RcppDynProg/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/WinVector/RcppDynProg/issues">https://github.com/WinVector/RcppDynProg/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Mount &lt;jmount@win-vector.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Dynamic Programming implemented in 'Rcpp'.  Includes example partition and out of sample fitting applications.  Also supplies additional custom coders for the 'vtreat' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>wrapr (&ge; 2.0.4), Rcpp (&ge; 1.0.0), utils, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-20 00:28:18 UTC; johnmount</td>
</tr>
<tr>
<td>Author:</td>
<td>John Mount [aut, cre],
  Nina Zumel [aut],
  Win-Vector LLC [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-20 02:32:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='RcppDynProg-package'>RcppDynProg</h2><span id='topic+RcppDynProg'></span><span id='topic+RcppDynProg-package'></span>

<h3>Description</h3>

<p>Rcpp dynamic programming solutions for partitioning and machine learning problems.
Includes out of sample fitting applications.  
Also supplies additional custom coders for the vtreat package.
Please see <a href="https://github.com/WinVector/RcppDynProg">https://github.com/WinVector/RcppDynProg</a> for details.
</p>


<h3>Author(s)</h3>

<p>John Mount
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/WinVector/RcppDynProg/">https://github.com/WinVector/RcppDynProg/</a>
</p>
</li>
<li> <p><a href="https://winvector.github.io/RcppDynProg/">https://winvector.github.io/RcppDynProg/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/WinVector/RcppDynProg/issues">https://github.com/WinVector/RcppDynProg/issues</a>
</p>
</li></ul>


<hr>
<h2 id='all_partitions'>Build all partitions into intervals.</h2><span id='topic+all_partitions'></span>

<h3>Description</h3>

<p>Build all partitions into intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_partitions(n, kmax = n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_partitions_+3A_n">n</code></td>
<td>
<p>integer, sequence lenght to choose from.</p>
</td></tr>
<tr><td><code id="all_partitions_+3A_kmax">kmax</code></td>
<td>
<p>int, maximum number of segments in solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of all partitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
all_partitions(4, 2)

</code></pre>

<hr>
<h2 id='const_cost'>const_cost</h2><span id='topic+const_cost'></span>

<h3>Description</h3>

<p>Calculate out of sample total square error cost of using mean of points to estimate other points in interval.
Zero indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>const_cost(y, w, min_seg, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="const_cost_+3A_y">y</code></td>
<td>
<p>NumericVector, values to group in order.</p>
</td></tr>
<tr><td><code id="const_cost_+3A_w">w</code></td>
<td>
<p>NumericVector, weights.</p>
</td></tr>
<tr><td><code id="const_cost_+3A_min_seg">min_seg</code></td>
<td>
<p>positive integer, minimum segment size (&gt;=1).</p>
</td></tr>
<tr><td><code id="const_cost_+3A_i">i</code></td>
<td>
<p>integer, first index (inclusive).</p>
</td></tr>
<tr><td><code id="const_cost_+3A_j">j</code></td>
<td>
<p>integer, j&gt;=i last index (inclusive);</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar, const cost of [i,...,j] interval (inclusive).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
const_cost(c(1, 1, 2, 2), c(1, 1, 1, 1), 1, 0, 3)

</code></pre>

<hr>
<h2 id='const_cost_logistic'>const_cost_logistic</h2><span id='topic+const_cost_logistic'></span>

<h3>Description</h3>

<p>Calculate logistic cost of using mean of points to estimate other points in interval.
Zero indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>const_cost_logistic(y, w, min_seg, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="const_cost_logistic_+3A_y">y</code></td>
<td>
<p>NumericVector, 0/1 values to group in order (should be in interval [0,1]).</p>
</td></tr>
<tr><td><code id="const_cost_logistic_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (should be positive).</p>
</td></tr>
<tr><td><code id="const_cost_logistic_+3A_min_seg">min_seg</code></td>
<td>
<p>positive integer, minimum segment size (&gt;=1).</p>
</td></tr>
<tr><td><code id="const_cost_logistic_+3A_i">i</code></td>
<td>
<p>integer, first index (inclusive).</p>
</td></tr>
<tr><td><code id="const_cost_logistic_+3A_j">j</code></td>
<td>
<p>integer, j&gt;=i last index (inclusive);</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar, const cost of [i,...,j] interval (inclusive).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
const_cost_logistic(c(0.1, 0.1, 0.2, 0.2), c(1, 1, 1, 1), 1, 0, 3)

</code></pre>

<hr>
<h2 id='const_costs'>const_costs</h2><span id='topic+const_costs'></span>

<h3>Description</h3>

<p>Built matrix of total out of sample interval square error costs for held-out means.
One indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>const_costs(y, w, min_seg, indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="const_costs_+3A_y">y</code></td>
<td>
<p>NumericVector, values to group in order.</p>
</td></tr>
<tr><td><code id="const_costs_+3A_w">w</code></td>
<td>
<p>NumericVector, weights.</p>
</td></tr>
<tr><td><code id="const_costs_+3A_min_seg">min_seg</code></td>
<td>
<p>positive integer, minimum segment size (&gt;=1).</p>
</td></tr>
<tr><td><code id="const_costs_+3A_indices">indices</code></td>
<td>
<p>IntegerVector, order list of indices to pair.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xcosts NumericMatix, for j&gt;=i xcosts(i,j) is the cost of partition element [i,...,j] (inclusive).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
const_costs(c(1, 1, 2, 2), c(1, 1, 1, 1), 1, 1:4)

</code></pre>

<hr>
<h2 id='const_costs_logistic'>const_costs_logistic</h2><span id='topic+const_costs_logistic'></span>

<h3>Description</h3>

<p>Built matrix of interval logistic costs for held-out means.
One indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>const_costs_logistic(y, w, min_seg, indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="const_costs_logistic_+3A_y">y</code></td>
<td>
<p>NumericVector, 0/1 values to group in order (should be in interval [0,1]).</p>
</td></tr>
<tr><td><code id="const_costs_logistic_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (should be positive).</p>
</td></tr>
<tr><td><code id="const_costs_logistic_+3A_min_seg">min_seg</code></td>
<td>
<p>positive integer, minimum segment size (&gt;=1).</p>
</td></tr>
<tr><td><code id="const_costs_logistic_+3A_indices">indices</code></td>
<td>
<p>IntegerVector, order list of indices to pair.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xcosts NumericMatix, for j&gt;=i xcosts(i,j) is the cost of partition element [i,...,j] (inclusive).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
const_costs_logistic(c(0.1, 0.1, 0.2, 0.2), c(1, 1, 1, 1), 1, 1:4)

</code></pre>

<hr>
<h2 id='lin_cost'>lin_cost</h2><span id='topic+lin_cost'></span>

<h3>Description</h3>

<p>Calculate cost of using linear model fit on points to estimate other points in the interval.
Zero indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin_cost(x, y, w, min_seg, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin_cost_+3A_x">x</code></td>
<td>
<p>NumericVector, x-coords of values to group.</p>
</td></tr>
<tr><td><code id="lin_cost_+3A_y">y</code></td>
<td>
<p>NumericVector, values to group in order.</p>
</td></tr>
<tr><td><code id="lin_cost_+3A_w">w</code></td>
<td>
<p>NumericVector, weights.</p>
</td></tr>
<tr><td><code id="lin_cost_+3A_min_seg">min_seg</code></td>
<td>
<p>positive integer, minimum segment size (&gt;=1).</p>
</td></tr>
<tr><td><code id="lin_cost_+3A_i">i</code></td>
<td>
<p>integer, first index (inclusive).</p>
</td></tr>
<tr><td><code id="lin_cost_+3A_j">j</code></td>
<td>
<p>integer, j&gt;=i last index (inclusive);</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar, linear cost of [i,...,j] interval (inclusive).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lin_cost(c(1, 2, 3, 4), c(1, 2, 2, 1), c(1, 1, 1, 1), 1, 0, 3)

</code></pre>

<hr>
<h2 id='lin_cost_logistic'>lin_cost_logistic logistic deviance pricing</h2><span id='topic+lin_cost_logistic'></span>

<h3>Description</h3>

<p>Calculate deviance cost of using logistic model fit on points to estimate other points in the interval.
Fits are evaluated in-sample.
Zero indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin_cost_logistic(x, y, w, min_seg, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin_cost_logistic_+3A_x">x</code></td>
<td>
<p>NumericVector, x-coords of values to group.</p>
</td></tr>
<tr><td><code id="lin_cost_logistic_+3A_y">y</code></td>
<td>
<p>NumericVector, values to group in order (should be in interval [0,1]).</p>
</td></tr>
<tr><td><code id="lin_cost_logistic_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (positive).</p>
</td></tr>
<tr><td><code id="lin_cost_logistic_+3A_min_seg">min_seg</code></td>
<td>
<p>positive integer, minimum segment size (&gt;=1).</p>
</td></tr>
<tr><td><code id="lin_cost_logistic_+3A_i">i</code></td>
<td>
<p>integer, first index (inclusive).</p>
</td></tr>
<tr><td><code id="lin_cost_logistic_+3A_j">j</code></td>
<td>
<p>integer, j&gt;=i last index (inclusive);</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar, linear cost of [i,...,j] interval (inclusive).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lin_cost_logistic(c(1, 2, 3, 4, 5, 6, 7), c(0, 0, 1, 0, 1, 1, 0), c(1, 1, 1, 1, 1, 1, 1), 3, 0, 6)

</code></pre>

<hr>
<h2 id='lin_costs'>lin_costs</h2><span id='topic+lin_costs'></span>

<h3>Description</h3>

<p>Built matrix of interval costs for held-out linear models.
One indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin_costs(x, y, w, min_seg, indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin_costs_+3A_x">x</code></td>
<td>
<p>NumericVector, x-coords of values to group.</p>
</td></tr>
<tr><td><code id="lin_costs_+3A_y">y</code></td>
<td>
<p>NumericVector, values to group in order.</p>
</td></tr>
<tr><td><code id="lin_costs_+3A_w">w</code></td>
<td>
<p>NumericVector, weights.</p>
</td></tr>
<tr><td><code id="lin_costs_+3A_min_seg">min_seg</code></td>
<td>
<p>positive integer, minimum segment size (&gt;=1).</p>
</td></tr>
<tr><td><code id="lin_costs_+3A_indices">indices</code></td>
<td>
<p>IntegerVector, ordered list of indices to pair.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xcosts NumericMatix, for j&gt;=i xcosts(i,j) is the cost of partition element [i,...,j] (inclusive).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lin_costs(c(1, 2, 3, 4), c(1, 2, 2, 1), c(1, 1, 1, 1), 1, 1:4)

</code></pre>

<hr>
<h2 id='lin_costs_logistic'>lin_costs_logistic deviance costs.</h2><span id='topic+lin_costs_logistic'></span>

<h3>Description</h3>

<p>Built matrix of interval deviance costs for held-out logistic models.
Fits are evaluated in-sample.
One indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin_costs_logistic(x, y, w, min_seg, indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin_costs_logistic_+3A_x">x</code></td>
<td>
<p>NumericVector, x-coords of values to group.</p>
</td></tr>
<tr><td><code id="lin_costs_logistic_+3A_y">y</code></td>
<td>
<p>NumericVector, values to group in order (should be in interval [0,1]).</p>
</td></tr>
<tr><td><code id="lin_costs_logistic_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (should be positive).</p>
</td></tr>
<tr><td><code id="lin_costs_logistic_+3A_min_seg">min_seg</code></td>
<td>
<p>positive integer, minimum segment size (&gt;=1).</p>
</td></tr>
<tr><td><code id="lin_costs_logistic_+3A_indices">indices</code></td>
<td>
<p>IntegerVector, ordered list of indices to pair.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xcosts NumericMatix, for j&gt;=i xcosts(i,j) is the cost of partition element [i,...,j] (inclusive).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lin_costs_logistic(c(1, 2, 3, 4, 5, 6, 7), c(0, 0, 1, 0, 1, 1, 0), c(1, 1, 1, 1, 1, 1, 1), 3, 1:7)

</code></pre>

<hr>
<h2 id='logistic_fits'>In sample logistic predictions (in link space).</h2><span id='topic+logistic_fits'></span>

<h3>Description</h3>

<p>logistic regression predictions.
Zero indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic_fits(x, y, w, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic_fits_+3A_x">x</code></td>
<td>
<p>NumericVector, expanatory variable.</p>
</td></tr>
<tr><td><code id="logistic_fits_+3A_y">y</code></td>
<td>
<p>NumericVector, 0/1 values to fit.</p>
</td></tr>
<tr><td><code id="logistic_fits_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (required, positive).</p>
</td></tr>
<tr><td><code id="logistic_fits_+3A_i">i</code></td>
<td>
<p>integer, first index (inclusive).</p>
</td></tr>
<tr><td><code id="logistic_fits_+3A_j">j</code></td>
<td>
<p>integer, last index (inclusive).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of predictions for interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(5)
d &lt;- data.frame(x = rnorm(10))
d$y &lt;- d$x + rnorm(nrow(d))&gt;0
weights &lt;- runif(nrow(d))
m &lt;- glm(y~x, data = d, family = binomial, weights = weights)
d$pred1 &lt;- predict(m, newdata = d, type = "link")
d$pred2 &lt;- logistic_fits(d$x, d$y, weights, 0, nrow(d)-1)
d &lt;- d[order(d$x), , drop = FALSE]
print(d)

</code></pre>

<hr>
<h2 id='logistic_solve1'>logistic_fit</h2><span id='topic+logistic_solve1'></span>

<h3>Description</h3>

<p>Calculate y ~ sigmoid(a + b x) using iteratively re-weighted least squares.
Zero indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic_solve1(x, y, w, initial_link, i, j, skip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic_solve1_+3A_x">x</code></td>
<td>
<p>NumericVector, expanatory variable.</p>
</td></tr>
<tr><td><code id="logistic_solve1_+3A_y">y</code></td>
<td>
<p>NumericVector, 0/1 values to fit.</p>
</td></tr>
<tr><td><code id="logistic_solve1_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (required, positive).</p>
</td></tr>
<tr><td><code id="logistic_solve1_+3A_initial_link">initial_link</code></td>
<td>
<p>initial link estimates (required, all zeroes is a good start).</p>
</td></tr>
<tr><td><code id="logistic_solve1_+3A_i">i</code></td>
<td>
<p>integer, first index (inclusive).</p>
</td></tr>
<tr><td><code id="logistic_solve1_+3A_j">j</code></td>
<td>
<p>integer, last index (inclusive).</p>
</td></tr>
<tr><td><code id="logistic_solve1_+3A_skip">skip</code></td>
<td>
<p>integer, index to skip (-1 to not skip).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of a and b.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(5)
d &lt;- data.frame(
  x =  rnorm(10),
  y = sample(c(0,1), 10, replace = TRUE)
)
weights &lt;- runif(nrow(d))
m &lt;- glm(y~x, data = d, family = binomial, weights = weights)
coef(m)
logistic_solve1(d$x, d$y, weights, rep(0.0, nrow(d)), 0, nrow(d)-1, -1)

</code></pre>

<hr>
<h2 id='piecewise_constant'>Piecewise constant fit.</h2><span id='topic+piecewise_constant'></span>

<h3>Description</h3>

<p><code>vtreat</code> custom coder based on <code>RcppDynProg::solve_for_partition()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewise_constant(varName, x, y, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewise_constant_+3A_varname">varName</code></td>
<td>
<p>character, name of variable to work on.</p>
</td></tr>
<tr><td><code id="piecewise_constant_+3A_x">x</code></td>
<td>
<p>numeric, input values.</p>
</td></tr>
<tr><td><code id="piecewise_constant_+3A_y">y</code></td>
<td>
<p>numeric, values to estimate.</p>
</td></tr>
<tr><td><code id="piecewise_constant_+3A_w">w</code></td>
<td>
<p>numeric, weights.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
piecewise_constant("x", 1:8, c(-1, -1, -1, -1, 1, 1, 1, 1))

</code></pre>

<hr>
<h2 id='piecewise_constant_coder'>Piecewise constant fit coder factory.</h2><span id='topic+piecewise_constant_coder'></span>

<h3>Description</h3>

<p>Build a piecewise constant fit coder with some parameters bound in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewise_constant_coder(
  penalty = 1,
  min_n_to_chunk = 1000,
  min_seg = 10,
  max_k = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewise_constant_coder_+3A_penalty">penalty</code></td>
<td>
<p>per-segment cost penalty.</p>
</td></tr>
<tr><td><code id="piecewise_constant_coder_+3A_min_n_to_chunk">min_n_to_chunk</code></td>
<td>
<p>minimum n to subdivied problem.</p>
</td></tr>
<tr><td><code id="piecewise_constant_coder_+3A_min_seg">min_seg</code></td>
<td>
<p>positive integer, minimum segment size.</p>
</td></tr>
<tr><td><code id="piecewise_constant_coder_+3A_max_k">max_k</code></td>
<td>
<p>maximum segments to divide into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vtreat coder
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
coder &lt;- piecewise_constant_coder(min_seg = 1)
coder("x", 1:8, c(-1, -1, -1, -1, 1, 1, 1, 1))

</code></pre>

<hr>
<h2 id='piecewise_linear'>Piecewise linear fit.</h2><span id='topic+piecewise_linear'></span>

<h3>Description</h3>

<p><code>vtreat</code> custom coder based on <code>RcppDynProg::solve_for_partition()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewise_linear(varName, x, y, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewise_linear_+3A_varname">varName</code></td>
<td>
<p>character, name of variable to work on.</p>
</td></tr>
<tr><td><code id="piecewise_linear_+3A_x">x</code></td>
<td>
<p>numeric, input values.</p>
</td></tr>
<tr><td><code id="piecewise_linear_+3A_y">y</code></td>
<td>
<p>numeric, values to estimate.</p>
</td></tr>
<tr><td><code id="piecewise_linear_+3A_w">w</code></td>
<td>
<p>numeric, weights.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
piecewise_linear("x", 1:8, c(1, 2, 3, 4, 4, 3, 2, 1))

</code></pre>

<hr>
<h2 id='piecewise_linear_coder'>Piecewise linear fit coder factory.</h2><span id='topic+piecewise_linear_coder'></span>

<h3>Description</h3>

<p>Build a piecewise linear fit coder with some parameters bound in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewise_linear_coder(
  penalty = 1,
  min_n_to_chunk = 1000,
  min_seg = 10,
  max_k = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewise_linear_coder_+3A_penalty">penalty</code></td>
<td>
<p>per-segment cost penalty.</p>
</td></tr>
<tr><td><code id="piecewise_linear_coder_+3A_min_n_to_chunk">min_n_to_chunk</code></td>
<td>
<p>minimum n to subdivied problem.</p>
</td></tr>
<tr><td><code id="piecewise_linear_coder_+3A_min_seg">min_seg</code></td>
<td>
<p>positive integer, minimum segment size.</p>
</td></tr>
<tr><td><code id="piecewise_linear_coder_+3A_max_k">max_k</code></td>
<td>
<p>maximum segments to divide into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vtreat coder
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
coder &lt;- piecewise_linear_coder(min_seg = 1)
coder("x", 1:8, c(1, 2, 3, 4, 4, 3, 2, 1))

</code></pre>

<hr>
<h2 id='score_solution'>compute the price of a partition solution (and check is valid).</h2><span id='topic+score_solution'></span>

<h3>Description</h3>

<p>compute the price of a partition solution (and check is valid).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_solution(x, solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_solution_+3A_x">x</code></td>
<td>
<p>NumericMatix, for j&gt;=i x(i,j) is the cost of partition element [i,...,j] (inclusive).</p>
</td></tr>
<tr><td><code id="score_solution_+3A_solution">solution</code></td>
<td>
<p>vector of indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>price
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(c(1,1,5,1,1,0,5,0,1), nrow=3)
s &lt;- c(1, 2, 4)
score_solution(x, s)

</code></pre>

<hr>
<h2 id='solve_for_partition'>Solve for a piecewise linear partiton.</h2><span id='topic+solve_for_partition'></span>

<h3>Description</h3>

<p>Solve for a good set of right-exclusive x-cuts such that the 
overall graph of y~x is well-approximated by a piecewise linear
function.  Solution is a ready for use with
with <code>base::findInterval()</code> and <code>stats::approx()</code>
(demonstrated in the examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_for_partition(
  x,
  y,
  ...,
  w = NULL,
  penalty = 0,
  min_n_to_chunk = 1000,
  min_seg = 1,
  max_k = length(x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_for_partition_+3A_x">x</code></td>
<td>
<p>numeric, input variable (no NAs).</p>
</td></tr>
<tr><td><code id="solve_for_partition_+3A_y">y</code></td>
<td>
<p>numeric, result variable (no NAs, same length as x).</p>
</td></tr>
<tr><td><code id="solve_for_partition_+3A_...">...</code></td>
<td>
<p>not used, force later arguments by name.</p>
</td></tr>
<tr><td><code id="solve_for_partition_+3A_w">w</code></td>
<td>
<p>numeric, weights (no NAs, positive, same length as x).</p>
</td></tr>
<tr><td><code id="solve_for_partition_+3A_penalty">penalty</code></td>
<td>
<p>per-segment cost penalty.</p>
</td></tr>
<tr><td><code id="solve_for_partition_+3A_min_n_to_chunk">min_n_to_chunk</code></td>
<td>
<p>minimum n to subdivied problem.</p>
</td></tr>
<tr><td><code id="solve_for_partition_+3A_min_seg">min_seg</code></td>
<td>
<p>positive integer, minimum segment size.</p>
</td></tr>
<tr><td><code id="solve_for_partition_+3A_max_k">max_k</code></td>
<td>
<p>maximum segments to divide into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame appropriate for stats::approx().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example data
d &lt;- data.frame(
  x = 1:8,
  y = c(1, 2, 3, 4, 4, 3, 2, 1))

# solve for break points
soln &lt;- solve_for_partition(d$x, d$y)
# show solution
print(soln)

# label each point 
d$group &lt;- base::findInterval(
  d$x,
  soln$x[soln$what=='left'])
# apply piecewise approximation
d$estimate &lt;- stats::approx(
  soln$x,
  soln$pred,
  xout = d$x,
  method = 'linear',
  rule = 2)$y
# show result
print(d)

</code></pre>

<hr>
<h2 id='solve_for_partitionc'>Solve for a piecewise constant partiton.</h2><span id='topic+solve_for_partitionc'></span>

<h3>Description</h3>

<p>Solve for a good set of right-exclusive x-cuts such that the 
overall graph of y~x is well-approximated by a piecewise linear
function. Solution is a ready for use with
with <code>base::findInterval()</code> and <code>stats::approx()</code>
(demonstrated in the examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_for_partitionc(
  x,
  y,
  ...,
  w = NULL,
  penalty = 0,
  min_n_to_chunk = 1000,
  min_seg = 1,
  max_k = length(x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_for_partitionc_+3A_x">x</code></td>
<td>
<p>numeric, input variable (no NAs).</p>
</td></tr>
<tr><td><code id="solve_for_partitionc_+3A_y">y</code></td>
<td>
<p>numeric, result variable (no NAs, same length as x).</p>
</td></tr>
<tr><td><code id="solve_for_partitionc_+3A_...">...</code></td>
<td>
<p>not used, force later arguments by name.</p>
</td></tr>
<tr><td><code id="solve_for_partitionc_+3A_w">w</code></td>
<td>
<p>numeric, weights (no NAs, positive, same length as x).</p>
</td></tr>
<tr><td><code id="solve_for_partitionc_+3A_penalty">penalty</code></td>
<td>
<p>per-segment cost penalty.</p>
</td></tr>
<tr><td><code id="solve_for_partitionc_+3A_min_n_to_chunk">min_n_to_chunk</code></td>
<td>
<p>minimum n to subdivied problem.</p>
</td></tr>
<tr><td><code id="solve_for_partitionc_+3A_min_seg">min_seg</code></td>
<td>
<p>positive integer, minimum segment size.</p>
</td></tr>
<tr><td><code id="solve_for_partitionc_+3A_max_k">max_k</code></td>
<td>
<p>maximum segments to divide into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame appropriate for stats::approx().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example data
d &lt;- data.frame(
  x = 1:8,
  y = c(-1, -1, -1, -1, 1, 1, 1, 1))

# solve for break points
soln &lt;- solve_for_partitionc(d$x, d$y)
# show solution
print(soln)

# label each point
d$group &lt;- base::findInterval(
  d$x,
  soln$x[soln$what=='left'])
# apply piecewise approximation
d$estimate &lt;- stats::approx(
  soln$x,
  soln$pred,
  xout = d$x,
  method = 'constant',
  rule = 2)$y
# show result
print(d)

</code></pre>

<hr>
<h2 id='solve_interval_partition'>solve_interval_partition interval partition problem.</h2><span id='topic+solve_interval_partition'></span>

<h3>Description</h3>

<p>Solve a for a minimal cost partition of the integers [1,...,nrow(x)] problem where for j&gt;=i x(i,j).
is the cost of choosing the partition element [i,...,j]. 
Returned solution is an ordered vector v of length k&lt;=kmax where: v[1]==1, v[k]==nrow(x)+1, and the 
partition is of the form [v[i], v[i+1]) (intervals open on the right).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_interval_partition(x, kmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_interval_partition_+3A_x">x</code></td>
<td>
<p>square NumericMatix, for j&gt;=i x(i,j) is the cost of partition element [i,...,j] (inclusive).</p>
</td></tr>
<tr><td><code id="solve_interval_partition_+3A_kmax">kmax</code></td>
<td>
<p>int, maximum number of segments in solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dynamic program solution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
costs &lt;- matrix(c(1.5, NA ,NA ,1 ,0 , NA, 5, -1, 1), nrow = 3)
solve_interval_partition(costs, nrow(costs))

</code></pre>

<hr>
<h2 id='solve_interval_partition_k'>solve_interval_partition interval partition problem with a bound on number of steps.</h2><span id='topic+solve_interval_partition_k'></span>

<h3>Description</h3>

<p>Solve a for a minimal cost partition of the integers [1,...,nrow(x)] problem where for j&gt;=i x(i,j).
is the cost of choosing the partition element [i,...,j]. 
Returned solution is an ordered vector v of length k&lt;=kmax where: v[1]==1, v[k]==nrow(x)+1, and the 
partition is of the form [v[i], v[i+1]) (intervals open on the right).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_interval_partition_k(x, kmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_interval_partition_k_+3A_x">x</code></td>
<td>
<p>square NumericMatix, for j&gt;=i x(i,j) is the cost of partition element [i,...,j] (inclusive).</p>
</td></tr>
<tr><td><code id="solve_interval_partition_k_+3A_kmax">kmax</code></td>
<td>
<p>int, maximum number of segments in solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dynamic program solution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
costs &lt;- matrix(c(1.5, NA ,NA ,1 ,0 , NA, 5, -1, 1), nrow = 3)
solve_interval_partition(costs, nrow(costs))

</code></pre>

<hr>
<h2 id='solve_interval_partition_no_k'>solve_interval_partition interval partition problem, no boun on the number of steps.</h2><span id='topic+solve_interval_partition_no_k'></span>

<h3>Description</h3>

<p>Not working yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_interval_partition_no_k(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_interval_partition_no_k_+3A_x">x</code></td>
<td>
<p>square NumericMatix, for j&gt;=i x(i,j) is the cost of partition element [i,...,j] (inclusive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Solve a for a minimal cost partition of the integers [1,...,nrow(x)] problem where for j&gt;=i x(i,j).
is the cost of choosing the partition element [i,...,j]. 
Returned solution is an ordered vector v of length k where: v[1]==1, v[k]==nrow(x)+1, and the 
partition is of the form [v[i], v[i+1]) (intervals open on the right).
</p>


<h3>Value</h3>

<p>dynamic program solution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
costs &lt;- matrix(c(1.5, NA ,NA ,1 ,0 , NA, 5, -1, 1), nrow = 3)
solve_interval_partition(costs, nrow(costs))

</code></pre>

<hr>
<h2 id='solve_interval_partition_R'>solve_interval_partition (R version)</h2><span id='topic+solve_interval_partition_R'></span>

<h3>Description</h3>

<p>Solve a for a minimal cost partition of the integers [1,...,nrow(x)] problem where for j&gt;=i x(i,j).
is the cost of choosing the partition element [i,...,j]. 
Returned solution is an ordered vector v of length k where: v[1]==1, v[k]==nrow(x)+1, and the 
partition is of the form [v[i], v[i+1]) (intervals open on the right).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_interval_partition_R(x, kmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_interval_partition_R_+3A_x">x</code></td>
<td>
<p>NumericMatix, for j&gt;=i x(i,j) is the cost of partition element [i,...,j] (inclusive).</p>
</td></tr>
<tr><td><code id="solve_interval_partition_R_+3A_kmax">kmax</code></td>
<td>
<p>int, maximum number of steps in solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dynamic program solution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(c(1,1,5,1,1,0,5,0,1), nrow=3)
k &lt;- 3
solve_interval_partition_R(x, k)
solve_interval_partition(x, k)

</code></pre>

<hr>
<h2 id='summarize_input'>Summarize data (for debugging).</h2><span id='topic+summarize_input'></span>

<h3>Description</h3>

<p>Summarize data (for debugging).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_input(x, y, w, i, j, skip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_input_+3A_x">x</code></td>
<td>
<p>NumericVector, expanatory variable.</p>
</td></tr>
<tr><td><code id="summarize_input_+3A_y">y</code></td>
<td>
<p>NumericVector, 0/1 values to fit.</p>
</td></tr>
<tr><td><code id="summarize_input_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (required, positive).</p>
</td></tr>
<tr><td><code id="summarize_input_+3A_i">i</code></td>
<td>
<p>integer, first index (inclusive).</p>
</td></tr>
<tr><td><code id="summarize_input_+3A_j">j</code></td>
<td>
<p>integer, last index (inclusive).</p>
</td></tr>
<tr><td><code id="summarize_input_+3A_skip">skip</code></td>
<td>
<p>integer, index to skip (-1 to not skip).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
costs &lt;- matrix(c(1.5, NA ,NA ,1 ,0 , NA, 5, -1, 1), nrow = 3)
solve_interval_partition(costs, nrow(costs))

</code></pre>

<hr>
<h2 id='xlin_fits'>xlin_fits</h2><span id='topic+xlin_fits'></span>

<h3>Description</h3>

<p>Calculate out of sample linear fit predictions using regularization.
Zero indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlin_fits(x, y, w, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlin_fits_+3A_x">x</code></td>
<td>
<p>NumericVector, explanatory variable (length&gt;=2).</p>
</td></tr>
<tr><td><code id="xlin_fits_+3A_y">y</code></td>
<td>
<p>NumericVector, values fit.</p>
</td></tr>
<tr><td><code id="xlin_fits_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (positive).</p>
</td></tr>
<tr><td><code id="xlin_fits_+3A_i">i</code></td>
<td>
<p>integer, first index (inclusive).</p>
</td></tr>
<tr><td><code id="xlin_fits_+3A_j">j</code></td>
<td>
<p>integer, j&gt;=i+2 last index (inclusive);</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xlin_fits(c(1, 2, 3, 4), c(1, 2, 2, 1), c(1, 1, 1, 1), 0, 3)

</code></pre>

<hr>
<h2 id='xlin_fits_lm'>xlin_fits_R</h2><span id='topic+xlin_fits_lm'></span>

<h3>Description</h3>

<p>Calculate out of sample linear fit predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlin_fits_lm(x, y, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlin_fits_lm_+3A_x">x</code></td>
<td>
<p>NumericVector, x-coords of values to group (length&gt;=2).</p>
</td></tr>
<tr><td><code id="xlin_fits_lm_+3A_y">y</code></td>
<td>
<p>NumericVector, values to group in order.</p>
</td></tr>
<tr><td><code id="xlin_fits_lm_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (positive).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xlin_fits_lm(c(1, 2, 3, 4), c(1, 2, 2, 1), c(1, 1, 1, 1))

</code></pre>

<hr>
<h2 id='xlin_fits_R'>xlin_fits_R</h2><span id='topic+xlin_fits_R'></span>

<h3>Description</h3>

<p>Calculate out of sample linear fit predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlin_fits_R(x, y, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlin_fits_R_+3A_x">x</code></td>
<td>
<p>NumericVector, x-coords of values to group (length&gt;=2).</p>
</td></tr>
<tr><td><code id="xlin_fits_R_+3A_y">y</code></td>
<td>
<p>NumericVector, values to group in order.</p>
</td></tr>
<tr><td><code id="xlin_fits_R_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (positive).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xlin_fits_R(c(1, 2, 3, 4), c(1, 2, 2, 1), c(1, 1, 1, 1))

</code></pre>

<hr>
<h2 id='xlin_fits_V'>xlin_fits_R</h2><span id='topic+xlin_fits_V'></span>

<h3>Description</h3>

<p>Calculate out of sample linear fit predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlin_fits_V(x, y, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlin_fits_V_+3A_x">x</code></td>
<td>
<p>NumericVector, x-coords of values to group (length&gt;=2).</p>
</td></tr>
<tr><td><code id="xlin_fits_V_+3A_y">y</code></td>
<td>
<p>NumericVector, values to group in order.</p>
</td></tr>
<tr><td><code id="xlin_fits_V_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (positive).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xlin_fits_V(c(1, 2, 3, 4), c(1, 2, 2, 1), c(1, 1, 1, 1))

</code></pre>

<hr>
<h2 id='xlin_pfits'>xlin_pfits</h2><span id='topic+xlin_pfits'></span>

<h3>Description</h3>

<p>Calculate out of sample linear fit predictions using pseudo-inverse.
Please see: <a href="https://win-vector.com/2019/01/08/a-beautiful-2-by-2-matrix-identity/">https://win-vector.com/2019/01/08/a-beautiful-2-by-2-matrix-identity/</a>.
Zero indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlin_pfits(x, y, w, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlin_pfits_+3A_x">x</code></td>
<td>
<p>NumericVector, explanatory variable (length&gt;=2).</p>
</td></tr>
<tr><td><code id="xlin_pfits_+3A_y">y</code></td>
<td>
<p>NumericVector, values to fit.</p>
</td></tr>
<tr><td><code id="xlin_pfits_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (positive).</p>
</td></tr>
<tr><td><code id="xlin_pfits_+3A_i">i</code></td>
<td>
<p>integer, first index (inclusive).</p>
</td></tr>
<tr><td><code id="xlin_pfits_+3A_j">j</code></td>
<td>
<p>integer, j&gt;=i+2 last index (inclusive);</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xlin_pfits(c(1, 2, 3, 4), c(1, 2, 2, 1), c(1, 1, 1, 1), 0, 3)

</code></pre>

<hr>
<h2 id='xlogistic_fits'>Out of sample logistic predictions (in link space).</h2><span id='topic+xlogistic_fits'></span>

<h3>Description</h3>

<p>1-hold out logistic regression predections.
Zero indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlogistic_fits(x, y, w, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlogistic_fits_+3A_x">x</code></td>
<td>
<p>NumericVector, expanatory variable.</p>
</td></tr>
<tr><td><code id="xlogistic_fits_+3A_y">y</code></td>
<td>
<p>NumericVector, 0/1 values to fit.</p>
</td></tr>
<tr><td><code id="xlogistic_fits_+3A_w">w</code></td>
<td>
<p>NumericVector, weights (required, positive).</p>
</td></tr>
<tr><td><code id="xlogistic_fits_+3A_i">i</code></td>
<td>
<p>integer, first index (inclusive).</p>
</td></tr>
<tr><td><code id="xlogistic_fits_+3A_j">j</code></td>
<td>
<p>integer, last index (inclusive).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of predictions for interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(5)
d &lt;- data.frame(x = rnorm(10))
d$y &lt;- d$x + rnorm(nrow(d))&gt;0
weights &lt;- runif(nrow(d))
m &lt;- glm(y~x, data = d, family = binomial, weights = weights)
d$pred1 &lt;- predict(m, newdata = d, type = "link")
d$pred2 &lt;- xlogistic_fits(d$x, d$y, weights, 0, nrow(d)-1)
d &lt;- d[order(d$x), , drop = FALSE]
print(d)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
