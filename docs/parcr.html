<!DOCTYPE html><html><head><title>Help for package parcr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {parcr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%or%'><p>Applying alternative parsers</p></a></li>
<li><a href='#%ret%'><p>Return a fixed value instead of the result of a parser</p></a></li>
<li><a href='#%then%'><p>Applying parsers in sequence</p></a></li>
<li><a href='#%using%'><p>Applying a function to the result of a parser</p></a></li>
<li><a href='#%xthen%'><p>Keeping only first or second result from a <code style="white-space: pre;">&#8288;%then%&#8288;</code> sequence</p></a></li>
<li><a href='#by_split'><p>Applying a parser to a split string</p></a></li>
<li><a href='#by_symbol'><p>Applying a parser to individual symbols of a string</p></a></li>
<li><a href='#EmptyLine'><p>Recognize empty lines</p></a></li>
<li><a href='#eof'><p>Detect end of input</p></a></li>
<li><a href='#failed'><p>Testing for parser failure</p></a></li>
<li><a href='#fastafile'><p>Example nucleotide fasta file</p></a></li>
<li><a href='#finished'><p>Test whether the parser has completely consumed the input</p></a></li>
<li><a href='#literal'><p>Matching parser input with a literal string</p></a></li>
<li><a href='#match_s'><p>Identifying and processing a string and producing custom output</p></a></li>
<li><a href='#print.marker'><p>Print method for an object of class <code>marker</code></p></a></li>
<li><a href='#reporter'><p>Turn a parser into an error reporting parser</p></a></li>
<li><a href='#satisfy'><p>Matching input using a logical function</p></a></li>
<li><a href='#succeed'><p>The most basic parsers</p></a></li>
<li><a href='#zero_or_more'><p>Repeated application of a parser</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Construct Parsers for Structured Text Files</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Construct parser combinator functions, higher order functions that
  parse input. Construction of such parsers is transparent and easy. Their main
  application is the parsing of structured text files like those generated by
  laboratory instruments. Based on a paper by Hutton (1992)
  &lt;<a href="https://doi.org/10.1017%2FS0956796800000411">doi:10.1017/S0956796800000411</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, stringr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SystemsBioinformatics/parcr">https://github.com/SystemsBioinformatics/parcr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SystemsBioinformatics/parcr/issues">https://github.com/SystemsBioinformatics/parcr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 12:53:06 UTC; douwe</td>
</tr>
<tr>
<td>Author:</td>
<td>Douwe Molenaar <a href="https://orcid.org/0000-0001-7108-4545"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Douwe Molenaar &lt;d.molenaar@vu.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25or+25'>Applying alternative parsers</h2><span id='topic++25or+25'></span>

<h3>Description</h3>

<p>The <code style="white-space: pre;">&#8288;%or%&#8288;</code> combinator <code>(p1 %or% p2)</code> returns the result of <code>p1</code> if <code>p1</code> is
successful or, if <code>p1</code> fails that of <code>p2</code> if <code>p2</code> parses successfully,
otherwise it returns a <code>fail</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p1 %or% p2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25or+2B25_+3A_p1">p1</code>, <code id="+2B25or+2B25_+3A_p2">p2</code></td>
<td>
<p>two parsers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
(p1 %or% p2)(x):
  if p1(x)==[] then
    if p2(x)==[] then fail()(x) else p2(x)
  else p1(x)
</pre>
<p>where <code style="white-space: pre;">&#8288;[]&#8288;</code> is the empty list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(literal("A") %or% literal("a"))(LETTERS[1:5]) # success on first parser
(literal("A") %or% literal("a"))(letters[1:5]) # success on second parser
(literal("A") %or% literal("a"))(LETTERS[2:6]) # failure
starts_with_a &lt;- function(x) grepl("^a",x[1])
# success on both parsers, but returns result of p1 only
(literal("a") %or% satisfy(starts_with_a)) (letters[1:5])

</code></pre>

<hr>
<h2 id='+25ret+25'>Return a fixed value instead of the result of a parser</h2><span id='topic++25ret+25'></span>

<h3>Description</h3>

<p>Sometimes we are not interested in the result from a parser, only that the
parser succeeds. It may be convenient to return some short representation
or nothing even rather than the string itself. The <code style="white-space: pre;">&#8288;%ret%&#8288;</code> combinator is
useful in such cases. The parser <code>(p %ret% c)</code> has the same behavior as <code>p</code>,
except that it returns the value <code>c</code> if successful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p %ret% c
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25ret+2B25_+3A_p">p</code></td>
<td>
<p>a parser.</p>
</td></tr>
<tr><td><code id="+2B25ret+2B25_+3A_c">c</code></td>
<td>
<p>string, <em>i.e.</em> a single-element character vector. <code>NULL</code> is coerced
to <code>character(0)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
(p %xret% c)(x):
  if p(x)==[] then fail()(x)
  else succeed(c)(x[-1])
</pre>


<h3>See Also</h3>

<p><a href="#topic++25using+25">%using%</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(literal("A") %ret% "We have an A!") (LETTERS[1:5])
(literal("A") %ret% NULL) (LETTERS[1:5])
</code></pre>

<hr>
<h2 id='+25then+25'>Applying parsers in sequence</h2><span id='topic++25then+25'></span>

<h3>Description</h3>

<p><code>(p1 %then% p2)</code> recognizes anything that <code>p1</code> and <code>p2</code> would if applied in
succession.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p1 %then% p2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25then+2B25_+3A_p1">p1</code>, <code id="+2B25then+2B25_+3A_p2">p2</code></td>
<td>
<p>two parsers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
(p1 %then% p2)(x):
  if p1(x)==[] or x==null then fail()(x)
  else
    if p2(x[-1])==[] then fail()(x)
    else succeed([p1(x)$L, p2(x[-1])$L])(x[-2])
</pre>
<p>where <code>null</code> is the empty vector, <code>x[-1]</code> and <code>x[-2]</code> are the vector <code>x</code>
without the first element and without the first two elements, respectively.
</p>


<h3>See Also</h3>

<p>The discarding versions <a href="#topic++25xthen+25">%xthen%</a> and <a href="#topic++25thenx+25">%thenx%</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>starts_with_a &lt;- function(x) grepl("^a",x[1])
starts_with_b &lt;- function(x) grepl("^b",x[1])
(satisfy(starts_with_a) %then% satisfy(starts_with_b)) (c("ab", "bc", "de")) # success
(satisfy(starts_with_a) %then% satisfy(starts_with_b)) (c("bb", "bc", "de")) # failure
(satisfy(starts_with_a) %then% satisfy(starts_with_b)) (c("ab", "ac", "de")) # failure

</code></pre>

<hr>
<h2 id='+25using+25'>Applying a function to the result of a parser</h2><span id='topic++25using+25'></span>

<h3>Description</h3>

<p>The <code style="white-space: pre;">&#8288;%using%&#8288;</code> combinator allows us to manipulate results from a parser. The
parser <code>(p %using% f)</code> has the same behavior as the parser <code>p</code>, except that
the function <code>f</code> is applied to its result value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p %using% f
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25using+2B25_+3A_p">p</code></td>
<td>
<p>a parser.</p>
</td></tr>
<tr><td><code id="+2B25using+2B25_+3A_f">f</code></td>
<td>
<p>a function to be applied to the result of a successful <code>p</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
(p %using% f)(x):
  if p1(x)==[] then fail()(x)
  else succeed(f(p1(x)$L))(x[-1])
</pre>


<h3>Examples</h3>

<pre><code class='language-R'>(literal('ab') %using% toupper) (c("ab","cdef")) # success
(literal('ab') %using% toupper) (c("bb","cdef")) # failure

</code></pre>

<hr>
<h2 id='+25xthen+25'>Keeping only first or second result from a <code style="white-space: pre;">&#8288;%then%&#8288;</code> sequence</h2><span id='topic++25xthen+25'></span><span id='topic++25thenx+25'></span>

<h3>Description</h3>

<p>Two parsers composed in sequence produce a pair of results. Sometimes we are
only interested in one component of the pair. For example in the case of
reserved words such as 'begin' and 'end'. In such cases, two special
versions of the <code style="white-space: pre;">&#8288;%then%&#8288;</code> combinator are useful, which keep either the
first or second result, as reflected by the position of the letter 'x' in
their names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p1 %xthen% p2

p1 %thenx% p2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25xthen+2B25_+3A_p1">p1</code>, <code id="+2B25xthen+2B25_+3A_p2">p2</code></td>
<td>
<p>two parsers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
(p1 %xthen% p2)(x):
  if p1(x)==[] or x==null then fail()(x)
  else
    if p2(x[-1])==[] then fail()(x)
    else succeed(p1(x)$L)(x[-2])

(p1 %thenx% p2)(x):
  if p1(x)==[] or x==null then fail()(x)
  else
    if p2(x[-1])==[] then fail()(x)
    else succeed(p2(x[-1])$L)(x[-2])
</pre>
<p>where <code>null</code> is the empty vector, <code>x[-1]</code> and <code>x[-2]</code> are the vector <code>x</code>
without the first element and without the first two elements, respectively.
</p>


<h3>See Also</h3>

<p><a href="#topic++25then+25">%then%</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_number &lt;- function(x) grepl("\\d+",x[1])
# Numbers are preceded by "&gt;" symbols, but we only want the number
(literal("&gt;") %thenx% satisfy(is_number)) (c("&gt;", "12"))
# Temperatures are followed by the unit 'C', but we only want the number
(satisfy(is_number) %xthen% literal("C")) (c("21", "C"))

</code></pre>

<hr>
<h2 id='by_split'>Applying a parser to a split string</h2><span id='topic+by_split'></span>

<h3>Description</h3>

<p>Splits a string by using a split pattern and then applies the parser <code>p</code>
to the resulting character vector. If <code>finish = TRUE</code> then the parser should
completely consume its input, otherwise the parser fails. If
<code>finish = FALSE</code> then any remaining part of the string is discarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>by_split(p, split, finish = TRUE, fixed = FALSE, perl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_split_+3A_p">p</code></td>
<td>
<p>A parser.</p>
</td></tr>
<tr><td><code id="by_split_+3A_split">split</code></td>
<td>
<p>a string (or object which can be coerced to such) containing
<a href="base.html#topic+regular+20expression">regular expression</a>(s) (unless fixed = TRUE) to use for splitting.
If empty matches occur, in particular if split has length 0, x is split
into single characters.</p>
</td></tr>
<tr><td><code id="by_split_+3A_finish">finish</code></td>
<td>
<p>logical. Should the parser completely consume the string?
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="by_split_+3A_fixed">fixed</code></td>
<td>

<p>logical.  If <code>TRUE</code> match <code>split</code> exactly, otherwise
use regular expressions.  Has priority over <code>perl</code>.
</p>
</td></tr>
<tr><td><code id="by_split_+3A_perl">perl</code></td>
<td>
<p>logical.  Should Perl-compatible regexps be used?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="base.html#topic+strsplit">base::strsplit()</a></code> is used to perform the splitting. The
parameters <code>split</code>, <code>fixed</code> and <code>perl</code> are passed on to that function.
</p>


<h3>Value</h3>

<p>A parser.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strsplit">base::strsplit()</a></code>, <code><a href="#topic+by_symbol">by_symbol()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>by_split((literal("a") %then% literal("b")),"\\t") ("a\tb") # success
by_split((literal("a") %then% literal("b")),"\\t") ("a\tb\tc") # failure
by_split((literal("a") %then% literal("b")),"\\t", finish=FALSE) ("a\tb\tc") # success
</code></pre>

<hr>
<h2 id='by_symbol'>Applying a parser to individual symbols of a string</h2><span id='topic+by_symbol'></span>

<h3>Description</h3>

<p>Splits a string to individual symbols and then applies the parser <code>p</code> to the
resulting character vector, otherwise the parser fails. If <code>finish = TRUE</code>
then the parser should completely consume its input. If <code>finish = FALSE</code>
then any remaining part of the string is discarded.
</p>
<p>This function is identical to <code>by_split(p, "", finish)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>by_symbol(p, finish = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_symbol_+3A_p">p</code></td>
<td>
<p>A parser.</p>
</td></tr>
<tr><td><code id="by_symbol_+3A_finish">finish</code></td>
<td>
<p>logical. Should the parser completely consume the string?
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parser.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+by_split">by_split()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>by_symbol(exactly(3,literal("a"))) (c("aaa", "bb")) # success
by_symbol(exactly(3,literal("a"))) (c("aaaa", "bb")) # failure
</code></pre>

<hr>
<h2 id='EmptyLine'>Recognize empty lines</h2><span id='topic+EmptyLine'></span><span id='topic+Spacer'></span><span id='topic+MaybeEmpty'></span>

<h3>Description</h3>

<p>An empty line is a line that consists entirely of space-like characters.
<code>EmptyLine</code> is a parser that recognizes one empty line, <code>Spacer</code> recognizes
one or more empty lines and <code>MaybeEmpty</code> recognizes zero or more empty
lines. <code>EmptyLine</code> returns the empty line but <code>Spacer</code> and <code>MaybeEmpty</code>
discard these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EmptyLine()

Spacer()

MaybeEmpty()
</code></pre>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
space_like_eraser(x):
    d = x in which all "\\s+" are replaced by ""
    if d=="" TRUE else FALSE

Emptyline: satisfy(space_like_eraser)

Spacer: one_or_more(EmptyLine()) %ret% null

MaybeEmpty: zero_or_more(EmptyLine()) %ret% null
</pre>
<p>where <code>null</code> is the empty vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EmptyLine() (" \t  ") # success
EmptyLine() ("    .") # failure
EmptyLine() ("") # success
Spacer() (c("   \t  ", "    ", "abc"))
Spacer() (c("            ", "    ", "Important text"))
Spacer() (c("Important text")) # failure, missing empty line
MaybeEmpty() (c("            ", "    ", "Important text")) # success, just as Spacer()
MaybeEmpty() (c("Important text")) # success, in contrast to Spacer()
</code></pre>

<hr>
<h2 id='eof'>Detect end of input</h2><span id='topic+eof'></span>

<h3>Description</h3>

<p>Tests whether the end of the input character vector has been reached,
which boils down to detection of <code>character(0)</code> in the <code>R</code>-element (see
<code><a href="#topic+succeed">succeed()</a></code>). Since the intended application of this parser is parsing of
text files the function has been called after the end of file (EOF) signal.
To indicate that an end of file has been detected, the <code>R</code>-element side of
the parser output will be converted to an empty list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eof()
</code></pre>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
eof()(x):
  if x==null then succeed(x)(list())
  else fail()(x)
</pre>


<h3>Examples</h3>

<pre><code class='language-R'>(literal("a") %then% eof())("a") # success
# Notice the difference on the R-side with
literal("a")("a")
eof()(character(0)) # success
eof()("a") # failure

</code></pre>

<hr>
<h2 id='failed'>Testing for parser failure</h2><span id='topic+failed'></span>

<h3>Description</h3>

<p>Use this function to test whether your parser failed, for example in
unit testing of your parsers when writing a package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>failed(o)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="failed_+3A_o">o</code></td>
<td>
<p>Output from a parser.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.marker">print.marker()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- (literal("A") %then% literal("B"))(c("A","A"))
d
failed(d)

</code></pre>

<hr>
<h2 id='fastafile'>Example nucleotide fasta file</h2><span id='topic+fastafile'></span>

<h3>Description</h3>

<p>An example fasta-formatted file with a mixture of nucleotide and protein
sequences. It is used in the vignette to demonstrate parsing with the tools
from the package. It is not clear to me whether mixing of sequence types is
allowed in a fasta file, but we demonstrate in the vignette that is is easy
to parse them from a single file. The sequences used are truncated for the
sake of the example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastafile
</code></pre>


<h3>Format</h3>



<h4><code>fastafile</code></h4>

<p>A character vector
</p>



<h3>Source</h3>

<p>Modified from <a href="https://bioinformatics.org/annhyb/examples/seq_fasta.html">https://bioinformatics.org/annhyb/examples/seq_fasta.html</a>
and <a href="https://en.wikipedia.org/wiki/FASTA_format">https://en.wikipedia.org/wiki/FASTA_format</a>
</p>

<hr>
<h2 id='finished'>Test whether the parser has completely consumed the input</h2><span id='topic+finished'></span>

<h3>Description</h3>

<p>A parser has completely consumed its input when the input has satisfied
<code><a href="#topic+eof">eof()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finished(o)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finished_+3A_o">o</code></td>
<td>
<p>Output from a parser.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>finished((literal("A") %then% eof())("A")) # TRUE
finished((literal("A"))("A")) # FALSE
finished((literal("A") %then% eof())(c("A","C"))) # FALSE
</code></pre>

<hr>
<h2 id='literal'>Matching parser input with a literal string</h2><span id='topic+literal'></span>

<h3>Description</h3>

<p><code>literal</code> tests whether a supplied string literally equals a desired value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>literal(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="literal_+3A_string">string</code></td>
<td>
<p>string, a single-element character vector, or an object that
can be coerced to a character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
literal(a)(x): satisfy(F(y): y==a)(x)
</pre>
<p>where <code>F</code> is equivalent to the <code>function</code> declarator in R. So, we have an
anonymous function in the argument of <code>satisfy</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>literal("ab") (c("ab", "cdef")) # success
literal("ab") (c("abc", "cdef")) # failure

</code></pre>

<hr>
<h2 id='match_s'>Identifying and processing a string and producing custom output</h2><span id='topic+match_s'></span>

<h3>Description</h3>

<p><code>match_s</code> matches a string using a function and returns a desired object
type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_s(s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_s_+3A_s">s</code></td>
<td>
<p>a string-parsing function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This parser short-cuts the pattern <code>satisfy(b) %using% f</code>. With <code>match_s</code>
you do not have to write separate predicate and processing functions <code>b</code> and
<code>f</code> when identification and parsing can be done with a single string
parsing function <code>s</code>.
</p>
<p>The function <code>s</code> will be given a non-empty single-element character vector
as its argument, so you don't have to test for empty input, like
<code>character(0)</code>. These two facts also often simplify further processing with
the string functions like <code>grep</code>, <code>regmatches</code> and those from the <code>stringr</code>
package. The function <code>s</code> can return any R-object when succeeding, but to
signal failure to the parser it must return the empty <code>list()</code>. Note that
<code>list()</code> output from <code>s</code> will be turned into a marker object, the internal
object to mark failure, by <code>match_s()</code>, see <code><a href="#topic+failed">failed()</a></code>.
</p>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
match_s(s)(x):
  if x==null then fail()(x)
  else if s(x[1]) then succeed(s(x[1]))(x[-1]) else fail()(x)
</pre>


<h3>Examples</h3>

<pre><code class='language-R'>expect_integers &lt;- function(x) {
  m &lt;- gregexpr("[[:digit:]]+", x)
  matches &lt;- regmatches(x,m)[[1]]
  if (length(matches)==0) {
    # this means failure to detect numbers where we expected them
    return(list())
  } else {
    return(as.numeric(matches))
  }
}

match_s(expect_integers) ("12 15 16 # some comment") # success
match_s(expect_integers) ("some text") # failure

</code></pre>

<hr>
<h2 id='print.marker'>Print method for an object of class <code>marker</code></h2><span id='topic+print.marker'></span>

<h3>Description</h3>

<p>An object of class <code>marker</code> is an empty list created by the function
<code>fail()</code>. To indicate that this object differs from simply <code>list()</code> its
print method prints <code style="white-space: pre;">&#8288;[]&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marker'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.marker_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.marker_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>marker</code> class is used internally to mark the largest index number of
the element (i.e. line) of the input character vector at which the parser
failed. This number is stored in the attribute <code>n</code> of a marker and only
correctly corresponds to that index number if the parser is wrapped in a
<code><a href="#topic+reporter">reporter()</a></code> call.
</p>


<h3>Value</h3>

<p>The printed <code>marker</code> object is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+failed">failed()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- (literal("A") %then% literal("B"))(c("A","A"))
# prints the icon [] for failed parsing
d
# Reveal the modest content of the marker object
unclass(d)
</code></pre>

<hr>
<h2 id='reporter'>Turn a parser into an error reporting parser</h2><span id='topic+reporter'></span>

<h3>Description</h3>

<p>Turns a parser into an error reporting parser, and when the parser is
successful returns only the <code>L</code>-element of the parser output, the
successfully parsed part of the input (see <code><a href="#topic+succeed">succeed()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reporter(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reporter_+3A_p">p</code></td>
<td>
<p>a parser.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The error object that this function returns is a list containing the
elements <code>linenr</code> and <code>linecontent</code>, corresponding to the line in which the
parser failed and its content. The user of this package can catch this
object to create custom error messages instead of the message generated by
this function.
</p>
<p>A warning is issued when the parser did not completely consume the input.
Complete consumption of input is only explicitly made when the parser ends
with <code><a href="#topic+eof">eof()</a></code>. Therefore, even though all elements were parsed, a zero-length
character vector will remain in the <code>R</code> element if the parser does not end
with <code><a href="#topic+eof">eof()</a></code>.
</p>


<h3>Value</h3>

<p>The <code>L</code>-part of a successful parser result or an error message about
the line where the parser failed. A warning is thrown when the parser
did not completely consume the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>at &lt;- function() literal("a") %then% literal("t")
atat &lt;- rep(c("a","t"),2)
# Yields an error message about parser failing on line 5
try(
  reporter(match_n(3,at()) %then% eof())(c(atat,"t","t"))
)
# No error, but parser result
reporter(match_n(2,at()) %then% eof())(atat)
# warning: the input is not completely consumed
try(
  reporter(match_n(2,at()))(atat)
)

</code></pre>

<hr>
<h2 id='satisfy'>Matching input using a logical function</h2><span id='topic+satisfy'></span>

<h3>Description</h3>

<p><code>satisfy()</code> turns a logical function into a parser that recognizes strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>satisfy(b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="satisfy_+3A_b">b</code></td>
<td>
<p>a boolean function to determine if the string is accepted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notice (see pseudocode) that <code>satisfy</code> fails when presented with empty
input, so it is futile to write predicate functions that would recognize
such input.
</p>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
satisfy(b)(x):
  if x==null then fail()(x)
  else if b(x[1]) then succeed(x[1])(x[-1]) else fail()(x)
</pre>
<p>where <code>x[1]</code> is the first element of <code>x</code>, <code>x[-1]</code> all subsequent elements
(or <code>null</code> if it only has one element). <code>null</code> is the empty vector,
equivalent to <code>character(0)</code> in R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define a predicate function that tests whether the next element starts
# with an 'a'
starts_with_a &lt;- function(x) grepl("^a",x)
# Use it in the satisfy parser
satisfy(starts_with_a)(c("abc","def")) # success
satisfy(starts_with_a)(c("bca","def")) # failure
# Using an anonymous function
satisfy(function(x) {as.numeric(x)&gt;10})("15") # success

</code></pre>

<hr>
<h2 id='succeed'>The most basic parsers</h2><span id='topic+succeed'></span><span id='topic+fail'></span>

<h3>Description</h3>

<p>These are the most basic constructors of a parser, but they are important
cogs of the parser machinery. The <code>succeed</code> parser always succeeds, without
consuming any input, whereas the <code>fail</code> parser always fails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>succeed(left)

fail(lnr = LNR())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="succeed_+3A_left">left</code></td>
<td>
<p>any R-object constructed from a parsed vector.</p>
</td></tr>
<tr><td><code id="succeed_+3A_lnr">lnr</code></td>
<td>
<p>integer. The line number (element number) at which the fail
occurs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>succeed</code> parser constructs a <code>list</code> object with a 'left' or <code>L</code>-element
that contains the parser result of the consumed part of the input vector and
the 'right' or <code>R</code>-element that contains the unconsumed part of the vector.
Since the outcome of succeed does not depend on its input, its result value
must be pre-determined, so it is included as a parameter.
</p>
<p>While <code>succeed</code> never fails, <code>fail</code> always does, regardless of the input
vector. It returns the empty list <code>list()</code> to signal this fact.
</p>


<h3>Value</h3>

<p>A list. <code>succeed()</code> returns a list with two elements named <code>L</code> and
<code>R</code>. <code>fail()</code> returns a <code>marker</code> object which is basically an empty list
with a line number <code>n</code> as attribute. It is printed as the icon <code style="white-space: pre;">&#8288;[]&#8288;</code>,
see <code><a href="#topic+print.marker">print.marker()</a></code>. Note that <code>n</code> will only correctly represent the line
number of failure when a parser is wrapped in the <code><a href="#topic+reporter">reporter()</a></code> function.
</p>


<h3>Pseudocode</h3>

<pre>
succeed(y)(x): [L=[y],R=[x]]
fail()(x):     []
</pre>
<p>where <code style="white-space: pre;">&#8288;[L=[y],R=[x]]&#8288;</code> is a named list with lists <code style="white-space: pre;">&#8288;[y]&#8288;</code> and <code style="white-space: pre;">&#8288;[x]&#8288;</code> as elements
and <code style="white-space: pre;">&#8288;[]&#8288;</code> is an empty list.
</p>


<h3>Note</h3>

<p>It is very unlikely that you will ever have to use these functions when
constructing parsers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>succeed("A")("abc")
succeed(data.frame(title="Keisri hull", author="Jaan Kross"))(c("Unconsumed","text"))

fail()("abc")

</code></pre>

<hr>
<h2 id='zero_or_more'>Repeated application of a parser</h2><span id='topic+zero_or_more'></span><span id='topic+one_or_more'></span><span id='topic+exactly'></span><span id='topic+zero_or_one'></span><span id='topic+match_n'></span>

<h3>Description</h3>

<p>Often, we want to assess whether a given structure can be successfully
parsed through repetitive application of a parser <code>p</code>. This could involve
testing the parser applied multiple times in succession or determining
its capability to be applied zero or more times.
</p>
<p>The subsequent functions are designed to address and evaluate these
scenarios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_or_more(p)

one_or_more(p)

exactly(n, p)

zero_or_one(p)

match_n(n, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_or_more_+3A_p">p</code></td>
<td>
<p>a parser.</p>
</td></tr>
<tr><td><code id="zero_or_more_+3A_n">n</code></td>
<td>
<p>a positive integer, including 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All these parsers with the excception of <code>match_n</code> exhibit greedy behavior
striving to apply <code>p</code> as many times as possible. If the resulting count
doesn't match the expected quantity, such as in the case of <code>exactly(n,p)</code>
where <code>p</code> successfully parses more than <code>n</code> times, then the parser fails.
In contrast, <code>match_n(n,p)</code> strictly applies <code>p</code> exactly <code>n</code> times,
preventing any further application of <code>p</code> even if <code>p</code> could potentially be
applied more often. Clearly, both functions will fail if <code>p</code> fails after
less than <code>n</code> repetitions.
</p>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
zero_or_more(p):
  (p %then% zero_or_more(p)) %or% succeed(null)

one_or_more(p):
  p %then% zero_or_more(p)

exactly(n,p):
  count = 0
  r = zero_or_more(p %using% F(x): count = count + 1; x)(x)
  if count == n then
    count = 0
    r
  else fail()(x)

zero_or_one:
  exactly(0,p) %or% exactly(1,p)

match_n(n,p):
  if n==0 then F(x): succeed(list())(x)
  else
    if n==1 then p else (p %then% match_n(n-1, p))
</pre>
<p>where <code>null</code> is the empty vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zero_or_more(literal("A")) (c("A",LETTERS[1:5]))
zero_or_more(literal("A")) (LETTERS[2:5])

one_or_more(literal("A")) (c("A",LETTERS[1:5])) # success
one_or_more(literal("A")) (LETTERS[2:5]) # failure

exactly(2,literal("A")) (c("A", LETTERS[1:5])) # success
exactly(2,literal("A")) (c(rep("A",2), LETTERS[1:5])) # failure: too many "A"

zero_or_one(literal("A")) (LETTERS[2:5]) # success
zero_or_one(literal("A")) (LETTERS[1:5]) # success
zero_or_one(literal("A")) (c("A",LETTERS[1:5])) # failure

match_n(2,literal("A")) (c("A", LETTERS[1:5])) # success
match_n(2,literal("A")) (c(rep("A",2), LETTERS[1:5])) # success

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
