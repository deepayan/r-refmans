<!DOCTYPE html><html lang="en"><head><title>Help for package bigergm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigergm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ari'><p>Compute the adjusted rand index (ARI) between two clusterings</p></a></li>
<li><a href='#bali'><p>Bali terrorist network</p></a></li>
<li><a href='#bigergm'><p>bigergm: Exponential-family random graph models for large networks with local dependence</p></a></li>
<li><a href='#bunt'><p>Van de Bunt friendship network</p></a></li>
<li><a href='#est_between'><p>Estimate between-block parameters</p></a></li>
<li><a href='#est_within'><p>Estimate a within-block network model.</p></a></li>
<li><a href='#get_between_networks'><p>Obtain the between-block networks defined by the block attribute.</p></a></li>
<li><a href='#get_within_networks'><p>Obtain the within-block networks defined by the block attribute.</p></a></li>
<li><a href='#gof.bigergm'><p>Conduct Goodness-of-Fit Diagnostics on a Exponential Family Random Graph</p>
Model for big networks</a></li>
<li><a href='#kapferer'><p>Kapferer collaboration network</p></a></li>
<li><a href='#plot.bigergm'><p>Plot the network with the found clusters</p></a></li>
<li><a href='#py_dep'><p>Install optional Python dependencies for bigergm</p></a></li>
<li><a href='#reed'><p>A network of friendships between students at Reed College.</p></a></li>
<li><a href='#rice'><p>A network of friendships between students at Rice University.</p></a></li>
<li><a href='#simulate_bigergm'><p>Simulate networks under Exponential Random Graph Models (ERGMs) under local dependence</p></a></li>
<li><a href='#simulate.bigergm'><p>Simulate networks under Exponential Random Graph Models (ERGMs) under local dependence</p></a></li>
<li><a href='#state_twitter'><p>Twitter (X) network of U.S. state legislators</p></a></li>
<li><a href='#toyNet'><p>A toy network to play <code>bigergm</code> with.</p></a></li>
<li><a href='#yule'><p>Compute Yule's Phi-coefficient</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fit, Simulate, and Diagnose Hierarchical Exponential-Family
Models for Big Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox for analyzing and simulating large networks based on hierarchical exponential-family random graph models (HERGMs).'bigergm' implements the estimation for large networks efficiently building on the 'lighthergm' and 'hergm' packages. Moreover, the package contains tools for simulating networks with local dependence to assess the goodness-of-fit.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ergm (&ge; 4.5.0), Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.10.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RcppArmadillo (&ge; 0.10.5), network (&ge; 1.16.0), Matrix,
cachem, tidyr, statnet.common, methods, stringr, intergraph,
igraph, parallel, magrittr, purrr, dplyr, glue, readr, foreach,
rlang, memoise, reticulate, ergm.multi</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat, sna, tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-24 10:49:46 UTC; corneliusfritz</td>
</tr>
<tr>
<td>Author:</td>
<td>Cornelius Fritz [aut, cre],
  Michael Schweinberger [aut],
  Shota Komatsu [aut],
  Juan Nelson Mart√≠nez Dahbura [aut],
  Takanori Nishida [aut],
  Angelo Mele [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cornelius Fritz &lt;corneliusfritz2010@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-24 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ari'>Compute the adjusted rand index (ARI) between two clusterings</h2><span id='topic+ari'></span>

<h3>Description</h3>

<p>This function computes the adjusted rand index (ARI) of the true and estimated block membership (its definition can be found here <a href="https://en.wikipedia.org/wiki/Rand_index">https://en.wikipedia.org/wiki/Rand_index</a>).
The adjusted rand index is used as a measure of association between two group membership vectors.
The more similar the two partitions z_star and z are, the closer the ARI is to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ari(z_star, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ari_+3A_z_star">z_star</code></td>
<td>
<p>The true block membership</p>
</td></tr>
<tr><td><code id="ari_+3A_z">z</code></td>
<td>
<p>The estimated block membership</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjusted rand index
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyNet)
set.seed(123)
ari(z_star = toyNet%v% "block",
z = sample(c(1:4),size = 200,replace = TRUE))
</code></pre>

<hr>
<h2 id='bali'>Bali terrorist network</h2><span id='topic+bali'></span>

<h3>Description</h3>

<p>The network corresponds to the contacts between the 17 terrorists
who carried out the bombing in Bali, Indonesia in 2002.
The network is taken from Koschade (2006).
</p>


<h3>Format</h3>

<p>A <code>statnet</code>'s network class object.
data(bali)
</p>


<h3>References</h3>

<p>Koschade, S. (2006). A social network analysis of Jemaah Islamiyah: The applications to counter-terrorism and intelligence.
Studies in Conflict and Terrorism, 29, 559&ndash;575.
</p>

<hr>
<h2 id='bigergm'>bigergm: Exponential-family random graph models for large networks with local dependence</h2><span id='topic+bigergm'></span>

<h3>Description</h3>

<p>The function <code>bigergm</code> estimates and simulates three classes of exponential-family
random graph models for large networks under local dependence:
</p>

<ol>
<li><p>The p_1 model of Holland and Leinhardt (1981) in exponential-family form and extensions by Vu, Hunter, and Schweinberger (2013), Schweinberger, Petrescu-Prahova, and Vu (2014), Dahbura et al. (2021), and Fritz et al. (2024) to both directed and undirected random graphs with additional model terms, with and without covariates.
</p>
</li>
<li><p>The stochastic block model of Snijders and Nowicki (1997) and Nowicki and Snijders (2001) in exponential-family form.
</p>
</li>
<li><p>The exponential-family random graph models with local dependence of Schweinberger and Handcock (2015), with and without covariates. The exponential-family random graph models with local dependence replace the long-range dependence of conventional exponential-family random graph models by short-range dependence. Therefore, exponential-family random graph models with local dependence replace the strong dependence of conventional exponential-family random graph models by weak dependence, reducing the problem of model degeneracy (Handcock, 2003; Schweinberger, 2011) and improving goodness-of-fit (Schweinberger and Handcock, 2015). In addition, exponential-family random graph models with local dependence satisfy a weak form of self-consistency in the sense that these models are self-consistent under neighborhood sampling (Schweinberger and Handcock, 2015), which enables consistent estimation of neighborhood-dependent parameters (Schweinberger and Stewart, 2017; Schweinberger, 2017).
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>bigergm(
  object,
  add_intercepts = FALSE,
  n_blocks = NULL,
  n_cores = 1,
  blocks = NULL,
  estimate_parameters = TRUE,
  verbose = 0,
  n_MM_step_max = 100,
  tol_MM_step = 1e-04,
  initialization = "infomap",
  use_infomap_python = FALSE,
  virtualenv_python = "r-bigergm",
  seed_infomap = NULL,
  weight_for_initialization = 1000,
  seed = NULL,
  method_within = "MPLE",
  control_within = ergm::control.ergm(),
  clustering_with_features = TRUE,
  compute_pi = FALSE,
  check_alpha_update = FALSE,
  check_blocks = FALSE,
  cache = NULL,
  return_checkpoint = TRUE,
  only_use_preprocessed = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bigergm_+3A_object">object</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> <code><a href="stats.html#topic+formula">formula</a></code> object or <code><a href="#topic+bigergm">bigergm</a></code> class object.
If a formula is given, the function estimates a new model specified by it.
It needs to be of the form
<code>y ~ &lt;model terms&gt;</code>, where <code>y</code> is a
<code><a href="network.html#topic+network">network</a></code> object.
For the details on the possible <code>&lt;model terms&gt;</code>, see
<code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> and Morris, Handcock and Hunter (2008).
All terms that induce dependence are excluded from the between block model, while the within block model includes all terms.
When you pass a <code><a href="#topic+bigergm">bigergm</a></code> class object to the function, you continue from the previous MM step.
Note that the block allocation (which is either provided by parameter <code>blocks</code> or estimated in the first step) is saved as the vertex.attribute <code>block</code> of the network.
This attribute can also be used in the specified formula.
The <code><a href="ergm.multi.html#topic+L-ergmTerm">L-ergmTerm</a></code> is supported to enable size-dependent coefficients for the within-blocks model.
Note, however, that for size-dependent parameters of terms that are included in the between-blocks model,
the intercept in the linear model provided to <code><a href="ergm.multi.html#topic+L-ergmTerm">L-ergmTerm</a></code> should not include the intercept.
See the second example below for a demonstration.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_add_intercepts">add_intercepts</code></td>
<td>
<p>Boolean value to indicate whether adequate intercepts
should be added to the provided formula so that the model in the first stage
of the estimation is a nested model of the estimated model in the second stage of the estimation.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_n_blocks">n_blocks</code></td>
<td>
<p>The number of blocks. This must be specified by the user.
When you pass a <code><a href="#topic+bigergm">bigergm</a></code> class object to the function, you don't have to specify this argument.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of CPU cores to use.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_blocks">blocks</code></td>
<td>
<p>The pre-specified block memberships for each node.
If <code>NULL</code>, the latent community structure is estimated, assuming that the number of communities is <code>n_blocks</code>.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_estimate_parameters">estimate_parameters</code></td>
<td>
<p>If <code>TRUE</code>, both clustering and parameter estimation are implemented.
If <code>FALSE</code>, only clustering is executed.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer: if this is TRUE/1,
the program will print out additional information about the progress of estimation and simulation.
A higher value yields lower level information.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_n_mm_step_max">n_MM_step_max</code></td>
<td>
<p>The maximum number of MM iterations.
Currently, no early stopping criteria is introduced. Thus <code>n_MM_step_max</code> MM iterations are exactly implemented.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_tol_mm_step">tol_MM_step</code></td>
<td>
<p>Tolerance regarding the relative change of the lower bound of the likelihood
used to decide on the convergence of the clustering step</p>
</td></tr>
<tr><td><code id="bigergm_+3A_initialization">initialization</code></td>
<td>
<p>How the blocks should be initialized.
If <code>infomap</code> (the default), <code>igraph</code>' or Python's infomap is implemented.
If <code>random</code>, the initial clusters are randomly uniformally selected.
If <code>spectral</code>, spectral clustering is conducted.
If <code>walktrap</code>, the walktrap clustering algorithm as implemented in <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> is conducted.
If <code>initialization</code>
is a vector of integers of the same length as the number of nodes in the provided network (in <code>object</code>),
then the provided vector is used as the initial cluster assignment.
If <code>initialization</code> is a string relating to a file path, <code><a href="#topic+bigergm">bigergm</a></code> will interpret it as block allocations saved in Python's infomap .clu format under that path.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_use_infomap_python">use_infomap_python</code></td>
<td>
<p>If <code>TRUE</code>, the cluster initialization is implemented using Pythons' infomap.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_virtualenv_python">virtualenv_python</code></td>
<td>
<p>Which virtual environment should be used for the infomap algorithm?</p>
</td></tr>
<tr><td><code id="bigergm_+3A_seed_infomap">seed_infomap</code></td>
<td>
<p>seed value (integer) for the infomap algorithm, which can be used to initialize the estimation of the blocks.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_weight_for_initialization">weight_for_initialization</code></td>
<td>
<p>weight value used for cluster initialization. The higher this value, the more weight is put on the initialized block allocation.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_seed">seed</code></td>
<td>
<p>seed value (integer) for the random number generator.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_method_within">method_within</code></td>
<td>
<p>If &quot;MPLE&quot; (the default), then the maximum pseudolikelihood estimator is implemented when estimating the within-block network model.
If &quot;MLE&quot;, then an approximate maximum likelihood estimator is conducted. If &quot;CD&quot; (EXPERIMENTAL), the Monte-Carlo contrastive divergence estimate is returned.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_control_within">control_within</code></td>
<td>
<p>A list of control parameters for the <code><a href="ergm.html#topic+ergm">ergm</a></code> function used to estimate the parameters of the within model. See <code><a href="ergm.html#topic+control.ergm">control.ergm</a></code> for details.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_clustering_with_features">clustering_with_features</code></td>
<td>
<p>If <code>TRUE</code>, clustering is implemented using the discrete covariates specified in the formula.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_compute_pi">compute_pi</code></td>
<td>
<p>If <code>TRUE</code>, this function keeps track of pi matrices at each MM iteration.
If the network is large, we strongly recommend to set to be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_check_alpha_update">check_alpha_update</code></td>
<td>
<p>If <code>TRUE</code>, this function keeps track of alpha matrices at each MM iteration.
If the network is large, we strongly recommend to set to be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_check_blocks">check_blocks</code></td>
<td>
<p>If TRUE, this function keeps track of estimated block memberships at each MM iteration.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_cache">cache</code></td>
<td>
<p>a <code>cachem</code> cache object used to store intermediate calculations such as eigenvector decomposition results.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_return_checkpoint">return_checkpoint</code></td>
<td>
<p>If <code>TRUE</code>, the function returns the checkpoint list. For most applications, this should be set to <code>TRUE</code> but if memory space needed by the output is an issue, set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_only_use_preprocessed">only_use_preprocessed</code></td>
<td>
<p>If <code>TRUE</code>, the function only uses the preprocessed data from a previous fit but does not continue the estimation from its final iteration, instead the estimation is started again from the provided initialization.</p>
</td></tr>
<tr><td><code id="bigergm_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions (mainly to the <code><a href="ergm.html#topic+ergm">ergm</a></code> function used for the estimation of within-block connections).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'bigergm' including the results of the fitted model.
These include:
</p>

<dl>
<dt>call:</dt><dd><p>call of the mode</p>
</dd>
<dt>block:</dt><dd><p>vector of the found block of the nodes into cluster</p>
</dd>
<dt>initial_block:</dt><dd><p>vector of the initial block of the nodes into cluster</p>
</dd>
<dt>sbm_pi:</dt><dd><p>Connection probabilities represented as a <code>n_blocks x n_blocks</code> matrix from the first stage of the estimation between all clusters</p>
</dd>
<dt>MM_list_z:</dt><dd><p>list of cluster allocation for each node and each iteration</p>
</dd>
<dt>MM_list_alpha:</dt><dd><p>list of posterior distributions of cluster allocations for all nodes for each iteration</p>
</dd>
<dt>MM_change_in_alpha:</dt><dd><p>change in 'alpha' for each iteration</p>
</dd>
<dt>MM_lower_bound:</dt><dd><p> vector of the evidence lower bounds from the MM algorithm</p>
</dd>
<dt>alpha: </dt><dd><p>matrix representing the converged posterior distributions of cluster allocations for all nodes</p>
</dd>
<dt>counter_e_step:</dt><dd><p> integer number indicating the number of iterations carried out</p>
</dd>
<dt>adjacency_matrix:</dt><dd><p>sparse matrix representing the adjacency matrix used for the estimation</p>
</dd>
<dt>estimation_status:</dt><dd><p>character stating the status of the estimation</p>
</dd>
<dt>est_within:</dt><dd><p><code><a href="ergm.html#topic+ergm">ergm</a></code> object of the model for within cluster connections </p>
</dd>
<dt>est_between:</dt><dd><p><code><a href="ergm.html#topic+ergm">ergm</a></code> object of the model for between cluster connections</p>
</dd>
<dt>checkpoint:</dt><dd><p>list of information to continue the estimation (only returned if <code>return_checkpoint = TRUE</code>)</p>
</dd>
<dt>membership_before_kmeans:</dt><dd><p>vector of the found blocks of the nodes into cluster before the final check for bad clusters</p>
</dd>
<dt>estimate_parameters:</dt><dd><p>binary value if the parameters in the second step of the algorithm should be estimated or not</p>
</dd>
</dl>



<h3>References</h3>

<p>Babkin, S., Stewart, J., Long, X., and M. Schweinberger (2020). Large-scale estimation of random graph models with local dependence. Computational Statistics and Data Analysis, 152, 1&ndash;19.
</p>
<p>Dahbura, J. N. M., Komatsu, S., Nishida, T. and Mele, A. (2021), ‚ÄòA structural model of business cards exchange networks‚Äô.
https://arxiv.org/abs/2105.12704
</p>
<p>Fritz C., Georg C., Mele A., and Schweinberger M. (2024). A strategic model of software dependency networks.
https://arxiv.org/abs/2402.13375
</p>
<p>Handcock, M. S. (2003). Assessing degeneracy in statistical models of social networks. Technical report, Center for Statistics and the Social Sciences, University of Washington, Seattle. <br />
https://csss.uw.edu/Papers/wp39.pdf
</p>
<p>Holland, P. W. and S. Leinhardt (1981). An exponential family of probability distributions for directed graphs. Journal of the American Statistical Association, Theory &amp; Methods, 76, 33&ndash;65.
</p>
<p>Morris M, Handcock MS, Hunter DR (2008). Specification of Exponential-Family Random Graph Models: Terms and Computational Aspects.
Journal of Statistical Software, 24.
</p>
<p>Nowicki, K. and T. A. B. Snijders (2001). Estimation and prediction for stochastic blockstructures. Journal of the American Statistical Association, Theory &amp; Methods, 96, 1077&ndash;1087.
</p>
<p>Schweinberger, M. (2011). Instability, sensitivity, and degeneracy of discrete exponential families. Journal of the American Statistical Association, Theory &amp; Methods, 106, 1361&ndash;1370.
</p>
<p>Schweinberger, M. (2020). Consistent structure estimation of exponential-family random graph models with block structure. Bernoulli, 26, 1205&ndash;1233.
</p>
<p>Schweinberger, M. and M. S. Handcock (2015). Local dependence in random graph models: characterization, properties, and statistical inference. Journal of the Royal Statistical Society, Series B (Statistical Methodology), 7, 647-676.
</p>
<p>Schweinberger, M., Krivitsky, P. N., Butts, C.T. and J. Stewart (2020). Exponential-family models of random graphs: Inference in finite, super, and infinite population scenarios. Statistical Science, 35, 627-662.
</p>
<p>Schweinberger, M. and P. Luna (2018). HERGM: Hierarchical exponential-family random graph models. Journal of Statistical Software, 85, 1&ndash;39.
</p>
<p>Schweinberger, M., Petrescu-Prahova, M. and D. Q. Vu (2014). Disaster response on September 11, 2001 through the lens of statistical network analysis. Social Networks, 37, 42&ndash;55.
</p>
<p>Schweinberger, M. and J. Stewart (2020). Concentration and consistency results for canonical and curved exponential-family random graphs. The Annals of Statistics, 48, 374&ndash;396.
</p>
<p>Snijders, T. A. B. and K. Nowicki (1997). Estimation and prediction for stochastic blockmodels for graphs with latent block structure. Journal of Classification, 14, 75&ndash;100.
</p>
<p>Stewart, J., Schweinberger, M., Bojanowski, M., and M. Morris (2019). Multilevel network data facilitate statistical inference for curved ERGMs with geometrically weighted terms. Social Networks, 59, 98&ndash;119.
</p>
<p>Vu, D. Q., Hunter, D. R. and M. Schweinberger (2013). Model-based clustering of large networks. Annals of Applied Statistics, 7, 1010&ndash;1039.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load an embedded network object.
data(toyNet)

# Specify the model that you would like to estimate.
model_formula &lt;- toyNet ~ edges + nodematch("x") + nodematch("y") + triangle
# Estimate the model
bigergm_res &lt;- bigergm(
  object = model_formula,
  # The model you would like to estimate
  n_blocks = 4,
  # The number of blocks
  n_MM_step_max = 10,
  # The maximum number of MM algorithm steps
  estimate_parameters = TRUE,
  # Perform parameter estimation after the block recovery step
  clustering_with_features = TRUE,
  # Indicate that clustering must take into account nodematch on characteristics
  check_blocks = FALSE)
  
 # Example with N() operator
 
 ## Not run: 
set.seed(1)
# Prepare ingredients for simulating a network
N &lt;- 500
K &lt;- 10

list_within_params &lt;- c(1, 2, 2,-0.5)
list_between_params &lt;- c(-8, 0.5, -0.5)
formula &lt;- g ~ edges + nodematch("x") + nodematch("y")  + N(~edges,~log(n)-1)

memb &lt;- sample(1:K,prob = c(0.1,0.2,0.05,0.05,0.10,0.1,0.1,0.1,0.1,0.1), 
               size = N, replace = TRUE)
vertex_id &lt;- as.character(11:(11 + N - 1))

x &lt;- sample(1:2, size = N, replace = TRUE)
y &lt;- sample(1:2, size = N, replace = TRUE)


df &lt;- tibble::tibble(
  id = vertex_id,
  memb = memb,
  x = x,
  y = y
)
g &lt;- network::network.initialize(n = N, directed = FALSE)
g %v% "vertex.names" &lt;- df$id
g %v% "block" &lt;- df$memb
g %v% "x" &lt;- df$x
g %v% "y" &lt;- df$y

# Simulate a network
g_sim &lt;-
  simulate_bigergm(
    formula = formula,
    coef_within = list_within_params,
    coef_between = list_between_params,
    nsim = 1, 
    control_within = control.simulate.formula(MCMC.burnin = 200000))

estimation &lt;- bigergm(update(formula,new = g_sim~.), n_blocks = 10, 
                      verbose = T)
summary(estimation)

## End(Not run)
</code></pre>

<hr>
<h2 id='bunt'>Van de Bunt friendship network</h2><span id='topic+bunt'></span>

<h3>Description</h3>

<p>Van de Bunt (1999) and Van de Bunt et al. (1999)
collected data on friendships between 32 freshmen at a European university at 7 time points.
Here, the last time point is used.
A directed edge from student <code>i</code> to <code>j</code> indicates that student <code>i</code>
considers student <code>j</code> to be a <code style="white-space: pre;">&#8288;friend" or &#8288;</code>best friend&quot;.
</p>


<h3>Format</h3>

<p>A <code>statnet</code>'s network class object.
data(bunt)
</p>


<h3>References</h3>

<p>Van de Bunt, G. G. (1999). Friends by choice. An Actor-Oriented Statistical Network Model for Friendship Networks through Time. Thesis Publishers, Amsterdam.
</p>
<p>Van de Bunt, G. G., Van Duijn, M. A. J., and T. A. B. Snijders (1999). Friendship Networks Through Time: An Actor-Oriented Statistical Network Model. Computational and Mathematical Organization Theory, 5, 167&ndash;192.
</p>

<hr>
<h2 id='est_between'>Estimate between-block parameters</h2><span id='topic+est_between'></span>

<h3>Description</h3>

<p>Function to estimate the between-block model by relying on the maximum likelihood estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_between(
  formula,
  network,
  add_intercepts = TRUE,
  clustering_with_features = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_between_+3A_formula">formula</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> <code><a href="stats.html#topic+formula">formula</a></code> object of the form
<code>y ~ &lt;model terms&gt;</code>, where <code>y</code> is a
<code><a href="network.html#topic+network">network</a></code> object.
The network object must contain block information as a vertex attribute with the name 'block'.
For the details on the possible <code>&lt;model terms&gt;</code>, see
<code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> and Morris, Handcock and Hunter (2008).
All terms that induce dependence are excluded from the between block model.</p>
</td></tr>
<tr><td><code id="est_between_+3A_network">network</code></td>
<td>
<p>a network object with one vertex attribute called 'block' representing which node belongs to which block</p>
</td></tr>
<tr><td><code id="est_between_+3A_add_intercepts">add_intercepts</code></td>
<td>
<p>Boolean value to indicate whether adequate intercepts
should be added to the provided formula so that the model in the first stage
of the estimation is a nested model of the estimated model in the second stage of the estimation</p>
</td></tr>
<tr><td><code id="est_between_+3A_clustering_with_features">clustering_with_features</code></td>
<td>
<p>Boolean value to indicate if the clustering
was carried out making use of the covariates or not (only important if <code>add_intercepts = TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'ergm' object of the estimated model.
</p>


<h3>References</h3>

<p>Morris M, Handcock MS, Hunter DR (2008). Specification of Exponential-Family Random Graph Models: Terms and Computational Aspects.
Journal of Statistical Software, 24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj &lt;- c(
c(0, 1, 0, 0, 1, 0),
c(1, 0, 1, 0, 0, 1),
c(0, 1, 0, 1, 1, 0),
c(0, 0, 1, 0, 1, 1),
c(1, 0, 1, 1, 0, 1),
c(0, 1, 0, 1, 1, 0)
)
adj &lt;- matrix(data = adj, nrow = 6, ncol = 6)
rownames(adj) &lt;- as.character(1001:1006)
colnames(adj) &lt;- as.character(1001:1006)

# Use non-consecutive block names
block &lt;- c(50, 70, 95, 50, 95, 70)
g &lt;- network::network(adj, matrix.type = "adjacency")
g %v% "block" &lt;- block
est &lt;- est_between(
  formula = g ~ edges,network = g,
  add_intercepts = FALSE, clustering_with_features = FALSE
)
</code></pre>

<hr>
<h2 id='est_within'>Estimate a within-block network model.</h2><span id='topic+est_within'></span>

<h3>Description</h3>

<p>Function to estimate the within-block model. Both pseudo-maximum likelihood and monte carlo approximate maximum likelihood estimators are implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_within(
  formula,
  network,
  seed = NULL,
  method = "MPLE",
  add_intercepts = TRUE,
  clustering_with_features = FALSE,
  return_network = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_within_+3A_formula">formula</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> <code><a href="stats.html#topic+formula">formula</a></code> object of the form
<code>y ~ &lt;model terms&gt;</code>, where <code>y</code> is a
<code><a href="network.html#topic+network">network</a></code> object.
The network object must contain block information as a vertex attribute with the name 'block'.
For the details on the possible <code>&lt;model terms&gt;</code>, see
<code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> and Morris, Handcock and Hunter (2008).
The <code><a href="ergm.multi.html#topic+L-ergmTerm">L-ergmTerm</a></code> is supported to enable size-dependent coefficients.</p>
</td></tr>
<tr><td><code id="est_within_+3A_network">network</code></td>
<td>
<p>a network object with one vertex attribute called 'block' representing which node belongs to which block</p>
</td></tr>
<tr><td><code id="est_within_+3A_seed">seed</code></td>
<td>
<p>seed value (integer) for the random number generator</p>
</td></tr>
<tr><td><code id="est_within_+3A_method">method</code></td>
<td>
<p>If &quot;MPLE&quot; (the default), then the maximum pseudolikelihood estimator is returned.
If &quot;MLE&quot;, then an approximate maximum likelihood estimator is returned.</p>
</td></tr>
<tr><td><code id="est_within_+3A_add_intercepts">add_intercepts</code></td>
<td>
<p>Boolean value to indicate whether adequate intercepts
should be added to the provided formula so that the model in the first stage
of the estimation is a nested model of the estimated model in the second stage of the estimation</p>
</td></tr>
<tr><td><code id="est_within_+3A_clustering_with_features">clustering_with_features</code></td>
<td>
<p>Boolean value to indicate if the clustering
was carried out making use of the covariates or not (only important if <code>add_intercepts = TRUE</code>)</p>
</td></tr>
<tr><td><code id="est_within_+3A_return_network">return_network</code></td>
<td>
<p>Boolean value to indicate if the network object should be returned in the output.
This is needed if the user wants to use, e.g., the <code><a href="ergm.html#topic+gof">gof</a></code> function as opposed to the <code><a href="#topic+gof.bigergm">gof.bigergm</a></code> function.</p>
</td></tr>
<tr><td><code id="est_within_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to the <code><a href="ergm.html#topic+ergm">ergm</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'ergm' object of the estimated model.
</p>


<h3>References</h3>

<p>Morris M, Handcock MS, Hunter DR (2008). Specification of Exponential-Family Random Graph Models: Terms and Computational Aspects.
Journal of Statistical Software, 24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj &lt;- c(
c(0, 1, 0, 0, 1, 0),
c(1, 0, 1, 0, 0, 1),
c(0, 1, 0, 1, 1, 0),
c(0, 0, 1, 0, 1, 1),
c(1, 0, 1, 1, 0, 1),
c(0, 1, 0, 1, 1, 0)
)
adj &lt;- matrix(data = adj, nrow = 6, ncol = 6)
rownames(adj) &lt;- as.character(1001:1006)
colnames(adj) &lt;- as.character(1001:1006)

# Use non-consecutive block names
block &lt;- c(70, 70, 70, 70, 95, 95)
g &lt;- network::network(adj, matrix.type = "adjacency", directed = FALSE)
g %v% "block" &lt;- block
g %v% "vertex.names" &lt;- 1:length(g %v% "vertex.names")
est &lt;- est_within(
formula = g ~ edges,
  network = g,
  parallel = FALSE,
  verbose = 0,
  initial_estimate = NULL,
  seed = NULL,
  method = "MPLE", 
  add_intercepts = FALSE,
  clustering_with_features = FALSE
  )
</code></pre>

<hr>
<h2 id='get_between_networks'>Obtain the between-block networks defined by the block attribute.</h2><span id='topic+get_between_networks'></span>

<h3>Description</h3>

<p>Function to return a list of networks, each network representing the within-block network of a block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_between_networks(network, block)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_between_networks_+3A_network">network</code></td>
<td>
<p>a network object</p>
</td></tr>
<tr><td><code id="get_between_networks_+3A_block">block</code></td>
<td>
<p>a vector of integers representing the block of each node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of networks
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load an embedded network object.
data(toyNet)
get_within_networks(toyNet, toyNet %v% "block")
</code></pre>

<hr>
<h2 id='get_within_networks'>Obtain the within-block networks defined by the block attribute.</h2><span id='topic+get_within_networks'></span>

<h3>Description</h3>

<p>Function to return a list of networks, each network representing the within-block network of a block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_within_networks(network, block, combined_networks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_within_networks_+3A_network">network</code></td>
<td>
<p>a network object</p>
</td></tr>
<tr><td><code id="get_within_networks_+3A_block">block</code></td>
<td>
<p>a vector of integers representing the block of each node</p>
</td></tr>
<tr><td><code id="get_within_networks_+3A_combined_networks">combined_networks</code></td>
<td>
<p>a boolean indicating whether the between-block networks should be returned as a <code>combined_networks</code> object or not (default is TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of networks
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load an embedded network object.
data(toyNet)
get_within_networks(toyNet, toyNet %v% "block")
</code></pre>

<hr>
<h2 id='gof.bigergm'>Conduct Goodness-of-Fit Diagnostics on a Exponential Family Random Graph
Model for big networks</h2><span id='topic+gof.bigergm'></span>

<h3>Description</h3>

<p>A sample of graphs is randomly drawn from the specified model.  The first
argument is typically the output of a call to <code><a href="#topic+bigergm">bigergm</a></code> and the
model used for that call is the one fit.
</p>
<p>By default, the sample consists of 100 simulated networks, but this sample
size (and many other settings) can be changed using the <code>ergm_control</code>
argument described above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigergm'
gof(
  object,
  ...,
  type = "full",
  control_within = ergm::control.simulate.formula(),
  seed = NULL,
  nsim = 100,
  compute_geodesic_distance = TRUE,
  start_from_observed = TRUE,
  simulate_sbm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gof.bigergm_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+bigergm">bigergm</a></code> object.</p>
</td></tr>
<tr><td><code id="gof.bigergm_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to <code><a href="#topic+simulate_bigergm">simulate_bigergm</a></code>,
which, in turn, passes the information to <code><a href="ergm.html#topic+simulate_formula">simulate_formula</a></code>.
See documentation for <code><a href="#topic+bigergm">bigergm</a></code>.</p>
</td></tr>
<tr><td><code id="gof.bigergm_+3A_type">type</code></td>
<td>
<p>the type of evaluation to perform. Can take the values <code>full</code> or <code>within</code>. <code>full</code> performs the evaluation on all edges, and <code>within</code> only considers within-block edges.</p>
</td></tr>
<tr><td><code id="gof.bigergm_+3A_control_within">control_within</code></td>
<td>
<p>MCMC parameters as an instance of <code>control.simulate.formula</code> to be used for the within-block simulations.</p>
</td></tr>
<tr><td><code id="gof.bigergm_+3A_seed">seed</code></td>
<td>
<p>the seed to be passed to simulate_bigergm. If <code>NULL</code>, a random seed is used.</p>
</td></tr>
<tr><td><code id="gof.bigergm_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations to employ for calculating goodness of fit, default is 100.</p>
</td></tr>
<tr><td><code id="gof.bigergm_+3A_compute_geodesic_distance">compute_geodesic_distance</code></td>
<td>
<p>if <code>TRUE</code>, the distribution of geodesic distances is also computed (considerably increases computation time on large networks. <code>FALSE</code> by default.)</p>
</td></tr>
<tr><td><code id="gof.bigergm_+3A_start_from_observed">start_from_observed</code></td>
<td>
<p>if <code>TRUE</code>, MCMC uses the observed network as a starting point. If <code>FALSE</code>, MCMC starts from a random network.</p>
</td></tr>
<tr><td><code id="gof.bigergm_+3A_simulate_sbm">simulate_sbm</code></td>
<td>
<p>if <code>TRUE</code>, the between-block connections are simulated from the estimated stochastic block model from the first stage not the estimated ERGM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+gof.bigergm">gof.bigergm</a></code> returns a list with two entries.
The first entry 'original' is another list of the network stats, degree distribution, edgewise-shared partner distribution, and geodesic distance distribution (if <code>compute_geodesic_distance = TRUE</code>) of the observed network.
The second entry is called 'simulated' is also list compiling the network stats, degree distribution, edgewise-shared partner distribution, and geodesic distance distribution (if <code>compute_geodesic_distance = TRUE</code>) of all simulated networks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyNet)

# Specify the model that you would like to estimate.
data(toyNet)
# Specify the model that you would like to estimate.
model_formula &lt;- toyNet ~ edges + nodematch("x") + nodematch("y") + triangle
estimate &lt;- bigergm(model_formula,n_blocks = 4)
gof_res &lt;- gof(estimate,
nsim = 100
)
plot(gof_res)

</code></pre>

<hr>
<h2 id='kapferer'>Kapferer collaboration network</h2><span id='topic+kapferer'></span>

<h3>Description</h3>

<p>The network corresponds to collaborations between 39 workers in a tailor shop in Africa:
an undirected edge between workers <code>i</code> and <code>j</code> indicates that the workers collaborated.
The network is taken from Kapferer (1972).
</p>


<h3>Format</h3>

<p>A <code>statnet</code>'s network class object.
data(kapferer)
</p>


<h3>References</h3>

<p>Kapferer, B. (1972). Strategy and Transaction in an African Factory. Manchester University Press, Manchester, U.K.
</p>

<hr>
<h2 id='plot.bigergm'>Plot the network with the found clusters</h2><span id='topic+plot.bigergm'></span>

<h3>Description</h3>

<p>This function plots the network with the found clusters. The nodes are colored according to the found clusters.
Note that the function uses the <code>network</code> package for plotting the network and should therefore not be used for large networks with more than 1-2 K vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigergm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bigergm_+3A_x">x</code></td>
<td>
<p>The output of the bigergm function</p>
</td></tr>
<tr><td><code id="plot.bigergm_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions</p>
</td></tr>
</table>

<hr>
<h2 id='py_dep'>Install optional Python dependencies for bigergm</h2><span id='topic+py_dep'></span>

<h3>Description</h3>

<p>Install Python dependencies needed for using the Python implementation of infomap.
The code uses the <code>reticulate</code> package to install the Python packages <code>infomap</code> and <code>numpy</code>.
These packages are needed for the <code>bigergm</code> function when <code>use_infomap_python = TRUE</code> else the Python implementation is not needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>py_dep(envname = "r-bigergm", method = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="py_dep_+3A_envname">envname</code></td>
<td>
<p>The name, or full path, of the environment in which Python packages
are to be installed. When NULL (the default), the active environment as set
by the RETICULATE_PYTHON_ENV variable will be used; if that is unset, then the
r-reticulate environment will be used.</p>
</td></tr>
<tr><td><code id="py_dep_+3A_method">method</code></td>
<td>
<p>Installation method. By default,
&quot;auto&quot; automatically finds a method that will
work in the local environment. Change the
default to force a specific installation method.
Note that the &quot;virtualenv&quot; method is not available on Windows.</p>
</td></tr>
<tr><td><code id="py_dep_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for installing the Python dependencies 'infomap' and 'numpy'
</p>

<hr>
<h2 id='reed'>A network of friendships between students at Reed College.</h2><span id='topic+reed'></span>

<h3>Description</h3>

<p>The data was collected by Facebook and provided as part of Traud et al. (2012)
</p>


<h3>Format</h3>

<p>A <code>statnet</code>'s network class object. It has three nodal features.
</p>

<dl>
<dt>doorm</dt><dd><p>anonymized dorm in which each node lives.</p>
</dd>
<dt>gender</dt><dd><p>gender of each node.</p>
</dd>
<dt>high.school</dt><dd><p>anonymized highschool to which each node went to.</p>
</dd>
<dt>year</dt><dd><p>year of graduation of each node.</p>
</dd>
</dl>
<p>...

data(reed)
</p>


<h3>References</h3>

<p>Traud, Mucha, Porter (2012). Social Structure of Facebook Network.
Physica A: Statistical Mechanics and its Applications, 391, 4165-4180
</p>

<hr>
<h2 id='rice'>A network of friendships between students at Rice University.</h2><span id='topic+rice'></span>

<h3>Description</h3>

<p>The data was collected by Facebook and provided as part of Traud et al. (2012)
</p>


<h3>Format</h3>

<p>A <code>statnet</code>'s network class object. It has three nodal features.
</p>

<dl>
<dt>doorm</dt><dd><p>anonymized dorm in which each node lives.</p>
</dd>
<dt>gender</dt><dd><p>gender of each node.</p>
</dd>
<dt>high.school</dt><dd><p>anonymized highschool to which each node went to.</p>
</dd>
<dt>year</dt><dd><p>year of graduation of each node.</p>
</dd>
</dl>

<p>data(rice)
</p>


<h3>References</h3>

<p>Traud, Mucha, Porter (2012). Social Structure of Facebook Network.
Physica A: Statistical Mechanics and its Applications, 391, 4165-4180
</p>

<hr>
<h2 id='simulate_bigergm'>Simulate networks under Exponential Random Graph Models (ERGMs) under local dependence</h2><span id='topic+simulate_bigergm'></span>

<h3>Description</h3>

<p>This function simulates networks under Exponential Random Graph Models (ERGMs) with local dependence.
There is also an option to simulate only within-block networks and a S3 method for the class <code>bigergm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_bigergm(
  formula,
  coef_within,
  coef_between,
  network = ergm.getnetwork(formula),
  control_within = ergm::control.simulate.formula(),
  only_within = FALSE,
  seed = NULL,
  nsim = 1,
  output = "network",
  verbose = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_bigergm_+3A_formula">formula</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> <code><a href="stats.html#topic+formula">formula</a></code> object of the form
<code>y ~ &lt;model terms&gt;</code>, where <code>y</code> is a
<code><a href="network.html#topic+network">network</a></code> object.
The network object must contain block information as a vertex attribute with the name 'block'.
For the details on the possible <code>&lt;model terms&gt;</code>, see
<code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> and Morris, Handcock and Hunter (2008).
All terms that induce dependence are excluded from the between block model, while the within block model includes all terms.
The <code><a href="ergm.multi.html#topic+L-ergmTerm">L-ergmTerm</a></code> is supported to enable size-dependent coefficients for the within-blocks model.
Note, however, that for size-dependent parameters of terms that are included in the between-blocks model,
the intercept in the linear model provided to <code><a href="ergm.multi.html#topic+L-ergmTerm">L-ergmTerm</a></code> should not include the intercept.
See the second example of <code><a href="#topic+bigergm">bigergm</a></code> for a demonstration.</p>
</td></tr>
<tr><td><code id="simulate_bigergm_+3A_coef_within">coef_within</code></td>
<td>
<p>a vector of within-block parameters. The order of the parameters should match that of the formula.</p>
</td></tr>
<tr><td><code id="simulate_bigergm_+3A_coef_between">coef_between</code></td>
<td>
<p>a vector of between-block parameters. The order of the parameters should match that of the formula without externality terms.</p>
</td></tr>
<tr><td><code id="simulate_bigergm_+3A_network">network</code></td>
<td>
<p>a network object to be used as a seed network for the simulation (if none is provided, the network on the lhs of the <code>formula</code> is used).</p>
</td></tr>
<tr><td><code id="simulate_bigergm_+3A_control_within">control_within</code></td>
<td>
<p>auxiliary function as user interface for fine-tuning ERGM simulation for within-block networks.</p>
</td></tr>
<tr><td><code id="simulate_bigergm_+3A_only_within">only_within</code></td>
<td>
<p>If this is TRUE, only within-block networks are simulated.</p>
</td></tr>
<tr><td><code id="simulate_bigergm_+3A_seed">seed</code></td>
<td>
<p>seed value (integer) for network simulation.</p>
</td></tr>
<tr><td><code id="simulate_bigergm_+3A_nsim">nsim</code></td>
<td>
<p>number of networks generated.</p>
</td></tr>
<tr><td><code id="simulate_bigergm_+3A_output">output</code></td>
<td>
<p>Normally character, one of &quot;network&quot; (default), &quot;stats&quot;, &quot;edgelist&quot;, to determine the output format.</p>
</td></tr>
<tr><td><code id="simulate_bigergm_+3A_verbose">verbose</code></td>
<td>
<p>If this is TRUE/1, the program will print out additional information about the progress of simulation.</p>
</td></tr>
<tr><td><code id="simulate_bigergm_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code><a href="ergm.html#topic+simulate_formula">simulate_formula</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated networks, the output form depends on the parameter <code>output</code>
(default is a list of networks).
</p>


<h3>References</h3>

<p>Morris M, Handcock MS, Hunter DR (2008). Specification of Exponential-Family Random Graph Models: Terms and Computational Aspects.
Journal of Statistical Software, 24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyNet)
# Specify the model that you would like to estimate.
model_formula &lt;- toyNet ~ edges + nodematch("x") + nodematch("y") + triangle
# Simulate network stats
sim_stats &lt;- bigergm::simulate_bigergm(
formula = model_formula,
  # Formula for the model
coef_between = c(-4.5,0.8, 0.4),
# The coefficients for the between connections
coef_within = c(-1.7,0.5,0.6,0.15),
# The coefficients for the within connections
nsim = 10,
# Number of simulations to return
output = "stats",
# Type of output
)

</code></pre>

<hr>
<h2 id='simulate.bigergm'>Simulate networks under Exponential Random Graph Models (ERGMs) under local dependence</h2><span id='topic+simulate.bigergm'></span>

<h3>Description</h3>

<p>This function simulates networks under the Exponential Random Graph Model (ERGM)
with local dependence with all parameters set according to the estimated model (<code>object</code>).
See <code><a href="#topic+simulate_bigergm">simulate_bigergm</a></code> for details of the simulation process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigergm'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  ...,
  output = "network",
  control_within = ergm::control.simulate.formula(),
  only_within = FALSE,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.bigergm_+3A_object">object</code></td>
<td>
<p>an object of class <code>bigergm</code></p>
</td></tr>
<tr><td><code id="simulate.bigergm_+3A_nsim">nsim</code></td>
<td>
<p>number of networks to be randomly drawn from the given distribution on the set of all networks.</p>
</td></tr>
<tr><td><code id="simulate.bigergm_+3A_seed">seed</code></td>
<td>
<p>seed value (integer) for network simulation.</p>
</td></tr>
<tr><td><code id="simulate.bigergm_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code><a href="ergm.html#topic+simulate_formula">simulate_formula</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.bigergm_+3A_output">output</code></td>
<td>
<p>Normally character, one of &quot;network&quot; (default), &quot;stats&quot;, &quot;edgelist&quot;, to determine the output of the function.</p>
</td></tr>
<tr><td><code id="simulate.bigergm_+3A_control_within">control_within</code></td>
<td>
<p><code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code> object for fine-tuning ERGM simulation of within-block networks.</p>
</td></tr>
<tr><td><code id="simulate.bigergm_+3A_only_within">only_within</code></td>
<td>
<p>If this is TRUE, only within-block networks are simulated.</p>
</td></tr>
<tr><td><code id="simulate.bigergm_+3A_verbose">verbose</code></td>
<td>
<p>If this is TRUE/1, the program will print out additional information about the progress of simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated networks, the output form depends on the parameter <code>output</code>
(default is a list of networks).
</p>

<hr>
<h2 id='state_twitter'>Twitter (X) network of U.S. state legislators</h2><span id='topic+state_twitter'></span>

<h3>Description</h3>

<p>The network includes the Twitter (X) following interactions between U.S. state legislators.
The data was collection by Gopal et al. (2022) and Kim et al. (2022).
For this network, we only include the largest connected component of state legislators that were active on Twitter in the six months leading up to and including the insurrection at the United States Capitol on January 6, 2021.
All state senate and state representatives for states with a bicameral system are included and all state legislators for state (Nebraska) with a unicameral system are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(state_twitter)
</code></pre>


<h3>Format</h3>

<p>A <code>statnet</code>'s network class object. It has the following categorical attributes for each state legislator.
</p>

<dl>
<dt>gender</dt><dd><p>factor stating whether the legislator is 'female' or 'male'.</p>
</dd>
<dt>party</dt><dd><p>party affiliation of the legislator, which is 'Democratic', 'Independent' or 'Republican'.</p>
</dd>
<dt>race</dt><dd><p>race with the following levels: 'Asian or Pacific Islander', 'Black', 'Latino', 'MENA(Middle East and North Africa)','Multiracial', 'Native American', and 'White'.</p>
</dd>
<dt>state</dt><dd><p>character of the state that the legislator represents.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gopal, Kim, Nakka, Boehmke, Harden, Desmarais.
The National Network of U.S. State Legislators on Twitter.
Political Science Research &amp; Methods, Forthcoming.
</p>
<p>Kim, Nakka, Gopal, Desmarais,Mancinelli, Harden, Ko, and Boehmke (2022).
Attention to the COVID-19 pandemic on Twitter: Partisan differences among U.S. state legislators. Legislative Studies Quarterly 47, 1023‚Äì1041.
</p>

<hr>
<h2 id='toyNet'>A toy network to play <code>bigergm</code> with.</h2><span id='topic+toyNet'></span>

<h3>Description</h3>

<p>This network has a clear cluster structure.
The number of clusters is four, and which cluster each node belongs to is defined in the variable &quot;block&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(toyNet)
</code></pre>


<h3>Format</h3>

<p>A <code>statnet</code>'s network class object. It has three nodal features.
</p>

<dl>
<dt>block</dt><dd><p>block membership of each node</p>
</dd>
<dt>x</dt><dd><p>a covariate. It has 10 labels.</p>
</dd>
<dt>y</dt><dd><p>a covariate. It has 10 labels.</p>
</dd>
</dl>
<p>...

<code>1</code> and <code>2</code> are not variables with any particular meaning.
</p>

<hr>
<h2 id='yule'>Compute Yule's Phi-coefficient</h2><span id='topic+yule'></span>

<h3>Description</h3>

<p>This function computes Yule's Phi-coefficient between the true and estimated block membership (its definition can be found here <a href="https://en.wikipedia.org/wiki/Phi_coefficient">https://en.wikipedia.org/wiki/Phi_coefficient</a>).
In this context, the Phi Coefficient is a measure of association between two group membership vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yule(z_star, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yule_+3A_z_star">z_star</code></td>
<td>
<p>a true block membership</p>
</td></tr>
<tr><td><code id="yule_+3A_z">z</code></td>
<td>
<p>an estimated block membership</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Real value of Yule's Phi-coefficient between the true and estimated block membership is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyNet)
yule(z_star = toyNet%v% "block",
                  z = sample(c(1:4),size = 200,replace = TRUE))
                  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
