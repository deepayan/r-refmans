<!DOCTYPE html><html><head><title>Help for package bigergm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigergm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compute_multiplied_feature_matrices'><p>Get a list of sparse feature adjacency matrix from a formula.</p></a></li>
<li><a href='#compute_yule_coef'><p>Compute Yule's Phi-coefficient</p></a></li>
<li><a href='#draw_between_block_connection'><p>Draw between-block connections.</p></a></li>
<li><a href='#draw_within_block_connection'><p>Draw within-block connections</p></a></li>
<li><a href='#estimate_between_param'><p>Estimate between-block parameters by logit</p></a></li>
<li><a href='#estimate_within_params'><p>Estimate a within-block network model.</p></a></li>
<li><a href='#get_list_sparse_feature_adjmat'><p>Get a list of sparse feature adjacency matrix from a formula</p></a></li>
<li><a href='#gof_bigergm'><p>Goodness of fit statistics for HERGM</p></a></li>
<li><a href='#hergm'><p>Hierarchical exponential-family random graph models (HERGMs) with local dependence</p></a></li>
<li><a href='#install_python_dependencies'><p>Install optional Python dependencies</p></a></li>
<li><a href='#simulate_hergm'><p>Simulate a network</p></a></li>
<li><a href='#simulate_hergm_within'><p>Sample within cluster networks</p></a></li>
<li><a href='#toyNet'><p>A toy network to play <code>bigergm</code> with.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fit, Simulate, and Diagnose Hierarchical Exponential-Family
Models for Big Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox to analyze and simulate large networks based on hierarchical exponential-family random graph models (HERGMs).'bigergm' implements the estimation for large networks efficiently on large networks building on the 'lighthergm' package. Moreover, the package contains tools for simulating networks with local dependence to assess the estimates' goodness-of-fit.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ergm (&ge; 4.5.0), Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.10.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RcppArmadillo (&ge; 0.10.5), network (&ge; 1.16.0), Matrix,
cachem, tidyr, statnet.common, methods, stringr, intergraph,
igraph, parallel, magrittr, purrr, dplyr, tibble, glue, readr,
foreach, rlang, doParallel, memoise, reticulate</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat, sna</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-15 14:31:24 UTC; corneliusfritz</td>
</tr>
<tr>
<td>Author:</td>
<td>Shota Komatsu [aut],
  Juan Nelson Mart√≠nez Dahbura [aut],
  Takanori Nishida [aut],
  Angelo Mele [aut],
  Cornelius Fritz [aut, cre],
  Michael Schweinberger [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cornelius Fritz &lt;corneliusfritz2010@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-16 15:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='compute_multiplied_feature_matrices'>Get a list of sparse feature adjacency matrix from a formula.</h2><span id='topic+compute_multiplied_feature_matrices'></span>

<h3>Description</h3>

<p>These matrices can be given to the <code><a href="#topic+hergm">hergm</a></code> function as parameters. Generally, this function should only be used if users are working with large networks and are planning to continually estimate the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_multiplied_feature_matrices(net, list_feature_matrices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_multiplied_feature_matrices_+3A_net">net</code></td>
<td>
<p>a network object from which nodal covariates are extracted.</p>
</td></tr>
<tr><td><code id="compute_multiplied_feature_matrices_+3A_list_feature_matrices">list_feature_matrices</code></td>
<td>
<p>a list of feature adjacency matrices generated by <code>get_list_sparse_feature_adjmat()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of sparse matrices of multiplied feature matrices that are needed for carrying our the first step of the estimation if the covariates should be used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyNet)

model_formula &lt;- toyNet ~ edges + nodematch("x") + nodematch("y") 
list_feature_matrices &lt;- get_list_sparse_feature_adjmat(toyNet, model_formula)
multiplied_feature_matrices &lt;- 
  compute_multiplied_feature_matrices(net = toyNet,
  list_feature_matrices = list_feature_matrices)

</code></pre>

<hr>
<h2 id='compute_yule_coef'>Compute Yule's Phi-coefficient</h2><span id='topic+compute_yule_coef'></span>

<h3>Description</h3>

<p>Compute Yule's Phi-coefficient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_yule_coef(z_star, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_yule_coef_+3A_z_star">z_star</code></td>
<td>
<p>a true block membership</p>
</td></tr>
<tr><td><code id="compute_yule_coef_+3A_z">z</code></td>
<td>
<p>an estimated block membership</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Real value of Yule's Phi-coefficient between the true and estimated block membership is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyNet)
compute_yule_coef(z_star = toyNet%v% "block",
                  z = sample(c(1:4),size = 200,replace = TRUE))
                  
</code></pre>

<hr>
<h2 id='draw_between_block_connection'>Draw between-block connections.</h2><span id='topic+draw_between_block_connection'></span>

<h3>Description</h3>

<p>Draw between-block connections. There may be some edges that appear both in within- and between-block links.
The overlapped edges will be removed after this step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_between_block_connection(
  formula_for_simulation,
  sorted_dataframe,
  coef_between_block,
  seed_edgelist_between = NULL,
  use_fast_between_simulation = FALSE,
  list_feature_matrices = NULL,
  seed = NULL,
  n_sim = 1,
  prevent_duplicate = TRUE,
  verbose = 0,
  ergm_control = ergm::control.simulate.formula(),
  output = "edgelist",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_between_block_connection_+3A_formula_for_simulation">formula_for_simulation</code></td>
<td>
<p>formula for simulating a between-block network</p>
</td></tr>
<tr><td><code id="draw_between_block_connection_+3A_sorted_dataframe">sorted_dataframe</code></td>
<td>
<p>a data frame with the covariate information. The order must match the nodes in the network and it must contain the coliumn 'vertex_id' matching the network.</p>
</td></tr>
<tr><td><code id="draw_between_block_connection_+3A_coef_between_block">coef_between_block</code></td>
<td>
<p>a vector of between-block parameters. The order of the parameters should match that of the formula.</p>
</td></tr>
<tr><td><code id="draw_between_block_connection_+3A_seed_edgelist_between">seed_edgelist_between</code></td>
<td>
<p>a seed edgelist from which a between-block network is simulated.</p>
</td></tr>
<tr><td><code id="draw_between_block_connection_+3A_use_fast_between_simulation">use_fast_between_simulation</code></td>
<td>
<p>If <code>TRUE</code>, this function uses an effcient way to simulate a between-block network.
If the network is very large, you should consider using this option.
Note that when you use this, the first element of <code>coef_between_block</code> must be the edges parameter.</p>
</td></tr>
<tr><td><code id="draw_between_block_connection_+3A_list_feature_matrices">list_feature_matrices</code></td>
<td>
<p>a list of feature adjacency matrices. This is used when <code>use_fast_between_simulation</code>.</p>
</td></tr>
<tr><td><code id="draw_between_block_connection_+3A_seed">seed</code></td>
<td>
<p>seed value (integer) for the random number generator.</p>
</td></tr>
<tr><td><code id="draw_between_block_connection_+3A_n_sim">n_sim</code></td>
<td>
<p>number of networks generated.</p>
</td></tr>
<tr><td><code id="draw_between_block_connection_+3A_prevent_duplicate">prevent_duplicate</code></td>
<td>
<p>If <code>TRUE</code>, the coefficient on nodematch(&quot;block&quot;) is set to be a very large negative number in drawing between-block links,
so that there will be (almost) no within-block links.</p>
</td></tr>
<tr><td><code id="draw_between_block_connection_+3A_verbose">verbose</code></td>
<td>
<p>If this is TRUE/1, the program will print out additionalinformation about the progress of simulation.</p>
</td></tr>
<tr><td><code id="draw_between_block_connection_+3A_ergm_control">ergm_control</code></td>
<td>
<p>auxiliary function as user interface for fine-tuning ERGM simulation</p>
</td></tr>
<tr><td><code id="draw_between_block_connection_+3A_output">output</code></td>
<td>
<p>Normally character, one of &quot;network&quot; (default), &quot;stats&quot;, &quot;edgelist&quot;, to determine the output format.</p>
</td></tr>
<tr><td><code id="draw_between_block_connection_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ergm.html#topic+network.list">network.list</a></code> object of the <code>n_sim</code> networks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyNet)

# Specify the model that you would like to estimate.
model_formula &lt;- toyNet ~ edges + nodematch("x") + nodematch("y") 
# Estimate the model
nodes_data &lt;- data.frame(
  vertex_id = 1:toyNet$gal$n,
  x = toyNet %v% "x",
  y = toyNet %v% "y",
  block = toyNet %v% "block"
)
list_feature_matrices &lt;- 
   get_list_sparse_feature_adjmat(toyNet, model_formula)
toyNet &lt;- network::as.edgelist(toyNet)

draw_between_block_connection(formula_for_simulation = model_formula, 
                              sorted_dataframe = nodes_data,
                              coef_between_block = c(-2,0.1,0.2),
                              n_sim = 10)

</code></pre>

<hr>
<h2 id='draw_within_block_connection'>Draw within-block connections</h2><span id='topic+draw_within_block_connection'></span>

<h3>Description</h3>

<p>Draw within-block connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_within_block_connection(
  seed_network,
  formula_for_simulation,
  coef_within_block,
  ergm_control,
  output = "network",
  seed,
  n_sim,
  verbose,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_within_block_connection_+3A_seed_network">seed_network</code></td>
<td>
<p>a seed network from which a network will be simulated.</p>
</td></tr>
<tr><td><code id="draw_within_block_connection_+3A_formula_for_simulation">formula_for_simulation</code></td>
<td>
<p>formula for simulating a network</p>
</td></tr>
<tr><td><code id="draw_within_block_connection_+3A_coef_within_block">coef_within_block</code></td>
<td>
<p>a vector of within-block parameters. The order of the parameters should match that of the formula.</p>
</td></tr>
<tr><td><code id="draw_within_block_connection_+3A_ergm_control">ergm_control</code></td>
<td>
<p>auxiliary function as user interface for fine-tuning ERGM simulation</p>
</td></tr>
<tr><td><code id="draw_within_block_connection_+3A_output">output</code></td>
<td>
<p>Normally character, one of &quot;network&quot; (default), &quot;stats&quot;, &quot;edgelist&quot;, to determine the output format.</p>
</td></tr>
<tr><td><code id="draw_within_block_connection_+3A_seed">seed</code></td>
<td>
<p>seed value (integer) for the random number generator.</p>
</td></tr>
<tr><td><code id="draw_within_block_connection_+3A_n_sim">n_sim</code></td>
<td>
<p>Number of networks to be randomly drawn from the given distribution on the set of all networks.</p>
</td></tr>
<tr><td><code id="draw_within_block_connection_+3A_verbose">verbose</code></td>
<td>
<p>If this is TRUE/1, the program will print out additionalinformation about the progress of simulation.</p>
</td></tr>
<tr><td><code id="draw_within_block_connection_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated within-block connections, the output form depends on the parameter <code>output</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyNet)

model_formula &lt;- toyNet ~ edges + nodematch("x") + nodematch("y") 
draw_within_block_connection(formula_for_simulation = model_formula, 
                             coef_within_block = c(-2,0.1,0.2),
                             ergm_control = control.simulate(),
                             seed_network =toyNet,
                             verbose = TRUE, 
                             output = "edgelist",
                             seed = 123, 
                             n_sim = 1)


</code></pre>

<hr>
<h2 id='estimate_between_param'>Estimate between-block parameters by logit</h2><span id='topic+estimate_between_param'></span>

<h3>Description</h3>

<p>Estimate between-block parameters by logit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_between_param(formula, network, block)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_between_param_+3A_formula">formula</code></td>
<td>
<p>formula for estimating between-block parameters</p>
</td></tr>
<tr><td><code id="estimate_between_param_+3A_network">network</code></td>
<td>
<p>network object</p>
</td></tr>
<tr><td><code id="estimate_between_param_+3A_block">block</code></td>
<td>
<p>a vector that represents which node belongs to which node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'ergm' object of the estimated model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj &lt;- c(
c(0, 1, 0, 0, 1, 0),
c(1, 0, 1, 0, 0, 1),
c(0, 1, 0, 1, 1, 0),
c(0, 0, 1, 0, 1, 1),
c(1, 0, 1, 1, 0, 1),
c(0, 1, 0, 1, 1, 0)
)
adj &lt;- matrix(data = adj, nrow = 6, ncol = 6)
rownames(adj) &lt;- as.character(1001:1006)
colnames(adj) &lt;- as.character(1001:1006)

# Use non-consecutive block names
block &lt;- c(50, 70, 95, 50, 95, 70)

g &lt;- network::network(adj, matrix.type = "adjacency")

est &lt;- estimate_between_param(
  formula = g ~ edges,network = g, block = block
)
</code></pre>

<hr>
<h2 id='estimate_within_params'>Estimate a within-block network model.</h2><span id='topic+estimate_within_params'></span>

<h3>Description</h3>

<p>Estimate a within-block network model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_within_params(
  formula,
  network,
  z_memb,
  number_cores = 1,
  verbose = 1,
  seeds = NULL,
  method_second_step = c("MPLE", "MLE"),
  offset_coef = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_within_params_+3A_formula">formula</code></td>
<td>
<p>a within network formula</p>
</td></tr>
<tr><td><code id="estimate_within_params_+3A_network">network</code></td>
<td>
<p>a network object</p>
</td></tr>
<tr><td><code id="estimate_within_params_+3A_z_memb">z_memb</code></td>
<td>
<p>block memberships for each node</p>
</td></tr>
<tr><td><code id="estimate_within_params_+3A_number_cores">number_cores</code></td>
<td>
<p>The number of CPU cores to use.</p>
</td></tr>
<tr><td><code id="estimate_within_params_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer: if this is TRUE/1,
the program will print out additional information about the progress of estimation and simulation.</p>
</td></tr>
<tr><td><code id="estimate_within_params_+3A_seeds">seeds</code></td>
<td>
<p>seed value (integer) for the random number generator</p>
</td></tr>
<tr><td><code id="estimate_within_params_+3A_method_second_step">method_second_step</code></td>
<td>
<p>If &quot;MPLE&quot; (the default), then the maximum pseudolikelihood estimator is returned.
If &quot;MLE&quot;, then an approximate maximum likelihood estimator is returned.</p>
</td></tr>
<tr><td><code id="estimate_within_params_+3A_offset_coef">offset_coef</code></td>
<td>
<p>a vector of model parameters to be fixed when estimation.(i.e., not estimated).</p>
</td></tr>
<tr><td><code id="estimate_within_params_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'ergm' object of the estimated model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj &lt;- c(
c(0, 1, 0, 0, 1, 0),
c(1, 0, 1, 0, 0, 1),
c(0, 1, 0, 1, 1, 0),
c(0, 0, 1, 0, 1, 1),
c(1, 0, 1, 1, 0, 1),
c(0, 1, 0, 1, 1, 0)
)
adj &lt;- matrix(data = adj, nrow = 6, ncol = 6)
rownames(adj) &lt;- as.character(1001:1006)
colnames(adj) &lt;- as.character(1001:1006)

# Use non-consecutive block names
block &lt;- c(50, 70, 95, 50, 95, 70)

g &lt;- network::network(adj, matrix.type = "adjacency")

est &lt;- estimate_within_params(
  formula = g ~ edges,
  network = g,
  z_memb = block,
  parallel = FALSE,
  verbose = 0,
  initial_estimate = NULL,
  seeds = NULL,
  method_second_step = "MPLE"
)
</code></pre>

<hr>
<h2 id='get_list_sparse_feature_adjmat'>Get a list of sparse feature adjacency matrix from a formula</h2><span id='topic+get_list_sparse_feature_adjmat'></span>

<h3>Description</h3>

<p>Get a list of sparse feature adjacency matrix from a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_list_sparse_feature_adjmat(network, formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_list_sparse_feature_adjmat_+3A_network">network</code></td>
<td>
<p>a network object from which nodal covariates are extracted.</p>
</td></tr>
<tr><td><code id="get_list_sparse_feature_adjmat_+3A_formula">formula</code></td>
<td>
<p>a network model to be considered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of sparse matrices of feature matrices that are used for the first step of the estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyNet)
model_formula &lt;- toyNet ~ edges + nodematch("x") + nodematch("y") 
list_feature_matrices &lt;- 
  get_list_sparse_feature_adjmat(toyNet, model_formula)
</code></pre>

<hr>
<h2 id='gof_bigergm'>Goodness of fit statistics for HERGM</h2><span id='topic+gof_bigergm'></span>

<h3>Description</h3>

<p>Goodness of fit statistics for HERGM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof_bigergm(
  net,
  data_for_simulation,
  list_feature_matrices,
  colname_vertex_id,
  colname_block_membership,
  bigergm_results,
  type = "full",
  ergm_control = ergm::control.simulate.formula(),
  seed = NULL,
  n_sim = 1,
  prevent_duplicate = TRUE,
  compute_geodesic_distance = FALSE,
  start_from_observed = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_bigergm_+3A_net">net</code></td>
<td>
<p>the target network</p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_data_for_simulation">data_for_simulation</code></td>
<td>
<p>a dataframe with node-level covariates</p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_list_feature_matrices">list_feature_matrices</code></td>
<td>
<p>a list of feature adjacency matrices</p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_colname_vertex_id">colname_vertex_id</code></td>
<td>
<p>the name of the column that contains the node id</p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_colname_block_membership">colname_block_membership</code></td>
<td>
<p>the name o the column that contains the block affiliation of each node</p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_bigergm_results">bigergm_results</code></td>
<td>
<p>a bigergm results object</p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_type">type</code></td>
<td>
<p>the type of evaluation to perform. Can take the values <code>full</code> or <code>within</code>. <code>full</code> performs the evaluation on all edges, and <code>within</code> only considers within-block edges.</p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_ergm_control">ergm_control</code></td>
<td>
<p>MCMC parameters as an instance of ergm.control</p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_seed">seed</code></td>
<td>
<p>the seed to be passed to simulate_hergm</p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_n_sim">n_sim</code></td>
<td>
<p>the number of simulations to employ for calculating goodness of fit</p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_prevent_duplicate">prevent_duplicate</code></td>
<td>
<p>see <code>simulate_hergm</code></p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_compute_geodesic_distance">compute_geodesic_distance</code></td>
<td>
<p>if <code>TRUE</code>, the distribution of geodesic distances is also computed (considerably increases computation time on large networks. <code>FALSE</code> by default.)</p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_start_from_observed">start_from_observed</code></td>
<td>
<p>if <code>TRUE</code>, MCMC uses the observed network as a starting point</p>
</td></tr>
<tr><td><code id="gof_bigergm_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+gof_bigergm">gof_bigergm</a></code> returns a list with two entries.
The first entry 'original' is another list of the network stats, degree distribution, edgewise-shared partner distribution, and geodesic distance distribution (if <code>compute_geodesic_distance = TRUE</code>) of the observed network.
The second entry is called 'simulated' is also list compiling the network stats, degree distribution, edgewise-shared partner distribution, and geodesic distance distribution (if <code>compute_geodesic_distance = TRUE</code>) of all simulated networks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyNet)

# Specify the model that you would like to estimate.
model_formula &lt;- toyNet ~ edges + nodematch("x") + nodematch("y") + triangle
# Estimate the model
nodes_data &lt;- data.frame(
  node_id = 1:toyNet$gal$n,
  x = toyNet %v% "x",
  y = toyNet %v% "y",
  block = toyNet %v% "block"
)
list_feature_matrices &lt;- bigergm::get_list_sparse_feature_adjmat(toyNet, model_formula)
estimate &lt;- hergm(model_formula,n_clusters = 4)
gof_res &lt;- bigergm::gof_bigergm(
  toyNet,
  list_feature_matrices = list_feature_matrices,
  data_for_simulation = nodes_data,
  colname_vertex_id = "node_id",
  colname_block_membership = "block",
  bigergm_results = estimate,
  n_sim = 100
)


</code></pre>

<hr>
<h2 id='hergm'>Hierarchical exponential-family random graph models (HERGMs) with local dependence</h2><span id='topic+hergm'></span>

<h3>Description</h3>

<p>The function hergm estimates and simulates three classes of hierarchical exponential-family random graph models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hergm(
  object,
  n_clusters,
  n_cores = 1,
  block_membership = NULL,
  estimate_parameters = TRUE,
  verbose = 0,
  n_MM_step_max = 100,
  tol_MM_step = 1e-04,
  initialization_method = 1,
  use_infomap_python = FALSE,
  virtualenv_python = "r-bigergm",
  seed_infomap = NULL,
  weight_for_initialization = 1000,
  seeds = NULL,
  initialized_cluster_data = NULL,
  method_second_step = "MPLE",
  clustering_with_features = TRUE,
  list_multiplied_feature_matrices = NULL,
  fix_covariate_parameter = FALSE,
  compute_pi = FALSE,
  check_alpha_update = FALSE,
  check_block_membership = FALSE,
  cache = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hergm_+3A_object">object</code></td>
<td>
<p>A formula or <code>bigergm</code> class object. A <code>bigergm</code> is returned by <code>hergm()</code>.
When you pass a <code>bigergm</code> class object to <code>hergm()</code>, you can restart the MM step.</p>
</td></tr>
<tr><td><code id="hergm_+3A_n_clusters">n_clusters</code></td>
<td>
<p>The number of blocks. This must be specified by the user.
When you pass a &quot;bigergm&quot; class object to <code>hergm()</code>, you don't have to specify this argument.</p>
</td></tr>
<tr><td><code id="hergm_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of CPU cores to use.</p>
</td></tr>
<tr><td><code id="hergm_+3A_block_membership">block_membership</code></td>
<td>
<p>The pre-specified block memberships for each node.
If <code>NULL</code>, the latent community structure is estimated, assuming that the number of communities is <code>n_clusters</code>.</p>
</td></tr>
<tr><td><code id="hergm_+3A_estimate_parameters">estimate_parameters</code></td>
<td>
<p>If <code>TRUE</code>, both clustering and parameter estimation are implemented.
If <code>FALSE</code>, only clustering is executed.</p>
</td></tr>
<tr><td><code id="hergm_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer: if this is TRUE/1,
the program will print out additional information about the progress of estimation and simulation.
A higher value yields lower level information.</p>
</td></tr>
<tr><td><code id="hergm_+3A_n_mm_step_max">n_MM_step_max</code></td>
<td>
<p>The maximum number of MM iterations.
Currently, no early stopping criteria is introduced. Thus <code>n_MM_step_max</code> MM iterations are exactly implemented.</p>
</td></tr>
<tr><td><code id="hergm_+3A_tol_mm_step">tol_MM_step</code></td>
<td>
<p>Tolerance regarding the relative change of the lower bound of the likelihood
used to decide on the convergence of the clustering step</p>
</td></tr>
<tr><td><code id="hergm_+3A_initialization_method">initialization_method</code></td>
<td>
<p>Cluster initialization method.
If <code>1</code> (the default), <code>igraph</code>'s infomap is implemented.
If <code>2</code>, the initial clusters are randomly uniformally selected.
If <code>3</code>, spectral clustering is conducted.</p>
</td></tr>
<tr><td><code id="hergm_+3A_use_infomap_python">use_infomap_python</code></td>
<td>
<p>If <code>TRUE</code>, the cluster initialization is implemented using Pythons' infomap.</p>
</td></tr>
<tr><td><code id="hergm_+3A_virtualenv_python">virtualenv_python</code></td>
<td>
<p>Which virtual environment should be used for the infomap algorithm?</p>
</td></tr>
<tr><td><code id="hergm_+3A_seed_infomap">seed_infomap</code></td>
<td>
<p>seed value (integer) for the infomap algorithm, which can be used to initialize the estimation of the blocks</p>
</td></tr>
<tr><td><code id="hergm_+3A_weight_for_initialization">weight_for_initialization</code></td>
<td>
<p>weight value used for cluster initialization. The higher this value, the more weight is put on the initialized alpha.</p>
</td></tr>
<tr><td><code id="hergm_+3A_seeds">seeds</code></td>
<td>
<p>seed value (integer) for the random number generator</p>
</td></tr>
<tr><td><code id="hergm_+3A_initialized_cluster_data">initialized_cluster_data</code></td>
<td>
<p>initialized cluster data from which the MM iterations begin.
This can be either a vector of block affiliations of each node or initialized cluster data by Python's infomap (given by .clu format).</p>
</td></tr>
<tr><td><code id="hergm_+3A_method_second_step">method_second_step</code></td>
<td>
<p>If &quot;MPLE&quot; (the default), then the maximum pseudolikelihood estimator is implemented when estimating the within-block network model.
If &quot;MLE&quot;, then an approximate maximum likelihood estimator is conducted.</p>
</td></tr>
<tr><td><code id="hergm_+3A_clustering_with_features">clustering_with_features</code></td>
<td>
<p>If <code>TRUE</code>, clustering is implemented using the discrete covariates specified in the formula.</p>
</td></tr>
<tr><td><code id="hergm_+3A_list_multiplied_feature_matrices">list_multiplied_feature_matrices</code></td>
<td>
<p>a list of multiplied feature adjacency matrices necessary for MM step.
If <code>NULL</code>, <code>hergm()</code> automatically calculates. Or you can calculate by <code>compute_multiplied_feature_matrices()</code>.</p>
</td></tr>
<tr><td><code id="hergm_+3A_fix_covariate_parameter">fix_covariate_parameter</code></td>
<td>
<p>If <code>TRUE</code>, when estimating the within-block network model,
parameters for covariates are fixed at the estimated of the between-block network model.</p>
</td></tr>
<tr><td><code id="hergm_+3A_compute_pi">compute_pi</code></td>
<td>
<p>If <code>TRUE</code>, this function keeps track of pi matrices at each MM iteration.
If the network is large, we strongly recommend to set to be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hergm_+3A_check_alpha_update">check_alpha_update</code></td>
<td>
<p>If <code>TRUE</code>, this function keeps track of alpha matrices at each MM iteration.
If the network is large, we strongly recommend to set to be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hergm_+3A_check_block_membership">check_block_membership</code></td>
<td>
<p>If TRUE, this function keeps track of estimated block memberships at each MM iteration.</p>
</td></tr>
<tr><td><code id="hergm_+3A_cache">cache</code></td>
<td>
<p>a <code>cachem</code> cache object used to store intermediate calculations such as eigenvector decomposition results.</p>
</td></tr>
<tr><td><code id="hergm_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'bigergm' including the results of the fitted model.
These include:
</p>

<dl>
<dt>call:</dt><dd><p>call of the mode</p>
</dd>
<dt>partition:</dt><dd><p>vector of the found partition of the nodes into cluster</p>
</dd>
<dt>initial_block:</dt><dd><p>vector of the initial partition of the nodes into cluster</p>
</dd>
<dt>sbm_pi:</dt><dd><p>Connection probabilities represented as a <code>n_clusters x n_clusters</code> matrix from the first stage of the estimation between all clusters</p>
</dd>
<dt>MM_list_z:</dt><dd><p>list of cluster allocation for each node and each iteration</p>
</dd>
<dt>MM_list_alpha:</dt><dd><p>list of posterior distributions of cluster allocations for all nodes for each iteration</p>
</dd>
<dt>MM_change_in_alpha:</dt><dd><p>change in 'alpha' for each iteration</p>
</dd>
<dt>MM_lower_bound:</dt><dd><p> vector of the evidence lower bounds from the MM algorithm</p>
</dd>
<dt>alpha: </dt><dd><p>matrix representing the converged posterior distributions of cluster allocations for all nodes</p>
</dd>
<dt>counter_e_step:</dt><dd><p> integer number indicating the number of iterations carried out</p>
</dd>
<dt>adjacency_matrix:</dt><dd><p>sparse matrix representing the adjacency matrix used for the estimation</p>
</dd>
<dt>estimation_status:</dt><dd><p>character stating the status of the estimation</p>
</dd>
<dt>est_within:</dt><dd><p><code><a href="ergm.html#topic+ergm">ergm</a></code> object of the model for within cluster connections </p>
</dd>
<dt>est_between:</dt><dd><p><code><a href="ergm.html#topic+ergm">ergm</a></code> object of the model for between cluster connections</p>
</dd>
<dt>checkpoint:</dt><dd><p>list of information to continue the estimation</p>
</dd>
<dt>membership_before_kmeans:</dt><dd><p>vector of the found partition of the nodes into cluster before the final check for bad clusters</p>
</dd>
<dt>estimate_parameters:</dt><dd><p>binary value if the parameters in the second step of the algorithm should be estimated or not</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Load an embedded network object.
data(toyNet)

# Specify the model that you would like to estimate.
model_formula &lt;- toyNet ~ edges + nodematch("x") + nodematch("y") + triangle
# Estimate the model
hergm_res &lt;- bigergm::hergm(
  object = model_formula,
  # The model you would like to estimate
  n_clusters = 4,
  # The number of blocks
  n_MM_step_max = 10,
  # The maximum number of MM algorithm steps
  estimate_parameters = TRUE,
  # Perform parameter estimation after the block recovery step
  clustering_with_features = TRUE,
  # Indicate that clustering must take into account nodematch on characteristics
  check_block_membership = FALSE)
  
</code></pre>

<hr>
<h2 id='install_python_dependencies'>Install optional Python dependencies</h2><span id='topic+install_python_dependencies'></span>

<h3>Description</h3>

<p>Install Python dependencies needed for using the Python implementation of infomap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_python_dependencies(envname = "r-bigergm", method = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_python_dependencies_+3A_envname">envname</code></td>
<td>
<p>The name, or full path, of the environment in which Python packages
are to be installed. When NULL (the default), the active environment as set
by the RETICULATE_PYTHON_ENV variable will be used; if that is unset, then the
r-reticulate environment will be used.</p>
</td></tr>
<tr><td><code id="install_python_dependencies_+3A_method">method</code></td>
<td>
<p>Installation method. By default,
&quot;auto&quot; automatically finds a method that will
work in the local environment. Change the
default to force a specific installation method.
Note that the &quot;virtualenv&quot; method is not available on Windows.</p>
</td></tr>
<tr><td><code id="install_python_dependencies_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for installing the Python dependencies 'infomap' and 'numpy'
</p>

<hr>
<h2 id='simulate_hergm'>Simulate a network</h2><span id='topic+simulate_hergm'></span>

<h3>Description</h3>

<p>Simulate a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_hergm(
  formula_for_simulation,
  data_for_simulation,
  colname_vertex_id,
  colname_block_membership,
  seed_edgelist = NULL,
  coef_within_block,
  coef_between_block,
  ergm_control = ergm::control.simulate.formula(),
  seed = NULL,
  directed = FALSE,
  n_sim = 1,
  output = "network",
  prevent_duplicate = TRUE,
  use_fast_between_simulation = FALSE,
  list_feature_matrices = NULL,
  verbose = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_hergm_+3A_formula_for_simulation">formula_for_simulation</code></td>
<td>
<p>formula for simulating a network</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_data_for_simulation">data_for_simulation</code></td>
<td>
<p>a data frame that contains vertex id, block membership, and vertex features.</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_colname_vertex_id">colname_vertex_id</code></td>
<td>
<p>a column name in the data frame for the vertex id</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_colname_block_membership">colname_block_membership</code></td>
<td>
<p>a column name in the data frame for the block membership</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_seed_edgelist">seed_edgelist</code></td>
<td>
<p>an edgelist used for creating a seed network. It should have the &quot;edgelist&quot; class</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_coef_within_block">coef_within_block</code></td>
<td>
<p>a vector of within-block parameters. The order of the parameters should match that of the formula.</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_coef_between_block">coef_between_block</code></td>
<td>
<p>a vector of between-block parameters. The order of the parameters should match that of the formula without externality terms.</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_ergm_control">ergm_control</code></td>
<td>
<p>auxiliary function as user interface for fine-tuning ERGM simulation</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_seed">seed</code></td>
<td>
<p>seed value (integer) for network simulation.</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_directed">directed</code></td>
<td>
<p>whether the simulated network is directed</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_n_sim">n_sim</code></td>
<td>
<p>number of networks generated</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_output">output</code></td>
<td>
<p>Normally character, one of &quot;network&quot; (default), &quot;stats&quot;, &quot;edgelist&quot;, to determine the output format.</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_prevent_duplicate">prevent_duplicate</code></td>
<td>
<p>If <code>TRUE</code>, the coefficient on nodematch(&quot;block&quot;) is set to be a very large negative number in drawing between-block links, so that there will be (almost) no within-block links.</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_use_fast_between_simulation">use_fast_between_simulation</code></td>
<td>
<p>If <code>TRUE</code>, this function uses an effcient way to simulate a between-block network. If the network is very large, you should consider using this option.
Note that when you use this, the first element of <code>coef_between_block</code> must be the edges parameter.</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_list_feature_matrices">list_feature_matrices</code></td>
<td>
<p>a list of feature adjacency matrices. If <code>use_fast_between_simulation</code>, this must be given.</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_verbose">verbose</code></td>
<td>
<p>If this is TRUE/1, the program will print out additional information about the progress of simulation.</p>
</td></tr>
<tr><td><code id="simulate_hergm_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated networks, the output form depends on the parameter <code>output</code>
(default is a list of networks).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyNet)

# Specify the model that you would like to estimate.
model_formula &lt;- toyNet ~ edges + nodematch("x") + nodematch("y") + triangle

# Prepare a data frame that contains nodal id and covariates.
nodes_data &lt;-
  data.frame(
    node_id = network::network.vertex.names(toyNet),
    block = network::get.vertex.attribute(toyNet, "block"),
    x = network::get.vertex.attribute(toyNet, "x"),
    y = network::get.vertex.attribute(toyNet, "y")
  )
# The feature adjacency matrices
list_feature_matrices &lt;- bigergm::get_list_sparse_feature_adjmat(toyNet, model_formula)

# Simulate network stats
sim_stats &lt;- bigergm::simulate_hergm(
  formula_for_simulation = model_formula,
  data_for_simulation = nodes_data,
  # Nodal data
  colname_vertex_id = "node_id", 
  # Name of the column containing node IDs
  colname_block_membership = "block",
  # Name of the column containing block IDs
  coef_between_block = c(-4.5,0.8, 0.4),
  # The coefficients for the between connections
  coef_within_block = c(-1.7,0.5,0.6,0.15),
  n_sim = 10,
  # Number of simulations to return
  output = "stats",
  # Type of output
  list_feature_matrices = list_feature_matrices
  # Information on the covariates
)

</code></pre>

<hr>
<h2 id='simulate_hergm_within'>Sample within cluster networks</h2><span id='topic+simulate_hergm_within'></span>

<h3>Description</h3>

<p>Obtains network statistics based on MCMC simulations including only the within-blocks connections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_hergm_within(
  formula_for_simulation,
  data_for_simulation,
  colname_vertex_id,
  colname_block_membership,
  coef_within_block,
  seed_edgelist = NULL,
  output = "stats",
  ergm_control = ergm::control.simulate.formula(),
  seed = NULL,
  n_sim = 1,
  verbose = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_hergm_within_+3A_formula_for_simulation">formula_for_simulation</code></td>
<td>
<p>formula for simulating a network</p>
</td></tr>
<tr><td><code id="simulate_hergm_within_+3A_data_for_simulation">data_for_simulation</code></td>
<td>
<p>a data frame that contains vertex id, block membership, and vertex features.</p>
</td></tr>
<tr><td><code id="simulate_hergm_within_+3A_colname_vertex_id">colname_vertex_id</code></td>
<td>
<p>a column name in the data frame for the vertex ids</p>
</td></tr>
<tr><td><code id="simulate_hergm_within_+3A_colname_block_membership">colname_block_membership</code></td>
<td>
<p>a column name in the data frame for the block membership</p>
</td></tr>
<tr><td><code id="simulate_hergm_within_+3A_coef_within_block">coef_within_block</code></td>
<td>
<p>a vector of within-block parameters. The order of the parameters should match that of the formula.</p>
</td></tr>
<tr><td><code id="simulate_hergm_within_+3A_seed_edgelist">seed_edgelist</code></td>
<td>
<p>an edgelist used for creating a seed network. It should have the &quot;edgelist&quot; class</p>
</td></tr>
<tr><td><code id="simulate_hergm_within_+3A_output">output</code></td>
<td>
<p>The desired output of the simulation (any of <code>stats</code>, <code>network</code> or <code>edgelist</code>). Defaults to <code>stats</code></p>
</td></tr>
<tr><td><code id="simulate_hergm_within_+3A_ergm_control">ergm_control</code></td>
<td>
<p>auxiliary function as user interface for fine-tuning ERGM simulation</p>
</td></tr>
<tr><td><code id="simulate_hergm_within_+3A_seed">seed</code></td>
<td>
<p>seed value (integer) for network simulation.</p>
</td></tr>
<tr><td><code id="simulate_hergm_within_+3A_n_sim">n_sim</code></td>
<td>
<p>number of networks generated</p>
</td></tr>
<tr><td><code id="simulate_hergm_within_+3A_verbose">verbose</code></td>
<td>
<p>If this is TRUE/1, the program will print out additional information about the progress of simulation.</p>
</td></tr>
<tr><td><code id="simulate_hergm_within_+3A_...">...</code></td>
<td>
<p>arguments to be passed to low level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.frame' object where the columns relate to the sufficient statistics specified in <code>formula_for_simulation</code> and each row relates to one of the <code>n_sim</code> simulations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyNet) 
# Specify the model that you would like to estimate.
model_formula &lt;- toyNet ~ edges + nodematch("x") + nodematch("y") 
# Estimate the model
nodes_data &lt;- data.frame(
  node_id = 1:toyNet$gal$n,
  x = toyNet %v% "x",
  y = toyNet %v% "y",
  block = toyNet %v% "block"
)
list_feature_matrices &lt;- 
   get_list_sparse_feature_adjmat(toyNet, model_formula)
toyNet &lt;- network::as.edgelist(toyNet)

simulate_hergm_within(formula_for_simulation = model_formula, 
                      data_for_simulation = nodes_data,
                      colname_vertex_id = "node_id",
                      colname_block_membership = "block",
                      coef_within_block = c(-2,0.1,0.2),
                      n_sim = 10)

</code></pre>

<hr>
<h2 id='toyNet'>A toy network to play <code>bigergm</code> with.</h2><span id='topic+toyNet'></span>

<h3>Description</h3>

<p>This network has a clear cluster structure.
The number of clusters is four, and which cluster each node belongs to is defined in the variable &quot;block&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toyNet
</code></pre>


<h3>Format</h3>

<p>A <code>statnet</code>'s network class object. It has three nodal features.
</p>

<dl>
<dt>block</dt><dd><p>block membership of each node</p>
</dd>
<dt>x</dt><dd><p>a covariate. It has 10 labels.</p>
</dd>
<dt>y</dt><dd><p>a covariate. It has 10 labels.</p>
</dd>
</dl>
<p>...

<code>x</code> and <code>y</code> are not variables with any particular meaning.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
