<!DOCTYPE html><html><head><title>Help for package hdbayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hdbayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hdbayes-package'><p>hdbayes: Bayesian Analysis of Generalized Linear Models with Historical Data</p></a></li>
<li><a href='#actg019'><p>AIDS Clinical Trial ACTG019</p></a></li>
<li><a href='#actg036'><p>AIDS Clinical Trial ACTG036</p></a></li>
<li><a href='#E1694'><p>ECOG E1694 Trial</p></a></li>
<li><a href='#E2696'><p>ECOG E2696 Trial</p></a></li>
<li><a href='#glm.bhm'><p>Posterior of Bayesian hierarchical model (BHM)</p></a></li>
<li><a href='#glm.commensurate'><p>Posterior of commensurate prior (CP)</p></a></li>
<li><a href='#glm.leap'><p>Posterior of Latent Exchangeability Prior (LEAP)</p></a></li>
<li><a href='#glm.napp'><p>Posterior of normalized asymptotic power prior (NAPP)</p></a></li>
<li><a href='#glm.npp'><p>Posterior of normalized power prior (NPP)</p></a></li>
<li><a href='#glm.npp.lognc'><p>Estimate the logarithm of the normalizing constant for normalized power prior (NPP) for one data set</p></a></li>
<li><a href='#glm.pp'><p>Posterior of power prior (PP) with fixed <code class="reqn">a_0</code></p></a></li>
<li><a href='#glm.rmap'><p>Posterior of robust meta-analytic predictive prior (RMAP)</p></a></li>
<li><a href='#glm.rmap.bhm'><p>Posterior of robust meta-analytic predictive prior (RMAP)</p></a></li>
<li><a href='#glm.rmap.bhm.approx'><p>Posterior of robust meta-analytic predictive prior (RMAP)</p></a></li>
<li><a href='#IBCSG_curr'><p>International Breast Cancer Study Group (IBCSG) Trial VI Data</p></a></li>
<li><a href='#IBCSG_hist'><p>International Breast Cancer Study Group (IBCSG) Trial VI Data</p></a></li>
<li><a href='#lm.npp'><p>Posterior of normalized power prior (NPP) for normal linear models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Analysis of Generalized Linear Models with Historical
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>User-friendly functions for leveraging (multiple) historical data set(s)
    for generalized linear models. Contains functions for sampling from the posterior
    distribution of a generalized linear model using the prior induced by the Bayesian 
    hierarchical model, power prior by Ibrahim and Chen (2000) &lt;<a href="https://doi.org/10.1214%2Fss%2F1009212673">doi:10.1214/ss/1009212673</a>&gt;, 
    normalized power prior by Duan et al. (2006) &lt;<a href="https://doi.org/10.1002%2Fenv.752">doi:10.1002/env.752</a>&gt;, normalized
    asymptotic power prior by Ibrahim et al. (2015) &lt;<a href="https://doi.org/10.1002%2Fsim.6728">doi:10.1002/sim.6728</a>&gt;, commensurate
    prior by Hobbs et al. (2011) &lt;<a href="https://doi.org/10.1111%2Fj.1541-0420.2011.01564.x">doi:10.1111/j.1541-0420.2011.01564.x</a>&gt;, robust 
    meta-analytic-predictive prior by Schmidli et al. (2014) &lt;<a href="https://doi.org/10.1111%2Fbiom.12242">doi:10.1111/biom.12242</a>&gt;,
    and the latent exchangeability prior (LEAP) by Alt et al. (2023) &lt;<a href="https://doi.org/10.48550/arXiv.2303.05223">doi:10.48550/arXiv.2303.05223</a>&gt;.
    The package compiles all the 'CmdStan' models once during installation using the
    'instantiate' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ethan-alt/hdbayes">https://github.com/ethan-alt/hdbayes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ethan-alt/hdbayes/issues">https://github.com/ethan-alt/hdbayes/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>instantiate (&ge; 0.1.0), callr, fs, formula.tools, stats,
posterior, enrichwith, mclust, bridgesampling</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cmdstanr (&ge; 0.6.0), parallel</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>CmdStan
(https://mc-stan.org/users/interfaces/cmdstan)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'E1694-data.R' 'E2696-data.R' 'IBCSG_curr-data.R'
'IBCSG_hist-data.R' 'actg019-data.R' 'actg036-data.R'
'data_checks.R' 'expfam_loglik.R' 'glm_bhm.R'
'glm_commensurate.R' 'glm_leap.R' 'glm_napp.R'
'glm_npp_lognc.R' 'glm_npp.R' 'glm_pp.R' 'glm_rmap.R'
'glm_rmap_bhm.R' 'glm_rmap_bhm_approx.R' 'hdbayes-package.R'
'lm_npp.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-05 20:39:28 UTC; xinxin</td>
</tr>
<tr>
<td>Author:</td>
<td>Ethan M. Alt <a href="https://orcid.org/0000-0002-6112-9030"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Xinxin Chen [aut],
  Luiz M. Carvalho [aut],
  Joseph G. Ibrahim [aut],
  Xiuya Chang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ethan M. Alt &lt;ethanalt@live.unc.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-08 14:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='hdbayes-package'>hdbayes: Bayesian Analysis of Generalized Linear Models with Historical Data</h2><span id='topic+hdbayes-package'></span><span id='topic+hdbayes'></span>

<h3>Description</h3>

<p>User-friendly functions for leveraging (multiple) historical data set(s) for generalized linear models. Contains functions for sampling from the posterior distribution of a generalized linear model using the prior induced by the Bayesian hierarchical model, power prior by Ibrahim and Chen (2000) <a href="https://doi.org/10.1214/ss/1009212673">doi:10.1214/ss/1009212673</a>, normalized power prior by Duan et al. (2006) <a href="https://doi.org/10.1002/env.752">doi:10.1002/env.752</a>, normalized asymptotic power prior by Ibrahim et al. (2015) <a href="https://doi.org/10.1002/sim.6728">doi:10.1002/sim.6728</a>, commensurate prior by Hobbs et al. (2011) <a href="https://doi.org/10.1111/j.1541-0420.2011.01564.x">doi:10.1111/j.1541-0420.2011.01564.x</a>, robust meta-analytic-predictive prior by Schmidli et al. (2014) <a href="https://doi.org/10.1111/biom.12242">doi:10.1111/biom.12242</a>, and the latent exchangeability prior (LEAP) by Alt et al. (2023) <a href="https://arxiv.org/abs/2303.05223">arXiv:2303.05223</a>. The package compiles all the 'CmdStan' models once during installation using the 'instantiate' package.
</p>
<p>Bayesian analysis of generalized linear models using historical data
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ethan M. Alt <a href="mailto:ethanalt@live.unc.edu">ethanalt@live.unc.edu</a> (<a href="https://orcid.org/0000-0002-6112-9030">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Xinxin Chen
</p>
</li>
<li><p> Luiz M. Carvalho
</p>
</li>
<li><p> Joseph G. Ibrahim
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Xiuya Chang [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ethan-alt/hdbayes">https://github.com/ethan-alt/hdbayes</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ethan-alt/hdbayes/issues">https://github.com/ethan-alt/hdbayes/issues</a>
</p>
</li></ul>


<hr>
<h2 id='actg019'>AIDS Clinical Trial ACTG019</h2><span id='topic+actg019'></span>

<h3>Description</h3>

<p>A data set from the AIDS clinical trial ACTG019 (<a href="https://clinicaltrials.gov/ct2/show/NCT00000736">https://clinicaltrials.gov/ct2/show/NCT00000736</a>) comparing
zidovudine (AZT) with a placebo in adults with asymptomatic HIV infection. The study results were described in
Volberding et al. (1990) <a href="doi:10.1056/NEJM199004053221401">doi:10.1056/NEJM199004053221401</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actg019
</code></pre>


<h3>Format</h3>

<p>A data frame with 822 rows and 5 variables:
</p>

<dl>
<dt>outcome</dt><dd><p>outcome variable with 1 indicating death, development of AIDS or AIDS-related complex (ARC) and 0 otherwise</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>treatment</dt><dd><p>treatment indicator, 0 = placebo, 1 = AZT</p>
</dd>
<dt>race</dt><dd><p>race indicator, 0 = non-white, 1 = white</p>
</dd>
<dt>cd4</dt><dd><p>CD4 cell count</p>
</dd>
</dl>



<h3>References</h3>

<p>Volberding, P. A., Lagakos, S. W., Koch, M. A., Pettinelli, C., Myers, M. W., Booth, D. K., Balfour, H. H., Reichman, R. C., Bartlett, J. A., Hirsch, M. S., Murphy, R. L., Hardy, W. D., Soeiro, R., Fischl, M. A., Bartlett, J. G., Merigan, T. C., Hyslop, N. E., Richman, D. D., Valentine, F. T., Corey, L., and the AIDS Clinical Trials Group of the National Institute of Allergy and Infectious Diseases (1990). Zidovudine in asymptomatic human immunodeficiency virus infection. New England Journal of Medicine, 322(14), 941–949.
</p>
<p>Chen, M.-H., Ibrahim, J. G., and Yiannoutsos, C. (1999). Prior elicitation, Variable Selection and Bayesian computation for Logistic Regression Models. Journal of the Royal Statistical Society Series B: Statistical Methodology, 61(1), 223–242.
</p>

<hr>
<h2 id='actg036'>AIDS Clinical Trial ACTG036</h2><span id='topic+actg036'></span>

<h3>Description</h3>

<p>A data set from the AIDS clinical trial ACTG036 (<a href="https://clinicaltrials.gov/study/NCT00001104">https://clinicaltrials.gov/study/NCT00001104</a>) comparing
zidovudine (AZT) with a placebo in patients with hereditary coagulation disorders and HIV infection. The study
results were described in Merigan et al. (1991) <a href="doi:10.1182/blood.V78.4.900.900">doi:10.1182/blood.V78.4.900.900</a>. This data set has the same
variables as the actg019 data set. We can use the actg019 data as the historical data and the actg036 data as
the current data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actg036
</code></pre>


<h3>Format</h3>

<p>A data frame with 183 rows and 5 variables:
</p>

<dl>
<dt>outcome</dt><dd><p>outcome variable with 1 indicating death, development of AIDS or AIDS-related complex (ARC) and 0 otherwise</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>treatment</dt><dd><p>treatment indicator, 0 = placebo, 1 = AZT</p>
</dd>
<dt>race</dt><dd><p>race indicator, 0 = non-white, 1 = white</p>
</dd>
<dt>cd4</dt><dd><p>CD4 cell count</p>
</dd>
</dl>



<h3>References</h3>

<p>Merigan, T., Amato, D., Balsley, J., Power, M., Price, W., Benoit, S., Perez-Michael, A., Brownstein, A., Kramer, A., and Brettler, D. (1991). Placebo-controlled trial to evaluate zidovudine in treatment of human immunodeficiency virus infection in asymptomatic patients with hemophilia. NHF-ACTG 036 Study Group. Blood, 78(4), 900–906.
</p>
<p>Chen, M.-H., Ibrahim, J. G., and Yiannoutsos, C. (1999). Prior elicitation, Variable Selection and Bayesian computation for Logistic Regression Models. Journal of the Royal Statistical Society Series B: Statistical Methodology, 61(1), 223–242.
</p>

<hr>
<h2 id='E1694'>ECOG E1694 Trial</h2><span id='topic+E1694'></span>

<h3>Description</h3>

<p>A data set from the ECOG E1694 trial comparing the GM2-KLH/QS-21 (GMK) vaccine with high-dose
interferon alfa-2b (IFN) therapy in resected high-risk melanoma patients. The study results
were described in Kirkwood et al. (2001) <a href="doi:10.1200/JCO.2001.19.9.2370">doi:10.1200/JCO.2001.19.9.2370</a>. This data set only
includes patients without nodal metastasis and has the same variables as the E2696 data set.
We can use the E2696 data as the historical data and the E1694 data as the current data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E1694
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 6 variables:
</p>

<dl>
<dt>failtime</dt><dd><p>relapse-free survival (RFS) times (in months)</p>
</dd>
<dt>failind</dt><dd><p>relapse indicator, 0 = right censored, 1 = relapse</p>
</dd>
<dt>treatment</dt><dd><p>treatment indicator, 0 = GMK, 1 = IFN</p>
</dd>
<dt>sex</dt><dd><p>gender indicator, 0 = male, 1 = female</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>perform</dt><dd><p>ECOG performance status indicator, 0 = fully active patient, able to
carry on all pre-disease performance without restriction,
1 = restricted in physically strenuous activity, but are ambulatory
and able to carry out work of a light or sedentary nature</p>
</dd>
</dl>



<h3>References</h3>

<p>Kirkwood, J. M., Ibrahim, J. G., Sosman, J. A., Sondak, V. K., Agarwala, S. S., Ernstoff, M. S., and Rao, U. (2001). High-dose interferon alfa-2b significantly prolongs relapse-free and overall survival compared with the GM2-KLH/QS-21 vaccine in patients with resected stage IIB-III melanoma: Results of intergroup trial E1694/S9512/C509801. Journal of Clinical Oncology, 19(9), 2370–2380.
</p>

<hr>
<h2 id='E2696'>ECOG E2696 Trial</h2><span id='topic+E2696'></span>

<h3>Description</h3>

<p>A data set from the ECOG E2696 trial comparing the combination of the GM2-KLH/QS-21 (GMK) vaccine
and high-dose interferon alfa-2b (IFN) therapy with the GMK vaccine alone in resected high-risk
melanoma patients. The study results were described in Kirkwood et al. (2001) <a href="doi:10.1200/JCO.2001.19.5.1430">doi:10.1200/JCO.2001.19.5.1430</a>.
This data set only includes patients without nodal metastasis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E2696
</code></pre>


<h3>Format</h3>

<p>A data frame with 105 rows and 6 variables:
</p>

<dl>
<dt>failtime</dt><dd><p>relapse-free survival (RFS) times (in months)</p>
</dd>
<dt>failind</dt><dd><p>relapse indicator, 0 = right censored, 1 = relapse</p>
</dd>
<dt>treatment</dt><dd><p>treatment indicator, 0 = GMK, 1 = GMK and IFN</p>
</dd>
<dt>sex</dt><dd><p>gender indicator, 0 = male, 1 = female</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>perform</dt><dd><p>ECOG performance status indicator, 0 = fully active patient, able to
carry on all pre-disease performance without restriction,
1 = restricted in physically strenuous activity, but are ambulatory
and able to carry out work of a light or sedentary nature</p>
</dd>
</dl>



<h3>References</h3>

<p>Kirkwood, J. M., Ibrahim, J., Lawson, D. H., Atkins, M. B., Agarwala, S. S., Collins, K., Mascari, R., Morrissey, D. M., and Chapman, P. B. (2001). High-dose interferon alfa-2b does not diminish antibody response to GM2 vaccination in patients with resected melanoma: Results of the multicenter eastern cooperative oncology group phase II trial E2696. Journal of Clinical Oncology, 19(5), 1430–1436.
</p>

<hr>
<h2 id='glm.bhm'>Posterior of Bayesian hierarchical model (BHM)</h2><span id='topic+glm.bhm'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the BHM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.bhm(
  formula,
  family,
  data.list,
  offset.list = NULL,
  meta.mean.mean = NULL,
  meta.mean.sd = NULL,
  meta.sd.mean = NULL,
  meta.sd.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.bhm_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of offset.list is equal to
the length of data.list. The length of each element of offset.list is equal to the number
of rows in the corresponding element of data.list. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_meta.mean.mean">meta.mean.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the means for the normal hyperpriors on the mean hyperparameters of regression coefficients. If
a scalar is provided, meta.mean.mean will be a vector of repeated elements of the given scalar.
Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_meta.mean.sd">meta.mean.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sds for the normal hyperpriors on the mean hyperparameters of regression coefficients. If a
scalar is provided, same as for meta.mean.mean. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_meta.sd.mean">meta.sd.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the means for the half-normal hyperpriors on the sd hyperparameters of regression coefficients.
If a scalar is provided, same as for meta.mean.mean. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_meta.sd.sd">meta.sd.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sds for the half-normal hyperpriors on the sd hyperparameters of regression coefficients.
If a scalar is provided, same as for meta.mean.mean. Defaults to a vector of 1s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_disp.mean">disp.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of data sets (including the current
data) giving the means for the half-normal priors on the dispersion parameters. If a scalar is
provided, same as for meta.mean.mean. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_disp.sd">disp.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of data sets (including the current
data) giving the sds for the half-normal priors on the dispersion parameters. If a scalar is
provided, same as for meta.mean.mean. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BHM assumes that the regression coefficients for the historical and current data are different, but
are correlated through a common distribution, whose hyperparameters (i.e., mean and standard deviation (sd)
(the covariance matrix is assumed to have a diagonal structure)) are treated as random. The number of
of regression coefficients for the current data is assumed to be the same as that for the historical data.
</p>
<p>The hyperpriors on the mean and the sd hyperparameters are independent normal and independent half-normal
distributions, respectively. The priors on the dispersion parameters (if applicable) for the current and
historical data sets are independent half-normal distributions.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  actg036 = actg036[1:50, ]
  data_list = list(currdata = actg019, histdata = actg036)
  glm.bhm(
    formula = outcome ~ scale(age) + race + treatment + scale(cd4),
    family = binomial('logit'),
    data.list = data_list,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.commensurate'>Posterior of commensurate prior (CP)</h2><span id='topic+glm.commensurate'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the CP by Hobbs et al. (2011) <a href="doi:10.1111/j.1541-0420.2011.01564.x">doi:10.1111/j.1541-0420.2011.01564.x</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.commensurate(
  formula,
  family,
  data.list,
  tau,
  offset.list = NULL,
  beta0.mean = NULL,
  beta0.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.commensurate_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code></p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_tau">tau</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the commensurate prior parameters. If a scalar is provided, tau will be a vector of repeated
elements of the given scalar. Each element of tau must be positive, corresponding to a normal
precision parameter.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of offset.list is equal to
the length of data.list. The length of each element of offset.list is equal to the number
of rows in the corresponding element of data.list. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_beta0.mean">beta0.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients
giving the mean parameters for the prior on the historical data regression coefficients. If a
scalar is provided, same as for tau. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_beta0.sd">beta0.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sd parameters for the prior on the historical data regression coefficients. If a scalar is
provided, same as for tau. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_disp.mean">disp.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of data sets (including the current
data) giving the means for the half-normal priors on the dispersion parameters. If a scalar is
provided, same as for tau. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_disp.sd">disp.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of data sets (including the current
data) giving the sds for the half-normal priors on the dispersion parameters. If a scalar is
provided, same as for tau. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CP assumes that the regression coefficients for the current data conditional on those for the historical
data are independent normal distributions with mean equal to the corresponding regression coefficients
for the historical data and variance equal to the inverse of the corresponding elements of a user-specified
vector (tau) of precision parameters. The number of current data regression coefficients is assumed to be the
same as that of historical data regression coefficients. The priors on the dispersion parameters (if applicable)
for the current and historical data sets are independent half-normal distributions.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples.
</p>


<h3>References</h3>

<p>Hobbs, B. P., Carlin, B. P., Mandrekar, S. J., and Sargent, D. J. (2011). Hierarchical commensurate and power prior models for adaptive incorporation of historical information in clinical trials. Biometrics, 67(3), 1047–1056.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  actg036 = actg036[1:50, ]
  data_list = list(currdata = actg019, histdata = actg036)
  glm.commensurate(
    formula = cd4 ~ treatment + age + race,
    family = poisson(), data.list = data_list,
    tau = rep(5, 4),    ## 4 parameters including intercept
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.leap'>Posterior of Latent Exchangeability Prior (LEAP)</h2><span id='topic+glm.leap'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the LEAP by Alt et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.leap(
  formula,
  family,
  data.list,
  K = 2,
  prob.conc = NULL,
  offset.list = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.leap_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_data.list">data.list</code></td>
<td>
<p>a list of two <code>data.frame</code>s giving the current data followed by one historical data set.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_k">K</code></td>
<td>
<p>the desired number of classes to identify. Defaults to 2.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_prob.conc">prob.conc</code></td>
<td>
<p>a scalar or a vector of length <code>K</code> giving the concentration parameters for Dirichlet prior.
If length == 2, a <code>beta(prob.conc[1], prob.conc[2])</code> prior is used. If a scalar is provided,
prob.conc will be a vector of repeated elements of the given scalar. Defaults to a vector of 1s.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of matrices giving the offset for current data followed by historical data. For each
matrix, the number of rows corresponds to observations and columns correspond to classes.
Defaults to a list of matrices of 0s.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_beta.mean">beta.mean</code></td>
<td>
<p>a <code style="white-space: pre;">&#8288;p x K&#8288;</code> matrix of mean parameters for initial prior on regression coefficients (including
intercept). Defaults to a matrix of 0s.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_beta.sd">beta.sd</code></td>
<td>
<p>a <code style="white-space: pre;">&#8288;p x K&#8288;</code> matrix of sd parameters for the initial prior on regression coefficients (including
intercept). Defaults to a matrix of 10s.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_disp.mean">disp.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of classes (<code>K</code>) giving the means for
the half-normal hyperpriors on the dispersion parameters. If a scalar is provided, disp.mean will
be a vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_disp.sd">disp.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of classes (<code>K</code>) giving the sds for
the half-normal hyperpriors on the dispersion parameters. If a scalar is provided, same as for
disp.mean. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LEAP discounts the historical data by identifying the most relevant individuals from the historical data.
It is equivalent to a prior induced by the posterior of a finite mixture model for the historical data set.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples.
</p>


<h3>References</h3>

<p>Alt, E. M., Chang, X., Jiang, X., Liu, Q., Mo, M., Xia, H. M., and Ibrahim, J. G. (2023). LEAP: The latent exchangeability prior for borrowing information from historical data. arXiv preprint.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actg019)
data(actg036)
# take subset for speed purposes
actg019 = actg019[1:100, ]
actg036 = actg036[1:50, ]
if (instantiate::stan_cmdstan_exists()) {
  glm.leap(
    formula = outcome ~ scale(age) + race + treatment + scale(cd4),
    family = binomial('logit'),
    data.list = list(actg019, actg036),
    K = 2,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.napp'>Posterior of normalized asymptotic power prior (NAPP)</h2><span id='topic+glm.napp'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the NAPP by Ibrahim et al. (2015) <a href="doi:10.1002/sim.6728">doi:10.1002/sim.6728</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.napp(
  formula,
  family,
  data.list,
  offset.list = NULL,
  a0.shape1 = 1,
  a0.shape2 = 1,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.napp_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical datasets.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of offset.list is equal to
the length of data.list. The length of each element of offset.list is equal to the number
of rows in the corresponding element of data.list. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_a0.shape1">a0.shape1</code></td>
<td>
<p>first shape parameter for the i.i.d. beta prior on a0 vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_a0.shape2">a0.shape2</code></td>
<td>
<p>second shape parameter for the i.i.d. beta prior on a0 vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NAPP assumes that the regression coefficients and logarithm of the dispersion parameter are a multivariate
normal distribution with mean equal to the maximum likelihood estimate of the historical data and covariance
matrix equal to <code class="reqn">a_0^{-1}</code> multiplied by the inverse Fisher information matrix of the historical data,
where <code class="reqn">a_0</code> is the power prior parameter (treated as random).
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples.
</p>


<h3>References</h3>

<p>Ibrahim, J. G., Chen, M., Gwon, Y., and Chen, F. (2015). The power prior: Theory and applications. Statistics in Medicine, 34(28), 3724–3749.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  actg036 = actg036[1:50, ]
  data_list = list(currdata = actg019, histdata = actg036)
  glm.napp(
    formula = cd4 ~ treatment + age + race,
    family = poisson('log'),
    data.list = data_list,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.npp'>Posterior of normalized power prior (NPP)</h2><span id='topic+glm.npp'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the NPP by Duan et al. (2006) <a href="doi:10.1002/env.752">doi:10.1002/env.752</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.npp(
  formula,
  family,
  data.list,
  a0.lognc,
  lognc,
  offset.list = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  a0.shape1 = 1,
  a0.shape2 = 1,
  a0.lower = NULL,
  a0.upper = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.npp_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_a0.lognc">a0.lognc</code></td>
<td>
<p>a vector giving values of the power prior parameter for which the logarithm of the normalizing
constant has been evaluated.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_lognc">lognc</code></td>
<td>
<p>an S by T matrix where S is the length of a0.lognc, T is the number of historical data sets, and
the j-th column, j = 1, ..., T, is a vector giving the logarithm of the normalizing constant (as
estimated by <code><a href="#topic+glm.npp.lognc">glm.npp.lognc()</a></code> for a0.lognc using the j-th historical data set.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of offset.list is equal to
the length of data.list. The length of each element of offset.list is equal to the number
of rows in the corresponding element of data.list. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_beta.mean">beta.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the mean parameters for the initial prior on regression coefficients. If a scalar is provided,
beta.mean will be a vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_beta.sd">beta.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sd parameters for the initial prior on regression coefficients. If a scalar is provided,
same as for beta.mean. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_disp.mean">disp.mean</code></td>
<td>
<p>mean parameter for the half-normal prior on dispersion parameter. Defaults to 0.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_disp.sd">disp.sd</code></td>
<td>
<p>sd parameter for the half-normal prior on dispersion parameter. Defaults to 10.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_a0.shape1">a0.shape1</code></td>
<td>
<p>first shape parameter for the i.i.d. beta prior on a0 vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_a0.shape2">a0.shape2</code></td>
<td>
<p>second shape parameter for the i.i.d. beta prior on a0 vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_a0.lower">a0.lower</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of historical data sets giving the
lower bounds for each element of the a0 vector. If a scalar is provided, a0.lower will be a
vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_a0.upper">a0.upper</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of historical data sets giving the
upper bounds for each element of the a0 vector. If a scalar is provided, same as for a0.lower.
Defaults to a vector of 1s.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before using this function, users must estimate the logarithm of the normalizing constant across a
range of different values for the power prior parameter (<code class="reqn">a_0</code>), possibly smoothing techniques
over a find grid. The power prior parameters (<code class="reqn">a_0</code>'s) are treated as random with independent
beta priors. The initial priors on the regression coefficients are independent normal priors. The
current and historical data sets are assumed to have a common dispersion parameter with a
half-normal prior (if applicable). For normal linear models, the exact normalizing constants for
NPP can be computed. See the implementation in <code><a href="#topic+lm.npp">lm.npp()</a></code>.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples.
</p>


<h3>References</h3>

<p>Duan, Y., Ye, K., and Smith, E. P. (2005). Evaluating water quality using power priors to incorporate historical information. Environmetrics, 17(1), 95–106.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glm.npp.lognc">glm.npp.lognc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if(requireNamespace("parallel")){
    data(actg019)
    data(actg036)
    ## take subset for speed purposes
    actg019 = actg019[1:100, ]
    actg036 = actg036[1:50, ]

    library(parallel)
    ncores    = 2
    data.list = list(data = actg019, histdata = actg036)
    formula   = cd4 ~ treatment + age + race
    family    = poisson()
    a0        = seq(0, 1, length.out = 11)
    if (instantiate::stan_cmdstan_exists()) {
      ## call created function
      ## wrapper to obtain log normalizing constant in parallel package
      logncfun = function(a0, ...){
        hdbayes::glm.npp.lognc(
          formula = formula, family = family, a0 = a0, histdata = data.list[[2]],
          ...
        )
      }

      cl = makeCluster(ncores)
      clusterSetRNGStream(cl, 123)
      clusterExport(cl, varlist = c('formula', 'family', 'data.list'))
      a0.lognc = parLapply(
        cl = cl, X = a0, fun = logncfun, iter_warmup = 500,
        iter_sampling = 1000, chains = 1, refresh = 0
      )
      stopCluster(cl)
      a0.lognc = data.frame( do.call(rbind, a0.lognc) )

      ## sample from normalized power prior
      glm.npp(
        formula = cd4 ~ treatment + age + race,
        family = poisson(),
        data.list = data.list,
        a0.lognc = a0.lognc$a0,
        lognc = matrix(a0.lognc$lognc, ncol = 1),
        chains = 1, iter_warmup = 500, iter_sampling = 1000,
        refresh = 0
      )
    }
  }

</code></pre>

<hr>
<h2 id='glm.npp.lognc'>Estimate the logarithm of the normalizing constant for normalized power prior (NPP) for one data set</h2><span id='topic+glm.npp.lognc'></span>

<h3>Description</h3>

<p>Uses Markov chain Monte Carlo (MCMC) and bridge sampling to estimate the logarithm of the normalizing
constant for the NPP for a fixed value of the power prior parameter <code class="reqn">a_0 \in (0, 1)</code> for one data
set. The initial priors are independent normal priors on the regression coefficients and a half-normal
prior on the dispersion parameter (if applicable).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.npp.lognc(
  formula,
  family,
  histdata,
  a0,
  offset0 = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  bridge.args = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.npp.lognc_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_histdata">histdata</code></td>
<td>
<p>a <code>data.frame</code> giving the historical data.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_a0">a0</code></td>
<td>
<p>the power prior parameter (a scalar between 0 and 1).</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_offset0">offset0</code></td>
<td>
<p>vector whose dimension is equal to the rows of the historical data set giving an offset for the
historical data. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_beta.mean">beta.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the mean parameters for the normal initial prior on regression coefficients given the dispersion
parameter. If a scalar is provided, beta.mean will be a vector of repeated elements of the given
scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_beta.sd">beta.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sd parameters for the initial prior on regression coefficients. The sd used is
<code>sqrt(dispersion) * beta.sd</code>. If a scalar is provided, same as for beta.mean. Defaults to
a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_disp.mean">disp.mean</code></td>
<td>
<p>mean parameter for the half-normal prior on dispersion parameter. Defaults to 0.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_disp.sd">disp.sd</code></td>
<td>
<p>sd parameter for the half-normal prior on dispersion parameter. Defaults to 10.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_bridge.args">bridge.args</code></td>
<td>
<p>a <code>list</code> giving arguments (other than samples, log_posterior, data, lb, ub) to pass
onto <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a vector giving the value of a0, the estimated logarithm of the normalizing constant, the minimum
estimated bulk effective sample size of the MCMC sampling, and the maximum Rhat.
</p>


<h3>References</h3>

<p>Gronau, Q. F., Singmann, H., and Wagenmakers, E.-J. (2020). bridgesampling: An r package for estimating normalizing constants. Journal of Statistical Software, 92(10).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg036)
  ## take subset for speed purposes
  actg036 = actg036[1:50, ]
  glm.npp.lognc(
    cd4 ~ treatment + age + race,
    family = poisson(), histdata = actg036, a0 = 0.5,
    chains = 1, iter_warmup = 500, iter_sampling = 5000
  )
}
</code></pre>

<hr>
<h2 id='glm.pp'>Posterior of power prior (PP) with fixed <code class="reqn">a_0</code></h2><span id='topic+glm.pp'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the PP by Ibrahim and Chen (2000) <a href="doi:10.1214/ss/1009212673">doi:10.1214/ss/1009212673</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.pp(
  formula,
  family,
  data.list,
  a0.vals,
  offset.list = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.pp_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_a0.vals">a0.vals</code></td>
<td>
<p>a scalar between 0 and 1 or a vector whose dimension is equal to the number of historical
data sets giving the (fixed) power prior parameter for each historical data set. Each element of
vector should be between 0 and 1. If a scalar is provided, same as for beta.mean.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of offset.list is equal to
the length of data.list. The length of each element of offset.list is equal to the number
of rows in the corresponding element of data.list. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_beta.mean">beta.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the mean parameters for the initial prior on regression coefficients. If a scalar is provided,
beta.mean will be a vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_beta.sd">beta.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sd parameters for the initial prior on regression coefficients. If a scalar is provided,
same as for beta.mean. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_disp.mean">disp.mean</code></td>
<td>
<p>mean parameter for the half-normal prior on dispersion parameter. Defaults to 0.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_disp.sd">disp.sd</code></td>
<td>
<p>sd parameter for the half-normal prior on dispersion parameter. Defaults to 10.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power prior parameters (<code class="reqn">a_0</code>'s) are treated as fixed. The initial priors on the regression coefficients
are independent normal priors. The current and historical data sets are assumed to have a common dispersion parameter
with a half-normal prior (if applicable).
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples.
</p>


<h3>References</h3>

<p>Chen, M.-H. and Ibrahim, J. G. (2000). Power prior distributions for Regression Models. Statistical Science, 15(1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  actg036 = actg036[1:50, ]
  data_list = list(currdata = actg019, histdata = actg036)
  glm.pp(
    formula = cd4 ~ treatment + age + race,
    family = poisson('log'),
    data.list = data_list,
    a0.vals = 0.5,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.rmap'>Posterior of robust meta-analytic predictive prior (RMAP)</h2><span id='topic+glm.rmap'></span>

<h3>Description</h3>

<p>Final step for sampling from the posterior distribution of a GLM using the RMAP by Schmidli et al. (2014) <a href="doi:10.1111/biom.12242">doi:10.1111/biom.12242</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.rmap(
  formula,
  family,
  curr.data,
  probs,
  means,
  covs,
  curr.offset = NULL,
  w = 0.1,
  norm.vague.mean = NULL,
  norm.vague.sd = NULL,
  curr.disp.mean = NULL,
  curr.disp.sd = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.rmap_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_curr.data">curr.data</code></td>
<td>
<p>a <code>data.frame</code> giving the current data.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_probs">probs</code></td>
<td>
<p>a vector of mixing proportions in the mixture approximation to the prior induced by the BHM.
Obtained from the outputs of the <code><a href="#topic+glm.rmap.bhm.approx">glm.rmap.bhm.approx()</a></code> function.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_means">means</code></td>
<td>
<p>a matrix with the jth column being the mean vector for the jth component in the mixture
approximation to the prior induced by the BHM. Obtained from the outputs of the
<code><a href="#topic+glm.rmap.bhm.approx">glm.rmap.bhm.approx()</a></code> function.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_covs">covs</code></td>
<td>
<p>a 3-dimensional array giving the covariance matrices for the mixture approximation to the prior
induced by the BHM. Obtained from the outputs of the <code><a href="#topic+glm.rmap.bhm.approx">glm.rmap.bhm.approx()</a></code> function.
the means for the half-normal hyperpriors on the sd hyperparameters of regression coefficients.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_curr.offset">curr.offset</code></td>
<td>
<p>a vector whose dimension is equal to the rows of the current data set giving an offset for
the current data. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_w">w</code></td>
<td>
<p>a scalar between 0 and 1 giving how much weight to put on the historical data.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_norm.vague.mean">norm.vague.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the means for the vague normal prior on regression coefficients. If a scalar is provided,
norm.vague.mean will be a vector of repeated elements of the given scalar. Defaults to a
vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_norm.vague.sd">norm.vague.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sds for the vague normal prior on regression coefficients. If a scalar is provided, same as
for norm.vague.mean. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_curr.disp.mean">curr.disp.mean</code></td>
<td>
<p>a scalar giving the mean for the half-normal hyperprior on the dispersion parameter for the current
data. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_curr.disp.sd">curr.disp.sd</code></td>
<td>
<p>a scalar giving the sd for the half-normal hyperprior on the dispersion parameter for the current
data. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples from the posterior distribution of a GLM using the RMAP. The first component of
the RMAP is a prior induced by the Bayesian hierarchical model (BHM). We approximate this component by
a mixture of multivariate normal distributions where the parameters are obtained from the outputs of the
<code><a href="#topic+glm.rmap.bhm.approx">glm.rmap.bhm.approx()</a></code> function. The second component is a vague (noninformative) multivariate normal
prior. We assume that the covariance matrix of the vague prior is a diagonal matrix.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples.
</p>


<h3>References</h3>

<p>Schmidli, H., Gsteiger, S., Roychoudhury, S., O’Hagan, A., Spiegelhalter, D., and Neuenschwander, B. (2014). Robust meta‐analytic‐predictive priors in clinical trials with historical control information. Biometrics, 70(4), 1023–1032.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glm.rmap.bhm">glm.rmap.bhm()</a></code> for the first step and <code><a href="#topic+glm.rmap.bhm.approx">glm.rmap.bhm.approx()</a></code> for the second step of implementing RMAP.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if (instantiate::stan_cmdstan_exists()) {
    data(actg019) ## current data
    data(actg036) ## historical data
    ## take subset for speed purposes
    actg019 = actg019[1:150, ]
    actg036 = actg036[1:100, ]
    hist_data_list = list(actg036)
    samples_bhm = glm.rmap.bhm(
      formula = outcome ~ scale(age) + race + treatment + scale(cd4),
      family = binomial('logit'),
      hist.data.list = hist_data_list,
      chains = 1, iter_warmup = 1000, iter_sampling = 2000
    )$beta_pred
    res_approx = glm.rmap.bhm.approx(
      samples.bhm = samples_bhm,
      G = 1:5, verbose = FALSE
    )
    glm.rmap(
      formula = outcome ~ scale(age) + race + treatment + scale(cd4),
      family = binomial('logit'),
      curr.data = actg019,
      probs = res_approx$probs,
      means = res_approx$means,
      covs = res_approx$covs,
      chains = 1, iter_warmup = 1000, iter_sampling = 2000
    )
  }

</code></pre>

<hr>
<h2 id='glm.rmap.bhm'>Posterior of robust meta-analytic predictive prior (RMAP)</h2><span id='topic+glm.rmap.bhm'></span>

<h3>Description</h3>

<p>First step for sampling from the posterior distribution of a GLM using the RMAP by Schmidli et al. (2014) <a href="doi:10.1111/biom.12242">doi:10.1111/biom.12242</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.rmap.bhm(
  formula,
  family,
  hist.data.list,
  hist.offset.list = NULL,
  meta.mean.mean = NULL,
  meta.mean.sd = NULL,
  meta.sd.mean = NULL,
  meta.sd.sd = NULL,
  hist.disp.mean = NULL,
  hist.disp.sd = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.rmap.bhm_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_hist.data.list">hist.data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. Each element in the list is a historical data set.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_hist.offset.list">hist.offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each historical data. The length of hist.offset.list is
equal to the length of hist.data.list. The length of each element of hist.offset.list is equal
to the number of rows in the corresponding element of hist.data.list. Defaults to a list of
vectors of 0s.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_meta.mean.mean">meta.mean.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the means for the normal hyperpriors on the mean hyperparameters of regression coefficients. If
a scalar is provided, meta.mean.mean will be a vector of repeated elements of the given scalar.
Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_meta.mean.sd">meta.mean.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sds for the normal hyperpriors on the mean hyperparameters of regression coefficients. If a
scalar is provided, same as for meta.mean.mean. Defaults to a vector of 1s.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_meta.sd.mean">meta.sd.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the means for the half-normal hyperpriors on the sd hyperparameters of regression coefficients.
If a scalar is provided, same as for meta.mean.mean. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_meta.sd.sd">meta.sd.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sds for the half-normal hyperpriors on the sd hyperparameters of regression coefficients.
If a scalar is provided, same as for meta.mean.mean. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_hist.disp.mean">hist.disp.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of historical data sets giving the
means for the half-normal hyperpriors on the dispersion parameters. If a scalar is provided,
same as for meta.mean.mean. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_hist.disp.sd">hist.disp.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of historical data sets giving the
sds for the half-normal hyperpriors on the dispersion parameters. If a scalar is provided, same
as for meta.mean.mean. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RMAP is a mixture prior of two components where one component is a prior induced by the Bayesian hierarchical model (BHM),
and the other is a vague (noninformative) prior. This function samples from the prior induced by the BHM.
</p>


<h3>Value</h3>

<p>The function returns a matrix of the samples of regression coefficients from the prior induced by the BHM.
The number of columns is equal to the number of regression coefficients, and the number of rows is equal to
the number of MCMC samples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glm.rmap.bhm.approx">glm.rmap.bhm.approx()</a></code> for the second step and <code><a href="#topic+glm.rmap">glm.rmap()</a></code> for the final step of implementing RMAP.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg036) ## historical data
  ## take subset for speed purposes
  actg036 = actg036[1:50, ]
  hist_data_list = list(actg036)
  glm.rmap.bhm(
    formula = outcome ~ scale(age) + race + treatment + scale(cd4),
    family = binomial('logit'),
    hist.data.list = hist_data_list,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.rmap.bhm.approx'>Posterior of robust meta-analytic predictive prior (RMAP)</h2><span id='topic+glm.rmap.bhm.approx'></span>

<h3>Description</h3>

<p>Second step for sampling from the posterior distribution of a GLM using the RMAP by Schmidli et al. (2014) <a href="doi:10.1111/biom.12242">doi:10.1111/biom.12242</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.rmap.bhm.approx(samples.bhm, G = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.rmap.bhm.approx_+3A_samples.bhm">samples.bhm</code></td>
<td>
<p>a matrix of the samples of regression coefficients from the prior induced by the BHM, output
from the <code><a href="#topic+glm.rmap.bhm">glm.rmap.bhm()</a></code> function.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm.approx_+3A_g">G</code></td>
<td>
<p>an integer vector giving the numbers of mixtures components (in the mixture approximation to
the BHM) for which the BIC is to be calculated. Defaults to 1:9. See the argument <code>G</code> in
<code><a href="mclust.html#topic+Mclust">?mclust::Mclust</a></code>.</p>
</td></tr>
<tr><td><code id="glm.rmap.bhm.approx_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>. See <a href="https://mclust-org.github.io/mclust/reference/Mclust.html">https://mclust-org.github.io/mclust/reference/Mclust.html</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function approximates the distribution of the output &quot;beta_pred&quot; from the <code><a href="#topic+glm.rmap.bhm">glm.rmap.bhm()</a></code> function (i.e.,
samples from the prior induced by the Bayesian hierarchical model (BHM)) by a mixture of multivariate normal
distributions. We use the <code>mclust</code> package by Scrucca et al. (2023) to implement the mixture approximation.
</p>


<h3>Value</h3>

<p>The function returns a list giving the parameters estimated from the optimal (according to BIC)
mixture model including the mixing proportions, the estimated mean and covariance matrix for each
mixture component. An object of class <code>Mclust</code> from the mclust::Mclust() function is also included.
</p>


<h3>References</h3>

<p>Scrucca, L., Fraley, C., Murphy, T. B., and Raftery, A. E. (2023). Model-Based Clustering, Classification, and Density Estimation Using mclust in R. Chapman and Hall/CRC. ISBN 978-1032234953. <a href="https://mclust-org.github.io/book/">https://mclust-org.github.io/book/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glm.rmap.bhm">glm.rmap.bhm()</a></code> for the first step and <code><a href="#topic+glm.rmap">glm.rmap()</a></code> for the final step of implementing RMAP.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if (instantiate::stan_cmdstan_exists()) {
    data(actg036) ## historical data
    ## take subset for speed purposes
    actg036 = actg036[1:100, ]
    hist_data_list = list(actg036)
    samples_bhm = glm.rmap.bhm(
      formula = outcome ~ scale(age) + race + treatment + scale(cd4),
      family = binomial('logit'),
      hist.data.list = hist_data_list,
      chains = 1, iter_warmup = 1000, iter_sampling = 2000
    )$beta_pred
    glm.rmap.bhm.approx(
      samples.bhm = samples_bhm,
      G = 1:5, verbose = FALSE
    )
  }

</code></pre>

<hr>
<h2 id='IBCSG_curr'>International Breast Cancer Study Group (IBCSG) Trial VI Data</h2><span id='topic+IBCSG_curr'></span>

<h3>Description</h3>

<p>A data set from the IBCSG Trial VI investigating both the duration of adjuvant chemotherapy
(3 versus 6 initial cycles of oral cyclophosphamide, methotrexate, and fluorouracil (CMF)) and
the reintroduction of single courses of delayed chemotherapy in node-positive premenopausal
breast cancer patients. The study results were described by IBCSG (1996) <a href="doi:10.1200/JCO.1996.14.6.1885">doi:10.1200/JCO.1996.14.6.1885</a>
and Hürny et al. (1992) <a href="doi:10.1016/0959-8049(92)90399-m">doi:10.1016/0959-8049(92)90399-m</a>. This data set only includes patients
above the age of 40 (i.e., age <code class="reqn">\geq</code> 40) and treats the measurements of patients' physical well-being
on month 18 as the outcome. The IBCSG_hist data set includes patients from the same study but
with age &lt; 40. We can use the IBCSG_hist data as the historical data and the IBCSG_curr data as
the current data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBCSG_curr
</code></pre>


<h3>Format</h3>

<p>A data frame with 488 rows and 8 variables:
</p>

<dl>
<dt>phys18</dt><dd><p>outcome variable, integer scores between 0 and 100 measuring
the patients' physical well-being on month 18, with a higher
score indicating a better physical well-being</p>
</dd>
<dt>phys1</dt><dd><p>physical well-being scores assessed at the start of the study</p>
</dd>
<dt>n_init_cycles</dt><dd><p>number of initial cycles of CMF, equal to 3 or 6</p>
</dd>
<dt>reintroduction</dt><dd><p>indicator of reintroduction of chemotherapy, 0 = no
reintroduction, 1 = having reintroduction</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>country</dt><dd><p>country, ANZ = New Zealand/Australia, CH = Switzerland,
SWED = Sweden</p>
</dd>
<dt>nodegp</dt><dd><p>indicator of number of positive nodes being greater than or
equal to 4, 0 = less than 4, 1 = 4+</p>
</dd>
<dt>ER</dt><dd><p>estrogen receptor (ER) status indicator, 0 = negative, 1 = positive</p>
</dd>
</dl>



<h3>References</h3>

<p>International Breast Cancer Study Group. (1996). Duration and reintroduction of adjuvant chemotherapy for node-positive premenopausal breast cancer patients. Journal of Clinical Oncology, 14(6), 1885–1894.
</p>
<p>Hürny, C., Bernhard, J., Gelber, R. D., Coates, A., Castiglione, M., Isley, M., Dreher, D., Peterson, H., Goldhirsch, A., and Senn, H.-J. (1992). Quality of life measures for patients receiving adjuvant therapy for breast cancer: An international trial. European Journal of Cancer, 28(1), 118–124.
</p>
<p>Chi, Y.-Y. and Ibrahim, J. G. (2005). Joint models for multivariate longitudinal and Multivariate Survival Data. Biometrics, 62(2), 432–445.
</p>

<hr>
<h2 id='IBCSG_hist'>International Breast Cancer Study Group (IBCSG) Trial VI Data</h2><span id='topic+IBCSG_hist'></span>

<h3>Description</h3>

<p>A data set from the IBCSG Trial VI investigating both the duration of adjuvant chemotherapy
(3 versus 6 initial cycles of oral cyclophosphamide, methotrexate, and fluorouracil (CMF)) and
the reintroduction of single courses of delayed chemotherapy in node-positive premenopausal
breast cancer patients. The study results were described by IBCSG (1996) <a href="doi:10.1200/JCO.1996.14.6.1885">doi:10.1200/JCO.1996.14.6.1885</a>
and Hürny et al. (1992) <a href="doi:10.1016/0959-8049(92)90399-m">doi:10.1016/0959-8049(92)90399-m</a>. This data set only includes patients
under the age of 40 (i.e., age &lt; 40) and treats the measurements of patients' physical well-being
on month 18 as the outcome. The IBCSG_curr data set includes patients from the same study but
with age <code class="reqn">\geq</code> 40. We can use the IBCSG_hist data as the historical data and the IBCSG_curr data as
the current data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBCSG_hist
</code></pre>


<h3>Format</h3>

<p>A data frame with 103 rows and 8 variables:
</p>

<dl>
<dt>phys18</dt><dd><p>outcome variable, integer scores between 0 and 100 measuring
the patients' physical well-being on month 18, with a higher
score indicating a better physical well-being</p>
</dd>
<dt>phys1</dt><dd><p>physical well-being scores assessed at the start of the study</p>
</dd>
<dt>n_init_cycles</dt><dd><p>number of initial cycles of CMF, equal to 3 or 6</p>
</dd>
<dt>reintroduction</dt><dd><p>indicator of reintroduction of chemotherapy, 0 = no
reintroduction, 1 = having reintroduction</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>country</dt><dd><p>country, ANZ = New Zealand/Australia, CH = Switzerland,
SWED = Sweden</p>
</dd>
<dt>nodegp</dt><dd><p>indicator of number of positive nodes being greater than or
equal to 4, 0 = less than 4, 1 = 4+</p>
</dd>
<dt>ER</dt><dd><p>estrogen receptor (ER) status indicator, 0 = negative, 1 = positive</p>
</dd>
</dl>



<h3>References</h3>

<p>International Breast Cancer Study Group. (1996). Duration and reintroduction of adjuvant chemotherapy for node-positive premenopausal breast cancer patients. Journal of Clinical Oncology, 14(6), 1885–1894.
</p>
<p>Hürny, C., Bernhard, J., Gelber, R. D., Coates, A., Castiglione, M., Isley, M., Dreher, D., Peterson, H., Goldhirsch, A., and Senn, H.-J. (1992). Quality of life measures for patients receiving adjuvant therapy for breast cancer: An international trial. European Journal of Cancer, 28(1), 118–124.
</p>
<p>Chi, Y.-Y. and Ibrahim, J. G. (2005). Joint models for multivariate longitudinal and Multivariate Survival Data. Biometrics, 62(2), 432–445.
</p>

<hr>
<h2 id='lm.npp'>Posterior of normalized power prior (NPP) for normal linear models</h2><span id='topic+lm.npp'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a normal linear model using the NPP by Duan et al. (2006) <a href="doi:10.1002/env.752">doi:10.1002/env.752</a>.
The power prior parameters (<code class="reqn">a_0</code>'s) are treated as random with independent beta priors. The current and historical
data sets are assumed to have a common dispersion parameter (<code class="reqn">\sigma^2</code>) with an inverse-gamma prior. Conditional on
<code class="reqn">\sigma^2</code>, the initial priors on the regression coefficients are independent normal distributions with variance
<code class="reqn">\propto (\sigma^2)^{-1}</code>. In this case, the normalizing constant for the NPP has a closed form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.npp(
  formula,
  data.list,
  offset.list = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  sigmasq.shape = 2.1,
  sigmasq.scale = 1.1,
  a0.shape1 = 1,
  a0.shape2 = 1,
  a0.lower = NULL,
  a0.upper = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.npp_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of offset.list is equal to
the length of data.list. The length of each element of offset.list is equal to the number
of rows in the corresponding element of data.list. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_beta.mean">beta.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the mean parameters for the initial prior on regression coefficients. If a scalar is provided,
beta.mean will be a vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_beta.sd">beta.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients.
Conditional on the variance parameter sigmasq for the outcome, beta.sd * sqrt(sigmasq) gives
the sd for the initial prior on regression coefficients. If a scalar is provided, same as for
beta.mean. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_sigmasq.shape">sigmasq.shape</code></td>
<td>
<p>shape parameter for inverse-gamma prior on variance parameter. Defaults to 2.1.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_sigmasq.scale">sigmasq.scale</code></td>
<td>
<p>scale parameter for inverse-gamma prior on variance parameter. Defaults to 1.1.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_a0.shape1">a0.shape1</code></td>
<td>
<p>first shape parameter for the i.i.d. beta prior on a0 vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_a0.shape2">a0.shape2</code></td>
<td>
<p>second shape parameter for the i.i.d. beta prior on a0 vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_a0.lower">a0.lower</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of historical data sets giving the
lower bounds for each element of the a0 vector. If a scalar is provided, a0.lower will be a
vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_a0.upper">a0.upper</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of historical data sets giving the
upper bounds for each element of the a0 vector. If a scalar is provided, same as for a0.lower.
Defaults to a vector of 1s.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples.
</p>


<h3>References</h3>

<p>Duan, Y., Ye, K., and Smith, E. P. (2005). Evaluating water quality using power priors to incorporate historical information. Environmetrics, 17(1), 95–106.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  data_list = list(currdata = actg019, histdata = actg036)
  lm.npp(
    formula = cd4 ~ treatment + age + race,
    data.list = data_list,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
