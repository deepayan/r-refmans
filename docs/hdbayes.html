<!DOCTYPE html><html lang="en"><head><title>Help for package hdbayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hdbayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hdbayes-package'><p>hdbayes: Bayesian Analysis of Generalized Linear Models with Historical Data</p></a></li>
<li><a href='#actg019'><p>AIDS Clinical Trial ACTG019</p></a></li>
<li><a href='#actg036'><p>AIDS Clinical Trial ACTG036</p></a></li>
<li><a href='#E1684'><p>ECOG E1684 Trial</p></a></li>
<li><a href='#E1690'><p>ECOG E1690 Trial</p></a></li>
<li><a href='#E1694'><p>ECOG E1694 Trial</p></a></li>
<li><a href='#E2696'><p>ECOG E2696 Trial</p></a></li>
<li><a href='#glm.bhm'><p>Posterior of Bayesian hierarchical model (BHM)</p></a></li>
<li><a href='#glm.commensurate'><p>Posterior of commensurate prior (CP)</p></a></li>
<li><a href='#glm.leap'><p>Posterior of latent exchangeability prior (LEAP)</p></a></li>
<li><a href='#glm.logml.commensurate'><p>Log marginal likelihood of a GLM under commensurate prior (CP)</p></a></li>
<li><a href='#glm.logml.leap'><p>Log marginal likelihood of a GLM under latent exchangeability prior (LEAP)</p></a></li>
<li><a href='#glm.logml.map'><p>Log marginal likelihood of a GLM under meta-analytic predictive (MAP) prior</p></a></li>
<li><a href='#glm.logml.napp'><p>Log marginal likelihood of a GLM under normalized asymptotic power prior (NAPP)</p></a></li>
<li><a href='#glm.logml.npp'><p>Log marginal likelihood of a GLM under normalized power prior (NPP)</p></a></li>
<li><a href='#glm.logml.post'><p>Log marginal likelihood of a GLM under a normal/half-normal prior</p></a></li>
<li><a href='#glm.logml.pp'><p>Log marginal likelihood of a GLM under power prior (PP)</p></a></li>
<li><a href='#glm.napp'><p>Posterior of normalized asymptotic power prior (NAPP)</p></a></li>
<li><a href='#glm.npp'><p>Posterior of normalized power prior (NPP)</p></a></li>
<li><a href='#glm.npp.lognc'><p>Estimate the logarithm of the normalizing constant for normalized power prior (NPP) for one data set</p></a></li>
<li><a href='#glm.post'><p>Posterior of a normal/half-normal prior</p></a></li>
<li><a href='#glm.pp'><p>Posterior of power prior (PP) with fixed <code class="reqn">a_0</code></p></a></li>
<li><a href='#glm.rmap'><p>Posterior of robust meta-analytic predictive prior (RMAP)</p></a></li>
<li><a href='#IBCSG_curr'><p>International Breast Cancer Study Group (IBCSG) Trial VI Data</p></a></li>
<li><a href='#IBCSG_hist'><p>International Breast Cancer Study Group (IBCSG) Trial VI Data</p></a></li>
<li><a href='#lm.npp'><p>Posterior of normalized power prior (NPP) for normal linear models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian Analysis of Generalized Linear Models with Historical
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>User-friendly functions for leveraging (multiple) historical data set(s) for generalized
    linear models. The package contains functions for sampling from the posterior distribution of a
    generalized linear model using the prior induced by the Bayesian hierarchical model, power prior 
    by Ibrahim and Chen (2000) &lt;<a href="https://doi.org/10.1214%2Fss%2F1009212673">doi:10.1214/ss/1009212673</a>&gt;, normalized power prior by Duan et al. (2006) 
    &lt;<a href="https://doi.org/10.1002%2Fenv.752">doi:10.1002/env.752</a>&gt;, normalized asymptotic power prior by Ibrahim et al. (2015) &lt;<a href="https://doi.org/10.1002%2Fsim.6728">doi:10.1002/sim.6728</a>&gt;, 
    commensurate prior by Hobbs et al. (2011) &lt;<a href="https://doi.org/10.1111%2Fj.1541-0420.2011.01564.x">doi:10.1111/j.1541-0420.2011.01564.x</a>&gt;, robust meta-analytic-predictive 
    prior by Schmidli et al. (2014) &lt;<a href="https://doi.org/10.1111%2Fbiom.12242">doi:10.1111/biom.12242</a>&gt;, the latent exchangeability prior by Alt et al. (2023) 
    &lt;<a href="https://doi.org/10.48550%2FarXiv.2303.05223">doi:10.48550/arXiv.2303.05223</a>&gt;, and a normal (or half-normal) prior. Functions for computing the marginal 
    log-likelihood under each of the implemented priors are also included. The package compiles all 
    the 'CmdStan' models once during installation using the 'instantiate' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ethan-alt/hdbayes">https://github.com/ethan-alt/hdbayes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ethan-alt/hdbayes/issues">https://github.com/ethan-alt/hdbayes/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>instantiate (&ge; 0.1.0), callr, fs, formula.tools, stats,
posterior, enrichwith, mclust, bridgesampling, mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cmdstanr (&ge; 0.6.0), ggplot2, knitr, parallel, rmarkdown,
tibble, dplyr</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>CmdStan
(https://mc-stan.org/users/interfaces/cmdstan)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'E1684-data.R' 'E1690-data.R' 'E1694-data.R' 'E2696-data.R'
'IBCSG_curr-data.R' 'IBCSG_hist-data.R' 'actg019-data.R'
'actg036-data.R' 'data_checks.R' 'expfam_loglik.R'
'get_stan_data.R' 'glm_bhm.R' 'glm_bhm_lognc.R'
'glm_commensurate.R' 'mixture_loglik.R'
'glm_commensurate_lognc.R' 'glm_leap.R' 'glm_leap_lognc.R'
'glm_logml_commensurate.R' 'glm_logml_leap.R' 'glm_logml_map.R'
'glm_logml_napp.R' 'glm_logml_npp.R' 'glm_logml_post.R'
'glm_pp_lognc.R' 'glm_logml_pp.R' 'glm_napp.R'
'glm_npp_lognc.R' 'glm_npp.R' 'glm_post.R' 'glm_pp.R'
'glm_rmap.R' 'hdbayes-package.R' 'lm_npp.R' 'zzz.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-22 16:22:52 UTC; xinxin</td>
</tr>
<tr>
<td>Author:</td>
<td>Ethan M. Alt <a href="https://orcid.org/0000-0002-6112-9030"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Xinxin Chen [aut],
  Luiz M. Carvalho [aut],
  Joseph G. Ibrahim [aut],
  Xiuya Chang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ethan M. Alt &lt;ethanalt@live.unc.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-22 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='hdbayes-package'>hdbayes: Bayesian Analysis of Generalized Linear Models with Historical Data</h2><span id='topic+hdbayes-package'></span><span id='topic+hdbayes'></span>

<h3>Description</h3>

<p>User-friendly functions for leveraging (multiple) historical data set(s) for generalized linear models. The package contains functions for sampling from the posterior distribution of a generalized linear model using the prior induced by the Bayesian hierarchical model, power prior by Ibrahim and Chen (2000) <a href="https://doi.org/10.1214/ss/1009212673">doi:10.1214/ss/1009212673</a>, normalized power prior by Duan et al. (2006) <a href="https://doi.org/10.1002/env.752">doi:10.1002/env.752</a>, normalized asymptotic power prior by Ibrahim et al. (2015) <a href="https://doi.org/10.1002/sim.6728">doi:10.1002/sim.6728</a>, commensurate prior by Hobbs et al. (2011) <a href="https://doi.org/10.1111/j.1541-0420.2011.01564.x">doi:10.1111/j.1541-0420.2011.01564.x</a>, robust meta-analytic-predictive prior by Schmidli et al. (2014) <a href="https://doi.org/10.1111/biom.12242">doi:10.1111/biom.12242</a>, the latent exchangeability prior by Alt et al. (2023) <a href="https://doi.org/10.48550/arXiv.2303.05223">doi:10.48550/arXiv.2303.05223</a>, and a normal (or half-normal) prior. Functions for computing the marginal log-likelihood under each of the implemented priors are also included. The package compiles all the 'CmdStan' models once during installation using the 'instantiate' package.
</p>
<p>Bayesian analysis of generalized linear models using historical data
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ethan M. Alt <a href="mailto:ethanalt@live.unc.edu">ethanalt@live.unc.edu</a> (<a href="https://orcid.org/0000-0002-6112-9030">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Xinxin Chen
</p>
</li>
<li><p> Luiz M. Carvalho
</p>
</li>
<li><p> Joseph G. Ibrahim
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Xiuya Chang [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ethan-alt/hdbayes">https://github.com/ethan-alt/hdbayes</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ethan-alt/hdbayes/issues">https://github.com/ethan-alt/hdbayes/issues</a>
</p>
</li></ul>


<hr>
<h2 id='actg019'>AIDS Clinical Trial ACTG019</h2><span id='topic+actg019'></span>

<h3>Description</h3>

<p>A data set from the AIDS clinical trial ACTG019 (<a href="https://clinicaltrials.gov/ct2/show/NCT00000736">https://clinicaltrials.gov/ct2/show/NCT00000736</a>) comparing
zidovudine (AZT) with a placebo in adults with asymptomatic HIV infection. The study results were described in
Volberding et al. (1990) <a href="doi:10.1056/NEJM199004053221401">doi:10.1056/NEJM199004053221401</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actg019
</code></pre>


<h3>Format</h3>

<p>A data frame with 822 rows and 5 variables:
</p>

<dl>
<dt>outcome</dt><dd><p>outcome variable with 1 indicating death, development of AIDS or AIDS-related complex (ARC) and 0 otherwise</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>treatment</dt><dd><p>treatment indicator, 0 = placebo, 1 = AZT</p>
</dd>
<dt>race</dt><dd><p>race indicator, 0 = non-white, 1 = white</p>
</dd>
<dt>cd4</dt><dd><p>CD4 cell count</p>
</dd>
</dl>



<h3>References</h3>

<p>Volberding, P. A., Lagakos, S. W., Koch, M. A., Pettinelli, C., Myers, M. W., Booth, D. K., Balfour, H. H., Reichman, R. C., Bartlett, J. A., Hirsch, M. S., Murphy, R. L., Hardy, W. D., Soeiro, R., Fischl, M. A., Bartlett, J. G., Merigan, T. C., Hyslop, N. E., Richman, D. D., Valentine, F. T., Corey, L., and the AIDS Clinical Trials Group of the National Institute of Allergy and Infectious Diseases (1990). Zidovudine in asymptomatic human immunodeficiency virus infection. New England Journal of Medicine, 322(14), 941–949.
</p>
<p>Chen, M.-H., Ibrahim, J. G., and Yiannoutsos, C. (1999). Prior elicitation, Variable Selection and Bayesian computation for Logistic Regression Models. Journal of the Royal Statistical Society Series B: Statistical Methodology, 61(1), 223–242.
</p>

<hr>
<h2 id='actg036'>AIDS Clinical Trial ACTG036</h2><span id='topic+actg036'></span>

<h3>Description</h3>

<p>A data set from the AIDS clinical trial ACTG036 (<a href="https://clinicaltrials.gov/study/NCT00001104">https://clinicaltrials.gov/study/NCT00001104</a>) comparing
zidovudine (AZT) with a placebo in patients with hereditary coagulation disorders and HIV infection. The study
results were described in Merigan et al. (1991) <a href="doi:10.1182/blood.V78.4.900.900">doi:10.1182/blood.V78.4.900.900</a>. This data set has the same
variables as the actg019 data set. We can use the actg019 data as the historical data and the actg036 data as
the current data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actg036
</code></pre>


<h3>Format</h3>

<p>A data frame with 183 rows and 5 variables:
</p>

<dl>
<dt>outcome</dt><dd><p>outcome variable with 1 indicating death, development of AIDS or AIDS-related complex (ARC) and 0 otherwise</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>treatment</dt><dd><p>treatment indicator, 0 = placebo, 1 = AZT</p>
</dd>
<dt>race</dt><dd><p>race indicator, 0 = non-white, 1 = white</p>
</dd>
<dt>cd4</dt><dd><p>CD4 cell count</p>
</dd>
</dl>



<h3>References</h3>

<p>Merigan, T., Amato, D., Balsley, J., Power, M., Price, W., Benoit, S., Perez-Michael, A., Brownstein, A., Kramer, A., and Brettler, D. (1991). Placebo-controlled trial to evaluate zidovudine in treatment of human immunodeficiency virus infection in asymptomatic patients with hemophilia. NHF-ACTG 036 Study Group. Blood, 78(4), 900–906.
</p>
<p>Chen, M.-H., Ibrahim, J. G., and Yiannoutsos, C. (1999). Prior elicitation, Variable Selection and Bayesian computation for Logistic Regression Models. Journal of the Royal Statistical Society Series B: Statistical Methodology, 61(1), 223–242.
</p>

<hr>
<h2 id='E1684'>ECOG E1684 Trial</h2><span id='topic+E1684'></span>

<h3>Description</h3>

<p>A data set from the ECOG E1684 trial comparing the high-dose interferon alfa-2b (IFN)
therapy with the observation in resected high-risk melanoma patients. The study results
were described in Kirkwood et al. (1996) <a href="doi:10.1200/JCO.1996.14.1.7">doi:10.1200/JCO.1996.14.1.7</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E1684
</code></pre>


<h3>Format</h3>

<p>A data frame with 262 rows and 8 variables:
</p>

<dl>
<dt>failtime</dt><dd><p>time to relapse in years</p>
</dd>
<dt>failcens</dt><dd><p>censoring indicator for time to relapse, 0 = did not relapse, 1 = relapsed</p>
</dd>
<dt>survtime</dt><dd><p>time to death in years</p>
</dd>
<dt>survcens</dt><dd><p>censoring indicator for time to death, 0 = alive, 1 = dead</p>
</dd>
<dt>treatment</dt><dd><p>treatment indicator, 0 = observation, 1 = high-dose IFN</p>
</dd>
<dt>sex</dt><dd><p>gender indicator, 0 = male, 1 = female</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>node_bin</dt><dd><p>indicator for having more than one cancerous lymph node,
0 = with one or no cancerous lymph nodes,
1 = with more than one cancerous lymph node</p>
</dd>
</dl>



<h3>References</h3>

<p>Kirkwood, J. M., Strawderman, M. H., Ernstoff, M. S., Smith, T. J., Borden, E. C., and Blum, R. H. (1996). Interferon alfa-2b adjuvant therapy of high-risk resected cutaneous melanoma: The Eastern Cooperative Oncology Group trial EST 1684. Journal of Clinical Oncology, 14(1), 7–17.
</p>

<hr>
<h2 id='E1690'>ECOG E1690 Trial</h2><span id='topic+E1690'></span>

<h3>Description</h3>

<p>A data set from the ECOG E1690 trial evaluating the effectiveness of the interferon alfa-2b
(IFN) therapy compared to the observation in high-risk melanoma patients. There were three
arms in the trial: high-dose IFN, low-dose IFN, and observation. The study results were
described in Kirkwood et al. (2000) <a href="doi:10.1200/JCO.2000.18.12.2444">doi:10.1200/JCO.2000.18.12.2444</a>. Here, we only consider
the high-dose IFN arm and the observation arm so that this data set has the same variables as
the E1684 data set. We can use the E1684 data as the historical data and the E1690 data as the
current data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E1690
</code></pre>


<h3>Format</h3>

<p>A data frame with 426 rows and 8 variables:
</p>

<dl>
<dt>failtime</dt><dd><p>time to relapse in years</p>
</dd>
<dt>failcens</dt><dd><p>censoring indicator for time to relapse, 0 = did not relapse, 1 = relapsed</p>
</dd>
<dt>survtime</dt><dd><p>time to death in years</p>
</dd>
<dt>survcens</dt><dd><p>censoring indicator for time to death, 0 = alive, 1 = dead</p>
</dd>
<dt>treatment</dt><dd><p>treatment indicator, 0 = observation, 1 = high-dose IFN</p>
</dd>
<dt>sex</dt><dd><p>gender indicator, 0 = male, 1 = female</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>node_bin</dt><dd><p>indicator for having more than one cancerous lymph node,
0 = with one or no cancerous lymph nodes,
1 = with more than one cancerous lymph node</p>
</dd>
</dl>



<h3>References</h3>

<p>Kirkwood, J. M., Ibrahim, J. G., Sondak, V. K., Richards, J., Flaherty, L. E., Ernstoff, M. S., Smith, T. J., Rao, U., Steele, M., and Blum, R. H. (2000). High- and low-dose interferon alfa-2b in high-risk melanoma: First analysis of intergroup trial E1690/S9111/C9190. Journal of Clinical Oncology, 18(12), 2444–2458.
</p>

<hr>
<h2 id='E1694'>ECOG E1694 Trial</h2><span id='topic+E1694'></span>

<h3>Description</h3>

<p>A data set from the ECOG E1694 trial comparing the GM2-KLH/QS-21 (GMK) vaccine with high-dose
interferon alfa-2b (IFN) therapy in resected high-risk melanoma patients. The study results
were described in Kirkwood et al. (2001) <a href="doi:10.1200/JCO.2001.19.9.2370">doi:10.1200/JCO.2001.19.9.2370</a>. This data set only
includes patients without nodal metastasis and has the same variables as the E2696 data set.
We can use the E2696 data as the historical data and the E1694 data as the current data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E1694
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 6 variables:
</p>

<dl>
<dt>failtime</dt><dd><p>relapse-free survival (RFS) times (in months)</p>
</dd>
<dt>failind</dt><dd><p>relapse indicator, 0 = right censored, 1 = relapse</p>
</dd>
<dt>treatment</dt><dd><p>treatment indicator, 0 = GMK, 1 = IFN</p>
</dd>
<dt>sex</dt><dd><p>gender indicator, 0 = male, 1 = female</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>perform</dt><dd><p>ECOG performance status indicator, 0 = fully active patient, able to
carry on all pre-disease performance without restriction,
1 = restricted in physically strenuous activity, but are ambulatory
and able to carry out work of a light or sedentary nature</p>
</dd>
</dl>



<h3>References</h3>

<p>Kirkwood, J. M., Ibrahim, J. G., Sosman, J. A., Sondak, V. K., Agarwala, S. S., Ernstoff, M. S., and Rao, U. (2001). High-dose interferon alfa-2b significantly prolongs relapse-free and overall survival compared with the GM2-KLH/QS-21 vaccine in patients with resected stage IIB-III melanoma: Results of intergroup trial E1694/S9512/C509801. Journal of Clinical Oncology, 19(9), 2370–2380.
</p>

<hr>
<h2 id='E2696'>ECOG E2696 Trial</h2><span id='topic+E2696'></span>

<h3>Description</h3>

<p>A data set from the ECOG E2696 trial comparing the combination of the GM2-KLH/QS-21 (GMK) vaccine
and high-dose interferon alfa-2b (IFN) therapy with the GMK vaccine alone in resected high-risk
melanoma patients. The study results were described in Kirkwood et al. (2001) <a href="doi:10.1200/JCO.2001.19.5.1430">doi:10.1200/JCO.2001.19.5.1430</a>.
This data set only includes patients without nodal metastasis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E2696
</code></pre>


<h3>Format</h3>

<p>A data frame with 105 rows and 6 variables:
</p>

<dl>
<dt>failtime</dt><dd><p>relapse-free survival (RFS) times (in months)</p>
</dd>
<dt>failind</dt><dd><p>relapse indicator, 0 = right censored, 1 = relapse</p>
</dd>
<dt>treatment</dt><dd><p>treatment indicator, 0 = GMK, 1 = GMK and IFN</p>
</dd>
<dt>sex</dt><dd><p>gender indicator, 0 = male, 1 = female</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>perform</dt><dd><p>ECOG performance status indicator, 0 = fully active patient, able to
carry on all pre-disease performance without restriction,
1 = restricted in physically strenuous activity, but are ambulatory
and able to carry out work of a light or sedentary nature</p>
</dd>
</dl>



<h3>References</h3>

<p>Kirkwood, J. M., Ibrahim, J., Lawson, D. H., Atkins, M. B., Agarwala, S. S., Collins, K., Mascari, R., Morrissey, D. M., and Chapman, P. B. (2001). High-dose interferon alfa-2b does not diminish antibody response to GM2 vaccination in patients with resected melanoma: Results of the multicenter eastern cooperative oncology group phase II trial E2696. Journal of Clinical Oncology, 19(5), 1430–1436.
</p>

<hr>
<h2 id='glm.bhm'>Posterior of Bayesian hierarchical model (BHM)</h2><span id='topic+glm.bhm'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the Bayesian hierarchical model (BHM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.bhm(
  formula,
  family,
  data.list,
  offset.list = NULL,
  meta.mean.mean = NULL,
  meta.mean.sd = NULL,
  meta.sd.mean = NULL,
  meta.sd.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.bhm_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of <code>offset.list</code> is equal to
the length of <code>data.list</code>. The length of each element of <code>offset.list</code> is equal to the number
of rows in the corresponding element of <code>data.list</code>. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_meta.mean.mean">meta.mean.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the means for the normal hyperpriors on the mean hyperparameters of regression coefficients.
If a scalar is provided, <code>meta.mean.mean</code> will be a vector of repeated elements of the given
scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_meta.mean.sd">meta.mean.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sds for the normal hyperpriors on the mean hyperparameters of regression coefficients. If
a scalar is provided, same as for <code>meta.mean.mean</code>. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_meta.sd.mean">meta.sd.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the means for the half-normal hyperpriors on the sd hyperparameters of regression coefficients.
If a scalar is provided, same as for <code>meta.mean.mean</code>. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_meta.sd.sd">meta.sd.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sds for the half-normal hyperpriors on the sd hyperparameters of regression coefficients.
If a scalar is provided, same as for <code>meta.mean.mean</code>. Defaults to a vector of 1s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_disp.mean">disp.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of data sets (including the current
data) giving the location parameters for the half-normal priors on the dispersion parameters.
If a scalar is provided, same as for <code>meta.mean.mean</code>. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_disp.sd">disp.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of data sets (including the current
data) giving the scale parameters for the half-normal priors on the dispersion parameters. If a
scalar is provided, same as for <code>meta.mean.mean</code>. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.bhm_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayesian hierarchical model (BHM) assumes that the regression coefficients for the historical and
current data are different, but are correlated through a common distribution, whose hyperparameters
(i.e., mean and standard deviation (sd) (the covariance matrix is assumed to have a diagonal structure))
are treated as random. The number of regression coefficients for the current data is assumed to be the
same as that for the historical data.
</p>
<p>The hyperpriors on the mean and the sd hyperparameters are independent normal and independent half-normal
distributions, respectively. The priors on the dispersion parameters (if applicable) for the current and
historical data sets are independent half-normal distributions.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples, with an attribute called 'data' which includes
the list of variables specified in the data block of the Stan program.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  actg036 = actg036[1:50, ]
  data_list = list(currdata = actg019, histdata = actg036)
  glm.bhm(
    formula = outcome ~ scale(age) + race + treatment + scale(cd4),
    family = binomial('logit'),
    data.list = data_list,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.commensurate'>Posterior of commensurate prior (CP)</h2><span id='topic+glm.commensurate'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the commensurate prior (CP) by Hobbs et al. (2011) <a href="doi:10.1111/j.1541-0420.2011.01564.x">doi:10.1111/j.1541-0420.2011.01564.x</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.commensurate(
  formula,
  family,
  data.list,
  offset.list = NULL,
  beta0.mean = NULL,
  beta0.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  p.spike = 0.1,
  spike.mean = 200,
  spike.sd = 0.1,
  slab.mean = 0,
  slab.sd = 5,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.commensurate_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code></p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of <code>offset.list</code> is equal to
the length of <code>data.list</code>. The length of each element of <code>offset.list</code> is equal to the number
of rows in the corresponding element of <code>data.list</code>. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_beta0.mean">beta0.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients
giving the mean parameters for the prior on the historical data regression coefficients. If a
scalar is provided, <code>beta0.mean</code> will be a vector of repeated elements of the given scalar.
Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_beta0.sd">beta0.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sd parameters for the prior on the historical data regression coefficients. If a scalar is
provided, same as for <code>beta0.mean</code>. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_disp.mean">disp.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of data sets (including the current
data) giving the location parameters for the half-normal priors on the dispersion parameters.
If a scalar is provided, same as for <code>beta0.mean</code>. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_disp.sd">disp.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of data sets (including the current
data) giving the scale parameters for the half-normal priors on the dispersion parameters. If a
scalar is provided, same as for <code>beta0.mean</code>. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_p.spike">p.spike</code></td>
<td>
<p>a scalar between 0 and 1 giving the probability of the spike component in spike-and-slab prior
on commensurability parameter <code class="reqn">\tau</code>. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_spike.mean">spike.mean</code></td>
<td>
<p>a scalar giving the location parameter for the half-normal prior (spike component) on <code class="reqn">\tau</code>.
Defaults to 200.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_spike.sd">spike.sd</code></td>
<td>
<p>a scalar giving the scale parameter for the half-normal prior (spike component) on <code class="reqn">\tau</code>.
Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_slab.mean">slab.mean</code></td>
<td>
<p>a scalar giving the location parameter for the half-normal prior (slab component) on <code class="reqn">\tau</code>.
Defaults to 0.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_slab.sd">slab.sd</code></td>
<td>
<p>a scalar giving the scale parameter for the half-normal prior (slab component) on <code class="reqn">\tau</code>.
Defaults to 5.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.commensurate_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The commensurate prior (CP) assumes that the regression coefficients for the current data conditional on those for
the historical data are independent normal distributions with mean equal to the corresponding regression coefficients
for the historical data and variance equal to the inverse of the corresponding elements of a vector of precision
parameters (referred to as the commensurability parameter <code class="reqn">\tau</code>). We regard <code class="reqn">\tau</code> as random and elicit
a spike-and-slab prior, which is specified as a mixture of two half-normal priors, on <code class="reqn">\tau</code>.
</p>
<p>The number of current data regression coefficients is assumed to be the same as that of historical data regression
coefficients. The priors on the dispersion parameters (if applicable) for the current and historical data sets are
independent half-normal distributions.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples, with an attribute called 'data' which includes
the list of variables specified in the data block of the Stan program.
</p>


<h3>References</h3>

<p>Hobbs, B. P., Carlin, B. P., Mandrekar, S. J., and Sargent, D. J. (2011). Hierarchical commensurate and power prior models for adaptive incorporation of historical information in clinical trials. Biometrics, 67(3), 1047–1056.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  actg036 = actg036[1:50, ]
  data_list = list(currdata = actg019, histdata = actg036)
  glm.commensurate(
    formula = cd4 ~ treatment + age + race,
    family = poisson(), data.list = data_list,
    p.spike = 0.1,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.leap'>Posterior of latent exchangeability prior (LEAP)</h2><span id='topic+glm.leap'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the latent exchangeability prior (LEAP) by Alt et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.leap(
  formula,
  family,
  data.list,
  K = 2,
  prob.conc = NULL,
  offset.list = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.leap_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets. For LEAP implementation, all historical data sets will be
stacked into one historical data set.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_k">K</code></td>
<td>
<p>the desired number of classes to identify. Defaults to 2.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_prob.conc">prob.conc</code></td>
<td>
<p>a scalar or a vector of length <code>K</code> giving the concentration parameters for Dirichlet prior.
If length == 2, a <code>Beta(prob.conc[1], prob.conc[2])</code> prior is used. If a scalar is provided,
<code>prob.conc</code> will be a vector of repeated elements of the given scalar. Defaults to a vector of 1s.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of matrices giving the offset for current data followed by historical data. For each
matrix, the number of rows corresponds to observations and columns correspond to classes.
Defaults to a list of matrices of 0s. Note that the first element of <code>offset.list</code> (corresponding
to the offset for current data) should be a matrix of repeated columns if <code>offset.list</code> is not NULL.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_beta.mean">beta.mean</code></td>
<td>
<p>a scalar or a <code style="white-space: pre;">&#8288;p x K&#8288;</code> matrix of mean parameters for initial prior on regression coefficients,
where <code>p</code> is the number of regression coefficients (including intercept). If a scalar is provided,
<code>beta.mean</code> will be a matrix of repeated elements of the given scalar. Defaults to a matrix of 0s.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_beta.sd">beta.sd</code></td>
<td>
<p>a scalar or a <code style="white-space: pre;">&#8288;p x K&#8288;</code> matrix of sd parameters for the initial prior on regression coefficients,
where <code>p</code> is the number of regression coefficients (including intercept). If a scalar is provided,
same as for <code>beta.mean</code>. Defaults to a matrix of 10s.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_disp.mean">disp.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of classes (<code>K</code>) giving the location
parameters for the half-normal priors on the dispersion parameters. If a scalar is provided,
<code>disp.mean</code> will be a vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_disp.sd">disp.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of classes (<code>K</code>) giving the scale
parameters for the half-normal priors on the dispersion parameters. If a scalar is provided, same
as for <code>disp.mean</code>. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.leap_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The latent exchangeability prior (LEAP) discounts the historical data by identifying the most relevant individuals
from the historical data. It is equivalent to a prior induced by the posterior of a finite mixture model for the
historical data set.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples, with an attribute called 'data' which includes
the list of variables specified in the data block of the Stan program.
</p>


<h3>References</h3>

<p>Alt, E. M., Chang, X., Jiang, X., Liu, Q., Mo, M., Xia, H. M., and Ibrahim, J. G. (2023). LEAP: The latent exchangeability prior for borrowing information from historical data. arXiv preprint.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actg019)
data(actg036)
# take subset for speed purposes
actg019 = actg019[1:100, ]
actg036 = actg036[1:50, ]
if (instantiate::stan_cmdstan_exists()) {
  glm.leap(
    formula = outcome ~ scale(age) + race + treatment + scale(cd4),
    family = binomial('logit'),
    data.list = list(actg019, actg036),
    K = 2,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.logml.commensurate'>Log marginal likelihood of a GLM under commensurate prior (CP)</h2><span id='topic+glm.logml.commensurate'></span>

<h3>Description</h3>

<p>Uses Markov chain Monte Carlo (MCMC) and bridge sampling to estimate the logarithm of the marginal
likelihood of a GLM under the commensurate prior (CP).
</p>
<p>The arguments related to MCMC sampling are utilized to draw samples from the commensurate prior.
These samples are then used to compute the logarithm of the normalizing constant of the commensurate prior using
historical data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.logml.commensurate(
  post.samples,
  bridge.args = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.logml.commensurate_+3A_post.samples">post.samples</code></td>
<td>
<p>output from <code><a href="#topic+glm.commensurate">glm.commensurate()</a></code> giving posterior samples of a GLM under the commensurate
prior (CP), with an attribute called 'data' which includes the list of variables specified
in the data block of the Stan program.</p>
</td></tr>
<tr><td><code id="glm.logml.commensurate_+3A_bridge.args">bridge.args</code></td>
<td>
<p>a <code>list</code> giving arguments (other than <code>samples</code>, <code>log_posterior</code>, <code>data</code>, <code>lb</code>, and <code>ub</code>) to
pass onto <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>.</p>
</td></tr>
<tr><td><code id="glm.logml.commensurate_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.logml.commensurate_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.logml.commensurate_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method
in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.logml.commensurate_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>list</code> with the following objects
</p>

<dl>
<dt>model</dt><dd><p>&quot;Commensurate&quot;</p>
</dd>
<dt>logml</dt><dd><p>the estimated logarithm of the marginal likelihood</p>
</dd>
<dt>bs</dt><dd><p>an object of class <code>bridge</code> or <code>bridge_list</code> containing the output from using <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>
to compute the logarithm of the normalizing constant of the commensurate prior (CP) using all data sets</p>
</dd>
<dt>bs.hist</dt><dd><p>an object of class <code>bridge</code> or <code>bridge_list</code> containing the output from using
<code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code> to compute the logarithm of the normalizing constant of the CP using historical
data sets</p>
</dd>
<dt>min_ess_bulk</dt><dd><p>the minimum estimated bulk effective sample size of the MCMC sampling</p>
</dd>
<dt>max_Rhat</dt><dd><p>the maximum Rhat</p>
</dd>
</dl>



<h3>References</h3>

<p>Hobbs, B. P., Carlin, B. P., Mandrekar, S. J., and Sargent, D. J. (2011). Hierarchical commensurate and power prior models for adaptive incorporation of historical information in clinical trials. Biometrics, 67(3), 1047–1056.
</p>
<p>Gronau, Q. F., Singmann, H., and Wagenmakers, E.-J. (2020). bridgesampling: An r package for estimating normalizing constants. Journal of Statistical Software, 92(10).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019   = actg019[1:100, ]
  actg036   = actg036[1:50, ]
  formula   = cd4 ~ treatment + age + race
  family    = poisson()
  data_list = list(currdata = actg019, histdata = actg036)
  d.cp      = glm.commensurate(
    formula = formula,
    family = family,
    data.list = data_list,
    p.spike = 0.1,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
  glm.logml.commensurate(
    post.samples = d.cp,
    bridge.args = list(silent = TRUE),
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.logml.leap'>Log marginal likelihood of a GLM under latent exchangeability prior (LEAP)</h2><span id='topic+glm.logml.leap'></span>

<h3>Description</h3>

<p>Uses Markov chain Monte Carlo (MCMC) and bridge sampling to estimate the logarithm of the marginal
likelihood of a GLM under the latent exchangeability prior (LEAP).
</p>
<p>The arguments related to MCMC sampling are utilized to draw samples from the LEAP. These
samples are then used to compute the logarithm of the normalizing constant of the LEAP using historical
data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.logml.leap(
  post.samples,
  bridge.args = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.logml.leap_+3A_post.samples">post.samples</code></td>
<td>
<p>output from <code><a href="#topic+glm.leap">glm.leap()</a></code> giving posterior samples of a GLM under the latent exchangeability
prior (LEAP), with an attribute called 'data' which includes the list of variables specified
in the data block of the Stan program.</p>
</td></tr>
<tr><td><code id="glm.logml.leap_+3A_bridge.args">bridge.args</code></td>
<td>
<p>a <code>list</code> giving arguments (other than <code>samples</code>, <code>log_posterior</code>, <code>data</code>, <code>lb</code>, and <code>ub</code>) to
pass onto <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>.</p>
</td></tr>
<tr><td><code id="glm.logml.leap_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.logml.leap_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.logml.leap_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method
in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.logml.leap_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>list</code> with the following objects
</p>

<dl>
<dt>model</dt><dd><p>&quot;LEAP&quot;</p>
</dd>
<dt>logml</dt><dd><p>the estimated logarithm of the marginal likelihood</p>
</dd>
<dt>bs</dt><dd><p>an object of class <code>bridge</code> or <code>bridge_list</code> containing the output from using
<code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code> to compute the logarithm of the normalizing constant of the
latent exchangeability prior (LEAP) using all data sets</p>
</dd>
<dt>bs.hist</dt><dd><p>an object of class <code>bridge</code> or <code>bridge_list</code> containing the output from using
<code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code> to compute the logarithm of the normalizing constant of the
LEAP using historical data sets</p>
</dd>
<dt>min_ess_bulk</dt><dd><p>the minimum estimated bulk effective sample size of the MCMC sampling</p>
</dd>
<dt>max_Rhat</dt><dd><p>the maximum Rhat</p>
</dd>
</dl>



<h3>References</h3>

<p>Alt, E. M., Chang, X., Jiang, X., Liu, Q., Mo, M., Xia, H. M., and Ibrahim, J. G. (2023). LEAP: The latent exchangeability prior for borrowing information from historical data. arXiv preprint.
</p>
<p>Gronau, Q. F., Singmann, H., and Wagenmakers, E.-J. (2020). bridgesampling: An r package for estimating normalizing constants. Journal of Statistical Software, 92(10).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019   = actg019[1:100, ]
  actg036   = actg036[1:50, ]
  formula   = outcome ~ scale(age) + race + treatment + scale(cd4)
  family    = binomial('logit')
  data_list = list(currdata = actg019, histdata = actg036)
  d.leap    = glm.leap(
    formula = formula,
    family = family,
    data.list = data_list,
    K = 2,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
  glm.logml.leap(
    post.samples = d.leap,
    bridge.args = list(silent = TRUE),
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.logml.map'>Log marginal likelihood of a GLM under meta-analytic predictive (MAP) prior</h2><span id='topic+glm.logml.map'></span>

<h3>Description</h3>

<p>Uses Markov chain Monte Carlo (MCMC) and bridge sampling to estimate the logarithm of the marginal
likelihood of a GLM under the meta-analytic predictive (MAP) prior. The MAP prior is equivalent to the prior
induced by the Bayesian hierarchical model (BHM).
</p>
<p>The arguments related to MCMC sampling are utilized to draw samples from the MAP prior. These
samples are then used to compute the logarithm of the normalizing constant of the BHM using only historical
data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.logml.map(
  post.samples,
  bridge.args = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.logml.map_+3A_post.samples">post.samples</code></td>
<td>
<p>output from <code><a href="#topic+glm.bhm">glm.bhm()</a></code> giving posterior samples of a GLM under the Bayesian hierarchical
model (BHM), with an attribute called 'data' which includes the list of variables specified
in the data block of the Stan program.</p>
</td></tr>
<tr><td><code id="glm.logml.map_+3A_bridge.args">bridge.args</code></td>
<td>
<p>a <code>list</code> giving arguments (other than <code>samples</code>, <code>log_posterior</code>, <code>data</code>, <code>lb</code>, and <code>ub</code>) to
pass onto <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>.</p>
</td></tr>
<tr><td><code id="glm.logml.map_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.logml.map_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.logml.map_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method
in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.logml.map_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>list</code> with the following objects
</p>

<dl>
<dt>model</dt><dd><p>&quot;MAP&quot;</p>
</dd>
<dt>logml</dt><dd><p>the estimated logarithm of the marginal likelihood of the meta-analytic predictive (MAP) prior</p>
</dd>
<dt>bs</dt><dd><p>an object of class <code>bridge</code> or <code>bridge_list</code> containing the output from using <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>
to compute the logarithm of the normalizing constant of the Bayesian hierarchical model (BHM) using all data sets</p>
</dd>
<dt>bs.hist</dt><dd><p>an object of class <code>bridge</code> or <code>bridge_list</code> containing the output from using
<code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code> to compute the logarithm of the normalizing constant of the BHM using historical
data sets</p>
</dd>
<dt>min_ess_bulk</dt><dd><p>the minimum estimated bulk effective sample size of the MCMC sampling</p>
</dd>
<dt>max_Rhat</dt><dd><p>the maximum Rhat</p>
</dd>
</dl>



<h3>References</h3>

<p>Gronau, Q. F., Singmann, H., and Wagenmakers, E.-J. (2020). bridgesampling: An r package for estimating normalizing constants. Journal of Statistical Software, 92(10).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  actg036 = actg036[1:50, ]
  formula = outcome ~ scale(age) + race + treatment + scale(cd4)
  family = binomial('logit')
  data_list = list(currdata = actg019, histdata = actg036)
  d.bhm = glm.bhm(
    formula = formula,
    family = family,
    data.list = data_list,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
  glm.logml.map(
    post.samples = d.bhm,
    bridge.args = list(silent = TRUE),
    chains = 1, iter_warmup = 1000, iter_sampling = 2000
  )
}
</code></pre>

<hr>
<h2 id='glm.logml.napp'>Log marginal likelihood of a GLM under normalized asymptotic power prior (NAPP)</h2><span id='topic+glm.logml.napp'></span>

<h3>Description</h3>

<p>Uses bridge sampling to estimate the logarithm of the marginal likelihood of a GLM under the
normalized asymptotic power prior (NAPP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.logml.napp(post.samples, bridge.args = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.logml.napp_+3A_post.samples">post.samples</code></td>
<td>
<p>output from <code><a href="#topic+glm.napp">glm.napp()</a></code> giving posterior samples of a GLM under the normalized asymptotic
power prior (NAPP), with an attribute called 'data' which includes the list of variables
specified in the data block of the Stan program.</p>
</td></tr>
<tr><td><code id="glm.logml.napp_+3A_bridge.args">bridge.args</code></td>
<td>
<p>a <code>list</code> giving arguments (other than <code>samples</code>, <code>log_posterior</code>, <code>data</code>, <code>lb</code>, and <code>ub</code>) to
pass onto <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>list</code> with the following objects
</p>

<dl>
<dt>model</dt><dd><p>&quot;NAPP&quot;</p>
</dd>
<dt>logml</dt><dd><p>the estimated logarithm of the marginal likelihood</p>
</dd>
<dt>bs</dt><dd><p>an object of class <code>bridge</code> or <code>bridge_list</code> containing the output from using <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>
to compute the logarithm of the marginal likelihood of the normalized asymptotic power prior (NAPP)</p>
</dd>
</dl>



<h3>References</h3>

<p>Ibrahim, J. G., Chen, M., Gwon, Y., and Chen, F. (2015). The power prior: Theory and applications. Statistics in Medicine, 34(28), 3724–3749.
</p>
<p>Gronau, Q. F., Singmann, H., and Wagenmakers, E.-J. (2020). bridgesampling: An r package for estimating normalizing constants. Journal of Statistical Software, 92(10).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  actg036 = actg036[1:50, ]
  data_list = list(currdata = actg019, histdata = actg036)
  formula = cd4 ~ treatment + age + race
  family = poisson('log')
  d.napp = glm.napp(
    formula = formula, family = family,
    data.list = data_list,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
  glm.logml.napp(
    post.samples = d.napp,
    bridge.args = list(silent = TRUE)
  )
}
</code></pre>

<hr>
<h2 id='glm.logml.npp'>Log marginal likelihood of a GLM under normalized power prior (NPP)</h2><span id='topic+glm.logml.npp'></span>

<h3>Description</h3>

<p>Uses bridge sampling to estimate the logarithm of the marginal likelihood of a GLM under the
normalized power prior (NPP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.logml.npp(post.samples, bridge.args = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.logml.npp_+3A_post.samples">post.samples</code></td>
<td>
<p>output from <code><a href="#topic+glm.npp">glm.npp()</a></code> giving posterior samples of a GLM under the normalized power
prior (NPP), with an attribute called 'data' which includes the list of variables
specified in the data block of the Stan program.</p>
</td></tr>
<tr><td><code id="glm.logml.npp_+3A_bridge.args">bridge.args</code></td>
<td>
<p>a <code>list</code> giving arguments (other than samples, log_posterior, data, lb, ub) to pass onto
<code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>list</code> with the following objects
</p>

<dl>
<dt>model</dt><dd><p>&quot;NPP&quot;</p>
</dd>
<dt>logml</dt><dd><p>the estimated logarithm of the marginal likelihood</p>
</dd>
<dt>bs</dt><dd><p>an object of class <code>bridge</code> or <code>bridge_list</code> containing the output from using <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>
to compute the logarithm of the marginal likelihood of the normalized power prior (NPP)</p>
</dd>
</dl>



<h3>References</h3>

<p>Duan, Y., Ye, K., and Smith, E. P. (2005). Evaluating water quality using power priors to incorporate historical information. Environmetrics, 17(1), 95–106.
</p>
<p>Gronau, Q. F., Singmann, H., and Wagenmakers, E.-J. (2020). bridgesampling: An r package for estimating normalizing constants. Journal of Statistical Software, 92(10).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if(requireNamespace("parallel")){
    data(actg019)
    data(actg036)
    ## take subset for speed purposes
    actg019 = actg019[1:100, ]
    actg036 = actg036[1:50, ]

    library(parallel)
    ncores    = 2
    data.list = list(data = actg019, histdata = actg036)
    formula   = cd4 ~ treatment + age + race
    family    = poisson()
    a0        = seq(0, 1, length.out = 11)
    if (instantiate::stan_cmdstan_exists()) {
      ## call created function
      ## wrapper to obtain log normalizing constant in parallel package
      logncfun = function(a0, ...){
        hdbayes::glm.npp.lognc(
          formula = formula, family = family, a0 = a0, histdata = data.list[[2]],
          ...
        )
      }

      cl = makeCluster(ncores)
      clusterSetRNGStream(cl, 123)
      clusterExport(cl, varlist = c('formula', 'family', 'data.list'))
      a0.lognc = parLapply(
        cl = cl, X = a0, fun = logncfun, iter_warmup = 500,
        iter_sampling = 1000, chains = 1, refresh = 0
      )
      stopCluster(cl)
      a0.lognc = data.frame( do.call(rbind, a0.lognc) )

      ## sample from normalized power prior
      d.npp = glm.npp(
        formula = formula,
        family = family,
        data.list = data.list,
        a0.lognc = a0.lognc$a0,
        lognc = matrix(a0.lognc$lognc, ncol = 1),
        chains = 1, iter_warmup = 500, iter_sampling = 1000,
        refresh = 0
      )
      glm.logml.npp(
        post.samples = d.npp,
        bridge.args = list(silent = TRUE)
      )
    }
  }

</code></pre>

<hr>
<h2 id='glm.logml.post'>Log marginal likelihood of a GLM under a normal/half-normal prior</h2><span id='topic+glm.logml.post'></span>

<h3>Description</h3>

<p>Uses bridge sampling to estimate the logarithm of the marginal likelihood of a GLM under the normal/half-normal prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.logml.post(post.samples, bridge.args = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.logml.post_+3A_post.samples">post.samples</code></td>
<td>
<p>output from <code><a href="#topic+glm.post">glm.post()</a></code> giving posterior samples of a GLM under the normal/half-normal
prior, with an attribute called 'data' which includes the list of variables specified
in the data block of the Stan program.</p>
</td></tr>
<tr><td><code id="glm.logml.post_+3A_bridge.args">bridge.args</code></td>
<td>
<p>a <code>list</code> giving arguments (other than <code>samples</code>, <code>log_posterior</code>, <code>data</code>, <code>lb</code>, and <code>ub</code>) to
pass onto <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>list</code> with the following objects
</p>

<dl>
<dt>model</dt><dd><p>&quot;Normal/Half-Normal&quot;</p>
</dd>
<dt>logml</dt><dd><p>the estimated logarithm of the marginal likelihood</p>
</dd>
<dt>bs</dt><dd><p>an object of class <code>bridge</code> or <code>bridge_list</code> containing the output from using <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>
to compute the logarithm of the marginal likelihood of the normal/half-normal prior</p>
</dd>
</dl>



<h3>References</h3>

<p>Gronau, Q. F., Singmann, H., and Wagenmakers, E.-J. (2020). bridgesampling: An r package for estimating normalizing constants. Journal of Statistical Software, 92(10).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  actg019 = actg019[1:100, ]
  data.list = list(currdata = actg019)
  formula = cd4 ~ treatment + age + race
  family = poisson('log')
  d.post = glm.post(
    formula = formula, family = family,
    data.list = data.list,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
  glm.logml.post(
    post.samples = d.post,
    bridge.args = list(silent = TRUE)
  )
}
</code></pre>

<hr>
<h2 id='glm.logml.pp'>Log marginal likelihood of a GLM under power prior (PP)</h2><span id='topic+glm.logml.pp'></span>

<h3>Description</h3>

<p>Uses Markov chain Monte Carlo (MCMC) and bridge sampling to estimate the logarithm of the marginal
likelihood of a GLM under the power prior (PP).
</p>
<p>The arguments related to MCMC sampling are utilized to draw samples from the power prior (PP).
These samples are then used to compute the logarithm of the normalizing constant of the PP using only historical
data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.logml.pp(
  post.samples,
  bridge.args = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.logml.pp_+3A_post.samples">post.samples</code></td>
<td>
<p>output from <code><a href="#topic+glm.pp">glm.pp()</a></code> giving posterior samples of a GLM under the power prior (PP), with
an attribute called 'data' which includes the list of variables specified in the data block
of the Stan program.</p>
</td></tr>
<tr><td><code id="glm.logml.pp_+3A_bridge.args">bridge.args</code></td>
<td>
<p>a <code>list</code> giving arguments (other than <code>samples</code>, <code>log_posterior</code>, <code>data</code>, <code>lb</code>, and <code>ub</code>) to
pass onto <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>.</p>
</td></tr>
<tr><td><code id="glm.logml.pp_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.logml.pp_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.logml.pp_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method
in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.logml.pp_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all of the power prior parameters (<code class="reqn">a_0</code>'s) are equal to zero, or if the posterior samples are obtained from using only
one data set (the current data), then the function will return the same result as the output from <code><a href="#topic+glm.logml.post">glm.logml.post()</a></code>.
</p>
<p>If at least one of the power prior parameters (<code class="reqn">a_0</code>'s) is non-zero, the function will return a <code>list</code> with the following objects
</p>

<dl>
<dt>model</dt><dd><p>&quot;PP&quot;</p>
</dd>
<dt>logml</dt><dd><p>the estimated logarithm of the marginal likelihood</p>
</dd>
<dt>bs</dt><dd><p>an object of class <code>bridge</code> or <code>bridge_list</code> containing the output from using <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>
to compute the logarithm of the normalizing constant of the power prior (PP) using all data sets</p>
</dd>
<dt>bs.hist</dt><dd><p>an object of class <code>bridge</code> or <code>bridge_list</code> containing the output from using
<code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code> to compute the logarithm of the normalizing constant of the PP using historical
data sets</p>
</dd>
<dt>min_ess_bulk</dt><dd><p>the minimum estimated bulk effective sample size of the MCMC sampling</p>
</dd>
<dt>max_Rhat</dt><dd><p>the maximum Rhat</p>
</dd>
</dl>



<h3>References</h3>

<p>Chen, M.-H. and Ibrahim, J. G. (2000). Power prior distributions for Regression Models. Statistical Science, 15(1).
</p>
<p>Gronau, Q. F., Singmann, H., and Wagenmakers, E.-J. (2020). bridgesampling: An r package for estimating normalizing constants. Journal of Statistical Software, 92(10).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  actg036 = actg036[1:50, ]
  data_list = list(currdata = actg019, histdata = actg036)
  formula = cd4 ~ treatment + age + race
  family = poisson('log')
  a0 = 0.5
  d.pp = glm.pp(
    formula = formula, family = family,
    data.list = data_list,
    a0.vals = a0,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
  glm.logml.pp(
    post.samples = d.pp,
    bridge.args = list(silent = TRUE),
    chains = 1, iter_warmup = 1000, iter_sampling = 2000
  )
}
</code></pre>

<hr>
<h2 id='glm.napp'>Posterior of normalized asymptotic power prior (NAPP)</h2><span id='topic+glm.napp'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the normalized asymptotic power prior (NAPP) by
Ibrahim et al. (2015) <a href="doi:10.1002/sim.6728">doi:10.1002/sim.6728</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.napp(
  formula,
  family,
  data.list,
  offset.list = NULL,
  a0.shape1 = 1,
  a0.shape2 = 1,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.napp_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical datasets.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of <code>offset.list</code> is equal to
the length of <code>data.list</code>. The length of each element of <code>offset.list</code> is equal to the number
of rows in the corresponding element of <code>data.list</code>. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_a0.shape1">a0.shape1</code></td>
<td>
<p>first shape parameter for the i.i.d. beta prior on a0 vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_a0.shape2">a0.shape2</code></td>
<td>
<p>second shape parameter for the i.i.d. beta prior on a0 vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.napp_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normalized asymptotic power prior (NAPP) assumes that the regression coefficients and logarithm of the
dispersion parameter are a multivariate normal distribution with mean equal to the maximum likelihood
estimate of the historical data and covariance matrix equal to <code class="reqn">a_0^{-1}</code> multiplied by the inverse Fisher
information matrix of the historical data, where <code class="reqn">a_0</code> is the power prior parameter (treated as random).
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples, with an attribute called 'data' which includes
the list of variables specified in the data block of the Stan program.
</p>


<h3>References</h3>

<p>Ibrahim, J. G., Chen, M., Gwon, Y., and Chen, F. (2015). The power prior: Theory and applications. Statistics in Medicine, 34(28), 3724–3749.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  actg036 = actg036[1:50, ]
  data_list = list(currdata = actg019, histdata = actg036)
  glm.napp(
    formula = cd4 ~ treatment + age + race,
    family = poisson('log'),
    data.list = data_list,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.npp'>Posterior of normalized power prior (NPP)</h2><span id='topic+glm.npp'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the normalized power prior (NPP) by Duan et al.
(2006) <a href="doi:10.1002/env.752">doi:10.1002/env.752</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.npp(
  formula,
  family,
  data.list,
  a0.lognc,
  lognc,
  offset.list = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  a0.shape1 = 1,
  a0.shape2 = 1,
  a0.lower = NULL,
  a0.upper = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.npp_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_a0.lognc">a0.lognc</code></td>
<td>
<p>a vector giving values of the power prior parameter for which the logarithm of the normalizing
constant has been evaluated.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_lognc">lognc</code></td>
<td>
<p>an S by T matrix where S is the length of <code>a0.lognc</code>, T is the number of historical data sets, and
the j-th column, j = 1, ..., T, is a vector giving the logarithm of the normalizing constant (as
estimated by <code><a href="#topic+glm.npp.lognc">glm.npp.lognc()</a></code> for <code>a0.lognc</code> using the j-th historical data set.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of <code>offset.list</code> is equal to
the length of <code>data.list</code>. The length of each element of <code>offset.list</code> is equal to the number
of rows in the corresponding element of <code>data.list</code>. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_beta.mean">beta.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the mean parameters for the initial prior on regression coefficients. If a scalar is provided,
<code>beta.mean</code> will be a vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_beta.sd">beta.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sd parameters for the initial prior on regression coefficients. If a scalar is provided,
same as for <code>beta.mean</code>. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_disp.mean">disp.mean</code></td>
<td>
<p>location parameter for the half-normal prior on dispersion parameter. Defaults to 0.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_disp.sd">disp.sd</code></td>
<td>
<p>scale parameter for the half-normal prior on dispersion parameter. Defaults to 10.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_a0.shape1">a0.shape1</code></td>
<td>
<p>first shape parameter for the i.i.d. beta prior on <code class="reqn">a_0</code> vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_a0.shape2">a0.shape2</code></td>
<td>
<p>second shape parameter for the i.i.d. beta prior on <code class="reqn">a_0</code> vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_a0.lower">a0.lower</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of historical data sets giving the
lower bounds for each element of the <code class="reqn">a_0</code> vector. If a scalar is provided, <code>a0.lower</code> will be a
vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_a0.upper">a0.upper</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of historical data sets giving the
upper bounds for each element of the <code class="reqn">a_0</code> vector. If a scalar is provided, same as for <code>a0.lower</code>.
Defaults to a vector of 1s.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method
in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.npp_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before using this function, users must estimate the logarithm of the normalizing constant across a
range of different values for the power prior parameter (<code class="reqn">a_0</code>), possibly smoothing techniques
over a find grid. The power prior parameters (<code class="reqn">a_0</code>'s) are treated as random with independent
beta priors. The initial priors on the regression coefficients are independent normal priors. The
current and historical data sets are assumed to have a common dispersion parameter with a
half-normal prior (if applicable). For normal linear models, the exact normalizing constants for
NPP can be computed. See the implementation in <code><a href="#topic+lm.npp">lm.npp()</a></code>.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples, with an attribute called 'data' which includes
the list of variables specified in the data block of the Stan program.
</p>


<h3>References</h3>

<p>Duan, Y., Ye, K., and Smith, E. P. (2005). Evaluating water quality using power priors to incorporate historical information. Environmetrics, 17(1), 95–106.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glm.npp.lognc">glm.npp.lognc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if(requireNamespace("parallel")){
    data(actg019)
    data(actg036)
    ## take subset for speed purposes
    actg019 = actg019[1:100, ]
    actg036 = actg036[1:50, ]

    library(parallel)
    ncores    = 2
    data.list = list(data = actg019, histdata = actg036)
    formula   = cd4 ~ treatment + age + race
    family    = poisson()
    a0        = seq(0, 1, length.out = 11)
    if (instantiate::stan_cmdstan_exists()) {
      ## call created function
      ## wrapper to obtain log normalizing constant in parallel package
      logncfun = function(a0, ...){
        hdbayes::glm.npp.lognc(
          formula = formula, family = family, a0 = a0, histdata = data.list[[2]],
          ...
        )
      }

      cl = makeCluster(ncores)
      clusterSetRNGStream(cl, 123)
      clusterExport(cl, varlist = c('formula', 'family', 'data.list'))
      a0.lognc = parLapply(
        cl = cl, X = a0, fun = logncfun, iter_warmup = 500,
        iter_sampling = 1000, chains = 1, refresh = 0
      )
      stopCluster(cl)
      a0.lognc = data.frame( do.call(rbind, a0.lognc) )

      ## sample from normalized power prior
      glm.npp(
        formula = formula,
        family = family,
        data.list = data.list,
        a0.lognc = a0.lognc$a0,
        lognc = matrix(a0.lognc$lognc, ncol = 1),
        chains = 1, iter_warmup = 500, iter_sampling = 1000,
        refresh = 0
      )
    }
  }

</code></pre>

<hr>
<h2 id='glm.npp.lognc'>Estimate the logarithm of the normalizing constant for normalized power prior (NPP) for one data set</h2><span id='topic+glm.npp.lognc'></span>

<h3>Description</h3>

<p>Uses Markov chain Monte Carlo (MCMC) and bridge sampling to estimate the logarithm of the normalizing
constant for the NPP for a fixed value of the power prior parameter <code class="reqn">a_0 \in (0, 1)</code> for one data
set. The initial priors are independent normal priors on the regression coefficients and a half-normal
prior on the dispersion parameter (if applicable).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.npp.lognc(
  formula,
  family,
  histdata,
  a0,
  offset0 = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  bridge.args = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.npp.lognc_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_histdata">histdata</code></td>
<td>
<p>a <code>data.frame</code> giving the historical data.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_a0">a0</code></td>
<td>
<p>the power prior parameter (a scalar between 0 and 1).</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_offset0">offset0</code></td>
<td>
<p>vector whose dimension is equal to the rows of the historical data set giving an offset for the
historical data. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_beta.mean">beta.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the mean parameters for the normal initial prior on regression coefficients given the dispersion
parameter. If a scalar is provided, beta.mean will be a vector of repeated elements of the given
scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_beta.sd">beta.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sd parameters for the initial prior on regression coefficients. The sd used is
<code>sqrt(dispersion) * beta.sd</code>. If a scalar is provided, same as for beta.mean. Defaults to
a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_disp.mean">disp.mean</code></td>
<td>
<p>location parameter for the half-normal prior on dispersion parameter. Defaults to 0.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_disp.sd">disp.sd</code></td>
<td>
<p>scale parameter for the half-normal prior on dispersion parameter. Defaults to 10.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_bridge.args">bridge.args</code></td>
<td>
<p>a <code>list</code> giving arguments (other than samples, log_posterior, data, lb, ub) to pass
onto <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.npp.lognc_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a vector giving the value of a0, the estimated logarithm of the normalizing constant, the minimum
estimated bulk effective sample size of the MCMC sampling, and the maximum Rhat.
</p>


<h3>References</h3>

<p>Gronau, Q. F., Singmann, H., and Wagenmakers, E.-J. (2020). bridgesampling: An r package for estimating normalizing constants. Journal of Statistical Software, 92(10).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg036)
  ## take subset for speed purposes
  actg036 = actg036[1:50, ]
  glm.npp.lognc(
    cd4 ~ treatment + age + race,
    family = poisson(), histdata = actg036, a0 = 0.5,
    chains = 1, iter_warmup = 500, iter_sampling = 5000
  )
}
</code></pre>

<hr>
<h2 id='glm.post'>Posterior of a normal/half-normal prior</h2><span id='topic+glm.post'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using a normal/half-normal prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.post(
  formula,
  family,
  data.list,
  offset.list = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.post_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.post_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.post_+3A_data.list">data.list</code></td>
<td>
<p>a list consisting of one <code>data.frame</code> giving the current data. If <code>data.list</code> has more
than one <code>data.frame</code>, only the first element will be used as the current data.</p>
</td></tr>
<tr><td><code id="glm.post_+3A_offset.list">offset.list</code></td>
<td>
<p>a list consisting of one vector giving the offset for the current data. The length of
the vector is equal to the number of rows in the current data. The vector has all values
set to 0 by default. If <code>offset.list</code> has more than one vector, same as for <code>data.list</code>.</p>
</td></tr>
<tr><td><code id="glm.post_+3A_beta.mean">beta.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the mean parameters for the normal prior on regression coefficients. If a scalar is provided,
<code>beta.mean</code> will be a vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.post_+3A_beta.sd">beta.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sd parameters for the normal prior on regression coefficients. If a scalar is provided,
same as for <code>beta.mean</code>. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.post_+3A_disp.mean">disp.mean</code></td>
<td>
<p>location parameter for the half-normal prior on dispersion parameter. Defaults to 0. If
<code>disp.mean</code> is a vector with length &gt; 1, only the first element will be used as <code>disp.mean</code>.</p>
</td></tr>
<tr><td><code id="glm.post_+3A_disp.sd">disp.sd</code></td>
<td>
<p>scale parameter for the half-normal prior on dispersion parameter. Defaults to 10. If
<code>disp.sd</code> is a vector with length &gt; 1, same as for <code>disp.mean</code>.</p>
</td></tr>
<tr><td><code id="glm.post_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.post_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.post_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.post_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The priors on the regression coefficients are independent normal distributions. When the normal priors are elicited
with large variances, the prior is also referred to as the reference or vague prior. The dispersion parameter is
assumed to be independent of the regression coefficients with a half-normal prior (if applicable).
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples, with an attribute called 'data' which includes
the list of variables specified in the data block of the Stan program.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  data.list = list(currdata = actg019)
  glm.post(
    formula = cd4 ~ treatment + age + race,
    family = poisson('log'),
    data.list = data.list,
    beta.sd   = 10,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.pp'>Posterior of power prior (PP) with fixed <code class="reqn">a_0</code></h2><span id='topic+glm.pp'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the power prior (PP) by Ibrahim and Chen (2000) <a href="doi:10.1214/ss/1009212673">doi:10.1214/ss/1009212673</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.pp(
  formula,
  family,
  data.list,
  a0.vals,
  offset.list = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.pp_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_a0.vals">a0.vals</code></td>
<td>
<p>a scalar between 0 and 1 or a vector whose dimension is equal to the number of historical
data sets giving the (fixed) power prior parameter for each historical data set. Each element of
vector should be between 0 and 1. If a scalar is provided, same as for <code>beta.mean</code>.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of <code>offset.list</code> is equal to
the length of <code>data.list</code>. The length of each element of <code>offset.list</code> is equal to the number
of rows in the corresponding element of <code>data.list</code>. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_beta.mean">beta.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the mean parameters for the initial prior on regression coefficients. If a scalar is provided,
<code>beta.mean</code> will be a vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_beta.sd">beta.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sd parameters for the initial prior on regression coefficients. If a scalar is provided,
same as for <code>beta.mean</code>. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_disp.mean">disp.mean</code></td>
<td>
<p>location parameter for the half-normal prior on dispersion parameter. Defaults to 0.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_disp.sd">disp.sd</code></td>
<td>
<p>scale parameter for the half-normal prior on dispersion parameter. Defaults to 10.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.pp_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power prior parameters (<code class="reqn">a_0</code>'s) are treated as fixed. The initial priors on the regression coefficients
are independent normal priors. The current and historical data sets are assumed to have a common dispersion parameter
with a half-normal prior (if applicable).
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples, with an attribute called 'data' which includes
the list of variables specified in the data block of the Stan program.
</p>


<h3>References</h3>

<p>Chen, M.-H. and Ibrahim, J. G. (2000). Power prior distributions for Regression Models. Statistical Science, 15(1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  actg036 = actg036[1:50, ]
  data_list = list(currdata = actg019, histdata = actg036)
  glm.pp(
    formula = cd4 ~ treatment + age + race,
    family = poisson('log'),
    data.list = data_list,
    a0.vals = 0.5,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

<hr>
<h2 id='glm.rmap'>Posterior of robust meta-analytic predictive prior (RMAP)</h2><span id='topic+glm.rmap'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the robust meta-analytic predictive prior (RMAP)
by Schmidli et al. (2014) <a href="doi:10.1111/biom.12242">doi:10.1111/biom.12242</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.rmap(
  formula,
  family,
  data.list,
  offset.list = NULL,
  w = 0.1,
  meta.mean.mean = NULL,
  meta.mean.sd = NULL,
  meta.sd.mean = NULL,
  meta.sd.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  norm.vague.mean = NULL,
  norm.vague.sd = NULL,
  bridge.args = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.rmap_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_family">family</code></td>
<td>
<p>an object of class <code>family</code>. See <code><a href="stats.html#topic+family">?stats::family</a></code>.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of <code>offset.list</code> is equal to
the length of <code>data.list</code>. The length of each element of <code>offset.list</code> is equal to the number
of rows in the corresponding element of <code>data.list</code>. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_w">w</code></td>
<td>
<p>a scalar between 0 and 1 giving how much weight to put on the historical data. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_meta.mean.mean">meta.mean.mean</code></td>
<td>
<p>same as <code>meta.mean.mean</code> in <code><a href="#topic+glm.bhm">glm.bhm()</a></code>. It is a scalar or a vector whose dimension is equal
to the number of regression coefficients giving the means for the normal hyperpriors on the
mean hyperparameters of regression coefficients in Bayesian hierarchical model (BHM). If a
scalar is provided, <code>meta.mean.mean</code> will be a vector of repeated elements of the given scalar.
Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_meta.mean.sd">meta.mean.sd</code></td>
<td>
<p>same as <code>meta.mean.sd</code> in <code><a href="#topic+glm.bhm">glm.bhm()</a></code>. It is a scalar or a vector whose dimension is equal
to the number of regression coefficients giving the sds for the normal hyperpriors on the
mean hyperparameters of regression coefficients in BHM. If a scalar is provided, same as for
<code>meta.mean.mean</code>. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_meta.sd.mean">meta.sd.mean</code></td>
<td>
<p>same as <code>meta.sd.mean</code> in <code><a href="#topic+glm.bhm">glm.bhm()</a></code>. It is a scalar or a vector whose dimension is equal
to the number of regression coefficients giving the means for the half-normal hyperpriors
on the sd hyperparameters of regression coefficients in BHM. If a scalar is provided, same
as for <code>meta.mean.mean</code>. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_meta.sd.sd">meta.sd.sd</code></td>
<td>
<p>same as <code>meta.sd.sd</code> in <code><a href="#topic+glm.bhm">glm.bhm()</a></code>. It is a scalar or a vector whose dimension is equal to
the number of regression coefficients giving the sds for the half-normal hyperpriors on the
sd hyperparameters of regression coefficients in BHM. If a scalar is provided, same as for
<code>meta.mean.mean</code>. Defaults to a vector of 1s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_disp.mean">disp.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of data sets (including the current
data) giving the location parameters for the half-normal priors on the dispersion parameters. If
a scalar is provided, same as for <code>meta.mean.mean</code>. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_disp.sd">disp.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of data sets (including the current
data) giving the scale parameters for the half-normal priors on the dispersion parameters. If a
scalar is provided, same as for <code>meta.mean.mean</code>. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_norm.vague.mean">norm.vague.mean</code></td>
<td>
<p>same as <code>beta.mean</code> in <code><a href="#topic+glm.post">glm.post()</a></code>. It is a scalar or a vector whose dimension is equal to the
number of regression coefficients giving the means for the vague normal prior on regression
coefficients. If a scalar is provided, <code>norm.vague.mean</code> will be a vector of repeated elements
of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_norm.vague.sd">norm.vague.sd</code></td>
<td>
<p>same as <code>beta.sd</code> in <code><a href="#topic+glm.post">glm.post()</a></code>. It is a scalar or a vector whose dimension is equal to the
number of regression coefficients giving the sds for the vague normal prior on regression
coefficients. If a scalar is provided, same as for <code>norm.vague.mean</code>. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_bridge.args">bridge.args</code></td>
<td>
<p>a <code>list</code> giving arguments (other than samples, log_posterior, data, lb, ub) to pass
onto <code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler()</a></code>.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="glm.rmap_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The robust meta-analytic predictive prior (RMAP) is a two-part mixture prior consisting of a meta-analytic
predictive (MAP) prior (the prior induced by Bayesian hierarchical model (BHM)) and a vague (i.e.,
non-informative) prior (specifically, the normal/half-normal prior with large variances). Although Schmidli et al.
(2014) recommends to use a finite mixture of conjugate priors to approximate the BHM, it can be difficult and
time-consuming to come up with an appropriate approximation.
</p>
<p>Instead, the approach taken by hdbayes is to use the marginal likelihood of the MAP and vague priors.
Specifically, note that the posterior distribution of a GLM under RMAP is also a two-part mixture distribution.
The updated mixture weight for posterior density under the MAP prior is
</p>
<p style="text-align: center;"><code class="reqn">\widetilde{w} = \frac{w Z_I(D, D_0)}{w Z_I(D, D_0) + (1-w) Z_V(D)},</code>
</p>

<p>where <code class="reqn">w</code> is the prior mixture weight for the MAP prior in RMAP, <code class="reqn">Z_I(D, D_0)</code> is the marginal likelihood
of the MAP prior, and <code class="reqn">Z_V(D)</code> is the marginal likelihood of the vague prior.
</p>


<h3>Value</h3>

<p>The function returns a <code>list</code> with the following objects
</p>

<dl>
<dt>post.samples</dt><dd><p>an object of class <code>draws_df</code> giving posterior samples under the robust meta-analytic predictive prior (RMAP)</p>
</dd>
<dt>post.samples.bhm</dt><dd><p>an object of class <code>draws_df</code> giving posterior samples under the Bayesian hierarchical model (BHM),
obtained from using <code><a href="#topic+glm.bhm">glm.bhm()</a></code></p>
</dd>
<dt>post.samples.vague</dt><dd><p>an object of class <code>draws_df</code> giving posterior samples under the vague/non-informative prior, obtained
from using <code><a href="#topic+glm.post">glm.post()</a></code></p>
</dd>
<dt>bs.map</dt><dd><p>output from computing log marginal likelihood of the prior induced by the BHM (referred to as the meta-analytic predictive
(MAP) prior) via <code><a href="#topic+glm.logml.map">glm.logml.map()</a></code> function</p>
</dd>
<dt>bs.vague</dt><dd><p>output from computing log marginal likelihood of the vague prior via <code><a href="#topic+glm.logml.post">glm.logml.post()</a></code> function</p>
</dd>
</dl>



<h3>References</h3>

<p>Schmidli, H., Gsteiger, S., Roychoudhury, S., O’Hagan, A., Spiegelhalter, D., and Neuenschwander, B. (2014). Robust meta‐analytic‐predictive priors in clinical trials with historical control information. Biometrics, 70(4), 1023–1032.
</p>
<p>Gronau, Q. F., Singmann, H., and Wagenmakers, E.-J. (2020). bridgesampling: An r package for estimating normalizing constants. Journal of Statistical Software, 92(10).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if (instantiate::stan_cmdstan_exists()) {
    data(actg019) ## current data
    data(actg036) ## historical data
    ## take subset for speed purposes
    actg019 = actg019[1:150, ]
    actg036 = actg036[1:100, ]
    data.list = list(actg019, actg036)
    glm.rmap(
      formula = outcome ~ scale(age) + race + treatment + scale(cd4),
      family = binomial('logit'),
      data.list = data.list,
      w = 0.1,
      chains = 1, iter_warmup = 1000, iter_sampling = 2000
    )
  }

</code></pre>

<hr>
<h2 id='IBCSG_curr'>International Breast Cancer Study Group (IBCSG) Trial VI Data</h2><span id='topic+IBCSG_curr'></span>

<h3>Description</h3>

<p>A data set from the IBCSG Trial VI investigating both the duration of adjuvant chemotherapy
(3 versus 6 initial cycles of oral cyclophosphamide, methotrexate, and fluorouracil (CMF)) and
the reintroduction of single courses of delayed chemotherapy in node-positive premenopausal
breast cancer patients. The study results were described by IBCSG (1996) <a href="doi:10.1200/JCO.1996.14.6.1885">doi:10.1200/JCO.1996.14.6.1885</a>
and Hürny et al. (1992) <a href="doi:10.1016/0959-8049(92)90399-m">doi:10.1016/0959-8049(92)90399-m</a>. This data set only includes patients
above the age of 40 (i.e., age <code class="reqn">\geq</code> 40) and treats the measurements of patients' physical well-being
on month 18 as the outcome. The IBCSG_hist data set includes patients from the same study but
with age &lt; 40. We can use the IBCSG_hist data as the historical data and the IBCSG_curr data as
the current data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBCSG_curr
</code></pre>


<h3>Format</h3>

<p>A data frame with 488 rows and 8 variables:
</p>

<dl>
<dt>phys18</dt><dd><p>outcome variable, integer scores between 0 and 100 measuring
the patients' physical well-being on month 18, with a higher
score indicating a better physical well-being</p>
</dd>
<dt>phys1</dt><dd><p>physical well-being scores assessed at the start of the study</p>
</dd>
<dt>n_init_cycles</dt><dd><p>number of initial cycles of CMF, equal to 3 or 6</p>
</dd>
<dt>reintroduction</dt><dd><p>indicator of reintroduction of chemotherapy, 0 = no
reintroduction, 1 = having reintroduction</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>country</dt><dd><p>country, ANZ = New Zealand/Australia, CH = Switzerland,
SWED = Sweden</p>
</dd>
<dt>nodegp</dt><dd><p>indicator of number of positive nodes being greater than or
equal to 4, 0 = less than 4, 1 = 4+</p>
</dd>
<dt>ER</dt><dd><p>estrogen receptor (ER) status indicator, 0 = negative, 1 = positive</p>
</dd>
</dl>



<h3>References</h3>

<p>International Breast Cancer Study Group. (1996). Duration and reintroduction of adjuvant chemotherapy for node-positive premenopausal breast cancer patients. Journal of Clinical Oncology, 14(6), 1885–1894.
</p>
<p>Hürny, C., Bernhard, J., Gelber, R. D., Coates, A., Castiglione, M., Isley, M., Dreher, D., Peterson, H., Goldhirsch, A., and Senn, H.-J. (1992). Quality of life measures for patients receiving adjuvant therapy for breast cancer: An international trial. European Journal of Cancer, 28(1), 118–124.
</p>
<p>Chi, Y.-Y. and Ibrahim, J. G. (2005). Joint models for multivariate longitudinal and Multivariate Survival Data. Biometrics, 62(2), 432–445.
</p>

<hr>
<h2 id='IBCSG_hist'>International Breast Cancer Study Group (IBCSG) Trial VI Data</h2><span id='topic+IBCSG_hist'></span>

<h3>Description</h3>

<p>A data set from the IBCSG Trial VI investigating both the duration of adjuvant chemotherapy
(3 versus 6 initial cycles of oral cyclophosphamide, methotrexate, and fluorouracil (CMF)) and
the reintroduction of single courses of delayed chemotherapy in node-positive premenopausal
breast cancer patients. The study results were described by IBCSG (1996) <a href="doi:10.1200/JCO.1996.14.6.1885">doi:10.1200/JCO.1996.14.6.1885</a>
and Hürny et al. (1992) <a href="doi:10.1016/0959-8049(92)90399-m">doi:10.1016/0959-8049(92)90399-m</a>. This data set only includes patients
under the age of 40 (i.e., age &lt; 40) and treats the measurements of patients' physical well-being
on month 18 as the outcome. The IBCSG_curr data set includes patients from the same study but
with age <code class="reqn">\geq</code> 40. We can use the IBCSG_hist data as the historical data and the IBCSG_curr data as
the current data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBCSG_hist
</code></pre>


<h3>Format</h3>

<p>A data frame with 103 rows and 8 variables:
</p>

<dl>
<dt>phys18</dt><dd><p>outcome variable, integer scores between 0 and 100 measuring
the patients' physical well-being on month 18, with a higher
score indicating a better physical well-being</p>
</dd>
<dt>phys1</dt><dd><p>physical well-being scores assessed at the start of the study</p>
</dd>
<dt>n_init_cycles</dt><dd><p>number of initial cycles of CMF, equal to 3 or 6</p>
</dd>
<dt>reintroduction</dt><dd><p>indicator of reintroduction of chemotherapy, 0 = no
reintroduction, 1 = having reintroduction</p>
</dd>
<dt>age</dt><dd><p>patient age in years</p>
</dd>
<dt>country</dt><dd><p>country, ANZ = New Zealand/Australia, CH = Switzerland,
SWED = Sweden</p>
</dd>
<dt>nodegp</dt><dd><p>indicator of number of positive nodes being greater than or
equal to 4, 0 = less than 4, 1 = 4+</p>
</dd>
<dt>ER</dt><dd><p>estrogen receptor (ER) status indicator, 0 = negative, 1 = positive</p>
</dd>
</dl>



<h3>References</h3>

<p>International Breast Cancer Study Group. (1996). Duration and reintroduction of adjuvant chemotherapy for node-positive premenopausal breast cancer patients. Journal of Clinical Oncology, 14(6), 1885–1894.
</p>
<p>Hürny, C., Bernhard, J., Gelber, R. D., Coates, A., Castiglione, M., Isley, M., Dreher, D., Peterson, H., Goldhirsch, A., and Senn, H.-J. (1992). Quality of life measures for patients receiving adjuvant therapy for breast cancer: An international trial. European Journal of Cancer, 28(1), 118–124.
</p>
<p>Chi, Y.-Y. and Ibrahim, J. G. (2005). Joint models for multivariate longitudinal and Multivariate Survival Data. Biometrics, 62(2), 432–445.
</p>

<hr>
<h2 id='lm.npp'>Posterior of normalized power prior (NPP) for normal linear models</h2><span id='topic+lm.npp'></span>

<h3>Description</h3>

<p>Sample from the posterior distribution of a normal linear model using the NPP by Duan et al. (2006) <a href="doi:10.1002/env.752">doi:10.1002/env.752</a>.
The power prior parameters (<code class="reqn">a_0</code>'s) are treated as random with independent beta priors. The current and historical
data sets are assumed to have a common dispersion parameter (<code class="reqn">\sigma^2</code>) with an inverse-gamma prior. Conditional on
<code class="reqn">\sigma^2</code>, the initial priors on the regression coefficients are independent normal distributions with variance
<code class="reqn">\propto (\sigma^2)^{-1}</code>. In this case, the normalizing constant for the NPP has a closed form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.npp(
  formula,
  data.list,
  offset.list = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  sigmasq.shape = 2.1,
  sigmasq.scale = 1.1,
  a0.shape1 = 1,
  a0.shape2 = 1,
  a0.lower = NULL,
  a0.upper = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm.npp_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_data.list">data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_offset.list">offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of offset.list is equal to
the length of data.list. The length of each element of offset.list is equal to the number
of rows in the corresponding element of data.list. Defaults to a list of vectors of 0s.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_beta.mean">beta.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the mean parameters for the initial prior on regression coefficients. If a scalar is provided,
beta.mean will be a vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_beta.sd">beta.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients.
Conditional on the variance parameter sigmasq for the outcome, beta.sd * sqrt(sigmasq) gives
the sd for the initial prior on regression coefficients. If a scalar is provided, same as for
beta.mean. Defaults to a vector of 10s.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_sigmasq.shape">sigmasq.shape</code></td>
<td>
<p>shape parameter for inverse-gamma prior on variance parameter. Defaults to 2.1.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_sigmasq.scale">sigmasq.scale</code></td>
<td>
<p>scale parameter for inverse-gamma prior on variance parameter. Defaults to 1.1.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_a0.shape1">a0.shape1</code></td>
<td>
<p>first shape parameter for the i.i.d. beta prior on a0 vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_a0.shape2">a0.shape2</code></td>
<td>
<p>second shape parameter for the i.i.d. beta prior on a0 vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_a0.lower">a0.lower</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of historical data sets giving the
lower bounds for each element of the a0 vector. If a scalar is provided, a0.lower will be a
vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_a0.upper">a0.upper</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of historical data sets giving the
upper bounds for each element of the a0 vector. If a scalar is provided, same as for a0.lower.
Defaults to a vector of 1s.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_chains">chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td></tr>
<tr><td><code id="lm.npp_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g. seed, refresh, init).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples.
</p>


<h3>References</h3>

<p>Duan, Y., Ye, K., and Smith, E. P. (2005). Evaluating water quality using power priors to incorporate historical information. Environmetrics, 17(1), 95–106.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  data_list = list(currdata = actg019, histdata = actg036)
  lm.npp(
    formula = cd4 ~ treatment + age + race,
    data.list = data_list,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
