<!DOCTYPE html><html><head><title>Help for package qrjoint</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qrjoint}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chull.center'><p>Fast Interior Point Center of Multivariate Data</p></a></li>
<li><a href='#coef.qde'><p>Coefficient Extraction from qde Model Fit</p></a></li>
<li><a href='#coef.qrjoint'><p>Regression Coefficient Extraction from qrjoint Model Fit</p></a></li>
<li><a href='#getBands'><p>Posterior Credible Bands</p></a></li>
<li><a href='#plasma'>
<p>Plasma Concentration of Beta-Carotene and Retinol</p></a></li>
<li><a href='#predict.qde'><p>Posterior predictive summary for quantile-based density estimation</p></a></li>
<li><a href='#predict.qrjoint'><p>Posterior predictive summary for quantile estimation</p></a></li>
<li><a href='#qde'><p>Quantiles based Density Estimation</p></a></li>
<li><a href='#qrjoint'><p>Joint Estimation of Linear Quantile Planes</p></a></li>
<li><a href='#qrjoint-internal'><p>Internal qrjoint Functions</p></a></li>
<li><a href='#redmaple'><p>Basal Areas of Red Maple Trees</p></a></li>
<li><a href='#summary.qde'><p>Summary Method for Quantile based Density Estimation</p></a></li>
<li><a href='#summary.qrjoint'><p>Summary Method for qrjoint Model Fit</p></a></li>
<li><a href='#waic'><p>Watanabe Information Criterion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0-9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Joint Estimation in Linear Quantile Regression</td>
</tr>
<tr>
<td>Author:</td>
<td>Surya Tokdar &lt;surya.tokdar@duke.edu&gt; and Erika Cunningham &lt;erika.ball@duke.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Surya Tokdar &lt;surya.tokdar@duke.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.6), stats, graphics, grDevices</td>
</tr>
<tr>
<td>Imports:</td>
<td>splines, coda, Matrix, kernlab, quantreg</td>
</tr>
<tr>
<td>Description:</td>
<td>Joint estimation of quantile specific intercept and slope parameters in a linear regression setting.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-31 01:18:12 UTC; stokdar</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-05 17:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='chull.center'>Fast Interior Point Center of Multivariate Data</h2><span id='topic+chull.center'></span>

<h3>Description</h3>

<p>Calculates an interior point by averaging a small number of near-extreme points of the cloud.</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
chull.center(x, maxEPts = ncol(x) + 1, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chull.center_+3A_x">x</code></td>
<td>
<p>a matrix giving the data cloud.</p>
</td></tr>
<tr><td><code id="chull.center_+3A_maxepts">maxEPts</code></td>
<td>
<p>integer giving the maximum number of (near)-extreme points to be used in averaging. Default is <code>ncol(x)+1</code>.</p>
</td></tr>
<tr><td><code id="chull.center_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether a pairwise scatter plot should be made</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Near extreme points are found in a space-filling manner by adding points with minimum residual conditional variance given points already included under a smooth GP specification. See Yang and Tokdar (2015), Section B.1. for more details.</p>


<h3>Value</h3>

<p>Returns an interior point of the data cloud. The positions of the near extreme points are returned as the attribute <code>"EPts"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
p &lt;- 9
n &lt;- 200
u &lt;- runif(n)
require(splines)
x &lt;- bs(u, df = p)
chull.center(x, plot = TRUE)
</code></pre>

<hr>
<h2 id='coef.qde'>Coefficient Extraction from qde Model Fit</h2><span id='topic+coef.qde'></span>

<h3>Description</h3>

<p>Post process MCMC output from <code><a href="#topic+qde">qde</a></code> to create summaries of the quantile estimates.</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'qde'
coef(object, burn.perc = 0.5, nmc = 200, reduce = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.qde_+3A_object">object</code></td>
<td>
<p>a fitted model of the class <code>qde</code>.</p>
</td></tr>
<tr><td><code id="coef.qde_+3A_burn.perc">burn.perc</code></td>
<td>
<p>a positive fraction indicating what fraction of the saved draws are to be discarded as burn-in</p>
</td></tr>
<tr><td><code id="coef.qde_+3A_nmc">nmc</code></td>
<td>
<p>integer giving the number of samples, post burn-in, to be used in Monte Carlo averaging</p>
</td></tr>
<tr><td><code id="coef.qde_+3A_reduce">reduce</code></td>
<td>
<p>logical indicating if the tail-expanded grid of tau values is to be reduced to the regular increment grid</p>
</td></tr>
<tr><td><code id="coef.qde_+3A_...">...</code></td>
<td>
<p>not currently implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extracts posterior draws of intercept and slope functions from saved draws of model parameters. A plot may be obtained if <code>plot = TRUE</code>. A list is returned invisibly with three fields.
</p>
<table>
<tr><td><code>beta.samp</code></td>
<td>
<p>a matrix with <code>nmc</code> many columns and <code>length(tau.grid)</code> many rows.</p>
</td></tr>
<tr><td><code>beta.est</code></td>
<td>
<p>a 3-column matrix of median, 2.5th and 97.5th percentiles of the posterior distribution of <code class="reqn">\beta_0</code></p>
</td></tr>
<tr><td><code>parametric</code></td>
<td>
<p>a matrix with 3 columns giving the estimate (posterior median) and the lower and upper end points of the 95% posterior credible interval for <code class="reqn">\gamma_0</code>, <code class="reqn">\sigma</code>, and, <code class="reqn">\nu</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+qde">qde</a></code> and <code><a href="#topic+summary.qde">summary.qde</a></code> for model fitting under qrjoint. Also see <code><a href="#topic+getBands">getBands</a></code> for plotting credible bands for coefficients.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plasma data analysis
data(plasma)
Y &lt;- plasma$BetaPlasma
Y &lt;- Y + 0.1 * rnorm(length(Y)) ## remove atomicity

# model fitting with 50 posterior samples from 100 iterations (thin = 2)
fit.qde &lt;- qde(Y, 50, 2)
betas &lt;- coef(fit.qde)
signif(betas$parametric, 3)
</code></pre>

<hr>
<h2 id='coef.qrjoint'>Regression Coefficient Extraction from qrjoint Model Fit</h2><span id='topic+coef.qrjoint'></span>

<h3>Description</h3>

<p>Post process MCMC output from <code><a href="#topic+qrjoint">qrjoint</a></code> to create summaries of intercept and slope function estimates</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'qrjoint'
coef(object, burn.perc = 0.5, nmc = 200, plot = FALSE, show.intercept = TRUE, 
        reduce = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.qrjoint_+3A_object">object</code></td>
<td>
<p>a fitted model of the class <code>qrjoint</code>.</p>
</td></tr>
<tr><td><code id="coef.qrjoint_+3A_burn.perc">burn.perc</code></td>
<td>
<p>a positive fraction indicating what fraction of the saved draws are to be discarded as burn-in</p>
</td></tr>
<tr><td><code id="coef.qrjoint_+3A_nmc">nmc</code></td>
<td>
<p>integer giving the number of samples, post burn-in, to be used in Monte Carlo averaging</p>
</td></tr>
<tr><td><code id="coef.qrjoint_+3A_plot">plot</code></td>
<td>
<p>logical indicating if plots are to be made</p>
</td></tr>
<tr><td><code id="coef.qrjoint_+3A_show.intercept">show.intercept</code></td>
<td>
<p>whether to plot the intercept curve when <code>plot = TRUE</code></p>
</td></tr>
<tr><td><code id="coef.qrjoint_+3A_reduce">reduce</code></td>
<td>
<p>logical indicating if the tail-expanded grid of tau values is to be reduced to the regular increment grid</p>
</td></tr>
<tr><td><code id="coef.qrjoint_+3A_...">...</code></td>
<td>
<p>limited plotting parameters that are passed onto the call of <code><a href="#topic+getBands">getBands</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extracts posterior draws of intercept and slope functions from saved draws of model parameters. A plot may be obtained if <code>plot = TRUE</code>. A list is returned invisibly with three fields.
</p>
<table>
<tr><td><code>beta.samp</code></td>
<td>
<p>a three-dimensional array of posterior samples of <code class="reqn">\beta_j</code>. Its dimensions are <code>L</code> (length of tau.grid)  x <code>p+1</code> (intercept + slopes) x <code>nmc</code> (retained posterior draws).</p>
</td></tr>
<tr><td><code>beta.est</code></td>
<td>
<p>a three-dimensional array containing posterior summaries (2.5th,  50th, and 97.5th percentiles) of <code class="reqn">\beta_j</code>. Its dimensions are <code>L</code> (length of tau.grid)  x <code>p+1</code> (intercept + slopes) x 3 (posterior summaries).</p>
</td></tr> 
<tr><td><code>parametric</code></td>
<td>
<p>a matrix with 3 columns giving the estimate (posterior median) and the lower and upper end points of the 95% posterior credible interval for <code class="reqn">\gamma_0</code>, <code class="reqn">\gamma</code>, <code class="reqn">\sigma</code>, and, <code class="reqn">\nu</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+qrjoint">qrjoint</a></code> and <code><a href="#topic+summary.qrjoint">summary.qrjoint</a></code> for model fitting under qrjoint. Also see <code><a href="#topic+getBands">getBands</a></code> for plotting credible bands for coefficients.</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Plasma data analysis

# recoding variables
data(plasma)
plasma$Sex &lt;- as.factor(plasma$Sex)
plasma$SmokStat &lt;- as.factor(plasma$SmokStat)
plasma$VitUse &lt;- 3 - plasma$VitUse
plasma$VitUse &lt;- as.factor(plasma$VitUse)

# model fitting with 50 posterior samples from 100 iterations (thin = 2)
fit.qrj &lt;- qrjoint(BetaPlasma ~ Age + Sex + SmokStat + Quetelet + VitUse + Calories + 
        Fat + Fiber + Alcohol + Cholesterol + BetaDiet, plasma, nsamp = 40, thin = 2)

## Not run: 
betas &lt;- coef(fit.qrj) ## no plots
betas &lt;- coef(fit.qrj, plot = TRUE) ## estimates are plotted

## End(Not run)
</code></pre>

<hr>
<h2 id='getBands'>Posterior Credible Bands</h2><span id='topic+getBands'></span>

<h3>Description</h3>

<p>Calculate and display credible bands of a vector of parameters from a sample of draws. Most suitable when the vector represents a discretized version of a function.</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
getBands(b, col = 2, lwd = 1, plot = TRUE, add = FALSE, 
x = seq(0,1,len=nrow(b)), remove.edges = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBands_+3A_b">b</code></td>
<td>
<p>a matrix of sampled draws of a vector, columns giving samples and rows giving elements of the vector</p>
</td></tr>
<tr><td><code id="getBands_+3A_col">col</code></td>
<td>
<p>color of the median line and 95% bands, usual color codes could be used</p>
</td></tr>
<tr><td><code id="getBands_+3A_lwd">lwd</code></td>
<td>
<p>line width for the median line</p>
</td></tr>
<tr><td><code id="getBands_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether plots are to be drawn, default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="getBands_+3A_add">add</code></td>
<td>
<p>logical indicating whether plot is to be added to existing plot, default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="getBands_+3A_x">x</code></td>
<td>
<p>indexing the parameter coordinates. When <code>b</code> represents a (discretized) function, <code>x</code> can be taken as the function argument values. Needed when plot is to be created. Default sets it to a uniform grid of points over [0,1].</p>
</td></tr>
<tr><td><code id="getBands_+3A_remove.edges">remove.edges</code></td>
<td>
<p>logical indicating whether the first and last entries of <code>b</code> are to be removed from plotting. This is helpful in qrjoint plots, where the two extremes could be <code>Inf</code> or nearly <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="getBands_+3A_...">...</code></td>
<td>
<p>limited number of plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns median, 2.5th and 97.5th percentiles as a 3-column matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.qrjoint">coef.qrjoint</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## toy example

x &lt;- 2*pi*seq(0,1,.01)
fsamp &lt;- replicate(100, rnorm(1,0,0.1) + rnorm(1,1,0.2) * cos(x))
getBands(fsamp)
getBands(fsamp, x = x, col = 3, remove.edges = FALSE, xlab = "x", ylab = "f", bty = "n")
getBands(fsamp, x = x, col = "darkgreen", remove.edges = FALSE, xlab = "x", ylab = "f")
</code></pre>

<hr>
<h2 id='plasma'>
Plasma Concentration of Beta-Carotene and Retinol</h2><span id='topic+plasma'></span>

<h3>Description</h3>

<p>Plasma concentration levels of beta-carotene and retinol along with dietary intake and drug usage measurements for 315 patients who had an elective surgical procedure during a three-year period to biopsy or remove a lesion of the lung, colon, breast, skin, ovary or uterus that was found to be non-cancerous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(plasma)</code></pre>


<h3>Format</h3>

<p>A data frame with 315 observations on the following 14 variables.
</p>

<dl>
<dt><code>Age</code></dt><dd><p>age (years)</p>
</dd>
<dt><code>Sex</code></dt><dd><p>sex (<code>1</code>=Male, <code>2</code>=Female)</p>
</dd>
<dt><code>SmokStat</code></dt><dd><p>smoking status (<code>1</code>=Never, <code>2</code>=Former, <code>3</code>=Current)</p>
</dd>
<dt><code>Quetelet</code></dt><dd><p>Quetlet index, aka, BMI (weight / height^2)</p>
</dd>
<dt><code>VitUse</code></dt><dd><p>vitamin use (<code>0</code>=No, <code>1</code>=Yes, not often, <code>2</code>=Yes, fairly often)</p>
</dd>
<dt><code>Calories</code></dt><dd><p>number of calories consumed per day</p>
</dd>
<dt><code>Fat</code></dt><dd><p>grams of fat consumed per day</p>
</dd>
<dt><code>Fiber</code></dt><dd><p>grams of fiber consumed per day</p>
</dd>
<dt><code>Alcohol</code></dt><dd><p>number of alcoholic drinks consumed per week</p>
</dd>
<dt><code>Cholesterol</code></dt><dd><p>cholesterol consumed (mg per day)</p>
</dd>
<dt><code>BetaDiet</code></dt><dd><p>dietary beta-carotene consumed (mcg per day)</p>
</dd>
<dt><code>RetDiet</code></dt><dd><p>dietary retinol consumed (mcg per day) </p>
</dd>
<dt><code>BetaPlasma</code></dt><dd><p>plasma beta-carotene concentration (ng/ml)</p>
</dd>
<dt><code>RetPlasma</code></dt><dd><p>plasma retinol concentration (ng/ml)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Dietary intakes are self-reported. Results from analyzing this data should be used with caution!
</p>


<h3>Source</h3>

<p>Statlib database</p>


<h3>References</h3>

<p>Nierenberg, D. W., T. A. Stukel, J. A. Baron, B. J. Dain, and E. R. Greenberg (1989). Determinants of plasma levels of beta-carotene and retinol. <em>American Journal of Epidemiology</em>, 130(3), 511&ndash;521.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(plasma)
</code></pre>

<hr>
<h2 id='predict.qde'>Posterior predictive summary for quantile-based density estimation</h2><span id='topic+predict.qde'></span>

<h3>Description</h3>

<p>Extract posterior predictive density estimate for <code><a href="#topic+qde">qde</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'qde'
predict(object, burn.perc = 0.5, nmc = 200, yRange = range(object$y), yLength = 401, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.qde_+3A_object">object</code></td>
<td>
<p>a fitted model of the class 'qde'.</p>
</td></tr>
<tr><td><code id="predict.qde_+3A_burn.perc">burn.perc</code></td>
<td>
<p>a positive fraction indicating what fraction of the saved draws are to be discarded as burn-in</p>
</td></tr>
<tr><td><code id="predict.qde_+3A_nmc">nmc</code></td>
<td>
<p>integer giving the number of samples, post burn-in, to be used in Monte Carlo averaging</p>
</td></tr>
<tr><td><code id="predict.qde_+3A_yrange">yRange</code></td>
<td>
<p>range of values over which posterior predictive density is to be evaluated</p>
</td></tr>
<tr><td><code id="predict.qde_+3A_ylength">yLength</code></td>
<td>
<p>number of grid points spanning yRange for posterior predictive density evaluation</p>
</td></tr>
<tr><td><code id="predict.qde_+3A_...">...</code></td>
<td>
<p>currently no additional arguments are allowed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with three items:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>vector giving the grid over which the posterior predictive density is evaluated.</p>
</td></tr>
<tr><td><code>fsamp</code></td>
<td>
<p>a matrix with <code>yLength</code> many rows and <code>nmc</code> many columns. Each column corresponds to a draw of the response density from the posterior predictive.</p>
</td></tr>
<tr><td><code>fest</code></td>
<td>
<p>summary of the posterior predictive density given by point-wise median, 2.5th and 97.5th percentiles.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+qde">qde</a></code> and <code><a href="#topic+summary.qde">summary.qde</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Plasma data analysis

data(plasma)
Y &lt;- plasma$BetaPlasma
Y &lt;- Y + 0.1 * rnorm(length(Y)) ## remove atomicity

# model fitting with 50 posterior samples from 100 iterations (thin = 2)
fit.qde &lt;- qde(Y, 50, 2)
pred &lt;- predict(fit.qde)
hist(Y, freq = FALSE, col = "gray", border = "white", ylim = c(0, max(pred$fest)))
matplot(pred$y, pred$fest, type="l", col=1, lty=c(2,1,2), ylab="Density", xlab="y")
</code></pre>

<hr>
<h2 id='predict.qrjoint'>Posterior predictive summary for quantile estimation</h2><span id='topic+predict.qrjoint'></span>

<h3>Description</h3>

<p>Extract quantile functions for <code><a href="#topic+qrjoint">qrjoint</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'qrjoint'
predict(object, newdata=NULL, summarize=TRUE, burn.perc = 0.5, nmc = 200, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.qrjoint_+3A_object">object</code></td>
<td>
<p>a fitted model of the class 'qrjoint'.</p>
</td></tr>
<tr><td><code id="predict.qrjoint_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame containing variables on which to predict. If omitted, the fitted data are used.</p>
</td></tr>
<tr><td><code id="predict.qrjoint_+3A_summarize">summarize</code></td>
<td>
<p>a logical indicating whether the quantile functions should be summarized across posterior draws into a single estimate (TRUE) or be left as individual samples (FALSE)</p>
</td></tr>
<tr><td><code id="predict.qrjoint_+3A_burn.perc">burn.perc</code></td>
<td>
<p>a positive fraction indicating what fraction of the saved draws are to be discarded as burn-in</p>
</td></tr>
<tr><td><code id="predict.qrjoint_+3A_nmc">nmc</code></td>
<td>
<p>integer giving the number of samples, post burn-in, to be used in Monte Carlo averaging</p>
</td></tr>
<tr><td><code id="predict.qrjoint_+3A_...">...</code></td>
<td>
<p>currently no additional arguments are allowed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either returns a matrix of posterior quantile-function estimates if <code>summarize=TRUE</code>. Dimensions are <code>n</code> (number of rows in predicted data) x <code>L</code> (length of regularized tau.grid); or a three dimensional array of posterior quantile-function samples if <code>summarize=FALSE</code>. Dimensions are <code>n</code> (number of rows in predicted data) x <code>L</code> (length of regularized tau.grid)  x <code>nmc</code> (retained posterior draws).
</p>


<h3>Note</h3>

<p>When supplying <code>newdata</code>, new covariate values should lie within the convex hull of the original fit's covariate space; otherwise, it is possible that extrapolated quantile functions will not obey the quantile monotonicity constraint. For information on expanding the convex hull of the original fit see Detail section of <code><a href="#topic+qrjoint">qrjoint</a></code>.
</p>
<p>Additional functionality is planned in future release to provide density function estimates given a set of input covariates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qrjoint">qrjoint</a></code> and <code><a href="#topic+summary.qrjoint">summary.qrjoint</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Plasma data analysis

# recoding variables
data(plasma)
plasma$Sex &lt;- as.factor(plasma$Sex)
plasma$SmokStat &lt;- as.factor(plasma$SmokStat)
plasma$VitUse &lt;- 3 - plasma$VitUse
plasma$VitUse &lt;- as.factor(plasma$VitUse)

# Model fitting with 40 posterior samples from 80 iterations (thin = 2) is for
# illustration only. For practical model fitting, increase iterations, 
# e.g. nsamp = 500, thin = 20
## Not run: 
fit.qrj &lt;- qrjoint(BetaPlasma ~ Age + Sex + SmokStat + Quetelet + VitUse + Calories + 
        Fat + Fiber + Alcohol + Cholesterol + BetaDiet, plasma, nsamp = 40, thin = 2)

quants &lt;- predict(fit.qrj)
matplot(fit.qrj$tau.g[fit.qrj$reg.ix], t(quants), type="l", xlab="p",
ylab="Quantile Function", col="lightgray", lty=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='qde'>Quantiles based Density Estimation</h2><span id='topic+qde'></span><span id='topic+update.qde'></span>

<h3>Description</h3>

<p>Provides a semiparametric estimation of the quantiles for independented univariate data with possible right censoring. This is same as estimating the intercept function within a joint linear quantile regression model with no predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qde(y, nsamp = 1e3, thin = 10, cens = NULL,
    wt = NULL, incr = 0.01, par = "prior", nknots = 6,
    hyper = list(sig = c(.1,.1), lam = c(6,4), kap = c(0.1,0.1,1)),
    prox.range = c(.2,.95), acpt.target = 0.15, ref.size = 3,
    blocking = "single", temp = 1, expo = 2, blocks.mu, blocks.S,
    fix.nu = FALSE, fbase = c("t", "logistic", "unif"), verbose = TRUE)

## S3 method for class 'qde'
update(object, nadd, append = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qde_+3A_y">y</code></td>
<td>
<p>numeric vector of response data.</p>
</td></tr>
<tr><td><code id="qde_+3A_nsamp">nsamp</code></td>
<td>
<p>number of posterior samples to be saved; defaults to 1000.</p>
</td></tr>
<tr><td><code id="qde_+3A_thin">thin</code></td>
<td>
<p>thinning rate for the Markov chain sampler &ndash; one posterior sample is saved per <code>thin</code> iterations. Defaults to 10. The Markov chain sampler runs for a total of <code>nsamp * thin</code> many iterations.</p>
</td></tr>
<tr><td><code id="qde_+3A_cens">cens</code></td>
<td>
<p>censoring status of response. Must be a vector of length length(y), with 0 indicating no censoring, 1 indicating right censoring, and 2 indicating left censoring. If not supplied, defaults to all zeros.</p>
</td></tr>
<tr><td><code id="qde_+3A_wt">wt</code></td>
<td>
<p>weights attached to the observation units, expected to be non-negative numbers, and defaults to a vector of ones if not otherwise supplied.</p>
</td></tr>
<tr><td><code id="qde_+3A_incr">incr</code></td>
<td>
<p>tau grid increment. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="qde_+3A_par">par</code></td>
<td>
<p>character string indicating how the sampler is to be initialized. Only two options are currently supported: &quot;prior&quot; to initialize at a random draw from the prior; &quot;RQ&quot; to initialize at a model space approximation of the estimates from <code><a href="quantreg.html#topic+rq">rq</a></code>.</p>
</td></tr>
<tr><td><code id="qde_+3A_nknots">nknots</code></td>
<td>
<p>number of knots to be used for low rank approximation of the Gaussian process priors. Defaults to 6.</p>
</td></tr>
<tr><td><code id="qde_+3A_hyper">hyper</code></td>
<td>
<p>hyperparameters of the prior distribution. Must be a list with some of all of the following fields: <code>sig</code>: a two vector giving the parameters of the inverse-gamma distribution on sigma-square that is used when <code>shrink</code>=TRUE, <code>lam</code>: a two vector giving the parameters of the beta distribution on proximity = <code class="reqn">\exp(-0.01* \lambda^2)</code>, and <code>kap</code>:  a vector to be coerced into a <code>3 * nkap</code> matrix, with <code>nkap</code> being the number of components in the mixture of gamma prior on <code>kappa</code>, and each column of the matrix gives the shape, rate and mixing weight of a component.</p>
</td></tr>
<tr><td><code id="qde_+3A_prox.range">prox.range</code></td>
<td>
<p>for specifying the range of length-scale parameter of the Gaussian process prior.</p>
</td></tr>
<tr><td><code id="qde_+3A_acpt.target">acpt.target</code></td>
<td>
<p>target acceptance rate of the adaptive Metropolis sampler; defaults to 0.15</p>
</td></tr>
<tr><td><code id="qde_+3A_ref.size">ref.size</code></td>
<td>
<p>adaptation rate of the adaptive Metropolis sampler. The proposal density is updated once every <code>ref.size</code> iterations. Could be a single number or a vector of length same as the number of blocks.</p>
</td></tr>
<tr><td><code id="qde_+3A_blocking">blocking</code></td>
<td>
<p>type of blocking to be applied. Either a character string specifying one to be chosen from the supplied menu (see Details), or a list giving user specified blocks. In the latter case, each element of the list is a logical vector of length equal to the total number of model parameters, which equals <code>nknots+3</code> indicating which model parameters belong to the block.</p>
</td></tr>
<tr><td><code id="qde_+3A_temp">temp</code></td>
<td>
<p>temperature of the log-likelihood function. The log-likelihood function is raised to the power of <code>temp</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="qde_+3A_expo">expo</code></td>
<td>
<p>the exponent to be used in the covariance kernel of the Gaussian process priors. Defaults to 2, giving the standard squared-exponential covariance kernel.</p>
</td></tr>
<tr><td><code id="qde_+3A_blocks.mu">blocks.mu</code></td>
<td>
<p>initial block specific means in the form of  a list. If left unspecified then will be automatically generated as a list of vectors of zeros of appropriate lengths matching the corresponding block sizes.</p>
</td></tr>
<tr><td><code id="qde_+3A_blocks.s">blocks.S</code></td>
<td>
<p>initial block specific covariance matrices in the form of a list. If left unspecified then will be automatically generated as a list of identity matrices of appropriate dimensions matching the corresponding block sizes. When <code>blocking</code> is chosen as one of the menu items of the form &quot;std*&quot;, known prior covariance information and estimated variance matrices from <code><a href="quantreg.html#topic+rq">rq</a></code> are used.</p>
</td></tr>
<tr><td><code id="qde_+3A_fix.nu">fix.nu</code></td>
<td>
<p>either the logical FALSE indicating that nu should be learned, or a positive real number giving the fixed value of nu, which is then excluded from MCMC updates</p>
</td></tr>
<tr><td><code id="qde_+3A_fbase">fbase</code></td>
<td>
<p>either &quot;t&quot; (default), &quot;logistic&quot; or &quot;unif&quot; to indicate what base distribution is to be used.</p>
</td></tr>
<tr><td><code id="qde_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether MCMC progress should be printed, defaults to TRUE</p>
</td></tr>
<tr><td><code id="qde_+3A_object">object</code></td>
<td>
<p>a fitted model of the class 'qde'.</p>
</td></tr>
<tr><td><code id="qde_+3A_nadd">nadd</code></td>
<td>
<p>number of additional MCMC samples.</p>
</td></tr>
<tr><td><code id="qde_+3A_append">append</code></td>
<td>
<p>logical indicating whether new samples should be appended to old ones. If FALSE then old samples are discarded.</p>
</td></tr>
<tr><td><code id="qde_+3A_...">...</code></td>
<td>
<p>no additional arguments are allowed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model assumes the quantile function of the data is given by: <code>Q(t) = gamma_0 + sigma * (Qb(zeta(t)|nu) - Qb(zeta(0,5)|nu))</code>, <code>Qb(.|nu)</code> is a parametric quantile function with unknown parameter <code>nu</code>, <code>gamma_0</code> is the unknown median, <code>sigma</code> is an unknown saling factor, and, <code>zeta</code> is an unknown distortion of the unit interval. The distortion <code>zeta</code> is modeled nonparametrically through a logistic Gaussian process prior, other parameters are given diffuse priors.
</p>
<p>In running the MCMC, the following menu choices are available for blocking the parameter vector. For this special case <code>p = ncol(X) = 0</code>, some of the menu choices are actually the same, in particular, &quot;std0&quot; is same as &quot;single&quot;, &quot;std1&quot; is same as &quot;single2&quot;, and, &quot;std2&quot; is same as &quot;single3&quot;.
</p>
<p><code>"single"</code>: a single block containing all parameters
</p>
<p><code>"single2"</code>: one block containing all parameters and an additional block containing only (gamma[0], gamma, sigma, nu)
</p>
<p><code>"single3"</code>: like <code>"single2"</code>, but the second block is split into two further blocks, one with <code class="reqn">(\gamma_0, \gamma)</code>, the other with <code class="reqn">(\sigma, \nu)</code>
</p>
<p><code>"std0"</code>: Same as <code>"single"</code>.
</p>
<p><code>"std1"</code>: Same as <code>"single2"</code>.
</p>
<p><code>"std2"</code>: Same as <code>"single3"</code>.
</p>
<p><code>"std3"</code>: total 3 blocks. First block is <code class="reqn">W_{*0}</code>, last two are <code class="reqn">(\gamma_0, \gamma)</code> and <code class="reqn">(\sigma, \nu)</code>
</p>
<p><code>"std4"</code>: total 3 blocks. First block is <code class="reqn">(W_{*0}, \gamma_0)</code>, last two are <code class="reqn">(\gamma_0, \gamma)</code> and <code class="reqn">(\sigma, \nu)</code>
</p>
<p><code>"std5"</code>: total 4 blocks. First three are same as <code>"std4"</code> and one additional block containing all parameters.
</p>


<h3>Value</h3>

<p><code>qde(y, ...)</code> returns a &lsquo;qde&rsquo; class object to be used by <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="base.html#topic+summary">summary</a></code>.
</p>
<p>Returned object is a list containing the following variables.
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>latest draw of the parameter vector</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code>cens</code></td>
<td>
<p>censoring status vector</p>
</td></tr>
<tr><td><code>wt</code></td>
<td>
<p>vector of observation weights</p>
</td></tr>
<tr><td><code>hyper</code></td>
<td>
<p>completed list of hyper-parameters</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>model dimension vector of the form c(n, p, length of tau grid, position of <code class="reqn">\tau_0</code> on the grid, nknots, length of lambda grid, nkap, total number of MCMC iterations, thin, nsamp)</p>
</td></tr>
<tr><td><code>gridmats</code></td>
<td>
<p>details of covariance matrix factors etc, intended for internal use.</p>
</td></tr>
<tr><td><code>tau.g</code></td>
<td>
<p>the tau grid</p>
</td></tr>
<tr><td><code>muV</code></td>
<td>
<p>list of means for parameter blocks</p>
</td></tr>
<tr><td><code>SV</code></td>
<td>
<p>list of covariance matrices for parameter blocks</p>
</td></tr>
<tr><td><code>blocks</code></td>
<td>
<p>list of blocks</p>
</td></tr>
<tr><td><code>blocks.size</code></td>
<td>
<p>vector of block lengths</p>
</td></tr>
<tr><td><code>dmcmcpar</code></td>
<td>
<p>numeric vector containing details of adaptive MCMC runs, equals c(temp, decay rate of adaptation, vector of target acceptance rates for the blocks, vector of increment scales used in adaptation). Intended strictly for internal use.</p>
</td></tr>
<tr><td><code>imcmcpar</code></td>
<td>
<p>numeric vector containing details of adaptive MCMC runs, equals c(number of parameter blocks, ref.size, indicator on whether details are to be printed during MCMC progress, rate of details printing, a vector of counters needed for printing). Intended strictly for internal use.</p>
</td></tr>
<tr><td><code>parsamp</code></td>
<td>
<p>a long vector containing the parameter draws. Could be coerced into a matrix of dim <code>npar * nsamp</code>. Intended primarily for use by <code><a href="base.html#topic+summary">summary</a></code> and <code><a href="stats.html#topic+coef">coef</a></code>.</p>
</td></tr>
<tr><td><code>acptsamp</code></td>
<td>
<p>a long vector containing rates of acceptance statistics for parameter blocks. Could be coerced into a matrix of dim <code>nblocks * nsamp</code>. Not very informative, because thinning times and adaptation times may not be exactly synced.</p>
</td></tr>
<tr><td><code>lpsamp</code></td>
<td>
<p>vector of log posterior values for the saved MCMC draws.</p>
</td></tr>
<tr><td><code>fbase.choice</code></td>
<td>
<p>integer 1 for &quot;t&quot;, 2 for &quot;logistic&quot; and 3 for &quot;unif&quot; base.</p>
</td></tr>
<tr><td><code>prox</code></td>
<td>
<p>vector of proximity (exp(-0.01*lambda^2)) grid values</p>
</td></tr>
<tr><td><code>reg.ix</code></td>
<td>
<p>positions of the regular tau grid on the expanded tail-appended grid</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p>run time of the MCMC</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yang, Y. and Tokdar, S.T., 2017. Joint estimation of quantile planes over arbitrary predictor spaces. Journal of the American Statistical Association, 112(519), pp.1107-1120.</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.qde">summary.qde</a></code>, <code><a href="#topic+coef.qde">coef.qde</a></code> and <code><a href="#topic+predict.qde">predict.qde</a></code>. Also see <code><a href="#topic+qrjoint">qrjoint</a></code> for regression model fitting in presence of covariates.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plasma data analysis

data(plasma)
Y &lt;- plasma$BetaPlasma

# model fitting with 100 posterior samples from 200 iterations (thin = 2)
# this is of course for illustration, for practical model fitting you
# ought to try at least something like nsamp = 500, thin = 20
fit.qde &lt;- qde(Y, nsamp = 100, thin = 2)
summary(fit.qde, more = TRUE)
pred &lt;- predict(fit.qde)
hist(Y, freq = FALSE, col = "gray", border = "white", ylim = c(0, max(pred$fest)))
lines(pred$y, pred$fest[,2])
lines(pred$y, pred$fest[,1], lty = 2)
lines(pred$y, pred$fest[,3], lty = 2)
</code></pre>

<hr>
<h2 id='qrjoint'>Joint Estimation of Linear Quantile Planes</h2><span id='topic+qrjoint'></span><span id='topic+update.qrjoint'></span>

<h3>Description</h3>

<p> Estimate intercept and slope functions within a joint linear regression model of the quantiles, with possible right or left censoring of the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
qrjoint(formula, data, nsamp = 1e3, thin = 10, cens = NULL, 
    wt = NULL, incr = 0.01, par = "prior", nknots = 6,
    hyper = list(sig = c(.1,.1), lam = c(6,4), kap = c(.1,.1,1)), 
    shrink = FALSE, prox.range = c(.2,.95), acpt.target = 0.15, 
    ref.size = 3, blocking = "std5", temp = 1, expo = 2, 
    blocks.mu, blocks.S, fix.nu=FALSE, fbase = c("t", "logistic", "unif"), verbose = TRUE)
    
## S3 method for class 'qrjoint'
update(object, nadd, append = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qrjoint_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted. It must include at least one predictor.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_data">data</code></td>
<td>
<p>a data frame containing variables in the model.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_nsamp">nsamp</code></td>
<td>
<p>number of posterior samples to be saved; defaults to 1000.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_thin">thin</code></td>
<td>
<p>thinning rate for the Markov chain sampler &ndash; one posterior sample is saved per <code>thin</code> iterations. Defaults to 10. The Markov chain sampler runs for a total of <code>nsamp * thin</code> many iterations.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_cens">cens</code></td>
<td>
<p>censoring status of response. Must be a vector of length NROW(data), with 0 indicating no censoring, 1 indicating right censoring, and 2 indicating left censoring. If not supplied, defaults to all zeros.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_wt">wt</code></td>
<td>
<p>weights attached to the observation units, expected to be non-negative numbers, and defaults to a vector of ones if not otherwise supplied.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_incr">incr</code></td>
<td>
<p>tau grid increment. Defaults to 0.01.</p>
</td></tr> 
<tr><td><code id="qrjoint_+3A_par">par</code></td>
<td>
<p>character string indicating how the sampler is to be initialized. Three options are currently supported: &quot;prior&quot; to initialize at a random draw from the prior; &quot;RQ&quot; to initialize at a model space approximation of the estimates from <code><a href="quantreg.html#topic+rq">rq</a></code>; and, &quot;noX&quot; to initialize at a model with all slope functions being equal to zero, and the intercept function obtained by fitting <code>qde</code> to the response data alone.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_nknots">nknots</code></td>
<td>
<p>number of knots to be used for low rank approximation of the Gaussian process priors. Defaults to 6.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_hyper">hyper</code></td>
<td>
<p>hyperparameters of the prior distribution. Must be a list with some of all of the following fields: <code>sig</code>: a two vector giving the parameters of the inverse-gamma distribution on sigma-square that is used when <code>shrink</code>=TRUE, <code>lam</code>: a two vector giving the parameters of the beta distribution on proximity = <code class="reqn">\exp(-0.01* \lambda^2)</code>, and <code>kap</code>: a vector to be coerced into a <code>3 * nkap</code> matrix, with <code>nkap</code> being the number of components in the mixture of gamma prior on <code>kappa</code>, and each column of the matrix gives the shape, rate and mixing weight of a component.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_shrink">shrink</code></td>
<td>
<p>for applying shrinkage to gamma[0] and gamma. Defaults to FALSE, in which case a right Haar prior is used on (gamma[0], gamma, sigma2). If TRUE then a horseshoe type prior is used.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_prox.range">prox.range</code></td>
<td>
<p>for specifying the range of length-scale parameter of the Gaussian process prior.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_acpt.target">acpt.target</code></td>
<td>
<p>target acceptance rate of the adaptive Metropolis sampler; defaults to 0.15</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_ref.size">ref.size</code></td>
<td>
<p>adaptation rate of the adaptive Metropolis sampler. The proposal density is updated once every <code>ref.size</code> iterations. Could be a single number or a vector of length same as the number of blocks.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_blocking">blocking</code></td>
<td>
<p>type of blocking to be applied. Either a character string specifying one to be chosen from the supplied menu (see Details), or a list giving user specified blocks. In the latter case, each element of the list is a logical vector of length equal to the total number of model parameters, which equals <code>(nknots+1)*(ncol(X)+1) + 2</code> indicating which model parameters belong to the block.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_temp">temp</code></td>
<td>
<p>temperature of the log-likelihood function. The log-likelihood function is raised to the power of <code>temp</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_expo">expo</code></td>
<td>
<p>the exponent to be used in the covariance kernel of the Gaussian process priors. Defaults to 2, giving the standard squared-exponential covariance kernel.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_blocks.mu">blocks.mu</code></td>
<td>
<p>initial block specific means in the form of  a list. If left unspecified then will be automatically generated as a list of vectors of zeros of appropriate lengths matching the corresponding block sizes.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_blocks.s">blocks.S</code></td>
<td>
<p>initial block specific covariance matrices in the form of a list. If left unspecified then will be automatically generated as a list of identity matrices of appropriate dimensions matching the corresponding block sizes. When <code>blocking</code> is chosen as one of the menu items of the form &quot;std*&quot;, known prior covariance information and estimated variance matrices from <code><a href="quantreg.html#topic+rq">rq</a></code> are used.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_fix.nu">fix.nu</code></td>
<td>
<p>either the logical FALSE indicating that nu should be learned, or a positive real number giving the fixed value of nu, which is then excluded from MCMC updates</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_fbase">fbase</code></td>
<td>
<p>either &quot;t&quot; (default), &quot;logistic&quot; or &quot;unif&quot; to indicate what base distribution is to be used.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether MCMC progress should be printed, defaults to TRUE</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_object">object</code></td>
<td>
<p>a fitted model of the class 'qrjoint'.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_nadd">nadd</code></td>
<td>
<p>number of additional MCMC samples.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_append">append</code></td>
<td>
<p>logical indicating whether new samples should be appended to old ones. If FALSE then old samples are discarded.</p>
</td></tr>
<tr><td><code id="qrjoint_+3A_...">...</code></td>
<td>
<p>no additional arguments are allowed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A formula has an implied intercept term. This model requires that the intercept term be included; therefore, it cannot be explicitely removed via (y ~ 0 + x) or (y ~ -1 + x) constructs.
</p>
<p>The model assumes each conditional quantile of the response is a hyper-plane. The intercept and slope functions (as functons of the quantile level) are estimated under the constraint that the resulting quantile planes are non-crossing over some closed, convex predictor domain. The domain is equated, by default, to the convex hull of the observed predictor vectors. The input argument <code>wt</code> provides more flexibility in the domain specification. All observation units are used in calculating the convex hull, but only those with non-zero weights are used in the likelihood evaluation. By including pseudo-points with zero weight (e.g. covariates from a test dataframe), the boundaries of the predictor domain can be expanded.
</p>
<p>In running the MCMC, the following menu choices are available for blocking the parameter vector. Below, <code>p = ncol(X)</code>.
</p>
<p><code>"single"</code>: a single block containing all parameters
</p>
<p><code>"single2"</code>: one block containing all parameters and an additional block containing only (gamma[0], gamma, sigma, nu)
</p>
<p><code>"single3"</code>: like <code>"single2"</code>, but the second block is split into two further blocks, one with <code class="reqn">(\gamma_0, \gamma)</code>, the other with <code class="reqn">(\sigma, \nu)</code>
</p>
<p><code>"std0"</code>: <code>p+1</code> blocks, <code class="reqn">(j+1)</code>-th contains <code class="reqn">(W_{*j}, \gamma_j, \sigma, \nu)</code>, <code class="reqn">j= 0,\ldots ,p</code>.
</p>
<p><code>"std1"</code>: total <code>p+2</code> blocks. First <code>p+1</code> blocks same as <code>"std0"</code> and one additional block of <code class="reqn">(\gamma_0, \gamma, \sigma, \nu)</code>.
</p>
<p><code>"std2"</code>: total <code>p+3</code> blocks. First <code>p+1</code> blocks same as <code>"std0"</code> and two additional blocks of <code class="reqn">(\gamma_0, \gamma)</code> and <code class="reqn">(\sigma, \nu)</code>
</p>
<p><code>"std3"</code>: total <code>p+3</code> blocks. First <code>p+1</code> blocks are <code class="reqn">W_{*j}</code>, <code class="reqn">j = 0, \ldots, p</code>, last two are <code class="reqn">(\gamma_0, \gamma)</code> and <code class="reqn">(\sigma, \nu)</code>
</p>
<p><code>"std4"</code>: total <code>p+3</code> blocks. First <code>p+1</code> blocks are <code class="reqn">(W_{*j}, \gamma_j)</code>, <code class="reqn">j = 0, \ldots, p</code>, last two are <code class="reqn">(\gamma_0, \gamma)</code> and <code class="reqn">(\sigma, \nu)</code>
</p>
<p><code>"std5"</code>: total <code>p+4</code> blocks. First <code>p+3</code> are same as <code>"std4"</code> and one additional block containing all parameters.
</p>


<h3>Value</h3>

<p><code>qrjoint(x, y, ...)</code> returns a &lsquo;qrjoint&rsquo; class object to be used by <code><a href="#topic+update.qrjoint">update.qrjoint</a></code>, <code><a href="#topic+coef.qrjoint">coef.qrjoint</a></code> and <code><a href="#topic+summary.qrjoint">summary.qrjoint</a></code>. 
</p>
<p><code>update(object,...)</code> runs additional Markov chain iterations and appends thinned draws to an existing &lsquo;qrjoint&rsquo; object <code>object</code>. All relevant details are inherited from <code>object</code>.
</p>
<p>Returned object is a list containing the following variables.
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>latest draw of the parameter vector</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>scaled and centered design matrix</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>response vector</p>
</td></tr>    
<tr><td><code>cens</code></td>
<td>
<p>censoring status vector, 0=uncensored, 1=right censored, 2=left censored</p>
</td></tr>
<tr><td><code>wt</code></td>
<td>
<p>vector of observation weights</p>
</td></tr>
<tr><td><code>shrink</code></td>
<td>
<p>shrinkage indicator</p>
</td></tr>
<tr><td><code>hyper</code></td>
<td>
<p>completed list of hyper-parameters</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>model dimension vector of the form c(n, p, length of tau grid, position of <code class="reqn">\tau_0</code> on the grid, nknots, length of lambda grid, nkap, total number of MCMC iterations, thin, nsamp)</p>
</td></tr>
<tr><td><code>gridmats</code></td>
<td>
<p>details of covariance matrix factors etc, intended for internal use.</p>
</td></tr>
<tr><td><code>tau.g</code></td>
<td>
<p>the tau grid</p>
</td></tr>
<tr><td><code>muV</code></td>
<td>
<p>list of means for parameter blocks</p>
</td></tr>
<tr><td><code>SV</code></td>
<td>
<p>list of covariance matrices for parameter blocks</p>
</td></tr>
<tr><td><code>blocks</code></td>
<td>
<p>list of blocks</p>
</td></tr>
<tr><td><code>blocks.size</code></td>
<td>
<p>vector of block lengths</p>
</td></tr>
<tr><td><code>dmcmcpar</code></td>
<td>
<p>numeric vector containing details of adaptive MCMC runs, equals c(temp, decay rate of adaptation, vector of target acceptance rates for the blocks, vector of increment scales used in adaptation). Intended strictly for internal use.</p>
</td></tr>
<tr><td><code>imcmcpar</code></td>
<td>
<p>numeric vector containing details of adaptive MCMC runs, equals c(number of parameter blocks, ref.size, indicator on whether details are to be printed during MCMC progress, rate of details printing, a vector of counters needed for printing). Intended strictly for internal use.</p>
</td></tr>
<tr><td><code>parsamp</code></td>
<td>
<p>a long vector containing the parameter draws. Could be coerced into a matrix of dim <code>npar * nsamp</code>. Intended primarily for use by <code><a href="#topic+summary.qrjoint">summary.qrjoint</a></code> and <code><a href="#topic+coef.qrjoint">coef.qrjoint</a></code>.</p>
</td></tr>
<tr><td><code>acptsamp</code></td>
<td>
<p>a long vector containing rates of acceptance statistics for parameter blocks. Could be coerced into a matrix of dim <code>nblocks * nsamp</code>. Not very informative, because thinning times and adaptation times may not be exactly synced.</p>
</td></tr>
<tr><td><code>lpsamp</code></td>
<td>
<p>vector of log posterior values for the saved MCMC draws.</p>
</td></tr>
<tr><td><code>fbase.choice</code></td>
<td>
<p>integer 1 for &quot;t&quot;, 2 for &quot;logistic&quot; and 3 &quot;unif&quot; base.</p>
</td></tr>
<tr><td><code>prox</code></td>
<td>
<p>vector of proximity (exp(-0.01*lambda^2)) grid values</p>
</td></tr>
<tr><td><code>reg.ix</code></td>
<td>
<p>positions of the regular tau grid on the expanded tail-appended grid</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p>run time of the MCMC</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>original model call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>terms included in model frame</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yang, Y. and Tokdar, S.T., 2017. Joint estimation of quantile planes over arbitrary predictor spaces. Journal of the American Statistical Association, 112(519), pp.1107-1120.</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.qrjoint">summary.qrjoint</a></code> and <code><a href="#topic+coef.qrjoint">coef.qrjoint</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Plasma data analysis

# recoding variables
data(plasma)
plasma$Sex &lt;- as.factor(plasma$Sex)
plasma$SmokStat &lt;- as.factor(plasma$SmokStat)
plasma$VitUse &lt;- 3 - plasma$VitUse
plasma$VitUse &lt;- as.factor(plasma$VitUse)

# Model fitting with 40 posterior samples from 80 iterations (thin = 2) is for
# illustration only. For practical model fitting, increase iterations, 
# e.g. nsamp = 500, thin = 20
fit.qrj &lt;- qrjoint(BetaPlasma ~ Age + Sex + SmokStat + Quetelet + VitUse + Calories + 
        Fat + Fiber + Alcohol + Cholesterol + BetaDiet, plasma, nsamp = 40, thin = 2)
summary(fit.qrj, more = TRUE)

## Not run: 
# additional MCMC runs to get 10 more samples (20 additional iterations)
fit.qrj &lt;- update(fit.qrj, 10)
summary(fit.qrj, more = TRUE)

## End(Not run)

## Not run: 
### UIS data analysis (with right censoring)
data(uis)
uis.qrj &lt;- qrjoint(Y ~ TREAT + NDT + IV3 + BECK + FRAC + 
                       RACE + AGE + SITE , data=uis, cens = (1 - uis$CENSOR), 
                     nsamp = 50, thin = 2, fix.nu = 1e5)
summary(uis.qrj, more = TRUE)

betas &lt;- coef(uis.qrj, plot = TRUE, col = "darkgreen")
tau.grid &lt;- uis.qrj$tau.g[uis.qrj$reg.ix]
L &lt;- length(tau.grid)
beta.samp &lt;- betas$beta.samp

# survival curve estimation for k randomly chosen subjects
n &lt;- nrow(uis)
k &lt;- 9
ix.sel &lt;- sort(sample(n, k))
Qsel.gp &lt;- predict(uis.qrj, newdata=uis[ix.sel,], summarize=FALSE)
  
colRGB &lt;- col2rgb("darkgreen")/255
colTrans &lt;- rgb(colRGB[1], colRGB[2], colRGB[3], alpha = 0.05)
par(mfrow = c(3,3), mar = c(4,3,2,1) + .1)
for(i in 1:k){
  plot(exp(apply(Qsel.gp[i,,],1,mean)), 1 - tau.grid, ty = "n", ann = FALSE, 
        bty = "n", xlim = exp(c(2, 8)), ylim = c(0,1), lty = 2, log = "x")
  for(j in 1:dim(beta.samp)[3])
      lines(exp(Qsel.gp[i,,j]), 1 - tau.grid, col = colTrans, lwd = 1)
  title(xlab = "Return time (days)", ylab = "Survival function", line = 2)
  title(main = bquote(Obs.Id == .(ix.sel[i])))
  grid()  
}

## End(Not run)
</code></pre>

<hr>
<h2 id='qrjoint-internal'>Internal qrjoint Functions</h2><span id='topic+estFn'></span><span id='topic+ppFn0'></span><span id='topic+ppFn'></span><span id='topic+lamFn'></span><span id='topic+nuFn'></span><span id='topic+nuFn.inv'></span><span id='topic+sigFn'></span><span id='topic+sigFn.inv'></span><span id='topic+unitFn'></span><span id='topic+q0'></span><span id='topic+Q0'></span><span id='topic+F0'></span><span id='topic+sum.sq'></span><span id='topic+extract'></span><span id='topic+logmean'></span><span id='topic+logsum'></span><span id='topic+shrinkFn'></span><span id='topic+trape'></span><span id='topic+klGP'></span><span id='topic+proxFn'></span>

<h3>Description</h3>

<p>These functions are repeatedly used by the main functions of the package &quot;qrjoint&quot;. Not intended for direct use the by user.</p>

<hr>
<h2 id='redmaple'>Basal Areas of Red Maple Trees</h2><span id='topic+redmaple'></span>

<h3>Description</h3>

<p>Site-level basal areas of red maple trees (<em>Acer rubrum</em>) at 608 unmanaged and forested sites in Connecticut, Massachusetts, and Rhode Island. Data are aggregated from the Forest Inventory Analysis (FIA) of the US Forest Service. Geographical regions of the sites are added using Enviromental Protection Agency (EPA) shapefiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(redmaple)</code></pre>


<h3>Format</h3>

<p>A data frame with 608 observations on the following variables for each site:
</p>

<dl>
<dt><code>plotID</code></dt><dd><p>Unique identifier</p>
</dd>
<dt><code>elev</code></dt><dd><p>Elevation, measured in feet</p>
</dd>
<dt><code>slope</code></dt><dd><p>Slope, measured in degrees</p>
</dd>
<dt><code>aspect</code></dt><dd><p>Aspect, measured in degrees proceeding from North clockwise around a compass. For sites with zero or near-zero slopes, aspect is recorded as 0. North is recorded as 360.</p>
</dd>
<dt><code>Region</code></dt><dd><p>EPA Level-III geographical region</p>
</dd>
<dt><code>region</code></dt><dd><p>EPA Level-III geographical region, shortened</p>
</dd>
<dt><code>State</code></dt><dd><p>State</p>
</dd>
<dt><code>baRedMaple</code></dt><dd><p>Total basal area of red maple trees, measured in square feet per acre</p>
</dd>
</dl>



<h3>Details</h3>

<p>This three-state subset from the FIA is intended to illustrate the capabilities of the qrjoint package in flexibly modeling excess-boundary zeros, using its censoring option. This subset of variables should not be construed as a comprehensive list of factors influencing red maple basal area growth. All sites in the sample are of equivalent area.
</p>


<h3>Source</h3>

<p>Forest Inventory and Analysis Database, St. Paul, MN: U.S. Department of Agriculture, Forest Service, Northern Research Station. <a href="https://apps.fs.usda.gov/fia/datamart/datamart.html">https://apps.fs.usda.gov/fia/datamart/datamart.html</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(redmaple)
</code></pre>

<hr>
<h2 id='summary.qde'>Summary Method for Quantile based Density Estimation</h2><span id='topic+summary.qde'></span>

<h3>Description</h3>

<p>Summarize model fit for <code><a href="#topic+qde">qde</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'qde'
summary(object, ntrace = 1000, burn.perc = 0.5, 
        plot.dev = TRUE, more.details = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.qde_+3A_object">object</code></td>
<td>
<p>a fitted model of the class 'qde'.</p>
</td></tr>
<tr><td><code id="summary.qde_+3A_ntrace">ntrace</code></td>
<td>
<p>number of draws to be included in trace plots</p>
</td></tr>
<tr><td><code id="summary.qde_+3A_burn.perc">burn.perc</code></td>
<td>
<p>fraction of MCMC draws to be discarded as burn-in.</p>
</td></tr>
<tr><td><code id="summary.qde_+3A_plot.dev">plot.dev</code></td>
<td>
<p>logical indicator of whether to show trace plot of deviance</p>
</td></tr>
<tr><td><code id="summary.qde_+3A_more.details">more.details</code></td>
<td>
<p>logical indicating whether other details from MCMC are to be plotted</p>
</td></tr>
<tr><td><code id="summary.qde_+3A_...">...</code></td>
<td>
<p>a limited number of plotting controls that are passed onto the deviance plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays the trace of the deviance statistic. More details include trace plots of of the proximity parameter of each GP, a plot of Geweke p-values for (from <code>geweke.diag</code>) convergence of each model parameter and an image plot of parameter correlation. Also prints two versions of Watanabe AIC.
</p>
<p>The following quantities are returned invisibly.
</p>
<table>
<tr><td><code>deviance</code></td>
<td>
<p>vector deviance statistic of the samples parameter draws</p>
</td></tr> 
<tr><td><code>pg</code></td>
<td>
<p>a matrix with <code>nsamp</code> number of columns, each columns could be coerced into a matrix of dimension <code>ngrid * (p+1)</code>, where the columns gives the conditional posterior weights on the lambda grid values for the corresponding GP function.</p>
</td></tr>       
<tr><td><code>prox</code></td>
<td>
<p>posterior draws of proximity in the form of a <code>(p+1)*nsamp</code> matrix.</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>a matrix of <code>n*nsamp</code> containing observation-level log-likelihood contributions. Used to calculate <var>waic</var>, and could be used for other AIC calculations.</p>
</td></tr>
<tr><td><code>ql</code></td>
<td>
<p>a matrix of <code>n*nsamp</code> containing observation-level estimated quantile levels.</p>
</td></tr>
<tr><td><code>waic</code></td>
<td>
<p>Two versions of Watanabe AIC from Gelman, Hwang and Vehtari (2014).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gelman, A., Hwang, J., and Vehtari, A. (2014). Understanding predictive information criterion for Bayesian models. <em>Stat Comput</em>, 24, 997-1016.</p>


<h3>See Also</h3>

<p><code><a href="#topic+qrjoint">qrjoint</a></code> and <code><a href="#topic+coef.qrjoint">coef.qrjoint</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Plasma data analysis

data(plasma)
Y &lt;- plasma$BetaPlasma
Y &lt;- Y + 0.1 * rnorm(length(Y)) ## remove atomicity

# model fitting with 50 posterior samples from 100 iterations (thin = 2)
fit.qde &lt;- qde(Y, 50, 2)
summary(fit.qde, more = TRUE)
</code></pre>

<hr>
<h2 id='summary.qrjoint'>Summary Method for qrjoint Model Fit</h2><span id='topic+summary.qrjoint'></span>

<h3>Description</h3>

<p>Summarize model fit, including MCMC details, for <code><a href="#topic+qrjoint">qrjoint</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'qrjoint'
summary(object, ntrace = 1000, burn.perc = 0.5,
        plot.dev = TRUE, more.details = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.qrjoint_+3A_object">object</code></td>
<td>
<p>a fitted model of the class 'qrjoint'.</p>
</td></tr>
<tr><td><code id="summary.qrjoint_+3A_ntrace">ntrace</code></td>
<td>
<p>number of draws to be included in trace plots</p>
</td></tr>
<tr><td><code id="summary.qrjoint_+3A_burn.perc">burn.perc</code></td>
<td>
<p>fraction of MCMC draws to be discarded as burn-in.</p>
</td></tr>
<tr><td><code id="summary.qrjoint_+3A_plot.dev">plot.dev</code></td>
<td>
<p>logical indicator of whether to show trace plot of deviance</p>
</td></tr>
<tr><td><code id="summary.qrjoint_+3A_more.details">more.details</code></td>
<td>
<p>logical indicating whether other details from MCMC are to be plotted</p>
</td></tr>
<tr><td><code id="summary.qrjoint_+3A_...">...</code></td>
<td>
<p>a limited number of plotting controls that are passed onto the deviance plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays the trace of the deviance statistic. More details include trace plots of of the proximity parameter of each GP, a plot of Geweke p-values for (from <code>geweke.diag</code>) convergence of each model parameter and an image plot of parameter correlation. Also prints two versions of Watanabe AIC.
</p>
<p>The following quantities are returned invisibly.
</p>
<table>
<tr><td><code>deviance</code></td>
<td>
<p>vector deviance statistic of the samples parameter draws</p>
</td></tr> 
<tr><td><code>pg</code></td>
<td>
<p>a matrix with <code>nsamp</code> number of columns, each columns could be coerced into a matrix of dimension <code>ngrid * (p+1)</code>, where the columns gives the conditional posterior weights on the lambda grid values for the corresponding GP function.</p>
</td></tr>       
<tr><td><code>prox</code></td>
<td>
<p>posterior draws of proximity in the form of a <code>(p+1)*nsamp</code> matrix.</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>a matrix of <code>n*nsamp</code> containing observation-level log-likelihood contributions. Used to calculate <var>waic</var>, and could be used for other AIC calculations.</p>
</td></tr>
<tr><td><code>ql</code></td>
<td>
<p>a matrix of <code>n*nsamp</code> containing observation-level estimated quantile levels (i.e. t such that <code class="reqn">y = Q(t|x)</code>) at each posterior draw. These may be used in lieu of residuals to assess model fit and assumption of linearity.</p>
</td></tr>
<tr><td><code>waic</code></td>
<td>
<p>Two versions of Watanabe AIC from Gelman, Hwang and Vehtari (2014).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gelman, A., Hwang, J., and Vehtari, A. (2014). Understanding predictive information criterion for Bayesian models. <em>Stat Comput</em>, 24, 997-1016.</p>


<h3>See Also</h3>

<p><code><a href="#topic+qrjoint">qrjoint</a></code> and <code><a href="#topic+coef.qrjoint">coef.qrjoint</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Plasma data analysis

# recoding variables
data(plasma)
plasma$Sex &lt;- as.factor(plasma$Sex)
plasma$SmokStat &lt;- as.factor(plasma$SmokStat)
plasma$VitUse &lt;- 3 - plasma$VitUse
plasma$VitUse &lt;- as.factor(plasma$VitUse)

# Model fitting with 40 posterior samples from 80 iterations (thin = 2) is for
# illustration only. For practical model fitting, increase iterations, 
# e.g. nsamp = 500, thin = 20
fit.qrj &lt;- qrjoint(BetaPlasma ~ Age + Sex + SmokStat + Quetelet + VitUse + Calories + 
        Fat + Fiber + Alcohol + Cholesterol + BetaDiet, plasma, nsamp = 40, thin = 2)
summ &lt;- summary(fit.qrj, more = TRUE)

## Not run: 
# Visually assess uniformity of quantile levels with histogram and qqplot
# Notes: Can assess across all MCMC draws (as below) or for single iteration;
# adjustments to quantile levels will be needed for censored observations
hist(summ$ql, breaks=40, freq=F)
curve(dunif(x),add=T)
qqplot(summ$ql, qunif(ppoints(length(summ$ql))),xlab="actual", ylab="theoretical")
abline(0,1)

# Visually assess linearity assumption using quantile levels
# Notes: Can assess across all MCMC draws or for single iteration (as below)

# Loess gives visual of center of quantile levels across covariate;
# trend line should be near 0.5
library(ggplot2)
use &lt;- sample(1:ncol(summ$ql),1)
plasma$qlsamp &lt;- summ$ql[,use]
ggplot(data=plasma, aes(x=Age, y=qlsamp)) + geom_point() + geom_smooth(se=F,
method="loess")

# Violin plot allows for assessment of entire distribution across covariate;
# densities within decile bins should be blocky-uniform 
cut_dec &lt;- function(x) factor(cut(x, quantile(x,0:10/10),inc=TRUE),labels=1:10)
ggplot(data=plasma, aes(x=cut_dec(Age), y=qlsamp)) + geom_violin() +
xlab("Age Decile Bins")

## End(Not run)

</code></pre>

<hr>
<h2 id='waic'>Watanabe Information Criterion</h2><span id='topic+waic'></span>

<h3>Description</h3>

<p>Calculates two versions of the Watanabe information criteria from MCMC draws.</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
waic(logliks, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waic_+3A_logliks">logliks</code></td>
<td>
<p>a matrix of observation level log-likelihood values, the columns are MCMC iterations and the rows are observations in the data</p>
</td></tr>
<tr><td><code id="waic_+3A_print">print</code></td>
<td>
<p>logical whether to print the results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the two version of the WAIC
</p>


<h3>References</h3>

<p>Gelman, A., Hwang, J., and Vehtari, A. (2014). Understanding predictive information criterion for Bayesian models. <em>Stat Comput</em>, 24, 997-1016.</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.qrjoint">summary.qrjoint</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Plasma data analysis

# recoding variables
data(plasma)
plasma$Sex &lt;- as.factor(plasma$Sex)
plasma$SmokStat &lt;- as.factor(plasma$SmokStat)
plasma$VitUse &lt;- 3 - plasma$VitUse
plasma$VitUse &lt;- as.factor(plasma$VitUse)

# Model fitting with 40 posterior samples from 80 iterations (thin = 2) is for
# illustration only. For practical model fitting, increase iterations, 
# e.g. nsamp = 500, thin = 20
fit.qrj &lt;- qrjoint(BetaPlasma ~ Age + Sex + SmokStat + Quetelet + VitUse + Calories + 
        Fat + Fiber + Alcohol + Cholesterol + BetaDiet, plasma, nsamp = 40, thin = 2)
summary(fit.qrj, more = TRUE)

# the call to summary already shows the waic for the fitted model, it also returns 
# the observation level log-likelihood vales. To calculate waic from last 20 draws 
# we can use:

## Not run: 
summary(fit.qrj, more = TRUE)
ll &lt;- sm$ll
waic(ll[,21:40])

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
