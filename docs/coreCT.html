<!DOCTYPE html><html><head><title>Help for package coreCT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coreCT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#conv'><p>Convert a matrix of semi-processed DICOM images to mass and volume of material classes. This is a deprecated version.</p></a></li>
<li><a href='#convDir'><p>Convert a directory of raw DICOM images to material classes</p></a></li>
<li><a href='#convert'><p>Convert a matrix of semi-processed DICOM images to mass and volume of material classes</p></a></li>
<li><a href='#convertDir'><p>Convert a directory of raw DICOM images to material classes</p></a></li>
<li><a href='#core_426'><p>Three computed tomography scans from a Spartina alterniflora core</p></a></li>
<li><a href='#coreHist'><p>Whole-core frequency distribution of Hounsfield units</p></a></li>
<li><a href='#getRoots'><p>Convert a matrix of semi-processed DICOM images to root particle counts, volumes, and surface areas</p></a></li>
<li><a href='#getRootsDir'><p>Convert a directory of raw DICOM images to  root particle counts and surface areas</p></a></li>
<li><a href='#getSurface'><p>Remove artificial surface layers from processed CT data</p></a></li>
<li><a href='#rootSize'><p>Convert a matrix of semi-processed DICOM images to root particle counts, volumes, and surface areas</p></a></li>
<li><a href='#rootSizeDir'><p>Convert a directory of raw DICOM images to  root particle counts and surface areas</p></a></li>
<li><a href='#voxDims'><p>Extract voxel dimensions from DICOM image</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Programmatic Analysis of Sediment Cores Using Computed
Tomography Imaging</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-02-05</td>
</tr>
<tr>
<td>Description:</td>
<td>Computed tomography (CT) imaging is a powerful tool for understanding the composition of sediment cores. This package streamlines and accelerates the analysis of CT data generated in the context of environmental science. Included are tools for processing raw DICOM images to characterize sediment composition (sand, peat, etc.). Root analyses are also enabled, including measures of external surface area and volumes for user-defined root size classes. For a detailed description of the application of computed tomography imaging for sediment characterization, see: Davey, E., C. Wigand, R. Johnson, K. Sundberg, J. Morris, and C. Roman. (2011) &lt;<a href="https://doi.org/10.1890%2F10-2037.1">doi:10.1890/10-2037.1</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/troyhill/coreCT">https://github.com/troyhill/coreCT</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/troyhill/coreCT/issues">https://github.com/troyhill/coreCT/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), raster, igraph, oro.dicom, plyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-05 14:12:30 UTC; tdh</td>
</tr>
<tr>
<td>Author:</td>
<td>Troy D. Hill <a href="https://orcid.org/0000-0003-2980-4099"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Earl Davey [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Troy D. Hill &lt;Hill.Troy@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-05 15:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='conv'>Convert a matrix of semi-processed DICOM images to mass and volume of material classes. This is a deprecated version.</h2><span id='topic+conv'></span>

<h3>Description</h3>

<p>Converts raw CT units to material classes for each CT slice, directly replicating Earl Davey's manual classification approach. This method is deprecated as of coreCT version 1.3.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv(mat.list, upperLim = 3045, lowerLim = -1025, 
pixelA, thickness = 0.625, # all in mm 
airHU = -850.3233, airSD = 77.6953, 
SiHU = 271.7827, SiSD = 39.2814,
glassHU = 1345.0696, glassSD = 45.4129,
waterHU = 63.912, waterSD = 14.1728,
densities = c(0.0012, 1, 1.23, 2.2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_+3A_mat.list">mat.list</code></td>
<td>
<p>list of DICOM images for a sediment core (values in Hounsfield Units)</p>
</td></tr>
<tr><td><code id="conv_+3A_upperlim">upperLim</code></td>
<td>
<p>upper bound cutoff for pixels (Hounsfield Units)</p>
</td></tr>
<tr><td><code id="conv_+3A_lowerlim">lowerLim</code></td>
<td>
<p>lower bound cutoff for pixels (Hounsfield Units)</p>
</td></tr>
<tr><td><code id="conv_+3A_pixela">pixelA</code></td>
<td>
<p>pixel area (mm2)</p>
</td></tr>
<tr><td><code id="conv_+3A_thickness">thickness</code></td>
<td>
<p>CT image thickness (mm)</p>
</td></tr>
<tr><td><code id="conv_+3A_airhu">airHU</code></td>
<td>
<p>mean value for air-filled calibration rod (Hounsfield Units)</p>
</td></tr>
<tr><td><code id="conv_+3A_airsd">airSD</code></td>
<td>
<p>standard deviation for air-filled calibration rod</p>
</td></tr>
<tr><td><code id="conv_+3A_sihu">SiHU</code></td>
<td>
<p>mean value for colloidal silica calibration rod</p>
</td></tr>
<tr><td><code id="conv_+3A_sisd">SiSD</code></td>
<td>
<p>standard deviation for colloidal Si calibration rod</p>
</td></tr>
<tr><td><code id="conv_+3A_glasshu">glassHU</code></td>
<td>
<p>mean value for glass calibration rod</p>
</td></tr>
<tr><td><code id="conv_+3A_glasssd">glassSD</code></td>
<td>
<p>standard deviation for glass calibration rod</p>
</td></tr>
<tr><td><code id="conv_+3A_waterhu">waterHU</code></td>
<td>
<p>mean value for water filled calibration rod</p>
</td></tr>
<tr><td><code id="conv_+3A_watersd">waterSD</code></td>
<td>
<p>standard deviation for water filled calibration rod</p>
</td></tr>
<tr><td><code id="conv_+3A_densities">densities</code></td>
<td>
<p>numeric vector of known cal rod densities. Format must be c(air, water, Si, glass)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates average Hounsfield units, cross-sectional areas (cm2), volumes (cm3), and masses (g) of material classes for each CT slice. This function assumes that core walls and all non-sediment material have been removed from the raw DICOM imagery. This function converts data from raw x-ray attenuation values to Hounsfield Units, and then uses user-defined calibration rod inputs to categorize sediment components: air, roots and rhizomes, peat, water, particulates, sand, and rock/shell.
</p>


<h3>Value</h3>

<p>value <code>conv</code> returns a dataframe with one row per CT slice. Values returned are the average Hounsfield Unit value, the area (cm2), volume (cm3), and mass (grams) of 7 material classes: gas, peat, roots and rhizomes, particulates, sand, water, and rock/shell. If &lt;code&gt;rootData = TRUE&lt;/code&gt;, data for specified root size classes are also returned. See &lt;code&gt;rootSize&lt;/code&gt; for more detail on those values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rootSize">rootSize</a></code> operates similarly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ct.slope &lt;- unique(extractHeader(core_426$hdr, "RescaleSlope"))
ct.int   &lt;- unique(extractHeader(core_426$hdr, "RescaleIntercept")) 
# convert raw units to Hounsfield units
HU_426 &lt;- lapply(core_426$img, function(x) x*ct.slope + ct.int)

materials &lt;- conv(HU_426, pixelA = 0.0596)

## Not run: 
# plot using "ggplot" package after transforming with "reshape2" package
mass.long &lt;- reshape2::melt(materials, id.vars = c("depth"), 
   measure.vars = grep(".g", names(materials)))
ggplot2::ggplot(data = mass.long, ggplot2::aes(y = -depth, x = value, 
   color = variable)) + ggplot2::geom_point() + ggplot2::theme_classic() + 
   ggplot2::xlab("mass per section (g)")

## End(Not run)

</code></pre>

<hr>
<h2 id='convDir'>Convert a directory of raw DICOM images to material classes</h2><span id='topic+convDir'></span>

<h3>Description</h3>

<p>Calculates the area and volume of material classes for each CT slice in a directory. This approach  directly replicates Earl Davey's manual classification approach. This method is deprecated as of coreCT version 1.3.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convDir(directory = file.choose(), upperLim = 3045, lowerLim = -1025, 
airHU = -850.3233, airSD = 77.6953, 
SiHU = 271.7827, SiSD = 39.2814,
glassHU = 1345.0696, glassSD = 45.4129,
waterHU = 63.912, waterSD = 14.1728,
densities = c(0.0012, 1, 1.23, 2.2),
rootData = TRUE, 
diameter.classes = c(1, 2, 2.5, 10), 
class.names = diameter.classes,
pixel.minimum = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convDir_+3A_directory">directory</code></td>
<td>
<p>a character string that can be a matrix of DICOM images or the address of an individual DICOM file in a folder of DICOM images. The default action is &lt;code&gt;file.choose()&lt;/code&gt;; a browser menu appears so the user can select the the desired directory by identifying a single DICOM file in the folder of images.</p>
</td></tr>
<tr><td><code id="convDir_+3A_upperlim">upperLim</code></td>
<td>
<p>upper bound cutoff for pixels (Hounsfield Units)</p>
</td></tr>
<tr><td><code id="convDir_+3A_lowerlim">lowerLim</code></td>
<td>
<p>lower bound cutoff for pixels (Hounsfield Units)</p>
</td></tr>
<tr><td><code id="convDir_+3A_airhu">airHU</code></td>
<td>
<p>mean value for air-filled calibration rod (Hounsfield Units)</p>
</td></tr>
<tr><td><code id="convDir_+3A_airsd">airSD</code></td>
<td>
<p>standard deviation for air-filled calibration rod</p>
</td></tr>
<tr><td><code id="convDir_+3A_sihu">SiHU</code></td>
<td>
<p>mean value for colloidal silica calibration rod</p>
</td></tr>
<tr><td><code id="convDir_+3A_sisd">SiSD</code></td>
<td>
<p>standard deviation for colloidal Si calibration rod</p>
</td></tr>
<tr><td><code id="convDir_+3A_glasshu">glassHU</code></td>
<td>
<p>mean value for glass calibration rod</p>
</td></tr>
<tr><td><code id="convDir_+3A_glasssd">glassSD</code></td>
<td>
<p>standard deviation for glass calibration rod</p>
</td></tr>
<tr><td><code id="convDir_+3A_waterhu">waterHU</code></td>
<td>
<p>mean value for water filled calibration rod</p>
</td></tr>
<tr><td><code id="convDir_+3A_watersd">waterSD</code></td>
<td>
<p>standard deviation for water filled calibration rod</p>
</td></tr>
<tr><td><code id="convDir_+3A_densities">densities</code></td>
<td>
<p>numeric vector of known cal rod densities. Format must be c(air, water, Si, glass)</p>
</td></tr>
<tr><td><code id="convDir_+3A_rootdata">rootData</code></td>
<td>
<p>if TRUE, <code>rootSize</code> is also called on the matrix</p>
</td></tr>
<tr><td><code id="convDir_+3A_diameter.classes">diameter.classes</code></td>
<td>
<p>if rootData is TRUE, this argument provides an integer vector of diameter cut points used by <code>rootSize</code>. Units are mm (zero is added in automatically).</p>
</td></tr>
<tr><td><code id="convDir_+3A_class.names">class.names</code></td>
<td>
<p>placeholder, not used presently</p>
</td></tr>
<tr><td><code id="convDir_+3A_pixel.minimum">pixel.minimum</code></td>
<td>
<p>minimum number of pixels needed for a clump to be identified as a root</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the area and volume of material classes for each CT slice in a directory. Unlike <code><a href="#topic+conv">conv</a></code>, <code><a href="#topic+convDir">convDir</a></code> accepts a folder of raw values and makes the conversion to Hounsfield Units using the metadata associated with the DICOM images.
</p>


<h3>Value</h3>

<p>value <code>convDir</code> returns a dataframe with one row per CT slice. Values returned are the area and volume of seven material classes: gas, peat, roots and rhizomes, rock and shell, fine mineral particles, sand, and water. If <code>rootData = TRUE</code>, the output will also contain data on the abundance (number of particles), volume (cm3), and external surface area (cm2) of the root size classes specified in the <code>diameter.classes</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convDir">convDir</a></code> is a wrapper for <code><a href="#topic+conv">conv</a></code>. <code><a href="#topic+rootSizeDir">rootSizeDir</a></code> operates similarly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>materials &lt;- convDir("core_426", rootData = FALSE)


## Not run:  
# plot using "ggplot" package after transforming with "reshape2" package
mass.long &lt;- reshape2::melt(materials, id.vars = c("depth"), 
   measure.vars = grep(".g", names(materials)))
ggplot2::ggplot(data = mass.long, ggplot2::aes(y = -depth, x = value, 
   color = variable)) + ggplot2::geom_point() + ggplot2::theme_classic() + 
   ggplot2::xlab("mass per section (g)") 

## End(Not run)

</code></pre>

<hr>
<h2 id='convert'>Convert a matrix of semi-processed DICOM images to mass and volume of material classes</h2><span id='topic+convert'></span>

<h3>Description</h3>

<p>Converts raw CT units to material classes for each CT slice. This version accommodates calibration curves with &gt;4 calibrants, and uses density thresholds converted to Hounsfield Units using the calibration curve (rather than direct calibration rod values) to partition sediment components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert(mat.list, upperLim = 3045, lowerLim = -1025, 
pixelA, thickness = 0.625, # all in mm 
means     = c(-850.3233, 63.912, 271.7827, 1345.0696),
sds       = c(77.6953, 14.1728, 39.2814, 45.4129),
densities = c(0.0012, 1, 1.23, 2.2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_+3A_mat.list">mat.list</code></td>
<td>
<p>list of DICOM images for a sediment core (values in Hounsfield Units)</p>
</td></tr>
<tr><td><code id="convert_+3A_upperlim">upperLim</code></td>
<td>
<p>upper bound cutoff for pixels (Hounsfield Units)</p>
</td></tr>
<tr><td><code id="convert_+3A_lowerlim">lowerLim</code></td>
<td>
<p>lower bound cutoff for pixels (Hounsfield Units)</p>
</td></tr>
<tr><td><code id="convert_+3A_pixela">pixelA</code></td>
<td>
<p>pixel area (mm2)</p>
</td></tr>
<tr><td><code id="convert_+3A_thickness">thickness</code></td>
<td>
<p>slice thickness for computed tomography image series (mm)</p>
</td></tr>
<tr><td><code id="convert_+3A_means">means</code></td>
<td>
<p>mean values (units = Hounsfield Units) for calibration rods used.</p>
</td></tr>
<tr><td><code id="convert_+3A_sds">sds</code></td>
<td>
<p>standard deviations (units = Hounsfield Units) for calibration rods used. Must be in the same order as <code>means</code>.</p>
</td></tr>
<tr><td><code id="convert_+3A_densities">densities</code></td>
<td>
<p>numeric vector of known cal rod densities. Must be in the same order as <code>means</code> and <code>sds</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates average Hounsfield units, cross-sectional areas (cm2), volumes (cm3), and masses (g) of material classes for each CT slice. This function assumes that core walls and all non-sediment material have been removed from the raw DICOM imagery. This function converts data from raw x-ray attenuation values to Hounsfield Units, and then uses user-defined calibration rod inputs to categorize sediment components: air, roots and rhizomes, peat, water, particulates, sand, and rock/shell. The input style for calibration rods ensures sediment components are partitioned following the density divisions in Davey et al. 2011. Calibration rods and are used to develop the calibration curve. Separately, the densities used for partitioning in Davey et al. 2011 (0.0012, 1, 1.23, 2.2 g/cm3) are converted to Hounsfield Units and used for partitioning sediment components. The standard deviation for the calibration rod nearest to the target value is used for the standard deviation for the division between two sediment components.
</p>


<h3>Value</h3>

<p>value <code>convert</code> returns a dataframe with one row per CT slice. Values returned are the average Hounsfield Unit value, the area (cm2), volume (cm3), and mass (grams) of 7 material classes: gas, peat, roots and rhizomes, particulates, sand, water, and rock/shell. If &lt;code&gt;rootData = TRUE&lt;/code&gt;, data for specified root size classes are also returned. See &lt;code&gt;getRoots&lt;/code&gt; for more detail on those values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRoots">getRoots</a></code> operates similarly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ct.slope &lt;- unique(extractHeader(core_426$hdr, "RescaleSlope"))
ct.int   &lt;- unique(extractHeader(core_426$hdr, "RescaleIntercept")) 
# convert raw units to Hounsfield units
HU_426 &lt;- lapply(core_426$img, function(x) x*ct.slope + ct.int)

materials &lt;- convert(HU_426, pixelA = 0.0596)

## Not run: 
# plot using "ggplot" package after transforming with "reshape2" package
mass.long &lt;- reshape2::melt(materials, id.vars = c("depth"), 
   measure.vars = grep(".g", names(materials)))
ggplot2::ggplot(data = mass.long, ggplot2::aes(y = -depth, x = value, 
   color = variable)) + ggplot2::geom_point() + ggplot2::theme_classic() + 
   ggplot2::xlab("mass per section (g)")

## End(Not run)

</code></pre>

<hr>
<h2 id='convertDir'>Convert a directory of raw DICOM images to material classes</h2><span id='topic+convertDir'></span>

<h3>Description</h3>

<p>Calculates the area and volume of material classes for each CT slice in a directory. This version accommodates calibration curves with &gt;4 calibrants, and uses density thresholds converted to Hounsfield Units using the calibration curve (rather than direct calibration rod values) to partition sediment components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertDir(directory = file.choose(), upperLim = 3045, lowerLim = -1025, 
means     = c(-850.3233, 63.912, 271.7827, 1345.0696), 
sds       = c(77.6953, 14.1728, 39.2814, 45.4129),
densities = c(0.0012, 1, 1.23, 2.2),
rootData = TRUE, 
diameter.classes = c(1, 2, 2.5, 10), 
class.names = diameter.classes,
pixel.minimum = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertDir_+3A_directory">directory</code></td>
<td>
<p>a character string that can be a matrix of DICOM images or the address of an individual DICOM file in a folder of DICOM images. The default action is &lt;code&gt;file.choose()&lt;/code&gt;; a browser menu appears so the user can select the the desired directory by identifying a single DICOM file in the folder of images.</p>
</td></tr>
<tr><td><code id="convertDir_+3A_upperlim">upperLim</code></td>
<td>
<p>upper bound cutoff for pixels (Hounsfield Units)</p>
</td></tr>
<tr><td><code id="convertDir_+3A_lowerlim">lowerLim</code></td>
<td>
<p>lower bound cutoff for pixels (Hounsfield Units)</p>
</td></tr>
<tr><td><code id="convertDir_+3A_means">means</code></td>
<td>
<p>mean values (units = Hounsfield Units) for calibration rods used.</p>
</td></tr>
<tr><td><code id="convertDir_+3A_sds">sds</code></td>
<td>
<p>standard deviations (units = Hounsfield Units) for calibration rods used. Must be in the same order as <code>means</code>.</p>
</td></tr>
<tr><td><code id="convertDir_+3A_densities">densities</code></td>
<td>
<p>numeric vector of known cal rod densities. Format must be c(air, water, Si, glass)</p>
</td></tr>
<tr><td><code id="convertDir_+3A_rootdata">rootData</code></td>
<td>
<p>if TRUE, <code>rootSize</code> is also called on the matrix</p>
</td></tr>
<tr><td><code id="convertDir_+3A_diameter.classes">diameter.classes</code></td>
<td>
<p>if rootData is TRUE, this argument provides an integer vector of diameter cut points used by <code>rootSize</code>. Units are mm (zero is added in automatically).</p>
</td></tr>
<tr><td><code id="convertDir_+3A_class.names">class.names</code></td>
<td>
<p>placeholder, not used presently</p>
</td></tr>
<tr><td><code id="convertDir_+3A_pixel.minimum">pixel.minimum</code></td>
<td>
<p>minimum number of pixels needed for a clump to be identified as a root</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the area and volume of material classes for each CT slice in a directory. Unlike <code><a href="#topic+conv">conv</a></code>, <code><a href="#topic+convDir">convDir</a></code> accepts a folder of raw values and makes the conversion to Hounsfield Units using the metadata associated with the DICOM images.
</p>


<h3>Value</h3>

<p>value <code>convertDir</code> returns a dataframe with one row per CT slice. Values returned are the area and volume of seven material classes: gas, peat, roots and rhizomes, rock and shell, fine mineral particles, sand, and water. If <code>rootData = TRUE</code>, the output will also contain data on the abundance (number of particles), volume (cm3), and external surface area (cm2) of the root size classes specified in the <code>diameter.classes</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convertDir">convertDir</a></code> is a wrapper for <code><a href="#topic+convert">convert</a></code>. <code><a href="#topic+getRootsDir">getRootsDir</a></code> operates similarly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>materials &lt;- convertDir("core_426", rootData = FALSE)


## Not run:  
# plot using "ggplot" package after transforming with "reshape2" package
mass.long &lt;- reshape2::melt(materials, id.vars = c("depth"), 
   measure.vars = grep(".g", names(materials)))
ggplot2::ggplot(data = mass.long, ggplot2::aes(y = -depth, x = value, 
   color = variable)) + ggplot2::geom_point() + ggplot2::theme_classic() + 
   ggplot2::xlab("mass per section (g)") 

## End(Not run)

</code></pre>

<hr>
<h2 id='core_426'>Three computed tomography scans from a Spartina alterniflora core</h2><span id='topic+core_426'></span>

<h3>Description</h3>

<p>Three computed tomography scans from a Spartina alterniflora core
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(core_426)
</code></pre>


<h3>Format</h3>

<p>A list of 3 matrices, each with two elements: header and image data
</p>

<hr>
<h2 id='coreHist'>Whole-core frequency distribution of Hounsfield units</h2><span id='topic+coreHist'></span>

<h3>Description</h3>

<p>Provides the raw data and plots a frequency distibution for Hounsfield Units in the entire core, also delineating material classes. As of coreCT version 1.3.0, this code accommodates calibration curves with &gt;4 calibrants, and uses density thresholds converted to Hounsfield Units using the calibration curve (rather than direct calibration rod values) to partition sediment components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coreHist(directory = file.choose(), 
units = "percent",
upperLim = 3045, lowerLim = -1025,
means     = c(-850.3233, 63.912, 271.7827, 1345.0696),
sds       = c(77.6953, 14.1728, 39.2814, 45.4129),
densities = c(0.0012, 1, 1.23, 2.2),
returnData = TRUE, pngName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coreHist_+3A_directory">directory</code></td>
<td>
<p>a character string that can be (1) a matrix of DICOM images that exists in the global environment, or (2) the address of an individual DICOM file in a folder of DICOM images. The default action is &lt;code&gt;file.choose()&lt;/code&gt;; a browser menu appears so the user can select the the desired directory by identifying a single DICOM file in the folder of images.</p>
</td></tr>
<tr><td><code id="coreHist_+3A_units">units</code></td>
<td>
<p>units to be used for plotting purposes: either &quot;percent&quot; (the default) or &quot;absolute&quot;</p>
</td></tr>
<tr><td><code id="coreHist_+3A_upperlim">upperLim</code></td>
<td>
<p>upper bound cutoff for pixels (Hounsfield Units); upper bound is inclusive</p>
</td></tr>
<tr><td><code id="coreHist_+3A_lowerlim">lowerLim</code></td>
<td>
<p>lower bound cutoff for pixels (Hounsfield Units); lower bound is exclusive</p>
</td></tr>
<tr><td><code id="coreHist_+3A_means">means</code></td>
<td>
<p>mean values (units = Hounsfield Units) for calibration rods used.</p>
</td></tr>
<tr><td><code id="coreHist_+3A_sds">sds</code></td>
<td>
<p>standard deviations (units = Hounsfield Units) for calibration rods used. Must be in the same order as <code>means</code>.</p>
</td></tr>
<tr><td><code id="coreHist_+3A_densities">densities</code></td>
<td>
<p>numeric vector of known cal rod densities. Must be in the same order as <code>means</code> and <code>sds</code>.</p>
</td></tr>
<tr><td><code id="coreHist_+3A_returndata">returnData</code></td>
<td>
<p>if <code>TRUE</code>, voxel counts for each Hounsfield unit from <code>lowerLim</code> to <code>upperLim</code> are returned, as are material class definitions. These are the data needed to re-create and modify the frequency plot.</p>
</td></tr>
<tr><td><code id="coreHist_+3A_pngname">pngName</code></td>
<td>
<p>if this is not <code>NULL</code>, the frequency plot is saved to disk. In that case, <code>pngName</code> should be a character string containing the name and address of the file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list if <code>returnData = TRUE</code>, a list is returned containing (1) the frequencies for each Hounsfield unit value from <code>lowerLim</code> to <code>upperLim</code>, (2) the boundaries for material classes, and (3) a summary of the calibration curve applied. Lower boundaries for a component class are exclusive, while upper bounds are inclusive. These materials allow the frequency distribution to be plotted by the user. If <code>returnData = FALSE</code> the data are plotted in the graphics window, but nothing is preserved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(core_426)
coreHist("core_426", returnData = FALSE)

</code></pre>

<hr>
<h2 id='getRoots'>Convert a matrix of semi-processed DICOM images to root particle counts, volumes, and surface areas</h2><span id='topic+getRoots'></span>

<h3>Description</h3>

<p>Calculates the number of root/rhizome particles, volumes, and surface areas, for different size classes.  This version accommodates calibration curves with &gt;4 calibrants, and uses density thresholds converted to Hounsfield Units using the calibration curve (rather than direct calibration rod values) to partition sediment components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRoots(mat.list, pixelA, diameter.classes = c(1, 2, 2.5, 10),
class.names = diameter.classes,
thickness = 0.625,
means     = c(-850.3233, 63.912, 271.7827, 1345.0696),
sds       = c(77.6953, 14.1728, 39.2814, 45.4129), 
densities = c(0.0012, 1, 1.23, 2.2),
pixel.minimum = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRoots_+3A_mat.list">mat.list</code></td>
<td>
<p>list of DICOM images for a sediment core (values in Hounsfield Units)</p>
</td></tr>
<tr><td><code id="getRoots_+3A_pixela">pixelA</code></td>
<td>
<p>pixel area (mm2)</p>
</td></tr>
<tr><td><code id="getRoots_+3A_diameter.classes">diameter.classes</code></td>
<td>
<p>an integer vector of diameter cut points. Units are mm (zero is added in automatically).</p>
</td></tr>
<tr><td><code id="getRoots_+3A_class.names">class.names</code></td>
<td>
<p>not used presently</p>
</td></tr>
<tr><td><code id="getRoots_+3A_thickness">thickness</code></td>
<td>
<p>slice thickness for computed tomography image series (mm)</p>
</td></tr>
<tr><td><code id="getRoots_+3A_means">means</code></td>
<td>
<p>mean values (units = Hounsfield Units) for calibration rods used.</p>
</td></tr>
<tr><td><code id="getRoots_+3A_sds">sds</code></td>
<td>
<p>standard deviations (units = Hounsfield Units) for calibration rods used. Must be in the same order as <code>means</code>.</p>
</td></tr>
<tr><td><code id="getRoots_+3A_densities">densities</code></td>
<td>
<p>numeric vector of known cal rod densities. Must be in the same order as <code>means</code> and <code>sds</code>.</p>
</td></tr>
<tr><td><code id="getRoots_+3A_pixel.minimum">pixel.minimum</code></td>
<td>
<p>minimum number of pixels needed for a clump to be identified as a root</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the number of root/rhizome particles, volumes, and surface areas, for different size classes. This function requires that values be Hounsfield Units (i.e., data must be semi-processed from the raw DICOM imagery).
</p>


<h3>Value</h3>

<p>value <code>getRoots</code> returns a dataframe with one row per CT slice. Values returned are the number, volume (cm3), and surface area (cm2) of particles in each size class with an upper bound defined in <code>diameter.classes</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convert">convert</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ct.slope &lt;- unique(extractHeader(core_426$hdr, "RescaleSlope"))
ct.int   &lt;- unique(extractHeader(core_426$hdr, "RescaleIntercept")) 
# convert raw units to Hounsfield units
HU_426 &lt;- lapply(core_426$img, function(x) x*ct.slope + ct.int)

rootChars &lt;- getRoots(HU_426, pixelA = 0.0596,
diameter.classes = c(2.5, 10))

## Not run: 
# plot using "ggplot" package after transforming with "reshape2" package
area.long &lt;- reshape2::melt(rootChars, id.vars = c("depth"), 
   measure.vars = grep("Area", names(rootChars)))
ggplot2::ggplot(data = area.long, ggplot2::aes(y = -depth, x = value, 
   color = variable)) + ggplot2::geom_point() + ggplot2::theme_classic() + 
   ggplot2::xlab("root external surface area per slice (cm2)")

## End(Not run)

</code></pre>

<hr>
<h2 id='getRootsDir'>Convert a directory of raw DICOM images to  root particle counts and surface areas</h2><span id='topic+getRootsDir'></span>

<h3>Description</h3>

<p>Calculates the number of root/rhizome particles and surface areas, for different size classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRootsDir(directory = file.choose(), 
diameter.classes = c(1, 2, 5, 10, 20),
class.names = diameter.classes,
means     = c(-850.3233, 63.912, 271.7827, 1345.0696),
sds       = c(77.6953, 14.1728, 39.2814, 45.4129),
densities = c(0.0012, 1, 1.23, 2.2),
pixel.minimum = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRootsDir_+3A_directory">directory</code></td>
<td>
<p>a character string that can be a matrix of DICOM images or the address of an individual DICOM file in a folder of DICOM images. The default action is &lt;code&gt;file.choose()&lt;/code&gt;; a browser menu appears so the user can select the the desired directory by identifying a single DICOM file in the folder of images.</p>
</td></tr>
<tr><td><code id="getRootsDir_+3A_diameter.classes">diameter.classes</code></td>
<td>
<p>an integer vector of diameter cut points. Units are mm (zero is added in automatically).</p>
</td></tr>
<tr><td><code id="getRootsDir_+3A_class.names">class.names</code></td>
<td>
<p>not used presently</p>
</td></tr>
<tr><td><code id="getRootsDir_+3A_means">means</code></td>
<td>
<p>mean values (units = Hounsfield Units) for calibration rods used.</p>
</td></tr>
<tr><td><code id="getRootsDir_+3A_sds">sds</code></td>
<td>
<p>standard deviations (units = Hounsfield Units) for calibration rods used. Must be in the same order as <code>means</code>.</p>
</td></tr>
<tr><td><code id="getRootsDir_+3A_densities">densities</code></td>
<td>
<p>numeric vector of known cal rod densities. Must be in the same order as <code>means</code> and <code>sds</code>.</p>
</td></tr>
<tr><td><code id="getRootsDir_+3A_pixel.minimum">pixel.minimum</code></td>
<td>
<p>minimum number of pixels needed for a clump to be identified as a root</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the number of root/rhizome particles and surface areas, for different size classes. Unlike <code><a href="#topic+getRoots">getRoots</a></code>, <code><a href="#topic+getRootsDir">getRootsDir</a></code> accepts a folder of raw values and makes the conversion to Hounsfield Units using the metadata associated with the DICOM images. This version accommodates calibration curves with &gt;4 calibrants, and uses density thresholds converted to Hounsfield Units using the calibration curve (rather than direct calibration rod values) to partition sediment components.
</p>


<h3>Value</h3>

<p>value <code>getRootData</code> returns a dataframe with one row per CT slice. Values returned are the number, volume (cm3), and surface area (cm2) of particles in each size class with an upper bound defined in <code>diameter.classes</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRootsDir">getRootsDir</a></code> is a wrapper for <code><a href="#topic+getRoots">getRoots</a></code>. <code><a href="#topic+getRootsDir">getRootsDir</a></code> operates similarly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rootChars &lt;- getRootsDir("core_426", diameter.classes = c(2.5, 10))

## Not run: 
# plot using "ggplot" package after transforming with "reshape2" package
area.long &lt;- reshape2::melt(rootChars, id.vars = c("depth"), 
   measure.vars = grep("Area", names(rootChars)))
ggplot2::ggplot(data = area.long, ggplot2::aes(y = -depth, x = value, 
   color = variable)) + ggplot2::geom_point() + ggplot2::theme_classic() + 
   ggplot2::xlab("root external surface area per slice (cm2)")

## End(Not run)

</code></pre>

<hr>
<h2 id='getSurface'>Remove artificial surface layers from processed CT data</h2><span id='topic+getSurface'></span>

<h3>Description</h3>

<p>Identifies and removes artificial surface layers from processed CT data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSurface(x, material = "particulates", threshold = 0.40, 
start = "top", thickness = 0.625)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSurface_+3A_x">x</code></td>
<td>
<p>dataframe created by <code>conv</code></p>
</td></tr>
<tr><td><code id="getSurface_+3A_material">material</code></td>
<td>
<p>material used for determining where the surface begins</p>
</td></tr>
<tr><td><code id="getSurface_+3A_threshold">threshold</code></td>
<td>
<p>decimal fraction of total area, used to determine the surface layer. Surface slices where <code>material</code> exceeds threshold value are removed.</p>
</td></tr>
<tr><td><code id="getSurface_+3A_start">start</code></td>
<td>
<p>should core be processed from the top, bottom, or both?</p>
</td></tr>
<tr><td><code id="getSurface_+3A_thickness">thickness</code></td>
<td>
<p>CT image thickness (mm)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Identifies and removes artificial surface layers from processed CT data. Areas can be removed from one or both ends of the core (set by <code>start</code>), based on exceeding a <code>threshold</code> proportion of material (e.g., 75
</p>


<h3>Value</h3>

<p>value <code>getSurface</code> shortens the output of <code>conv</code> to remove artificial surface layers. The output is thus a subset of the input, and identical in structure to the /codeconv output.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conv">conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Not run:
## Not run: data(core_426)
ct.slope &lt;- unique(extractHeader(core_426$hdr, "RescaleSlope"))
ct.int   &lt;- unique(extractHeader(core_426$hdr, "RescaleIntercept")) 
# convert raw units to Hounsfield units
HU_426 &lt;- lapply(core_426$img, function(x) x*ct.slope + ct.int)

materials &lt;- conv(HU_426)
head(materials[, 1:6], 20)

materials2 &lt;- getSurface(materials)
head(materials2[, 1:6])

## End(Not run)
</code></pre>

<hr>
<h2 id='rootSize'>Convert a matrix of semi-processed DICOM images to root particle counts, volumes, and surface areas</h2><span id='topic+rootSize'></span>

<h3>Description</h3>

<p>Calculates the number of root/rhizome particles, volumes,  and surface areas, for different size classes.  This approach  directly replicates Earl Davey's manual classification approach. This method is deprecated as of coreCT version 1.3.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rootSize(mat.list, pixelA, diameter.classes = c(1, 2, 2.5, 10),
class.names = diameter.classes,
thickness = 0.625,
airHU = -850.3233,
airSD = 77.6953,
waterHU = 63.912,
waterSD = 14.1728,
pixel.minimum = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rootSize_+3A_mat.list">mat.list</code></td>
<td>
<p>list of DICOM images for a sediment core (values in Hounsfield Units)</p>
</td></tr>
<tr><td><code id="rootSize_+3A_pixela">pixelA</code></td>
<td>
<p>pixel area (mm2)</p>
</td></tr>
<tr><td><code id="rootSize_+3A_diameter.classes">diameter.classes</code></td>
<td>
<p>an integer vector of diameter cut points. Units are mm (zero is added in automatically).</p>
</td></tr>
<tr><td><code id="rootSize_+3A_class.names">class.names</code></td>
<td>
<p>not used presently</p>
</td></tr>
<tr><td><code id="rootSize_+3A_thickness">thickness</code></td>
<td>
<p>CT image thickness (mm)</p>
</td></tr>
<tr><td><code id="rootSize_+3A_airhu">airHU</code></td>
<td>
<p>mean value for air-filled calibration rod (all rod arguments are in Hounsfield Units)</p>
</td></tr>
<tr><td><code id="rootSize_+3A_airsd">airSD</code></td>
<td>
<p>standard deviation for air-filled calibration rod</p>
</td></tr>
<tr><td><code id="rootSize_+3A_waterhu">waterHU</code></td>
<td>
<p>mean value for water-filled calibration rod</p>
</td></tr>
<tr><td><code id="rootSize_+3A_watersd">waterSD</code></td>
<td>
<p>standard deviation for water-filled calibration rod</p>
</td></tr>
<tr><td><code id="rootSize_+3A_pixel.minimum">pixel.minimum</code></td>
<td>
<p>minimum number of pixels needed for a clump to be identified as a root</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the number of root/rhizome particles, volumes, and surface areas, for different size classes. This function requires that values be Hounsfield Units (i.e., data must be semi-processed from the raw DICOM imagery).
</p>


<h3>Value</h3>

<p>value <code>rootSize</code> returns a dataframe with one row per CT slice. Values returned are the number, volume (cm3), and surface area (cm2) of particles in each size class with an upper bound defined in <code>diameter.classes</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conv">conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ct.slope &lt;- unique(extractHeader(core_426$hdr, "RescaleSlope"))
ct.int   &lt;- unique(extractHeader(core_426$hdr, "RescaleIntercept")) 
# convert raw units to Hounsfield units
HU_426 &lt;- lapply(core_426$img, function(x) x*ct.slope + ct.int)

rootChars &lt;- rootSize(HU_426, pixelA = 0.0596,
diameter.classes = c(2.5, 10))

## Not run: 
# plot using "ggplot" package after transforming with "reshape2" package
area.long &lt;- reshape2::melt(rootChars, id.vars = c("depth"), 
   measure.vars = grep("Area", names(rootChars)))
ggplot2::ggplot(data = area.long, ggplot2::aes(y = -depth, x = value, 
   color = variable)) + ggplot2::geom_point() + ggplot2::theme_classic() + 
   ggplot2::xlab("root external surface area per slice (cm2)")

## End(Not run)

</code></pre>

<hr>
<h2 id='rootSizeDir'>Convert a directory of raw DICOM images to  root particle counts and surface areas</h2><span id='topic+rootSizeDir'></span>

<h3>Description</h3>

<p>Calculates the number of root/rhizome particles and surface areas, for different size classes.  This approach  directly replicates Earl Davey's manual classification approach. This method is deprecated as of coreCT version 1.3.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rootSizeDir(directory = file.choose(), diameter.classes = c(1, 2, 5, 10, 20),
class.names = diameter.classes,
airHU = -850.3233,
airSD = 77.6953,
waterHU = 63.912,
waterSD = 14.1728,
pixel.minimum = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rootSizeDir_+3A_directory">directory</code></td>
<td>
<p>a character string that can be a matrix of DICOM images or the address of an individual DICOM file in a folder of DICOM images. The default action is &lt;code&gt;file.choose()&lt;/code&gt;; a browser menu appears so the user can select the the desired directory by identifying a single DICOM file in the folder of images.</p>
</td></tr>
<tr><td><code id="rootSizeDir_+3A_diameter.classes">diameter.classes</code></td>
<td>
<p>an integer vector of diameter cut points. Units are mm (zero is added in automatically).</p>
</td></tr>
<tr><td><code id="rootSizeDir_+3A_class.names">class.names</code></td>
<td>
<p>not used presently</p>
</td></tr>
<tr><td><code id="rootSizeDir_+3A_airhu">airHU</code></td>
<td>
<p>mean value for air-filled calibration rod (all rod arguments are in Hounsfield Units)</p>
</td></tr>
<tr><td><code id="rootSizeDir_+3A_airsd">airSD</code></td>
<td>
<p>standard deviation for air-filled calibration rod</p>
</td></tr>
<tr><td><code id="rootSizeDir_+3A_waterhu">waterHU</code></td>
<td>
<p>mean value for water-filled calibration rod</p>
</td></tr>
<tr><td><code id="rootSizeDir_+3A_watersd">waterSD</code></td>
<td>
<p>standard deviation for water-filled calibration rod</p>
</td></tr>
<tr><td><code id="rootSizeDir_+3A_pixel.minimum">pixel.minimum</code></td>
<td>
<p>minimum number of pixels needed for a clump to be identified as a root</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the number of root/rhizome particles and surface areas, for different size classes. Unlike <code><a href="#topic+rootSize">rootSize</a></code>, <code><a href="#topic+rootSizeDir">rootSizeDir</a></code> accepts a folder of raw values and makes the conversion to Hounsfield Units using the metadata associated with the DICOM images.
</p>


<h3>Value</h3>

<p>value <code>rootSize</code> returns a dataframe with one row per CT slice. Values returned are the number, volume (cm3), and surface area (cm2) of particles in each size class with an upper bound defined in <code>diameter.classes</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rootSizeDir">rootSizeDir</a></code> is a wrapper for <code><a href="#topic+rootSize">rootSize</a></code>. <code><a href="#topic+rootSizeDir">rootSizeDir</a></code> operates similarly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rootChars &lt;- rootSizeDir("core_426", diameter.classes = c(2.5, 10))

## Not run: 
# plot using "ggplot" package after transforming with "reshape2" package
area.long &lt;- reshape2::melt(rootChars, id.vars = c("depth"), 
   measure.vars = grep("Area", names(rootChars)))
ggplot2::ggplot(data = area.long, ggplot2::aes(y = -depth, x = value, 
   color = variable)) + ggplot2::geom_point() + ggplot2::theme_classic() + 
   ggplot2::xlab("root external surface area per slice (cm2)")

## End(Not run)

</code></pre>

<hr>
<h2 id='voxDims'>Extract voxel dimensions from DICOM image</h2><span id='topic+voxDims'></span>

<h3>Description</h3>

<p>Extract pixel area and slice thickness from DICOM header to characterize voxel (3D pixel) dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voxDims(directory = file.choose())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voxDims_+3A_directory">directory</code></td>
<td>
<p>a character string that can be a matrix of DICOM images or the address of an individual DICOM file in a folder of DICOM images. The default action is &lt;code&gt;file.choose()&lt;/code&gt;; a browser menu appears so the user can select the the desired directory by identifying a single DICOM file in the folder of images.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value <code>voxDims</code> returns a two-column dataframe showing the pixel area and slice thickness. Values in the DICOM headers are assumed to be millimeters; pixel area and slice thickness columns are labeled based on this assumption.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(core_426)
voxDims("core_426")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
