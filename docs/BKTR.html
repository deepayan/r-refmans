<!DOCTYPE html><html><head><title>Help for package BKTR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BKTR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#*.Kernel'><p>Operator overloading for kernel multiplication</p></a></li>
<li><a href='#+.Kernel'><p>Operator overloading for kernel addition</p></a></li>
<li><a href='#bixi_spatial_features'>
<p>Spatial Features of Montreal BIXI Stations in 2019</p></a></li>
<li><a href='#bixi_spatial_locations'>
<p>Spatial Locations of Montreal BIXI Stations in 2019</p></a></li>
<li><a href='#bixi_station_departures'>
<p>Daily Departure from BIXI Stations in 2019</p></a></li>
<li><a href='#bixi_temporal_features'>
<p>Temporal Features in Montreal applicable to BIXI for 2019</p></a></li>
<li><a href='#bixi_temporal_locations'>
<p>Temporal indices for the 2019 BIXI season</p></a></li>
<li><a href='#BixiData'><p>BIXI Data Class</p></a></li>
<li><a href='#BKTRRegressor'><p>R6 class encapsulating the BKTR regression elements</p></a></li>
<li><a href='#CompositionOps'><p>Kernel Composition Operations</p></a></li>
<li><a href='#Kernel'><p>Base R6 class for Kernels</p></a></li>
<li><a href='#KernelAddComposed'><p>R6 class for Kernels Composed via Addition</p></a></li>
<li><a href='#KernelComposed'><p>R6 class for Composed Kernels</p></a></li>
<li><a href='#KernelMatern'><p>R6 class for Matern Kernels</p></a></li>
<li><a href='#KernelMulComposed'><p>R6 class for Kernels Composed via Multiplication</p></a></li>
<li><a href='#KernelParameter'><p>R6 class for kernel's hyperparameter</p></a></li>
<li><a href='#KernelPeriodic'><p>R6 class for Periodic Kernels</p></a></li>
<li><a href='#KernelRQ'><p>R6 class for Rational Quadratic Kernels</p></a></li>
<li><a href='#KernelSE'><p>R6 class for Square Exponential Kernels</p></a></li>
<li><a href='#KernelWhiteNoise'><p>R6 class for White Noise Kernels</p></a></li>
<li><a href='#plot_beta_dists'><p>Plot Beta Coefficients Distribution</p></a></li>
<li><a href='#plot_covariates_beta_dists'><p>Plot Beta Coefficients Distribution Regrouped by Covariates</p></a></li>
<li><a href='#plot_hyperparams_dists'><p>Plot Hyperparameters Distributions</p></a></li>
<li><a href='#plot_hyperparams_traceplot'><p>Plot Hyperparameters Traceplot</p></a></li>
<li><a href='#plot_spatial_betas'><p>Plot Spatial Beta Coefficients</p></a></li>
<li><a href='#plot_temporal_betas'><p>Plot Temporal Beta Coefficients</p></a></li>
<li><a href='#plot_y_estimates'><p>Plot Y Estimates</p></a></li>
<li><a href='#print.BKTRRegressor'><p>Print the summary of a BKTRRegressor instance</p></a></li>
<li><a href='#reshape_covariate_dfs'><p>Function used to transform covariates coming from two dataframes one for spatial and</p>
one for temporal into a single dataframe with the right shape for the BKTR Regressor.
This is useful when the temporal covariates do not vary trough space and the spatial
covariates do not vary trough time (Like in the BIXI example). The function also adds
a column for the target variable at the beginning of the dataframe.</a></li>
<li><a href='#simulate_spatiotemporal_data'><p>Simulate Spatiotemporal Data Using Kernel Covariances.</p></a></li>
<li><a href='#summary.BKTRRegressor'><p>Summarize a BKTRRegressor instance</p></a></li>
<li><a href='#TensorOperator'><p>R6 singleton that contains the configuration for the tensor backend</p></a></li>
<li><a href='#TSR'><p>Tensor Operator Singleton</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Kernelized Tensor Regression</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates scalable spatiotemporally varying coefficient
    modelling with Bayesian kernelized tensor regression.
    The important features of this package are:
    (a) Enabling local temporal and spatial modeling of the relationship between
    the response variable and covariates.
    (b) Implementing the model described by Lei et al. (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2109.00046">doi:10.48550/arXiv.2109.00046</a>&gt;.
    (c) Using a Bayesian Markov Chain Monte Carlo (MCMC) algorithm to sample from the posterior
    distribution of the model parameters.
    (d) Employing a tensor decomposition to reduce the number of estimated parameters.
    (e) Accelerating tensor operations and enabling graphics processing unit (GPU) acceleration
    with the 'torch' package.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>torch, R6, R6P, ggplot2, ggmap, data.table</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'samplers.R' 'tensor_ops.R' 'result_logger.R'
'likelihood_evaluator.R' 'distances.R' 'kernels.R' 'bktr.R'
'examples.R' 'plots.R' 'utils.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, R.rsp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown, R.rsp</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/julien-hec/BKTR/issues">https://github.com/julien-hec/BKTR/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-20 09:17:36 UTC; juju</td>
</tr>
<tr>
<td>Author:</td>
<td>Julien Lanthier <a href="https://orcid.org/0009-0008-8728-4996"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Mengying Lei <a href="https://orcid.org/0000-0001-7343-3323"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Aurélie Labbe <a href="https://orcid.org/0000-0002-4207-8143"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Lijun Sun <a href="https://orcid.org/0000-0001-9488-0712"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julien Lanthier &lt;julien.lanthier@hec.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-20 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2A.Kernel'>Operator overloading for kernel multiplication</h2><span id='topic++2A.Kernel'></span>

<h3>Description</h3>

<p>Operator overloading for kernel multiplication
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kernel'
k1 * k2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A.Kernel_+3A_k1">k1</code></td>
<td>
<p>Kernel: The left kernel to use for composition</p>
</td></tr>
<tr><td><code id="+2B2A.Kernel_+3A_k2">k2</code></td>
<td>
<p>Kernel: The right kernel to use for composition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>KernelMulComposed</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a new locally periodic kernel
k_loc_per &lt;- KernelSE$new() * KernelPeriodic$new()
# Set the kernel's positions
positions_df &lt;- data.frame(x=c(-4, 0, 3), y=c(-2, 0, 2))
k_loc_per$set_positions(positions_df)
# Generate the kernel's covariance matrix
k_loc_per$kernel_gen()

</code></pre>

<hr>
<h2 id='+2B.Kernel'>Operator overloading for kernel addition</h2><span id='topic++2B.Kernel'></span>

<h3>Description</h3>

<p>Operator overloading for kernel addition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kernel'
k1 + k2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.Kernel_+3A_k1">k1</code></td>
<td>
<p>Kernel: The left kernel to use for composition</p>
</td></tr>
<tr><td><code id="+2B2B.Kernel_+3A_k2">k2</code></td>
<td>
<p>Kernel: The right kernel to use for composition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>KernelAddComposed</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a new additive kernel
k_rq_plus_per &lt;- KernelRQ$new() + KernelPeriodic$new()
# Set the kernel's positions
positions_df &lt;- data.frame(x=c(-4, 0, 3), y=c(-2, 0, 2))
k_rq_plus_per$set_positions(positions_df)
# Generate the kernel's covariance matrix
k_rq_plus_per$kernel_gen()

</code></pre>

<hr>
<h2 id='bixi_spatial_features'>
Spatial Features of Montreal BIXI Stations in 2019
</h2><span id='topic+bixi_spatial_features'></span>

<h3>Description</h3>

<p>These data represent 14 spatial features (columns) for 587 bike sharing
stations (rows) located at different geographical coordinates (longitude,
latitude) in Montreal. The Montreal based bike sharing company is named BIXI.
The first column contains the descriptive label affected to each station and the
other columns contain information about the infrastructure, points of interests,
walkscore and population surrounding each station for 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bixi_spatial_features")</code></pre>


<h3>Format</h3>

<p>A data frame with 587 observations on the following 14 variables.
</p>

<dl>
<dt><code>location</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>area_park</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>len_cycle_path</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>len_major_road</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>len_minor_road</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>num_metro_stations</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>num_other_commercial</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>num_restaurants</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>num_university</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>num_pop</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>num_bus_stations</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>num_bus_routes</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>walkscore</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>capacity</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wang, X., Cheng, Z., Trépanier, M., &amp; Sun, L. (2021).
Modeling bike-sharing demand using a regression model with spatially
varying coefficients. Journal of Transport Geography, 93, 103059.
</p>


<h3>References</h3>

<p>Reference for the BIXI station informations:
BIXI Montréal (2023). “Open Data.” Accessed: 2023-07-11, URL
<a href="https://bixi.com/en/">https://bixi.com/en/</a> open-data.
</p>
<p>Reference for point of interests and infrastructure informations:
DMTI Spatial Inc (2019). “Enhanced Point of Interest (DMTI).”
URL <a href="https://www.dmtispatial.com">https://www.dmtispatial.com</a>.
</p>
<p>Reference for Walkscore:
Walk Score (2023). “Walk Score Methodology.” Accessed: 2023-07-11,
URL <a href="https://www.walkscore.com/methodology.shtml">https://www.walkscore.com/methodology.shtml</a>.
</p>
<p>The population information comes from the 2016 Canada census data at a
dissemination block level.
</p>

<hr>
<h2 id='bixi_spatial_locations'>
Spatial Locations of Montreal BIXI Stations in 2019
</h2><span id='topic+bixi_spatial_locations'></span>

<h3>Description</h3>

<p>Data points representing the spatial locations of 587 bike sharing stations for
the Montreal based bike sharing company named BIXI. The dataframe contains
a label to identify each station and its associated longitude and latitude
coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bixi_spatial_locations")</code></pre>


<h3>Format</h3>

<p>A data frame with 587 observations on the following 3 variables.
</p>

<dl>
<dt><code>location</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>latitude</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>longitude</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wang, X., Cheng, Z., Trépanier, M., &amp; Sun, L. (2021).
Modeling bike-sharing demand using a regression model with spatially
varying coefficients. Journal of Transport Geography, 93, 103059.
</p>


<h3>References</h3>

<p>BIXI Montréal (2023). “Open Data.” Accessed: 2023-07-11, URL
<a href="https://bixi.com/en/">https://bixi.com/en/</a> open-data.
</p>

<hr>
<h2 id='bixi_station_departures'>
Daily Departure from BIXI Stations in 2019
</h2><span id='topic+bixi_station_departures'></span>

<h3>Description</h3>

<p>These data capture the number of daily departure for 587 bike sharing stations
(rows) through 197 days (columns). The data is limited to the 2019 season of
a Montreal based bike sharing company named BIXI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bixi_station_departures")</code></pre>


<h3>Format</h3>

<p>A data frame with 587 rows and 197 columns.</p>


<h3>Source</h3>

<p>Wang, X., Cheng, Z., Trépanier, M., &amp; Sun, L. (2021).
Modeling bike-sharing demand using a regression model with spatially
varying coefficients. Journal of Transport Geography, 93, 103059.
</p>


<h3>References</h3>

<p>BIXI Montréal (2023). “Open Data.” Accessed: 2023-07-11, URL
<a href="https://bixi.com/en/">https://bixi.com/en/</a> open-data.
</p>

<hr>
<h2 id='bixi_temporal_features'>
Temporal Features in Montreal applicable to BIXI for 2019
</h2><span id='topic+bixi_temporal_features'></span>

<h3>Description</h3>

<p>These data represent the temporal features in Montreal applicable to a Montreal
based bike sharing company named BIXI. The data include six features (columns)
for 196 days (rows). The time column represent the label associated to each
captured time for the 2019 season of BIXI. The other columns contain information
about Montral weather and applicable holidays for each day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bixi_temporal_features")</code></pre>


<h3>Format</h3>

<p>A data frame with 196 observations on the following 6 variables.
</p>

<dl>
<dt><code>time</code></dt><dd><p>a IDate</p>
</dd>
<dt><code>humidity</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>max_temp_f</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>mean_temp_c</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>total_precip_mm</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>holiday</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Lei, M., Labbe, A., &amp; Sun, L. (2021). Scalable Spatiotemporally Varying
Coefficient Modelling with Bayesian Kernelized Tensor Regression.
arXiv preprint arXiv:2109.00046.
</p>


<h3>References</h3>

<p>The weather data is sourced from the Environment and Climate Change
Canada Historical Climate Data website.
</p>
<p>The holiday column is specifying if a date is a holiday or not,
according to the Quebec government.
</p>

<hr>
<h2 id='bixi_temporal_locations'>
Temporal indices for the 2019 BIXI season
</h2><span id='topic+bixi_temporal_locations'></span>

<h3>Description</h3>

<p>These data represent 196 temporal indices (rows) related to each day
of the 2019 season of Montreal based bike sharing company named BIXI.
The time column represent the label associated to each day and the time_index
column represent the location in time space of each day when compared to each
other. Since no days are missing and they are all spaced by exactly one day,
the time_index is simply a range from 0 to 195.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bixi_temporal_locations")</code></pre>


<h3>Format</h3>

<p>A data frame with 196 observations on the following 2 variables.
</p>

<dl>
<dt><code>time</code></dt><dd><p>a IDate</p>
</dd>
<dt><code>time_index</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Lei, M., Labbe, A., &amp; Sun, L. (2021). Scalable Spatiotemporally Varying
Coefficient Modelling with Bayesian Kernelized Tensor Regression.
arXiv preprint arXiv:2109.00046.
</p>

<hr>
<h2 id='BixiData'>BIXI Data Class</h2><span id='topic+BixiData'></span>

<h3>Description</h3>

<p>R6 class encapsulating all BIXI dataframes. It is also
possible to use a light version of the dataset by using the <code>is_light</code>
parameter. In this case, the dataset is reduced to its first 25 stations
and first 50 days. The light version is only used for testing and short examples.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>departure_df</code></dt><dd><p>The departure dataframe</p>
</dd>
<dt><code>spatial_features_df</code></dt><dd><p>The spatial features dataframe</p>
</dd>
<dt><code>temporal_features_df</code></dt><dd><p>The temporal features dataframe</p>
</dd>
<dt><code>spatial_positions_df</code></dt><dd><p>The spatial positions dataframe</p>
</dd>
<dt><code>temporal_positions_df</code></dt><dd><p>The temporal positions dataframe</p>
</dd>
<dt><code>data_df</code></dt><dd><p>The data dataframe</p>
</dd>
<dt><code>is_light</code></dt><dd><p>Whether the light version of the dataset is used</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BixiData-new"><code>BixiData$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BixiData-clone"><code>BixiData$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BixiData-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the BIXI data class
</p>


<h5>Usage</h5>

<div class="r"><pre>BixiData$new(is_light = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>is_light</code></dt><dd><p>Whether the light version of the dataset is used,
defaults to FALSE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new BIXI data instance
</p>


<hr>
<a id="method-BixiData-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BixiData$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create a light BIXI data collection instance containing multiple dataframes
# This only uses the first 25 stations and 50 days of the full dataset
bixi_data &lt;- BixiData$new(is_light = TRUE)
# Dataframe containing the position (latitude and longitude) of M stations
bixi_data$spatial_positions_df
# Dataframe containing the time position of N days (O to N-1)
bixi_data$temporal_positions_df
# Dataframe with spatial and temporal features for each day and station (M x N rows)
bixi_data$data_df

</code></pre>

<hr>
<h2 id='BKTRRegressor'>R6 class encapsulating the BKTR regression elements</h2><span id='topic+BKTRRegressor'></span>

<h3>Description</h3>

<p>A BKTRRegressor holds all the key elements to accomplish the MCMC sampling
algorithm (<strong>Algorithm 1</strong> of the paper).
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>data_df</code></dt><dd><p>The dataframe containing all the covariates through time and space (including
the response variable)</p>
</dd>
<dt><code>y</code></dt><dd><p>The response variable tensor</p>
</dd>
<dt><code>omega</code></dt><dd><p>The tensor indicating which response values are not missing</p>
</dd>
<dt><code>covariates</code></dt><dd><p>The tensor containing all the covariates</p>
</dd>
<dt><code>covariates_dim</code></dt><dd><p>The dimensions of the covariates tensor</p>
</dd>
<dt><code>logged_params_tensor</code></dt><dd><p>The tensor containing all the sampled hyperparameters</p>
</dd>
<dt><code>tau</code></dt><dd><p>The precision hyperparameter</p>
</dd>
<dt><code>spatial_decomp</code></dt><dd><p>The spatial covariate decomposition</p>
</dd>
<dt><code>temporal_decomp</code></dt><dd><p>The temporal covariate decomposition</p>
</dd>
<dt><code>covs_decomp</code></dt><dd><p>The feature covariate decomposition</p>
</dd>
<dt><code>result_logger</code></dt><dd><p>The result logger instance used to store the results of the MCMC sampling</p>
</dd>
<dt><code>has_completed_sampling</code></dt><dd><p>Boolean showing wheter the MCMC sampling has been completed</p>
</dd>
<dt><code>spatial_kernel</code></dt><dd><p>The spatial kernel used</p>
</dd>
<dt><code>temporal_kernel</code></dt><dd><p>The temporal kernel used</p>
</dd>
<dt><code>spatial_positions_df</code></dt><dd><p>The dataframe containing the spatial positions</p>
</dd>
<dt><code>temporal_positions_df</code></dt><dd><p>The dataframe containing the temporal positions</p>
</dd>
<dt><code>spatial_params_sampler</code></dt><dd><p>The spatial kernel hyperparameter sampler</p>
</dd>
<dt><code>temporal_params_sampler</code></dt><dd><p>The temporal kernel hyperparameter sampler</p>
</dd>
<dt><code>tau_sampler</code></dt><dd><p>The tau hyperparameter sampler</p>
</dd>
<dt><code>precision_matrix_sampler</code></dt><dd><p>The precision matrix sampler</p>
</dd>
<dt><code>spatial_ll_evaluator</code></dt><dd><p>The spatial likelihood evaluator</p>
</dd>
<dt><code>temporal_ll_evaluator</code></dt><dd><p>The temporal likelihood evaluator</p>
</dd>
<dt><code>rank_decomp</code></dt><dd><p>The rank of the CP decomposition</p>
</dd>
<dt><code>burn_in_iter</code></dt><dd><p>The number of burn in iterations</p>
</dd>
<dt><code>sampling_iter</code></dt><dd><p>The number of sampling iterations</p>
</dd>
<dt><code>max_iter</code></dt><dd><p>The total number of iterations</p>
</dd>
<dt><code>a_0</code></dt><dd><p>The initial value for the shape in the gamma function generating tau</p>
</dd>
<dt><code>b_0</code></dt><dd><p>The initial value for the rate in the gamma function generating tau</p>
</dd>
<dt><code>formula</code></dt><dd><p>The formula used to specify the relation between the response variable and the covariates</p>
</dd>
<dt><code>spatial_labels</code></dt><dd><p>The spatial labels</p>
</dd>
<dt><code>temporal_labels</code></dt><dd><p>The temporal labels</p>
</dd>
<dt><code>feature_labels</code></dt><dd><p>The feature labels</p>
</dd>
<dt><code>geo_coords_projector</code></dt><dd><p>The geographic coordinates projector</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>summary</code></dt><dd><p>A summary of the BKTRRegressor instance</p>
</dd>
<dt><code>beta_covariates_summary</code></dt><dd><p>A dataframe containing the summary of the beta covariates</p>
</dd>
<dt><code>y_estimates</code></dt><dd><p>A dataframe containing the y estimates</p>
</dd>
<dt><code>imputed_y_estimates</code></dt><dd><p>A dataframe containing the imputed y estimates</p>
</dd>
<dt><code>beta_estimates</code></dt><dd><p>A dataframe containing the beta estimates</p>
</dd>
<dt><code>hyperparameters_per_iter_df</code></dt><dd><p>A dataframe containing the beta estimates per iteration</p>
</dd>
<dt><code>decomposition_tensors</code></dt><dd><p>List of all used decomposition tensors</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BKTRRegressor-new"><code>BKTRRegressor$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BKTRRegressor-mcmc_sampling"><code>BKTRRegressor$mcmc_sampling()</code></a>
</p>
</li>
<li> <p><a href="#method-BKTRRegressor-predict"><code>BKTRRegressor$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-BKTRRegressor-get_iterations_betas"><code>BKTRRegressor$get_iterations_betas()</code></a>
</p>
</li>
<li> <p><a href="#method-BKTRRegressor-get_beta_summary_df"><code>BKTRRegressor$get_beta_summary_df()</code></a>
</p>
</li>
<li> <p><a href="#method-BKTRRegressor-clone"><code>BKTRRegressor$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BKTRRegressor-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>BKTRRegressor</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>BKTRRegressor$new(
  data_df,
  spatial_positions_df,
  temporal_positions_df,
  rank_decomp = 10,
  burn_in_iter = 500,
  sampling_iter = 500,
  formula = NULL,
  spatial_kernel = KernelMatern$new(smoothness_factor = 3),
  temporal_kernel = KernelSE$new(),
  sigma_r = 0.01,
  a_0 = 1e-06,
  b_0 = 1e-06,
  has_geo_coords = TRUE,
  geo_coords_scale = 10
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data_df</code></dt><dd><p>data.table: A dataframe containing all the covariates
through time and space. It is important that the dataframe has a two
indexes named 'location' and 'time' respectively. The dataframe should
also contain every possible combinations of 'location' and 'time'
(i.e. even missing rows should be filled present but filled with NaN).
So if the dataframe has 10 locations and 5 time points, it should have
50 rows (10 x 5). If formula is None, the dataframe should contain
the response variable 'Y' as the first column. Note that the covariate
columns cannot contain NaN values, but the response variable can.</p>
</dd>
<dt><code>spatial_positions_df</code></dt><dd><p>data.table: Spatial kernel input tensor used
to calculate covariates' distance. Vector of length equal to the number of location points.</p>
</dd>
<dt><code>temporal_positions_df</code></dt><dd><p>data.table: Temporal kernel input tensor used to
calculate covariate distance. Vector of length equal to the number of time points.</p>
</dd>
<dt><code>rank_decomp</code></dt><dd><p>Integer: Rank of the CP decomposition (Paper &ndash; <code class="reqn">R</code>). Defaults to 10.</p>
</dd>
<dt><code>burn_in_iter</code></dt><dd><p>Integer: Number of iteration before sampling (Paper &ndash; <code class="reqn">K_1</code>). Defaults to 500.</p>
</dd>
<dt><code>sampling_iter</code></dt><dd><p>Integer: Number of sampling iterations (Paper &ndash; <code class="reqn">K_2</code>). Defaults to 500.</p>
</dd>
<dt><code>formula</code></dt><dd><p>A Wilkinson R formula to specify the relation
between the response variable 'Y' and the covariates. If Null, the first
column of the data frame will be used as the response variable and all the
other columns will be used as the covariates.  Defaults to Null.</p>
</dd>
<dt><code>spatial_kernel</code></dt><dd><p>Kernel: Spatial kernel Used. Defaults to
a KernelMatern(smoothness_factor=3).</p>
</dd>
<dt><code>temporal_kernel</code></dt><dd><p>Kernel: Temporal kernel used. Defaults to KernelSE().</p>
</dd>
<dt><code>sigma_r</code></dt><dd><p>Numeric:  Variance of the white noise process (<code class="reqn">\tau^{-1}</code>)
defaults to 1E-2.</p>
</dd>
<dt><code>a_0</code></dt><dd><p>Numeric: Initial value for the shape (<code class="reqn">\alpha</code>) in the gamma function
generating tau defaults to 1E-6.</p>
</dd>
<dt><code>b_0</code></dt><dd><p>Numeric: Initial value for the rate (<code class="reqn">\beta</code>) in the gamma function
generating tau defaults to 1E-6.</p>
</dd>
<dt><code>has_geo_coords</code></dt><dd><p>Boolean: Whether the spatial positions df use geographic coordinates
(latitude, longitude). Defaults to TRUE.</p>
</dd>
<dt><code>geo_coords_scale</code></dt><dd><p>Numeric: Scale factor to convert geographic coordinates to euclidean
2D space via Mercator projection using x &amp; y domains of [-scale/2, +scale/2]. Only used if
has_geo_coords is TRUE. Defaults to 10.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>BKTRRegressor</code> object.
</p>


<hr>
<a id="method-BKTRRegressor-mcmc_sampling"></a>



<h4>Method <code>mcmc_sampling()</code></h4>

<p>Launch the MCMC sampling process. <br />
For a predefined number of iterations:
</p>

<ol>
<li><p>Sample spatial kernel hyperparameters
</p>
</li>
<li><p>Sample temporal kernel hyperparameters
</p>
</li>
<li><p>Sample the precision matrix from a wishart distribution
</p>
</li>
<li><p>Sample a new spatial covariate decomposition
</p>
</li>
<li><p>Sample a new feature covariate decomposition
</p>
</li>
<li><p>Sample a new temporal covariate decomposition
</p>
</li>
<li><p>Calculate respective errors for the iterations
</p>
</li>
<li><p>Sample a new tau value
</p>
</li>
<li><p>Collect all the important data for the iteration
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>BKTRRegressor$mcmc_sampling()</pre></div>



<h5>Returns</h5>

<p>NULL Results are stored and can be accessed via summary()
</p>


<hr>
<a id="method-BKTRRegressor-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Use interpolation to predict betas and response values for new data.
</p>


<h5>Usage</h5>

<div class="r"><pre>BKTRRegressor$predict(
  new_data_df,
  new_spatial_positions_df = NULL,
  new_temporal_positions_df = NULL,
  jitter = 1e-05
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_data_df</code></dt><dd><p>data.table: New covariates. Must have the same columns as
the covariates used to fit the model. The index should contain the combination
of all old spatial coordinates with all new temporal coordinates, the combination
of all new spatial coordinates with all old temporal coordinates, and the
combination of all new spatial coordinates with all new temporal coordinates.</p>
</dd>
<dt><code>new_spatial_positions_df</code></dt><dd><p>data.table or NULL: A data frame containing the new
spatial positions. Defaults to NULL.</p>
</dd>
<dt><code>new_temporal_positions_df</code></dt><dd><p>data.table or NULL: A data frame containing the new
temporal positions. Defaults to NULL.</p>
</dd>
<dt><code>jitter</code></dt><dd><p>Numeric or NULL: A small value to add to the diagonal of the precision matrix.
Defaults to NULL.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List: A list of two dataframes. The first represents the beta
forecasted for all new spatial locations or temporal points.
The second represents the forecasted response for all new spatial
locations or temporal points.
</p>


<hr>
<a id="method-BKTRRegressor-get_iterations_betas"></a>



<h4>Method <code>get_iterations_betas()</code></h4>

<p>Return all sampled betas through sampling iterations for a given
set of spatial, temporal and feature labels. Useful for plotting the
distribution of sampled beta values.
</p>


<h5>Usage</h5>

<div class="r"><pre>BKTRRegressor$get_iterations_betas(
  spatial_label,
  temporal_label,
  feature_label
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>spatial_label</code></dt><dd><p>String: The spatial label for which we want to get the betas</p>
</dd>
<dt><code>temporal_label</code></dt><dd><p>String: The temporal label for which we want to get the betas</p>
</dd>
<dt><code>feature_label</code></dt><dd><p>String: The feature label for which we want to get the betas</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list containing the sampled betas through iteration for the given labels
</p>


<hr>
<a id="method-BKTRRegressor-get_beta_summary_df"></a>



<h4>Method <code>get_beta_summary_df()</code></h4>

<p>Get a summary of estimated beta values. If no labels are given,
then the summary is for all the betas. If labels are given, then the summary
is for the given labels.
</p>


<h5>Usage</h5>

<div class="r"><pre>BKTRRegressor$get_beta_summary_df(
  spatial_labels = NULL,
  temporal_labels = NULL,
  feature_labels = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>spatial_labels</code></dt><dd><p>vector: The spatial labels used in summary. If NULL,
then all spatial labels are used. Defaults to NULL.</p>
</dd>
<dt><code>temporal_labels</code></dt><dd><p>vector: The temporal labels used in summary. If NULL,
then all temporal labels are used. Defaults to NULL.</p>
</dd>
<dt><code>feature_labels</code></dt><dd><p>vector: The feature labels used in summary. If NULL,
then all feature labels are used. Defaults to NULL.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new data.table with the beta summary for the given labels.
</p>


<hr>
<a id="method-BKTRRegressor-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BKTRRegressor$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# Create a BIXI data collection instance containing multiple dataframes
bixi_data &lt;- BixiData$new(is_light = TRUE) # Use light version for example

# Create a BKTRRegressor instance
bktr_regressor &lt;- BKTRRegressor$new(
  formula = nb_departure ~ 1 + mean_temp_c + area_park,
  data_df &lt;- bixi_data$data_df,
  spatial_positions_df = bixi_data$spatial_positions_df,
  temporal_positions_df = bixi_data$temporal_positions_df,
  burn_in_iter = 5, sampling_iter = 10) # For example only (too few iterations)

# Launch the MCMC sampling
bktr_regressor$mcmc_sampling()

# Get the summary of the bktr regressor
summary(bktr_regressor)

# Get estimated response variables for missing values
bktr_regressor$imputed_y_estimates

# Get the list of sampled betas for given spatial, temporal and feature labels
bktr_regressor$get_iterations_betas(
  spatial_label = bixi_data$spatial_positions_df$location[1],
  temporal_label = bixi_data$temporal_positions_df$time[1],
  feature_label = 'mean_temp_c')

# Get the summary of all betas for the 'mean_temp_c' feature
bktr_regressor$get_beta_summary_df(feature_labels = 'mean_temp_c')


## PREDICTION EXAMPLE ##
# Create a light version of the BIXI data collection instance
bixi_data &lt;- BixiData$new(is_light = TRUE)
# Simplify variable names
data_df &lt;- bixi_data$data_df
spa_pos_df &lt;- bixi_data$spatial_positions_df
temp_pos_df &lt;- bixi_data$temporal_positions_df

# Keep some data aside for prediction
new_spa_pos_df &lt;- spa_pos_df[1:2, ]
new_temp_pos_df &lt;- temp_pos_df[1:5, ]
reg_spa_pos_df &lt;- spa_pos_df[-(1:2), ]
reg_temp_pos_df &lt;- temp_pos_df[-(1:5), ]
reg_data_df_mask &lt;- data_df$location %in% reg_spa_pos_df$location &amp;
  data_df$time %in% reg_temp_pos_df$time
reg_data_df &lt;- data_df[reg_data_df_mask, ]
new_data_df &lt;- data_df[!reg_data_df_mask, ]

# Launch mcmc sampling on regression data
bktr_regressor &lt;- BKTRRegressor$new(
  formula = nb_departure ~ 1 + mean_temp_c + area_park,
  data_df = reg_data_df,
  spatial_positions_df = reg_spa_pos_df,
  temporal_positions_df = reg_temp_pos_df,
  burn_in_iter = 5, sampling_iter = 10) # For example only (too few iterations)
bktr_regressor$mcmc_sampling()

# Predict response values for new data
bktr_regressor$predict(
  new_data_df = new_data_df,
  new_spatial_positions_df = new_spa_pos_df,
  new_temporal_positions_df = new_temp_pos_df)

</code></pre>

<hr>
<h2 id='CompositionOps'>Kernel Composition Operations</h2><span id='topic+CompositionOps'></span>

<h3>Description</h3>

<p>Kernel Composition Operations Enum. Possibilities of operation between
two kernels to generate a new composed kernel. The values are: <code>MUL</code> and <code>ADD</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompositionOps
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='Kernel'>Base R6 class for Kernels</h2><span id='topic+Kernel'></span>

<h3>Description</h3>

<p>Abstract base class for kernels (Should not be instantiated)
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>kernel_variance</code></dt><dd><p>The variance of the kernel</p>
</dd>
<dt><code>jitter_value</code></dt><dd><p>The jitter value to add to the kernel matrix</p>
</dd>
<dt><code>distance_matrix</code></dt><dd><p>The distance matrix between points in a tensor format</p>
</dd>
<dt><code>name</code></dt><dd><p>The kernel's name</p>
</dd>
<dt><code>parameters</code></dt><dd><p>The parameters of the kernel (list of <code>KernelParameter</code>)</p>
</dd>
<dt><code>covariance_matrix</code></dt><dd><p>The covariance matrix of the kernel in a tensor format</p>
</dd>
<dt><code>positions_df</code></dt><dd><p>The positions of the points in a dataframe format</p>
</dd>
<dt><code>has_dist_matrix</code></dt><dd><p>Identify if the kernel has a distance matrix or not</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Kernel-new"><code>Kernel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Kernel-core_kernel_fn"><code>Kernel$core_kernel_fn()</code></a>
</p>
</li>
<li> <p><a href="#method-Kernel-add_jitter_to_kernel"><code>Kernel$add_jitter_to_kernel()</code></a>
</p>
</li>
<li> <p><a href="#method-Kernel-kernel_gen"><code>Kernel$kernel_gen()</code></a>
</p>
</li>
<li> <p><a href="#method-Kernel-set_positions"><code>Kernel$set_positions()</code></a>
</p>
</li>
<li> <p><a href="#method-Kernel-plot"><code>Kernel$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-Kernel-clone"><code>Kernel$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Kernel-new"></a>



<h4>Method <code>new()</code></h4>

<p>Kernel abstract base constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>Kernel$new(kernel_variance, jitter_value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>kernel_variance</code></dt><dd><p>Numeric: The variance of the kernel</p>
</dd>
<dt><code>jitter_value</code></dt><dd><p>Numeric: The jitter value to add to the kernel matrix</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Kernel</code> object.
</p>


<hr>
<a id="method-Kernel-core_kernel_fn"></a>



<h4>Method <code>core_kernel_fn()</code></h4>

<p>Abstract method to compute the core kernel's covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>Kernel$core_kernel_fn()</pre></div>


<hr>
<a id="method-Kernel-add_jitter_to_kernel"></a>



<h4>Method <code>add_jitter_to_kernel()</code></h4>

<p>Method to add jitter to the kernel's covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>Kernel$add_jitter_to_kernel()</pre></div>


<hr>
<a id="method-Kernel-kernel_gen"></a>



<h4>Method <code>kernel_gen()</code></h4>

<p>Method to compute the kernel's covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>Kernel$kernel_gen()</pre></div>


<hr>
<a id="method-Kernel-set_positions"></a>



<h4>Method <code>set_positions()</code></h4>

<p>Method to set the kernel's positions and compute the distance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>Kernel$set_positions(positions_df)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>positions_df</code></dt><dd><p>Dataframe: The positions of the points in a dataframe format</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Kernel-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Method to plot the kernel's covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>Kernel$plot(show_figure = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>show_figure</code></dt><dd><p>Boolean: If TRUE, the figure is shown, otherwise it is returned</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If <code>show_figure</code> is TRUE, the figure is shown, otherwise it is returned
</p>


<hr>
<a id="method-Kernel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Kernel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='KernelAddComposed'>R6 class for Kernels Composed via Addition</h2><span id='topic+KernelAddComposed'></span>

<h3>Description</h3>

<p>R6 class automatically generated when
adding two kernels together.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Kernel">BKTR::Kernel</a></code> -&gt; <code><a href="#topic+KernelComposed">BKTR::KernelComposed</a></code> -&gt; <code>KernelAddComposed</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-KernelAddComposed-new"><code>KernelAddComposed$new()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelAddComposed-clone"><code>KernelAddComposed$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="add_jitter_to_kernel"><a href='../../BKTR/html/Kernel.html#method-Kernel-add_jitter_to_kernel'><code>BKTR::Kernel$add_jitter_to_kernel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="kernel_gen"><a href='../../BKTR/html/Kernel.html#method-Kernel-kernel_gen'><code>BKTR::Kernel$kernel_gen()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="plot"><a href='../../BKTR/html/Kernel.html#method-Kernel-plot'><code>BKTR::Kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="KernelComposed" data-id="core_kernel_fn"><a href='../../BKTR/html/KernelComposed.html#method-KernelComposed-core_kernel_fn'><code>BKTR::KernelComposed$core_kernel_fn()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="KernelComposed" data-id="set_positions"><a href='../../BKTR/html/KernelComposed.html#method-KernelComposed-set_positions'><code>BKTR::KernelComposed$set_positions()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-KernelAddComposed-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>KernelAddComposed</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelAddComposed$new(left_kernel, right_kernel, new_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>left_kernel</code></dt><dd><p>Kernel: The left kernel to use for composition</p>
</dd>
<dt><code>right_kernel</code></dt><dd><p>Kernel: The right kernel to use for composition</p>
</dd>
<dt><code>new_name</code></dt><dd><p>String: The name of the composed kernel</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>KernelAddComposed</code> object.
</p>


<hr>
<a id="method-KernelAddComposed-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelAddComposed$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# Create a new additive kernel
k_rq_plus_per &lt;- KernelAddComposed$new(
  left_kernel = KernelRQ$new(),
  right_kernel = KernelPeriodic$new(),
  new_name = 'SE + Periodic Kernel'
)
# Set the kernel's positions
positions_df &lt;- data.frame(x=c(-4, 0, 3), y=c(-2, 0, 2))
k_rq_plus_per$set_positions(positions_df)
# Generate the kernel's covariance matrix
k_rq_plus_per$kernel_gen()

</code></pre>

<hr>
<h2 id='KernelComposed'>R6 class for Composed Kernels</h2><span id='topic+KernelComposed'></span>

<h3>Description</h3>

<p>R6 class for Composed Kernels
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Kernel">BKTR::Kernel</a></code> -&gt; <code>KernelComposed</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>The kernel's name</p>
</dd>
<dt><code>parameters</code></dt><dd><p>The parameters of the kernel (list of <code>KernelParameter</code>)</p>
</dd>
<dt><code>left_kernel</code></dt><dd><p>The left kernel to use for composition</p>
</dd>
<dt><code>right_kernel</code></dt><dd><p>The right kernel to use for composition</p>
</dd>
<dt><code>composition_operation</code></dt><dd><p>The operation to use for composition</p>
</dd>
<dt><code>has_dist_matrix</code></dt><dd><p>Identify if the kernel has a distance matrix or not</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-KernelComposed-new"><code>KernelComposed$new()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelComposed-core_kernel_fn"><code>KernelComposed$core_kernel_fn()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelComposed-set_positions"><code>KernelComposed$set_positions()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelComposed-clone"><code>KernelComposed$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="add_jitter_to_kernel"><a href='../../BKTR/html/Kernel.html#method-Kernel-add_jitter_to_kernel'><code>BKTR::Kernel$add_jitter_to_kernel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="kernel_gen"><a href='../../BKTR/html/Kernel.html#method-Kernel-kernel_gen'><code>BKTR::Kernel$kernel_gen()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="plot"><a href='../../BKTR/html/Kernel.html#method-Kernel-plot'><code>BKTR::Kernel$plot()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-KernelComposed-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>KernelComposed</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelComposed$new(left_kernel, right_kernel, new_name, composition_operation)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>left_kernel</code></dt><dd><p>Kernel: The left kernel to use for composition</p>
</dd>
<dt><code>right_kernel</code></dt><dd><p>Kernel: The right kernel to use for composition</p>
</dd>
<dt><code>new_name</code></dt><dd><p>String: The name of the composed kernel</p>
</dd>
<dt><code>composition_operation</code></dt><dd><p>CompositionOps: The operation to use for composition</p>
</dd>
</dl>

</div>


<hr>
<a id="method-KernelComposed-core_kernel_fn"></a>



<h4>Method <code>core_kernel_fn()</code></h4>

<p>Method to compute the core kernel's covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelComposed$core_kernel_fn()</pre></div>



<h5>Returns</h5>

<p>The core kernel's covariance matrix
</p>


<hr>
<a id="method-KernelComposed-set_positions"></a>



<h4>Method <code>set_positions()</code></h4>

<p>Method to set the kernel's positions and compute the distance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelComposed$set_positions(positions_df)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>positions_df</code></dt><dd><p>Dataframe: The positions of the points in a dataframe format</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL, set the kernel's positions and compute the distance matrix
</p>


<hr>
<a id="method-KernelComposed-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelComposed$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# Create a new locally periodic kernel
k_loc_per &lt;- KernelComposed$new(
  left_kernel = KernelSE$new(),
  right_kernel = KernelPeriodic$new(),
  new_name = 'Locally Periodic Kernel',
  composition_operation = CompositionOps$MUL
)
# Set the kernel's positions
positions_df &lt;- data.frame(x=c(-4, 0, 3), y=c(-2, 0, 2))
k_loc_per$set_positions(positions_df)
# Generate the kernel's covariance matrix
k_loc_per$kernel_gen()

</code></pre>

<hr>
<h2 id='KernelMatern'>R6 class for Matern Kernels</h2><span id='topic+KernelMatern'></span>

<h3>Description</h3>

<p>R6 class for Matern Kernels
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Kernel">BKTR::Kernel</a></code> -&gt; <code>KernelMatern</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>lengthscale</code></dt><dd><p>The lengthscale parameter instance of the kernel</p>
</dd>
<dt><code>smoothness_factor</code></dt><dd><p>The smoothness factor of the kernel</p>
</dd>
<dt><code>has_dist_matrix</code></dt><dd><p>Identify if the kernel has a distance matrix or not</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-KernelMatern-new"><code>KernelMatern$new()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelMatern-get_smoothness_kernel_fn"><code>KernelMatern$get_smoothness_kernel_fn()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelMatern-core_kernel_fn"><code>KernelMatern$core_kernel_fn()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelMatern-clone"><code>KernelMatern$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="add_jitter_to_kernel"><a href='../../BKTR/html/Kernel.html#method-Kernel-add_jitter_to_kernel'><code>BKTR::Kernel$add_jitter_to_kernel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="kernel_gen"><a href='../../BKTR/html/Kernel.html#method-Kernel-kernel_gen'><code>BKTR::Kernel$kernel_gen()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="plot"><a href='../../BKTR/html/Kernel.html#method-Kernel-plot'><code>BKTR::Kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="set_positions"><a href='../../BKTR/html/Kernel.html#method-Kernel-set_positions'><code>BKTR::Kernel$set_positions()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-KernelMatern-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>KernelMatern</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelMatern$new(
  smoothness_factor = 5,
  lengthscale = KernelParameter$new(2),
  kernel_variance = 1,
  jitter_value = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>smoothness_factor</code></dt><dd><p>Numeric: The smoothness factor of the kernel (1, 3 or 5)</p>
</dd>
<dt><code>lengthscale</code></dt><dd><p>KernelParameter: The lengthscale parameter instance of the kernel</p>
</dd>
<dt><code>kernel_variance</code></dt><dd><p>Numeric: The variance of the kernel</p>
</dd>
<dt><code>jitter_value</code></dt><dd><p>Numeric: The jitter value to add to the kernel matrix</p>
</dd>
</dl>

</div>


<hr>
<a id="method-KernelMatern-get_smoothness_kernel_fn"></a>



<h4>Method <code>get_smoothness_kernel_fn()</code></h4>

<p>Method to the get the smoothness kernel function for a given integer smoothness factor
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelMatern$get_smoothness_kernel_fn()</pre></div>



<h5>Returns</h5>

<p>The smoothness kernel function
</p>


<hr>
<a id="method-KernelMatern-core_kernel_fn"></a>



<h4>Method <code>core_kernel_fn()</code></h4>

<p>Method to compute the core kernel's covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelMatern$core_kernel_fn()</pre></div>



<h5>Returns</h5>

<p>The core kernel's covariance matrix
</p>


<hr>
<a id="method-KernelMatern-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelMatern$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# Create a new Matern 3/2 kernel
k_matern &lt;- KernelMatern$new(smoothness_factor = 3)
# Set the kernel's positions
positions_df &lt;- data.frame(x=c(-4, 0, 3), y=c(-2, 0, 2))
k_matern$set_positions(positions_df)
# Generate the kernel's covariance matrix
k_matern$kernel_gen()

</code></pre>

<hr>
<h2 id='KernelMulComposed'>R6 class for Kernels Composed via Multiplication</h2><span id='topic+KernelMulComposed'></span>

<h3>Description</h3>

<p>R6 class automatically generated when
multiplying two kernels together.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Kernel">BKTR::Kernel</a></code> -&gt; <code><a href="#topic+KernelComposed">BKTR::KernelComposed</a></code> -&gt; <code>KernelMulComposed</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-KernelMulComposed-new"><code>KernelMulComposed$new()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelMulComposed-clone"><code>KernelMulComposed$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="add_jitter_to_kernel"><a href='../../BKTR/html/Kernel.html#method-Kernel-add_jitter_to_kernel'><code>BKTR::Kernel$add_jitter_to_kernel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="kernel_gen"><a href='../../BKTR/html/Kernel.html#method-Kernel-kernel_gen'><code>BKTR::Kernel$kernel_gen()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="plot"><a href='../../BKTR/html/Kernel.html#method-Kernel-plot'><code>BKTR::Kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="KernelComposed" data-id="core_kernel_fn"><a href='../../BKTR/html/KernelComposed.html#method-KernelComposed-core_kernel_fn'><code>BKTR::KernelComposed$core_kernel_fn()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="KernelComposed" data-id="set_positions"><a href='../../BKTR/html/KernelComposed.html#method-KernelComposed-set_positions'><code>BKTR::KernelComposed$set_positions()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-KernelMulComposed-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>KernelMulComposed</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelMulComposed$new(left_kernel, right_kernel, new_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>left_kernel</code></dt><dd><p>Kernel: The left kernel to use for composition</p>
</dd>
<dt><code>right_kernel</code></dt><dd><p>Kernel: The right kernel to use for composition</p>
</dd>
<dt><code>new_name</code></dt><dd><p>String: The name of the composed kernel</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>KernelMulComposed</code> object.
</p>


<hr>
<a id="method-KernelMulComposed-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelMulComposed$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# Create a new locally periodic kernel
k_loc_per &lt;- KernelMulComposed$new(
  left_kernel = KernelSE$new(),
  right_kernel = KernelPeriodic$new(),
  new_name = 'Locally Periodic Kernel'
)
# Set the kernel's positions
positions_df &lt;- data.frame(x=c(-4, 0, 3), y=c(-2, 0, 2))
k_loc_per$set_positions(positions_df)
# Generate the kernel's covariance matrix
k_loc_per$kernel_gen()

</code></pre>

<hr>
<h2 id='KernelParameter'>R6 class for kernel's hyperparameter</h2><span id='topic+KernelParameter'></span>

<h3>Description</h3>

<p>KernelParameter contains all information and behaviour related to a kernel parameters.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>value</code></dt><dd><p>The hyperparameter mean's prior value or its constant value</p>
</dd>
<dt><code>is_fixed</code></dt><dd><p>Says if the kernel parameter is fixed or not (if fixed, there is no sampling)</p>
</dd>
<dt><code>lower_bound</code></dt><dd><p>The hyperparameter's minimal value during sampling</p>
</dd>
<dt><code>upper_bound</code></dt><dd><p>The hyperparameter's maximal value during sampling</p>
</dd>
<dt><code>slice_sampling_scale</code></dt><dd><p>The sampling range's amplitude</p>
</dd>
<dt><code>hparam_precision</code></dt><dd><p>Precision of the hyperparameter</p>
</dd>
<dt><code>kernel</code></dt><dd><p>The kernel associated with the parameter (it is set at kernel instanciation)</p>
</dd>
<dt><code>name</code></dt><dd><p>The kernel parameter's name</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>full_name</code></dt><dd><p>The kernel parameter's full name</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NA-new"><code>KernelParameter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NA-set_kernel"><code>KernelParameter$set_kernel()</code></a>
</p>
</li>
<li> <p><a href="#method-unknown-clone"><code>KernelParameter$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-NA-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>KernelParameter</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelParameter$new(
  value,
  is_fixed = FALSE,
  lower_bound = DEFAULT_LBOUND,
  upper_bound = DEFAULT_UBOUND,
  slice_sampling_scale = log(10),
  hparam_precision = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>Numeric: The hyperparameter mean's prior value (Paper - <code class="reqn">\phi</code>) or its constant value</p>
</dd>
<dt><code>is_fixed</code></dt><dd><p>Boolean: Says if the kernel parameter is fixed or not (if fixed, there is no sampling)</p>
</dd>
<dt><code>lower_bound</code></dt><dd><p>Numeric: Hyperparameter's minimal value during sampling (Paper - <code class="reqn">\phi_{min}</code>)</p>
</dd>
<dt><code>upper_bound</code></dt><dd><p>Numeric: Hyperparameter's maximal value during sampling (Paper - <code class="reqn">\phi_{max}</code>)</p>
</dd>
<dt><code>slice_sampling_scale</code></dt><dd><p>Numeric: The sampling range's amplitude (Paper - <code class="reqn">\rho</code>)</p>
</dd>
<dt><code>hparam_precision</code></dt><dd><p>Numeric: The hyperparameter's precision</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>KernelParameter</code> object.
</p>


<hr>
<a id="method-NA-set_kernel"></a>



<h4>Method <code>set_kernel()</code></h4>

<p>Set <code>Kernel</code> for a given <code>KernelParameter</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelParameter$set_kernel(kernel, param_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>kernel</code></dt><dd><p>Kernel: The kernel to associate with the parameter</p>
</dd>
<dt><code>param_name</code></dt><dd><p>String: The parameter's name</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL, set a new kernel for the parameter
</p>


<hr>
<a id="method-unknown-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelParameter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# A kernel parameter can be a constant value
const_param &lt;- KernelParameter$new(7, is_fixed = TRUE)
# It can otherwise be sampled and have its value updated through sampling
samp_param &lt;- KernelParameter$new(1, lower_bound = 0.1,
  upper_bound = 10, slice_sampling_scale = 4)

# A kernel parameter can be associated with any type of kernel
KernelPeriodic$new(period_length = const_param, lengthscale = samp_param)

</code></pre>

<hr>
<h2 id='KernelPeriodic'>R6 class for Periodic Kernels</h2><span id='topic+KernelPeriodic'></span>

<h3>Description</h3>

<p>R6 class for Periodic Kernels
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Kernel">BKTR::Kernel</a></code> -&gt; <code>KernelPeriodic</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>lengthscale</code></dt><dd><p>The lengthscale parameter instance of the kernel</p>
</dd>
<dt><code>period_length</code></dt><dd><p>The period length parameter instance of the kernel</p>
</dd>
<dt><code>has_dist_matrix</code></dt><dd><p>Identify if the kernel has a distance matrix or not</p>
</dd>
<dt><code>name</code></dt><dd><p>The kernel's name</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-KernelPeriodic-new"><code>KernelPeriodic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelPeriodic-core_kernel_fn"><code>KernelPeriodic$core_kernel_fn()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelPeriodic-clone"><code>KernelPeriodic$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="add_jitter_to_kernel"><a href='../../BKTR/html/Kernel.html#method-Kernel-add_jitter_to_kernel'><code>BKTR::Kernel$add_jitter_to_kernel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="kernel_gen"><a href='../../BKTR/html/Kernel.html#method-Kernel-kernel_gen'><code>BKTR::Kernel$kernel_gen()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="plot"><a href='../../BKTR/html/Kernel.html#method-Kernel-plot'><code>BKTR::Kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="set_positions"><a href='../../BKTR/html/Kernel.html#method-Kernel-set_positions'><code>BKTR::Kernel$set_positions()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-KernelPeriodic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>KernelPeriodic</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelPeriodic$new(
  lengthscale = KernelParameter$new(2),
  period_length = KernelParameter$new(2),
  kernel_variance = 1,
  jitter_value = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lengthscale</code></dt><dd><p>KernelParameter: The lengthscale parameter instance of the kernel</p>
</dd>
<dt><code>period_length</code></dt><dd><p>KernelParameter: The period length parameter instance of the kernel</p>
</dd>
<dt><code>kernel_variance</code></dt><dd><p>Numeric: The variance of the kernel</p>
</dd>
<dt><code>jitter_value</code></dt><dd><p>Numeric: The jitter value to add to the kernel matrix</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>KernelPeriodic</code> object.
</p>


<hr>
<a id="method-KernelPeriodic-core_kernel_fn"></a>



<h4>Method <code>core_kernel_fn()</code></h4>

<p>Method to compute the core kernel's covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelPeriodic$core_kernel_fn()</pre></div>



<h5>Returns</h5>

<p>The core kernel's covariance matrix
</p>


<hr>
<a id="method-KernelPeriodic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelPeriodic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# Create a new Periodic kernel
k_periodic &lt;- KernelPeriodic$new()
# Set the kernel's positions
positions_df &lt;- data.frame(x=c(-4, 0, 3), y=c(-2, 0, 2))
k_periodic$set_positions(positions_df)
# Generate the kernel's covariance matrix
k_periodic$kernel_gen()

</code></pre>

<hr>
<h2 id='KernelRQ'>R6 class for Rational Quadratic Kernels</h2><span id='topic+KernelRQ'></span>

<h3>Description</h3>

<p>R6 class for Rational Quadratic Kernels
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Kernel">BKTR::Kernel</a></code> -&gt; <code>KernelRQ</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>lengthscale</code></dt><dd><p>The lengthscale parameter instance of the kernel</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The alpha parameter instance of the kernel</p>
</dd>
<dt><code>has_dist_matrix</code></dt><dd><p>The distance matrix between points in a tensor format</p>
</dd>
<dt><code>name</code></dt><dd><p>The kernel's name</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-KernelRQ-new"><code>KernelRQ$new()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelRQ-core_kernel_fn"><code>KernelRQ$core_kernel_fn()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelRQ-clone"><code>KernelRQ$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="add_jitter_to_kernel"><a href='../../BKTR/html/Kernel.html#method-Kernel-add_jitter_to_kernel'><code>BKTR::Kernel$add_jitter_to_kernel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="kernel_gen"><a href='../../BKTR/html/Kernel.html#method-Kernel-kernel_gen'><code>BKTR::Kernel$kernel_gen()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="plot"><a href='../../BKTR/html/Kernel.html#method-Kernel-plot'><code>BKTR::Kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="set_positions"><a href='../../BKTR/html/Kernel.html#method-Kernel-set_positions'><code>BKTR::Kernel$set_positions()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-KernelRQ-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>KernelRQ</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelRQ$new(
  lengthscale = KernelParameter$new(2),
  alpha = KernelParameter$new(2),
  kernel_variance = 1,
  jitter_value = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lengthscale</code></dt><dd><p>KernelParameter: The lengthscale parameter instance of the kernel</p>
</dd>
<dt><code>alpha</code></dt><dd><p>KernelParameter: The alpha parameter instance of the kernel</p>
</dd>
<dt><code>kernel_variance</code></dt><dd><p>Numeric: The variance of the kernel</p>
</dd>
<dt><code>jitter_value</code></dt><dd><p>Numeric: The jitter value to add to the kernel matrix</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>KernelRQ</code> object.
</p>


<hr>
<a id="method-KernelRQ-core_kernel_fn"></a>



<h4>Method <code>core_kernel_fn()</code></h4>

<p>Method to compute the core kernel's covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelRQ$core_kernel_fn()</pre></div>



<h5>Returns</h5>

<p>The core kernel's covariance matrix
</p>


<hr>
<a id="method-KernelRQ-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelRQ$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# Create a new RQ kernel
k_rq &lt;- KernelRQ$new()
# Set the kernel's positions
positions_df &lt;- data.frame(x=c(-4, 0, 3), y=c(-2, 0, 2))
k_rq$set_positions(positions_df)
# Generate the kernel's covariance matrix
k_rq$kernel_gen()

</code></pre>

<hr>
<h2 id='KernelSE'>R6 class for Square Exponential Kernels</h2><span id='topic+KernelSE'></span>

<h3>Description</h3>

<p>R6 class for Square Exponential Kernels
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Kernel">BKTR::Kernel</a></code> -&gt; <code>KernelSE</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>lengthscale</code></dt><dd><p>The lengthscale parameter instance of the kernel</p>
</dd>
<dt><code>has_dist_matrix</code></dt><dd><p>Identify if the kernel has a distance matrix or not</p>
</dd>
<dt><code>name</code></dt><dd><p>The kernel's name</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-KernelSE-new"><code>KernelSE$new()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelSE-core_kernel_fn"><code>KernelSE$core_kernel_fn()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelSE-clone"><code>KernelSE$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="add_jitter_to_kernel"><a href='../../BKTR/html/Kernel.html#method-Kernel-add_jitter_to_kernel'><code>BKTR::Kernel$add_jitter_to_kernel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="kernel_gen"><a href='../../BKTR/html/Kernel.html#method-Kernel-kernel_gen'><code>BKTR::Kernel$kernel_gen()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="plot"><a href='../../BKTR/html/Kernel.html#method-Kernel-plot'><code>BKTR::Kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="set_positions"><a href='../../BKTR/html/Kernel.html#method-Kernel-set_positions'><code>BKTR::Kernel$set_positions()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-KernelSE-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>KernelSE</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelSE$new(
  lengthscale = KernelParameter$new(2),
  kernel_variance = 1,
  jitter_value = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lengthscale</code></dt><dd><p>KernelParameter: The lengthscale parameter instance of the kernel</p>
</dd>
<dt><code>kernel_variance</code></dt><dd><p>Numeric: The variance of the kernel</p>
</dd>
<dt><code>jitter_value</code></dt><dd><p>Numeric: The jitter value to add to the kernel matrix</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>KernelSE</code> object.
</p>


<hr>
<a id="method-KernelSE-core_kernel_fn"></a>



<h4>Method <code>core_kernel_fn()</code></h4>

<p>Method to compute the core kernel's covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelSE$core_kernel_fn()</pre></div>



<h5>Returns</h5>

<p>The core kernel's covariance matrix
</p>


<hr>
<a id="method-KernelSE-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelSE$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# Create a new SE kernel
k_se &lt;- KernelSE$new()
# Set the kernel's positions
positions_df &lt;- data.frame(x=c(-4, 0, 3), y=c(-2, 0, 2))
k_se$set_positions(positions_df)
# Generate the kernel's covariance matrix
k_se$kernel_gen()

</code></pre>

<hr>
<h2 id='KernelWhiteNoise'>R6 class for White Noise Kernels</h2><span id='topic+KernelWhiteNoise'></span>

<h3>Description</h3>

<p>R6 class for White Noise Kernels
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Kernel">BKTR::Kernel</a></code> -&gt; <code>KernelWhiteNoise</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>has_dist_matrix</code></dt><dd><p>Identify if the kernel has a distance matrix or not</p>
</dd>
<dt><code>name</code></dt><dd><p>The kernel's name</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-KernelWhiteNoise-new"><code>KernelWhiteNoise$new()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelWhiteNoise-core_kernel_fn"><code>KernelWhiteNoise$core_kernel_fn()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelWhiteNoise-clone"><code>KernelWhiteNoise$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="add_jitter_to_kernel"><a href='../../BKTR/html/Kernel.html#method-Kernel-add_jitter_to_kernel'><code>BKTR::Kernel$add_jitter_to_kernel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="kernel_gen"><a href='../../BKTR/html/Kernel.html#method-Kernel-kernel_gen'><code>BKTR::Kernel$kernel_gen()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="plot"><a href='../../BKTR/html/Kernel.html#method-Kernel-plot'><code>BKTR::Kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="BKTR" data-topic="Kernel" data-id="set_positions"><a href='../../BKTR/html/Kernel.html#method-Kernel-set_positions'><code>BKTR::Kernel$set_positions()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-KernelWhiteNoise-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>KernelWhiteNoise$new(kernel_variance = 1, jitter_value = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>kernel_variance</code></dt><dd><p>Numeric: The variance of the kernel</p>
</dd>
<dt><code>jitter_value</code></dt><dd><p>Numeric: The jitter value to add to the kernel matrix</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>KernelWhiteNoise</code> object.
</p>


<hr>
<a id="method-KernelWhiteNoise-core_kernel_fn"></a>



<h4>Method <code>core_kernel_fn()</code></h4>

<p>Method to compute the core kernel's covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelWhiteNoise$core_kernel_fn()</pre></div>



<h5>Returns</h5>

<p>The core kernel's covariance matrix
</p>


<hr>
<a id="method-KernelWhiteNoise-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelWhiteNoise$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# Create a new white noise kernel
k_white_noise &lt;- KernelWhiteNoise$new()
# Set the kernel's positions
positions_df &lt;- data.frame(x=c(-4, 0, 3), y=c(-2, 0, 2))
k_white_noise$set_positions(positions_df)
# Generate the kernel's covariance matrix
k_white_noise$kernel_gen()

</code></pre>

<hr>
<h2 id='plot_beta_dists'>Plot Beta Coefficients Distribution</h2><span id='topic+plot_beta_dists'></span>

<h3>Description</h3>

<p>Plot the distribution of beta values for a given list of labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_beta_dists(
  bktr_reg,
  labels_list,
  show_figure = TRUE,
  fig_width = 9,
  fig_height = 6,
  fig_resolution = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_beta_dists_+3A_bktr_reg">bktr_reg</code></td>
<td>
<p>BKTRRegressor: BKTRRegressor object.</p>
</td></tr>
<tr><td><code id="plot_beta_dists_+3A_labels_list">labels_list</code></td>
<td>
<p>List: List of labels tuple (spatial, temporal, feature) for
which to plot the beta distribution through iterations</p>
</td></tr>
<tr><td><code id="plot_beta_dists_+3A_show_figure">show_figure</code></td>
<td>
<p>Boolean: Whether to show the figure. Defaults to True.</p>
</td></tr>
<tr><td><code id="plot_beta_dists_+3A_fig_width">fig_width</code></td>
<td>
<p>Integer: Figure width. Defaults to 9.</p>
</td></tr>
<tr><td><code id="plot_beta_dists_+3A_fig_height">fig_height</code></td>
<td>
<p>Integer: Figure height. Defaults to 6.</p>
</td></tr>
<tr><td><code id="plot_beta_dists_+3A_fig_resolution">fig_resolution</code></td>
<td>
<p>Numeric: Figure resolution PPI. Defaults to 200.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot or NULL: ggplot object or NULL if show_figure is set to FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Launch MCMC sampling on a light version of the BIXI dataset
bixi_data &lt;- BixiData$new(is_light = TRUE)
bktr_regressor &lt;- BKTRRegressor$new(
  data_df &lt;- bixi_data$data_df,
  spatial_positions_df = bixi_data$spatial_positions_df,
  temporal_positions_df = bixi_data$temporal_positions_df,
  burn_in_iter = 5, sampling_iter = 10) # For example only (too few iterations)
bktr_regressor$mcmc_sampling()

# Plot temporal beta coefficients for the first station and the first feature
spa_lab &lt;- bixi_data$spatial_positions_df$location[3]
plot_beta_dists(
  bktr_regressor,
  labels_list = list(
     c(spa_lab, '2019-04-15', 'area_park'),
     c(spa_lab, '2019-04-16', 'area_park'),
     c(spa_lab, '2019-04-16', 'mean_temp_c')
  ),
)

</code></pre>

<hr>
<h2 id='plot_covariates_beta_dists'>Plot Beta Coefficients Distribution Regrouped by Covariates</h2><span id='topic+plot_covariates_beta_dists'></span>

<h3>Description</h3>

<p>Plot the distribution of beta estimates regrouped by covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_covariates_beta_dists(
  bktr_reg,
  feature_labels = NULL,
  show_figure = TRUE,
  fig_width = 9,
  fig_height = 6,
  fig_resolution = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_covariates_beta_dists_+3A_bktr_reg">bktr_reg</code></td>
<td>
<p>BKTRRegressor: BKTRRegressor object.</p>
</td></tr>
<tr><td><code id="plot_covariates_beta_dists_+3A_feature_labels">feature_labels</code></td>
<td>
<p>Array or NULL: Array of feature labels for
which to plot the beta estimates distribution. If NULL plot for all features.</p>
</td></tr>
<tr><td><code id="plot_covariates_beta_dists_+3A_show_figure">show_figure</code></td>
<td>
<p>Boolean: Whether to show the figure. Defaults to True.</p>
</td></tr>
<tr><td><code id="plot_covariates_beta_dists_+3A_fig_width">fig_width</code></td>
<td>
<p>Integer: Figure width. Defaults to 9.</p>
</td></tr>
<tr><td><code id="plot_covariates_beta_dists_+3A_fig_height">fig_height</code></td>
<td>
<p>Integer: Figure height. Defaults to 6.</p>
</td></tr>
<tr><td><code id="plot_covariates_beta_dists_+3A_fig_resolution">fig_resolution</code></td>
<td>
<p>Numeric: Figure resolution PPI. Defaults to 200.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot or NULL: ggplot object or NULL if show_figure is set to FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Launch MCMC sampling on a light version of the BIXI dataset
bixi_data &lt;- BixiData$new(is_light = TRUE)
bktr_regressor &lt;- BKTRRegressor$new(
  formula = 'nb_departure ~ 1 + area_park + mean_temp_c + total_precip_mm',
  data_df &lt;- bixi_data$data_df,
  spatial_positions_df = bixi_data$spatial_positions_df,
  temporal_positions_df = bixi_data$temporal_positions_df,
  burn_in_iter = 5, sampling_iter = 10) # For example only (too few iterations)
bktr_regressor$mcmc_sampling()

# Plot beta estimates distribution for all features
plot_covariates_beta_dists(bktr_regressor)
# Or plot for a subset of features
plot_covariates_beta_dists(bktr_regressor, c('area_park', 'mean_temp_c'))

</code></pre>

<hr>
<h2 id='plot_hyperparams_dists'>Plot Hyperparameters Distributions</h2><span id='topic+plot_hyperparams_dists'></span>

<h3>Description</h3>

<p>Plot the distribution of hyperparameters through iterations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hyperparams_dists(
  bktr_reg,
  hyperparameters = NULL,
  show_figure = TRUE,
  fig_width = 9,
  fig_height = 6,
  fig_resolution = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_hyperparams_dists_+3A_bktr_reg">bktr_reg</code></td>
<td>
<p>BKTRRegressor: BKTRRegressor object.</p>
</td></tr>
<tr><td><code id="plot_hyperparams_dists_+3A_hyperparameters">hyperparameters</code></td>
<td>
<p>Array or NULL: Array of hyperparameters to plot.
If NULL, plot all hyperparameters. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="plot_hyperparams_dists_+3A_show_figure">show_figure</code></td>
<td>
<p>Boolean: Whether to show the figure. Defaults to True.</p>
</td></tr>
<tr><td><code id="plot_hyperparams_dists_+3A_fig_width">fig_width</code></td>
<td>
<p>Integer: Figure width. Defaults to 9.</p>
</td></tr>
<tr><td><code id="plot_hyperparams_dists_+3A_fig_height">fig_height</code></td>
<td>
<p>Integer: Figure height. Defaults to 6.</p>
</td></tr>
<tr><td><code id="plot_hyperparams_dists_+3A_fig_resolution">fig_resolution</code></td>
<td>
<p>Numeric: Figure resolution PPI. Defaults to 200.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot or NULL: ggplot object or NULL if show_figure is set to FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Launch MCMC sampling on a light version of the BIXI dataset
bixi_data &lt;- BixiData$new(is_light = TRUE)
k_matern &lt;- KernelMatern$new()
k_periodic &lt;- KernelPeriodic$new()
bktr_regressor &lt;- BKTRRegressor$new(
  data_df &lt;- bixi_data$data_df,
  spatial_kernel = k_matern,
  temporal_kernel = k_periodic,
  spatial_positions_df = bixi_data$spatial_positions_df,
  temporal_positions_df = bixi_data$temporal_positions_df,
  burn_in_iter = 5, sampling_iter = 10) # For example only (too few iterations)
bktr_regressor$mcmc_sampling()

# Plot the distribution of all hyperparameters
plot_hyperparams_dists(bktr_regressor)

# Plot the distribution of the spatial kernel hyperparameters
spa_par_name &lt;- paste0('Spatial - ', k_matern$parameters[[1]]$full_name)
plot_hyperparams_dists(bktr_regressor, spa_par_name)

# Plot the distribution of the temporal kernel hyperparameters
temp_par_names &lt;- sapply(k_periodic$parameters, function(x) x$full_name)
temp_par_names &lt;- paste0('Temporal - ', temp_par_names)
plot_hyperparams_dists(bktr_regressor, temp_par_names)

</code></pre>

<hr>
<h2 id='plot_hyperparams_traceplot'>Plot Hyperparameters Traceplot</h2><span id='topic+plot_hyperparams_traceplot'></span>

<h3>Description</h3>

<p>Plot the evolution of hyperparameters through iterations. (Traceplot)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hyperparams_traceplot(
  bktr_reg,
  hyperparameters = NULL,
  show_figure = TRUE,
  fig_width = 9,
  fig_height = 5.5,
  fig_resolution = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_hyperparams_traceplot_+3A_bktr_reg">bktr_reg</code></td>
<td>
<p>BKTRRegressor: BKTRRegressor object.</p>
</td></tr>
<tr><td><code id="plot_hyperparams_traceplot_+3A_hyperparameters">hyperparameters</code></td>
<td>
<p>Array or NULL: Array of hyperparameters to plot.
If NULL, plot all hyperparameters. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="plot_hyperparams_traceplot_+3A_show_figure">show_figure</code></td>
<td>
<p>Boolean: Whether to show the figure. Defaults to True.</p>
</td></tr>
<tr><td><code id="plot_hyperparams_traceplot_+3A_fig_width">fig_width</code></td>
<td>
<p>Integer: Figure width. Defaults to 9.</p>
</td></tr>
<tr><td><code id="plot_hyperparams_traceplot_+3A_fig_height">fig_height</code></td>
<td>
<p>Integer: Figure height. Defaults to 5.5.</p>
</td></tr>
<tr><td><code id="plot_hyperparams_traceplot_+3A_fig_resolution">fig_resolution</code></td>
<td>
<p>Numeric: Figure resolution PPI. Defaults to 200.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot or NULL: ggplot object or NULL if show_figure is set to FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Launch MCMC sampling on a light version of the BIXI dataset
bixi_data &lt;- BixiData$new(is_light = TRUE)
k_matern &lt;- KernelMatern$new()
k_periodic &lt;- KernelPeriodic$new()
bktr_regressor &lt;- BKTRRegressor$new(
  data_df &lt;- bixi_data$data_df,
  spatial_kernel = k_matern,
  temporal_kernel = k_periodic,
  spatial_positions_df = bixi_data$spatial_positions_df,
  temporal_positions_df = bixi_data$temporal_positions_df,
  burn_in_iter = 5, sampling_iter = 10) # For example only (too few iterations)
bktr_regressor$mcmc_sampling()

# Plot the traceplot of all hyperparameters
plot_hyperparams_traceplot(bktr_regressor)

# Plot the traceplot of the spatial kernel hyperparameters
spa_par_name &lt;- paste0('Spatial - ', k_matern$parameters[[1]]$full_name)
plot_hyperparams_traceplot(bktr_regressor, spa_par_name)

# Plot the traceplot of the temporal kernel hyperparameters
temp_par_names &lt;- sapply(k_periodic$parameters, function(x) x$full_name)
temp_par_names &lt;- paste0('Temporal - ', temp_par_names)
plot_hyperparams_traceplot(bktr_regressor, temp_par_names)

</code></pre>

<hr>
<h2 id='plot_spatial_betas'>Plot Spatial Beta Coefficients</h2><span id='topic+plot_spatial_betas'></span>

<h3>Description</h3>

<p>Create a plot of beta values through space for a given
temporal point and a set of feature labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_spatial_betas(
  bktr_reg,
  plot_feature_labels,
  temporal_point_label,
  nb_cols = 1,
  use_dark_mode = TRUE,
  show_figure = TRUE,
  zoom = 11,
  google_token = NULL,
  fig_width = 8.5,
  fig_height = 5.5,
  fig_resolution = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_spatial_betas_+3A_bktr_reg">bktr_reg</code></td>
<td>
<p>BKTRRegressor: BKTRRegressor object.</p>
</td></tr>
<tr><td><code id="plot_spatial_betas_+3A_plot_feature_labels">plot_feature_labels</code></td>
<td>
<p>Array: Array of feature labels to plot.</p>
</td></tr>
<tr><td><code id="plot_spatial_betas_+3A_temporal_point_label">temporal_point_label</code></td>
<td>
<p>String: Temporal point label to plot.</p>
</td></tr>
<tr><td><code id="plot_spatial_betas_+3A_nb_cols">nb_cols</code></td>
<td>
<p>Integer: The number of columns to use in the facet grid.</p>
</td></tr>
<tr><td><code id="plot_spatial_betas_+3A_use_dark_mode">use_dark_mode</code></td>
<td>
<p>Boolean: Whether to use a dark mode for the geographic map or not.</p>
</td></tr>
<tr><td><code id="plot_spatial_betas_+3A_show_figure">show_figure</code></td>
<td>
<p>Boolean: Whether to show the figure. Defaults to True.</p>
</td></tr>
<tr><td><code id="plot_spatial_betas_+3A_zoom">zoom</code></td>
<td>
<p>Integer: Zoom level for the geographic map. Defaults to 11.</p>
</td></tr>
<tr><td><code id="plot_spatial_betas_+3A_google_token">google_token</code></td>
<td>
<p>String or NULL: Google API token to use for the geographic map. Defaults to NULL.
If NULL, use Stamen maps.</p>
</td></tr>
<tr><td><code id="plot_spatial_betas_+3A_fig_width">fig_width</code></td>
<td>
<p>Numeric: Figure width when figure is shown. Defaults to 8.5.</p>
</td></tr>
<tr><td><code id="plot_spatial_betas_+3A_fig_height">fig_height</code></td>
<td>
<p>Numeric: Figure height when figure is shown. Defaults to 5.5.</p>
</td></tr>
<tr><td><code id="plot_spatial_betas_+3A_fig_resolution">fig_resolution</code></td>
<td>
<p>Numeric: Figure resolution PPI. Defaults to 200.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot or NULL: ggplot object or NULL if show_figure is set to FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Launch MCMC sampling on a light version of the BIXI dataset
bixi_data &lt;- BixiData$new(is_light = TRUE)
bktr_regressor &lt;- BKTRRegressor$new(
  data_df &lt;- bixi_data$data_df,
  spatial_positions_df = bixi_data$spatial_positions_df,
  temporal_positions_df = bixi_data$temporal_positions_df,
  burn_in_iter = 5, sampling_iter = 10) # For example only (too few iterations)
bktr_regressor$mcmc_sampling()

# Plot spatial beta coefficients for the first time point and the two features
plot_spatial_betas(
  bktr_regressor,
  plot_feature_labels = c('mean_temp_c', 'area_park'),
  temporal_point_label = bixi_data$temporal_positions_df$time[1])

# We can also use light mode and plot the maps side by side
plot_spatial_betas(
  bktr_regressor,
  plot_feature_labels = c('mean_temp_c', 'area_park', 'total_precip_mm'),
  temporal_point_label = bixi_data$temporal_positions_df$time[10],
  use_dark_mode = FALSE,  nb_cols = 3)

</code></pre>

<hr>
<h2 id='plot_temporal_betas'>Plot Temporal Beta Coefficients</h2><span id='topic+plot_temporal_betas'></span>

<h3>Description</h3>

<p>Create a plot of the beta values through time for a given
spatial point and a set of feature labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_temporal_betas(
  bktr_reg,
  plot_feature_labels,
  spatial_point_label,
  date_format = "%Y-%m-%d",
  show_figure = TRUE,
  fig_width = 8.5,
  fig_height = 5.5,
  fig_resolution = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_temporal_betas_+3A_bktr_reg">bktr_reg</code></td>
<td>
<p>BKTRRegressor: BKTRRegressor object.</p>
</td></tr>
<tr><td><code id="plot_temporal_betas_+3A_plot_feature_labels">plot_feature_labels</code></td>
<td>
<p>Array: Array of feature labels to plot.</p>
</td></tr>
<tr><td><code id="plot_temporal_betas_+3A_spatial_point_label">spatial_point_label</code></td>
<td>
<p>String: Spatial point label to plot.</p>
</td></tr>
<tr><td><code id="plot_temporal_betas_+3A_date_format">date_format</code></td>
<td>
<p>String: Format of the date to use in bktr dataframes for the time.
Defaults to '%Y-%m-%d'.</p>
</td></tr>
<tr><td><code id="plot_temporal_betas_+3A_show_figure">show_figure</code></td>
<td>
<p>Boolean: Whether to show the figure. Defaults to True.</p>
</td></tr>
<tr><td><code id="plot_temporal_betas_+3A_fig_width">fig_width</code></td>
<td>
<p>Numeric: Figure width when figure is shown. Defaults to 8.5.</p>
</td></tr>
<tr><td><code id="plot_temporal_betas_+3A_fig_height">fig_height</code></td>
<td>
<p>Numeric: Figure height when figure is shown. Defaults to 5.5.</p>
</td></tr>
<tr><td><code id="plot_temporal_betas_+3A_fig_resolution">fig_resolution</code></td>
<td>
<p>Numeric: Figure resolution PPI. Defaults to 200.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot or NULL: ggplot object or NULL if show_figure is set to FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Launch MCMC sampling on a light version of the BIXI dataset
bixi_data &lt;- BixiData$new(is_light = TRUE)
bktr_regressor &lt;- BKTRRegressor$new(
  data_df &lt;- bixi_data$data_df,
  spatial_positions_df = bixi_data$spatial_positions_df,
  temporal_positions_df = bixi_data$temporal_positions_df,
  burn_in_iter = 5, sampling_iter = 10) # For example only (too few iterations)
bktr_regressor$mcmc_sampling()

# Plot temporal beta coefficients for the first station and the two features
plot_temporal_betas(
  bktr_regressor,
  plot_feature_labels = c('mean_temp_c', 'area_park'),
  spatial_point_label = bixi_data$spatial_positions_df$location[1])

</code></pre>

<hr>
<h2 id='plot_y_estimates'>Plot Y Estimates</h2><span id='topic+plot_y_estimates'></span>

<h3>Description</h3>

<p>Plot y estimates vs observed y values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_y_estimates(
  bktr_reg,
  show_figure = TRUE,
  fig_width = 5,
  fig_height = 5,
  fig_resolution = 200,
  fig_title = "y estimates vs observed y values"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_y_estimates_+3A_bktr_reg">bktr_reg</code></td>
<td>
<p>BKTRRegressor: BKTRRegressor object.</p>
</td></tr>
<tr><td><code id="plot_y_estimates_+3A_show_figure">show_figure</code></td>
<td>
<p>Boolean: Whether to show the figure. Defaults to True.</p>
</td></tr>
<tr><td><code id="plot_y_estimates_+3A_fig_width">fig_width</code></td>
<td>
<p>Numeric: Figure width when figure is shown. Defaults to 5.</p>
</td></tr>
<tr><td><code id="plot_y_estimates_+3A_fig_height">fig_height</code></td>
<td>
<p>Numeric: Figure height when figure is shown. Defaults to 5.</p>
</td></tr>
<tr><td><code id="plot_y_estimates_+3A_fig_resolution">fig_resolution</code></td>
<td>
<p>Numeric: Figure resolution PPI when figure is shown. Defaults to 200.</p>
</td></tr>
<tr><td><code id="plot_y_estimates_+3A_fig_title">fig_title</code></td>
<td>
<p>String or NULL: Figure title if provided. Defaults to 'y estimates vs observed y values'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot or NULL: ggplot object or NULL if show_figure is set to FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Launch MCMC sampling on a light version of the BIXI dataset
bixi_data &lt;- BixiData$new(is_light = TRUE)
bktr_regressor &lt;- BKTRRegressor$new(
  data_df &lt;- bixi_data$data_df,
  spatial_positions_df = bixi_data$spatial_positions_df,
  temporal_positions_df = bixi_data$temporal_positions_df,
  burn_in_iter = 5, sampling_iter = 10) # For example only (too few iterations)
bktr_regressor$mcmc_sampling()

# Plot Y estimates vs observed y values
plot_y_estimates(bktr_regressor)

</code></pre>

<hr>
<h2 id='print.BKTRRegressor'>Print the summary of a BKTRRegressor instance</h2><span id='topic+print.BKTRRegressor'></span>

<h3>Description</h3>

<p>Print the summary of a BKTRRegressor instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BKTRRegressor'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.BKTRRegressor_+3A_x">x</code></td>
<td>
<p>A BKTRRegressor instance</p>
</td></tr>
<tr><td><code id="print.BKTRRegressor_+3A_...">...</code></td>
<td>
<p>Additional arguments to comply with generic function</p>
</td></tr>
</table>

<hr>
<h2 id='reshape_covariate_dfs'>Function used to transform covariates coming from two dataframes one for spatial and
one for temporal into a single dataframe with the right shape for the BKTR Regressor.
This is useful when the temporal covariates do not vary trough space and the spatial
covariates do not vary trough time (Like in the BIXI example). The function also adds
a column for the target variable at the beginning of the dataframe.</h2><span id='topic+reshape_covariate_dfs'></span>

<h3>Description</h3>

<p>Function used to transform covariates coming from two dataframes one for spatial and
one for temporal into a single dataframe with the right shape for the BKTR Regressor.
This is useful when the temporal covariates do not vary trough space and the spatial
covariates do not vary trough time (Like in the BIXI example). The function also adds
a column for the target variable at the beginning of the dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshape_covariate_dfs(spatial_df, temporal_df, y_df, y_column_name = "y")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshape_covariate_dfs_+3A_spatial_df">spatial_df</code></td>
<td>
<p>data.table: Spatial covariates dataframe with an index named
location and a shape of (n_locations, n_spatial_covariates)</p>
</td></tr>
<tr><td><code id="reshape_covariate_dfs_+3A_temporal_df">temporal_df</code></td>
<td>
<p>data.table: Temporal covariates dataframe with an index named
time and a shape of (n_times, n_temporal_covariates)</p>
</td></tr>
<tr><td><code id="reshape_covariate_dfs_+3A_y_df">y_df</code></td>
<td>
<p>data.table: The dataframe containing the target variable. It should have
a shape of (n_locations, n_times). The columns and index names of this dataframe
should be correspond to the one of the spatial_df and temporal_df.</p>
</td></tr>
<tr><td><code id="reshape_covariate_dfs_+3A_y_column_name">y_column_name</code></td>
<td>
<p>string: The name of the target variable column in y_df. Default
to 'y'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table: The reshaped covariates dataframe with a shape of
(n_locations * n_times, 1 + n_spatial_covariates + n_temporal_covariates).
The first two columns are the indexes (location, time), the following column
is the target variable and the other columns are the covariates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Let's reshape the BIXI dataframes without normalization
new_data_df &lt;- reshape_covariate_dfs(
  spatial_df = BKTR::bixi_spatial_features,
  temporal_df = BKTR::bixi_temporal_features,
  y_df = BKTR::bixi_station_departures,
  y_column_name = 'whole_nb_departure')
# The resulting dataframe has the right shape to be a BKTRRegressor data_df
head(new_data_df)

</code></pre>

<hr>
<h2 id='simulate_spatiotemporal_data'>Simulate Spatiotemporal Data Using Kernel Covariances.</h2><span id='topic+simulate_spatiotemporal_data'></span>

<h3>Description</h3>

<p>Simulate Spatiotemporal Data Using Kernel Covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_spatiotemporal_data(
  nb_locations,
  nb_time_points,
  nb_spatial_dimensions,
  spatial_scale,
  time_scale,
  spatial_covariates_means,
  temporal_covariates_means,
  spatial_kernel,
  temporal_kernel,
  noise_variance_scale
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_spatiotemporal_data_+3A_nb_locations">nb_locations</code></td>
<td>
<p>Integer: Number of spatial locations</p>
</td></tr>
<tr><td><code id="simulate_spatiotemporal_data_+3A_nb_time_points">nb_time_points</code></td>
<td>
<p>Integer: Number of time points</p>
</td></tr>
<tr><td><code id="simulate_spatiotemporal_data_+3A_nb_spatial_dimensions">nb_spatial_dimensions</code></td>
<td>
<p>Integer: Number of spatial dimensions</p>
</td></tr>
<tr><td><code id="simulate_spatiotemporal_data_+3A_spatial_scale">spatial_scale</code></td>
<td>
<p>Numeric: Spatial scale</p>
</td></tr>
<tr><td><code id="simulate_spatiotemporal_data_+3A_time_scale">time_scale</code></td>
<td>
<p>Numeric: Time scale</p>
</td></tr>
<tr><td><code id="simulate_spatiotemporal_data_+3A_spatial_covariates_means">spatial_covariates_means</code></td>
<td>
<p>Vector: Spatial covariates means</p>
</td></tr>
<tr><td><code id="simulate_spatiotemporal_data_+3A_temporal_covariates_means">temporal_covariates_means</code></td>
<td>
<p>Vector: Temporal covariates means</p>
</td></tr>
<tr><td><code id="simulate_spatiotemporal_data_+3A_spatial_kernel">spatial_kernel</code></td>
<td>
<p>Kernel: Spatial kernel</p>
</td></tr>
<tr><td><code id="simulate_spatiotemporal_data_+3A_temporal_kernel">temporal_kernel</code></td>
<td>
<p>Kernel: Temporal kernel</p>
</td></tr>
<tr><td><code id="simulate_spatiotemporal_data_+3A_noise_variance_scale">noise_variance_scale</code></td>
<td>
<p>Numeric: Noise variance scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing 4 dataframes:
- 'data_df' contains the response variable and the covariates
- 'spatial_positions_df' contains the spatial locations and their coordinates
- 'temporal_positions_df' contains the time points and their coordinates
- 'beta_df' contains the true beta coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate data with 20 locations, 30 time points, in 2D spatial dimensions
# with 3 spatial covariates and 2 temporal covariates
simu_data &lt;- simulate_spatiotemporal_data(
   nb_locations=20,
   nb_time_points=30,
   nb_spatial_dimensions=2,
   spatial_scale=10,
   time_scale=10,
   spatial_covariates_means=c(0, 2, 4),
   temporal_covariates_means=c(1, 3),
   spatial_kernel=KernelMatern$new(),
   temporal_kernel=KernelSE$new(),
   noise_variance_scale=1)

# The dataframes are similar to bixi_data, we have:
# - data_df
head(simu_data$data_df)
# - spatial_positions_df
head(simu_data$spatial_positions_df)
# - temporal_positions_df
head(simu_data$temporal_positions_df)

# We also obtain the true beta coefficients used to simulate the data
head(simu_data$beta_df)

</code></pre>

<hr>
<h2 id='summary.BKTRRegressor'>Summarize a BKTRRegressor instance</h2><span id='topic+summary.BKTRRegressor'></span>

<h3>Description</h3>

<p>Summarize a BKTRRegressor instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BKTRRegressor'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BKTRRegressor_+3A_object">object</code></td>
<td>
<p>A BKTRRegressor instance</p>
</td></tr>
<tr><td><code id="summary.BKTRRegressor_+3A_...">...</code></td>
<td>
<p>Additional arguments to comply with generic function</p>
</td></tr>
</table>

<hr>
<h2 id='TensorOperator'>R6 singleton that contains the configuration for the tensor backend</h2><span id='topic+TensorOperator'></span>

<h3>Description</h3>

<p>Tensor backend configuration and methods for all the tensor operations
in BKTR
</p>


<h3>Super class</h3>

<p><code><a href="R6P.html#topic+Singleton">R6P::Singleton</a></code> -&gt; <code>TensorOperator</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>fp_type</code></dt><dd><p>The floating point type to use for the tensor operations</p>
</dd>
<dt><code>fp_device</code></dt><dd><p>The device to use for the tensor operations</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TensorOperator-new"><code>TensorOperator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-set_params"><code>TensorOperator$set_params()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-get_default_jitter"><code>TensorOperator$get_default_jitter()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-tensor"><code>TensorOperator$tensor()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-is_tensor"><code>TensorOperator$is_tensor()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-eye"><code>TensorOperator$eye()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-ones"><code>TensorOperator$ones()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-zeros"><code>TensorOperator$zeros()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-rand"><code>TensorOperator$rand()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-randn"><code>TensorOperator$randn()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-randn_like"><code>TensorOperator$randn_like()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-arange"><code>TensorOperator$arange()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-rand_choice"><code>TensorOperator$rand_choice()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-kronecker_prod"><code>TensorOperator$kronecker_prod()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-khatri_rao_prod"><code>TensorOperator$khatri_rao_prod()</code></a>
</p>
</li>
<li> <p><a href="#method-TensorOperator-clone"><code>TensorOperator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-TensorOperator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the tensor operator with the given floating point type
and device
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$new(fp_type = "float64", fp_device = "cpu")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fp_type</code></dt><dd><p>The floating point type to use for the tensor operations (either
&quot;float64&quot; or &quot;float32&quot;)</p>
</dd>
<dt><code>fp_device</code></dt><dd><p>The device to use for the tensor operations (either &quot;cpu&quot; or
&quot;cuda&quot;)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new tensor operator instance
</p>


<hr>
<a id="method-TensorOperator-set_params"></a>



<h4>Method <code>set_params()</code></h4>

<p>Set the tensor operator parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$set_params(fp_type = NULL, fp_device = NULL, seed = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fp_type</code></dt><dd><p>The floating point type to use for the tensor operations (either
&quot;float64&quot; or &quot;float32&quot;)</p>
</dd>
<dt><code>fp_device</code></dt><dd><p>The device to use for the tensor operations (either &quot;cpu&quot; or
&quot;cuda&quot;)</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed to use for the random number generator</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TensorOperator-get_default_jitter"></a>



<h4>Method <code>get_default_jitter()</code></h4>

<p>Get the default jitter value for the floating point type used by the tensor operator
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$get_default_jitter()</pre></div>



<h5>Returns</h5>

<p>The default jitter value for the floating point type used by the tensor operator
</p>


<hr>
<a id="method-TensorOperator-tensor"></a>



<h4>Method <code>tensor()</code></h4>

<p>Create a tensor from a vector or matrix of data with the tensor operator dtype and device
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$tensor(tensor_data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tensor_data</code></dt><dd><p>The vector or matrix of data to create the tensor from</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new tensor with the tensor operator dtype and device
</p>


<hr>
<a id="method-TensorOperator-is_tensor"></a>



<h4>Method <code>is_tensor()</code></h4>

<p>Check if a provided object is a tensor
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$is_tensor(tensor)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tensor</code></dt><dd><p>The object to check</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A boolean indicating if the object is a tensor
</p>


<hr>
<a id="method-TensorOperator-eye"></a>



<h4>Method <code>eye()</code></h4>

<p>Create a tensor with a diagonal of ones and zeros with the tensor operator dtype and device
for a given dimension
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$eye(eye_dim)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>eye_dim</code></dt><dd><p>The dimension of the tensor to create</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new tensor with a diagonal of ones and zeros with the tensor operator dtype and device
</p>


<hr>
<a id="method-TensorOperator-ones"></a>



<h4>Method <code>ones()</code></h4>

<p>Create a tensor of ones with the tensor operator dtype and device for a given dimension
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$ones(tsr_dim)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tsr_dim</code></dt><dd><p>The dimension of the tensor to create</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new tensor of ones with the tensor operator dtype and device
</p>


<hr>
<a id="method-TensorOperator-zeros"></a>



<h4>Method <code>zeros()</code></h4>

<p>Create a tensor of zeros with the tensor operator dtype and device for a given dimension
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$zeros(tsr_dim)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tsr_dim</code></dt><dd><p>The dimension of the tensor to create</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new tensor of zeros with the tensor operator dtype and device
</p>


<hr>
<a id="method-TensorOperator-rand"></a>



<h4>Method <code>rand()</code></h4>

<p>Create a tensor of random uniform values with the tensor operator dtype and
device for a given dimension
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$rand(tsr_dim)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tsr_dim</code></dt><dd><p>The dimension of the tensor to create</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new tensor of random values with the tensor operator dtype and device
</p>


<hr>
<a id="method-TensorOperator-randn"></a>



<h4>Method <code>randn()</code></h4>

<p>Create a tensor of random normal values with the tensor operator dtype and device
for a given dimension
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$randn(tsr_dim)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tsr_dim</code></dt><dd><p>The dimension of the tensor to create</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new tensor of random normal values with the tensor operator dtype and device
</p>


<hr>
<a id="method-TensorOperator-randn_like"></a>



<h4>Method <code>randn_like()</code></h4>

<p>Create a tensor of random uniform values with the same shape as a given tensor
with the tensor operator dtype and device
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$randn_like(input_tensor)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input_tensor</code></dt><dd><p>The tensor to use as a shape reference</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new tensor of random uniform values with the same shape as a given tensor
</p>


<hr>
<a id="method-TensorOperator-arange"></a>



<h4>Method <code>arange()</code></h4>

<p>Create a tensor of a range of values with the tensor operator dtype and device
for a given start and end
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$arange(start, end)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>start</code></dt><dd><p>The start of the range</p>
</dd>
<dt><code>end</code></dt><dd><p>The end of the range</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new tensor of a range of values with the tensor operator dtype and device
</p>


<hr>
<a id="method-TensorOperator-rand_choice"></a>



<h4>Method <code>rand_choice()</code></h4>

<p>Choose random values from a tensor for a given number of samples
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$rand_choice(
  choices_tsr,
  nb_sample,
  use_replace = FALSE,
  weights_tsr = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>choices_tsr</code></dt><dd><p>The tensor to choose values from</p>
</dd>
<dt><code>nb_sample</code></dt><dd><p>The number of samples to choose</p>
</dd>
<dt><code>use_replace</code></dt><dd><p>A boolean indicating if the sampling should be done with replacement.
Defaults to FALSE</p>
</dd>
<dt><code>weights_tsr</code></dt><dd><p>The weights to use for the sampling. If NULL, the sampling is uniform.
Defaults to NULL</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new tensor of randomly chosen values from a tensor
</p>


<hr>
<a id="method-TensorOperator-kronecker_prod"></a>



<h4>Method <code>kronecker_prod()</code></h4>

<p>Efficiently compute the kronecker product of two matrices in tensor format
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$kronecker_prod(a, b)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p>The first tensor</p>
</dd>
<dt><code>b</code></dt><dd><p>The second tensor</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The kronecker product of the two matrices
</p>


<hr>
<a id="method-TensorOperator-khatri_rao_prod"></a>



<h4>Method <code>khatri_rao_prod()</code></h4>

<p>Efficiently compute the khatri rao product of two matrices in tensor format
having the same number of columns
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$khatri_rao_prod(a, b)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p>The first tensor</p>
</dd>
<dt><code>b</code></dt><dd><p>The second tensor</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The khatri rao product of the two matrices
</p>


<hr>
<a id="method-TensorOperator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TensorOperator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# Set the seed, setup the tensor floating point type and device
TSR$set_params(fp_type='float64', fp_device='cpu', seed=42)
# Create a tensor from a vector
TSR$tensor(c(1, 2, 3))
# Create a tensor from a matrix
TSR$tensor(matrix(c(1, 2, 3, 4), nrow=2))
# Create a 3x3 tensor with a diagonal of ones and zeros elsewhere
TSR$eye(3)
# Create a tensor of ones (with 6 elements, 2 rows and 3 columns)
TSR$ones(c(2, 3))
# Create a tensor of zeros (with 12 elements, 3 rows and 4 columns)
TSR$zeros(c(3, 4))
# Create a tensor of random uniform values (with 6 elements)
TSR$rand(c(2, 3))
# Create a tensor of random normal values (with 6 elements)
TSR$randn(c(2, 3))
# Create a tensor of random normal values with the same shape as a given tensor
tsr_a &lt;- TSR$randn(c(2, 3))
TSR$randn_like(tsr_a)
# Create a tensor of a range of values (1, 2, 3, 4)
TSR$arange(1, 4)
# Choose two random values from a given tensor without replacement
tsr_b &lt;- TSR$rand(6)
TSR$rand_choice(tsr_b, 2)
# Use the tensor operator to compute the kronecker product of two 2x2 matrices
tsr_c &lt;- TSR$tensor(matrix(c(1, 2, 3, 4), nrow=2))
tsr_d &lt;- TSR$tensor(matrix(c(5, 6, 7, 8), nrow=2))
TSR$kronecker_prod(tsr_c, tsr_d) # Returns a 4x4 tensor
# Use the tensor operator to compute the khatri rao product of two 2x2 matrices
TSR$khatri_rao_prod(tsr_c, tsr_d) # Returns a 4x2 tensor
# Check if a given object is a tensor
TSR$is_tensor(tsr_d) # Returns TRUE
TSR$is_tensor(TSR$eye(2)) # Returns TRUE
TSR$is_tensor(1) # Returns FALSE

</code></pre>

<hr>
<h2 id='TSR'>Tensor Operator Singleton</h2><span id='topic+TSR'></span>

<h3>Description</h3>

<p>Singleton instance of the <code>TensorOperator</code> class that contains
all informations related the tensor API; tensor methods, used data type and used device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSR
</code></pre>


<h3>Format</h3>

<p>An object of class <code>TensorOperator</code> (inherits from <code>Singleton</code>, <code>R6</code>) of length 19.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
