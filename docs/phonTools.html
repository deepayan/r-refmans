<!DOCTYPE html><html><head><title>Help for package phonTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phonTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a96'>
<p>Aronson et al. (1996) Hebrew Vowel Data</p></a></li>
<li><a href='#b95'>
<p>Bradlow (1995) Spanish Vowel Data</p></a></li>
<li><a href='#combocalc'>
<p>Combinations and Permutations</p></a></li>
<li><a href='#createtemplate'>
<p>Create an LDA Template</p></a></li>
<li><a href='#errorbars'>
<p>Error bars.</p></a></li>
<li><a href='#f73'>
<p>Fant (1973) Swedish Vowel Data</p></a></li>
<li><a href='#f99'>
<p>Fourakis et al. (1999) Greek Vowel Data</p></a></li>
<li><a href='#fastacf'>
<p>Fast Autocorrelation</p></a></li>
<li><a href='#Ffilter'>
<p>Formant Filtering</p></a></li>
<li><a href='#findformants'>
<p>Find Formants</p></a></li>
<li><a href='#FIRfilter'>
<p>Perform Digital Filtering</p></a></li>
<li><a href='#formanttrack'>
<p>Formant Tracking</p></a></li>
<li><a href='#freqresponse'>
<p>Frequency Response</p></a></li>
<li><a href='#h95'>
<p>Hillenbrand et al. (1995) Vowel Data</p></a></li>
<li><a href='#hotelling.test'>
<p>Hotelling's T2 Test</p></a></li>
<li><a href='#imputeformants'>
<p>Impute Missing Formant Values</p></a></li>
<li><a href='#interpolate'>
<p>Interpolation</p></a></li>
<li><a href='#ldboundary'>
<p>Linear Discriminant Boundary</p></a></li>
<li><a href='#ldclassify'>
<p>Linear Discriminant Classification</p></a></li>
<li><a href='#loadsound'>
<p>Load WAV files into R</p></a></li>
<li><a href='#loadtable'>
<p>Load Table</p></a></li>
<li><a href='#lpc'>
<p>Linear Predictive Coding</p></a></li>
<li><a href='#makeFIR'>
<p>Create a Digital Filter</p></a></li>
<li><a href='#makesound'>
<p>Make a 'sound' object</p></a></li>
<li><a href='#multiplot'>
<p>Plot with variable panel sizes</p></a></li>
<li><a href='#normalize'>
<p>Normalize Vowels</p></a></li>
<li><a href='#normalize.compare'>
<p>Compare Normalization Methods</p></a></li>
<li><a href='#ntypes'>
<p>Number of Unique Elements</p></a></li>
<li><a href='#p73'>
<p>Pols et al. (1973) Dutch Vowel Data</p></a></li>
<li><a href='#pb52'>
<p>Peterson &amp; Barney (1952) Vowel Data</p></a></li>
<li><a href='#peakfind'>
<p>Find the Peaks</p></a></li>
<li><a href='#phasor'>
<p>Plot Phasors</p></a></li>
<li><a href='#pickIPA'>
<p>Pick IPA Symbols</p></a></li>
<li><a href='#pitchtrack'>
<p>Pitch Tracking</p></a></li>
<li><a href='#playsound'>
<p>Play Sounds</p></a></li>
<li><a href='#polezero'>
<p>Pole-zero Plots</p></a></li>
<li><a href='#powertrack'>
<p>Power tracking</p></a></li>
<li><a href='#preemphasis'>
<p>Add Preemphasis</p></a></li>
<li><a href='#PSTM'>
<p>Probabilistic Sliding Template Model</p></a></li>
<li><a href='#pwelch'>
<p>Welch's Power Spectral Density Estimate</p></a></li>
<li><a href='#rcr'>
<p>Random Coefficients Regression</p></a></li>
<li><a href='#reduce.fraction'>
<p>Reduce Fractions</p></a></li>
<li><a href='#resample'>
<p>Resample a Sound</p></a></li>
<li><a href='#rmvtnorm'>
<p>Random multivariate normal variables</p></a></li>
<li><a href='#rotate'>
<p>Rotate</p></a></li>
<li><a href='#sdellipse'>
<p>Standard deviation Ellipse</p></a></li>
<li><a href='#selectslice'>
<p>Select Slices</p></a></li>
<li><a href='#sinc'>
<p>Sinc Function</p></a></li>
<li><a href='#sinusoid'>
<p>Create Sinusoids</p></a></li>
<li><a href='#snip'>
<p>Snip/Zoom</p></a></li>
<li><a href='#sound'>
<p>Sound object</p></a></li>
<li><a href='#spectralslice'>
<p>Spectral Slice</p></a></li>
<li><a href='#spectrogram'>
<p>Create Spectrograms</p></a></li>
<li><a href='#synthfilter'>
<p>Filtering by Synthesis</p></a></li>
<li><a href='#t07'>
<p>Thomson (2007) Vowel Data</p></a></li>
<li><a href='#voweldata'>
<p>Information about Vowel Data Sets</p></a></li>
<li><a href='#vowelplot'>
<p>Plot Vowels</p></a></li>
<li><a href='#vowelsynth'>
<p>Vowel Synthesis</p></a></li>
<li><a href='#vplot'>
<p>Plot Vowels</p></a></li>
<li><a href='#windowfunc'>
<p>Window Function</p></a></li>
<li><a href='#writesound'>
<p>Write out a WAV file</p></a></li>
<li><a href='#xsampatoIPA'>
<p>Convert X-Sampa to IPA</p></a></li>
<li><a href='#y96'>
<p>Yang (1996) Korean Vowel Data</p></a></li>
<li><a href='#zeros'>
<p>Zero Vector/Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Phonetic and Acoustic Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Santiago Barreda</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15)</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains tools for the organization, display, and analysis of the sorts of data frequently encountered in phonetics research and experimentation, including the easy creation of IPA vowel plots, and the creation and manipulation of WAVE audio files.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-20 16:43:47 UTC; santi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-20 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='a96'>
Aronson et al. (1996) Hebrew Vowel Data
</h2><span id='topic+a96'></span>

<h3>Description</h3>

<p>Formant frequency information for vowels averaged across 6 male speakers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data (a96)</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt><code>sex</code></dt><dd><p> - A factor indicating speaker sex.</p>
</dd>
<dt><code>vowel</code></dt><dd><p> - The vowel category in x-sampa.</p>
</dd>
<dt><code>f1</code></dt><dd><p> - A numeric vector indcating the vowel F1 in Hz.</p>
</dd>
<dt><code>f2</code></dt><dd><p> - A numeric vector indcating the vowel F2 in Hz.</p>
</dd>
<dt><code>f3</code></dt><dd><p> - A numeric vector indcating the vowel F3 in Hz.</p>
</dd>
<dt><code>f4</code></dt><dd><p> - A numeric vector indcating the vowel F4 in Hz.</p>
</dd>
</dl>



<h3>References</h3>

<p>Aronson, L., Rosenhouse, J. Rosenhouse, G. &amp; Podoshin, L. (1996). An acoustic analysis of modern Hebrew vowels and voiced consonants. Journal of Phonetics 24. 283-193. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data(a96)
#vowelplot (a96$f1, a96$f2, a96$vowel, logaxes = 'xy', xsampa = TRUE)
</code></pre>

<hr>
<h2 id='b95'>
Bradlow (1995) Spanish Vowel Data
</h2><span id='topic+b95'></span>

<h3>Description</h3>

<p>Formant frequency information for vowels averaged across 4 male speakers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data (b95)</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt><code>sex</code></dt><dd><p> - A factor indicating speaker sex.</p>
</dd>
<dt><code>vowel</code></dt><dd><p> - The vowel category in x-sampa.</p>
</dd>
<dt><code>f1</code></dt><dd><p> - A numeric vector indcating the vowel F1 in Hz.</p>
</dd>
<dt><code>f2</code></dt><dd><p> - A numeric vector indcating the vowel F2 in Hz.</p>
</dd>
</dl>



<h3>References</h3>

<p>Bradlow, A. R. (1995). A comparative acoustic study of English and Spanish vowels. Journal of the Acoustical Society of America 97. 1916-1924.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data(b95)
#vowelplot (b95$f1, b95$f2, b95$vowel, logaxes = 'xy', xsampa = TRUE)
</code></pre>

<hr>
<h2 id='combocalc'>
Combinations and Permutations
</h2><span id='topic+combocalc'></span>

<h3>Description</h3>

<p>Calculate the number of combinations or permutations for a number of objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combocalc (objects, choose, order = FALSE, repetition = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combocalc_+3A_objects">objects</code></td>
<td>
<p>The number of different kinds of objects available for selection.</p>
</td></tr> 
<tr><td><code id="combocalc_+3A_choose">choose</code></td>
<td>
<p>The number of objects selected at a given time.</p>
</td></tr> 
<tr><td><code id="combocalc_+3A_order">order</code></td>
<td>
<p>If TRUE, the order of the objects matters, for example aba != aab.</p>
</td></tr> 
<tr><td><code id="combocalc_+3A_repetition">repetition</code></td>
<td>
<p>If TRUE, a sequence such as bbb is permissible.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># combinations, no repetition
combocalc (10, 4, order = FALSE, repetition = FALSE)
# combinations, with repetition
combocalc (10, 4, order = FALSE, repetition = TRUE)
# permutations, no repetition
combocalc (10, 4, order = TRUE, repetition = FALSE)
# permutations, with repetition
combocalc (10, 4, order = TRUE, repetition = TRUE)
</code></pre>

<hr>
<h2 id='createtemplate'>
Create an LDA Template
</h2><span id='topic+createtemplate'></span><span id='topic+print.template'></span><span id='topic+plot.template'></span><span id='topic+territorialmap'></span>

<h3>Description</h3>

<p>Create a linear discriminant analysis template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createtemplate (features, classes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createtemplate_+3A_features">features</code></td>
<td>
<p>A matrix of features in which each row represents a single token and each column represents a different 'feature' used to classify the token. For vowel sounds, each column should represent different single formant frequency.</p>
</td></tr>
<tr><td><code id="createtemplate_+3A_classes">classes</code></td>
<td>
<p>A vector indicating the category of each token described in each row of 'features'. The length of this vector must equal the number of rows in 'features'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the location of the mean of each class in an n-dimensional space, where each dimension corresponds to one of n columns in 'features'. In addition, the pooled, within-category covariance matrix is found. 
</p>
<p>The name for each vowel category is stored as the rownames of the 'means' element. 
</p>
<p>The function plot() is defined for template objects and allows the user to view the location of and expected variation around the different vowel categories in the formant space.
</p>
<p>This information may be used in conjunction with the PSTM() function, included in this package. The mean and covariance matrices provided by this function may also be useful for the ldclassify() function provided in this package. 
</p>


<h3>Value</h3>

<p>A 'template' object, a list containing the elements:
</p>
<table>
<tr><td><code>classes</code></td>
<td>
<p>The category labels.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>A matrix containing the mean location for each vowel category within the formant-space. Each row represents a different category while each column represents a different formant.</p>
</td></tr>
<tr><td><code>covariance</code></td>
<td>
<p>The pooled, within-category covariance matrix for the formant frequencies provided.</p>
</td></tr>
<tr><td><code>ranges</code></td>
<td>
<p>A matrix of dimension ranges, one row for each dimension.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Nearey, T. M. &amp; P. F. Assmann. (2007). Pobabilistic 'sliding template' models for indirect vowel normalization. in Experimental Approaches to Phonology, edited by M.J. Sole, P. S., Beddor, and M. Ohala (Oxford University Press, Oxford), pp. 246-269.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data (pb52)            ## load the Peterson and Barney vowels.
## normalize them.
#normdvowels = normalize (pb52[,7:9], pb52$speaker, pb52$vowel)  
#formants = normdvowels[,1:3]
#vowels = pb52$vowel

## create a vowel template with the normalized formant frequencies
## and information about the vowel category.
#template = createtemplate (formants, vowels)

## and inspect with plot()
#plot (template, xsampa = TRUE)
</code></pre>

<hr>
<h2 id='errorbars'>
Error bars.
</h2><span id='topic+errorbars'></span><span id='topic+errorbar'></span>

<h3>Description</h3>

<p>This functions adds error bars to a plot or, optionally, plots points and added error bars. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errorbars (x, y, top, bottom = top, length = .2, add = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errorbars_+3A_x">x</code></td>
<td>
<p>X axis positions.</p>
</td></tr> 
<tr><td><code id="errorbars_+3A_y">y</code></td>
<td>
<p>Y axis positions.</p>
</td></tr> 
<tr><td><code id="errorbars_+3A_top">top</code></td>
<td>
<p>Top error bar length.</p>
</td></tr> 
<tr><td><code id="errorbars_+3A_bottom">bottom</code></td>
<td>
<p>Bottom error bar length.</p>
</td></tr> 
<tr><td><code id="errorbars_+3A_length">length</code></td>
<td>
<p>The length of the horizontal bars.</p>
</td></tr> 
<tr><td><code id="errorbars_+3A_add">add</code></td>
<td>
<p>If TRUE, error bars are added to existing plot.</p>
</td></tr> 
<tr><td><code id="errorbars_+3A_...">...</code></td>
<td>
<p>Additional arguments go to the internal call of arrows() which draws the error bars.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Inspired by a similar function first seen here:
</p>
<p>http://monkeysuncle.stanford.edu/?p=485
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## add bars to existing plots 
#plot (1:10, 1:10, col = 4, pch = 18)
#errorbars (1:10, 1:10, .5, col = 4)

## or create a new plot
#errorbars (1:10, 1:10, 2, add = FALSE)

</code></pre>

<hr>
<h2 id='f73'>
Fant (1973) Swedish Vowel Data
</h2><span id='topic+f73'></span>

<h3>Description</h3>

<p>Formant frequency information for vowels averaged across 50 male speakers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data (f73)</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt><code>sex</code></dt><dd><p> - A factor indicating speaker sex.</p>
</dd>
<dt><code>vowel</code></dt><dd><p> - The vowel category in x-sampa.</p>
</dd>
<dt><code>f1</code></dt><dd><p> - A numeric vector indcating the vowel F1 in Hz.</p>
</dd>
<dt><code>f2</code></dt><dd><p> - A numeric vector indcating the vowel F2 in Hz.</p>
</dd>
<dt><code>f3</code></dt><dd><p> - A numeric vector indcating the vowel F3 in Hz.</p>
</dd>
<dt><code>f4</code></dt><dd><p> - A numeric vector indcating the vowel F4 in Hz.</p>
</dd>
</dl>



<h3>References</h3>

<p>Fant, G. (1973). Speech sounds and features. Cambridge, MA: MIT Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data(f73)
#vowelplot (f73$f1, f73$f2, f73$vowel, logaxes = 'xy', xsampa = TRUE)
</code></pre>

<hr>
<h2 id='f99'>
Fourakis et al. (1999) Greek Vowel Data
</h2><span id='topic+f99'></span>

<h3>Description</h3>

<p>Formant frequency information for vowels averaged across 5 male speakers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data (f99)</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt><code>sex</code></dt><dd><p> - A factor indicating speaker sex.</p>
</dd>
<dt><code>vowel</code></dt><dd><p> - The vowel category in x-sampa.</p>
</dd>
<dt><code>f1</code></dt><dd><p> - A numeric vector indcating the vowel F1 in Hz.</p>
</dd>
<dt><code>f2</code></dt><dd><p> - A numeric vector indcating the vowel F2 in Hz.</p>
</dd>
</dl>



<h3>References</h3>

<p>Fourakis, M., Botinis, A. &amp; Katsaiti, M. (1999). Acoustic characteristics of Greek vowels. Phonetica, 56. 28-43.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data(f99)
#vowelplot (f99$f1, f99$f2, f99$vowel, logaxes = 'xy', xsampa = TRUE)
</code></pre>

<hr>
<h2 id='fastacf'>
Fast Autocorrelation
</h2><span id='topic+fastacf'></span>

<h3>Description</h3>

<p>Compute the ACF of a signal. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastacf  (signal, lag.max = length(signal), window = 'hann',
          show = TRUE, correct = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastacf_+3A_signal">signal</code></td>
<td>
<p>The signal, a numeric vector.</p>
</td></tr> 
<tr><td><code id="fastacf_+3A_lag.max">lag.max</code></td>
<td>
<p>The maximum lag value to be returned.</p>
</td></tr> 
<tr><td><code id="fastacf_+3A_window">window</code></td>
<td>
<p> The type of window to be applied to the signal. Uses the windowfunc() function in this package. For no window select 'rectangular'.</p>
</td></tr> 
<tr><td><code id="fastacf_+3A_show">show</code></td>
<td>
<p>If TRUE, the results are plotted.</p>
</td></tr> 
<tr><td><code id="fastacf_+3A_correct">correct</code></td>
<td>
<p> If TRUE, the output is corrected based on the window length and the window function that is applied.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The autocorrelation function is calculated using the inverse Fourier transform applied to the power spectrum. This leads to much faster calculation times than the acf() function included in the typical R installation. Corrections for window type and length are carried out as described in Boersma (1993). 
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<table>
<tr><td><code>lag</code></td>
<td>
<p> Indicates the lag value.</p>
</td></tr>
<tr><td><code>acf</code></td>
<td>
<p> Indicates the ACF value at the lag.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Boersma, P., (1993). Accurate short-term analysis of the fundamental frequency and the harmonics-to-noise ratio of a sampled sound. Proc. Instit. Phon. Sci. 17: 97-110.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Uncomment and run the code below to see the speed advantage.
## Raising the n makes the difference even more pronounced.
#n = 25000
#system.time ({
#acf (rnorm (n), plot = F, lag.max = n)
#})

#system.time ({
#fastacf (rnorm (n), plot = F, lag.max = n)
#})

</code></pre>

<hr>
<h2 id='Ffilter'>
Formant Filtering
</h2><span id='topic+Ffilter'></span>

<h3>Description</h3>

<p>Perform cascade formant filtering of sounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ffilter (sound, ffs, bwp = 0.06, minbw = 60, fs = 22050, verify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ffilter_+3A_sound">sound</code></td>
<td>
<p>A numeric vector representing a waveform, or a 'sound' object created with the loadsound() or makesound() functions.</p>
</td></tr> 
<tr><td><code id="Ffilter_+3A_ffs">ffs</code></td>
<td>
<p>A list of vectors of initial and final center frequencies for each formant. Each vector should contain formant frequencies in order of lowest to highest frequency. If only a single vector is provided, formants will remain stable throughout.</p>
</td></tr> 
<tr><td><code id="Ffilter_+3A_bwp">bwp</code></td>
<td>
<p>A vector of formant bandwidths, one for each formant.</p>
</td></tr> 
<tr><td><code id="Ffilter_+3A_minbw">minbw</code></td>
<td>
<p>The minimum permissible formant bandwidth, in Hertz.</p>
</td></tr> 
<tr><td><code id="Ffilter_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency of the sound. If a 'sound' object is passed, this does not need to be specified.</p>
</td></tr> 
<tr><td><code id="Ffilter_+3A_verify">verify</code></td>
<td>
<p>If TRUE, before and after spectra are plotted to allow the user to visually verify the process.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function allows the user to specify one or more formant filters and to pass a signal through said filters. This may be used to create synthetic speech sounds or to modify existing sounds as desired. The given signal is passed through the formant filters in reverse order. Filter bandwidths specify the distance between formant center frequencies and the point at which the output will be 3 dB below peak energy.
</p>
<p>Filter bandwidths may be provided in Hz, or as a percentage of the formant frequencies. To set these as a percent of formant frequencies, all values must be less than 1. If these are not provided they are set to 6 percent of the formant center frequencies by default. If only one value is provided, this is assumed to be the desired value for all formants.
</p>


<h3>Value</h3>

<p>A vector representing the filtered sound.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Klatt, D. H. (1980). Software for a cascade/parallel formant synthesizer. Journal of the Acoustical Society of America 67(3): 971-995.
</p>
<p>http://www.fon.hum.uva.nl/praat/manual/Sound__Filter__one_formant____.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## uncomment and run
## Generate half a second of white noise
#sound = rnorm (11025, 0, 1)

## pass this through some formant filters
## two static formants
#filtered1 = Ffilter (sound, ffs = c(4000,7000), bw = 500)
## a single moving formant
#filtered2 = Ffilter (sound, ffs = list(3000,8000), bw = 500)
## two moving formants


## inspect the results
#par (mfrow = c(1,2), mar = c(4,4,1,1))
#spectrogram (filtered1, maxfreq = 11025)
#spectrogram (filtered2, maxfreq = 11025)

</code></pre>

<hr>
<h2 id='findformants'>
Find Formants
</h2><span id='topic+findformants'></span>

<h3>Description</h3>

<p>Find formants given a sound or set of LPC coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findformants (sound, fs = 10000, coeffs = NULL, maxbw = 600, 
minformant = 200, verify = TRUE, showbws = FALSE, 
showrejected = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findformants_+3A_sound">sound</code></td>
<td>
<p>A numeric vector representing a waveform, or a 'sound' object created with the loadsound() or makesound() functions.</p>
</td></tr> 
<tr><td><code id="findformants_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency of the sound. If a 'sound' object is passed this does not need to be specified.</p>
</td></tr>
<tr><td><code id="findformants_+3A_coeffs">coeffs</code></td>
<td>
<p>If a number is given, this many coefficients are used in the analysis. Alternatively, the LPC (AR filter) coefficients may be passed to the function directly using this parameter. For good results, two coefficients are required for each formants plus 2 or 3 'for the pot'.</p>
</td></tr> 
<tr><td><code id="findformants_+3A_maxbw">maxbw</code></td>
<td>
<p>The maximum bandwidth for accepted formants.</p>
</td></tr>   
<tr><td><code id="findformants_+3A_minformant">minformant</code></td>
<td>
<p>Formants below this frequency are rejected.</p>
</td></tr> 
<tr><td><code id="findformants_+3A_verify">verify</code></td>
<td>
<p>If TRUE, a plot is created which allows the user to visually inspect the process.</p>
</td></tr>
<tr><td><code id="findformants_+3A_showbws">showbws</code></td>
<td>
<p>If TRUE, formant bandwidths are indicated on the plot.</p>
</td></tr>
<tr><td><code id="findformants_+3A_showrejected">showrejected</code></td>
<td>
<p>If TRUE, rejected formant locations are indicated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formant frequencies are found analytically using the formulas provided in Snell (1993). If Verify = TRUE, the estimated frequency response, formant locations, and a pole-zero plot of the estimated filter are presented. Accepted formants are presented in 5 colors (which are reused if there are more than 5 formants), while rejected formants are presented in black.
</p>


<h3>Value</h3>

<p>A dataframe with the following elements is returned:
</p>
<table>
<tr><td><code>frequency</code></td>
<td>
<p>The frequencies of formants, in ascending order.</p>
</td></tr>
<tr><td><code>bandwidth</code></td>
<td>
<p>The corresponding formant bandwidth.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Snell, R.(1993). &quot;Formant location from LPC analysis data&quot;, IEEE Transactions on Speech and Audio Processing, 1(2), pp. 129-134.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make a synthetic vowel with a known set of formant frequencies
## and bandwidths
#sound = vowelsynth (ffs = c(500,1500,2500,3500,4500),
#                    fbw = c(30, 90, 150, 210, 270), f0 = 100)

## compare different plotting options					
#findformants (sound)
#findformants (sound, showrejected = FALSE)
#findformants (sound, showbws = TRUE)
</code></pre>

<hr>
<h2 id='FIRfilter'>
Perform Digital Filtering
</h2><span id='topic+FIRfilter'></span>

<h3>Description</h3>

<p>Finite Impulse Response (FIR) filtering of vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIRfilter (sound, from = 0, to = fs/2, fs = 22050, order = 200, 
verify = FALSE, impulse = NULL, pad = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FIRfilter_+3A_sound">sound</code></td>
<td>
<p>A numeric vector representing a waveform, or a 'sound' object created with the loadsound() or makesound() functions.</p>
</td></tr> 
<tr><td><code id="FIRfilter_+3A_from">from</code></td>
<td>
<p>The low cutoff point for the filter. Frequencies higher than this are not attenuated. Minimum allowed value is 0 Hz.</p>
</td></tr> 
<tr><td><code id="FIRfilter_+3A_to">to</code></td>
<td>
<p>The high cutoff point for the filter. Frequencies lower than this are not attenuated. Maximum allowed value is fs/2 Hz.</p>
</td></tr> 
<tr><td><code id="FIRfilter_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency of the sound. If a 'sound' object is passed, this does not need to be specified.</p>
</td></tr> 
<tr><td><code id="FIRfilter_+3A_order">order</code></td>
<td>
<p>The number of taps included in the filter. The order of the filter may not exceed the number of samples that make up the sound.</p>
</td></tr> 
<tr><td><code id="FIRfilter_+3A_verify">verify</code></td>
<td>
<p>If TRUE, a plot comparing the spectrum of the input sound is compared the the filtered sound.</p>
</td></tr> 
<tr><td><code id="FIRfilter_+3A_impulse">impulse</code></td>
<td>
<p>If a filter impulse response is specified, this is used to filter the signal.</p>
</td></tr> 
<tr><td><code id="FIRfilter_+3A_pad">pad</code></td>
<td>
<p>If TRUE, the signal is padded with zero so that the original length is maintained.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function performs lowpass, highpass and bandpass filtering using a windowed-sinc filter. Increasing the filter order decreases the transition region between the passband and the stopband. The magnitude of frequencies in the stopband is usually attenuated by about about 45 dB.
</p>
<p>If verify is TRUE, a plot is created which allows the user to inspect the performance of the function. 
</p>


<h3>Value</h3>

<p>If a vector is given, the filtered vector is returned.
</p>
<p>If a 'sound' object is given, a sound object containing the filtered sound is returned. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Sinc_filter
</p>
<p>Lyons, R. G. (2004). Understanding Digital Signal Processing (2nd ed.). Prentice Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate random noise
#sound = rnorm (5000, 0, 100)

## implement low, high and band-pass filters
#par (mfrow = c(3,1), mar = c(4,4,1,1))
#snd1 = FIRfilter (sound, from = 400, fs = 1000, verify = T)
#snd2 = FIRfilter (sound, to = 400, fs = 1000, verify = T)
#snd3 = FIRfilter (sound, from = 400, to = 100, fs = 1000, verify = T)

## use filters of different orders (i.e., differing number of taps)
#par (mfrow = c(2,1), mar = c(4,4,1,1))
#snd1 = FIRfilter (sound, to = 400, fs = 1000, order = 50, verify = T)
## higher order filters lead to narrower transition regions
#snd2 = FIRfilter (sound, to = 400, fs = 1000, order = 2000, verify = T)
</code></pre>

<hr>
<h2 id='formanttrack'>
Formant Tracking
</h2><span id='topic+formanttrack'></span>

<h3>Description</h3>

<p>Create a formant track for a sound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formanttrack (sound, timestep = 5, windowlength = 30, 
formants = 5, cutoff = 5000, minformant = 200, maxbw = 600, 
fs = 22050, show = TRUE, periodicity = .5, returnbw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formanttrack_+3A_sound">sound</code></td>
<td>
<p>A numeric vector representing a waveform, or a 'sound' object created with the loadsound() or makesound() functions.</p>
</td></tr> 
<tr><td><code id="formanttrack_+3A_timestep">timestep</code></td>
<td>
<p> How far the analysis window will advance, in milliseconds. If this value is set to zero, the function is applied to the entire signal.</p>
</td></tr> 
<tr><td><code id="formanttrack_+3A_windowlength">windowlength</code></td>
<td>
<p> The length of the analysis window. Longer windows will result in increased accuracy with decreased time-resolution.</p>
</td></tr> 
<tr><td><code id="formanttrack_+3A_formants">formants</code></td>
<td>
<p>The desired number of formants to be tracked. Depending on the sound and time point, fewer than this many may be found.</p>
</td></tr>   
<tr><td><code id="formanttrack_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum analysis frequency. May not be higher than the Nyquist frequency.</p>
</td></tr>   
<tr><td><code id="formanttrack_+3A_minformant">minformant</code></td>
<td>
<p>Formants below this frequency are rejected.</p>
</td></tr> 
<tr><td><code id="formanttrack_+3A_maxbw">maxbw</code></td>
<td>
<p>The maximum bandwidth for accepted formants.</p>
</td></tr>   
<tr><td><code id="formanttrack_+3A_fs">fs</code></td>
<td>
<p> The sampling frequency of the sound. If a 'sound' or 'ts' object is passed, this does not need to be specified.</p>
</td></tr> 
<tr><td><code id="formanttrack_+3A_show">show</code></td>
<td>
<p>If TRUE, a plot is created which allows the user to visually inspect the process.</p>
</td></tr>
<tr><td><code id="formanttrack_+3A_periodicity">periodicity</code></td>
<td>
<p>A value between 0 and 1. Signal sections with corrected ACF values lower than this are not analyzed. Allows voiceless sections to be excluded from analysis.</p>
</td></tr> 
<tr><td><code id="formanttrack_+3A_returnbw">returnbw</code></td>
<td>
<p>If TRUE, estimated formant bandwidths are returned.</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>This function works by repeatedly calling findformants(), and periodicity is established using pitchtrack(), both of which are included in this package. When no formants are found, or if less than the desired number of formants are found, a value of zero is returned for that formant, at that time point. 
</p>
<p>Tracked formants are presented over a greyscale spectrogram if show is TRUE. When plotting, different colors are used for each formant to allow the user to distinguish these.
</p>


<h3>Value</h3>

<p>A dataframe with the following elements is returned:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>The time, in milliseconds, of the middle of the analysis window.</p>
</td></tr>
<tr><td><code>f#</code></td>
<td>
<p>The formant frequency for formant number #, one column for each formant.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#data (sound)
#par (mfrow = c(2,1), mar = c(4,4,1,1))
#formanttrack (sound)
#formanttrack (sound, periodicity = 0)

</code></pre>

<hr>
<h2 id='freqresponse'>
Frequency Response
</h2><span id='topic+freqresponse'></span>

<h3>Description</h3>

<p>Find the frequency response of a digital filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqresponse (b, a, fs = 0, add = FALSE, show = TRUE,
              steps = 1000,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqresponse_+3A_b">b</code></td>
<td>
<p>The moving-average (MA), numerator coefficients of the filter.</p>
</td></tr> 
<tr><td><code id="freqresponse_+3A_a">a</code></td>
<td>
<p>The autoregressive (AR), denominator coefficients of the filter. Please note that the leading 1 at a[0] is not assumed.</p>
</td></tr> 
<tr><td><code id="freqresponse_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency of the sound. If this is not given calculations are presented as if fs = 1.</p>
</td></tr> 
<tr><td><code id="freqresponse_+3A_add">add</code></td>
<td>
<p>If TRUE, the frequency response plot is added to an existing plot.</p>
</td></tr> 
<tr><td><code id="freqresponse_+3A_show">show</code></td>
<td>
<p>If TRUE, the frequency response of the estimated filter is plotted.</p>
</td></tr> 
<tr><td><code id="freqresponse_+3A_steps">steps</code></td>
<td>
<p>The number of steps between zero and the Nyquist frequency.</p>
</td></tr> 
<tr><td><code id="freqresponse_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to internal plotting functions.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function plots (and optionally returns) the frequency response for the digital filter whose transfer function is determined by the numerator and denominator filter coefficients given in b and a.
</p>


<h3>Value</h3>

<p>A dataframe with two columns (frequency and response) that can be used to redraw the frequency response if required. The 'response' value corresponds to dB. magnitude below peak. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Lyons, R. G. (2004). Understanding Digital Signal Processing (2nd ed.). Prentice Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## make a synthetic vowel with a known set of formant frequencies
#sound = vowelsynth (ffs = c(500,1500,2500,3500,4500), 
#fbw = c(30, 80, 150, 200, 220),f0 = 100, dur = 100)

#plot (sound)

## let the LPC function estimate the filter used to generate the vowel
#coeffs = lpc (sound, show = FALSE)

## compare frequency response of estimated filter to vowel spectrum
#spectralslice (sound, col = 4, preemphasisf = 50)
#freqresponse (1, coeffs, add = TRUE, fs = 10000)

## generate a sinc function
#filt = sinc (seq (-15,15,1/2), normalized = TRUE)
## treat it as a low-pass FIR filter and inspect its frequency response
#freqresponse (filt, 1)

</code></pre>

<hr>
<h2 id='h95'>
Hillenbrand et al. (1995) Vowel Data
</h2><span id='topic+h95'></span>

<h3>Description</h3>

<p>Formant frequency, f0 and duration information for vowels collected from 139 speakers in the Hillenbrand et al. (1995) data. Speaker numbers have been modified to be uniquely identifying numbers. Data has been simplified so that only &quot;steady state&quot; formant frequency measures are given. Missing F2 values (n = 10) and F3 values (n = 41) have been imputed using the imputeformants() function included in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data (h95)</code></pre>


<h3>Format</h3>

<p>A data frame with 1668 observations on the following 9 variables:
</p>

<dl>
<dt><code>type</code></dt><dd><p> - A factor with levels <code>b</code> <code>g</code> <code>m</code> <code>w</code> representing speaker type: boy, girl, man and woman.</p>
</dd>
<dt><code>speaker</code></dt><dd><p> - A numeric vector indicating a uniquely identifying speaker number.</p>
</dd>
<dt><code>vowel</code></dt><dd><p> - The vowel category in x-sampa</p>
</dd>
<dt><code>dur</code></dt><dd><p> - A numeric vector indicating the duration of the vowel in milliseconds.</p>
</dd>
<dt><code>f0</code></dt><dd><p> - A numeric vector indcating the vowel f0 in Hz.</p>
</dd>
<dt><code>f1</code></dt><dd><p> - A numeric vector indcating the vowel F1 in Hz.</p>
</dd>
<dt><code>f2</code></dt><dd><p> - A numeric vector indcating the vowel F2 in Hz.</p>
</dd>
<dt><code>f3</code></dt><dd><p> - A numeric vector indcating the vowel F3 in Hz.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was created from data provided on Dr. Hillenbrand's personal website:
</p>
<p>http://homepages.wmich.edu/~hillenbr/voweldata.html
</p>


<h3>References</h3>

<p>Hillenbrand, J.M., Getty, L.A., Clark, M.J., and Wheeler, K. (1995). &quot;Acoustic characteristics of American English vowels,&quot; Journal of the Acoustical Society of America, 97, 3099-3111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data(h95)
#vowelplot (h95$f1, h95$f2, h95$vowel, logaxes = 'xy', ellipses = TRUE,
#xsampa = TRUE)
</code></pre>

<hr>
<h2 id='hotelling.test'>
Hotelling's T2 Test
</h2><span id='topic+hotelling.test'></span><span id='topic+print.hotelling.test'></span>

<h3>Description</h3>

<p>Hotelling's T2 test for one and two samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotelling.test(matrix1, matrix2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotelling.test_+3A_matrix1">matrix1</code></td>
<td>
<p>A numeric matrix or dataframe in which each row represents an observation of a multivariate random variable, and each column represents a dimension of that variable.</p>
</td></tr>
<tr><td><code id="hotelling.test_+3A_matrix2">matrix2</code></td>
<td>
<p>An optional second numeric matrix or dataframe of the same column rank as 'matrix1'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a single matrix is provided, this function tests the alternative hypothesis that all column means are not equal to zero. If a second matrix is provided, the alternative hypothesis to be tested is that the group means are not all equal. The statistic is tested using an F-distribution which assumes that the matrices represent (roughly) multivariate normal variables.
</p>
<p>This function is only designed for multivariate tests of location. If a univariate test is desired, please use a t-test.
</p>


<h3>Value</h3>

<p>An object of class 'Hotelling.test', a list containing the elements:
</p>
<table>
<tr><td><code>f.value</code></td>
<td>
<p>The value of the test statistic.</p>
</td></tr>
<tr><td><code>df1</code></td>
<td>
<p>The numerator degrees of freedom for the F statistic.</p>
</td></tr>
<tr><td><code>df2</code></td>
<td>
<p>The denominator degrees of freedom for the F statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p-value for the test.</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>The number of independent samples involved in the test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Hotelling, H. (1931). The generalization of Student's ratio. Annals of Mathematical Statistics 2 (3): 360-378. 
</p>
<p>http://en.wikipedia.org/wiki/Hotelling's_T-squared_distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load Peterson &amp; Barney data
#data (pb52)

## separate the Peterson &amp; Barney vowels by speaker
## gender and age (child vs. adult)
#men = pb52[pb52$sex == 'm' &amp; pb52$type == 'm',]
#women = pb52[pb52$sex == 'f' &amp; pb52$type == 'w',]
#boys = pb52[pb52$sex == 'm' &amp; pb52$type == 'c',]
#girls = pb52[pb52$sex == 'f' &amp; pb52$type == 'c',]

## fit 4 separate models which predict F1 frequency 
## on the basis of vowel category. 
#men = rcr (f1 ~ vowel, men$speaker, men)
#women = rcr (f1 ~ vowel, women$speaker, women)
#boys = rcr (f1 ~ vowel, boys$speaker, boys)
#girls = rcr (f1 ~ vowel, girls$speaker, girls)

## A Hotelling T2 test indicates that there are 
## significant differences in F1 frequency 
## based on vowel category between males and females
#hotelling.test (men$coefficients, women$coefficients)

## but no significant differences based on the same 
## criteria between boys and girls.
#hotelling.test (boys$coefficients, girls$coefficients)
</code></pre>

<hr>
<h2 id='imputeformants'>
Impute Missing Formant Values
</h2><span id='topic+imputeformants'></span>

<h3>Description</h3>

<p>Impute missing formant values using a least-squares approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeformants (ffs, speaker, vowel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputeformants_+3A_ffs">ffs</code></td>
<td>
<p>A numeric vector containing formant frequency measurements for a single formant. Values should be in Hz, and missing values need to be set to 0.</p>
</td></tr> 
<tr><td><code id="imputeformants_+3A_speaker">speaker</code></td>
<td>
<p>A vector indicating which speaker produced each formant.</p>
</td></tr> 
<tr><td><code id="imputeformants_+3A_vowel">vowel</code></td>
<td>
<p>A vector indicating which vowel category each formant belongs to.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function finds the least-squares approximation for each missing value based on the assumption that each formant for a given vowel differs between-speakers solely on the basis on a speaker-specific multiplicative parameter. This assumption is well supported in the literature (Nearey 1978, Nearey &amp; Assmann 2007, Turner et al. 2009). This parameter would be most closely related to gross speaker vocal-tract length.
</p>


<h3>Value</h3>

<p>A vector containing each original formant frequency and imputed formant frequencies where appropriate.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Nearey, T. M. (1978). Phonetic Feature Systems for Vowels. PhD thesis, Indiana University Linguistics Club. 
</p>
<p>Nearey, T. M. &amp; P. F. Assmann. (2007). Pobabilistic 'sliding template' models for indirect vowel normalization. in Experimental Approaches to Phonology, edited by M.J. Sole, P. S., Beddor, and M. Ohala (Oxford University Press, Oxford), pp. 246-269.
</p>
<p>Turner, R. E., Walters, T. C., Monaghan, J. J. M., &amp; Patterson, R. D. (2009). A statistical, formant-pattern model for segregating vowel type and vocal-tract length in developmental formant data. The Journal of the Acoustical Society of America, 125(4), 2374. doi:10.1121/1.3079772
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data (h95)

## Select F2 values from the tenth speaker in H95 data
## set the first 5 values to "missing"
#ffs = h95$f2
#ffs[h95$speaker == 10][1:5] = 0
#speaker = h95$speaker
#vowel = h95$vowel

## impute these missing values
#imputedf2 = imputeformants (ffs, speaker, vowel)

## resulting in a very close approximation of the original values
#plot (imputedf2[h95$speaker == 10], h95$f2[h95$speaker == 10])
#abline (0, 1, col = 2)
</code></pre>

<hr>
<h2 id='interpolate'>
Interpolation
</h2><span id='topic+interpolate'></span>

<h3>Description</h3>

<p>Piece-wise cubic or linear spline interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate (y, x = 1:length(y), steps = 20, increment = -1, 
show = FALSE, type = 'cubic', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_+3A_y">y</code></td>
<td>
<p>A vector of 'knots', between which the function will interpolate points.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_x">x</code></td>
<td>
<p>The 'x' coordinates corresponding to each knot. If not specified, the knots are assumed to be equally spaced.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_steps">steps</code></td>
<td>
<p>The number of interpolating steps between each knot. Increasing this number will result in a smoother interpolation. If the knots are not equally spaced along the x-axis, the interpolated points will not be equally spaced across the entire curve.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_increment">increment</code></td>
<td>
<p>If this is greater than 0, interpolated points are separated along the x-axis by this value. Note that if the knot locations are not multiples of this increment, there will be irregularities in the spacing of the interpolated points.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_show">show</code></td>
<td>
<p>If TRUE, the result of the interpolation is shown in a plot.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_type">type</code></td>
<td>
<p>If 'cubic', a natural cubic spline interpolation is performed. If 'linear', a linear interpolation is performed.</p>
</td></tr> 
<tr><td><code id="interpolate_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the internal call of plot() if show = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this function performs a 'natural' cubic spline interpolation between the points provided by the user. Optionally, a linear interpolation between the points may be carried out.
</p>


<h3>Value</h3>

<p>A dataframe with columns corresponding to the x and y dimensions of the interpolated points is returned.
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The x-axis coordinates of the interpolated points.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The y-axis coordinates of the interpolated points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Spline_interpolation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate ten random points
#y = rnorm (10, 0, 5)
#interpolate (y, show = TRUE)  ## plot a cubic interpolation
#linear = interpolate (y, type = 'linear')   
## and compare to a linear interpolation
#lines (linear, col = 2) 
</code></pre>

<hr>
<h2 id='ldboundary'>
Linear Discriminant Boundary
</h2><span id='topic+ldboundary'></span>

<h3>Description</h3>

<p>Given two mean vectors and a covariance matrix (and optional prior probabilities), this function will return the slope and intercept of the boundary line between the two categories.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldboundary (mean1, mean2, covariance, prior1 = .5, prior2 = .5, add = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldboundary_+3A_mean1">mean1</code></td>
<td>
<p>A mean vector for category 1, must contain 2 elements.</p>
</td></tr> 
<tr><td><code id="ldboundary_+3A_mean2">mean2</code></td>
<td>
<p>A mean vector for category 2, must contain 2 elements.</p>
</td></tr> 
<tr><td><code id="ldboundary_+3A_covariance">covariance</code></td>
<td>
<p>A 2x2 covariance matrix for both distributions.</p>
</td></tr> 
<tr><td><code id="ldboundary_+3A_prior1">prior1</code></td>
<td>
<p>The prior probability of category 1.</p>
</td></tr> 
<tr><td><code id="ldboundary_+3A_prior2">prior2</code></td>
<td>
<p>The prior probability of category 2.</p>
</td></tr> 
<tr><td><code id="ldboundary_+3A_add">add</code></td>
<td>
<p>If TRUE, the boundary line is added top the plot.</p>
</td></tr> 
<tr><td><code id="ldboundary_+3A_...">...</code></td>
<td>
<p>Additional parameters are passed to the internal call of the line plotting function, in the event that add = T.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>The slope and intercept of the boundary line are returned. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Linear_discriminant_analysis
https://onlinecourses.science.psu.edu/stat557/book/export/html/35
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create two groups with the same covariance patterns
#group1 = rmvtnorm (200, means= c(0,0), k=2, sigma = -.4)
#group2 = rmvtnorm (200, means= c(3,3), k=2, sigma = -.4)
#covariance = (var (group1) + var (group2)) / 2

## plot groups and boundary line between categories.
#plot (group1, col = 2, pch = 16, ylim = c(-2,5), xlim = c(-2,5))
#points (group2, col = 4, pch = 16)
#ldboundary (c(0,0), c(3,3), covariance, add = TRUE)

</code></pre>

<hr>
<h2 id='ldclassify'>
Linear Discriminant Classification
</h2><span id='topic+ldclassify'></span>

<h3>Description</h3>

<p>Classify items using linear discriminant analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldclassify (data, means, covariance, template = NULL, posterior = 'no')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldclassify_+3A_data">data</code></td>
<td>
<p>A matrix in which each row represents an item to be classified, and each column represents an observation from a variable describing the item.</p>
</td></tr> 
<tr><td><code id="ldclassify_+3A_means">means</code></td>
<td>
<p>A matrix of means where each row is a mean vector specifying a candidate category. The number of columns must equal the number of columns in data.</p>
</td></tr> 
<tr><td><code id="ldclassify_+3A_covariance">covariance</code></td>
<td>
<p>The pooled within-groups covariance matrix to be used for classification.</p>
</td></tr>
<tr><td><code id="ldclassify_+3A_template">template</code></td>
<td>
<p>A 'Template' object may be passed instead of a mean and covariance.</p>
</td></tr>
<tr><td><code id="ldclassify_+3A_posterior">posterior</code></td>
<td>
<p>If 'winner', the posterior probability of the winning category is returned. If 'all', the posterior of every category is returned.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function classifies the items described in the data matrix by comparing them to the reference patterns for the different candidate categories represented in the means matrix. The category with the minimum Mahalanobis distance to the observed pattern (i.e., a given row of the data matrix) is selected as the winner. Mahalanobis distances are found with using the covariance matrix provided to the function. 
</p>
<p>Mean and covariance matrices can be made easily for data using the createtemplate() function included in this package.
</p>


<h3>Value</h3>

<p>A vector of winning categories is returned. If winning posteriors are desired, these are returned in a second column. All posteriors are returned in separate columns for each category.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load Peterson &amp; Barney vowel data
#data (pb52)

## normalize vowel formant frequencies
#normdvowels = normalize (pb52[,7:9], pb52$speaker, pb52$vowel)
#formants = normdvowels[,1:3]
#vowels = pb52$vowel

## make a vowel template based on these frequencies
#template = createtemplate (formants, vowels) 

## classify vowels
#answers = ldclassify (formants, template$means, template$covariance)
## compare to known categories
#table (answers, vowels)
</code></pre>

<hr>
<h2 id='loadsound'>
Load WAV files into R
</h2><span id='topic+loadsound'></span><span id='topic+print.sound'></span><span id='topic+plot.sound'></span>

<h3>Description</h3>

<p>A function which allows WAV files to be loaded into R. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadsound (filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadsound_+3A_filename">filename</code></td>
<td>
<p>A string indicating the file name of the WAV file to be loaded. If no filename is provided, a dialog box will open allowing the user to select a file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is only compatible with 8 and 16 bit mono WAV files. The function returns a 'sound object'. Many of the functions included in this package interact with 'sound' objects.
</p>


<h3>Value</h3>

<p>An object of class 'sound', a list containing the elements:
</p>
<table>
<tr><td><code>filename</code></td>
<td>
<p>A vector containing the filename of the WAV file.</p>
</td></tr>
<tr><td><code>fs</code></td>
<td>
<p>The sampling frequency of the sound. </p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>The duration of the sound, in milliseconds. </p>
</td></tr>
<tr><td><code>sound</code></td>
<td>
<p>A vector of numeric values representing the sampled sound. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>https://ccrma.stanford.edu/courses/422/projects/WaveFormat/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the command below to select a WAV file to load into R
## sound = loadsound ()

## sound
## plot (sound)
## spectrogram (sound)
</code></pre>

<hr>
<h2 id='loadtable'>
Load Table
</h2><span id='topic+loadtable'></span>

<h3>Description</h3>

<p>Load text table data quickly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadtable (...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadtable_+3A_...">...</code></td>
<td>
<p>Arguments are passed to the internal call of read.table().</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function is a wrapper for read.table() for those times when you just don't feel like typing a filename. The function opens up a file selection dialog box allowing the user to select the file containing the data. 
</p>


<h3>Value</h3>

<p>Returns the output of read.table().
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## uncomment and run
# data = loadtable ()
# head (data)
</code></pre>

<hr>
<h2 id='lpc'>
Linear Predictive Coding
</h2><span id='topic+lpc'></span>

<h3>Description</h3>

<p>Predict autoregressive filter coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpc (sound, order = round(fs/1000)+3, fs = 10000, show = FALSE, 
add = FALSE, preemph = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpc_+3A_sound">sound</code></td>
<td>
<p>Either a numeric vector representing a sequence of samples taken from a sound wave or a sound object created with the loadsound() or makesound() functions.</p>
</td></tr>
<tr><td><code id="lpc_+3A_order">order</code></td>
<td>
<p>The number of LPC coefficients to be estimated. By default there is 2 per kHz below the Nyquist frequency plus 3 extra coefficients.</p>
</td></tr> 
<tr><td><code id="lpc_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency in Hz. If a sound object is passed this does not need to be specificed.</p>
</td></tr>
<tr><td><code id="lpc_+3A_show">show</code></td>
<td>
<p>If TRUE, the frequency response of the estimated filter is plotted.</p>
</td></tr> 
<tr><td><code id="lpc_+3A_add">add</code></td>
<td>
<p>If TRUE, the frequency response plot is added to an existing plot.</p>
</td></tr> 
<tr><td><code id="lpc_+3A_preemph">preemph</code></td>
<td>
<p>If TRUE, preemphasis of 3 dB per octave is applied to the sound before analysis.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>LPC coefficients are estimated using the autocorrelation method. The signal is windowed with a Hanning window prior to analysis.
</p>


<h3>Value</h3>

<p>A vector containing the LPC coefficients is returned.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make a synthetic vowel with a known set of formant frequencies
#sound = vowelsynth (ffs = c(500,1500,2500,3500,4500), 
#fbw = c(30, 80, 150, 200, 220),f0 = 100, dur = 250)

## let the LPC function estimate the filter used to generate the vowel
#coeffs = lpc (sound, show = TRUE)
</code></pre>

<hr>
<h2 id='makeFIR'>
Create a Digital Filter
</h2><span id='topic+makeFIR'></span>

<h3>Description</h3>

<p>Design a Finite Impulse Response (FIR) Filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFIR (frequency, dB, order = 200, signal = NULL, window = 'hann', 
         verify = FALSE, interpolation = 'linear')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFIR_+3A_frequency">frequency</code></td>
<td>
<p>The frequencies at which the frequency response of the filter will be specified. The first frequency specified must be equal to 0. The final frequency specified is assumed to be equal to fs/2.</p>
</td></tr> 
<tr><td><code id="makeFIR_+3A_db">dB</code></td>
<td>
<p>The power (in decibels) of the filter at each specified frequency.</p>
</td></tr> 
<tr><td><code id="makeFIR_+3A_order">order</code></td>
<td>
<p>The order of the signal.</p>
</td></tr> 
<tr><td><code id="makeFIR_+3A_signal">signal</code></td>
<td>
<p>If a signal is provided, it is filtered and returned.</p>
</td></tr> 
<tr><td><code id="makeFIR_+3A_window">window</code></td>
<td>
<p>The type of window to be applied to the filter impulse response. Uses the windowfunc() function included in this package.</p>
</td></tr>   
<tr><td><code id="makeFIR_+3A_verify">verify</code></td>
<td>
<p>If TRUE, a series of plots are created to allow the user to verify that the filter is appropriate.</p>
</td></tr> 
<tr><td><code id="makeFIR_+3A_interpolation">interpolation</code></td>
<td>
<p>Determines 'linear' or 'cubic' interpolation between the specified points. Uses the interpolate() function included in this package.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Designs Type I FIR filters of odd length (even order). If an odd order is provided, 1 is added to the order. Filters are designed using the window-design method. The filter frequency response is defined at evenly-spaced locations determined by the filter order and the sampling frequency. If frequency specifications do not fall exactly on these points, the nearest appropriate location is used. This design method may lead to 'undesirable' behaviour between specified frequencies. This can be minimized by increasing the filter order and selecting an appropriate window function. 
</p>


<h3>Value</h3>

<p>If output = TRUE, the impulse response of the filter specified by the user is returned.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Lyons, R. G. (2004). Understanding Digital Signal Processing (2nd ed.). Prentice Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## specify a filter with an arbitrary response
#frequency = c(0, 500, 502, 5000, 5002, 7000, 7002, 11025)
#dB = c(0, 0, -50,  -50, -10,  -10, -70, -70)

## create the filter and verify that the frequency response is as desired
#testfilter = makeFIR (frequency, dB, verify = TRUE, order = 1500)
#spectralslice (testfilter, padding = 1000)


## create the filter and verify that the frequency response is as desired
#makeFIR (frequency, dB, verify = TRUE, order = 300, signal = rnorm (1400))

</code></pre>

<hr>
<h2 id='makesound'>
Make a 'sound' object
</h2><span id='topic+makesound'></span>

<h3>Description</h3>

<p>Create a 'sound' object from a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makesound (sound, filename, fs = 22050)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makesound_+3A_sound">sound</code></td>
<td>
<p>A numeric vector representing a sound wave.</p>
</td></tr> 
<tr><td><code id="makesound_+3A_filename">filename</code></td>
<td>
<p>A string indicating the desired file name associated with this object.</p>
</td></tr> 
<tr><td><code id="makesound_+3A_fs">fs</code></td>
<td>
<p>The desired sampling frequency of the sound object.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function can make a vector into a 'sound' object. If a filename is not set, the filename defaults to 'sound.wav' where 'sound' indicates the name of the sound variable that was passed to the function. The benefit of working with 'sound' objects is that they carry their sampling frequency and filename (as well as some other information) with them. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>https://ccrma.stanford.edu/courses/422/projects/WaveFormat/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data (sound)
## take only the first 10000 samples from a 'sound' object
tmp = sound$sound[1:10000]
## and make a new 'sound' object
tmp = makesound (tmp, fs = 22050)
tmp

## get ready to make two plots with thin margins
#multiplot (2); par (mar = c(4,4,1,1));
## and show a spectrogram of the original
#spectrogram (sound)       

## and the new, truncated version
#spectrogram (tmp)         

</code></pre>

<hr>
<h2 id='multiplot'>
Plot with variable panel sizes
</h2><span id='topic+multiplot'></span>

<h3>Description</h3>

<p>Create plots with columns or rows of unequal sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiplot (n = 2, type = 'r', sizes = rep (1/n, n), show = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiplot_+3A_n">n</code></td>
<td>
<p>The number of figure panels to be created.</p>
</td></tr> 
<tr><td><code id="multiplot_+3A_type">type</code></td>
<td>
<p>If 'r', the panels will be arranged in rows, if 'c', the panels will be arranged in columns.</p>
</td></tr> 
<tr><td><code id="multiplot_+3A_sizes">sizes</code></td>
<td>
<p>A vector indicating the percentage of the total width/height taken up by each row/column.</p>
</td></tr> 
<tr><td><code id="multiplot_+3A_show">show</code></td>
<td>
<p>If TRUE, the resulting panel layout is shown to the user.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function is essentially a wrapper for the layout() function, which allows the user to create multi-panel figures in which each row or column is of a varying height/width.
</p>
<p>Please note that small rows or columns might result in an error related to figure margins being too large when you try to create a plot. These may be reduced with the 'mar' parameter for the par() function, which sometimes solves the problem. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## uncomment and run

data (sound)
## run this instead to select your own sound for this demo.
# sound = loadsound ()       

#par (mar = c(4,4,1,1))
#multiplot (n = 3, sizes = c(.25, .5, .25))  

#plot (sound)
#spectrogram (sound, dynamicrange = 50, maxfreq = 7000)
#spectralslice (sound)

</code></pre>

<hr>
<h2 id='normalize'>
Normalize Vowels
</h2><span id='topic+normalize'></span>

<h3>Description</h3>

<p>Function to normalize vowels using one of several methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(formants, speakers, vowels, method = 'neareyE', 
          corners = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_formants">formants</code></td>
<td>
<p>A matrix or dataframe containing formant frequency information for vowels. Each row is assumed to indicate data from a single vowel. At least two columns (indicating information regarding at least two formants) are required.</p>
</td></tr>
<tr><td><code id="normalize_+3A_speakers">speakers</code></td>
<td>
<p>A vector indicating which speaker produced each vowel in 'formants'. The length of this vector must equal the number of rows in 'formants'.</p>
</td></tr>
<tr><td><code id="normalize_+3A_vowels">vowels</code></td>
<td>
<p>A vector indicating the vowel category of each vowel in 'formants'. The length of this vector must equal the number of rows in 'formants'.</p>
</td></tr>
<tr><td><code id="normalize_+3A_method">method</code></td>
<td>
<p>A string indicating the desired method. Choices are 'neareyE', 'neareyI', 'lobanov' and 'wandf'. See details for more information.</p>
</td></tr>
<tr><td><code id="normalize_+3A_corners">corners</code></td>
<td>
<p>For the 'wandf' method, a vector of two strings indicating the lowest F1-highest F2 vowel, and the highest F1-intermediate F2 vowel for the vowel system. In most vowel systems these are an /i/-like vowel, and an /a/-like vowel, respectively. Vowels must be provided in that order. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function normalizes vowels based on provided formant frequencies (FFs). The available methods are:
</p>
<p>Nearey formant-extrinsic log-mean ('neareyE'): This method finds the logarithmic-mean FF across all vowels produced by a speaker, and subtracts this value from the log-transformed FFs representing each vowel. 
</p>
<p>Nearey formant-intrinsic log-mean ('neareyI'): This method finds the logarithmic-mean for each formant independently across all vowels produced by a speaker. The log-mean for each individual formant is then subtracted from the log-transformed FF representing each vowel. 
</p>
<p>Lobanov ('lobanov'): This method finds the mean and standard deviation for each formant. FFs are then standardized (in the statistical sense) using these estimated parameters for each speaker, for each formant. 
</p>
<p>Watt and Fabricius ('wandf'): This method requires the user to provided point vowels representing the frontmost and highest vowel, and the lowest (and, ideally central) vowel in a vowel system. An estimate of the centroid of the vowel system is calculated based on these values. Normalized FFs are then expressed as the ratio of observed FFs to the estimated centroids, independently for F1 and F2.  
</p>
<p>For both Nearey methods, and the Lobanov method, the average is found for each vowel category within-speaker before calculating the overall mean. As a result, the data from each speaker may contain unequal numbers of each vowel category. However, all speakers must be represented by the same vowel categories or the result will be (possibly) subtle differences in normalized vowel spaces dues to the possibly differing estimates of means and stadard deviations of the different formants. 
</p>


<h3>Value</h3>

<p>A dataframe with the same numbers of rows as the formant data provided and the following columns:
</p>
<table>
<tr><td><code>formants</code></td>
<td>
<p>A column corresponding to each formant provided. These are named 'fn' where n corresponds to the formant number.</p>
</td></tr>
<tr><td><code>speakers</code></td>
<td>
<p>A column indicated which speaker produced each vowel.</p>
</td></tr>
<tr><td><code>vowels</code></td>
<td>
<p>A column indicating which vowel is represented in each row.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Lobanov, B. M. (1971). Classification of Russian vowels spoken by different listeners. Journal of the Acoustical Society of America 49:606-08.
</p>
<p>Nearey, T. M. (1978). Phonetic Feature Systems for Vowels. PhD thesis, Indiana University Linguistics Club. 
</p>
<p>Watt, D. and Fabricius, A. (2002). Evaluation of a technique for improving the mapping of multiple speakers' vowel spaces in the F1 ~ F2 plane. In D. Nelson, Leeds Working Papers in Linguistics and Phonetics 9:159-73.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## normalize all Peterson &amp; Barney (1952) vowels using each method.
#data (pb52)

#neareyE = normalize (pb52[,7:9], pb52$speaker, pb52$vowel,
#method = 'neareyE')
#neareyI = normalize (pb52[,7:9], pb52$speaker, pb52$vowel,
#method = 'neareyI')
#lobanov = normalize (pb52[,7:9], pb52$speaker, pb52$vowel,
#method = 'lobanov')
#wandf = normalize (pb52[,7:9], pb52$speaker, pb52$vowel,
#method = 'wandf', corners =  c('i','A'))

## compare normalization methods using vowelplot().
#par (mfrow = c(2,2), mar = c(4,4,3,1))
#vowelplot (neareyE[,1], neareyE[,2], neareyE$vowel, alternateAxes = TRUE, 
#  pointType = 16, main = 'neareyE', ellipses = TRUE)
#vowelplot (neareyI[,1], neareyI[,2], neareyI$vowel, alternateAxes = TRUE, 
#  pointType = 16, main = 'neareyI', ellipses = TRUE)
#vowelplot (lobanov[,1], lobanov[,2], lobanov$vowel, alternateAxes = TRUE, 
#  pointType = 16, main = 'lobanov', ellipses = TRUE)
#vowelplot (wandf[,1], wandf[,2], wandf$vowel, alternateAxes = TRUE, 
#  pointType = 16, main = 'wandf', ellipses = TRUE)
</code></pre>

<hr>
<h2 id='normalize.compare'>
Compare Normalization Methods
</h2><span id='topic+normalize.compare'></span>

<h3>Description</h3>

<p>Compare the effectiveness of different normalization methods. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize.compare (normd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize.compare_+3A_normd">normd</code></td>
<td>
<p>A list of dataframes containing the different formant data to be compared. Each dataframe must contain columns called &quot;f1&quot;, &quot;f2&quot;, &quot;speaker&quot;, and &quot;vowel&quot;, in any order.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function provides a relatively straightforward way to compare the effectiveness of different normalization methods based on the assumption that a good normalization method maximizes the separation between different vowel categories and minimizes the variation within a single vowel category. Minimizing the variation within a single vowel category means that the vowel spaces of different speakers are maximally similar. 
</p>
<p>This function provides two measures to compare the performance of normalization methods:
</p>
<p>1) The square root of the average Mahalanobis distance between vowel categories is found for all pairs of vowel categories. This value indicates the average separation of vowel categories with respect to within-category error and the covariance patterns of the formant frequencies. A higher value indicates a better performing normalization algorithm.  
</p>
<p>2) The percentage of correct classifications using a linear discriminant model trained on the normalized formant-frequencies using the given category-labels. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the Peterson and Barney vowels
#data (pb52)

## normalize using several different methods
#neareyE = normalize (pb52[,7:9], pb52$speaker, pb52$vowel, 
#method = 'neareyE')
#neareyI = normalize (pb52[,7:9], pb52$speaker, pb52$vowel, 
#method = 'neareyI')
#lobanov = normalize (pb52[,7:9], pb52$speaker, pb52$vowel, 
#method = 'lobanov')
#wandf = normalize (pb52[,7:9], pb52$speaker, pb52$vowel, 
#method = 'wandf', corners =  c('i','A'))
#normd = list (pb52, neareyE, neareyI, lobanov, wandf)

## compare outcome of methods (and unnormalized vowels)
## uncomment to run
#normalize.compare (normd)
</code></pre>

<hr>
<h2 id='ntypes'>
Number of Unique Elements
</h2><span id='topic+ntypes'></span>

<h3>Description</h3>

<p>Find the number of unique elements in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ntypes (vector) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ntypes_+3A_vector">vector</code></td>
<td>
<p>The vector of interest.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>A simple function that converts a vector to a factor, and finds the number of levels. This provides the number of unique elements in a vector, something I find I frequently need. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data (pb52)
## the number of unique vowel categories.
ntypes (pb52$vowel)
</code></pre>

<hr>
<h2 id='p73'>
Pols et al. (1973) Dutch Vowel Data
</h2><span id='topic+p73'></span>

<h3>Description</h3>

<p>Formant frequency information for vowels averaged across 24 male speakers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data (p73)</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt><code>sex</code></dt><dd><p> - A factor indicating speaker sex.</p>
</dd>
<dt><code>vowel</code></dt><dd><p> - The vowel category in x-sampa.</p>
</dd>
<dt><code>f1</code></dt><dd><p> - A numeric vector indcating the vowel F1 in Hz.</p>
</dd>
<dt><code>f2</code></dt><dd><p> - A numeric vector indcating the vowel F2 in Hz.</p>
</dd>
<dt><code>f3</code></dt><dd><p> - A numeric vector indcating the vowel F3 in Hz.</p>
</dd>
</dl>



<h3>References</h3>

<p>Pols, L. C. W., Tromp, H. R. C., &amp; Plomp, R. (1973). Frequency analysis of Dutch vowels from 50 male speakers. Journal of the Acoustical Society of America, 53. 1093-1101. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(p73)
#vowelplot (p73$f1, p73$f2, p73$vowel, logaxes = 'xy', ellipses = TRUE, 
#xsampa = TRUE)
</code></pre>

<hr>
<h2 id='pb52'>
Peterson &amp; Barney (1952) Vowel Data
</h2><span id='topic+pb52'></span>

<h3>Description</h3>

<p>Formant frequency and f0 information for vowels collected from 76 speakers in the Peterson &amp; Barney (1952) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data (pb52)</code></pre>


<h3>Format</h3>

<p>A data frame with 1520 observations on the following 9 variables:
</p>

<dl>
<dt><code>type</code></dt><dd><p> - A factor with levels <code>c</code> <code>m</code> <code>w</code> representing speaker type: child, man and woman.</p>
</dd>
<dt><code>sex</code></dt><dd><p> - A factor with levels <code>f</code> <code>m</code> representing speaker gender: male and female.</p>
</dd>
<dt><code>speaker</code></dt><dd><p> - A numeric vector indicating a uniquely identifying speaker number.</p>
</dd>
<dt><code>vowel</code></dt><dd><p> - The vowel category in x-sampa.</p>
</dd>
<dt><code>repetition</code></dt><dd><p> - A numeric vector indicating the repetition number.</p>
</dd>
<dt><code>f0</code></dt><dd><p> - A numeric vector indcating the vowel f0 in Hz.</p>
</dd>
<dt><code>f1</code></dt><dd><p> - A numeric vector indcating the vowel F1 in Hz.</p>
</dd>
<dt><code>f2</code></dt><dd><p> - A numeric vector indcating the vowel F2 in Hz.</p>
</dd>
<dt><code>f3</code></dt><dd><p> - A numeric vector indcating the vowel F3 in Hz.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was created from tables provided within Praat:
</p>
<p>http://www.fon.hum.uva.nl/praat/
</p>


<h3>References</h3>

<p>Peterson, G.E. &amp; Barney (1952). Control methods used in a study of the vowels. Journal of the Acoustical Society of America 24: 175-184.
</p>
<p>Boersma, Paul &amp; Weenink, David (2012). Praat: doing phonetics by computer [Computer program]. Version 5.3.19, retrieved 24 June 2012 from http://www.praat.org/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pb52)
#vowelplot (pb52$f1, pb52$f2, pb52$vowel, logaxes = 'xy', ellipses = TRUE, 
#xsampa = TRUE)
</code></pre>

<hr>
<h2 id='peakfind'>
Find the Peaks
</h2><span id='topic+peakfind'></span>

<h3>Description</h3>

<p>Locate the peaks in a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peakfind (x, show = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peakfind_+3A_x">x</code></td>
<td>
<p>A vector whose peaks are to be located.</p>
</td></tr> 
<tr><td><code id="peakfind_+3A_show">show</code></td>
<td>
<p>If TRUE, the vector is plotted and peaks are indicated with red triangles.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function looks for peaks by finding elements whose value is greater than both the elements that surround it. If no peaks are found, a value of zero is returned. 
</p>


<h3>Value</h3>

<p>A vector indicating the location (position in the vector) of peaks in the vector.  
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data (sound)
#sound2 = sound$sound[10000:11000] 
#spectrum = spectralslice (sound2, padding = 0, output = TRUE, show = TRUE)
#peakfind (spectrum[,2])
</code></pre>

<hr>
<h2 id='phasor'>
Plot Phasors
</h2><span id='topic+phasor'></span>

<h3>Description</h3>

<p>Plot phasors representing one or more complex-valued variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phasor (num, scaled = TRUE, add = FALSE, circle = FALSE, 
        xlim, ylim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phasor_+3A_num">num</code></td>
<td>
<p>A complex-valued variable to be plotted as a phasor, or a vector of such variables.</p>
</td></tr> 
<tr><td><code id="phasor_+3A_scaled">scaled</code></td>
<td>
<p>If TRUE, phasor magnitudes are scaled to 1.</p>
</td></tr> 
<tr><td><code id="phasor_+3A_add">add</code></td>
<td>
<p>If TRUE, phasors are plotted on existing figure. If FALSE, a new plot is created.</p>
</td></tr> 
<tr><td><code id="phasor_+3A_circle">circle</code></td>
<td>
<p>If TRUE and scaled is TRUE, the unit circle is drawn.</p>
</td></tr> 
<tr><td><code id="phasor_+3A_xlim">xlim</code></td>
<td>
<p>x-axis range.</p>
</td></tr> 
<tr><td><code id="phasor_+3A_ylim">ylim</code></td>
<td>
<p>y-axis range.</p>
</td></tr> 
<tr><td><code id="phasor_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the internal call of 'plot' and 'arrows'.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Complex-valued variables may be created using the complex() function.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#noise = rnorm (100)
#phasors = fft(noise)

#par (mfrow = c(1,3))
#phasor (phasors)
#phasor (phasors, circle = TRUE)
#phasor (phasors, scaled = FALSE)

</code></pre>

<hr>
<h2 id='pickIPA'>
Pick IPA Symbols
</h2><span id='topic+pickIPA'></span><span id='topic+ipainfo'></span>

<h3>Description</h3>

<p>Select IPA symbols that you wish to include in a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pickIPA (vowels, n = 0, xsampa = FALSE, description = FALSE, 
         verify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pickIPA_+3A_vowels">vowels</code></td>
<td>
<p>An optional vector of vowel labels that you would like to plot using IPA symbols.</p>
</td></tr> 
<tr><td><code id="pickIPA_+3A_n">n</code></td>
<td>
<p>If no vowel vector is provided, the number of symbols desired.</p>
</td></tr> 
<tr><td><code id="pickIPA_+3A_xsampa">xsampa</code></td>
<td>
<p>If TRUE, x-sampa versions of the symbols are returned.</p>
</td></tr> 
<tr><td><code id="pickIPA_+3A_description">description</code></td>
<td>
<p>If TRUE, description of the place, manner and voicing of the symbols are also returned.</p>
</td></tr> 
<tr><td><code id="pickIPA_+3A_verify">verify</code></td>
<td>
<p>If TRUE, the selected symbols are plotted in the order indicated by the user, allowing visual confirmation of the selected symbols.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This is an interactive function that allows the user to select IPA symbols for plotting using a chart. The values returned by this function may only be passed to the 'pch' parameter within plotting functions. At the moment it has only been implemented for vowel sounds.
</p>
<p>If a vowels vector is given, the function finds the number of categories in the vector. The user is then prompted to select the IPA symbol corresponding to each category by clicking on the correct location on the plot.  
</p>
<p>If a vowels vector is not provided, the function allows the user to select any desired number of symbols, and returns these in the same order as indicated by the user. 
</p>
<p>**There may be issues when exporting figures to PDF using IPA font. Exporting plots directly as images works 'out of the box'**
</p>


<h3>Value</h3>

<p>A list with the following columns (some of which are optional):
</p>
<table>
<tr><td><code>IPA</code></td>
<td>
<p>The symbol which should be passed to 'pch' to plot IPA symbols.</p>
</td></tr>
<tr><td><code>xsampa</code></td>
<td>
<p>The xsampa representation of each IPA character.</p>
</td></tr>
<tr><td><code>description</code></td>
<td>
<p>If description = TRUE, a description of each sound.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/X-SAMPA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##uncomment to run
#vowels = pickIPA (n = 3)
#plot (c(1,2,3), c(1,2,3), pch = vowels)

## select vowels in the order displayed in the console
## to obtain symbols and descriptions of the vowel categories 
## in the Peterson and Barney data. 

# data (pb52)
# tmp = pickIPA (pb52$vowel, description = TRUE, xsampa = TRUE)
# tmp
</code></pre>

<hr>
<h2 id='pitchtrack'>
Pitch Tracking
</h2><span id='topic+pitchtrack'></span>

<h3>Description</h3>

<p>Create a pitch track for a sound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pitchtrack (sound, f0range = c(60,400), timestep = 2, fs = 22050, minacf = .5,
correction = TRUE, show = TRUE, windowlength = 50, addtospect = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pitchtrack_+3A_sound">sound</code></td>
<td>
<p> A numeric vector representing a waveform, or a 'sound' object created with the loadsound() or makesound() functions.</p>
</td></tr> 
<tr><td><code id="pitchtrack_+3A_f0range">f0range</code></td>
<td>
<p> A numeric vector of length two where the first value corresponds to the minimum f0 Hz to be considered, and the second represents the maximum to be considered.</p>
</td></tr> 
<tr><td><code id="pitchtrack_+3A_timestep">timestep</code></td>
<td>
<p> How far the analysis window will advance, in milliseconds. If this value is set to zero, the function is applied to the entire signal.</p>
</td></tr> 
<tr><td><code id="pitchtrack_+3A_fs">fs</code></td>
<td>
<p> The sampling frequency of the sound. If a 'sound' or 'ts' object is passed, this does not need to be specified.</p>
</td></tr> 
<tr><td><code id="pitchtrack_+3A_minacf">minacf</code></td>
<td>
<p> Autocorrelation values below this are ignored.</p>
</td></tr> 
<tr><td><code id="pitchtrack_+3A_correction">correction</code></td>
<td>
<p> If TRUE, ACF values are corrected for lag value.</p>
</td></tr> 
<tr><td><code id="pitchtrack_+3A_show">show</code></td>
<td>
<p> If TRUE, a plot displaying the pitch track is created.</p>
</td></tr> 
<tr><td><code id="pitchtrack_+3A_windowlength">windowlength</code></td>
<td>
<p> The length of the analysis window, in milliseconds. This should be approximately three-times longer than the wavelength of the lowest pitch. The default value is appropriate for a floor of 60 Hz.</p>
</td></tr> 
<tr><td><code id="pitchtrack_+3A_addtospect">addtospect</code></td>
<td>
<p> If TRUE, the pitch track is added to a spectrogram created with the spectrogram() function included in this package. The track is scaled up by a factor of 10 (e.g., 100 Hz will be plotted at 1000 Hz on the spectrogram) so that it will fit nicely in the typical spectrogram range of 0-5000 Hz.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Pitch tracking is carried out using a simplified version of the algorithm described in Boersma (1993), including corrections for lag value and window function. When plotting pitch tracks, the points sizes are proportional to autocorrelation values.  
</p>


<h3>Value</h3>

 
<p>A dataframe with the following columns:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p> The analysis window centre point, in milliseconds.</p>
</td></tr>
<tr><td><code>f0</code></td>
<td>
<p> The calculated f0 (pitch).</p>
</td></tr>
<tr><td><code>acf</code></td>
<td>
<p> The value of the autocorrelation function corresponding to the winning f0.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Boersma, P., (1993). Accurate short-term analysis of the fundamental frequency and the harmonics-to-noise ratio of a sampled sound. Proc. Instit. Phon. Sci. 17: 97-110.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#data (sound)               ## use the example 'sound' object provided
#sound = loadsound()       ## or run this line to use you own sound

## to generate a pitch track
#output = pitchtrack (sound)

## to add a pitch to a spectrogram
#spectrogram (sound)
#pitchtrack (sound, addtospect = TRUE)
 
</code></pre>

<hr>
<h2 id='playsound'>
Play Sounds
</h2><span id='topic+playsound'></span><span id='topic+play'></span>

<h3>Description</h3>

<p>Play sounds in R using VLC Player.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>playsound  (sound, path = 'default', fs = 10000, erase = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="playsound_+3A_sound">sound</code></td>
<td>
<p>Either a sound object, or a numeric vector to be played.</p>
</td></tr> 
<tr><td><code id="playsound_+3A_path">path</code></td>
<td>
<p>The location of VLC.exe on your computer. 'default' provides the default for a standard windows installation of VLC player. If this is set to 'pick', a dialog box opens allowing the user to specify the path.</p>
</td></tr> 
<tr><td><code id="playsound_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency in Hz. If a 'sound' or 'ts' object is passed this does not need to be specified.</p>
</td></tr>
<tr><td><code id="playsound_+3A_erase">erase</code></td>
<td>
<p>If TRUE, the temporary WAV file created is deleted after playing.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The sound is written out as a .wav file and VLC is called from the command line to play the file. The file is optionally erased after the fact. If the path is selected by the user, this is returned for use in future calls. Obviously, this function relies on VLC being installed. With the appropriate path, it seems like this function should work on Linux and OSX, though it has only been tested on a Windows computer. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  ## make a 1 second, 100 Hz tone.
#  tone = sinusoid (freqs = 250, dur = 1000, fs = 1000)[,2]
#  ## play it in VLC player
#  playsound (q[,2], fs = 1000, erase = FALSE)
</code></pre>

<hr>
<h2 id='polezero'>
Pole-zero Plots
</h2><span id='topic+polezero'></span>

<h3>Description</h3>

<p>Generate a Pole-zero plot from filter coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polezero (b, a, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polezero_+3A_b">b</code></td>
<td>
<p>The filter moving-average (MA) coefficients.</p>
</td></tr> 
<tr><td><code id="polezero_+3A_a">a</code></td>
<td>
<p>The filter autoregressive (AR) coefficients.</p>
</td></tr> 
<tr><td><code id="polezero_+3A_...">...</code></td>
<td>
<p>Additional parameters are passed to the internal call of plot().</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function plots filter poles (x) and zeros (o) based on the given coefficients.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Pole
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example of a typical single-zero preemphasis filter
#a = 1
#b = c(1, -.94)
#polezero (b, a)

#example of a complex-pole formant-style filter
#a = c(1, -.3, .2)
#b = c(1)
#polezero (b, a)
</code></pre>

<hr>
<h2 id='powertrack'>
Power tracking
</h2><span id='topic+powertrack'></span>

<h3>Description</h3>

<p>Create a power track for a sound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powertrack (sound, timestep = 5, windowlength = 30, 
            fs = 22050, show = TRUE, zeromax = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powertrack_+3A_sound">sound</code></td>
<td>
<p>A numeric vector representing a waveform, or a 'sound' object created with the loadsound() or makesound() functions.</p>
</td></tr> 
<tr><td><code id="powertrack_+3A_timestep">timestep</code></td>
<td>
<p>Determines how far the window will be moved for each adjacent analysis, in milliseconds.</p>
</td></tr> 
<tr><td><code id="powertrack_+3A_windowlength">windowlength</code></td>
<td>
<p>Determines how much of the signal is included for each analysis step, in milliseconds. If this is too small, pitch-synchronous ripples will be seen in the track.</p>
</td></tr> 
<tr><td><code id="powertrack_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency of the sound. If a 'sound' or 'ts' object is passed, this does not need to be specified.</p>
</td></tr> 
<tr><td><code id="powertrack_+3A_show">show</code></td>
<td>
<p>If TRUE, the track is plotted.</p>
</td></tr> 
<tr><td><code id="powertrack_+3A_zeromax">zeromax</code></td>
<td>
<p>If TRUE, the maximum dB value is set to zero.</p>
</td></tr> 
<tr><td><code id="powertrack_+3A_...">...</code></td>
<td>
<p>Additional parameters are passed to the internal call of plot(), and used to create the figure.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Returns the average power in the signal in a section as determined by the parameters of the function. A Hann window is applied to each section prior to analysis. Sections with zero power are ignored and not returned. 
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p> The time, in milliseconds, of each point of analysis.</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p> The power, in decibels, at each analysis point.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## plot the waveform and power of a given sound.
#data (sound)
# sound = loadsound()        ## run this line to use you own sound

## compare waveform and power
#par (mfrow = c(2,1), mar = c(4,4,1,1));
#plot (sound)
#powertrack (sound)
</code></pre>

<hr>
<h2 id='preemphasis'>
Add Preemphasis
</h2><span id='topic+preemphasis'></span>

<h3>Description</h3>

<p>Single-zero preemphasis filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preemphasis (input, cutoff = 50, fs = 22050, verify = FALSE, 
coeff = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preemphasis_+3A_input">input</code></td>
<td>
<p>Either a numeric vector representing a sequence of samples taken from a sound wave or a sound object created with the loadsound() or makesound() functions.</p>
</td></tr>
<tr><td><code id="preemphasis_+3A_cutoff">cutoff</code></td>
<td>
<p>The spectral slope is increased by 6 dB. per octave above this frequency.</p>
</td></tr> 
<tr><td><code id="preemphasis_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency of the sound. If a 'sound' object is passed, this does not need to be specified.</p>
</td></tr> 
<tr><td><code id="preemphasis_+3A_verify">verify</code></td>
<td>
<p>If TRUE, before and after spectra are plotted to allow the user to visually verify the process.</p>
</td></tr> 
<tr><td><code id="preemphasis_+3A_coeff">coeff</code></td>
<td>
<p>Optionally, the single coefficient used by the filter may be specified.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>The modified sound is returned. If a 'sound' object another 'sound' object is returned. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>http://www.fon.hum.uva.nl/praat/manual/Sound__Filter__pre-emphasis____.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#signal = sinusoid (c(100, 200, 400, 800, 1600), fs = 4000, 
#dur = 100, sum = TRUE)[,7]

#preemphasis (signal, verify = TRUE, fs = 4000, cutoff = 50)
</code></pre>

<hr>
<h2 id='PSTM'>
Probabilistic Sliding Template Model
</h2><span id='topic+PSTM'></span><span id='topic+mscohere'></span><span id='topic+iplot'></span><span id='topic+outlier.plot'></span>

<h3>Description</h3>

<p>Classify Vowels Using the Probabilistic Sliding Template Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSTM (ffs, f0, template, winner = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSTM_+3A_ffs">ffs</code></td>
<td>
<p>A matrix of formant frequencies in which each row represents a single vowel token, and each column represents a formant frequency. At least 3 formants need to be specified for every vowel.</p>
</td></tr> 
<tr><td><code id="PSTM_+3A_f0">f0</code></td>
<td>
<p>A vector containing the average f0 measured for each vowel to be classified. The length of this vector must equal the number of rows in ffs.</p>
</td></tr>
<tr><td><code id="PSTM_+3A_template">template</code></td>
<td>
<p>A 'template' object created with the createtemplate() function provided in this package. If no template is specified, vowels are classified relative to vowels from Edmonton English.</p>
</td></tr>
<tr><td><code id="PSTM_+3A_winner">winner</code></td>
<td>
<p>If TRUE, only the winner of each classification is returned. If FALSE, information regarding all candidate vowels is returned. See 'value' subsection for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The classic log-mean normalization method of Nearey (1978) helps compare the vowels produced by different speakers by controlling for the log-mean formant frequency (FF) produced by a speaker. This approach to normalization assumes that variation in the vowel spaces of speakers of the same dialect is primarily according to a single multiplicative parameter. When this speaker-specific scaling parameter is controlled for, differences in the vowel spaces of different speakers are minimized. 
</p>
<p>The Probabilistic Sliding Template Model (PSTM) of Nearey and Assmann (2007) attempts to predict perceived vowel quality by 'guessing' an appropriate speaker-specific scaling parameter and normalizing vowels using this estimated parameter. 'Method 6' of the PSTM (described in Nearey &amp; Assmann, 2007) is used to estimate the necessary parameter. After normalization, vowels are classified by comparing them to a provided reference template, which can be created using the createtemplate() function included in this package. Normalized or unnormalized vowels may be classified, as long as the same transformations are performed on the data used to create the template and the data being classified.  
</p>
<p>If no template is passed, the model identifies vowels relative to the vowel system of Edmonton English speakers. For in-depth details regarding the specifics of this model, please see Nearey &amp; Assmann (2007).
</p>


<h3>Value</h3>

<p>If winner = TRUE:
</p>
<p>A dataframe with the following columns:
</p>
<table>
<tr><td><code>vowel</code></td>
<td>
<p>The label for each winning vowel.</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>The optimal psi determined for the winning vowel.</p>
</td></tr>
<tr><td><code>postprob</code></td>
<td>
<p>The posterior probability of observing the winning vowel, given the formants and the psi.</p>
</td></tr>
</table>
<p>If winner = FALSE:
</p>
<p>A list of dataframes, each of which contains information for every candidate vowel category for each token to be classified. Each dataframe has the following columns:
</p>
<table>
<tr><td><code>vowel</code></td>
<td>
<p>The label for each candidate vowel category.</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>The optimal psi determined for each vowel category.</p>
</td></tr>
<tr><td><code>postprob</code></td>
<td>
<p>The posterior probability of observing each vowel category, given the formants and the psi.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Nearey, T. M. (1978). Phonetic Feature Systems for Vowels. PhD thesis, Indiana University Linguistics Club. 
</p>
<p>Nearey, T. M. &amp; P. F. Assmann. (2007). Pobabilistic 'sliding template' models for indirect vowel normalization. in Experimental Approaches to Phonology, edited by M.J. Sole, P. S., Beddor, and M. Ohala (Oxford University Press, Oxford), pp. 246-269.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load Peterson &amp; Barney vowel data
#data (pb52)

## normalize vowel formant frequencies
#normdvowels = normalize (pb52[,7:9], pb52$speaker, pb52$vowel)
#formants = normdvowels[,1:3]
#vowels = pb52$vowel

## make a vowel template based on these frequencies
#template = createtemplate (formants, vowels) 

## first classify only the first three vowels
#ffs = pb52[1:3,c(7:9)] 
#f0 = pb52[1:3,6]

## outputting only the winners, and then the full posterior probabilities
#PSTM (ffs, f0, template)
#PSTM (ffs, f0, template, winner = FALSE)

## now classify all vowels
## uncomment to run
#ffs = pb52[,c(7:9)] 
#f0 = pb52[,6]  
#winner = PSTM (ffs, f0, template)
## with a good degree of accuracy
#table (winner$vowel, pb52$vowel)
</code></pre>

<hr>
<h2 id='pwelch'>
Welch's Power Spectral Density Estimate
</h2><span id='topic+pwelch'></span>

<h3>Description</h3>

<p>Calculates a power spectral density estimate using Welch's method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwelch (sound, points = 0, overlap = 0, padding = 0, 
window = 'hamming', show = TRUE, fs = 1, preemphasisf = 0, 
zeromax = TRUE, type,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwelch_+3A_sound">sound</code></td>
<td>
<p>A vector representing a sound wave, or a 'sound' object.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_points">points</code></td>
<td>
<p>The number of points to be included in each window. If not specified, the sound is divided into 10 equally-sized windows.</p>
</td></tr> 
<tr><td><code id="pwelch_+3A_overlap">overlap</code></td>
<td>
<p>The amount of overlap between adjacent segments, in points.</p>
</td></tr> 
<tr><td><code id="pwelch_+3A_padding">padding</code></td>
<td>
<p>The amount of zero padding to be applied to each window.</p>
</td></tr> 
<tr><td><code id="pwelch_+3A_window">window</code></td>
<td>
<p>The window to be applied to each segment of the signal. See windowfunc() for available options.</p>
</td></tr> 
<tr><td><code id="pwelch_+3A_show">show</code></td>
<td>
<p>If FALSE, no plot is created.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency of the sound. If a 'sound' object is passed this does not need to be specified.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_preemphasisf">preemphasisf</code></td>
<td>
<p>Preemphasis of 3 dB per octave is added to frequencies above the specified frequency.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_zeromax">zeromax</code></td>
<td>
<p>If TRUE, the maximum dB is set to 0.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_type">type</code></td>
<td>
<p>The line type to be used for plotting, passes its value to the 'lty' parameter.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_...">...</code></td>
<td>
<p>any additional arguments will be passed to the internal calls of 'plot'.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function divides the signal into a number of equally-sized windows, finds the power spectrum of each one, and then finds the average across all windowed sections. 
</p>


<h3>Value</h3>

<p>The following columns:
</p>
<table>
<tr><td><code>hz</code></td>
<td>
<p>The center frequency of the analysis bins.</p>
</td></tr>
<tr><td><code>dB</code></td>
<td>
<p>The dB magnitude/power for the analysis bin.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## make a sine wave
#sinewave = sinusoid (f = 300, fs = 1000, dur = 2000, sum = FALSE)

## add noise
#sinewave = sinewave[,2] + rnorm (length (sinewave[,2]), 0, 3)

## compare the results of pwelch() and spectralslice()
#par (mfrow = c(2,1), mar = c(4,4,1,1))
#spectralslice (sinewave, fs = 1000)
#pwelch (sinewave, points = 400, fs = 1000)

</code></pre>

<hr>
<h2 id='rcr'>
Random Coefficients Regression
</h2><span id='topic+rcr'></span><span id='topic+print.rcr'></span><span id='topic+print.summary.rcr'></span><span id='topic+summary.rcr'></span><span id='topic+anova.rcr'></span><span id='topic+print.anova.rcr'></span><span id='topic+plot.rcr'></span>

<h3>Description</h3>

<p>Carry out a random coefficients regression (rcr) using repeated calls to glm, individually for the data from each participant/data cluster. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcr(formula, participants, dataframe, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcr_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="rcr_+3A_participants">participants</code></td>
<td>
<p>A vector indicating which row in the dataframe belongs to which participant. Length must equal the number of rows in the dataframe.</p>
</td></tr>
<tr><td><code id="rcr_+3A_dataframe">dataframe</code></td>
<td>
<p>The dataframe containing the data for the model.</p>
</td></tr>
<tr><td><code id="rcr_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the internal glm() function call. For example, family, if not 'gaussian', should be specified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a model to the data from each participant individually using repeated calls to glm(). Significance testing is then carried out on the coefficients fit for each participant using the methods established in Gumpertz &amp; Pantula (1989) and Lorch &amp; Myers (1990).
</p>
<p>In perceptual experiments there is frequently a high number of data points collected from each participant, and the data collected from each participant is balanced by design. In these situations rcr performs comparably to mixed-effects models. In the event that only a small number of observations are made from each listener, or the data is not balanced, rcr may not be appropriate.
</p>
<p>A call to summary() on an rcr object performs a one-sample t-test on each coefficient to test whether it is significantly different from zero.
</p>
<p>A call to anova() on an rcr object performs a one-sample t-test in the case of single coefficients, and a one-sample Hotelling T2 test in the event that multiple coefficients are associated with a single factor, to test that they are not all equal to zero. 
</p>
<p>A call to plot() on an rcr object displays the density corresponding to the distribution of all fitted coefficients. These are compared to a normal distribution with the same mean and standard deviation.
</p>


<h3>Value</h3>

<p>An object of class 'rcr', a list containing the elements:
</p>
<table>
<tr><td><code>formula</code></td>
<td>
<p>The formula used to call and create the rcr object.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The exact call used to create the rcr object.</p>
</td></tr>
<tr><td><code>participants</code></td>
<td>
<p>A vector indicating the labels used to identify each individual participant as indicated by 'participants'.</p>
</td></tr>
<tr><td><code>factors</code></td>
<td>
<p>A vector indicating the grouping of the explanatory variables.</p>
</td></tr>
<tr><td><code>factor.names</code></td>
<td>
<p>A vector containing the names of each group of coefficients.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>A dataframe containing the coefficients fit individually for each participant.</p>
</td></tr>
<tr><td><code>coefficient.means</code></td>
<td>
<p>The mean value of each coefficient across all participants.</p>
</td></tr>
<tr><td><code>coefficient.names</code></td>
<td>
<p>The name of each individual coefficient.</p>
</td></tr>
<tr><td><code>varExp</code></td>
<td>
<p>The percent of variance or deviance explained by the model for each participant.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Gumpertz, M., &amp; Pantula, S. G. (1989). A Simple Approach to Inference in Random Coefficient Models. The American Statistician, 43(4), 203-210.
</p>
<p>Lorch, T. F. &amp; Myers, J. L. (1990). Regression analyses of repeated measures data in cognitive research. J. Exp. Psychol. Learn. Mem. Cogn. 16: 149-157.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data (pb52)

## runs an rcr model on the Peterson &amp; Barney (1952) vowels to test 
## for the predictive value of the speaker's f0 and F3
#rcr.model = rcr (f1 ~ f0 * f3, pb52$speaker, pb52)
#rcr.model

## test for the significance of each individual coefficient 
#summary (rcr.model)

## a similar analysis can be run using vowel category as the predictor
#rcr.model = rcr (f1 ~ vowel, pb52$speaker, pb52)
#rcr.model

## here, summary() tests each coefficient individually
#summary (rcr.model)

## while anova() tests associated coefficients together
#anova (rcr.model)
</code></pre>

<hr>
<h2 id='reduce.fraction'>
Reduce Fractions 
</h2><span id='topic+reduce.fraction'></span>

<h3>Description</h3>

<p>Reduce fractions to lowest terms using Euclid's Algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce.fraction (ratio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce.fraction_+3A_ratio">ratio</code></td>
<td>
<p>A vector with two integers. The first element is the numerator of a ratio, and the second element is the denominator.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A vector containing the elements of the reduced fraction. The first element is the numerator of a ratio, and the second element is the denominator. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## an easy one
reduce.fraction (c(100, 200))

## irreducible
reduce.fraction (c(140, 201))

## a hard one
reduce.fraction (c(140, 203))
</code></pre>

<hr>
<h2 id='resample'>
Resample a Sound
</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>Resample using sinc interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample (sound, newfs, oldfs, precision = 50, filterorder = 200, synthfilter = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_sound">sound</code></td>
<td>
<p>Either a numeric vector representing a sequence of samples taken from a sound wave or a sound object created with the loadsound() or makesound() functions.</p>
</td></tr>
<tr><td><code id="resample_+3A_newfs">newfs</code></td>
<td>
<p>The new desired sampling frequency.</p>
</td></tr> 
<tr><td><code id="resample_+3A_oldfs">oldfs</code></td>
<td>
<p>The original sampling frequency. If a 'sound' object is provided, this does not need to be specified.</p>
</td></tr> 
<tr><td><code id="resample_+3A_precision">precision</code></td>
<td>
<p>The number of samples before and after the current point to be used for interpolation.</p>
</td></tr> 
<tr><td><code id="resample_+3A_filterorder">filterorder</code></td>
<td>
<p>The number of taps to be used for the low-pass FIR filters used, where appropriate.</p>
</td></tr> 
<tr><td><code id="resample_+3A_synthfilter">synthfilter</code></td>
<td>
<p>If TRUE, synthfilter() is used for filtering.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>The resampled vector is returned. If a 'sound' object is passed, the resampled sound is returned as an object. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data (sound)
## downsample and then upsample the sound back to 
## its original sampling frequency
#downsamped = resample (sound, 11025)
#upsamped = resample (downsamped, 22050)

# compare a part of the waveforms for all three sounds
#par (mfrow = c(3,1), mar = c(4,4,1,1))
#plot (sound$sound[1:14000], type = 'l')
#plot (upsamped$sound[1:14000], type = 'l', col = 2)
#plot (downsamped$sound[1:7000], type = 'l', col = 4)
</code></pre>

<hr>
<h2 id='rmvtnorm'>
Random multivariate normal variables
</h2><span id='topic+rmvtnorm'></span>

<h3>Description</h3>

<p>Draw vectors from a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvtnorm (n = 1, k = 2, means = rep (0, k), sigma = diag (k))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvtnorm_+3A_n">n</code></td>
<td>
<p>The number of vectors to be drawn.</p>
</td></tr> 
<tr><td><code id="rmvtnorm_+3A_k">k</code></td>
<td>
<p>The dimension of the vectors to be drawn.</p>
</td></tr> 
<tr><td><code id="rmvtnorm_+3A_means">means</code></td>
<td>
<p>A vector of means, one for each dimension.</p>
</td></tr> 
<tr><td><code id="rmvtnorm_+3A_sigma">sigma</code></td>
<td>
<p>The covariance matrix of the distribution. If a number between 0 and 1 is provided, this is assumed to be the correlation parameter for a bivariate standard normal distribution.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>If means and sigma are not specified, a standard normal distribution is assumed along every dimensions, and dimensions are assumed to be uncorrelated. If the number of dimensions is not specified, a bivariate distribution is assumed. 
</p>


<h3>Value</h3>

<p>A matrix with rows equal to n and columns equal to k, where each row indicates a single observation, and each column represents a different dimension.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples of draws from different bivariate normal distributions
## and standard deviation ellipses drawn to fit them.
#par (mfrow = c(2,2))
#draws = rmvtnorm (n = 1000, k = 2, sigma = .3)
#plot (draws)
#sdellipse (draws, stdev = 3, lwd = 3, col = 2)

#draws = rmvtnorm (n = 1000, k = 2, sigma = -.3)
#plot (draws)
#sdellipse (draws, stdev = 3, lwd = 3, col = 2)

#draws = rmvtnorm (n = 1000, k = 2, sigma = -.7)
#plot (draws)
#sdellipse (draws, stdev = 3, lwd = 3, col = 2)

#draws = rmvtnorm (n = 1000, k = 2, sigma = .7)
#plot (draws)
#sdellipse (draws, stdev = 3, lwd = 3, col = 2)
</code></pre>

<hr>
<h2 id='rotate'>
Rotate 
</h2><span id='topic+rotate'></span>

<h3>Description</h3>

<p>Rotate 2D and complex-valued observations. The output is of the same kind as the input. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate (xy, angle, degrees = FALSE, origin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_+3A_xy">xy</code></td>
<td>
<p>Either, a vector of complex-valued observations, or a matrix with 2 columns and any number of rows.</p>
</td></tr> 
<tr><td><code id="rotate_+3A_angle">angle</code></td>
<td>
<p>The desired angle of rotation, in radians.</p>
</td></tr> 
<tr><td><code id="rotate_+3A_degrees">degrees</code></td>
<td>
<p>If angle of rotation is specified in degrees instead of radians, this should be set to TRUE.</p>
</td></tr> 
<tr><td><code id="rotate_+3A_origin">origin</code></td>
<td>
<p>If TRUE, points are rotated about the origin. If FALSE, points are rotated 'in place' about the mean for each dimension (i.e. the central location of the distribution).</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## rotate points in a 2D space 
#mat = cbind (1:100, 100:1)
#rotate (mat, pi/2)

## rotate complex-valued numbers
#complx = complex (real = mat[,1], imaginary = mat[,2])
#rotate (complx, pi/2)

</code></pre>

<hr>
<h2 id='sdellipse'>
Standard deviation Ellipse
</h2><span id='topic+sdellipse'></span>

<h3>Description</h3>

<p>Draw standard deviation ellipses around a group of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdellipse (points, stdev = 1.96, density = .01,  
add = TRUE, show = TRUE, means = NULL, se = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdellipse_+3A_points">points</code></td>
<td>
<p>A matrix with two columns in which each row is a different observation from a bivariate normal distribution. Optionally, a 2 by 2 covariance matrix may be specified directly in conjunction with the means parameter.</p>
</td></tr> 
<tr><td><code id="sdellipse_+3A_stdev">stdev</code></td>
<td>
<p>The number of standard deviations to be enclosed by the ellipse.</p>
</td></tr> 
<tr><td><code id="sdellipse_+3A_density">density</code></td>
<td>
<p>The spacing between sampling points along the ellipse. A higher number results in a coarser sampling.</p>
</td></tr> 
<tr><td><code id="sdellipse_+3A_add">add</code></td>
<td>
<p>If TRUE, the ellipse is added to an existing plot. If FALSE, a new plot is created.</p>
</td></tr> 
<tr><td><code id="sdellipse_+3A_show">show</code></td>
<td>
<p>If FALSE, no ellipse is drawn.</p>
</td></tr> 
<tr><td><code id="sdellipse_+3A_means">means</code></td>
<td>
<p>A vector of 2 means, one for each dimension. If these are specified, points is assumed to be a covariance matrix rather than a sequence of observations.</p>
</td></tr> 
<tr><td><code id="sdellipse_+3A_se">se</code></td>
<td>
<p>If TRUE, a standard error (rather than standard deviation) ellipse is plotted.</p>
</td></tr> 
<tr><td><code id="sdellipse_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the internal call of lines() or plot() as appropriate.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function may be used in 2 different ways: 1) To draw standard deviation ellipses around a set of observations (if 'means' is not specified) 2) To draw ellipses and circles on plots (if 'means' is specified).  
</p>


<h3>Value</h3>

<p>A matrix is returned where the first column indicate x-axis ellipse coordinates and the second column indicates y-axis ellipse coordinates. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples of draws from different bivariate normal distributions
## and standard deviation ellipses drawn to fit them.
#par (mfrow = c(2,2))
#draws = rmvtnorm (n = 1000, k = 2, sigma = .3)
#plot (draws)
#sdellipse (draws, stdev = 3, lwd = 3, col = 2)

#draws = rmvtnorm (n = 1000, k = 2, sigma = -.3)
#plot (draws)
#sdellipse (draws, stdev = 3, lwd = 3, col = 2)

#draws = rmvtnorm (n = 1000, k = 2, sigma = -.7)
#plot (draws)
#sdellipse (draws, stdev = 3, lwd = 3, col = 2)

#draws = rmvtnorm (n = 1000, k = 2, sigma = .7)
#plot (draws)
#sdellipse (draws, stdev = 3, lwd = 3, col = 2)

## alternatively, a covariance matrix may be specified directly. 
#par (mfrow = c(1,1))
#sdellipse (matrix(c(1,.5,.5,1),2,2), means = c(0,0), 
#add = FALSE, stdev = 1)
#sdellipse (matrix(c(1,-.5,-.5,1),2,2), means = c(0,0), 
#add = TRUE, stdev = 1)
</code></pre>

<hr>
<h2 id='selectslice'>
Select Slices
</h2><span id='topic+selectslice'></span>

<h3>Description</h3>

<p>Select spectral slices from a spectrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectslice (specobject, n = 1, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectslice_+3A_specobject">specobject</code></td>
<td>
<p>A 'spectrogram' object created with the spectrogram() function included in this package.</p>
</td></tr> 
<tr><td><code id="selectslice_+3A_n">n</code></td>
<td>
<p>The number of desired slices.</p>
</td></tr> 
<tr><td><code id="selectslice_+3A_plot">plot</code></td>
<td>
<p>If FALSE, the spectrogram is not plotted.</p>
</td></tr> 
<tr><td><code id="selectslice_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the internal call of plot.spectrogram().</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function allows the user to select a given number of time points on a spectrogram, and to retrieve spectral slices at those time points. The spectrogram object is plotted, and the user must click on the spectrogram a given number of times at the desired points. The analysis parameters of the slices will reflect the parameters used when creating the spectrogram. Setting the 'plot' parameter to FALSE is useful if you want one set of analysis parameters for the visually presented spectrogram and another set for the spectral slices.
</p>


<h3>Value</h3>

<p>A dataframe with one column for each spectral slice selected. Row names indicate frequencies, column names indicate times in milliseconds. Values are decibels below peak. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## uncomment to run

# sound = vowelsynth ()
# spect = spectrogram (sound)
# slices = selectslice (spect, n = 3)

</code></pre>

<hr>
<h2 id='sinc'>
Sinc Function
</h2><span id='topic+sinc'></span>

<h3>Description</h3>

<p>Sample the sinc function at given points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinc (x, normalized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinc_+3A_x">x</code></td>
<td>
<p>A vector of x-axis points at which the sinc function will be sampled.</p>
</td></tr> 
<tr><td><code id="sinc_+3A_normalized">normalized</code></td>
<td>
<p>If TRUE, a normalized sinc function is returned.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The formula for the unnormalized sinc function is y = sin(x)/x.
</p>
<p>The formula for the normalized sinc function is y = sin(x*pi)/(x*pi).
</p>


<h3>Value</h3>

<p>A vector containing y-axis values for each specified x-axis value is returned.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Sinc_function
</p>
<p>Lyons, R. G. (2004). Understanding Digital Signal Processing (2nd ed.). Prentice Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#x = seq(-20,20,.1)
## generate both forms of the sinc function between -20 and 20
#y1 = sinc (x)
#y2 = sinc (x, normalized = TRUE)
## the unnormalized sinc function has zero crossing at 
## integer multiples of pi
#plot (x,y1, type = 'b')
## the normalized sinc function has zero crossing at integers
#lines (x,y2, type = 'b', col = 4)
#abline (h = 0)
</code></pre>

<hr>
<h2 id='sinusoid'>
Create Sinusoids
</h2><span id='topic+sinusoid'></span><span id='topic+sinusoids'></span>

<h3>Description</h3>

<p>Create and display one or more sinusoids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinusoid (freqs, amps = rep(1, length(freqs)), dur = 50, 
phases = rep(0, length(freqs)), fs = 10000, sum = FALSE, 
show = FALSE, colors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinusoid_+3A_freqs">freqs</code></td>
<td>
<p>A vector of frequencies, one for each desired sinusoid.</p>
</td></tr> 
<tr><td><code id="sinusoid_+3A_amps">amps</code></td>
<td>
<p>A vector of peak amplitudes, one for each desired sinusoid.</p>
</td></tr> 
<tr><td><code id="sinusoid_+3A_dur">dur</code></td>
<td>
<p>The desired duration of the sinusoids, in milliseconds.</p>
</td></tr> 
<tr><td><code id="sinusoid_+3A_phases">phases</code></td>
<td>
<p>A vector of initial phases, one for each desired sinusoid, expressed in radians.</p>
</td></tr> 
<tr><td><code id="sinusoid_+3A_fs">fs</code></td>
<td>
<p>The desired sampling frequency of the sinusoids.</p>
</td></tr> 
<tr><td><code id="sinusoid_+3A_sum">sum</code></td>
<td>
<p>If TRUE, the sum the generated sinusoids is also found.</p>
</td></tr> 
<tr><td><code id="sinusoid_+3A_show">show</code></td>
<td>
<p>If TRUE, the generated sinusoids are plotted. If sum is TRUE, a second plot is created to display the sum of the sinusoids.</p>
</td></tr> 
<tr><td><code id="sinusoid_+3A_colors">colors</code></td>
<td>
<p>An optional vector of colors used to plot the individual sinusoids. If the number of colors given is less than the number of frequencies specified, the colors are repeated.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>A number of sinusoids are generated, and optionally plotted and/or returned. The number of frequencies specified must equal the number of amplitudes and initial phases. 
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>The time, in milliseconds, at which is sample is taken.</p>
</td></tr>
<tr><td><code>waveN</code></td>
<td>
<p>A series of columns, each indicating the amplitude of wave N at a given time.</p>
</td></tr>
<tr><td><code>sum</code></td>
<td>
<p>A column indicating the sum of all of the sinusoids.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## several waves, and the sum
#sum = sinusoid (freqs = c(100,200,300), amps = c(1,3,2), 
#sum = TRUE, show = TRUE)

## no sum, different phase shifts
#nosum = sinusoid (freqs = c(100,200,300), amps = c(1,3,2), 
#phases = c(pi/2, 0, pi/4), sum = FALSE)
</code></pre>

<hr>
<h2 id='snip'>
Snip/Zoom
</h2><span id='topic+snip'></span>

<h3>Description</h3>

<p>Select a subsection of a sound or spectrogram object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snip  (object, show = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snip_+3A_object">object</code></td>
<td>
<p>A 'sound' or 'spectrogram' object to be truncated.</p>
</td></tr> 
<tr><td><code id="snip_+3A_show">show</code></td>
<td>
<p>If TRUE, the selected subsection is displayed, resulting in zoom functionality.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The input object is plotted and the user must click on two points on the plot. If show = TRUE, this function allows the user to zoom in on a subsection of the object. If the output is assigned to a variable, a new object is created and returned that contains only the data in between the two designated points. 
</p>


<h3>Value</h3>

<p>A 'sound' or 'spectrogram' object which interacts with several functions included in this package.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data (sound)
## the example below is commented because examples cannot 
## require user interaction. simply uncomment the lines below
## and select two points on the plot. 
# clipped = snipsound (sound)
# spectrogram (clipped)
# spectralslice (clipped)
</code></pre>

<hr>
<h2 id='sound'>
Sound object
</h2><span id='topic+sound'></span>

<h3>Description</h3>

<p>An example of a sound object, the phrase 'This is a spectrogram', produced by the author of this package. This sound object may be inspected with spectrogram() and plotted with plot(). Sections of the individual samples representing the waveform (found in the &quot;sound&quot; element of a sound object) can be passed to spectralslice() to see a spectral slice. Several functions included in this package may also be used to modify or manipulate 'sound' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data (sound)</code></pre>


<h3>Format</h3>

<p>This sound object has the same properties as all sound objects. These may be inspected by using the print() function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## uncomment and run

#data (sound)
#par (mar = c(4,4,1,1))
#multiplot (n = 3, sizes = c(.25, .5, .25))  

#plot (sound)
#spectrogram (sound, dynamicrange = 50, maxfreq = 7000)
</code></pre>

<hr>
<h2 id='spectralslice'>
Spectral Slice
</h2><span id='topic+spectralslice'></span><span id='topic+slice'></span>

<h3>Description</h3>

<p>A function to plot the power spectrum of a vector representing a sound wave. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectralslice (sound, padding = length(sound) * 2, fs = 1,  
show = TRUE, add = FALSE, window = "kaiser", 
windowparameter = 3, zeromax = TRUE, preemphasisf = 0, type, 
line = FALSE, removeDC = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectralslice_+3A_sound">sound</code></td>
<td>
<p>A vector representing a sound wave, or a 'sound' object.</p>
</td></tr>
<tr><td><code id="spectralslice_+3A_padding">padding</code></td>
<td>
<p>The amount of zero-padding desired for the analysis, in number of samples.</p>
</td></tr>
<tr><td><code id="spectralslice_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency of the sound. If a 'sound' object is passed this does not need to be specified.</p>
</td></tr>
<tr><td><code id="spectralslice_+3A_show">show</code></td>
<td>
<p>If FALSE, no plot is created.</p>
</td></tr>
<tr><td><code id="spectralslice_+3A_add">add</code></td>
<td>
<p>If TRUE, the spectrum is added to an existing plot. If FALSE a new one is created.</p>
</td></tr>
<tr><td><code id="spectralslice_+3A_window">window</code></td>
<td>
<p>The window to be applied to the signal, applied by windowfunc(), provided in this package.</p>
</td></tr>
<tr><td><code id="spectralslice_+3A_windowparameter">windowparameter</code></td>
<td>
<p>The parameter for the window to be applied to the signal, if appropriate. Passed to windowfunc().</p>
</td></tr>
<tr><td><code id="spectralslice_+3A_zeromax">zeromax</code></td>
<td>
<p>If TRUE, the maximum dB is set to 0.</p>
</td></tr>
<tr><td><code id="spectralslice_+3A_type">type</code></td>
<td>
<p>The line type to be used for plotting, passes its value to the 'lty' parameter.</p>
</td></tr>
<tr><td><code id="spectralslice_+3A_preemphasisf">preemphasisf</code></td>
<td>
<p>Preemphasis of 3 dB per octave is added to frequencies above the specified frequency.</p>
</td></tr>
<tr><td><code id="spectralslice_+3A_line">line</code></td>
<td>
<p>If TRUE, a line spectrum is created.</p>
</td></tr>
<tr><td><code id="spectralslice_+3A_removedc">removeDC</code></td>
<td>
<p>If TRUE, the DC component is removed.</p>
</td></tr>
<tr><td><code id="spectralslice_+3A_...">...</code></td>
<td>
<p>any additional arguments will be passed to the internal calls of 'plot' or 'lines'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the following elements is returned:
</p>
<table>
<tr><td><code>hz</code></td>
<td>
<p>The center frequency of the analysis bins.</p>
</td></tr>
<tr><td><code>dB</code></td>
<td>
<p>The dB magnitude/power for the analysis bin.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## synthesize schwa-like vowel 
#vowel = vowelsynth (ffs = c(500,1500,2500,3500,4500))$sound
    
## compare window lengths
#par (mfrow = c(3,1))
#spectralslice (vowel[500:550], fs = 10000)
#spectralslice (vowel[500:1000], fs = 10000)
     
## line spectrum
#spectralslice (vowel[500:600], padding = 0, line = TRUE, fs = 10000)

</code></pre>

<hr>
<h2 id='spectrogram'>
Create Spectrograms
</h2><span id='topic+spectrogram'></span><span id='topic+plot.spectrogram'></span><span id='topic+print.spectrogram'></span>

<h3>Description</h3>

<p>Create and display spectrograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectrogram (sound, fs = 22050, windowlength = 5, 
timestep = -1000, padding = 10, 
preemphasisf = 50, maxfreq = 5000, colors = TRUE, 
dynamicrange = 50, nlevels = dynamicrange, maintitle = "", 
show = TRUE, window = 'kaiser', windowparameter = 3, 
quality = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectrogram_+3A_sound">sound</code></td>
<td>
<p>Either a numeric vector representing a sequence of samples taken from a sound wave or a sound object created with the loadsound() or makesound() functions.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency in Hz. If a sound object is passed this does not need to be specified.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_windowlength">windowlength</code></td>
<td>
<p>The desired analysis window length in milliseconds.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_timestep">timestep</code></td>
<td>
<p>If a negative value is given, -N, then N equally-spaced time steps are calculated. If a positive number is given, this is the spacing between adjacent analyses, in milliseconds.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_padding">padding</code></td>
<td>
<p>The amount of zero padding for each window, measured in units of window length. For example, if the window is 50 points, and padding = 10, 500 zeros will be appended to each window.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_preemphasisf">preemphasisf</code></td>
<td>
<p>Preemphasis of 6 dB per octave is added to frequencies above the specified frequency. For no preemphasis, set to a frequency higher than the sampling frequency.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_maxfreq">maxfreq</code></td>
<td>
<p>the maximum frequency to be displayed for the spectrogram up to a maximum of fs/2. This is set to 5000 Hz by default.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_colors">colors</code></td>
<td>
<p>If TRUE, a color spectrogram will be displayed. If FALSE, greyscale is used. If a vector of colors is provided, these colors are used to create the spectrogram.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_nlevels">nlevels</code></td>
<td>
<p>The number of divisions to be used for the z-axis of the spectrogram. By default it is set equal to the dynamic range, meaning that a single color represents 1 dB on the z-axis.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_dynamicrange">dynamicrange</code></td>
<td>
<p>Values greater than this many dB below the maximum will be displayed in the same color.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_maintitle">maintitle</code></td>
<td>
<p>A string indicating the spectrogram title if one is desired.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_show">show</code></td>
<td>
<p>If FALSE, no spectrogram is plotted. This is useful if the user would like to perform an action on an existing spectrogram plot without having to redraw it.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_window">window</code></td>
<td>
<p>the window to be applied to the signal, applied by the windowfunc function in this package.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_windowparameter">windowparameter</code></td>
<td>
<p>the parameter for the window to be applied to the signal, if appropriate.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_quality">quality</code></td>
<td>
<p>If TRUE, a contour plot is created, which results in a high-quality image that may be slow to plot. If FALSE, a lower-quality image is created that plots much faster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to create and plot spectrograms. The user may specify all analysis parameters, in addition to the colors used to display the spectrogram. 
</p>
<p>The function optionally returns a spectrogram object for which the plot() function is defined. 
</p>


<h3>Value</h3>

<p>If output is set to TRUE, an object of class 'spectrogram', a list containing the elements:
</p>
<table>
<tr><td><code>spectrogram</code></td>
<td>
<p>a matrix containing the magnitude at each bin center. Frequencies differ across columns, while time varies between rows.</p>
</td></tr>
<tr><td><code>fs</code></td>
<td>
<p>the sampling frequency of the sound from which the spectrogram was made.</p>
</td></tr>
<tr><td><code>windowlength</code></td>
<td>
<p>the length of the analysis window used to create the spectrogram.</p>
</td></tr>
<tr><td><code>timestep</code></td>
<td>
<p>the timestep (in milliseconds) used to create the spectrogram.</p>
</td></tr>
<tr><td><code>dynamicrange</code></td>
<td>
<p>the dynamic range (in dB) of the spectrogram.</p>
</td></tr>
<tr><td><code>color</code></td>
<td>
<p>the colors used to create the spectrogram. This value corresponds to the 'color' parameter set when calling spectrogram().</p>
</td></tr>
<tr><td><code>maxfreq</code></td>
<td>
<p>the maximum desired frequency when plotting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## uncoment and run. 
#data (sound)             ## use the example 'sound' object provided
#sound = loadsound()       ## or run this line to use you own sound

#spectrogram (sound)
# spectrogram (sound, quality = TRUE)

</code></pre>

<hr>
<h2 id='synthfilter'>
Filtering by Synthesis
</h2><span id='topic+synthfilter'></span>

<h3>Description</h3>

<p>Use Fourier synthesis to recreate signal without undesired frequency components.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthfilter (sound, band = c(0,fs/4), fs = 1, verify = FALSE, attenuation = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synthfilter_+3A_sound">sound</code></td>
<td>
<p>A numeric vector representing a waveform, or a 'sound' object created with the loadsound() or makesound() functions.</p>
</td></tr> 
<tr><td><code id="synthfilter_+3A_band">band</code></td>
<td>
<p>A vector with exactly two elements, the first specifying the lowest frequency to be passed (must be &gt; 0), and the second specifying the highest frequency to be passed (must be &lt; fs/2).</p>
</td></tr> 
<tr><td><code id="synthfilter_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency of the sound. If a 'sound' object is passed, this does not need to be specified.</p>
</td></tr> 
<tr><td><code id="synthfilter_+3A_attenuation">attenuation</code></td>
<td>
<p>Attenuation of stop band, in dBs. If left as 0, stopband frequency components are completely omitted.</p>
</td></tr>
<tr><td><code id="synthfilter_+3A_verify">verify</code></td>
<td>
<p>If TRUE, a plot comparing the spectrum of the input sound is compared the the filtered sound.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function performs lowpass, highpass and bandpass filtering by performing an FFT on the entire signal, zeroing out coefficients representing undesired frequency components, and performing an IFFT on the result. This approach may not be appropriate for some applications, but it is useful in some cases. This may be slow for long signals. 
</p>
<p>If verify is TRUE, a plot is created which allows the user to inspect the performance of the function.
</p>


<h3>Value</h3>

<p>If a vector is given, the filtered vector is returned. If a 'sound' object is given, a sound object containing the filtered sound is returned. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## uncomment and run
##  white noise
#noise = rnorm(5000)

## low-pass filter
#synthfilter (noise, band = c(0, .25), verify = TRUE)

##  band-pass filter
#synthfilter (noise, band = c(.15, .25), verify = TRUE)

##  high-pass filter
#synthfilter (noise, band = c(.35, .5), verify = TRUE)

</code></pre>

<hr>
<h2 id='t07'>
Thomson (2007) Vowel Data
</h2><span id='topic+t07'></span>

<h3>Description</h3>

<p>Mean formant frequency information for the vowels of male and female speakers from Edmonton English.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data (pb52)</code></pre>


<h3>Format</h3>

<p>A data frame with 1520 observations on the following 9 variables:
</p>

<dl>
<dt><code>vowel</code></dt><dd><p> - The vowel category in x-sampa.</p>
</dd>
<dt><code>gender</code></dt><dd><p> - A factor with levels <code>f</code> <code>m</code> representing speaker gender: male and female.</p>
</dd>
<dt><code>f1</code></dt><dd><p> - A numeric vector indcating the vowel F1 in Hz.</p>
</dd>
<dt><code>f2</code></dt><dd><p> - A numeric vector indcating the vowel F2 in Hz.</p>
</dd>
<dt><code>f3</code></dt><dd><p> - A numeric vector indcating the vowel F3 in Hz.</p>
</dd>
</dl>



<h3>References</h3>

<p>Thomson, R. (2007). Modeling L1/L2 interactions in the perception and production of English vowels by Mandarin L1 speakers: A training study. PhD dissertation, University of Alberta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data(t07)
#vowelplot (t07$f1, t07$f2, t07$vowel, logaxes = 'xy', meansOnly = TRUE, 
#xsampa = TRUE)
</code></pre>

<hr>
<h2 id='voweldata'>
Information about Vowel Data Sets
</h2><span id='topic+voweldata'></span>

<h3>Description</h3>

<p>Contains a brief description and listing of all vowel data sets included in this package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data (voweldata)
</code></pre>


<h3>Format</h3>

<p>A data frame with the following information:
</p>

<dl>
<dt><code>name</code></dt><dd><p> - The name of the data set.</p>
</dd>
<dt><code>language</code></dt><dd><p> - The language represented in the data set.</p>
</dd>
<dt><code>nspeakers</code></dt><dd><p> - The number of speakers.</p>
</dd>
<dt><code>sexes</code></dt><dd><p> - The sexes of the speakers, m (male) and female (f).</p>
</dd>
<dt><code>nformants</code></dt><dd><p> - The number of formants represented, between 2 and 4.</p>
</dd>
<dt><code>individual</code></dt><dd><p> - If 'yes', individual speaker measurements are given, if 'no', measurements are averaged within gender.</p>
</dd>
</dl>



<h3>References</h3>

<p>At the moment 9 vowel data sets are included in this package. See individual data set pages for citation information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data(voweldata)
</code></pre>

<hr>
<h2 id='vowelplot'>
Plot Vowels
</h2><span id='topic+vowelplot'></span>

<h3>Description</h3>

<p>A flexible function that can create a wide variety of vowel plots (including IPA symbols).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vowelplot (f1s, f2s, labels = 0, xrange = NULL, yrange = NULL, 
meansOnly = FALSE, ellipses = FALSE, ellipsesd = 1.96, add = FALSE, 
pointType = 0, colors = NULL, logaxes = '', defaultPlot = TRUE, 
alternateAxes = FALSE, xsampa = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vowelplot_+3A_f1s">f1s</code></td>
<td>
<p>A numeric vector indicating vowel F1 frequencies.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_f2s">f2s</code></td>
<td>
<p>A numeric vector indicating vowel F2 frequencies.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_labels">labels</code></td>
<td>
<p>A vector with labels for vowels. Must be provided for any category-dependent differences in plotting. If x-sampa labels are given IPA symbols may be plotted.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_xrange">xrange</code></td>
<td>
<p>Allows the user to set the x axis range for the plot.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_yrange">yrange</code></td>
<td>
<p>Allows the user to set the y axis range for the plot.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_meansonly">meansOnly</code></td>
<td>
<p>If TRUE, only category means are plotted (labels must be provided).</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_ellipses">ellipses</code></td>
<td>
<p>If TRUE, standard deviation ellipses are drawn (one per category as indicated by label vector).</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_ellipsesd">ellipsesd</code></td>
<td>
<p>A number indicating the number of standard deviations ellipses will enclose.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_add">add</code></td>
<td>
<p>If TRUE, vowels are plotted on existing figure. If FALSE, a new one is created.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_pointtype">pointType</code></td>
<td>
<p>Kinds of points to use determined by 'pch' value. If specified it overrides text labels. IPA symbols may be plotted by finding appropriate values using the pickIPA() function included in this package.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_colors">colors</code></td>
<td>
<p>Colors to use for different categories. If specified this overrides automatic colors. It cycles through the list given if number of colors are less than number of categories.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_logaxes">logaxes</code></td>
<td>
<p>Linear axes are used by default. For log axes set to 'xy'.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_defaultplot">defaultPlot</code></td>
<td>
<p>If TRUE, the function plots using pre-determined values. If FALSE, the user has almost complete control over the internal call of 'plot'.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_alternateaxes">alternateAxes</code></td>
<td>
<p>If TRUE, F1 is plotted on the y axis and F2 on the x axis with the origin in the top right corner. By default F1 is plotted on the x axis and F2 on the y axis with the origin in the bottom left corner.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_xsampa">xsampa</code></td>
<td>
<p>If TRUE, the labels vector given to the function is assumed to be specified in x-sampa and IPA symbols are used to plot using the xsampatoIPA() function included in this package. If this is set to TRUE and the 'labels' input is not in x-sampa, the symbols will be wrong.</p>
</td></tr>
<tr><td><code id="vowelplot_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the internal call of 'plot'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>*** This function has been deprecated and is no longer being developed. I recommend using vplot() instead, which is more flexible and gives the user more control over plotting. ***
</p>
<p>This function now includes functionality to easily generate vowel plots using IPA symbols. This relies on category labels being specified in x-sampa. Alternatively, the required plotting values for IPA symbols may be selected using the pickIPA() function included in this package, and then passed to the 'pointType' parameter.
</p>
<p>There may be issues when exporting figures to PDF using IPA font. Exporting plots directly as images works 'out of the box'.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/X-SAMPA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A few examples of some vowel plots. 

#data (pb52)
#par (mfrow = c(1,4), mar = c(4.2,4.2,1,1))

# standard layout with linear axes
#vowelplot (pb52$f1, pb52$f2, pb52$vowel, xsampa = TRUE)

# alternate layout with log axes
#vowelplot (pb52$f1, pb52$f2, pb52$vowel, logaxes = 'xy', 
#alternateAxes = TRUE, xsampa = TRUE)

# category means only 
#vowelplot (pb52$f1, pb52$f2, pb52$vowel, logaxes = 'xy', 
#meansOnly = TRUE, xsampa = TRUE)

# category means only with standard deviation ellipses
#vowelplot (pb52$f1, pb52$f2, pb52$vowel, logaxes = 'xy', meansOnly = TRUE,
#           ellipses = TRUE, xsampa = TRUE)
</code></pre>

<hr>
<h2 id='vowelsynth'>
Vowel Synthesis
</h2><span id='topic+vowelsynth'></span>

<h3>Description</h3>

<p>Create synthetic vowels using a cascade formant synthesizer. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vowelsynth (ffs = c(270, 2200, 2800, 3400, 4400), fbw = 0.06, 
dur = 300, f0 = c(120,100),fs = 10000, verify = FALSE, 
returnsound = TRUE, noise1 = .001, noise2 = .01, power = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vowelsynth_+3A_ffs">ffs</code></td>
<td>
<p>A vector of center frequencies for each formant. For moving formants, a list containing two vectors may be provided, where the first vector indicates intitial values, and the final vector indicates final values. Formant frequencies should be provided in order of lowest to highest frequency.</p>
</td></tr>   
<tr><td><code id="vowelsynth_+3A_fbw">fbw</code></td>
<td>
<p>A vector of formant bandwidths for each formant. See details for more information.</p>
</td></tr> 
<tr><td><code id="vowelsynth_+3A_dur">dur</code></td>
<td>
<p>The desired duration of the sound, in milliseconds. Vowels must be at least 50 ms long.</p>
</td></tr>   
<tr><td><code id="vowelsynth_+3A_f0">f0</code></td>
<td>
<p>The desired f0 (pitch) of the sound. Optionally, a vector with initial and final f0 values may be provided.</p>
</td></tr>   
<tr><td><code id="vowelsynth_+3A_fs">fs</code></td>
<td>
<p>The desired sampling frequency of the output sound.</p>
</td></tr>   
<tr><td><code id="vowelsynth_+3A_verify">verify</code></td>
<td>
<p>If TRUE, the waveform and spectrogram of the created sound are plotted to allow the user to visually verify the process.</p>
</td></tr>   
<tr><td><code id="vowelsynth_+3A_returnsound">returnsound</code></td>
<td>
<p>If TRUE, the sound is returned as a sound object, which can be used with several other functions included in this package. If FALSE, only a vector representing the sound wave is returned.</p>
</td></tr> 
<tr><td><code id="vowelsynth_+3A_noise1">noise1</code></td>
<td>
<p>Noise to be added to the source, before formant filtering, as a proportion of the source RMS amplitude.</p>
</td></tr>  
<tr><td><code id="vowelsynth_+3A_noise2">noise2</code></td>
<td>
<p>Noise to be added to the output, as a proportion of the signal RMS amplitude.</p>
</td></tr>  
<tr><td><code id="vowelsynth_+3A_power">power</code></td>
<td>
<p>A desired power contour can be specified. Must be of the same length as the output sound, or the sound is truncated to the length of this vector.</p>
</td></tr>     
</table>


<h3>Details</h3>

<p>This function is a Klatt-style cascade formant synthesizer that is intended to create synthetic vowel sounds. The voice source is generated using the KLGLOTT88 method described in Klatt (1988).
</p>
<p>If the vowels sound too 'robotic', there may be formants too close to the Nyquist frequency. Conversely, if the vowels sound too 'muffled', you may need to add more formants, and make sure they extend closer to the Nyquist frequency. Vowels sound more natural when f0 is not static.  
</p>
<p>Formant bandwidths may be provided in Hz, or as a percentage of the formant frequencies. To set these as a percent of formant frequencies, all values must be less than 1. If these are not provided they are set to 6 percent of the formant center frequencies by default. If only one value is provided, this is assumed to be the desired value for all formants.
</p>


<h3>Value</h3>

<p>A vector or 'sound' object representing the filtered sound.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Klatt, D. H. (1980). Software for a cascade/parallel formant synthesizer. Journal of the Acoustical Society of America 67(3): 971-995.
</p>
<p>Klatt, D. H. (1988). Klattalk: The conversion of English text to speech. Unpublished Manuscript. Massachusetts Institute of Technology, Cambridge, MA. Chapter 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## uncomment to run

## The following examples are based on my vowels 
#i = vowelsynth (returnsound = FALSE, f0 = c(125,105))
#a = vowelsynth (ffs = c(700, 1300, 2300, 3400, 4400), 
#returnsound = FALSE, f0 = c(125,105))
#e = vowelsynth (ffs = c(400, 2000, 2600, 3400, 4400), 
#returnsound = FALSE, f0 = c(125,105))
#o = vowelsynth (ffs = c(400, 900, 2300, 3400, 4400), 
#returnsound = FALSE, f0 = c(125,105))
#u = vowelsynth (ffs = c(300, 750, 2300, 3400, 4400), 
#returnsound = FALSE, f0 = c(125,105))

#silence = rep(0, 1000)
#vowels = c(a, silence, e, silence, i, silence, o, silence, u)

#writesound (vowels, filename = 'vowels.wav', fs = 10000)

## an example of a synthetic diphthong
#ei = vowelsynth (ffs = list(c(400, 2000, 2600, 3400, 4400), 
#c(270, 2200, 2800, 3400, 4400)), f0 = c(125,105))
#writesound (ei)
#spectrogram (ei, pause = FALSE)

</code></pre>

<hr>
<h2 id='vplot'>
Plot Vowels
</h2><span id='topic+vplot'></span><span id='topic+IPA'></span>

<h3>Description</h3>

<p>A flexible function that can create a wide variety of vowel plots (including IPA symbols).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vplot (x, y, labels = NULL, colors = NULL, points = NULL, 
meansonly = FALSE, ellipsesd = 0, add = FALSE, alternateaxes = FALSE,
xsampa = FALSE, logaxes = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vplot_+3A_x">x</code></td>
<td>
<p>A numeric vector indicating formant frequencies to be plotted on the x axis.</p>
</td></tr>
<tr><td><code id="vplot_+3A_y">y</code></td>
<td>
<p>A numeric vector indicating formant frequencies to be plotted on the y axis.</p>
</td></tr>
<tr><td><code id="vplot_+3A_labels">labels</code></td>
<td>
<p>A vector with labels for vowels. Must be provided for any category-dependent differences in plotting. If x-sampa labels are given IPA symbols may be plotted.</p>
</td></tr>
<tr><td><code id="vplot_+3A_colors">colors</code></td>
<td>
<p>Colors to use for different categories. If specified this overrides automatic colors. It cycles through the list given if number of colors are less than number of categories.</p>
</td></tr>
<tr><td><code id="vplot_+3A_points">points</code></td>
<td>
<p>Kinds of points to use determined by 'pch' value. If specified it overrides text labels. IPA symbols may be plotted by finding appropriate values using the pickIPA() function included in this package.</p>
</td></tr>
<tr><td><code id="vplot_+3A_meansonly">meansonly</code></td>
<td>
<p>If TRUE, only category means are plotted (labels must be provided).</p>
</td></tr>
<tr><td><code id="vplot_+3A_ellipsesd">ellipsesd</code></td>
<td>
<p>If a number greater than zero is given, ellipses are drawn enclosing this many standard deviations (one per category as indicated by label vector).</p>
</td></tr>
<tr><td><code id="vplot_+3A_add">add</code></td>
<td>
<p>If TRUE, vowels are plotted on existing figure. If FALSE, a new one is created.</p>
</td></tr>
<tr><td><code id="vplot_+3A_logaxes">logaxes</code></td>
<td>
<p>Linear axes are used by default, for log axes set to TRUE.</p>
</td></tr>
<tr><td><code id="vplot_+3A_alternateaxes">alternateaxes</code></td>
<td>
<p>If TRUE, the origin in the top right corner of the plot, resulting in a configuration like the IPA vowel quadrilateral if F1 and F2 are provided. By default the origin in the bottom left corner.</p>
</td></tr>
<tr><td><code id="vplot_+3A_xsampa">xsampa</code></td>
<td>
<p>If TRUE, the labels vector given to the function is assumed to be specified in x-sampa and IPA symbols are used to plot using the xsampatoIPA() function included in this package. If this is set to TRUE and the 'labels' input is not in x-sampa, the symbols will be wrong.</p>
</td></tr>
<tr><td><code id="vplot_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the internal call of 'plot'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>*** This function replaces the older vowelplot() function, which has been deprecated. ***
</p>
<p>A flexible vowel plotting function, including functionality to easily generate vowel plots using IPA symbols. This relies on category labels being specified in x-sampa (the required plotting values for IPA symbols may be selected using the pickIPA() function included in this package).
</p>
<p>Default parameter values are set for the plot, but these may all be overridden using the standard plotting parameters. 
</p>
<p>There may be issues when exporting figures to PDF using IPA font. Exporting plots directly as images works 'out of the box'.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/X-SAMPA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A few examples of some vowel plots. 

## load the Peterson and Barney data
#data (pb52)
#pb52 = pb52[pb52$type=='m',]  ## use only the males

#par (mfrow = c(3,2), mar = c(4.2,4.2,1,1))

# standard layout with linear axes
#vplot (pb52$f1, pb52$f2, pb52$vowel, xsampa = TRUE)

# alternate layout with log axes
#vplot (pb52$f1, pb52$f2, pb52$vowel, logaxes = TRUE, 
#           alternateaxes = TRUE, xsampa = TRUE)

# category means only 
#vplot (pb52$f1, pb52$f2, pb52$vowel, logaxes = TRUE, 
#           meansonly = TRUE, xsampa = TRUE, cex = 3)

# category means only with standard deviation ellipses
#vplot (pb52$f1, pb52$f2, pb52$vowel, logaxes = FALSE, 
#       meansonly = TRUE, ellipsesd = 2, xsampa = TRUE)

# same as above, with alternate axes
#vplot (pb52$f1, pb52$f2, pb52$vowel, logaxes = TRUE, 
#       meansonly = TRUE, ellipsesd = 2, xsampa = TRUE, 
#	   alternateaxes = TRUE)

# individual points with standard deviation ellipses
# and alternate axes
#vplot (pb52$f1, pb52$f2, pb52$vowel, logaxes = TRUE, 
#	   meansonly = FALSE, ellipsesd = 2, xsampa = TRUE, 
#	   alternateaxes = TRUE)

</code></pre>

<hr>
<h2 id='windowfunc'>
Window Function
</h2><span id='topic+windowfunc'></span>

<h3>Description</h3>

<p>Generates a window function of a given type and length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>windowfunc (npoints, type = 'hann', parameter = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="windowfunc_+3A_npoints">npoints</code></td>
<td>
<p>The desired window length, in points. If a vector is given, the window will have the same length as the vector.</p>
</td></tr>
<tr><td><code id="windowfunc_+3A_type">type</code></td>
<td>
<p>A string indicating the type of window desired. For the sake of simplicity, all window names are in lowercase. Supported types are: rectangular, hann, hamming, cosine, bartlett, gausian, and kaiser.</p>
</td></tr>
<tr><td><code id="windowfunc_+3A_parameter">parameter</code></td>
<td>
<p>The parameter necessary to generate the window, if appropriate. At the moment, the only windows that require parameters are the Kaiser and Gaussian windows. By default, these are set to 2 for kaiser and 0.4 for gaussian windows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A window function is generated, of the type and length specified by the user. This is returned as a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Window_function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#par (mfrow = c(1,4))
#plot (windowfunc (100, 'hann'))
#plot (windowfunc (100, 'bartlett'))
#plot (windowfunc (100, 'kaiser', parameter = 2))
#plot (windowfunc (100, 'kaiser', parameter = 6))
</code></pre>

<hr>
<h2 id='writesound'>
Write out a WAV file
</h2><span id='topic+writesound'></span>

<h3>Description</h3>

<p>Create a WAV file from a numeric vector or 'sound' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writesound (samples, filename = '', fs = 22050)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writesound_+3A_samples">samples</code></td>
<td>
<p>A numeric vector representing a sound wave.</p>
</td></tr> 
<tr><td><code id="writesound_+3A_filename">filename</code></td>
<td>
<p>A string indicating the desired output file name.</p>
</td></tr> 
<tr><td><code id="writesound_+3A_fs">fs</code></td>
<td>
<p>The desired output sampling frequency. If a sound object is passed this does not need to be specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates single channel (mono), 16-bit WAV sound files at a desired sampling frequency. If a 'sound' object is passed, the filename and sampling frequency do not need to be set. If a filename is not set, the filename defaults to 'samples.wav' where 'samples' indicates the name of the samples variable that was passed to the function.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>https://ccrma.stanford.edu/courses/422/projects/WaveFormat/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a sine wave with a frequency of 1000 Hz
## sampled at a frequency of 10000 Hz
#x = seq (0,.1, 1/10000)
#snd = sin (2*pi*1000*x)
#plot (snd[1:100], type = 'b')

## write out sine wave as a WAV file
# writesound (snd, filename = '1khz.wav', fs = 10000)

## if no filename is provided, this sound will be called 'snd.wav'
# writesound (snd, fs = 10000)
</code></pre>

<hr>
<h2 id='xsampatoIPA'>
Convert X-Sampa to IPA
</h2><span id='topic+xsampatoIPA'></span>

<h3>Description</h3>

<p>Convert a vector of x-sampa vowel descriptions to values that can be used to plot IPA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xsampatoIPA (vowels, chart = FALSE, verify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xsampatoIPA_+3A_vowels">vowels</code></td>
<td>
<p>A vector representing vowel labels in x-sampa to be converted to values that can be used to plot the corresponding IPA symbols. If this is not provided a plot comparing IPA to x-sampa representations is displayed.</p>
</td></tr> 
<tr><td><code id="xsampatoIPA_+3A_chart">chart</code></td>
<td>
<p>If TRUE, a plot comparing IPA to x-sampa representations is displayed.</p>
</td></tr> 
<tr><td><code id="xsampatoIPA_+3A_verify">verify</code></td>
<td>
<p>If TRUE, the selected symbols are plotted to allow for verification.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function converts x-sampa to values that can be used to plot IPA symbols by passing them to the 'pch' parameter within plotting functions. At the moment it has only been implemented for vowel sounds. The function also generate a figure comparing IPA to x-sampa vowel representations that may be useful to some users.
</p>
<p>**There may be issues when exporting figures to PDF using IPA font. Exporting plots directly as images works 'out of the box'**
</p>


<h3>Value</h3>

<p>A vector of the same length as 'vowels', with the values required to plot the desired vowels. 
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/X-SAMPA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## compare x-sampa and IPA vpwel charts
#xsampatoIPA ()
## some examples
#IPA = xsampatoIPA (c('I','3','e','Q'))
#plot (1:5, pch = IPA, cex = 2)

</code></pre>

<hr>
<h2 id='y96'>
Yang (1996) Korean Vowel Data
</h2><span id='topic+y96'></span>

<h3>Description</h3>

<p>Formant frequency information for vowels averaged across 60 male and female speakers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data (y96)</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt><code>sex</code></dt><dd><p> - A factor indicating speaker sex.</p>
</dd>
<dt><code>vowel</code></dt><dd><p> - The vowel category in x-sampa.</p>
</dd>
<dt><code>f1</code></dt><dd><p> - A numeric vector indcating the vowel F1 in Hz.</p>
</dd>
<dt><code>f2</code></dt><dd><p> - A numeric vector indcating the vowel F2 in Hz.</p>
</dd>
<dt><code>f3</code></dt><dd><p> - A numeric vector indcating the vowel F3 in Hz.</p>
</dd>
</dl>



<h3>References</h3>

<p>Yang, B. (1996). A comparative study of American English and Korean vowels produced by male and female speakers. Journal of Phonetics, 24. 245-261.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data(y96)
#vowelplot (y96$f1, y96$f2, y96$vowel, logaxes = 'xy', xsampa = TRUE)
</code></pre>

<hr>
<h2 id='zeros'>
Zero Vector/Matrix
</h2><span id='topic+zeros'></span>

<h3>Description</h3>

<p>Returns a vector or 2D matrix of zeros of the same shape as the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeros (x,y=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zeros_+3A_x">x</code></td>
<td>
<p>A scalar, vector, or two dimensional matrix.</p>
</td></tr> 
<tr><td><code id="zeros_+3A_y">y</code></td>
<td>
<p>An optional parameter to create a 2D matrix.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>If a scalar value is given, a vector of that many zeros is returned. If the y parameter is also specified, a matrix is returned with x rows and y columns. 
</p>
<p>If a vector is given, a vector of zeros of the same length is returned. 
</p>
<p>If a 2D matrix or dataframe is given, a matrix of zeros with the name number of rows and columns is returned.
</p>


<h3>Author(s)</h3>

<p>Santiago Barreda &lt;sbarreda@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A vector 
zeros (5)
## A matrix
zeros (5, 3)

## Copy an existing vector
zeros (1:10)

## Copy an existing matrix
samplematrix = 1:10 
zeros (samplematrix)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
