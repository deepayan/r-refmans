<!DOCTYPE html><html lang="en"><head><title>Help for package C443</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {C443}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clusterforest'><p>Clustering the classification trees in a forest based on similarities</p></a></li>
<li><a href='#clusters'><p>Get the cluster assignments for a solution of a clusterforest object</p></a></li>
<li><a href='#clusters.clusterforest'><p>Get the cluster assignments for a solution of a clusterforest object</p></a></li>
<li><a href='#clusters.default'><p>Get the cluster assignments for a solution of a clusterforest object</p></a></li>
<li><a href='#drugs'><p>Drug consumption data set</p></a></li>
<li><a href='#medoidtrees'><p>Get the medoid trees for a solution of a clusterforest object</p></a></li>
<li><a href='#medoidtrees.clusterforest'><p>Get the medoid trees for a solution of a clusterforest object</p></a></li>
<li><a href='#medoidtrees.default'><p>Get the medoid trees for a solution of a clusterforest object</p></a></li>
<li><a href='#plot.clusterforest'><p>Plot a clusterforest object</p></a></li>
<li><a href='#print.clusterforest'><p>Print a clusterforest object</p></a></li>
<li><a href='#summary.clusterforest'><p>Summarize a clusterforest object</p></a></li>
<li><a href='#treesimilarities'><p>Get the similarity matrix that wast used to create a clusterforest object</p></a></li>
<li><a href='#treesimilarities.clusterforest'><p>Get the similarity matrix that wast used to create a clusterforest object</p></a></li>
<li><a href='#treesimilarities.default'><p>Get the similarity matrix that wast used to create a clusterforest object</p></a></li>
<li><a href='#treesource'><p>Mapping the tree clustering solution to a known source of variation underlying the forest</p></a></li>
<li><a href='#treesource.clusterforest'><p>Mapping the tree clustering solution to a known source of variation underlying the forest</p></a></li>
<li><a href='#treesource.default'><p>Mapping the tree clustering solution to a known source of variation underlying the forest</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>See a Forest for the Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>3.4.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, partykit, rpart, RColorBrewer, grDevices, gridExtra,
ggplot2, cluster, parallel, foreach, igraph, stats, graphics,
plyr, ranger, randomForest, methods, doParallel</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-21</td>
</tr>
<tr>
<td>Description:</td>
<td>Get insight into a forest of classification trees, by calculating similarities between the trees, and subsequently clustering them. Each cluster is represented by it's most central cluster member. The package implements the methodology described in Sies &amp; Van Mechelen (2020) &lt;<a href="https://doi.org/10.1007%2Fs00357-019-09350-4">doi:10.1007/s00357-019-09350-4</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/KULeuven-PPW-OKPIV/C443">https://github.com/KULeuven-PPW-OKPIV/C443</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/KULeuven-PPW-OKPIV/C443/issues">https://github.com/KULeuven-PPW-OKPIV/C443/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-21 09:11:52 UTC; aniek</td>
</tr>
<tr>
<td>Author:</td>
<td>Aniek Sies [aut, cre],
  Kristof Meers [ctb],
  Iven Van Mechelen [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aniek Sies &lt;aniek.sies@kuleuven.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-21 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='clusterforest'>Clustering the classification trees in a forest based on similarities</h2><span id='topic+clusterforest'></span>

<h3>Description</h3>

<p>A function to get insight into a forest of classification trees by clustering the trees in a forest using Partitioning Around Medoids (PAM, Kaufman &amp; Rousseeuw, 2009), based on user provided similarities,
or based on similarities calculated by the package using a similarity measure chosen by the user (see Sies &amp; Van Mechelen, 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterforest(
  observeddata,
  treedata = NULL,
  trees,
  simmatrix = NULL,
  m = NULL,
  tol = NULL,
  weight = NULL,
  fromclus = 1,
  toclus = 1,
  treecov = NULL,
  sameobs = FALSE,
  seed = NULL,
  no_cores = detectCores(logical = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterforest_+3A_observeddata">observeddata</code></td>
<td>
<p>The entire observed dataset</p>
</td></tr>
<tr><td><code id="clusterforest_+3A_treedata">treedata</code></td>
<td>
<p>A list of dataframes on which the trees are based. Not necessary if the data set is included in the tree object already.</p>
</td></tr>
<tr><td><code id="clusterforest_+3A_trees">trees</code></td>
<td>
<p>A list of trees of class party, classes inheriting from party (e.g., glmtree), classes that can be coerced to party (i.e., rpart, Weka_tree, XMLnode), or a randomForest or ranger object.</p>
</td></tr>
<tr><td><code id="clusterforest_+3A_simmatrix">simmatrix</code></td>
<td>
<p>A similaritymatrix with the similarities between all trees. Should be square, symmetric and have ones on the diagonal. Default=NULL</p>
</td></tr>
<tr><td><code id="clusterforest_+3A_m">m</code></td>
<td>
<p>Similarity measure that should be used to calculate similarities, in the case that no similarity matrix was provided by the user. Default=NULL.
m=1 is based on counting common predictors;
m=2 is based on counting common predictor-split point combinations;
m=3 is based on common ordered sets of predictor-range part combinations (see Shannon &amp; Banks (1999));
m=4 is based on the agreement of partitions implied by leaf membership (Chipman, 1998);
m=5 is based on the agreement of partitions implied by class labels (Chipman, 1998);
m=6 is based on the number of predictor occurrences in definitions of leaves with same class label;
m=7 is based on the number of predictor-split point combinations in definitions of leaves with same class label
m=8  measures closeness to logical equivalence (applicable in case of binary predictors only)</p>
</td></tr>
<tr><td><code id="clusterforest_+3A_tol">tol</code></td>
<td>
<p>A vector with for each predictor a number that defines the tolerance zone within which two split points of the predictor in question are assumed equal. For example, if the tolerance for predictor X
is 1, then a split on that predictor in tree A will be assumed equal to a split in tree B as long as the splitpoint in tree B is within the splitpoint in tree A + or - 1. Only applicable for m=1 and m=6. Default=NULL</p>
</td></tr>
<tr><td><code id="clusterforest_+3A_weight">weight</code></td>
<td>
<p>If 1, the number of dissimilar paths in the Shannon and Banks measure (m=2), should be weighted by 1/their length (Otherwise they are weighted equally). Only applicable for m=2. Default=NULL</p>
</td></tr>
<tr><td><code id="clusterforest_+3A_fromclus">fromclus</code></td>
<td>
<p>The lowest number of clusters for which the PAM algorithm should be run. Default=1.</p>
</td></tr>
<tr><td><code id="clusterforest_+3A_toclus">toclus</code></td>
<td>
<p>The highest number of clusters for which the PAM algorithm should be run. Default=1.</p>
</td></tr>
<tr><td><code id="clusterforest_+3A_treecov">treecov</code></td>
<td>
<p>A vector/dataframe with the covariate value(s) for each tree in the forest (1 column per covariate) in the case of known
sources of variation underlying the forest, that should be linked to the clustering solution.</p>
</td></tr>
<tr><td><code id="clusterforest_+3A_sameobs">sameobs</code></td>
<td>
<p>Are the same observations included in every tree data set? For example, in the case of subsamples or bootstrap samples, the answer is no. Default=FALSE</p>
</td></tr>
<tr><td><code id="clusterforest_+3A_seed">seed</code></td>
<td>
<p>A seed number that should be used for the multi start procedure (based on which initial medoids are assigned). Default=NULL.</p>
</td></tr>
<tr><td><code id="clusterforest_+3A_no_cores">no_cores</code></td>
<td>
<p>Number of CPU cores used for computations. Default=detectCores(logical=FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user should provide the number of clusters that the solution should contain, or a range of numbers that should be explored.
In the latter case, the resulting clusterforest object will contain clustering results for each solution.
On this clusterforest object, several methods, such as plot, print and summary, can be used.
</p>


<h3>Value</h3>

<p>The function returns an object of class clusterforest, with attributes:
</p>
<table role = "presentation">
<tr><td><code>medoids</code></td>
<td>
<p>the position of the medoid trees in the forest (i.e., which element of the list of partytrees)</p>
</td></tr>
<tr><td><code>medoidtrees</code></td>
<td>
<p>the medoid trees</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>The cluster to which each tree in the forest is assigned</p>
</td></tr>
<tr><td><code>avgsilwidth</code></td>
<td>
<p>The average silhouette width for each solution (see Kaufman and Rousseeuw, 2009)</p>
</td></tr>
<tr><td><code>accuracy</code></td>
<td>
<p>For each solution, the accuracy of the predicted class labels based on the medoids.</p>
</td></tr>
<tr><td><code>agreement</code></td>
<td>
<p>For each solution, the agreement between the predicted class label for each observation based on the forest as a whole, and those based on the
medoids only (see Sies &amp; Van Mechelen,2020)</p>
</td></tr>
<tr><td><code>withinsim</code></td>
<td>
<p>Within cluster similarity for each solution (see Sies &amp; Van Mechelen, 2020)</p>
</td></tr>
<tr><td><code>treesimilarities</code></td>
<td>
<p>Similarity matrix on which clustering was based</p>
</td></tr>
<tr><td><code>treecov</code></td>
<td>
<p>covariate value(s) for each tree in the forest</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>seed number that was used for the multi start procedure (based on which initial medoids were assigned)</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Kaufman, L., &amp; Rousseeuw, P. J. (2009). Finding groups in data: an introduction to cluster analysis (Vol. 344). John Wiley &amp; Sons.</cite>
</p>
<p><cite>Sies, A. &amp; Van Mechelen I. (2020). C443: An R-package to see a forest for the trees. Journal of Classification.</cite>
</p>
<p><cite>Shannon, W. D., &amp; Banks, D. (1999). Combining classification trees using MLE. Statistics in medicine, 18(6), 727-740.</cite>
</p>
<p><cite>Chipman, H. A., George, E. I., &amp; McCulloh, R. E. (1998). Making sense of a forest of trees. Computing Science and Statistics, 84-92.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(MASS)
require(ranger)
require(rpart)
#Function to draw a bootstrap sample from a dataset
DrawBoots &lt;- function(dataset, i){
set.seed(2394 + i)
Boot &lt;- dataset[sample(1:nrow(dataset), size = nrow(dataset), replace = TRUE),]
return(Boot)
}

#Function to grow a tree using rpart on a dataset
GrowTree &lt;- function(x,y,BootsSample, minsplit = 40, minbucket = 20, maxdepth =3){
 controlrpart &lt;- rpart.control(minsplit = minsplit, minbucket = minbucket, maxdepth = maxdepth,
  maxsurrogate = 0, maxcompete = 0)
 tree &lt;- rpart(as.formula(paste(noquote(paste(y, "~")), noquote(paste(x, collapse="+")))),
 data = BootsSample, control = controlrpart)
 return(tree)
}

#Use functions to draw 10 boostrapsamples and grow a tree on each sample
Boots&lt;- lapply(1:10, function(k) DrawBoots(Pima.tr ,k))
Trees &lt;- lapply(1:10, function (i) GrowTree(x=c("npreg", "glu",  "bp",  "skin",
"bmi", "ped", "age"), y="type", Boots[[i]] ))

#Clustering the trees in this forest
ClusterForest&lt;- clusterforest(observeddata=Pima.tr,treedata=Boots,trees=Trees,m=1,
fromclus=1, toclus=2, sameobs=FALSE, no_cores=2)

#Example RandomForest
Pima.tr.ranger &lt;- ranger(type ~ ., data = Pima.tr, keep.inbag = TRUE, num.trees=20,
max.depth=3)

ClusterForest&lt;- clusterforest(observeddata=Pima.tr,trees=Pima.tr.ranger,m=5,
                           fromclus=1, toclus=2, sameobs=FALSE, no_cores=2)
</code></pre>

<hr>
<h2 id='clusters'>Get the cluster assignments for a solution of a clusterforest object</h2><span id='topic+clusters'></span>

<h3>Description</h3>

<p>A function to get the cluster assignments for a given solution of a clusterforest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusters(clusterforest, solution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusters_+3A_clusterforest">clusterforest</code></td>
<td>
<p>A clusterforest object</p>
</td></tr>
<tr><td><code id="clusters_+3A_solution">solution</code></td>
<td>
<p>The solution for which cluster assignments should be returned. Default = 1</p>
</td></tr>
</table>

<hr>
<h2 id='clusters.clusterforest'>Get the cluster assignments for a solution of a clusterforest object</h2><span id='topic+clusters.clusterforest'></span>

<h3>Description</h3>

<p>A function to get the cluster assignments for a given solution of a clusterforest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clusterforest'
clusters(clusterforest, solution = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusters.clusterforest_+3A_clusterforest">clusterforest</code></td>
<td>
<p>The clusterforest object</p>
</td></tr>
<tr><td><code id="clusters.clusterforest_+3A_solution">solution</code></td>
<td>
<p>The solution</p>
</td></tr>
</table>

<hr>
<h2 id='clusters.default'>Get the cluster assignments for a solution of a clusterforest object</h2><span id='topic+clusters.default'></span>

<h3>Description</h3>

<p>A function to get the cluster assignments for a given solution of a clusterforest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
clusters(clusterforest, solution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusters.default_+3A_clusterforest">clusterforest</code></td>
<td>
<p>The clusterforest object</p>
</td></tr>
<tr><td><code id="clusters.default_+3A_solution">solution</code></td>
<td>
<p>The solution</p>
</td></tr>
</table>

<hr>
<h2 id='drugs'>Drug consumption data set</h2><span id='topic+drugs'></span>

<h3>Description</h3>

<p>A dataset collected by Fehrman et al. (2017), freely available on the UCI Machine Learning Repository (Lichman, 2013) containing records of 1885 respondents regarding their use of 18 types of drugs, and their measurements on 12 predictors.
#' All predictors were originally categorical and were quantified by Fehrman et al. (2017). The meaning of the values can be found on
<a href="https://archive.ics.uci.edu/dataset/373/drug+consumption+quantified">https://archive.ics.uci.edu/dataset/373/drug+consumption+quantified</a>.
The original response categories for each drug were: never used the drug, used it over a decade ago, or in the last decade, year, month, week, or day.
We transformed these into binary response categories, where 0 (non-user) consists of the categories never used the drug and used it over a decade ago and 1 (user) consists of all other categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drugs
</code></pre>


<h3>Format</h3>

<p>A data frame with 1185 rows and 32 variables:
</p>

<dl>
<dt>ID</dt><dd><p>Respondent ID</p>
</dd>
<dt>Age</dt><dd><p>Age of respondent</p>
</dd>
<dt>Gender</dt><dd><p>Gender of respondent, where 0.48 denotes female and -0.48 denotes male</p>
</dd>
<dt>Edu</dt><dd><p>Level of education of participant</p>
</dd>
<dt>Country</dt><dd><p>Country of current residence of participant</p>
</dd>
<dt>Ethn</dt><dd><p>Ethnicity of participant</p>
</dd>
<dt>Neuro</dt><dd><p>NEO-FFI-R Neuroticism score</p>
</dd>
<dt>Extr</dt><dd><p>NEO-FFI-R Extraversion score</p>
</dd>
<dt>Open</dt><dd><p>NEO-FFI-R Openness to experience score</p>
</dd>
<dt>Agree</dt><dd><p>NEO-FFI-R Agreeableness score</p>
</dd>
<dt>Consc</dt><dd><p>NEO-FFI-R Conscientiousness score</p>
</dd>
<dt>Impul</dt><dd><p>Impulsiveness score measured by BIS-11</p>
</dd>
<dt>Sensat</dt><dd><p>Sensation seeking score measured by ImpSS</p>
</dd>
<dt>Alc</dt><dd><p>Alcohol user (1) or non-user (0)</p>
</dd>
<dt>Amphet</dt><dd><p>Amphetamine user (1) or non-user (0)</p>
</dd>
<dt>Amyl</dt><dd><p>Amyl nitrite user (1) or non-user (0)</p>
</dd>
<dt>Benzos</dt><dd><p>Benzodiazepine user (1) or non-user (0)</p>
</dd>
<dt>Caff</dt><dd><p>Caffeine user (1) or non-user (0)</p>
</dd>
<dt>Can</dt><dd><p>Cannabis user (1) or non-user (0)</p>
</dd>
<dt>Choco</dt><dd><p>Chocolate user (1) or non-user (0)</p>
</dd>
<dt>Coke</dt><dd><p>Coke user (1) or non-user (0)</p>
</dd>
<dt>Crack</dt><dd><p>Crack user (1) or non-user (0)</p>
</dd>
<dt>Ecst</dt><dd><p>Ecstacy user (1) or non-user (0)</p>
</dd>
<dt>Her</dt><dd><p>Heroin user (1) or non-user (0)</p>
</dd>
<dt>Ket</dt><dd><p>Ketamine user (1) or non-user (0)</p>
</dd>
<dt>Leghighs</dt><dd><p>Legal Highs user (1) or non-user (0)</p>
</dd>
<dt>LSD</dt><dd><p>LSD user (1) or non-user (0)</p>
</dd>
<dt>Meth</dt><dd><p>Methadone user (1) or non-user (0)</p>
</dd>
<dt>Mush</dt><dd><p>Magical Mushroom user (1) or non-user (0)</p>
</dd>
<dt>Nico</dt><dd><p>Nicotine user (1) or non-user (0)</p>
</dd>
<dt>Semeron</dt><dd><p>Semeron user (1) or non-user (0), fictitious drug to identify over-claimers</p>
</dd>
<dt>VSA</dt><dd><p>volatile substance abuse user(1) or non-user (0)</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://archive.ics.uci.edu/dataset/373/drug+consumption+quantified">https://archive.ics.uci.edu/dataset/373/drug+consumption+quantified</a>
</p>


<h3>References</h3>

<p><cite>Fehrman, E., Muhammad, A. K., Mirkes, E. M., Egan, V., &amp; Gorban, A. N. (2017). The Five Factor Model of personality and evaluation of drug consumption risk. In Data Science (pp. 231-242). Springer, Cham.</cite>
<cite>Lichman, M. (2013). UCI machine learning repository.</cite>
</p>

<hr>
<h2 id='medoidtrees'>Get the medoid trees for a solution of a clusterforest object</h2><span id='topic+medoidtrees'></span>

<h3>Description</h3>

<p>A function to get the medoid trees for a given solution of a clusterforest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medoidtrees(clusterforest, solution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="medoidtrees_+3A_clusterforest">clusterforest</code></td>
<td>
<p>A clusterforest object</p>
</td></tr>
<tr><td><code id="medoidtrees_+3A_solution">solution</code></td>
<td>
<p>The solution for which medoid trees should be returned. Default = 1</p>
</td></tr>
</table>

<hr>
<h2 id='medoidtrees.clusterforest'>Get the medoid trees for a solution of a clusterforest object</h2><span id='topic+medoidtrees.clusterforest'></span>

<h3>Description</h3>

<p>A function to get the medoid trees for a given solution of a clusterforest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clusterforest'
medoidtrees(clusterforest, solution = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="medoidtrees.clusterforest_+3A_clusterforest">clusterforest</code></td>
<td>
<p>A clusterforest object</p>
</td></tr>
<tr><td><code id="medoidtrees.clusterforest_+3A_solution">solution</code></td>
<td>
<p>The solution for which medoid trees should be returned. Default = 1</p>
</td></tr>
</table>

<hr>
<h2 id='medoidtrees.default'>Get the medoid trees for a solution of a clusterforest object</h2><span id='topic+medoidtrees.default'></span>

<h3>Description</h3>

<p>A function to get the medoid trees for a given solution of a clusterforest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
medoidtrees(clusterforest, solution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="medoidtrees.default_+3A_clusterforest">clusterforest</code></td>
<td>
<p>A clusterforest object</p>
</td></tr>
<tr><td><code id="medoidtrees.default_+3A_solution">solution</code></td>
<td>
<p>The solution for which medoid trees should be returned. Default = 1</p>
</td></tr>
</table>

<hr>
<h2 id='plot.clusterforest'>Plot a clusterforest object</h2><span id='topic+plot.clusterforest'></span>

<h3>Description</h3>

<p>A function that can be used to plot a clusterforest object, either by returning plots
with information such as average silhouette width and within cluster siiliarity on the cluster solutions, 
or plots of the medoid trees of each solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clusterforest'
plot(x, solution = NULL, predictive_plots = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.clusterforest_+3A_x">x</code></td>
<td>
<p>A clusterforest object</p>
</td></tr>
<tr><td><code id="plot.clusterforest_+3A_solution">solution</code></td>
<td>
<p>The solution to plot the medoid trees from. If NULL, plots with the average silhouette width, within cluster similiarty
(and predictive accuracy) per solution are returned. Default = NULL</p>
</td></tr>
<tr><td><code id="plot.clusterforest_+3A_predictive_plots">predictive_plots</code></td>
<td>
<p>Indicating whether predictive plots should be returned: A plot showing the predictive accuracy
when making predictions based on the medoid trees, and a plot of the agreement between the class label
for each object predicted on the basis of the random forest as a whole versus based on the medoid trees. Default = FALSE.</p>
</td></tr>
<tr><td><code id="plot.clusterforest_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be used in generic plot function, or in plot.party.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to plot a clusterforest object in two ways. If it's used without specifying a solution,
then the average silhouette width, and within cluster similarity measures are plotted for each solution. 
If additionally, predictive_plots=TRUE, two more plots are returned, namely a plot showing for each solution the 
predictive accuracy when making predictions based on the medoid trees, and a plot showing for each solution the agreement between
the class label for each object predicted on the basis of the random forest as a whole versus based on the medoid trees.
These plots may be helpful in deciding how many clusters are needed to summarize the forest (see Sies &amp; Van Mechelen, 2020).
</p>
<p>If the function is used with the clusterforest object and the number of the solution, then the medoid tree(s)
of that solution are plotted.
</p>


<h3>References</h3>

<p><cite>Sies, A. &amp; Van Mechelen I. (2020). C443: An R-package to see a forest for the trees. Journal of Classification.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(MASS)
require(rpart)
#Function to draw a bootstrap sample from a dataset
DrawBoots &lt;- function(dataset, i){
set.seed(2394 + i)
Boot &lt;- dataset[sample(1:nrow(dataset), size = nrow(dataset), replace = TRUE),]
return(Boot)
}

#Function to grow a tree using rpart on a dataset
GrowTree &lt;- function(x,y,BootsSample, minsplit = 40, minbucket = 20, maxdepth =3){
 controlrpart &lt;- rpart.control(minsplit = minsplit, minbucket = minbucket,
 maxdepth = maxdepth, maxsurrogate = 0, maxcompete = 0)
 tree &lt;- rpart(as.formula(paste(noquote(paste(y, "~")),
 noquote(paste(x, collapse="+")))), data = BootsSample,
 control = controlrpart)
 return(tree)
}

#Use functions to draw 20 boostrapsamples and grow a tree on each sample
Boots&lt;- lapply(1:10, function(k) DrawBoots(Pima.tr ,k))
Trees &lt;- lapply(1:10, function (i) GrowTree(x=c("npreg", "glu",  "bp",
 "skin",  "bmi", "ped", "age"), y="type",
Boots[[i]] ))

ClusterForest&lt;- clusterforest(observeddata=Pima.tr,treedata=Boots,trees=Trees,m=1,
fromclus=1, toclus=5, sameobs=FALSE, no_cores=2)
plot(ClusterForest)
plot(ClusterForest,2)
</code></pre>

<hr>
<h2 id='print.clusterforest'>Print a clusterforest object</h2><span id='topic+print.clusterforest'></span>

<h3>Description</h3>

<p>A function that can be used to print a clusterforest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clusterforest'
print(x, solution = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.clusterforest_+3A_x">x</code></td>
<td>
<p>A clusterforest object</p>
</td></tr>
<tr><td><code id="print.clusterforest_+3A_solution">solution</code></td>
<td>
<p>The solution to print the medoid trees from. Default = NULL</p>
</td></tr>
<tr><td><code id="print.clusterforest_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be used in the generic print function.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.clusterforest'>Summarize a clusterforest object</h2><span id='topic+summary.clusterforest'></span>

<h3>Description</h3>

<p>A function to summarize a clusterforest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clusterforest'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.clusterforest_+3A_object">object</code></td>
<td>
<p>A clusterforest object</p>
</td></tr>
<tr><td><code id="summary.clusterforest_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be used in the generic summary function.</p>
</td></tr>
</table>

<hr>
<h2 id='treesimilarities'>Get the similarity matrix that wast used to create a clusterforest object</h2><span id='topic+treesimilarities'></span>

<h3>Description</h3>

<p>A function to get the similarity matrix used to obtain a clusterforest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treesimilarities(clusterforest)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treesimilarities_+3A_clusterforest">clusterforest</code></td>
<td>
<p>A clusterforest object</p>
</td></tr>
</table>

<hr>
<h2 id='treesimilarities.clusterforest'>Get the similarity matrix that wast used to create a clusterforest object</h2><span id='topic+treesimilarities.clusterforest'></span>

<h3>Description</h3>

<p>A function to get the similarity matrix used to obtain a clusterforest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clusterforest'
treesimilarities(clusterforest)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treesimilarities.clusterforest_+3A_clusterforest">clusterforest</code></td>
<td>
<p>A clusterforest object</p>
</td></tr>
</table>

<hr>
<h2 id='treesimilarities.default'>Get the similarity matrix that wast used to create a clusterforest object</h2><span id='topic+treesimilarities.default'></span>

<h3>Description</h3>

<p>A function to get the similarity matrix used to obtain a clusterforest object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
treesimilarities(clusterforest)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treesimilarities.default_+3A_clusterforest">clusterforest</code></td>
<td>
<p>A clusterforest object</p>
</td></tr>
</table>

<hr>
<h2 id='treesource'>Mapping the tree clustering solution to a known source of variation underlying the forest</h2><span id='topic+treesource'></span>

<h3>Description</h3>

<p>A function that can be used to get insight into a clusterforest solution, in the case that there are known
sources of variation underlying the forest. These known sources of variation must be included in the clusterforest object
(and thus must be defined when running the clusterforest function)
In case of a categorical covariate, it visualizes the number of trees from each value of the covariate that belong to each cluster.
In case of a continuous covariate, it returns the mean and standard deviation of the covariate in each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treesource(clusterforest, solution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treesource_+3A_clusterforest">clusterforest</code></td>
<td>
<p>The clusterforest object, indluding the treecov attribute.</p>
</td></tr>
<tr><td><code id="treesource_+3A_solution">solution</code></td>
<td>
<p>The solution</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>multiplot</code></td>
<td>
<p>In case of categorical covariate, for each value of the covariate, a bar plot with the number of trees that belong to each cluster</p>
</td></tr>
<tr><td><code>heatmap</code></td>
<td>
<p>In case of a categorical covariate, a heatmap with for each value of the covariate, the number of trees that belong to each cluster</p>
</td></tr>
<tr><td><code>clustermeans</code></td>
<td>
<p>In case of a continuous covariate, the mean of the covariate in each cluster</p>
</td></tr>
<tr><td><code>clusterstds</code></td>
<td>
<p>In case of a continuous covariate, the standard deviation of the covariate in each cluster</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(rpart)
data_Amphet &lt;-drugs[,c ("Amphet","Age", "Gender", "Edu", "Neuro", "Extr", "Open", "Agree",
"Consc", "Impul","Sensat")]
data_cocaine &lt;-drugs[,c ("Coke","Age", "Gender", "Edu", "Neuro", "Extr", "Open", "Agree",
                         "Consc", "Impul","Sensat")]


#Function to draw a bootstrap sample from a dataset
DrawBoots &lt;- function(dataset, i){
set.seed(2394 + i)
Boot &lt;- dataset[sample(1:nrow(dataset), size = nrow(dataset), replace = TRUE),]
return(Boot)
}

#Function to grow a tree using rpart on a dataset
GrowTree &lt;- function(x,y,BootsSample, minsplit = 40, minbucket = 20, maxdepth =3){

 controlrpart &lt;- rpart.control(minsplit = minsplit, minbucket = minbucket, maxdepth = maxdepth,
 maxsurrogate = 0, maxcompete = 0)
 tree &lt;- rpart(as.formula(paste(noquote(paste(y, "~")), noquote(paste(x, collapse="+")))),
  data = BootsSample, control = controlrpart)
 return(tree)
}

#Draw bootstrap samples and grow trees
BootsA&lt;- lapply(1:5, function(k) DrawBoots(data_Amphet,k))
BootsC&lt;- lapply(1:5, function(k) DrawBoots(data_cocaine,k))
Boots = c(BootsA,BootsC)

TreesA &lt;- lapply(1:5, function (i) GrowTree(x=c ("Age", "Gender", "Edu", "Neuro",
"Extr", "Open", "Agree","Consc", "Impul","Sensat"), y="Amphet", BootsA[[i]] ))
TreesC &lt;- lapply(1:5, function (i) GrowTree(x=c ( "Age", "Gender", "Edu", "Neuro",
"Extr", "Open", "Agree", "Consc", "Impul","Sensat"), y="Coke", BootsC[[i]] ))
Trees=c(TreesA,TreesC)

#Cluster the trees
ClusterForest&lt;- clusterforest(observeddata=drugs,treedata=Boots,trees=Trees,m=1,
fromclus=2, toclus=2, treecov=rep(c("Amphet","Coke"),each=5), sameobs=FALSE, no_cores=2)

#Link cluster result to known source of variation
treesource(ClusterForest, 2)
</code></pre>

<hr>
<h2 id='treesource.clusterforest'>Mapping the tree clustering solution to a known source of variation underlying the forest</h2><span id='topic+treesource.clusterforest'></span>

<h3>Description</h3>

<p>A function that can be used to get insight into a clusterforest solution, in the case that there is a known
source of variation underlying the forest.
It visualizes the number of trees from each source that belong to each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clusterforest'
treesource(clusterforest, solution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treesource.clusterforest_+3A_clusterforest">clusterforest</code></td>
<td>
<p>The clusterforest object</p>
</td></tr>
<tr><td><code id="treesource.clusterforest_+3A_solution">solution</code></td>
<td>
<p>The solution</p>
</td></tr>
</table>

<hr>
<h2 id='treesource.default'>Mapping the tree clustering solution to a known source of variation underlying the forest</h2><span id='topic+treesource.default'></span>

<h3>Description</h3>

<p>A function that can be used to get insight into a clusterforest solution, in the case that there is a known
source of variation underlying the forest.
It visualizes the number of trees from each source that belong to each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
treesource(clusterforest, solution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treesource.default_+3A_clusterforest">clusterforest</code></td>
<td>
<p>The clusterforest object</p>
</td></tr>
<tr><td><code id="treesource.default_+3A_solution">solution</code></td>
<td>
<p>The solution</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
