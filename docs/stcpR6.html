<!DOCTYPE html><html><head><title>Help for package stcpR6</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stcpR6}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stcpR6-package'><p>stcpR6: Sequential Test and Change-Point Detection Algorithms Based on E-Values / E-Detectors</p></a></li>
<li><a href='#compute_baseline'><p>Compute baseline processes.</p></a></li>
<li><a href='#compute_baseline_for_sample_size'><p>Compute baseline parameters given target variance process bounds.</p></a></li>
<li><a href='#generate_sub_B_fn'><p>Pre-defined psi_star functions for sub-Bernoulli family.</p></a></li>
<li><a href='#generate_sub_E_fn'><p>Pre-defined psi_star functions for sub-exponential family.</p></a></li>
<li><a href='#generate_sub_G_fn'><p>Pre-defined psi_star functions for sub-Gaussian family.</p></a></li>
<li><a href='#logSumExpTrick'><p>log-sum-exp trick</p></a></li>
<li><a href='#NormalCS'><p>NormalCS Class</p></a></li>
<li><a href='#Stcp'><p>Stcp Class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Sequential Test and Change-Point Detection Algorithms Based on
E-Values / E-Detectors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms of nonparametric sequential test and online 
  change-point detection for streams of univariate (sub-)Gaussian, binary, 
  and bounded random variables, introduced in following publications -
  Shin et al. (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2203.03532">doi:10.48550/arXiv.2203.03532</a>&gt;,
  Shin et al. (2021) &lt;<a href="https://doi.org/10.48550%2FarXiv.2010.08082">doi:10.48550/arXiv.2010.08082</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 1.0.12), R6</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/shinjaehyeok/stcpR6">https://github.com/shinjaehyeok/stcpR6</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shinjaehyeok/stcpR6/issues">https://github.com/shinjaehyeok/stcpR6/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-08 04:32:28 UTC; shinj</td>
</tr>
<tr>
<td>Author:</td>
<td>Jaehyeok Shin <a href="https://orcid.org/0000-0003-0464-915X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jaehyeok Shin &lt;shinjaehyeok@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-08 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stcpR6-package'>stcpR6: Sequential Test and Change-Point Detection Algorithms Based on E-Values / E-Detectors</h2><span id='topic+stcpR6'></span><span id='topic+stcpR6-package'></span>

<h3>Description</h3>

<p>Algorithms of nonparametric sequential test and online change-point detection for streams of univariate (sub-)Gaussian, binary, and bounded random variables, introduced in following publications - Shin et al. (2024) <a href="https://doi.org/10.48550/arXiv.2203.03532">doi:10.48550/arXiv.2203.03532</a>, Shin et al. (2021) <a href="https://doi.org/10.48550/arXiv.2010.08082">doi:10.48550/arXiv.2010.08082</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jaehyeok Shin <a href="mailto:shinjaehyeok@gmail.com">shinjaehyeok@gmail.com</a> (<a href="https://orcid.org/0000-0003-0464-915X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/shinjaehyeok/stcpR6">https://github.com/shinjaehyeok/stcpR6</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/shinjaehyeok/stcpR6/issues">https://github.com/shinjaehyeok/stcpR6/issues</a>
</p>
</li></ul>


<hr>
<h2 id='compute_baseline'>Compute baseline processes.</h2><span id='topic+compute_baseline'></span>

<h3>Description</h3>

<p>Compute parameters to build baseline processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_baseline(
  alpha,
  delta_lower,
  delta_upper,
  psi_fn_list = generate_sub_G_fn(),
  v_min = 1,
  k_max = 200,
  tol = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_baseline_+3A_alpha">alpha</code></td>
<td>
<p>ARL parameter in (0,1)</p>
</td></tr>
<tr><td><code id="compute_baseline_+3A_delta_lower">delta_lower</code></td>
<td>
<p>Lower bound of target Delta. It must be positive and smaller than or equal to <code>delta_upper</code>.</p>
</td></tr>
<tr><td><code id="compute_baseline_+3A_delta_upper">delta_upper</code></td>
<td>
<p>Upper bound of target Delta. It must be positive and larger than or equal to <code>delta_lower</code>.</p>
</td></tr>
<tr><td><code id="compute_baseline_+3A_psi_fn_list">psi_fn_list</code></td>
<td>
<p>A list of R functions that computes psi and psi_star functions. Can be generated by <code>generate_sub_G_fn()</code> or counterparts for sub_B and sub_E.</p>
</td></tr>
<tr><td><code id="compute_baseline_+3A_v_min">v_min</code></td>
<td>
<p>A lower bound of v function in the baseline process. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="compute_baseline_+3A_k_max">k_max</code></td>
<td>
<p>Positive integer to determine the maximum number of baselines. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="compute_baseline_+3A_tol">tol</code></td>
<td>
<p>Tolerance of root-finding, positive numeric. Default is 1e-10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 1. Parameters of baseline processes, 2. Mixing weights, 3. Auxiliary values for computation.
</p>

<hr>
<h2 id='compute_baseline_for_sample_size'>Compute baseline parameters given target variance process bounds.</h2><span id='topic+compute_baseline_for_sample_size'></span>

<h3>Description</h3>

<p>Given target variance process bounds for confidence sequences, compute baseline parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_baseline_for_sample_size(
  alpha,
  v_upper,
  v_lower,
  psi_fn_list = generate_sub_G_fn(),
  v_min = 1,
  k_max = 200,
  tol = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_baseline_for_sample_size_+3A_alpha">alpha</code></td>
<td>
<p>ARL parameter in (0,1)</p>
</td></tr>
<tr><td><code id="compute_baseline_for_sample_size_+3A_v_upper">v_upper</code></td>
<td>
<p>Upper bound of the target variance process bound</p>
</td></tr>
<tr><td><code id="compute_baseline_for_sample_size_+3A_v_lower">v_lower</code></td>
<td>
<p>Lower bound of the target variance process bound.</p>
</td></tr>
<tr><td><code id="compute_baseline_for_sample_size_+3A_psi_fn_list">psi_fn_list</code></td>
<td>
<p>A list of R functions that computes psi and psi_star functions. Can be generated by <code>generate_sub_G_fn()</code> or counterparts for sub_B and sub_E.</p>
</td></tr>
<tr><td><code id="compute_baseline_for_sample_size_+3A_v_min">v_min</code></td>
<td>
<p>A lower bound of v function in the baseline process. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="compute_baseline_for_sample_size_+3A_k_max">k_max</code></td>
<td>
<p>Positive integer to determine the maximum number of baselines. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="compute_baseline_for_sample_size_+3A_tol">tol</code></td>
<td>
<p>Tolerance of root-finding, positive numeric. Default is 1e-10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 1. Parameters of baseline processes, 2. Mixing weights, 3. Auxiliary values for computation.
</p>

<hr>
<h2 id='generate_sub_B_fn'>Pre-defined psi_star functions for sub-Bernoulli family.</h2><span id='topic+generate_sub_B_fn'></span>

<h3>Description</h3>

<p>Pre-defined psi_star functions for sub-Bernoulli family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_sub_B_fn(p = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_sub_B_fn_+3A_p">p</code></td>
<td>
<p>The boundary of mean space of the pre-change distributions (default = 0.5).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of pre-defined psi_star functions for sub-Bernoulli family.
</p>

<hr>
<h2 id='generate_sub_E_fn'>Pre-defined psi_star functions for sub-exponential family.</h2><span id='topic+generate_sub_E_fn'></span>

<h3>Description</h3>

<p>Pre-defined psi_star functions for sub-exponential family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_sub_E_fn()
</code></pre>


<h3>Value</h3>

<p>A list of pre-defined psi_star functions for sub-exponential family.
</p>

<hr>
<h2 id='generate_sub_G_fn'>Pre-defined psi_star functions for sub-Gaussian family.</h2><span id='topic+generate_sub_G_fn'></span>

<h3>Description</h3>

<p>Pre-defined psi_star functions for sub-Gaussian family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_sub_G_fn(sig = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_sub_G_fn_+3A_sig">sig</code></td>
<td>
<p>The sigma parameter of the sub-Gaussian family (default = 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of pre-defined psi_star functions for sub-Gaussian family.
</p>

<hr>
<h2 id='logSumExpTrick'>log-sum-exp trick</h2><span id='topic+logSumExpTrick'></span>

<h3>Description</h3>

<p>Apply log-sum-exp trick to a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logSumExpTrick(xs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logSumExpTrick_+3A_xs">xs</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log of sum of exp of <code>xs</code>, which is equal to <code>log(sum(exp(xs)))</code>.
</p>

<hr>
<h2 id='NormalCS'>NormalCS Class</h2><span id='topic+NormalCS'></span>

<h3>Description</h3>

<p>NormalCS class is used to compute always-valid confidence sequence
for the standard normal process based on the STCP method.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NormalCS-new"><code>NormalCS$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalCS-print"><code>NormalCS$print()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalCS-getAlpha"><code>NormalCS$getAlpha()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalCS-getWeights"><code>NormalCS$getWeights()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalCS-getLambdas"><code>NormalCS$getLambdas()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalCS-computeWidth"><code>NormalCS$computeWidth()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalCS-computeInterval"><code>NormalCS$computeInterval()</code></a>
</p>
</li></ul>


<hr>
<a id="method-NormalCS-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new NormalCS object.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalCS$new(
  alternative = c("two.sided", "greater", "less"),
  alpha = 0.05,
  n_upper = 1000,
  n_lower = 1,
  weights = NULL,
  lambdas = NULL,
  k_max = 1000
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alternative</code></dt><dd><p>Alternative / post-change mean space
</p>

<ul>
<li><p> two.sided: Two-sided test / change detection
</p>
</li>
<li><p> greater: Alternative /post-change mean is greater than null / pre-change one
</p>
</li>
<li><p> less:  Alternative /post-change mean is less than null / pre-change one
</p>
</li></ul>
</dd>
<dt><code>alpha</code></dt><dd><p>Upper bound on the type 1 error of the confidence sequence.</p>
</dd>
<dt><code>n_upper</code></dt><dd><p>Upper bound of the target sample interval</p>
</dd>
<dt><code>n_lower</code></dt><dd><p>Lower bound of the target sample interval</p>
</dd>
<dt><code>weights</code></dt><dd><p>If not null, the input weights will be used to initialize the object
instead of <code>n_upper</code> and <code>n_lower</code>.</p>
</dd>
<dt><code>lambdas</code></dt><dd><p>If not null, the input lambdas will be used to initialize the object.
instead of <code>n_upper</code> and <code>n_lower</code>.</p>
</dd>
<dt><code>k_max</code></dt><dd><p>Positive integer to determine the maximum number of baselines.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>NormalCS</code> object.
</p>


<hr>
<a id="method-NormalCS-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print summary of Stcp object.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalCS$print()</pre></div>


<hr>
<a id="method-NormalCS-getAlpha"></a>



<h4>Method <code>getAlpha()</code></h4>

<p>Return the upper bound on the type 1 error
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalCS$getAlpha()</pre></div>


<hr>
<a id="method-NormalCS-getWeights"></a>



<h4>Method <code>getWeights()</code></h4>

<p>Return weights of mixture of e-values / e-detectors.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalCS$getWeights()</pre></div>


<hr>
<a id="method-NormalCS-getLambdas"></a>



<h4>Method <code>getLambdas()</code></h4>

<p>Return lambda parameters of mixture of e-values / e-detectors.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalCS$getLambdas()</pre></div>


<hr>
<a id="method-NormalCS-computeWidth"></a>



<h4>Method <code>computeWidth()</code></h4>

<p>Compute the width of confidence interval at time n.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalCS$computeWidth(n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Positive time.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-NormalCS-computeInterval"></a>



<h4>Method <code>computeInterval()</code></h4>

<p>Compute a vector of two end points of confidence interval
at time n
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalCS$computeInterval(n, x_bar = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Positive time.</p>
</dd>
<dt><code>x_bar</code></dt><dd><p>The center of the confidence interval.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Initialize two-sided standard normal confidence sequence
# optimized for the interval [10, 100]
normal_cs &lt;- NormalCS$new(
  alternative = "two.sided",
  alpha = 0.05,
  n_upper = 100,
  n_lower = 10
  )
  
# Compute confidence interval at n = 20 when observed sample mean = 0.5
normal_cs$computeInterval(20, x_bar = 0.5)

# (Advanced) NormalCS supports general variance process.
# Both n_upper and n_lower can be general positive numbers.
normal_cs2 &lt;- NormalCS$new(
  alternative = "two.sided",
  alpha = 0.05,
  n_upper = 100.5,
  n_lower = 10.5
  )
# Confidence interval at n = 20.5
normal_cs$computeInterval(20.5, x_bar = 0.5)

</code></pre>

<hr>
<h2 id='Stcp'>Stcp Class</h2><span id='topic+Stcp'></span>

<h3>Description</h3>

<p>Stcp class supports a unified framework for sequential tests and change
detection algorithms for streams of univariate (sub-)Gaussian, binary,
and bounded random variables.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Stcp-new"><code>Stcp$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-print"><code>Stcp$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-getWeights"><code>Stcp$getWeights()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-getLambdas"><code>Stcp$getLambdas()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-getLogValue"><code>Stcp$getLogValue()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-getThreshold"><code>Stcp$getThreshold()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-isStopped"><code>Stcp$isStopped()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-getTime"><code>Stcp$getTime()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-getStoppedTime"><code>Stcp$getStoppedTime()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-reset"><code>Stcp$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-updateLogValues"><code>Stcp$updateLogValues()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-updateLogValuesUntilStop"><code>Stcp$updateLogValuesUntilStop()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-updateAndReturnHistories"><code>Stcp$updateAndReturnHistories()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-updateLogValuesByAvgs"><code>Stcp$updateLogValuesByAvgs()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-updateLogValuesUntilStopByAvgs"><code>Stcp$updateLogValuesUntilStopByAvgs()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-updateAndReturnHistoriesByAvgs"><code>Stcp$updateAndReturnHistoriesByAvgs()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Stcp-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new Stcp object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$new(
  method = c("ST", "SR", "CU", "GLRCU"),
  family = c("Normal", "Ber", "Bounded"),
  alternative = c("two.sided", "greater", "less"),
  threshold = log(1/0.05),
  m_pre = 0,
  delta_lower = 0.1,
  delta_upper = NULL,
  weights = NULL,
  lambdas = NULL,
  k_max = 1000
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>Method of the sequential procedure.
</p>

<ul>
<li><p> ST: Sequential test based on a mixture of E-values.
</p>
</li>
<li><p> SR: Sequential change detection based on e-SR procedure.
</p>
</li>
<li><p> CU: Sequential change detection based on e-CUSUM procedure.
</p>
</li>
<li><p> GLRCU: Sequential change detection based on GLR-CUSUM procedure.
</p>
</li></ul>
</dd>
<dt><code>family</code></dt><dd><p>Distribution of underlying univariate observations.
</p>

<ul>
<li><p> Normal: (sub-)Gaussian with sigma = 1.
</p>
</li>
<li><p> Ber: Bernoulli distribution on {0,1}.
</p>
</li>
<li><p> Bounded: General bounded distribution on [0,1]
</p>
</li></ul>
</dd>
<dt><code>alternative</code></dt><dd><p>Alternative / post-change mean space
</p>

<ul>
<li><p> two.sided: Two-sided test / change detection
</p>
</li>
<li><p> greater: Alternative /post-change mean is greater than null / pre-change one
</p>
</li>
<li><p> less:  Alternative /post-change mean is less than null / pre-change one
</p>
</li></ul>
</dd>
<dt><code>threshold</code></dt><dd><p>Stopping threshold. We recommend to use log(1/alpha)
for &quot;ST&quot; and &quot;SR&quot; methods where alpha is a testing level or 1/ARL.
for &quot;CU&quot; and &quot;GRLCU&quot;, we recommend to tune the threshold by using
domain-specific sampler to hit the target ARL.</p>
</dd>
<dt><code>m_pre</code></dt><dd><p>The boundary of mean parameter in null / pre-change space</p>
</dd>
<dt><code>delta_lower</code></dt><dd><p>Minimum gap between null / pre-change space and
alternative / post-change one. It must be strictly positive for ST, SR and CU.
Currently, GLRCU does not support the minimum gap, and this param will be ignored.</p>
</dd>
<dt><code>delta_upper</code></dt><dd><p>Maximum gap between null / pre-change space and
alternative / post-change one. It must be strictly positive for ST, SR and CU.
Currently, GLRCU does not support the maximum gap, and this param will be ignored.</p>
</dd>
<dt><code>weights</code></dt><dd><p>If not null, the input weights will be used to initialize Stcp object.</p>
</dd>
<dt><code>lambdas</code></dt><dd><p>If not null, the input lambdas will be used to initialize Stcp object.</p>
</dd>
<dt><code>k_max</code></dt><dd><p>Positive integer to determine the maximum number of baselines.
For GLRCU method, it is used as the lookup window size for GLRCU statistics.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Stcp</code> object.
</p>


<hr>
<a id="method-Stcp-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print summary of Stcp object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$print()</pre></div>


<hr>
<a id="method-Stcp-getWeights"></a>



<h4>Method <code>getWeights()</code></h4>

<p>Return weights of mixture of e-values / e-detectors.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$getWeights()</pre></div>


<hr>
<a id="method-Stcp-getLambdas"></a>



<h4>Method <code>getLambdas()</code></h4>

<p>Return lambda parameters of mixture of e-values / e-detectors.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$getLambdas()</pre></div>


<hr>
<a id="method-Stcp-getLogValue"></a>



<h4>Method <code>getLogValue()</code></h4>

<p>Return the log value of mixture of e-values / e-detectors.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$getLogValue()</pre></div>


<hr>
<a id="method-Stcp-getThreshold"></a>



<h4>Method <code>getThreshold()</code></h4>

<p>Return the threshold of the sequential test / change detection
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$getThreshold()</pre></div>


<hr>
<a id="method-Stcp-isStopped"></a>



<h4>Method <code>isStopped()</code></h4>

<p>Return TRUE if the sequential test / change detection was stopped by crossing the threshold.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$isStopped()</pre></div>


<hr>
<a id="method-Stcp-getTime"></a>



<h4>Method <code>getTime()</code></h4>

<p>Return the number of observations having been passed.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$getTime()</pre></div>


<hr>
<a id="method-Stcp-getStoppedTime"></a>



<h4>Method <code>getStoppedTime()</code></h4>

<p>Return the stopped time. If it has been never stopped, return zero.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$getStoppedTime()</pre></div>


<hr>
<a id="method-Stcp-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the stcp object to the initial setup.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$reset()</pre></div>


<hr>
<a id="method-Stcp-updateLogValues"></a>



<h4>Method <code>updateLogValues()</code></h4>

<p>Update the log value and related fields by passing a vector of observations.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$updateLogValues(xs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xs</code></dt><dd><p>A numeric vector of observations.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Stcp-updateLogValuesUntilStop"></a>



<h4>Method <code>updateLogValuesUntilStop()</code></h4>

<p>Update the log value and related fields until the log value is crossing the boundary.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$updateLogValuesUntilStop(xs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xs</code></dt><dd><p>A numeric vector of observations.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Stcp-updateAndReturnHistories"></a>



<h4>Method <code>updateAndReturnHistories()</code></h4>

<p>Update the log value and related fields then return updated log values by passing a vector of observations.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$updateAndReturnHistories(xs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xs</code></dt><dd><p>A numeric vector of observations.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Stcp-updateLogValuesByAvgs"></a>



<h4>Method <code>updateLogValuesByAvgs()</code></h4>

<p>Update the log value and related fields by passing
a vector of averages and number of corresponding samples.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$updateLogValuesByAvgs(x_bars, ns)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x_bars</code></dt><dd><p>A numeric vector of averages.</p>
</dd>
<dt><code>ns</code></dt><dd><p>A numeric vector of sample sizes.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Stcp-updateLogValuesUntilStopByAvgs"></a>



<h4>Method <code>updateLogValuesUntilStopByAvgs()</code></h4>

<p>Update the log value and related fields by passing
a vector of averages and number of corresponding samples
until the log value is crossing the boundary.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$updateLogValuesUntilStopByAvgs(x_bars, ns)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x_bars</code></dt><dd><p>A numeric vector of averages.</p>
</dd>
<dt><code>ns</code></dt><dd><p>A numeric vector of sample sizes.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Stcp-updateAndReturnHistoriesByAvgs"></a>



<h4>Method <code>updateAndReturnHistoriesByAvgs()</code></h4>

<p>Update the log value and related fields then return updated log values
a vector of averages and number of corresponding samples.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$updateAndReturnHistoriesByAvgs(x_bars, ns)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x_bars</code></dt><dd><p>A numeric vector of averages.</p>
</dd>
<dt><code>ns</code></dt><dd><p>A numeric vector of sample sizes.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Sequential Normal mean test H0: mu &lt;= 0
# Initialize stcp object for this test.
stcp &lt;- Stcp$new(method = "ST",
                 family = "Normal",
                 alternative = "greater",
                 threshold = log(1 / 0.05),
                 m_pre = 0)
                 
# Update the observations
obs &lt;- c(1.0, 3.0, 2.0)            
stcp$updateLogValuesUntilStop(obs)

# Check whether the sequential test is stopped
stcp$isStopped() # TRUE

# Check when the test was stopped
stcp$getStoppedTime() # 3

# Although the number of obervaions was 4, the test was stopped at 3.
stcp$getTime() # 3

# Get the log value of the mixutre of e-values at the current time (3)
stcp$getLogValue() # 4.425555

# ...which is higher than the threshold log(1 / 0.05) ~ 2.996
stcp$getThreshold() # 2.995732

# Reset the test object
stcp$reset()

# Rerun the test but, at this time, we track updated log values
log_values &lt;- stcp$updateAndReturnHistories(obs) 
print(log_values) # 0.1159777 2.7002207 4.4255551 1.9746508

# Again, the test was stopped at 3rd observation
stcp$getStoppedTime() # 3

# But, at this time, log values were evaluated until the 4th observation.
stcp$getTime() # 4

# Print overall summary
stcp # or stcp$print() or print(stcp)
# stcp Model:
#   - Method:  ST 
# - Family:  Normal 
# - Alternative:  greater 
# - Alpha:  0.05 
# - m_pre:  0 
# - Num. of mixing components:  55 
# - Obs. have been passed:  4 
# - Current log value:  1.974651 
# - Is stopped before:  TRUE 
# - Stopped time:  3 

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
