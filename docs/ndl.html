<!DOCTYPE html><html><head><title>Help for package ndl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ndl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ndl-package'>
<p>Naive Discriminative Learning</p></a></li>
<li><a href='#acts2probs'>
<p>Calculate probability matrix from activation matrix, as well as predicted</p>
values</a></li>
<li><a href='#anova.ndlClassify'><p>Analysis of Model Fit for Naive Discriminatory Reader Models</p></a></li>
<li><a href='#crosstableStatistics'>
<p>Calculate statistics for a contingency table</p></a></li>
<li><a href='#cueCoding'>
<p>code a vector of cues as n-grams</p></a></li>
<li><a href='#danks'>
<p>Example data from Danks (2003), after Spellman (1996).</p></a></li>
<li><a href='#dative'><p>Dative Alternation</p></a></li>
<li><a href='#estimateActivations'>
<p>Estimation of the activations of outcomes (meanings)</p></a></li>
<li><a href='#estimateWeights'>
<p>Estimation of the association weights using the equilibrium</p>
equations of Danks (2003) for the Rescorla-Wagner equations.</a></li>
<li><a href='#estimateWeightsCompact'>
<p>Estimation of the association weights using the equilibrium</p>
equations of Danks (2003) for the Rescorla-Wagner equations using
a compact binary event file.</a></li>
<li><a href='#learn'>
<p>Count cue-outcome co-occurences needed to run the Danks equations.</p></a></li>
<li><a href='#learnLegacy'>
<p>Count cue-outcome co-occurrences needed to run the Danks equations.</p></a></li>
<li><a href='#lexample'>
<p>Lexical example data illustrating the Rescorla-Wagner equations</p></a></li>
<li><a href='#modelStatistics'>
<p>Calculate a range of goodness of fit measures for an object fitted with some multivariate statistical method that yields probability estimates for outcomes.</p></a></li>
<li><a href='#ndlClassify'>
<p>Classification using naive discriminative learning.</p></a></li>
<li><a href='#ndlCrossvalidate'>
<p>Crossvalidation of a Naive Discriminative Learning model.</p></a></li>
<li><a href='#ndlCuesOutcomes'><p>Creation of dataframe for Naive Discriminative Learning from formula specification</p>
</p></a></li>
<li><a href='#ndlStatistics'>
<p>Calculate goodness of fit statistics for a naive discriminative</p>
learning model.</a></li>
<li><a href='#ndlVarimp'>
<p>Permutation variable importance for classification using naive discriminative learning.</p></a></li>
<li><a href='#numbers'>
<p>Example data illustrating the Rescorla-Wagner equations as applied</p>
to numerical cognition by Ramscar et al. (2011).</a></li>
<li><a href='#orthoCoding'>
<p>Code a character string (written word form) as letter n-grams</p></a></li>
<li><a href='#plot.ndlClassify'>
<p>Plot function for selected results of <code>ndlClassify</code>.</p></a></li>
<li><a href='#plot.RescorlaWagner'>
<p>Plot function for the output of <code>RescorlaWagner</code>.</p></a></li>
<li><a href='#plurals'>
<p>Artificial data set used to illustrate the Rescorla-Wagner equations</p>
and naive discriminative learning.</a></li>
<li><a href='#predict.ndlClassify'>
<p>Predict method for ndlClassify objects</p></a></li>
<li><a href='#random.pseudoinverse'>
<p>Calculate an approximation of the pseudoinverse of a matrix.</p></a></li>
<li><a href='#RescorlaWagner'>
<p>Implementation of the Rescorla-Wagner equations.</p></a></li>
<li><a href='#serbian'>
<p>Serbian case inflected nouns.</p></a></li>
<li><a href='#serbianLex'>
<p>Serbian lexicon with 1187 prime-target pairs.</p></a></li>
<li><a href='#serbianUniCyr'>
<p>Serbian case inflected nouns (in Cyrillic Unicode).</p></a></li>
<li><a href='#serbianUniLat'>
<p>Serbian case inflected nouns (in Latin-alphabet Unicode).</p></a></li>
<li><a href='#summary.ndlClassify'><p>A summary of a Naive Discriminatory Learning Model</p></a></li>
<li><a href='#summary.ndlCrossvalidate'><p>A summary of a crossvalidation of a Naive Discriminatory Reader Model</p></a></li>
<li><a href='#think'>
<p>Finnish &lsquo;think&rsquo; verbs.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Naive Discriminative Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.18</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-09-09</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tino Sering &lt;konstantin.sering@uni-tuebingen.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Naive discriminative learning implements learning and
    classification models based on the Rescorla-Wagner equations and their
    equilibrium equations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.0), MASS, Hmisc</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-09-10 09:06:55 UTC; tino</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Antti Arppe [aut],
  Peter Hendrix [aut],
  Petar Milin [aut],
  R. Harald Baayen [aut],
  Tino Sering [aut, cre],
  Cyrus Shaoul [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-09-10 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ndl-package'>
Naive Discriminative Learning
</h2><span id='topic+ndl-package'></span><span id='topic+ndl'></span>

<h3>Description</h3>

<p>Naive discriminative learning implements learning and
classification models based on the Rescorla-Wagner equations and their
equilibrium equations.
</p>
<p>Naive discriminative learning implements classification models based
on the Rescorla-Wagner equations and the equilibrium equations of
the Rescorla-Wagner equations.  This package provides three kinds of
functionality: (1) discriminative learning based directly on the
Rescorla-Wagner equations, (2) a function implementing the naive
discriminative reader, and a model for silent (single-word) reading,
and (3) a classifier based on the equilibrium equations.  The
functions and datasets for the naive discriminative reader model
make it possible to replicate the simulation results for Experiment
1 of Baayen et al. (2011).  The classifier is provided to allow for
comparisons between machine learning (svm, TiMBL, glm, random
forests, etc.) and discrimination learning.  Compared to standard
classification algorithms, naive discriminative learning may overfit
the data, albeit gracefully.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ndl</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Naive Discriminative Learning</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.2.18</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-09-09</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Antti Arppe", role = "aut", email = "arppe@ualberta.ca"),
    person("Peter Hendrix", role = "aut", email = "peter.hendrix@gmail.com"),
    person("Petar Milin", role = "aut", email = "pmilin@gmail.com"),
    person("R. Harald Baayen", role = "aut", email = "harald.baayen@uni-tuebingen.de"),
    person("Tino Sering", role = c("aut", "cre"), email = "konstantin.sering@uni-tuebingen.de"),
    person("Cyrus Shaoul", role = "aut", email = "cyrus@cyrus.org"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Tino Sering &lt;konstantin.sering@uni-tuebingen.de&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Naive discriminative learning implements learning and
    classification models based on the Rescorla-Wagner equations and their
    equilibrium equations.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.0.2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 0.11.0), MASS, Hmisc</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> 2015-11-10 10:28:58 UTC; kfs-studium</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 6.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Antti Arppe [aut],
  Peter Hendrix [aut],
  Petar Milin [aut],
  R. Harald Baayen [aut],
  Tino Sering [aut, cre],
  Cyrus Shaoul [aut]</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
RescorlaWagner          Implementation of the Rescorla-Wagner
                        equations.
acts2probs              Calculate probability matrix from activation
                        matrix, as well as predicted values
anova.ndlClassify       Analysis of Model Fit for Naive Discriminatory
                        Reader Models
crosstableStatistics    Calculate statistics for a contingency table
cueCoding               code a vector of cues as n-grams
danks                   Example data from Danks (2003), after Spellman
                        (1996).
dative                  Dative Alternation
estimateActivations     Estimation of the activations of outcomes
                        (meanings)
estimateWeights         Estimation of the association weights using the
                        equilibrium equations of Danks (2003) for the
                        Rescorla-Wagner equations.
estimateWeightsCompact
                        Estimation of the association weights using the
                        equilibrium equations of Danks (2003) for the
                        Rescorla-Wagner equations using a compact
                        binary event file.
learn                   Count cue-outcome co-occurences needed to run
                        the Danks equations.
learnLegacy             Count cue-outcome co-occurrences needed to run
                        the Danks equations.
lexample                Lexical example data illustrating the
                        Rescorla-Wagner equations
modelStatistics         Calculate a range of goodness of fit measures
                        for an object fitted with some multivariate
                        statistical method that yields probability
                        estimates for outcomes.
ndl-package             Naive Discriminative Learning
ndlClassify             Classification using naive discriminative
                        learning.
ndlCrossvalidate        Crossvalidation of a Naive Discriminative
                        Learning model.
ndlCuesOutcomes         Creation of dataframe for Naive Discriminative
                        Learning from formula specification
ndlStatistics           Calculate goodness of fit statistics for a
                        naive discriminative learning model.
ndlVarimp               Permutation variable importance for
                        classification using naive discriminative
                        learning.
numbers                 Example data illustrating the Rescorla-Wagner
                        equations as applied to numerical cognition by
                        Ramscar et al. (2011).
orthoCoding             Code a character string (written word form) as
                        letter n-grams
plot.RescorlaWagner     Plot function for the output of
                        'RescorlaWagner'.
plot.ndlClassify        Plot function for selected results of
                        'ndlClassify'.
plurals                 Artificial data set used to illustrate the
                        Rescorla-Wagner equations and naive
                        discriminative learning.
predict.ndlClassify     Predict method for ndlClassify objects
random.pseudoinverse    Calculate an approximation of the pseudoinverse
                        of a matrix.
serbian                 Serbian case inflected nouns.
serbianLex              Serbian lexicon with 1187 prime-target pairs.
serbianUniCyr           Serbian case inflected nouns (in Cyrillic
                        Unicode).
serbianUniLat           Serbian case inflected nouns (in Latin-alphabet
                        Unicode).
summary.ndlClassify     A summary of a Naive Discriminatory Learning
                        Model
summary.ndlCrossvalidate
                        A summary of a crossvalidation of a Naive
                        Discriminatory Reader Model
think                   Finnish 'think' verbs.
</pre>
<p>For more detailed information on the core Rescorla-Wagner equations, see
the functions <code><a href="#topic+RescorlaWagner">RescorlaWagner</a></code> and
<code><a href="#topic+plot.RescorlaWagner">plot.RescorlaWagner</a></code>, as well as the data sets
<code><a href="#topic+danks">danks</a></code>, <code><a href="#topic+numbers">numbers</a></code> (data courtesy of Michael
Ramscar), and <code><a href="#topic+lexample">lexample</a></code> (an example discussed in Baayen et
al. 2011).
</p>
<p>The functions for the naive discriminative learning (at the user level)
are <code><a href="#topic+estimateWeights">estimateWeights</a></code> and
<code><a href="#topic+estimateActivations">estimateActivations</a></code>. The relevant data sets are
<code><a href="#topic+serbian">serbian</a></code>, <a href="#topic+serbianUniCyr">serbianUniCyr</a>,<a href="#topic+serbianUniLat">serbianUniLat</a>, and
<code><a href="#topic+serbianLex">serbianLex</a></code>.  The examples for <code><a href="#topic+serbianLex">serbianLex</a></code>
present the full simulation for Experiment 1 of Baayen et al. (2011).
</p>
<p>Key functionality for the user is provided by the functions
<code><a href="#topic+orthoCoding">orthoCoding</a></code>, <code><a href="#topic+estimateWeights">estimateWeights</a></code>, and
<code>estimateActivations</code>.  <code>orthoCoding</code> calculates the letter
n-grams for character strings, to be used as cues.  It is assumed that
meaning or meanings (separated by underscores if there are more then
one) are available as outcomes.  The frequency with which each (unique)
combination of cues and outcomes occurs are required.  For some example
input data sets, see: <code><a href="#topic+danks">danks</a></code>, <code><a href="#topic+plurals">plurals</a></code>,
<code><a href="#topic+serbian">serbian</a></code>, <code><a href="#topic+serbianUniCyr">serbianUniCyr</a></code> and
<code><a href="#topic+serbianUniLat">serbianUniLat</a></code>.
</p>
<p>The function <code><a href="#topic+estimateWeights">estimateWeights</a></code> estimates the association
strengths of cues to outcomes, using the equilibrium equations presented
in Danks (2003).  The function <code><a href="#topic+estimateActivations">estimateActivations</a></code> estimates the
activations of outcomes (meanings) given cues (n-grams).
</p>
<p>The Rcpp-based <code><a href="#topic+learn">learn</a></code> and <code><a href="#topic+learnLegacy">learnLegacy</a></code>
functions use a C++ function to compute the conditional co-occurrence
matrices required in the equilibrium equations. These are internally
used by <code><a href="#topic+estimateWeights">estimateWeights</a></code> and should not be used directly by users
of the package.
</p>
<p>The key function for naive discriminative classification is
<code><a href="#topic+ndlClassify">ndlClassify</a></code>; see data sets <code><a href="#topic+think">think</a></code> and
<code><a href="#topic+dative">dative</a></code> for examples.
</p>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Tino Sering &lt;konstantin.sering@uni-tuebingen.de&gt;
</p>
<p>Author Contributions:
Initial concept by R. Harald Baayen with contributions from Petar Milin
and Peter Hendrix. First R coding done by R. Harald Baayen.
</p>
<p>Initial R package development until version 0.1.6 by Antti
Arppe. Initial documentation by Antti Arppe.  Initial optimizations in
C by Petar Milin and Antti Arppe.
</p>
<p>Classification functionality developed further by Antti Arppe.
</p>
<p>In version 0.2.14 to version 0.2.16, improvements to the NDL algorithm by Petar
Milin and Cyrus Shaoul. In version 0.2.14 to version 0.2.16, improved
performance optimizations (C++ and Rcpp) by Cyrus Shaoul.
</p>
<p>From version 0.2.17 onwards bug fixes and cran compliance by Tino Sering.
</p>


<h3>References</h3>

<p>Baayen, R. H. and Milin, P.  and Filipovic Durdevic, D. and
Hendrix, P. and Marelli, M., An amorphous model for morphological
processing in visual comprehension based on naive discriminative
learning.  Psychological Review, 118, 438-482.
</p>
<p>Baayen, R. H. (2011) Corpus linguistics and naive discriminative
learning.  Brazilian Journal of Applied Linguistics, 11, 295-328.
</p>
<p>Arppe, A. and Baayen, R. H. (in prep.) Statistical classification
and principles of human learning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Rescorla-Wagner
data(lexample)

lexample$Cues &lt;- orthoCoding(lexample$Word, grams=1)
lexample.rw &lt;- RescorlaWagner(lexample, nruns=25, traceCue="h",
   traceOutcome="hand")
plot(lexample.rw)
mtext("h - hand", 3, 1)

data(numbers)

traceCues &lt;- c( "exactly1", "exactly2", "exactly3", "exactly4", "exactly5",
   "exactly6", "exactly7", "exactly10", "exactly15")
traceOutcomes &lt;- c("1", "2", "3", "4", "5", "6", "7", "10", "15")

ylimit &lt;- c(0,1)
par(mfrow=c(3,3), mar=c(4,4,1,1))

for (i in 1:length(traceCues)) {
  numbers.rw &lt;- RescorlaWagner(numbers, nruns=1, traceCue=traceCues[i],
     traceOutcome=traceOutcomes[i])
  plot(numbers.rw, ylimit=ylimit)
  mtext(paste(traceCues[i], " - ", traceOutcomes[i], sep=""), side=3, line=-1,
    cex=0.7)
}
par(mfrow=c(1,1))

# naive discriminative learning (for complete example, see serbianLex)
# This function uses a Unicode dataset.
data(serbianUniCyr)
serbianUniCyr$Cues &lt;- orthoCoding(serbianUniCyr$WordForm, grams=2)
serbianUniCyr$Outcomes &lt;- serbianUniCyr$LemmaCase
sw &lt;- estimateWeights(cuesOutcomes=serbianUniCyr,hasUnicode=T)

desiredItems &lt;- unique(serbianUniCyr["Cues"])
desiredItems$Outcomes=""
activations &lt;- estimateActivations(desiredItems, sw)$activationMatrix
rownames(activations) &lt;- unique(serbianUniCyr[["WordForm"]])

syntax &lt;- c("acc", "dat", "gen", "ins", "loc", "nom", "Pl",  "Sg") 
activations2 &lt;- activations[,!is.element(colnames(activations), syntax)]
head(rownames(activations2),50)
head(colnames(activations2),8)

image(activations2, xlab="word forms", ylab="meanings", xaxt="n", yaxt="n")
mtext(c("yena", "...", "zvuke"), side=1, line=1, at=c(0, 0.5, 1),  adj=c(0,0,1))
mtext(c("yena", "...", "zvuk"), side=2, line=1, at=c(0, 0.5, 1),   adj=c(0,0,1))

# naive discriminative classification
data(think)
think.ndl &lt;- ndlClassify(Lexeme ~ Person + Number + Agent + Patient + Register,
   data=think)
summary(think.ndl)
plot(think.ndl, values="weights", type="hist", panes="multiple")
plot(think.ndl, values="probabilities", type="density")

## End(Not run)
</code></pre>

<hr>
<h2 id='acts2probs'>
Calculate probability matrix from activation matrix, as well as predicted
values
</h2><span id='topic+acts2probs'></span>

<h3>Description</h3>

<p><code>acts2probs</code> takes the activation matrix returned by
<code><a href="#topic+ndlClassify">ndlClassify</a></code> and calculates the matrix of probabilities
for the estimated activation matrix, as well as the predicted values
of the response variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acts2probs(acts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acts2probs_+3A_acts">acts</code></td>
<td>
<p>A matrix of activations (number of observations by number of levels
of the response variable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probabilities in <code>p</code> are obtained by adding the absolute value
of the minimum activation to the activation matrix, and
renorming. The selection rule used to produce <code>predicted</code> is to
choose for each instance in the data the outcome value that has
received the highest probability estimate.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<dl>
<dt><code>p</code></dt><dd><p>a matrix with the probabilities of the levels of
the response variable for each observation.</p>
</dd>
<dt><code>predicted</code></dt><dd><p>a character vector with predicted values.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Harald Baayen and Antti Arppe
</p>


<h3>References</h3>

<p>Arppe, A. and Baayen, R. H. (in prep.). Statistical classification and principles 
of human learning.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+ndlClassify">ndlClassify</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(think)
think.ndl &lt;- ndlClassify(Lexeme ~ Person + Number + Agent + Register, data=think)
pdata &lt;- acts2probs(think.ndl$activationMatrix)
</code></pre>

<hr>
<h2 id='anova.ndlClassify'>Analysis of Model Fit for Naive Discriminatory Reader Models
</h2><span id='topic+anova.ndlClassify'></span><span id='topic+anova.ndlClassifylist'></span>

<h3>Description</h3>

<p>Compute an analysis of individual variable contributions or model
comparisons for one or more Naive Discriminatory Reader model
fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ndlClassify'
anova(object, ..., statistic = "deviance", test = "Chisq")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.ndlClassify_+3A_object">object</code>, <code id="anova.ndlClassify_+3A_...">...</code></td>
<td>

<p>Object(s) of class <code>"ndlClassify"</code>, typically the result of a
call to <code>ndlClassify</code>, or a list of <code>objects</code> for the
<code>ndlClassifylist</code> method.
</p>
</td></tr>
<tr><td><code id="anova.ndlClassify_+3A_statistic">statistic</code></td>
<td>

<p>A character string specifying the statistic describing the fit
that is to be compared, by default <code>deviance</code>, which is
obtained from the object(s).
</p>
</td></tr>
<tr><td><code id="anova.ndlClassify_+3A_test">test</code></td>
<td>

<p>A character string, determining the statistical method by which
the significance of the comparison are done, by default the
Chi-squared test (<code>Chisq</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, comparison of the terms of a single model or multiple
models is only implemented based on the <code>deviance</code>
statistic.
</p>
<p>Specifying a single object gives a sequential analysis of deviance
table for that fit.  That is, the reductions in the residual
deviance as each term of the formula is added in turn are given in
as the rows of a table, plus the residual deviances themselves.
</p>
<p>If more than one object is specified, the table has a row for the
residual degrees of freedom and deviance for each model.  For all
but the first model, the change in degrees of freedom and deviance
is also given. (This only makes statistical sense if the models
are nested.)  It is conventional to list the models from smallest
to largest, but this is up to the user.
</p>
<p>The table will contain test statistics (and P values) comparing
the reduction in deviance for the row to the
residuals.  Only a comparison of models or
contributions of their components by the chi-squared test has
been implemented.
</p>
<p>The comparison between two or more models by <code>anova</code> or
<code>anova.ndlClassifylist</code> will only be valid if they are
fitted to the same dataset. If <code>anova.ndlClassifylist</code>
detects this, it will stop and report an error.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> inheriting from class
<code>"data.frame"</code>.
</p>


<h3>Author(s)</h3>

<p>Antti Arppe
</p>


<h3>References</h3>

<p>Arppe, A. and Baayen, R. H. (in prep.) Statistical classification and
principles of human learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ndlClassify">ndlClassify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(think)
set.seed(314)
think &lt;- think[sample(1:nrow(think),500),]

think.ndl1 &lt;- ndlClassify(Lexeme ~ Agent * Person, data=think)
anova(think.ndl1)

think.ndl2 &lt;- ndlClassify(Lexeme ~ Agent * Person + Patient, data=think)
anova(think.ndl1, think.ndl2)

</code></pre>

<hr>
<h2 id='crosstableStatistics'>
Calculate statistics for a contingency table 
</h2><span id='topic+crosstableStatistics'></span>

<h3>Description</h3>

<p><code>crosstableStatistics</code> takes a contingency table of observed
vs. predicted values for a binary or polytomous response variable as
input, and calculates a range of statistics about prediction
accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosstableStatistics(ctable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crosstableStatistics_+3A_ctable">ctable</code></td>
<td>

<p>A contingency table cross-classifying observed and predicted values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<dl>
<dt><code>accuracy</code></dt><dd><p>Overall prediction accuracy</p>
</dd>
<dt><code>recall.predicted</code></dt><dd><p>Recall of prediction for each outcome value</p>
</dd>
<dt><code>precision.predicted</code></dt><dd><p>Precision of prediction for each outcome value</p>
</dd>
<dt><code>lambda.prediction</code></dt><dd><p>lambda for prediction accuracy (improvement over baseline of always predicting mode)</p>
</dd>
<dt><code>tau.classification</code></dt><dd><p>tau for classification accuracy (improvement over baseline of homogeneous distribution of predicted outcomes)</p>
</dd>
<dt><code>d.lambda.prediction</code></dt><dd><p>d(lambda): used for calculating <code>P(lambda)</code></p>
</dd>
<dt><code>d.tau.classification</code></dt><dd><p>d(tau): used for calculating <code>P(tau)</code></p>
</dd>
<dt><code>p.lambda.prediction</code></dt><dd><p>P(lambda): probability of reaching <code>lambda</code> by chance</p>
</dd>
<dt><code>p.tau.classification</code></dt><dd><p>P(tau): probability of reaching <code>tau</code> by chance</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Antti Arppe and Harald Baayen
</p>


<h3>References</h3>

<p>Arppe, A. 2008. Univariate, bivariate and multivariate methods in
corpus-based lexicography &ndash; a study of synonymy. Publications of
the Department of General Linguistics, University of Helsinki,
No. 44. URN: http://urn.fi/URN:ISBN:978-952-10-5175-3.
</p>
<p>Arppe, A. and Baayen, R. H. (in prep.). Statistical classification
and principles of human learning.
</p>
<p>Menard, Scott (1995). Applied Logistic Regression Analysis. Sage
University Paper Series on Quantitative Applications in the Social
Sciences 07-106. Thousand Oaks: Sage Publications.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+modelStatistics">modelStatistics</a>, <a href="#topic+ndlStatistics">ndlStatistics</a>, <a href="#topic+ndlClassify">ndlClassify</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctable &lt;- matrix(c(30, 10, 5, 60), 2, 2)
crosstableStatistics(ctable)
</code></pre>

<hr>
<h2 id='cueCoding'>
code a vector of cues as n-grams
</h2><span id='topic+cueCoding'></span>

<h3>Description</h3>

<p><code>cueCoding</code> codes a vector of cues into unigrams, bigrams, 
..., n-grams, with unigrams as default. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cueCoding(cues = c("hello", "world"), maxn=1, adjacent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cueCoding_+3A_cues">cues</code></td>
<td>

<p>A  vector of cues (represented by strings) to be recoded as unigrams,
bigrams, ..., ngrams.
</p>
</td></tr>
<tr><td><code id="cueCoding_+3A_maxn">maxn</code></td>
<td>

<p>The longest n-gram to be encoded, by default <code>maxn=1</code>. 
</p>
</td></tr>
<tr><td><code id="cueCoding_+3A_adjacent">adjacent</code></td>
<td>

<p>A logical indicating whether only adjacent bigrams should be
included when <code>maxn=2</code>.  If <code>adjacent=TRUE</code> and
<code>maxn!=2</code>, <code>maxn</code> is forced to 2.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of cue n-grams, one for each word in the input
vector <code>cues</code>. Each n-gram vector lists the constituent unigrams, 
bigrams, etc., separated by underscores.
</p>


<h3>Author(s)</h3>

<p>Antti Arppe and Harald Baayen
</p>


<h3>References</h3>

<p>Arppe, A. and Baayen, R. H. (in prep.). Statistical classification
and principles of human learning.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+ndlClassify">ndlClassify</a>, <a href="#topic+ndlCuesOutcomes">ndlCuesOutcomes</a>,
  <a href="#topic+ndlVarimp">ndlVarimp</a>, <a href="#topic+ndlCrossvalidate">ndlCrossvalidate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cues from the \code{think} data: Person, Number, Register
cues &lt;- c("First", "Plural", "hs95")
cueCoding(cues, maxn=1)
cueCoding(cues, maxn=2)
</code></pre>

<hr>
<h2 id='danks'>
Example data from Danks (2003), after Spellman (1996).
</h2><span id='topic+danks'></span>

<h3>Description</h3>

<p>Data of Spellman (1996) used by Danks (2003) to illustrate the equilibrium 
equations for the Rescorla-Wagner model.  There are two liquids (red
and blue) that are potentially fertilizers, and the
experimental participant is given the rates at which
flowers bloom for the four possible conditions (no
liquid, red liquid, blue liquid, and both liquids). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(danks)</code></pre>


<h3>Format</h3>

<p>A data frame with 8 observations on the following 3 variables.
</p>

<dl>
<dt><code>Cues</code></dt><dd><p>A character vector specifying the cues. The pots in which the flowers are grown, and the color of the fertilizer.  Individual cues are separated by underscores.</p>
</dd>
<dt><code>Outcomes</code></dt><dd><p>A character vector specifying whether plants flowered (y or n).</p>
</dd>
<dt><code>Frequency</code></dt><dd><p>A numeric vector specifying the frequency of flowering.</p>
</dd>
</dl>



<h3>Details</h3>

<p>For details, see Danks (2003: 112).
</p>


<h3>Source</h3>

<p>B. A. Spellman, (1996). Conditionalizing causality. In Shanks, D. R., Holyoak,
K. J., &amp; Medin, D. L. (Eds.), Causal learning: the psychology of learning and
motivation, Vol. 34 (pp. 167-206). San Diego, CA: Academic Press.
</p>


<h3>References</h3>

<p>D. Danks (2003), Equilibria of the Rescorla-Wagner model.  Journal of
Mathematical Psychology 47, 109-121.
</p>
<p>B. A. Spellman, (1996). Conditionalizing causality. In Shanks, D. R., Holyoak,
K. J., &amp; Medin, D. L. (Eds.), Causal learning: the psychology of learning and
motivation, Vol. 34 (pp. 167-206). San Diego, CA: Academic Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(danks)
estimateWeights(cuesOutcomes=danks)
</code></pre>

<hr>
<h2 id='dative'>Dative Alternation</h2><span id='topic+dative'></span>

<h3>Description</h3>

<p>Data describing the realization of the dative as NP or PP in the Switchboard
corpus and the Treebank Wall Street Journal collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dative)</code></pre>


<h3>Format</h3>

<p>A data frame with 3263 observations on the following 15 variables.
</p>

<dl>
<dt><code>Speaker</code></dt><dd><p>a factor coding speaker; available only for the 
subset of spoken English.</p>
</dd>
<dt><code>Modality</code></dt><dd><p>a factor with levels <code>spoken</code>, <code>written</code>.</p>
</dd>
<dt><code>Verb</code></dt><dd><p>a factor with the verbs as levels.</p>
</dd> 
<dt><code>SemanticClass</code></dt><dd><p>a factor with levels 
<code>a</code> (abstract: 'give it some thought'), 
<code>c</code> (communication: 'tell, give me your name'), 
<code>f</code> (future transfer of possession: 'owe, promise'), 
<code>p</code> (prevention of possession: 'cost, deny'), and
<code>t</code> (transfer of possession: 'give an armband, send').</p>
</dd>
<dt><code>LengthOfRecipient</code></dt><dd><p>a numeric vector coding the 
number of words comprising the recipient.</p>
</dd>
<dt><code>AnimacyOfRec</code></dt><dd><p>a factor with levels <code>animate</code> and
<code>inanimate</code> for the animacy of the recipient.</p>
</dd>
<dt><code>DefinOfRec</code></dt><dd><p>a factor with levels <code>definite</code> and
<code>indefinite</code> coding the definiteness of the recipient.</p>
</dd>
<dt><code>PronomOfRec</code></dt><dd><p>a factor with levels <code>nonpronominal</code> and
<code>pronominal</code> coding the pronominality of the recipient.</p>
</dd>
<dt><code>LengthOfTheme</code></dt><dd><p>a numeric vector coding the number of words
comprising the theme.</p>
</dd>
<dt><code>AnimacyOfTheme</code></dt><dd><p>a factor with levels <code>animate</code> and
<code>inanimate</code> coding the animacy of the theme.</p>
</dd>
<dt><code>DefinOfTheme</code></dt><dd><p>a factor with levels <code>definite</code> and
<code>indefinite</code> coding the definiteness of the theme.</p>
</dd>
<dt><code>PronomOfTheme</code></dt><dd><p>a factor with levels <code>nonpronominal</code> and
<code>pronominal</code> coding the pronominality of the theme.</p>
</dd>
<dt><code>RealizationOfRecipient</code></dt><dd><p>a factor with levels <code>NP</code> and
<code>PP</code> coding the realization of the dative.</p>
</dd>
<dt><code>AccessOfRec</code></dt><dd><p>a factor with levels <code>accessible</code>, 
<code>given</code>, and <code>new</code> coding the accessibility of the recipient.</p>
</dd>
<dt><code>AccessOfTheme</code></dt><dd><p>a factor with levels <code>accessible</code>, 
<code>given</code>, and <code>new</code> coding the accessibility of the theme.</p>
</dd>
</dl>



<h3>References</h3>

<p>Bresnan, J., Cueni, A., Nikitina, T. and Baayen, R. H. (2007)
Predicting the dative alternation, in Bouma, G. and Kraemer, I. and
Zwarts, J.  (eds.), <em>Cognitive Foundations of Interpretation</em>,
Royal Netherlands Academy of Sciences, 69-94.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dative)
out &lt;- which(is.element(colnames(dative), c("Speaker","Verb")))
dative &lt;- dative[,-out]
dative.ndl &lt;- ndlClassify(RealizationOfRecipient ~ ., data=dative)
ndlStatistics(dative.ndl)


## End(Not run) </code></pre>

<hr>
<h2 id='estimateActivations'>
Estimation of the activations of outcomes (meanings) 
</h2><span id='topic+estimateActivations'></span>

<h3>Description</h3>

<p><code>estimateActivations</code> is used to estimate the activations for
outcomes (meanings) using the equilibrium association strengths
(weights) for the Rescorla-Wagner model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateActivations(cuesOutcomes, weightMatrix, unique=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateActivations_+3A_cuesoutcomes">cuesOutcomes</code></td>
<td>

<p>A data frame with three variables specifying frequency, cues, and outcomes:
</p>

<dl>
<dt><code>Cues</code></dt><dd><p>A character vector specifying the cues. When there is more than one cue, the cues should be separated by underscores.</p>
</dd>
<dt><code>Outcomes</code></dt><dd><p>A character vector specifying the outcomes.  When there is more than one outcome, the outcomes should be separated by underscores.</p>
</dd>
<dt><code>Frequency</code></dt><dd><p>A numeric vector specifying the frequency with which a combination of cues and outcomes occurs.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="estimateActivations_+3A_weightmatrix">weightMatrix</code></td>
<td>

<p>A numeric matrix with as dimensions the number of cues
(horizontal) and number of outcomes (vertical).  Rows and columns
should be labeled with cues and outcomes.
</p>
</td></tr>
<tr><td><code id="estimateActivations_+3A_unique">unique</code></td>
<td>

<p>A logical that, if <code>=TRUE</code>, removes duplicate rows from the activation matrix.
</p>
</td></tr>
<tr><td><code id="estimateActivations_+3A_...">...</code></td>
<td>

<p>Control arguments to be passed along from
<code><a href="#topic+ndlClassify">ndlClassify</a></code> and/or <code><a href="#topic+ndlCrossvalidate">ndlCrossvalidate</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The activation of an outcome is defined as the sum of the weights on
the incoming links from active cues.  When the input (the <code>Cues</code>
in <code>cuesOutcomes</code>) contain elements that are not present in the
rownames of the <code>weightMatrix</code>, such new cues are added to the
<code>weightMatrix</code> with zero entries. The set of exemplars in
<code>cuesOutcomes</code> may contain rows with identical cue sets but
different outcome sets. Consequently, for such rows, identical vectors
of activations of outcomes are generated.  In the activation matrix
returned by <code>estimateActivations</code>, such duplicate entries are
removed.
</p>
<p>For examples of how the <code>cuesOutcomes</code> data frame should be
structured, see the data sets <code><a href="#topic+danks">danks</a></code>,
<code><a href="#topic+plurals">plurals</a></code>, and <code><a href="#topic+serbian">serbian</a></code>.  For examples of how
the <code>weightMatrix</code> should be structured, see the corresponding
output of <code><a href="#topic+estimateWeights">estimateWeights</a></code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<dl>
<dt><code>activationMatrix</code></dt><dd><p>A matrix with as dimensions, for rows, the number of exemplars
(by-row cue sets, typically word forms), and for columns, the number
of unique outcomes (meanings), specifying the activation of a
meaning given the cues in the input for a given exemplar.</p>
</dd>
<dt><code>newCues</code></dt><dd><p>A vector of cues encountered in <code>cuesOutcomes</code> which were not
present in <code>weightMatrix</code>.</p>
</dd>
<dt>...</dt><dd>
<p>Control arguments to be passed along from <code><a href="#topic+ndlClassify">ndlClassify</a></code>,
and/or <code><a href="#topic+ndlCrossvalidate">ndlCrossvalidate</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>R. H. Baayen &amp; Antti Arppe
</p>


<h3>References</h3>

<p>Baayen, R. H. and Milin, P.  and Filipovic Durdevic, D. and Hendrix,
P. and Marelli, M., An amorphous model for morphological processing in
visual comprehension based on naive discriminative learning.
Psychological Review, 118, 438-482.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateWeights">estimateWeights</a>, <a href="#topic+danks">danks</a>, <a href="#topic+plurals">plurals</a>, <a href="#topic+serbian">serbian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(serbian)
  serbian$Cues &lt;- orthoCoding(serbian$WordForm, grams=2)
  serbian$Outcomes &lt;- serbian$LemmaCase
  sw &lt;- estimateWeights(cuesOutcomes=serbian)
  sw[1:5,1:6]
  activations &lt;- estimateActivations(unique(serbian["Cues"]), sw)$activationMatrix
  rownames(activations) &lt;- unique(serbian[["WordForm"]])
  activations[1:5,1:6]

  syntax &lt;- c("acc", "dat", "gen", "ins", "loc", "nom", "Pl", "Sg") 
  activations2 &lt;- activations[,!is.element(colnames(activations),syntax)]
  head(rownames(activations2), 50)
  head(colnames(activations2), 8)
  image(activations2, xlab="word forms", ylab="meanings", xaxt="n", yaxt="n")
  mtext(c("yena", "...", "zvuke"), side=1, line=1, at=c(0, 0.5, 1), adj=c(0,0,1))
  mtext(c("yena", "...", "zvuk"), side=2, line=1, at=c(0, 0.5, 1), adj=c(0,0,1))
</code></pre>

<hr>
<h2 id='estimateWeights'>
Estimation of the association weights using the equilibrium
equations of Danks (2003) for the Rescorla-Wagner equations.
</h2><span id='topic+estimateWeights'></span>

<h3>Description</h3>

<p>A function to estimate the weights (associative strengths) for
cue-outcome pairs when learning is in equilibrium, using the
equilibrium equations for the Rescorla-Wagner model of Danks (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateWeights(cuesOutcomes, removeDuplicates=TRUE, saveCounts=FALSE,
verbose=FALSE, trueCondProb=TRUE, addBackground=FALSE, hasUnicode=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateWeights_+3A_cuesoutcomes">cuesOutcomes</code></td>
<td>

<p>A data frame with three variables specifying frequency, cues, and
outcomes, that may be created with <code><a href="#topic+ndlCuesOutcomes">ndlCuesOutcomes</a></code> or
with the accessory script in the inst/scripts directory:
</p>

<dl>
<dt><code>Cues</code></dt><dd><p>A character vector specifying the cues. 
When there is more than one cue, the cues should be 
separated by underscores.</p>
</dd>
<dt><code>Outcomes</code></dt><dd><p>A character vector specifying the outcomes.  
When there is more than one outcome, the outcomes should 
be separated by underscores.</p>
</dd>
<dt><code>Frequency</code></dt><dd><p>A numeric vector specifying the frequency 
with which a combination of cues and outcomes occurs.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="estimateWeights_+3A_removeduplicates">removeDuplicates</code></td>
<td>

<p>A logical specifying whether multiple occurrences of a Cue in
conjunction with an individual instance of an Outcome shall each
be counted as a distinct occurrence of that Cue (<code>FALSE</code>: default), or
only as a single occurrence (<code>TRUE</code>).
</p>
</td></tr>
<tr><td><code id="estimateWeights_+3A_savecounts">saveCounts</code></td>
<td>

<p>A logical specifying whether the co-occurrence matrices should be
saved.  If set equal to <code>TRUE</code>, the files <code>coocCues.rda</code> and
<code>coocCuesOutcomes.rda</code> will be saved in the current
working directory.
</p>
</td></tr>
<tr><td><code id="estimateWeights_+3A_verbose">verbose</code></td>
<td>

<p>If set to <code>TRUE</code>, display diagnostic messages.
</p>
</td></tr>
<tr><td><code id="estimateWeights_+3A_addbackground">addBackground</code></td>
<td>

<p>If you would like to add a background rate for all your cues and
outcomes, but did not include an general environment cue to all your
events, one will be added for you to the matrices, as
specified in Danks (2003). If changed from the default (FALSE) to
TRUE, background cues will be added. The name used for the background rates is &quot;Environ&quot;, and
will be included in the output weight matrix.
</p>
</td></tr>
<tr><td><code id="estimateWeights_+3A_truecondprob">trueCondProb</code></td>
<td>

<p>The conditional probability calculations used will be those
specified in Danks (2003). If changed from the default (TRUE) to
FALSE, the normalization specified in Baayen, et al (2011) is used.
</p>
</td></tr>
<tr><td><code id="estimateWeights_+3A_hasunicode">hasUnicode</code></td>
<td>

<p>A logical specifying whether to apply a UTF-8 to integer conversion
to the names of the cues. This was implemented to solve issues with
differences Unicode cue names. 
</p>
</td></tr>
<tr><td><code id="estimateWeights_+3A_...">...</code></td>
<td>
<p>Control arguments to be passed along from <code><a href="#topic+ndlClassify">ndlClassify</a></code>
and/or <code><a href="#topic+ndlCrossvalidate">ndlCrossvalidate</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using Rcpp, a C++ based implementation processes all of the data in
RAM. The module will check the amount of RAM you have available in
your system and warn you if the amount of RAM is insufficient
to build your model.
</p>
<p>For examples of how the <code>cuesOutcomes</code> data frame should be
structured, see the data sets <code><a href="#topic+danks">danks</a></code>,
<code><a href="#topic+plurals">plurals</a></code>, and <code><a href="#topic+serbian">serbian</a></code>. N.B. Empty
<code>Cues</code> or <code>Outcomes</code> (effectively having <code>length =
  0</code>), e.g. <code>Cues</code> or <code>Outcomes</code> strings with an initial or
final underscore or two immediately adjacent underscores, will
result in an error.
</p>


<h3>Value</h3>

<p>A matrix with cue-to-outcome association strengths. Rows are cues,
and columns are outcomes.  Rows and columns are labeled. If
addBackground=T, a row named &quot;Environ&quot; will be added to the output.
</p>


<h3>Acknowledgements</h3>

<p>The assistance of Uwe Ligges in getting the C function <code>cooc</code>
to work within the R framework is greatly appreciated. This C function
was removed in version 0.2.0 and replaced with the C++ function by
Cyrus Shaoul.
</p>


<h3>Note</h3>

<p>Add a note here.
</p>


<h3>Author(s)</h3>

<p>Cyrus Shaoul, R. H. Baayen and Petar Milin, with contributions from Antti Arppe and
Peter Hendrix.
</p>


<h3>References</h3>

<p>Baayen, R. H. and Milin, P.  and Filipovic Durdevic, D. and Hendrix,
P. and Marelli, M. (2011), An amorphous model for morphological processing in
visual comprehension based on naive discriminative learning.
Psychological Review, 118, 438-482.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateActivations">estimateActivations</a>, <a href="#topic+ndlCuesOutcomes">ndlCuesOutcomes</a>,
   <a href="#topic+danks">danks</a>, <a href="#topic+plurals">plurals</a>, <a href="#topic+serbian">serbian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(danks)
  estimateWeights(cuesOutcomes=danks)

  data(plurals)
  plurals$Cues &lt;- orthoCoding(plurals$WordForm, grams=1)
  round(estimateWeights(cuesOutcomes=plurals),2)
  
  data(serbian)
  serbian$Cues &lt;- orthoCoding(serbian$WordForm, grams=2)
  serbian$Outcomes &lt;- serbian$LemmaCase
  sw &lt;- estimateWeights(cuesOutcomes=serbian)
  round(sw[1:5,1:6],2)
</code></pre>

<hr>
<h2 id='estimateWeightsCompact'>
Estimation of the association weights using the equilibrium
equations of Danks (2003) for the Rescorla-Wagner equations using
a compact binary event file.
</h2><span id='topic+estimateWeightsCompact'></span>

<h3>Description</h3>

<p>A function to estimate the weights (associative strengths) for
cue-outcome pairs when learning is in equilibrium, using the
equilibrium equations for the Rescorla-Wagner model of Danks (2003) using
a compact binary event file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateWeightsCompact(datasource, removeDuplicates=TRUE,
saveCounts=FALSE, verbose=FALSE, MaxEvents=100000000000000,
trueCondProb=TRUE, addBackground=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateWeightsCompact_+3A_datasource">datasource</code></td>
<td>

<p>A data source that is linked with a file naming convention. If the
datasource is the string &quot;source&quot;, then the following resources will
need to exist in the current working directory:
</p>

<dl>
<dt><code>source.events</code></dt><dd><p>A directory that contains binary event
files in the format specified in learn.module.cpp</p>
</dd>
<dt><code>source.cues</code></dt><dd><p>A text file that contains the full list of
cues in the first column, and separated by a tab, the CueID for
each cue. Must be encoded in UTF8.</p>
</dd>
<dt><code>source.outcomes</code></dt><dd><p>A text file that contains the full list of
outcomes in the first column, and separated by a tab, the OutcomeID for
each outcome. Must be encoded in UTF8.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="estimateWeightsCompact_+3A_removeduplicates">removeDuplicates</code></td>
<td>

<p>A logical specifying whether multiple occurrences of a Cue in
conjunction with an Outcome shall each
be counted as a distinct occurrence of that Cue (<code>FALSE</code>), or
only as a single occurrence (<code>TRUE</code>: default).
</p>
</td></tr>
<tr><td><code id="estimateWeightsCompact_+3A_savecounts">saveCounts</code></td>
<td>

<p>A logical specifying whether the co-occurrence matrices should be
saved.  If set equal to <code>TRUE</code>, the files <code>coocCues.rda</code> and
<code>coocCuesOutcomes.rda</code> will be saved in the current
workspace. Default is FALSE.
</p>
</td></tr>
<tr><td><code id="estimateWeightsCompact_+3A_verbose">verbose</code></td>
<td>

<p>If set to <code>TRUE</code>, display diagnostic messages.
</p>
</td></tr>
<tr><td><code id="estimateWeightsCompact_+3A_maxevents">MaxEvents</code></td>
<td>

<p>If changed from the default value, the learning algorithm will stop
learning after using the first N events in the training data. This
actually number of events used may be slightly higher than the
number specified.
</p>
</td></tr>
<tr><td><code id="estimateWeightsCompact_+3A_addbackground">addBackground</code></td>
<td>

<p>If you would like to add a background rate for all your cues and
outcomes, but did not include an general environment cue to all your
events, one will be added for you to the matrices, as
specified in Danks (2003). If changed from the default (FALSE) to
TRUE, background cues will be added. The name used for the background rates is &quot;Environ&quot;, and
will be included in the output weight matrix.
</p>
</td></tr>
<tr><td><code id="estimateWeightsCompact_+3A_truecondprob">trueCondProb</code></td>
<td>

<p>The conditional probability calculations used will be those
specified in Danks (2003). If changed from the default (TRUE) to
FALSE, the normalization specified in Baayen, et al (2011) is used.
</p>
</td></tr>
<tr><td><code id="estimateWeightsCompact_+3A_...">...</code></td>
<td>
<p>Control arguments to be passed along from <code><a href="#topic+ndlClassify">ndlClassify</a></code>
and/or <code><a href="#topic+ndlCrossvalidate">ndlCrossvalidate</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using Rcpp, a C++ based implementation processes all of the data
RAM. The module will check the amount of RAM you have available in
your system and warn you of RAM is insufficient
to build your model.
</p>


<h3>Value</h3>

<p>A matrix with cue-to-outcome association strengths. Rows are cues,
and columns are outcomes.  Rows and columns are labeled. If
addBackground=T, a row named &quot;Environ&quot; will be added to the output.
</p>


<h3>Acknowledgements</h3>

<p>Thanks to all the beta testers of the ndl package.
</p>


<h3>Note</h3>

<p>Add a note here.
</p>


<h3>Author(s)</h3>

<p>Cyrus Shaoul, R. H. Baayen and Petar Milin, with contributions from Antti Arppe and
Peter Hendrix.
</p>


<h3>References</h3>

<p>Baayen, R. H. and Milin, P.  and Filipovic Durdevic, D. and Hendrix,
P. and Marelli, M., (2011) An amorphous model for morphological processing in
visual comprehension based on naive discriminative learning.
Psychological Review, 118, 438-482.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateActivations">estimateActivations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  message("This module requires data in a non-portable format to
demonstrate how it works.")
</code></pre>

<hr>
<h2 id='learn'>
Count cue-outcome co-occurences needed to run the Danks equations.
</h2><span id='topic+learn'></span>

<h3>Description</h3>

<p>An internal function to count cue-outcome co-occurrences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learn(data,RemoveDuplicates,verbose,MaxEvents,addBackground)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learn_+3A_data">data</code></td>
<td>

<p>A directory where the binary event data files are located.
</p>
</td></tr>
<tr><td><code id="learn_+3A_removeduplicates">RemoveDuplicates</code></td>
<td>

<p>A logical specifying whether multiple occurrences of a Cue in
conjunction with an Outcome shall each
be counted as a distinct occurrence of that Cue (<code>FALSE</code>), or
only as a single occurrence (<code>TRUE</code>: default).
</p>
</td></tr>
<tr><td><code id="learn_+3A_verbose">verbose</code></td>
<td>

<p>Display diagnostic messages or not.
</p>
</td></tr>     
<tr><td><code id="learn_+3A_maxevents">MaxEvents</code></td>
<td>

<p>The total number of events to learn from before stopping
learning. Checked one time per compact data file.
</p>
</td></tr>     
<tr><td><code id="learn_+3A_addbackground">addBackground</code></td>
<td>

<p>Option to add background rates.
</p>
</td></tr>     
</table>


<h3>Details</h3>

<p>This function calls an Rcpp function of the same name to process the
data in the compact data format.
</p>


<h3>Value</h3>

<p>A list of two matrices with cue-cue coocurrences and cue-outcome
cooccurrences and a vector with background rates.
</p>


<h3>Acknowledgements</h3>

<p>Thanks to all the testers!
</p>


<h3>Note</h3>

<p>No temporary files are used.
</p>


<h3>Author(s)</h3>

<p>Cyrus Shaoul
</p>


<h3>References</h3>

<p>Baayen, R. H. and Milin, P.  and Filipovic Durdevic, D. and Hendrix,
P. and Marelli, M., An amorphous model for morphological processing in
visual comprehension based on naive discriminative learning.
Psychological Review, 118, 438-482.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateActivations">estimateActivations</a>, <a href="#topic+ndlCuesOutcomes">ndlCuesOutcomes</a>,
    <a href="#topic+estimateWeightsCompact">estimateWeightsCompact</a>,
  <a href="#topic+danks">danks</a>, <a href="#topic+plurals">plurals</a>, <a href="#topic+serbian">serbian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#None (internal function)
</code></pre>

<hr>
<h2 id='learnLegacy'>
Count cue-outcome co-occurrences needed to run the Danks equations.
</h2><span id='topic+learnLegacy'></span>

<h3>Description</h3>

<p>An internal function to count cue-outcome co-occurrences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learnLegacy(DFin,RemoveDuplicates,verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learnLegacy_+3A_dfin">DFin</code></td>
<td>

<p>A dataframe, as defined in the documentation for <a href="#topic+estimateWeights">estimateWeights</a>.
</p>
</td></tr>
<tr><td><code id="learnLegacy_+3A_removeduplicates">RemoveDuplicates</code></td>
<td>

<p>A logical specifying whether multiple occurrences of a Cue in
conjunction with an Outcome shall each
be counted as a distinct occurrence of that Cue (<code>FALSE</code>), or
only as a single occurrence (<code>TRUE</code>: default).
</p>
</td></tr>
<tr><td><code id="learnLegacy_+3A_verbose">verbose</code></td>
<td>

<p>Display diagnostic messages or not.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls an Rcpp function of the same name to process the
data in the DFin data frame.
</p>


<h3>Value</h3>

<p>A list of two matrices with cue-cue co-occurrences and cue-outcome
co-occurrences.
</p>


<h3>Acknowledgements</h3>

<p>Thanks to all the testers out there! Martijn, you know who you are.
</p>


<h3>Note</h3>

<p>No temporary files are used.
</p>


<h3>Author(s)</h3>

<p>Cyrus Shaoul
</p>


<h3>References</h3>

<p>Baayen, R. H. and Milin, P.  and Filipovic Durdevic, D. and Hendrix,
P. and Marelli, M., An amorphous model for morphological processing in
visual comprehension based on naive discriminative learning.
Psychological Review, 118, 438-482.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateActivations">estimateActivations</a>, <a href="#topic+ndlCuesOutcomes">ndlCuesOutcomes</a>,
    <a href="#topic+estimateWeights">estimateWeights</a>,
  <a href="#topic+danks">danks</a>, <a href="#topic+plurals">plurals</a>, <a href="#topic+serbian">serbian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#None (internal function)
</code></pre>

<hr>
<h2 id='lexample'>
Lexical example data illustrating the Rescorla-Wagner equations  
</h2><span id='topic+lexample'></span>

<h3>Description</h3>

<p>Ten monomorphemic and inflected English words with fictive frequencies,
and meanings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lexample)</code></pre>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 3 variables:
</p>

<dl>
<dt><code>Word</code></dt><dd><p>A character vector specifying word forms</p>
</dd>
<dt><code>Frequency</code></dt><dd><p>A numeric vector with the &ndash; fictive &ndash;
frequencies of occurrence of the words</p>
</dd>
<dt><code>Outcomes</code></dt><dd><p>A character vector specifying the meaning 
components of the words, separated by underscores</p>
</dd>
</dl>



<h3>Details</h3>

<p>This example lexicon is used in Baayen et al. (2011) (table 8, figure 4)
to illustrate the Rescorla-Wagner equations.
</p>


<h3>References</h3>

<p>Baayen, R. H., Milin, P., Filipovic Durdevic, D., Hendrix, P. and
Marelli, M.  (2011), An amorphous model for morphological processing
in visual comprehension based on naive discriminative
learning. Psychological Review, 118, 438-482.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RescorlaWagner">RescorlaWagner</a>, <a href="#topic+orthoCoding">orthoCoding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(lexample)
lexample$Cues &lt;- orthoCoding(lexample$Word, grams=1)
par(mfrow=c(2,2))
lexample.rw &lt;- RescorlaWagner(lexample, nruns=25, traceCue="h",traceOutcome="hand")
plot(lexample.rw)
mtext("h - hand", 3, 1)

lexample.rw &lt;- RescorlaWagner(lexample, nruns=25, traceCue="s",traceOutcome="plural")
plot(lexample.rw)
mtext("s - plural", 3, 1)

lexample.rw &lt;- RescorlaWagner(lexample, nruns=25, traceCue="a",traceOutcome="as")
plot(lexample.rw)
mtext("a - as", 3, 1)

lexample.rw &lt;- RescorlaWagner(lexample, nruns=25, traceCue="s",traceOutcome="as")
plot(lexample.rw)
mtext("s - as", 3, 1)
par(mfrow=c(1,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='modelStatistics'>
Calculate a range of goodness of fit measures for an object fitted with some multivariate statistical method that yields probability estimates for outcomes.
</h2><span id='topic+modelStatistics'></span>

<h3>Description</h3>

<p><code>modelStatistics</code> calculates a range of goodness of fit
measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  modelStatistics(observed, predicted, frequency=NA, p.values,
     n.data, n.predictors, outcomes=levels(as.factor(observed)),
     p.normalize=TRUE, cross.tabulation=TRUE, 
     p.zero.correction=1/(NROW(p.values)*NCOL(p.values))^2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelStatistics_+3A_observed">observed</code></td>
<td>
<p>observed values of the response variable</p>
</td></tr>
<tr><td><code id="modelStatistics_+3A_predicted">predicted</code></td>
<td>
<p>predicted values of the response variable; typically the outcome estimated to have the highest probability</p>
</td></tr>
<tr><td><code id="modelStatistics_+3A_frequency">frequency</code></td>
<td>
<p>frequencies of observed and predicted values; if <code>NA</code>, frequencies equal to 1 for all observed and predicted values</p>
</td></tr>
<tr><td><code id="modelStatistics_+3A_p.values">p.values</code></td>
<td>
<p>matrix of probabilities for all values of the response variable (i.e outcomes)</p>
</td></tr>
<tr><td><code id="modelStatistics_+3A_n.data">n.data</code></td>
<td>
<p>sum frequency of data points in model</p>
</td></tr>
<tr><td><code id="modelStatistics_+3A_n.predictors">n.predictors</code></td>
<td>
<p>number of predictor levels in model</p>
</td></tr>
<tr><td><code id="modelStatistics_+3A_outcomes">outcomes</code></td>
<td>
<p>a vector with the possible values of the response variable</p>
</td></tr>
<tr><td><code id="modelStatistics_+3A_p.normalize">p.normalize</code></td>
<td>
<p>if <code>TRUE</code>, probabilities are normalized so that <code>sum(P)</code> of all outcomes for each datapoint is equal to 1</p>
</td></tr>
<tr><td><code id="modelStatistics_+3A_cross.tabulation">cross.tabulation</code></td>
<td>
<p>if <code>TRUE</code>, statistics on the crosstabulation of observed and predicted response values are calculated with <code>crosstableStatistics</code></p>
</td></tr>
<tr><td><code id="modelStatistics_+3A_p.zero.correction">p.zero.correction</code></td>
<td>
<p>a function to adjust slightly response/outcome-specific probability estimates which are exactly P=0; necessary for the proper calculation of pseudo-R-squared statistics; by default calculated on the basis of the dimensions of the matrix of probabilities <code>p.values</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A list with the following components: </p>

<dl>
<dt><code>loglikelihood.null</code></dt><dd><p>Loglikelihood for null model</p>
</dd>
<dt><code>loglikelihood.model</code></dt><dd><p>Loglikelihood for fitted model</p>
</dd>
<dt><code>deviance.null</code></dt><dd><p>Null deviance</p>
</dd>
<dt><code>deviance.model</code></dt><dd><p>Model deviance</p>
</dd>
<dt><code>R2.likelihood</code></dt><dd><p>(McFadden's) R-squared</p>
</dd>
<dt><code>R2.nagelkerke</code></dt><dd><p>Nagelkerke's R-squared</p>
</dd>
<dt><code>AIC.model</code></dt><dd><p>Akaike's Information Criterion</p>
</dd>
<dt><code>BIC.model</code></dt><dd><p>Bayesian Information Criterion</p>
</dd>
<dt><code>C</code></dt><dd><p>index of concordance C (for binary response variables only)</p>
</dd>
<dt><code>crosstable</code></dt><dd><p>Crosstabulation of observed and predicted
outcomes, if <code>cross.tabulation=TRUE</code></p>
</dd>
<dt><code>crosstableStatistics(crosstable)</code></dt><dd><p>Various statistics
calculated on <code>crosstable</code> with <code>crosstableStatistics</code>, if
<code>cross.tabulation=TRUE</code></p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Antti Arppe and Harald Baayen
</p>


<h3>References</h3>

<p>Arppe, A. 2008. Univariate, bivariate and multivariate methods in
corpus-based lexicography &ndash; a study of synonymy. Publications of the
Department of General Linguistics, University of Helsinki,
No. 44. URN: http://urn.fi/URN:ISBN:978-952-10-5175-3.
</p>
<p>Arppe, A., and Baayen, R. H. (in prep.) Statistical modeling and the
principles of human learning.
</p>
<p>Hosmer, David W., Jr., and Stanley Lemeshow 2000. Applied Regression Analysis 
(2nd edition). New York: Wiley.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+ndlClassify">ndlClassify</a></code>, <code><a href="#topic+ndlStatistics">ndlStatistics</a></code>, <code><a href="#topic+crosstableStatistics">crosstableStatistics</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(think)
think.ndl &lt;- ndlClassify(Lexeme ~ Agent + Patient, data=think)
probs &lt;- acts2probs(think.ndl$activationMatrix)$p
preds &lt;- acts2probs(think.ndl$activationMatrix)$predicted
n.data &lt;- nrow(think)
n.predictors &lt;- nrow(think.ndl$weightMatrix) *
   ncol(think.ndl$weightMatrix)
modelStatistics(observed=think$Lexeme, predicted=preds, p.values=probs,
   n.data=n.data, n.predictors=n.predictors)
</code></pre>

<hr>
<h2 id='ndlClassify'>
Classification using naive discriminative learning.
</h2><span id='topic+ndlClassify'></span><span id='topic+print.ndlClassify'></span>

<h3>Description</h3>

<p><code>ndlClassify</code> uses the equilibrium equations of Danks (2003)
for the Rescorla-Wagner model (1972) to estimate association
strengths (weights) for cues (typically levels of factorial
predictors) to outcomes (typically a binary or polytomous response
variable).  Given the association strengths, the probability of a
response level is obtained by summation over the weights on active
incoming links.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndlClassify(formula, data, frequency=NA, variable.value.separator="", ...)

## S3 method for class 'ndlClassify'
print(x, max.print=10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndlClassify_+3A_formula">formula</code></td>
<td>

<p>An object of class <code>formula</code> (or one that can be coerced to
that class): a symbolic description of the model to be fitted.  
</p>
</td></tr>
<tr><td><code id="ndlClassify_+3A_data">data</code></td>
<td>
 
<p>A data frame containing the variables in the model.  
</p>
</td></tr>
<tr><td><code id="ndlClassify_+3A_frequency">frequency</code></td>
<td>
 
<p>A numeric vector (or the name of a column in the input data frame)
with the frequencies of the exemplars.  If absent, each exemplar
is assigned a frequency equal to 1.
</p>
</td></tr>
<tr><td><code id="ndlClassify_+3A_x">x</code></td>
<td>

<p>An object of the class <code>"ndlClassify"</code> fitted with <code>ndlClassify</code>
to be printed with <code>print.ndlClassify</code>.
</p>
</td></tr>
<tr><td><code id="ndlClassify_+3A_max.print">max.print</code></td>
<td>

<p>The maximum number of rows of the <code>weightMatrix</code> to be output
when printing with <code>print.ndlClassify</code>; by default equal to
10; if set to <code>NA</code> all rows will be output.
</p>
</td></tr>
<tr><td><code id="ndlClassify_+3A_variable.value.separator">variable.value.separator</code></td>
<td>
 
<p>A character string which will separate variable names from
variable values in their combination as cue values; by default an
empty character string (<code>=""</code>). 
</p>
</td></tr>
<tr><td><code id="ndlClassify_+3A_...">...</code></td>
<td>
 
<p>Control arguments to be passed along to
<code><a href="#topic+ndlCuesOutcomes">ndlCuesOutcomes</a></code>, <code><a href="#topic+estimateWeights">estimateWeights</a></code>,
<code><a href="#topic+estimateActivations">estimateActivations</a></code>, and/or <code><a href="#topic+print.ndlClassify">print.ndlClassify</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Classification by naive discriminative learning.
</p>


<h3>Value</h3>

<p>A list of the class <code>"ndlClassify"</code> with the following components:
</p>

<dl>
<dt><code>activationMatrix</code></dt><dd><p>A matrix specifying for each row of the
input data frame the activations (probabilities) of the levels of the
response variable  (<code>nrow</code> observations by <code>nlevels</code> of response variable).</p>
</dd>
<dt><code>weightMatrix</code></dt><dd><p> A matrix specifying for each cue (predictor value)
the association strength (weight) to each outcome (level of the response
variable)  (number of distinct predictor values by number of response levels).</p>
</dd>
<dt><code>cuesOutcomes</code></dt><dd><p> The input data structure for naive
discriminative learning created by <code>ndlCuesOutcomes</code> based on
the <code>data</code> argument (number of observations by 3: <code>Frequency,
   Cues, Outcomes</code>).</p>
</dd>
<dt><code>call</code></dt><dd><p>The call matched to fit the resulting <code>"ndlClassify"</code> object.</p>
</dd>
<dt><code>formula</code></dt><dd><p>The formula specified for fitting the
resulting <code>"ndlClassify"</code> object.</p>
</dd>
<dt><code>data</code></dt><dd><p>The supplied <code>data</code> argument, excluding all
elements not specified for the modeling task in <code>formula</code> and
<code>frequency</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>R. H. Baayen and Antti Arppe
</p>


<h3>References</h3>

<p>Baayen, R. H. and Milin, P.  and Filipovic Durdevic, D. and Hendrix,
P. and Marelli, M., An amorphous model for morphological processing in
visual comprehension based on naive discriminative learning.
Psychological Review, 118, 438-482.
</p>
<p>Danks, D. (2003). Equilibria of the Rescorla-Wagner model. Journal of
Mathematical Psychology, 47 (2), 109-121.
</p>
<p>Rescorla, R. A., &amp; Wagner, A. R. (1972). A theory of Pavlovian
conditioning: Variations in the effectiveness of reinforcement and
nonreinforcement. In Black, A. H., &amp; Prokasy, W. F. (Eds.),
Classical conditioning II: Current research and theory (pp. 64-99).
New York: Appleton-Century-Crofts.
</p>
<p>Arppe, A. and Baayen, R. H. (in prep.) Statistical classification and
principles of human learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ndlClassify">summary.ndlClassify</a>, <a href="#topic+plot.ndlClassify">plot.ndlClassify</a>, <a href="#topic+anova.ndlClassify">anova.ndlClassify</a>, <a href="#topic+predict.ndlClassify">predict.ndlClassify</a>, <a href="#topic+ndlCuesOutcomes">ndlCuesOutcomes</a>, <a href="#topic+estimateWeights">estimateWeights</a>, <a href="#topic+cueCoding">cueCoding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(think)
set.seed(314)
think &lt;- think[sample(1:nrow(think),500),]
think.ndl &lt;- ndlClassify(Lexeme ~ (Person * Number * Agent) + Register,
   data=think)
summary(think.ndl)

## Not run: 
think.ndl.SA &lt;- ndlClassify(Lexeme ~ (Polarity + Voice + Mood + Person +
  Number + Covert + ClauseEquivalent + Agent + Patient + Manner + Time +
  Modality1 + Modality2 + Source + Goal + Quantity + Location +
  Duration + Frequency + MetaComment + ReasonPurpose + Condition +
  CoordinatedVerb)^2 + Author + Section, data=think)
summary(think.ndl.SA)

## End(Not run)

## Not run: 
data(dative)
out &lt;- which(is.element(colnames(dative), c("Speaker","Verb")))
dative &lt;- dative[-out]
dative.ndl &lt;- ndlClassify(RealizationOfRecipient ~ ., data=dative)
summary(dative.ndl)


## End(Not run)
</code></pre>

<hr>
<h2 id='ndlCrossvalidate'>
Crossvalidation of a Naive Discriminative Learning model.
</h2><span id='topic+ndlCrossvalidate'></span>

<h3>Description</h3>

<p><code>ndlCrossvalidate</code> undertakes a crossvalidation of a Naive
Discriminative Learning model fitted using <code>ndlClassify</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndlCrossvalidate(formula, data, frequency=NA, k=10, folds=NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndlCrossvalidate_+3A_formula">formula</code></td>
<td>

<p>An object of class <code>formula</code> (or one that can be coerced to
that class): a symbolic description of the model to be fitted. If
alternatively set to <code>=NA</code>, the <code>data</code> argument is
expected to be in the <code>ndl</code> internal format as generated by
<code><a href="#topic+ndlCuesOutcomes">ndlCuesOutcomes</a></code>, and <code>ndlCrossvalidate</code> will
check that this is the case.
</p>
</td></tr>
<tr><td><code id="ndlCrossvalidate_+3A_data">data</code></td>
<td>
 
<p>A data frame (as in <code>ndlClassify</code>) containing the variables
in the <code>formula</code> specifying the model.
</p>
</td></tr>
<tr><td><code id="ndlCrossvalidate_+3A_frequency">frequency</code></td>
<td>
 
<p>A numeric vector (or the name of a column in the input data frame)
with the frequencies of the exemplars.  If absent, each exemplar
is assigned a frequency equal to 1.
</p>
</td></tr>
<tr><td><code id="ndlCrossvalidate_+3A_k">k</code></td>
<td>

<p>The number of folds, by default equal to 10.
</p>
</td></tr>
<tr><td><code id="ndlCrossvalidate_+3A_folds">folds</code></td>
<td>

<p>A list of user-defined folds, each item on the list representing a
vector of indices indicating lines in the data frame to be used
for testing a model fitted with the rest of the data. By default
<code>NULL</code>, so that the folds are determined with random
selection by the function <code>ndlCrossvalidate</code>.
</p>
</td></tr>
<tr><td><code id="ndlCrossvalidate_+3A_...">...</code></td>
<td>

<p>Control arguments to be passed along to auxiliary functions, in specific
<code><a href="#topic+estimateWeights">estimateWeights</a></code> and/or <code><a href="#topic+estimateActivations">estimateActivations</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Crossvalidation of a Naive Discriminative Learning model.
</p>


<h3>Value</h3>

<p>A list of the class <code>"ndlCrossvalidate"</code> with the following components:
</p>

<dl>
<dt><code>call</code></dt><dd><p>The call matched by <code>ndlCrossvalidate</code></p>
</dd>
<dt><code>formula</code></dt><dd><p>The formula specified for <code>ndlCrossvalidate</code></p>
</dd>
<dt><code>fits</code></dt><dd><p>A list of individual fits resulting from <code>ndlCrossvalidate</code></p>
</dd>
<dt><code>k</code></dt><dd><p>The number of folds, by default equal to 10</p>
</dd>
<dt><code>n.total</code></dt><dd><p>The sum frequency of data points</p>
</dd>
<dt><code>n.train</code></dt><dd><p>The size of the training set</p>
</dd>
<dt><code>n.test</code></dt><dd><p>The size of of the testing set</p>
</dd>
<dt><code>folds</code></dt><dd><p>A list with the folds used in the crossvalidation;
either selected at random by <code>ndlCrossvalidate</code> or provided by
the user.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Antti Arppe
</p>


<h3>References</h3>

<p>Baayen, R. H. and Milin, P.  and Filipovic Durdevic, D. and Hendrix,
P. and Marelli, M., An amorphous model for morphological processing in
visual comprehension based on naive discriminative learning.
Psychological Review, 118, 438-482.
</p>
<p>Arppe, A. and Baayen, R. H. (in prep.). Statistical modeling and the
principles of human learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ndlCrossvalidate">summary.ndlCrossvalidate</a>, <a href="#topic+ndlStatistics">ndlStatistics</a>, <a href="#topic+ndlCuesOutcomes">ndlCuesOutcomes</a>,
   <a href="#topic+cueCoding">cueCoding</a>, <a href="#topic+estimateWeights">estimateWeights</a>, <a href="#topic+estimateActivations">estimateActivations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(think)
set.seed(314)
think &lt;- think[sample(1:nrow(think),500),]
think.cv5 &lt;- ndlCrossvalidate(Lexeme ~ Agent + Patient, data=think, k=5)
summary(think.cv5)
rm(think)

## Not run: 
data(think)
think.cv10 &lt;- ndlCrossvalidate(Lexeme ~ Person + Number + Agent + Patient + Register,
   data=think, k=10)
summary(think.cv10)

## End(Not run)
## Not run: 
library(languageR)
data(finalDevoicing)
finDev.cv10 &lt;- ndlCrossvalidate(Voice ~ Onset1Type + Onset2Type + VowelType *
   ConsonantType * Obstruent + Nsyll + Stress, data=finalDevoicing, k=10)
summary(finDev.cv10)


## End(Not run)

</code></pre>

<hr>
<h2 id='ndlCuesOutcomes'>Creation of dataframe for Naive Discriminative Learning from formula specification
</h2><span id='topic+ndlCuesOutcomes'></span>

<h3>Description</h3>

<p><code>ndlCuesOutcomes</code> creates a dataframe for fitting a naive
discriminative classification model with <code>ndlClassify</code>, using
the specified formula and provided data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndlCuesOutcomes(formula, data, frequency=NA, 
  numeric2discrete=function(x) Hmisc::cut2(x,g=g.numeric), g.numeric=2,
  check.values=TRUE, ignore.absent=NULL, variable.value.separator="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndlCuesOutcomes_+3A_formula">formula</code></td>
<td>

<p>An object of class <code>formula</code> (or one that can be coerced to
that class): a symbolic description of the model to be fitted.  
</p>
</td></tr>
<tr><td><code id="ndlCuesOutcomes_+3A_data">data</code></td>
<td>
 
<p>A data frame containing the variables in the model.  
</p>
</td></tr>
<tr><td><code id="ndlCuesOutcomes_+3A_frequency">frequency</code></td>
<td>
 
<p>A numeric vector (or the name of a column in the input data frame)
with the frequencies of the exemplars. If absent, each exemplar is
assigned a frequency equal to 1.
</p>
</td></tr>
<tr><td><code id="ndlCuesOutcomes_+3A_numeric2discrete">numeric2discrete</code></td>
<td>

<p>A function to transform a continuous numeric predictor into a
number of discrete classes, by default <code>cut2</code> from the
<code>Hmisc</code> package. If set to NULL, each value of each
numeric predictor will be treated as a discrete class of its own.
</p>
</td></tr>
<tr><td><code id="ndlCuesOutcomes_+3A_g.numeric">g.numeric</code></td>
<td>

<p>A parameter to be passed to the <code>numeric2discrete</code> function
(parameter <code>g</code> for <code>Hmisc::cut2(..., g=g.numeric, ...)</code>,
or a user-defined function), determining the desired number of
discrete categories for each numeric predictor; by default equal
to 2.
</p>
</td></tr>
<tr><td><code id="ndlCuesOutcomes_+3A_check.values">check.values</code></td>
<td>

<p>A logical specifying whether underscores &lsquo;_&rsquo; in predictor
values should substituted with periods &lsquo;.&rsquo;; if <code>=FALSE</code>,
the predictor values will be only checked and an error message will
result if any underscores are discovered.
</p>
</td></tr>
<tr><td><code id="ndlCuesOutcomes_+3A_ignore.absent">ignore.absent</code></td>
<td>

<p>A character vector specifying one or more values for any predictor
(e.g. <code>NIL</code>, <code>None</code> and/or <code>Other</code>) which may be
considered truely <code>absent</code> cues in terms of the
Rescorla-Wagner equations; by default set to <code>NULL</code> so that
all values of all predictors will be treated as <code>present</code>
cues.
</p>
</td></tr>
<tr><td><code id="ndlCuesOutcomes_+3A_variable.value.separator">variable.value.separator</code></td>
<td>
 
<p>A character string which will separate variable names from
variable values in their combination as cue values; by default an
empty character string (<code>=""</code>).
</p>
</td></tr>
<tr><td><code id="ndlCuesOutcomes_+3A_...">...</code></td>
<td>

<p>Control arguments to be passed along to <code>estimateWeights</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a dataframe to be used for fitting a Naive Discriminatory
Learning classifier model.
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>

<dl>
<dt><code>Frequency</code></dt><dd><p>Frequency with which the specific Cues and Outcomes co-occur.</p>
</dd>
<dt><code>Cues</code></dt><dd><p>A character vector of sets of Cues per instance, with Cues separated by underscore &lsquo;_&rsquo;.</p>
</dd>
<dt><code>Outcomes</code></dt><dd><p>A character vector of Outcomes per instance.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>R. H. Baayen and Antti Arppe
</p>


<h3>References</h3>

<p>Arppe, A. and Baayen, R. H. (in prep.) Statistical modeling and the
principles of human learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cueCoding">cueCoding</a>, <a href="#topic+ndlClassify">ndlClassify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(think)
set.seed(314)
think &lt;- think[sample(1:nrow(think),500),]
think.CuesOutcomes &lt;- ndlCuesOutcomes(Lexeme ~ (Person * Number * Agent) + Register, 
data=think)
head(think.CuesOutcomes)

## Not run: 
data(dative)
dative.cuesOutcomes &lt;- ndlCuesOutcomes(RealizationOfRecipient ~ LengthOfRecipient +
   LengthOfTheme, data=dative, numeric2discrete=NULL)
table(dative.cuesOutcomes$Cues)

dative.cuesOutcomes1 &lt;- ndlCuesOutcomes(RealizationOfRecipient ~ LengthOfRecipient +
   LengthOfTheme, data=dative)
table(dative.cuesOutcomes1$Cues)

dative.cuesOutcomes2 &lt;- ndlCuesOutcomes(RealizationOfRecipient ~ LengthOfRecipient +
   LengthOfTheme, data=dative, g.numeric=3)
table(dative.cuesOutcomes2$Cues)


## End(Not run)
</code></pre>

<hr>
<h2 id='ndlStatistics'>
Calculate goodness of fit statistics for a naive discriminative
learning model.
</h2><span id='topic+ndlStatistics'></span>

<h3>Description</h3>

<p><code>ndlStatistics</code> takes an Naive Discriminary Learning model
object as generated by <code><a href="#topic+ndlClassify">ndlClassify</a></code> and calculates a
range of goodness of fit statistics using
<code><a href="#topic+modelStatistics">modelStatistics</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndlStatistics(ndl, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndlStatistics_+3A_ndl">ndl</code></td>
<td>

<p>A naive discriminative learning model fitted with <code><a href="#topic+ndlClassify">ndlClassify</a></code>.
</p>
</td></tr>
<tr><td><code id="ndlStatistics_+3A_...">...</code></td>
<td>

<p>Control arguments to be passed along to <code>modelStatistics</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<dl>
<dt><code>n.data</code></dt><dd><p>sum frequency of data points</p>
</dd>
<dt><code>df.null</code></dt><dd><p>degrees of freedom of the Null model</p>
</dd>
<dt><code>df.model</code></dt><dd><p>degrees of freedom of the fitted model</p>
</dd>
<dt><code>statistics</code></dt><dd><p>a list of various measures of goodness of fit calculated with <code>modelStatistics</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Antti Arppe and Harald Baayen
</p>


<h3>References</h3>

<p>Arppe, A. and Baayen, R. H. (in prep.) Statistical modeling and the
principles of human learning.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+ndlClassify">ndlClassify</a></code>, <code><a href="#topic+modelStatistics">modelStatistics</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(think)
set.seed(314)
think &lt;- think[sample(1:nrow(think),500),]
think.ndl &lt;- ndlClassify(Lexeme ~ Agent + Patient, data=think)
ndlStatistics(think.ndl)

## Not run: 
data(dative)
dative.ndl &lt;- ndlClassify(RealizationOfRecipient ~ AnimacyOfRec + DefinOfRec +
   PronomOfRec + AnimacyOfTheme + DefinOfTheme + PronomOfTheme, data=dative)
ndlStatistics(dative.ndl)

## End(Not run)
</code></pre>

<hr>
<h2 id='ndlVarimp'>
Permutation variable importance for classification using naive discriminative learning.
</h2><span id='topic+ndlVarimp'></span>

<h3>Description</h3>

<p><code>ndlVarimp</code> uses permutation variable importance for naive
discriminative classification models, typically the output of
<code>ndlClassify</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndlVarimp(object, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndlVarimp_+3A_object">object</code></td>
<td>

<p>An object of class <code>"ndlClassify"</code> (or one that can be
coerced to that class); typically a model object as produced by
<code><a href="#topic+ndlClassify">ndlClassify</a></code>.
</p>
</td></tr>
<tr><td><code id="ndlVarimp_+3A_verbose">verbose</code></td>
<td>
 
<p>A logical (default TRUE) specifying whether the successive predictors
being evaluated should be echoed to stdout.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variable importance is assessed using predictor permutation.
Currently, conditional permutation variable importance (as for <code>varimp</code>
for random forests in the <code>party</code> package) is not implemented.
</p>


<h3>Value</h3>

<p>A list with two numeric vectors:
</p>

<dl>
<dt><code>concordance</code></dt><dd><p>For binary response variables, a named vector
specifying for each predictor the index of concordance when that predictor
is permuted.  For polytomous response variables, NA.</p>
</dd>
<dt><code>accuracy</code></dt><dd><p> A named vector specifying for each predictor
the accuracy of the model with that predictor permuted.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>R. H. Baayen and Antti Arppe
</p>


<h3>References</h3>

<p>R. Harald Baayen (2011).  Corpus linguistics and naive 
discriminative learning.  Brazilian journal of applied 
linguistics, 11, 295-328.
</p>
<p>Carolin Strobl, Anne-Laure Boulesteix, Thomas Kneib, Thomas
Augustin and Achim Zeileis (2008).  Conditional Variable
Importance for Random Forests. BMC Bioinformatics, 9, 307.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ndlClassify">summary.ndlClassify</a>, <a href="#topic+plot.ndlClassify">plot.ndlClassify</a>, <a href="#topic+anova.ndlClassify">anova.ndlClassify</a>, <a href="#topic+ndlCuesOutcomes">ndlCuesOutcomes</a>, <a href="#topic+estimateWeights">estimateWeights</a>, <a href="#topic+cueCoding">cueCoding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dative)
dative &lt;- dative[!is.na(dative$Speaker),-2]
dative.ndl &lt;- ndlClassify(RealizationOfRecipient ~ ., data=dative)
dative.varimp &lt;- ndlVarimp(dative.ndl)

library(lattice)
dotplot(sort(summary(dative.ndl)$statistics$accuracy-dative.varimp$accuracy), 
   xlab="permutation variable importance")

## End(Not run)
</code></pre>

<hr>
<h2 id='numbers'>
Example data illustrating the Rescorla-Wagner equations as applied 
to numerical cognition by Ramscar et al. (2011).
</h2><span id='topic+numbers'></span>

<h3>Description</h3>

<p>The data used in simulation 3 of Ramscar et al. (2011) on numerical
cognition.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lexample)</code></pre>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 3 variables.
</p>

<dl>
<dt><code>Cues</code></dt><dd><p>A character vector specifying cues for
quantities, separated by underscores.</p>
</dd>
<dt><code>Frequency</code></dt><dd><p>The frequencies with which the numbers
appear in the COCA corpus.</p>
</dd>
<dt><code>Outcomes</code></dt><dd><p>A character vector specifying numerical
outcomes associated with the input quantities.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The cues represent learning trials with objects of the same size,
shape and color. The numeric cues represent the presence of at
least one subset of the specified size.  The cues <code>exactlyn</code> 
represent the presence of exactly <code>n</code> objects. We are indebted 
to Michael Ramscar to making this data set available for inclusion 
in the package.
</p>


<h3>References</h3>

<p>Michael Ramscar, Melody Dye, Hanna Muenke Popick &amp; Fiona O'Donnell-McCarthy
(2011), The Right Words or Les Mots Justes?  Why Changing the Way We Speak to
Children Can Help Them Learn Numbers Faster.  Manuscript,  Department of
Psychology, Stanford University.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(numbers)

traceCues=c( "exactly1", "exactly2", "exactly3", "exactly4",
"exactly5", "exactly6", "exactly7", "exactly10", "exactly15")
traceOutcomes=c("1", "2", "3", "4", "5", "6", "7", "10", "15")

ylimit=c(0,1)
par(mfrow=c(3,3),mar=c(4,4,1,1))

for (i in 1:length(traceCues)){
  numbers.rw = RescorlaWagner(numbers, nruns=1,
    traceCue=traceCues[i],traceOutcome=traceOutcomes[i])
  plot(numbers.rw, ylimit=ylimit)
  mtext(paste(traceCues[i], " - ", traceOutcomes[i], sep=""), 
    side=3, line=-1, cex=0.7)
}
par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='orthoCoding'>
Code a character string (written word form) as letter n-grams
</h2><span id='topic+orthoCoding'></span>

<h3>Description</h3>

<p><code>orthoCoding</code> codes a character string into unigrams, bigrams, 
..., n-grams, with as default bigrams as the substring size. If
tokenization is not at the letter/character level, a token separator
can be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthoCoding(strings=c("hel.lo","wor.ld"), grams = c(2), tokenized = F, sepToken = '.') 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthoCoding_+3A_strings">strings</code></td>
<td>

<p>A character vector of strings (usually words) to be recoded as
n-grams.
</p>
</td></tr>
<tr><td><code id="orthoCoding_+3A_grams">grams</code></td>
<td>

<p>A vector of numbers, each one a size of ngram to be produced. For
example a vector like grams=c(1,3) will create the unigram and trigram
cues from the input. 
</p>
</td></tr>
<tr><td><code id="orthoCoding_+3A_tokenized">tokenized</code></td>
<td>

<p>If tokenzied is FALSE (the default), the input strings are split
into letters/characters. If it is set to TRUE, the strings will be split
up based on the value of sepToken.
</p>
</td></tr>
<tr><td><code id="orthoCoding_+3A_septoken">sepToken</code></td>
<td>

<p>A string that defines which character will be used to separate tokens
when tokenized is TRUE. Defaults to the &quot;.&quot; character.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of grams (joined by underscores), one for each word in the input
vector <cite>words</cite>.
</p>


<h3>Author(s)</h3>

<p>Cyrus Shaoul, Peter Hendrix and Harald Baayen
</p>


<h3>References</h3>

<p>Baayen, R. H. and Milin, P.  and Filipovic Durdevic, D. and Hendrix,
P. and Marelli, M., An amorphous model for morphological processing in
visual comprehension based on naive discriminative learning.
Psychological Review, 118, 438-482.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+estimateWeights">estimateWeights</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Default
orthoCoding(tokenize=FALSE)
#With tokenizing on a specific character
orthoCoding(tokenize=TRUE)

#Comparing different n-gram sizes
data(serbian) 
serbian$Cues=orthoCoding(serbian$WordForm, grams=2)
head(serbian$Cues)
serbian$Cues=orthoCoding(serbian$WordForm, grams=c(2,4))
head(serbian$Cues)
</code></pre>

<hr>
<h2 id='plot.ndlClassify'>
Plot function for selected results of <code>ndlClassify</code>.
</h2><span id='topic+plot.ndlClassify'></span><span id='topic+plot.ndlWeights'></span><span id='topic+plot.ndlProbabilities'></span>

<h3>Description</h3>

<p>This function presents visually the estimated weights or expected
probabilities for a model fitted with <code>ndlClassify</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ndlClassify'
plot(x, values="weights", ...)

## S3 method for class 'ndlWeights'
plot(x, type="density", predictors=NULL, outcomes=NULL,
panes="single", lty=NULL, col=NULL, mfrow=NULL, main=NULL,
legend.position="topright", ...)

## S3 method for class 'ndlProbabilities'
plot(x, type="density", select="all",
panes="single", lty=NULL, col=NULL, pch=NULL, mfrow=NULL,
main=NULL, legend.position="topright", ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ndlClassify_+3A_x">x</code></td>
<td>

<p>A object of the class <code>"ndlClassify"</code> produced by
<code>ndlClassify</code>, consisting of a list including estimated
weights for predictors and association strengths for
outcome-predictor combinations.
</p>
</td></tr>
<tr><td><code id="plot.ndlClassify_+3A_values">values</code></td>
<td>

<p>A character string specifiying whether estimated <code>weights</code>
(default) or expected <code>probabilities</code> should be plotted.
</p>
</td></tr>
<tr><td><code id="plot.ndlClassify_+3A_type">type</code></td>
<td>
 
<p>A character string spefifying the type of plot to be drawn;
<code>density</code> is available for both value types as default,
while a histogram (<code>hist</code>) is available only for
<code>plot.ndlWeights</code> and sorted values (<code>sort</code>) only for
<code>plot.ndlProbabilities</code>.
</p>
</td></tr>
<tr><td><code id="plot.ndlClassify_+3A_panes">panes</code></td>
<td>

<p>A character string specifying whether a <code>single</code> pane
(default) integrating all component plots, or <code>multiple</code>
panes for each individual component plot are to be plotted. If
<code>multiple</code> panes are selected, the number or rows and
columns is specified automatically. Alternatively, one can invoke
the plotting of multiple panes by explicitly specifying the
appropriate number of rows and columns with the parameter
<code>mfrow</code> (N.B. this overrides <code>panes="single"</code>).
</p>
</td></tr>
<tr><td><code id="plot.ndlClassify_+3A_predictors">predictors</code></td>
<td>
 
<p>A regular expression specifying which predictors and their values
should be included in the plot(s); by default <code>=NULL</code> so that
all predictors incorporated in the <code>ndlClassify</code> model will
be included.
</p>
</td></tr>
<tr><td><code id="plot.ndlClassify_+3A_outcomes">outcomes</code></td>
<td>

<p>A list of outcomes to be included in the plot; by default <code>=NULL</code> so that all
outcomes will be considered.
</p>
</td></tr>
<tr><td><code id="plot.ndlClassify_+3A_select">select</code></td>
<td>

<p>For <code>plot.ndlProbabilities</code>, a character string specifying
which instance-wise probability estimates should be plotted; by
default <code>all</code>, other values are <code>max</code> for instance-wise
maximum probabilities, <code>min</code> for instance-wise minimum
probabilities, <code>maxmin, minmax</code> for both maximum and minimum
instance-wise probabilities. Alternatively, a numeric vector
<code>c(1,2,...)</code> specifying selected ranks of the instance-wise
probability estimates can be provided, with <code>1</code> corresponding
to the instance-wise maximum probability estimates.
</p>
</td></tr>
<tr><td><code id="plot.ndlClassify_+3A_lty">lty</code>, <code id="plot.ndlClassify_+3A_col">col</code>, <code id="plot.ndlClassify_+3A_pch">pch</code>, <code id="plot.ndlClassify_+3A_mfrow">mfrow</code>, <code id="plot.ndlClassify_+3A_main">main</code>, <code id="plot.ndlClassify_+3A_legend.position">legend.position</code></td>
<td>

<p>Specifications of various graphical parameters (see
<code><a href="graphics.html#topic+par">par</a></code>) to be used in the plots; if any of these is set
to <code>=NULL</code> default settings will be used (for
<code>legend.position</code>, the default value is <code>topright</code>). Note that
<code>lty</code> is relevant only to <code>plot.ndlWeights(...,
    type="density", ...)</code> and <code>plot.ndlProbabilities(...,
    type="density", ...)</code>, and <code>pch</code> only to
<code>plot.ndlProbabilities(..., type="sort", ...)</code>.
</p>
</td></tr>
<tr><td><code id="plot.ndlClassify_+3A_...">...</code></td>
<td>
 
<p>Arguments to be passed to methods, such as graphical
parameters (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the selected type is produced on the graphics device.
</p>


<h3>Author(s)</h3>

<p>Antti Arppe and R. H. Baayen
</p>


<h3>References</h3>

<p>Arppe, A. and Baayen, R. H. (in prep.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ndlClassify">ndlClassify</a></code>, <code><a href="#topic+acts2probs">acts2probs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(think)
think.ndl &lt;- ndlClassify(Lexeme ~ Agent + Patient + Section, data=think)

plot(think.ndl, values="weights")
plot(think.ndl, values="weights", type="hist", panes="multiple")
plot(think.ndl, values="weights", type="density", panes="multiple")
plot(think.ndl, values="weights", type="density", panes="multiple",
   predictors="Section*")
plot(think.ndl, values="weights", type="density", panes="multiple",
   predictors="Patient*")
plot(think.ndl, values="weights", type="hist", panes="multiple", col=1:4)
plot(think.ndl, values="weights", type="density", panes="single",
   outcomes=c("ajatella","miettia","pohtia","harkita"))

plot(think.ndl, values="probabilities")
plot(think.ndl, values="probabilities", panes="multiple")
plot(think.ndl, values="probabilities", select="max")
plot(think.ndl, values="probabilities", select=c(1:3))
plot(think.ndl, values="probabilities", panes="multiple", select=c(1:3))
plot(think.ndl, values="probabilities", type="sort", legend.position="topleft")
plot(think.ndl, values="probabilities", type="sort", pch=".",
   legend.position="topleft")
plot(think.ndl, values="probabilities", type="sort", pch=".", panes="multiple")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.RescorlaWagner'>
Plot function for the output of <code>RescorlaWagner</code>.
</h2><span id='topic+plot.RescorlaWagner'></span>

<h3>Description</h3>

<p>This function graphs the Rescorla-Wagner weights for a cue-outcome pair
against learning time. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RescorlaWagner'
plot(x, asymptote=TRUE, xlab="t", ylab="weight", ylimit=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.RescorlaWagner_+3A_x">x</code></td>
<td>

<p>A object of the class <code>"RescorlaWagner"</code> produced by
<code>RescorlaWagner</code>, consisting of a list including estimated
weights for the incremental and equilibrium stages.
</p>
</td></tr>
<tr><td><code id="plot.RescorlaWagner_+3A_asymptote">asymptote</code></td>
<td>
 
<p>A logical specifying whether the equilibrium asymptotic 
weight should be added to the plot.
</p>
</td></tr>
<tr><td><code id="plot.RescorlaWagner_+3A_xlab">xlab</code></td>
<td>
 
<p>Label for x-axis, by default <code>"t"</code>.
</p>
</td></tr>
<tr><td><code id="plot.RescorlaWagner_+3A_ylab">ylab</code></td>
<td>
 
<p>Label for y-axis, by default <code>"weight"</code>.
</p>
</td></tr>
<tr><td><code id="plot.RescorlaWagner_+3A_ylimit">ylimit</code></td>
<td>
 
<p>The range of values to be displayed on the Y axis. By default,
this will be determined from the data itself.
</p>
</td></tr>
<tr><td><code id="plot.RescorlaWagner_+3A_...">...</code></td>
<td>
 
<p>Arguments to be passed to methods, such as graphical
parameters (see <code>link{par}</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is produced on the graphics device.
</p>


<h3>Author(s)</h3>

<p>R. H. Baayen and Antti Arppe
</p>


<h3>References</h3>

<p>Danks, D. (2003). Equilibria of the Rescorla-Wagner model. Journal of
Mathematical Psychology, 47 (2), 109-121.
</p>
<p>Rescorla, R. A., &amp; Wagner, A. R. (1972). A theory of Pavlovian
conditioning: Variations in the effectiveness of reinforcement and
nonreinforcement. In Black, A. H., &amp; Prokasy, W. F. (Eds.),
Classical conditioning II: Current research and theory (pp. 64-99).
New York: Appleton-Century-Crofts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RescorlaWagner">RescorlaWagner</a></code>, <code><a href="#topic+orthoCoding">orthoCoding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lexample)
lexample$Cues &lt;- orthoCoding(lexample$Word, grams=1)
lexample.rw &lt;- RescorlaWagner(lexample, nruns=25, 
   traceCue="h", traceOutcome="hand")
plot(lexample.rw)
mtext("h - hand", 3, 1)

# Full example

## Not run: 
par(mfrow=c(2,2))
lexample.rw &lt;- RescorlaWagner(lexample, nruns=25, 
   traceCue="h", traceOutcome="hand")
plot(lexample.rw)
mtext("h - hand", 3, 1)

lexample.rw &lt;- RescorlaWagner(lexample, nruns=25, 
   traceCue="s", traceOutcome="plural")
plot(lexample.rw)
mtext("s - plural", 3, 1)

lexample.rw &lt;- RescorlaWagner(lexample, nruns=25, 
   traceCue="a", traceOutcome="as")
plot(lexample.rw)
mtext("a - as", 3, 1)

lexample.rw &lt;- RescorlaWagner(lexample, nruns=25, 
   traceCue="s", traceOutcome="as")
plot(lexample.rw)
mtext("s - as", 3, 1)
par(mfrow=c(1,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='plurals'>
Artificial data set used to illustrate the Rescorla-Wagner equations 
and naive discriminative learning.
</h2><span id='topic+plurals'></span>

<h3>Description</h3>

<p>Data set with 10 English words of different (ad hoc) frequencies, each
with a lexical meaning and a grammatical meaning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(plurals)</code></pre>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 3 variables:
</p>

<dl>
<dt><code>WordForm</code></dt><dd><p>A character vector of word forms (cues).</p>
</dd>
<dt><code>Frequency</code></dt><dd><p>A numeric vector of frequencies.</p>
</dd>
<dt><code>Outcomes</code></dt><dd><p>A character vector of meanings (outcomes).
Meanings are separated by underscores.  The <code>NIL</code> meaning is ignored.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Baayen, R. H. and Milin, P.  and Filipovic Durdevic, D. and Hendrix,
P. and Marelli, M., An amorphous model for morphological processing in
visual comprehension based on naive discriminative learning.
Psychological Review, 118, 438-482.
</p>


<h3>References</h3>

<p>Baayen, R. H. and Milin, P.  and Filipovic Durdevic, D. and Hendrix,
P. and Marelli, M., An amorphous model for morphological processing in
visual comprehension based on naive discriminative learning.
Psychological Review, 118, 438-482.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(plurals)
plurals$Cues &lt;- orthoCoding(plurals$WordForm, grams=1)
estimateWeights(cuesOutcomes=plurals)
</code></pre>

<hr>
<h2 id='predict.ndlClassify'>
Predict method for ndlClassify objects
</h2><span id='topic+predict.ndlClassify'></span>

<h3>Description</h3>

<p>Obtains predictions on the basis of a fitted <code>"ndlClassify"</code>
object on data already incorporated in the object or on new
data with the same predictors as the originally fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ndlClassify'
predict(object, newdata=NULL, frequency=NA,
   type="choice", ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ndlClassify_+3A_object">object</code></td>
<td>

<p>objects of class <code>"ndlClassify"</code>, typically the result of a
call to <code>ndlClassify</code>.
</p>
</td></tr>
<tr><td><code id="predict.ndlClassify_+3A_newdata">newdata</code></td>
<td>

<p>optionally, a data frame in which to look for variables with
which to predict.  If omitted (i.e. set to <code>NULL</code>), the
original data used to fit the <code>object</code> are used.
</p>
</td></tr>
<tr><td><code id="predict.ndlClassify_+3A_frequency">frequency</code></td>
<td>
 
<p>A numeric vector (or the name of a column in the (new) data frame
<code>newdata</code>) with the frequencies of the exemplars. If absent,
each exemplar is assigned a frequency equal to 1.
</p>
</td></tr>
<tr><td><code id="predict.ndlClassify_+3A_type">type</code></td>
<td>

<p>the type of prediction requested.  The default option
<code>type="choice"</code> produces the predicted individual discrete
choices (i.e. Outcomes), given the predictor Cues selected for
fitting the original <code>object</code>. The option <code>type="acts"</code>
provides the sum activations for each Outcome given the Cue
combinations in <code>newdata</code> (or in the original data in
<code>object</code>, while the alternative <code>type="probs"</code> yields
the distributions of predicted probabilities (based on the
activations) over the Outcome responses.
</p>
</td></tr>
<tr><td><code id="predict.ndlClassify_+3A_...">...</code></td>
<td>

<p>further arguments passed to and from other functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata</code> is omitted the predictions are based on the data
used for the fit.
</p>


<h3>Value</h3>

<p>a vector <code>predicted</code>, or matrix of activations
<code>activations</code>, or a matrix of predictions
<code>probabilities</code>.
</p>


<h3>Author(s)</h3>

<p>Antti Arppe
</p>


<h3>References</h3>

<p>Arppe, A. and Baayen, R. H. (in prep.) Statistical classification and
principles of human learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ndlClassify">ndlClassify</a></code>, <code><a href="#topic+estimateActivations">estimateActivations</a></code>, <code><a href="#topic+acts2probs">acts2probs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(think)
think.ndl &lt;- ndlClassify(Lexeme ~ Agent + Patient, data=think[1:300,])
head(predict(think.ndl, type="choice"))
predict(think.ndl, newdata=think[301:320,], type="probs")
predict(think.ndl, newdata=think[301:320,], type="acts")

</code></pre>

<hr>
<h2 id='random.pseudoinverse'>
Calculate an approximation of the pseudoinverse of a matrix.
</h2><span id='topic+random.pseudoinverse'></span>

<h3>Description</h3>

<p>An internal function that uses an approximation of the SVD using the
first k singular values of A to calculate the pseudo-inverse. Only
used when the cue-cue matrix contains more than 20,000 cues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.pseudoinverse(m, verbose=F, k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.pseudoinverse_+3A_m">m</code></td>
<td>

<p>A matrix.
</p>
</td></tr>
<tr><td><code id="random.pseudoinverse_+3A_k">k</code></td>
<td>

<p>If k = 0, the default, k will be set to the size of 3/4 of the
singular values. If not, the k-rank approximation will be calculated.
</p>
</td></tr>
<tr><td><code id="random.pseudoinverse_+3A_verbose">verbose</code></td>
<td>

<p>Display diagnostic messages or not.
</p>
</td></tr>     
</table>


<h3>Details</h3>

<p>This idea was proposed by Gunnar Martinsson
Associate Professor and Director of Graduate Studies
Department of Applied Mathematics, University of Colorado at Boulder
http://amath.colorado.edu/faculty/martinss/
And with ideas from:
Yoel Shkolnisky and his Out-of-Core SVD code:
https://sites.google.com/site/yoelshkolnisky/software
</p>


<h3>Value</h3>

<p>The approximate pseudoinverse of the input matrix
</p>


<h3>Acknowledgements</h3>

<p>Thanks to Gunnar for his help with this!
</p>


<h3>Note</h3>

<p>No temporary files are used.
</p>


<h3>Author(s)</h3>

<p>Cyrus Shaoul
</p>


<h3>References</h3>

<p>&quot;Finding structure with randomness: Probabilistic algorithms for
constructing approximate matrix decompositions&quot;
Nathan Halko, Per-Gunnar Martinsson, Joel A. Tropp
http://arxiv.org/abs/0909.4061
</p>


<h3>See Also</h3>

<p><a href="#topic+estimateWeights">estimateWeights</a>,  <a href="#topic+estimateWeightsCompact">estimateWeightsCompact</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#None (internal function)
</code></pre>

<hr>
<h2 id='RescorlaWagner'>
Implementation of the Rescorla-Wagner equations.
</h2><span id='topic+RescorlaWagner'></span>

<h3>Description</h3>

<p><code>RescorlaWagner</code> implements an iterative simulation based on the Rescorla-Wagner equations. Given a data frame specifying cues, outcomes, and frequencies, it calculates, for a given cue-outcome pair,
the temporal sequence of developing weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RescorlaWagner(cuesOutcomes, traceCue="h", traceOutcome="hand",
   nruns=1, random=TRUE, randomOrder = NA, alpha=0.1, lambda=1,
   beta1=0.1, beta2=0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RescorlaWagner_+3A_cuesoutcomes">cuesOutcomes</code></td>
<td>

<p>A data frame specifying cues, outcomes, and frequencies of combinations of cues and outcomes.
In the data frame, cues and outcomes should be character vectors.
</p>
</td></tr>
<tr><td><code id="RescorlaWagner_+3A_tracecue">traceCue</code></td>
<td>
 
<p>A character string specifying the cue to be traced over time.
</p>
</td></tr>
<tr><td><code id="RescorlaWagner_+3A_traceoutcome">traceOutcome</code></td>
<td>
 
<p>A character string specifying the outcome to be traced over time.
</p>
</td></tr>
<tr><td><code id="RescorlaWagner_+3A_nruns">nruns</code></td>
<td>
 
<p>An integer specifying the number of times the data have to be presented 
for learning.  The total number of learning trials is 
<code>nruns*sum(cuesOutcomes$Frequency)</code>.  
</p>
</td></tr>
<tr><td><code id="RescorlaWagner_+3A_random">random</code></td>
<td>

<p>A logical specifying whether the order of the learning trials for a given
run should be randomly reordered.  Can be set to <code>FALSE</code> in case all
frequencies are 1, and the sequence of learning trials in <code>cuesOutcomes</code>
is given by the order of the rows.
</p>
</td></tr>
<tr><td><code id="RescorlaWagner_+3A_randomorder">randomOrder</code></td>
<td>

<p>If not <code>NA</code>, a vector specifying the (usually random) order
of the learning trials.
</p>
</td></tr>
<tr><td><code id="RescorlaWagner_+3A_alpha">alpha</code></td>
<td>

<p>The salience of the trace cue.
</p>
</td></tr>
<tr><td><code id="RescorlaWagner_+3A_lambda">lambda</code></td>
<td>

<p>The maximum level of associative strength possible.
</p>
</td></tr>
<tr><td><code id="RescorlaWagner_+3A_beta1">beta1</code></td>
<td>

<p>The salience of the situation in which the outcome occurs.
</p>
</td></tr>
<tr><td><code id="RescorlaWagner_+3A_beta2">beta2</code></td>
<td>

<p>The salience of the situation in which the outcome does not occur.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equilibrium weights (Danks, 2003) are also estimated.
</p>


<h3>Value</h3>

<p>An object of the class <code>"RescorlaWagner"</code>, being a list with
the following components:
</p>

<dl>
<dt><code>weightvector</code></dt><dd><p> A numeric vector with the weights for all 
<code>nruns*sum(dat[,"Frequency"])</code> training trials.</p>
</dd>
<dt><code>equilibriumWeight</code></dt><dd><p> The weight of the cue-outcome link at equilibrium.</p>
</dd>
<dt><code>traceCue</code></dt><dd><p> A character string specifying the trace cue.</p>
</dd>
<dt><code>traceOutcome</code></dt><dd><p> A character string specifying the trace outcome.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>R. H. Baayen and Antti Arppe
</p>


<h3>References</h3>

<p>Danks, D. (2003). Equilibria of the Rescorla-Wagner model. Journal of
Mathematical Psychology, 47 (2), 109-121.
</p>
<p>Rescorla, R. A., &amp; Wagner, A. R. (1972). A theory of Pavlovian
conditioning: Variations in the effectiveness of reinforcement and
nonreinforcement. In Black, A. H., &amp; Prokasy, W. F. (Eds.),
Classical conditioning II: Current research and theory (pp. 64-99).
New York: Appleton-Century-Crofts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orthoCoding">orthoCoding</a></code>, <code><a href="#topic+plot.RescorlaWagner">plot.RescorlaWagner</a></code>, <code><a href="#topic+numbers">numbers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lexample)
lexample$Cues &lt;- orthoCoding(lexample$Word, grams=1)
lexample.rw &lt;- RescorlaWagner(lexample, nruns=25, 
   traceCue="h", traceOutcome="hand")
plot(lexample.rw)

data(numbers)
traceCues=c( "exactly1", "exactly2", "exactly3", "exactly4",
   "exactly5", "exactly6", "exactly7", "exactly10", "exactly15")
traceOutcomes=c("1", "2", "3", "4", "5", "6", "7", "10", "15")
ylimit=c(0,1)
par(mfrow=c(3,3),mar=c(4,4,1,1))
     
for(i in 1:length(traceCues)) {
   numbers.rw &lt;- RescorlaWagner(numbers, nruns=1,
      traceCue=traceCues[i], traceOutcome=traceOutcomes[i])
    plot(numbers.rw, ylimit=ylimit)
    mtext(paste(traceCues[i], " - ", traceOutcomes[i], sep=""), 
       side=3, line=-1, cex=0.7)
  }
par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='serbian'>
Serbian case inflected nouns.
</h2><span id='topic+serbian'></span>

<h3>Description</h3>

<p>3240 case-inflected Serbian nouns and their frequencies, for 270 different
masculine, feminine and neuter noun lemmas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(serbian)</code></pre>


<h3>Format</h3>

<p>A data frame with 3240 observations on the following 3 variables:
</p>

<dl>
<dt><code>WordForm</code></dt><dd><p>A character vector specifying the inflected word forms.</p>
</dd>
<dt><code>LemmaCase</code></dt><dd><p>A character vector specifying lemma (meaning), case, and number.</p>
</dd>
<dt><code>Frequency</code></dt><dd><p>A numeric vector specifying the frequency of each word form.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Frequencies were taken from the Frequency Dictionary of Contemporary Serbian Language (Kostic, 1999).
The 270 lemmas comprise the set of nouns for which each different case form appears at least once
in this resource.
</p>


<h3>Source</h3>

<p>Kostic, D. (1999). Frekvencijski recnik savremenog srpskog jezika (Frequency
Dictionary of Contemporary Serbian Language). Institute for Experimental
Phonetics and Speech Pathology &amp; Laboratory of Experimental Psychology,
University of Belgrade, Serbia.
</p>


<h3>References</h3>

<p>Kostic, D. (1999). Frekvencijski recnik savremenog srpskog jezika (Frequency
Dictionary of Contemporary Serbian Language). Institute for Experimental
Phonetics and Speech Pathology &amp; Laboratory of Experimental Psychology,
University of Belgrade, Serbia.
</p>
<p>Baayen, R. H., Milin, P., Filipovic Durdevic, D., Hendrix, P. and Marelli, M.
(2011), An amorphous model for morphological processing in visual comprehension
based on naive discriminative learning. Psychological Review, 118, 438-482. 
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+serbianLex">serbianLex</a>, <a href="#topic+estimateActivations">estimateActivations</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(serbian)
serbian$Cues &lt;- orthoCoding(serbian$WordForm, grams=2)
serbian$Outcomes &lt;- serbian$LemmaCase
sw &lt;- estimateWeights(cuesOutcomes=serbian)
sw[1:5,1:5]
desiredItems &lt;- unique(serbian["Cues"])
desiredItems$Outcomes=""
activations &lt;- estimateActivations(desiredItems, sw)$activationMatrix
rownames(activations) &lt;- unique(serbian[["WordForm"]])
activations[1:5,1:6]
</code></pre>

<hr>
<h2 id='serbianLex'>
Serbian lexicon with 1187 prime-target pairs.
</h2><span id='topic+serbianLex'></span>

<h3>Description</h3>

<p>The 1187 prime-target pairs and their lexical properties used in the
simulation study of Experiment 1 of Baayen et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(serbianLex)</code></pre>


<h3>Format</h3>

<p>A data frame with 1187 observations on the following 14 variables:
</p>

<dl>
<dt><code>Target</code></dt><dd><p>A factor specifying the target noun form</p>
</dd>
<dt><code>Prime</code></dt><dd><p>A factor specifying the prime noun form</p>
</dd>
<dt><code>PrimeLemma</code></dt><dd><p>A factor specifying the lemma of the prime</p>
</dd>
<dt><code>TargetLemma</code></dt><dd><p>A factor specifying the target lemma</p>
</dd>
<dt><code>Length</code></dt><dd><p>A numeric vector with the length in letters of the target</p>
</dd>
<dt><code>WeightedRE</code></dt><dd><p>A numeric vector with the weighted relative entropy of the prime and target inflectional paradigms</p>
</dd>
<dt><code>NormLevenshteinDist</code></dt><dd><p>A numeric vector with the normalized 
Levenshtein distance of prime and target forms</p>
</dd>
<dt><code>TargetLemmaFreq</code></dt><dd><p>A numeric vector with log frequency of 
the target lemma</p>
</dd>
<dt><code>PrimeSurfFreq</code></dt><dd><p>A numeric vector with log frequency of the prime form</p>
</dd>
<dt><code>PrimeCondition</code></dt><dd><p>A factor with prime conditions, levels: <code>DD</code>, <code>DSSD</code>, <code>SS</code></p>
</dd>
<dt><code>CosineSim</code></dt><dd><p>A numeric vector with the cosine similarity of prime and target vector space semantics</p>
</dd>
<dt><code>IsMasc</code></dt><dd><p>A vector of logicals, <code>TRUE</code> if the noun is masculine.</p>
</dd>
<dt><code>TargetGender</code></dt><dd><p>A factor with the gender of the target, levels: <code>f</code>, <code>m</code>, and <code>n</code></p>
</dd>
<dt><code>TargetCase</code></dt><dd><p>A factor specifying the case of the target noun, levels: <code>acc</code>, <code>dat</code>, <code>nom</code></p>
</dd>
<dt><code>MeanLogObsRT</code></dt><dd><p>Mean log-transformed observed reaction time</p>
</dd>
</dl>



<h3>References</h3>

<p>Baayen, R. H., Milin, P., Filipovic Durdevic, D., Hendrix, P. and
Marelli, M. (2011), An amorphous model for morphological processing in
visual comprehension based on naive discriminative
learning. Psychological Review, 118, 438-482.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calculate the weight matrix for the full set of Serbian nouns
data(serbian)
serbian$Cues &lt;- orthoCoding(serbian$WordForm, grams=2)
serbian$Outcomes &lt;- serbian$LemmaCase
sw &lt;- estimateWeights(cuesOutcomes=serbian)

# calculate the meaning activations for all unique word forms

desiredItems &lt;- unique(serbian["Cues"])
desiredItems$Outcomes &lt;- ""
activations &lt;- estimateActivations(desiredItems, sw)$activationMatrix
rownames(activations) &lt;- unique(serbian[["WordForm"]])
activations &lt;- activations + abs(min(activations))
activations[1:5,1:6]

# calculate simulated latencies for the experimental materials

data(serbianLex)
syntax &lt;- c("acc", "dat", "gen", "ins", "loc", "nom", "Pl", "Sg")
we &lt;- 0.4 # compound cue weight
strengths &lt;- rep(0, nrow(serbianLex))
for(i in 1:nrow(serbianLex)) {
   target &lt;- serbianLex$Target[i]
   prime &lt;- serbianLex$Prime[i]
   targetLemma &lt;- as.character(serbianLex$TargetLemma[i])
   primeLemma &lt;- as.character(serbianLex$PrimeLemma[i])
   targetOutcomes &lt;- c(targetLemma, primeLemma, syntax)
   primeOutcomes &lt;- c(targetLemma, primeLemma, syntax)
   p &lt;- activations[target, targetOutcomes]
   q &lt;- activations[prime, primeOutcomes]
   strengths[i] &lt;- sum((q^we)*(p^(1-we)))
}
serbianLex$SimRT &lt;- -strengths
lengthPenalty &lt;- 0.3
serbianLex$SimRT2 &lt;- serbianLex$SimRT + 
  (lengthPenalty * (serbianLex$Length&gt;5))

cor.test(serbianLex$SimRT, serbianLex$MeanLogObsRT)
cor.test(serbianLex$SimRT2, serbianLex$MeanLogObsRT)

serbianLex.lm &lt;- lm(SimRT2 ~ Length +  WeightedRE*IsMasc + 
      NormLevenshteinDist + TargetLemmaFreq + 
      PrimeSurfFreq + PrimeCondition, data=serbianLex)
summary(serbianLex.lm)
</code></pre>

<hr>
<h2 id='serbianUniCyr'>
Serbian case inflected nouns (in Cyrillic Unicode).
</h2><span id='topic+serbianUniCyr'></span>

<h3>Description</h3>

<p>3240 case-inflected Serbian nouns and their frequencies, for 270 different
masculine, feminine and neuter noun lemmas, written using the Cyrillic
alphabet and encoded in UTF-8.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(serbianUniCyr)</code></pre>


<h3>Format</h3>

<p>A data frame with 3240 observations on the following 3 variables:
</p>

<dl>
<dt><code>WordForm</code></dt><dd><p>A character vector specifying the inflected
word forms encoded in UTF-8.</p>
</dd>
<dt><code>LemmaCase</code></dt><dd><p>A character vector specifying lemma (meaning), case, and number.</p>
</dd>
<dt><code>Frequency</code></dt><dd><p>A numeric vector specifying the frequency of each word form.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Frequencies were taken from the Frequency Dictionary of Contemporary
Serbian Language (Kostic, 1999).  The 270 lemmas comprise the set of
nouns for which each different case form appears at least once in this
resource.
</p>


<h3>Source</h3>

<p>Kostic, D. (1999). Frekvencijski recnik savremenog srpskog jezika (Frequency
Dictionary of Contemporary Serbian Language). Institute for Experimental
Phonetics and Speech Pathology &amp; Laboratory of Experimental Psychology,
University of Belgrade, Serbia.
</p>


<h3>References</h3>

<p>Kostic, D. (1999). Frekvencijski recnik savremenog srpskog jezika (Frequency
Dictionary of Contemporary Serbian Language). Institute for Experimental
Phonetics and Speech Pathology &amp; Laboratory of Experimental Psychology,
University of Belgrade, Serbia.
</p>
<p>Baayen, R. H., Milin, P., Filipovic Durdevic, D., Hendrix, P. and Marelli, M.
(2011), An amorphous model for morphological processing in visual comprehension
based on naive discriminative learning. Psychological Review, 118, 438-482. 
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+serbian">serbian</a>, <a href="#topic+serbianLex">serbianLex</a>, <a href="#topic+estimateActivations">estimateActivations</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(serbianUniCyr)
serbianUniCyr$Cues &lt;- orthoCoding(serbianUniCyr$WordForm, grams=2)
serbianUniCyr$Outcomes &lt;- serbianUniCyr$LemmaCase
sw &lt;- estimateWeights(cuesOutcomes=serbianUniCyr)
sw[1:5,1:5]
desiredItems &lt;- unique(serbianUniCyr["Cues"])
desiredItems$Outcomes=""
activations &lt;- estimateActivations(desiredItems, sw)$activationMatrix
rownames(activations) &lt;- unique(serbianUniCyr[["WordForm"]])
activations[1:5,1:6]

## End(Not run)
</code></pre>

<hr>
<h2 id='serbianUniLat'>
Serbian case inflected nouns (in Latin-alphabet Unicode).
</h2><span id='topic+serbianUniLat'></span>

<h3>Description</h3>

<p>3240 case-inflected Serbian nouns and their frequencies, for 270 different
masculine, feminine and neuter noun lemmas, written using the Latin
alphabet and encoded in UTF-8.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(serbianUniLat)</code></pre>


<h3>Format</h3>

<p>A data frame with 3240 observations on the following 3 variables:
</p>

<dl>
<dt><code>WordForm</code></dt><dd><p>A character vector specifying the inflected
word forms encoded in UTF-8.</p>
</dd>
<dt><code>LemmaCase</code></dt><dd><p>A character vector specifying lemma (meaning), case, and number.</p>
</dd>
<dt><code>Frequency</code></dt><dd><p>A numeric vector specifying the frequency of each word form.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Frequencies were taken from the Frequency Dictionary of Contemporary
Serbian Language (Kostic, 1999).  The 270 lemmas comprise the set of
nouns for which each different case form appears at least once in this
resource.
</p>


<h3>Source</h3>

<p>Kostic, D. (1999). Frekvencijski recnik savremenog srpskog jezika (Frequency
Dictionary of Contemporary Serbian Language). Institute for Experimental
Phonetics and Speech Pathology &amp; Laboratory of Experimental Psychology,
University of Belgrade, Serbia.
</p>


<h3>References</h3>

<p>Kostic, D. (1999). Frekvencijski recnik savremenog srpskog jezika (Frequency
Dictionary of Contemporary Serbian Language). Institute for Experimental
Phonetics and Speech Pathology &amp; Laboratory of Experimental Psychology,
University of Belgrade, Serbia.
</p>
<p>Baayen, R. H., Milin, P., Filipovic Durdevic, D., Hendrix, P. and Marelli, M.
(2011), An amorphous model for morphological processing in visual comprehension
based on naive discriminative learning. Psychological Review, 118, 438-482. 
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+serbian">serbian</a>, <a href="#topic+serbianLex">serbianLex</a>, <a href="#topic+estimateActivations">estimateActivations</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(serbianUniLat)
serbianUniLat$Cues &lt;- orthoCoding(serbianUniLat$WordForm, grams=2)
serbianUniLat$Outcomes &lt;- serbianUniLat$LemmaCase
sw &lt;- estimateWeights(cuesOutcomes=serbianUniLat)
sw[1:5,1:5]
desiredItems &lt;- unique(serbianUniLat["Cues"])
desiredItems$Outcomes=""
activations &lt;- estimateActivations(desiredItems, sw)$activationMatrix
rownames(activations) &lt;- unique(serbianUniLat[["WordForm"]])
activations[1:5,1:6]
</code></pre>

<hr>
<h2 id='summary.ndlClassify'>A summary of a Naive Discriminatory Learning Model
</h2><span id='topic+summary.ndlClassify'></span><span id='topic+print.summary.ndlClassify'></span>

<h3>Description</h3>

<p>A summarization method for an object of the class <code>"ndlClassify"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ndlClassify'
summary(object, ...)

## S3 method for class 'summary.ndlClassify'
print(x, digits = max(3, getOption("digits") - 3), max.print=10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ndlClassify_+3A_object">object</code></td>
<td>

<p>An object of class <code>"ndlClassify"</code>, resulting from a call to
<code>ndlClassify</code>.
</p>
</td></tr>
<tr><td><code id="summary.ndlClassify_+3A_x">x</code></td>
<td>

<p>An object of class <code>"summary.ndlClassify"</code>, usually
resulting from a call to <code>summary.ndlClassify</code>.
</p>
</td></tr>
<tr><td><code id="summary.ndlClassify_+3A_digits">digits</code></td>
<td>

<p>The number of significant digits to use when printing.
</p>
</td></tr>
<tr><td><code id="summary.ndlClassify_+3A_max.print">max.print</code></td>
<td>

<p>The maximum number of rows of <code>weights</code> to be output when
printing; by default equal to 10; ; if set to <code>NA</code> all rows
will be output.
</p>
</td></tr>
<tr><td><code id="summary.ndlClassify_+3A_...">...</code></td>
<td>

<p>Control arguments passed to or from other methods,
e.g. <code>ndlStatistics</code> and <code>modelStatistics</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates descriptive statistics of a fitted Naive Discriminatory
Learning model and prints a nice summary of the key results.
</p>


<h3>Value</h3>

<p><code>summary.ndlClassify</code> returns an object of the class
<code>"summary.ndlClassify"</code>, a list with the following components:
</p>

<dl>
<dt><code>call</code></dt><dd><p>The call matched to fit  the <code>"ndlClassify"</code> object.
</p>
</dd>
<dt><code>formula</code></dt><dd><p>The formula specified for the <code>"ndlClassify"</code> object.
</p>
</dd>
<dt><code>weights</code></dt><dd><p>The estimated weights.
</p>
</dd>
<dt><code>statistics</code></dt><dd><p>A range of descriptive statistics calculated with <code>ndlStatistics</code>.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Antti Arppe
</p>


<h3>References</h3>

<p>Arppe, A. and Baayen, R. H. (in prep.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ndlClassify">ndlClassify</a>, <a href="#topic+ndlStatistics">ndlStatistics</a>, <a href="#topic+modelStatistics">modelStatistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## For examples see examples(ndlClassify).

</code></pre>

<hr>
<h2 id='summary.ndlCrossvalidate'>A summary of a crossvalidation of a Naive Discriminatory Reader Model
</h2><span id='topic+summary.ndlCrossvalidate'></span><span id='topic+print.summary.ndlCrossvalidate'></span>

<h3>Description</h3>

<p>A summarization method for an object of the class <code>"ndlCrossvalidate"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ndlCrossvalidate'
summary(object, ...)

## S3 method for class 'summary.ndlCrossvalidate'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ndlCrossvalidate_+3A_object">object</code></td>
<td>

<p>An object of class <code>"ndlCrossvalidate"</code>, resulting from a call to
<code>ndlCrossvalidate</code>.
</p>
</td></tr>
<tr><td><code id="summary.ndlCrossvalidate_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary.ndlCrossvalidate"</code>, usually resulting from a
call to <code>summary.ndlCrossvalidate</code>.
</p>
</td></tr>
<tr><td><code id="summary.ndlCrossvalidate_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to use when printing.
</p>
</td></tr>
<tr><td><code id="summary.ndlCrossvalidate_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates overall descriptive statistics of the crossvalidation of
a fitted Naive Discriminatory Reader model and prints a nice summary
of the key results.
</p>


<h3>Value</h3>

<p><code>summary.ndlCrossvalidate</code> returns an object of the class
<code>"summary.ndlCrossvalidate"</code>, a list with the following components:
</p>

<dl>
<dt><code>call</code></dt><dd><p>The call matched to fit  the <code>"ndlCrossvalidate"</code> object.
</p>
</dd>
<dt><code>formula</code></dt><dd><p>The formula specified for the <code>"ndlCrossvalidate"</code> object.
</p>
</dd>
<dt><code>statistics.summary</code></dt><dd><p>The means, minima and maxima of a
range descriptive statistics for the fit and performance of
individual folds; see <code><a href="#topic+ndlStatistics">ndlStatistics</a></code>.
</p>
</dd>
<dt><code>crosstable.summary</code></dt><dd><p>The means of the crosstabulation of
observed and predicted outcomes for the held-out test data.
</p>
</dd>
<dt><code>recall.predicted.summary</code></dt><dd><p>The means of the recall
values for the individual outcomes predicted with the held-out test
data.
</p>
</dd>
<dt><code>precision.predicted.summary</code></dt><dd><p>The means of the precision
values for the individual outcomes predicted with the held-out test
data.
</p>
</dd>
<dt><code>statistics.all</code></dt><dd><p>All the values for a range descriptive
statistics for the fit and performance of individual folds on the
held-out test data; see <code><a href="#topic+ndlStatistics">ndlStatistics</a></code>.
</p>
</dd>
<dt><code>k</code></dt><dd><p>The number of folds.
</p>
</dd>
<dt><code>n.total</code></dt><dd><p>The sum frequency of all data points in
<code>data</code>.
</p>
</dd>
<dt><code>n.train</code></dt><dd><p>The sum frequency of data points used for
training the individual models (excluding the individual folds).
</p>
</dd>
<dt><code>n.test</code></dt><dd><p>The sum frequency of data points in the
individual held-out folds used for testing the individual models.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Antti Arppe
</p>


<h3>References</h3>

<p>Arppe, A. and Baayen, R. H. (in prep.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ndlCrossvalidate">ndlCrossvalidate</a>, <a href="#topic+ndlClassify">ndlClassify</a>, <a href="#topic+ndlStatistics">ndlStatistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## For examples see examples(ndlCrossvalidate).

</code></pre>

<hr>
<h2 id='think'>
Finnish &lsquo;think&rsquo; verbs.
</h2><span id='topic+think'></span>

<h3>Description</h3>

<p>3404 occurrences of four synonymous Finnish &lsquo;think&rsquo; verbs (&lsquo;ajatella&rsquo;: 1492; &lsquo;mietti\&quot;a&rsquo;: 812; &lsquo;pohtia&rsquo;: 713; &lsquo;harkita&rsquo;: 387) in newspaper and Internet newsgroup discussion texts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(think)</code></pre>


<h3>Format</h3>

<p>A data frame with 3404 observations on the following 27 variables:
</p>

<dl>
<dt><code>Lexeme</code></dt><dd><p>A factor specifying one of the four &lsquo;think&rsquo; verb synonyms</p>
</dd>
<dt><code>Polarity</code></dt><dd><p>A factor specifying whether the &lsquo;think&rsquo; verb has negative polarity (<code>Negation</code>) or not (<code>Other</code>)</p>
</dd>
<dt><code>Voice</code></dt><dd><p>A factor specifying whether the &lsquo;think&rsquo; verb is in the <code>Passive</code> voice or not (<code>Other</code>)</p>
</dd>
<dt><code>Mood</code></dt><dd><p>A factor specifying whether the &lsquo;think&rsquo; verb is in the <code>Indicative</code> or <code>Conditional</code> mood or not (Other)</p>
</dd>
<dt><code>Person</code></dt><dd><p>A factor specifying whether the &lsquo;think&rsquo; verb is in the <code>First</code>, <code>Second</code>, <code>Third</code> person or not (<code>None</code>)</p>
</dd>
<dt><code>Number</code></dt><dd><p>A factor specifying whether the &lsquo;think&rsquo; verb is in the <code>Plural</code> number or not (<code>Other</code>)</p>
</dd>
<dt><code>Covert</code></dt><dd><p>A factor specifying whether the agent/subject of the &lsquo;think&rsquo; verb is explicitly expressed as a syntactic argument (<code>Overt</code>), or only as a morphological feature of the &lsquo;think&rsquo; verb (<code>Covert</code>)</p>
</dd>
<dt><code>ClauseEquivalent</code></dt><dd><p>A factor specifying whether the &lsquo;think&rsquo; verb is used as a non-finite clause equivalent (<code>ClauseEquivalent</code>) or as a finite verb (<code>FiniteVerbChain</code>)</p>
</dd>
<dt><code>Agent</code></dt><dd><p>A factor specifying the occurrence of Agent/Subject of the &lsquo;think&rsquo; verb as either a Human <code>Individual</code>, Human <code>Group</code>, or as absent (<code>None</code>)</p>
</dd>
<dt><code>Patient</code></dt><dd><p>A factor specifying the occurrence of the Patient/Object argument among the semantic or structural subclasses as either an Human Individual or Group (<code>IndividualGroup</code>), <code>Abstraction</code>, <code>Activity</code>, <code>Communication</code>, <code>Event</code>, an &lsquo;etta&rsquo; (&lsquo;that&rsquo;) clause (<code>etta_CLAUSE</code>), <code>DirectQuote</code>, <code>IndirectQuestion</code>, <code>Infinitive</code>, <code>Participle</code>, or as absent (<code>None</code>)</p>
</dd>
<dt><code>Manner</code></dt><dd><p>A factor specifying the occurrrence of the Manner argument as any of its subclasses <code>Generic</code>, <code>Negative</code> (sufficiency), <code>Positive</code> (sufficiency), <code>Frame</code>, <code>Agreement</code> (Concur or Disagree), <code>Joint</code> (Alone or Together), or as absent (<code>None</code>)</p>
</dd>
<dt><code>Time</code></dt><dd><p>A factor specifying the occurrence of Time argument (as a moment) as either of its subclasses <code>Definite</code>, <code>Indefinite</code>, or as absent (<code>None</code>)</p>
</dd>
<dt><code>Modality1</code></dt><dd><p>A factor specifying the main semantic subclasses of the entire Verb chain as either indicating <code>Possibility</code>, <code>Necessity</code>, or their absense (<code>None</code>)</p>
</dd>
<dt><code>Modality2</code></dt><dd><p>A factor specifying minor semantic subclasses of the entire Verb chain as indicating either a <code>Temporal</code> element (begin, end, continuation, etc.), <code>External</code> (cause), <code>Volition</code>, <code>Accidental</code> nature of the thinking process, or their absense (<code>None</code>)</p>
</dd>
<dt><code>Source</code></dt><dd><p>A factor specifying the occurrence of a <code>Source</code> argument or its absense (<code>None</code>)</p>
</dd>
<dt><code>Goal</code></dt><dd><p>A factor specifying the occurrence of a <code>Goal</code> argument or its absence (<code>None</code>)</p>
</dd>
<dt><code>Quantity</code></dt><dd><p>A factor specifying the occurrence of a <code>Quantity</code> argument, or its absence (<code>None</code>)</p>
</dd>
<dt><code>Location</code></dt><dd><p>A factor specifying the occurrence of a <code>Location</code> argument, or its absence (<code>None</code>)</p>
</dd>
<dt><code>Duration</code></dt><dd><p>A factor specifying the occurrence of a <code>Duration</code> argument, or its absence (<code>None</code>)</p>
</dd>
<dt><code>Frequency</code></dt><dd><p>A factor specifying the occurrence of a <code>Frequency</code> arument, or its absence (<code>None</code>)</p>
</dd>
<dt><code>MetaComment</code></dt><dd><p>A factor specifying the occurrence of a <code>MetaComment</code>, or its absence (<code>None</code>)</p>
</dd>
<dt><code>ReasonPurpose</code></dt><dd><p>A factor specifying the occurrence of a Reason or Purpose argument (<code>ReasonPurpose</code>), or their absence (<code>None</code>)</p>
</dd>
<dt><code>Condition</code></dt><dd><p>A factor specifying the occurrence of a <code>Condition</code> argument, or its absence (<code>None</code>)</p>
</dd>
<dt><code>CoordinatedVerb</code></dt><dd><p>A factor specifying the occurrence of a Coordinated Verb (in relation to the &lsquo;think&rsquo; verb: <code>CoordinatedVerb</code>), or its absence (<code>None</code>)</p>
</dd>
<dt><code>Register</code></dt><dd><p>A factor specifying whether the &lsquo;think&rsquo; verb occurs in the newspaper subcorpus (<code>hs95</code>) or the Internet newsgroup discussion corpus (<code>sfnet</code>)</p>
</dd>
<dt><code>Section</code></dt><dd><p>A factor specifying the subsection in which the &lsquo;think&rsquo; verb occurs in either of the two subcorpora</p>
</dd>
<dt><code>Author</code></dt><dd><p>A factor specifying the author of the text in which the &lsquo;think&rsquo; verb occurs, if that author is identifiable &ndash; authors in the Internet newgroup discussion subcorpus are anonymized; unidentifiable/unknown author designated as (<code>None</code>)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The four most frequent synonyms meaning &lsquo;think, reflect, ponder,
consider&rsquo;, i.e. &lsquo;ajatella, miettia, pohtia, harkita&rsquo;, were extracted
from two months of newspaper text from the 1990s (Helsingin Sanomat
1995) and six months of Internet newsgroup discussion from the early
2000s (SFNET 2002-2003), namely regarding (personal) relationships
(sfnet.keskustelu.ihmissuhteet) and politics
(sfnet.keskustelu.politiikka). The newspaper corpus consisted of
3,304,512 words of body text (i.e. excluding headers and captions as
well as punctuation tokens), and included 1,750 examples of the
studied &lsquo;think&rsquo; verbs. The Internet corpus comprised 1,174,693 words of
body text, yielding 1,654 instances of the selected &lsquo;think&rsquo;
verbs. In terms of distinct identifiable authors, the newspaper
sub-corpus was the product of just over 500 journalists and other
contributors, while the Internet sub-corpus involved well over 1000
discussants. The <code>think</code> dataset contains a selection of 26
contextual features judged as most informative.
</p>
<p>For extensive details of the data and its linguistic and statistical
analysis, see Arppe (2008). For the full selection of contextual
features, see the <code>amph</code> (2008) microcorpus.
</p>


<h3>Source</h3>

<p>amph 2008. A micro-corpus of 3404 occurrences of the four most common
Finnish THINK lexemes, &lsquo;ajatella, miettia, pohtia, and harkita&rsquo;, in
Finnish newspaper and Internet newsgroup discussion texts, containing
extracts and linguistic analysis of the relevant context in the
original corpus data, scripts for processing this data, R functions
for its statistical analysis, as well as a comprehensive set of
ensuing results as R data tables. Compiled and analyzed by Antti
Arppe. Available on-line at URL:
http://www.csc.fi/english/research/software/amph/
</p>
<p>Helsingin Sanomat 1995. ~22 million words of Finnish newspaper
articles published in Helsingin Sanomat during January&ndash;December
1995. Compiled by the Research Institute for the Languages of Finland
[KOTUS] and CSC &ndash; IT Center for Science, Finland. Available on-line at
URL: http://www.csc.fi/kielipankki/
</p>
<p>SFNET 2002-2003. ~100 million words of Finnish internet newsgroup
discussion posted during October 2002 &ndash; April 2003. Compiled by Tuuli
Tuominen and Panu Kalliokoski, Computing Centre, University of
Helsinki, and Antti Arppe, Department of General Linguistics,
University of Helsinki, and CSC &ndash; IT Center for Science,
Finland. Available on-line at URL: http://www.csc.fi/kielipankki/
</p>


<h3>References</h3>

<p>Arppe, A. 2008. Univariate, bivariate and multivariate methods in
corpus-based lexicography &ndash; a study of synonymy. Publications of the
Department of General Linguistics, University of Helsinki,
No. 44. URN: http://urn.fi/URN:ISBN:978-952-10-5175-3.
</p>
<p>Arppe, A. 2009. Linguistic choices vs. probabilities &ndash; how much and
what can linguistic theory explain? In: Featherston, Sam &amp; Winkler,
Susanne (eds.) The Fruits of Empirical Linguistics. Volume 1:
Process. Berlin: de Gruyter, pp. 1-24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(think)
think.ndl = ndlClassify(Lexeme ~ Person + Number + Agent + Patient + Register,
   data=think)
summary(think.ndl)
plot(think.ndl)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
