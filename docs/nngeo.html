<!DOCTYPE html><html><head><title>Help for package nngeo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nngeo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cities'><p>Point layer of the three largest cities in Israel</p></a></li>
<li><a href='#line'><p>Sample network dataset: lines</p></a></li>
<li><a href='#nngeo-package'><p>nngeo: k-Nearest Neighbor Join for Spatial Data</p></a></li>
<li><a href='#pnt'><p>Sample network dataset: points</p></a></li>
<li><a href='#st_azimuth'><p>Calculate the azimuth between pairs of points</p></a></li>
<li><a href='#st_connect'><p>Create lines between features of two layers</p></a></li>
<li><a href='#st_ellipse'><p>Calculate ellipse polygon</p></a></li>
<li><a href='#st_nn'><p>Nearest Neighbor Search for Simple Features</p></a></li>
<li><a href='#st_postgis'><p>Send 'sf' layer to a PostGIS query</p></a></li>
<li><a href='#st_remove_holes'><p>Remove polygon holes</p></a></li>
<li><a href='#st_segments'><p>Split polygons or lines to segments</p></a></li>
<li><a href='#towns'><p>Point layer of towns in Israel</p></a></li>
<li><a href='#water'><p>Polygonal layer of water bodies in Israel</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>k-Nearest Neighbor Join for Spatial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.7</td>
</tr>
<tr>
<td>Description:</td>
<td>K-nearest neighbor search for projected and non-projected 'sf' spatial layers. Nearest neighbor search uses (1) C code from 'GeographicLib' for lon-lat point layers, (2) function knn() from package 'nabor' for projected point layers, or (3) function st_distance() from package 'sf' for line or polygon layers. The package also includes several other utility functions for spatial analysis.</td>
</tr>
<tr>
<td>Imports:</td>
<td>nabor, units, methods, parallel, data.table</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), sf (&ge; 0.6)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DBI, RPostgreSQL, stars, knitr, rmarkdown, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://michaeldorman.github.io/nngeo/">https://michaeldorman.github.io/nngeo/</a>,
<a href="https://github.com/michaeldorman/nngeo/">https://github.com/michaeldorman/nngeo/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/michaeldorman/nngeo/issues/">https://github.com/michaeldorman/nngeo/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-24 15:24:26 UTC; michael</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Dorman [aut, cre],
  Johnathan Rush [ctb],
  Ian Hough [ctb],
  Dominic Russel [ctb],
  Luigi Ranghetti [ctb],
  Attilio Benini [ctb],
  Arnaud Tarroux [ctb],
  Charles F.F Karney [ctb, cph] (Author of included C code from
    'GeographicLib' for geodesic distance)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Dorman &lt;dorman@post.bgu.ac.il&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-24 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cities'>Point layer of the three largest cities in Israel</h2><span id='topic+cities'></span>

<h3>Description</h3>

<p>A <code>sf</code> POINT layer of the three largest cities in Israel: Jerusalem, Tel-Aviv and Haifa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cities
</code></pre>


<h3>Format</h3>

<p>A <code>sf</code> POINT layer with 3 features and 1 attribute:
</p>

<dl>
<dt>name</dt><dd><p>Town name</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>plot(cities)
</code></pre>

<hr>
<h2 id='line'>Sample network dataset: lines</h2><span id='topic+line'></span>

<h3>Description</h3>

<p>An <code>sf</code> object based on the <code>edge_table</code> sample dataset from pgRouting 2.6 tutorial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line
</code></pre>


<h3>Format</h3>

<p>An <code>sf</code> object
</p>


<h3>References</h3>

<p><a href="https://docs.pgrouting.org/2.6/en/sampledata.html">https://docs.pgrouting.org/2.6/en/sampledata.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(line)
</code></pre>

<hr>
<h2 id='nngeo-package'>nngeo: k-Nearest Neighbor Join for Spatial Data</h2><span id='topic+nngeo'></span><span id='topic+nngeo-package'></span>

<h3>Description</h3>

<p>K-nearest neighbor search for projected and non-projected 'sf' spatial layers. Nearest neighbor search uses (1) C code from 'GeographicLib' for lon-lat point layers, (2) function knn() from package 'nabor' for projected point layers, or (3) function st_distance() from package 'sf' for line or polygon layers. The package also includes several other utility functions for spatial analysis.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Dorman <a href="mailto:dorman@post.bgu.ac.il">dorman@post.bgu.ac.il</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Johnathan Rush <a href="mailto:johnathan.rush@mssm.edu">johnathan.rush@mssm.edu</a> [contributor]
</p>
</li>
<li><p> Ian Hough <a href="mailto:hough@post.bgu.ac.il">hough@post.bgu.ac.il</a> [contributor]
</p>
</li>
<li><p> Dominic Russel <a href="mailto:domrussel@gmail.com">domrussel@gmail.com</a> [contributor]
</p>
</li>
<li><p> Luigi Ranghetti <a href="mailto:luigi.ranghetti@gmail.com">luigi.ranghetti@gmail.com</a> [contributor]
</p>
</li>
<li><p> Attilio Benini <a href="mailto:attilio.benini@gmx.net">attilio.benini@gmx.net</a> [contributor]
</p>
</li>
<li><p> Arnaud Tarroux <a href="mailto:arnaud.tarroux@nina.no">arnaud.tarroux@nina.no</a> [contributor]
</p>
</li>
<li><p> Charles F.F Karney (Author of included C code from 'GeographicLib' for geodesic distance) [contributor, copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://michaeldorman.github.io/nngeo/">https://michaeldorman.github.io/nngeo/</a>
</p>
</li>
<li> <p><a href="https://github.com/michaeldorman/nngeo/">https://github.com/michaeldorman/nngeo/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/michaeldorman/nngeo/issues/">https://github.com/michaeldorman/nngeo/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='pnt'>Sample network dataset: points</h2><span id='topic+pnt'></span>

<h3>Description</h3>

<p>An <code>sf</code> object based on the <code>pointsOfInterest</code> sample dataset from pgRouting 2.6 tutorial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnt
</code></pre>


<h3>Format</h3>

<p>An <code>sf</code> object
</p>


<h3>References</h3>

<p><a href="https://docs.pgrouting.org/2.6/en/sampledata.html">https://docs.pgrouting.org/2.6/en/sampledata.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(pnt)
</code></pre>

<hr>
<h2 id='st_azimuth'>Calculate the azimuth between pairs of points</h2><span id='topic+st_azimuth'></span>

<h3>Description</h3>

<p>Calculates the (planar!) azimuth between pairs in two sequences of points <code>x</code> and <code>y</code>. When point sequence length doesn't match, the shorter one is recycled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_azimuth(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_azimuth_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code>, of type <code>"POINT"</code></p>
</td></tr>
<tr><td><code id="st_azimuth_+3A_y">y</code></td>
<td>
<p>Object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code>, of type <code>"POINT"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector, of the same length as (the longer of) <code>x</code> and <code>y</code>, with the azimuth values from <code>x</code> to <code>y</code> (in decimal degrees, ranging between 0 and 360 clockwise from north). For identical points, an azimuth of <code>NA</code> is returned.
</p>


<h3>Note</h3>

<p>The function currently calculates planar azimuth, ignoring CRS information. For bearing on a sphere, given points in lon-lat, see function <code>geosphere::bearing</code>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Azimuth#Cartographical_azimuth">https://en.wikipedia.org/wiki/Azimuth#Cartographical_azimuth</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two points
x = st_point(c(0, 0))
y = st_point(c(1, 1))
st_azimuth(x, y)

# Center and all other points on a 5*5 grid
library(stars)
m = matrix(1, ncol = 5, nrow = 5)
m[(nrow(m)+1)/2, (ncol(m)+1)/2] = 0
s = st_as_stars(m)
s = st_set_dimensions(s, 2, offset = ncol(m), delta = -1)
names(s) = "value"
pnt = st_as_sf(s, as_points = TRUE)
ctr = pnt[pnt$value == 0, ]
az = st_azimuth(ctr, pnt)
plot(st_geometry(pnt), col = NA)
plot(st_connect(ctr, pnt, k = nrow(pnt), progress = FALSE), col = "grey", add = TRUE)
plot(st_geometry(pnt), col = "grey", add = TRUE)
text(st_coordinates(pnt), as.character(round(az)), col = "red")
</code></pre>

<hr>
<h2 id='st_connect'>Create lines between features of two layers</h2><span id='topic+st_connect'></span>

<h3>Description</h3>

<p>Returns a line layer with line segments which connect the nearest feature(s) from <code>y</code> for each feature in <code>x</code>. This is mostly useful for graphical purposes (see Note and Examples below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_connect(x, y, ids = NULL, progress = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_connect_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="st_connect_+3A_y">y</code></td>
<td>
<p>Object of class <code>sf</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="st_connect_+3A_ids">ids</code></td>
<td>
<p>A sparse list representation of features to connect such as returned by function <code><a href="#topic+st_nn">st_nn</a></code>. If <code>NULL</code> the function automatically calculates <code>ids</code> using <code><a href="#topic+st_nn">st_nn</a></code></p>
</td></tr>
<tr><td><code id="st_connect_+3A_progress">progress</code></td>
<td>
<p>Display progress bar? (default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="st_connect_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>st_nn</code> when calculating <code>ids</code>, such as <code>k</code> and <code>maxdist</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>sfc</code> with geometry type <code>LINESTRING</code>
</p>


<h3>Note</h3>

<p>The segments are straight lines, i.e., they correspond to shortest path assuming planar geometry regardless of CRS. Therefore, the lines should serve as a graphical indication of features that are nearest to each other; the exact shortest path between features should be calculated by other means, such as <code>geosphere::greatCircle</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Nearest 'city' per 'town'
l = st_connect(towns, cities, progress = FALSE)
plot(st_geometry(towns), col = "darkgrey")
plot(st_geometry(l), add = TRUE)
plot(st_geometry(cities), col = "red", add = TRUE)

# Ten nearest 'towns' per 'city'
l = st_connect(cities, towns, k = 10, progress = FALSE)
plot(st_geometry(towns), col = "darkgrey")
plot(st_geometry(l), add = TRUE)
plot(st_geometry(cities), col = "red", add = TRUE)

## Not run: 

# Nearest 'city' per 'town', search radius of 30 km
cities = st_transform(cities, 32636)
towns = st_transform(towns, 32636)
l = st_connect(cities, towns, k = nrow(towns), maxdist = 30000, progress = FALSE)
plot(st_geometry(towns), col = "darkgrey")
plot(st_geometry(l), add = TRUE)
plot(st_buffer(st_geometry(cities), units::set_units(30, km)), border = "red", add = TRUE)

# The 20-nearest towns for each water body, search radius of 100 km
water = st_transform(water, 32636)
l = st_connect(water[-1, ], towns, k = 20, maxdist = 100000, progress = FALSE)
plot(st_geometry(water[-1, ]), col = "lightblue", border = NA)
plot(st_geometry(towns), col = "darkgrey", add = TRUE)
plot(st_geometry(l), col = "red", add = TRUE)


# The 2-nearest water bodies for each town, search radius of 100 km
l = st_connect(towns, water[-1, ], k = 2, maxdist = 100000)
plot(st_geometry(water[-1, ]), col = "lightblue", border = NA, extent = l)
plot(st_geometry(towns), col = "darkgrey", add = TRUE)
plot(st_geometry(l), col = "red", add = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='st_ellipse'>Calculate ellipse polygon</h2><span id='topic+st_ellipse'></span>

<h3>Description</h3>

<p>The function calculates ellipse polygons, given centroid locations and sizing on the x and y axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_ellipse(pnt, ex, ey, res = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_ellipse_+3A_pnt">pnt</code></td>
<td>
<p>Object of class <code>sf</code> or <code>sfc</code> (type <code>"POINT"</code>) representing centroid locations</p>
</td></tr>
<tr><td><code id="st_ellipse_+3A_ex">ex</code></td>
<td>
<p>Size along x-axis, in CRS units</p>
</td></tr>
<tr><td><code id="st_ellipse_+3A_ey">ey</code></td>
<td>
<p>Size along y-axis, in CRS units</p>
</td></tr>
<tr><td><code id="st_ellipse_+3A_res">res</code></td>
<td>
<p>Number of points the ellipse polygon consists of (default <code>30</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>sfc</code> (type <code>"POLYGON"</code>) containing ellipse polygons
</p>


<h3>References</h3>

<p>Based on StackOverflow answer by user <code>fdetsch</code>:
</p>
<p><a href="https://stackoverflow.com/questions/35841685/add-an-ellipse-on-raster-plot-in-r">https://stackoverflow.com/questions/35841685/add-an-ellipse-on-raster-plot-in-r</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
dat = data.frame(
  x = c(1, 1, -1, 3, 3),
  y = c(0, -3, 2, -2, 0),
  ex = c(0.5, 2, 2, 0.3, 0.6),
  ey = c(0.5, 0.2, 1, 1, 0.3),
  stringsAsFactors = FALSE
)
dat = st_as_sf(dat, coords = c("x", "y"))
dat

# Plot 1
plot(st_geometry(dat), graticule = TRUE, axes = TRUE, main = "Input")
text(st_coordinates(dat), as.character(1:nrow(dat)), pos = 2)

# Calculate ellipses
el = st_ellipse(pnt = dat, ex = dat$ex, ey = dat$ey)

# Plot 2
plot(el, graticule = TRUE, axes = TRUE, main = "Output")
plot(st_geometry(dat), pch = 3, add = TRUE)
text(st_coordinates(dat), as.character(1:nrow(dat)), pos = 2)
</code></pre>

<hr>
<h2 id='st_nn'>Nearest Neighbor Search for Simple Features</h2><span id='topic+st_nn'></span>

<h3>Description</h3>

<p>Returns the indices of layer <code>y</code> which are nearest neighbors of each feature of layer <code>x</code>. The number of nearest neighbors <code>k</code> and the search radius <code>maxdist</code> can be modified.<br /><br />
The function has three modes of operation:
</p>

<ul>
<li><p>lon-lat points—Calculation using C code from <code>GeographicLib</code>, similar to <code>sf::st_distance</code>
</p>
</li>
<li><p>projected points—Calculation using <code>nabor::knn</code>, a fast search method based on the <code>libnabo</code> C++ library
</p>
</li>
<li><p>lines or polygons, either lon-lat or projected—Calculation based on <code>sf::st_distance</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>st_nn(
  x,
  y,
  sparse = TRUE,
  k = 1,
  maxdist = Inf,
  returnDist = FALSE,
  progress = TRUE,
  parallel = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_nn_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="st_nn_+3A_y">y</code></td>
<td>
<p>Object of class <code>sf</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="st_nn_+3A_sparse">sparse</code></td>
<td>
<p><code>logical</code>; should a sparse index list be returned (<code>TRUE</code>, the default) or a dense logical matrix? See &quot;Value&quot; section below.</p>
</td></tr>
<tr><td><code id="st_nn_+3A_k">k</code></td>
<td>
<p>The maximum number of nearest neighbors to compute. Default is <code>1</code>, meaning that only a single point (nearest neighbor) is returned.</p>
</td></tr>
<tr><td><code id="st_nn_+3A_maxdist">maxdist</code></td>
<td>
<p>Search radius (<strong>in meters</strong>). Points farther than search radius are not considered. Default is <code>Inf</code>, meaning that search is unconstrained.</p>
</td></tr>
<tr><td><code id="st_nn_+3A_returndist">returnDist</code></td>
<td>
<p><code>logical</code>; whether to return a second <code>list</code> with the distances between detected neighbors.</p>
</td></tr>
<tr><td><code id="st_nn_+3A_progress">progress</code></td>
<td>
<p>Display progress bar? The default is <code>TRUE</code>. When using <code>parallel&gt;1</code> or when input is projected points, a progress bar is not displayed regardless of <code>progress</code> argument.</p>
</td></tr>
<tr><td><code id="st_nn_+3A_parallel">parallel</code></td>
<td>
<p>Number of parallel processes. The default <code>parallel=1</code> implies ordinary non-parallel processing. Parallel processing is not applicable for projected points, where calculation is already highly optimized through the use of <code>nabor::knn</code>. Parallel processing is done with the <code>parallel</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>If <code>sparse=TRUE</code> (the default), a sparse <code>list</code> with list element <code>i</code> being a numeric vector with the indices <code>j</code> of neighboring features from <code>y</code> for the feature <code>x[i,]</code>, or an empty vector (<code>integer(0)</code>) in case there are no neighbors.
</p>
</li>
<li><p>If <code>sparse=FALSE</code>, a <code>logical</code> matrix with element <code>[i,j]</code> being <code>TRUE</code> when <code>y[j,]</code> is a neighbor of <code>x[i]</code>.
</p>
</li>
<li><p>If <code>returnDists=TRUE</code> the function returns a <code>list</code>, with the first element as specified above, and the second element a sparse <code>list</code> with the distances (as <code>units</code> vectors, <strong>in meters</strong>) between each pair of detected neighbors corresponding to the sparse <code>list</code> of indices.
</p>
</li></ul>



<h3>References</h3>

<p>C. F. F. Karney, GeographicLib, Version 1.49 (2017-mm-dd), <a href="https://geographiclib.sourceforge.io/1.49/">https://geographiclib.sourceforge.io/1.49/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cities)
data(towns)

cities = st_transform(cities, 32636)
towns = st_transform(towns, 32636)
water = st_transform(water, 32636)

# Nearest town
st_nn(cities, towns, progress = FALSE)

# Using 'sfc' objects
st_nn(st_geometry(cities), st_geometry(towns), progress = FALSE)
st_nn(cities, st_geometry(towns), progress = FALSE)
st_nn(st_geometry(cities), towns, progress = FALSE)

# With distances
st_nn(cities, towns, returnDist = TRUE, progress = FALSE)

## Not run: 

# Distance limit
st_nn(cities, towns, maxdist = 7200)
st_nn(cities, towns, k = 3, maxdist = 12000)
st_nn(cities, towns, k = 3, maxdist = 12000, returnDist = TRUE)

# 3 nearest towns
st_nn(cities, towns, k = 3)

# Spatial join
st_join(cities, towns, st_nn, k = 1)
st_join(cities, towns, st_nn, k = 2)
st_join(cities, towns, st_nn, k = 1, maxdist = 7200)
st_join(towns, cities, st_nn, k = 1)

# Polygons to polygons
st_nn(water, towns, k = 4)

# Large example - Geo points
n = 1000
x = data.frame(
  lon = (runif(n) * 2 - 1) * 70,
  lat = (runif(n) * 2 - 1) * 70
)
x = st_as_sf(x, coords = c("lon", "lat"), crs = 4326)
start = Sys.time()
result1 = st_nn(x, x, k = 3)
end = Sys.time()
end - start

# Large example - Geo points - Parallel processing
start = Sys.time()
result2 = st_nn(x, x, k = 3, parallel = 4)
end = Sys.time()
end - start
all.equal(result1, result2)

# Large example - Proj points
n = 1000
x = data.frame(
  x = (runif(n) * 2 - 1) * 70,
  y = (runif(n) * 2 - 1) * 70
)
x = st_as_sf(x, coords = c("x", "y"), crs = 4326)
x = st_transform(x, 32630)
start = Sys.time()
result = st_nn(x, x, k = 3)
end = Sys.time()
end - start

# Large example - Polygons
set.seed(1)
n = 150
x = data.frame(
  lon = (runif(n) * 2 - 1) * 70,
  lat = (runif(n) * 2 - 1) * 70
)
x = st_as_sf(x, coords = c("lon", "lat"), crs = 4326)
x = st_transform(x, 32630)
x = st_buffer(x, 1000000)
start = Sys.time()
result1 = st_nn(x, x, k = 3)
end = Sys.time()
end - start

# Large example - Polygons - Parallel processing
start = Sys.time()
result2 = st_nn(x, x, k = 3, parallel = 4)
end = Sys.time()
end - start
all.equal(result1, result2)


## End(Not run)
</code></pre>

<hr>
<h2 id='st_postgis'>Send 'sf' layer to a PostGIS query</h2><span id='topic+st_postgis'></span>

<h3>Description</h3>

<p>The function sends a query plus an <code>sf</code> layer to PostGIS, saving the trouble of manually importing the layer and exporting the result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_postgis(x, con, query, prefix = "temporary_nngeo_layer_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_postgis_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code></p>
</td></tr>
<tr><td><code id="st_postgis_+3A_con">con</code></td>
<td>
<p>Connection to PostgreSQL database with PostGIS extension enabled. Can be created using function <code>RPostgreSQL::dbConnect</code></p>
</td></tr>
<tr><td><code id="st_postgis_+3A_query">query</code></td>
<td>
<p>SQL query, which may refer to layer <code>x</code> as <code>x</code> and to the geometry column of the <code>x</code> layer as <code>geom</code> (see examples)</p>
</td></tr>
<tr><td><code id="st_postgis_+3A_prefix">prefix</code></td>
<td>
<p>Prefix for storage of temporarily layer in the database</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returned result from the database: an <code>sf</code> layer in case the result includes a geometry column, otherwise a <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Database connection and 'sf' layer
source("~/Dropbox/postgis_159.R")  ## Creates connection object 'con'
x = towns

# Query 1: Buffer
query = "SELECT ST_Buffer(geom, 0.1, 'quad_segs=2') AS geom FROM x LIMIT 5;"
st_postgis(x, con, query)

# Query 2: Extrusion
query = "SELECT ST_Extrude(geom, 0, 0, 30) AS geom FROM x LIMIT 5;"
st_postgis(x, con, query)

## End(Not run)
</code></pre>

<hr>
<h2 id='st_remove_holes'>Remove polygon holes</h2><span id='topic+st_remove_holes'></span>

<h3>Description</h3>

<p>The function removes all polygon holes and return the modified layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_remove_holes(x, max_area = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_remove_holes_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code>, of type <code>"POLYGON"</code> or <code>"MULTIPOLYGON"</code></p>
</td></tr>
<tr><td><code id="st_remove_holes_+3A_max_area">max_area</code></td>
<td>
<p>Maximum area of holes to be removed (<code>numeric</code>), in the units of <code>x</code> or in <code>[m^2]</code> for layers in geographic projection (lon/lat). Default value (<code>0</code>) causes removing all holes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of same class as <code>x</code>, with holes removed
</p>


<h3>Note</h3>

<p>See function <code><a href="sfheaders.html#topic+sf_remove_holes">sfheaders::sf_remove_holes</a></code> for a highly-optimized faster alternative if you don't need the argument <code>max_area</code>: <a href="https://github.com/dcooley/sfheaders">https://github.com/dcooley/sfheaders</a>
</p>


<h3>References</h3>

<p>Following the StackOverflow answer by user <code>lbusett</code>:
</p>
<p><a href="https://stackoverflow.com/questions/52654701/removing-holes-from-polygons-in-r-sf">https://stackoverflow.com/questions/52654701/removing-holes-from-polygons-in-r-sf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opar = par(mfrow = c(1, 2))

# Example with 'sfg' - POLYGON
p1 = rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4), c(0,0))
p2 = rbind(c(1,1), c(1,2), c(2,2), c(1,1))
pol = st_polygon(list(p1, p2))
pol
result = st_remove_holes(pol)
result
plot(pol, col = "#FF000033", main = "Before")
plot(result, col = "#FF000033", main = "After")

# Example with 'sfg' - MULTIPOLYGON
p3 = rbind(c(3,0), c(4,0), c(4,1), c(3,1), c(3,0))
p4 = rbind(c(3.3,0.3), c(3.8,0.3), c(3.8,0.8), c(3.3,0.8), c(3.3,0.3))[5:1,]
p5 = rbind(c(3,3), c(4,2), c(4,3), c(3,3))
mpol = st_multipolygon(list(list(p1,p2), list(p3,p4), list(p5)))
mpol
result = st_remove_holes(mpol)
result
plot(mpol, col = "#FF000033", main = "Before")
plot(result, col = "#FF000033", main = "After")

# Example with 'sfc' - POLYGON
x = st_sfc(pol, pol * 0.75 + c(3.5, 2))
x
result = st_remove_holes(x)
result
plot(x, col = "#FF000033", main = "Before")
plot(result, col = "#FF000033", main = "After")

# Example with 'sfc' - MULTIPOLYGON
x = st_sfc(pol, mpol * 0.75 + c(3.5, 2))
x
result = st_remove_holes(x)
result
plot(x, col = "#FF000033", main = "Before")
plot(result, col = "#FF000033", main = "After")

par(opar)

# Example with 'sf'
x = st_sfc(pol, mpol * 0.75 + c(3.5, 2))
x = st_sf(geom = x, data.frame(id = 1:length(x)))
result = st_remove_holes(x)
result
plot(x, main = "Before")
plot(result, main = "After")

# Example with 'sf' using argument 'max_area'
x = st_sfc(pol, mpol * 0.75 + c(3.5, 2))
x = st_sf(geom = x, data.frame(id = 1:length(x)))
result = st_remove_holes(x, max_area = 0.4)
result
plot(x, main = "Before")
plot(result, main = "After")
</code></pre>

<hr>
<h2 id='st_segments'>Split polygons or lines to segments</h2><span id='topic+st_segments'></span>

<h3>Description</h3>

<p>Split lines or polygons to separate segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_segments(x, progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_segments_+3A_x">x</code></td>
<td>
<p>An object of class <code>sfg</code>, <code>sfc</code> or <code>sf</code>, with geometry type <code>LINESTRING</code>, <code>MULTILINESTRING</code>, <code>POLYGON</code> or <code>MULTIPOLYGON</code></p>
</td></tr>
<tr><td><code id="st_segments_+3A_progress">progress</code></td>
<td>
<p>Display progress bar? (default <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> layer of type <code>LINESTRING</code> where each segment is represented by a separate feature
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample geometries
s1 = rbind(c(0,3),c(0,4),c(1,5),c(2,5))
ls = st_linestring(s1)
s2 = rbind(c(0.2,3), c(0.2,4), c(1,4.8), c(2,4.8))
s3 = rbind(c(0,4.4), c(0.6,5))
mls = st_multilinestring(list(s1,s2,s3))
p1 = rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4), c(0,0))
p2 = rbind(c(1,1), c(1,2), c(2,2), c(1,1))
pol = st_polygon(list(p1,p2))
p3 = rbind(c(3,0), c(4,0), c(4,1), c(3,1), c(3,0))
p4 = rbind(c(3.3,0.3), c(3.8,0.3), c(3.8,0.8), c(3.3,0.8), c(3.3,0.3))[5:1,]
p5 = rbind(c(3,3), c(4,2), c(4,3), c(3,3))
mpol = st_multipolygon(list(list(p1,p2), list(p3,p4), list(p5)))

# Geometries ('sfg')
opar = par(mfrow = c(1, 2))

plot(ls)
seg = st_segments(ls, progress = FALSE)
plot(seg, col = rainbow(length(seg)))
text(st_coordinates(st_centroid(seg)), as.character(1:length(seg)))

plot(mls)
seg = st_segments(mls, progress = FALSE)
plot(seg, col = rainbow(length(seg)))
text(st_coordinates(st_centroid(seg)), as.character(1:length(seg)))

plot(pol)
seg = st_segments(pol, progress = FALSE)
plot(seg, col = rainbow(length(seg)))
text(st_coordinates(st_centroid(seg)), as.character(1:length(seg)))

plot(mpol)
seg = st_segments(mpol, progress = FALSE)
plot(seg, col = rainbow(length(seg)))
text(st_coordinates(st_centroid(seg)), as.character(1:length(seg)))

par(opar)

# Columns ('sfc')
opar = par(mfrow = c(1, 2))

ls = st_sfc(ls)
plot(ls)
seg = st_segments(ls, progress = FALSE)
plot(seg, col = rainbow(length(seg)))
text(st_coordinates(st_centroid(seg)), as.character(1:length(seg)))

ls2 = st_sfc(c(ls, ls + c(1, -1), ls + c(-3, -1)))
plot(ls2)
seg = st_segments(ls2, progress = FALSE)
plot(seg, col = rainbow(length(seg)))
text(st_coordinates(st_centroid(seg)), as.character(1:length(seg)))

mls = st_sfc(mls)
plot(mls)
seg = st_segments(mls, progress = FALSE)
plot(seg, col = rainbow(length(seg)))
text(st_coordinates(st_centroid(seg)), as.character(1:length(seg)))

mls2 = st_sfc(c(mls, mls + c(1, -2)))
plot(mls2)
seg = st_segments(mls2, progress = FALSE)
plot(seg, col = rainbow(length(seg)))
text(st_coordinates(st_centroid(seg)), as.character(1:length(seg)))

pol = st_sfc(pol)
plot(pol)
seg = st_segments(pol, progress = FALSE)
plot(seg, col = rainbow(length(seg)))
text(st_coordinates(st_centroid(seg)), as.character(1:length(seg)))

mpol = st_sfc(mpol)
plot(mpol)
seg = st_segments(mpol, progress = FALSE)
plot(seg, col = rainbow(length(seg)))
text(st_coordinates(st_centroid(seg)), as.character(1:length(seg)))

mpol2 = st_sfc(c(mpol, mpol + c(5, 2)))
plot(mpol2)
seg = st_segments(mpol2, progress = FALSE)
plot(seg, col = rainbow(length(seg)))
text(st_coordinates(st_centroid(seg)), as.character(1:length(seg)))

par(opar)

# Layers ('sf')
opar = par(mfrow = c(1, 2))

mpol_sf = st_sf(id = 1:2, type = c("a", "b"), geom = st_sfc(c(mpol, mpol + c(5, 2))))
plot(st_geometry(mpol_sf))
seg = st_segments(mpol_sf, progress = FALSE)
plot(st_geometry(seg), col = rainbow(nrow(seg)))
text(st_coordinates(st_centroid(seg)), as.character(1:nrow(seg)))

par(opar)

</code></pre>

<hr>
<h2 id='towns'>Point layer of towns in Israel</h2><span id='topic+towns'></span>

<h3>Description</h3>

<p>A <code>sf</code> POINT layer of towns in Israel, based on a subset from the <code>maps::world.cities</code> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>towns
</code></pre>


<h3>Format</h3>

<p>A <code>sf</code> POINT layer with 193 features and 4 attributes:
</p>

<dl>
<dt>name</dt><dd><p>Town name</p>
</dd>
<dt>country.etc</dt><dd><p>Country name</p>
</dd>
<dt>pop</dt><dd><p>Population size</p>
</dd>
<dt>capital</dt><dd><p>Is it a capital?</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>plot(towns)
</code></pre>

<hr>
<h2 id='water'>Polygonal layer of water bodies in Israel</h2><span id='topic+water'></span>

<h3>Description</h3>

<p>A <code>sf</code> POLYGON layer of the four large water bodies in Israel:
</p>

<ul>
<li><p>Mediterranean Sea
</p>
</li>
<li><p>Red Sea
</p>
</li>
<li><p>Sea of Galilee
</p>
</li>
<li><p>Dead Sea
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>water
</code></pre>


<h3>Format</h3>

<p>A <code>sf</code> POLYGON layer with 4 features and 1 attribute:
</p>

<dl>
<dt>name</dt><dd><p>Water body name</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>plot(water)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
