<!DOCTYPE html><html><head><title>Help for package OTclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OTclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#align'><p>Optimal Transport Alignment</p></a></li>
<li><a href='#clustCPS'><p>CPS Analysis for cluster validation..</p></a></li>
<li><a href='#cplot'><p>Covering Point Set Plot</p></a></li>
<li><a href='#CPS'><p>CPS Analysis on a collection of clustering results</p></a></li>
<li><a href='#ensemble'><p>Generate an ensemble of partitions.</p></a></li>
<li><a href='#jaccard'><p>Jaccard similarity matrix.</p></a></li>
<li><a href='#mplot'><p>Membership Heat Map</p></a></li>
<li><a href='#otclust'><p>Mean partition by optimal transport alignment.</p></a></li>
<li><a href='#otplot'><p>Visualize a partition on 2 dimensional space</p></a></li>
<li><a href='#perturb'><p>Perturb data by adding noise, bootstrapping or mix-up</p></a></li>
<li><a href='#pplot'><p>Point-wise Uncertainty Assessment</p></a></li>
<li><a href='#preprocess'><p>Data preprocessing</p></a></li>
<li><a href='#sim1'><p>Simulated toy data</p></a></li>
<li><a href='#vis_pollen'><p>Single cell gene visualization data from Pollen's paper</p></a></li>
<li><a href='#visCPS'><p>CPS Analysis on selecting visualization method.</p></a></li>
<li><a href='#wassDist'><p>Wasserstein distance between two partitions.</p></a></li>
<li><a href='#YAN'><p>Single cell gene data from Yan's paper</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Mean Partition, Uncertainty Assessment, Cluster Validation and
Visualization Selection for Cluster Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Author:</td>
<td>Lixiang Zhang [aut, cre],
  Beomseok Seo [aut],
  Lin Lin [aut],
  Jia Li [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lixiang Zhang &lt;phoelief@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Providing mean partition for ensemble clustering by optimal transport alignment(OTA), uncertainty measures for both partition-wise and cluster-wise assessment and multiple visualization functions to show uncertainty, for instance, membership heat map and plot of covering point set. A partition refers to an overall clustering result. Jia Li, Beomseok Seo, and Lin Lin (2019) &lt;<a href="https://doi.org/10.1002%2Fsam.11418">doi:10.1002/sam.11418</a>&gt;. Lixiang Zhang, Lin Lin, and Jia Li (2020) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtaa165">doi:10.1093/bioinformatics/btaa165</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tsne, umap, HDclust, dbscan, flexclust,
mclust</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, ggplot2, RColorBrewer, magrittr, class</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-06 06:49:34 UTC; zhanglixiang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-06 14:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='align'>Optimal Transport Alignment</h2><span id='topic+align'></span>

<h3>Description</h3>

<p>This function aligns an ensemble of partitions with a reference partition by optimal transport.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_+3A_data">data</code></td>
<td>
<p>&ndash; a numeric matrix of horizontally stacked cluster labels. Each column contains cluster labels for all the data points according to one clustering result. The reference clustering result is put in the first column, and the first cluster must be labeled as 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of alignment result.
</p>
<table>
<tr><td><code>distance</code></td>
<td>
<p>Wasserstein distances between the reference partition and the others.</p>
</td></tr>
<tr><td><code>numcls</code></td>
<td>
<p>the number of clusters for each partition.</p>
</td></tr>
<tr><td><code>statistics</code></td>
<td>
<p>average tightness ratio, average coverage ratio, 1-average jaccard distance.</p>
</td></tr>
<tr><td><code>cap</code></td>
<td>
<p>cluster alignment and points based (CAP) separability.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>switched labels.</p>
</td></tr>
<tr><td><code>cps</code></td>
<td>
<p>covering point set.</p>
</td></tr>
<tr><td><code>match</code></td>
<td>
<p>topological relationship statistics between the reference partition and the others.</p>
</td></tr>
<tr><td><code>Weight</code></td>
<td>
<p>weight matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
# the number of clusters.
C = 4
# calculate baseline method for comparison.
kcl = kmeans(sim1$X,C)
# align clustering results for convenience of comparison.
compar = align(cbind(sim1$z,kcl$cluster))
</code></pre>

<hr>
<h2 id='clustCPS'>CPS Analysis for cluster validation..</h2><span id='topic+clustCPS'></span>

<h3>Description</h3>

<p>Covering Point Set Analysis for validating clustering results. It conducts alignment among different results and then calculates the covering point set. The return contains several statistics which can be directly used as input for mplot or cplot. If you want to design your own workflow, you can use function CPS instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustCPS(
  data,
  k,
  l = TRUE,
  pre = TRUE,
  noi = "after",
  cmethod = "kmeans",
  dimr = "PCA",
  vis = "tsne",
  ref = NULL,
  nPCA = 50,
  nEXP = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustCPS_+3A_data">data</code></td>
<td>
<p>&ndash; data given in a matrix format, where rows are samples, and columns are variables.</p>
</td></tr>
<tr><td><code id="clustCPS_+3A_k">k</code></td>
<td>
<p>&ndash; number of clusters.</p>
</td></tr>
<tr><td><code id="clustCPS_+3A_l">l</code></td>
<td>
<p>&ndash; logical. If True, log-transformation will be carried out on the data.</p>
</td></tr>
<tr><td><code id="clustCPS_+3A_pre">pre</code></td>
<td>
<p>&ndash; logical. If True, pre-dimension reduction will be carried out based on the variance.</p>
</td></tr>
<tr><td><code id="clustCPS_+3A_noi">noi</code></td>
<td>
<p>&ndash; adding noise before or after the dimension reduction, choosing between &quot;before&quot; and &quot;after&quot;, default &quot;after&quot;.</p>
</td></tr>
<tr><td><code id="clustCPS_+3A_cmethod">cmethod</code></td>
<td>
<p>&ndash; clustering method, choosing from &quot;kmeans&quot; and &quot;mclust&quot;, default &quot;kmeans&quot;.</p>
</td></tr>
<tr><td><code id="clustCPS_+3A_dimr">dimr</code></td>
<td>
<p>&ndash; dimension reduction technique, choose from &quot;none&quot; and &quot;PCA&quot;, default &quot;PCA&quot;.</p>
</td></tr>
<tr><td><code id="clustCPS_+3A_vis">vis</code></td>
<td>
<p>&ndash; the visualization method to be used, such as &quot;tsne&quot; and &quot;umap&quot;, default &quot;tsne&quot;. Also, you can provide your own visualization coordinates in a numeric matrix of two columns.</p>
</td></tr>
<tr><td><code id="clustCPS_+3A_ref">ref</code></td>
<td>
<p>&ndash; optional, clustering result in a vector format and the first cluster is labeled as 1. If provided it will be used as the reference, if not we will generate one.</p>
</td></tr>
<tr><td><code id="clustCPS_+3A_npca">nPCA</code></td>
<td>
<p>&ndash; number of principal components to use, default 50.</p>
</td></tr>
<tr><td><code id="clustCPS_+3A_nexp">nEXP</code></td>
<td>
<p>&ndash; number of perturbed clustering results for CPS Analysis, default 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list used for mplot or cplot, in which tight_all is the overall tightness, member is the matrix used for the membership plot, set is the matrix for the covering point set plot, tight is the vector of cluster-wise tightness, vis is the visualization coordinates, ref is the reference labels and topo is the topological relationship between clusters for point-wise uncertainty assessment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CPS Analysis on validation of clustering result
data(YAN)
# Suppose you generate the visualization coordinates on your own
x1=matrix(seq(1,nrow(YAN),1),ncol=1)
x2=matrix(seq(1,nrow(YAN),1),ncol=1)
# Using nEXP=50 for illustration, usually use nEXP greater 100
y=clustCPS(YAN[,1:100], k=7, l=FALSE, pre=FALSE, noi="after",vis=cbind(x1,x2), nEXP = 50)
# visualization of the results
mplot(y,4)
</code></pre>

<hr>
<h2 id='cplot'>Covering Point Set Plot</h2><span id='topic+cplot'></span>

<h3>Description</h3>

<p>Output the Covering Point Set plot of the required cluster. The return of clustCPS, visCPS or CPS can be directly used as the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplot(result, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplot_+3A_result">result</code></td>
<td>
<p>&ndash; the return from function clustCPS, visCPS or CPS.</p>
</td></tr>
<tr><td><code id="cplot_+3A_k">k</code></td>
<td>
<p>&ndash; which cluster that you want to see the covering point set plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>covering point set plot of the required cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CPS analysis on selection of visualization methods
data(vis_pollen)
c=visCPS(vis_pollen$vis, vis_pollen$ref)
# visualization of the results
mplot(c,2)
cplot(c,2)
</code></pre>

<hr>
<h2 id='CPS'>CPS Analysis on a collection of clustering results</h2><span id='topic+CPS'></span>

<h3>Description</h3>

<p>Covering Point Set Analysis of given clustering results. It conducts alignment among different results and then calculates the covering point set. The return contains several statistics which can be directly used as input for mplot or cplot. By using this function you can design your own workflow instead of using clustCPS, see vignette for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPS(ref, vis, pert)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CPS_+3A_ref">ref</code></td>
<td>
<p>&ndash; the reference clustering result in a vector, the first cluster is labeled as 1.</p>
</td></tr>
<tr><td><code id="CPS_+3A_vis">vis</code></td>
<td>
<p>&ndash; the visualization coordinates in a numeric matrix of two columns.</p>
</td></tr>
<tr><td><code id="CPS_+3A_pert">pert</code></td>
<td>
<p>&ndash; a collection of clustering results in a matrix format, each column represents one clustering result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list used for mplot or cplot, in which tight_all is the overall tightness, member is the matrix used for the membership heat map, set is the matrix for the covering point set plot, tight is the vector of cluster-wise tightness, vis is the visualization coordinates, ref is the reference labels and topo is the topological relationship between clusters for point-wise uncertainty assessment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CPS analysis on selection of visualization methods
data(vis_pollen)
k1=kmeans(vis_pollen$vis,max(vis_pollen$ref))$cluster
k2=kmeans(vis_pollen$vis,max(vis_pollen$ref))$cluster
k=cbind(as.matrix(k1,ncol=1),as.matrix(k2,ncol=1))
c=CPS(vis_pollen$ref, vis_pollen$vis, pert=k)
# visualization of the results
mplot(c,2)
cplot(c,2)
</code></pre>

<hr>
<h2 id='ensemble'>Generate an ensemble of partitions.</h2><span id='topic+ensemble'></span>

<h3>Description</h3>

<p>Generate multiple clustering results (that is, partitions) based on multiple versions of perturbed data using a specified baseline clustering method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble(data, nbs, clust_param, clustering = "kmeans", perturb_method = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensemble_+3A_data">data</code></td>
<td>
<p>&ndash; data that will be perturbed.</p>
</td></tr>
<tr><td><code id="ensemble_+3A_nbs">nbs</code></td>
<td>
<p>&ndash; the number of clustering partitions to be generated.</p>
</td></tr>
<tr><td><code id="ensemble_+3A_clust_param">clust_param</code></td>
<td>
<p>&ndash; parameters for pre-defined clustering methods. If clustering is &quot;kmeans&quot;, &quot;Mclust&quot;, &quot;hclust&quot;, this is an integer indicating the number of clusters. For &quot;dbscan&quot;, a numeric indicating epsilon. For &quot;HMM-VB&quot;, a list of parameters.</p>
</td></tr>
<tr><td><code id="ensemble_+3A_clustering">clustering</code></td>
<td>
<p>&ndash; baseline clustering methods. User specified functions or example methods included in package (&quot;kmeans&quot;, &quot;Mclust&quot;, &quot;hclust&quot;, &quot;dbscan&quot;, &quot;HMM-VB&quot;) can be used. Refer to the Detail.</p>
</td></tr>
<tr><td><code id="ensemble_+3A_perturb_method">perturb_method</code></td>
<td>
<p>&ndash; adding noise is <code>0</code> and bootstrap resampling is <code>1</code>. Default is bootstrap resampling.
# perturb_method=0 perturbed by adding Gaussian noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of cluster labels of the ensemble partitions. Each column is cluster labels of an individual clustering result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
# the number of clusters.
C = 4
ens.data = ensemble(sim1$X[1:10,], nbs=10, clust_param=C, clustering="kmeans", perturb_method=1)
</code></pre>

<hr>
<h2 id='jaccard'>Jaccard similarity matrix.</h2><span id='topic+jaccard'></span>

<h3>Description</h3>

<p>This function calculates Jaccard similarity matrix between two partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccard(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jaccard_+3A_x">x</code>, <code id="jaccard_+3A_y">y</code></td>
<td>
<p>&ndash; vectors of cluster labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of Jaccard similarity between clusters in two partitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=c(1,2,3)
y=c(3,2,1)
jaccard(x,y)
</code></pre>

<hr>
<h2 id='mplot'>Membership Heat Map</h2><span id='topic+mplot'></span>

<h3>Description</h3>

<p>Output the membership heat map of the required cluster. The return of clustCPS, visCPS or CPS can be directly used as the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mplot(result, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mplot_+3A_result">result</code></td>
<td>
<p>&ndash; the return from function clustCPS, visCPS or CPS.</p>
</td></tr>
<tr><td><code id="mplot_+3A_k">k</code></td>
<td>
<p>&ndash; which cluster that you want to see the membership heat map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>membership heat map of the required cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CPS analysis on selection of visualization methods
data(vis_pollen)
c=visCPS(vis_pollen$vis, vis_pollen$ref)
# visualization of the results
mplot(c,2)
cplot(c,2)
</code></pre>

<hr>
<h2 id='otclust'>Mean partition by optimal transport alignment.</h2><span id='topic+otclust'></span>

<h3>Description</h3>

<p>This function calculates the mean partition of an ensemble of partitions by optimal transport alignment and uncertainty/stability measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otclust(ensemble, idx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otclust_+3A_ensemble">ensemble</code></td>
<td>
<p>&ndash; a matrix of ensemble partition. Use <code>ensemble()</code> to generate an ensemble of perturbed partitions.</p>
</td></tr>
<tr><td><code id="otclust_+3A_idx">idx</code></td>
<td>
<p>&ndash; an integer indicating the index of reference partition in <code>ensemble</code>. If not specified, median partition is used as the reference partition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of alignment result.
</p>
<table>
<tr><td><code>idx</code></td>
<td>
<p>the index of reference partition.</p>
</td></tr>
<tr><td><code>avedist</code></td>
<td>
<p>average distances between each partition and all ensemble partitions.</p>
</td></tr>
<tr><td><code>meanpart</code></td>
<td>
<p>a list of mean partition.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>Wasserstein distances between mean partition and the others.</p>
</td></tr>
<tr><td><code>numcls</code></td>
<td>
<p>the number of clusters for each partition.</p>
</td></tr>
<tr><td><code>statistics</code></td>
<td>
<p>average tightness ratio, average coverage ratio, 1-average jaccard distance.</p>
</td></tr>
<tr><td><code>cap</code></td>
<td>
<p>cluster alignment and points based (CAP) separability.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>switched labels.</p>
</td></tr>
<tr><td><code>cps</code></td>
<td>
<p>covering point set.</p>
</td></tr>
<tr><td><code>match</code></td>
<td>
<p>topological relationship statistics between the reference partition and the others.</p>
</td></tr>
<tr><td><code>Weight</code></td>
<td>
<p>weight matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
# the number of clusters.
C = 4
ens.data = ensemble(sim1$X[1:100,], nbs=10, clust_param=C, clustering="kmeans", perturb_method=1)
# find mean partition and uncertainty statistics.
ota = otclust(ens.data)
</code></pre>

<hr>
<h2 id='otplot'>Visualize a partition on 2 dimensional space</h2><span id='topic+otplot'></span>

<h3>Description</h3>

<p>This function plots a partition on 2 dimensional reduced space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otplot(
  data,
  labels,
  convex.hull = F,
  title = "",
  xlab = "",
  ylab = "",
  legend.title = "",
  legend.labels = NULL,
  add.text = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otplot_+3A_data">data</code></td>
<td>
<p>&ndash; coordinates matrix of data.</p>
</td></tr>
<tr><td><code id="otplot_+3A_labels">labels</code></td>
<td>
<p>&ndash; cluster labels in a vector, the first cluster is labeled as 1.</p>
</td></tr>
<tr><td><code id="otplot_+3A_convex.hull">convex.hull</code></td>
<td>
<p>&ndash; logical. If it is <code>True</code>, the plot draws convex hull for each cluster.</p>
</td></tr>
<tr><td><code id="otplot_+3A_title">title</code></td>
<td>
<p>&ndash; title</p>
</td></tr>
<tr><td><code id="otplot_+3A_xlab">xlab</code></td>
<td>
<p>&ndash; xlab</p>
</td></tr>
<tr><td><code id="otplot_+3A_ylab">ylab</code></td>
<td>
<p>&ndash; ylab</p>
</td></tr>
<tr><td><code id="otplot_+3A_legend.title">legend.title</code></td>
<td>
<p>&ndash; legend title</p>
</td></tr>
<tr><td><code id="otplot_+3A_legend.labels">legend.labels</code></td>
<td>
<p>&ndash; legend labels</p>
</td></tr>
<tr><td><code id="otplot_+3A_add.text">add.text</code></td>
<td>
<p>&ndash; default True</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
# the number of clusters.
C = 4
ens.data = ensemble(sim1$X[1:50,], nbs=50, clust_param=C, clustering="kmeans", perturb_method=1)

# find mean partition and uncertainty statistics.
ota = otclust(ens.data)
# calculate baseline method for comparison.
kcl = kmeans(sim1$X[1:50],C)

# align clustering results for convenience of comparison.
compar = align(cbind(sim1$z[1:50],kcl$cluster,ota$meanpart))
lab.match = lapply(compar$weight,function(x) apply(x,2,which.max))
kcl.algnd = match(kcl$cluster,lab.match[[1]])
ota.algnd = match(ota$meanpart,lab.match[[2]])
# plot the result on two dimensional space.
otplot(sim1$X[1:50,],ota.algnd,con=FALSE,title='Mean partition')   # mean partition by OTclust
</code></pre>

<hr>
<h2 id='perturb'>Perturb data by adding noise, bootstrapping or mix-up</h2><span id='topic+perturb'></span>

<h3>Description</h3>

<p>Perturb data by adding Gaussian noise, bootstrap resampling or mix-up. Gaussian noise has mean 0 and variance 0.01*average variance of all variables. The mix-up lambda is 0.9.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturb(data, method = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perturb_+3A_data">data</code></td>
<td>
<p>&ndash; data that will be perturbed.</p>
</td></tr>
<tr><td><code id="perturb_+3A_method">method</code></td>
<td>
<p>&ndash; adding noise is <code>0</code>, bootstrapping is <code>1</code> and mix-up is <code>2</code>. Default is adding noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the perturbed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vis_pollen)
perturb(as.matrix(vis_pollen$vis),method=0)
</code></pre>

<hr>
<h2 id='pplot'>Point-wise Uncertainty Assessment</h2><span id='topic+pplot'></span>

<h3>Description</h3>

<p>Output both the numerical and graphical point-wise uncertainty assessment for each individual points. The return of clustCPS, visCPS or CPS can be directly used as the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pplot(result, method = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pplot_+3A_result">result</code></td>
<td>
<p>&ndash; the return from function clustCPS, visCPS or CPS.</p>
</td></tr>
<tr><td><code id="pplot_+3A_method">method</code></td>
<td>
<p>&ndash; method for calculating point-wise uncertainty. Using posterior probability matrix is <code>0</code> and using topological information between clusters is <code>1</code>. Default is using posterior probability matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list, in which P is the posterior probability matrix that each sample below to the reference clusters, point_stab is the point-wise stability for each sample and v is the visualization of the point-wise stability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CPS analysis on selection of visualization methods
data(vis_pollen)
k1=kmeans(vis_pollen$vis,max(vis_pollen$ref))$cluster
k2=kmeans(vis_pollen$vis,max(vis_pollen$ref))$cluster
k=cbind(as.matrix(k1,ncol=1),as.matrix(k2,ncol=1))
c=CPS(vis_pollen$ref, vis_pollen$vis, pert=k)
# Point-wise Uncertainty Assessment
pplot(c)
</code></pre>

<hr>
<h2 id='preprocess'>Data preprocessing</h2><span id='topic+preprocess'></span>

<h3>Description</h3>

<p>Preprocessing for dimension reduction based on variance, it will delete the variable whose variance is smaller than 0.5*mean variance of all variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess(data, l = TRUE, pre = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_+3A_data">data</code></td>
<td>
<p>&ndash; data that needs to be processed</p>
</td></tr>
<tr><td><code id="preprocess_+3A_l">l</code></td>
<td>
<p>&ndash; logical. If True, log-transformation will be carried out on the data.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_pre">pre</code></td>
<td>
<p>&ndash; logical. If True, pre-dimension reduction will be carried out based on the variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the processed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(YAN)
preprocess(YAN,l=FALSE,pre=TRUE)
</code></pre>

<hr>
<h2 id='sim1'>Simulated toy data</h2><span id='topic+sim1'></span>

<h3>Description</h3>

<p>A dataset containing 5000 samples and 2 features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim1
</code></pre>


<h3>Format</h3>

<p>A matrix with 5000 rows and 2 variables
</p>

<hr>
<h2 id='vis_pollen'>Single cell gene visualization data from Pollen's paper</h2><span id='topic+vis_pollen'></span>

<h3>Description</h3>

<p>A dataset containing the visualization coordinates and the true cluster labels of 301 cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_pollen
</code></pre>


<h3>Format</h3>

<p>A list containing two components
</p>

<dl>
<dt>vis</dt><dd><p>visualization coordinates of cells</p>
</dd>
<dt>ref</dt><dd><p>true labels of cells</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.nature.com/articles/nbt.2967">https://www.nature.com/articles/nbt.2967</a>
</p>

<hr>
<h2 id='visCPS'>CPS Analysis on selecting visualization method.</h2><span id='topic+visCPS'></span>

<h3>Description</h3>

<p>Covering Point Set Analysis on the visualization results. Use K-Nearest Neighbor to generate a collection of results for CPS Analysis. The return contains several statistics which can be directly used as input for mplot or cplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visCPS(vlab, ref, nEXP = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visCPS_+3A_vlab">vlab</code></td>
<td>
<p>&ndash; the coordinates generated by one visualization method in a numeric matrix of two columns.</p>
</td></tr>
<tr><td><code id="visCPS_+3A_ref">ref</code></td>
<td>
<p>&ndash; the true labels in a vector format, the first cluster is labeled as 1.</p>
</td></tr>
<tr><td><code id="visCPS_+3A_nexp">nEXP</code></td>
<td>
<p>&ndash; number of perturbed results for CPS Analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list used for mplot or cplot, in which tight_all is the overall tightness, member is the matrix used for the membership heat map, set is the matrix for the covering point set plot, tight is the vector of cluster-wise tightness, vis is the visualization coordinates, ref is the reference labels and topo is the topological relationship between clusters for point-wise uncertainty assessment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CPS analysis on selection of visualization methods
data(vis_pollen)
c=visCPS(vis_pollen$vis, vis_pollen$ref)
# visualization of the results
mplot(c,2)
cplot(c,2)
</code></pre>

<hr>
<h2 id='wassDist'>Wasserstein distance between two partitions.</h2><span id='topic+wassDist'></span>

<h3>Description</h3>

<p>This function calculates Wasserstein distance between two partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wassDist(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wassDist_+3A_x">x</code>, <code id="wassDist_+3A_y">y</code></td>
<td>
<p>&ndash; vectors of cluster labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=c(1,2,3)
y=c(3,2,1)
wassDist(x,y)
</code></pre>

<hr>
<h2 id='YAN'>Single cell gene data from Yan's paper</h2><span id='topic+YAN'></span>

<h3>Description</h3>

<p>A dataset containing 124 cells with their 3840 genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YAN
</code></pre>


<h3>Format</h3>

<p>A matrix with 124 rows and 3840 variables
</p>


<h3>Source</h3>

<p><a href="https://www.nature.com/articles/nsmb.2660">https://www.nature.com/articles/nsmb.2660</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
