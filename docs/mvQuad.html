<!DOCTYPE html><html><head><title>Help for package mvQuad</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvQuad}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mvQuad-package'>
<p>Methods for multivariate Quadrature (numerical integration)</p></a></li>
<li><a href='#copyNIGrid'><p>copies an NIGrid-object</p></a></li>
<li><a href='#createNIGrid'><p>creates a grid for numerical integration.</p></a></li>
<li><a href='#getNodes and getWeights'><p>get nodes and weights from an NIGrid-object</p></a></li>
<li><a href='#plot (plot.NIGrid)'><p>plots an NIGrid-object</p></a></li>
<li><a href='#print (print.NIGrid)'><p>prints characteristic information for an NIGrid-object</p></a></li>
<li><a href='#quadrature'><p>computes the approximated Integral</p></a></li>
<li><a href='#QuadRules'><p>nodes and weights for 1D - Gauss-Quadrature</p></a></li>
<li><a href='#readRule'><p>reads a quadrature-rule from a text file</p></a></li>
<li><a href='#rescale (rescale.NIGrid)'><p>moves, rescales and/or rotates a multidimensional grid.</p></a></li>
<li><a href='#size (size.NIGrid)'><p>returns the size of an NIGrid-object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Multivariate Quadrature</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Constantin Weiser ( University Mainz / Germany)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Constantin Weiser &lt;constantin.weiser@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods to construct multivariate grids, which can be used
    for multivariate quadrature. This grids can be based on different quadrature
    rules like Newton-Cotes formulas (trapezoidal-, Simpson's- rule, ...) or Gauss
    quadrature (Gauss-Hermite, Gauss-Legendre, ...). For the construction of the
    multidimensional grid the product-rule or the combination- technique can be
    applied.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/weiserc/mvQuad/">https://github.com/weiserc/mvQuad/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, statmod, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rgl, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-19 10:53:01 UTC; weiserc</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-19 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mvQuad-package'>
Methods for multivariate Quadrature (numerical integration)
</h2><span id='topic+mvQuad-package'></span><span id='topic+mvQuad'></span>

<h3>Description</h3>

<p>This package provides methods to construct multivariate grids, which can be
used for multivariate quadrature. This grids can be based on different quadrature
rules like Newton-Cotes formulas (trapezoidal-, Simpson-rule, ...) or Gauss-Quadrature
(Gauss-Hermite, Gauss-Legendre, ...). For the construction of the multidimensional
grid the product-rule or the combination-technique can be applied.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> mvQuad</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-09-18</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Constantin Weiser (University Mainz / Germany)
Maintainer: Constantin Weiser &lt;constantin.weiser@gmail.com&gt;
</p>


<h3>References</h3>

<p>Philip J. Davis, Philip Rabinowitz (1984): Methods of Numerical Integration
</p>
<p>F. Heiss, V. Winschel (2008): Likelihood approximation by numerical integration on sparse grids, Journal of Econometrics
</p>
<p>H.-J. Bungartz, M. Griebel (2004): Sparse grids, Acta Numerica
</p>
<p>Peter Jaeckel (2005): A note on multivariate Gauss-Hermite quadrature
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myGrid &lt;- createNIGrid(dim=2, type="GLe", level=5)
rescale(myGrid, domain=rbind(c(-1,1),c(-1,1)))
print(myGrid)
plot(myGrid, col="blue")
myFun &lt;- function(x){
   1 - x[,1]^2 * x[,2]^2
}
quadrature(myFun, myGrid)
</code></pre>

<hr>
<h2 id='copyNIGrid'>copies an NIGrid-object</h2><span id='topic+copyNIGrid'></span>

<h3>Description</h3>

<p><code>copyNIGrid</code> copies an NIGrid-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copyNIGrid(object1, object2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copyNIGrid_+3A_object1">object1</code></td>
<td>
<p>original NIGrid-object</p>
</td></tr>
<tr><td><code id="copyNIGrid_+3A_object2">object2</code></td>
<td>
<p>destination; if NULL <code>copyNIGrid</code> returns a NIGrid-object
otherwise the <code>object2</code> will be overwritten.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a NIGrid-object or NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myGrid &lt;- createNIGrid(dim=2, type="GHe", level=5)
myGrid.copy &lt;- copyNIGrid(myGrid)
</code></pre>

<hr>
<h2 id='createNIGrid'>creates a grid for numerical integration.</h2><span id='topic+createNIGrid'></span>

<h3>Description</h3>

<p><code>createNIGrid</code> Creates a grid for multivariate numerical integration.
The Grid can be based on different quadrature- and construction-rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createNIGrid(dim = NULL, type = NULL, level = NULL,
  ndConstruction = "product", level.trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createNIGrid_+3A_dim">dim</code></td>
<td>
<p>number of dimensions</p>
</td></tr>
<tr><td><code id="createNIGrid_+3A_type">type</code></td>
<td>
<p>quadrature rule (see Details)</p>
</td></tr>
<tr><td><code id="createNIGrid_+3A_level">level</code></td>
<td>
<p>accuracy level (typically number of grid points for the underlying 1D quadrature rule)</p>
</td></tr>
<tr><td><code id="createNIGrid_+3A_ndconstruction">ndConstruction</code></td>
<td>
<p>character vector which denotes the construction rule
for multidimensional grids.
</p>

<dl>
<dt><code>product</code></dt><dd><p>for product rule, returns a &quot;full grid&quot; (default)</p>
</dd>
<dt><code>sparse</code></dt><dd><p>for combination technique, leads to a regular &quot;sparse grid&quot;.</p>
</dd></dl>
</td></tr>
<tr><td><code id="createNIGrid_+3A_level.trans">level.trans</code></td>
<td>
<p>logical variable denotes either to take the levels as number
of grid points (FALSE = default) or to transform in that manner that number of
grid points = 2^(levels-1) (TRUE). Alternatively <code>level.trans</code> can be a function, which takes (n x d)-matrix and returns
a matrix with the same dimensions (see the example; this feature is particularly useful for the 'sparse' construction rule,
to account for different importance of the dimensions).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following quadrature rules are supported (build-in).
</p>

<dl>
<dt><code>cNC1, cNC2, ..., cNC6</code></dt><dd><p>closed Newton-Cotes Formula of degree 1-6 (1=trapezoidal-rule; 2=Simpson's-rule; ...),
initial interval of integration: [0, 1]</p>
</dd>
<dt><code>oNC0, oNC1, ..., oNC3</code></dt><dd><p>open Newton-Cote Formula of degree 0-3 (0=midpoint-rule; ...),
initial interval of integration: [0, 1]</p>
</dd>
<dt><code>GLe, GKr</code></dt><dd><p>Gauss-Legendre and Gauss-Kronrod rule for an initial interval of integration: [0, 1]</p>
</dd>
<dt><code>nLe</code></dt><dd><p>nested Gauss-Legendre rule for an initial interval of integration: [0, 1] (Knut Petras (2003). Smolyak cubature of given polynomial degree with few nodes for increasing dimension. Numerische Mathematik 93, 729-753)</p>
</dd>
<dt><code>GLa</code></dt><dd><p>Gauss-Laguerre rule for an initial interval of integration: [0, INF)</p>
</dd>
<dt><code>GHe</code></dt><dd><p>Gauss-Hermite rule for an initial interval of integration: (-INF, INF)</p>
</dd>
<dt><code>nHe</code></dt><dd><p>nested Gauss-Hermite rule for an initial interval of integration: (-INF, INF) (A. Genz and B. D. Keister (1996). Fully symmetric interpolatory rules for multiple integrals over infinite regions with Gaussian weight.&quot; Journal of Computational and Applied Mathematics 71, 299-309)</p>
</dd>
<dt><code>GHN</code>, <code>nHN</code></dt><dd><p>(nested) Gauss-Hermite rule as before but weights are multiplied by the standard normal density (<code class="reqn">\hat(w)_i = w_i * \phi(x_i)</code>).</p>
</dd>
<dt><code>Leja</code></dt><dd><p>Leja-Points for an initial interval of integration: [0, 1]</p>
</dd></dl>

<p>The argument <code>type</code> and <code>level</code> can also be vector-value, different for each dimension (the later only for &quot;product rule&quot;; see examples)
</p>


<h3>Value</h3>

<p>Returns an object of class 'NIGrid'. This object is basically an environment
containing nodes and weights and a list of features for this special grid. This
grid can be used for numerical integration (via <code><a href="#topic+quadrature">quadrature</a></code>)
</p>


<h3>References</h3>

<p>Philip J. Davis, Philip Rabinowitz (1984): Methods of Numerical Integration
</p>
<p>F. Heiss, V. Winschel (2008): Likelihood approximation by numerical integration on sparse grids, Journal of Econometrics
</p>
<p>H.-J. Bungartz, M. Griebel (2004): Sparse grids, Acta Numerica
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rescale.NIGrid">rescale</a></code>, <code><a href="#topic+quadrature">quadrature</a></code>, <code><a href="#topic+print.NIGrid">print</a></code>, <code><a href="#topic+plot.NIGrid">plot</a></code> and <code><a href="#topic+size.NIGrid">size</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1D-Grid --&gt; closed Newton-Cotes Formula of degree 1 (trapeziodal-rule)
myGrid &lt;- createNIGrid(dim=1, type="cNC1", level=10)
print(myGrid)
## 2D-Grid --&gt; nested Gauss-Legendre rule
myGrid &lt;- createNIGrid(dim=2, type=c("GLe","nLe"), level=c(4, 7))
rescale(myGrid, domain = rbind(c(-1,1),c(-1,1)))
plot(myGrid)
print(myGrid)
myFun &lt;- function(x){
   1-x[,1]^2*x[,2]^2
}
quadrature(f = myFun, grid = myGrid)
## level transformation
levelTrans &lt;- function(x){
  tmp &lt;- as.matrix(x)
  tmp[, 2] &lt;- 2*tmp[ ,2]
  return(tmp)
}
nw &lt;- createNIGrid(dim=2, type="cNC1", level = 3,
   level.trans = levelTrans, ndConstruction = "sparse")
plot(nw)
</code></pre>

<hr>
<h2 id='getNodes+20and+20getWeights'>get nodes and weights from an NIGrid-object</h2><span id='topic+getNodes'></span><span id='topic+getNodes+20and+20getWeights'></span><span id='topic+getWeights'></span>

<h3>Description</h3>

<p><code>getNodes</code> and <code>getWeights</code> extract the (potentially rescaled) nodes and weights
out of an NIGrid-Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNodes(grid)

getWeights(grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNodes+2B20and+2B20getWeights_+3A_grid">grid</code></td>
<td>
<p>object of class <code>NIGrid</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the nodes or weights of the given grid
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createNIGrid">createNIGrid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myGrid &lt;- createNIGrid(dim=2, type="cNC1", level=3)
getNodes(myGrid)
getWeights(myGrid)
</code></pre>

<hr>
<h2 id='plot+20+28plot.NIGrid+29'>plots an NIGrid-object</h2><span id='topic+plot+20+28plot.NIGrid+29'></span><span id='topic+plot.NIGrid'></span>

<h3>Description</h3>

<p>Plots the grid points of an NIGrid-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NIGrid'
plot(x, plot.dimension = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B20+2B28plot.NIGrid+2B29_+3A_x">x</code></td>
<td>
<p>a grid of type <code>NIGrid</code></p>
</td></tr>
<tr><td><code id="plot+2B20+2B28plot.NIGrid+2B29_+3A_plot.dimension">plot.dimension</code></td>
<td>
<p>vector of length 1, 2 or 3. with the dimensions to be plotted
(see examples)</p>
</td></tr>
<tr><td><code id="plot+2B20+2B28plot.NIGrid+2B29_+3A_...">...</code></td>
<td>
<p>arguments passed to the default plot command</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myGrid &lt;- createNIGrid(dim=4, type=c("GHe", "cNC1", "GLe", "oNC1"),
                       level=c(3,4,5,6))
plot(myGrid) ## dimension 1-min(3,dim(myGrid)) are plotted
## Free arranged plots
plot(myGrid, plot.dimension=c(4,2,1))
plot(myGrid, plot.dimension=c(1,2))
plot(myGrid, plot.dimension=c(3))
</code></pre>

<hr>
<h2 id='print+20+28print.NIGrid+29'>prints characteristic information for an NIGrid-object</h2><span id='topic+print+20+28print.NIGrid+29'></span><span id='topic+print.NIGrid'></span>

<h3>Description</h3>

<p>Prints characteristic information for an NIGrid-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NIGrid'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B20+2B28print.NIGrid+2B29_+3A_x">x</code></td>
<td>
<p>a grid of type <code>NIGrid</code></p>
</td></tr>
<tr><td><code id="print+2B20+2B28print.NIGrid+2B29_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the information for an NIGrid-object (i.a. grid size (dimensions, grid points, memory usage),
type and support)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myGrid &lt;- createNIGrid(dim=2, type="GHe", level=5)
print(myGrid)
</code></pre>

<hr>
<h2 id='quadrature'>computes the approximated Integral</h2><span id='topic+quadrature'></span>

<h3>Description</h3>

<p><code>quadrature</code> computes the integral for a given function based on an NIGrid-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadrature(f, grid = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadrature_+3A_f">f</code></td>
<td>
<p>a function which takes the x-values as a (n x d) matrix as a first argument</p>
</td></tr>
<tr><td><code id="quadrature_+3A_grid">grid</code></td>
<td>
<p>a grid of type <code>NIGrid</code></p>
</td></tr>
<tr><td><code id="quadrature_+3A_...">...</code></td>
<td>
<p>further arguments for the function <code>f</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The approximated value of the integral
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createNIGrid">createNIGrid</a></code>, <code><a href="#topic+rescale.NIGrid">rescale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myGrid &lt;- createNIGrid(dim=2, type="GLe", level=5)
rescale(myGrid, domain=rbind(c(-1,1),c(-1,1)))
plot(myGrid, col="blue")
myFun &lt;- function(x){
   1 - x[,1]^2 * x[,2]^2
}
quadrature(myFun, myGrid)
</code></pre>

<hr>
<h2 id='QuadRules'>nodes and weights for 1D - Gauss-Quadrature</h2><span id='topic+QuadRules'></span>

<h3>Description</h3>

<p>This data set stores nodes an weights for Gauss-Quadrature.
Syntax:
</p>
<p>QuadRules[['type']][['level']]
</p>

<ul>
<li><p> type=&quot;<b>GLe</b>&quot; Gauss-Legendre; interval [0,1]; max-level 45
</p>
</li>
<li><p> type=&quot;<b>nLe</b>&quot; nested-type Gauss-Legendre; interval [0,1]; max-level 25
</p>
</li>
<li><p> type=&quot;<b>GKr</b>&quot; Gauss-Kronrod; interval [0,1]; max-level 29
</p>
</li>
<li><p> type=&quot;<b>GLa</b>&quot; Gauss-Laguere; interval [0, Inf); max-level 30
</p>
</li>
<li><p> type=&quot;<b>GHe</b>&quot; Gauss-Hermite; interval (-Inf, Inf); max-level 45
</p>
</li>
<li><p> type=&quot;<b>GHN</b>&quot; Gauss-Hermite (as above, but pre-multiplied weights <code class="reqn">\hat(w)_i = w_i * \phi(x_i)</code>)
</p>
</li>
<li><p> type=&quot;<b>nHe</b>&quot; nested-type Gauss-Hermite; interval (-Inf, Inf) max-level 25
</p>
</li>
<li><p> type=&quot;<b>nHN</b>&quot; nested-type Gauss-Hermite (as above, but pre-multiplied weights <code class="reqn">\hat(w)_i = w_i * \phi(x_i)</code>)
</p>
</li>
<li><p> type=&quot;<b>Leja</b>&quot; Leja-points; interval [0,1]; max-level 141
</p>
</li></ul>



<h3>Format</h3>

<p>list of nodes and weights (for organisation see &quot;Syntax&quot; in description section)</p>


<h3>Source</h3>

<p> - http://keisan.casio.com/exec/system/1329114617 high precission computing (for G..-rules)
</p>
<p>- further information in <code><a href="#topic+createNIGrid">createNIGrid</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- QuadRules[["GHe"]][[2]]</code></pre>

<hr>
<h2 id='readRule'>reads a quadrature-rule from a text file</h2><span id='topic+readRule'></span>

<h3>Description</h3>

<p><code>readRule</code> reads a quadrature-rule from a text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readRule(file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readRule_+3A_file">file</code></td>
<td>
<p>file name of the text file containing the quadrature rule</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The text file containing the quadrature rule has to be formatted in the following way:
</p>
<p>The first line have to declare the domain <code>initial.domain a b</code>, where a and b denotes the lower and upper-bound for the integration domain.
This can be either a number or '-Inf'/'Inf' (for example <code>initial.domain 0 1</code> or <code>initial.domain 0 Inf</code>)
</p>
<p>Every following line contains one single node and weight belonging to one level of the rule (format: 'level' 'node' 'weight').
This example shows the use for the &quot;midpoint-rule&quot; (levels: 1 - 3).
</p>
<p>&gt; <code>initial.domain 0 1</code>
</p>
<p>&gt; <code>1 0.5 1</code>
</p>
<p>&gt; <code>2 0.25 0.5</code>
</p>
<p>&gt; <code>2 0.75 0.5</code>
</p>
<p>&gt; <code>3 0.166666666666667 0.333333333333333</code>
</p>
<p>&gt; <code>3 0.5 0.333333333333333</code>
</p>
<p>&gt; <code>3 0.833333333333333 0.333333333333333</code>
</p>


<h3>Value</h3>

<p>Returns an object of class 'customRule', which can be used for creating a 'NIGrid' (<code><a href="#topic+createNIGrid">createNIGrid</a></code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createNIGrid">createNIGrid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: myRule &lt;- readRule(file="midpoint_rule.txt")
## Not run: nw &lt;- createNIGrid(d=1, type = myRule.txt, level = 2)
</code></pre>

<hr>
<h2 id='rescale+20+28rescale.NIGrid+29'>moves, rescales and/or rotates a multidimensional grid.</h2><span id='topic+rescale'></span><span id='topic+rescale+20+28rescale.NIGrid+29'></span><span id='topic+rescale.NIGrid'></span>

<h3>Description</h3>

<p><code>rescale.NIGrid</code> manipulates a grid for more efficient numerical integration with
respect to a given domain (bounded integral) or vector
of means and covariance matrix (unbounded integral).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale(object, ...)

## S3 method for class 'NIGrid'
rescale(object, domain = NULL, m = NULL, C = NULL,
  dec.type = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale+2B20+2B28rescale.NIGrid+2B29_+3A_object">object</code></td>
<td>
<p>an initial grid of type <code>NIGrid</code></p>
</td></tr>
<tr><td><code id="rescale+2B20+2B28rescale.NIGrid+2B29_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="rescale+2B20+2B28rescale.NIGrid+2B29_+3A_domain">domain</code></td>
<td>
<p>a (d x 2)-matrix with the boundaries for each dimension</p>
</td></tr>
<tr><td><code id="rescale+2B20+2B28rescale.NIGrid+2B29_+3A_m">m</code></td>
<td>
<p>vector of means</p>
</td></tr>
<tr><td><code id="rescale+2B20+2B28rescale.NIGrid+2B29_+3A_c">C</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="rescale+2B20+2B28rescale.NIGrid+2B29_+3A_dec.type">dec.type</code></td>
<td>
<p>type of covariance decomposition (<cite>Peter Jaeckel (2005)</cite>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function modifies the &quot;support-attribute&quot; of the grid. The
recalculation of the nodes and weights is done when the <code><a href="#topic+getNodes">getNodes</a></code> or <code><a href="#topic+getWeights">getWeights</a></code>
are used.
</p>


<h3>References</h3>

<p>Peter Jaeckel (2005): A note on multivariate Gauss-Hermite quadrature
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadrature">quadrature</a></code>, <code><a href="#topic+createNIGrid">createNIGrid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C = matrix(c(2,0.9,0.9,2),2)
m = c(-.5, .3)
par(mfrow=c(3,1))

myGrid &lt;- createNIGrid(dim=2, type="GHe", level=5)

rescale(myGrid, m=m, C=C, dec.type=0)
plot(myGrid, col="red")

rescale(myGrid, m=m, C=C, dec.type=1)
plot(myGrid, col="green")

rescale(myGrid, m=m, C=C, dec.type=2)
plot(myGrid, col="blue")
</code></pre>

<hr>
<h2 id='size+20+28size.NIGrid+29'>returns the size of an NIGrid-object</h2><span id='topic+dim.NIGrid'></span><span id='topic+size'></span><span id='topic+size+20+28size.NIGrid+29'></span><span id='topic+size.NIGrid'></span>

<h3>Description</h3>

<p>Returns the size of an NIGrid-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size(object, ...)

## S3 method for class 'NIGrid'
size(object, ...)

## S3 method for class 'NIGrid'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size+2B20+2B28size.NIGrid+2B29_+3A_object">object</code></td>
<td>
<p>a grid of type <code>NIGrid</code></p>
</td></tr>
<tr><td><code id="size+2B20+2B28size.NIGrid+2B29_+3A_...">...</code></td>
<td>
<p>other arguments passed to the specific method</p>
</td></tr>
<tr><td><code id="size+2B20+2B28size.NIGrid+2B29_+3A_x">x</code></td>
<td>
<p>object of type <code>NIGrid</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the grid size in terms of dimensions, number of grid points and used memory
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myGrid &lt;- createNIGrid(dim=2, type="GHe", level=5)
size(myGrid)
dim(myGrid)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
