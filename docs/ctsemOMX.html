<!DOCTYPE html><html><head><title>Help for package ctsemOMX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ctsemOMX}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AnomAuth'><p>AnomAuth</p></a></li>
<li><a href='#ctCI'><p>ctCI</p>
Computes confidence intervals on specified parameters / matrices for already fitted ctsem fit object.</a></li>
<li><a href='#ctCompareExpected'><p>ctCompareExpected</p>
Compares model implied to observed means and covariances for panel data fit with ctsem.</a></li>
<li><a href='#ctExample1'><p>ctExample1</p></a></li>
<li><a href='#ctExample1TIpred'><p>ctExample1TIpred</p></a></li>
<li><a href='#ctExample2'><p>ctExample2</p></a></li>
<li><a href='#ctExample2level'><p>ctExample2level</p></a></li>
<li><a href='#ctExample3'><p>ctExample3</p></a></li>
<li><a href='#ctExample4'><p>ctExample4</p></a></li>
<li><a href='#ctFit'><p>Fit a ctsem object</p></a></li>
<li><a href='#ctGenerateFromFit'><p>Generates data according to the model estimated in a ctsemFit object.</p></a></li>
<li><a href='#ctIndplot'><p>ctIndplot</p></a></li>
<li><a href='#ctModelFromFit'><p>Extract a ctsem model structure with parameter values from a ctsem fit object.</p></a></li>
<li><a href='#ctMultigroupFit'><p>Fits a multiple group continuous time model.</p></a></li>
<li><a href='#ctPlot'><p>ctPlot</p></a></li>
<li><a href='#ctPostPredict'><p>Posterior predictive type check for ctsemFit.</p></a></li>
<li><a href='#ctRefineTo'><p>ctRefineTo</p></a></li>
<li><a href='#ctsemOMX'><p>ctsemOMX</p></a></li>
<li><a href='#datastructure'><p>datastructure</p></a></li>
<li><a href='#longexample'><p>longexample</p></a></li>
<li><a href='#Oscillating'><p>Oscillating</p></a></li>
<li><a href='#plot.ctsemFit'><p>Plotting function for object class ctsemFit</p></a></li>
<li><a href='#plot.ctsemMultigroupFit'><p>Plot function for ctsemMultigroupFit object</p></a></li>
<li><a href='#summary.ctsemFit'><p>Summary function for ctsemFit object</p></a></li>
<li><a href='#summary.ctsemMultigroupFit'><p>Summary function for ctsemMultigroupFit object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Continuous Time SEM - 'OpenMx' Based Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-4</td>
</tr>
<tr>
<td>Description:</td>
<td>Original 'ctsem' (continuous time structural equation modelling)
    functionality, based on the 'OpenMx' software, as described in 
    Driver, Oud, Voelkle (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v077.i05">doi:10.18637/jss.v077.i05</a>&gt;, with updated details in vignette. 
    Combines stochastic differential equations representing latent processes with 
    structural equation measurement models. These functions were split off from
    the main package of 'ctsem', as the main package uses the 'rstan' package as a backend now &ndash;
    offering estimation options from max likelihood to Bayesian.
    There are nevertheless use cases for the wide format SEM style approach as offered here, 
    particularly when there are no individual differences in observation timing and the
    number of individuals is large. For the main 'ctsem' package, see <a href="https://cran.r-project.org/package=ctsem">https://cran.r-project.org/package=ctsem</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ctsem (&ge; 3.3.2), OpenMx (&ge; 2.9.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cdriveraus/ctsemOMX">https://github.com/cdriveraus/ctsemOMX</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, Matrix, methods, plyr, stats, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-05 15:45:09 UTC; Driver</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles Driver [aut, cre, cph],
  Manuel Voelkle [aut, cph],
  Han Oud [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charles Driver &lt;charles.driver2@uzh.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-05 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AnomAuth'>AnomAuth</h2><span id='topic+AnomAuth'></span>

<h3>Description</h3>

<p>A dataset containing panel data assessments of individuals Anomia and Authoritarianism.
</p>


<h3>Format</h3>

<p>data frame with 2722 rows, 14 columns. Column Y1 represents anomia, 
Y2 Authoritarianism, dTx the time interval for measurement occasion x.
</p>


<h3>Source</h3>

<p>See <a href="https://psycnet.apa.org:443/journals/met/17/2/176/">https://psycnet.apa.org:443/journals/met/17/2/176/</a> for details.
</p>

<hr>
<h2 id='ctCI'>ctCI
Computes confidence intervals on specified parameters / matrices for already fitted ctsem fit object.</h2><span id='topic+ctCI'></span>

<h3>Description</h3>

<p>ctCI
Computes confidence intervals on specified parameters / matrices for already fitted ctsem fit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctCI(ctfitobj, confidenceintervals, optimizer = "NPSOL", verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctCI_+3A_ctfitobj">ctfitobj</code></td>
<td>
<p>Already fit ctsem fit object (class: ctsemFit) to estimate confidence intervals for.</p>
</td></tr>
<tr><td><code id="ctCI_+3A_confidenceintervals">confidenceintervals</code></td>
<td>
<p>character vector of matrices and or parameters for which to estimate 95% confidence intervals for.</p>
</td></tr>
<tr><td><code id="ctCI_+3A_optimizer">optimizer</code></td>
<td>
<p>character vector. Defaults to NPSOL (recommended), but other optimizers available within OpenMx (e.g. 'CSOLNP') may be specified.</p>
</td></tr>
<tr><td><code id="ctCI_+3A_verbose">verbose</code></td>
<td>
<p>Integer between 0 and 3 reflecting amount of output while calculating.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Confidence intervals typically estimate more reliably using the proprietary NPSOL optimizer available within OpenMx only when
installing directly from OpenMx website. Use command &quot; source('http://openmx.psyc.virginia.edu/getOpenMx.R') &quot; to install OpenMx with NPSOL.
If estimating for a multigroup model, specify confidence intervals as normal, e.g. <code>confidenceintervals = c('DRIFT', 'diffusion_Y1_Y1')</code> .
The necessary group prefixes are added internally.
</p>


<h3>Value</h3>

<p>ctfitobj, with confidence intervals included.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples set to 'donttest' because they take longer than 5s.

data("ctExample3")
model &lt;- ctModel(n.latent = 1, n.manifest = 3, Tpoints = 100, 
 LAMBDA = matrix(c(1, "lambda2", "lambda3"), nrow = 3, ncol = 1), 
 MANIFESTMEANS = matrix(c(0, "manifestmean2", "manifestmean3"), nrow = 3, 
   ncol = 1))
fit &lt;- ctFit(dat = ctExample3, ctmodelobj = model, objective = "Kalman",
 stationary = c("T0VAR"))

fit &lt;- ctCI(fit, confidenceintervals = 'DRIFT')

summary(fit)$omxsummary$CI

</code></pre>

<hr>
<h2 id='ctCompareExpected'>ctCompareExpected
Compares model implied to observed means and covariances for panel data fit with ctsem.</h2><span id='topic+ctCompareExpected'></span>

<h3>Description</h3>

<p>ctCompareExpected
Compares model implied to observed means and covariances for panel data fit with ctsem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctCompareExpected(
  fitobj,
  cov = TRUE,
  outputmatrices = FALSE,
  pause = TRUE,
  varlist = "all",
  ylim = c(-1, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctCompareExpected_+3A_fitobj">fitobj</code></td>
<td>
<p>Fitted model object from OpenMx or ctsem.</p>
</td></tr>
<tr><td><code id="ctCompareExpected_+3A_cov">cov</code></td>
<td>
<p>Logical. If TRUE, show covariance plots, if FALSE show correlations.</p>
</td></tr>
<tr><td><code id="ctCompareExpected_+3A_outputmatrices">outputmatrices</code></td>
<td>
<p>if TRUE, output expected, observed, and residual correlation matrices as well as plots.</p>
</td></tr>
<tr><td><code id="ctCompareExpected_+3A_pause">pause</code></td>
<td>
<p>if TRUE (default) output plots interactively, one at a time.  If FALSE, output without stopping.</p>
</td></tr>
<tr><td><code id="ctCompareExpected_+3A_varlist">varlist</code></td>
<td>
<p>if &quot;all&quot; include all variables in dataset.  Otherwise, specify numeric vector of variables to include.</p>
</td></tr>
<tr><td><code id="ctCompareExpected_+3A_ylim">ylim</code></td>
<td>
<p>vector of min and max Y axis limits for plot.</p>
</td></tr>
<tr><td><code id="ctCompareExpected_+3A_...">...</code></td>
<td>
<p>additional arguments passed to plot.</p>
</td></tr>
</table>

<hr>
<h2 id='ctExample1'>ctExample1</h2><span id='topic+ctExample1'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>100 by 17 matrix containing containing ctsem wide format data. 
6 measurement occasions of leisure time and happiness and 5 measurement intervals for each of 100 individuals.
</p>

<hr>
<h2 id='ctExample1TIpred'>ctExample1TIpred</h2><span id='topic+ctExample1TIpred'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>100 by 18 matrix containing containing ctsem wide format data. 
6 measurement occasions of leisure time and happiness, 1 measurement of number of friends,
and 5 measurement intervals for each of 100 individuals.
</p>

<hr>
<h2 id='ctExample2'>ctExample2</h2><span id='topic+ctExample2'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>100 by 18 matrix containing containing ctsem wide format data. 
8 measurement occasions of leisure time and happiness, 
7 measurement occasions of a money intervention dummy,
and 7 measurement intervals for each of 50 individuals.
</p>

<hr>
<h2 id='ctExample2level'>ctExample2level</h2><span id='topic+ctExample2level'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>100 by 18 matrix containing ctsem wide format data. 
8 measurement occasions of leisure time and happiness, 
7 measurement occasions of a money intervention dummy,
and 7 measurement intervals for each of 50 individuals.
</p>

<hr>
<h2 id='ctExample3'>ctExample3</h2><span id='topic+ctExample3'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>1 by 399 matrix containing containing ctsem wide format data. 
100 observations of variables Y1 and Y2 and 199 measurement intervals, for 1 subject.
</p>

<hr>
<h2 id='ctExample4'>ctExample4</h2><span id='topic+ctExample4'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>20 by 79 matrix containing 20 observations of variables 
Y1, Y2, Y3, and 19 measurement intervals dTx, for each of 20 individuals.
</p>

<hr>
<h2 id='ctFit'>Fit a ctsem object</h2><span id='topic+ctFit'></span>

<h3>Description</h3>

<p>This function fits continuous time SEM models specified via <code>ctModel</code>
to a dataset containing one or more subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctFit(
  dat,
  ctmodelobj,
  dataform = "auto",
  objective = "auto",
  stationary = c("T0TRAITEFFECT", "T0TIPREDEFFECT"),
  optimizer = "CSOLNP",
  retryattempts = 5,
  iterationSummary = FALSE,
  carefulFit = TRUE,
  carefulFitWeight = 100,
  showInits = FALSE,
  asymptotes = FALSE,
  meanIntervals = FALSE,
  crossEffectNegStarts = TRUE,
  fit = TRUE,
  nofit = FALSE,
  discreteTime = FALSE,
  verbose = 0,
  useOptimizer = TRUE,
  omxStartValues = NULL,
  transformedParams = TRUE,
  datawide = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctFit_+3A_dat">dat</code></td>
<td>
<p>the data you wish to fit a ctsem model to, in either wide format (one individual per row), 
or long format (one time point of one individual per row). See details.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_ctmodelobj">ctmodelobj</code></td>
<td>
<p>the ctsem model object you wish to use, specified via the <code>ctModel</code> function.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_dataform">dataform</code></td>
<td>
<p>either &quot;wide&quot; or &quot;long&quot; depending on which input format you wish to use for the data. See details and or vignette.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_objective">objective</code></td>
<td>
<p>'auto' selects either 'Kalman', if fitting to single subject data, 
or 'mxRAM' for multiple subjects. For single subject data, 'Kalman' uses the <code>mxExpectationStateSpace </code>
function from OpenMx to implement the Kalman filter. 
For more than one subject, 'mxRAM' specifies a wide format SEM with a row of data per subject.
'cov' may be specified, in which case the 'meanIntervals' argument is set to TRUE, and the covariance matrix
of the supplied data is calculated and fit instead of the raw data. This is much faster but only a rough approximation,
unless there are no individual differences in time interval and no missing data.
'Kalman' may be specified for multiple subjects, however as no trait matrices are used by the Kalman filter
one must consider how average level differences between subjects are accounted for.
See <code><a href="#topic+ctMultigroupFit">ctMultigroupFit</a></code> for the possibility to apply the Kalman filter over multiple subjects)</p>
</td></tr>
<tr><td><code id="ctFit_+3A_stationary">stationary</code></td>
<td>
<p>Character vector of T0 matrix names in which to constrain any 
free parameters to stationarity. 
Defaults to <code>c('T0TRAITEFFECT','T0TIPREDEFFECT')</code>, constraining only
between person effects to stationarity. Use <code>NULL</code> for no constraints,
or 'all' to constrain all T0 matrices.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_optimizer">optimizer</code></td>
<td>
<p>character string, defaults to the open-source 'CSOLNP' optimizer that is distributed
in all versions of OpenMx. However, 'NPSOL' may sometimes perform better for these problems,
though requires that you have installed OpenMx via the OpenMx web site, by running:
<code>source('http://openmx.psyc.virginia.edu/getOpenMx.R')</code></p>
</td></tr>
<tr><td><code id="ctFit_+3A_retryattempts">retryattempts</code></td>
<td>
<p>Number of times to retry the start value randomisation and fit procedure, if non-convergance or uncertain fits occur.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_iterationsummary">iterationSummary</code></td>
<td>
<p>if TRUE, outputs limited fit details after every fit attempt.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_carefulfit">carefulFit</code></td>
<td>
<p>if TRUE, first fits the specified model with a penalised likelihood function 
to force MANIFESTVAR, DRIFT, TRAITVAR, MANIFESTTRAITVAR parameters to remain close to 0, then
fits the specified model normally, using these estimates as starting values. 
Can help to ensure optimization begins at sensible, non-exteme values, 
though results in any user specified start values being ignored for the final fit (though they are still used for initial fit).</p>
</td></tr>
<tr><td><code id="ctFit_+3A_carefulfitweight">carefulFitWeight</code></td>
<td>
<p>Positive numeric. Sets the weight for the penalisation (or prior) applied by the carefulFit algorithm. 
Generally unnecessary to adjust, may be helpful to try a selection of values (perhaps between 0 and 1000) when optimization is problematic.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_showinits">showInits</code></td>
<td>
<p>if TRUE, prints the list of 
starting values for free parameters. These are the 'raw' values used by OpenMx, 
and reflect the log (var / cov matrices) or -log(DRIFT matrices) transformations used in ctsem.
These are saved in the fit object under <code>fitobject$omxStartValues</code>.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_asymptotes">asymptotes</code></td>
<td>
<p>when TRUE, optimizes over asymptotic parameter matrices instead of continuous time parameter matrices. 
Can be faster for optimization and in some cases makes reliable convergance easier. Will result in equivalent models 
when continuous time input matrices (DRIFT, DIFFUSION, CINT) are free, but fixing the values of 
any such matrices will result in large differences - a value of 0 in a cell of the normal continuous time DIFFUSION matrix
does not necessarily result in a value of 0 for the asymptotic DIFFUSION matrix, for instance.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_meanintervals">meanIntervals</code></td>
<td>
<p>Use average time intervals for each column for calculation 
(both faster and inaccurate to the extent that intervals vary across individuals).</p>
</td></tr>
<tr><td><code id="ctFit_+3A_crosseffectnegstarts">crossEffectNegStarts</code></td>
<td>
<p>Logical. If TRUE (default) free DRIFT matrix cross effect parameters have starting values 
set to small negative values (e.g. -.05), if FALSE, the start values are 0. The TRUE setting is useful for easy 
initialisation of higher order models, while the FALSE setting is useful when one has already estimated a model without cross effects,
and wishes to begin optimization from those values by using the omxStartValues switch.
are re-transformed into regular continuous time parameter matrices, and may be interpreted as normal.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_fit">fit</code></td>
<td>
<p>if FALSE, output only openmx model without fitting</p>
</td></tr>
<tr><td><code id="ctFit_+3A_nofit">nofit</code></td>
<td>
<p>Deprecated. If TRUE, output only openmx model without fitting</p>
</td></tr>
<tr><td><code id="ctFit_+3A_discretetime">discreteTime</code></td>
<td>
<p>Estimate a discrete time model - ignores timing information, parameter
estimates will correspond to those of classical vector autoregression models, 
OpenMx fit object will be directly output, thus ctsem summary and plot functionality will be unavailable.
Time dependent predictor type also becomes irrelevant.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_verbose">verbose</code></td>
<td>
<p>Integer between 0 and 3. Sets mxComputeGradientDescent messaging level, defaults to 0.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_useoptimizer">useOptimizer</code></td>
<td>
<p>Logical. Defaults to TRUE.  Passes argument to <code>mxRun</code>, 
useful for using custom optimizers or fitting to specified parameters.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_omxstartvalues">omxStartValues</code></td>
<td>
<p>A named vector containing the raw (potentially log transformed) OpenMx starting values for free parameters, as captured by
OpenMx function <code>omxGetParameters(ctmodelobj$mxobj)</code>. These values will take precedence 
over any starting values already specified using ctModel.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_transformedparams">transformedParams</code></td>
<td>
<p>Logical indicating whether or not to log transform 
certain parameters internally to allow unconstrained estimation over
entire 'sensible' range for parameters. 
When TRUE (default) raw OpenMx parameters (only reported if <code>verbose=TRUE</code> argument used
for summary function) will reflect these transformations and may be harder to 
interpret, but summary matrices are reported as normal.</p>
</td></tr>
<tr><td><code id="ctFit_+3A_datawide">datawide</code></td>
<td>
<p>included for compatibility with scripts written for earlier versions of ctsem. 
Do not use this argument, instead use the dat argument, and the dataform argument now specifies whether the
data is in wide or long format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For full discussion of how to structure the data and use this function, see the vignette using: <code>vignette('ctsem')</code>, or
the data examples <code>data("longexample") ; longexample</code> for long and <code>data("datastructure") ; datastructure</code> for wide. 
If using long format, the subject id column must be numeric and grouped by ascending time within subject, and named 'id'. 
The time column must also be numeric, and representing absolute time (e.g., since beginning of study, *not* time intervals),
and called 'time'.
Models are specified using the <code>ctModel</code> function.
For help regarding the summary function, see <code><a href="#topic+summary.ctsemFit">summary.ctsemFit</a></code>, 
and for the plot function, <code><a href="#topic+plot.ctsemFit">plot.ctsemFit</a></code>.
Multigroup models may be specified using <code><a href="#topic+ctMultigroupFit">ctMultigroupFit</a></code>.
Confidence intervals for any matrices and or parameters 
may be estimated using <code><a href="#topic+ctCI">ctCI</a></code>.
Difficulties during estimation can sometimes be alleviated using <code><a href="#topic+ctRefineTo">ctRefineTo</a></code> instead of <code><a href="#topic+ctFit">ctFit</a></code> &ndash; 
this uses a multistep fit procedure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples set to 'donttest' because they take longer than 5s.

mfrowOld&lt;-par()$mfrow
par(mfrow=c(2, 3))

### example from Driver, Oud, Voelkle (2017), 
### simulated happiness and leisure time with unobserved heterogeneity.
data(ctExample1)
traitmodel &lt;- ctModel(n.manifest=2, n.latent=2, Tpoints=6, LAMBDA=diag(2), 
  manifestNames=c('LeisureTime', 'Happiness'), 
  latentNames=c('LeisureTime', 'Happiness'), TRAITVAR="auto")
traitfit &lt;- ctFit(dat=ctExample1, ctmodelobj=traitmodel)
summary(traitfit)
plot(traitfit, wait=FALSE)


###Example from Voelkle, Oud, Davidov, and Schmidt (2012) - anomia and authoritarianism.  
data(AnomAuth) 
AnomAuthmodel &lt;- ctModel(LAMBDA = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2), 
Tpoints = 5, n.latent = 2, n.manifest = 2, MANIFESTVAR=diag(0, 2), TRAITVAR = NULL) 
AnomAuthfit &lt;- ctFit(AnomAuth, AnomAuthmodel)
summary(AnomAuthfit)


### Single subject time series - using Kalman filter (OpenMx statespace expectation)
data('ctExample3')
model &lt;- ctModel(n.latent = 1, n.manifest = 3, Tpoints = 100, 
  LAMBDA = matrix(c(1, 'lambda2', 'lambda3'), nrow = 3, ncol = 1), 
  CINT= matrix('cint'),
  MANIFESTMEANS = matrix(c(0, 'manifestmean2', 'manifestmean3'), nrow = 3, 
    ncol = 1))
fit &lt;- ctFit(dat = ctExample3, ctmodelobj = model, objective = 'Kalman', 
  stationary = c('T0VAR'))


###Oscillating model from Voelkle &amp; Oud (2013). 
data("Oscillating")

inits &lt;- c(-39, -.3, 1.01, 10.01, .1, 10.01, 0.05, .9, 0)
names(inits) &lt;- c("crosseffect","autoeffect", "diffusion",
  "T0var11", "T0var21", "T0var22","m1", "m2", 'manifestmean')

oscillatingm &lt;- ctModel(n.latent = 2, n.manifest = 1, Tpoints = 11,
  MANIFESTVAR = matrix(c(0), nrow = 1, ncol = 1),
  LAMBDA = matrix(c(1, 0), nrow = 1, ncol = 2),
  T0MEANS = matrix(c('m1', 'm2'), nrow = 2, ncol = 1),
  T0VAR = matrix(c("T0var11", "T0var21", 0, "T0var22"), nrow = 2, ncol = 2),
  DRIFT = matrix(c(0, "crosseffect", 1, "autoeffect"), nrow = 2, ncol = 2),
  CINT = matrix(0, ncol = 1, nrow = 2),
  MANIFESTMEANS = matrix('manifestmean', nrow = 1, ncol = 1),
  DIFFUSION = matrix(c(0, 0, 0, "diffusion"), nrow = 2, ncol = 2),
  startValues=inits)

oscillatingf &lt;- ctFit(Oscillating, oscillatingm, carefulFit = FALSE)

</code></pre>

<hr>
<h2 id='ctGenerateFromFit'>Generates data according to the model estimated in a ctsemFit object.</h2><span id='topic+ctGenerateFromFit'></span>

<h3>Description</h3>

<p>Generates data according to the model estimated in a ctsemFit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctGenerateFromFit(
  fit,
  timestep = "asdata",
  n.subjects = 100,
  timerange = "asdata",
  predictorSubjects = "all",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctGenerateFromFit_+3A_fit">fit</code></td>
<td>
<p>object of class ctsemFit as returned from ctFit.</p>
</td></tr>
<tr><td><code id="ctGenerateFromFit_+3A_timestep">timestep</code></td>
<td>
<p>positive numeric value indicating the time interval to use for
data generation.</p>
</td></tr>
<tr><td><code id="ctGenerateFromFit_+3A_n.subjects">n.subjects</code></td>
<td>
<p>integer. Number of subjects worth of data to generate</p>
</td></tr>
<tr><td><code id="ctGenerateFromFit_+3A_timerange">timerange</code></td>
<td>
<p>either 'asdata' to calculate range based on data in fit object,
or vector of length 2 specifying min and max times for generation.</p>
</td></tr>
<tr><td><code id="ctGenerateFromFit_+3A_predictorsubjects">predictorSubjects</code></td>
<td>
<p>vector of integers, or string 'all', defining which 
subjects to sample time dependent and independent predictors from.</p>
</td></tr>
<tr><td><code id="ctGenerateFromFit_+3A_...">...</code></td>
<td>
<p>parameters to pass to ctGenerate function, such as wide=FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of generated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(AnomAuth) 
AnomAuthmodel &lt;- ctModel(LAMBDA = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2), 
  Tpoints = 5, n.latent = 2, n.manifest = 2, MANIFESTVAR=diag(0, 2)) 
AnomAuthfit &lt;- ctFit(AnomAuth, AnomAuthmodel)

dwide &lt;- ctGenerateFromFit(AnomAuthfit,timestep=1,n.subjects=5,wide=TRUE)
head(dwide)

</code></pre>

<hr>
<h2 id='ctIndplot'>ctIndplot</h2><span id='topic+ctIndplot'></span>

<h3>Description</h3>

<p>Convenience function to simply plot individuals trajectories from ctsem wide format data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctIndplot(
  datawide,
  n.manifest,
  Tpoints,
  n.subjects = "all",
  colourby = "variable",
  vars = "all",
  opacity = 1,
  varnames = NULL,
  xlab = "Time",
  ylab = "Value",
  type = "b",
  start = 0,
  legend = TRUE,
  legendposition = "topright",
  new = TRUE,
  jittersd = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctIndplot_+3A_datawide">datawide</code></td>
<td>
<p>ctsem wide format data</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_n.manifest">n.manifest</code></td>
<td>
<p>Number of manifest variables in data structure</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_tpoints">Tpoints</code></td>
<td>
<p>Number of discrete time points per case in data structure</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_n.subjects">n.subjects</code></td>
<td>
<p>Number of subjects to randomly select for plotting, or character vector 'all'.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_colourby">colourby</code></td>
<td>
<p>set  plot colours by &quot;subject&quot; or &quot;variable&quot;</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_vars">vars</code></td>
<td>
<p>either 'all' or a numeric vector specifying which manifest variables to plot.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_opacity">opacity</code></td>
<td>
<p>Opacity of plot lines</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_varnames">varnames</code></td>
<td>
<p>vector of variable names for legend (defaults to NULL)</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_xlab">xlab</code></td>
<td>
<p>X axis label.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_ylab">ylab</code></td>
<td>
<p>Y axis label.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_type">type</code></td>
<td>
<p>character specifying plot type, as per usual base R plot commands. 
Defaults to 'b', both points and lines.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_start">start</code></td>
<td>
<p>Measurement occasion to start plotting from - defaults to T0.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_legend">legend</code></td>
<td>
<p>Logical. Plot a legend?</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_legendposition">legendposition</code></td>
<td>
<p>Where to position the legend.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_new">new</code></td>
<td>
<p>logical. If TRUE, creates a new plot, otherwise overlays on current plot.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_jittersd">jittersd</code></td>
<td>
<p>positive numeric indicating standard deviation of noise to add to observed
data for plotting purposes.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_...">...</code></td>
<td>
<p>additional plotting parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ctExample1)
ctIndplot(ctExample1,n.subjects=1, n.manifest=2,Tpoints=6, colourby='variable')

</code></pre>

<hr>
<h2 id='ctModelFromFit'>Extract a ctsem model structure with parameter values from a ctsem fit object.</h2><span id='topic+ctModelFromFit'></span>

<h3>Description</h3>

<p>Extract a ctsem model structure with parameter values from a ctsem fit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctModelFromFit(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctModelFromFit_+3A_fit">fit</code></td>
<td>
<p>object output by <code><a href="#topic+ctFit">ctFit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'ctsemInit' (as generated by <code>ctModel</code>), 
which can be used with <code><a href="#topic+ctFit">ctFit</a></code> and functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AnomAuth) 
AnomAuthmodel &lt;- ctModel(LAMBDA = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2), 
  Tpoints = 5, n.latent = 2, n.manifest = 2, MANIFESTVAR=diag(0, 2)) 
AnomAuthfit &lt;- ctFit(AnomAuth, AnomAuthmodel)

fitmodel &lt;- ctModelFromFit(AnomAuthfit)
</code></pre>

<hr>
<h2 id='ctMultigroupFit'>Fits a multiple group continuous time model.</h2><span id='topic+ctMultigroupFit'></span>

<h3>Description</h3>

<p>Fits a single continuous time structural equation models to multiple groups (where each group contains 1 or more subjects),
by default, all parameters are free across groups.  Can also be used to easily estimate seperate models for each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctMultigroupFit(
  dat,
  groupings,
  ctmodelobj,
  dataform = "wide",
  fixedmodel = NA,
  freemodel = NA,
  carefulFit = TRUE,
  omxStartValues = NULL,
  retryattempts = 5,
  showInits = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctMultigroupFit_+3A_dat">dat</code></td>
<td>
<p>Wide format data, as used in <code><a href="#topic+ctFit">ctFit</a></code>.  See <code>ctLongToWide</code> to
easily convert long format data.</p>
</td></tr>
<tr><td><code id="ctMultigroupFit_+3A_groupings">groupings</code></td>
<td>
<p>For wide format: Vector of character labels designating group membership for each row of dat.
For long format: Named list of groups, with each list element containing a vector of subject id's for the group.
In both cases, group names will be prefixed on relevant parameter estimates in the summary.</p>
</td></tr>
<tr><td><code id="ctMultigroupFit_+3A_ctmodelobj">ctmodelobj</code></td>
<td>
<p>Continuous time model to fit, specified via <code>ctModel</code> function.</p>
</td></tr>
<tr><td><code id="ctMultigroupFit_+3A_dataform">dataform</code></td>
<td>
<p>either &quot;wide&quot; or &quot;long&quot; depending on which input format you wish to use for the data. 
See details of <code><a href="#topic+ctFit">ctFit</a></code> and or vignette.</p>
</td></tr>
<tr><td><code id="ctMultigroupFit_+3A_fixedmodel">fixedmodel</code></td>
<td>
<p>Modified version of ctmodelobj, wherein any parameters you wish to keep 
fixed over groups should be given the value 'groupfixed'.  
If specified, all other parameters will be free across groups.</p>
</td></tr>
<tr><td><code id="ctMultigroupFit_+3A_freemodel">freemodel</code></td>
<td>
<p>Modified version of ctmodelobj, wherein any parameters you wish to free across groups
should be given the label 'groupfree'.  
If specified, all other parameters will be fixed across groups.  
If left NULL, the default, all parameters are free across groups.</p>
</td></tr>
<tr><td><code id="ctMultigroupFit_+3A_carefulfit">carefulFit</code></td>
<td>
<p>if TRUE, first fits the specified model with a penalised likelihood function 
to discourage parameters from boundary conditions, then
fits the specified model normally, using these estimates as starting values. 
Can help / speed optimization, though results in user specified inits being ignored for the final fit.</p>
</td></tr>
<tr><td><code id="ctMultigroupFit_+3A_omxstartvalues">omxStartValues</code></td>
<td>
<p>A named vector containing the raw (potentially log transformed) OpenMx starting values for free parameters, as captured by
OpenMx function <code>omxGetParameters(ctmodelobj$mxobj)</code>. These values will take precedence 
over any starting values already specified using ctModel.</p>
</td></tr>
<tr><td><code id="ctMultigroupFit_+3A_retryattempts">retryattempts</code></td>
<td>
<p>Number of fit retries to make.</p>
</td></tr>
<tr><td><code id="ctMultigroupFit_+3A_showinits">showInits</code></td>
<td>
<p>Displays start values prior to optimization</p>
</td></tr>
<tr><td><code id="ctMultigroupFit_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="#topic+ctFit">ctFit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional <code><a href="#topic+ctFit">ctFit</a></code> parameters may be specified as required. Confidence intervals for any matrices and or parameters 
may be estimated afer fitting using <code><a href="#topic+ctCI">ctCI</a></code>.
</p>


<h3>Value</h3>

<p>Returns an OpenMx fit object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctFit">ctFit</a></code> and <code>ctModel</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Two group model, all parameters except LAMBDA[3,1] constrained across groups.
data(ctExample4)
basemodel&lt;-ctModel(n.latent=1, n.manifest=3, Tpoints=20,
                   LAMBDA=matrix(c(1, 'lambda2', 'lambda3'), nrow=3, ncol=1),
                   MANIFESTMEANS=matrix(c(0, 'manifestmean2', 'manifestmean3'), 
                   nrow=3, ncol=1), TRAITVAR = 'auto')

freemodel&lt;-basemodel
freemodel$LAMBDA[3,1]&lt;-'groupfree'
groups&lt;-paste0('g',rep(1:2, each=10),'_')

multif&lt;-ctMultigroupFit(dat=ctExample4, groupings=groups,
                       ctmodelobj=basemodel, freemodel=freemodel)
summary(multif,group=1)



#fixed model approach
fixedmodel&lt;-basemodel
fixedmodel$LAMBDA[2,1]&lt;-'groupfixed'
groups&lt;-paste0('g',rep(1:2, each=10),'_')

multif&lt;-ctMultigroupFit(dat=ctExample4, groupings=groups,
                       ctmodelobj=basemodel, fixedmodel=fixedmodel)
summary(multif,group=2) 



</code></pre>

<hr>
<h2 id='ctPlot'>ctPlot</h2><span id='topic+ctPlot'></span>

<h3>Description</h3>

<p>Plots mean trajectories, autoregression, and crossregression plots, for ctsemFit objects. 
More customizeable than basic plot.ctsemFit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctPlot(
  x,
  plotType,
  xlim,
  resolution = 50,
  impulseIndex = NULL,
  subject = 1,
  typeVector = "auto",
  colVector = "auto",
  ltyVector = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctPlot_+3A_x">x</code></td>
<td>
<p>ctsemFit object as generated by <code><a href="#topic+ctFit">ctFit</a></code>.</p>
</td></tr>
<tr><td><code id="ctPlot_+3A_plottype">plotType</code></td>
<td>
<p>string. &quot;mean&quot; for expectation independent of any data, 
&quot;AR&quot; for autoregressions, &quot;CR&quot; for cross regressions, 
&quot;standardiseCR&quot; for standardised cross regressions (standardised based on estimated within subject variance), 
&quot;withinVar&quot; for within variance and covariance,
&quot;randomImpulse&quot; for expected change in processes given a random fluctuation of +1 for each process 
(so a mixture of DIFFUSION and DRIFT characteristics),
&quot;experimentalImpulse&quot; for expected change in processes given an exogenous input of +1 for each process, provides 
alternate characterisation of autoregressive and cross regressive plots.</p>
</td></tr>
<tr><td><code id="ctPlot_+3A_xlim">xlim</code></td>
<td>
<p>vector. As per usual for plot(), but xlim may not be negative.</p>
</td></tr>
<tr><td><code id="ctPlot_+3A_resolution">resolution</code></td>
<td>
<p>Numeric. Plot points between each unit of time. Default of 'auto' adapts to xlim and results in 500 points in total.</p>
</td></tr>
<tr><td><code id="ctPlot_+3A_impulseindex">impulseIndex</code></td>
<td>
<p>Numeric. Only required for impulse plot types, specifies which column of the DRIFT matrix the impulse relates to.</p>
</td></tr>
<tr><td><code id="ctPlot_+3A_subject">subject</code></td>
<td>
<p>numeric. Specifies the subject (row of data from the mxobj) to plot for factorScores type plot.</p>
</td></tr>
<tr><td><code id="ctPlot_+3A_typevector">typeVector</code></td>
<td>
<p>Vector of plot types to use for plotting.</p>
</td></tr>
<tr><td><code id="ctPlot_+3A_colvector">colVector</code></td>
<td>
<p>vector of colours to use for plotting.</p>
</td></tr>
<tr><td><code id="ctPlot_+3A_ltyvector">ltyVector</code></td>
<td>
<p>Vector of line types to use for plotting.</p>
</td></tr>
<tr><td><code id="ctPlot_+3A_...">...</code></td>
<td>
<p>Other options passed to <code>plot()</code>. ylim is required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of labels from the DRIFT matrix in order plotted - useful for legends. Side-effect: plots graphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples set to 'donttest' because they take longer than 5s.

### example from Driver, Oud, Voelkle (2016), 
### simulated happiness and leisure time with unobserved heterogeneity.

data(ctExample1)
traitmodel &lt;- ctModel(n.manifest=2, n.latent=2, Tpoints=6, LAMBDA=diag(2), 
  manifestNames=c('LeisureTime', 'Happiness'), 
  latentNames=c('LeisureTime', 'Happiness'), TRAITVAR="auto")
traitfit &lt;- ctFit(dat=ctExample1, ctmodelobj=traitmodel)
ctPlot(traitfit, plotType='CR', xlim=c(0,5),ylim=c(-1,1))

</code></pre>

<hr>
<h2 id='ctPostPredict'>Posterior predictive type check for ctsemFit.</h2><span id='topic+ctPostPredict'></span>

<h3>Description</h3>

<p>Samples data according to the ctsemFit object, computes quantiles over time based on model fit,
plots these against original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctPostPredict(
  fit,
  timestep = 0.1,
  n.subjects = 100,
  probs = c(0.025, 0.5, 0.975),
  plot = TRUE,
  ctPlotArrayArgs = list(grid = FALSE, legend = FALSE),
  indPlotArgs = list(colourby = "subject", lwd = 2, new = FALSE, type = "p", opacity =
    0.3),
  mfrow = "auto"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctPostPredict_+3A_fit">fit</code></td>
<td>
<p>object of class ctsemFit as returned from <code><a href="#topic+ctFit">ctFit</a></code></p>
</td></tr>
<tr><td><code id="ctPostPredict_+3A_timestep">timestep</code></td>
<td>
<p>positive value denoting the time interval to use for sampling.</p>
</td></tr>
<tr><td><code id="ctPostPredict_+3A_n.subjects">n.subjects</code></td>
<td>
<p>Number of subjects worth of data to sample.</p>
</td></tr>
<tr><td><code id="ctPostPredict_+3A_probs">probs</code></td>
<td>
<p>Vector of values between 0 and 1 denoting quantiles to generate. 
For plotting, vector should be of length 3 and values should be rising.</p>
</td></tr>
<tr><td><code id="ctPostPredict_+3A_plot">plot</code></td>
<td>
<p>Whether to plot or return the generated data.</p>
</td></tr>
<tr><td><code id="ctPostPredict_+3A_ctplotarrayargs">ctPlotArrayArgs</code></td>
<td>
<p>additional arguments to pass to <code>ctPlotArray</code> function,
for plotting generated distributions.</p>
</td></tr>
<tr><td><code id="ctPostPredict_+3A_indplotargs">indPlotArgs</code></td>
<td>
<p>list of parameters to pass to ctIndplot, for 
plotting original data. Only used if plot=TRUE.</p>
</td></tr>
<tr><td><code id="ctPostPredict_+3A_mfrow">mfrow</code></td>
<td>
<p>2 dimensional integer vector defining number of rows and columns of plots,
as per the mfrow argument to <code><a href="graphics.html#topic+par">par</a></code>.
'auto' determines automatically, to a maximum of 4 by 4, while <code>NULL</code> 
uses the current system setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either nothing (if plot=TRUE) or an array containing generated data over quantiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("AnomAuth")
AnomAuthmodel &lt;- ctModel(LAMBDA = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2), 
  Tpoints = 5, n.latent = 2, n.manifest = 2, MANIFESTVAR=diag(0, 2), TRAITVAR = 'auto') 
AnomAuthFit &lt;- ctFit(AnomAuth, AnomAuthmodel)
ctPostPredict(AnomAuthFit,timestep=.5,n.subjects=100)

</code></pre>

<hr>
<h2 id='ctRefineTo'>ctRefineTo</h2><span id='topic+ctRefineTo'></span>

<h3>Description</h3>

<p>Fits a ctsem m in a stepwise fashion to help with difficult optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctRefineTo(datawide, ctmodelobj, modfunc = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctRefineTo_+3A_datawide">datawide</code></td>
<td>
<p>Data in ctsem wide format</p>
</td></tr>
<tr><td><code id="ctRefineTo_+3A_ctmodelobj">ctmodelobj</code></td>
<td>
<p>A continuous time m specified via the <code>ctModel</code> function.</p>
</td></tr>
<tr><td><code id="ctRefineTo_+3A_modfunc">modfunc</code></td>
<td>
<p>function to run prior to each optimization step, that takes ctsem fit object, modifies it as desired, and returns the fit object.</p>
</td></tr>
<tr><td><code id="ctRefineTo_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code><a href="#topic+ctFit">ctFit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a sequence of ctsem models increasing in complexity, 
starting with a m involving fixed and relatively strong auto effects, no cross effects, no predictors, and no off-diagonal covariances.
For many models this can improve the speed and robustness of fitting
</p>


<h3>Value</h3>

<p>Returns a fitted ctsem object in the same manner as <code><a href="#topic+ctFit">ctFit</a></code>.
</p>

<hr>
<h2 id='ctsemOMX'>ctsemOMX</h2><span id='topic+ctsemOMX'></span><span id='topic+ctsemOMX-package'></span>

<h3>Description</h3>

<p>ctsem is an R package for continuous time structural equation modelling of panel (N &gt; 1) 
and time series (N = 1) data, using either a frequentist or Bayesian approach, or middle
ground forms like maximum a posteriori. This ctsemOMX addition includes the original OpenMx based functions
which have been split off from the main package.
</p>
<p>ctsem is an R package for continuous time structural equation modelling of panel (N &gt; 1) 
and time series (N = 1) data, using either a frequentist or Bayesian approach, or middle
ground forms like maximum a posteriori. This ctsemOMX addition includes the original OpenMx based functions
which have been split off from the main package.
</p>


<h3>Details</h3>

<p>The general workflow begins by specifying a model using the <code>ctModel</code> function, 
in which the <code>type</code> of model is also specified. Then the model is fit to data using 
either <code><a href="#topic+ctFit">ctFit</a></code> if the original 'omx' (OpenMx, SEM, max likelihood) model is specified.
The omx forms are no longer in 
development and for most purposes, the newer stan based forms (contained in the base ctsem package)
are more robust and flexible.
For citation info, please run <code>citation('ctsem')</code> .
</p>
<p>The general workflow begins by specifying a model using the <code>ctModel</code> function, 
in which the <code>type</code> of model is also specified. Then the model is fit to data using 
either <code><a href="#topic+ctFit">ctFit</a></code> if the original 'omx' (OpenMx, SEM, max likelihood) model is specified.
The omx forms are no longer in 
development and for most purposes, the newer stan based forms (contained in the base ctsem package)
are more robust and flexible.
For citation info, please run <code>citation('ctsem')</code> .
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Charles Driver <a href="mailto:charles.driver2@uzh.ch">charles.driver2@uzh.ch</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Manuel Voelkle [copyright holder]
</p>
</li>
<li><p> Han Oud [copyright holder]
</p>
</li></ul>



<h3>References</h3>

<p>https://www.jstatsoft.org/article/view/v077i05
</p>
<p>Driver, C. C., &amp; Voelkle, M. C. (2018). Hierarchical Bayesian continuous time dynamic modeling. 
Psychological Methods. Advance online publication.http://dx.doi.org/10.1037/met0000168
</p>
<p>https://www.jstatsoft.org/article/view/v077i05
</p>
<p>Driver, C. C., &amp; Voelkle, M. C. (2018). Hierarchical Bayesian continuous time dynamic modeling. 
Psychological Methods. Advance online publication.http://dx.doi.org/10.1037/met0000168
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cdriveraus/ctsemOMX">https://github.com/cdriveraus/ctsemOMX</a>
</p>
</li></ul>


<hr>
<h2 id='datastructure'>datastructure</h2><span id='topic+datastructure'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>2 by 15 matrix containing containing ctsem wide format data. 
3 measurement occasions of manifest variables Y1 and Y2, 
2 measurement occasions of time dependent predictor TD1, 
2 measurement intervals dTx, and 2 time independent predictors 
TI1 and TI2, for 2 individuals.
</p>

<hr>
<h2 id='longexample'>longexample</h2><span id='topic+longexample'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>7 by 8 matrix containing ctsem long format data, for two subjects, 
with three manifest variables Y1, Y2, Y3, 
one time dependent predictor TD1, two time independent predictors TI1 and TI2, 
and absolute timing information Time.
</p>

<hr>
<h2 id='Oscillating'>Oscillating</h2><span id='topic+Oscillating'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package.
</p>


<h3>Format</h3>

<p>200 by 21 matrix containing containing ctsem wide format data. 
11 measurement occasions and 10 measurement intervals for each of 200 individuals
</p>


<h3>Source</h3>

<p>See <a href="https://bpspsychub.onlinelibrary.wiley.com/doi/abs/10.1111/j.2044-8317.2012.02043.x">https://bpspsychub.onlinelibrary.wiley.com/doi/abs/10.1111/j.2044-8317.2012.02043.x</a>
</p>

<hr>
<h2 id='plot.ctsemFit'>Plotting function for object class ctsemFit</h2><span id='topic+plot.ctsemFit'></span>

<h3>Description</h3>

<p>Ouputs mean trajectories, autoregression, and crossregression plots. 
For more customization possibilities, see <code><a href="#topic+ctPlot">ctPlot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctsemFit'
plot(
  x,
  resolution = 50,
  wait = TRUE,
  max.time = "auto",
  mean = TRUE,
  withinVariance = TRUE,
  AR = TRUE,
  CR = TRUE,
  standardiseCR = FALSE,
  randomImpulse = FALSE,
  experimentalImpulse = FALSE,
  xlab = "Time",
  meansylim = "auto",
  ARylim = "auto",
  CRylim = "auto",
  ylab = "Value",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ctsemFit_+3A_x">x</code></td>
<td>
<p>ctsemFit object as generated by <code><a href="#topic+ctFit">ctFit</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_resolution">resolution</code></td>
<td>
<p>Numeric. Plot points between each unit of time. Default of 'auto' adapts to max.time and results in 500 in total.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_wait">wait</code></td>
<td>
<p>If true, user is prompted to continue before plotting next graph.  If false, graphs are plotted one after another without waiting.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_max.time">max.time</code></td>
<td>
<p>Time scale on which to plot parameters.  If auto, parameters are plotted for full range of observed variables.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_mean">mean</code></td>
<td>
<p>if TRUE, plot of means from 0 to max.time included in output.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_withinvariance">withinVariance</code></td>
<td>
<p>if TRUE, plot within subject variance / covariance.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_ar">AR</code></td>
<td>
<p>if TRUE, plot of autoregressive values from 0 to max.time included in output.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_cr">CR</code></td>
<td>
<p>if TRUE, plot of cross regressive values from 0 to max.time included in output.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_standardisecr">standardiseCR</code></td>
<td>
<p>if TRUE , cross regression values are standardised based on estimated within subject variance.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_randomimpulse">randomImpulse</code></td>
<td>
<p>if TRUE (default), plots expected change in processes given a random fluctuation of +1 for each process &ndash; 
plot is then a mixture of DIFFUSION and DRIFT characteristics.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_experimentalimpulse">experimentalImpulse</code></td>
<td>
<p>if TRUE (default), plots expected change in processes given an exogenous input of +1 for each process &ndash; 
alternate characterisation of autoregressive and cross regressive plots.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_xlab">xlab</code></td>
<td>
<p>X axis label.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_meansylim">meansylim</code></td>
<td>
<p>Vector of min and max limits for mean trajectory plot. 'auto' calculates automatically.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_arylim">ARylim</code></td>
<td>
<p>Vector of min and max limits for autoregression plot. 'auto' is c(0,1), and expands if necessary.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_crylim">CRylim</code></td>
<td>
<p>Vector of min and max limits for cross regression plot. 'auto' is c(-1,1), and expands if necessary.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_ylab">ylab</code></td>
<td>
<p>Y axis label.</p>
</td></tr>
<tr><td><code id="plot.ctsemFit_+3A_...">...</code></td>
<td>
<p>Other options passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Side-effect: plots graphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples set to 'donttest' because they take longer than 5s.

### example from Driver, Oud, Voelkle (2015), 
### simulated happiness and leisure time with unobserved heterogeneity.

data(ctExample1)
traitmodel &lt;- ctModel(n.manifest=2, n.latent=2, Tpoints=6, LAMBDA=diag(2), 
  manifestNames=c('LeisureTime', 'Happiness'), 
  latentNames=c('LeisureTime', 'Happiness'), TRAITVAR="auto")
traitfit &lt;- ctFit(dat=ctExample1, ctmodelobj=traitmodel)
plot(traitfit, wait=FALSE)

</code></pre>

<hr>
<h2 id='plot.ctsemMultigroupFit'>Plot function for ctsemMultigroupFit object</h2><span id='topic+plot.ctsemMultigroupFit'></span>

<h3>Description</h3>

<p>Plots <code><a href="#topic+ctMultigroupFit">ctMultigroupFit</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctsemMultigroupFit'
plot(x, group = "show chooser", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ctsemMultigroupFit_+3A_x">x</code></td>
<td>
<p>ctsemMultigroupFit object as generated by <code><a href="#topic+ctMultigroupFit">ctMultigroupFit</a></code></p>
</td></tr>
<tr><td><code id="plot.ctsemMultigroupFit_+3A_group">group</code></td>
<td>
<p>character string of subgroup to plot. Default of 'show chooser' displays list and lets you select.</p>
</td></tr>
<tr><td><code id="plot.ctsemMultigroupFit_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code><a href="#topic+plot.ctsemFit">plot.ctsemFit</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Side-effect: plots graphs.
</p>

<hr>
<h2 id='summary.ctsemFit'>Summary function for ctsemFit object</h2><span id='topic+summary.ctsemFit'></span>

<h3>Description</h3>

<p>Provides summary details for ctsemFit objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctsemFit'
summary(object, ridging = FALSE, timeInterval = 1, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ctsemFit_+3A_object">object</code></td>
<td>
<p>ctsemFit object as generated by ctFit.</p>
</td></tr>
<tr><td><code id="summary.ctsemFit_+3A_ridging">ridging</code></td>
<td>
<p>if TRUE, adds a small amount of variance to diagonals when calculating standardised (correlation) matrices,
should only be used if standardised matrices return NAN.</p>
</td></tr>
<tr><td><code id="summary.ctsemFit_+3A_timeinterval">timeInterval</code></td>
<td>
<p>positive numeric value specifying time interval to use for discrete parameter matrices, defaults to 1.</p>
</td></tr>
<tr><td><code id="summary.ctsemFit_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, displays the raw, internally transformed (when fitting with default arguments) OpenMx parameters and corresponding standard errors, as well as
additional summary matrices. Parameter transforms are described in the vignette, <code>vignette('ctsem')</code>. Additional summary matrices
include: 'discrete' matrices &ndash; matrices representing
the effect for the given time interval (default of 1); 'asymptotic' matrices &ndash; represents the effect as time interval
approaches infinity (therefore asymCINT describes mean level of processes at the asymptote, asymDIFFUSION describes total within-
subject variance at the asymptote, etc); 'standardised' matrices &ndash; transforms covariance matrices to correlation matrices, and transforms 
discreteDRIFT based on DIFFUSION, to give effect sizes.</p>
</td></tr>
<tr><td><code id="summary.ctsemFit_+3A_...">...</code></td>
<td>
<p>additional parameters to pass.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Important: Although <code>ctModel</code> takes cholesky decomposed variance-covariance matrices as input,
the summary function displays the full variance-covariance matrices. These can be cholesky decomposed for comparison purposes using
<code>t(chol(summary(ctfitobject)$covariancematrix))</code>.
Standard errors are displayed in the $ctparameters section, however if <code><a href="#topic+ctFit">ctFit</a></code> was used with transformedParams=TRUE (the default, and recommended) 
covariance matrix standard errors will have been approximated using the delta method. For 
inferential purposes, maximum likelihood confidence intervals may be estimated using the <code><a href="#topic+ctCI">ctCI</a></code> function.
</p>


<h3>Value</h3>

<p>Summary of ctsemFit object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples set to 'donttest' because they take longer than 5s. 


### example from Driver, Oud, Voelkle (2015), 
### simulated happiness and leisure time with unobserved heterogeneity.
data(ctExample1)
traitmodel &lt;- ctModel(n.manifest=2, n.latent=2, Tpoints=6, LAMBDA=diag(2), 
  manifestNames=c('LeisureTime', 'Happiness'), 
  latentNames=c('LeisureTime', 'Happiness'), TRAITVAR="auto")
traitfit &lt;- ctFit(dat=ctExample1, ctmodelobj=traitmodel)
summary(traitfit,timeInterval=1)

</code></pre>

<hr>
<h2 id='summary.ctsemMultigroupFit'>Summary function for ctsemMultigroupFit object</h2><span id='topic+summary.ctsemMultigroupFit'></span>

<h3>Description</h3>

<p>Provides summary details for objects fitted with <code><a href="#topic+ctMultigroupFit">ctMultigroupFit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctsemMultigroupFit'
summary(object, group = "show chooser", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ctsemMultigroupFit_+3A_object">object</code></td>
<td>
<p>ctsemMultigroupFit object as generated by <code><a href="#topic+ctMultigroupFit">ctMultigroupFit</a></code></p>
</td></tr>
<tr><td><code id="summary.ctsemMultigroupFit_+3A_group">group</code></td>
<td>
<p>character string of subgroup to display summary parameters for. Default of 'show chooser' displays list and lets you select.</p>
</td></tr>
<tr><td><code id="summary.ctsemMultigroupFit_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code><a href="#topic+summary.ctsemFit">summary.ctsemFit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary of ctsemMultigroupFit object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
