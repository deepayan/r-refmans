<!DOCTYPE html><html><head><title>Help for package m2r</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {m2r}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#enter_m2'><p>Enter a Macaulay2 session</p></a></li>
<li><a href='#factor_n'><p>Factor an integer into primes</p></a></li>
<li><a href='#factor_poly'><p>Factor a polynomial</p></a></li>
<li><a href='#gb'><p>Compute a Grobner basis with Macaulay2</p></a></li>
<li><a href='#ideal'><p>Create a new ideal in Macaulay2</p></a></li>
<li><a href='#is'><p>Macaulay2 object tests</p></a></li>
<li><a href='#LLL'><p>LLL algorithm</p></a></li>
<li><a href='#m2_call'><p>Call and reset a Macaulay2 process</p></a></li>
<li><a href='#m2_matrix'><p>Create a new matrix in Macaulay2</p></a></li>
<li><a href='#m2_parser'><p>Convert a M2 object into an R object</p></a></li>
<li><a href='#m2_path'><p>Set path to Macaulay2 (M2)</p></a></li>
<li><a href='#m2_utility'><p>Utility tools for M2</p></a></li>
<li><a href='#m2r'><p>Macaulay2 in R</p></a></li>
<li><a href='#phc'><p>PHCpack</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#ring'><p>Create a new ring in Macaulay2</p></a></li>
<li><a href='#snf'><p>Smith normal form</p></a></li>
<li><a href='#str_m2'><p>Give the structure of a Macaulay2 ring</p></a></li>
<li><a href='#use_ring'><p>Set Macaulay2 ring</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interface to 'Macaulay2'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Kahle &lt;david@kahle.io&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Persistent interface to 'Macaulay2' <a href="http://www.math.uiuc.edu/Macaulay2/">http://www.math.uiuc.edu/Macaulay2/</a>
    and front-end tools facilitating its use in the 'R' ecosystem. For details see 
    Kahle et. al. (2020) &lt;<a href="https://doi.org/10.18637%2Fjss.v093.i09">doi:10.18637/jss.v093.i09</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>mpoly (&ge; 1.0.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr, memoise, gmp, usethis, Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Macaulay2 &lt;http://www.math.uiuc.edu/Macaulay2/&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/coneill-math/m2r">https://github.com/coneill-math/m2r</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/coneill-math/m2r/issues">https://github.com/coneill-math/m2r/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, microbenchmark, testthat, R.rsp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-27 22:32:36 UTC; david_kahle</td>
</tr>
<tr>
<td>Author:</td>
<td>David Kahle <a href="https://orcid.org/0000-0002-9999-1558"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph, cre],
  Christopher O'Neill [aut, cph],
  Jeff Sommars [aut, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-28 08:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='enter_m2'>Enter a Macaulay2 session</h2><span id='topic+enter_m2'></span>

<h3>Description</h3>

<p>Enter a Macaulay2 session
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enter_m2(port = 27436L, timeout = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enter_m2_+3A_port">port</code></td>
<td>
<p>port for Macaulay2 socket</p>
</td></tr>
<tr><td><code id="enter_m2_+3A_timeout">timeout</code></td>
<td>
<p>number of seconds before aborting</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2 be installed and an interactive session

enter_m2()

# m2 code below
1 + 1
a = 1
a
R = QQ[t,x,y,z]
I = ideal(t^4  -  x, t^3  -  y, t^2  -  z)
gens gb I
exit

# back in R, the variable persists using m2()
m2("a")
m2("I")


# we can also define variables in R that persist in m2
m2("b = 5")

enter_m2()
b
exit


## End(Not run)

</code></pre>

<hr>
<h2 id='factor_n'>Factor an integer into primes</h2><span id='topic+factor_n'></span><span id='topic+factor_n.'></span>

<h3>Description</h3>

<p>Factor an integer into primes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_n(n, code = FALSE, ...)

factor_n.(n, code = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor_n_+3A_n">n</code></td>
<td>
<p>an integer or a polynomial</p>
</td></tr>
<tr><td><code id="factor_n_+3A_code">code</code></td>
<td>
<p>return only the M2 code? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="factor_n_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with integer columns <code>prime</code> and
<code>power</code> or <code>m2_pointer</code> referencing the factorization
in M2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2

##### basic usage
########################################

2^2 * 3^7 * 5^2 # = 218700
factor_n(218700)
factor_n.(218700)

(df &lt;- factor_n(218700))
df$prime
df$power
str(df)


factor_n(218700, code = TRUE)


##### other options
########################################

(integer_pointer &lt;- m2.("218700"))
m2_name(integer_pointer)
factor_n(integer_pointer, code = TRUE)
factor_n(integer_pointer)



factor_n(3234432540)
factor_n(323443254223453)
factor_n(rpois(1, 1e4))


##### known issues
########################################

# R doesn't handle big ints well. note in the following
# the m2 code number is different than the supplied number
factor_n(32344325422364353453, code = TRUE)

# this can be circumvented by passing a string instead
factor_n("32344325422364353453", code = TRUE)

# but if the factors are large, R can't handle the parsing well
factor_n("32344325422364353453")

# here's a workaround:
factor_pointer &lt;- factor_n.("32344325422364353453")
m2_meta(factor_pointer, "ext_str")
extract_factors &lt;- function(pointer) {
  require(stringr)
  str &lt;- m2_meta(pointer, "ext_str")
  str &lt;- str_sub(str, 19, -2)
  str &lt;- str_extract_all(str, "\\{[0-9]+,[0-9]+\\}")[[1]]
  str &lt;- str_sub(str, 2, -2)
  str &lt;- str_split(str, ",")
  df &lt;- as.data.frame(t(simplify2array(str)))
  names(df) &lt;- c("prime", "power")
  df
}
(df &lt;- extract_factors(factor_pointer))


# using gmp (currently broken)
# factor_n("32344325422364353453", gmp = TRUE)
m2("11 * 479 * 6138607975396537")
11 * 479 * 6138607975396537


## End(Not run)

</code></pre>

<hr>
<h2 id='factor_poly'>Factor a polynomial</h2><span id='topic+factor_poly'></span><span id='topic+factor_poly.'></span>

<h3>Description</h3>

<p>Factor a polynomial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_poly(mpoly, code = FALSE)

factor_poly.(mpoly, code = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor_poly_+3A_mpoly">mpoly</code></td>
<td>
<p>a character parseable by <code><a href="mpoly.html#topic+mp">mp()</a></code>, an
<code>mpoly</code> object, or a pointer to a polynomial in M2</p>
</td></tr>
<tr><td><code id="factor_poly_+3A_code">code</code></td>
<td>
<p>return only the M2 code? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="factor_poly_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with elements <code>factor</code> (an
<code>mpolyList</code> object) and <code>power</code>, an integer
vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2 be installed and an interactive session

##### basic usage
########################################

ring("x", "y", coefring = "QQ")
factor_poly("x^4 - y^4")

# reference function
factor_poly.("x^4 - y^4")


##### different inputs
########################################

# factor_poly accepts mpoly objects:
# remember you must create the ring first!
(p &lt;- mp("x^4 - y^4"))
factor_poly.(p)
factor_poly(p)
mp("(x-y) (x+y) (x^2+y^2)")



##### other examples
########################################

ring("x","y", "z", coefring = "QQ")
(p &lt;- mp("(x^2 - y) (x^2 + y) (x + y)^2 (x - z)^2"))
factor_poly.(p)
factor_poly(p)

(p &lt;- mp("(x-1)^3 (y-1)^3"))
factor_poly.(p)
factor_poly(p)


## End(Not run)
</code></pre>

<hr>
<h2 id='gb'>Compute a Grobner basis with Macaulay2</h2><span id='topic+gb'></span><span id='topic+gb.'></span><span id='topic+gb_'></span><span id='topic+gb_.'></span>

<h3>Description</h3>

<p>Compute a Grobner basis with Macaulay2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gb(..., control = list(), raw_chars = FALSE, code = FALSE)

gb.(..., control = list(), raw_chars = FALSE, code = FALSE)

gb_(x, control = list(), raw_chars = FALSE, code = FALSE, ...)

gb_.(x, control = list(), raw_chars = FALSE, code = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gb_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="gb_+3A_control">control</code></td>
<td>
<p>a list of options, see examples</p>
</td></tr>
<tr><td><code id="gb_+3A_raw_chars">raw_chars</code></td>
<td>
<p>if <code>TRUE</code>, the character vector will not be parsed by
<code><a href="mpoly.html#topic+mp">mp()</a></code>, saving time (default: <code>FALSE</code>). the down-side is that the
strings must be formated for M2 use directly, as opposed to for <code><a href="mpoly.html#topic+mp">mp()</a></code>.
(e.g. <code>"x*y+3"</code> instead of <code>"x y + 3"</code>)</p>
</td></tr>
<tr><td><code id="gb_+3A_code">code</code></td>
<td>
<p>return only the M2 code? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="gb_+3A_x">x</code></td>
<td>
<p>a character vector of polynomials to be parsed by <code><a href="mpoly.html#topic+mp">mp()</a></code>, a
<code>mpolyList</code> object, an <code><a href="#topic+ideal">ideal()</a></code> or pointer to an ideal</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gb</code> uses nonstandard evaluation; <code>gb_</code> is the standard evaluation
equivalent.
</p>


<h3>Value</h3>

<p>an <code>mpolyList</code> object of class <code>m2_grobner_basis</code> or a
<code>m2_grobner_basis_pointer</code> pointing to the same. See <code><a href="mpoly.html#topic+mpolyList">mpolyList()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="mpoly.html#topic+mp">mp()</a></code>, <code><a href="#topic+use_ring">use_ring()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2


##### basic usage
########################################

# the last ring evaluated is the one used in the computation
ring("t","x","y","z", coefring = "QQ")
gb("t^4 - x", "t^3 - y", "t^2 - z")

# here's the code it's running in M2
gb("t^4 - x", "t^3 - y", "t^2 - z", code = TRUE)



##### different versions of gb
########################################

# standard evaluation version
poly_chars &lt;- c("t^4 - x", "t^3 - y", "t^2 - z")
gb_(poly_chars)

# reference nonstandard evaluation version
gb.("t^4 - x", "t^3 - y", "t^2 - z")

# reference standard evaluation version
gb_.(poly_chars)



##### different inputs to gb
########################################

# ideals can be passed to gb
I &lt;- ideal("t^4 - x", "t^3 - y", "t^2 - z")
gb_(I)

# note that gb() works here, too, since there is only one input
gb(I)

# ideal pointers can be passed to gb
I. &lt;- ideal.("t^4 - x", "t^3 - y", "t^2 - z")
gb_(I.)

# setting raw_chars is a bit faster, because it doesn't use ideal()
gb("t^4 - x", "t^3 - y", "t^2 - z", raw_chars = TRUE, code = TRUE)
gb("t^4 - x", "t^3 - y", "t^2 - z", raw_chars = TRUE)



##### more advanced usage
########################################

# the control argument accepts a named list with additional
# options
gb_(
  c("t^4 - x", "t^3 - y", "t^2 - z"),
  control = list(StopWithMinimalGenerators = TRUE),
  code = TRUE
)

gb_(
  c("t^4 - x", "t^3 - y", "t^2 - z"),
  control = list(StopWithMinimalGenerators = TRUE)
)



##### potential issues
########################################

# when specifying raw_chars, be sure to add asterisks
# between variables to create monomials; that's the M2 way
ring("x", "y", "z", coefring = "QQ")
gb("x y", "x z", "x", raw_chars = TRUE, code = TRUE) # errors without code = TRUE
gb("x*y", "x*z", "x", raw_chars = TRUE, code = TRUE) # correct way
gb("x*y", "x*z", "x", raw_chars = TRUE)










## End(Not run)
</code></pre>

<hr>
<h2 id='ideal'>Create a new ideal in Macaulay2</h2><span id='topic+ideal'></span><span id='topic+ideal.'></span><span id='topic+ideal_'></span><span id='topic+ideal_.'></span><span id='topic+print.m2_ideal'></span><span id='topic+print.m2_ideal_list'></span><span id='topic+radical'></span><span id='topic+radical.'></span><span id='topic+saturate'></span><span id='topic+saturate.'></span><span id='topic+quotient'></span><span id='topic+quotient.'></span><span id='topic+primary_decomposition'></span><span id='topic+primary_decomposition.'></span><span id='topic+dimension'></span><span id='topic++2B.m2_ideal'></span><span id='topic++2A.m2_ideal'></span><span id='topic++3D+3D.m2_ideal'></span><span id='topic++5E.m2_ideal'></span>

<h3>Description</h3>

<p>Create a new ideal in Macaulay2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ideal(..., raw_chars = FALSE, code = FALSE)

ideal.(..., raw_chars = FALSE, code = FALSE)

ideal_(x, raw_chars = FALSE, code = FALSE, ...)

ideal_.(x, raw_chars = FALSE, code = FALSE, ...)

## S3 method for class 'm2_ideal'
print(x, ...)

## S3 method for class 'm2_ideal_list'
print(x, ...)

radical(ideal, ring, code = FALSE, ...)

radical.(ideal, ring, code = FALSE, ...)

saturate(I, J, code = FALSE, ...)

saturate.(I, J, code = FALSE, ...)

quotient(I, J, code = FALSE, ...)

quotient.(I, J, code = FALSE, ...)

primary_decomposition(ideal, code = FALSE, ...)

primary_decomposition.(ideal, code = FALSE, ...)

dimension(ideal, code = FALSE, ...)

## S3 method for class 'm2_ideal'
e1 + e2

## S3 method for class 'm2_ideal'
e1 * e2

## S3 method for class 'm2_ideal'
e1 == e2

## S3 method for class 'm2_ideal'
e1 ^ e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ideal_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="ideal_+3A_raw_chars">raw_chars</code></td>
<td>
<p>if <code>TRUE</code>, the character vector will not be parsed by
<code><a href="mpoly.html#topic+mp">mp()</a></code>, saving time (default: <code>FALSE</code>). the down-side is that the
strings must be formated for M2 use directly, as opposed to for <code><a href="mpoly.html#topic+mp">mp()</a></code>.
(e.g. <code>"x*y+3"</code> instead of <code>"x y + 3"</code>)</p>
</td></tr>
<tr><td><code id="ideal_+3A_code">code</code></td>
<td>
<p>return only the M2 code? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="ideal_+3A_x">x</code></td>
<td>
<p>a listing of polynomials. several formats are accepted, see
examples.</p>
</td></tr>
<tr><td><code id="ideal_+3A_ideal">ideal</code></td>
<td>
<p>an ideal object of class <code>m2_ideal</code> or
<code>m2_ideal_pointer</code></p>
</td></tr>
<tr><td><code id="ideal_+3A_ring">ring</code></td>
<td>
<p>the referent ring in Macaulay2</p>
</td></tr>
<tr><td><code id="ideal_+3A_i">I</code>, <code id="ideal_+3A_j">J</code></td>
<td>
<p>ideals or objects parsable into ideals</p>
</td></tr>
<tr><td><code id="ideal_+3A_e1">e1</code>, <code id="ideal_+3A_e2">e2</code></td>
<td>
<p>ideals for arithmetic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a reference to a Macaulay2 ideal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2


##### basic usage
########################################

ring("x", "y", coefring = "QQ")
ideal("x + y", "x^2 + y^2")



##### different versions of gb
########################################

# standard evaluation version
poly_chars &lt;- c("x + y", "x^2 + y^2")
ideal_(poly_chars)

# reference nonstandard evaluation version
ideal.("x + y", "x^2 + y^2")

# reference standard evaluation version
ideal_.(poly_chars)



##### different inputs to gb
########################################

ideal_(   c("x + y", "x^2 + y^2") )
ideal_(mp(c("x + y", "x^2 + y^2")))
ideal_(list("x + y", "x^2 + y^2") )



##### predicate functions
########################################

I  &lt;- ideal ("x + y", "x^2 + y^2")
I. &lt;- ideal.("x + y", "x^2 + y^2")
is.m2_ideal(I)
is.m2_ideal(I.)
is.m2_ideal_pointer(I)
is.m2_ideal_pointer(I.)



##### ideal radical
########################################

I &lt;- ideal("(x^2 + 1)^2 y", "y + 1")
radical(I)
radical.(I)



##### ideal dimension
########################################

I &lt;- ideal_(c("(x^2 + 1)^2 y", "y + 1"))
dimension(I)

# dimension of a line
ring("x", "y", coefring = "QQ")
I &lt;- ideal("y - (x+1)")
dimension(I)

# dimension of a plane
ring("x", "y", "z", coefring = "QQ")
I &lt;- ideal("z - (x+y+1)")
dimension(I)



##### ideal quotients and saturation
########################################

ring("x", "y", "z", coefring = "QQ")
(I &lt;- ideal("x^2", "y^4", "z + 1"))
(J &lt;- ideal("x^6"))

quotient(I, J)
quotient.(I, J)

saturate(I)
saturate.(I)
saturate(I, J)
saturate(I, mp("x"))
saturate(I, "x")


ring("x", "y", coefring = "QQ")
saturate(ideal("x y"), "x^2")

# saturation removes parts of varieties
# solution over R is x = -1, 0, 1
ring("x", coefring = "QQ")
I &lt;- ideal("(x-1) x (x+1)")
saturate(I, "x") # remove x = 0 from solution
ideal("(x-1) (x+1)")



##### primary decomposition
########################################

ring("x", "y", "z", coefring = "QQ")
I &lt;- ideal("(x^2 + 1) (x^2 + 2)", "y + 1")
primary_decomposition(I)
primary_decomposition.(I)

I &lt;- ideal("x (x + 1)", "y")
primary_decomposition(I)

# variety = z axis union x-y plane
(I &lt;- ideal("x z", "y z"))
dimension(I) # =  max dimension of irreducible components
(Is &lt;- primary_decomposition(I))
dimension(Is)



##### ideal arithmetic
########################################

ring("x", "y", "z", coefring = "RR")

# sums (cox et al., 184)
(I &lt;- ideal("x^2 + y"))
(J &lt;- ideal("z"))
I + J

# products (cox et al., 185)
(I &lt;- ideal("x", "y"))
(J &lt;- ideal("z"))
I * J

# equality
(I &lt;- ideal("x", "y"))
(J &lt;- ideal("z"))
I == J
I == I

# powers
(I &lt;- ideal("x", "y"))
I^3


## End(Not run)
</code></pre>

<hr>
<h2 id='is'>Macaulay2 object tests</h2><span id='topic+is'></span><span id='topic+is.m2'></span><span id='topic+is.m2_pointer'></span><span id='topic+is.ring'></span><span id='topic+is.m2_polynomialring'></span><span id='topic+is.m2_polynomialring_pointer'></span><span id='topic+is.m2_grobner_basis'></span><span id='topic+is.m2_ideal'></span><span id='topic+is.m2_ideal_pointer'></span><span id='topic+is.m2_ideal_list'></span><span id='topic+is.m2_ideal_list_pointer'></span><span id='topic+is.m2_module'></span><span id='topic+is.m2_option'></span><span id='topic+is.m2_matrix'></span><span id='topic+is.m2_matrix_pointer'></span><span id='topic+is.m2_list'></span><span id='topic+is.m2_array'></span><span id='topic+is.m2_sequence'></span>

<h3>Description</h3>

<p>Predicate functions for Macaulay2 objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.m2(x)

is.m2_pointer(x)

is.ring(x)

is.m2_polynomialring(x)

is.m2_polynomialring_pointer(x)

is.m2_grobner_basis(x)

is.m2_ideal(x)

is.m2_ideal_pointer(x)

is.m2_ideal_list(x)

is.m2_ideal_list_pointer(x)

is.m2_module(x)

is.m2_option(x)

is.m2_matrix(x)

is.m2_matrix_pointer(x)

is.m2_list(x)

is.m2_array(x)

is.m2_sequence(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical(1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2

R &lt;- ring(c("x1", "x2", "x3"))
is.m2(R)
is.ring(R)
is.ring(10)
is.ring(mp("x+1"))


## End(Not run)
</code></pre>

<hr>
<h2 id='LLL'>LLL algorithm</h2><span id='topic+LLL'></span><span id='topic+LLL.'></span>

<h3>Description</h3>

<p>Macaulay2's implementation of the LLL algorithm. This implementation is still
under development and is currently untested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LLL(mat, control = list(), code = FALSE)

LLL.(mat, control = list(), code = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LLL_+3A_mat">mat</code></td>
<td>
<p>a matrix (integer entries)</p>
</td></tr>
<tr><td><code id="LLL_+3A_control">control</code></td>
<td>
<p>additional arguments to pass to LLL; see examples</p>
</td></tr>
<tr><td><code id="LLL_+3A_code">code</code></td>
<td>
<p>return only the M2 code? (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>m2_matrix</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+m2_matrix">m2_matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2

##### basic usage
########################################

# example 1
M &lt;- matrix(c(
  1, 1, 1, 1,
  2, 0, 3, 4,
  1, 0, 0, 0,
  0, 1, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
), nrow = 6, byrow = TRUE)

LLL(M)




# example 2 (wikipedia)
M &lt;- matrix(c(
  1, -1, 3,
  1,  0, 5,
  1,  2, 6
), nrow = 3, byrow = TRUE)

LLL(M)


##### control
########################################

M &lt;- matrix(c(
  1, 1, 1, 1,
  2, 0, 3, 4,
  1, 0, 0, 0,
  0, 1, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
), nrow = 6, byrow = TRUE)

LLL(M, code = TRUE)
LLL(M, control = list(Strategy = "NTL"), code = TRUE)
LLL(M, control = list(Strategy = c("BKZ", "RealFP")), code = TRUE)

LLL(M)
LLL(M, control = list(Strategy = "NTL"))
LLL(M, control = list(Strategy = c("BKZ", "RealFP")))
LLL(M, control = list(Strategy = c("BKZ", "RealQP")))



# method timings with microbenchmark.  note they are roughly the same
# for this example matrix
microbenchmark::microbenchmark(
  "NTL" = LLL(M, control = list(Strategy = "NTL")),
  "BKZ_RealFP" = LLL(M, control = list(Strategy = c("BKZ", "RealFP"))),
  "BKZ_RealQP" = LLL(M, control = list(Strategy = c("BKZ", "RealQP"))),
  "BKZ_RealRR" = LLL(M, control = list(Strategy = c("BKZ", "RealRR")))
)



##### additional examples
########################################

LLL.(M)
LLL(M, code = TRUE)




## End(Not run)

</code></pre>

<hr>
<h2 id='m2_call'>Call and reset a Macaulay2 process</h2><span id='topic+m2_call'></span><span id='topic+m2r_version_number'></span><span id='topic+m2r_cloud_url'></span><span id='topic+has_m2_connection'></span><span id='topic+start_m2'></span><span id='topic+stop_m2'></span><span id='topic+reset_m2'></span><span id='topic+m2'></span><span id='topic+m2.'></span><span id='topic+print.m2_pointer'></span>

<h3>Description</h3>

<p>Call and reset a Macaulay2 process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2r_version_number()

m2r_cloud_url()

has_m2_connection()

start_m2(
  port = 27436L,
  timeout = 10,
  attempts = 10,
  cloud = FALSE,
  hostname = m2r_cloud_url()
)

stop_m2()

reset_m2(
  port = 27436L,
  timeout = 10,
  attempts = 10,
  hostname = "ec2-52-10-66-241.us-west-2.compute.amazonaws.com"
)

m2(code, timeout = -1)

m2.(code, timeout = -1)

## S3 method for class 'm2_pointer'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2_call_+3A_port">port</code></td>
<td>
<p>port for Macaulay2 socket</p>
</td></tr>
<tr><td><code id="m2_call_+3A_timeout">timeout</code></td>
<td>
<p>number of seconds before aborting</p>
</td></tr>
<tr><td><code id="m2_call_+3A_attempts">attempts</code></td>
<td>
<p>numer of times to try to make connection</p>
</td></tr>
<tr><td><code id="m2_call_+3A_cloud">cloud</code></td>
<td>
<p>use a cloud?</p>
</td></tr>
<tr><td><code id="m2_call_+3A_hostname">hostname</code></td>
<td>
<p>the remote host to connect to; defaults to the Amazon EC2
instance</p>
</td></tr>
<tr><td><code id="m2_call_+3A_code">code</code></td>
<td>
<p>Macaulay2 code</p>
</td></tr>
<tr><td><code id="m2_call_+3A_x">x</code></td>
<td>
<p>formal argument for print method</p>
</td></tr>
<tr><td><code id="m2_call_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m2 return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2

m2("1 + 1")
m2.("1 + 1")

m2("factor 32004")

# run a chunk of m2 code, only pulling the end value back into R
m2("
  R = QQ[a..d]
  I = ideal(a^3-b^2*c, b*c^2-c*d^2, c^3)
  G = gens gb I
")

# illustrate the persistent connection
m2("a = 1 + 1")
m2("a")
reset_m2()
m2("a")


# forcing a cloud start
if(has_m2_connection()) stop_m2()
start_m2(cloud = TRUE)
m2("1 + 1")
stop_m2()



m2.("peek(QQ[x,y,z])")
m2("peek(QQ[x,y,z])")

# m2 returns in its ext_str position the result of running
# toExternalString on the return value of the chunk of code
# you run. in principle, toExternalString provides the code
# needed to recreate the m2 object of interest. however,
# does not work for all objects representable in the m2 language.
# in particular, mutable objects are not supported.
# this is what happens when you look at those:
m2.("new MutableList from {1,2,3}")
m2("new MutableList from {1,2,3}")


## End(Not run)
</code></pre>

<hr>
<h2 id='m2_matrix'>Create a new matrix in Macaulay2</h2><span id='topic+m2_matrix'></span><span id='topic+m2_matrix.'></span><span id='topic+m2_numrows'></span><span id='topic+m2_numcols'></span><span id='topic+m2_length'></span><span id='topic+print.m2_matrix'></span><span id='topic+print.m2_image'></span><span id='topic+m2_kernel'></span><span id='topic+m2_kernel.'></span>

<h3>Description</h3>

<p>Create a new matrix in Macaulay2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2_matrix(mat, ring, name, code = FALSE)

m2_matrix.(mat, ring, name, code = FALSE)

m2_numrows(x, code = FALSE, ...)

m2_numcols(x, code = FALSE, ...)

m2_length(x, code = FALSE, ...)

## S3 method for class 'm2_matrix'
print(x, ...)

## S3 method for class 'm2_image'
print(x, ...)

m2_kernel(mat, name, code = FALSE)

m2_kernel.(mat, name, code = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2_matrix_+3A_mat">mat</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="m2_matrix_+3A_ring">ring</code></td>
<td>
<p>a ring containing the matrix entries</p>
</td></tr>
<tr><td><code id="m2_matrix_+3A_name">name</code></td>
<td>
<p>the <code>m2_name</code> of the object, which is it's name
on the M2 side</p>
</td></tr>
<tr><td><code id="m2_matrix_+3A_code">code</code></td>
<td>
<p>return only the M2 code? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="m2_matrix_+3A_x">x</code></td>
<td>
<p>formal argument for print method</p>
</td></tr>
<tr><td><code id="m2_matrix_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>m2_matrix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2

##### basic usage
########################################

(mat &lt;- m2_matrix(matrix(c(1,2,3,4,5,6), nrow = 3, ncol = 2)))
m2_matrix(matrix(c(1,2,3,4,5,6), nrow = 3, ncol = 2))

m2_name(mat)
m2(m2_name(mat))
m2(sprintf("class(%s)", m2_name(mat)))
(mat &lt;- m2_matrix.(matrix(c(1,2,3,4,5,6), nrow = 3, ncol = 2)))

##### known issues
########################################

ring("x", "y", "z", coefring = "QQ")
(mat &lt;- matrix(mp(c("x","y","x+y","y-2","x-3","y-z")), nrow = 2, ncol = 3))
m2_matrix(mat, code = TRUE)
m2_matrix(mat)
# the above is an mpoly problem, not a m2r problem
# mpoly does not have a data structure for matrices (as of 12/2016)

mat_chars &lt;- sapply(m2_matrix(mat), print, silent = TRUE)
dim(mat_chars) &lt;- c(2, 3)
mat_chars


m2_numrows(mat)
m2_numcols(mat)
m2_parse(mat)

(mat &lt;- m2_matrix(matrix(c(1,2),nrow=1)))
m2_kernel(mat)


## End(Not run)
</code></pre>

<hr>
<h2 id='m2_parser'>Convert a M2 object into an R object</h2><span id='topic+m2_parser'></span><span id='topic+m2_parse'></span><span id='topic+print.m2_integer'></span><span id='topic+print.m2_float'></span><span id='topic+print.m2_complex'></span><span id='topic+print.m2_string'></span><span id='topic+print.m2_boolean'></span><span id='topic+print.m2_list'></span><span id='topic+print.m2_array'></span><span id='topic+print.m2_sequence'></span><span id='topic+print.m2_symbol'></span><span id='topic+print.m2_option'></span><span id='topic+print.m2_hashtable'></span><span id='topic+print.m2_module'></span><span id='topic+m2_toggle_gmp'></span><span id='topic+get_m2_gmp'></span>

<h3>Description</h3>

<p>Convert a M2 object into an R object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2_parse(s)

## S3 method for class 'm2_integer'
print(x, ...)

## S3 method for class 'm2_float'
print(x, ...)

## S3 method for class 'm2_complex'
print(x, ...)

## S3 method for class 'm2_string'
print(x, ...)

## S3 method for class 'm2_boolean'
print(x, ...)

## S3 method for class 'm2_list'
print(x, ...)

## S3 method for class 'm2_array'
print(x, ...)

## S3 method for class 'm2_sequence'
print(x, ...)

## S3 method for class 'm2_symbol'
print(x, ...)

## S3 method for class 'm2_option'
print(x, ...)

## S3 method for class 'm2_hashtable'
print(x, ...)

## S3 method for class 'm2_module'
print(x, ...)

m2_toggle_gmp()

get_m2_gmp()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2_parser_+3A_s">s</code></td>
<td>
<p>a character(1), typically the result of running toExternalString on
an M2 object</p>
</td></tr>
<tr><td><code id="m2_parser_+3A_x">x</code></td>
<td>
<p>an object to be printed</p>
</td></tr>
<tr><td><code id="m2_parser_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an R object
</p>


<h3>References</h3>

<p>D. Kahle, C. O'Neill, and J. Sommars (2020). &quot;A Computer Algebra
System for R: Macaulay2 and the m2r Package.&quot; Journal of Statistical
Software, 93(9):1-31.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2

m2("1+1")
m2.("1+1")
m2_parse(m2.("1+1"))

m2("QQ[x,y]")
m2.("QQ[x,y]")
m2_parse(m2.("QQ[x,y]"))

get_m2_gmp()
m2("3/2") %&gt;% m2_parse()
m2_toggle_gmp() # gmp on
m2("3/2") %&gt;% m2_parse()
m2("6/4") %&gt;% m2_parse()
m2("3345234524352435432/223454325235432524352433245") %&gt;% m2_parse()
m2_toggle_gmp() # gmp off



m2("50!") %&gt;% m2_parse()
m2_toggle_gmp() # gmp on
m2("50!") %&gt;% m2_parse()
m2_toggle_gmp() # gmp off


## End(Not run)
</code></pre>

<hr>
<h2 id='m2_path'>Set path to Macaulay2 (M2)</h2><span id='topic+m2_path'></span><span id='topic+set_m2_path'></span><span id='topic+get_m2_path'></span><span id='topic+get_m2_connection'></span><span id='topic+get_m2_con'></span><span id='topic+get_m2_procid'></span><span id='topic+get_m2_port'></span>

<h3>Description</h3>

<p>These are helper functions that deal with pathing to Macaulay2 and asking if it
is present. When the Macaulay2 package is loaded it attempts to find the
Macaulay2 executable by looking for an environment variable indicating where it
is, i.e. its path as specified in your .Renviron file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_m2_path(path = NULL)

get_m2_path()

get_m2_connection()

get_m2_con()

get_m2_procid()

get_m2_port()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2_path_+3A_path">path</code></td>
<td>
<p>A character string, the path to M2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For easiest use, you'll want to specify the path the Macaulay2 executable in
your ~/.Renviron file. It should look something like
</p>
<p><code>M2=/Applications/Macaulay2-1.10/bin</code>
</p>
<p>You can set this permanently with <code><a href="#topic+edit_r_environ">edit_r_environ()</a></code>. Note that absolute
paths should be specified, not relative paths, e.g. don't use ~/path/to/exe.
</p>
<p>You can change this for the current session using <code><a href="#topic+set_m2_path">set_m2_path()</a></code>, which
accepts a character string or, if missing, uses <code><a href="base.html#topic+file.choose">file.choose()</a></code> to let you
interactively; you just select an arbitrary executable.
</p>
<p>On Windows, m2r just defaults to the cloud implementation. Local M2 instances
are not currently supported on Windows.
</p>


<h3>Value</h3>

<p>An invisible character string, the path found.  More importantly, the
function has the side effect of setting the global m2r option &quot;m2_path&quot;
</p>


<h3>Author(s)</h3>

<p>David Kahle <a href="mailto:david@kahle.com">david@kahle.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2


getOption("m2r")
get_m2_path()
set_m2_path()


## each of these functions can be used statically as well
(m2_path &lt;- get_m2_path())
set_m2_path("/path/to/m2/directory")
get_m2_path()
set_m2_path(m2_path) # undoes example


# if you'd like to use the cloud, after you library(m2r)
# and before you use m2() type
set_m2_path(NULL)

# alternatively, if you have already been using m2, do:
stop_m2()
set_m2_path(NULL)
m2("1+1")



## End(Not run)
</code></pre>

<hr>
<h2 id='m2_utility'>Utility tools for M2</h2><span id='topic+m2_utility'></span><span id='topic+m2_name'></span><span id='topic+m2_name+3C-'></span><span id='topic+m2_meta'></span><span id='topic+m2_meta+3C-'></span><span id='topic+m2_structure'></span><span id='topic+m2_exists'></span><span id='topic+m2_ls'></span><span id='topic+m2_rm'></span><span id='topic+m2_getwd'></span>

<h3>Description</h3>

<p>Utility tools for M2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2_name(x)

m2_name(x) &lt;- value

m2_meta(x, m2_attr)

m2_meta(x, m2_attr) &lt;- value

m2_structure(x = NA, m2_name, m2_class, m2_meta, base_class)

m2_exists(name)

m2_ls(all.names = FALSE)

m2_rm(name)

m2_getwd()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2_utility_+3A_x">x</code></td>
<td>
<p>an object of class <code>m2</code></p>
</td></tr>
<tr><td><code id="m2_utility_+3A_value">value</code></td>
<td>
<p>the value to assign</p>
</td></tr>
<tr><td><code id="m2_utility_+3A_m2_attr">m2_attr</code></td>
<td>
<p>the name of an M2 attribute</p>
</td></tr>
<tr><td><code id="m2_utility_+3A_m2_name">m2_name</code></td>
<td>
<p><code>m2_name</code>  M2 attribute</p>
</td></tr>
<tr><td><code id="m2_utility_+3A_m2_class">m2_class</code></td>
<td>
<p><code>m2_class</code> M2 attribute</p>
</td></tr>
<tr><td><code id="m2_utility_+3A_m2_meta">m2_meta</code></td>
<td>
<p><code>m2_meta</code>  M2 attribute</p>
</td></tr>
<tr><td><code id="m2_utility_+3A_base_class">base_class</code></td>
<td>
<p>a base class; an R class to use for dispatching
if there is no relevant method for the other classes (e.g.
<code>m2</code>)</p>
</td></tr>
<tr><td><code id="m2_utility_+3A_name">name</code></td>
<td>
<p>a string; the name of a M2 object</p>
</td></tr>
<tr><td><code id="m2_utility_+3A_all.names">all.names</code></td>
<td>
<p>if <code>TRUE</code>, all registered Macaulay2
variables, including ones internally used by m2r, will be
returned</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2

m2("a = 5")
m2_ls()
m2_exists("a")
m2("b = 1")
m2_exists(c("a","b","c"))

m2_getwd()

x &lt;- 1
class(x) &lt;- "m2"
attr(x, "m2_meta") &lt;- list(a = 1, b = 2)
m2_meta(x)
m2_meta(x, "b")
m2_meta(x, "b") &lt;- 5
m2_meta(x, "b")

# R &lt;- ring(c("x1", "x2", "x3"))
# m2_name(R)
# m2(sprintf("class %s", m2_name(R)))
# m2_ls()
# m2_rm(m2_name(R))
# m2_ls()
# m2(paste("class", m2_name(R)))

m2_ls()
m2_ls(all.names = TRUE)



## End(Not run)
</code></pre>

<hr>
<h2 id='m2r'>Macaulay2 in R</h2><span id='topic+m2r'></span><span id='topic+package-m2r'></span>

<h3>Description</h3>

<p>m2r provides a persistent interface to Macaulay2
(<a href="http://www.math.uiuc.edu/Macaulay2/">http://www.math.uiuc.edu/Macaulay2/</a>) and front-end tools facilitating
its use in the R ecosystem. For details, see vignette(&quot;m2r&quot;).
</p>


<h3>References</h3>

<p>D. Kahle, C. O'Neill, and J. Sommars (2020). &quot;A Computer Algebra
System for R: Macaulay2 and the m2r Package.&quot; Journal of Statistical
Software, 93(9):1-31.
</p>

<hr>
<h2 id='phc'>PHCpack</h2><span id='topic+phc'></span><span id='topic+solve_system'></span><span id='topic+solve_system.'></span><span id='topic+mixed_volume'></span>

<h3>Description</h3>

<p>Call PHCpack to solve a zero-dimensional system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_system(mpolyList)

solve_system.(mpolyList)

mixed_volume(mpolyList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phc_+3A_mpolylist">mpolyList</code></td>
<td>
<p>An mpolyList object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>solve_system()</code> doesn't take in an input ring
because the solver only works over the complex numbers.
</p>


<h3>Value</h3>

<p>(currently) the output of an m2() call (string?)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2

# for this to work, you need to have modified your
# init-PHCpack.m2 file instead of changing your .bashrc
# file to establish the path of phc
# (**clarify**, maybe checkout algstat::polySolve)

(mpolyList &lt;- mp(c("t^4 - x", "t^3 - y", "t^2 - z", "x+y+z")))
solve_system(mpolyList)
mixed_volume(mpolyList)


## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+edit_r_environ'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>usethis</dt><dd><p><code><a href="usethis.html#topic+edit_r_environ">edit_r_environ</a></code></p>
</dd>
</dl>

<hr>
<h2 id='ring'>Create a new ring in Macaulay2</h2><span id='topic+ring'></span><span id='topic+ring.'></span><span id='topic+ring_'></span><span id='topic+ring_.'></span><span id='topic+m2_coefrings'></span><span id='topic+m2_termorders'></span><span id='topic+print.m2_polynomialring'></span>

<h3>Description</h3>

<p>Create a new ring in Macaulay2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ring(..., coefring = m2_coefrings(), order = m2_termorders(), code = FALSE)

ring.(..., coefring = m2_coefrings(), order = m2_termorders(), code = FALSE)

ring_(
  vars,
  coefring = m2_coefrings(),
  order = m2_termorders(),
  code = FALSE,
  ...
)

ring_.(
  vars,
  coefring = m2_coefrings(),
  order = m2_termorders(),
  code = FALSE,
  ...
)

m2_coefrings()

m2_termorders()

## S3 method for class 'm2_polynomialring'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ring_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="ring_+3A_coefring">coefring</code></td>
<td>
<p>coefficient ring (default: <code>"CC"</code>)</p>
</td></tr>
<tr><td><code id="ring_+3A_order">order</code></td>
<td>
<p>a term order (default: <code>"grevlex"</code>)</p>
</td></tr>
<tr><td><code id="ring_+3A_code">code</code></td>
<td>
<p>return only the M2 code? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="ring_+3A_vars">vars</code></td>
<td>
<p>vector of variable names</p>
</td></tr>
<tr><td><code id="ring_+3A_x">x</code></td>
<td>
<p>formal argument for print method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a reference to a Macaulay2 ring
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2

##### basic usage
########################################

ring("x", "y")
ring("x", "y", coefring = "QQ")


##### standard evaluation
########################################

ring_(c("x", "y"))
ring_(c("x", "y"), code = TRUE)

(myring &lt;- ring_(c("x1","x2","x3","y"), coefring = "QQ", order = "lex"))

m2_name(myring)
m2_meta(myring, "vars")
m2_meta(myring, "coefring")
m2_meta(myring, "order")

##### other options
########################################

ring_.(c("x", "y"))
ring_.(c("x", "y"), code = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='snf'>Smith normal form</h2><span id='topic+snf'></span><span id='topic+snf.'></span>

<h3>Description</h3>

<p>For an integer matrix M, this computes the matrices D, P, and Q such that
<em>D = PMQ</em>, which can be seen as an analogue of the singular value
decomposition. All are integer matrices, and P and Q are unimodular (have
determinants +- 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snf(mat, code = FALSE)

snf.(mat, code = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snf_+3A_mat">mat</code></td>
<td>
<p>a matrix (integer entries)</p>
</td></tr>
<tr><td><code id="snf_+3A_code">code</code></td>
<td>
<p>return only the M2 code? (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code>m2_matrix</code> objects with names <code>D</code>, <code>P</code>, and
<code>Q</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+m2_matrix">m2_matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2

##### basic usage
########################################

M &lt;- matrix(c(
   2,  4,   4,
  -6,  6,  12,
  10, -4, -16
), nrow = 3, byrow = TRUE)

snf(M)

(mats &lt;- snf(M))
P &lt;- mats$P; D &lt;- mats$D; Q &lt;- mats$Q

P %*% M %*% Q                # = D
solve(P) %*% D %*% solve(Q)  # = M

det(P)
det(Q)


M &lt;- matrix(c(
     1,    2,    3,
     1,   34,   45,
  2213, 1123, 6543,
     0,    0,    0
), nrow = 4, byrow = TRUE)
(mats &lt;- snf(M))
P &lt;- mats$P; D &lt;- mats$D; Q &lt;- mats$Q
P %*% M %*% Q                # = D



##### understanding lattices
########################################




# cols of m generate the lattice L
M &lt;- matrix(c(2,-1,1,3), nrow = 2)
row.names(M) &lt;- c("x", "y")
M

# plot lattice
df &lt;- expand.grid(x = -20:20, y = -20:20)
pts &lt;- t(apply(df, 1, function(v) M %*% v))
w &lt;- c(-15, 15)
plot(pts, xlim = w, ylim = w)

# decompose m
(mats &lt;- snf(M))
P &lt;- mats$P; D &lt;- mats$D; Q &lt;- mats$Q

# PMQ = D, the columns of MQ = P^(-1) D  are a simpler basis of
# the lattice generated by (the cols of) M
(basis &lt;- solve(P) %*% D)

# plot lattice generated by new basis
pts2 &lt;- t(apply(df, 1, function(v) basis %*% v))
points(pts2, pch = "*", col = "red")



##### other options
########################################

snf.(M)
snf(M, code = TRUE)





## End(Not run)

</code></pre>

<hr>
<h2 id='str_m2'>Give the structure of a Macaulay2 ring</h2><span id='topic+str_m2'></span>

<h3>Description</h3>

<p>Give the structure of a Macaulay2 ring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_m2(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_m2_+3A_object">object</code></td>
<td>
<p>An <code>m2</code> object</p>
</td></tr>
<tr><td><code id="str_m2_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible the object passed in.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2

a &lt;- m2("1")

R &lt;- ring(c("x1", "x2", "x3"))
str_m2(R)
str_m2.default(R)


## End(Not run)

</code></pre>

<hr>
<h2 id='use_ring'>Set Macaulay2 ring</h2><span id='topic+use_ring'></span>

<h3>Description</h3>

<p><code>use_ring()</code> sets the default referent ring on the Macaulay2
side using the <code>use</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_ring(ring)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_ring_+3A_ring">ring</code></td>
<td>
<p>a <code>m2_ring</code> (see <code><a href="#topic+ring">ring()</a></code>),
<code>m2_ring_pointer</code> (see <code><a href="#topic+ring.">ring.()</a></code>), or a character
string containing the name of a ring in Macaulay2</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  requires Macaulay2


##### basic usage
########################################

ring("x", coefring = "QQ")
factor_poly("x^4 + 1")

QQtxyz &lt;- ring("t","x","y","z", coefring = "QQ")
gb("t^4 - x", "t^3 - y", "t^2 - z")

ring("x", "y", "z", "t", coefring = "QQ")
gb("t^4 - x", "t^3 - y", "t^2 - z")

use_ring(QQtxyz)
gb("t^4 - x", "t^3 - y", "t^2 - z")


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
