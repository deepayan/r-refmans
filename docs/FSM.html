<!DOCTYPE html><html><head><title>Help for package FSM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FSM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#crd'><p>Completely Randomized Design (CRD)</p></a></li>
<li><a href='#ess_model'><p>Model-based Effective Sample Size (ESS)</p></a></li>
<li><a href='#ess_rand'><p>Randomization-based Effective Sample Size (ESS)</p></a></li>
<li><a href='#fsm'><p>Finite Selection Model (FSM)</p></a></li>
<li><a href='#fsm_batch'><p>Batched FSM for sequential experiments</p></a></li>
<li><a href='#Lalonde'><p>The Lalonde experimental dataset</p></a></li>
<li><a href='#love_plot'><p>Love plot</p></a></li>
<li><a href='#make_sq_inter'><p>Squares and two-way interactions of variables</p></a></li>
<li><a href='#perm_test'><p>Fisher's randomization test for sharp null hypothesis.</p></a></li>
<li><a href='#som'><p>Selection Order Matrix (SOM)</p></a></li>
<li><a href='#tasmd_rand'><p>Target Absolute Standardized Mean Differences (TASMD)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Finite Selection Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Randomized and balanced allocation of units to treatment groups using the Finite Selection Model (FSM). The FSM was originally proposed and developed at the RAND corporation by Carl Morris to enhance the experimental design for the now famous Health Insurance Experiment. See Morris (1979) &lt;<a href="https://doi.org/10.1016%2F0304-4076%2879%2990053-8">doi:10.1016/0304-4076(79)90053-8</a>&gt; for details on the original version of the FSM.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-07 19:58:13 UTC; Ambarish</td>
</tr>
<tr>
<td>Author:</td>
<td>Ambarish Chattopadhyay [aut, cre],
  Carl Morris [aut],
  Jose Zubizarreta [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ambarish Chattopadhyay &lt;ambarish_chattopadhyay@g.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-10 19:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='crd'>Completely Randomized Design (CRD)</h2><span id='topic+crd'></span>

<h3>Description</h3>

<p>Generates an assignment under completely randomized design (CRD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crd(data_frame, n_treat, treat_sizes, control = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crd_+3A_data_frame">data_frame</code></td>
<td>
<p>A data frame corresponding to the full sample of units.</p>
</td></tr>
<tr><td><code id="crd_+3A_n_treat">n_treat</code></td>
<td>
<p>Number of treatment groups.</p>
</td></tr>
<tr><td><code id="crd_+3A_treat_sizes">treat_sizes</code></td>
<td>
<p>A vector of treatment group sizes. If <code>control = TRUE</code>, 
the first element of <code>treat_sizes</code> should be the control group size.</p>
</td></tr>
<tr><td><code id="crd_+3A_control">control</code></td>
<td>
<p>If <code>TRUE</code>, treatments are labeled as 0,1,...,g-1 (0 representing the control group). 
If <code>FALSE</code>, they are labeled as 1,2,...,g.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original data frame augmented with the column of the treatment indicator.
</p>


<h3>Author(s)</h3>

<p>Ambarish Chattopadhyay, Carl N. Morris and Jose R. Zubizarreta.
</p>


<h3>References</h3>

<p>Chattopadhyay, A., Morris, C. N., and Zubizarreta, J. R. (2020), 
&ldquo;Randomized and Balanced Allocation of Units into Treatment Groups Using the Finite Selection Model for <code>R</code>&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider N = 12, n1 = n2 = n3 = 4.
df_sample = data.frame(index = 1:12, x = c(20,30,40,40,50,60,20,30,40,40,50,60))
# Draw a random assignment from CRD.
fc = crd(data_frame = df_sample, n_treat = 3, treat_sizes = c(4,4,4))
# Get vector of treatment assignments.
Z_crd = fc$Treat
</code></pre>

<hr>
<h2 id='ess_model'>Model-based Effective Sample Size (ESS)</h2><span id='topic+ess_model'></span>

<h3>Description</h3>

<p>Computes the model-based effective sample size (ESS) of a collection of assignments 
under a given set of potential outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ess_model(X_cov, assign_matrix, Y_mat, contrast = c(1, -1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_model_+3A_x_cov">X_cov</code></td>
<td>
<p>A matrix of covariates or transformations thereof that will be used
as explanatory variables in the linear outcome models within each treatment group.</p>
</td></tr>
<tr><td><code id="ess_model_+3A_assign_matrix">assign_matrix</code></td>
<td>
<p>A matrix containing a collection of treatment assignment vectors, each column
containing a particular assignment vector.</p>
</td></tr>
<tr><td><code id="ess_model_+3A_y_mat">Y_mat</code></td>
<td>
<p>A matrix of potential outcomes, where rows represent units and columns represent treatment
levels (ordered).</p>
</td></tr>
<tr><td><code id="ess_model_+3A_contrast">contrast</code></td>
<td>
<p>A vector of the coefficients of the treatment contrast of interest. For example, for estimating the
average treatment effect of treatment 1 versus treatment 2, <code>contrast = c(1,-1)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of effective sample sizes for the given collection of assignments.
</p>


<h3>Author(s)</h3>

<p>Ambarish Chattopadhyay, Carl N. Morris and Jose R. Zubizarreta.
</p>


<h3>References</h3>

<p>Chattopadhyay, A., Morris, C. N., and Zubizarreta, J. R. (2020), &ldquo;Randomized and Balanced Allocation 
of Units into Treatment Groups Using the Finite Selection Model for <code>R</code>&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider the Lalonde dataset.
# Get the full sample size.
N = nrow(Lalonde)
# Get the treatment group sizes.
n1 = floor(N/2)
n2 = N-n1
# Generate an SOM.
som_obs = som(n_treat = 2, treat_sizes = c(n1,n2),include_discard = FALSE,
method = 'SCOMARS', marginal_treat = rep((n2/N),N), control = FALSE)
# Generate a treatment assignment given som_obs.
f = fsm(data_frame = Lalonde, SOM = som_obs, s_function = 'Dopt', eps = 0.0001, 
ties = 'random', intercept = TRUE, standardize = TRUE, units_print = FALSE)
# Get assignment vector under the FSM.
Z_fsm_obs = f$data_frame_allocated$Treat
# Draw a random CRD.
Z_crd_obs = crd(data_frame = Lalonde, n_treat = 2, treat_sizes = c(n1, n2), 
control = FALSE)$Treat
Z_big = cbind(Z_crd_obs, Z_fsm_obs)
# Generate the potential outcomes.
Y_1 = 100 - Lalonde$Age + 6 * Lalonde$Education - 20 * Lalonde$Black + 
20 * Lalonde$Hispanic + 0.003 * Lalonde$Re75 + rnorm(N,0,4)
Y_1 = round(Y_1,2)
# Set unit level causal effect = tau = 0.
tau = 0
Y_2 = Y_1 + tau
# Get the matrix of potential outcomes.
Y_appended = cbind(Y_1, Y_2)
# Get the matrix of covariates.
X_cov = Lalonde[,-1]
ess = ess_model(X_cov = X_cov, assign_matrix = Z_big, Y_mat = Y_appended, contrast = c(1,-1))
</code></pre>

<hr>
<h2 id='ess_rand'>Randomization-based Effective Sample Size (ESS)</h2><span id='topic+ess_rand'></span>

<h3>Description</h3>

<p>Computes the randomization-based effective sample size (ESS) of a collection of assignments 
under a given set of potential outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ess_rand(assign_array, Y_mat, contrast = c(1, -1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_rand_+3A_assign_array">assign_array</code></td>
<td>
<p>A three dimensional array containing a set of independent realizations of a
collection the designs. The first coordinate of the array represents the iterations for
each design. The second coordinate represents the units. The third coordinate represents the design.</p>
</td></tr>
<tr><td><code id="ess_rand_+3A_y_mat">Y_mat</code></td>
<td>
<p>A matrix of potential outcomes, where rows represent units and columns represent treatment
levels (ordered).</p>
</td></tr>
<tr><td><code id="ess_rand_+3A_contrast">contrast</code></td>
<td>
<p>A vector of the coefficients of the treatment contrast of interest. For example, for estimating the
average treatment effect of treatment 1 versus treatment 2, <code>contrast = c(1,-1)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of effective sample sizes for the given collection of assignments.
</p>


<h3>Author(s)</h3>

<p>Ambarish Chattopadhyay, Carl N. Morris and Jose R. Zubizarreta.
</p>


<h3>References</h3>

<p>Chattopadhyay, A., Morris, C. N., and Zubizarreta, J. R. (2020), &ldquo;Randomized and Balanced Allocation 
of Units into Treatment Groups Using the Finite Selection Model for <code>R</code>&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider N = 12, n1 = n2 = 6.
df_sample = data.frame(index = 1:12, x = c(20,30,40,40,50,60,20,30,40,40,50,60))
# Generate the potential outcomes.
Y_1 = 100 + (df_sample$x - mean(df_sample$x)) + rnorm(12, 0, 4)
Y_2 = Y_1 + 50
# Create matrix of potential outcomes.
Y_appended = cbind(Y_1, Y_2)
# Generate 100 assignments under CRD and the FSM.
Z_crd_iter = matrix(rep(0, 100 * 12), nrow = 100)
Z_fsm_iter = matrix(rep(0, 100 * 12), nrow = 100)
for(i in 1:100)
{
# Generate an assignment vector under CRD.
fc = crd(data_frame = df_sample, n_treat = 2, treat_sizes = c(6,6), control = FALSE)
Z_crd_iter[i,] = fc$Treat
# Generate an assignment vector under the FSM.
som_iter = som(data_frame = NULL, n_treat = 2, 
treat_sizes = c(6, 6),include_discard = FALSE,
method = 'SCOMARS', marginal_treat = rep((6/12), 12), control = FALSE)
f = fsm(data_frame = df_sample, SOM = som_iter, s_function = 'Dopt',eps = 0.0001, 
ties = 'random', intercept = TRUE, standardize = TRUE, units_print = FALSE)
Z_fsm_iter[i,] = f$data_frame_allocated$Treat
}
# Create a 3-dim array of assignments.
Z_array = array(0, dim = c(100, 12, 2))
Z_array[,,1] = Z_crd_iter
Z_array[,,2] = Z_fsm_iter
# Calculate the ESS.
ess_rand(assign_array = Z_array, Y_mat = Y_appended, contrast = c(1,-1))
</code></pre>

<hr>
<h2 id='fsm'>Finite Selection Model (FSM)</h2><span id='topic+fsm'></span>

<h3>Description</h3>

<p>Generates a randomized assignment of a group of units to multiple groups of pre-determined 
sizes using the Finite Selection Model (FSM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsm(
  data_frame,
  SOM,
  s_function = "Dopt",
  Q_initial = NULL,
  eps = 0.001,
  ties = "random",
  intercept = TRUE,
  standardize = TRUE,
  units_print = TRUE,
  index_col = TRUE,
  Pol_mat = NULL,
  w_pol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsm_+3A_data_frame">data_frame</code></td>
<td>
<p>A data frame containing a column of unit indices (optional) and covariates (or transformations thereof).</p>
</td></tr>
<tr><td><code id="fsm_+3A_som">SOM</code></td>
<td>
<p>A selection order matrix.</p>
</td></tr>
<tr><td><code id="fsm_+3A_s_function">s_function</code></td>
<td>
<p>Specifies a selection function, a string among <code>'constant'</code>, <code>'Dopt'</code>, 
<code>'Aopt'</code>, <code>'max pc'</code>, <code>'min pc'</code>, <code>'Dopt pc'</code>, <code>'max average'</code>, <code>'min average'</code>,
<code>'Dopt average'</code>. <code>'constant'</code> selection function puts a constant value on every unselected unit. 
<code>'Dopt'</code> use the D-optimality criteria based on the full set of covariates to select units. 
<code>'Aopt'</code> uses the A-optimality criteria. <code>'max pc'</code> (respectively, <code>'min pc'</code>) selects that 
unit that has the maximum (respectively, minimum) value of the first principal component. 
<code>'Dopt pc'</code> uses the D-optimality criteria on the first principal component, <code>'max average'</code> 
(respectively, <code>'min average'</code>) selects that unit that has the maximum (respectively, minimum) 
value of the simple average of the covariates. <code>'Dopt average'</code> uses the D-optimality criteria on the 
simple average of the covariates.</p>
</td></tr>
<tr><td><code id="fsm_+3A_q_initial">Q_initial</code></td>
<td>
<p>A (optional) non-singular matrix (called 'initial matrix') that is added the <code class="reqn">(X^T X)</code> 
matrix of the choosing treatment group at any stage, when the <code class="reqn">(X^T X)</code> matrix of that treatment group
at that stage is non-invertible. If <code>FALSE</code>, the <code class="reqn">(X^T X)</code> matrix for the full set of observations is used
as the non-singular matrix. Applicable if <code>s_function = 'Dopt'</code> or <code>'Aopt'</code>.</p>
</td></tr>
<tr><td><code id="fsm_+3A_eps">eps</code></td>
<td>
<p>Proportionality constant for <code>Q_initial</code>, the default value is 0.001.</p>
</td></tr>
<tr><td><code id="fsm_+3A_ties">ties</code></td>
<td>
<p>Specifies how to deal with ties in the values of the selection function. If <code>ties = 'random'</code>,
a unit is selected randomly from the set of candidate units. If <code>ties = 'smallest'</code>, the unit 
that appears earlier in the data frame, i.e. the unit with the smallest index gets selected.</p>
</td></tr>
<tr><td><code id="fsm_+3A_intercept">intercept</code></td>
<td>
<p>if <code>TRUE</code>, the design matrix of each treatment group includes a column of intercepts.</p>
</td></tr>
<tr><td><code id="fsm_+3A_standardize">standardize</code></td>
<td>
<p>if <code>TRUE</code>, the columns of the <code class="reqn">X</code> matrix other than the column for the intercept (if any), 
are standardized.</p>
</td></tr>
<tr><td><code id="fsm_+3A_units_print">units_print</code></td>
<td>
<p>if <code>TRUE</code>, the function automatically prints the candidate units at each step of selection.</p>
</td></tr>
<tr><td><code id="fsm_+3A_index_col">index_col</code></td>
<td>
<p>if <code>TRUE</code>, data_frame contains a column of unit indices.</p>
</td></tr>
<tr><td><code id="fsm_+3A_pol_mat">Pol_mat</code></td>
<td>
<p>Policy matrix. Applicable only when <code>s_function = 'Aopt'</code>.</p>
</td></tr>
<tr><td><code id="fsm_+3A_w_pol">w_pol</code></td>
<td>
<p>A vector of policy weights. Applicable only when <code>s_function = 'Aopt'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following items.
</p>
<p><code>data_frame_allocated</code>:  The original data frame augmented with the column of the treatment indicator.
</p>
<p><code>som_appended</code>:  The SOM with augmented columns for the indices and covariate values for units selected.
</p>
<p><code>som_split</code>:  som_appended, split by the levels of the treatment.
</p>
<p><code>crit_print</code>:  The value of the objective function, at each stage of build up process. At each stage, 
the unit that maximizes the objective function is selected.
</p>


<h3>Author(s)</h3>

<p>Ambarish Chattopadhyay, Carl N. Morris and Jose R. Zubizarreta
</p>


<h3>References</h3>

<p>Chattopadhyay, A., Morris, C. N., and Zubizarreta, J. R. (2020), &ldquo;Randomized and Balanced Allocation of 
Units into Treatment Groups Using the Finite Selection Model for <code>R</code>&rdquo;.
</p>
<p>Morris, C. (1979), &ldquo;A finite selection model for experimental design of the health insurance study&rdquo;,
Journal of Econometrics, 11(1), 43–61.
</p>
<p>Morris, C., Hill, J. (2000), &ldquo;The health insurance experiment: design using the finite selection model&rdquo;, 
Public policy and statistics: case studies from RAND, Springer Science &amp; Business Media, 29–53.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data.
df_sample = data.frame(index = 1:12, x = c(20,30,40,40,50,60,20,30,40,40,50,60))
# Generate an SOM with N = 12, n1 = n2 = 6.
som_sample = som(n_treat = 2, treat_sizes = c(6,6), method = 'SCOMARS', control = TRUE, 
marginal_treat = rep(6/12,12))
# Assign units given the SOM.
f = fsm(data_frame = df_sample, SOM = som_sample, s_function = 'Dopt', 
eps = 0.001, ties = 'random', intercept = TRUE, standardize = TRUE, units_print = TRUE, 
index_col = TRUE)
</code></pre>

<hr>
<h2 id='fsm_batch'>Batched FSM for sequential experiments</h2><span id='topic+fsm_batch'></span>

<h3>Description</h3>

<p>Extension of the FSM to cases where units arrive sequentially in batches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsm_batch(
  data_frame,
  data_frame_past,
  t_ind,
  SOM,
  s_function = "Dopt",
  Q_initial = NULL,
  eps = 0.001,
  ties = "random",
  intercept = TRUE,
  index_col_past = TRUE,
  standardize = TRUE,
  units_print = TRUE,
  index_col = TRUE,
  Pol_mat = NULL,
  w_pol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsm_batch_+3A_data_frame">data_frame</code></td>
<td>
<p>Data frame containing a column of unit indices (optional) and covariates (or transformations thereof).</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_data_frame_past">data_frame_past</code></td>
<td>
<p>A data frame of units already allocated to treatment groups. 
Data frame contains a column of unit indices (optional), columns of covariates (or transformations thereof), 
and a column for treatment indicator.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_t_ind">t_ind</code></td>
<td>
<p>column name containing the treatment indicator in <code>data_frame_past</code>.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_som">SOM</code></td>
<td>
<p>Selection Order Matrix.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_s_function">s_function</code></td>
<td>
<p>Specifies a selection function, a string among <code>'constant'</code>, <code>'Dopt'</code>, 
<code>'Aopt'</code>, <code>'max pc'</code>, <code>'min pc'</code>, <code>'Dopt pc'</code>, <code>'max average'</code>, <code>'min average'</code>,
<code>'Dopt average'</code>. <code>'constant'</code> selection function puts a constant value on every unselected unit. 
<code>'Dopt'</code> use the D-optimality criteria based on the full set of covariates to select units. 
<code>'Aopt'</code> uses the A-optimality criteria. <code>'max pc'</code> (respectively, <code>'min pc'</code>) selects that 
unit that has the maximum (respectively, minimum) value of the first principal component. 
<code>'Dopt pc'</code> uses the D-optimality criteria on the first principal component, <code>'max average'</code> 
(respectively, <code>'min average'</code>) selects that unit that has the maximum (respectively, minimum) 
value of the simple average of the covariates. <code>'Dopt average'</code> uses the D-optimality criteria on the 
simple average of the covariates.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_q_initial">Q_initial</code></td>
<td>
<p>A (optional) non-singular matrix (called 'initial matrix') that is added the <code class="reqn">(X^T X)</code> 
matrix of the choosing treatment group at any stage, when the <code class="reqn">(X^T X)</code> matrix of that treatment group
at that stage is non-invertible. If <code>FALSE</code>, the <code class="reqn">(X^T X)</code> matrix for the full set of observations is used
as the non-singular matrix. Applicable if <code>s_function = 'Dopt'</code> or <code>'Aopt'</code>.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_eps">eps</code></td>
<td>
<p>Proportionality constant for <code>Q_initial</code>, the default value is 0.001.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_ties">ties</code></td>
<td>
<p>Specifies how to deal with ties in the values of the selection function. If <code>ties = 'random'</code>,
a unit is selected randomly from the set of candidate units. If <code>ties = 'smallest'</code>, the unit 
that appears earlier in the data frame, i.e. the unit with the smallest index gets selected.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_intercept">intercept</code></td>
<td>
<p>if <code>TRUE</code>, the design matrix of each treatment group includes a column of intercepts.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_index_col_past">index_col_past</code></td>
<td>
<p><code>TRUE</code> if column of unit indices is present in <code>data_frame_past</code>.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_standardize">standardize</code></td>
<td>
<p>if <code>TRUE</code>, the columns of the <code class="reqn">X</code> matrix other than the column for the intercept (if any), 
are standardized.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_units_print">units_print</code></td>
<td>
<p>if <code>TRUE</code>, the function automatically prints the candidate units at each step of selection.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_index_col">index_col</code></td>
<td>
<p>if <code>TRUE</code>, data_frame contains a column of unit indices.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_pol_mat">Pol_mat</code></td>
<td>
<p>Policy matrix. Applicable only when <code>s_function = 'Aopt'</code>.</p>
</td></tr>
<tr><td><code id="fsm_batch_+3A_w_pol">w_pol</code></td>
<td>
<p>A vector of policy weights. Applicable only when <code>s_function = 'Aopt'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following items.
</p>
<p><code>data_frame_allocated</code>:  The original data frame augmented with the column of the treatment indicator.
</p>
<p><code>som_appended</code>:  The SOM with augmented columns for the indices and covariate values for units selected.
</p>
<p><code>som_split</code>:  som_appended, split by the levels of the treatment.
</p>
<p><code>data_frame_allocated_augmented</code>: data frame combining <code>data_frame_allocated</code> and <code>data_frame_past</code>.
</p>


<h3>Author(s)</h3>

<p>Ambarish Chattopadhyay, Carl N. Morris and Jose R. Zubizarreta
</p>


<h3>References</h3>

<p>Chattopadhyay, A., Morris, C. N., and Zubizarreta, J. R. (2020), &ldquo;Randomized and Balanced Allocation of Units into Treatment Groups Using the Finite Selection Model for <code>R</code>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider N=18, number of treatments = 2, n1 = n2 = 9, batch sizes = 6,6,6.
# Get data frame for the first batch.
df_sample_1 = data.frame(index = 1:6, age = c(20,30,40,40,50,60))
# Obtain SOM for all the 12 units.
som_gen = som(data_frame = NULL, n_treat = 2, treat_sizes = c(9,9), 
include_discard = FALSE, method = 'SCOMARS', marginal_treat = rep((9/18),18), control = FALSE)
# Assign the first batch.
f1 = fsm(data_frame = df_sample_1, SOM = som_gen[1:6,], s_function = 'Dopt', 
eps = 0.0001, ties = 'random', intercept = TRUE, standardize = TRUE, units_print = TRUE)
f1_app = f1$data_frame_allocated
# Get data frame for the second batch.
df_sample_2 = data.frame(index = 7:12, age = c(20,30,40,40,50,60))
# Assign the second batch.
f2 = fsm_batch(data_frame = df_sample_2, SOM = som_gen[7:12,], s_function = 'Dopt', 
eps = 0.0001, ties = 'random', intercept = TRUE, standardize = TRUE, units_print = TRUE,
data_frame_past = f1_app, t_ind = 'Treat', index_col_past = TRUE)
f2_app = f2$data_frame_allocated_augmented
# Get data frame for the third batch.
df_sample_3 = data.frame(index = 13:18, age = c(20,30,40,40,50,60))
# Assign the third batch.
f3 = fsm_batch(data_frame = df_sample_3, SOM = som_gen[13:18,], s_function = 'Dopt', 
eps = 0.0001, ties = 'random', intercept = TRUE, standardize = TRUE, units_print = TRUE,
data_frame_past = f2_app, t_ind = 'Treat', index_col_past = TRUE)
f3_app = f3$data_frame_allocated_augmented
</code></pre>

<hr>
<h2 id='Lalonde'>The Lalonde experimental dataset</h2><span id='topic+Lalonde'></span>

<h3>Description</h3>

<p>The Nationally Supported Work (NSW) experimental data set by Lalonde (1986).
</p>


<h3>References</h3>

<p>LaLonde, R. J. (1986), &ldquo;Evaluating the econometric evaluations of training programs with experimental data&quot;.
The American Economic Review, pp. 604–620.
</p>
<p>Dehejia, R., and Wahba, S. (1999), &ldquo;Causal effects in nonexperimental studies: Reevaluating the evaluation of 
training programs&quot;, Journal of the American Statistical Association, 94(443), 1053–1062.
</p>
<p>https://users.nber.org/~rdehejia/nswdata.html
</p>
<p>Chattopadhyay, A., Morris, C. N., and Zubizarreta, J. R. (2020), &ldquo;Randomized and Balanced Allocation 
of Units into Treatment Groups Using the Finite Selection Model for <code>R</code>&quot;.
</p>

<hr>
<h2 id='love_plot'>Love plot</h2><span id='topic+love_plot'></span>

<h3>Description</h3>

<p>Generates a Love plot of Absolute Standardized Mean Differences (ASMD) or Target Absolute Standardized Differences (TASMD) 
between two groups under one or two designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>love_plot(
  data_frame,
  index_col = TRUE,
  alloc1,
  alloc2 = NULL,
  imbalance = "TASMD",
  treat_lab = 1,
  vline = "",
  xupper = 1,
  mean_tar = NULL,
  sd_tar = NULL,
  denom = "target",
  legend_text = "FSM",
  legend_position = "topright"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="love_plot_+3A_data_frame">data_frame</code></td>
<td>
<p>Data frame containing a column of unit indices (optional) and covariates (or transformations thereof).</p>
</td></tr>
<tr><td><code id="love_plot_+3A_index_col">index_col</code></td>
<td>
<p>if <code>TRUE</code>, <code>data_frame</code> contains a column of unit indices.</p>
</td></tr>
<tr><td><code id="love_plot_+3A_alloc1">alloc1</code></td>
<td>
<p>A vector of treatment assignment.</p>
</td></tr>
<tr><td><code id="love_plot_+3A_alloc2">alloc2</code></td>
<td>
<p>A (optional) vector of treatment assignment.</p>
</td></tr>
<tr><td><code id="love_plot_+3A_imbalance">imbalance</code></td>
<td>
<p>Measure of imbalance used. If <code>imbalance = 'TASMD'</code>, imbalance is computed using 
the Target Absolute Standardized Mean Differences (TASMD). If <code>imbalance = 'ASMD'</code>, 
imbalance is computed using the Absolute Standardized Mean Differences (ASMD)</p>
</td></tr>
<tr><td><code id="love_plot_+3A_treat_lab">treat_lab</code></td>
<td>
<p>Label of the treatment group in which the TASMD is computed. Applicable only when <code>imbalance = 'TASMD'</code>.</p>
</td></tr>
<tr><td><code id="love_plot_+3A_vline">vline</code></td>
<td>
<p>A (optional) x-coordinate at which a vertical line is drawn.</p>
</td></tr>
<tr><td><code id="love_plot_+3A_xupper">xupper</code></td>
<td>
<p>Upper limit of the x-axis.</p>
</td></tr>
<tr><td><code id="love_plot_+3A_mean_tar">mean_tar</code></td>
<td>
<p>A (optional) vector of target profile of the covariates under consideration, 
e.g., mean of the covariates in the target population. Applicable only when <code>imbalance = 'TASMD'</code>. 
If <code>mean_tar = NULL</code>, the full-sample average of the covariates is considered as the target profile.</p>
</td></tr>
<tr><td><code id="love_plot_+3A_sd_tar">sd_tar</code></td>
<td>
<p>A optional vector of the standard deviation of the covariates in the target population. 
Applicable only when <code>imbalance = 'TASMD'</code>.</p>
</td></tr>
<tr><td><code id="love_plot_+3A_denom">denom</code></td>
<td>
<p>Specifies the denominator for the computation of TASMD. If <code>denom = 'target'</code>, 
the standard deviations of the covariates in the target population are used. If <code>denom = 'group'</code>, 
the standard deviations of the covariates in the treatment group given by <code>treat_lab</code> are used. 
Applicable only when <code>imbalance = 'TASMD'</code>.</p>
</td></tr>
<tr><td><code id="love_plot_+3A_legend_text">legend_text</code></td>
<td>
<p>Legend of the two designs under consideration.</p>
</td></tr>
<tr><td><code id="love_plot_+3A_legend_position">legend_position</code></td>
<td>
<p>= Position of the legend in the plot. The default is <code>'topright'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Love plot of the ASMD/TASMD of the covariates.
</p>


<h3>Author(s)</h3>

<p>Ambarish Chattopadhyay, Carl N. Morris and Jose R. Zubizarreta.
</p>


<h3>References</h3>

<p>Chattopadhyay, A., Morris, C. N., and Zubizarreta, J. R. (2020), &ldquo;Randomized and Balanced Allocation 
of Units into Treatment Groups Using the Finite Selection Model for <code>R</code>&quot;.
</p>
<p>Love, T. (2004), “Graphical display of covariate balance”, Presentation, 
See http://chrp.org/love/JSM2004RoundTableHandout.pdf, 1364.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider the Lalonde dataset.
# Get the full sample size.
N = nrow(Lalonde)
# Get the treatment group sizes.
n1 = floor(N/2)
n2 = N-n1
# Generate an SOM.
som_obs = som(n_treat = 2, treat_sizes = c(n1,n2),include_discard = FALSE,
method = 'SCOMARS', marginal_treat = rep((n2/N),N), control = FALSE)
# Generate a treatment assignment given som_obs.
f = fsm(data_frame = Lalonde, SOM = som_obs, s_function = 'Dopt', eps = 0.0001, 
ties = 'random', intercept = TRUE, standardize = TRUE, units_print = FALSE)
# Get assignment vector under the FSM.
Z_fsm_obs = f$data_frame_allocated$Treat
# Draw a random CRD.
Z_crd_obs = crd(data_frame = Lalonde, n_treat = 2, treat_sizes = c(n1, n2), 
control = FALSE)$Treat
# Draw Love plot.
love_plot(data_frame = Lalonde, index_col = TRUE, alloc1 = Z_fsm_obs, alloc2 = Z_crd_obs, 
imbalance = 'TASMD', treat_lab = 1, mean_tar = NULL, sd_tar = NULL, denom = 'target',
vline = "", legend_text = c("FSM","CRD"), xupper = 0.15, legend_position = 'topright') 
</code></pre>

<hr>
<h2 id='make_sq_inter'>Squares and two-way interactions of variables</h2><span id='topic+make_sq_inter'></span>

<h3>Description</h3>

<p>Generates squares and/or two-way interactions (pairwise products) of the columns of a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_sq_inter(
  data_frame,
  is_square = TRUE,
  is_inter = TRUE,
  keep_marginal = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_sq_inter_+3A_data_frame">data_frame</code></td>
<td>
<p>Data frame containing the variables whose squares and interactions are to be created.</p>
</td></tr>
<tr><td><code id="make_sq_inter_+3A_is_square">is_square</code></td>
<td>
<p>If <code>TRUE</code>, square of each column of <code>data_frame</code> is created.</p>
</td></tr>
<tr><td><code id="make_sq_inter_+3A_is_inter">is_inter</code></td>
<td>
<p>If <code>TRUE</code>, product of every pair of columns of <code>data_frame</code> is created.</p>
</td></tr>
<tr><td><code id="make_sq_inter_+3A_keep_marginal">keep_marginal</code></td>
<td>
<p>If <code>TRUE</code>, the original columns of <code>data_frame</code> are retained 
in the resulting data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the squares and/or pairwise products of <code>data_frame</code>.
</p>


<h3>Author(s)</h3>

<p>Ambarish Chattopadhyay, Carl N. Morris and Jose R. Zubizarreta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider a data frame with N = 12 units and 2 covariates.
data_frame_sample = data.frame(male = c(rep(1,6),rep(0,6)), 
age = c(20,30,40,40,50,60,20,30,40,40,50,60))
# Get a data frame with all possible squares and first order interactions.
make_sq_inter(data_frame = data_frame_sample, is_square = TRUE, 
is_inter = TRUE, keep_marginal = FALSE)
</code></pre>

<hr>
<h2 id='perm_test'>Fisher's randomization test for sharp null hypothesis.</h2><span id='topic+perm_test'></span>

<h3>Description</h3>

<p>Performs Fisher's randomization test for sharp null hypotheses of the form 
<code class="reqn">H_0: c_1 Y_i(1) + c_2 Y_i(2) - \tau = 0</code>, for a vector of contrasts <code class="reqn">(c_1, c_2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm_test(
  Y_obs,
  alloc_obs,
  alloc,
  contrast = c(1, -1),
  tau = 0,
  method = "marginal mean",
  alternative = "not equal"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perm_test_+3A_y_obs">Y_obs</code></td>
<td>
<p>Vector of observed outcome.</p>
</td></tr>
<tr><td><code id="perm_test_+3A_alloc_obs">alloc_obs</code></td>
<td>
<p>Vector of observed treatment assignment.</p>
</td></tr>
<tr><td><code id="perm_test_+3A_alloc">alloc</code></td>
<td>
<p>A matrix of treatment assignments over which the randomization distribution of the test statistic
is computed. Each row of <code>alloc</code> should correspond to an assignment vector.</p>
</td></tr>
<tr><td><code id="perm_test_+3A_contrast">contrast</code></td>
<td>
<p>A vector of the coefficients of the treatment contrast of interest. For example, for estimating the
average treatment effect of treatment 1 versus treatment 2, <code>contrast = c(1,-1)</code>.</p>
</td></tr>
<tr><td><code id="perm_test_+3A_tau">tau</code></td>
<td>
<p>The value of the treatment contrast specified by the sharp null hypothesis.</p>
</td></tr>
<tr><td><code id="perm_test_+3A_method">method</code></td>
<td>
<p>The method of computing the test statistic. If <code>method = 'marginal mean'</code>, the test statistic
is <code class="reqn">c_1 \hat{Y}_i(1) + c_2 \hat{Y}_i(2)</code>, where <code class="reqn">\hat{Y}(z)</code> 
is the mean of the observed outcome in the group <code class="reqn">Z = z</code>, for <code class="reqn">z = 0,1</code>. If <code>method = 'marginal rank'</code>, 
the test statistic is <code class="reqn">c_1 \hat{Y}_i(1) + c_2 \hat{Y}_i(2)</code>, 
where <code class="reqn">\hat{Y}(z)</code> is the mean of the rank of the observed outcome in the group <code class="reqn">Z = z</code>, for <code class="reqn">z = 0,1</code></p>
</td></tr>
<tr><td><code id="perm_test_+3A_alternative">alternative</code></td>
<td>
<p>The type of alternative hypothesis used. For right-sided test, <code>alternative = 'greater'</code>.
For left-sided test, <code>alternative = 'less'</code>. For both-sided test, <code>alternative = 'not equal'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following items.
</p>
<p><code>test_stat_obs</code>: The observed value of the test statistic.
</p>
<p><code>test_stat_iter</code>: A vector of values of the test statistic across repeated randomizations.
</p>
<p><code>p_value</code>: p-value of the test.
</p>


<h3>Author(s)</h3>

<p>Ambarish Chattopadhyay, Carl N. Morris and Jose R. Zubizarreta.
</p>


<h3>References</h3>

<p>Chattopadhyay, A., Morris, C. N., and Zubizarreta, J. R. (2020), &ldquo;Randomized and Balanced Allocation 
of Units into Treatment Groups Using the Finite Selection Model for <code>R</code>&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider N = 12, n1 = n2 = 6. 
# We test the sharp null of no treatment effect under CRD.
df_sample = data.frame(index = 1:12, x = c(20,30,40,40,50,60,20,30,40,40,50,60))
# True potential outcomes.
Y_1_true = 100 + (df_sample$x - mean(df_sample$x)) + rnorm(12, 0, 4)
Y_2_true = Y_1_true + 50
# Generate the realized assignment under CRD.
fc = crd(data_frame = df_sample, n_treat = 2, treat_sizes = c(6,6), control = FALSE)
Z_crd_obs = fc$Treat
# Get the observed outcomes
Y_obs = Y_1_true
Y_obs[Z_crd_obs == 2] = Y_2_true[Z_crd_obs == 2]
# Generate 1000 assignments under CRD.
Z_crd_iter = matrix(rep(0, 1000 * 12), nrow = 1000)
for(i in 1:1000)
{
fc = crd(data_frame = df_sample, n_treat = 2, treat_sizes = c(6,6), control = FALSE)
Z_crd_iter[i,] = fc$Treat
}
# Test for the sharp null H0: Y_i(1) = Y_i(0) for all i.
# Alternative: not H0 (two-sided test).
perm = perm_test(Y_obs = Y_obs, alloc_obs = Z_crd_obs, alloc = Z_crd_iter, 
contrast = c(1,-1), tau = 0, method = "marginal mean", alternative = 'not equal')
# Obtain the p-value.
perm$p_value
</code></pre>

<hr>
<h2 id='som'>Selection Order Matrix (SOM)</h2><span id='topic+som'></span>

<h3>Description</h3>

<p>Generates a Selection Order Matrix (SOM) in a deterministic/random manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>som(
  data_frame = NULL,
  n_treat,
  treat_sizes,
  include_discard = FALSE,
  method = "SCOMARS",
  control = FALSE,
  marginal_treat = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="som_+3A_data_frame">data_frame</code></td>
<td>
<p>A (optional) data frame corresponding to the full sample of units. 
Required if <code>include_discard = TRUE</code>.</p>
</td></tr>
<tr><td><code id="som_+3A_n_treat">n_treat</code></td>
<td>
<p>Number of treatment groups.</p>
</td></tr>
<tr><td><code id="som_+3A_treat_sizes">treat_sizes</code></td>
<td>
<p>A vector of treatment group sizes. If <code>control = TRUE</code>, 
the first element of <code>treat_sizes</code> should be the control group size.</p>
</td></tr>
<tr><td><code id="som_+3A_include_discard">include_discard</code></td>
<td>
<p><code>TRUE</code> if a discard group is considered.</p>
</td></tr>
<tr><td><code id="som_+3A_method">method</code></td>
<td>
<p>Specifies the selection strategy used among <code>'global percentage'</code>, 
<code>'randomized chunk'</code>, <code>'SCOMARS'</code>. <code>'SCOMARS'</code> is applicable only if <code>n_treat = 2</code>.</p>
</td></tr>
<tr><td><code id="som_+3A_control">control</code></td>
<td>
<p>If <code>TRUE</code>, treatments are labeled as 0,1,...,g-1 (0 representing the control group). 
If <code>FALSE</code>, they are labeled as 1,2,...,g.</p>
</td></tr>
<tr><td><code id="som_+3A_marginal_treat">marginal_treat</code></td>
<td>
<p>A vector of marginal probabilities, the jth element being the probability that treatment group
(or treatment group 2 in case <code>control = FALSE</code>) gets to choose at the jth stage given
the total number of choices made by treatment group upto the (j-1)th stage. 
Only applicable when <code>method = 'SCOMARS'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the selection order of treatments, i.e. the labels of treatment groups 
at each stage of selection. If <code>method = 'SCOMARS'</code>, the data frame contains an additional column of 
the conditional selection probabilities.
</p>


<h3>Author(s)</h3>

<p>Ambarish Chattopadhyay, Carl N. Morris and Jose R. Zubizarreta.
</p>


<h3>References</h3>

<p>Chattopadhyay, A., Morris, C. N., and Zubizarreta, J. R. (2020), 
&ldquo;Randomized and Balanced Allocation of Units into Treatment Groups Using the Finite Selection Model for <code>R</code>&rdquo;.
</p>
<p>Morris, C. (1983), &ldquo;Sequentially controlled Markovian random sampling (SCOMARS)&rdquo;, Institute of 
Mathematical Statistics Bulletin,12(5), 237.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate an SOM with N = 12, n1 = n2 = 6.
som_sample = som(data_frame = NULL, n_treat = 2, treat_sizes = c(6,6), include_discard = FALSE, 
method = 'SCOMARS', control = FALSE, marginal_treat = rep(6/12,12))
</code></pre>

<hr>
<h2 id='tasmd_rand'>Target Absolute Standardized Mean Differences (TASMD)</h2><span id='topic+tasmd_rand'></span>

<h3>Description</h3>

<p>Computes the mean and standard deviation of Target Absolute Standardized Mean Differences (TASMD) of 
multiple covariates (or transformations thereof) in a treatment group relative to a target population 
or a target individual for a set of assignments under one or two designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tasmd_rand(
  data_frame,
  index_col = FALSE,
  alloc1,
  alloc2,
  treat_lab = 1,
  legend = c("CRD", "FSM"),
  mean_tar = NULL,
  sd_tar = NULL,
  denom = "target",
  roundoff = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tasmd_rand_+3A_data_frame">data_frame</code></td>
<td>
<p>Data frame containing a column of unit indices (optional) and covariates 
(or transformations thereof).</p>
</td></tr>
<tr><td><code id="tasmd_rand_+3A_index_col">index_col</code></td>
<td>
<p>if <code>TRUE</code>, <code>data_frame</code> contains a column of unit indices.</p>
</td></tr>
<tr><td><code id="tasmd_rand_+3A_alloc1">alloc1</code></td>
<td>
<p>A matrix or vector of treatment assignments. If <code>alloc1</code> is a matrix, then each row
should correspond to an assignment vector.</p>
</td></tr>
<tr><td><code id="tasmd_rand_+3A_alloc2">alloc2</code></td>
<td>
<p>A (optional) matrix or vector of treatment assignment. If <code>alloc2</code> is a matrix, then each row
should correspond to an assignment vector.</p>
</td></tr>
<tr><td><code id="tasmd_rand_+3A_treat_lab">treat_lab</code></td>
<td>
<p>Label of the treatment group in which the TASMD is computed.</p>
</td></tr>
<tr><td><code id="tasmd_rand_+3A_legend">legend</code></td>
<td>
<p>Legend of the two designs under consideration.</p>
</td></tr>
<tr><td><code id="tasmd_rand_+3A_mean_tar">mean_tar</code></td>
<td>
<p>A (optional) vector of target profile of the covariates under consideration, 
e.g., mean of the covariates in the target population. Applicable only when <code>imbalance = 'TASMD'</code>. 
If <code>mean_tar = NULL</code>, the full-sample average of the covariates is considered as the target profile.</p>
</td></tr>
<tr><td><code id="tasmd_rand_+3A_sd_tar">sd_tar</code></td>
<td>
<p>A optional vector of the standard deviation of the covariates in the target population. 
Applicable only when <code>imbalance = 'TASMD'</code>.</p>
</td></tr>
<tr><td><code id="tasmd_rand_+3A_denom">denom</code></td>
<td>
<p>Specifies the denominator for the computation of TASMD. If <code>denom = 'target'</code>, 
the standard deviations of the covariates in the target population are used. If <code>denom = 'group'</code>, 
the standard deviations of the covariates in the treatment group given by <code>treat_lab</code> are used. 
Applicable only when <code>imbalance = 'TASMD'</code>.</p>
</td></tr>
<tr><td><code id="tasmd_rand_+3A_roundoff">roundoff</code></td>
<td>
<p>A number indicating the number of decimal places to be used for rounding off the TASMDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following items (if <code>alloc1</code> and <code>alloc2</code> are matrices)
</p>
<p><code>tasmd_table</code>: A matrix containing the means (standard deviations in parenthesis) of the TASMDs
for the designs under consideration. If <code>alloc1</code> or <code>alloc2</code> is a vector, the
TASMD of the corresponding assignment is returned.
</p>
<p><code>tasmd_mean</code>: A matrix containing the means of the TASMDs for the designs under consideration.
</p>
<p><code>tasmd_sd</code>: A matrix containing the standard deviations of the TASMDs for the designs under consideration.
</p>
<p>If <code>alloc1</code> and <code>alloc2</code> are vectors, <code>tasmd_rand</code> produces a data frame of the corresponding TASMDs.
</p>


<h3>Author(s)</h3>

<p>Ambarish Chattopadhyay, Carl N. Morris and Jose R. Zubizarreta.
</p>


<h3>References</h3>

<p>Chattopadhyay, A., Morris, C. N., and Zubizarreta, J. R. (2020), &ldquo;Randomized and Balanced Allocation 
of Units into Treatment Groups Using the Finite Selection Model for <code>R</code>&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider the Lalonde dataset.
# Get the full sample size.
N = nrow(Lalonde)
# Get the treatment group sizes.
n1 = floor(N/2)
n2 = N-n1
# Generate an SOM.
som_obs = som(n_treat = 2, treat_sizes = c(n1,n2),include_discard = FALSE,
method = 'SCOMARS', marginal_treat = rep((n2/N),N), control = FALSE)
# Generate a treatment assignment given som_obs.
f = fsm(data_frame = Lalonde, SOM = som_obs, s_function = 'Dopt', eps = 0.0001, 
ties = 'random', intercept = TRUE, standardize = TRUE, units_print = FALSE)
# Get assignment vector under the FSM.
Z_fsm_obs = f$data_frame_allocated$Treat
# Draw a random CRD.
Z_crd_obs = crd(data_frame = Lalonde, n_treat = 2, treat_sizes = c(n1, n2), 
control = FALSE)$Treat
# Calculate the TASMD.
TASMD = tasmd_rand(data_frame = Lalonde, index_col = TRUE, alloc1 = Z_crd_obs, 
alloc2 = Z_fsm_obs, treat_lab = 1, mean_tar = NULL, sd_tar = NULL, 
denom = 'target', legend = c('CRD','FSM'), roundoff = 3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
