<!DOCTYPE html><html><head><title>Help for package loe</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {loe}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GARI'>
<p>Graph Adjusted Rand Index</p>
</a></li>
<li><a href='#get.order'>
<p>Making ordinal information.</p>
</a></li>
<li><a href='#LOE'>
<p>LOE for a unweighted Graph.</p></a></li>
<li><a href='#loe-package'>
<p>Local Ordinal Embedding</p>
</a></li>
<li><a href='#make.distmat'>
<p>Euclidean distance matrix computation</p>
</a></li>
<li><a href='#make.kNNG'>
<p>Making the kNN Graph</p>
</a></li>
<li><a href='#SOE'>
<p>Soft Ordinal Embedding (SOE)</p>
</a></li>
<li><a href='#spec.emb'>
<p>Spectral embedding with the normalized or the unnormalized Laplacian (Laplacian eigenmaps).</p>
</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Local Ordinal Embedding</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-02-09</td>
</tr>
<tr>
<td>Author:</td>
<td>Yoshikazu Terada, Ulrike von Luxburg </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yoshikazu Terada &lt;terada@nict.go.jp&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3), MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, Matrix, vegan</td>
</tr>
<tr>
<td>Description:</td>
<td>Local Ordinal embedding (LOE) is one of graph embedding methods for unweighted graphs.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-02-09 10:40:11 UTC; terada</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-02-09 14:36:35</td>
</tr>
</table>
<hr>
<h2 id='GARI'>
Graph Adjusted Rand Index

</h2><span id='topic+GARI'></span>

<h3>Description</h3>

<p>Computes the graph adjusted Rand index measuring a recovery rate of ordinal information in an unweighted graph.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>GARI(ADM, EADM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GARI_+3A_adm">ADM</code></td>
<td>

<p>The given unweighted adjacency matrix

</p>
</td></tr>
<tr><td><code id="GARI_+3A_eadm">EADM</code></td>
<td>

<p>An recovered unweighted adjacency matrix from an embedding. The size of EADM should be same as that of <code>ADM</code>.

</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GARI is bounded from above by 1, and 
<code class="reqn">\mathrm{GARI}(A_n,\hat{A}_{n})=1\iff A_n=\hat{A}_{n}</code>. 
A high GARI score implies that many of the ordinal constraints have
been satisfied by the solution.

</p>


<h3>Value</h3>

<p>The graph adjusted rand index measuring a recovery rate of ordinal information (a scalar).





</p>


<h3>Author(s)</h3>

<p>Yoshikazu Terada

</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
###########
#Based on the distance matrix of an embedding, 
#this function provides the recovered adjacency matrix for given number of nearest neighbors.
###########
rec.graph &lt;- function(DM, k, symm =FALSE, weight=FALSE ) {
N &lt;- nrow(DM)
ADM &lt;- matrix(0, N, N)
#Search kNN point
if(weight==TRUE){
 for (i in 1:N) {
  nid &lt;- order(DM[i,])
  ADM[ i, nid[2:(k[i]+1)] ] &lt;- DM[ i, nid[2:(k[i]+1)] ]
 }
}else{
 for (i in 1:N) {
  nid &lt;- order(DM[i,])
  ADM[i,nid[2:(k[i]+1)] ] &lt;- 1
 }
}
if(symm==TRUE){
 SADM &lt;- ADM+t(ADM)
 SADM[SADM==2*ADM] &lt;- ADM[SADM==2*ADM]
 ADM &lt;- SADM
}
return(ADM)
}
						

ADM &lt;- as.matrix( get.adjacency(graph.famous("Thomassen")) )
#Apply LOE
result.LOE &lt;- LOE(ADM=ADM,p=2,c=0.1,method="BFGS",report=1000)

#Compute the vector of numbers of nearest neighbors with each verteces
true.nn &lt;- apply(X=ADM,1,sum)

#Reconstracte the adjacency matrix based on the result embedding
EDM &lt;- as.matrix( dist(result.LOE$X) )
EADM &lt;- rec.graph(EDM,k=true.nn )

#Compute GARI between ADM and EADM
GARI(ADM,EADM)
</code></pre>

<hr>
<h2 id='get.order'>
Making ordinal information.

</h2><span id='topic+get.order'></span>

<h3>Description</h3>

<p>For a given dissimilarity matrix <code class="reqn">\Xi=(\xi_{ij})_{n\times n}</code>, 
creating the ordinal information matrix whose row vectors are ordinal quadruples of indices: 
a row vector <code class="reqn">(i,j,k,l)</code> means <code class="reqn">\xi_{ij}&lt;\xi_{kl}</code>.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.order(DM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.order_+3A_dm">DM</code></td>
<td>

<p>A dissimilarity matrix.

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix whose row vectors are ordinal quadruples of indices: a row vector (i,j,k,l) means <code class="reqn">\xi_{ij}&lt;\xi_{kl}</code>.





</p>


<h3>Author(s)</h3>

<p>Yoshikazu Terada

</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eurodist)
OIF &lt;- get.order(as.matrix(eurodist))
</code></pre>

<hr>
<h2 id='LOE'>
LOE for a unweighted Graph.
</h2><span id='topic+LOE'></span>

<h3>Description</h3>

<p>Performs LOE for a given unweighted grah.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LOE(ADM, p=2, c=0.1,eps= 1e-5,maxit =1000,method=c("BFGS","SD","MM"),
iniX = "auto",report=100,DEL=1,H=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LOE_+3A_adm">ADM</code></td>
<td>

<p>The adjacency matrix.
</p>
</td></tr>
<tr><td><code id="LOE_+3A_p">p</code></td>
<td>

<p>Number of dimensions.
</p>
</td></tr>
<tr><td><code id="LOE_+3A_c">c</code></td>
<td>

<p>Scale parameter which only takes strictly positive value.
</p>
</td></tr>
<tr><td><code id="LOE_+3A_eps">eps</code></td>
<td>

<p>Convergence criterion for the majorization algorithm or the steepest descent algorithm.
</p>
</td></tr>
<tr><td><code id="LOE_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iteretions.
</p>
</td></tr>
<tr><td><code id="LOE_+3A_method">method</code></td>
<td>

<p>If &quot;BFGS&quot;, then the BFGS method is used for optimizing the stress function.
If &quot;SD&quot;, then the steepest descent method is used.
If &quot;MM&quot;, then the majorization minimization algortihm is used.
</p>
</td></tr>
<tr><td><code id="LOE_+3A_inix">iniX</code></td>
<td>

<p>Matrix with starting values for embedding (optional). If &quot;auto&quot;, then Laplacian eigenmaps is used as a starting value.
</p>
</td></tr>
<tr><td><code id="LOE_+3A_report">report</code></td>
<td>

<p>The frequency of reports. Defaults to every 100 iterations.
</p>
</td></tr>
<tr><td><code id="LOE_+3A_del">DEL</code></td>
<td>

<p>The initial step size in the steepest descent algorithm. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="LOE_+3A_h">H</code></td>
<td>

<p>The rate parameter of the backtracking line search in the steepest descent algorithm. 
This parameter only takes value in <code class="reqn">(0,1)</code>.
Defaults to 0.5.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>LOE</code> returns a list with components:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>The best corrdinate matrix with p columns whose rows give the coordinates of the vertexes.</p>
</td></tr>
<tr><td><code>str</code></td>
<td>
<p> If <code>method</code> is &quot;BFGS&quot;, then the value of the stress function of LOE corresponding to <code>X</code> is returned.
If &quot;SD&quot; or &quot;MM&quot;, then the vector of values on each iteration is returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yoshikazu Terada
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################
#Realizable case#
#################
library(igraph)
###############################
#Create a toy data
x &lt;- seq(-5,5,by=1)
y &lt;- seq(1,6,by=1)
hx1 &lt;- seq(-3.5,-1.5,by=0.5)
hx2 &lt;- seq(1.5,3.5,by=0.5)
hy &lt;- seq(2.5,4.5,by=0.5)
D1 &lt;- matrix(0,66,2)
for(i in 1:11){
	for(j in 1:6){
		D1[i+11*(j-1),] &lt;- c(x[i],y[j])
	}
}
D2n &lt;- matrix(0,25,2)
D2p &lt;- matrix(0,25,2)
for(i in 1:5){
	for(j in 1:5){
		D2n[i+5*(j-1),] &lt;- c(hx1[i],hy[j])
		D2p[i+5*(j-1),] &lt;- c(hx2[i],hy[j])
	}
}
D2n &lt;- D2n[-c(7,9,17,19),]
D2p &lt;- D2p[-c(7,9,17,19),]
Data &lt;- rbind(D1,D2n,D2p)
Data &lt;- scale(Data[order(Data[,1]),], scale=FALSE)
N &lt;- nrow(Data)
#Visualization of the original data
plot(Data,pch=20,xlab="",ylab="",cex=1,col=rainbow(N,start=.7,end=.9),
xlim=c(-7,7),ylim=c(-7,7),main="Original data")

#Creating a k-NN graph based on Data
DM &lt;- as.matrix(dist(Data))
ADM &lt;- make.kNNG(DM,k=25)

#plot of the adjacency matrix
AADM &lt;- ADM
diag(AADM) &lt;- NA
image(AADM[N:1,],col=topo.colors(3),ann=FALSE,axes=FALSE)

#Apply some graph embedding methods
LE &lt;-spec.emb(A=ADM,2,norm=FALSE)
result.LOE &lt;- LOE(ADM=ADM,p=2,c=0.1,method="BFGS",report=1000,iniX=LE)

#Procrustes transform
library(vegan)
LOEX &lt;- procrustes(X=Data,Y=result.LOE$X)$Yrot
plot(LOEX,pch=20,xlab="",ylab="",cex=1,col=rainbow(N,start=.7,end=.9),
xlim=c(-7,7),ylim=c(-7,7),main="LOE")
###############################

#############
#This function provide appropriate vectors of xlim and ylim
#for given embedding matrix X.
#############
make.lim &lt;- function(X){
			mima &lt;- matrix(0, 2,2)
			mima[,1] &lt;- apply(X, 2, min)
			mima[,2] &lt;- apply(X, 2, max)
			han &lt;- mima[,2] - mima[,1]
			cent &lt;-  (mima[,2] + mima[,1])/2
			tmpr &lt;- max(han)+max(han)*0.05
			for(s in 1:2){
				mima[s,] &lt;- c(cent[s]-tmpr/2,cent[s]+tmpr/2)
			}
			return(mima)
		}
##############################
#Standered graph-drawing task#
##############################
###############################
ADM &lt;- as.matrix( get.adjacency(graph.famous("Thomassen")) )
TG &lt;- graph.adjacency(ADM)

#Apply some graph embedding methods
LE &lt;-spec.emb(A=ADM,2,norm=FALSE)
KK &lt;- layout.kamada.kawai(TG,maxiter=1000,start=LE)
FR &lt;- layout.fruchterman.reingold(TG,maxiter=1000,start=LE)
result.LOE &lt;- LOE(ADM=ADM,p=2,c=0.1,method="MM",report=1000,maxit=2000)


#Visualization of embeddings
par(mfrow=c(2,3),oma = c(0, 0, 4, 0))
#plot of the adjacency matrix
	AADM &lt;- ADM
	N &lt;- nrow(AADM)
	diag(AADM) &lt;- NA
	image(AADM[N:1,],col=topo.colors(3),ann=FALSE,axes=FALSE)
#plot of Laplacian eigenmaps
	tmplim &lt;- make.lim(LE)
	vsize &lt;- (tmplim[1,2] -tmplim[1,1])*4
	plot(TG, layout=LE, main="Laplacian eigenmaps",
		vertex.size=vsize,vertex.color="blue",vertex.label.color="white",vertex.label=NA,
		edge.arrow.size=0.1,xlim=tmplim[1,],ylim=tmplim[2,],axes=TRUE,rescale=FALSE)
#plot of Kamada and Kawai
	tmplim &lt;- make.lim(KK)
	vsize &lt;- (tmplim[1,2] -tmplim[1,1])*4
	plot(TG, layout=KK, main="Kamada and Kawai",
		vertex.size=vsize,vertex.color="blue",vertex.label.color="white",vertex.label=NA,
		edge.arrow.size=0.1,xlim=tmplim[1,],ylim=tmplim[2,],axes=TRUE,rescale=FALSE)
#plot of Fruchterman Reingold
	tmplim &lt;- make.lim(FR)
	vsize &lt;- (tmplim[1,2] -tmplim[1,1])*4
	plot(TG, layout=FR, main="Fruchterman Reingold",
		vertex.size=vsize,vertex.color="blue",vertex.label.color="white",vertex.label=NA,
		edge.arrow.size=0.1,xlim=tmplim[1,],ylim=tmplim[2,],axes=TRUE,rescale=FALSE)
#plot of LOE
	tmplim &lt;- make.lim(result.LOE$X)
	vsize &lt;- (tmplim[1,2] -tmplim[1,1])*4
	plot(TG, layout=result.LOE$X, main="LOE",
		vertex.size=vsize,vertex.color="blue",vertex.label.color="white",vertex.label=NA,
		edge.arrow.size=0.1,xlim=tmplim[1,],ylim=tmplim[2,],axes=TRUE,rescale=FALSE)
	plot(result.LOE$str,type="l",xlab="Number of iter.", ylab="Stress")
#Make title
	mtext(side = 3, line=1, outer=TRUE, text = "Thomassen", cex=2)
###############################
</code></pre>

<hr>
<h2 id='loe-package'>
Local Ordinal Embedding

</h2><span id='topic+loe-package'></span><span id='topic+loe'></span>

<h3>Description</h3>

<p>Soft Ordinal Embedding (SOE) is a simple new method for ordinal embedding problem.
SOE can deal with a part of ordinal comparisons:
<code class="reqn">dissimilarity(i,j)&lt;dissimilarity(k,l)</code> for certain quadruples of indices <code class="reqn">(i,j,k,l)</code>.
</p>
<p>The local point of view suggests
ordinal embedding as an interesting alternative to graph drawing
algorithms. If vertex <code class="reqn">i</code> is connected by an edge to vertex <code class="reqn">j</code>, but
not to vertex <code class="reqn">k</code>, we interpret this constellation as a constraint of
the form <code class="reqn">\xi_{ij} &lt; \xi_{ik}</code>. 
With this interpretation, 
graph embedding (graph drawing) becomes a special case of ordinal embedding. 
We call SOE for graph embedding problem Local Ordinal Embedding (LOE). 
For the connectivity matrix of given unweighted graph, 
LOE provides a low-dimensional embedding which preserves the original graph structure.
</p>
<p>This package provides SOE and LOE. 

</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> loe</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-01-28</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The functions for SOE on ordinal comparison matrices and LOE on unweighted adjacency matrices are <code>SOE()</code> and <code>LOE()</code>, respectively. 
</p>




<h3>Acknowledgement</h3>

<p>The authors wishes to express their thanks to Dr. Michio Yamamoto and Mr. Yuichi Saito for their help in creating this package.
This work was partially supported by Grant-in-Aid for JSPS Fellows Number 24-2466.
</p>


<h3>Author(s)</h3>

<p>Yoshikazu Terada and Ulrike von Luxburg
</p>
<p>Maintainer: Yoshikazu Terada <a href="mailto:terada@sigmath.es.osaka-u.ac.jp">terada@sigmath.es.osaka-u.ac.jp</a>

</p>

<hr>
<h2 id='make.distmat'>
Euclidean distance matrix computation

</h2><span id='topic+make.distmat'></span>

<h3>Description</h3>

<p>This function computes and returns the distance matrix computed by using the Euclidean distance between the row of a data matrix.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.distmat(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.distmat_+3A_x">X</code></td>
<td>

<p>A numeric matrix.

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Euclidean distance matrix based on a given corrdinate matrix <code>X</code>.





</p>


<h3>Author(s)</h3>

<p>Yoshikazu Terada

</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a toy data
x &lt;- seq(-5,5,by=1)
y &lt;- seq(1,6,by=1)
hx1 &lt;- seq(-3.5,-1.5,by=0.5)
hx2 &lt;- seq(1.5,3.5,by=0.5)
hy &lt;- seq(2.5,4.5,by=0.5)
D1 &lt;- matrix(0,66,2)
for(i in 1:11){
	for(j in 1:6){
		D1[i+11*(j-1),] &lt;- c(x[i],y[j])
	}
}
D2n &lt;- matrix(0,25,2)
D2p &lt;- matrix(0,25,2)
for(i in 1:5){
	for(j in 1:5){
		D2n[i+5*(j-1),] &lt;- c(hx1[i],hy[j])
		D2p[i+5*(j-1),] &lt;- c(hx2[i],hy[j])
	}
}
D2n &lt;- D2n[-c(7,9,17,19),]
D2p &lt;- D2p[-c(7,9,17,19),]
Data &lt;- rbind(D1,D2n,D2p)

#Creating a k-NN graph based on Data
DM &lt;- make.distmat(Data)
</code></pre>

<hr>
<h2 id='make.kNNG'>
Making the kNN Graph

</h2><span id='topic+make.kNNG'></span>

<h3>Description</h3>

<p>Making the kNN graph from given distance matrix.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.kNNG(DM, k = as.integer(2 * log(nrow(DM))), symm = FALSE, weight = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.kNNG_+3A_dm">DM</code></td>
<td>

<p>A distance matrix.

</p>
</td></tr>
<tr><td><code id="make.kNNG_+3A_k">k</code></td>
<td>

<p>Number of neighbers

</p>
</td></tr>
<tr><td><code id="make.kNNG_+3A_symm">symm</code></td>
<td>

<p>If TRUE, then the connectivity matrix is symmetrized.

</p>
</td></tr>
<tr><td><code id="make.kNNG_+3A_weight">weight</code></td>
<td>

<p>If TRUE, then the weighted kNN graph is created.

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjacency matrix of a kNN graph.





</p>


<h3>Author(s)</h3>

<p>Yoshikazu Terada

</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a toy data
x &lt;- seq(-5,5,by=1)
y &lt;- seq(1,6,by=1)
hx1 &lt;- seq(-3.5,-1.5,by=0.5)
hx2 &lt;- seq(1.5,3.5,by=0.5)
hy &lt;- seq(2.5,4.5,by=0.5)
D1 &lt;- matrix(0,66,2)
for(i in 1:11){
	for(j in 1:6){
		D1[i+11*(j-1),] &lt;- c(x[i],y[j])
	}
}
D2n &lt;- matrix(0,25,2)
D2p &lt;- matrix(0,25,2)
for(i in 1:5){
	for(j in 1:5){
		D2n[i+5*(j-1),] &lt;- c(hx1[i],hy[j])
		D2p[i+5*(j-1),] &lt;- c(hx2[i],hy[j])
	}
}
D2n &lt;- D2n[-c(7,9,17,19),]
D2p &lt;- D2p[-c(7,9,17,19),]
Data &lt;- rbind(D1,D2n,D2p)
Data &lt;- scale(Data[order(Data[,1]),], scale=FALSE)

#Visualization of Data
plot(Data,pch=20,xlab="",ylab="",cex=1,col=rainbow(108,start=.7,end=.9),
xlim=c(-7,7),ylim=c(-7,7))

#Creating a k-NN graph based on Data
DM &lt;- as.matrix(dist(Data))
ADM &lt;- make.kNNG(DM,k=25)
</code></pre>

<hr>
<h2 id='SOE'>
Soft Ordinal Embedding (SOE)

</h2><span id='topic+SOE'></span>

<h3>Description</h3>

<p>Performs SOE for a given part of ordinal informaiton.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>SOE(CM, N, p = 2, c = 0.1, maxit = 1000, report = 100, iniX = "rand",rnd=10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SOE_+3A_cm">CM</code></td>
<td>

<p>A matrix whose rows represent ordinal information: 
A row vector <code class="reqn">(i,j,k,l)</code> means <code class="reqn">\xi_{ij}&lt;\xi_{kl}</code>, where <code class="reqn">\xi_{ij}</code> is a dissimilarity 
between object <code class="reqn">i</code> and object <code class="reqn">j</code>. 
If the number of given ordinal comparisons is more than 100000, then SOE randomly chooses <code>rnd</code> ordinal comarisons from given comparisons.

</p>
</td></tr>
<tr><td><code id="SOE_+3A_n">N</code></td>
<td>

<p>The number of objects.

</p>
</td></tr>
<tr><td><code id="SOE_+3A_p">p</code></td>
<td>

<p>The number of dimensions.

</p>
</td></tr>
<tr><td><code id="SOE_+3A_c">c</code></td>
<td>

<p>Scale parameter which only takes strictly positive value.

</p>
</td></tr>
<tr><td><code id="SOE_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iteretions.

</p>
</td></tr>
<tr><td><code id="SOE_+3A_report">report</code></td>
<td>

<p>The frequency of reports. Defaults to every 100 iterations.

</p>
</td></tr>
<tr><td><code id="SOE_+3A_inix">iniX</code></td>
<td>

<p>Matrix with starting values for embedding (optional).

</p>
</td></tr>
<tr><td><code id="SOE_+3A_rnd">rnd</code></td>
<td>

<p>The number of ordinal comarisons which are randomly chosen from given ordinal comparisons <code>CM</code>.
<code>rnd</code> is used only if the number of given ordinal comparisons is more than 100000.

</p>
</td></tr>
</table>


<h3>Value</h3>






<p><code>SOE</code> returns a list with components:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>The best corrdinate matrix with <code class="reqn">p</code> columns whose rows give the coordinates of objects.</p>
</td></tr>
<tr><td><code>str</code></td>
<td>
<p>The value of the stress function of SOE corresponding to <code>X</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yoshikazu Terada

</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
data(eurodist)
OIF &lt;- get.order(as.matrix(eurodist))
sid &lt;- sample(1:nrow(OIF))
POI &lt;- OIF[sid[1:1000],]
result &lt;- SOE(CM=POI, N=nrow(as.matrix(eurodist)),p=2, c=0.1,maxit =1000,report=100)
plot(result$X,type="n",xlab="Dim. 1", ylab="Dim. 2")
text(result$X,rownames(as.matrix(eurodist)),cex=1)
</code></pre>

<hr>
<h2 id='spec.emb'>
Spectral embedding with the normalized or the unnormalized Laplacian (Laplacian eigenmaps).

</h2><span id='topic+spec.emb'></span>

<h3>Description</h3>

<p>Performs spectral embedding for a given adjacency matrix.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec.emb(A, p, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec.emb_+3A_a">A</code></td>
<td>


</td></tr>
<tr><td><code id="spec.emb_+3A_p">p</code></td>
<td>

<p>The number of dimensions.

</p>
</td></tr>
<tr><td><code id="spec.emb_+3A_norm">norm</code></td>
<td>

<p>If <code>TRUE</code>, then the normalized Laplacian is used for embedding.
If <code>FASLE</code>, then the unnormalized Laplacian is used for embedding.

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corrdinate matrix with p columns whose rows give the coordinates of the vertexes.





</p>


<h3>Author(s)</h3>

<p>Yoshikazu Terada

</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
ADM &lt;- as.matrix( get.adjacency(graph.famous("Icosahedral")) )

#Apply some graph embedding methods
LE &lt;-spec.emb(A=ADM,2,norm=FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
