<!DOCTYPE html><html><head><title>Help for package memgene</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {memgene}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#codomToPropShared'>
<p>Find proportion of shared alleles genetic distances from a codominant alleles matrix</p></a></li>
<li><a href='#memgene-package'>
<p>Spatial pattern detection in genetic distance data using Moran's Eigenvector Maps</p></a></li>
<li><a href='#mgForward'>
<p>Forward selection of MEM eigenvectors against genetic distance data</p></a></li>
<li><a href='#mgLandscape'>
<p>Landscape genetic analysis using MEMGENE</p></a></li>
<li><a href='#mgMap'>
<p>Visualization of MEMGENE variables</p></a></li>
<li><a href='#mgMEM'>
<p>Extraction of MEM eigenvectors given distances among sampling locations</p></a></li>
<li><a href='#mgQuick'>
<p>Memgene analysis of genetic distance data (main interface for package)</p></a></li>
<li><a href='#mgRDA'>
<p>Extraction of MEMGENE variables using redundancy analysis (RDA)</p></a></li>
<li><a href='#mgVarPart'>
<p>Variation partitioning of the genetic distance matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Pattern Detection in Genetic Distance Data Using Moran's
Eigenvector Maps</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Pedro Peres-Neto, Paul Galpern</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Galpern &lt;pgalpern@ucalgary.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Can detect relatively weak spatial genetic patterns by using Moran's Eigenvector Maps (MEM) to extract only the spatial component of genetic variation.  Has applications in landscape genetics where the movement and dispersal of organisms are studied using neutral genetic variation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>ade4, gdistance, raster, sp, vegan</td>
</tr>
<tr>
<td>Suggests:</td>
<td>adegenet, geosphere, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-21 18:38:38 UTC; pgalpern</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-21 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='codomToPropShared'>
Find proportion of shared alleles genetic distances from a codominant alleles matrix
</h2><span id='topic+codomToPropShared'></span>

<h3>Description</h3>

<p>Given a matrix with two adjacent columns for each locus (e.g. LOCUS1a, LOCUS1b, LOCUS2a, LOCUS2b, ...)
containing codominant alelles, where individual genotypes are in rows, find the proportion of shared alleles
(Bowcock et al., 1994) among individuals using functions in the adegenet package.<br />
</p>
<p>This is a convenience function that wraps adegenet routines.<br />
</p>
<p>Note that any type of genetic distance matrix can be used in MEMGENE, and the proportion of shared alleles metric is not a requirement. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codomToPropShared(alleles, missingData = c(-98,-99), genind=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codomToPropShared_+3A_alleles">alleles</code></td>
<td>

<p>A matrix with two adjacent columns for each locus containing codominant alleles
</p>
</td></tr>
<tr><td><code id="codomToPropShared_+3A_missingdata">missingData</code></td>
<td>

<p>A vector of any length giving the values in the alleles matrix representing missing data (<code>NA</code> also represents missing)
</p>
</td></tr>
<tr><td><code id="codomToPropShared_+3A_genind">genind</code></td>
<td>

<p>Return a genind object rather than the proportion of shared alleles genetic distance matrix.  A genind object can be used by various functions in the adegenet package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First prepares the alleles matrix into a format that can be converted using functions in the adegenet package to the <code>genind</code> format.  <code>propShared</code> is then run on this object.
</p>


<h3>Value</h3>

<p>Returns a genetic distance matrix using the proportion of shared alleles metric (Bowcock et al., 1994)
</p>


<h3>Author(s)</h3>

<p>Pedro Peres-Neto (peres-neto.pedro@uqam.ca)<br />
Paul Galpern (pgalpern@ucalgary.ca)
</p>


<h3>References</h3>

<p>Bowcock AM, Ruizlinares A, Tomfohrde J, et al. 1994 High resolution of human evolutionary trees with polymorphic microsatellites. Nature, 368, 455-457.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
radialData &lt;- read.csv(system.file("extdata/radial.csv", package="memgene"))
radialGen &lt;- radialData[, -c(1,2)]
radialDM &lt;- codomToPropShared(radialGen)

</code></pre>

<hr>
<h2 id='memgene-package'>
Spatial pattern detection in genetic distance data using Moran's Eigenvector Maps
</h2><span id='topic+memgene-package'></span><span id='topic+memgene'></span>

<h3>Description</h3>

<p>Memgene can detect relatively weak spatial genetic patterns by using Moran's Eigenvector Maps (MEM) to extract only the spatial component of genetic variation.  Memgene has applications in landscape genetics where the movement and dispersal of organisms are studied using neutral genetic variation.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> memgene</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-06-07</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Paul Galpern (pgalpern@ucalgary.ca)<br />
Pedro Peres-Neto (peres-neto.pedro@uqam.ca)
</p>
<p>Maintainer: Paul Galpern (pgalpern@ucalgary.ca)
</p>


<h3>References</h3>

<p>Galpern, P., Peres-Neto, P., Polfus, J., and Manseau, M.  2014.  MEMGENE: Spatial pattern detection in genetic distance data.  Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The basic interface to MEMGENE is mgQuick()
?mgQuick

## For landscape genetic analysis with MEMGENE see mgLandscape()
?mgLandscape
</code></pre>

<hr>
<h2 id='mgForward'>
Forward selection of MEM eigenvectors against genetic distance data
</h2><span id='topic+mgForward'></span>

<h3>Description</h3>

<p>This function calls <code>mgRDA</code> repeatedly in order to identify a reduced
set of all MEM eigenvectors (i.e. spatial patterns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgForward(genD, vectorsMEM, perm = 100, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgForward_+3A_gend">genD</code></td>
<td>

<p>A symmetrical distance matrix giving the genetic distances among
individual genotypes or populations
</p>
</td></tr>
<tr><td><code id="mgForward_+3A_vectorsmem">vectorsMEM</code></td>
<td>

<p>A matrix giving a set of MEM eigenvectors 
</p>
</td></tr>
<tr><td><code id="mgForward_+3A_perm">perm</code></td>
<td>

<p>The number of permutations in a randomization test
</p>
</td></tr>
<tr><td><code id="mgForward_+3A_alpha">alpha</code></td>
<td>

<p>The 1-alpha level for forward selection
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wrapper for <code><a href="#topic+mgRDA">mgRDA</a></code> designed for forward selection
</p>


<h3>Value</h3>

<p>A list<br />
<code>$selectedMEM</code> gives the indices of the input <code>vectorsMEM</code> that
were selected and can then be used in a call to <code>mgRDA(..., full=TRUE)</code>
</p>


<h3>Author(s)</h3>

<p>Pedro Peres-Neto (peres-neto.pedro@uqam.ca)<br />
Paul Galpern (pgalpern@ucalgary.ca)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Prepare the radial data for analysis
radialData &lt;- read.csv(system.file("extdata/radial.csv", package="memgene"))
radialGen &lt;- radialData[, -c(1,2)]
radialXY &lt;- radialData[, 1:2]
if (require(adegenet)) {
  radialDM &lt;- codomToPropShared(radialGen)
} else {
  stop("adegenent package required to produce genetic distance matrix in example.")
}

## Find MEM eigenvectors given sampling locations
## by first finding the Euclidean distance matrix
radialEuclid &lt;- dist(radialXY)
radialMEM &lt;- mgMEM(radialEuclid)

## Forward select significant MEM eigenvectors using RDA
## Positive MEM eigenvectors (positive spatial autocorrelation) first
radialPositive &lt;- mgForward(radialDM,
    radialMEM$vectorsMEM[ , radialMEM$valuesMEM &gt; 0])
## Negative MEM eigenvectors (negative spatial autocorrelation) second
radialNegative &lt;- mgForward(radialDM,
    radialMEM$vectorsMEM[ , radialMEM$valuesMEM &lt; 0])


## Summarize the selected MEM eigenvectors
allSelected &lt;- cbind(radialMEM$vectorsMEM[, radialMEM$valuesMEM &gt; 0][
                    , na.omit(radialPositive$selectedMEM)],
                 radialMEM$vectorsMEM[, radialMEM$valuesMEM &lt; 0][
                    , na.omit(radialNegative$selectedMEM)])

## Use the selected MEM eigenvectors in a final model
radialAnalysis &lt;- mgRDA(radialDM, allSelected, full=TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='mgLandscape'>
Landscape genetic analysis using MEMGENE
</h2><span id='topic+mgLandscape'></span><span id='topic+print.mgLandscape'></span>

<h3>Description</h3>

<p>Use least-cost path distances among sampling locations on a resistance surface, rather than Euclidean distances (as in <code><a href="#topic+mgQuick">mgQuick</a></code>), to extract MEM eigenvectors.  The goal is to compare multiple resistance surfaces (i.e. representing alternative hypotheses about landscape resistance) in terms of the proportion of variation in genetic distance they explain.  This is often a goal in landscape genetic analysis.  By default Euclidean distances (i.e. representing a surface with no landscape resistance) are also analyzed unless <code>euclid=FALSE</code>.<br />
</p>
<p>The analysis steps are as follows:<br />
</p>
<p>1.   Find MEM eigenvectors given a distance matrix extracted from the
coordinates (<code>coords</code>).  In the case of a resistance surface the
distances are least-cost paths among sampling locations found using the
function <code>gdistance::costDistance</code>.  In the Euclidean case
Euclidean distances are used.  For all distance matrices a minimum spanning tree
of the locations is found, followed by truncation of the tree (see <code><a href="#topic+mgMEM">mgMEM</a></code>)<br />
</p>
<p>2.   Perform separate forward selections of positive and
negative MEM eigenvectors against genetic distance (<code>genD</code>),
to identify a significant
subset, using parameters <code>forwardPerm</code> as the number of
permutations and <code>forwardAlpha</code> as the alpha level
for a significant eigenvector. NOTE: The number of permutations
<code>forwardPerm</code> is set at 100 by default to reduce analysis time for
exploratory analyses.  This number should be increased for final analyses.<br />
</p>
<p>3.   Use variation partitioning against the genetic distance matrix
to find the proportion of variation in genetic
distance explained by the selected positive and negative MEM eigenvectors (i.e.
fraction [a] representing spatial genetic variation explained by the resistance surface hypothesis)
and the matrix of coordinates (i.e. fraction [c] representing spatial genetic variation
not explained by the resistance hypothesis).  These [a] and [c] fractions
can be used to inform model selection (see below). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgLandscape(resistance, genD, coords, euclid=TRUE, forwardPerm=100,
forwardAlpha=0.05, finalPerm=1000, verbose=TRUE)
## S3 method for class 'mgLandscape'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgLandscape_+3A_resistance">resistance</code></td>
<td>

<p>A <code>RasterLayer</code> produced by the <code>raster</code> package in a planar (i.e. not longitude/latitude) projection giving the hypothesized resistance to movement of landscape features (all cells must be either missing as <code>NA</code> or <code>&gt;=1</code>) To test multiple resistance hypotheses provide a <code>RasterStack</code> or <code>RasterBrick</code> also produced by the <code>raster</code> package.
</p>
</td></tr>
<tr><td><code id="mgLandscape_+3A_gend">genD</code></td>
<td>

<p>A symmetrical distance matrix giving the genetic distances among
individual genotypes or populations
</p>
</td></tr>
<tr><td><code id="mgLandscape_+3A_coords">coords</code></td>
<td>

<p>A two column <code>matrix</code> or <code>data.frame</code> of x and y coordinates of sampling locations of individual genotypes or populations.  Must be in the same planar projection as the resistance surface.  Geographic coordinates (i.e. longitude/latitude) must be projected before use.
</p>
</td></tr>
<tr><td><code id="mgLandscape_+3A_euclid">euclid</code></td>
<td>

<p>If <code>TRUE</code> will test the Euclidean distances among sampling locations in addition to the resistance
surface(s) supplied.  Including a Euclidean surface is recommended as a null model.
</p>
</td></tr>
<tr><td><code id="mgLandscape_+3A_forwardperm">forwardPerm</code></td>
<td>

<p>The number of permutations in the randomization test for the forward selection of MEM eigenvectors.
The default <code>forwardPerm=100</code> is sufficient for exploratory purposes, however this should be increased for final analyses.
</p>
</td></tr>
<tr><td><code id="mgLandscape_+3A_forwardalpha">forwardAlpha</code></td>
<td>

<p>The 1-alpha level for the forward selection process
</p>
</td></tr>
<tr><td><code id="mgLandscape_+3A_finalperm">finalPerm</code></td>
<td>

<p>The number of permutations to test the significance of the [a], [c] and [abc] fractions.
</p>
</td></tr>
<tr><td><code id="mgLandscape_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code> then report progress to the console
</p>
</td></tr>
<tr><td><code id="mgLandscape_+3A_x">x</code></td>
<td>

<p>An object of class <code>mgLandscape</code> produced by the <code>mgLandscape</code> function
</p>
</td></tr>
<tr><td><code id="mgLandscape_+3A_...">...</code></td>
<td>

<p>Additional parameters passed to <code>print</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A code$summary table giving the results of the variation partitioning.  The following table
provides an interpretation of each of the fractions returned:<br />
</p>
<p>Proportion of variation in genetic distance that is... <code>(RsqAdj)</code><br />
<code>[abc]   explained by spatial predictors</code><br />
<code>[a]     spatial and explained by selected patterns in the model</code><br />
<code>[c]     spatial and explained by coordinates not patterns in the model</code><br />
<code>[b]     spatial and confounded between the model and coordinates</code><br />
<code>[d]     residual not explained by the spatial predictors</code><br />
</p>
<p>A good model will have a relatively high [a] fraction and relatively low [c] fraction indicating
that the selected patterns in the landscape model have captured a large proportion of the spatial variation in genetic distance.<br />
</p>


<h3>Author(s)</h3>

<p>Pedro Peres-Neto (peres-neto.pedro@uqam.ca)<br />
Paul Galpern (pgalpern@ucalgary.ca)
</p>


<h3>References</h3>

<p>Galpern, P., Peres-Neto, P., Polfus, J., and Manseau, M.  2014.  MEMGENE: Spatial pattern detection in genetic distance data.  Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Compare data generated using the radial data against three landscape models
##
## Prepare two resistance surfaces to test (the true radial, and the false river)
## These are produced as a RasterStack object
if (require(raster)) {
    resistanceMaps &lt;- stack(
           raster(system.file("extdata/radial.asc", package="memgene")),
           raster(system.file("extdata/river.asc", package="memgene")))
} else {
  stop("raster package required for mgLandscape.")
}

## Prepare the radial data for analysis
radialData &lt;- read.csv(system.file("extdata/radial.csv", package="memgene"))
radialGen &lt;- radialData[, -c(1,2)]
radialXY &lt;- radialData[, 1:2]
if (require(adegenet)) {
  radialDM &lt;- codomToPropShared(radialGen)
} else {
  stop("adegenent package required to produce genetic distance matrix in example.")
}

## Analyse the two resistance surfaces and a Euclidean model
## and produce a table comparing the three
## Set permutations at low values for a faster (though less accurate) run
compareThree &lt;- mgLandscape(resistanceMaps, radialDM, radialXY, euclid=TRUE,
   forwardPerm=100, finalPerm=100)
   
print(compareThree)
## Results can vary between runs because selected MEM eigenvectors may vary.
## Setting forwardPerm higher will increase consistency in this regard.
##
## We see that the true radial surface has the highest [a] fraction and
## the lowest [c] fraction indicating that it does well at capturing
## the spatial genetic variation that we expect in this simulated genetic data

## End(Not run)
</code></pre>

<hr>
<h2 id='mgMap'>
Visualization of MEMGENE variables
</h2><span id='topic+mgMap'></span>

<h3>Description</h3>

<p>A high-level plotting interface for the bubble plot visualization of MEMGENE variables.<br />
If there are exactly two columns in <code>memgene</code> and therefore two MEMGENE variables to be plotted, then a single plotting window is created with the two plots side by side.  Otherwise each MEMGENE variable is plotted in its own window unless.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgMap(coords, memgene, wid = NULL, hei = NULL, dev.open = FALSE,
    add.plot = FALSE, legend = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgMap_+3A_coords">coords</code></td>
<td>

<p>A two column <code>matrix</code> or <code>data.frame</code> of x and y coordinates of sampling locations of individual genotypes
</p>
</td></tr>
<tr><td><code id="mgMap_+3A_memgene">memgene</code></td>
<td>

<p>A matrix giving as columns the MEMGENE variables to be plotted (e.g. can be subsetted from the <code>$memgene</code> element produced by <code><a href="#topic+mgQuick">mgQuick</a></code>)
</p>
</td></tr>
<tr><td><code id="mgMap_+3A_wid">wid</code></td>
<td>

<p>The width of the plotting device to be created.  If <code>NULL</code> the decision is made by the function.
</p>
</td></tr>
<tr><td><code id="mgMap_+3A_hei">hei</code></td>
<td>

<p>The width of the plotting device to be created.  If <code>NULL</code> the decision is made by the function.  
</p>
</td></tr>
<tr><td><code id="mgMap_+3A_dev.open">dev.open</code></td>
<td>

<p>If <code>TRUE</code> do not open a new plotting device.  
</p>
</td></tr>
<tr><td><code id="mgMap_+3A_add.plot">add.plot</code></td>
<td>

<p>If <code>TRUE</code> superimposing bubbles on an existing plot or map.  
</p>
</td></tr>
<tr><td><code id="mgMap_+3A_legend">legend</code></td>
<td>

<p>If <code>TRUE</code> add a legend to the plot
</p>
</td></tr>
<tr><td><code id="mgMap_+3A_...">...</code></td>
<td>

<p>Additional parameters passed to the <code>sr.value</code> function modified from Borcard et al (2011).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function embeds slightly modified versions of <code>sr.value</code>, <code>scatterutil.legend.bw.circle</code>, and <code>scatterutil.legend.circle.grey</code> distributed with Borcard et al. (2012) which are themselves modified from similar functions distributed with the <code>ade4</code> package under a GPL-2 license. 
</p>


<h3>Value</h3>

<p>Side effect.  A plot is produced.
</p>


<h3>Author(s)</h3>

<p>Pedro Peres-Neto (peres-neto.pedro@uqam.ca)<br />
Paul Galpern (pgalpern@ucalgary.ca)
</p>


<h3>References</h3>

<p>Borcard, D., Gillet, F., and Legendre. P.  2011.  Numerical Ecology with R.  Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Prepare the radial data for analysis
radialData &lt;- read.csv(system.file("extdata/radial.csv", package="memgene"))
radialGen &lt;- radialData[, -c(1,2)]
radialXY &lt;- radialData[, 1:2]
if (require(adegenet)) {
  radialDM &lt;- codomToPropShared(radialGen)
} else {
  stop("adegenent package required to produce genetic distance matrix in example.")
}

## Run the MEMGENE analysis
radialAnalysis &lt;- mgQuick(radialDM, radialXY)

## Visualize the first two MEMGENE variables side-by-side
mgMap(radialXY, radialAnalysis$memgene[, 1:2])

## Visualize the first MEMGENE variable superimposed over a raster map
## with the same coordinate system, AND include a legend
if (require(raster)) {
    resistanceMap &lt;- raster(system.file("extdata/radial.asc", package="memgene"))
    plot(resistanceMap, legend=FALSE)
    mgMap(radialXY, radialAnalysis$memgene[, 1], add.plot=TRUE, legend=TRUE)
} else {
    mgMap(radialXY, radialAnalysis$memgene[, 1], legend=TRUE)
}


## End(Not run)
</code></pre>

<hr>
<h2 id='mgMEM'>
Extraction of MEM eigenvectors given distances among sampling locations
</h2><span id='topic+mgMEM'></span>

<h3>Description</h3>

<p>Extract MEM eigenvectors given a distance matrix
among sampling locations of genetic material.  This matrix could be Euclidean
or otherwise.  If truncation and/or transformation parameters
are provided these operations occur. Truncation implies that distances
that exceed a threshold amount are assigned to 4 * threshold.  Minimum
spanning tree truncation is the recommended default.
Transformation performs an exponential or gaussian transformation of the
distance matrix after truncation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgMEM(locD, truncation = NULL, transformation = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgMEM_+3A_locd">locD</code></td>
<td>

<p>A symmetric distance matrix giving the distances (typically Euclidean)
among the sampling locations of genetic material (e.g. of genotyped individuals or populations).
</p>
</td></tr>
<tr><td><code id="mgMEM_+3A_truncation">truncation</code></td>
<td>

<p>See details (EXPERIMENTAL)
</p>
</td></tr>
<tr><td><code id="mgMEM_+3A_transformation">transformation</code></td>
<td>

<p>Can be character &quot;exponential&quot; or &quot;gaussian&quot; or NULL for no transformation (EXPERIMENTAL)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If sampling locations are in longitude/latitude and are far apart, be sure to
supply the geodesic distance as <code>locD</code>.  (Note that <code><a href="#topic+mgQuick">mgQuick</a></code> implements
geodesic distances using the <code>longlat=TRUE</code> parameter when provided with sampling coordinates)
</p>
<p><code>truncation</code><br />
</p>
<p>1.  Can be numeric from 0 to 1 specifying the
proportion of the maximum distance in locD to truncate
following this a  spanning tree is used to further
truncate as in PCNM (aka dbMEM or classical MEM) <br />
</p>
<p>2.  Can be NULL (default) indicating only the minimum spanning tree (MST) truncation where
links that exceed the longest link in the MST (dMST) are replaced with 4 * dMST<br />
</p>
<p>3.  Can be FALSE indicating that nothing is done to the distance matrix
which is only suitable when locD is non-euclidean (i.e. will have
negative eigenvectors
</p>


<h3>Value</h3>

<p>A list<br />
<code>$valuesMEM</code> gives the eigenvalues all MEM eigenvectors<br />
<code>$vectorsMEM</code> gives the MEM eigenvectors in columns
</p>


<h3>Author(s)</h3>

<p>Pedro Peres-Neto (peres-neto.pedro@uqam.ca)<br />
Paul Galpern (pgalpern@ucalgary.ca)
</p>


<h3>References</h3>

<p>Legendre, P., and Legendre L.  2012. Numerical Ecology, 3rd. ed.  Elsevier, Amsterdam.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Prepare the radial data for analysis
radialData &lt;- read.csv(system.file("extdata/radial.csv", package="memgene"))
radialXY &lt;- radialData[, 1:2]

## Find MEM eigenvectors given sampling locations
## by first finding the Euclidean distance matrix
radialEuclid &lt;- dist(radialXY)
radialMEM &lt;- mgMEM(radialEuclid)

</code></pre>

<hr>
<h2 id='mgQuick'>
Memgene analysis of genetic distance data (main interface for package)
</h2><span id='topic+mgQuick'></span>

<h3>Description</h3>

<p>Performs multiple&ndash;typical&ndash;steps in a memgene
analysis of genetic distance data.  Gracefully handles
potential errors.  Steps are as follows:
</p>
<p>1.   Find MEM eigenvectors given 
coordinates (<code>coords</code>)<br />
</p>
<p>2.   Perform separate forward selections of positive and
negative MEM eigenvectors against genetic distance (<code>genD</code>),
to identify a significant
subset, using parameters <code>forwardPerm</code> as the number of
permutations and <code>forwardAlpha</code> as the alpha level
for a significant eigenvector.  NOTE: The number of permutations
<code>forwardPerm</code> is set at 100 by default to reduce analysis time for
exploratory analyses.  This number should be increased for final analyses.<br />
</p>
<p>3.   Find the fit of the selected eigenvectors to the
genetic distance data (using RDA).<br />
</p>
<p>4.   Optionally run a permutation test (<code>finalPerm</code>) for
the fit of the selected eigenvectors to the genetic distance
data.<br />
</p>
<p>5.   Produce MEMGENE variables using the fitted values from the RDA
analysis.  MEMGENE variables are the eigenvectors from a PCA of the fitted
values.  These are the product of memgene and can be used for visualization
and subsequent analyses.
</p>
<p>6.   Optionally produce plots of the scores for the
first <code>n</code> MEMGENE variables if <code>doPlot = n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgQuick(genD, coords, longlat = FALSE, truncation = NULL,
    transformation = NULL, forwardPerm = 100, forwardAlpha = 0.05,
    finalPerm = NULL, doPlot = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgQuick_+3A_gend">genD</code></td>
<td>

<p>A symmetrical distance matrix giving the genetic distances among
individual genotypes or populations
</p>
</td></tr>
<tr><td><code id="mgQuick_+3A_coords">coords</code></td>
<td>

<p>A two column <code>matrix</code> or <code>data.frame</code> of x and y coordinates of sampling locations of individual genotypes
</p>
</td></tr>
<tr><td><code id="mgQuick_+3A_longlat">longlat</code></td>
<td>

<p>If <code>TRUE</code> then <code>coords</code> are longitude and latitude, so
find the geodesic distances among sampling locations using the <code>geosphere</code> package
</p>
</td></tr>
<tr><td><code id="mgQuick_+3A_truncation">truncation</code></td>
<td>

<p><code>NULL</code> under typical usage.  See <code><a href="#topic+mgMEM">mgMEM</a></code> for experimental options.
</p>
</td></tr>
<tr><td><code id="mgQuick_+3A_transformation">transformation</code></td>
<td>

<p><code>NULL</code> under typical usage.  See <code><a href="#topic+mgMEM">mgMEM</a></code> for experimental options.  
</p>
</td></tr>
<tr><td><code id="mgQuick_+3A_forwardperm">forwardPerm</code></td>
<td>

<p>The number of permutations in the randomization test for the forward selection of MEM eigenvectors. The default <code>forwardPerm=100</code> is sufficient for exploratory purposes, however this should be increased for final analyses.
</p>
</td></tr>
<tr><td><code id="mgQuick_+3A_forwardalpha">forwardAlpha</code></td>
<td>

<p>The 1-alpha level for the forward selection process
</p>
</td></tr>
<tr><td><code id="mgQuick_+3A_finalperm">finalPerm</code></td>
<td>

<p>The number of permutations for the final randomization test of the reduced model.  <code>NULL</code> by
default does not perform a final randomization test.
</p>
</td></tr>
<tr><td><code id="mgQuick_+3A_doplot">doPlot</code></td>
<td>

<p>Plot <code>doPlot = n</code> MEMGENE variables
</p>
</td></tr>
<tr><td><code id="mgQuick_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code> then report progress to the console
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list<br />
<code>$P</code> gives the probability of the null hypothesis for the RDA on the final model<br />
<code>$RSqAdj</code> is the adjusted R2 for the RDA, understood as the proportion of
all genetic variation that is explicable by spatial pattern (i.e. spatial genetic
signal)<br />
<code>$memgene</code> contains a matrix with the MEMGENE variables in columns<br />
<code>$memSelected</code> gives a matrix containing the selected MEM eigenvectors in columns<br />
<code>$whichSelectPos</code> gives the indices of the selected MEM eigenvectors with positive eigenvalues (i.e. from <code>$mem</code>)<br />
<code>$whichSelectNeg</code> gives the indices of the selected MEM eigenvectors with negative eigenvalues (i.e. from <code>$mem</code>)<br />
<code>$mem</code> the output of <code><a href="#topic+mgMEM">mgMEM</a></code> given <code>coords</code>
</p>


<h3>Author(s)</h3>

<p>Pedro Peres-Neto (peres-neto.pedro@uqam.ca)<br />
Paul Galpern (pgalpern@ucalgary.ca)
</p>


<h3>References</h3>

<p>Galpern, P., Peres-Neto, P., Polfus, J., and Manseau, M.  2014.  MEMGENE: Spatial pattern detection in genetic distance data.  Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Prepare the radial data for analysis
radialData &lt;- read.csv(system.file("extdata/radial.csv", package="memgene"))
radialGen &lt;- radialData[, -c(1,2)]
radialXY &lt;- radialData[, 1:2]
if (require(adegenet)) {
  radialDM &lt;- codomToPropShared(radialGen)
} else {
  stop("adegenent package required to produce genetic distance matrix in example.")
}

## Run the MEMGENE analysis
radialAnalysis &lt;- mgQuick(radialDM, radialXY)

## Extract the scores on the first 3 MEMGENE variables
## for subsequent analysis
radialMEMGENE1 &lt;- radialAnalysis$memgene[, 1]
radialMEMGENE2 &lt;- radialAnalysis$memgene[, 2]
radialMEMGENE3 &lt;- radialAnalysis$memgene[, 3]

## Find the proportion of variation explained by all MEMGENE variables
propVariation &lt;- radialAnalysis$sdev/sum(radialAnalysis$sdev)

## End(Not run)
</code></pre>

<hr>
<h2 id='mgRDA'>
Extraction of MEMGENE variables using redundancy analysis (RDA)
</h2><span id='topic+mgRDA'></span>

<h3>Description</h3>

<p>Performs a redundancy analysis (RDA) given MEM eigenvectors and
a genetic distance matrix.  Optionally performs a permutation test
for the RDA. Returns the MEMGENE variables, which are the product of a PCA
conducted on the fitted values of this RDA. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgRDA(genD, vectorsMEM, perm = NULL, full = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgRDA_+3A_gend">genD</code></td>
<td>

<p>A symmetrical distance matrix giving the genetic distances among
individual genotypes or populations
</p>
</td></tr>
<tr><td><code id="mgRDA_+3A_vectorsmem">vectorsMEM</code></td>
<td>

<p>A matrix giving a set of any number of MEM eigenvectors 
</p>
</td></tr>
<tr><td><code id="mgRDA_+3A_perm">perm</code></td>
<td>

<p>The number of permutations in a randomization test
</p>
</td></tr>
<tr><td><code id="mgRDA_+3A_full">full</code></td>
<td>

<p>If <code>TRUE</code> returns the MEMGENE variables.  <code>FALSE</code> is used
primarily by <code><a href="#topic+mgForward">mgForward</a></code> which calls this function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any type of genetic distance matrix <code>genD</code> giving pairwise
distances among individual genotypes could be used.  Population genetic distances (e.g. pairwise
Fst among populations) could also be used in principle, in which case the sampling centroids
of populations should be used to develop the MEM eigenvectors.
</p>


<h3>Value</h3>

<p>A list:<br />
<code>$RsqAdj</code> is the adjusted R2 for the RDA, understood as the proportion of
all genetic variation that is explicable by spatial pattern (i.e. spatial genetic
signal)<br />
<code>$memgene</code> gives the MEMGENE variables ordered according to the eigenvalues
which are given in <code>$sdev</code>
</p>


<h3>Author(s)</h3>

<p>Pedro Peres-Neto (peres-neto.pedro@uqam.ca)<br />
Paul Galpern (pgalpern@ucalgary.ca)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Prepare the radial data for analysis
radialData &lt;- read.csv(system.file("extdata/radial.csv", package="memgene"))
radialGen &lt;- radialData[, -c(1,2)]
radialXY &lt;- radialData[, 1:2]

if (require(adegenet)) {
  radialDM &lt;- codomToPropShared(radialGen)
} else {
  stop("adegenent package required to produce genetic distance matrix in example.")
}


## Find MEM eigenvectors given sampling locations
## by first finding the Euclidean distance matrix
radialEuclid &lt;- dist(radialXY)
radialMEM &lt;- mgMEM(radialEuclid)

## Forward select significant MEM eigenvectors using RDA
## Positive MEM eigenvectors (positive spatial autocorrelation) first
radialPositive &lt;- mgForward(radialDM,
    radialMEM$vectorsMEM[ , radialMEM$valuesMEM &gt; 0])
## Negative MEM eigenvectors (negative spatial autocorrelation) second
radialNegative &lt;- mgForward(radialDM,
    radialMEM$vectorsMEM[ , radialMEM$valuesMEM &lt; 0])


## Summarize the selected MEM eigenvectors
allSelected &lt;- cbind(radialMEM$vectorsMEM[, radialMEM$valuesMEM &gt; 0][
                    , na.omit(radialPositive$selectedMEM)],
                 radialMEM$vectorsMEM[, radialMEM$valuesMEM &lt; 0][
                    , na.omit(radialNegative$selectedMEM)])

## Use the selected MEM eigenvectors in a final model
radialAnalysis &lt;- mgRDA(radialDM, allSelected, full=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='mgVarPart'>
Variation partitioning of the genetic distance matrix 
</h2><span id='topic+mgVarPart'></span>

<h3>Description</h3>

<p>This function performs a variation partitioning of the genetic distance matrix
using the supplied MEM eigenvectors and spatial coordinates.  Randomization tests
are conducted to determine the significance of the [a] fraction representing
the MEM eigenvectors, the [c] fraction representing the spatial coordinates and
the [abc] fraction representing the spatial genetic variation.  It is called
by <code><a href="#topic+mgLandscape">mgLandscape</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgVarPart(genD, vectorsMEM, coords, perm=1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgVarPart_+3A_gend">genD</code></td>
<td>

<p>A symmetrical distance matrix giving the genetic distances among
individual genotypes or populations
</p>
</td></tr>
<tr><td><code id="mgVarPart_+3A_vectorsmem">vectorsMEM</code></td>
<td>

<p>A matrix giving a set of any number of MEM eigenvectors 
</p>
</td></tr>
<tr><td><code id="mgVarPart_+3A_coords">coords</code></td>
<td>

<p>A two column <code>matrix</code> or <code>data.frame</code> of x and y coordinates of sampling locations of individual genotypes or populations. 
</p>
</td></tr>
<tr><td><code id="mgVarPart_+3A_perm">perm</code></td>
<td>

<p>The number of permutations to use when testing the significance of the [a], [c] and [abc] fractions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+mgLandscape">mgLandscape</a></code> for explanation of the fractions.
</p>


<h3>Author(s)</h3>

<p>Pedro Peres-Neto (peres-neto.pedro@uqam.ca)<br />
Paul Galpern (pgalpern@ucalgary.ca)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Prepare the radial data for analysis
radialData &lt;- read.csv(system.file("extdata/radial.csv", package="memgene"))
radialGen &lt;- radialData[, -c(1,2)]
radialXY &lt;- radialData[, 1:2]

if (require(adegenet)) {
  radialDM &lt;- codomToPropShared(radialGen)
} else {
  stop("adegenent package required to produce genetic distance matrix in example.")
}


## Find MEM eigenvectors given sampling locations
## by first finding the Euclidean distance matrix
radialEuclid &lt;- dist(radialXY)
radialMEM &lt;- mgMEM(radialEuclid)

## Forward select significant MEM eigenvectors using RDA
## Positive MEM eigenvectors (positive spatial autocorrelation) first
radialPositive &lt;- mgForward(radialDM,
    radialMEM$vectorsMEM[ , radialMEM$valuesMEM &gt; 0])
## Negative MEM eigenvectors (negative spatial autocorrelation) second
radialNegative &lt;- mgForward(radialDM,
    radialMEM$vectorsMEM[ , radialMEM$valuesMEM &lt; 0])


## Summarize the selected MEM eigenvectors
allSelected &lt;- cbind(radialMEM$vectorsMEM[, radialMEM$valuesMEM &gt; 0][
                    , na.omit(radialPositive$selectedMEM)],
                 radialMEM$vectorsMEM[, radialMEM$valuesMEM &lt; 0][
                    , na.omit(radialNegative$selectedMEM)])

## Use the selected MEM eigenvectors and coordinates in
## variation partitioning
radialVarPart &lt;- mgVarPart(radialDM, allSelected, radialXY)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
