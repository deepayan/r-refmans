<!DOCTYPE html><html lang="en"><head><title>Help for package CommEcol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CommEcol}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CommEcol-package'><p>Community Ecology Analyses</p></a></li>
<li><a href='#autosimi'><p>Autosimilarity curve of species community data</p></a></li>
<li><a href='#betaRegDisp'><p>Beta diversity metrics between sites in a moving window along environmental gradients</p></a></li>
<li><a href='#CommEcol-internal'><p>Internal CommEcol objects</p></a></li>
<li><a href='#compas'><p>Simulation of species community data along gradients</p></a></li>
<li><a href='#dis.chao'><p>Chao et al. dissimilarity indices</p></a></li>
<li><a href='#dis.goodall'><p>Goodall dissimilarity index</p></a></li>
<li><a href='#dis.nness'><p>NNESS and NESS dissimilarity indices</p></a></li>
<li><a href='#japi'><p>Macroinvertebrate morphospecies living on stones of a stream in southeast Brazil</p></a></li>
<li><a href='#part.m.tree'><p>Partition of multi-sample dissimilarity indices using phylogenetic/functional data</p></a></li>
<li><a href='#part.p.tree'><p>Partition of pair-wise dissimilarity indices using phylogenetic/functional data</p></a></li>
<li><a href='#select.window'><p>Select cells inside a defined window of a gridded dataset</p></a></li>
<li><a href='#sites4.6'><p>Artificial dataset containing 4 samples [rows] and 6 species[columns].</p></a></li>
<li><a href='#sites5.6'><p>Artificial dataset containing 5 samples [rows] and 6 species[columns].</p></a></li>
<li><a href='#sites6.6'><p>Artificial dataset containing 6 samples [rows] and 6 species[columns].</p></a></li>
<li><a href='#stairs6'><p>Example of phylogenetic tree containing 6 species.</p></a></li>
<li><a href='#standExtent'><p>Standardization of spatial extent for two metacommunities by subsampling</p></a></li>
<li><a href='#tree6'><p>Example of phylogenetic tree containing 6 species.</p></a></li>
<li><a href='#treeNodf'><p>Tree-like Nestedness of Ecological Metacommunities</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Community Ecology Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-18</td>
</tr>
<tr>
<td>Depends:</td>
<td>vegan, rncl</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, picante, adespatial, betapart, gmp</td>
</tr>
<tr>
<td>Description:</td>
<td>Autosimilarity curves, standardization of spatial extent, dissimilarity indexes that overweight rare species, phylogenetic and functional (pairwise and multisample) dissimilarity indexes and nestedness for phylogenetic, functional and other diversity metrics. The methods for phylogenetic and functional nestedness is described in Melo, Cianciaruso and Almeida-Neto (2014) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12185">doi:10.1111/2041-210X.12185</a>&gt;. This should be a complement to available packages, particularly 'vegan'. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adriano Sanches Melo &lt;asm.adrimelo@gmail.com&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Adriano Sanches Melo [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-18 18:28:35 UTC; asmad</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-28 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CommEcol-package'>Community Ecology Analyses</h2><span id='topic+CommEcol-package'></span><span id='topic+CommEcol'></span>

<h3>Description</h3>

<p>Community Ecology Analyses.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> CommEcol</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.8.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-06-18</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Community Ecology Analyses. This should be a complement to available packages, particularly vegan.
</p>


<h3>Author(s)</h3>

<p>Adriano Sanches Melo<br />
Maintainer: Adriano Sanches Melo &lt;asm.adrimelo@gmail.com&gt;
</p>

<hr>
<h2 id='autosimi'>Autosimilarity curve of species community data</h2><span id='topic+autosimi'></span>

<h3>Description</h3>

<p>Similarities among two subsamples, each one obtained randomly from the same community dataset. Curves are otained for all subsample sizes from 1 up to half the number of sample units in the dataset. Autosimilarity curves can be used to evaluate sample suficiency when sample size is expressed as number of sampling units such as traps or quadrats. This is particularly suitable when the study involves similarities or dissimilarities among samples such as agglomerative clustering, ordination, Mantel test.</p>


<h3>Usage</h3>

<pre><code class='language-R'>autosimi(comm, method="bray", binary=FALSE, log.transf=FALSE, simi=TRUE, permutations=50)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autosimi_+3A_comm">comm</code></td>
<td>
<p>Dataframe or matrix with samples in rows and species in columns.</p>
</td></tr>
<tr><td><code id="autosimi_+3A_method">method</code></td>
<td>
<p>Similarity index obtained from <code><a href="vegan.html#topic+vegdist">vegdist</a></code>. Similarities are obtained simply as 1-dissimilarity. Accordingly, it only makes sense for indices bounded at 0-1. For indices not bounded at 0-1 (distances), use <code>simi=FALSE</code> to obtain autodissimilarity curves.</p>
</td></tr>
<tr><td><code id="autosimi_+3A_binary">binary</code></td>
<td>
<p>Should data be transformed to presence/absence?</p>
</td></tr>
<tr><td><code id="autosimi_+3A_log.transf">log.transf</code></td>
<td>
<p>Transformation <code>log(x+1)</code> before calculation of similarities (or dissimilarities)</p>
</td></tr>
<tr><td><code id="autosimi_+3A_simi">simi</code></td>
<td>
<p>Similarity or dissimilarity curve.</p>
</td></tr>
<tr><td><code id="autosimi_+3A_permutations">permutations</code></td>
<td>
<p>Number of curves randomly calculated and from which the mean autosimilairty curve is obtained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function selects randomly and without replacement an even number of sampling units (n = 2,4,6, ...) from the total sampling units. Next, the first n/2 sampling units are pooled (summed) to create a subsample, and the other n/2 sampling units to create another subsample. If <code>binary=TRUE</code>, the two subsamples are transformed to presence/absence. If <code>log.transf=TRUE</code>, <code>log(x+1)</code> of each value is obtained. The similarity between the two subsamples is calculated and stored. The procedure is repeated for larger subsample sizes until half the size of the full dataset (or up to the integer quotient in the case of odd numbers of sample units). The procedure is then repeated for the requested number of curves. The output is the average curve. This function is a different implementation of the procedures described in Schneck &amp; Melo (2010).
</p>


<h3>Value</h3>

<p>A dataframe containing subsample sizes and average similarity values. 
</p>


<h3>Author(s)</h3>

<p>Adriano Sanches Melo</p>


<h3>References</h3>

<p>Cao, Y., D.P. Larsen &amp; R.M. Hughes. 2001. Evaluating sampling sufficiency in fish assemblage surveys: a
similarity-based approach. Canadian Jounal of Fisheries and Aquatic Sciences 58: 1782-1793.
</p>
<p>Schneck, F. &amp; A.S. Melo. 2010. Reliable sample sizes for estimating similarity among macroinvertebrate assemblages in tropical streams. Annales de Limnologie 46: 93-100.
</p>
<p>Weinberg, S. 1978. Minimal area problem in invertebrate communities of Mediterranean rocky substrata. Marine Biology 49: 33-40.
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+vegdist">vegdist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-matrix(0,4,4)
diag(x)&lt;-1
x4&lt;-rbind(x,x,x,x)
x4
autosimi(x4, binary=TRUE)
plot(autosimi(x4, binary=TRUE))

data(BCI)
simi&lt;-autosimi(BCI, binary=TRUE, permutations=5)
simi
plot(simi, ylim=c(0.5,1)) # maintain the plot window open for the next curve
simi.log&lt;-autosimi(BCI, binary=FALSE, log.transf=TRUE, permutations=5)
points(simi.log, col="red")
</code></pre>

<hr>
<h2 id='betaRegDisp'>Beta diversity metrics between sites in a moving window along environmental gradients</h2><span id='topic+betaRegDisp'></span>

<h3>Description</h3>

<p>The function computes eight metrics of beta diversity according to an informed environmental gradient. It selects a given number of environmentally-neighborhood sites in a moving window to obtain beta diversity.</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaRegDisp(y, x, xy.coords = NULL, ws = 3, 
            method.1 = "jaccard", method.2 = "ruzicka", 
            method.3 = "ruzicka", 
            independent.data = FALSE, illust.plot = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betaRegDisp_+3A_y">y</code></td>
<td>
<p>Response matrix, where rows are sites and columns are species.</p>
</td></tr>
<tr><td><code id="betaRegDisp_+3A_x">x</code></td>
<td>
<p>Predictor vector. A vector of the environmental gradient under study with the same number of sites as in matrix <code>y</code>. Make sure the order of samples in <code>y</code> and <code>x</code> is the same.</p>
</td></tr>
<tr><td><code id="betaRegDisp_+3A_xy.coords">xy.coords</code></td>
<td>
<p>Geographical coordinates. A matrix with two columns of XY decimal degree geographical coordinates, which are used to compute euclidean distance among sites. Rows must be sites in the same order as in <code>y</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="betaRegDisp_+3A_ws">ws</code></td>
<td>
<p>Window size or number of sites to be used in the computation of the distinct beta-diversity metrics or between-site dissimilarities.  It must be a positive integer higher than 2.</p>
</td></tr>
<tr><td><code id="betaRegDisp_+3A_method.1">method.1</code></td>
<td>
<p>For beta-diversity metrics 1 to 3 (see details). A dissimilarity index available in the <code><a href="vegan.html#topic+vegdist">vegdist</a></code>. The options are: &quot;euclidean&quot;, &quot;jaccard&quot;, &quot;bray&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;kulczynski&quot;, &quot;gower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;,  &quot;raup&quot;, &quot;binomial&quot;, &quot;chao&quot;, &quot;altGower&quot;, &quot;cao&quot;, &quot;mahalanobis&quot;.</p>
</td></tr>
<tr><td><code id="betaRegDisp_+3A_method.2">method.2</code></td>
<td>
<p>For beta-diversity metrics 4 and 5 (see details). A dissimilarity index available in the <code><a href="adespatial.html#topic+beta.div">beta.div</a></code>. The options are: &quot;hellinger&quot;, &quot;chord&quot;, &quot;log.chord&quot;, &quot;chisquare&quot;, &quot;profiles&quot;, &quot;percentdiff&quot;, &quot;ruzicka&quot;, &quot;divergence&quot;, &quot;canberra&quot;, &quot;whittaker&quot;, &quot;wishart&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;sorensen&quot;, &quot;ochiai&quot;, &quot;ab.jaccard&quot;, &quot;ab.sorensen&quot;, &quot;ab.ochiai&quot;, &quot;ab.simpson&quot;, &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="betaRegDisp_+3A_method.3">method.3</code></td>
<td>
<p>For beta-diversity metrics 6, 7, and 8 (see details). A multisample dissimilarity index available in the <code><a href="betapart.html#topic+beta.multi.abund">beta.multi.abund</a></code>. The options are: &quot;ruzicka&quot; and &quot;bray&quot;.</p>
</td></tr>
<tr><td><code id="betaRegDisp_+3A_independent.data">independent.data</code></td>
<td>
<p>Should windows not superpose each other? If <code>independent.data=TRUE</code>, sites do not enter more than once in the dissimilarity calculations, that is, sites are included in a single window.</p>
</td></tr>
<tr><td><code id="betaRegDisp_+3A_illust.plot">illust.plot</code></td>
<td>
<p>Should a window plot be open and illustrate how the window moves along the gradient?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes eight beta-diversity metrics among sites included in a set (window) of length <code>ws</code>. See details in Dala-Corte et al. (2019).
</p>
<p>Metrics 1-3 uses dissimilarity indices available in <code><a href="vegan.html#topic+vegdist">vegdist</a></code>:
</p>
<p>1. Mean pair-wise dissimilarity between sites in a window;
</p>
<p>2. Mean dissimilarity between focal site and the other sites in a window. If an odd number is informed in <code>ws</code>, the focal site is the central site in relation to its neighbours in the window. If an even number is informed in <code>ws</code>, the focal site is the first site in the window;
</p>
<p>3. Mean distance of sites to their group centroid in a Principal Coordinate (PCoA) space computed using <code><a href="vegan.html#topic+betadisper">betadisper</a></code>;
</p>
<p>Metrics 4-5 uses dissimilarity indices available in <code><a href="adespatial.html#topic+beta.div">beta.div</a></code>:
</p>
<p>4. Total sum of squares (SS) of the window sites (Legendre and De Caceres, 2013);
</p>
<p>5. Local contributions to beta diversity (LCBD; Legendre and De Caceres, 2013);
</p>
<p>Metrics 6-8 uses dissimilarity indices available in <code><a href="betapart.html#topic+beta.multi.abund">beta.multi.abund</a></code>:
</p>
<p>6. Total multiple-site dissimilarities for a selected window of sites;
</p>
<p>7. Nestedness component of multiple-site dissimilarities for a selected window of sites;
</p>
<p>8. Turnover component of multiple-site dissimilarities for a selected window of sites. 
</p>


<h3>Value</h3>

<p>A matrix with 10 columns (or 12 if <code>xy.coords</code> is informed). Values in columns are sorted according to the enviromental gradient, from the lowest to the highest value. Columns correspond to:
</p>
<p>1. <code>grad</code> - The environmental gradient (predictor vector, <code>x</code>);
</p>
<p>2. <code>mean.grad</code> - Mean value of the environmental gradient of sites selected in each window;
</p>
<p>3. <code>mean.diss.pairs</code> - Mean pair-wise dissimilarity between sites in a selected window (metric 1);
</p>
<p>4. <code>diss.focal</code> - Mean dissimilarity between focal site and the other sites (metric 2);
</p>
<p>5. <code>mean.dist.cent </code> - Mean distance of sites to their group centroid in a Principal Coordinate (PCoA) space (metric 3);
</p>
<p>6. <code>SS.group</code> - Total sum of squares (SS) of the sites in a window (metric 4); 
</p>
<p>7. <code>SS.focal</code> - Local contributions to beta diversity (LCBD), which represents how much a focal site contributed to the total window SS;
</p>
<p>8. <code>beta.TOT</code> - Total multiple-site dissimilarity;
</p>
<p>9. <code>beta.NES</code> - Nestedness component of multiple-site dissimilarity;
</p>
<p>10. <code>beta.TUR</code> - Turnover component of multiple-site dissimilarity;
</p>
<p>11. <code>mean.geodist</code> - If <code>xy.coords</code> is provided, the mean linear euclidean distance between sites in the a window is returned.
</p>
<p>12. <code>focal.geodist</code> - If <code>xy.coords</code> is provided, the mean linear euclidean distance of the focal site in relation to its neighbours in the window is returned. 
</p>


<h3>Author(s)</h3>

<p>Luciano F. Sgarbi, Renato B. Dala-Corte and Adriano S. Melo</p>


<h3>References</h3>

<p>Anderson, M.J., K.E. Ellingsen and B.H. McArdle. 2006. Multivariate dispersion as a measure of beta diversity. Ecology Letters 9: 683-693.
</p>
<p>Baselga, A. 2010. Partitioning the turnover and nestedness components of beta diversity. Global Ecology and Biogeography 19: 134-143.
</p>
<p>Baselga, A. 2017. Partitioning abundance-based multiple-site dissimilarity into components: balanced variation in abundance and abundance gradients. Methods in Ecology and Evolution 8: 799-808.
</p>
<p>Dala-Corte, R.B., L.F. Sgarbi, F.G. Becker and A.S. Melo. 2019. Beta diversity of stream fish communities along anthropogenic environmental gradients at multiple spatial scales. Environmental Monitoring and Assessment 191:288.
</p>
<p>Legendre, P. and M. De Caceres. 2013. Beta diversity as the variance of community data: dissimilarity coefficients and partitioning. Ecology Letters 16: 951-963.
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+vegdist">vegdist</a></code>, <code><a href="vegan.html#topic+betadisper">betadisper</a></code>, <code><a href="adespatial.html#topic+beta.div">beta.div</a></code>, <code><a href="betapart.html#topic+beta.multi">beta.multi</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1. A simmulated community matrix with a known structure of increasing
##  beta diversity by turnover
# n is the total sample sites
# LocS is the number of spp per site
# MaxS is the total number of spp in the matrix

# All samples will contain LocS species. The first sample will contain presences
# for the first LocS species. The subsequent samples will contain LocS presences
# spread over a increasing set of species. The assignment of presences for the
# second sample to the last sample is done randomly. The last sample will
# contain LocS presences assigned randomly to the MaxS species. Thus, for a 
# window size of 3 (ws=3) and a dataset of 10 samples, beta diversity for the
# samples 1-3 will be much lower than for samples 8-10.   

SimComm &lt;- function(n = 19, MaxS = 24, LocS = 8){
    s &lt;- seq (LocS, MaxS, length.out = n)
    mat &lt;- matrix(0, n, MaxS, dimnames = 
                      list(paste("site", 1:n, sep = "_"), 
                           paste("sp", 1:MaxS, sep = "_")))
    for(i in 1:n){
        mat[i, sample(1:s[i], LocS)] &lt;- 1
    }
    mat &lt;- mat[, colSums(mat)!=0]
    return(mat)
}

mat &lt;- SimComm(n = 19, MaxS = 24, LocS = 8)

#Creating an environmental gradient:
grad &lt;- 1:nrow(mat)

b.resu &lt;- betaRegDisp(y = mat, x = grad, xy.coord = NULL, ws = 3, 
                      method.1 = "jaccard", 
                      method.2 = "ruzicka",
                      method.3 = "ruzicka", 
                      independent.data = FALSE, illust.plot = FALSE)

##Ploting all the output of the object for the simmulated community
op &lt;- par(no.readonly = TRUE)
par(mfrow = c(5, 2), oma = c(1, 0, 1, 0.1), mar = c(1.5, 3, .1, .1), cex = 1, las = 0)
for(i in 1:ncol(b.resu)){
  plot(b.resu[, 1], b.resu[, i], ylab = colnames(b.resu)[i], cex.lab = .9, 
       cex.axis = 0.9, tcl = -0.2, mgp = c(1.5, .2, 0), pch = 15, col = "grey")
}
mtext("Environmental gradient", cex = 1.3, 1, -0.1, outer = TRUE)
par(op)



##Example 2
data(varespec)
data(varechem)
grad &lt;- varechem[, "Baresoil"]
resu &lt;- betaRegDisp(y = varespec, x = grad, ws = 3, method.1 = "jaccard", 
            method.2 = "ruzicka", method.3 = "ruzicka", 
            independent.data = FALSE, illust.plot = FALSE)

#Plotting all the outputs of the function:
op &lt;- par(no.readonly = TRUE)
par(mfrow = c(5, 2), oma = c(1, 0, 1, 0.1), mar = c(1.5, 3, .1, .1), cex = 1, las = 0)
for(i in 1:ncol(resu)){
  plot(resu[, 1], resu[, i], ylab = colnames(resu)[i], cex.lab = .9, 
       cex.axis = 0.9, tcl = -0.2, mgp = c(1.5, .2, 0), pch = 15, col = "grey")
}
mtext("Environmental gradient", cex = 1.3, 1, 0, outer = TRUE)
par(op)

</code></pre>

<hr>
<h2 id='CommEcol-internal'>Internal CommEcol objects</h2><span id='topic+CommEcol-internal'></span>

<h3>Description</h3>

<p>Internal CommEcol objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='compas'>Simulation of species community data along gradients</h2><span id='topic+compas'></span>

<h3>Description</h3>

<p>The function generates unimodal curves of different shapes according to the specification of different parameter values. For different combinations of parameters, the response function may resemble the Gaussian curve or its skewed and platykurtic variations. Simulated observations are obtained by generating values for parameters and solving the function for defined x-values. In an ecological context, the response curve may be interpreted as densities of a species along an environmental gradient. Solving the function for a given x-value would be equivalent to sampling the species at the coordinate x. If many different curves are generated, solving the function for a given x-value would be equivalent to sampling a community at the coordinate x of the gradient. The idea is easily expanded to include two or more gradients or dimensions. For the case of two gradients, two sets of coordinates, one for each dimension, are used to obtain a community observation. A theory justifying the use of response curves along gradients and a discussion of the shapes of these curves is found in McGill &amp; Collins (2003). The code is mostly based on Minchin (1987a, 1987b).</p>


<h3>Usage</h3>

<pre><code class='language-R'>compas(S, dims, am, clump=1, beta.R, coords, n.quanti=5, n.quali=0.1, add1)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compas_+3A_s">S</code></td>
<td>
<p>The number of species occurring in the simulated gradients. This IS NOT necessarily the number of species that will appear in the resulting dataset as some species may not be &quot;sampled&quot;.</p>
</td></tr>
<tr><td><code id="compas_+3A_dims">dims</code></td>
<td>
<p>Number of gradients (dimensions).</p>
</td></tr> 
<tr><td><code id="compas_+3A_am">am</code></td>
<td>
<p>A vector of abundance of species in its modal point (log scale) for each gradient. This(ese) value(s) is(are) used to sample a lognormal distribution with mean(s) <code>am</code> and sd=1. The number of supplied means should be the same of the number of <code>dims</code>.</p>
</td></tr>
<tr><td><code id="compas_+3A_clump">clump</code></td>
<td>
<p>A non-zero positive integer indicating how strong the species richness gradient is. For <code>clump</code>=1, modal points for species (see Details) are randomly and uniformly distributed in the space and thus species richness are mostly homogeneous. For higher values, more modal points of species (and thus more species) will be clumped on higher values of the gradient(s) (the upper right-hand corner if <code>dims</code>=2. See example.</p>
</td></tr>
<tr><td><code id="compas_+3A_beta.r">beta.R</code></td>
<td>
<p>Beta diversity (turnover) parameter.</p>
</td></tr>
<tr><td><code id="compas_+3A_coords">coords</code></td>
<td>
<p>A matrix-like (or vector if <code>dims</code>=1) object with coordinates of sampling sites. The number of columns (axes) should be the same of the number of <code>dims</code>.</p>
</td></tr>
<tr><td><code id="compas_+3A_n.quanti">n.quanti</code></td>
<td>
<p>A value higher than 0 indicating how much noise or variability should be added to abudance values sampled from the response curves. Each abundance value is substituted by a random value obtained from a Negative Binomial distribution with mean equal to the respective abundance value and variance proportional to <code>n.quanti</code>.</p>
</td></tr> 
<tr><td><code id="compas_+3A_n.quali">n.quali</code></td>
<td>
<p>Qualitative Noise. Each specie has probability &quot;1-n.quali&quot; of occurring in a site within its range. The argument control the replacement of <code>n.quali</code>*100% of the abundance values by &quot;0&quot;.</p>
</td></tr>
<tr><td><code id="compas_+3A_add1">add1</code></td>
<td>
<p>A value between 0 and 1. Add (<code>add1</code>*100)% of &quot;marginal/vagrant species&quot; occurring randomly with 1 individual in the entire dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is based on the software Compas (Minchin 1987b), described in detail in Minchin (1987a). Simulated parameters are random values obtained from distributions such as the normal and the uniform. Some of these parameters can be modified by users. However, some them are fixed and not modified unless you are able to edit the code. The option to fix some of the parameters should simplify the use of the function.
</p>
<p>The number of species in the simulated matrix may be smaller than <code>S</code> because some species may occur outside the gradient. The gradiente is -50 up to 150, but 'sampling' occurs only at the range 0-100. This allows species to have their mode outside the 0-100 gradient. Also, species occurring in the gradient may not be sampled as a result of the quantitative (<code>n.quanti</code>) and qualitative (<code>n.quali</code>) noises added.
</p>
<p>Parameters alpha and gamma (not available as arguments), which together determine curve symmetry and kurtosis, are obtained from a uniform distribution bounded by 0.1 and 5. 
</p>
<p>The abundance at the mode of the curve is determined by random values otained from log-normal distribution with log(mean) <code>am</code> and  sd=1 (the last one not available as argument). 
</p>
<p>The position of the modal point in the gradient (parameter m, not available as argument) will depend on the value of <code>clump</code>. If <code>clump</code>=1 coordinates of the modal points are obtained from a random uniform distribution. For higher values of <code>clump</code>, species modal points will tend to be concentrated on high values of the gradient. In all cases, coordinates are bounded by -50 and +150. For a studied gradient bounded by 0 and 100, the specification of a larger interval allows the position of the modal point to be located outside the gradient. 
</p>
<p>The parameter <code>beta.R</code> determines the range of occurrence of species in the gradient. In terms of diversity, it determines the turnover (beta diversity) along the gradient, and is expressed as <code>beta.R</code> = 100/mean(r), and r are the ranges of species. Values of r are obtained from a normal distribution with mean 100/<code>beta.R</code> and standard deviation of 0.3*100/<code>beta.R</code> (the last one not available as argument). A <code>beta.R</code> = 2 determines that range of species are, on average, 50 units of the gradient (and 15 SD units). High <code>beta.R</code> determines restricted ranges and, thus, high beta diversity. Old versions of this function included the argument &quot;beta&quot; and expressed, contrary to the name of the argument, as range in the gradient. The code of the new function is equivalent to the old ones (beta=0.5 was translated as 0.5*100 and determined ranges around 50; this can be attained now as <code>beta.R</code>=2 which determines ranges 100/2=50). 
</p>
<p>Species may be (i) present in densities different from the expected or (ii) absent due to sampling error, historical factors, or the influence of a multitude of environmental factors. Simulated communities are subject to these two types of error or noise to mimic the two phenomena. In order to obtain scattered values of abundances for each species along their gradients, each non-zero value is replaced by a random value obtained from a Negative Binomial distribution (<code><a href="stats.html#topic+rnbinom">rnbinom</a></code>) with mean equal to the value to be replaced and variance proportional to <code>n.quanti</code>. The parametrization of the Negative Binomial is done using mu (mean) and size (dispersion parameter), the later obtained as mu^2 / (variance-mu). The <code>n.quanti</code> is used to define the variance as mu*(1+<code>n.quanti</code>). For <code>n.quanti</code> tending to zero the distribution is similar to the Poisson. For values up to 1 it is still similar to the Poisson. For <code>n.quanti</code> &gt;5  it is quite distinct with long right-hand tails and many zeros if the mean is low (e.g. &lt;10). Additional absences are achieved by randomly choosing <code>n.quali</code>*100% of non-zero values and replacing them by zeros. 
</p>
<p>A third characteristic commonly seen in field datasets is the occurrence of a species outside its regular range or in different habitats. These species are termed vagrant or marginal, and usually appear in the dataset with 1 individual. In order to account for this common finding, the function attaches to the simulated community an additional set of species with 1 individual, each species occurring in one sample unit only. The number of these additional species is set as <code>add1</code>*100% of the number of species sampled in the simulated communities after the inclusion of the two types of errors cited above.
</p>


<h3>Value</h3>

<p>A dataframe of sites (rows) by species (cols) abundances. In case of <code>dims</code>=1, a plot of response species curves is produced. These curves do not include quantitative noise (<code>n.quanti</code>), qualitative noise (<code>n.quali</code>) (see comments above) and 'marginalor vagrant species' (<code>add1</code>) additions. Notice that the number of species in the result dataframe may vary as (i) some species may not be sampled by <code>coords</code>, or (ii) species range is located outside the sampling gradient (0-100).
</p>


<h3>Note</h3>

<p>As the function includes many parameters, many simulated communities will not mimic the real ones. Users should try different set of options to approxiamte real datasets. A starting point may be the examples provided below.
</p>


<h3>Author(s)</h3>

<p>Adriano Sanches Melo</p>


<h3>References</h3>

<p>McGill, B. &amp; C. Collins. 2003. A unified theory for macroecology based on spatial patterns of abundance. Evolutionary Ecology Research 5: 469-492.
</p>
<p>Minchin, P.R. 1987a. Simulation of multidimensional community patterns: towards a comprehensive model. Vegetatio 71: 145-156.
</p>
<p>Minchin, P.R. 1987b. COMPAS: a program for the simulation of multidimensional community patterns based on generalized beta functions. Dep. of Biological Sciences, Southern Illinois University Edwardsville, USA.
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+vegdist">vegdist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># 1 dimension.
coo &lt;- seq(10, 90, 10)
compas(S=30, dims=1, am=2, beta.R=2, coords=coo, 
       n.quanti=5,  n.quali=0.1, add1=0.1)
	
# 2 dimensions.
coo2 &lt;- cbind(coo, coo)
compas(S=50, dims=2, am=c(2,2), beta.R=c(1,1), coords=coo2, 
       n.quanti=5, n.quali=0.1, add1=0.1)

# 2 dimensions. Homogeneous and clumped species distributions.
# Try a few times.
coo.grid &lt;- expand.grid(seq(10,90,10), seq(10,90,10))
plot(coo.grid, xlim=c(0,100), ylim=c(0,100))

mat1 &lt;- compas(S=60, dims=2, am=c(2,2), clump=1, beta.R=c(2,2), coords=coo.grid,
               n.quanti=5, n.quali=0.1, add1=0.1)
S1 &lt;- rowSums(ifelse(mat1&gt;0,1,0))

mat2 &lt;- compas(S=60, dims=2, am=c(2,2), clump=3, 
               beta.R=c(2,2), coords=coo.grid, n.quanti=5, n.quali=0.1, add1=0.1)
S2 &lt;- rowSums(ifelse(mat2&gt;0,1,0))

ind &lt;- coo.grid/10
S1.mat &lt;- matrix(NA, 9, 9)
S2.mat &lt;- matrix(NA, 9, 9)
for(i in 1:length(S1)){
      S1.mat[ind[i,1], ind[i,2]] &lt;- S1[i] 
      S2.mat[ind[i,1], ind[i,2]] &lt;- S2[i] 
   }

plot(coo.grid, cex=S1/4)
plot(coo.grid, cex=S2/4)

image(x=coo, y=coo, z=S1.mat, col=gray(50:1/50))
image(x=coo, y=coo, z=S2.mat, col=gray(50:1/50))

filled.contour(x=coo, y=coo, z=S1.mat)
filled.contour(x=coo, y=coo, z=S2.mat)
</code></pre>

<hr>
<h2 id='dis.chao'>Chao et al. dissimilarity indices</h2><span id='topic+dis.chao'></span>

<h3>Description</h3>

<p>Dissimilarity indices proposed by Chao et al. (2005) that takes into account (rare) unseen shared species. This is done mostly by heavy-weighting shared rare species. The function handle abundance or frequency data and are available for the Jaccard and Sorensen family of indices. Probability versions of the index, that does not heavy-weight rare species, are also included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dis.chao(comm, index="jaccard", version="rare", freq=NULL)
 </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dis.chao_+3A_comm">comm</code></td>
<td>
<p>Dataframe or matrix with samples in rows and species in columns.</p>
</td></tr>
<tr><td><code id="dis.chao_+3A_index">index</code></td>
<td>
<p>The index formula to be used in Chao dissimilarity. Partial match to &quot;jaccard&quot; or &quot;sorensen&quot;.</p>
</td></tr>
<tr><td><code id="dis.chao_+3A_version">version</code></td>
<td>
<p>The uncorrected probability version of the Chao index or the corrected version that takes into account unseen rare species. Partial match to &quot;probability&quot; or &quot;rare&quot;.</p>
</td></tr>
<tr><td><code id="dis.chao_+3A_freq">freq</code></td>
<td>
<p>A numeric vector indicating total number of sampling units composing each sample (row) of the community data for computing incidence-based Chao indices. Length of <code>freq</code> must be the same as the number of samples in <code>comm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Communities usually are composed of many rare and only a few common/frequent species. Although rare, a species may provide a valuable information in the estimation of resemblance between samples. However, the use of raw abundances makes the contribution of rare species to be negligible to the resulting index value. For instance, dropping a common species from the community data table usually will make much larger differences in the dissimilarity matrix than dropping a rare species.
</p>
<p>There are a few indices that give more importance to an individual belonging to a rare than to a common/frequent species (see <code><a href="#topic+dis.goodall">dis.goodall</a></code> and <code><a href="#topic+dis.nness">dis.nness</a></code>). Notice, however, that this differential weight of species can also be obtained, for instance, by log-transforming or standardizing data (e.g. dividing by maximum within each species) (Melo, in preparation). In this sense, an extreme case in which rare and common species have the same weight is in the use of presence/absence data.
</p>
<p>The &quot;probability&quot; version of the abundance-based Chao-Jaccard and Chao-Sorensen indices are distinct from those traditional formulae available, for instance, in <code><a href="vegan.html#topic+vegdist">vegdist</a></code> (Chao et al. 2005). These probability indices do not overweight rare species and are included here for comparability. The version that takes into account unseeen rare species simplifies to the probability version if no rare species (singleton or doubleton for abundance data; unique or duplicate for incidence data) is present (see example below).  
</p>


<h3>Value</h3>

<p>A &quot;dist&quot; object.
</p>


<h3>Author(s)</h3>

<p>Adriano Sanches Melo</p>


<h3>References</h3>

<p>Chao, A., R.L. Chazdon, R.K. Colwell &amp; T. Shen. 2005. A new statistical approach for assessing similarity of species composition with incidence and abundance data. Ecology Letters 8: 148-159.
</p>
<p>Melo, A.S. in preparation. Is it possible to improve recovery of multivariate groups by weighting rare species in similarity indices?
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+vegdist">vegdist</a></code>, <code><a href="#topic+dis.goodall">dis.goodall</a></code>, <code><a href="#topic+dis.nness">dis.nness</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
### Example 1: Rare species are heavier:
aa &lt;- c(1, 2, 4, 5)
bb &lt;- c(1, 2, 0, 5)
cc &lt;- c(0, 2, 3, 3)
dat3 &lt;- rbind(aa, bb, cc) 
colnames(dat3) &lt;- c("sp1", "sp2", "sp3", "sp4")
dat3

vegdist(dat3, method='jaccard', binary=FALSE) 
# Notice dissimilarity between the pair aa-bb is the same of the pair aa-cc. 
# In fact, bb and cc differ from aa in the same way (one species, and 
# 4 exclusive individuals).

dis.chao(dat3, index="jaccard", version="prob") 
# The probability version of the Chao index, however, produce different 
# dissimilarities for the pairs aa-bb and aa-cc 
# (aa-cc is less dissimilar than aa-bb).

dis.chao(dat3, index="jaccard", version="rare")
# The dissimilarity for the pair aa-cc is the same as that obtained using the 
# probability version. However, the dissimilarity for the pair aa-bb decreased.
# The reason is that aa-bb shares two rare species (sp1, sp2), 
# whereas the pair aa-cc shares a single rare species (sp2). 


### Example 2: "rare" version of the Chao index simplifies to the 
# "probability" version if no rare species (with 1 or 2 individuals) is present.
data(japi)
dim(japi) 
# 75 sampling units (stones) and 66 morphospecies of stream macroinvertebrates.
japi.m &lt;- as.matrix(japi)
japi.2 &lt;- ifelse(japi.m==1, 3, japi.m) 
# no singletons.
japi.3 &lt;- ifelse(japi.2==2, 3, japi.2) 
# no doubletons.

sort(
     dis.chao(japi.3, index='jac', version='rare')  
   - dis.chao(japi.3, index='jac', version='prob'))


### Example 3: frequency data
# Stones in the japi dataset were sampled from downstream to upstream direction.
# Consecutive stones are spaced 1-6 m. The set of the first 25 stones should be
# more dissimilar to the last set of 25 stones than the middle set 
# (simply because of spatial autocorrelation).
japi.pa &lt;- ifelse(japi.m &gt; 0, 1, 0) 
japi.1st &lt;- japi.pa[ 1:25, ]
japi.2nd &lt;- japi.pa[26:50, ]
japi.3rd &lt;- japi.pa[51:75, ]

japi.inc &lt;- rbind(
                 colSums(japi.1st),
                 colSums(japi.2nd),
                 colSums(japi.3rd)
) 
# species frequency of occurrence in the three sets of stones.

dis.chao(japi.inc, index="jaccard", freq=c(25, 25, 25) )
</code></pre>

<hr>
<h2 id='dis.goodall'>Goodall dissimilarity index</h2><span id='topic+dis.goodall'></span>

<h3>Description</h3>

<p>This is a probability index in which rare species (or descriptors) are overweighted. Accordingly, sharing rare species makes pairs of samples (or objects) more similar than sharing common/frequent species (or descriptors). As Legendre &amp; Legendre (1998) put it when describing this index: &quot;... it is less likely for two sites to both contain the same rare species than a more frequent species. In this sense, agreement for a rare species should be given more importance than for a frequent species, when estimating the similarity between sites.&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dis.goodall(comm, p.simi="steinhaus", approach="proportion")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dis.goodall_+3A_comm">comm</code></td>
<td>
<p>Dataframe or matrix with samples in rows and species in columns.</p>
</td></tr>
<tr><td><code id="dis.goodall_+3A_p.simi">p.simi</code></td>
<td>
<p>The partial similarity index to be used in the Goodall index. Partial match to &quot;steinhaus&quot; (raw abundance data), or &quot;gower&quot; (normalized abundance data).</p>
</td></tr>
<tr><td><code id="dis.goodall_+3A_approach">approach</code></td>
<td>
<p>The two approaches to compute Goodall index. Partial match to &quot;proportion&quot; or &quot;chisquare&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Communities are usually composed of many rare and only a few common/frequent species. Although rare, a species may provide a valuable information in the estimation of resemblance between samples. However, the use of raw abundances makes the contribution of rare species to be negligible to the resulting index value. For instance, dropping a common species from the community data table usually will make much larger differences in the dissimilarity matrix than dropping a rare species.
</p>
<p>There are a few indices that give more importance to an individual belonging to a rare than to a common/frequent species (see <code><a href="#topic+dis.chao">dis.chao</a></code> and <code><a href="#topic+dis.nness">dis.nness</a></code>). Notice, however, that this differential weight of species can also be obtained, for instance, by log-transforming or standardizing data (e.g. dividing by maximum within each species) (Melo in preparation). In this sense, an extreme case in which rare and common species have the same weight is in the use of presence/absence data.
</p>
<p>The implementation of Goodall index (Goodall 1966) follows Legendre &amp; Legendre (1998, pp. 269-273). They suggest to use the &quot;steinhaus&quot; index for raw species abundance data and the &quot;gower&quot; partial similarity index (<code>p.simi</code>) for normalized data. The index can be calculated in two ways or approaches (&quot;proportion&quot; or &quot;chisquare&quot;) and values produced by them should be very different, although this is mostly due to scale; they are monotonically correlated. Notice Legendre &amp; Legendre (1998) present a similarity version of this index. The one produced by this function is a dissimilarity, computed simply as 1-similarity. See the examples below for some behaviors of the index.
</p>
<p>One important issue made clear by Legendre &amp; Legendre (1998, pp. 270-271) is that the dissimilarity value for a pair of sites depnds on other sites present in the data matrix. If changes are made to some sites, the resulting dissimilarity values for all remaining pairs are modified (see example below).
</p>


<h3>Value</h3>

<p>A &quot;dist&quot; object.
</p>


<h3>Author(s)</h3>

<p>Adriano Sanches Melo</p>


<h3>References</h3>

<p>Goodall, D.W. 1966. A new similarity index based on probability. Biometrics 22: 882-907.
</p>
<p>Legendre, P &amp; L. Legendre. 1998. Numerical Ecology. 2nd ed. Elsevier. 
</p>
<p>Melo, A.S. (in preparation) Is it possible to improve recovery of multivariate groups by weighting rare species in similarity indices? 
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+vegdist">vegdist</a></code>, <code><a href="#topic+dis.chao">dis.chao</a></code>, <code><a href="#topic+dis.nness">dis.nness</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
a &lt;- c(1, 1, 0)
b &lt;- c(2, 1, 0)
c &lt;- c(0, 1, 1)
d &lt;- c(0, 1, 2)
e &lt;- c(0, 1, 3)
dat5 &lt;- rbind(a,b,c,d,e)
colnames(dat5) &lt;- c("sp1","sp2","sp3")
dat5

# Notice the samples in the pair a-b differ from each other exactly in the same
# way as samples in the pair c-d. However, a-b shares a rare species (sp1), 
# whereas c-d shares a frequent species (sp3, which is also present in e). Thus,
# the dissimilarity a-b is the same of c-d using Bray-Curtis, but not using 
# Goodall index:
vegdist(dat5, "bray")
dis.goodall(dat5)

# As the importance of a species for the Goodall index depends on its overall
# frequency in the community data, the deletion of a sample changes results:
dis.goodall(dat5[-5,])
</code></pre>

<hr>
<h2 id='dis.nness'>NNESS and NESS dissimilarity indices</h2><span id='topic+dis.nness'></span><span id='topic+dis.nness.find.m'></span>

<h3>Description</h3>

<p>These dissimilarities indices overweight rare species to a desired degree. If rare species are heavy-weighthed, individuals of a rare species are more important than individuals of a common species. In the extreme, a species represented by a single individual will have the same weight of a common species, which is equivalent to the use of presence-absence data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dis.nness(comm, m=NULL, ness=FALSE)
  dis.nness.find.m(comm, ness=FALSE)
  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dis.nness_+3A_comm">comm</code></td>
<td>
<p>Dataframe or matrix with samples in rows and species in columns.</p>
</td></tr>
<tr><td><code id="dis.nness_+3A_m">m</code></td>
<td>
<p>The number of individuals to be sampled in the estimation of species shared in NNESS and NESS indices. <code>m</code> must be an integer and lower than half (NESS) or the total (NNESS) abundance of the smallest sample in the pair under comparison. Higher <code>m</code> gives more importance to rare species. If no value is provided, the function will use <code>dis.nness.find.m</code> to find a value that is sensitive to both rare and abundant species (see Details below).</p>
</td></tr>
<tr><td><code id="dis.nness_+3A_ness">ness</code></td>
<td>
<p>Compute NESS index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Communities usually are composed of many rare and only a few common/frequent species. Although rare, a species may provide a valuable information in the estimation of resemblance between samples. However, the use of raw abundances makes the contribution of rare species to be negligible to the resulting index value. For instance, dropping a common species from the community data table usually will make much larger differences in the dissimilarity matrix than dropping a rare species.
</p>
<p>There are a few indices that give more importance to an individual belonging to a rare than to a common/frequent species (see <code><a href="#topic+dis.chao">dis.chao</a></code> and <code><a href="#topic+dis.goodall">dis.goodall</a></code>). Notice, however, that this differential weight of species can also be obtained, for instance, by log-transforming or standardizing data (e.g. dividing by maximum within each species) (Melo, in preparation). In this sense, an extreme case in which rare and common species have the same weight is in the use of presence/absence data.
</p>
<p>NNESS is a modified or New version of the Normalized Expected Species Shared (NESS). NESS was proposed by Grassle &amp; Smith (1976) and estimates similarity based on the number of species shared between random samples of size <code>m</code> individuals. Higher <code>m</code> gives more weight to rare species. For <code>m</code> = 1, NESS is the same as Morisita and NNESS is the same as Morisita-Horn dissimilarities. As higher values of <code>m</code> are used, dissimilarities tend to converge to presence-absence Sorensen index (when a rare and a common species have the same weight). NNESS was proposed by Trueblood et al. (1994) and circumvents the inability of NESS to handle samples composed exclusively by singletons (species with 1 individual).
</p>
<p>Trueblood et al. (1994) also suggested to use an <code>m</code> value that is sensitive to both rare and abundant species. The NESS or NNESS index is calculated using values of <code>m</code> ranging from 1 up to half (NESS) or the total (NNESS) number of individuals in the smallest sample. The Kendall correlation is then calculated for each pair of triangular dissimilarity matrices. The selected <code>m</code> value is the one which produces a correlation with the matrix obtained with <code>m</code> = 1 that is most similar to the correlation with <code>m</code> = max, where max is the maximum value <code>m</code> may assume (abundance of the smallest sample for NNESS or half of that abundance for NESS). As this procedure may be slow for large datasets, up to 30 <code>m</code> values are used to compute dissimilarity matrices. NESS and NNESS are most suitable for raw abundance data and, thus, to data expressed as integers. This implementation, however, will work on non-integer data. NESS and NNESS formulae are for similarities and are computed here simply as 1-similarity. 
</p>
<p>The calculation of NESS and NNESS involves the use of binomial coefficients. For samples with many individuals (e.g. 1100) and high <code>m</code> values (e.g. 490), the resulting value is too large to be stored as double precision. Accordingly, this function uses the <code><a href="gmp.html#topic+chooseZ">chooseZ</a></code> of the Multiple Precision Arithmetic package when total abundance of at least one sample contains more than 1000 individuals. If no sample contains more than 1000 individuals, computations are performed using the simpler <code><a href="base.html#topic+choose">choose</a></code>.
</p>
<p>NESS and NNESS are most suitable to abundance data. However, <code><a href="base.html#topic+choose">choose</a></code> is able to handle positive non-integers and calculations will be done accordingly. However, <code><a href="gmp.html#topic+chooseZ">chooseZ</a></code> is not able to handle non-integers and, thus, for datasets in which at least one sample contains more than 1000 individuals, non-integer abundances will be rounded up to next upper integer.   
</p>


<h3>Value</h3>

<p>A &quot;dist&quot; object for <code>dis.nness</code> and a integer for <code>dis.nness.find.m</code>.
</p>


<h3>Author(s)</h3>

<p>Adriano Sanches Melo</p>


<h3>References</h3>

<p>Grassle, J.F. &amp; W. Smith. 1976. A similarity measure sensitive to the contribution of rare species and its use in investigation of variation in marine benthic communities. Oecologia 25: 13-22.
</p>
<p>Melo, A.S. Submitted. Is it possible to improve recovery of multivariate groups by weighting rare species in similarity indices?
</p>
<p>Trueblood, D.D., E.D. Gallagher &amp; D.M.Gould. Three stages of seasonal succession on the Savin Hill Cove mudflat, Boston Harbor. Limnology and Oceanography 39: 1440-1454.
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+vegdist">vegdist</a></code>, <code><a href="#topic+dis.chao">dis.chao</a></code>, <code><a href="#topic+dis.goodall">dis.goodall</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
aa &lt;- c(1, 2, 4, 5)
bb &lt;- c(1, 2, 0, 5)
cc &lt;- c(0, 2, 3, 3)
dat3 &lt;- rbind(aa, bb, cc) 
colnames(dat3) &lt;- c("sp1", "sp2", "sp3", "sp4")
dat3

#  NESS using m=1 is the same as Morisita and
# NNESS using m=1 is the same as Morisita-Horn:
dis.nness(dat3, m=1, ness=TRUE)
vegdist(dat3, method="morisita")

dis.nness(dat3, m=1, ness=FALSE)
vegdist(dat3, method="horn")

# The dissimilarity for the pair aa-bb is reduced if more weight is given to 
# rare species (higher m). The reason is that aa-bb shares two rare 
# species (sp1, sp2), whereas the pair aa-cc shares a single rare species (sp2). 
dis.nness(dat3, m=1, ness=FALSE)
dis.nness(dat3, m=8, ness=FALSE)
</code></pre>

<hr>
<h2 id='japi'>Macroinvertebrate morphospecies living on stones of a stream in southeast Brazil</h2><span id='topic+japi'></span>

<h3>Description</h3>

<p>Abundance data of 66 macroinvertebrate morphospecies (columns) living on 75 stones (rows) of a stream in southeast Brazil. Stones were around 20 cm diameter and were sampled from downstream (pedra1) to upstream (pedra75) direction. Consecutive stones are spaced 1-6 m. Details can be found in Melo &amp; Froehlich (2001).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(japi)</code></pre>


<h3>Format</h3>

<p>A data frame with 75 observations (stones) on 66 variables (morphospecies).</p>


<h3>References</h3>

<p>Melo, A.S. &amp; C.G. Froehlich. 2001.Evaluation of methods for estimating macroinvertebrate species richness using individual stones in tropical streams. Freshwater Biology 46: 711-721.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(japi)
japi
</code></pre>

<hr>
<h2 id='part.m.tree'>Partition of multi-sample dissimilarity indices using phylogenetic/functional data</h2><span id='topic+part.m.tree'></span>

<h3>Description</h3>

<p>This function computes the partition of multi-sample Sorensen and Jaccard dissimilarity indices described by Baselga (2012), but adapted for phylogenetic/functional data. The two resulting components are dissimilarities due to turnover and nestednes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>part.m.tree(comm, tree, index.family="sorensen")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part.m.tree_+3A_comm">comm</code></td>
<td>
<p>Dataframe or matrix with samples in rows and species in columns.</p>
</td></tr>
<tr><td><code id="part.m.tree_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic/functional tree containing all species listed in <code>comm</code></p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code id="part.m.tree_+3A_index.family">index.family</code></td>
<td>
<p>The family of dissimilarity indices to be partitionated. Partial match to &quot;sorensen&quot; or &quot;jaccard&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the number of samples and three dissimilarity values. The nomenclature of the dissimilarities follows Baselga (2012). 
For the jaccard:
</p>
<table role = "presentation">
<tr><td><code>JAC</code></td>
<td>
<p>Multi-sample Jaccard dissimilarity index.</p>
</td></tr>
<tr><td><code>JTU</code></td>
<td>
<p>The turnover component of the Jaccard index.</p>
</td></tr>
<tr><td><code>JNE</code></td>
<td>
<p>The nestedness component of the Jaccard index.</p>
</td></tr> 
</table>
<p>For the sorensen:
</p>
<table role = "presentation">
<tr><td><code>SOR</code></td>
<td>
<p>Multi-sample Sorensen dissimilarity index.</p>
</td></tr>
<tr><td><code>SIM</code></td>
<td>
<p>The turnover component of the Sorensen index (Simpson index).</p>
</td></tr>
<tr><td><code>SNE</code></td>
<td>
<p>The nestedness component of the Sorensen index.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adriano Sanches Melo, but part of the code borrowed from <code><a href="betapart.html#topic+beta.multi">beta.multi</a></code> (package betapart) and <code><a href="picante.html#topic+phylosor">phylosor</a></code> (package picante)</p>


<h3>References</h3>

<p>Baselga, A. 2010. Partitioning the turnover and nestdness components of beta diversity. Global Ecology and Biogeography 19, 134-143.
</p>
<p>Baselga, A. 2012. The relationship between species replacement, dissimilarity derived from nestedness and nestedness. Global Ecology and Biogeography 21, 1223-1232.
</p>
<p>Leprieur, F., C. Albouy, J.D. Bortoli, P.F. Cowman, D.R. Bellwood and D. Mouillot. 2012. Quantifying phylogenetic beta diversity: distinguishing between 'true' turnover of lineages and phylogenetic diversity gradients. PLoS ONE 7(8), e42760. doi:10.1371/journal.pone.0042760
</p>


<h3>See Also</h3>

<p><code><a href="#topic+part.p.tree">part.p.tree</a></code> for pair-wise partitions.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(picante)
data(sites4.6)
data(tree6)
part.m.tree(comm=sites4.6, tree=tree6, index.family="sorensen")
</code></pre>

<hr>
<h2 id='part.p.tree'>Partition of pair-wise dissimilarity indices using phylogenetic/functional data</h2><span id='topic+part.p.tree'></span>

<h3>Description</h3>

<p>This function computes the partition of pair-wise Sorensen and Jaccard dissimilarity indices described by Baselga (2011, 2012), but adapted for phylogenetic/functional data. The two resulting components are dissimilarities due to turnover and nestednes</p>


<h3>Usage</h3>

<pre><code class='language-R'>part.p.tree(comm, tree, index.family = "sorensen")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part.p.tree_+3A_comm">comm</code></td>
<td>
<p>Dataframe or matrix with samples in rows and species in columns.</p>
</td></tr>
<tr><td><code id="part.p.tree_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic/functional tree containing all species listed in <code>comm</code>.</p>
</td></tr>
<tr><td><code id="part.p.tree_+3A_index.family">index.family</code></td>
<td>
<p>The family of dissimilarity indices to be partitionated. Partial match to &quot;sorensen&quot; or &quot;jaccard&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including three dissimilarity matrices. The nomenclature of the matrices follows Baselga (2012). 
For the jaccard:
</p>
<table role = "presentation">
<tr><td><code>jac</code></td>
<td>
<p>Jaccard dissimilarity matrix.</p>
</td></tr>
<tr><td><code>jtu</code></td>
<td>
<p>The turnover component of the Jaccard index.</p>
</td></tr>
<tr><td><code>jne</code></td>
<td>
<p>The nestedness (or richness difference) component of the Jaccard index.</p>
</td></tr> 
</table>
<p>For the sorensen:
</p>
<table role = "presentation">
<tr><td><code>sor</code></td>
<td>
<p>Sorensen dissimilarity matrix.</p>
</td></tr>
<tr><td><code>sim</code></td>
<td>
<p>The turnover component of the Sorensen index (Simpson index).</p>
</td></tr>
<tr><td><code>sne</code></td>
<td>
<p>The nestedness (or richness difference) component of the Sorensen index.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adriano Sanches Melo, with part of the code borrowed from <code><a href="picante.html#topic+phylosor">phylosor</a></code> (package picante).</p>


<h3>References</h3>

<p>Baselga, A. 2010. Partitioning the turnover and nestdness components of beta diversity. Global Ecology and Biogeography 19, 134-143.
</p>
<p>Baselga, A. 2012. The relationship between species replacement, dissimilarity derived from nestedness and nestedness. Global Ecology and Biogeography 21, 1223-1232.
</p>
<p>Leprieur, F., C. Albouy, J.D. Bortoli, P.F. Cowman, D.R. Bellwood and D. Mouillot. 2012. Quantifying phylogenetic beta diversity: distinguishing between 'true' turnover of lineages and phylogenetic diversity gradients. PLoS ONE 7(8), e42760. doi:10.1371/journal.pone.0042760
</p>


<h3>See Also</h3>

<p><code><a href="#topic+part.m.tree">part.m.tree</a></code> for multi-sample partitions.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(picante)
data(sites4.6)
data(tree6)
part.p.tree(comm=sites4.6, tree=tree6, index.family="sorensen")
</code></pre>

<hr>
<h2 id='select.window'>Select cells inside a defined window of a gridded dataset</h2><span id='topic+select.window'></span>

<h3>Description</h3>

<p>Selection of cells (or sites) around a focal cell. Cells must have have xy coordinates. Users should define a 'radius' from the focal cell that will define the window</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.window(xf, yf, radius = 1, xydata)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select.window_+3A_xf">xf</code></td>
<td>
<p>The x-coordinate of the focal cell.</p>
</td></tr>
<tr><td><code id="select.window_+3A_yf">yf</code></td>
<td>
<p>The y-coordinate of the focal cell.</p>
</td></tr>
<tr><td><code id="select.window_+3A_radius">radius</code></td>
<td>
<p>The radius that define the window to select neighbor cells.</p>
</td></tr>
<tr><td><code id="select.window_+3A_xydata">xydata</code></td>
<td>
<p>A matrix-like object. The first and second columns of data must have x and y coordinates, respectively. The remaining columns must contain species or other atributes to be selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is intended to be used in gridded data, but should work on sites irregularly scattered in the xy-space.</p>


<h3>Value</h3>

<p>A matrix-like object in which the first and second columns are the x and y coordinates. The remaining columns includes species (or attributes) observed in the selected cells.</p>


<h3>Author(s)</h3>

<p>Adriano Sanches Melo</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rep(1:5,each=5)
y &lt;- rep(1:5,5)
spp &lt;- matrix(1:100,25,4)
colnames(spp) &lt;- c("sp1","sp2","sp3","sp4")
xyspp &lt;- cbind(x,y,spp)
resu &lt;- select.window(xf=3, yf=3, radius=1.1, xydata=xyspp)
resu

plot(x,y) 
# maintain the plot window open.
points(resu[,1:2],col=2,cex=2 ) 
# cells of the selected window in red.

# A reduced number of cells will be selected for focal cells located in margins.
resu &lt;- select.window(xf=5, yf=5, radius=1.1, xydata=xyspp)
plot(x,y) 
# maintain the plot window open.
points(resu[,1:2],col=2,cex=2 ) 
# cells of the selected window in red.

# Unrecorded species in the selected window are removed from resulting 
#  dataframe (or matrix):
spp&lt;-matrix(rep(0:1,each=50),25,4)
colnames(spp)&lt;-c("sp1","sp2","sp3","sp4")
xyspp&lt;-cbind(x,y,spp)
select.window(xf=3, yf=3, radius=1.1, xydata=xyspp)
</code></pre>

<hr>
<h2 id='sites4.6'>Artificial dataset containing 4 samples [rows] and 6 species[columns].</h2><span id='topic+sites4.6'></span>

<h3>Description</h3>

<p>Artificial dataset containing 4 samples [rows] and 6 species[columns].</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sites4.6)</code></pre>


<h3>Format</h3>

<p>A data frame with 4 observations on the following 6 variables.
</p>

<dl>
<dt><code>taxon_1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_6</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(sites4.6)
sites4.6
</code></pre>

<hr>
<h2 id='sites5.6'>Artificial dataset containing 5 samples [rows] and 6 species[columns].</h2><span id='topic+sites5.6'></span>

<h3>Description</h3>

<p>Artificial dataset containing 5 samples [rows] and 6 species[columns].</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sites5.6)</code></pre>


<h3>Format</h3>

<p>A data frame with 5 observations on the following 6 variables.
</p>

<dl>
<dt><code>taxon_1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_6</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(sites5.6)
sites5.6
</code></pre>

<hr>
<h2 id='sites6.6'>Artificial dataset containing 6 samples [rows] and 6 species[columns].</h2><span id='topic+sites6.6'></span>

<h3>Description</h3>

<p>Artificial dataset containing 6 samples [rows] and 6 species[columns].</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sites6.6)</code></pre>


<h3>Format</h3>

<p>A data frame with 6 observations on the following 6 variables.
</p>

<dl>
<dt><code>taxon_1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>taxon_6</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(sites6.6)
sites6.6
</code></pre>

<hr>
<h2 id='stairs6'>Example of phylogenetic tree containing 6 species.</h2><span id='topic+stairs6'></span>

<h3>Description</h3>

<p>Example of phylogenetic tree containing 6 species</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stairs6)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 5
$ edge       : int [1:10, 1:2] 7 8 9 10 11 11 10 9 8 7 ...
$ Nnode      : int 5
$ tip.label  : chr [1:6] &quot;taxon_1&quot; &quot;taxon_2&quot; &quot;taxon_3&quot; &quot;taxon_4&quot; ...
$ edge.length: num [1:10] 1 1 1 1 1 1 2 3 4 5
$ root.edge  : num 1
- attr(*, &quot;class&quot;)= chr &quot;phylo&quot;
- attr(*, &quot;order&quot;)= chr &quot;cladewise&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stairs6)
plot(stairs6)
</code></pre>

<hr>
<h2 id='standExtent'>Standardization of spatial extent for two metacommunities by subsampling</h2><span id='topic+standExtent'></span>

<h3>Description</h3>

<p>Communities far from each other tend to differ more than those nearby. Accordingly, spatial extent usually affects species richness and other metacommunity properties. Comparison between two metacommunities may be biased if spatial extent differs. One potential solution is to standardize spatial extent by subsampling of the metacommunity more spread in space.</p>


<h3>Usage</h3>

<pre><code class='language-R'>standExtent(d.large, d.small, ini.large=NULL, ini.small=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standExtent_+3A_d.large">d.large</code></td>
<td>
<p>A square (symmetrical) or triangular distance matrix of the metacommunity with large spatial extent.</p>
</td></tr>
<tr><td><code id="standExtent_+3A_d.small">d.small</code></td>
<td>
<p>A square (symmetrical) or triangular distance matrix of the metacommunity with small spatial extent.</p>
</td></tr>
<tr><td><code id="standExtent_+3A_ini.large">ini.large</code></td>
<td>
<p>The first community to be used in the agregation process of the metacommunity with large spatial extent. Make sure it is present in <code>d.large</code>. If absent, a random  site will be used.</p>
</td></tr>
<tr><td><code id="standExtent_+3A_ini.small">ini.small</code></td>
<td>
<p>The first community to be used in the agregation process of the metacommunity with small spatial extent. Make sure it is present in <code>d.small</code>. If absent, a random  site will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standardized of spatial extent is done by selecting the same number of sites in both metacommunities using the criterion that within-metacommunity average distance among sites is similar. 
</p>
<p>The procedure consists of: 1) selection of a focal site <code>ini.large</code> in the  metacommunity more spread in space, 2) selection of a second site that is nearest to the focal one, 3) selection of a third site using the criterion of minimal average distance among them, 4) repeat step 3 until all sites are included. The procedure then 5) selects a focal site <code>ini.small</code> in the metacommunity less spread in space, 6) selects a second site in the metacommunity less spread in space using the criterion of the distance between the focal site and this second one is the most similar to the distance in step 2 above, 7) selects a third site using the criterion that the distance among the three sites is most similar to the average distance in step 3 above, and 8) repeats step 7 until all sites in the less spread metacommunity are included.
</p>
<p>Notice that after some sites are accumulated, the difference between the average distances in the two sets of metacommunities will increase abruptly. This will occur when most sites in the periphery of the less spread metacommunity are included.
</p>
<p>Users may specify initial sites in the accumulation process (steps 1 and 5 above). If not specified, randomly selected sites will be used.
</p>
<p>The percentage of difference of the two spatial extents is provided in the form: (d.mean.large - d.mean.small)/d.mean.large, where d.mean.large and d.mean.small are, respectively, the average within-metacommunity distances of the more and less spread metacommunities. This difference may be helpful to decide for the number and identity of sites to be used.
</p>


<h3>Value</h3>

<p>A dataframe containing the names of the accumulated sites in both metacommunities, their within-metacommunity average distances and the percentage of difference in spatial extents.
</p>


<h3>Author(s)</h3>

<p>Adriano Sanches Melo</p>


<h3>References</h3>

<p>Heino, J., A.S. Melo, J. Jyrkankallio-Mikkola, D.K. Petsch, V.Sa. Saito, K.T. Tolonen, L.M. Bini, T.S.F. Silva, V. Pajunen, J. Soininen &amp; T. Siqueira. (in preparation) Higher richness but lower abundance of stream insects in tropical than boreal regions hold at regional, basin and local scales.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Data
large.lat &lt;- seq(2, 16, 2)
large.lon &lt;- seq(2, 16, 2)
large.coo &lt;- expand.grid(large.lon, large.lat)
large.coo[, 1] &lt;- large.coo[, 1] + rnorm(64, sd=0.4)
large.coo[, 2] &lt;- large.coo[, 2] + rnorm(64, sd=0.4)
rownames(large.coo) &lt;- as.character(paste("large", 1:64, sep=""))
large.distances &lt;- dist(large.coo) 

small.lat &lt;- 1:8 
# Notice the spatial extent here is much smaller than that of 
#  the "large" set above.
small.lon &lt;- 1:8
small.coo &lt;- expand.grid(small.lon, small.lat)
small.coo[, 1] &lt;- small.coo[, 1] + rnorm(64, sd=0.4)
small.coo[, 2] &lt;- small.coo[, 2] + rnorm(64, sd=0.4)
rownames(small.coo) &lt;- as.character(paste("small", 1:64, sep=""))
small.distances &lt;- dist(small.coo) 

### Example 1 - Graphical demonstration of the subsampling process.
resu &lt;- standExtent(d.large = large.distances, d.small=small.distances,
                    ini.large="large52", ini.small="small45")
                    
plot(2:64, resu[2:64, "percent.dif"]) 
# Notice the subit increase of the curve. This is because the average distance 
# in the small metacommunity cannot follow the increase in its large metacommunity.

op &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,1))
par(mar=c(1.7, 2, 1.2, 1.2))
plot(large.coo, xlim=c(0, 17), ylim=c(0, 17))
text(10, 16, "Large")
points(large.coo[resu[1, "site.large"],], col="blue", pch=15)
count &lt;- 1
threshold &lt;- 0
while(threshold &lt;= 5 | count &lt;= 7){ 
# Using a threshold of 5 percent or at least 7 sites are accumulated. The later
#   is due to large variations when number of sites is low.
   count &lt;- count+1
   points(large.coo[resu[count,"site.large"],], col="red", pch=15)
   threshold &lt;- abs(resu[count, "percent.dif"])
   Sys.sleep(0.05)
} 
# Wait a little bit and watch the plot until the plotting of red dot stops.

par(mar=c(1.7, 2, 1.2, 1.2)) 
plot(small.coo, xlim=c(0, 17), ylim=c(0, 17)) 
# notice the reduced spatil extent.
text(10, 16, "Small")
points(small.coo[resu[1,"site.small"],], col="blue", pch=15)
count &lt;- 1
threshold &lt;- 0
while(threshold &lt;= 5 | count &lt;= 7){
   count &lt;- count+1
   points(small.coo[resu[count,"site.small"],], col="red", pch=15)
   threshold &lt;- abs(resu[count, "percent.dif"])
   Sys.sleep(0.05)
}
par(op)

### Example 2 - Generation of 3 paired standardized spatial extents
### using each of the three first sites in the larger spatial extent
### as ini.large.
names.large &lt;- rownames(large.coo)[1:3]
resu.list &lt;- vector(mode="list", length=3)
names(resu.list) &lt;- names.large
for(i in names.large){
   print(i)
   resu.list[[i]] &lt;- standExtent(d.large = large.distances, 
                                 d.small=small.distances,
                                 ini.large=i)
}
resu.list
</code></pre>

<hr>
<h2 id='tree6'>Example of phylogenetic tree containing 6 species.</h2><span id='topic+tree6'></span>

<h3>Description</h3>

<p>Example of phylogenetic tree containing 6 species</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tree6)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 4
$ edge       : int [1:10, 1:2] 7 8 9 9 8 10 10 7 11 11 ...
$ Nnode      : int 5
$ tip.label  : chr [1:6] &quot;taxon_1&quot; &quot;taxon_2&quot; &quot;taxon_4&quot; &quot;taxon_3&quot; ...
$ edge.length: num [1:10] 1 1 1 1 1 1 1 1 2 2
- attr(*, &quot;class&quot;)= chr &quot;phylo&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tree6)
plot(tree6)
</code></pre>

<hr>
<h2 id='treeNodf'>Tree-like Nestedness of Ecological Metacommunities</h2><span id='topic+treeNodf'></span><span id='topic+treeNodfTest'></span>

<h3>Description</h3>

<p>This function implements a generalization of the NODF (Nested Overlap and Decreasing Fill; Almeida-Neto et al. 2008) to quantify nestedness in metacommunities that takes into account relatedness among objects expressed as a tree-like object (Melo, Cianciaruso and Almeida-Neto, submitted).</p>


<h3>Usage</h3>

<pre><code class='language-R'>  treeNodf    (comm, col.tree, order.rows=FALSE, row.tree, order.cols=FALSE)
  treeNodfTest(comm, col.tree, order.rows=FALSE, row.tree, order.cols=FALSE,
                                      null.model="perm.rows", permutations=999)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeNodf_+3A_comm">comm</code></td>
<td>
<p>Dataframe or matrix with samples in rows and species in columns.</p>
</td></tr>
<tr><td><code id="treeNodf_+3A_col.tree">col.tree</code></td>
<td>
<p>A tree-like object containing all species listed in <code>comm</code>. This tree will be used to quantify (and test) nestedness among objects in rows (e.g. sites).</p>
</td></tr>
<tr><td><code id="treeNodf_+3A_order.rows">order.rows</code></td>
<td>
<p>Should rows of <code>comm</code> be ordered by decreasing Branch-Length (BL) Diversity. See details below.</p>
</td></tr>
<tr><td><code id="treeNodf_+3A_row.tree">row.tree</code></td>
<td>
<p>A tree-like object containing all row objects (e.g. sites) listed in <code>comm</code>. This tree will be used to quantify (and test) nestedness among objects in columns (e.g. species).</p>
</td></tr>
<tr><td><code id="treeNodf_+3A_order.cols">order.cols</code></td>
<td>
<p>Should columns of <code>comm</code> be ordered by decreasing Branch-Length (BL) Diversity. See details below.</p>
</td></tr>
<tr><td><code id="treeNodf_+3A_null.model">null.model</code></td>
<td>
<p>Seven null models are currently implemented: &quot;perm.rows&quot;, &quot;perm.cols&quot;, &quot;perm.rc&quot;, &quot;perm.tip.cols&quot;, &quot;perm.tip.rows&quot;, &quot;perm.tip.rc&quot; and &quot;ff&quot;. See details.</p>
</td></tr>
<tr><td><code id="treeNodf_+3A_permutations">permutations</code></td>
<td>
<p>Number of permutations of the <code>null.model</code> to assess significance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a direct extension of the NODF metric used to quantify nestedness in metacommunities using presence-absence data. NODF measures the proportion of the species richness present in a species-poor community which is present in a species-rich community. The tree-like version of this metric uses Branch-Length (BL) as a measure of diversity (instead of species richness used in NODF). For phylogenetic trees (a cladogram), BL is the Phylogenetic Diversity (PD, sensu Faith 1992). In this case, treeNODF (or phyloNODF) measures the proportion of the BL (or PD) in a BL-poor (or PD-poor) community that is present in a BL-rich (or PD-rich) community. The same reasoning applies to other tree-like objects such as functional dendrograms (Petchey &amp; Gaston 2006).
</p>
<p>The treeNODF follows the same approach of NODF and are calculated for each pair of objects in a given matrix dimension. For instance, for a dataset including 5 sites in its rows, 10 (5*4/2) pairs of values are calculated. The treeNODF for rows is simply the average of these 10 values. The same can be applied for columns. For instance, if columns represent species, one may assess whether there are nestedness in the environmental conditions where they occur (envNODF). For envNODF, users should supply a tree-like object that depicts resemblance among sites (i.e. a dendrogram where sites are classified according to environmental variables of interest). Finally, the treeNODF can be calculated for both rows and columns. In this case, two tree-like objects must be provided. The option to test rows (sites), columns (species) or both will depend exclusively on the hypothesis the user have raised regarding the nestedness structure of his study system.
</p>
<p>The treeNODF can be partitionated into two components. The first one, called S.fraction, is the proportion of the species richness (or species incidence in the case of columns) of the BL-poor community that is shared with the BL-rich community. The second one is obtained as topoNODF = treeNODF - S.fraction and measures the effect of tree topology to treeNODF (see Melo et al. submitted). 
</p>
<p>NODF and its implementation in R <code><a href="vegan.html#topic+nestednodf">nestednodf</a></code> allows one to order rows and columns by frequencies (species richness for sites and species incidences for species). However, evidence of nestedness in a matrix automatically ordered by frequencies does not allows a proper inference of the mechanism generating nestedness (see Almeida-Neto et al 2008, Ulrich et al. 2009). Accordingly, better inferences of mechanisms generating nestedness and tree-nestedness should be done by ordering communities (rows) or species (columns) accordingly to a hypothesis raised <em>a priori</em> (and not by their S or BLs).
</p>
<p>The &quot;perm.rows&quot; null model permute rows (sites) and is useful to test a site by species matrix in which rows (sites) were ordered by an <em>a priori</em> hypothesis (e.g. island area, Lomolino 1996). The &quot;perm.cols&quot; null model permute columns (species) and is useful to test a site by species matrix in which columns (species) were ordered by an <em>a priori</em> hypothesis (e.g. species body size). These two models must not be used if diversity (S or BL) is used to order communtiy data. This is because simulated values of the statistic will lower or equal to the observed one, but never higher. Although termed 'null models' here, notice these procedures constitutes a permutation test (rows or columns are permuted, not elements).
</p>
<p>The &quot;perm.tip.cols&quot; null model shuffles species (columns) labels across tips of the tree-like object. This null model should be useful to test the effect of resemblance among species (columns) to the treeNODF result. Similarly, the &quot;perm.tip.rows&quot; model shuffles tip labels of the row.tree (usually, sites). The &quot;perm.tip.rc&quot; model shuffles tip labels of both trees.
</p>
<p>The &quot;ff&quot; null model is a popular choice in the literature on species co-occurrence analysis. It maintains sum of rows (species richness of sites) and sum of columns (species frequencies) fixed. Notice, however, that treeNODF makes inferences about BL and this type of &quot;diversity&quot; is affected not only by species richness but also by the resemblance among species (or sites) present in communities. The function <code><a href="vegan.html#topic+commsimulator">commsimulator</a></code> is used to shuffle matrices according to the &quot;ff&quot; null model using the &quot;quasiswap&quot; option.
</p>


<h3>Value</h3>

<p>For the <code>treeNodf</code>, a list including:
</p>
<table role = "presentation">
<tr><td><code>rows</code></td>
<td>
<p>The average of <code>tree.nodf.rows.dist</code> and the averages of its two components for rows.</p>
</td></tr>
<tr><td><code>cols</code></td>
<td>
<p>The average of <code>tree.nodf.cols.dist</code> and the averages of its two components for columns.</p>
</td></tr> 
<tr><td><code>mat</code></td>
<td>
<p>The average of <code>tree.nodf.rows.dist</code> and <code>tree.nodf.cols.dist</code> when treeNODF for both rows and columns are calculated. This is the treeNODF for the entire dataset. Averages for the two component metrics are also provided.</p>
</td></tr>
<tr><td><code>tree.nodf.rows.dist</code></td>
<td>
<p>A triangular matrix of treeNODFs for each pair of rows (sites). Each value represents the treeNODF of the site showed in its row in relation to the site showed in its column. Thus, values in the first column represents the treeNODFs of each community in relation to the community supposed to have the highest BL.</p>
</td></tr>
<tr><td><code>tree.nodf.cols.dist</code></td>
<td>
<p>A triangular matrix of treeNODFs for each pair of columns (species). Each value represents the treeNODF of the species showed in its column in relation to the site showed in its row. Thus, values in the first column represents the treeNODFs of each species in relation to the species supposed to have the highest BL (that is, the species supposedly to occurr in the widest set of conditions).</p>
</td></tr>
<tr><td><code>s.fraction.rows.dist</code></td>
<td>
<p>A triangular matrix of s.fration values for each pair of rows (sites).</p>
</td></tr>
<tr><td><code>s.fraction.cols.dist</code></td>
<td>
<p>A triangular matrix of s.fraction values for each pair of columns (species).</p>
</td></tr>
<tr><td><code>topo.nodf.rows.dist</code></td>
<td>
<p>A triangular matrix of topo.nodf values for each pair of rows (sites).</p>
</td></tr>
<tr><td><code>topo.nodf.cols.dist</code></td>
<td>
<p>A triangular matrix of topo.nodf values for each pair of columns (species).</p>
</td></tr>  
</table>
<p>For the <code>treeNodfTest</code>, a list containing the same list provided by <code>treeNODF</code> for the observed values and:
</p>
<table role = "presentation">
<tr><td><code>rows.aleats</code></td>
<td>
<p>treeNODF, S.fraction and topoNODF values for rows obtained using the chosen null model.</p>
</td></tr>
<tr><td><code>cols.aleats</code></td>
<td>
<p>treeNODF, S.fraction and topoNODF values for colums obtained using the chosen null model.</p>
</td></tr>
<tr><td><code>mat.aleats</code></td>
<td>
<p>treeNODF, S.fraction and topoNODF values for the entire matrix obtained using the chosen null model.</p>
</td></tr>
<tr><td><code>permutations</code></td>
<td>
<p>Number of permutations used in the test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adriano Sanches Melo</p>


<h3>References</h3>

<p>Almeida-Neto M., P. Guimaraes, P.R. Guimaraes, R.D. Loyola &amp; W. Ulrich. 2008. A consistent metric for nestedness analysis in ecological systems: reconciling concept and measurement. Oikos 117:1227-1239.
</p>
<p>Faith, D.P. 1992. Conservation evaluation and phylogenetic diversity. Biological Conservation 61:1-10.
</p>
<p>Lomolino, M.V. 1996. Investigatin causality of nestedness of insular communities: selective immigration or extinctions? Journal of Biogeography 23:699-703.  
</p>
<p>Melo, A.S., M.V. Cianciaruso &amp; M. Almeida-Neto. 2014. treeNODF: nestedness to phylogenetic, functional and other tree-based diversity metrics. Methods in Ecology and Evolution 5: 563-572.
</p>
<p>Petchey, O.L. &amp; K.J. Gaston. 2006. Functional diversity: back to basics and looking forward. Ecology Letters 9:741-758.
</p>
<p>Ulrich, W., M. Almeida-Neto &amp; N.J. Gotelli. 2009. A comsumer's guide to nestedness analysis. Oikos 118:3-17.</p>


<h3>See Also</h3>

<p><code><a href="picante.html#topic+pd">pd</a></code> (package picante), <code><a href="betapart.html#topic+beta.multi">beta.multi</a></code> (package betapart)</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(picante)
data(sites5.6)
data(tree6)
treeNodf(sites5.6, col.tree=tree6)
# You likely will need more runs in your permutation test.
treeNodfTest(sites5.6, col.tree=tree6, null.model="perm.rows", permutations=9)

alt5 &lt;- vegdist(1:5, method="euclidean")
alt5 &lt;- hclust(alt5)
alt5 &lt;- as.phylo(alt5)
alt5$tip.label&lt;-rownames(sites5.6)
treeNodf    (sites5.6, row.tree=alt5)

treeNodfTest(sites5.6, row.tree=alt5, null.model="perm.cols",permutations=99)

treeNodf     (sites5.6, col.tree=tree6, row.tree=alt5)

treeNodfTest(sites5.6, col.tree=tree6, row.tree=alt5, null.model="perm.rc", permutations=99)

treeNodfTest(sites5.6, col.tree=tree6, row.tree=alt5, null.model="ff", permutations=99)

# In the example below treeNodf is zero because PD of the first sample is 
#   lower than that of the second sample. Notice samples have the same species 
#   richness and higher PD for the first sample is due to the presence of a
#   distinctive species (e).
tree &lt;- read.tree(text="(((a:1,b:1):1,(c:1,d:1):1):2, e:4);")
plot(tree)
mat  &lt;- matrix(c(1,1,1,1,0, 1,1,1,0,1), byrow=TRUE, nrow=2, dimnames=list(1:2, letters[1:5]))
mat
pd(mat, tree)
treeNodf(mat, tree) 

# Here treeNodf is non-zero... but you would only do that if you have
#    an 'a priori' hypothesis to order rows of your matrix this way!
treeNodf(mat[2:1, ], tree) 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
