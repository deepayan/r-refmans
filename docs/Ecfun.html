<!DOCTYPE html><html lang="en-us"><head><title>Help for package Ecfun</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Ecfun}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Arrows'>
<p>Draw arrows between pairs of points.</p></a></li>
<li><a href='#as.Date1970'>
<p>Date from a number of days since the start of 1970.</p></a></li>
<li><a href='#asNumericDF'>
<p>Coerce to numeric dropping commas and info after a blank</p></a></li>
<li><a href='#BoxCox'>
<p>Box-Cox power transformation and its inverse</p></a></li>
<li><a href='#camelParse'>
<p>Split a character string where a capital letter follows a lowercase</p>
letter</a></li>
<li><a href='#canbeNumeric'>
<p>Can a variable reasonably be coerced to numeric?</p></a></li>
<li><a href='#checkNames'>
<p>Check and return names</p></a></li>
<li><a href='#classIndex'>
<p>Convert class to an integer 1-8 and vice versa</p></a></li>
<li><a href='#compareLengths'>
<p>Compare the lengths of two objects</p></a></li>
<li><a href='#compareOverlap'>
<p>Compare y between newDat and</p>
refDat for shared values of x</a></li>
<li><a href='#confint.var'>
<p>Confidence interval for sample variance or</p>
standard deviation</a></li>
<li><a href='#countByYear'>
<p>Allocate a total by year</p></a></li>
<li><a href='#countsByYear'>
<p>Allocate totals by year</p></a></li>
<li><a href='#createMessage'>
<p>Compose a message as a single substring from</p>
a character vector</a></li>
<li><a href='#createX2matchY'>
<p>Create X to match Y</p></a></li>
<li><a href='#Date3to1'>
<p>Convert three YMD vectors to a Date</p></a></li>
<li><a href='#dateCols'>
<p>Identify YMD names in a character vector</p></a></li>
<li><a href='#Dates3to1'>
<p>Convert 3-column dates in data to class Date</p></a></li>
<li><a href='#deletedFunctions'>
<p>Functions deleted from the Ecfun package</p></a></li>
<li><a href='#findCountry'>
<p>Find a 3-letter country code in rworldmap::countrySynonyms</p></a></li>
<li><a href='#getElement2'>
<p>Extract a named element from an object with</p>
a default</a></li>
<li><a href='#grepNonStandardCharacters'>
<p>grep for nonstandard characters</p></a></li>
<li><a href='#Interp'>
<p>Interpolate between numbers or numbers of characters</p></a></li>
<li><a href='#interpChar'>
<p>Interpolate between numbers or numbers of</p>
characters</a></li>
<li><a href='#interpPairs'>
<p>interpolate between pairs of vectors in a list</p></a></li>
<li><a href='#logVarCor'>
<p>Log-diagonal representation of a variance matrix</p></a></li>
<li><a href='#match.data.frame'>
<p>Identify the row of <code>y</code> best</p>
matching each row of <code>x</code></a></li>
<li><a href='#matchName'>
<p>Match surname and givenName in a table</p></a></li>
<li><a href='#matchQuote'>
<p>Match isolated quotes across records</p></a></li>
<li><a href='#mergeVote'>
<p>Merge Roll Call Vote</p></a></li>
<li><a href='#missing0'>
<p>Missing or length 0</p></a></li>
<li><a href='#nchar0'>
<p>Zero characters or NULL</p></a></li>
<li><a href='#Newdata'>
<p>Create a new data.frame for predict</p></a></li>
<li><a href='#parseCommas'>
<p>Convert character string with Dollar signs</p>
and commas to numerics</a></li>
<li><a href='#parseDollars'>
<p>Convert character string with Dollar signs</p>
and commas to numerics</a></li>
<li><a href='#parseName'>
<p>Parse surname and given name</p></a></li>
<li><a href='#Ping'>
<p>ping a Uniform resource locator (URL)</p></a></li>
<li><a href='#pmatch2'>
<p>Value matching or partial matching</p></a></li>
<li><a href='#pmatchIC'>
<p>pmatch ignoring case</p></a></li>
<li><a href='#qqnorm2'>
<p>Normal Probability Plot with Multiple Symbols</p></a></li>
<li><a href='#qqnorm2s'>
<p>Normal Probability Plot with Multiple Lines</p>
and Multiple Symbols</a></li>
<li><a href='#qqnorm2t'>
<p>Normal Probability Plot with Multiple Lines</p>
and Multiple Symbols</a></li>
<li><a href='#rasterImageAdj'>
<p>rasterImage adjusting to zero distortion</p></a></li>
<li><a href='#read.transpose'>
<p>Read a data table in transpose form</p></a></li>
<li><a href='#readDates3to1'>
<p>read.csv with Dates in 3 columns</p></a></li>
<li><a href='#readDW_NOMINATE'>
<p>Read the DW-NOMINATE data from their website.</p></a></li>
<li><a href='#readNIPA'>
<p>Read a National Income and Product Accounts</p>
data table</a></li>
<li><a href='#recode2'>
<p>bivariate recode</p></a></li>
<li><a href='#rgrep'>
<p>Reverse grep</p></a></li>
<li><a href='#sign'>
<p>Sign function with zero option</p></a></li>
<li><a href='#simulate.bic.glm'>
<p>A &quot;simulate&quot; method for a <code>BMA::bic.glm</code></p>
object</a></li>
<li><a href='#simulate.glm'>
<p>A &quot;simulate&quot; method for a glm object</p></a></li>
<li><a href='#strsplit1'>
<p>Split the first field</p></a></li>
<li><a href='#subNonStandardCharacters'>
<p>sub nonstandard characters with replacement</p></a></li>
<li><a href='#subNonStandardNames'>
<p>sub for nonstandard names</p></a></li>
<li><a href='#trimImage'>
<p>Trim zero rows or columns from an object of</p>
class <code>Image</code>.</a></li>
<li><a href='#truncdist'>
<p>Truncated distribution</p></a></li>
<li><a href='#whichAeqB'>
<p>Index of a single match</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.3-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-11</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for 'Ecdat'</td>
</tr>
<tr>
<td>Author:</td>
<td>Spencer Graves [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Spencer Graves &lt;spencer.graves@effectivedefense.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>car, DescTools, Ecdat, maps, grid, gridBase, pryr, knitr,
rmarkdown, invgamma, ipumsr, lubridate, bayesplot, bssm,
ggplot2, tibble, kableExtra, openxlsx, fitdistrplus, purrr,
markdown, EnvStats, drc, zoo, prodlim, plyr, TRAMPR, raster,
readxl</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>fda, tis, jpeg, MASS, stringi, methods, xml2, BMA, mvtnorm,
rvest, readr, rworldmap</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and vignettes to update 
    data sets in 'Ecdat' and to create, manipulate, 
    plot, and analyze those and similar data sets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Language:</td>
<td>en-us</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-12 09:13:43 UTC; sg</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-12 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Arrows'>
Draw arrows between pairs of points.
</h2><span id='topic+Arrows'></span>

<h3>Description</h3>

<p>Generalizes <code>graphics::arrows</code> to allow all arguments to be
vectors.  (As of R 3.1.0, only the first component of the
<code>length</code> argument is used by <code>graphics::arrows</code>;  others are
ignored without a warning.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Arrows(x0, y0, x1 = x0, y1 = y0, length = 0.25, angle = 30,
       code = 2, col = par("fg"), lty = par("lty"),
       lwd = par("lwd"), warnZeroLength=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Arrows_+3A_x0">x0</code>, <code id="Arrows_+3A_y0">y0</code>, <code id="Arrows_+3A_x1">x1</code>, <code id="Arrows_+3A_y1">y1</code>, <code id="Arrows_+3A_length">length</code>, <code id="Arrows_+3A_angle">angle</code>, <code id="Arrows_+3A_code">code</code>, <code id="Arrows_+3A_col">col</code>, <code id="Arrows_+3A_lty">lty</code>, <code id="Arrows_+3A_lwd">lwd</code>, <code id="Arrows_+3A_...">...</code></td>
<td>

<p>as for <code><a href="graphics.html#topic+arrows">arrows</a></code>.
</p>
</td></tr>
<tr><td><code id="Arrows_+3A_warnzerolength">warnZeroLength</code></td>
<td>

<p>Issue a warning for zero length arrow?  <code><a href="grid.html#topic+arrow">arrow</a></code> does;
skip if <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  Put all arguments in a <code>data.frame</code> to force them to shared
length.
</p>
<p>2.  Call <code><a href="graphics.html#topic+arrows">arrows</a></code> once for each row.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+arrows">arrows</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1. Simple example: 
##    3 arrows, the first with length 0 is suppressed 
##
plot(1:3, type='n')
Arrows(1, 1, c(1, 2, 2), c(1, 2:3), col=1:3, length=c(1, .2, .6))

##
## 2.  with an NA
##
plot(1:3, type='n')
Arrows(1, 1, c(1, 2, 2), c(1, 2, NA), col=1:3, length=c(1, .2, .6))

</code></pre>

<hr>
<h2 id='as.Date1970'>
Date from a number of days since the start of 1970.
</h2><span id='topic+as.Date1970'></span>

<h3>Description</h3>

<p><code>as.Date.numeric</code> requires <code>origin</code> 
to be specified.  The present function 
assumes that this origin is January 1, 1970.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.Date1970(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.Date1970_+3A_x">x</code></td>
<td>

<p>a numeric vector of dates in days since the 
start of 1970.
</p>
</td></tr>
<tr><td><code id="as.Date1970_+3A_...">...</code></td>
<td>

<p>optional arguments to pass to <code>as.Date</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of Dates
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.Date">as.Date</a></code>
<code><a href="fda.html#topic+as.POSIXct1970">as.POSIXct1970</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>days &lt;- c(0, 1, 365)
Dates &lt;- as.Date1970(days)


all.equal(c('1970-01-01', '1970-01-02', '1971-01-01'),
          as.character(Dates))



all.equal(days, as.numeric(Dates))


</code></pre>

<hr>
<h2 id='asNumericDF'>
Coerce to numeric dropping commas and info after a blank
</h2><span id='topic+asNumericChar'></span><span id='topic+asNumericDF'></span>

<h3>Description</h3>

<p>For <code>asNumericChar</code>, delete leading
blanks and a leading dollar sign plus
commas (thousand separators) and drop
information after a blank (other than
leading blanks), then coerce to numeric or
to factors, <code>Dates</code>, or 
<code>POSIXct</code> as desired.
</p>
<p>For a <code><a href="base.html#topic+data.frame">data.frame</a></code>, apply 
<code>asNumericChar</code> to all columns and
drop columns except those in <code>keep</code>,
<code>ignore</code>, <code>factors</code>, 
<code>Dates</code>, <code>POSIX</code> and 
<code>MSdates</code>.
</p>
<p>Then order the rows by the 
<code>orderBy</code> column.  Some Excel 
imports include commas as thousand
separators;  this replaces any commas
with char(0), &rdquo;, before trying to
convert to numeric.  
</p>
<p>Similarly, if &quot;%&quot; is found as the last 
character in any field, drop the percent
sign and divide the resulting numeric
conversion by 100 to convert to 
proportion.  
</p>
<p>Also, some character data includes 
footnote references following the year.  
</p>
<p>For example Table F-1 from the US Census 
Bureau needs all three of these numeric
conversion features:  It needs 
<code>orderBy</code>, because the most recent 
year appears first, just the opposite of
most other data sets where the most
recent year appears last.  It has
footnote references following a character
string indicating the year.  And it
includes commas as thousand separators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asNumericChar(x, leadingChar='^\\$', 
    suppressChar=',', pctChar='%$', 
    class.=NULL, format.=NULL)
asNumericDF(x, keep=
    function(x)any(!is.na(x)), 
  orderBy=NA, ignore=NULL, factors=NULL, 
  Dates=NULL, POSIX=NULL, MSdates=NULL, 
  format.=NULL, leadingChar='^\\$', 
  suppressChar=',', pctChar='%$')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asNumericDF_+3A_x">x</code></td>
<td>

<p>For <code>asNumericChar</code>, this is a
character vector to be converted to
numeric after <code>gsub(',', '', x)</code>.
</p>
<p>For <code>asNumericDF</code>, this is a
<code>data.frame</code> with all character 
columns to be converted to numerics.
</p>
</td></tr>
<tr><td><code id="asNumericDF_+3A_keep">keep</code></td>
<td>

<p>something to indicate which columns to 
keep, in addition to columns specified
in <code>ignore</code>, <code>factors</code>,
<code>Dates</code>, and <code>POSIX</code>.  
</p>
</td></tr>
<tr><td><code id="asNumericDF_+3A_orderby">orderBy</code></td>
<td>

<p>Which columns to order the rows of
<code>x[, keep]</code> by.  Default is to
keep the input order.  
</p>
</td></tr>
<tr><td><code id="asNumericDF_+3A_ignore">ignore</code></td>
<td>

<p>vector identifying columns of <code>x</code> 
to ignore, i.e., to keep and not
attempt to convert to another data 
type.  
</p>
</td></tr>
<tr><td><code id="asNumericDF_+3A_factors">factors</code></td>
<td>

<p>vector indicating columns of <code>x</code> 
to convert to <code><a href="base.html#topic+factor">factor</a></code>
</p>
</td></tr> 
<tr><td><code id="asNumericDF_+3A_dates">Dates</code></td>
<td>

<p>vector indicating columns of <code>x</code> 
to convert using 
<code><a href="base.html#topic+as.Date">as.Date</a></code>(, <code>format</code>).
</p>
</td></tr>
<tr><td><code id="asNumericDF_+3A_posix">POSIX</code></td>
<td>

<p>vector indicating columns of <code>x</code> 
to convert using 
<code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>(, <code>format</code>).  
</p>
</td></tr>
<tr><td><code id="asNumericDF_+3A_class.">class.</code></td>
<td>

<p>Desired class of output.  Default is 
<code><a href="base.html#topic+numeric">numeric</a></code>.  
</p>
</td></tr>
<tr><td><code id="asNumericDF_+3A_format.">format.</code></td>
<td>

<p>Character vector of length 1 to pass 
as argument <code>format</code> to 
<code><a href="base.html#topic+as.Date">as.Date</a></code> and / or 
<code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code> for conversion
from <code><a href="base.html#topic+character">character</a></code>.  
</p>
<p>For <code>Dates</code>, <code><a href="base.html#topic+as.Date">as.Date</a></code>
is first tried with format = 
'%Y-%m-%d', then with '%Y/%m/%d',
'%m-%d-%Y', and '%m/%d/%Y'.  The
conversion with the fewest NAs is kept.
If two match for numbers of NAs, the
one with the minimum absolute 
deviations from as.Date1970(0) is used.
</p>
</td></tr>
<tr><td><code id="asNumericDF_+3A_msdates">MSdates</code></td>
<td>

<p>The names or numbers identifying
columns of x identifying dates as
integer numbers of days since 
1899-12-31.  <a href="https://support.office.com/en-us/article/Add-sum-or-subtract-dates-9818b3f7-aa67-4008-8dff-3c3b503886af?ui=en-US&amp;rs=en-US&amp;ad=US">In 
Microsoft Excel, dates are stored in
that format</a>.  
</p>
</td></tr>
<tr><td><code id="asNumericDF_+3A_leadingchar">leadingChar</code></td>
<td>

<p>A regular expression passed to 
<code><a href="base.html#topic+grep">grep</a></code> and 
<code><a href="base.html#topic+sub">sub</a></code> to replace something
like an initial dollar sign with
<code>character(0)</code>.  
</p>
</td></tr>
<tr><td><code id="asNumericDF_+3A_suppresschar">suppressChar</code></td>
<td>

<p>a regular expression passed to 
<code><a href="base.html#topic+gsub">gsub</a></code> to replace all 
occurrences of something like &quot;,&quot; (a 
thousands separator in the U.S.) with 
<code>character(0)</code>.  
</p>
</td></tr>
<tr><td><code id="asNumericDF_+3A_pctchar">pctChar</code></td>
<td>

<p>A regular expression passed to 
<code><a href="base.html#topic+grep">grep</a></code> to identify percent 
columns.  <code>pctChar</code> is then 
passed to <code><a href="base.html#topic+sub">sub</a></code> to replace 
<code>pctChar</code> with 
<code>character(0)</code>, and the converted
numbers are then divided by 100 to
convert them to proportions.  
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>For <code>asNumericChar</code>:  
</p>
<p>1.  Replace commas by nothing
</p>
<p>2.  <code>strsplit</code> on ' ' and take only 
the first part, thereby eliminating the
footnote references.
</p>
<p>3.  Replace any blanks with NAs
</p>
<p>4.  <code>as.numeric</code>
</p>
<p>for <code>asNumericDF</code>:  
</p>
<p>1.  Copy <code>x</code> to <code>X</code>.  
</p>
<p>2.  Confirm that <code>ignore</code>, 
<code>factors</code>, <code>Dates</code>, and
<code>POSIX</code> all refer to columns 
of <code>x</code> and do not overlap.  
[*** NOTE:  as of 2016-07-21, these
checks have only been implemented
for <code>ignore</code>.]
</p>
<p>3.  Convert <code>factors</code>, <code>Dates</code>,
and <code>POSIX</code>.  
</p>
<p>4.  Apply <code>asNumericChar</code> to all
columns not in <code>ignore</code>, 
<code>factors</code>, <code>Dates</code>, or
<code>POSIX</code>.  
</p>
<p>5.  Keep columns specified by 
<code>keep</code>.  
</p>
<p>6.  return the result.  
</p>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code>
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>References</h3>

<p><a href="https://support.office.com/en-us/article/Add-sum-or-subtract-dates-9818b3f7-aa67-4008-8dff-3c3b503886af?ui=en-US&amp;rs=en-US&amp;ad=US">&quot;Add (sum) or subtract dates;  Applies To: Excel 2013&quot;</a>.  Microsoft.  (accessed 2016-08-11)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scan">scan</a></code>
<code><a href="base.html#topic+gsub">gsub</a></code>
<code><a href="base.html#topic+Quotes">Quotes</a></code>
<code><a href="tis.html#topic+stripBlanks">stripBlanks</a></code>
<code><a href="base.html#topic+as.numeric">as.numeric</a></code>, 
<code><a href="base.html#topic+factor">factor</a></code>, 
<code><a href="base.html#topic+as.Date">as.Date</a></code>, 
<code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>
<code><a href="openxlsx.html#topic+read.xlsx">read.xlsx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  an example 
##
(xDate &lt;- as.Date('1970-01-01')+c(0, 365))
(xPOSIX &lt;- as.POSIXct(xDate)+c(1, 99))
xMSdate &lt;- as.Date(1, 
    as.Date('1899-12-31'))+1:2
(fakeF1 &lt;- data.frame(yr=c('1948', 
            '1947 (1)'),
      q1=c(' 1,234 ', ''), duh=rep(NA, 2), 
      dol=c('$1,234', ''), 
      pct=c('1%', '2%'), 
      xDate=format(xDate, '%Y-%m-%d'), 
      xPOSIX=format(xPOSIX, '%Y-%m-%d %H:%M:%S'), 
      xMSdate=2:3, junk=c('this is',
          'junk')))
            
# This converts the last 3 columns to NAs and drops them:

str(nF1.1 &lt;- asNumericChar(fakeF1$yr))
str(nF1.2 &lt;- asNumericChar(fakeF1$q1))
str(nF1.3 &lt;- asNumericChar(fakeF1$duh))
(nF1.4 &lt;- asNumericChar('1969-12-31 18:00:01',
                        class.='POSIXct'))

(nF1 &lt;- asNumericDF(fakeF1))
(nF2 &lt;- asNumericDF(fakeF1, Dates=6, 
    MSdate='xMSdate', 
    ignore=c('junk', 'xPOSIX'), 
    format.='%Y-%m-%d'))
# check 
nF1. &lt;- data.frame(yr=
        asNumericChar(fakeF1$yr),
      q1=asNumericChar(fakeF1$q1), 
      dol=asNumericChar(fakeF1$dol), 
      pct=c(.01, .02), xMSdate=2:3)

nF1c &lt;- data.frame(yr=1948:1947, 
      q1=c(1234, NA), dol=c(1234, NA), 
      pct=c(.01, .02), xMSdate=2:3)


all.equal(nF1, nF1.)


all.equal(nF1., nF1c)


## 
## 2.  as.Date default example
##
  xD &lt;- asNumericChar(
    as.character(xDate), class.='Date')

  all.equal(xDate, xD)


##
## 3.  as.POSIXct default example 
##
xPOSIX
(xPOSIXch &lt;- as.character(xPOSIX))
(xP &lt;- asNumericChar(xPOSIXch, class.='POSIXct'))
attr(xPOSIX, 'tzone')
attr(xP, 'tzone')
# R-Devel after 4.2.1 breaks earlier code; fix
if(is.null(attr(xPOSIX, 'tzone')))
    attr(xPOSIX, 'tzone') &lt;- attr(xP, 'tzone')
(dP &lt;- difftime(xPOSIX, xP, units='secs'))
(madP &lt;- max(abs(as.numeric(dP))))

{
#all.equal(xPOSIX, xP)
# As of 2022-10-06 I don't know how to write code
# that will get a consistent answer with 
# different version R-devel with differences
# less than an hour
if(madP&gt;(6*60*60)){
  madPmsg &lt;- paste('Discrepancy betw fn and manual comp ', 
       'too large; is ', madP, 'seconds')
  stop(madPmsg)
}
TRUE
}


##
## 4.  orderBy=1:2
##
nF. &lt;- asNumericDF(fakeF1, orderBy=1:2)


all.equal(nF., nF1c[2:1,])


##
## 5.  Will it work for a tibble?  
##
if(require(tibble)){
  nF1t &lt;- asNumericDF(as_tibble(fakeF1))

  all.equal(nF1, nF1t)

}

</code></pre>

<hr>
<h2 id='BoxCox'>
Box-Cox power transformation and its inverse 
</h2><span id='topic+BoxCox'></span><span id='topic+invBoxCox'></span>

<h3>Description</h3>

<p>Box and Cox (1964) considered the following 
family of transformations indexed by 
<code>lambda</code>:  
</p>
<p><code>w</code> = <code>(y^lambda-1)/lambda</code>
</p>
<p>= <code>expm1(lambda*log(y))/lambda</code>, 
</p>
<p>with the <code>lambda=0</code> case defined as 
<code>log(y)</code> to make <code>w</code> continuous in 
<code>lambda</code> for constant <code>y</code>.  
</p>
<p>They estimate <code>lambda</code> assuming <code>w</code>
follows a normal distribution.  This raises a
theoretical problem in that <code>y</code> must be
positive, which means that <code>w</code> must follow 
a truncated normal distribution conditioned on 
<code>lambda*w</code> &gt; <code>(-1)</code>.  
</p>
<p>Bickel and Doksum (1981) removed the 
restriction to positive <code>y</code>, i.e., to 
<code>w</code> &gt; <code>(-1/lambda)</code> by modifying 
the transformation as follows:  
</p>
<p><code>w</code> = 
</p>
<p><code>(sgn(y)*abs(y)^lambda-1)/lambda</code> 
if <code>lambda != 0</code> and 
</p>
<p><code>sgn(y)*log(abs(y))</code> if <code>lambda = 0</code>, 
</p>
<p>where <code>sgn(y)</code> = 1 if y &gt;= 0 and -1 
otherwise.  
</p>
<p>NOTE:  <code>sgn(y)</code> is different from 
<code><a href="base.html#topic+sign">sign</a></code>(y), which is 0 for 
y = 0.  A two-argument update to the sign 
function in the base package has been added to 
this Ecfun package, so <code><a href="#topic+sign">sign</a></code>(y, 1) 
= <code>sgn(y)</code>.  
</p>
<p>If (y&lt;0), this transformation is discontinuous 
at <code>lambda = 0</code>.  To see this, we rewrite 
this as 
</p>
<p><code>w</code> = 
<code>(sgn(y)*expm1(lambda*log(abs(y))) + 
  (sgn(y)-1)) / lambda</code> 
</p>
<p>= <code>sgn(y)*(log(abs(y)) + O(lambda) + 
  (sgn(y)-1)/lambda</code>, 
</p>
<p>where 
<a href="https://en.wikipedia.org/wiki/Big_O_notation">O(lambda)</a>
indicates a term that is dominated by a 
constant times <code>lambda</code>.  
</p>
<p>If y&lt;0, this latter term 
<code>(sgn(y)-1)/lambda = (-2)/lambda</code> and 
becomes <code>Inf</code> as <code>lambda</code> -&gt; 0.  
</p>
<p>In practice, we assume that <code>y</code> &gt; 0, 
so this distinction has little practical 
value.  However, the <code>BoxCox</code> function 
computes the Bickel-Doksum version.  
</p>
<p>Box and Cox further noted that proper 
estimation of <code>lambda</code> should include 
the Jacobian of the transformation in the 
log(likelihood).  Doing this can be achieved 
by rescaling the transformation with the 
<code>n</code><code>th</code> root of the Jacobian, which 
can be written as follows:   
</p>
<p><code>j(y, lambda)</code> = 
<code>J(y, lambda)^(1/n)</code> = 
<code>GeometricMean(y)^(lambda-1)</code>.  
</p>
<p>With this the rescaled power transformation 
is as follows:    
</p>
<p><code>z</code> = <code>(y^lambda-1) / 
                    (lambda*j(y, lambda)</code> 
if <code>lambda!=0</code>
or <code>GeometricMean(y)*log(y)</code> if 
<code>lambda==0</code>.  
</p>
<p>In addition to facilitating estimation of 
<code>lambda</code>, rescaling has the advantage 
that the units of <code>z</code> are the same as 
the units of <code>y</code>.    
</p>
<p>The output has class <code>BoxCox</code>, which has 
attributes that allow the input to be recovered
using <code>invBoxCox</code>. The default values of 
the arguments of <code>invBoxCox</code> are provided 
by the corresponding <code><a href="base.html#topic+attributes">attributes</a></code> 
of <code>z</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  BoxCox(y, lambda, rescale=TRUE, na.rm=rescale) 
  invBoxCox(z, lambda, sign.y, GeometricMean, rescale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BoxCox_+3A_y">y</code></td>
<td>

<p>a numeric vector for which the power transform 
is desired  
</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_lambda">lambda</code></td>
<td>

<p>A numeric vector of length 1 or 2.  The first
component is the power.  If the second 
component is provided, <code>y</code> is replaced 
by <code>y+lambda[2]</code>.  
</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_rescale">rescale</code></td>
<td>

<p>logical or numeric.  If logical:  
</p>
<p>For <code>BoxCox</code>, this is <code>TRUE</code> to 
return the power transform with rescale, 
<code>z</code>, above, and <code>FALSE</code>
to return the power transform without the
<code>n</code>th root of the Jacobian, 
<code>w</code>, above.  This defaults to 
<code>TRUE</code>, because this will give <code>z</code> 
the same units as <code>y</code>.  
</p>
<p>For <code>invBoxCox</code>, this is <code>TRUE</code> 
if the input argument <code>z</code> is assumed to 
have been rescaled by the <code>n</code>th 
root of the Jacobian of the transformation. 
This defaults to a <code>rescale</code> attribute 
of <code>z</code> if present or to <code>TRUE</code> if 
absent.  
</p>
<p>If numeric, it is assumed to be the 
geometric mean of another set of y values to 
use with new <code>y</code>'s.  
</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_na.rm">na.rm</code></td>
<td>

<p>logical:  
<code>TRUE</code> to remove <code>NA</code>s from 
<code>y</code> before computing the geometric 
mean.  
</p>
<p><code>FALSE</code> to compute <code>NA</code>
for the geometric mean if 
<code>any(is.na(y))</code>.  
</p>
<p>NOTE:  If <code>na.rm</code> = <code>FALSE</code>, the 
output will be all <code>NA</code> if 
<code>rescale</code> = <code>TRUE</code>.  This could 
produce non usable answers in most cases.  
To avoid that, the default for <code>na.rm</code> 
is <code>TRUE</code> whenever <code>rescale</code> = 
<code>TRUE</code>.  Conversely, applications using
<code>na.rm</code> = <code>FALSE</code> will likely also 
want <code>rescale</code> = <code>FALSE</code> to avoid
returning a non-answer in these cases.  This
explains the default <code>na.rm</code> = 
<code>rescale</code>.  
</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_z">z</code></td>
<td>

<p>a numeric vector or an object of class 
<code>BoxCox</code> for which the inverse Box-Cox
transform is desired.  
</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_sign.y">sign.y</code></td>
<td>

<p>an optional logical vector giving 
<code>sign(y-lambda[2])</code> of the data values 
that presumably generated <code>z</code>.  Defaults 
to an <code>sign.y</code> attribute of <code>z</code> or 
to <code>rep(1, length(z))</code> if no such 
attribute is present.  
</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_geometricmean">GeometricMean</code></td>
<td>

<p>an optional numeric scalar giving the 
geometric mean of the  data values that 
presumably generated <code>z</code>.  Defaults to 
a <code>GeometricMean</code> attribute of 
<code>z</code> or to 1 if no such attribute is 
present.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Box and Cox (1964) discussed 
</p>
<p><code>w(y, lambda) = (y^lambda - 1)/lambda</code>. 
</p>
<p>They noted that <code>w</code> is continuous in 
<code>lambda</code> with w(y, lambda) = <code>log(y)</code> 
if <code>lambda</code> = 0 (by l'Hopital's rule).  
</p>
<p>They also discussed  
</p>
<p><code>z(y, lambda) = (y^lambda - 1) / 
  (lambda*g^(lambda-1))</code>, 
</p>
<p>where <code>g</code> = the geometric mean of <code>y</code>.
</p>
<p>They noted that proper estimation of 
<code>lambda</code> should include the Jacobian of 
w(y, lambda) with the likelihood.  They further
showed that a naive normal likelihood using 
<code>z(y, lambda)</code> as the response without a
Jacobian is equivalent to the normal likelihood
using <code>w(y, lambda)</code> adjusted appropriately
using the Jacobian.  See Box and Cox (1964) or 
<a href="https://en.wikipedia.org/wiki/Power_transform">the Wikipedia article on &quot;Power transform&quot;</a>.  
</p>
<p>Bickel and Doksum (1981) suggested adding 
<code>sign(y)</code> to the transformation, as 
discussed above. 
</p>
<p>NUMERICAL ANALYSIS:  
</p>
<p>Consider the Bickel and Doksum version 
described above:  
</p>
<p><code>w</code> &lt;- 
<code>(sign(y)*abs(y)^lambda-1)/lambda</code>
</p>
<p><code>if(any(y==0)), GeometricMean(y)</code> = 0.  
This creates a problem with the above math.    
</p>
<p>Let <code>ly = log(abs(y))</code>.  Then with 
<code>la = lambda</code>, 
</p>
<p><code>w</code> = <code>(sign(y)*exp(la*ly)-1)/la</code>
</p>
<p>= <code>sign(y) * ly * (1+(la*ly/2) * 
  (1+(la*ly/3)*(1+(la*ly/4)*(1+O(la*ly)))))
  + (sign(y)-1)/la</code>
</p>
<p>For y&gt;0, the last term is zero.  
<code><a href="MASS.html#topic+boxcox">boxcox</a></code> ignores cases 
with y&lt;=0 and uses this formula (ignoring 
the final <code>O(la*ly)</code>) whenever 
<code>abs(la) &lt;= eps = 1/50</code>. 
That form is used here also.  
</p>
<p>For <code>invBoxCox</code> a complementary 
analysis is as follows:  
</p>
<p><code>abs(y+lambda[2]) = abs(1+la*w)^(1/la)</code>
</p>
<p>= <code>exp(log1p(la*w)/la) for abs(la*w)&lt;1</code> 
</p>
<p>= <code>w * (1-la*w * ((1/2)-la*w * 
  ((1/3)-la*w*(1/4-...))))</code>
</p>


<h3>Value</h3>

<p><code>BoxCox</code> returns an object of class 
<code>BoxCox</code>, being a numeric vector of the 
same length as <code>y</code> with the following 
optional attributes:  
</p>

<dl>
<dt><code>lambda</code></dt><dd>
<p>the value of <code>lambda</code> 
used in the transformation
</p>
</dd>
<dt><code>sign.y</code></dt><dd>
<p>sign(y) (or sign(y-lambda[2]) lambda[2] is
provided and if any of these quantities are
negative.  Otherwise, this is omitted and all
are assumed to be positive.
</p>
</dd>
<dt><code>rescale</code></dt><dd>
<p>logical:  
<code>TRUE</code> if <code>z(y, lambda)</code> 
is returned rescaled by <code>g^(lambda-1)</code>
with g = the geometric mean of y 
</p>
<p>and <code>FALSE</code> if <code>z(y, lambda)</code> is 
not so rescaled.  
</p>
</dd>
<dt><code>GeometricMean</code></dt><dd>
<p>If <code>rescale</code> is numeric, 
<code>attr(., 'GeometricMean') &lt;- rescale</code>.  
</p>
<p>Otherwise, <code>attr(., 'GeometricMean')</code> is 
the Geometric mean of <code>abs(y) = 
      exp(mean(log(abs(y)))) or of 
      abs(y+lambda[2]) if(length(lambda)&gt;1)</code>.  
</p>
</dd>
</dl>
 
<p><code>invBoxCox</code> returns a numeric vector,
reconstructing <code>y</code> from 
<code>BoxCox(y, ...)</code>.  
</p>


<h3>Source</h3>

<p>Bickel, Peter J., and Doksum, Kjell A. (1981) 
&quot;An analysis of transformation revisited&quot;, 
<em>Journal of the American Statistical
Association</em>, 76 (374):  296-311  
</p>
<p>Box, George E. P.; Cox, D. R. (1964). 
&quot;An analysis of transformations&quot;, 
<em>Journal of the Royal Statistical Society</em>, 
Series B 26 (2): 211-252. 
</p>
<p>Box, George E. P.; Cox, D. R. (1982). 
&quot;An analysis of transformations revisited,
rebutted&quot;, 
<em>Journal of the American Statistical Association</em>, 
77(377): 209-210.    
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Power_transform">Wikipedia, &quot;Power transform&quot;</a>
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+boxcox">boxcox</a></code> in the MASS package 
</p>
<p><code><a href="MASS.html#topic+quine">quine</a></code> in the MASS package 
for data used in an example below.  
</p>
<p><code><a href="EnvStats.html#topic+boxcox">boxcox</a></code> and 
<code><a href="EnvStats.html#topic+boxcoxCensored">boxcoxCensored</a></code> in the
<code>EnvStats</code> package.  
</p>
<p><code><a href="drc.html#topic+boxcox.drc">boxcox.drc</a></code> in the 
<code>drc</code> package.  
</p>
<p><code><a href="car.html#topic+boxCox">boxCox</a></code> in the <code>car</code>
package.  
</p>
<p>These other uses all wrap the Box-Cox 
transformation in something larger and do not 
give the transformation itself directly.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  A simple example to check the two algorithms 
##
Days &lt;- 0:9
bc1 &lt;- BoxCox(Days, c(0.01, 1))
# Taylor expansion used for obs 1:7; expm1 for 8:10 

# check 
GM &lt;- exp(mean(log(abs(Days+1))))

bc0 &lt;- (((Days+1)^0.01)-1)/0.01
bc1. &lt;- (bc0 / (GM^(0.01-1)))  
# log(Days+1) ranges from 0 to 4.4 
# lambda = 0.01 will invoke both the obvious
# algorithm and the alternative assumed to be 
# more accurate for (lambda(log(y)) &lt; 0.02).  
attr(bc1., 'lambda') &lt;- c(0.01, 1)  
attr(bc1., 'rescale') &lt;- TRUE 
attr(bc1., 'GeometricMean') &lt;- GM 
class(bc1.) &lt;- 'BoxCox'


all.equal(bc1, bc1.)


##
## 2.  another simple example with lambda=0
##
bc0.4 &lt;- BoxCox(1:5, 0)
GM5 &lt;- prod(1:5)^.2
bc0.4. &lt;- log(1:5)*GM5
attr(bc0.4., 'lambda') &lt;- 0  
attr(bc0.4., 'rescale') &lt;- TRUE 
attr(bc0.4., 'GeometricMean') &lt;- GM5 
class(bc0.4.) &lt;- 'BoxCox'


all.equal(bc0.4, bc0.4.)


bc0.4e9 &lt;- BoxCox(1:5, .Machine$double.eps)
bc0.4ex &lt;- log(1:5)*exp(mean(log(1:5)))

all.equal(bc0.4ex, as.numeric(bc0.4e9))


# now invert:  

bc0.4i &lt;- invBoxCox(bc0.4.)

all.equal(1:5, bc0.4i)



all.equal(1:5, invBoxCox(bc0.4e9))


##
## 3.  The "boxcox" function in the MASS package 
##     computes a maximum likelihood estimate with  
##     BoxCox(Days+1, lambda=0.21) 
##     with a 95 percent confidence interval of 
##     approximately (0.08, 0.35)
##
bcDays1 &lt;- BoxCox(MASS::quine$Days, c(0.21, 1))

# check 
GeoMean &lt;- exp(mean(log(abs(MASS::quine$Days+1))))

bcDays1. &lt;- ((((MASS::quine$Days+1)^0.21)-1) / 
               (0.21*GeoMean^(0.21-1)))  
# log(Days+1) ranges from 0 to 4.4 
attr(bcDays1., 'lambda') &lt;- c(0.21, 1)  
attr(bcDays1., 'rescale') &lt;- TRUE 
attr(bcDays1., 'GeometricMean') &lt;- GeoMean 
class(bcDays1.) &lt;- 'BoxCox'


all.equal(bcDays1, bcDays1.)


iDays &lt;- invBoxCox(bcDays1)

all.equal(iDays, MASS::quine$Days)


##
## 4.  Easily computed example 
##
bc2 &lt;- BoxCox(c(1, 4), 2)

# check 
bc2. &lt;- (c(1, 4)^2-1)/4
attr(bc2., 'lambda') &lt;- 2
attr(bc2., 'rescale') &lt;- TRUE 
attr(bc2., 'GeometricMean') &lt;- 2 
class(bc2.) &lt;- 'BoxCox'


all.equal(bc2, bc2.)



all.equal(invBoxCox(bc2), c(1, 4))


##
## 5.  plot(BoxCox())
##
y0 &lt;- seq(-2, 2, .1)
z2 &lt;- BoxCox(y0, 2, rescale=FALSE)
plot(y0, z2)

# check 
z2. &lt;- (sign(y0)*y0^2-1)/2

attr(z2., 'lambda') &lt;- 2
attr(z2., 'sign.y') &lt;- sign(y0, 1)
attr(z2., 'rescale') &lt;- FALSE 
attr(z2., 'GeometricMean') &lt;- 0
class(z2.) &lt;- 'BoxCox'


all.equal(z2, z2.)



all.equal(invBoxCox(z2), y0)


</code></pre>

<hr>
<h2 id='camelParse'>
Split a character string where a capital letter follows a lowercase
letter
</h2><span id='topic+camelParse'></span>

<h3>Description</h3>

<p>Split a character string where a capital letter follows a lowercase
letter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>camelParse(x, except=c('De', 'Mc', 'Mac'))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="camelParse_+3A_x">x</code></td>
<td>

<p>a character vector
</p>
</td></tr>
<tr><td><code id="camelParse_+3A_except">except</code></td>
<td>

<p>character vector giving exceptions:  If any of these are found,
ignore and look for the next one
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Find all places where a lowercase letter is followed by a capital.
</p>
<p>Split on those points
</p>


<h3>Value</h3>

<p>list of character vectors
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strsplit">strsplit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tst &lt;- c('Smith, JohnJohn Smith',
         'EducationNational DefenseOther Committee',
         'McCain, JohnJohn McCain')
tst. &lt;- camelParse(tst)


all.equal(tst., list(c('Smith, John', 'John Smith'),
    c('Education', 'National Defense', 'Other Committee'),
    c('McCain, John', 'John McCain') ) )

</code></pre>

<hr>
<h2 id='canbeNumeric'>
Can a variable reasonably be coerced to numeric?  
</h2><span id='topic+canbeNumeric'></span>

<h3>Description</h3>

<p>Can <code><a href="base.html#topic+seq">seq</a></code> be reasonably applied to 
<code>x</code>?  Returns TRUE if yes and FALSE otherwise.  
</p>
<p>We'd like to use this with, for example, date-time
objects in <code><a href="base.html#topic+as.Date">as.Date</a></code> and 
<code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code> formats.  However, 
<code><a href="base.html#topic+as.numeric">as.numeric</a></code> of such objects is 
<code>FALSE</code>.  Moreover, <code><a href="base.html#topic+as.numeric">as.numeric</a></code> 
of <code><a href="base.html#topic+factor">factor</a></code>s is TRUE.  
</p>
<p>The current algorithm (which may change in the 
future) returns TRUE if 
(<code><a href="base.html#topic+mode">mode</a></code>(x) == 'numeric') &amp; 
(!('levels' %in% names(attributes(x)))).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canbeNumeric(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="canbeNumeric_+3A_x">x</code></td>
<td>

<p>an R object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+logical">logical</a></code> as described above.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mode">mode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Examples adapted from "mode"
##
cex4 &lt;- c('letters[1:4]', "as.Date('2014-01-02')", 
  'factor(letters[1:4])', "NULL", "1", "1:1", "1i", 
  "list(1)", "data.frame(x = 1)","pairlist(pi)", 
  "c", "lm", "formals(lm)[[1]]",  "formals(lm)[[2]]",
  "y ~ x","expression((1))[[1]]", "(y ~ x)[[1]]",
  "expression(x &lt;- pi)[[1]][[1]]")
lex4 &lt;- sapply(cex4, function(x) eval(parse(text = x)))
mex4 &lt;- t(sapply(lex4, function(x) 
    c(typeof(x), storage.mode(x), mode(x), canbeNumeric(x))))
dimnames(mex4) &lt;- list(cex4, 
    c("typeof(.)","storage.mode(.)","mode(.)", 'canbeNumeric(x)'))
mex4

# check 
mex. &lt;- as.character(as.logical(c(0, 1, 0, 0, 1, 1, rep(0, 12))))
names(mex.) &lt;- cex4

all.equal(mex4[,4], mex.)

</code></pre>

<hr>
<h2 id='checkNames'>
Check and return names  
</h2><span id='topic+checkNames'></span>

<h3>Description</h3>

<p>Check and return <code><a href="base.html#topic+names">names</a></code>.  If names are not 
provided or are not unique, write a message and return 
<code><a href="base.html#topic+make.names">make.names</a></code> consistent with <code>warn</code> and 
<code>unique</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkNames(x, warn=0, unique=TRUE, 
   avoid=character(0), 
   message0=head(deparse(substitute(x), 25), 2), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkNames_+3A_x">x</code></td>
<td>

<p>an <span class="rlang"><b>R</b></span> object suitable for <code><a href="base.html#topic+names">names</a></code>  
</p>
</td></tr>
<tr><td><code id="checkNames_+3A_warn">warn</code></td>
<td>

<p>Numeric code for how to treat problems, consistent 
with the argument <code>warn</code> in <code><a href="base.html#topic+options">options</a></code>:  
Negative to ignore, 0 to save and print later, 1 to 
print as they occur, 2 or greater to convert to errors.  
</p>
</td></tr>
<tr><td><code id="checkNames_+3A_unique">unique</code></td>
<td>

<p>logical:  TRUE to check that <code>names(x)</code> are 
unique.  Fix any duplicates with <code><a href="base.html#topic+make.names">make.names</a></code>.   
</p>
</td></tr>
<tr><td><code id="checkNames_+3A_avoid">avoid</code></td>
<td>

<p>a vector of regular expressions to avoid adding in the 
output of <code><a href="base.html#topic+make.names">make.names</a></code> with a companion 
<code>replacement</code> when found.  
</p>
<p>Thus, <code>length(avoid)</code> must be a nonnegative even 
integer, with <code>avoid[2*j-1]</code> providing the 
<code>pattern</code> for <code><a href="base.html#topic+regexpr">regexpr</a></code> and 
<code><a href="base.html#topic+sub">sub</a></code>, and <code>avoid[2*j]</code> providing 
the <code>replacement</code>.  See the second example.      
</p>
</td></tr>
<tr><td><code id="checkNames_+3A_message0">message0</code></td>
<td>

<p>Base to prepend to any message 
</p>
</td></tr>
<tr><td><code id="checkNames_+3A_...">...</code></td>
<td>
 
<p>optional arguments for <code><a href="base.html#topic+make.names">make.names</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  <code>namex &lt;- names(x)</code>  
</p>
<p>2.  Check per <code>warn</code> and <code>unique</code>  
</p>
<p>3.  Return an appropriate version of <code>namex</code>
</p>


<h3>Value</h3>

<p>a character vector of the same length as <code>x</code>.  If any 
problem is found, this character vector will have an 
attribute <code>message</code> describing the problem found.  
Message checking considers <code>unique</code> but ignores 
<code>warn</code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+names">names</a></code>
<code><a href="base.html#topic+make.names">make.names</a></code>
<code><a href="base.html#topic+options">options</a></code> for <code>warn</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  standard operation with no names 
## 
tst1 &lt;- checkNames(1:2)

# check 
tst1. &lt;- make.names(character(2), unique=TRUE)
attr(tst1., 'message') &lt;- paste(
  "1:2:  names = NULL; returning", 
  "make.names(character(length(x))), TRUE)")

all.equal(tst1, tst1.)

##
## 2.  avoid=c('\\.0$', '\\.1$')
##
tst2 &lt;-checkNames(1:2, 
    avoid=c('\\.0$', '.2', 
            '\\.1$', '.3') )

# check 
tst2. &lt;-c('X', 'X.3')
attr(tst2., 'message') &lt;- paste(
  "1:2:  names = NULL; returning", 
  "make.names(character(length(x))), TRUE)")

all.equal(tst2, tst2.)

</code></pre>

<hr>
<h2 id='classIndex'>
Convert class to an integer 1-8 and vice versa 
</h2><span id='topic+classIndex'></span><span id='topic+index2class'></span>

<h3>Description</h3>

<p><code>classIndex</code> converts the class of <code>x</code> to an integer:  
</p>

<ol>
<li><p> NULL
</p>
</li>
<li><p> logical 
</p>
</li>
<li><p> integer 
</p>
</li>
<li><p> numeric
</p>
</li>
<li><p> complex 
</p>
</li>
<li><p> raw 
</p>
</li>
<li><p> character 
</p>
</li>
<li><p> other 
</p>
</li></ol>
  
<p><code>index2class</code> converts an integer back to the 
corresponding class.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classIndex(x)
index2class(i, otherCharacter=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classIndex_+3A_x">x</code></td>
<td>

<p>an object whose class index is desired.  
</p>
</td></tr>
<tr><td><code id="classIndex_+3A_i">i</code></td>
<td>

<p>an integer to be converted to the name of the 
corresponding class 
</p>
</td></tr>
<tr><td><code id="classIndex_+3A_othercharacter">otherCharacter</code></td>
<td>

<p>logical:  TRUE to convert 8 to &quot;character&quot;;  
FALSE to convert 8 to &quot;other&quot;.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html">
Writing R Extensions</a> lists six different kinds of &quot;atomic 
vectors&quot;:  logical, integer, numeric, complex, character,
and raw:  See also 
<a href="http://adv-r.had.co.nz/Data-structures.html">Wickham 
(2013, section on &quot;Atomic vectors&quot; in the chapter on   
&quot;Data structures&quot;)</a>.  These form a standard hierarchy, 
except for &quot;raw&quot;, in that standard operations combining 
objects with different atomic classes will create an 
object of the higher class.  For example, <code>TRUE + 
  2 + pi</code> returns a numeric object ((approximately 
6.141593).  Similarly, <code>paste(1, 'a')</code> returns
the character string &quot;1 a&quot;. 
</p>
<p>For &quot;interpolation&quot;, we might expect users interpolating 
between objects of class &quot;raw&quot; (i.e., bytes) might most 
likely prefer &quot;Numeric&quot; to &quot;Character&quot; interpolation, 
coerced back to type &quot;raw&quot;.  
</p>
<p>The index numbers for the classes run from 1 to 8 to 
make it easy to convert them back from integers to 
character strings.  
</p>


<h3>Value</h3>

<p><code>classIndex</code> returns an integer between 1 and 7 
depending on <code>class(x)</code>.  
</p>
<p><code>index2class</code> returns a character string for the 
inverse transformation.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>References</h3>

<p>Wickham, Hadley (2014) <em>Advanced R</em>, 
especially <a href="http://adv-r.had.co.nz/Data-structures.html">Wickham 
(2013, section on &quot;Atomic vectors&quot; in the chapter on   
&quot;Data structures&quot;)</a>.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interpChar">interpChar</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  classIndex
##
x1 &lt;- classIndex(NULL)
x2 &lt;- classIndex(logical(0))
x3 &lt;- classIndex(integer(1))
x4 &lt;- classIndex(numeric(2))
x5 &lt;- classIndex(complex(3))
x6 &lt;- classIndex(raw(4))
x7 &lt;- classIndex(character(5))
x8 &lt;- classIndex(list())

# check 

all.equal(c(x1, x2, x3, x4, x5, x6, x7, x8), 1:8)


##
## 2.  index2class 
##
c1 &lt;- index2class(1)
c2 &lt;- index2class(2)
c3 &lt;- index2class(3)
c4 &lt;- index2class(4)
c5 &lt;- index2class(5) 
c6 &lt;- index2class(6) 
c7 &lt;- index2class(7)
c8 &lt;- index2class(8)
c8o &lt;- index2class(8, FALSE)

# check 

all.equal(c(c1, c2, c3, c4, c5, c6, c7, c8, c8o), 
          c('NULL', 'logical', 'integer', 'numeric', 
            'complex', 'raw', 'character', 'character', 
            'other'))


</code></pre>

<hr>
<h2 id='compareLengths'>
Compare the lengths of two objects  
</h2><span id='topic+compareLengths'></span>

<h3>Description</h3>

<p>Issue a warning or error if the lengths of two 
objects are not compatible.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareLengths(x, y, 
   name.x=deparse(substitute(x), width.cutoff, 
      nlines=1, ...), 
   name.y=deparse(substitute(y), width.cutoff, 
      nlines=1, ...), 
   message0='', compFun=c('NROW', 'length'), 
   action=c(compatible='', incompatible='warning'), 
   length0=c('compatible', 'incompatible', 'stop'), 
   width.cutoff=20, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareLengths_+3A_x">x</code>, <code id="compareLengths_+3A_y">y</code></td>
<td>

<p>objects whose lengths are to be compared 
</p>
</td></tr>
<tr><td><code id="compareLengths_+3A_name.x">name.x</code>, <code id="compareLengths_+3A_name.y">name.y</code></td>
<td>

<p>names of x and y to use in a message.  Default = 
<code>deparse(substitute(.), width.cutoff, nlines=1)</code>.  
</p>
</td></tr>
<tr><td><code id="compareLengths_+3A_message0">message0</code></td>
<td>

<p>character string to be included with <code>name.x</code>
and <code>name.y</code> in a message.  
</p>
</td></tr>
<tr><td><code id="compareLengths_+3A_compfun">compFun</code></td>
<td>

<p>function to use in the comparison.  
</p>
</td></tr>
<tr><td><code id="compareLengths_+3A_action">action</code></td>
<td>

<p>A character vector of length 2 giving the names 
of functions to call if the lengths are not 
equal but are either 'compatible' or 
'incompatible';  &rdquo; means no action.    
</p>
</td></tr>
<tr><td><code id="compareLengths_+3A_length0">length0</code></td>
<td>

<p>If <code>length(x)</code> or <code>length(y)</code> = 0 
(but not both), treat 
this case as specified by <code>length0</code>.   
</p>
</td></tr>
<tr><td><code id="compareLengths_+3A_width.cutoff">width.cutoff</code></td>
<td>

<p><code>width.cutoff</code> argument to pass to 
<code><a href="base.html#topic+deparse">deparse</a></code>.  This gives the 
maximum number of characters to use in a 
name in error and warning messages.  
</p>
</td></tr>
<tr><td><code id="compareLengths_+3A_...">...</code></td>
<td>
 
<p>optional arguments for <code><a href="base.html#topic+deparse">deparse</a></code> 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  If <code>nchar(name.x)</code> = 0 = 
<code>nchar(name.y)</code>, set <code>name.x &lt;- 'x'</code>, 
<code>name.y &lt;- 'y'</code>, and append 
'in <code>compareLengths</code>:' to <code>message0</code> 
for more informative messaging.  
</p>
<p>2.  <code>lenx &lt;- do.call(compFun, list(x))</code>;  
<code>leny &lt;- do.call(compFun, list(y))</code>
</p>
<p>3.  <code>if(lenx==leny)return(c('equal', ''))</code>
</p>
<p>4.  Compatible?  
</p>
<p>5.  Compose the message.  
</p>
<p>6.  &quot;action&quot;, as indicated 
</p>


<h3>Value</h3>

<p>A character vector of length 2.  The first 
element is either 'equal', 'compatible' or 
'incompatible'.  The second element is the 
message composed.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves with help from Duncan Murdoch 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interpChar">interpChar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  equal 
##

all.equal(compareLengths(1:3, 4:6), c("equal", ''))


##
## 2.  compatible 
##
a &lt;- 1:2
b &lt;- letters[1:6]
comp.ab &lt;- compareLengths(a, b, message0='Chk:')
comp.ba &lt;- compareLengths(b, a, message0='Chk:')
# check 
chk.ab &lt;- c('compatible', 
            'Chk: length(b) = 6 is 3 times length(a) = 2')

all.equal(comp.ab, chk.ab) 


all.equal(comp.ba, chk.ab) 


##
## 3.  incompatible 
##
Z &lt;- LETTERS[1:3]
comp.aZ &lt;- compareLengths(a, Z)
# check 
chk.aZ &lt;- c('incompatible', 
    ' length(Z) = 3 is not a multiple of length(a) = 2')

all.equal(comp.aZ, chk.aZ) 

##
## 4.  problems with name.x and name.y 
##
comp.ab2 &lt;- compareLengths(a, b, '', '')
# check 
chk.ab2 &lt;- c('compatible', 
             'in compareLengths: length(y) = 6 is 3 times length(x) = 2')

all.equal(comp.ab2, chk.ab2) 

##
## 5.  zeroLength 
##
zeroLen &lt;- compareLengths(logical(0), 1) 
# check 
zeroL &lt;- c('compatible', ' length(logical(0)) = 0')

all.equal(zeroLen, zeroL)

</code></pre>

<hr>
<h2 id='compareOverlap'>
Compare y between newDat and 
refDat for shared values of x
</h2><span id='topic+compareOverlap'></span>

<h3>Description</h3>

<p>Compute 
<code>dy &lt;- (y - yRef)</code> for all 
cases where <code>x == xRef</code>, 
where <code>x</code> and <code>y</code> are 
columns of <code>newDat</code> and 
<code>xRef</code> and <code>yRef</code> are 
columns of <code>refDat</code>.  
</p>
<p>Also compute 
<code>dyRef &lt;- dy / yRef</code>.  
</p>
<p>Return silently a 
<code>data.frame</code> with columns 
<code>x</code>, <code>y</code>, <code>yRef</code>, 
<code>dy</code>, and <code>dyRef</code>. 
</p>
<p>Also if 
<code>min(yRef)*max(yRef)&gt;0</code> 
<code>plot(dyRef)</code> else
<code>plot(dy)</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareOverlap(y=2, yRef=y, x=1, 
      xRef=x, newDat, refDat, 
      ignoreCase=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareOverlap_+3A_y">y</code>, <code id="compareOverlap_+3A_yref">yRef</code></td>
<td>

<p>columns of <code>newDat</code>, 
<code>refDat</code>, respectively, 
to compare, ignoring case in the 
names unless <code>ignoreCase</code> is 
<code>FALSE</code>.  
</p>
</td></tr>
<tr><td><code id="compareOverlap_+3A_x">x</code>, <code id="compareOverlap_+3A_xref">xRef</code></td>
<td>

<p>columns of <code>newDat</code>, 
<code>refDat</code>, respectively, 
to match when comparing 
<code>y</code> with <code>yRef</code>.
</p>
<p>As with <code>y</code> and <code>yRef</code>, 
ignore case in name matching 
unless <code>ignoreCase</code> is 
<code>FALSE</code>.  
</p>
</td></tr>
<tr><td><code id="compareOverlap_+3A_newdat">newDat</code>, <code id="compareOverlap_+3A_refdat">refDat</code></td>
<td>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code>s of new 
and reference data in which to 
search for overlap, i.e., common 
values of <code>newD[, x]</code> and 
<code>refDat[, xRef]</code>, and for 
those observations to compare 
<code>newDat[, y]</code> to 
<code>refDat[, yRef]</code>.  
</p>
</td></tr>
<tr><td><code id="compareOverlap_+3A_ignorecase">ignoreCase</code></td>
<td>

<p>logical:  If <code>TRUE</code>, 
ignore case when searching 
for columns of <code>newDat</code> 
and <code>refDat</code> to match 
<code>y</code>, <code>yRef</code>, 
<code>x</code>, and <code>xRef</code>.
</p>
</td></tr>
<tr><td><code id="compareOverlap_+3A_...">...</code></td>
<td>

<p>optional arguments to pass 
to <code>plot</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly useful 
for updating datasets that are obtained 
from sources like the 
<a href="https://bjs.ojp.gov">Bureau of Justice Statistics</a>, 
which publish many series with 
each update including the most recent 
11 years.  This function can be used 
to evaluate the extent of equivalence
between, e.g., historical data in 
<code>refDat</code> with the latest data
in <code>newDat</code>.
</p>


<h3>Value</h3>

<p>Invisibly return a 
<code>data.frame</code> with columns 
<code>x</code>, <code>paste0(y, 'New')</code>, 
<code>past0(yRef, 'Ref')</code>, 
<code>dy</code>, and <code>dyRef</code>
of the data compared.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>Examples</h3>

<pre><code class='language-R'>nDat &lt;- data.frame(yr=2000:2015, 
          Y=0:15)
rDat &lt;- data.frame(Yr=2018:2011, 
          y=c(17:13, 13:11))
nrDat &lt;- compareOverlap(
  newDat=nDat, refDat=rDat)

# Correct answer
NRdat &lt;- data.frame(yr=2011:2015, 
  YNew=11:15, yRef=c(11:13, 13:14), 
  dy=c(0,0,0, 1, 1), 
  dyRef=c(0,0,0, 1,1) / 
        c(11:13, 13:14))


all.equal(nrDat, NRdat)

</code></pre>

<hr>
<h2 id='confint.var'>
Confidence interval for sample variance or 
standard deviation 
</h2><span id='topic+confint.var'></span><span id='topic+confint.sd'></span>

<h3>Description</h3>

<p>Computes the standard normal (i.e., chi-square)
confidence intervals for a sample variance or 
standard deviation.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'var'
confint(object, parm, level=0.95, ...) 
## S3 method for class 'sd'
confint(object, parm, level=0.95, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.var_+3A_object">object</code></td>
<td>

<p>a numeric vector possibly with a <code>df</code> 
or <code>df.residuals</code> attribute assumed to 
represent a sample variance, possibly 
computed as root mean square of residuals
from a model.  
</p>
</td></tr>
<tr><td><code id="confint.var_+3A_parm">parm</code></td>
<td>

<p>degrees of freedom in the estimated 
variance or standard deviation.  
</p>
</td></tr>
<tr><td><code id="confint.var_+3A_level">level</code></td>
<td>

<p>the confidence level required
</p>
</td></tr>
<tr><td><code id="confint.var_+3A_...">...</code></td>
<td>

<p>optional arguments not used.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  If <code>object</code> is not numeric, throw
an error.  
</p>
<p>2.  If <code>parm</code> is missing, look for an 
attribute of <code>object</code> starting with 
<code>df</code>.  If present, use that for 
<code>parm</code>.  If <code>parm</code> is absent or 
not numeric, throw an error.  
</p>
<p>3.  replicate <code>object</code>, <code>parm</code>, and 
<code>level</code> to the same length.  Issue a warning 
if the longest is not a multiple of the others.  
</p>
<p>4.  <code>alph2 &lt;- (1-level)/2</code> 
</p>
<p>5.  <code>Qntls &lt;- cbind(lower=qchisq(alph2, parm, 
  lower=FALSE), upper=qchisq(alph2, parm))</code> 
</p>
<p>6.  <code>CI &lt;- (object*parm/Qntls)</code>
</p>
<p>7.  <code>attr(CI, 'level') &lt;-</code> Level
</p>
<p>7.  return(CI)
</p>


<h3>Value</h3>

<p>a matrix with columns &quot;lower&quot; and &quot;upper&quot;, 
<code>nrow</code> = the longest of the lengths 
of <code>object</code>, <code>parm</code>, and <code>level</code>, 
and an attribute &quot;level&quot;.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Standard_deviation">
Wikipedia, &quot;Standard deviation&quot;</a>, accessed 
2016-07-06. 
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor.test">cor.test</a></code>, 
<code><a href="DescTools.html#topic+VarCI">VarCI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  simple examples 
##
(CI.v &lt;- confint.var(c(1,1,4), c(1, 9, 9))) 
(CI.s &lt;- confint.sd(c(1,1,2), c(1, 9, 9))) 

# Compare with the examples on Wikipedia

all.equal(CI.s, sqrt(CI.v))


WikipEx &lt;- t(matrix(c(0.45, 31.9, 0.69, 1.83, 1.38, 3.66), 
                  nrow=2))
colnames(WikipEx) &lt;- c('lower', 'upper')

(dCI &lt;- (CI.s-WikipEx))
#Confirm within 2-digit roundoff

max(abs(dCI))&lt;0.0102


##
## 2.  test df attributes
##
v &lt;- c(1,1,4)
attr(v, 'df.') &lt;- c(1, 9, 9)
class(v) &lt;- 'var'
vCI &lt;- confint(v)

# check 

all.equal(vCI, CI.v)


s &lt;- sqrt(v)
class(s) &lt;- 'sd'
sCI &lt;- confint(s)

# check 

all.equal(sCI, CI.s)


</code></pre>

<hr>
<h2 id='countByYear'>
Allocate a total by year  
</h2><span id='topic+countByYear'></span>

<h3>Description</h3>

<p>Allocate <code>total</code> to <code>countByYear</code>
for a constant count per day between <code>start</code>
and <code>end</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countByYear(start, end, total=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countByYear_+3A_start">start</code>, <code id="countByYear_+3A_end">end</code></td>
<td>

<p>objects of class &quot;Date&quot; specifying the start, end, 
respectively, of the event 
</p>
</td></tr>
<tr><td><code id="countByYear_+3A_total">total</code></td>
<td>

<p>A number to be allocated by year in proportion to 
the number of days in the event each year.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector whose <code><a href="base.html#topic+sum">sum</a></code> is 
<code>total</code> with names for all the years between 
<code>start</code> and <code>end</code> 
</p>


<h3>Author(s)</h3>

<p>Spencer Graves 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  All in one year
##
start73 &lt;- as.Date('1973-01-22')
tst1 &lt;- countByYear(start73, start73+99, 123)

# check 
tst1. &lt;- 123
names(tst1.) &lt;- 1973

all.equal(tst1, tst1.)


##
## 2.  Two years 
##
tst2 &lt;- countByYear(start73, start73+365, 123) 

# check 
dur &lt;- 366
days1 &lt;- (365-21)
days2 &lt;- 22
tst2. &lt;- 123 * c(days1, days2)/dur 
names(tst2.) &lt;- 1973:1974 

all.equal(tst2, tst2.)


##
## 3.  Ten years 
## 
tst10 &lt;- countByYear(start73, start73+10*365.2, 123)

# check 
days &lt;- (c(rep(c(rep(365, 3), 366), length=10), 0)
         + c(-21, rep(0, 9), 22) )
tst10. &lt;- 123 * days/(10*365.2+1) 
names(tst10.) &lt;- 1973:1983 


all.equal(tst10, tst10.)

          
</code></pre>

<hr>
<h2 id='countsByYear'>
Allocate totals by year  
</h2><span id='topic+countsByYear'></span>

<h3>Description</h3>

<p>Allocate <code>total</code> to <code>countByYear</code>
for a constant count per day between <code>start</code>
and <code>end</code> for multiple events.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countsByYear(data, start="Start1", end='End1', 
             total='BatDeath', event='WarName', 
             endNA=max(data[, c(start,end)]))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countsByYear_+3A_data">data</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with columns 
<code>start</code>, <code>end</code>, and <code>total</code>
</p>
</td></tr>
<tr><td><code id="countsByYear_+3A_start">start</code>, <code id="countsByYear_+3A_end">end</code></td>
<td>

<p>columns of <code>data</code> of class <code>Date</code>
with <code>start</code> &lt;= <code>end</code> during which 
<code>total</code> is to be allocated 
</p>
</td></tr>
<tr><td><code id="countsByYear_+3A_total">total</code></td>
<td>

<p>A quantity to be allocated by year giving 
a constant rate per day.  
</p>
</td></tr>
<tr><td><code id="countsByYear_+3A_event">event</code></td>
<td>

<p>name of the event whose total is to be allocated.  
</p>
</td></tr>
<tr><td><code id="countsByYear_+3A_endna">endNA</code></td>
<td>

<p>Date to use if <code>is.na(data[, end])</code>.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric <code><a href="base.html#topic+matrix">matrix</a></code> whose 
<code><a href="base.html#topic+colSums">colSums</a></code> match <code>total</code> with names 
for all the years between <code>start</code> and <code>end</code>.  
The number of columns of the output matrix match the 
number of rows of <code>data</code>.  The
<code><a href="base.html#topic+colSums">colSums</a></code> match <code>total</code>.   
</p>


<h3>Author(s)</h3>

<p>Spencer Graves 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  data.frame(WarName, Start1, End1, BatDeath)
##
start73 &lt;- as.Date('1973-01-22')
tstWars &lt;- data.frame(WarName=c('short', '2yr', '10yr'), 
    Start1=c(start73, start73+365, start73-365), 
    End1=start73+c(99, 2*365, NA), 
    BatDeath=c(100, 123, 456)) 
##
## 2.  do
##
deathsByYr &lt;- countsByYear(tstWars, 
              endNA=start73+9*365.2)

# check 
Counts &lt;- matrix(0, 11, 3, 
    dimnames=list(c(1972:1982), tstWars$WarName) )
Counts['1973', 1] &lt;- 100
Counts[as.character(1974:1975), 2] &lt;- with(tstWars, 
    countByYear(Start1[2], End1[2], BatDeath[2]) )
Counts[as.character(1972:1982), 3] &lt;- with(tstWars, 
    countByYear(Start1[3], start73+9*365.2, BatDeath[3]) )


all.equal(deathsByYr, Counts)

  
</code></pre>

<hr>
<h2 id='createMessage'>
Compose a message as a single substring from 
a character vector 
</h2><span id='topic+createMessage'></span>

<h3>Description</h3>

<p>This is a utility function to make it easier 
to automatically compose informative error 
and warning messages without using too many 
characters.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createMessage(x, width.cutoff=45, default='x', 
      collapse='; ', endchars='...')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createMessage_+3A_x">x</code></td>
<td>

<p>input for <code><a href="base.html#topic+paste">paste</a></code>
</p>
</td></tr>
<tr><td><code id="createMessage_+3A_width.cutoff">width.cutoff</code></td>
<td>

<p>maximum number of characters from x to 
return in a single string.  This differs 
from the <code>width.cutoff</code> argument in 
<code><a href="base.html#topic+deparse">deparse</a></code> in that the output 
included here considers <code>endchars</code>, 
not part of <code><a href="base.html#topic+deparse">deparse</a></code>.  
</p>
</td></tr>
<tr><td><code id="createMessage_+3A_default">default</code></td>
<td>

<p>character string to return if 
<code>nchar(x)</code> = 0.  
</p>
</td></tr>
<tr><td><code id="createMessage_+3A_collapse">collapse</code></td>
<td>

<p><code>collapse</code> argument for 
<code><a href="base.html#topic+paste">paste</a></code> 
</p>
</td></tr>
<tr><td><code id="createMessage_+3A_endchars">endchars</code></td>
<td>

<p>a character string to indicate that part 
of the input string(s) was truncated.      
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x. &lt;- paste(..., collapse='; ')
  nchx &lt;- nchar(x.)
  maxch &lt;- (maxchar-nchar(endchars))
  if(nchx&gt;maxch){
    x2 &lt;- substring(x., 1, maxch)
    x. &lt;- paste0(x2, endchar)
  }</code>
</p>


<h3>Value</h3>

<p>a character string with at most 
<code>width.cutoff</code> characters.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+paste">paste</a></code>
<code><a href="base.html#topic+substr">substr</a></code>
<code><a href="base.html#topic+nchar">nchar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  typical use 
##
tstVec &lt;- c('Now', 'is', 'the', 'time')
msg &lt;- createMessage(tstVec, 9, collapse=':', 
                     endchars='//')

all.equal(msg, 'Now:is://')

##
## 2.  in a function 
##
tstFn &lt;- function(cl)createMessage(deparse(cl), 9)
Cl &lt;- quote(plot(1:3, y=4:6, col='red', main='Title'))
msg0 &lt;- tstFn(Cl)
# check 
msg. &lt;- 'plot(1...'

all.equal(msg0, msg.)


##
## 3.  default 
##
y &lt;- createMessage(character(3), default='y') 

all.equal(y, 'y')


</code></pre>

<hr>
<h2 id='createX2matchY'>
Create X to match Y 
</h2><span id='topic+createX2matchY'></span>

<h3>Description</h3>

<p>Return a default object of class 
<code>index2class(max(classIndex(x), classIndex(y)))</code> 
and length = length(y).  
</p>
<p>For example, suppose <code>class(x)</code> == 'numeric', for which
<code>classIndex</code> = 4.  If <code>class(y)</code> = 'integer', then 
an object of class 'numeric' is returned.  However, if 
<code>class(y)</code> = 'character', then an object of class 
'character' is returned.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createX2matchY(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createX2matchY_+3A_x">x</code>, <code id="createX2matchY_+3A_y">y</code></td>
<td>

<p>objects of possibly different classes and lengths.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as <code>y</code> whose class is 
<code>index2class(max(classIndex(x), classIndex(y)))</code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>See Also</h3>

<p><code><a href="#topic+interpPairs">interpPairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  NULL 
## -
null &lt;- createX2matchY(NULL, NULL)
# check 

all.equal(null, NULL)

##
## 2.  logical 
##
lgcl3 &lt;- createX2matchY(NULL, 
           c(FALSE, TRUE, FALSE))

# check 

all.equal(lgcl3, logical(3))


##
## 3.  integer
##
int3 &lt;- createX2matchY(integer(0), 
           c(FALSE, TRUE, FALSE))
# check 

all.equal(int3, integer(3))


##
## 4.  list -&gt; character
##
ch3 &lt;- createX2matchY(integer(0), 
         list(a=1, b=2, c=3))
# check 

all.equal(ch3, character(3))

</code></pre>

<hr>
<h2 id='Date3to1'>
Convert three YMD vectors to a Date 
</h2><span id='topic+Date3to1'></span>

<h3>Description</h3>

<p>Given a <code><a href="base.html#topic+data.frame">data.frame</a></code> with 3 columns, 
assume they represent Year, Month and Day and 
return a vector of class <code>Date</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Date3to1(data, default='Start')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Date3to1_+3A_data">data</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with 3 columns 
assumed to represent Year, Month and Day.    
</p>
</td></tr>
<tr><td><code id="Date3to1_+3A_default">default</code></td>
<td>

<p>A character string to indicate how missing 
months and days should be treated.  If the 
first letter is &quot;S&quot; or &quot;s&quot;, the default 
month will be 1 and the default day will be 
1.  Otherwise, &quot;End&quot; is assumed, for which 
the default month will be 12 and the default 
day will be the last day of the month.  
</p>
<p>NOTE:  Any number outside the range of 1 to 
the last day of the month is considered 
missing and its subscript is noted in the 
optional attribute &quot;missing&quot;.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data sets from the 
<a href="https://correlatesofwar.org/data-sets/COW-war/">Correlates 
of War</a> project include dates coded in triples 
of columns with names like 
</p>
<p><code>c("StartMonth1", "StartDay1", "StartYear1",
  "EndMonth1", ..., "EndYear2")</code>.  
</p>
<p>This function will accept one triple and
translate it into a vector of class <code>Date</code>. 
</p>


<h3>Value</h3>

<p>Returns an object of class <code>Date</code> with an 
optional attribute <code>missing</code> giving the 
indices of any elements with missing months or 
days, for which a default month or day was 
supplied.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dateCols">dateCols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date.frame &lt;- data.frame(Year=c(NA, -1, 1971:1979), 
      Month=c(1:2, -1, NA, 13, 2, 12, 6:9), 
      Day=c(0, 0:6, NA, -1, 32) )
     
DateVecS &lt;- Date3to1(date.frame)
DateVecE &lt;- Date3to1(date.frame, "End")
                         
# check 
na &lt;- c(1:5, 9:11)
DateVs &lt;- as.Date(c(NA, NA, 
  '1971-01-01', '1972-01-01', '1973-01-01', 
  '1974-02-04', '1975-12-05', '1976-06-06', 
  '1977-07-01', '1978-08-01', '1979-09-01') ) 
DateVe &lt;- as.Date(c(NA, NA, 
  '1971-12-31', '1972-12-31', '1973-12-31', 
  '1974-02-04', '1975-12-05', '1976-06-06', 
  '1977-07-31', '1978-08-31', '1979-09-30') ) 

attr(DateVs, 'missing') &lt;- na
attr(DateVe, 'missing') &lt;- na


all.equal(DateVecS, DateVs)


all.equal(DateVecE, DateVe)

</code></pre>

<hr>
<h2 id='dateCols'>
Identify YMD names in a character vector
</h2><span id='topic+dateCols'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+grep">grep</a></code> for YMD (year, month, day) in 
<code>col.names</code>.  Return a named list of integer 
vectors of length 3 for each triple found.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dateCols(col.names, YMD=c('Year', 'Month', 'Day'))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dateCols_+3A_col.names">col.names</code></td>
<td>

<p>either a character vector in which to search 
for names matching <code>YMD</code> or an object 
with non-null <code>colnames</code> 
</p>
</td></tr>
<tr><td><code id="dateCols_+3A_ymd">YMD</code></td>
<td>

<p>a character vector of patterns to use in 
<code><a href="base.html#topic+grep">grep</a></code> to identify triples of 
columns coding <code>YMD</code> in 
<code>col.names</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data sets from the 
<a href="https://correlatesofwar.org/data-sets/COW-war/">Correlates 
of War</a> project include dates coded in 
triples of columns with names like 
<code>c("StartMonth1", "StartDay1", 
  "StartYear1", "EndMonth1", ..., "EndYear2")</code>.  
This function will find all relevant date 
triples in a character vector of column names 
and return a list of integer vectors of 
length 3 with names like 
<code>"Start1", "End1", ..., "End2"</code> giving 
the positions in <code>col.names</code> of the 
desired date components.  
</p>
<p>Algorithm:  
</p>
<p>1.  <code>if(!is.null(colnames(YMD)))YMD &lt;- 
  colnames(YMD)</code>
</p>
<p>2.  <code>ymd</code> &lt;- <code><a href="base.html#topic+grep">grep</a></code> for YMD 
(Year, Month, Day) in <code>col.names</code>.
</p>
<p>3.  <code>groupNames</code> &lt;- <code><a href="base.html#topic+sub">sub</a></code> 
<code>pattern</code> with &rdquo; in <code>ymd</code>
</p>
<p>4.  Throw a <code><a href="base.html#topic+warning">warning</a></code> for any 
<code>groupNames</code> character string that 
does not appear with all three of Year, 
Month, and Day.  
</p>
<p>5.  Return a list of integer vectors of 
length 3 for each triple found.  
</p>


<h3>Value</h3>

<p>Returns a named list of integer vectors 
of length 3 identifying the positions in 
<code>col.names</code> of the desired date 
components.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Date3to1">Date3to1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  character vector 
##
colNames &lt;- c('war', 'StartMonth1', 
      'StartDay1', 'StartYear1', 
      'EndMonth1', 'EndMonth2', 
      'EndDay2', 'EndYear2', 'Initiator')

colNums &lt;- dateCols(colNames)
# Should issue a warning:  
# Warning message:
# In dateCols(colNames) :
#   number of matches for Year = 2 
#   != number of matches for Month = 3

# check 
colN &lt;- list(Start1=c(Year=4, Month=2, Day=3), 
             End2=c(Year=8, Month=6, Day=7) )

all.equal(colNums, colN)

##
## 2.  array 
##
A &lt;- matrix(ncol=length(colNames), 
      dimnames=list(NULL, colNames))

Anums &lt;- dateCols(A)

# check 

all.equal(Anums, colN)

</code></pre>

<hr>
<h2 id='Dates3to1'>
Convert 3-column dates in data to class Date 
</h2><span id='topic+Dates3to1'></span>

<h3>Description</h3>

<p>Return a <code><a href="base.html#topic+data.frame">data.frame</a></code> with columns of 
class &quot;Date&quot; replacing all 3-column dates.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dates3to1(data, YMD=c('Year', 'Month', 'Day'))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dates3to1_+3A_data">data</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> assumed to include 
dates coded in three column sets with names 
matching <code>YMD</code>.  
</p>
</td></tr>
<tr><td><code id="Dates3to1_+3A_ymd">YMD</code></td>
<td>

<p>a character vector of length 3 of patterns to use 
in <code><a href="base.html#topic+grep">grep</a></code> to identify triples of 
columns coding <code>YMD</code> in 
<code>col.names(data)</code>.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data sets from the 
<a href="https://correlatesofwar.org/data-sets/COW-war/">Correlates 
of War</a> project include dates coded in triples of
columns with names like <code>c("StartMonth1",
  "StartDay1", "StartYear1", "EndMonth1", ...,
  "EndYear2")</code>.  This function will accept a 
<code>data.frame</code> obtained via 
<code><a href="utils.html#topic+read.csv">read.csv</a></code> of such a file and replace
each such triple with a singe column of class 'Date'
combining the triple appropriately.  
</p>


<h3>Value</h3>

<p>Return a <code>data.frame</code> containing the
information in <code>data</code> reformatted as described
above.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dateCols">dateCols</a></code>
<code><a href="#topic+Date3to1">Date3to1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cow0 &lt;- data.frame(rec=1:3, startMonth=4:6, startDay=7:9, 
    startYear=1971:1973, endMonth1=10:12, endDay1=13:15, 
    endYear1=1974:1976, txt=letters[1:3])

cow0. &lt;- Dates3to1(cow0)

# check 
cow0x &lt;- data.frame(rec=1:3, txt=letters[1:3], 
    start=as.Date(c('1971-04-07', '1972-05-08', '1973-06-09')), 
    end1=as.Date(c('1974-10-13', '1975-11-14', '1976-12-15')) )


all.equal(cow0., cow0x)

</code></pre>

<hr>
<h2 id='deletedFunctions'>
Functions deleted from the Ecfun package
</h2><span id='topic+deletedFunctions'></span><span id='topic+readFinancialCrisisFiles'></span><span id='topic+readCookPVI'></span><span id='topic+readCookPVI.'></span><span id='topic+readUShouse'></span><span id='topic+readUSsenate'></span><span id='topic+readUSstateAbbreviations'></span><span id='topic+UShouse.senate'></span><span id='topic+USsenateClass'></span><span id='topic+mergeUShouse.senate'></span>

<h3>Description</h3>

<p>Several functions were deleted from <code>Ecfun</code> 
0.2-5, because they no longer worked, and 
it was not clear if there was demand for 
them.  
</p>
<p>If you need them, you can get the 
documentation and code for them from CRAN 
&gt; Packages &gt; Archive (near the bottom 
center) &gt; <code>Ecfun</code> &gt; 
<code>Ecfun_0.2-0.tar.gz</code>.  
I don't expect the code to work.  
However, I might be willing to 
collaborate in restoring the 
functionality to <code>Ecfun</code>.  
</p>
<p><code>readFinancialCrisisFiles</code>
was a companion to a book.  This 
function required the <code>gdata</code>
package, which was scheduled to be 
removed from CRAN.  
</p>
<p><code>USsenateClass</code> called by default 
<code>readUSsenate</code>.  <code>UShouse.senate</code> 
and <code>mergeUShouse.senate</code> called by 
default both <code>readUSsenate</code> and 
<code>readUShouse</code>.  The latter two and the 
remaining functions deleted did web scraping, 
and the web sites from which they scraped 
information changed, and it did not seem worth 
the work required to continue to maintain them.  
</p>

<hr>
<h2 id='findCountry'>
Find a 3-letter country code in rworldmap::countrySynonyms
</h2><span id='topic+findCountry'></span>

<h3>Description</h3>

<p>Search for a specific country name on 8 different columns 
of alternative names in 
<code><a href="rworldmap.html#topic+countrySynonyms">countrySynonyms</a></code>. Return either a 
3-character code or a longer character string saying, e.g., 
&quot;No match found for country&quot; followed by the name of the 
country not found. 
</p>
<p>NOTE: This code will be offered to the 
maintainer of the <code>rworldmap</code> package. If they
like it, it may not stay in <code>Ecfun</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findCountry(string, referenceTable = 
        rworldmap::countrySynonyms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findCountry_+3A_string">string</code></td>
<td>
 
<p>Character vector of strings to look for matches in 
<code>rworldmap::countrySynonyms[, 3:10]</code>. 
</p>
</td></tr>
<tr><td><code id="findCountry_+3A_referencetable">referenceTable</code></td>
<td>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code> with the second column
containing reference codes to be returned if found. 
<code>referencTable[-(1:2)]</code> are forced 
<code><a href="base.html#topic+toupper">toupper</a></code> then presented in sequence
in <code><a href="base.html#topic+grep">grep</a></code> until a match for 
<code>pattern = toupper(string[i])</code> is found. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1. Force <code>string</code> and 
<code>rworldmap::countrySynonyms[, 3:10]</code>
<code><a href="base.html#topic+toupper">toupper</a></code>. 
</p>
<p>2. <code><a href="base.html#topic+grep">grep</a></code> for <code>string[i]</code> in 
<code>rworldmap::countrySynonyms[, 3:10]</code> and
return the element of 
<code>rworldmap::countrySynonyms$ISO3</code>
that corresponds to anything found if it's 
3 characters and an appropriate message 
otherwise. 
</p>


<h3>Value</h3>

<p>A character of 3-character codes or longer 
not-found messages with names = <code>string</code>. 
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="base.html#topic+toupper">toupper</a></code>, 
<code><a href="rworldmap.html#topic+countrySynonyms">countrySynonyms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tstCodes &lt;- findCountry(
    c('Iran', 'Christmas Island', 'eSwatini'))
    
answer &lt;- c(Iran='IRN', 
  'Christmas Island'="referenceTable[53, 2] = ''", 
  'eSwatini'="No match found for country eSwatini")    


all.equal(tstCodes, answer)

</code></pre>

<hr>
<h2 id='getElement2'>
Extract a named element from an object with 
a default
</h2><span id='topic+getElement2'></span>

<h3>Description</h3>

<p>Get element <code>name</code> of <code>object</code>.  
If <code>object</code> does not have an element 
<code>name</code>, return <code>default</code>.
</p>
<p>If the <code>name</code> element of <code>object</code> 
is <code>NULL</code> the result depends on 
<code>warn.NULL</code>:  If <code>TRUE</code>, issue a 
warning and return <code>default</code>.  Otherwise, 
return <code>NULL</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getElement2(object, name=1, default=NA, 
      warn.NULL=TRUE, envir=list(), returnName)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getElement2_+3A_object">object</code></td>
<td>

<p>object from which to extract component 
<code>name</code>.
</p>
</td></tr>
<tr><td><code id="getElement2_+3A_name">name</code></td>
<td>

<p>Name or index of the element to extract
</p>
</td></tr>
<tr><td><code id="getElement2_+3A_default">default</code></td>
<td>

<p>default value if <code>name</code> is not part 
of <code>object</code>.
</p>
</td></tr>  
<tr><td><code id="getElement2_+3A_warn.null">warn.NULL</code></td>
<td>

<p>logical to decide how to treat cases where 
<code>object</code> has a component <code>name</code>:  
If <code>TRUE</code>, return <code>default</code> with 
a warning.  Otherwise, return <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="getElement2_+3A_envir">envir</code></td>
<td>

<p>Supplemental list beyond <code>object</code> in 
which to look for names in case 
<code>object[[name]]</code> is a language object 
that must be evaluated.
</p>
</td></tr>
<tr><td><code id="getElement2_+3A_returnname">returnName</code></td>
<td>

<p>logical:  <code>TRUE</code> to return 
<code><a href="base.html#topic+as.character">as.character</a></code> of any 
<code><a href="base.html#topic+name">name</a></code> found as an element of 
<code>object</code>.  
</p>
<p><code>FALSE</code> to <code><a href="base.html#topic+eval">eval</a></code> any 
<code><a href="base.html#topic+name">name</a></code> found in the environment 
of  <code>object</code>.  
</p>
<p>Default = <code>TRUE</code> if <code>name</code> == 1 or 
a character string matching the name of the 
first element of <code>object</code>.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  <code>If is.numeric(name) In &lt;- 
  (1 &lt;= name &lt;= length(object))</code> 
</p>
<p>2.  <code>else In &lt;- if(name %in% names(object))</code>
</p>
<p>3.  <code>El &lt;- if(In) object[[name]] else default</code> 
</p>
<p>4.  <code>warn.NULL</code>? 
</p>
<p>5.  <code>if(returnName) return(as.character(El)) 
  else return(eval(El, envir=object))</code>
</p>


<h3>Value</h3>

<p>an object of the form of <code>object[[name]]</code>;  
if <code>object</code> does not have an element or 
slot <code>name</code>, return <code>default</code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves with help from Marc Schwartz and 
Hadley Wickham
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+getElement">getElement</a></code>, which also can return 
slots from S4 objects.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  name in object, return 
##
e1 &lt;- getElement2(list(ab=1), 'ab', 2) # 1
# check 

all.equal(e1, 1)


##
## 2.  name not in object, return default
##
eNA &lt;- getElement2(list(), 'ab') # default default = NA
# check 

all.equal(eNA, NA)


e0 &lt;- getElement2(list(), 'ab', 2) # name not in object

all.equal(e0, 2)


e2 &lt;- getElement2(list(ab=1), 'a', 2) # partial matching not used 

all.equal(e2, 2)


##
## 3.  name NULL in object, return default 
##
ed &lt;- getElement2(list(a=NULL), 'a',2) # 2 with a warning

all.equal(ed, 2)


e. &lt;- getElement2(list(a=NULL), 'a', 2, warn.NULL=FALSE) # NULL

all.equal(e., NULL)


eNULL &lt;- getElement2(list(a=NULL), 'a', NULL) # NULL

all.equal(eNULL, NULL)


##
## 4.  Language:  find, eval, return 
##
Qte &lt;- quote(plot(1:4, y=x, col=c2))
if(require(pryr)){ 
  Qt &lt;- pryr::standardise_call(Qte) # add the name 'x' 
  fn &lt;- getElement2(Qt)
  eQuote &lt;- getElement2(Qt, 'y')
  Col2 &lt;- getElement2(Qt, 'col', envir=list(c2=2))
# check

  all.equal(fn, 'plot')


  all.equal(eQuote, 1:4)


  all.equal(Col2, 2)

}
</code></pre>

<hr>
<h2 id='grepNonStandardCharacters'>
grep for nonstandard characters
</h2><span id='topic+grepNonStandardCharacters'></span>

<h3>Description</h3>

<p>Return the indices of elements of <code>x</code>
containing characters that are not in 
<code>standardCharacters</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grepNonStandardCharacters(x, value=FALSE,
   standardCharacters=c(letters, LETTERS, ' ',
    '.', ',',  0:9, '\"', "\'", '-', '_', '(', 
    ')', '[', ']', '\n'),
   ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grepNonStandardCharacters_+3A_x">x</code></td>
<td>

<p>character vector in which it is desired to 
identify elements containing characters not 
in <code>standardCharacters</code>.
</p>
</td></tr>
<tr><td><code id="grepNonStandardCharacters_+3A_value">value</code></td>
<td>

<p>logical:  
<code>TRUE</code> to return the values found in
<code>x</code>, <code>FALSE</code> to return their 
indices.
</p>
</td></tr>
<tr><td><code id="grepNonStandardCharacters_+3A_standardcharacters">standardCharacters</code></td>
<td>

<p>Characters to overlook in <code>x</code> to 
identify anything not in 
<code>standardCharacters</code>.
</p>
</td></tr>
<tr><td><code id="grepNonStandardCharacters_+3A_...">...</code></td>
<td>
 
<p>optional arguments for 
<code><a href="base.html#topic+regexpr">regexpr</a></code> 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  <code>x. &lt;- strsplit(x, '')</code>:  convert 
the input character vector to a list of 
vectors of character vectors with 
<code>nchar(x.[i])</code> == 1 for i in 
1:<code>length(x)</code>.
</p>
<p>2.  <code>sapply(x., ...)</code> to identify all 
elements for which any element of x[[i]] is 
not in <code>standardCharacters</code>.
</p>


<h3>Value</h3>

<p>an integer vector identifying all elements 
of <code>x</code> containing a character not in 
<code>standardCharacters</code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stringi-package">stringi-package</a></code>
<code><a href="base.html#topic+grep">grep</a></code>,
<code><a href="base.html#topic+regexpr">regexpr</a></code>,
<code><a href="#topic+subNonStandardCharacters">subNonStandardCharacters</a></code>,
<code><a href="tools.html#topic+showNonASCII">showNonASCII</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Names &lt;- c('Raul', 'Ra`l', 'Torres,Raul', 'Torres, Raul')
#  confusion in character sets can create
#  names like Names[2]

chk &lt;- grepNonStandardCharacters(Names)


all.equal(chk, 2)


chkv &lt;- grepNonStandardCharacters(Names, TRUE)


all.equal(chkv, Names[2])

</code></pre>

<hr>
<h2 id='Interp'>
Interpolate between numbers or numbers of characters 
</h2><span id='topic+Interp'></span><span id='topic+Interp.default'></span><span id='topic+InterpChkArgs'></span><span id='topic+InterpChar'></span><span id='topic+InterpNum'></span>

<h3>Description</h3>

<p>Numeric interpolation is defined in the usual 
way:  
</p>
<p><code>xOut &lt;- x*(1-proportion) + y*proportion</code> 
</p>
<p>Character interpolation does linear interpolation 
on the number of characters of <code>x</code> and 
<code>y</code>.  If <code>length(proportion) == 1</code>, 
interpolation is done on <code>cumsum(nchar(.))</code>.  
If <code>length(proportion) &gt; 1</code>, interpolation 
is based on <code><a href="base.html#topic+nchar">nchar</a></code>.  In either case, 
the interpolant is rounded to an integer number 
of characters.  <code>Interp</code> then returns 
<code>substring(y, ...)</code> unless <code>nchar(x)</code> &gt; 
<code>nchar(y)</code>, when it returns 
<code>substring(x, ...)</code>.  
</p>
<p>Character interpolation is used in two cases:  
(1) At least one of <code>x</code> and <code>y</code> is 
character.  
(2) At least one of <code>x</code> and <code>y</code> is 
neither logical, integer, numeric, complex nor 
raw, and <code>class(unclass(.))</code> is either 
integer or character.  
</p>
<p>In all other cases, numeric interpolation is 
used.  
</p>
<p>NOTE:  This seems to provide a relatively simple 
default for what most people would want from 
the six classes of atomic vectors (logical, 
integer, numeric, complex, raw, and character) 
and most other classes.  For example, 
<code>class(unclass(factor))</code> is integer.  The
second rule would apply to this converting it to 
character.  The <code><a href="zoo.html#topic+coredata">coredata</a></code> of an 
object of class <code><a href="zoo.html#topic+zoo">zoo</a></code> could be 
most anything, but this relatively simple rule 
would deliver what most people want in most case.  
An exception would be an object with integer 
<code>coredata</code>.  To handle this as numeric, a 
<code>Interp.zoo</code> function would have to be 
written.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Interp(x, ...)
## Default S3 method:
Interp(x, y, proportion, 
        argnames=character(3), 
        message0=character(0), ...)
InterpChkArgs(x, y, proportion, 
        argnames=character(3), 
        message0=character(0), ...)
InterpChar(argsChk, ...)        
InterpNum(argsChk, ...)        
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Interp_+3A_x">x</code>, <code id="Interp_+3A_y">y</code></td>
<td>
 
<p>two vectors of the same class or to be 
coerced to the same class.  
</p>
</td></tr>
<tr><td><code id="Interp_+3A_proportion">proportion</code></td>
<td>

<p>A number or numeric vector assumed to be 
between 0 and 1.  
</p>
</td></tr>
<tr><td><code id="Interp_+3A_argnames">argnames</code></td>
<td>

<p>a character vector of length 3 giving 
arguments <code>name.x</code>, <code>name.y</code>, 
and <code>proportion</code> to pass to 
<code><a href="#topic+compareLengths">compareLengths</a></code> to improve 
the value  of any diagnostic message in 
case lengths are not compatible.  
</p>
</td></tr>
<tr><td><code id="Interp_+3A_message0">message0</code></td>
<td>

<p>A character string to be passed with 
<code>argnames</code> to 
<code><a href="#topic+compareLengths">compareLengths</a></code> to improve 
the value of any diagnostic message in 
case lengths are not compatible.  
</p>
</td></tr>
<tr><td><code id="Interp_+3A_argschk">argsChk</code></td>
<td>

<p>a list as returned by <code>interpChkArgs</code>
</p>
</td></tr>
<tr><td><code id="Interp_+3A_...">...</code></td>
<td>

<p>optional arguments for 
<code><a href="#topic+compareLengths">compareLengths</a></code>  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Interp</code> is an S3 generic function to 
allow users to easily modify the behavior 
to interpolate between special classes of 
objects.  
</p>
<p><code>Interp</code> has two basic algorithms for 
&quot;Numeric&quot; and &quot;Character&quot; interpolation.  
</p>
<p>The computations begin by calling 
<code>InterpChkArgs</code> to dispose quickly of 
simple cases (e.g, <code>x</code> or <code>y</code> 
<code><a href="base.html#topic+missing">missing</a></code> or <code><a href="base.html#topic+length">length</a></code> 
0 or if <code>proportion</code> is &lt;= 0 or &gt;= 1 or 
<code><a href="base.html#topic+missing">missing</a></code>).  It returns a list.  
</p>
<p>If the list contains a component named 
<code>xout</code>, <code>Interp</code> returns that value 
with no further computations.  
</p>
<p>Otherwise, the list returned by 
<code>InterpChkArgs</code> includes components 
&quot;algorithm&quot;, &quot;x&quot;, &quot;y&quot;, &quot;proportion&quot;, 
<code>pLength1</code> (defined below), &quot;raw&quot;, and 
&quot;outclass&quot;.  The &quot;algorithm&quot; component must 
be either &quot;Numeric&quot; or &quot;Character&quot;.  That 
algorithm is then performed as discussed below 
using arguments &quot;x&quot;, &quot;y&quot;, and &quot;proportion&quot;;  
all three will have the same length.  The 
class of &quot;x&quot; and &quot;y&quot; will match the algorithm.  
The list component &quot;raw&quot; is logical:  
<code>TRUE</code> if the output will be raw or such 
that <code>class(unclass(.))</code> of the output will 
be raw.  In that case, a &quot;Numeric&quot; interpolation 
will be transformed back into &quot;raw&quot;.  &quot;outclass&quot; 
will either be a list of attributes to apply to 
the output or NA.  If a list, <code>xout</code> will be 
added as component &quot;.Data&quot; to the list &quot;outclass&quot; 
and then then processed as 
<code>do.call('structure', outclass)</code> to produce 
the desired output.  
</p>
<p>These two basic algorithms (&quot;Numeric&quot; and 
&quot;Character&quot;) are the same if <code>proportion</code> 
is missing or not numeric:  In that case 
<code>Interp</code> throws an error.  
</p>
<p>We now consider &quot;Character&quot; first, because it's 
domain of applicability is easier to describe.  
The &quot;Numeric&quot; algorithm is used in all other 
cases
</p>
<p>1.  &quot;CHARACTER&quot; 
</p>
<p>* 1.1.  The &quot;CHARACTER&quot; algorithm is used when 
at least one of <code>x</code> and <code>y</code> is neither
logical, integer, numeric, complex nor raw and
satisfies one of the following two additional
conditions:  
</p>
<p>** 1.1.1.  Either <code>x</code> or <code>y</code> is
character. 
</p>
<p>** 1.1.2.  <code>class(unclass(.))</code> for at least 
one of <code>x</code> and <code>y</code> is either character
or integer.  
</p>
<p>NOTE:  The strengths and weaknesses of 1.1.2 can 
be seen in considering factors and integer 
vectors of class <code><a href="zoo.html#topic+zoo">zoo</a></code>:  For 
both, <code>class(unclass(.))</code> is integer.  For
factors, we want to use <code>as.character(.)</code>. 
For <code>zoo</code> objects with 
<code><a href="zoo.html#topic+coredata">coredata</a></code> of class integer, 
we would want to use numeric interpolation.  
This is not allowed with the current code but
could be easily implemented by writing 
<code>Interp.zoo</code>.  
</p>
<p>* 1.2.  If either <code>x</code> or <code>y</code> is missing 
or has <code><a href="base.html#topic+length">length</a></code> 0, the one that is 
provided is returned unchanged. 
</p>
<p>* 1.3.  Next determine the class of the output. 
This depends on whether neither, one or both of
<code>x</code> and <code>y</code> have one of the six classes
of atomic vectors  (logical, integer, numeric,
complex, raw, character):  
</p>
<p>** 1.3.1.  If both <code>x</code> and <code>y</code> have 
one of the six atomic classes and one is 
character, return a character object.  
</p>
<p>** 1.3.2.  If only one of <code>x</code> and <code>y</code> 
have an atomic class, return an object of the
class of the other.  
</p>
<p>** 1.3.3.  If neither of <code>x</code> nor <code>y</code> 
have a basic class, return an object with the
class of  <code>y</code>.  
</p>
<p>* 1.4.  Set <code>pLength1 &lt;- 
  (length(proportion) == 1)</code>:  
</p>
<p>** 1.4.1.  <code>If(pLength1)</code> do the linear 
interpolation on <code>cumsum(nchar(.))</code>.   
</p>
<p>** 1.4.2.  Else do the linear interpolation on 
<code><a href="base.html#topic+nchar">nchar</a></code>.  
</p>
<p>* 1.5.  Next check <code>x</code>, <code>y</code> and 
<code>proportion</code> for comparable lengths:  If 
all have length 0, return an object of the
appropriate class.  Otherwise, call 
<code>compareLengths(x, proportion)</code>, 
<code>compareLengths(y, proportion)</code>, and 
<code>compareLengths(x, y)</code>.  
</p>
<p>* 1.6.  Extend <code>x</code>, <code>y</code>, and 
<code>proportion</code> to the length of the longest
using <code><a href="base.html#topic+rep">rep</a></code>.  
</p>
<p>* 1.7. <code>nchOut</code> &lt;- the number of 
characters to output using numeric 
interpolation and rounding the result to 
integer.  
</p>
<p>* 1.8.  Return <code>substring(y, 1, nchOut)</code> 
except when the number of characters from 
<code>x</code> exceed those from <code>y</code>, in which 
case return <code>substring(x, 1, nchOut)</code>.  
[NOTE:  This meets the naive end conditions 
that the number of characters matches that of
<code>x</code> when <code>proportion</code> is 0 and matches 
that of <code>y</code> when <code>proportion</code> is 1.  
This can be used to &quot;erase&quot; characters moving 
from one frame to the next in a video.  See the
examples.   
</p>
<p>2.  &quot;NUMERIC&quot;
</p>
<p>* 2.1.  Confirm that this does NOT satisfy the
condition for the &quot;Character&quot; algorithm.  
</p>
<p>* 2.2.  If either <code>x</code> or <code>y</code> is missing 
or has <code><a href="base.html#topic+length">length</a></code> 0, return the one
provided.  
</p>
<p>* 2.3.  Next determine the class of the output.  
As for &quot;Character&quot; described in section 1.3, this
depends on whether neither, one or both of
<code>x</code> and <code>y</code> have a basic class other
than character (logical, integer, numeric, 
complex, raw):  
</p>
<p>** 2.3.1.  If <code>proportion</code> &lt;= 0, return 
<code>x</code> unchanged.  If <code>proportion</code> &gt;= 1,
return <code>y</code> unchanged.  
</p>
<p>** 2.3.2.  If neither <code>x</code> nor <code>y</code> has 
a basic class, return an object of class equal
that of <code>y</code>.
</p>
<p>** 2.3.3.  If exactly one of <code>x</code> and 
<code>y</code> does not have a basic class, return an
object of class determined by 
<code>class(unclass(.))</code> of the non-basic
argument.  
</p>
<p>** 2.3.4.  When interpolating between two objects 
of class raw, convert the interpolant back to
class raw.  Do this even when 2.3.2 or 2.3.3
applies and <code>class(unclass(.))</code> of both
<code>x</code> and <code>y</code> are of class raw.  
</p>
<p>* 2.4.  Next check <code>x</code>, <code>y</code> and 
<code>proportion</code> for comparable lengths:  If 
all have length 0, return an object of the
appropriate class.  Otherwise, call 
<code>compareLengths(x, proportion)</code>, 
<code>compareLengths(y, proportion)</code>, and 
<code>compareLengths(x, y)</code>.    
</p>
<p>* 2.5.  Compute the desired interpolation and 
convert it to the required class per step 2.3
above.    
</p>


<h3>Value</h3>

<p><code>Interp</code> returns a vector whose class is
described in &quot;* 1.3&quot; and &quot;* 2.3&quot; in &quot;Details&quot;
above.  
</p>
<p><code>InterpChkArgs</code> returns a list or throws an
error as described in &quot;Details&quot; above.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>References</h3>

<p>The <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html">
<em>Writing R Extensions</em></a> manual (available via 
<code>help.start()</code>) lists six different classes
of atomic vectors:  <code><a href="base.html#topic+logical">logical</a></code>, 
<code><a href="base.html#topic+integer">integer</a></code>, <code><a href="base.html#topic+numeric">numeric</a></code>, 
<code><a href="base.html#topic+complex">complex</a></code>, <code><a href="base.html#topic+raw">raw</a></code> and 
<code><a href="base.html#topic+character">character</a></code>.  See also Wickham, 
Hadley (2014) <em>Advanced R</em>, especially 
<a href="http://adv-r.had.co.nz/Data-structures.html">Wickham 
(2013, section on &quot;Atomic vectors&quot; in the 
chapter on   &quot;Data structures&quot;)</a>.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+classIndex">classIndex</a></code>
<code><a href="#topic+interpPairs">interpPairs</a></code>
</p>
<p>Many other packages have functions with names 
like <code>interp</code>, <code>interp1</code>, and 
<code>interpolate</code>.  Some do one-dimensional 
interpolation.  Others do two-dimensional
interpolation.  Some offer different kinds of
interpolation beyond linear.  At least one is a
wrapper for <code><a href="stats.html#topic+approx">approx</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  numerics 
## 
# 1.1.  standard 
xNum &lt;- interpChar(1:3, 4:5, (0:3)/4)
# answer 
xN. &lt;- c(1, 2.75, 3.5, 4)

all.equal(xNum, xN.)


# 1.2.  with x but not y:  
# return that vector with a warning

xN1 &lt;- Interp(1:4, p=.5)
# answer 
xN1. &lt;- 1:4

all.equal(xN1, xN1.)


##
## 2.  Single character vector 
##


i.5 &lt;- Interp(c('a', 'bc', 'def'), character(0), p=0.3)
# with y = NULL or character(0), 
# Interp returns x 

all.equal(i.5, c('a', 'bc', 'def'))


i.5b &lt;- Interp('', c('a', 'bc', 'def'), p=0.3)
# Cumulative characters (length(proportion)=1):  
#     0.3*(total 6 characters) = 1.2 characters
i.5. &lt;- c('a', 'b', '')

all.equal(i.5b, i.5.)


##
## 3.  Reverse character example 
##
i.5c &lt;- Interp(c('a', 'bc', 'def'), '', 0.3)
# check:  0.7*(total 6 characers) = 4.2 characters
i.5c. &lt;- c('a', 'bc', 'd')

all.equal(i.5c, i.5c.)


##
## 4.  More complicated example
##
xCh &lt;- Interp('', c('Do it', 'with R.'), 
              c(0, .5, .9)) 
# answer 
xCh. &lt;- c('', 'with', 'Do i') 

all.equal(xCh, xCh.)

##
## 5.  Still more complicated 
##
xC2 &lt;- Interp(c('a', 'fabulous', 'bug'), 
                  c('bigger or', 'just', 'big'), 
                  c(.3, .3, 1) )
x.y.longer &lt;- c('bigger or', 'fabulous', 'big')
# use y with ties 
# nch smaller        1          4         3
# nch larger         9          8         3
# d.char             8,         4,        0 
# prop              .3,        .7,        1 
# prop*d.char      2.4,       2.8,        0
# smaller+p*d        3,         7,        3
xC2. &lt;- c('big', 'fabulou', 'big')                 

all.equal(xC2, xC2.)


##
## 6.  with one NULL 
##
null1 &lt;- Interp(NULL, 1, .3)

all.equal(null1, 1)


null2 &lt;- Interp('abc', NULL, .3)

all.equal(null2, 'abc')

##
## 7.  length=0 
##
log0 &lt;- interpChar(logical(0), 2, .6)

all.equal(log0, 1.2)


##
## 8.  Date
##
(Jan1.1980 &lt;- as.Date('1980-01-01'))

Jan1.1972i &lt;- Interp(0, Jan1.1980, .2)
# check 
Jan1.1972 &lt;- as.Date('1972-01-01')


all.equal(Jan1.1972, round(Jan1.1972i))


##
## 9.  POSIXct 
##
(Jan1.1980c &lt;- as.POSIXct(Jan1.1980))

(Jan1.1972ci &lt;- Interp(0, Jan1.1980c, .2))
# check 
(Jan1.1972ct &lt;- as.POSIXct(Jan1.1972))


abs(difftime(Jan1.1972ct, Jan1.1972ci, 
             units="days"))&lt;0.5

</code></pre>

<hr>
<h2 id='interpChar'>
Interpolate between numbers or numbers of
characters 
</h2><span id='topic+interpChar'></span><span id='topic+interpChar.list'></span><span id='topic+interpChar.default'></span>

<h3>Description</h3>

<p>For <code>x</code> and <code>y</code> logical, integer,
numeric, Date or POSIX:  
</p>
<p><code>xOut &lt;- x*(1-.proportion) + y*.proportion</code> 
</p>
<p>Otherwise, coerce to character and return a 
<code><a href="base.html#topic+substring">substring</a></code> of <code>x</code> or <code>y</code> 
with number of characters interpolating linearly
between <code>nchar(x)</code> and <code>nchar(y)</code>;  
see details.  
</p>
<p>*** NOTE:  This function is currently in flux.  
The results may not match the documentation 
and may change in the future.  
</p>
<p>The current version does character interpolation
on the cumulative number of characters with
defaults with only one argument that may not be
easy to understand and use.  Proposed:  
</p>
<p>old:  interpolate on 
number of characters in each string with the 
default for a missing argument being 
<code>character(length(x))</code> [or 
<code>character(length(y))</code> or 
<code>numeric(length(x))</code> or ...]
</p>
<p>2014-08-08: default with either x or y missing 
should be to set the other to the one we have, 
so <code>interpChar</code> becomes a no op &ndash; except
that values with <code>.proportion</code> outside
(<code>validProportion</code> = [0, 1] by default)
should be dropped.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpChar(x, ...)
## S3 method for class 'list'
interpChar(x, .proportion, 
        argnames=character(3), 
        message0=character(0), ...)
## Default S3 method:
interpChar(x, y, .proportion, 
        argnames=character(3), 
        message0=character(0), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpChar_+3A_x">x</code></td>
<td>

<p>either a vector or a list.  If a list, pass 
the first two elements as the first two
arguments of <code>interpChar.default</code>.  
</p>
</td></tr>
<tr><td><code id="interpChar_+3A_y">y</code></td>
<td>
<p> a vector </p>
</td></tr>
<tr><td><code id="interpChar_+3A_.proportion">.proportion</code></td>
<td>

<p>A number or numeric vector assumed to be 
between 0 and 1.  
</p>
</td></tr>
<tr><td><code id="interpChar_+3A_argnames">argnames</code></td>
<td>

<p>a character vector of length 3 giving 
arguments <code>name.x</code>, <code>name.y</code>, 
and <code>.proportion</code> to pass to 
<code><a href="#topic+compareLengths">compareLengths</a></code> to improve 
the value  of any diagnostic message in 
case lengths are not compatible.  
</p>
</td></tr>
<tr><td><code id="interpChar_+3A_message0">message0</code></td>
<td>

<p>A character string to be passed with 
<code>argnames</code> to <code><a href="#topic+compareLengths">compareLengths</a></code>
to improve the value of any diagnostic message
in case lengths are not compatible.  
</p>
</td></tr>
<tr><td><code id="interpChar_+3A_...">...</code></td>
<td>

<p>optional arguments for 
<code><a href="#topic+compareLengths">compareLengths</a></code>  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  <code>x</code>, <code>y</code> and <code>.proportion</code> 
are first compared for compatible lengths using
<code><a href="#topic+compareLengths">compareLengths</a></code>.  A warning is 
issued if the lengths are not compatible.  They
are then all extended to the same length using
<code><a href="base.html#topic+rep">rep</a></code>.  
</p>
<p>2.  If <code>x</code> and <code>y</code> are both numeric,
<code>interpChar</code> returns the standard linear
interpolation (described above).  
</p>
<p>3.  If <code>x</code>, <code>y</code>, and <code>.proportion</code>
are all provided with at least one of <code>x</code> 
and <code>y</code> not being numeric  or logical, the
algorithm does linear interpolation on the
difference in the number of characters between 
<code>x</code> and <code>y</code>.  It returns characters 
from <code>y</code> except when <code>nchar(x)</code> &gt;
<code>nchar(y)</code>, in which case it returns
characters from <code>x</code>.  This meets the end
conditions that the number of characters matches
that of <code>x</code> when <code>.proportion</code> is 0 
and matches that of <code>y</code> when 
<code>.proportion</code> is 1.  This can be used to
&quot;erase&quot; characters moving from one frame to 
the next in a video.  See the examples.   
</p>
<p>4.  If either <code>x</code> or <code>y</code> is missing, 
it is replaced by a default vector of the same
type and length;  for example, if <code>y</code> is
missing and <code>x</code> is numeric, <code>y</code> =
<code>numeric(length(x))</code>.  (If the one supplied
is not numeric or logical, it is coerced to
character.)  
</p>


<h3>Value</h3>

<p>A vector:  Numeric if <code>x</code> and <code>y</code> are
both numeric and character otherwise.  The length
= max length of <code>x</code>, <code>y</code>, and 
<code>.proportion</code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>See Also</h3>

<p><code><a href="#topic+interpPairs">interpPairs</a></code>, which calls 
<code>interpChar</code>
</p>
<p><code><a href="#topic+classIndex">classIndex</a></code>, which is called by 
<code>interpChar</code> to help decide the class of 
the interpolant.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  numerics 
## 
# 1.1.  standard 
xNum &lt;- interpChar(1:3, 4:5, (0:3)/4)
# answer 
xN. &lt;- c(1, 2.75, 3.5, 4)

all.equal(xNum, xN.)


# 1.2.  list of length 1 with a numeric vector: 
#       return that vector with a warning
xN1 &lt;- interpChar(list(a.0=1:4), .5)
# answer 
xN1. &lt;- 1:4

all.equal(xN1, xN1.)


##
## 2.  Single character vector 
##
i.5 &lt;- interpChar(list(c('a', 'bc', 'def')), .p=0.3)
# If cumulative characters:  
#        0.3*(total 6 characters) = 1.8 characters
#
# However, the current code does something different, 
# returning "a", "bc", "d" &lt;- like using 1-.p?  
# This is a problem with the defaults with a single 
# argument;  ignore this issue for now.  
# 2014-06-04
i.5. &lt;- c('a', 'b', '')
#all.equal(i.5, i.5.)

##
## 3.  Reverse character example 
##
i.5c &lt;- interpChar(c('a', 'bc', 'def'), '', 0.3)
# check:  0.7*(total 6 characers) = 4.2 characters
i.5c. &lt;- c('a', 'bc', 'd')

all.equal(i.5c, i.5c.)


#  The same thing specified in a list 
i.5d &lt;- interpChar(list(c('a', 'bc', 'def'), ''), 0.3)

all.equal(i.5d, i.5c.)


##
## 4.  More complicated example
##
xCh &lt;- interpChar(list(c('Do it', 'with R.')), 
                  c(0, .5, .9)) 
# answer 
xCh. &lt;- c('', 'with', 'Do ') 
# With only one input, it's assumed to be y.  
# It is replicated to length(.proportion), 
# With nchar = 5, 7, 5, cum = 5, 12, 17.  

all.equal(xCh, xCh.)

##
## 5.  Still more complicated 
##
xC2 &lt;- interpChar(c('a', 'fabulous', 'bug'), 
                  c('bigger or', 'just', 'big'), 
                  c(.3, .3, 1) )
# answer 
x.y.longer &lt;- c('bigger or', 'fabulous', 'big')
# use y with ties 
# nch smaller        1          4         3
# nch larger         9          8         3
# d.char             8,         4,        0 
# cum characters     8,        12,       12 
# prop              .3,        .7,        1 
# prop*12          3.6,       8.4,       12
# cum.sm             1,         5,        8
# cum.sm+prop*12     5,        13,       20
#   -cum(larger[-1]) 5,         4,        3
xC2. &lt;- c('bigge', 'fabu', 'big')                 

all.equal(xC2, xC2.)


##
## 6.  with one NULL 
##
null1 &lt;- interpChar(NULL, 1, 1)

all.equal(null1, 1)


null2 &lt;- interpChar('abc', NULL, .3)

all.equal(null2, 'ab')

##
## 7.  length=0 
##
log0 &lt;- interpChar(logical(0), 2, .6)

all.equal(log0, 1.2)


##
## 8.  Date
##



##
## 9.  POSIXct 
##

</code></pre>

<hr>
<h2 id='interpPairs'>
interpolate between pairs of vectors in a list
</h2><span id='topic+interpPairs'></span><span id='topic+interpPairs.call'></span><span id='topic+interpPairs.function'></span><span id='topic+interpPairs.list'></span>

<h3>Description</h3>

<p>This does two things:  
</p>

<ol>
<li><p> Computes a <code>.proportion</code> 
interpolation between <code>pairs</code> by passing
each pair with <code>.proportion</code> to 
<code><a href="#topic+interpChar">interpChar</a></code>.  
<code><a href="#topic+interpChar">interpChar</a></code> does standard linear 
interpolation with numerics and interpolates 
based on the number of characters with 
non-numerics.  
</p>
</li>
<li><p> Discards rows of interpolants for which 
<code>.proportion</code> is outside 
<code>validProportion</code>.  If <code>object</code> is 
a <code>list</code>, corresponding rows of other
vectors of the same length are also discarded.  
</p>
<p>NOTE:  There are currently discrepancies 
between the documentation and the code over
defaults when one but not both elements of a
pair are provided.  The code returns an answer.
If that's not acceptable, provide the other 
half of the pair.  After some experience is
gathered, the question of defaults will be
revisited and the code or the documentation 
will change.  
</p>
</li></ol>
  


<h3>Usage</h3>

<pre><code class='language-R'>interpPairs(object, ...) 
## S3 method for class 'call'
interpPairs(object, 
    nFrames=1, iFrame=nFrames, 
    endFrames=round(0.2*nFrames), 
    envir = parent.frame(), 
    pairs=c('1'='\\.0$', '2'='\\.1$', 
        replace0='', replace1='.2', 
        replace2='.3'),     
    validProportion=0:1, message0=character(0), ...)
## S3 method for class 'function'
interpPairs(object, 
    nFrames=1, iFrame=nFrames, 
    endFrames=round(0.2*nFrames), 
    envir = parent.frame(), 
    pairs=c('1'='\\.0$', '2'='\\.1$', 
    replace0='', replace1='.2', replace2='.3'),     
    validProportion=0:1, message0=character(0), ...)
## S3 method for class 'list'
interpPairs(object, 
    .proportion, envir=list(), 
        pairs=c('1'='\\.0$', '2'='\\.1$',
        replace0='', replace1='.2', 
        replace2='.3'), validProportion=0:1,
        message0=character(0), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpPairs_+3A_object">object</code></td>
<td>

<p>A <code><a href="base.html#topic+call">call</a></code>, <code><a href="base.html#topic+function">function</a></code>, 
<code>list</code> or <code>data.frame</code> with names
possibly matching <code>pairs[1:2]</code>.  
</p>
<p>When names matching both of <code>pairs[1:2]</code>,
they are converted to potentially common names
using <code>sub(pairs[i], pairs[3], ...)</code>.  
When matches are found among the potentially
common names, they are passed with 
<code>.proportion</code> to <code><a href="#topic+interpChar">interpChar</a></code>
to compute an interpolation.  The matches are
removed and replaced with the interpolant,
shortened by excluding any rows for which 
<code>.proportion</code> is outside 
<code>validProportion</code>.  
</p>
<p>Elements with &quot;common names&quot; that do not have 
a match are replaced by elements with the 
common names that have been shortened by
omitting rows with <code>.proportion</code> outside
<code>validProportion</code>.  Thus, if <code>x.0</code> 
is found without <code>x.1</code>, <code>x.0</code> is
removed and replaced by <code>x</code>.  
</p>
</td></tr>
<tr><td><code id="interpPairs_+3A_nframes">nFrames</code></td>
<td>

<p>number of distinct plots to create.
</p>
</td></tr>
<tr><td><code id="interpPairs_+3A_iframe">iFrame</code></td>
<td>

<p>integer giving the index of the single frame 
to create.  Default = <code>nFrames</code>.
</p>
<p>An error is thrown if both <code>iFrame</code> and
<code>.proportion</code> are not <code>NULL</code>.  
</p>
</td></tr>  
<tr><td><code id="interpPairs_+3A_endframes">endFrames</code></td>
<td>

<p>Number of frames to hold constant at the end.
</p>
</td></tr>  
<tr><td><code id="interpPairs_+3A_.proportion">.proportion</code></td>
<td>

<p>a numeric vector assumed to lie between 0 and 
1 specifying how far to go from 
<code>suffixes[1]</code> to <code>suffixes[2]</code>.  
For example, if <code>x.0</code> and <code>x.1</code> are
found and are numeric, <code>x</code> = 
<code>x.0 + .proportion * (x.1 - x.0)</code>.  
Rows of <code>x</code> and any other element 
of <code>object</code> of the same length are dropped
for any <code>.proportion</code> outside 
<code>validProportion</code>.
</p>
<p>An error is thrown if both <code>iFrame</code> and
<code>.proportion</code> are not <code>NULL</code>.  
</p>
</td></tr>
<tr><td><code id="interpPairs_+3A_envir">envir</code></td>
<td>

<p>environment / list to use with <code>object</code>,
which can optionally provide other variables to
compute what gets plotted;  see the example
below using this argument.  
</p>
</td></tr>
<tr><td><code id="interpPairs_+3A_pairs">pairs</code></td>
<td>

<p>a character vector of two regular expressions 
to identify elements of <code>object</code> between
which to interpolate and three replacements.  
</p>
<p>(1) The first of the three replacements is used
in <code><a href="base.html#topic+sub">sub</a></code> to convert each 
<code>pairs[1:2]</code> name found to the desired 
name of the interpolate.  Common names found 
are then passed with <code>.proportion</code> to 
<code><a href="#topic+interpChar">interpChar</a></code>, which does the actual 
interpolation. 
</p>
<p>(2, 3) <code>interpPairs</code> also calls 
<code>checkNames(object, avoid = 
    pairs[c(1, 3, 2, 5)])</code>.  
This confirms that <code>object</code> has 
<code><a href="base.html#topic+names">names</a></code>, and all such names are
unique.  If <code>object</code> does not have names 
or has some duplicate names, the 
<code><a href="base.html#topic+make.names">make.names</a></code> is called to fix 
that problem, and any new names that match
<code>pairs[1:2]</code> are modified using 
<code><a href="base.html#topic+sub">sub</a></code> to avoid creating a new match.  
If the modification still matches 
<code>pairs[1:2]</code>, it generates an error.      
</p>
</td></tr>
<tr><td><code id="interpPairs_+3A_validproportion">validProportion</code></td>
<td>

<p>Range of values of <code>.proportion</code> to 
retain, as noted with the discussion of the
<code>object</code> argument.
</p>
</td></tr>
<tr><td><code id="interpPairs_+3A_message0">message0</code></td>
<td>

<p>a character string passed to 
<code><a href="#topic+interpChar">interpChar</a></code> to improve the value 
of diagnostic messages  
</p>
</td></tr>
<tr><td><code id="interpPairs_+3A_...">...</code></td>
<td>
<p> optional arguments for 
<code><a href="base.html#topic+sub">sub</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>*** FUNCTION *** 
</p>
<p>First <code>interpPairs.function</code> looks for
arguments <code>firstFrame</code>, <code>lastFrame</code>, 
and <code>Keep</code>.  If any of these are found, 
they are stored locally and removed from the
function.  If <code>iFrame</code> is provided, it is 
used with with these arguments plus 
<code>nFrames</code> and <code>endFrames</code> to compute
<code>.proportion</code>.  
</p>
<p>If <code>.proportion</code> is outside 
<code>validProportion</code>, <code>interpPairs</code> does
nothing, returning <code>enquote(NULL)</code>.  
</p>
<p>If <code>any(.proportion)</code> is inside 
<code>validProportion</code>, 
<code>interpPairs.function</code> next uses 
<code><a href="base.html#topic+grep">grep</a></code> to look for arguments with
names matching <code>pairs[1:2]</code>.  If any are
found, they are passed with <code>.proportion</code> 
to <code><a href="#topic+interpChar">interpChar</a></code>.  The result is 
stored in the modified <code>object</code> with the
common name obtained from 
<code>sub(pairs[i], pairs[3], ...)</code>, <code>i</code> = 
1, 2.  
</p>
<p>The result is then evaluated and then returned.  
</p>
<p>*** LIST *** 
</p>
<p>1.  <code>ALL.OUT:  
  if(none(0&lt;=.proportion&lt;=1))</code>return 
<code>'no.op' = list(fun='return', value=NULL)</code> 
</p>
<p>2.  <code>FIND PAIRS</code>:  Find names matching
<code>pairs[1:2]</code> using <code><a href="base.html#topic+grep">grep</a></code>.  
For example, names like <code>x.0</code> match the
default <code>pairs[1]</code>, and names like 
<code>x.1</code> match the default <code>pairs[1]</code>.  
</p>
<p>3.  <code>MATCH PAIRS</code>:  Use 
<code>sub(pairs[i], pairs[3], ...)</code> for 
i = 1:2, to translate each name matching 
<code>pairs[1:2]</code> into something else for 
matching.  For example, the default <code>pairs</code> 
thus translates, e.g., <code>x.0</code> and 
<code>x.1</code> both into <code>x</code>.  In the output, 
<code>x.0</code> and <code>x.1</code> are dropped, replaced 
by <code>x</code> = <code>interpChar(x.0, x.1, 
  .proportion, ...)</code>.  Rows with 
<code>.proportion</code> outside <code>validProportion</code> 
are dropped in <code>x</code>.  Drop similar rows of 
any numeric or character vector or 
<code><a href="base.html#topic+data.frame">data.frame</a></code> with the same number of 
rows as <code>x</code> or <code>.proportion</code>.  
</p>
<p>4.  Add component <code>.proportion</code> to 
<code>envir</code> to make it available to 
<code><a href="base.html#topic+eval">eval</a></code> any <code>language</code> component
of <code>object</code> in the next step.  
</p>
<p>5.  Loop over all elements of <code>object</code> to 
create <code>outList</code>, evaluating any 
expressions and computing the desired 
interpolation using <code><a href="#topic+interpChar">interpChar</a></code>. 
Computing <code>xleft</code> in this way allows
<code>xright</code> to be specified later as 
<code>quote(xleft + xinch(0.6))</code>, for example. 
This can be used with a call to 
<code><a href="#topic+rasterImageAdj">rasterImageAdj</a></code>.  
</p>
<p>6.  Let <code>N</code> = the maximum number of rows of
elements of <code>outList</code> created by 
interpolation in the previous step.  If 
<code>.proportion</code> is longer, set <code>N</code> = 
<code>length(.proportion)</code>.  Find all vectors and 
<code><a href="base.html#topic+data.frame">data.frame</a></code>s in <code>outList</code> with
<code>N</code> rows and delete any rows for which 
<code>.proportion</code> is outside 
<code>validProportion</code>.  
</p>
<p>7.  Delete the raw pairs found in steps 1-3,
retaining the element with the target name
computed in steps 4 and 5 above.  For other
elements of <code>object</code> modified in the 
previous step, retain the shortened form. 
Otherwise, retain the original, unevaluated
element.    
</p>


<h3>Value</h3>

<p>a <code>list</code> with elements containing the 
interpolation results.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interpChar">interpChar</a></code> for details on 
interpolation.  
<code><a href="#topic+compareLengths">compareLengths</a></code> for how lengths 
are checked and messages composed and written.  
<code><a href="base.html#topic+enquote">enquote</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###
###
### 1.  interpPairs.function
###
###

##
## 1.1.  simple 
##
plot0 &lt;- quote(plot(0))
plot0. &lt;- interpPairs(plot0)
# check 

all.equal(plot0, plot0.)


##
## 1.2.  no op 
##
noop &lt;- interpPairs(plot0, iFrame=-1)
# check

all.equal(noop, enquote(NULL))


##
## 1.3.  a more typical example
## example function for interpPairs 
tstPlot &lt;- function(){
  plot(1:2, 1:2, type='n')
  lines(firstFrame=1:3, 
        lastFrame=4, 
        x.1=seq(1, 2, .5), 
        y.1=x, 
        z.0=0, z.1=1, 
        txt.1=c('CRAN is', 'good', '...'), 
        col='red')
}
tstbo &lt;- body(tstPlot)
iPlot &lt;- interpPairs(tstbo[[2]])
# check 
iP &lt;- quote(plot(1:2, 1:2, type='n'))

all.equal(iPlot, iP)


iLines &lt;- interpPairs(tstbo[[3]], nFrames=5, iFrame=2)
# check:  
# .proportion = (iFrame-firstFrame)/(lastFrame-firstFrame)
#  = c(1/3, 0, -1/3)
# if x.0 = 0 and y.0 = 0 by default:  
iL &lt;- quote(linex(x=c(1/3, 0), y=c(1/9, 0), z=c(1/3, 0), 
           tst=c('CR', '')))
##
##**** This example seems to give the wrong answer
##**** 2014-06-03:  Ignore for the moment 
##           
#all.equal(iLines, iL)

##
## 1.4.  Don't throw a cryptic error with NULL 
##
ip0 &lt;- interpPairs(quote(text(labels.1=NULL)))
  
  
###
###
### 2.  interpPairs.list
###
###

##
## 2.1.  (x.0, y.0, x.1, y.1) -&gt; (x,y)
##
tstList &lt;- list(x.0=1:5, y.0=5:9, y.1=9:5, x.1=9,
                ignore=letters, col=1:5)
xy &lt;- interpPairs(tstList, 0.1)
# check 
xy. &lt;- list(ignore=letters, col=1:5, 
            x=1:5 + 0.1*(9-1:5), 
            y=5:9 + 0.1*(9:5-5:9) )
# New columns, 'x' and 'y', come after 
# columns 'col' and 'ignore' already in tstList 

all.equal(xy, xy.)


##
## 2.2.  Select the middle 2:  
##      x=(1-(0,1))*3:4+0:1*0=(3,0)
##
xy0 &lt;- interpPairs(tstList[-4], c(-Inf, -1, 0, 1, 2) )
# check 
xy0. &lt;- list(ignore=letters, col=3:4, x=c(3,0), y=7:6)


all.equal(xy0, xy0.)

##
## 2.3.  Null interpolation because of absence of y.1 and x.0  
##
xy02 &lt;- interpPairs(tstList[c(2, 4)], 0.1)
# check 
#### NOT the current default answer;  revisit later.  
xy02. &lt;- list(y=5:9, x=9)

# NOTE:  length(x) = 1 = length(x.1) in testList
#all.equal(xy02, xy02.)

##
## 2.4.  Select an empty list (make sure this works)
##
x0 &lt;- interpPairs(list(), 0:1)
# check 
x0. &lt;- list()
names(x0.) &lt;- character(0)

all.equal(x0, x0.)


##
## 2.5.  subset one vector only 
##
xyz &lt;- interpPairs(list(x=1:4), c(-1, 0, 1, 2))
# check 
xyz. &lt;- list(x=2:3)

all.equal(xyz, xyz.)


##
## 2.6.  with elements of class call
##
xc &lt;- interpPairs(list(x=1:3, y=quote(x+sin(pi*x/6))), 0:1)
# check
xc. &lt;- list(x=1:3, y=quote(x+sin(pi*x/6)))

all.equal(xc, xc.)


##
## 2.7. text
##
#  2 arguments 
j.5 &lt;- interpPairs(list(x.0='', x.1=c('a', 'bc', 'def')), 0.5)
# check  
j.5. &lt;- list(x=c('a', 'bc', ''))

all.equal(j.5, j.5.)


##
##  2.8.  text, 1 argument as a list 
##
j.50 &lt;- interpPairs(list(x.1=c('a', 'bc', 'def')), 0.5)
# check  

all.equal(j.50, j.5.)


##
## 2.9.  A more complicated example with elements to eval
##
logo.jpg &lt;- paste(R.home(), "doc", "html", "logo.jpg",
                  sep = .Platform$file.sep)
if(require(jpeg)){
  Rlogo &lt;- try(readJPEG(logo.jpg))
  if(!inherits(Rlogo, 'try-error')){
# argument list for a call to rasterImage or rasterImageAdj   
    RlogoLoc &lt;- list(image=Rlogo,
      xleft.0 = c(NZ=176.5,CH=172,US=171,  
                  CN=177,RU= 9.5,UK= 8),
      xleft.1 = c(NZ=176.5,CH=  9,US=-73.5,
                  CN=125,RU= 37, UK= 2),
      ybottom.0=c(NZ=-37,  CH=-34,US=-34,  
                  CN=-33,RU= 48, UK=47),
      ybottom.1=c(NZ=-37,  CH= 47,US= 46,  
                  CN= 32,RU=55.6,UK=55),
      xright=quote(xleft+xinch(0.6)),
      ytop = quote(ybottom+yinch(0.6)),
      angle.0 =0,
      angle.1 =c(NZ=0,CH=3*360,US=5*360, 
                 CN=2*360,RU=360,UK=360)
    )

    RlogoInterp &lt;- interpPairs(RlogoLoc, 
            .proportion=rep(c(0, -1), c(2, 4)) )
# check 

  all.equal(names(RlogoInterp), 
      c('image', 'xright', 'ytop', 
        'xleft', 'ybottom', 'angle'))
 

# NOTE:  'xleft', and 'ybottom' were created in interpPairs, 
# and therefore come after 'xright' and 'ytop', which were 
# already there.  

##
## 2.10.  using envir
##
    RlogoDiag &lt;- list(x0=quote(Rlogo.$xleft), 
                  y0=quote(Rlogo.$ybottom), 
                  x1=quote(Rlogo.$xright), 
                  y1=quote(Rlogo.$ytop) ) 

    RlogoD &lt;- interpPairs(RlogoDiag, .p=1, 
                    envir=list(Rlogo.=RlogoInterp) ) 

    all.equal(RlogoD, RlogoDiag)

  }
}
##
## 2.11.  assign;  no interp but should work   
##
tstAsgn &lt;- as.list(quote(op &lt;- (1:3)^2))
intAsgn &lt;- interpPairs(tstAsgn, 1)

# check 
intA. &lt;- tstAsgn 
names(intA.) &lt;- c('X', 'X.3', 'X.2')

all.equal(intAsgn, intA.)


#   op &lt;- par(...)
tstP &lt;- quote(op &lt;- par(mar=c(5, 4, 2, 2)+0.1))
tstPar &lt;- as.list(tstP)
intPar &lt;- interpPairs(tstPar, 1)

# check 
intP. &lt;- list(quote(`&lt;-`), quote(op), 
              quote(par(mar=c(5, 4, 2, 2)+0.1)) )
names(intP.) &lt;- c("X", 'X.3', 'X.2')

all.equal(intPar, intP.)


intP. &lt;- interpPairs(tstP)

all.equal(intP., tstP)


##
## NULL 
## 

all.equal(interpPairs(NULL), quote(NULL)) 

</code></pre>

<hr>
<h2 id='logVarCor'>
Log-diagonal representation of a variance matrix 
</h2><span id='topic+logVarCor'></span>

<h3>Description</h3>

<p>Translate a square symmetric matrix with positive 
diagonal elements into a vector of the logarithms 
of the diagonal elements with the correlations as 
an attribute, and vice versa.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logVarCor(x, corr, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logVarCor_+3A_x">x</code></td>
<td>

<p>If a matrix, translate into a vector with a 
&quot;corr&quot; attribute.  
</p>
<p>If a vector, translate into a matrix.  
</p>
</td></tr>
<tr><td><code id="logVarCor_+3A_corr">corr</code></td>
<td>

<p>optional vector of correlations for the 
<code><a href="base.html#topic+lower.tri">lower.tri</a></code> portion of a covariance 
matrix whose diagonal is <code>exp(x)</code>.  
</p>
<p>Use a &quot;corr&quot; attribute of <code>x</code> only if 
this argument is <code><a href="base.html#topic+missing">missing</a></code>.  
</p>
</td></tr>
<tr><td><code id="logVarCor_+3A_...">...</code></td>
<td>

<p>(not currently used)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if(length(dim(x))==2) return <code>log(diag(x))</code> 
with an attribute &quot;corr&quot; equal to the 
<code><a href="base.html#topic+lower.tri">lower.tri</a></code> of <code>cov2cor(x)</code>.  
</p>
<p>Otherwise, return a covariance matrix from 
<code>x</code> as described above.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+log">log</a></code>
<code><a href="base.html#topic+diag">diag</a></code>
<code><a href="stats.html#topic+cov2cor">cov2cor</a></code>
<code><a href="base.html#topic+lower.tri">lower.tri</a></code>
<code><a href="nlme.html#topic+pdLogChol">pdLogChol</a></code> converts a k-dimensional 
covariance matrix into a vector of length 
<code>choose(k+1, 2)</code>.  By contrast, <code>logVarCor</code> 
returns a vector of length <code>k</code> with a &quot;corr&quot; 
attribute of length <code>choose(k, 2)</code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  Trivial 1 x 1 matrix
##
# 1.1.  convert vector to "matrix"
mat1 &lt;- logVarCor(1)
# check

all.equal(mat1, matrix(exp(1), 1))
          

# 1.2.  Convert 1 x 1 matrix to vector 
lVCd1 &lt;- logVarCor(diag(1))
# check 
lVCd1. &lt;- 0
attr(lVCd1., 'corr') &lt;- numeric(0)

all.equal(lVCd1, lVCd1.)


##
## 2.  simple 2 x 2 matrix 
##
# 2.1.  convert 1:2 into a matrix 
lVC2 &lt;- logVarCor(1:2)
# check 
lVC2. &lt;- diag(exp(1:2))

all.equal(lVC2, lVC2.)


# 2.2.  Convert a matrix into a vector 
lVC2d &lt;- logVarCor(diag(1:2))
# check 
lVC2d. &lt;- log(1:2)
attr(lVC2d., 'corr') &lt;- 0 

all.equal(lVC2d, lVC2d.)


##
## 3.  3-d covariance matrix with nonzero correlations 
##
# 3.1.  Create matrix 
(ex3 &lt;- tcrossprod(matrix(c(rep(1,3), 0:2), 3)))
dimnames(ex3) &lt;- list(letters[1:3], letters[1:3])

# 3.2.  Convert to vector 
(Ex3 &lt;- logVarCor(ex3))

# check 
Ex3. &lt;- log(c(1, 2, 5))
names(Ex3.) &lt;- letters[1:3]
attr(Ex3., 'corr') &lt;- c(1/sqrt(2), 1/sqrt(5), 3/sqrt(10))

all.equal(Ex3, Ex3.)


# 3.3.  Convert back to a matrix 
Ex3.2 &lt;- logVarCor(Ex3)
# check 

all.equal(ex3, Ex3.2)

</code></pre>

<hr>
<h2 id='match.data.frame'>
Identify the row of <code>y</code> best 
matching each row of <code>x</code>
</h2><span id='topic+match.data.frame'></span>

<h3>Description</h3>

<p>For each row of <code>x[, by.x]</code>, 
find the best matching row of 
<code>y[, by.y]</code>, with the best 
match defined by <code>grep.</code> and
<code>split</code>.
</p>
<p><code>grep.</code> and <code>split</code> must 
either be <code><a href="base.html#topic+missing">missing</a></code> or
have the same length as <code>by.x</code> 
and <code>by.y</code>.  If <code>grep.[i]</code> 
and <code>split[i]</code> are NA, do a 
complete match of <code>x[, by.x[i]]</code> 
and <code>y[, by.y[i]]</code>.  Otherwise, 
for each row <code>j</code>, look for a 
match for <code>strsplit(x[j, by.x[i]], 
  split[i])[[1]][1]</code> among 
<code>strsplit(y[, by.y[i]], split[i])</code>.
See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.data.frame(x, y, by, by.x=by, by.y=by, 
        grep., split, sep=':')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.data.frame_+3A_x">x</code>, <code id="match.data.frame_+3A_y">y</code></td>
<td>

<p>data.frames
</p>
</td></tr>
<tr><td><code id="match.data.frame_+3A_by">by</code>, <code id="match.data.frame_+3A_by.x">by.x</code>, <code id="match.data.frame_+3A_by.y">by.y</code></td>
<td>

<p>names of columns of <code>x</code> and <code>y</code> 
to match.
</p>
</td></tr>
<tr><td><code id="match.data.frame_+3A_grep.">grep.</code></td>
<td>

<p>a character vector of the type of match 
for each element of <code>by.x</code> and 
<code>by.y</code>.  If <code>NA</code>, require a 
perfect match.
</p>
<p>Alternatives are <code><a href="base.html#topic+grep">grep</a></code> and 
<code><a href="base.html#topic+agrep">agrep</a></code> to find a match for 
the first segment in 
<code>strsplit(x, split=split[i])</code> among 
any of the segments of 
<code>strsplit(y, split=split[i])</code>.  Use 
<code>fixed=TRUE</code> with the calls to these
functions.
</p>
<p>NOTE:  These alternatives are not examined 
if a unique match is found between 
<code>x[, by.x[is.na(grep.) &amp; is.na(split)]]</code> 
and the corresponding columns of <code>y</code>.
</p>
</td></tr>
<tr><td><code id="match.data.frame_+3A_split">split</code></td>
<td>

<p>A character vector of <code>split</code> characters 
to pass to <code><a href="base.html#topic+strsplit">strsplit</a></code>;  
<code><a href="base.html#topic+strsplit">strsplit</a></code> is not called if
<code>is.na(split)</code>.
</p>
</td></tr>
<tr><td><code id="match.data.frame_+3A_sep">sep</code></td>
<td>

<p>a <code>sep</code> argument to use with 
<code><a href="base.html#topic+paste">paste</a></code> to produce a matching 
key for the columns of <code>x</code> and <code>y</code> 
for which perfect matches are required.  
<code>If(missing(sep) &amp;&amp; not(missing(grep.))) 
    sep &lt;- ' '</code> except where <code>grep.</code> = 
<code>NA</code>s.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  Check <code>by.x, by.y, grep.</code> and 
<code>split</code>.  <code>If((missing(by.x) |
  missing(by.y)) &amp;&amp; missing(by)) by &lt;- names(x)</code>
</p>
<p>2.  <code>fullMatch &lt;- (is.na(grep.) &amp; is
  .na(split))</code>.  Create <code>keyfx</code> and
<code>keyfy</code> by by pasting columns of 
<code>x[, by.x[fullMatch]]</code> and 
<code>y[, by.y[fullMatch]]</code>.  Also 
create <code>x.</code> and <code>y.</code> = 
<code><a href="base.html#topic+strsplit">strsplit</a></code> of
<code>x[, by.x[!fullMatch]]</code>.
</p>
<p>3.  Iterate over rows of <code>x</code> looking 
for the best match.  This includes an inner 
loop over columns of 
<code>x[, by.x[!fullMatch]]</code>, stopping
on the first unique match.  Return (-1) if 
no unique match is found.
</p>


<h3>Value</h3>

<p>an integer vector of length <code>nrow(x)</code>
containing the index of the best matching row 
of <code>y</code> or <code>NA</code> if no adequate match 
was found.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strsplit">strsplit</a></code>, <code><a href="base.html#topic+is.na">is.na</a></code>
<code><a href="base.html#topic+grep">grep</a></code>, <code><a href="base.html#topic+agrep">agrep</a></code>
<code><a href="base.html#topic+match">match</a></code>, <code><a href="prodlim.html#topic+row.match">row.match</a></code>,
<code><a href="plyr.html#topic+join">join</a></code>, <code><a href="plyr.html#topic+match_df">match_df</a></code>
<code><a href="TRAMPR.html#topic+classify">classify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>newdata &lt;- data.frame(state=c("AL", "MI","NY"),
                      surname=c("Rogers", "Rogers", "Smith"),
                      givenName=c("Mike R.", "Mike K.", "Al"),
                      stringsAsFactors=FALSE)
reference &lt;- data.frame(state=c("NY", "NY", "MI", "AL", "NY", "MI"),
                      surname=c("Smith", "Rogers", "Rogers (MI)",
                                "Rogers (AL)", "Smith", 'Jones'),
                      givenName=c("John", "Mike", "Mike", "Mike",
                                "T. Albert", 'Al Thomas'),
                      stringsAsFactors=FALSE)
newInRef &lt;- match.data.frame(newdata, reference,
       grep.=c(NA, 'agrep', 'agrep'))


all.equal(newInRef, c(4, 3, 5))

</code></pre>

<hr>
<h2 id='matchName'>
Match surname and givenName in a table
</h2><span id='topic+matchName'></span><span id='topic+matchName1'></span>

<h3>Description</h3>

<p>Use <code><a href="#topic+parseName">parseName</a></code> to split a name into 
<code>surname</code> and <code>givenName</code>, the look for
matches in <code>table</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchName(x, data, Names=1:2, 
          nicknames=matrix(character(0), 0, 2), 
          namesNotFound="attr.replacement", ...)
matchName1(x1, data, name=data[, 1],     
          nicknames=matrix(character(0), 0, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matchName_+3A_x">x</code></td>
<td>

<p>One of the following:  
</p>

<ul>
<li><p> A character matrix or <code>data.frame</code>
with the same number of rows as <code>data</code>.
The best partial match is sought in 
<code>Names</code>.  The algorithm stops when a
unique match is found;  any remaining 
columns of <code>x</code> are then ignored.  Any 
<code>nicknames</code> are ignored for the first
column but not for subsequent columns.   
</p>
</li>
<li><p> A character vector whose length matches
the number of rows of <code>data</code>.  This
will be replaced by <code>parseName(x)</code>.
</p>
</li></ul>
      
</td></tr>
<tr><td><code id="matchName_+3A_data">data</code></td>
<td>

<p>a character matrix or a 
<code><a href="base.html#topic+data.frame">data.frame</a></code>.  If <code>surname</code> 
and <code>givenName</code> are character vectors of 
names, their length must match the number of
rows of <code>data</code>.  
</p>
</td></tr>
<tr><td><code id="matchName_+3A_names">Names</code></td>
<td>

<p>One of the following in which matches for
<code>x</code> will be sought:  
</p>
 
<ul>
<li><p> A character vector or matrix or a
<code>data.frame</code> for which 
<code>NROW(Names) == nrow(data)</code>.  
</p>
</li>
<li><p> Something to select columns of 
<code>data</code> to produce a character vector or
matrix or <code>data.frame</code> via 
<code>data[, Names]</code>.  In this case, 
accents will be stripped using 
<code><a href="#topic+subNonStandardNames">subNonStandardNames</a></code>.  
</p>
</li></ul>

</td></tr>
<tr><td><code id="matchName_+3A_nicknames">nicknames</code></td>
<td>

<p>a character matrix with two columns, each row
giving a pair of names like &quot;Pete&quot; and &quot;Peter&quot;
that should be regarded as equivalent if no
exact match(es) is(are) found.   
</p>
</td></tr>
<tr><td><code id="matchName_+3A_...">...</code></td>
<td>
 
<p>optional arguments passed to 
<code>subNonStandardNames</code>
</p>
</td></tr>
<tr><td><code id="matchName_+3A_x1">x1</code></td>
<td>
 
<p>a character vector of names to match 
<code>name</code>. 
</p>
<p>NOTE:  <code>matchName</code> calls 
<code>subNonStandardNames</code>, but 
<code>matchName1</code> does not.  Thus, 
<code>x1</code> is assumed to NOT to contain 
characters not in standard English.  
</p>
</td></tr>
<tr><td><code id="matchName_+3A_name">name</code></td>
<td>

<p>A character vector or matrix for which 
<code>NROW(name)</code> == <code>nrow(data)</code>.  
</p>
<p>NOTE:  <code>matchName</code> calls 
<code>subNonStandardNames</code>, but 
<code>matchName1</code> does not.  Thus, 
<code>name</code> is assumed to NOT to contain
characters not in standard English.  
</p>
</td></tr>
<tr><td><code id="matchName_+3A_namesnotfound">namesNotFound</code></td>
<td>

<p>character vector passed to 
<code>subNonStandardNames</code> and used to 
compute any <code>namesNotFound</code> attribute 
of the object returned by <code>parseName</code>.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>*** 1.  <code>matchName(x, data, Names, 
  nicknames, ...)</code>:  
</p>
<p>1.1.  <code>if(length(dim(x)&lt;2))x &lt;- 
  parseName(x, ...)</code>  
</p>
<p>1.2.  <code>x1 &lt;- matchName1(x[, 1], 
  cata, Names[1], ...)</code>
</p>
<p>1.3.  For any component i of x1 with multiple 
rows, let <code>x1i &lt;- matchName1(x[i, 2], 
  x1[[i]], Name[-1], nicknames=nicknames, ...)</code>.  
If <code>nrow(x1i)</code>&gt;0, 
<code>x1[[i]] &lt;- x1i</code>;  else leave unchanged.  
</p>
<p>1.4.  return <code>x1</code>.   
</p>
<p>===========
</p>
<p>*** 2.  <code>matchName1(x1, data, name, 
  nicknames, ...)</code>:  
</p>
<p>2.1.  If name indicates a column of data, 
replace with <code>data[, name]</code>.  
</p>
<p>2.2.  <code>xsplit &lt;- strsplit(x1, ' ')</code>.  
</p>
<p>2.3.  <code>nx &lt;- length(x1); 
  xlist &lt;- vector(nx, mode='list')</code>
</p>
<p>2.4.  <code>for(j in 1:nx)</code>:   
</p>
<p>2.5.  <code>xj &lt;- xplit[[j]]</code> 
</p>
<p>2.6.  let <code>jd</code> = the subset of names that 
match <code>xj</code> or <code>subNonStandardNames(xj)</code>
or nicknames of <code>xj;  xlist[j] &lt;- jd</code>.  
</p>
<p>2.7.  return <code>xlist</code> 
</p>


<h3>Value</h3>

<p><code>matchName</code> returns a list of the same 
length as <code>x</code>, each of whose components is
an object obtained as a subset of rows of 
<code>data</code> or <code>NULL</code> if no acceptable 
matches are found.   The list may have an 
attribute <code>namesNotFound</code> as determined 
per the argument of that name.  
</p>
<p><code>matchNames1</code> returns a list of vectors 
of integers for subsets of <code>data</code> 
matching <code>x1</code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parseName">parseName</a></code>
<code><a href="#topic+subNonStandardNames">subNonStandardNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  Names to match exercising many possibile combinations 
##     of surname with 0, 1, &gt;1 matches possibly after 
##     replacing with subNonStandardNames 
##     combined with possibly multiple givenName combinations 
##     with 0, 1, &gt;1 matches possibly requiring replacing with 
##     subNonStandardNames or nicknames 
##
# NOTE:  "-" could also be "e" with an accent;  
#    not included with this documentation, because 
#    non-English characters generate warnings in standard tests.  
Names2mtch &lt;- c("Andr_ Bruce C_rdenas", "Dolores Ella Feinstein",
           "George Homer", "Inez Jane Kappa", "Luke Michael Noel", 
           "Oscar Papa", "Quincy Ra_l Stevens", 
           "Thomas U. Vel_zquez", "William X. Young", 
           "Zebra")
##
## 2.  Data = matrix(..., byrow=TRUE) to exercise the combinations 
##     the combinations from 1 
##
Data1 &lt;- matrix(c("Feld", "Don", "789", 
                  "C_rdenas", "Don", "456", 
                  "C_rdenas", "Andre B.", "123", 
                  "Smith", "George", "aaa", 
                  "Young", "Bill", "369"), 
                ncol=3, byrow=TRUE)
Data1. &lt;- subNonStandardNames(Data1)                
##
## 3.  matchName1
##        
parceNm1 &lt;- parseName(Names2mtch)
match1.1 &lt;- matchName1(parceNm1[, 'surname'], Data1.)

# check
match1.1s &lt;- vector('list', 10)
match1.1s[[1]] &lt;- 2:3
match1.1s[[9]] &lt;- 5
names(match1.1s) &lt;- parceNm1[, 'surname'] 

all.equal(match1.1, match1.1s)


##
## 4.  matchName1 with name = multiple columns 
##
match1.2 &lt;- matchName1(c('Cardenas', 'Don'), Data1., 
                       name=Data1.[, 1:2])

# check 
match1.2a &lt;- list(Cardenas=2:3, Don=1:2)

all.equal(match1.2, match1.2a)


##
## 5.  matchName 
##
nickNames &lt;- matrix(c("William", "Bill"), 1, byrow=TRUE)

match1 &lt;- matchName(Names2mtch, Data1, nicknames=nickNames)
                  
# check 
match1a &lt;- list("Cardenas, Andre Bruce"=Data1[3,, drop=FALSE ], 
                "Feinstein, Dolores Ella"=NULL, 
                "Homer, George"=NULL, "Kappa, Inez Jane"=NULL, 
                "Noel, Luke Michael"=NULL, "Papa, Oscar"=NULL, 
                "Stevens, Quincy Raul"=NULL, 
                "Velazquez, Thomas U."=NULL, 
                "Young, William X."=Data1[5,, drop=FALSE], 
                "Zebra"=NULL)

all.equal(match1, match1a)

##
## 6.  namesNotFound 
##
tstNotFound &lt;- matchName('xx_x', Data1)

# check 
tstNF &lt;- list('xx_x'=NULL)
attr(tstNF, 'namesNotFound') &lt;- 'xx_x'

all.equal(tstNotFound, tstNF)


##
## 7.  matchName(NULL) to simplify use 
##
mtchNULL &lt;- matchName(NULL, Data1)

all.equal(mtchNULL, NULL)

</code></pre>

<hr>
<h2 id='matchQuote'>
Match isolated quotes across records 
</h2><span id='topic+matchQuote'></span>

<h3>Description</h3>

<p>Look for unmatched quotes in a character 
vector.  If found, look for a matching 
quote starting the next character string
in the vector, possibly after a blank 
line.  If found, merge the two strings 
and return the resulting shortened 
character vector.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchQuote(x,  Quote='"', sep=' ', 
          maxChars2append=2, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matchQuote_+3A_x">x</code></td>
<td>

<p>a character vector to scan for unmatched 
<code>Quote</code>s.  
</p>
</td></tr>
<tr><td><code id="matchQuote_+3A_quote">Quote</code></td>
<td>

<p>the <code>Quote</code> character that should 
appear in pairs 
</p>
</td></tr>
<tr><td><code id="matchQuote_+3A_sep">sep</code></td>
<td>

<p><code>sep</code> argument passed to 
<code><a href="base.html#topic+paste">paste</a></code> to combine pairs of 
successive lines with unmatched quotes.  
</p>
</td></tr>
<tr><td><code id="matchQuote_+3A_maxchars2append">maxChars2append</code></td>
<td>

<p>maximum number of characters in the 
following string to concatenate two 
adjacent strings (possibly separated by 
a blank line) with unmatched 
<code>Quote</code>s.   
</p>
</td></tr>
<tr><td><code id="matchQuote_+3A_...">...</code></td>
<td>

<p>optional arguments for 
<code><a href="base.html#topic+gsub">gsub</a></code> 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was written to help parse 
data from the US Department of Health and 
Human Services on 
<a href="https://ocrportal.hhs.gov/ocr/breach/breach_report.jsf">
cyber-security breaches affecting 500 or 
more individuals</a>.  As of 2014-06-03 the 
<code>csv</code> version of these data included 
commas in quotes that are not <code>sep</code> 
characters, quotes that are not matched, 
lines with zero characters, followed by 
lines with 3 characters being a quote and 
a comma.  This function was written 
to drop the blank lines and append the 
quote-comma line to the preceding line so 
it contained matching quotes.  
</p>


<h3>Value</h3>

<p>The input character vector possibly 
shortened with the following attributes 
explaining what was found:  
</p>

<p>indices of the input <code>x</code> with 
an unmatched 
</p>
<dl>
<dt><code>unmatchedQuotes</code></dt><dd>
<p><code>Quote</code>.  
</p>
</dd>
<dt><code>blankLinesDropped</code></dt><dd>
<p>indices of the input <code>x</code> that 
were dropped because they (1) followed 
an unmatched <code>Quote</code> and (2) 
contained no non-blank characters.  
</p>
</dd>
<dt><code>quoteLinesAppended</code></dt><dd>
<p>indices of the input <code>x</code> that were
concatenated with a preceding line 
because the two lines contained unmatched
<code>Quote</code> characters, and concatenating 
them produced a line with all <code>Quote</code>s
matched.  
</p>
</dd>
<dt><code>ncharsAppended</code></dt><dd>
<p>an integer vector of the same length as 
<code>quoteLinesConcatenated</code> giving the
number of characters in the second line
concatenated onto the previous line.  
</p>
</dd>  
</dl>
 


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>See Also</h3>

<p><code><a href="#topic+strsplit1">strsplit1</a></code>
<code><a href="tools.html#topic+delimMatch">delimMatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chvec &lt;- c('abc', 'de"f', ' ', '",', 'g"h',
            'matched"quotes"', '')
ch. &lt;- matchQuote(chvec)

# check 
chv. &lt;- c('abc', 'de"f ",', 'g"h', 
          'matched"quotes"', '')
attr(chv., 'unmatchedQuotes') &lt;- c(2, 4, 5)
attr(chv., 'blankLinesDropped') &lt;- 3
attr(chv., 'quoteLinesAppended') &lt;- 4
attr(chv., 'ncharsAppended') &lt;- 2 

all.equal(ch., chv.)

</code></pre>

<hr>
<h2 id='mergeVote'>
Merge Roll Call Vote
</h2><span id='topic+mergeVote'></span>

<h3>Description</h3>

<p>Merge roll call vote record with a 
<code><a href="base.html#topic+data.frame">data.frame</a></code> containing other 
information.  The <code>vote</code> records are 
typically incomplete, so match first on 
<code>houseSenate</code> and <code>surname</code>.  
If this match is incomplete, try using 
<code>givenName</code>.  If that fails, try
<code>state</code> and <code>district</code>, which may 
not always be present in <code>vote</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeVote(x, vote, Office="House", vote.x, 
          check.x=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeVote_+3A_x">x</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> whose columns 
include <code>Office</code>, <code>surname</code>, and
<code>givenName</code>.
</p>
</td></tr>
<tr><td><code id="mergeVote_+3A_vote">vote</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with column names
which when forced <code><a href="base.html#topic+tolower">tolower</a></code> would
match <code>surname</code>, <code>givenname</code>,
and <code>vote</code>.  However, the 
<code>givenname</code> may not be complete, so use 
it only if the <code>surname</code> is not 
sufficient.
</p>
</td></tr>
<tr><td><code id="mergeVote_+3A_office">Office</code></td>
<td>

<p>Either &quot;House&quot; or &quot;Senate&quot;;  ignored if
<code>vote</code> includes a column <code>Office</code>.
</p>
</td></tr>
<tr><td><code id="mergeVote_+3A_vote.x">vote.x</code></td>
<td>

<p>name of a column of <code>x</code> containing a vote
to be updated with the <code>vote</code> column of 
the <code>vote</code> <code><a href="base.html#topic+data.frame">data.frame</a></code>.
If <code><a href="base.html#topic+missing">missing</a></code> and <code>x</code> has a
column with a name matching &quot;vote&quot;, then
<code>vote.x</code> is that column.  If 
<code><a href="base.html#topic+missing">missing</a></code> but <code>x</code> has no such
column, then append a column to <code>x</code> with
the name of the <code>vote</code> column of the
<code>vote</code> <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>
</td></tr>
<tr><td><code id="mergeVote_+3A_check.x">check.x</code></td>
<td>

<p>logical:  If TRUE, check for rows of 
<code>x[, vote.x]</code> that are NOT in 
<code>vote</code> and throw an error if found.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  Parse <code>vote.x</code> to get the name of 
the column of <code>x</code> into which to write 
the <code>vote</code> column of the <code>vote</code>
<code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>
<p>2.  If the <code>vote</code> <code><a href="base.html#topic+data.frame">data.frame</a></code> 
contains a column <code>Office</code>, ignore the
<code>Office</code> argument.  Otherwise, add the
argument <code>houseSenate</code> as a column of
<code>vote</code>.
</p>
<p>3. Create <code>keyx &lt;- with(x, paste(Office, 
  surname, sep=":"))</code>, 
<code>keyx2 &lt;- paste(keyx, givenName, sep=":")</code>,
<code>keyx. &lt;-
  paste(houseSenate, state, district, sep=":")</code>, 
and similarly <code>keyv</code>, <code>leyv2</code>, and
<code>keyv.</code> from <code>vote</code>.
</p>
<p>4.  Look for <code>keyv</code> in <code>keyx</code>.  When a
unique match is found, transfer the vote the
<code>vote</code> column of <code>x</code>.  When no
match is found, try for <code>keyv2</code> in 
<code>keyx2</code> or <code>keyv.</code> in <code>keyx.</code>  
If those fail, print an error message with the
information from <code>vote</code> on all failures 
and ask the user to add <code>state</code> and 
<code>district</code> information.
</p>
<p>5. <code>if(check.x)</code>, check for rows in 
<code>x[, vote.x]</code> that are NOT 
<code>notEligible</code> but are also not in 
<code>vote</code>:  Throw an error if any are found.
</p>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with the same 
columns as <code>x</code> with its vote column 
modified per the <code>vote</code> argument.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mergeUShouse.senate">mergeUShouse.senate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  Test good cases
##
votetst &lt;- data.frame(
  surName=c('Smith', 'Jones', 'Graves', 'Jsn', 'Jsn', 'Gay'),
  givenName=c("Sam", "", "", "John", "John", ''),
  votex=factor(c('Y', 'N', 'abstain', 'Y', 'Y', 'Y')),
  State=factor(rep(c("CA", "", "SC", "NY"), c(1, 2, 1, 2))),
  district=rep(c("13", "1", "2", "1"), c(1, 2, 2, 1)),
  stringsAsFactors=FALSE )

x1 &lt;- data.frame(
  Office=factor(rep(c("House", "Senate"), e=8)),
  state=rep(c("NY", "SC", "SD", "CA", "AK", "AR", "NY", "NJ"), 2),
  District=rep(c("2", "2", "At Large", "13", "1", "9", "1", "3"), 2),
  surname=rep(c('Jsn', 'Jsn', 'Smith', 'Smith', 'Jones',
       'Graves', 'Rx', 'Agnew'), 2),
  givenName=rep(c("John D.", "John J.",
    "Samual", "Samual", "Mary", "Mary", "Susan", 'Spiro'), 2),
  don=1:16, stringsAsFactors=FALSE)

x1. &lt;- mergeVote(x1, votetst)

x2 &lt;- cbind(x1, votex=factor( rep(
   c('Y', 'notEligible', 'Y', 'N', 'abstain', 'Y', 'notEligible'),
   c(2,1,1,1,1,1,9) ) ) )


all.equal(x1., x2)


##
## 2.  Test a case with a vote error in x
##

x1a &lt;- cbind(x1, voterr=rep(
     c('notEligible', 'Y', 'notEligible'), c(7, 1, 8)))

x1a. &lt;- try(mergeVote(x1a, votetst))


class(x1a.)=='try-error'


</code></pre>

<hr>
<h2 id='missing0'>
Missing or length 0  
</h2><span id='topic+missing0'></span>

<h3>Description</h3>

<p>TRUE if <code>x</code> is missing or if <code>length(x)</code> 
is 0.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing0(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missing0_+3A_x">x</code></td>
<td>
 
<p>a formal argument as for <code><a href="base.html#topic+missing">missing</a></code>  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only makes sense called from within another function
</p>


<h3>Value</h3>

<p><code><a href="base.html#topic+logical">logical</a></code>:  TRUE if <code>x</code> is 
<code><a href="base.html#topic+missing">missing</a></code> or if <code>length(x)</code> is 0.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+missing">missing</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tstFn &lt;- function(x)missing0(x)
# missing 

all.equal(tstFn(), TRUE)


# length 0 

all.equal(tstFn(logical()), TRUE)


# supplied 

all.equal(tstFn(1), FALSE)


</code></pre>

<hr>
<h2 id='nchar0'>
Zero characters or NULL 
</h2><span id='topic+nchar0'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if <code>(is.null(x) || 
  (length(x) == 0) || (max(nchar(x)) == 0))</code>.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nchar0(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nchar0_+3A_x">x</code></td>
<td>

<p>a character vector or something that can 
be coerced to mode character 
</p>
</td></tr>
<tr><td><code id="nchar0_+3A_...">...</code></td>
<td>

<p>optional arguments to be passed to 
<code><a href="base.html#topic+nchar">nchar</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is either
<code>NULL</code> or <code>max(nchar(x))</code> 
== 0.  <code>FALSE</code> otherwise.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+nchar">nchar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
all.equal(nchar0(NULL), TRUE)



all.equal(nchar0(character(0)), TRUE)



all.equal(nchar0(character(3)), TRUE)



all.equal(nchar0(c('a', 'c')), FALSE)

</code></pre>

<hr>
<h2 id='Newdata'>
Create a new data.frame for predict 
</h2><span id='topic+Newdata'></span>

<h3>Description</h3>

<p>Generate a new <code><a href="base.html#topic+data.frame">data.frame</a></code> or 
<code><a href="base.html#topic+matrix">matrix</a></code> from another with column(s) 
selected by <code>x</code> adopting <code>n</code> values in 
<code>range(data[,x])</code> and all other columns 
constant.  
</p>
<p>If <code><a href="#topic+canbeNumeric">canbeNumeric</a></code>(x) is <code>TRUE</code>, 
the output has <code>x</code> adopting <code>n</code> 
values in the <code><a href="base.html#topic+range">range</a></code>(x) and all 
other numeric variables at their 
<code><a href="stats.html#topic+median">median</a></code> and other variables at 
their most common values.  
</p>
<p>If <code><a href="#topic+canbeNumeric">canbeNumeric</a></code>(x) is <code>FALSE</code>, 
the output has <code>x</code> adopting all possible
values of <code>x</code> with all other variables at 
the same constant values as when 
<code><a href="#topic+canbeNumeric">canbeNumeric</a></code>(x) is <code>TRUE</code> (and
<code>n</code> is ignored).  If <code>x</code> has a 
<code><a href="base.html#topic+levels">levels</a></code> attribute, the possible
values are defined by that <code><a href="base.html#topic+levels">levels</a></code>
attribute.  Otherwise, it is defined by 
<code><a href="base.html#topic+unique">unique</a></code>(x).  
</p>
<p>This is designed to create a new 
<code><a href="base.html#topic+data.frame">data.frame</a></code> to be used as 
<code>newdata</code> for <code><a href="stats.html#topic+predict">predict</a></code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Newdata(data, x, n, na.rm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Newdata_+3A_data">data</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> or matrix.  
</p>
</td></tr>
<tr><td><code id="Newdata_+3A_x">x</code></td>
<td>

<p>name of a column of <code>data</code>.  If 
<code>NA</code> or <code>NULL</code>, select all columns 
of <code>data</code>.  
</p>
</td></tr>
<tr><td><code id="Newdata_+3A_n">n</code></td>
<td>

<p>an <code><a href="base.html#topic+integer">integer</a></code> vector indicating 
the number of levels of <code>data[, x]</code> if 
<code>canbeNumeric(datat[, x])</code>.  If 
<code>canbeNumeric(datat[, x])</code> is 
<code>FALSE</code>, take at most <code>n</code> of the 
most popular levels.    
</p>
<p>Default is 2 if <code>length(x)</code> &gt; 1 or if 
<code>x</code> is either <code>NA</code> or <code>NULL</code>.  
</p>
<p>If <code>n</code> = 1, use the median for 
<code>canbeNumeric</code> and the most popular level
otherwise.  
</p>
<p>If <code>n</code> &lt; 1, drop that variable.  
</p>
</td></tr>
<tr><td><code id="Newdata_+3A_na.rm">na.rm</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code> passed to 
<code><a href="base.html#topic+range">range</a></code>(x)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  Check <code>data, x</code>.  
</p>
<p>2.  If <code><a href="#topic+canbeNumeric">canbeNumeric</a></code>(x) is 
<code>TRUE</code>, let <code>xNew</code> be <code>n</code> 
values spanning <code><a href="base.html#topic+range">range</a></code>(x).  Else, 
let 
<code>xNew</code> &lt;- <code><a href="base.html#topic+levels">levels</a></code>(x).  
</p>
<p>3.  If <code><a href="base.html#topic+is.null">is.null</a></code>(<code>xNew</code>), set 
it to 
<code><a href="base.html#topic+sort">sort</a></code>(<code><a href="base.html#topic+unique">unique</a></code>(x)).  
</p>
<p>4.  let <code>newDat &lt;- data[rep(1, n), ]</code>, 
and replace <code>x</code> by <code>xNew</code>.  
</p>
<p>5.  <code>otherVars &lt;- colnames(data) != x</code>
</p>
<p>6.  <code>for(x2 in otherVars)</code> 
replace <code>newDat[, x2]</code>:  
If <code><a href="#topic+canbeNumeric">canbeNumeric</a></code>(x2) is <code>TRUE</code>, 
use <code><a href="stats.html#topic+median">median</a></code>(x2).  Otherwise, 
use its (first) most common value.  
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with <code>n</code>
rows and columns matching those of 
<code>data</code>, as described above.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.lm">predict.lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  A reasonable test with numerics, dates, 
##     an ordered factor and character variables
##
xDate &lt;- as.Date('2001-02-03')+1:4
tstDF &lt;- data.frame(x1=1:4, xDate=xDate, 
  xD2=as.POSIXct(xDate), 
  sex=ordered(c('M', 'F', 'M', 'F')), 
  huh=letters[c(1:3, 3)], stringsAsFactors=FALSE)

newDat &lt;- Newdata(tstDF, 'xDate', n=5)

# check
newD &lt;- data.frame(x1=2.5, 
  xDate=xDate[1]+seq(0, 3, length=5), 
  xD2=as.POSIXct(xDate[2]+0.5), 
  sex=ordered(c('M', 'F', 'M', 'F'))[2], 
  huh=letters[3], stringsAsFactors=FALSE)
attr(newD, 'out.attrs') &lt;- attr(newDat, 'out.attrs')

all.equal(newDat, newD)


##
## 2.  Test with only one column 
##
newDat1 &lt;- Newdata(tstDF[, 2, drop=FALSE], 'xDate', n=5)

# check 
newDat1. &lt;- newD[, 2, drop=FALSE]
attr(newDat1., 'out.attrs') &lt;- attr(newDat1, 'out.attrs')

all.equal(newDat1, newDat1.)


##
## 3.  Test with a factor 
##
newSex &lt;- Newdata(tstDF, 'sex')

# check 
newS &lt;- with(tstDF, data.frame(
  x1=2.5, xDate=xDate[1]+1.5, 
  xD2=as.POSIXct(xDate[1]+1.5), 
  sex=ordered(c('M', 'F'))[2:1], 
  huh=letters[3], stringsAsFactors=FALSE) )
attr(newS, 'out.attrs') &lt;- attr(newSex, 'out.attrs')

all.equal(newSex, newS)


##
## 4.  Test with an integer column number 
##
newDat2 &lt;- Newdata(tstDF, 2, n=5)

# check 

all.equal(newDat2, newD)


##
## 5.  Test with all
##
NewAll &lt;- Newdata(tstDF)

# check 
tstLvls &lt;- as.list(tstDF[c(1, 4), ])
tstLvls$sex &lt;- tstDF$sex[2:1]
tstLvls$huh &lt;- letters[c(3, 1)]
tstLvls$stringsAsFactors &lt;- FALSE

NewA. &lt;- do.call(expand.grid, tstLvls)
attr(NewA., 'out.attrs') &lt;- attr(NewAll, 'out.attrs')

all.equal(NewAll, NewA.)

</code></pre>

<hr>
<h2 id='parseCommas'>
Convert character string with Dollar signs 
and commas to numerics
</h2><span id='topic+parseCommas'></span><span id='topic+parseCommas.default'></span><span id='topic+parseCommas.data.frame'></span>

<h3>Description</h3>

<p><code>as.numeric</code> of character strings after 
suppressing commas and dollar signs.  This 
is a generalization of 
<code><a href="#topic+parseDollars">parseDollars</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseCommas(x, pattern='\\$|,', 
    replacement='', acceptableErrorRate=0, ...)
## Default S3 method:
parseCommas(x, 
    pattern='\\$|,', replacement='',
    acceptableErrorRate=0, ...)
## S3 method for class 'data.frame'
parseCommas(x, 
    pattern='\\$|,', replacement='',
    acceptableErrorRate=0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parseCommas_+3A_x">x</code></td>
<td>

<p>vector of character strings to be converted 
to numerics
</p>
</td></tr>
<tr><td><code id="parseCommas_+3A_pattern">pattern</code></td>
<td>

<p>regular expression to be replaced by 
<code>replacement</code>
</p>
</td></tr>
<tr><td><code id="parseCommas_+3A_replacement">replacement</code></td>
<td>

<p>Character string to substitute for each 
occurrence of <code>pattern</code>
</p>
</td></tr>
<tr><td><code id="parseCommas_+3A_acceptableerrorrate">acceptableErrorRate</code></td>
<td>

<p>number indicating the proportion of new 
<code>NA</code>s to that can be introduced and 
still assume it's numeric
</p>
</td></tr>
<tr><td><code id="parseCommas_+3A_...">...</code></td>
<td>

<p>optional arguments to pass to 
<code><a href="base.html#topic+gsub">gsub</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.numeric(gsub(x, ...))</code>
</p>
<p>The <code><a href="base.html#topic+data.frame">data.frame</a></code> method outputs 
another <code><a href="base.html#topic+data.frame">data.frame</a></code> with character 
or factor columns converted to numerics using
<code>parseDollars</code> whenever that can be done
without creating <code>NA</code>s.
</p>


<h3>Value</h3>

<p>Numeric vector converted from the character 
strings in <code>x</code> or a <code><a href="base.html#topic+data.frame">data.frame</a></code> 
with columns that are obviously numbers in
character format converted to numerics.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+gsub">gsub</a></code>
<code><a href="base.html#topic+as.numeric">as.numeric</a></code>
<code><a href="#topic+parseDollars">parseDollars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  a character vector
##
X2 &lt;- c('-$2,500', '$5,000.50')
x2 &lt;- parseDollars(X2)


all.equal(x2, c(-2500, 5000.5))


##
## A data.frame
##
chDF &lt;- data.frame(let=letters[1:2], Dol=X2, dol=x2)
numDF &lt;- parseCommas(chDF)

chkDF &lt;- chDF
chkDF$Dol &lt;- x2

all.equal(numDF, chkDF)

</code></pre>

<hr>
<h2 id='parseDollars'>
Convert character string with Dollar signs 
and commas to numerics
</h2><span id='topic+parseDollars'></span>

<h3>Description</h3>

<p>as.numeric of character strings after 
suppressing commas and dollar signs.  This is 
a special case of <code><a href="#topic+parseCommas">parseCommas</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseDollars(x, pattern='\\$|,', 
        replacement='', ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parseDollars_+3A_x">x</code></td>
<td>

<p>vector of character strings to be converted 
to numerics
</p>
</td></tr>
<tr><td><code id="parseDollars_+3A_pattern">pattern</code></td>
<td>

<p>regular expression to be replaced by 
<code>replacement</code>
</p>
</td></tr>
<tr><td><code id="parseDollars_+3A_replacement">replacement</code></td>
<td>

<p>Character string to substitute for each 
occurrence of <code>pattern</code>
</p>
</td></tr>
<tr><td><code id="parseDollars_+3A_...">...</code></td>
<td>

<p>optional arguments to pass to 
<code><a href="base.html#topic+gsub">gsub</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.numeric(gsub(x, ...))</code>.  See also 
<code><a href="#topic+parseCommas">parseCommas</a></code>.
</p>


<h3>Value</h3>

<p>Numeric vector converted from <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+gsub">gsub</a></code>
<code><a href="base.html#topic+as.numeric">as.numeric</a></code>
<code><a href="#topic+parseCommas">parseCommas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  a character vector
##
X2 &lt;- c('-$2,500', '$5,000.50')
x2 &lt;- parseDollars(X2)


all.equal(x2, c(-2500, 5000.5))


##
## A data.frame
##
chDF &lt;- data.frame(let=letters[1:2], Dol=X2, dol=x2)
numDF &lt;- parseCommas(chDF)

chkDF &lt;- chDF
chkDF$Dol &lt;- x2

all.equal(numDF, chkDF)

</code></pre>

<hr>
<h2 id='parseName'>
Parse surname and given name
</h2><span id='topic+parseName'></span>

<h3>Description</h3>

<p>Identify the presumed surname in a character 
string assumed to represent a name and return 
the result in a character matrix with 
<code>surname</code> followed by <code>givenName</code>.  
If only one name is provided (without 
punctuation), it is assumed to be the 
<code>givenName</code>;  see Wikipedia, 
<a href="https://en.wikipedia.org/wiki/Given_name">&quot;Given name&quot;</a> 
and <a href="https://en.wikipedia.org/wiki/Surname">&quot;Surname&quot;</a>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseName(x, 
    surnameFirst=(median(regexpr(',', x))&gt;0),
    suffix=c('Jr.', 'I', 'II', 'III', 'IV', 
              'Sr.', 'Dr.', 'Jr', 'Sr'),
    fixNonStandard=subNonStandardNames, 
    removeSecondLine=TRUE, 
    namesNotFound="attr.replacement", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parseName_+3A_x">x</code></td>
<td>

<p>a character vector
</p>
</td></tr>
<tr><td><code id="parseName_+3A_surnamefirst">surnameFirst</code></td>
<td>

<p>logical:  If TRUE, the surname comes first 
followed by a comma (&quot;,&quot;), then the given 
name.  If FALSE, parse the surname from a
standard Western &quot;John Smith, Jr.&quot; format.  
If <code>missing(surnameFirst)</code>, use TRUE 
if half of the elements of <code>x</code> 
contain a comma.
</p>
</td></tr>
<tr><td><code id="parseName_+3A_suffix">suffix</code></td>
<td>

<p>character vector of strings that are NOT 
a surname but might appear at the end 
without a comma that would otherwise 
identify it as a suffix.
</p>
</td></tr>
<tr><td><code id="parseName_+3A_fixnonstandard">fixNonStandard</code></td>
<td>

<p>function to look for and repair 
nonstandard names such as names 
containing characters with accent marks 
that are sometimes mangled
by different software.  Use 
<code><a href="base.html#topic+identity">identity</a></code> if this is not
desired.
</p>
</td></tr>
<tr><td><code id="parseName_+3A_removesecondline">removeSecondLine</code></td>
<td>

<p>logical:  If TRUE, delete anything 
following &quot;\n&quot; and return it as
an attribute <code>secondLine</code>.  
</p>
</td></tr>
<tr><td><code id="parseName_+3A_namesnotfound">namesNotFound</code></td>
<td>

<p>character vector passed to 
<code>subNonStandardNames</code> and used 
to compute any <code>namesNotFound</code> 
attribute of the object returned 
by <code>parseName</code>.  
</p>
</td></tr>
<tr><td><code id="parseName_+3A_...">...</code></td>
<td>
<p> optional arguments 
passed to <code>fixNonStandard</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>surnameFirst</code> is <code>FALSE</code>:
</p>
<p>1.  If the last character is &quot;)&quot; and 
the matching &quot;(&quot; is 3 characters earlier, 
drop all that stuff.  Thus, &quot;John Smith 
(AL)&quot; becomes &quot;John Smith&quot;.
</p>
<p>2.  Look for commas to identify a suffix 
like Jr. or III;  remove and call the 
rest x2.
</p>
<p>3.  <code>split &lt;- strsplit(x2, " ")</code>
</p>
<p>4.  Take the last as the surname.
</p>
<p>5.  If the &quot;surname&quot; found per 3 is in 
<code>suffix</code>, save to append it to the 
<code>givenName</code> and recurse to get the 
actual surname.
</p>
<p>NOTE:  This gives the wrong answer with 
double surnames written without a hyphen 
in the Spanish tradition, in which, e.g., 
&quot;Anastasio Somoza Debayle&quot;, &quot;Somoza Debayle&quot; 
give the (first) surnames of Anastasio's 
father and mother, respectively:  The 
current algorithm would return &quot;Debayle&quot; 
as the surname, which is incorrect.
</p>
<p>6.  Recompose the rest with any suffix as 
the <code>givenName</code>.
</p>


<h3>Value</h3>

<p>a character matrix with two columns:  
surname and <code>givenName</code>.  
</p>
<p>This matrix also has a 
<code>namesNotFound</code> attribute if one is 
returned by <code>subNonStandardNames</code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strsplit">strsplit</a></code>
<code><a href="base.html#topic+identity">identity</a></code>
<code><a href="#topic+subNonStandardNames">subNonStandardNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  Parse standard first-last name format
##
tstParse &lt;- c('Joe Smith (AL)', 'Teresa Angelica Sanchez de Gomez',
         'John Brown, Jr.', 'John Brown Jr.',
         'John W. Brown III', 'John Q. Brown,I',
         'Linda Rosa Smith-Johnson', 'Anastasio Somoza Debayle',
         'Ra_l Vel_zquez', 'Sting', 'Colette, ')
parsed &lt;- parseName(tstParse)

tstParse2 &lt;- matrix(c('Smith', 'Joe', 'Gomez', 'Teresa Angelica Sanchez de',
  'Brown', 'John, Jr.', 'Brown', 'John, Jr.',
  'Brown', 'John W., III', 'Brown', 'John Q., I',
  'Smith-Johnson', 'Linda Rosa', 'Debayle', 'Anastasio Somoza',
  'Velazquez', 'Raul', '', 'Sting', 'Colette', ''),
  ncol=2, byrow=TRUE)
# NOTE:  The 'Anastasio Somoza Debayle' is in the Spanish tradition
# and is handled incorrectly by the current algorithm.
# The correct answer should be "Somoza Debayle", "Anastasio".
# However, fixing that would complicate the algorithm excessively for now.
colnames(tstParse2) &lt;- c("surname", 'givenName')


all.equal(parsed, tstParse2)


##
## 2.  Parse "surname, given name" format
##
tst3 &lt;- c('Smith (AL),Joe', 'Sanchez de Gomez, Teresa Angelica',
     'Brown, John, Jr.', 'Brown, John W., III', 'Brown, John Q., I',
     'Smith-Johnson, Linda Rosa', 'Somoza Debayle, Anastasio',
     'Vel_zquez, Ra_l', ', Sting', 'Colette,')
tst4 &lt;- parseName(tst3)

tst5 &lt;- matrix(c('Smith', 'Joe', 'Sanchez de Gomez', 'Teresa Angelica',
  'Brown', 'John, Jr.', 'Brown', 'John W., III', 'Brown', 'John Q., I',
  'Smith-Johnson', 'Linda Rosa', 'Somoza Debayle', 'Anastasio',
  'Velazquez', 'Raul', '','Sting', 'Colette',''),
  ncol=2, byrow=TRUE)
colnames(tst5) &lt;- c("surname", 'givenName')


all.equal(tst4, tst5)


##
## 3.  secondLine 
##
L2 &lt;- parseName(c('Adam\n2nd line', 'Ed  \n --Vacancy', 'Frank'))

# check 
L2. &lt;- matrix(c('', 'Adam', '', 'Ed', '', 'Frank'), 
              ncol=2, byrow=TRUE)
colnames(L2.) &lt;- c('surname', 'givenName')
attr(L2., 'secondLine') &lt;- c('2nd line', ' --Vacancy', NA)

all.equal(L2, L2.)


##
## 4.  Force surnameFirst when in a minority 
##
snf &lt;- c('Sting', 'Madonna', 'Smith, Al')
SNF &lt;- parseName(snf, surnameFirst=TRUE)

# check 
SNF2 &lt;- matrix(c('', 'Sting', '', 'Madonna', 'Smith', 'Al'), 
               ncol=2, byrow=TRUE)
colnames(SNF2) &lt;- c('surname', 'givenName')               

all.equal(SNF, SNF2)


##
## 5.  nameNotFound
##
noSub &lt;- parseName('xx_x')

# check 
noSub. &lt;- matrix(c('', 'xx_x'), 1)
colnames(noSub.) &lt;- c('surname', 'givenName')               
attr(noSub., 'namesNotFound') &lt;- 'xx_x'

all.equal(noSub, noSub.)

</code></pre>

<hr>
<h2 id='Ping'>
ping a Uniform resource locator (URL)
</h2><span id='topic+Ping'></span>

<h3>Description</h3>

<p>***NOTE:  THIS IS A PRELIMINARY VERSION OF 
THIS FUNCTION;
***NOTE:  IT MAY BE CHANGED OR REMOVED IN 
A FUTURE RELEASE.
</p>
<p>ping a Uniform resource locator (URL) or 
Internet Protocol (IP) address.
</p>
<p>NOTE:  Some Internet Service Providers (ISPs) 
play games with &quot;ping&quot;.  That makes the results 
of <code>Ping</code> unreliable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ping(url, pingArgs='', warn=NA,
     show.output.on.console=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ping_+3A_url">url</code></td>
<td>

<p>a character string of a URL or IP address to
ping.  If <code>url</code> is a vector of length
greater than 1, only the first component is
used.
</p>
</td></tr>
<tr><td><code id="Ping_+3A_pingargs">pingArgs</code></td>
<td>

<p>arguments to pass to the <code>ping</code> command 
of typical operating systems via
</p>
<p><code>pingResult &lt;- system(paste('ping',
        pingArgs, url), intern=TRUE, ...)</code>
</p>
</td></tr>
<tr><td><code id="Ping_+3A_warn">warn</code></td>
<td>

<p>value for <code>options('warn')</code> during the 
call to <code><a href="base.html#topic+system">system</a></code>.  <code>NA</code> to 
not change <code>options('warn')</code> during 
this call.
</p>
</td></tr>
<tr><td><code id="Ping_+3A_show.output.on.console">show.output.on.console</code></td>
<td>

<p>argument for <code><a href="base.html#topic+system">system</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  <code>urlSplit0 &lt;- strsplit(url, '://')[[1]]</code>
</p>
<p>2.  <code>urlS0 &lt;- urlSplit0[min(2, 
  length(urlSplit0))]</code>
</p>
<p>3.  <code>host &lt;- strsplit(urlS0, '/')[[1]][1]</code>
</p>
<p>4.  <code>pingCmd &lt;- paste('ping', pingArgs, 
  host)</code>
</p>
<p>5.  <code>system(pingCmd, intern=TRUE, ...)</code>
</p>


<h3>Value</h3>

<p>list with the following components:
</p>
<table role = "presentation">
<tr><td><code>rawResults</code></td>
<td>

<p>character vector of the raw results from 
the ping command
</p>
</td></tr>
<tr><td><code>rawNumbers</code></td>
<td>

<p>numeric vector of the times measured
</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>

<p>numeric vector of numbers of packets 
sent, received, and lost
</p>
</td></tr>
<tr><td><code>p.lost</code></td>
<td>

<p>proportion lost = lost / sent
</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>

<p>numeric vector of <code>min, avg (mean), max,
    and mdev</code> (standard deviation) of the 
measured round trip times
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+system">system</a></code>, <code><a href="base.html#topic+options">options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Some ISPs play games with ping.
## Therefore, the results are not reliable.
##
## Not run: 
##
## good
##
(google &lt;- Ping('https://google.com/ping works on host not pages'))

\dontshow{stopifnot(}
with(google, (counts[1]&gt;0) &amp;&amp; (counts[3]&lt;1))
\dontshow{)}

##
## ping oops &lt;&lt;-- at one time, this failed.
##      However, with some ISPs, it works, so don't test it.
##

##
(couldnotfindhost &lt;- Ping('oops'))

\dontshow{stopifnot(}
with(couldnotfindhost,
     length(grep('could not find host', rawResults))&gt;0)
\dontshow{)}

##
## impossible, but not so obvious
##
(requesttimedout &lt;- Ping('requesttimedout.com'))

\dontshow{stopifnot(}
with(requesttimedout, (counts[1]&gt;0) &amp;&amp; (counts[2]&lt;1) &amp;&amp;
         (counts[3]&gt;0))
\dontshow{)}

## End(Not run)
</code></pre>

<hr>
<h2 id='pmatch2'>
Value matching or partial matching
</h2><span id='topic+pmatch2'></span>

<h3>Description</h3>

<p><code>pmatch2</code> returns a list of the positions 
of matches or partial matches of <code>x</code> in
<code>table</code>.  
</p>
<p>This does sloppy matching to find &quot;Peter&quot; 
to match &quot;Pete&quot; only if &quot;Pete&quot; is not in
<code>table</code>, and we want &quot;John Peter&quot; if 
neither &quot;Pete&quot; nor &quot;Peter&quot; are in 
<code>table</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmatch2(x, table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmatch2_+3A_x">x</code></td>
<td>

<p>the values to be matched
</p>
</td></tr>
<tr><td><code id="pmatch2_+3A_table">table</code></td>
<td>

<p>the values to be matched against
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  <code>nx &lt;- length(x); 
  out &lt;- vector(nx, "list"); 
  names(out) &lt;- x</code>
</p>
<p>2.  <code>for(ix in seq(length=nx))</code>:  
3.  <code>xi &lt;- which(x[ix] %in% table)</code>
</p>
<p>4.  <code>if(length(xi)&lt;1)
  xi &lt;- grep(paste0('^', x[ix]), table)</code>.  
</p>
<p>5.  <code>if(length(xi)&lt;1)xi &lt;- 
  grep(x[ix], table)</code>.  
</p>
<p>6.  <code>out[[ix]] &lt;- xi</code> 
</p>


<h3>Value</h3>

<p>A list of integer vectors indicating the 
positions in <code>table</code> matching each element 
of <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code>
<code><a href="base.html#topic+pmatch">pmatch</a></code>
<code><a href="base.html#topic+grep">grep</a></code>
<code><a href="#topic+matchName">matchName</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  common examples 
##
x2match &lt;- c('Pete', 'Peter', 'Ma', 'Mo', 'Paul', 
             'Cardenas')

tbl &lt;- c('Peter', 'Mary', 'Martha', 'John Paul', 'Peter', 
         'Cardenas', 'Cardenas') 

x2mtchd &lt;- pmatch2(x2match, tbl) 

# answer
x2mtchd. &lt;- list(Pete=c(1, 5), Peter=c(1, 5), Ma=2:3, 
    Mo=integer(0), Paul=4, Cardenas=6:7)

all.equal(x2mtchd, x2mtchd.)

##
## 2.  strange cases that caused errors and are now warnings
##
huh &lt;- pmatch2("(7", tbl)

# answer 
huh. &lt;- list("(7"=integer(0))

all.equal(huh, huh.)


</code></pre>

<hr>
<h2 id='pmatchIC'>
pmatch ignoring case
</h2><span id='topic+pmatchIC'></span>

<h3>Description</h3>

<p><code>pmatch</code> with an additional 
<code>ignoreCase</code> argument, returning 
a name not an index like 
<code><a href="base.html#topic+pmatch">pmatch</a></code> (and returning 
a name if supplied a number, unlike
<code><a href="base.html#topic+pmatch">pmatch</a></code>, which coerces 
the input to numeric).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmatchIC(x, table, nomatch = NA_integer_, 
  duplicates.ok = FALSE, 
  ignoreCase=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmatchIC_+3A_x">x</code></td>
<td>

<p>the values to be matched.  
If <code>is.numeric(x)</code>, 
<code>pmatch2</code> returns 
<code>table[x]</code>.  
</p>
<p>This is different from 
<code><a href="base.html#topic+pmatch">pmatch</a></code>, which 
matches <code>as.character(x)</code>. 
</p>
<p>Otherwise, if <code>ignoreCase</code>
is <code>TRUE</code>, <code>pmatchIC</code>
returns 
<code>pmatch(tolower(x), tolower(table))</code>.  
</p>
</td></tr>
<tr><td><code id="pmatchIC_+3A_table">table</code></td>
<td>

<p>the values to be matched against: 
converted to a character vector, 
per <code><a href="base.html#topic+pmatch">pmatch</a></code>. 
</p>
</td></tr>
<tr><td><code id="pmatchIC_+3A_nomatch">nomatch</code></td>
<td>

<p>the value to be returned at 
non-matching or multiply partially 
matching positions. 
</p>
</td></tr>
<tr><td><code id="pmatchIC_+3A_duplicates.ok">duplicates.ok</code></td>
<td>

<p>should elements be in table be used 
more than once? (See <code>pmatch</code>
for an example.)
</p>
</td></tr>
<tr><td><code id="pmatchIC_+3A_ignorecase">ignoreCase</code></td>
<td>

<p>logical:  if <code>TRUE</code> and 
<code>x</code> is character, 
<code>pmatchIC</code> returns 
<code>pmatch(tolower(x), tolower(table))</code>.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of matches.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+pmatch">pmatch</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>yr &lt;- pmatchIC('Yr', c('y1', 'yr', 'y2'))

all.equal('yr', yr)


# integer
m2 &lt;- pmatchIC(2, table=letters)

all.equal(m2, 'b')

</code></pre>

<hr>
<h2 id='qqnorm2'>
Normal Probability Plot with Multiple Symbols
</h2><span id='topic+qqnorm2'></span><span id='topic+plot.qqnorm2'></span><span id='topic+lines.qqnorm2'></span><span id='topic+points.qqnorm2'></span>

<h3>Description</h3>

<p>Create a normal probability plot with one 
line and different symbols for the values of 
another variable, <code>z</code>.  
</p>
<p><code>qqnorm2</code> produces an object of class 
<code>qqnorm2</code>, whose plot method produces 
the plot.
</p>
<p>To create a normal normal probability plots 
with multiple lines, see <code><a href="#topic+qqnorm2t">qqnorm2t</a></code> 
or <code><a href="#topic+qqnorm2s">qqnorm2s</a>:x</code>.  
</p>

<ul>
<li> <p><code><a href="#topic+qqnorm2s">qqnorm2s</a></code> produces a plot 
with multiple lines specified either by 
different names in a character vector 
<code>y</code> or by different 
<code><a href="base.html#topic+data.frame">data.frame</a></code>s in a list 
<code>data.</code>, with different points labeled 
according to the different levels of <code>z</code>.  
</p>
</li>
<li> <p><code><a href="#topic+qqnorm2t">qqnorm2t</a></code> produces a plot 
with multiple lines with <code>y</code> split on 
different levels of <code>x</code>, optionally 
with different points labeled according to 
different levels of <code>z</code>.  
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>qqnorm2(y, z, plot.it=TRUE, datax=TRUE, pch=NULL, 
        ...)
## S3 method for class 'qqnorm2'
plot(x, y, ...)
## S3 method for class 'qqnorm2'
lines(x, ...)
## S3 method for class 'qqnorm2'
points(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqnorm2_+3A_y">y</code></td>
<td>

<p>For <code>qnorm2</code>, <code>y</code> is a numeric 
vector for which a normal probability plot is 
desired.
</p>
<p>For <code>plot.qqnorm2</code>, <code>y</code> is ignored;  
it is included, because the generic 
<code><a href="base.html#topic+plot">plot</a></code> function requires it.
</p>
</td></tr>
<tr><td><code id="qqnorm2_+3A_z">z</code></td>
<td>

<p>A variable to indicate different plotting 
symbols.
</p>
<p>NOTE:  <code>is.logical(z)</code> is replaced by 
<code>z &lt;- as.character(z)</code>. 
</p>
<p>Otherwise, <code>pch[z]</code> would delete symbols 
in <code>pch</code> for which <code>z</code> is 
<code>FALSE</code> and would recycle the remaining 
symbols.  That would rarely be what we want.  
</p>
</td></tr>
<tr><td><code id="qqnorm2_+3A_plot.it">plot.it</code></td>
<td>

<p>logical:  Should the result be plotted?
</p>
</td></tr>
<tr><td><code id="qqnorm2_+3A_datax">datax</code></td>
<td>

<p>The <code>datax</code> argument of 
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code>:  If <code>TRUE</code>, the
data are displayed on the horizontal rather 
than the vertical axis.  (The default value 
for <code>datax</code> is the opposite of that for
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code>.)
</p>
</td></tr>
<tr><td><code id="qqnorm2_+3A_x">x</code></td>
<td>

<p>an object of class <code>qqnorm2</code>.
</p>
</td></tr>
<tr><td><code id="qqnorm2_+3A_pch">pch</code></td>
<td>

<p>a named vector of the plotting symbols to 
be used with names corresponding to the 
levels of z.  If <code>pch</code> is provided, 
it must either have names corresponding to 
levels of <code>z</code>, or <code>z</code> must be 
integers between 1 and <code>length(pch)</code>.
</p>
<p>Otherwise, if <code>z</code> takes levels 
<code>FALSE</code> and <code>TRUE</code> (or 0 and 1), 
<code>pch=c(4, 1)</code> to plot an &quot;x&quot; for 
<code>FALSE</code> and &quot;o&quot; for <code>TRUE</code>.
</p>
<p>Or if <code>z</code> assumes integer values 
between 0 and 255, by default, the symbols 
are chosen as described with 
<code><a href="graphics.html#topic+points">points</a></code>.
</p>
<p>NOTE:  *** <code>points.qqnorm2</code> may not 
work properly for <code>z</code> being integer 
between 0 and 255.  <code>lines.qqnorm2</code> 
is more likely to work in such 
cases.  *** No time to fix this as of 
2018-01-20.  
</p>
<p>Otherwise, by default, <code>z</code> is 
coerced to <code><a href="base.html#topic+character">character</a></code>, and 
the result is plotted.
</p>
</td></tr>
<tr><td><code id="qqnorm2_+3A_...">...</code></td>
<td>

<p>Optional arguments.
</p>
<p>For <code>plot.qqnorm2</code>, they are passed 
to <code>plot</code>.
</p>
<p>For <code>qqnorm2</code>, they are passed to 
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code> and to 
<code>plot.qqnorm2</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>qqnorm2</code>:
</p>
<p><code>qq1.  q2 &lt;- qqnorm(y, datax=datax, ...)</code>
</p>
<p><code>qq2.  q2[["z"]] &lt;- z</code>
</p>
<p><code>qq3.  q2[["pch"]]</code> gets whatever 
<code>pch</code> decodes to.
</p>
<p><code>qq4</code>.  Silently 
<code>return(list(x, y, z, pch, ...))</code>, where 
<code>x</code> and <code>y</code> are as returned by 
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code> in step 1 above.  If 
<code>pch</code> is not provided and <code>z</code> is not 
logical or positive integers, then <code>z</code> 
itself will be plotted and <code>pch</code> will not be
in the returned list.  
</p>
<p>For <code>plot.qqnorm2</code>:  
</p>
<p><code>plot1.  plot(x\$x, x\$y, type="n", ...)</code> 
with <code>...</code> taking precedence over <code>x</code>, 
where the same plot argument appears in both.  
</p>
<p><code>plot2.  if(type %in% 
  c('l', 'b', 'c', 'o'))
  lines(x\$x, x\$y, ...)</code>
</p>
<p><code>plot3.  if(type %in% c('p', 'b', 'o')): 
  if(is.null(x\$z))points(x\$x, x\$y, ...)
  else if(is.logical(x\$z))
         points(x\$x, x\$y, pch=x\$pch[x\$z], ...)
  else if(is.numeric(x\$z) &amp;&amp; 
     (min(z0 &lt;- round(x\$z))&gt;0) &amp;&amp; 
     (max(abs(x\$z-z0))&lt;10*.Machine\$double.eps))
  points(x\$x, x\$y, pch=x\$pch[x\$z], ...)
  else text(x\$x, x\$y, x\$z, ...)</code>
</p>
<p>For <code>lines.qqnorm2</code>
<code>lines1.  
  if(type != 'p')lines(x$x, x$y, ...)</code>;  
</p>
<p><code>lines2.  if(type %in% 
        c('p', 'b', 'o'))
  if(is.null(pch))text(x\$x, x\$y, x\$z, ...)
  else if(is.character(pch))
      text(x\$x, x\$y, x\$pch[x\$z], ...) 
  else points(x\$x, x\$y, pch=x\$pch[x\$z], ...)</code>
</p>
<p>For <code>points.qqnorm2</code>
<code>points1.  
  if(type %in% c('p', 'b', 'o'))
  if(is.null(pch))text(x\$x, x\$y, x\$z, ...)
  else if(is.character(pch))
        text(x\$x, x\$y, x\$pch[x\$z], ...) 
  else points(x\$x, x\$y, pch=x\$pch[x\$z], ...)</code>
</p>
<p><code>points2.  if(!(type %in% c('p', 'n')))
  lines(x$x, x$y, ...)</code>
</p>


<h3>Value</h3>

<p><code>qqnorm2</code> returns a list with 
components, <code>x, y, z</code>, and <code>pch</code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqnorm">qqnorm</a></code>, <code><a href="#topic+qqnorm2s">qqnorm2s</a></code>, 
<code><a href="#topic+qqnorm2t">qqnorm2t</a></code>
<code><a href="base.html#topic+plot">plot</a></code>
<code><a href="graphics.html#topic+points">points</a></code>
<code><a href="graphics.html#topic+lines">lines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## a simple test data.frame to illustrate the plot
## but too small to illustrate qqnorm concepts
##
tstDF &lt;- data.frame(y=1:3, z1=1:3, z2=c(TRUE, TRUE, FALSE),
                    z3=c('tell', 'me', 'why'), z4=c(1, 2.4, 3.69) )
# plotting symbols circle, triangle, and "+"
qn1 &lt;- with(tstDF, qqnorm2(y, z1))

# plotting symbols "x" and "o"
qn2 &lt;- with(tstDF, qqnorm2(y, z2))

# plotting with "-" and "+"
qn. &lt;- with(tstDF, qqnorm2(y, z2, pch=c('FALSE'='-', 'TRUE'='+')))

# plotting with "tell", "me", "why"
qn3 &lt;- with(tstDF, qqnorm2(y, z3))

# plotting with the numeric values
qn4 &lt;- with(tstDF, qqnorm2(y, z4))

##
## test plot, lines, points
##
plot(qn4, type='n') # establish the scales
lines(qn4)          # add a line
points(qn4)         # add points

##
## Check the objects created above
##
# check qn1
qn1. &lt;- qqnorm(1:3, datax=TRUE, plot.it=FALSE)
qn1.$xlab &lt;- 'y'
qn1.$ylab &lt;- 'Normal scores'
qn1.$z &lt;- tstDF$z1
qn1.$pch &lt;- 1:3
names(qn1.$pch) &lt;- 1:3
qn11 &lt;- qn1.[c(3:4, 1:2, 5:6)]
class(qn11) &lt;- 'qqnorm2'

all.equal(qn1, qn11)


# check qn2
qn2. &lt;- qqnorm(1:3, datax=TRUE, plot.it=FALSE)
qn2.$xlab &lt;- 'y'
qn2.$ylab &lt;- 'Normal scores'
qn2.$z &lt;- tstDF$z2
qn2.$pch &lt;- c('FALSE'=4, 'TRUE'=1)
qn22 &lt;- qn2.[c(3:4, 1:2, 5:6)]
class(qn22) &lt;- 'qqnorm2'

all.equal(qn2, qn22)


# check qn.
qn.. &lt;- qqnorm(1:3, datax=TRUE, plot.it=FALSE)
qn..$xlab &lt;- 'y'
qn..$ylab &lt;- 'Normal scores'
qn..$z &lt;- tstDF$z2
qn..$pch &lt;- c('FALSE'='-', 'TRUE'='+')
qn.2 &lt;- qn..[c(3:4, 1:2, 5:6)]
class(qn.2) &lt;- 'qqnorm2'

all.equal(qn., qn.2)


# check qn3
qn3. &lt;- qqnorm(1:3, datax=TRUE, plot.it=FALSE)
qn3.$xlab &lt;- 'y'
qn3.$ylab &lt;- 'Normal scores'
qn3.$z &lt;- as.character(tstDF$z3)
qn3.$pch &lt;- as.character(tstDF$z3)
names(qn3.$pch) &lt;- qn3.$pch
qn33 &lt;- qn3.[c(3:4, 1:2, 5:6)]
class(qn33) &lt;- 'qqnorm2'

all.equal(qn3, qn33)


# check qn4
qn4. &lt;- qqnorm(1:3, datax=TRUE, plot.it=FALSE)
qn4.$xlab &lt;- 'y'
qn4.$ylab &lt;- 'Normal scores'
qn4.$z &lt;- tstDF$z4
qn44 &lt;- qn4.[c(3:4, 1:2, 5)]
qn44$pch &lt;- NULL
class(qn44) &lt;- 'qqnorm2'

all.equal(qn4, qn44)


##
## Test lines(qn4) without z
##
#  just as a test, so this code can be used 
#  in other contexts
qn4. &lt;- qn4
qn4.$z &lt;- NULL
plot(qn4.)


</code></pre>

<hr>
<h2 id='qqnorm2s'>
Normal Probability Plot with Multiple Lines 
and Multiple Symbols
</h2><span id='topic+qqnorm2s'></span><span id='topic+plot.qqnorm2s'></span>

<h3>Description</h3>

<p>Create a normal probability plot with one 
line for each <code>y</code> variable or each 
<code><a href="base.html#topic+data.frame">data.frame</a></code> in a list <code>data.</code>
with different plotting symbols for the values 
of <code>z</code>.  
</p>
<p>To create a normal probability plot with one 
<code>y</code> variable split on a <code>link{factor}</code>
or <code><a href="base.html#topic+character">character</a></code> variable <code>x</code>, 
see <code><a href="#topic+qqnorm2t">qqnorm2t</a></code>.  
</p>
<p><code>qqnorm2s</code> produces an object of class
<code>qqnorm2s</code>, whose plot method produces 
the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqnorm2s(y, z=NULL, data., plot.it=TRUE, 
    datax=TRUE, outnames=NULL, pch=NULL, 
    col=c(1:4, 6), legend.=NULL, ...)
## S3 method for class 'qqnorm2s'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqnorm2s_+3A_y">y</code></td>
<td>

<p>a <code><a href="base.html#topic+character">character</a></code> vector of names 
of columns of <code>data.</code> for which normal 
probability plots are desired.  <code>data.</code>
is either a <code><a href="base.html#topic+data.frame">data.frame</a></code> or a
list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s of the same
length as <code>y</code>, with y[i] being the name
of a column of the <code><a href="base.html#topic+data.frame">data.frame</a></code> 
<code>data.[[i]]</code>.  <code>z</code> is a similar
character vector of names of columns of
<code>data.</code>, which identify symbols for
plotting different points in a normal
probability plot.  
</p>
<p>The lengths of <code>y</code>, and <code>z</code> must
match the number of <code>data.frame</code>s in
<code>data.</code>;  if not, the lengths of the
shorter are replicated to the length of the
longest before computations begin.
</p>
<p>For <code>plot.qqnorm2s</code>, <code>y</code> is 
ignored;  it is included, because the 
generic <code><a href="base.html#topic+plot">plot</a></code> function requires 
it.
</p>
</td></tr>
<tr><td><code id="qqnorm2s_+3A_z">z</code></td>
<td>

<p>A character vector giving the names of
columns of <code>data.</code> to
indicate different plotting symbols.  
<code>z</code> should be the same length as 
<code>y</code> and must equal the number of 
<code>data.frame</code>s in the list <code>data.</code> 
of <code>data.frames</code>.  If not, the shorter 
are replicated to the length of the longer.
</p>
</td></tr>
<tr><td><code id="qqnorm2s_+3A_data.">data.</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> or a list of 
data.frames with columns named in <code>y</code>
and <code>z</code>.
</p>
</td></tr>
<tr><td><code id="qqnorm2s_+3A_plot.it">plot.it</code></td>
<td>

<p>logical:  Should the result be plotted?
</p>
</td></tr>
<tr><td><code id="qqnorm2s_+3A_datax">datax</code></td>
<td>

<p>The <code>datax</code> argument of 
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code>:  If <code>TRUE</code>, the
data are displayed on the horizontal rather
than the vertical axis.  (The default value
for <code>datax</code> is the opposite of that for
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code>.)
</p>
</td></tr>
<tr><td><code id="qqnorm2s_+3A_outnames">outnames</code></td>
<td>

<p>Names for the components of the 
<code>qqnorm2s</code> object returned by the
<code>qqnorm2s</code> function.
</p>
</td></tr>
<tr><td><code id="qqnorm2s_+3A_pch">pch</code></td>
<td>

<p>a named vector of the plotting symbols to 
be used with names corresponding to the 
levels of <code>z</code>.
</p>
<p>By default, if <code>z</code> takes levels
<code>FALSE</code> and <code>TRUE</code> (or 0 and 1), 
<code>pch</code>=c(4, 1) to plot a &quot;x&quot; for 
<code>FALSE</code> and &quot;o&quot; for <code>TRUE</code>.
</p>
<p>If <code>z</code> assumes integer values between 0
and 255, by default, the symbols are chosen
as described with <code><a href="graphics.html#topic+points">points</a></code>.
</p>
<p>Otherwise, by default, <code>z</code> is coerced to
<code><a href="base.html#topic+character">character</a></code>, and the result is
plotted.
</p>
<p>If <code>pch</code> is provided, it must either
have names corresponding to levels of
<code>z</code>, or <code>z</code> must be integers
between 1 and <code>length(pch)</code>.
</p>
</td></tr>
<tr><td><code id="qqnorm2s_+3A_col">col</code></td>
<td>

<p>A vector indicating the colors corresponding 
to each element of <code>y</code>.  Defaults to 
<code>rep(c(1:4, 6), length=length(y))</code>, with
1:4  and 6 being black, red, green, blue, and
pink.
</p>
</td></tr>
<tr><td><code id="qqnorm2s_+3A_x">x</code></td>
<td>

<p>an object of class <code>qqnorm2</code>.
</p>
</td></tr>
<tr><td><code id="qqnorm2s_+3A_legend.">legend.</code></td>
<td>

<p>A list with components <code>pch</code> and
<code>col</code> providing information for
<code><a href="graphics.html#topic+legend">legend</a></code> to identify the 
plotting symbols (<code>pch</code>) and colors
(<code>col</code>).
</p>
<p>By default, <code>pch = list(x='right',
    legend=names(qq2s[[1]][['pch']]), 
    pch=qq2s[[1]][['pch']])</code>, where <code>qq2s</code> 
is described below in details.
</p>
<p>Similarly, by default, <code>lines = 
    list(x='bottomright', legend=y,
    lty=1, pch=NA, col=qq2s[[1]][['col']])</code>.
</p>
</td></tr>
<tr><td><code id="qqnorm2s_+3A_...">...</code></td>
<td>

<p>Optional arguments.
</p>
<p>For <code>plot.qqnorm2s</code>, they are passed 
to <code>plot</code>.
</p>
<p>For <code>qqnorm2s</code>, they are passed to 
<code><a href="#topic+qqnorm2">qqnorm2</a></code> and to 
<code>plot.qqnorm2s</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>qqnorm2s</code>:
</p>
<p>1.  Create <code>qq2s</code> = a list of objects 
of class <code>qqnorm2</code>
</p>
<p>2.  Add <code>legend.</code> to <code>qq2s</code>.
</p>
<p>3.  <code>class(qq2s) &lt;- 'qqnorm2s'</code>
</p>
<p>4.  <code>if(plot.it)plot(qq2s, ...)</code>
</p>
<p>5.  Silently <code>return(qq2s)</code>.
</p>
<p>For <code>plot.qqnorm2s</code>, create a plot with
one line for each variable named in <code>y</code>.
</p>


<h3>Value</h3>

<p><code>qqnorm2s</code> returns a named list with
components of class <code>qqnorm2</code> with names 
= <code>y</code> with each component having an
additional component <code>col</code> plus one 
called &quot;<code>legend.</code>&quot;.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qqnorm2">qqnorm2</a></code>
<code><a href="base.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## One data.frame
##
tstDF2 &lt;- data.frame(y=1:3, y2=3:5, 
    z2=c(TRUE, TRUE, FALSE),
    z3=c('tell', 'me', 'why'), 
    z4=c(1, 2.4, 3.69) )
# produce the object and plot it
Qn2 &lt;- qqnorm2s(c('y', 'y2'), 'z2', tstDF2)

# plot the object previously created
plot(Qn2)

# Check the object
qy &lt;- with(tstDF2, qqnorm2(y, z2, type='b'))
qy$col &lt;- 1
qy2 &lt;- with(tstDF2, qqnorm2(y2, z2, type='b'))
qy2$col &lt;- 2
legend. &lt;- list(
  pch=list(x='right', 
      legend=c('FALSE', 'TRUE'),
      pch=c('FALSE'=4, 'TRUE'= 1)),
  col=list(x='bottomright', 
      legend=c('y', 'y2'), lty=1, col=1:2))
Qn2. &lt;- list(y=qy, y2=qy2, legend.=legend.)
class(Qn2.) &lt;- 'qqnorm2s'


all.equal(Qn2, Qn2.)

##
## Two data.frames
##
tstDF2b &lt;- tstDF2
tstDF2b$y &lt;- c(0.1, 0.1, 9)
Qn2b &lt;- qqnorm2s('y', 'z2', 
    list(tstDF2, tstDF2b), 
    outnames=c('ok', 'oops'), log='x' )
##
## Split one data.frame 
##
tstDF2. &lt;- rbind(cbind(tstDF2, z1=1), 
                 cbind(tstDF2b, z1=2) )
Qn2. &lt;- qqnorm2s('y', 'z1', tstDF2.)
# Plot has only one line, because only 1 y variable.  
##
## Two data.frames without z
##
Qn2.0 &lt;- qqnorm2s('y', 
    data.=list(tstDF2, tstDF2b), 
    outnames=c('ok', 'oops'), log='x' )
</code></pre>

<hr>
<h2 id='qqnorm2t'>
Normal Probability Plot with Multiple Lines 
and Multiple Symbols
</h2><span id='topic+qqnorm2t'></span>

<h3>Description</h3>

<p>Create a normal probability plot of <code>y</code> 
with one line for each level of a 
<code><a href="base.html#topic+factor">factor</a></code> or <code><a href="base.html#topic+character">character</a></code> 
variable <code>x</code> and (optionally) different 
symbols for the different levels of a 
variable <code>z</code>.  
</p>
<p>To create a normal probability plot with 
one line for each of multiple <code>y</code> 
variables, see <code><a href="#topic+qqnorm2s">qqnorm2s</a></code>.  
</p>
<p>To create a normal probability plot with 
one line and different symbols for each 
level of a variable <code>z</code>, see 
<code><a href="#topic+qqnorm2">qqnorm2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqnorm2t(y, x, z=NULL, data., plot.it=TRUE, 
    datax=TRUE, outnames=NULL, pch=NULL, 
    col=c(1:4, 6), legend.=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqnorm2t_+3A_y">y</code></td>
<td>

<p>a <code><a href="base.html#topic+character">character</a></code> vector of length 
1 with the name of a column of <code>data.</code> 
for which normal probability plots are 
desired, with one line for each level of 
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="qqnorm2t_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+factor">factor</a></code> or 
<code><a href="base.html#topic+character">character</a></code> vector indicating 
how to split <code>y</code> for plotting.
</p>
</td></tr>
<tr><td><code id="qqnorm2t_+3A_z">z</code></td>
<td>

<p>A character vector giving the name of a
column of <code>data.</code> to indicate 
different plotting symbols.  
</p>
</td></tr>
<tr><td><code id="qqnorm2t_+3A_data.">data.</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with columns 
named in <code>y</code>, <code>x</code>, and <code>z</code>.
</p>
</td></tr>
<tr><td><code id="qqnorm2t_+3A_plot.it">plot.it</code></td>
<td>

<p>logical:  Should the result be plotted?
</p>
</td></tr>
<tr><td><code id="qqnorm2t_+3A_datax">datax</code></td>
<td>

<p>The <code>datax</code> argument of 
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code>:  If TRUE, the
data are displayed on the horizontal rather
than the vertical axis.  (The default value
for <code>datax</code> is the opposite of that for
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code>.)
</p>
</td></tr>
<tr><td><code id="qqnorm2t_+3A_outnames">outnames</code></td>
<td>

<p>Names for the components of the 
<code>qqnorm2s</code> object returned by the
<code>qqnorm2s</code> function.  Equal to the 
levels of <code>x</code> by default.  
</p>
</td></tr>
<tr><td><code id="qqnorm2t_+3A_pch">pch</code></td>
<td>

<p>a named vector of the plotting symbols to be
used with names corresponding to the levels
of <code>z</code>.
</p>
<p>By default, if <code>z</code> takes levels
<code>FALSE</code> and <code>TRUE</code> (or 0 and 1), 
<code>pch=c(4, 1)</code> to plot a &quot;x&quot; for 
<code>FALSE</code> and &quot;o&quot; for <code>TRUE</code>.
</p>
<p>If <code>z</code> assumes integer values between 0
and 255, by default, the symbols are chosen
as described with <code><a href="graphics.html#topic+points">points</a></code>.
</p>
<p>Otherwise, by default, <code>z</code> is coerced to
<code><a href="base.html#topic+character">character</a></code>, and the result is
plotted.
</p>
<p>If <code>pch</code> is provided, it must either
have names corresponding to levels of
<code>z</code>, or <code>z</code> must be integers
between 1 and <code>length(pch)</code>.
</p>
</td></tr>
<tr><td><code id="qqnorm2t_+3A_col">col</code></td>
<td>

<p>A vector indicating the colors corresponding 
to each element of <code>x</code>.  Defaults to 
<code>rep(c(1:4, 6), length=length(x))</code>, with
1:4  and 6 being black, red, green, blue, and
pink.
</p>
</td></tr>
<tr><td><code id="qqnorm2t_+3A_legend.">legend.</code></td>
<td>

<p>A list with components <code>pch</code> and
<code>col</code> providing information for
<code><a href="graphics.html#topic+legend">legend</a></code> to identify the plotting
symbols (<code>pch</code>) and colors (<code>col</code>).
</p>
<p>By default, <code>pch = list(x='right',
    legend=names(qq2s[[1]][['pch']]), 
    pch=qq2s[[1]][['pch']])</code>, where <code>qq2s</code>
is described below in details.
</p>
<p>Similarly, by default, <code>lines = 
    list(x='bottomright', legend=y,
    lty=1, pch=NA, col=qq2s[[1]][['col']])</code>.
</p>
</td></tr>
<tr><td><code id="qqnorm2t_+3A_...">...</code></td>
<td>

<p>Optional arguments.
</p>
<p>For <code>plot.qqnorm2s</code>, they are passed to 
<code>plot</code>.
</p>
<p>For <code>qqnorm2s</code>, they are passed to 
<code><a href="#topic+qqnorm2">qqnorm2</a></code> and to 
<code>plot.qqnorm2s</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data.</code> is split by <code>x</code> and the
result is passed to <code>qqnorm2s</code>
</p>


<h3>Value</h3>

<p>Returns an object of class 
<code><a href="#topic+qqnorm2s">qqnorm2s</a></code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qqnorm2">qqnorm2</a></code>, <code><a href="#topic+qqnorm2s">qqnorm2s</a></code>,
<code><a href="base.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## One data.frame
##
tstDF2 &lt;- data.frame(y=1:6, x=c('a','b'), 
    z2=c(TRUE, TRUE, FALSE),
    z3=c('tell', 'me', 'why') )
# produce the object and plot it
Qnt &lt;- qqnorm2t('y', 'x', 'z2', tstDF2)

# plot the object previously created
plot(Qnt)

Qnt0 &lt;- qqnorm2t('y', 'x', data.=tstDF2)
# without z 
qqnorm2t('y', 'x', data.=tstDF2)
</code></pre>

<hr>
<h2 id='rasterImageAdj'>
rasterImage adjusting to zero distortion
</h2><span id='topic+rasterImageAdj'></span>

<h3>Description</h3>

<p>Call <code>rasterImage</code> to plot <code>image</code> 
from <code>(xleft, ybottom)</code> to either 
<code>xright</code> or <code>ytop</code>, shrinking one 
toward the center to avoid distortion.  
</p>
<p><code>angle</code> specifies a rotation around the midpoint 
(<code>(xleft+xright)/2</code>, <code>(ybottom+ytop)/2</code>).  
This is different from <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code>, 
which rotates around <code>(xleft, ybottom)</code>.  
</p>
<p>NOTE:  The code may change in the future.  The visual 
image with rotation looks a little off in the 
examples below, but the code seems correct.  If you 
find an example where this is obviously off, please 
report to the maintainer &ndash; especially if you find a 
fix for this.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterImageAdj(image, xleft=par('usr')[1], 
    ybottom=par('usr')[3], xright=par('usr')[2], 
    ytop=par('usr')[4], angle = 0, interpolate = TRUE, 
    xsub=NULL, ysub=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rasterImageAdj_+3A_image">image</code></td>
<td>

<p>a <code>raster</code> object, or an object that can be 
coerced to one by <code><a href="grDevices.html#topic+as.raster">as.raster</a></code>.
</p>
</td></tr>
<tr><td><code id="rasterImageAdj_+3A_xleft">xleft</code></td>
<td>

<p>a vector (or scalar) of left x positions.
</p>
</td></tr>
<tr><td><code id="rasterImageAdj_+3A_ybottom">ybottom</code></td>
<td>

<p>a vector (or scalar) of bottom y positions.
</p>
</td></tr>
<tr><td><code id="rasterImageAdj_+3A_xright">xright</code></td>
<td>

<p>a vector (or scalar) of right x positions.
</p>
</td></tr>
<tr><td><code id="rasterImageAdj_+3A_ytop">ytop</code></td>
<td>

<p>a vector (or scalar) of top y positions.
</p>
</td></tr>
<tr><td><code id="rasterImageAdj_+3A_angle">angle</code></td>
<td>

<p>angle of rotation in degrees, anti-clockwise 
about the centroid of <code>image</code>.  
</p>
<p>NOTE:  <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code> rotates around 
(<code>xleft</code>, <code>ybottom</code>).  <code>rasterImage</code> 
rotates around the center <code>((xleft+xright)/2, 
    (ybottom+ytop)/2)</code>.  See the examples.  
</p>
</td></tr>
<tr><td><code id="rasterImageAdj_+3A_interpolate">interpolate</code></td>
<td>

<p>a logical vector (or scalar) indicating whether to 
apply linear interpolation to the image when 
drawing.
</p>
</td></tr>
<tr><td><code id="rasterImageAdj_+3A_xsub">xsub</code>, <code id="rasterImageAdj_+3A_ysub">ysub</code></td>
<td>

<p>subscripts to subset <code>image</code>  
</p>
</td></tr>
<tr><td><code id="rasterImageAdj_+3A_...">...</code></td>
<td>

<p>graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  <code>imagePixels</code> = number of (x, y) pixels in 
<code>image</code>.  Do this using 
<code>dim(as.raster(image))[2:1]</code>, because the 
first dimension of <code>image</code> can be either x or 
y depending on <code>class(image)</code>.  For example 
<code>link[EBImage]{Image}</code> returns <code>dim</code> with 
x first then y and an optional third dimension for 
color.  A simple 3-dimensional array is assumed by
<code><a href="graphics.html#topic+rasterImage">rasterImage</a></code> to have the y dimension 
first.  <code><a href="grDevices.html#topic+as.raster">as.raster</a></code> puts all these in a
standard format with y first, then x.
</p>
<p>2. <code>imageUnits &lt;- c(x=xright-xleft, ytop-ybottom)</code>
</p>
<p>3.  <code>xyinches</code> = (x, y) units per inch in the 
current plot, obtained from <code><a href="graphics.html#topic+xyinch">xyinch</a></code>.
</p>
<p>4.  Compute pixel density (pixels per inch) in both 
x and y dimension:  <code>pixelsPerInch &lt;- 
  imagePixels * xyinches / imageUnits</code>.
</p>
<p>5.  Compute <code>imageUnitsAdj</code> solving 4 for 
<code>imageUnits</code> and replacing <code>pixelsPerInch</code>
by the max pixel density:  <code>imageUnitsAdj &lt;-
  imagePixels * xyinches / max(pixelsPerInch)</code>.
</p>
<p>6.  <code>(dX, dY) = imageUnitsAdj/2</code> = half of the 
(width, height) in plotting units.  
</p>
<p>7.  <code>cntr = (xleft, ybottom) + (dX, dY)</code>.  
</p>
<p><code>xleft0  = cntr[1]+sin((angle-90)*pi/180)*dX*sqrt(2)</code>; 
</p>
<p><code>ybottom0= cntr[2]-cos((angle-90)*pi/180)*dY*sqrt(2)</code>;
</p>
<p><code>(xright0, ytop0)</code> 
= (upper right without rotation about lower left)
</p>
<p><code>xright0 = xleft0+imageUnitsAdj[2]</code>
</p>
<p><code>ytop0 = ybottom0+imageUnitsAdj[2]</code>
</p>
<p>8.  <code>rasterImage(image, xleft0, ybottom0, 
            xright0, ytop0, angle, interpolate, ...)</code>
</p>


<h3>Value</h3>

<p>a named vector giving the values of <code>xleft</code>, 
<code>ybottom</code>, <code>xright</code>, and <code>ytop</code> 
passed to <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code>.  
(<code><a href="graphics.html#topic+rasterImage">rasterImage</a></code> returns <code>NULL</code>, 
at least for some inputs.)  This shows the adjustment, 
shrinking toward the center and rotating as desired.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+rasterImage">rasterImage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># something to plot 
logo.jpg &lt;- file.path(R.home('doc'), 'html', 'logo.jpg')
if(require(jpeg)){
##
## 1.  Shrink as required
##
  Rlogo &lt;- try(readJPEG(logo.jpg))
  if(inherits(Rlogo, 'array')){  
  
    all.equal(dim(Rlogo), c(76, 100, 3))
  

    plot(1:2)
# default
    rasterImageAdj(Rlogo)

    plot(1:2, type='n', asp=0.75)
# Tall and thin
    rasterImage(Rlogo, 1, 1, 1.2, 2)
# Fix
    rasterImageAdj(Rlogo, 1.2, 1, 1.4, 2)

# short and wide
    rasterImage(Rlogo, 1.4, 1, 2, 1.2)
# Fix
    rasterImage(Rlogo, 1.4, 1.2, 2, 1.4)
##
## 2.  rotate 
##
#  2.1.  angle=90:  rasterImage left of rasterImageAdj
    plot(0:1, 0:1, type='n', asp=1)
    rasterImageAdj(Rlogo, .5, .5, 1, 1, 90)
    rasterImage(Rlogo, .5, .5, 1, 1, 90)
#  2.2.  angle=180:  rasterImage left and below 
    plot(0:1, 0:1, type='n', asp=1)
    rasterImageAdj(Rlogo, .5, .5, 1, 1, 180)
    rasterImage(Rlogo, .5, .5, 1, 1, 180)
#  2.3.  angle=270:  rasterImage below 
    plot(0:1, 0:1, type='n', asp=1)
    rasterImageAdj(Rlogo, .5, .5, 1, 1, 270)
    rasterImage(Rlogo, .5, .5, 1, 1, 270)
## 
## 3.  subset 
##
  dim(Rlogo)
# 76 100 3
  Rraster &lt;- as.raster(Rlogo)
  dim(Rraster)
# 76 100:  
# x=1:100, left to right 
# y=1:76, top to bottom 
  rasterImageAdj(Rlogo, 0, 0, .5, .5, xsub=40:94)
}
}
</code></pre>

<hr>
<h2 id='read.transpose'>
Read a data table in transpose form
</h2><span id='topic+read.transpose'></span>

<h3>Description</h3>

<p>Read a text (e.g., csv) file, find rows 
with more than 3 <code>sep</code> characters.  
Parse the initial contiguous block of 
those into a <code>matrix</code>.  Add 
<code>attributes</code> <code>headers</code>, 
<code>footers</code>, and a <code>summary</code>.
</p>
<p>The initial application for this function 
is to read &quot;Table 6.16.  Income and 
employment by industry&quot; in the National 
Income and Product Account (NIPA) tables 
published by the Bureau of Economic Analysis 
(BEA) of the United States Department of 
Commerce.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.transpose(file, header=TRUE, sep=',',
               na.strings='---', ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.transpose_+3A_file">file</code></td>
<td>

<p>the name of a file from which the data 
are to be read.
</p>
</td></tr>
<tr><td><code id="read.transpose_+3A_header">header</code></td>
<td>

<p>Logical:  Is the second column of the 
identified data matrix to be 
interpreted as variable names?
</p>
</td></tr>
<tr><td><code id="read.transpose_+3A_sep">sep</code></td>
<td>

<p>The field space separator character.
</p>
</td></tr>
<tr><td><code id="read.transpose_+3A_na.strings">na.strings</code></td>
<td>

<p>character string(s) that translate into NA
</p>
</td></tr>
<tr><td><code id="read.transpose_+3A_...">...</code></td>
<td>

<p>optional arguments for <code><a href="base.html#topic+strsplit">strsplit</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  <code>txt &lt;- readLines(file)</code>
</p>
<p>2.  Split into fields.
</p>
<p>3.  Identify headers, Data, footers.
</p>
<p>4.  Recombine the second component of each 
Data row if necessary so all have the same 
number of fields.
</p>
<p>5.  Extract variable names
</p>
<p>6.  Numbers?
</p>
<p>7. return the transpose
</p>


<h3>Value</h3>

<p>A matrix of the transpose of the rows with the 
max number of fields with attributes 
<code>headers</code>, <code>footers</code>, 
<code>other</code>, and <code>summary</code>.  If this
matrix can be coerced to numeric with no 
<code>NAs</code>, it will be.  Otherwise, it will be
left as character.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>References</h3>

<p><a href="https://www.bea.gov">
Table 6.16.  Income and employment by industry 
in the National Income and Product Account 
(NIPA) tables published by the Bureau of Economic
Analysis (BEA) of the United States Department 
of Commerce.</a>  As of February 2013, there were 
4 such tables available:  Table 6.16A, 6.16B, 
6.16C and 6.16D.  Each of the last three are
available in annual and quarterly summaries. 
The <code>USFinanceIndustry</code> data combined the
first 4 rows of the 4 annual summary tables.
</p>
<p>NOTE:  The structure of the BEA web site 
seems to have changes between 2013 and 2022.  
As of 2022-07-01 it does not seem easy to 
find these tables at the BEA website.  
</p>
<p>Line 5 in the sample tables saved in 2013 
contained &quot;a non-breaking space in Latin-1&quot;, 
which was not a valid code in UTF-8 and 
was rejected by a development version of R.
Since it wasn't easy to update those tables, 
the &quot;non-breaking spaces&quot; were replaced 
with &quot; &quot;.  
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>
<code><a href="base.html#topic+readLines">readLines</a></code>
<code><a href="base.html#topic+strsplit">strsplit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  Find demoFiles/*.csv
demoDir &lt;- system.file('demoFiles', package='Ecdat')
(demoCsv &lt;- dir(demoDir, pattern='csv$', full.names=TRUE))

# Use the fourth example
# to ensure the code will handle commas in a name
# and NAs
nipa6.16D &lt;- read.transpose(demoCsv[4])
str(nipa6.16D)
</code></pre>

<hr>
<h2 id='readDates3to1'>
read.csv with Dates in 3 columns 
</h2><span id='topic+readDates3to1'></span>

<h3>Description</h3>

<p><code><a href="utils.html#topic+read.csv">read.csv</a></code>, converting 3-column dates 
into vectors of class <code>Date</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDates3to1(file, YMD=c('Year', 'Month', 'Day'), 
                ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readDates3to1_+3A_file">file</code></td>
<td>

<p>the name of a file from which the data are to 
be read.
</p>
</td></tr>
<tr><td><code id="readDates3to1_+3A_ymd">YMD</code></td>
<td>

<p>Character vector of length 3 passed to 
<code><a href="#topic+dateCols">dateCols</a></code>
</p>
</td></tr>
<tr><td><code id="readDates3to1_+3A_...">...</code></td>
<td>

<p>optional arguments for <code><a href="utils.html#topic+read.csv">read.csv</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some files (e.g., from the 
<a href="https://correlatesofwar.org/data-sets/COW-war/">Correlates 
of War</a> project) have dates specified in 
three separate columns with names like 
<code>startMonth1</code>, <code>startDay1</code>, 
<code>startYear1</code>, <code>endMonth1</code>, ..., 
<code>endYear2</code>.  This function looks for 
such triples and replaces each found with 
a single column with a name like, 
<code>start1</code>, <code>end1</code>, ..., <code>end2</code>.  
</p>
<p>ALGORITHM
</p>
<p>1.  <code>dat &lt;- read.csv(file, ...)</code>
</p>
<p>2.  <code>Dates3to1(dat, YMD)</code>
</p>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with 3-column 
dates replace by single-column vectors of class 
<code>Date</code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.csv">read.csv</a></code>
<code><a href="#topic+Dates3to1">Dates3to1</a></code>
<code><a href="#topic+dateCols">dateCols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  Write a file to be read
##
cow0 &lt;- data.frame(rec=1:3, startMonth=4:6, 
    startDay=7:9, startYear=1971:1973, 
    endMonth1=10:12, endDay1=13:15, 
    endYear1=1974:1976, txt=letters[1:3])

cowFile &lt;- tempfile('cow0')    
write.csv(cow0, cowFile, row.names=FALSE)
##
## 2.  Read it 
##
cow0. &lt;- readDates3to1(cowFile)

# check 
cow0x &lt;- data.frame(rec=1:3, txt=letters[1:3], 
    start=as.Date(c('1971-04-07', '1972-05-08', '1973-06-09')), 
    end1=as.Date(c('1974-10-13', '1975-11-14', '1976-12-15')) )


all.equal(cow0., cow0x)



</code></pre>

<hr>
<h2 id='readDW_NOMINATE'>
Read the DW-NOMINATE data from their website. 
</h2><span id='topic+readDW_NOMINATE'></span>

<h3>Description</h3>

<p>Read <a href="https://voteview.com/static/data/out/members/HSall_members.csv">the DW-NOMINATE data</a> 
from their website using <code><a href="readr.html#topic+read_csv">read_csv</a></code>, 
adding a <code>Year</code> = <code>2*congress+1787</code>, which is the 
first year of each 2-year congress. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDW_NOMINATE(file=
"https://voteview.com/static/data/out/members/HSall_members.csv", 
...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readDW_NOMINATE_+3A_file">file</code></td>
<td>

<p><code>file</code> argument passed to <code><a href="readr.html#topic+read_csv">read_csv</a></code>.
</p>
</td></tr>
<tr><td><code id="readDW_NOMINATE_+3A_...">...</code></td>
<td>

<p>optional arguments for <code><a href="readr.html#topic+read_csv">read_csv</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is written to make it easy for users to 
download the <code>DW-NOMINATE</code> data from their 
website, assuming it should be easier to remember 
<code>readDW_NOMINATE</code> than 
</p>
<p><code>readr::read_csv("https://voteview.com/static/data/out/members/HSall_members.csv")</code>. 
</p>


<h3>Value</h3>

<p>a <code><a href="tibble.html#topic+tibble">tibble</a></code> with columns 
</p>
<table role = "presentation">
<tr><td><code>congress</code></td>
<td>

<p><code>number</code> of the Congress starting with 1 in 1789.
</p>
</td></tr>
<tr><td><code>chamber</code></td>
<td>

<p><code>character</code> 'House', 'Senate' or 'President'
</p>
</td></tr>
<tr><td><code>icpsr</code></td>
<td>

<p><code>number</code> <code>icpsr</code> (<a href="https://en.wikipedia.org/wiki/Inter-university_Consortium_for_Political_and_Social_Research">number assigned by the Inter-university Consortium for Political and Social Research (ICPSR)</a>).
</p>
</td></tr>
<tr><td><code>state_icpsr</code></td>
<td>

<p><code>number</code> for the state used by ICPSR. 
</p>
</td></tr>
<tr><td><code>district_code</code></td>
<td>

<p><code>number</code> between 0 and 99 indicating the district number 
within the state. This is 0 when (chamber %in% 
c('President', 'Senate') and occasionally when (chamber
== 'House'). &quot;At-large&quot; members of the US House are coded
98 or 99. There were some before 1970. However, as of 
2024-10-01, but there have been none since 1970. 
</p>
</td></tr>
<tr><td><code>state_abbrev</code></td>
<td>

<p>Either 'USA' or a 2-letter abbreviation for this state in the US. 
</p>
</td></tr>
<tr><td><code>party_code</code></td>
<td>

<p>positive <code>numeric</code>. As of 2024-09-30, over 80 percent 
of the members of Congress since 1857 have been either 
100 (Democrats) or 200 (Republicans), and since 1943, less 
than 1 percent of the US Congress has not been either 100 
or 200. 
</p>
</td></tr>
<tr><td><code>occupancy</code>, <code>last_means</code></td>
<td>

<p><code>numeric</code> = 0:7 or 'NA' with all 'NA's prior to 2017. 
</p>
</td></tr>
<tr><td><code>bioname</code></td>
<td>

<p><code>character</code> name of politician, starting with 
&quot;WASHINGTON, George&quot;. 
</p>
</td></tr>
<tr><td><code>bioguide_id</code></td>
<td>

<p><code>character</code> The ID code used by the 
<a href="https://bioguide.congress.gov/">Biographical directory of the United States Congress</a>, 
being the first character of the last name of the person
followed by a 6-digit number or 'NA' for US Presidents who 
were never members of Congress. 
</p>
</td></tr>
<tr><td><code>born</code>, <code>died</code></td>
<td>

<p><code>numeric</code> 4-digit birth year or 'NA'
</p>
</td></tr>
<tr><td><code>nominate_dim1</code>, <code>nominate_dim2</code></td>
<td>

<p><code>numeric</code> between -1 or 1 or 'NA' described
in Poole (2005). 
</p>
</td></tr>
<tr><td><code>nominate_log_likelihood</code></td>
<td>

<p><code>numeric</code> negative number or 'NA'
</p>
</td></tr>
<tr><td><code>nominate_goe_mean_probabilty</code></td>
<td>

<p><code>numeric</code> number between 0 and 1 or 'NA'
</p>
</td></tr>
<tr><td><code>nominate_number_of_votes</code></td>
<td>

<p><code>numeric</code> positive number or 'NA'
</p>
</td></tr>
<tr><td><code>nominate_number_of_errors</code></td>
<td>

<p><code>numeric</code> nonnegative number or 'NA'
</p>
</td></tr>
<tr><td><code>conditional</code></td>
<td>
 <p><code>logical</code> or 'NA'</p>
</td></tr>
<tr><td><code>nokken_poole_dim1</code>, <code>nokken_poole_dim2</code></td>
<td>

<p><code>numeric</code> between -1 or 1 or 'NA' 
described by Nokken and Poole (2004). 
</p>
</td></tr>
<tr><td><code>Year</code></td>
<td>

<p><code>numeric</code> First year of each 2-year computed 
from <code>congress</code> as (2*congress+1787).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>Source</h3>

<p>Embedded in an <a href="https://github.com/voteview/articles/blob/master/docs/party_polarization/party_polarization.Rmd">R Markdown vignette</a> 
by <a href="https://polisci.ucla.edu/person/jeffrey-b-lewis/">UCLA political science professor Jeff Lewis</a> 
in the <a href="https://github.com/voteview"><code>voteview</code></a> project on 'GitHub'. 
</p>


<h3>References</h3>

<p><a href="https://legacy.voteview.com"><code>Voteview.com</code> website</a>. 
</p>
<p>Timothy P. Nokken and Keith T. Poole (2004) 
&quot;Congressional Party Defection in American History.&quot; 
Legislative Studies Quarterly, 29:545-568,. 
</p>
<p>Keith T. Poole (2005) Spatial models of parliamentary voting 
(Cambridge U. Pr.). 
</p>


<h3>See Also</h3>

<p><code><a href="readr.html#topic+read_csv">read_csv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Wrap in try(...) so it won't throw an error 
# if the Voteview website is not available. 

Nominate &lt;- try(readDW_NOMINATE())
</code></pre>

<hr>
<h2 id='readNIPA'>
Read a National Income and Product Accounts 
data table
</h2><span id='topic+readNIPA'></span>

<h3>Description</h3>

<p>Read multiple files with data in rows using
<code><a href="#topic+read.transpose">read.transpose</a></code> and combine the 
initial columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readNIPA(files, sep.footnote='/', ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readNIPA_+3A_files">files</code></td>
<td>

<p>A character vector of names of files 
from which the data are to be read using 
<code><a href="#topic+read.transpose">read.transpose</a></code>.
</p>
</td></tr>
<tr><td><code id="readNIPA_+3A_sep.footnote">sep.footnote</code></td>
<td>

<p>a single character to identify footnote 
references in the variable names in some 
but not all of <code>files</code>.
</p>
</td></tr>
<tr><td><code id="readNIPA_+3A_...">...</code></td>
<td>

<p>optional arguments for 
<code><a href="#topic+read.transpose">read.transpose</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is written first and foremost to 
facilitate updating 
<code><a href="Ecdat.html#topic+USFinanceIndustry">USFinanceIndustry</a></code> from 
Table 6.16:  Income and employment by industry 
in the National Income and Product Account
tables published by the Bureau of Economic 
Analysis of the United States Department of 
Commerce.  As of February 2013, this table can 
be obtained from <a href="https://www.bea.gov">https://www.bea.gov</a>:  
Under &quot;U.S. Economic Accounts&quot;, first select 
&quot;Corporate Profits&quot; under &quot;National&quot;.  Then
next to &quot;Interactive Tables&quot;, select, &quot;National 
Income and Product Accounts Tables&quot;.  From 
there, select &quot;Begin using the data...&quot;.
Under &quot;Section 6 - income and employment by 
industry&quot;, select each of the tables starting 
&quot;Table 6.16&quot;.  As of February 2013, there were 
4 such tables available:  Table 6.16A, 6.16B, 
6.16C and 6.16D.  Each of the last three are 
available in annual and quarterly summaries.  
The <code><a href="Ecdat.html#topic+USFinanceIndustry">USFinanceIndustry</a></code> 
data combined the first 4 rows of the 4 annual 
summary tables.
</p>
<p>This is available in 4 separate files, which 
must be downloaded and combined using 
<code>readNIPA</code>.  The first three of these are
historical data and are rarely revised.  For 
convenience and for testing, they are provided 
in the <code>demoFiles</code> subdirectory of this 
<code>Ecdat</code> package.
</p>
<p>It has not been tested on other data but should 
work for annual data with a sufficiently similar 
structure.
</p>
<p>The algorithm proceeds as follows:
</p>
<p>1.  <code>Data &lt;- lapply(files, read.transpose)</code>
</p>
<p>2.  Is <code>Data</code> a list of numeric 
matrices?  If no, print an error.
</p>
<p>3.  <code><a href="base.html#topic+cbind">cbind</a></code> common initial 
variables, averaging overlapping years,
reporting percent difference
</p>
<p>4.  attributes:  stats from files and 
overlap.  Stats include the first and 
last year and the last revision date for 
each file, plus the number of years overlap 
with the previous file and the relative change
in the common files kept between those two 
files.
</p>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+matrix">matrix</a></code> of the common variables
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>References</h3>

<p><a href="https://www.bea.gov">United States Department of Commerce Bureau
of Economic Analysis National Income and Product Account tables</a>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>
<code><a href="base.html#topic+readLines">readLines</a></code>
<code><a href="base.html#topic+strsplit">strsplit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  Find demoFiles/*.csv
demoDir &lt;- system.file('demoFiles', package='Ecdat')
(demoCsv &lt;- dir(demoDir, pattern='csv$', full.names=TRUE))

nipa6.16 &lt;- readNIPA(demoCsv)
str(nipa6.16)
</code></pre>

<hr>
<h2 id='recode2'>
bivariate recode
</h2><span id='topic+recode2'></span>

<h3>Description</h3>

<p>Recode <code>x1</code> and <code>x2</code> per the 
lexical <code>codes</code> table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode2(x1, x2, codes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recode2_+3A_x1">x1</code>, <code id="recode2_+3A_x2">x2</code></td>
<td>

<p>vectors of the same length assuming a 
discrete number of levels
</p>
</td></tr>
<tr><td><code id="recode2_+3A_codes">codes</code></td>
<td>

<p>a 2-dimensional matrix indexed by the 
levels of <code>x1</code> and <code>x2</code>.  If 
<code>dimnames(codes)</code> are not provided, 
they are assumed to <code>unique(x1)</code> (or
<code>unique(x2)</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  If <code>length(x1) != length(x2)</code>, 
complain.
</p>
<p>2.  <code>if(is.logical(x1)) l1 &lt;- c(FALSE, TRUE)
  else l1 &lt;- unique(x1)</code>;
ditto for <code>x2</code>.
</p>
<p>3.  <code>If(missing(codes)) codes &lt;- 
  outer(unique(x1), unique(x2))</code>
</p>
<p>4.  <code>if(is.null(dim(codes))) dim(codes) &lt;- 
  c(length(unique(x1)), length(unique(x2)))</code>
</p>
<p>5.  If <code>is.null(rownames(codes))</code>, set as
follows:  If <code>nrow(codes) ==
  length(unique(x1)), rownames(codes) &lt;- 
  unique(x1)</code>.  Else, if
<code>nrow(codes) = max(x1)</code>, set 
<code>rownames(codes) &lt;- seq(1, max(x1))</code>.  
Else throw an error.  Ditto for 
<code>colnames, ncol</code>, and <code>x2</code>.
</p>
<p>6.  <code>codes[x1, x2]</code>
</p>


<h3>Value</h3>

<p>a vector of the same length as <code>x1</code> 
and <code>x2</code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+dim">dim</a></code>
<code><a href="base.html#topic+rownames">rownames</a></code>
<code>link{colnames}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>contrib &lt;- c(-1, 0, 0, 1)
contrib0 &lt;- c(FALSE, FALSE, TRUE, FALSE)

contribCodes &lt;- recode2(contrib&gt;0, contrib0,
   c('returned', 'received', '0', 'ERR') )

cC &lt;- c('returned', 'returned', '0', 'received')

all.equal(contribCodes, cC)


</code></pre>

<hr>
<h2 id='rgrep'>
Reverse grep  
</h2><span id='topic+rgrep'></span>

<h3>Description</h3>

<p>Find which pattern matches x.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgrep(pattern, x, ignore.case = FALSE, 
  perl = FALSE, value = FALSE, fixed = FALSE,
  useBytes = FALSE, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgrep_+3A_pattern">pattern</code></td>
<td>

<p>a <code><a href="base.html#topic+character">character</a></code> vector of regular
expressions to be matched to <code>x</code>
</p>
</td></tr>
<tr><td><code id="rgrep_+3A_x">x</code></td>
<td>

<p>a <code><a href="base.html#topic+character">character</a></code> string or vector 
for which a matching regular expression is
desired.  
</p>
</td></tr>
<tr><td><code id="rgrep_+3A_ignore.case">ignore.case</code>, <code id="rgrep_+3A_perl">perl</code>, <code id="rgrep_+3A_value">value</code>, <code id="rgrep_+3A_fixed">fixed</code>, <code id="rgrep_+3A_usebytes">useBytes</code>, <code id="rgrep_+3A_invert">invert</code></td>
<td>

<p>as for <code><a href="base.html#topic+grep">grep</a></code>   
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  <code>np &lt;- length(pattern)</code>
</p>
<p>2.  <code>g. &lt;- rep(NA, np)</code>
</p>
<p>3.  <code>for(i in seq(length=np)){
    g.[i] &lt;- (length(grep(pattern[i], x))&gt;0) 
  }</code>
</p>
<p>4.  <code>return(which(g.))</code>
</p>


<h3>Value</h3>

<p>an <code><a href="base.html#topic+integer">integer</a></code> vector of indices 
of elements of <code>pattern</code> with a match 
in <code>x</code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, 
<code><a href="base.html#topic+pmatch">pmatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  return index 
##
dd &lt;- data.frame(a = gl(3,4), b = gl(4,1,12)) # balanced 2-way
mm &lt;- model.matrix(~ a + b, dd)

b. &lt;- rgrep(names(dd), colnames(mm)[5])
# check 

all.equal(b., 2)

##
## 2.  return value 
##
bv &lt;- rgrep(names(dd), colnames(mm)[5], value=TRUE)
# check 

all.equal(bv, 'b')

</code></pre>

<hr>
<h2 id='sign'>
Sign function with zero option
</h2><span id='topic+sign'></span>

<h3>Description</h3>

<p><code>sign</code> returns a vector with the signs of 
the corresponding elements of <code>x</code>, being
1, zero, or -1 if the number is positive, 
zero or negative, respectively.  
</p>
<p>This generalizes the 
<code><a href="base.html#topic+sign">sign</a></code> function in the 
<code>base</code> package to allow something 
other than 0 as the the &quot;sign&quot; of 0.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sign(x, zero=0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sign_+3A_x">x</code></td>
<td>

<p>a numeric vector for which signs 
are desired
</p>
</td></tr>
<tr><td><code id="sign_+3A_zero">zero</code></td>
<td>

<p>an <code><a href="base.html#topic+integer">integer</a></code> value to be 
assigned for x==0.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="base.html#topic+integer">integer</a></code> vector of the 
same length as <code>x</code> assuming 
values 1, zero and -1, as discussed 
above.  
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sign">sign</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  default
##
sx &lt;- sign((-2):2)

# check 

all.equal(sx, base::sign((-2):2))


##
## 2.  with zero = 1
##
s1 &lt;- sign((-2):2, 1)

# check 

all.equal(s1, rep(c(-1, 1), c(2,3)))

</code></pre>

<hr>
<h2 id='simulate.bic.glm'>
A &quot;simulate&quot; method for a <code>BMA::bic.glm</code>
object
</h2><span id='topic+simulate.bic.glm'></span>

<h3>Description</h3>

<p>Simulate predictions for <code>newdata</code> for a
model of class <code><a href="BMA.html#topic+bic.glm">bic.glm</a></code>.  
</p>
<p>NOTES: The <strong>stats</strong> package has a 
<code><a href="stats.html#topic+simulate">simulate</a></code> method for 
&quot;<code>lm</code>&quot; objects which is used for 
<code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+glm">glm</a></code> 
objects.  This <code>simulate.bic.glm</code> 
function differs from the 
<code>stats::<a href="stats.html#topic+simulate">simulate</a></code> function 
in the same two fundamental and important ways 
as the <code>simulate.glm</code> function:  
</p>

<ol>
<li>
<p><code>stats::<a href="stats.html#topic+simulate">simulate</a></code>
returns simulated data consistent with the 
model fit assuming the estimated model 
parameters are true and exact, i.e., 
ignoring the uncertainty in parameter 
estimation.  Thus, if <code>family = 
      poisson</code>, 
<code>stats::<a href="stats.html#topic+simulate">simulate</a></code>
returns nonnegative integers.  
</p>
<p>By contrast the <code>simulate.bic.glm</code>
function documented here returns optionally 
simulated <code>coef (coefficients)</code> plus 
simulated values for the <code>link</code> and / 
or <code>response</code> but currently <em>NOT</em> 
pseudo-random numbers on the scale of the 
response.  
</p>
</li>
<li>
<p>The <code>simulate.bic.glm</code> function 
documented here also accepts an optional 
<code>newdata</code> argument, not accepted by 
<code>stats::<a href="stats.html#topic+simulate">simulate</a></code>.  The 
<code>stats::<a href="stats.html#topic+simulate">simulate</a></code> 
function only returns simulated values for 
the cases in the training set with no 
possibilities for use for different sets 
of conditions.  
</p>
</li></ol>
  


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bic.glm'
simulate(object, nsim = 1, 
    seed = NULL, newdata=NULL, 
    type = c("coef", "link", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.bic.glm_+3A_object">object</code></td>
<td>

<p>an object representing a fitted model 
of class <code><a href="BMA.html#topic+bic.glm">bic.glm</a></code>.  
</p>
</td></tr>
<tr><td><code id="simulate.bic.glm_+3A_nsim">nsim</code></td>
<td>

<p>number of response vectors to simulate. 
Defaults to 1.
</p>
</td></tr>
<tr><td><code id="simulate.bic.glm_+3A_seed">seed</code></td>
<td>

<p>Argument passed as the first argument to 
<code><a href="base.html#topic+set.seed">set.seed</a></code> if not NULL.  
</p>
</td></tr>
<tr><td><code id="simulate.bic.glm_+3A_newdata">newdata</code></td>
<td>

<p>optionally, a <code><a href="base.html#topic+data.frame">data.frame</a></code> 
in which to look for variables with 
which to predict. If omitted, predictors 
used in fitting are used.  
</p>
</td></tr>
<tr><td><code id="simulate.bic.glm_+3A_type">type</code></td>
<td>

<p>the type of simulations required. 
</p>

<ul>
<li> <p><code>coef</code>:
<code>type = "coef"</code> returns pseudo-
random numbers generated by  
<code>mvtnorm::<a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code> 
with <code>mean</code> = <code><a href="stats.html#topic+coef">coef</a></code> 
and <code>sigma</code> = <code><a href="stats.html#topic+vcov">vcov</a></code> 
for the component of the BMA mixture
randomly selected for each simulation.  
(Obviously, this does not use 
<code>newdata</code>.)
</p>
</li>
<li> <p><code>link</code>:
<code>type='link'</code> returns simulations 
on the scale of the linear predictors 
using <code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code> 
applied  to randomly selected components 
of the mixture with <code>mean</code> = 
<code><a href="stats.html#topic+coef">coef</a></code> and <code>sigma</code> = 
<code><a href="stats.html#topic+vcov">vcov</a></code> for that component.  
For a default binomial model, these are 
of log-odds (probabilities on logit 
scale).
</p>
</li>
<li> <p><code>response</code>:
<code>object[['linkinv']]</code> of <code>
        type = 'link'</code>.  For a binomial model, 
these are predicted probabilities.  
</p>
</li></ul>

</td></tr>
<tr><td><code id="simulate.bic.glm_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other
methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  Save current <code>seed</code> and optionally set 
it using code copied from 
<code>stats:::simulate.lm</code>.  
</p>
<p>2.  <code>postprob &lt;- object[['postprob']]; 
  x &lt;- object[['x']]; y &lt;- object[['y']]; 
  mle &lt;- object[['mle']]; 
  linkinv &lt;- object[['linkinv']]</code>.
</p>
<p>3.  <code>cl &lt;- as.list(object[['call']]);  
  wt &lt;- cl[['wt']]; 
  fam &lt;- cl[['glm.family']]</code>
</p>
<p>4.  <code>if(is.null(newdata))newdata &lt;- x</code> 
else ensure that all levels of factors of 
<code>newdata</code> match <code>x</code>.
</p>
<p>5.  <code>xMat &lt;- model.matrix(~., x);  
  newMat &lt;- model.matrix(~., newdata)</code>
</p>
<p>6.  <code>nComponents &lt;- length(postprob);  
  nobs &lt;- NROW(newdata)</code>
</p>
<p>7.  <code>sims &lt;- matrix(NA, nobs, nsim)</code>
</p>
<p>8.  <code>rmdl &lt;- sample(1:nComponents, nsims,
  TRUE, postprob)</code>
</p>
<p>9.  <code>for(Comp in 1:nComponents)
  nsimComp &lt;- sum(rmdl==Comp); 
  refitComp &lt;- glm.fit(xMat[, mle[Comp,]!=0], y, 
    wt, mle[Comp, mle[Comp,]!=0], family=fam); 
  simCoef &lt;- mvtnorm::rmvnorm(nsimComp, coef
    (refitComp), vcov(rfitComp)); 
  sims[rmdl==Comp, ] &lt;- tcrossprod(newMat[, 
    mle[Comp,]!=0], simCoef)</code>
</p>
<p>10.  If <code>length(type)</code> == 1:  return a
<code><a href="base.html#topic+data.frame">data.frame</a></code> with one column for 
each desired simulation, consistent with the 
behavior of the generic <code><a href="stats.html#topic+simulate">simulate</a></code>
applied to objects of class <code>lm</code> or 
<code>glm</code>.  Otherwise, return a list of 
<code><a href="base.html#topic+data.frame">data.frame</a></code>s of the desired types.  
</p>


<h3>Value</h3>

<p>Returns either a <code><a href="base.html#topic+data.frame">data.frame</a></code> or a
list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s depending on
'type':  
</p>
<table role = "presentation">
<tr><td><code>coef</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with <code>nsim</code> 
columns and one row for each variable in the max
model.  Values are non-zero for variables in the 
model in the BMA mixture selected for that 
simulation.  The non-zero values are generated 
using <code>mvtnorm::<a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code>
with  mean = <code><a href="stats.html#topic+coef">coef</a></code> and covariance 
matrix = <code><a href="stats.html#topic+vcov">vcov</a></code> of the model fit 
to the subset of variables in that component
model.  
</p>
</td></tr>
<tr><td><code>link</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with <code>nsim</code> 
columns of <code>nobs</code> values each giving the
simulations on the <code>link</code> scale for each
row in <code>newdata</code> (or the training set if
<code>newdata</code> is not provided).  
</p>
</td></tr>
<tr><td><code>response</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with <code>nsim</code>
columns of <code>nobs</code> values each giving the
simulations on the <code>response</code> scale, 
being <code>linkinv</code> of the simulations on 
the <code>link</code> scale.  
</p>
</td></tr>
<tr><td><code>if length(type)&gt;1</code></td>
<td>

<p>a list with simulations on the desired scales.  
</p>
</td></tr>
</table>
<p>The value also has an attribute &quot;<code>seed</code>&quot;. 
If argument <code>seed</code> is NULL, the attribute 
is the value of <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code> 
before the simulation started.  Otherwise it 
is the value of the argument with a &quot;kind&quot;
attribute with value <code>as.list(RNGkind())</code>.  
</p>
<p>NOTE:  This function currently may not work
with a model fit that involves a multivariate 
<code>link</code> or <code>response</code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+simulate">simulate</a></code>
<code><a href="#topic+simulate.glm">simulate.glm</a></code>
<code><a href="BMA.html#topic+bic.glm">bic.glm</a></code>
<code><a href="BMA.html#topic+predict.bic.glm">predict.bic.glm</a></code>
<code><a href="base.html#topic+set.seed">set.seed</a></code>
<code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BMA)
library(mvtnorm)
##
## 1.  a factor and a numeric 
##
PoisReg2 &lt;- data.frame(
  x=factor(rep(0:2, 2)), x1=rep(1:2, e=3))
bicGLM2 &lt;- bic.glm(PoisReg2, y=1:6, poisson)

newDat2 &lt;- data.frame(
  x=factor(rep(c(0, 2), 2), levels=0:2), 
  x1=3:6)
# NOTE:  Force newDat2['x'] to have the same levels
# as PoisReg2['x']

bicGLMsim2n &lt;- simulate(bicGLM2, nsim=5, seed=2,
  newdata=newDat2[1:3,])

##
## 2.  One variable:  BMA returns
##     a mixture of constant &amp; linear models
##
PoisRegDat &lt;- data.frame(x=1:2, y=c(5, 10))
bicGLMex &lt;- bic.glm(PoisRegDat['x'], 
                     PoisRegDat[, 'y'], poisson)
(postprob &lt;- bicGLMex[['postprob']])
bicGLMex['mle']

# Simulate for the model data 
bicGLMsim &lt;- simulate(bicGLMex, nsim=2, seed=1)  

# Simulate for new data
newDat &lt;- data.frame(x=3:4, 
      row.names=paste0('f', 3:4))
bicGLMsin &lt;- simulate(bicGLMex, nsim=3, seed=2, 
                      newdata=newDat)
                      
# Refit with bic.glm.matrix and confirm 
# that simulate returns the same answers

bicGLMat &lt;- bic.glm(as.matrix(PoisRegDat['x']), 
                         PoisRegDat[, 'y'], poisson)
bicGLMatsim &lt;- simulate(bicGLMat, nsim=3, seed=2, 
                      newdata=newDat)
                      
all.equal(bicGLMsin, bicGLMatsim)                      


# The same problem using bic.glm.formula                  
bicGLMfmla &lt;- bic.glm(y ~ x, PoisRegDat, poisson)
bicGLMfmlsim &lt;- simulate(bicGLMfmla, nsim=3, seed=2, 
                      newdata=newDat)
                      
all.equal(bicGLMsin, bicGLMfmlsim)                      

                      
##
## 2a.  Compute the correct answers manually 
##
GLMex1 &lt;- glm(y~x, poisson, PoisRegDat)
GLMex0 &lt;- glm(y~1, poisson, PoisRegDat)

postProb &lt;- bicGLMfmla$postprob
nComp &lt;- length(postProb)
newMat &lt;- model.matrix(~., newDat)
set.seed(2)
(rmdl &lt;- sample(1:nComp, 3, TRUE, 
          postprob))
GLMsim. &lt;- matrix(NA, 2, 3)
dimnames(GLMsim.) &lt;- list(
  rownames(newMat), 
  paste0('sim_', 1:3) )
          
sim1 &lt;- mvtnorm::rmvnorm(2, coef(GLMex1), 
                         vcov(GLMex1))
sim0 &lt;- mvtnorm::rmvnorm(1, coef(GLMex0), 
                         vcov(GLMex0))
GLMsim.[, rmdl==1] &lt;- tcrossprod(newMat, sim1)
GLMsim.[, rmdl==2] &lt;- tcrossprod(
          newMat[, 1, drop=FALSE], sim0)
                      

all.equal(bicGLMsin[[2]], data.frame(GLMsim.), 
    tolerance=4*sqrt(.Machine$double.eps))
# tcrossprod numeric precision is mediocre 
# for the constant model in this example.  

</code></pre>

<hr>
<h2 id='simulate.glm'>
A &quot;simulate&quot; method for a glm object
</h2><span id='topic+simulate.glm'></span>

<h3>Description</h3>

<p>Simulate predictions for <code>newdata</code> for a
model of class <code><a href="stats.html#topic+glm">glm</a></code> with mean 
<code>coef(object)</code> and variance 
<code>vcov(object)</code>. 
</p>
<p>NOTES: The <strong>stats</strong> package has a 
<code><a href="stats.html#topic+simulate">simulate</a></code> method for 
&quot;<code>lm</code>&quot; objects which is used for 
<code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+glm">glm</a></code> objects. 
It differs from the current <code>simulate.glm</code>
function in two fundamental and important ways:  
</p>

<ol>
<li>
<p><code>stats::<a href="stats.html#topic+simulate">simulate</a></code>
returns simulated data consistent with the 
model fit assuming the estimated model 
parameters are true and exact, i.e., 
ignoring the uncertainty in parameter 
estimation.  Thus, if <code>family = 
      poisson</code>, 
<code>stats::<a href="stats.html#topic+simulate">simulate</a></code>
returns nonnegative integers.  
</p>
<p>By contrast the <code>simulate.glm</code>
function documented here returns optionally 
simulated <code>coef (coefficients)</code> plus 
simulated values for the <code>link</code> and / 
or <code>response</code> but currently <em>NOT</em> 
pseudo-random numbers on the scale of the 
response.  
</p>
</li>
<li> 
<p>The <code>simulate.glm</code> function documented
here also accepts an optional <code>newdata</code>
argument, not accepted by 
<code>stats::<a href="stats.html#topic+simulate">simulate</a></code>.  The 
<code>stats::<a href="stats.html#topic+simulate">simulate</a></code> 
function only returns simulated values for 
the cases in the training set with no 
possibilities for use for different sets 
of conditions.  
</p>
</li></ol>
  


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
simulate(object, nsim = 1, 
    seed = NULL, newdata=NULL, 
    type = c("coef", "link", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.glm_+3A_object">object</code></td>
<td>

<p>an object representing a fitted model 
of class <code><a href="stats.html#topic+glm">glm</a></code>.  
</p>
</td></tr>
<tr><td><code id="simulate.glm_+3A_nsim">nsim</code></td>
<td>

<p>number of response vectors to simulate. 
Defaults to 1.
</p>
</td></tr>
<tr><td><code id="simulate.glm_+3A_seed">seed</code></td>
<td>

<p>Argument passed as the first argument to 
<code><a href="base.html#topic+set.seed">set.seed</a></code> if not NULL.  
</p>
</td></tr>
<tr><td><code id="simulate.glm_+3A_newdata">newdata</code></td>
<td>

<p>optionally, a <code><a href="base.html#topic+data.frame">data.frame</a></code> 
in which to look for variables with 
which to predict. If omitted, predictors 
used in fitting are used.  
</p>
</td></tr>
<tr><td><code id="simulate.glm_+3A_type">type</code></td>
<td>

<p>the type of simulations required. 
</p>

<ul>
<li> <p><code>coef</code>: 
Simulated coefficents using 
<code>mvtnorm::<a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a>(nsim,
        coef(object), vcov(object))</code>.  
</p>
</li>
<li> <p><code>link</code>: 
The default <code>type</code>='link' is on the 
scale of the linear predictors using 
<code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code> applied  
to randomly selected components of the 
mixture with <code>mean</code> = 
<code><a href="stats.html#topic+coef">coef</a></code> and <code>sigma</code> = 
<code><a href="stats.html#topic+vcov">vcov</a></code> for that component.  
For a default binomial model, these are 
of log-odds (probabilities on logit 
scale).
</p>
</li>
<li> <p><code>response</code>: 
<code>object[['linkinv']]</code> of <code>
        type = 'link'</code>.  For a binomial model, 
these are predicted probabilities.  
</p>
</li></ul>

</td></tr>
<tr><td><code id="simulate.glm_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other
methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  Save current <code>seed</code> and optionally set 
it using code copied from 
<code>stats:::simulate.lm</code>.  
</p>
<p>2.  <code>if(is.null(newdata))newdata</code> gets the
data used in the call to <code><a href="stats.html#topic+glm">glm</a></code>.
</p>
<p>3.  <code>newMat &lt;- model.matrix(~., newdata)</code>
</p>
<p>4.  <code>simCoef &lt;- mvtnorm::rmvnorm(nsim, 
  coef(object), vcov(object))</code>
</p>
<p>5.  <code>sims &lt;- tcrossprod(newMat, simCoef)</code>
</p>
<p>6.  If <code>length(type)</code> == 1:  return a
<code><a href="base.html#topic+data.frame">data.frame</a></code> with one column for 
each desired simulation, consistent with the 
behavior of the generic <code><a href="stats.html#topic+simulate">simulate</a></code>
applied to objects of class <code>lm</code> or 
<code>glm</code>.  Otherwise, return a list of 
<code><a href="base.html#topic+data.frame">data.frame</a></code>s of the desired types.  
</p>


<h3>Value</h3>

<p>Returns either a <code><a href="base.html#topic+data.frame">data.frame</a></code> or a
list of  <code><a href="base.html#topic+data.frame">data.frame</a></code>s depending 
on 'type':  
</p>
<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> 
with <code>nsim</code> columns giving simulated
parameters generated using 
<code>mvtnorm::<a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a>(nsim, 
    coef(object), vcov(object))</code>.  
</p>
</td></tr>
<tr><td><code>link</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with <code>nsim</code> 
columns of <code>nobs</code> values each giving 
the simulations on the <code>link</code> scale by
applying each set of simulated coefficients 
to <code>newdata</code> (or to the training set of
<code>newdata</code> is not supplied).  
</p>
</td></tr>
<tr><td><code>response</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with <code>nsim</code>
columns of <code>nobs</code> values each giving the
simulations on the <code>response</code> scale, 
being <code>linkinv</code> of the simulations on 
the <code>link</code> scale.  
</p>
</td></tr>
<tr><td><code>if length(type)&gt;1</code></td>
<td>

<p>a list with simulations on the desired 
scales.  
</p>
</td></tr>
</table>
<p>The value also has an attribute &quot;<code>seed</code>&quot;. 
If argument <code>seed</code> is <code>NULL</code>, the
attribute is the value of 
<code><a href="base.html#topic+.Random.seed">.Random.seed</a></code> before the 
simulation started.  Otherwise it is the value 
of the argument with a <code>kind</code> attribute 
with value <code>as.list(RNGkind())</code>.  
</p>
<p>NOTE:  This function currently may not work
with a model fit that involves a multivariate 
<code>link</code> or <code>response</code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+simulate">simulate</a></code>
<code><a href="stats.html#topic+glm">glm</a></code>
<code><a href="stats.html#topic+predict.glm">predict.glm</a></code>
<code><a href="base.html#topic+set.seed">set.seed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)
##
## 1.  a factor and a numeric 
##
PoisReg2 &lt;- data.frame(y=1:6, 
    x=factor(rep(0:2, 2)), x1=rep(1:2, e=3))
GLMpoisR2 &lt;- glm(y~x+x1, poisson, PoisReg2)

newDat. &lt;- data.frame(
  x=factor(rep(c(0, 2), 2), levels=0:2), 
  x1=3:6)
# NOTE:  Force newDat2['x'] to have the same levels
# as PoisReg2['x']

GLMsim2n &lt;- simulate(GLMpoisR2, nsim=3, seed=2,
  newdata=newDat.)

##
## 2.  One variable:  BMA returns
##     a mixture of constant &amp; linear models
##
PoisRegDat &lt;- data.frame(x=1:2, y=c(5, 10))
GLMex &lt;- glm(y~x, poisson, PoisRegDat)

# Simulate for the model data 
GLMsig &lt;- simulate(GLMex, nsim=2, seed=1)  

# Simulate for new data
newDat &lt;- data.frame(x=3:4, 
      row.names=paste0('f', 3:4))
GLMsio &lt;- simulate(GLMex, nsim=3, seed=2, 
                      newdata=newDat)

##
## 2a.  Compute the correct answers manually 
##
newMat &lt;- model.matrix(~., newDat)
RNGstate &lt;- structure(2, kind = as.list(RNGkind()))
set.seed(2)

sim &lt;- mvtnorm::rmvnorm(3, coef(GLMex), 
                         vcov(GLMex))
rownames(sim) &lt;- paste0('sim_', 1:3)
simDF &lt;- data.frame(t(sim))

GLMsim.l &lt;- tcrossprod(newMat, sim)
colnames(GLMsim.l) &lt;- paste0('sim_', 1:3)
GLMsim.r &lt;- exp(GLMsim.l) 
GLMsim2 &lt;- list(coef=simDF, 
  link=data.frame(GLMsim.l), 
  response=data.frame(GLMsim.r) )
attr(GLMsim2, 'seed') &lt;- RNGstate  


all.equal(GLMsio, GLMsim2)

</code></pre>

<hr>
<h2 id='strsplit1'>
Split the first field 
</h2><span id='topic+strsplit1'></span>

<h3>Description</h3>

<p>Split the first field from <code>x</code>, 
identified as all the characters 
preceding the first unquoted occurrence 
of <code>split</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strsplit1(x, split=',', Quote='"', ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strsplit1_+3A_x">x</code></td>
<td>

<p>a character vector to be split 
</p>
</td></tr>
<tr><td><code id="strsplit1_+3A_split">split</code></td>
<td>

<p>the split character 
</p>
</td></tr>
<tr><td><code id="strsplit1_+3A_quote">Quote</code></td>
<td>

<p>a quote character:  Occurrences of 
<code>split</code> between pairs of <code>Quote</code> 
are ignored.  
</p>
</td></tr>
<tr><td><code id="strsplit1_+3A_...">...</code></td>
<td>

<p>optional arguments for grep  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was written to help parse 
data from the US Department of Health and 
Human Services on 
<a href="https://ocrportal.hhs.gov/ocr/breach/breach_report.jsf">
cyber-security breaches affecting 500 or 
more individuals</a>.  As of 2014-06-03 the 
<code>csv</code> version of these data included 
commas in quotes that are not <code>sep</code> 
characters.  This function was written to 
split the fields one at a time to allow 
manual processing to make it easier to 
correct parsing errors.  
</p>
<p>Algorithm:  
</p>
<p>1.  <code>spl1 &lt;- regexpr(split, x, ...)</code>
</p>
<p>2.  <code>Qt1 &lt;- regexpr(Quote, x, ...)</code>
</p>
<p>3.  For any <code>(Qt1&lt;spl1)</code>, look for 
<code>Qt2 &lt;- regexpr(Quote, substring(x, Qt1+1))</code>,
then look for 
<code>spl1 &lt;- regexpr(split, substring(x, 
  Qt1+Qt2+1))</code>
</p>
<p>4.  <code>out &lt;- list(substr(x, 1, spl1-1), 
  substr(x, spl1+1))</code>
</p>


<h3>Value</h3>

<p>A list of length 2:  The first component of 
the list contains the character strings found
before the first unquoted occurrence of 
<code>split</code>.  The second component contains 
the character strings remaining after the 
characters up to the identified <code>split</code> 
are removed.   
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strsplit">strsplit</a></code>
<code><a href="base.html#topic+substring">substring</a></code>
<code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chars2split &lt;- c(qs00='abcdefg', qs01='abc,def', 
   qs10a='"abcdefg', qs10b='abc"defg', 
   qs1.1='"abc,def', qs20='"abc" def', 
   qs2.1='"ab,c" def', qs21='"abc", def', qs22.1='"a,b",c')    

split &lt;- strsplit1(chars2split)

# answer
split. &lt;- list(c(qs00='abcdefg', qs01='abc', qs10a='"abcdefg', 
   qs10b='abc"defg', qs1.1='"abc,def', qs20='"abc" def', 
   qs2.1='"ab,c" def', qs21='"abc"', qs22.1='"a,b"'), 
               c(qs00='', qs01='def', qs10a='', 
   qs10b='', qs1.1='', qs20='', qs2.1='', 
   qs21=' def', qs22.1='c') )

all.equal(split, split.)

</code></pre>

<hr>
<h2 id='subNonStandardCharacters'>
sub nonstandard characters with replacement
</h2><span id='topic+subNonStandardCharacters'></span>

<h3>Description</h3>

<p>First convert to ASCII, stripping standard 
accents and special characters.  Then find 
the first and last character not in 
<code>standardCharacters</code> and replace all 
between them with <code>replacement</code>.  For 
example, a string like &quot;Ruben&quot; where &quot;e&quot; 
carries an accent and is mangled by some 
software would become something like 
&quot;Rub_n&quot; using the default values for 
<code>standardCharacters</code> and 
<code>replacement</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subNonStandardCharacters(x,
   standardCharacters=c(letters, LETTERS, 
      ' ','.', '?', '!', ',', 0:9, '/', '*', 
      '$', '%', '\"', "\'", '-', '+', '&amp;', 
      '_', ';', '(', ')', '[', ']', '\n'),
   replacement='_',
   gsubList=list(list(pattern = 
      '\\\\\\\\|\\\\',
      replacement='\"')), ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subNonStandardCharacters_+3A_x">x</code></td>
<td>

<p>character vector in which it is desired 
to find the first and last character not 
in <code>standardCharacters</code> and replace 
that substring by <code>replacement</code>.
</p>
</td></tr>
<tr><td><code id="subNonStandardCharacters_+3A_standardcharacters">standardCharacters</code></td>
<td>

<p>a character vector of acceptable characters 
to keep.
</p>
</td></tr>
<tr><td><code id="subNonStandardCharacters_+3A_replacement">replacement</code></td>
<td>

<p>a character to replace the substring 
starting and ending with characters not 
in <code>standardCharacters</code>.
</p>
</td></tr>
<tr><td><code id="subNonStandardCharacters_+3A_gsublist">gsubList</code></td>
<td>

<p>list of lists of <code>pattern</code> and 
<code>replacement</code> arguments to be called 
in succession before looking for 
<code>nonStandardCharacters</code>
</p>
</td></tr>
<tr><td><code id="subNonStandardCharacters_+3A_...">...</code></td>
<td>

<p>optional arguments passed to 
<code><a href="base.html#topic+strsplit">strsplit</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  <code>for(il in 1:length(gsubList))
    x &lt;- gsub(gsubList[[il]][["pattern"]], 
        gsubList[[il]][['replacement']], x)</code>
</p>
<p>2.  <code>x &lt;- stringi::stri_trans_general(x,
  "Latin-ASCII")</code>
</p>
<p>3.  <code>nx &lt;- length(x)</code>
</p>
<p>4.  <code>x. &lt;- strsplit(x, "", ...)</code>
</p>
<p>5.  <code>for(ix in 1:nx)</code> find the first and 
last <code>standardCharacters</code> in <code>x.[ix]</code>
and substitute <code>replacement</code> for 
everything in between.
</p>
<p>NOTES:  
</p>
<p>** To find the elements of x that have changed,
use either 
<code>subNonStandardCharacters(x) != x</code> or 
<code>grep(replacement, 
  subNonStandardCharacters(x))</code>,
where 
<code>replacement</code> is the <code>replacement</code> 
argument = &quot;_&quot; by default.  
</p>
<p>** On 13 May 2013 Jeff Newmiller at the 
University of California, Davis, wrote, 'I 
think it is a fools errand to think that you 
can automatically &quot;normalize&quot; arbitrary Unicode
characters to an ASCII form that everyone will
agree on.'  (This was a reply on 
r-help@r-project.org, subject:  &quot;Re: [R] Matching 
names with non-English characters&quot;.)  
</p>
<p>** On 2014-12-15 Ista Zahn suggested 
<code><a href="stringi.html#topic+stri_trans_general">stri_trans_general</a></code>. 
(This was a reply on r-help@r-project.org, 
subject:  &quot;[R] Comparing Latin characters with 
and without accents?&quot;.)  
</p>


<h3>Value</h3>

<p>a character vector with everything between the
first and last character not in 
<code>standardCharacters</code> replaced by 
<code>replacement</code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves with thanks to Jeff Newmiller, 
who described this as a &quot;fool's errand&quot;, 
Milan Bouchet-Valat, who directed me to 
<code><a href="base.html#topic+iconv">iconv</a></code>, and Ista Zahn, who 
suggested 
<code><a href="stringi.html#topic+stri_trans_general">stri_trans_general</a></code>.  
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sub">sub</a></code>, <code><a href="base.html#topic+strsplit">strsplit</a></code>,
<code><a href="#topic+grepNonStandardCharacters">grepNonStandardCharacters</a></code>,
<code><a href="#topic+subNonStandardNames">subNonStandardNames</a></code>
<code><a href="#topic+subNonStandardNames">subNonStandardNames</a></code>
<code><a href="base.html#topic+iconv">iconv</a></code> in the <code>base</code> 
package does some conversion, but is not
consistent across platforms, at least 
using R 3.1.2 on 2015-01.25.  
<code><a href="stringi.html#topic+stri_trans_general">stri_trans_general</a></code> 
seems better.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1. Consider Names = Ruben, Avila and Jose, where 
##    "e" and "A" in these examples carry an accent.  
##    With the default values for standardCharacters and
##    replacement, these might be converted to something
##    like Rub_n, _vila, and Jos_, with different software
##    possibly mangling the names differently.  (The
##    standard checks for R packages in an English locale 
##    complains about non-ASCII characters, because they
##    are not portable.)
##
nonstdNames &lt;- c('Ra`l', 'Ra`', '`l', 'Torres, Raul',
           "Robert C. \\Bobby\\\\", NA, '', '  ', 
           '$12', '12%')
#  confusion in character sets can create
#  names like Names[2]
Name2 &lt;- subNonStandardCharacters(nonstdNames)
str(Name2)

# check 
Name2. &lt;- c('Ra_l', 'Ra_', '_l', nonstdNames[4],
            'Robert C. "Bobby"', NA, '', '  ', 
            '$12', '12%')
str(Name2.)

all.equal(Name2, Name2.)

##
## 2.  Example from iconv
##
icx &lt;- c("Ekstr\u{f8}m", "J\u{f6}reskog", 
         "bi\u{df}chen Z\u{fc}rcher")
icx2 &lt;- subNonStandardCharacters(icx)

# check 
icx. &lt;- c('Ekstrom', 'Joreskog', 'bisschen Zurcher')

all.equal(icx2, icx.)

</code></pre>

<hr>
<h2 id='subNonStandardNames'>
sub for nonstandard names
</h2><span id='topic+subNonStandardNames'></span>

<h3>Description</h3>

<p><code>sub(nonStandardNames[, 1], 
  nonStandardNames[, 2], x)</code>
</p>
<p>Accented characters common in non-English 
languages often get mangled in different 
ways by different software.  For example, 
the &quot;e&quot; in &quot;Andre&quot; may carry an accent that 
gets replaced by other characters by different 
software.  
</p>
<p>This function first converts <code>"Andr*"</code> 
to <code>"Andr_"</code> for any character &quot;*&quot; not 
in <code>standardCharacters</code>.  It then looks 
for <code>"Andr_"</code> in <code>nonStandardNames</code>.  
By default, it will find that and replace it 
with &quot;Andre&quot;.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subNonStandardNames(x,
  standardCharacters=c(letters, LETTERS, ' ', 
    '.', '?', '!', ',', 0:9,   '/', '*', '$', 
    '%', '\"', "\'", '-', '+', '&amp;', '_', ';', 
    '(', ')', '[', ']', '\n'),
  replacement='_',
  gsubList=list(list(pattern=
        '\\\\\\\\|\\\\',
      replacement='\"')),
  removeSecondLine=TRUE,
  nonStandardNames=Ecdat::nonEnglishNames, 
  namesNotFound="attr.replacement", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subNonStandardNames_+3A_x">x</code></td>
<td>

<p>character vector or matrix or a 
<code>data.frame</code> of character vectors in 
which it is desired replace
<code>nonStandardNames[, 1]</code> in 
<code>subNonStandardCharacters(x, ...)</code> 
with the corresponding element of 
<code>nonStandardNames[, 2]</code>.
</p>
</td></tr>
<tr><td><code id="subNonStandardNames_+3A_standardcharacters">standardCharacters</code>, <code id="subNonStandardNames_+3A_replacement">replacement</code>, <code id="subNonStandardNames_+3A_gsublist">gsubList</code>, <code id="subNonStandardNames_+3A_...">...</code></td>
<td>

<p>arguments passed to 
<code><a href="#topic+subNonStandardCharacters">subNonStandardCharacters</a></code>
</p>
</td></tr>
<tr><td><code id="subNonStandardNames_+3A_removesecondline">removeSecondLine</code></td>
<td>

<p>logical:  If <code>TRUE</code>, delete anything
following <code>"\n"</code> and return it as 
an attribute <code>secondLine</code>.  
</p>
</td></tr>
<tr><td><code id="subNonStandardNames_+3A_nonstandardnames">nonStandardNames</code></td>
<td>

<p><code>data.frame</code> or character matrix with 
two columns: 
Replace any substring of <code>x</code> matching 
<code>nonStandardNames[, 1]</code> with the 
corresponding element of 
<code>nonStandardNames[, 2]</code>
</p>
</td></tr>
<tr><td><code id="subNonStandardNames_+3A_namesnotfound">namesNotFound</code></td>
<td>

<p>character vector describing how to treat 
substitutions not found in 
<code>nonStandardNames[, 1]</code>:  
</p>

<ul>
<li>
<p><code>attr.replacement</code>: Return an 
attribute <code>namesNotFound</code> with 
<code>grep(replacement, 
          subNonStandardCharacters(...))</code>, 
if any.

</p>
</li>
<li><p><code>attr.notFound</code>:  
Return an attribute <code>namesNotFound</code>  
with <code>x != 
        subNonStandardCharacters(...)</code>, 
if any.

</p>
</li>
<li><p>&quot;print&quot;:  Print the elements of 
<code>x</code> <code>notFound</code> per either
<code>attr.replacement</code> or 
<code>attr.notFound</code>, as requested.
  
</p>
</li>
<li>
<p>&quot;&quot;:  Do not report any <code>notFound</code> 
elements of <code>x</code>.

</p>
</li></ul>

<p>NOTE:  x = &quot;_&quot; will be identified by 
<code>attr.replacement</code> but not by 
<code>attr.notfound</code> assuming the default 
value for <code>replacement</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  <code>removeSecondLine</code>s
</p>
<p>2.  <code>x. &lt;- subNonStandardCharacters(x, 
  standardCharacters, replacement, ...)</code>
</p>
<p>3.  Loop over all rows of 
<code>nonStandardNames</code> substituting 
anything matching 
<code>nonStandardNames[i, 1]</code> with 
<code>nonStandardNames[i, 2]</code>.
</p>
<p>4.  Eliminate leading and trailing blanks.
</p>
<p>5.  <code>if(is.matrix(x))</code> return a matrix;  
<code>if(is.data.frame(x))</code> return a 
<code>data.frame(..., stringsAsFactors=FALSE)</code> 
</p>
<p>NOTE: On 13 May 2013 Jeff Newmiller at the
University of California, Davis, wrote, 'I 
think it is a fools errand to think that you 
can automatically &quot;normalize&quot; arbitrary Unicode
characters to an ASCII form that everyone will
agree on.'  (This was a reply on 
<code>r-help@r-project.org</code>, subject:  &quot;Re: [R]
Matching names with non-English characters&quot;.) 
Doubtless someone has software to do a better 
job of this than what this function does, but 
I've so far been unable to find it in R.  If 
you know of a better solution to this problem, 
I'd be pleased to hear from you.  Spencer Graves
</p>


<h3>Value</h3>

<p>a character vector with all 
<code>nonStandardCharacters</code> replaced first by
<code>replacement</code> and then by the second 
column of <code>nonStandardNames</code> for any that
match the first column.  If a <code>secondLine</code> 
is found on any elements, it is returned as a
<code>secondLine</code> attribute. 
</p>
<p>If any names with <code>nonStandardCharacters</code> 
are not found in <code>nonStandardNames[, 1]</code>,
they are identified in an optional attribute 
per the <code>namesNotFound</code> argument.    
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sub">sub</a></code>
<code><a href="Ecdat.html#topic+nonEnglishNames">nonEnglishNames</a></code>
<code><a href="#topic+subNonStandardCharacters">subNonStandardCharacters</a></code>
<code><a href="tis.html#topic+stripBlanks">stripBlanks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  Example 
##
tstSNSN &lt;- c('Raul', 'Ra`l', 'Torres,Raul', 
    'Torres, Ra`l', "Robert C. \\Bobby\\\\", 
    'Ed  \n --Vacancy', '', '  ')
#  confusion in character sets can create
#  names like Names[2]
##
## 2.  subNonStandardNames(vector)
##
SNS2 &lt;- subNonStandardNames(tstSNSN)
SNS2

# check 
SNS2. &lt;- c('Raul', 'Raul', 'Torres,Raul', 'Torres, Raul',
            'Robert C. "Bobby"', 'Ed', '', '')
attr(SNS2., 'secondLine') &lt;- c(rep(NA, 5), ' --Vacancy',
        NA, NA)


all.equal(SNS2, SNS2.)

##
## 3.  subNonStandardNames(matrix)
##
tstmat &lt;- parseName(tstSNSN, surnameFirst=TRUE)
submat &lt;- subNonStandardNames(tstmat)

# check 
SNSmat &lt;- parseName(SNS2., surnameFirst=TRUE)

all.equal(submat, SNSmat)


##
## 4.  subNonStandardNames(data.frame)
##
tstdf &lt;- as.data.frame(tstmat)
subdf &lt;- subNonStandardNames(tstdf)

# check 
SNSdf &lt;- as.data.frame(SNSmat, stringsAsFactors=FALSE)

all.equal(subdf, SNSdf)


##
## 5.  namesNotFound 
##
noSub &lt;- subNonStandardNames('xx_x')

# check 
noSub. &lt;- 'xx_x'
attr(noSub., 'namesNotFound') &lt;- 'xx_x'

all.equal(noSub, noSub.)

</code></pre>

<hr>
<h2 id='trimImage'>
Trim zero rows or columns from an object of 
class <code>Image</code>.
</h2><span id='topic+trimImage'></span>

<h3>Description</h3>

<p>Identify rows or columns of a matrix or 
3-dimensional array that are all 0 and 
remove them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimImage(x, max2trim=.Machine$double.eps, 
      na.rm=TRUE, returnIndices2Keep=FALSE, 
      ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trimImage_+3A_x">x</code></td>
<td>

<p>a numeric matrix or 3-dimensional array 
or an object with subscripting defined so
it acts like such.
</p>
</td></tr>
<tr><td><code id="trimImage_+3A_max2trim">max2trim</code></td>
<td>

<p>a single number indicating the max 
absolute numeric value to trim.
</p>
</td></tr>
<tr><td><code id="trimImage_+3A_na.rm">na.rm</code></td>
<td>

<p>logical:  If <code>TRUE</code>, <code>NA</code>s 
will be ignored in determining the 
max absolute value for the row.  If a
row or column is all <code>NA</code>, it 
will be treated as all 0 in deciding 
whether to trim.
</p>
<p>If <code>FALSE</code>, any row or column 
containing an <code>NA</code> will be 
retained.
</p>
</td></tr>
<tr><td><code id="trimImage_+3A_returnindices2keep">returnIndices2Keep</code></td>
<td>

<p>if <code>TRUE</code>, return a list with 2 
integer vectors giving row and column 
indices to use in selecting the 
desired subset of <code>x</code>.  This 
allows an array <code>y</code> to be 
trimmed to match <code>x</code>.
</p>
<p>If <code>FALSE</code>, return the desired 
trimmed version of <code>x</code>.
</p>
<p>If this is a list with two two 
integer vectors, use them to trim 
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="trimImage_+3A_...">...</code></td>
<td>

<p>Optional arguments;  not currently 
used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  Check arguments:  2 &lt;= 
<code>length(dim(x))</code> &lt;= 3?  
<code>is.logical(na.rm)</code>?  
<code>returnIndices2Keep</code> = logical 
or list of 2 integer vectors, all 
the same sign, not exceeding 
<code>dim(x)</code>?
</p>
<p>2.  <code>if(is.list(returnIndices2Keep))</code> 
check that <code>returnIndices2Keep</code> is a 
list with 2 integer vectors, all the same 
sign, not exceeding <code>dim(x)</code>.
If yes, return <code>x</code> appropriately 
subsetted.
</p>
<p>3.  <code>if(!is.logical(returnIndices2Keep))</code>
throw an error message.
</p>
<p>4.  Compute <code>indices2Keep</code>.
</p>
<p>5.  <code>If(returnIndices2Keep)</code> return 
(<code>indices2Keep</code>) else return <code>x</code>
appropriately subsetted.
</p>


<h3>Value</h3>

<p><code>if(returnIndices2Keep==TRUE)</code> return 
a list with 2 integer vectors to use as 
subscripts in trimming objects like 
<code>x</code>.
</p>
<p>Otherwise, return an object like <code>x</code>
appropriately trimmed.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="raster.html#topic+trim">trim</a></code> trims raster 
images, similar to <code>trimImage</code>.
</p>
<p><code><a href="base.html#topic+trimws">trimws</a></code> trims leading and 
trailing spaces from character strings 
and factors.  Similar <code>trim</code>
functions exist in other packages but 
without obvious, explicit consideration 
of <code>factors</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  trim a simple matrix
##
tst1 &lt;- matrix(.Machine$double.eps, 3, 3,
    dimnames=list(letters[1:3], LETTERS[1:3]))
tst1[2,2] &lt;- 1
tst1t &lt;- trimImage(tst1)

# check
tst1. &lt;- matrix(1, 1, 1,
          dimnames=list(letters[2], LETTERS[2]))

all.equal(tst1t, tst1.)


##
## 2.  returnIndices2Keep
##
tst2i &lt;- trimImage(tst1, returnIndices2Keep=TRUE)
tst2a &lt;- trimImage(tst1, returnIndices2Keep=tst2i)

tst2i. &lt;- list(index1=2, index2=2)


# check

all.equal(tst2i, tst2i.)


all.equal(tst2a, tst1.)


##
## 3.  trim 0's only
##
tst3 &lt;- array(0, dim=3:5)
tst3[2, 2:3, ] &lt;- 0.5*.Machine$double.eps
tst3[3,,] &lt;- 1

tst3t &lt;- trimImage(tst3, 0)

# check
tst3t. &lt;- tst3[2:3,, ]

# check

all.equal(tst3t, tst3t.)


##
## 4.  trim NAs
##
tst4 &lt;- tst1
tst4[1,1] &lt;- NA
tst4[3,] &lt;- NA

tst4t &lt;- trimImage(tst4)
# tst4o == tst4
tst4o &lt;- trimImage(tst4, na.rm=FALSE)

# check

all.equal(tst4t, tst1[2, 2, drop=FALSE])



all.equal(tst4o, tst4)


##
## 5.  trim all
##
tst4a &lt;- trimImage(tst1, 1)

tst4a. &lt;- matrix(0,0,0,
     dimnames=list(NULL, NULL))


all.equal(tst4a, tst4a.)



</code></pre>

<hr>
<h2 id='truncdist'>
Truncated distribution 
</h2><span id='topic+truncdist'></span><span id='topic+dtruncdist'></span><span id='topic+ptruncdist'></span><span id='topic+qtruncdist'></span><span id='topic+rtruncdist'></span>

<h3>Description</h3>

<p>The cumulative distribution function for 
a truncated distribution is <code>0</code> for 
<code>x &lt;= truncmin</code>, <code>1</code> for 
<code>truncmax &lt; x</code>, and in between is
as follows:  
</p>
<p><code>(pdist(x, ...) - pdist(truncmin, ...)) / 
     (pdist(truncmax, ...) - pdist(truncmin, ...))</code>
</p>
<p>The density, quantile, and random number 
generation functions are similarly defined 
from this.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtruncdist(x, ..., dist='norm', truncmin=-Inf, 
            truncmax=Inf) 
ptruncdist(q, ..., dist='norm', truncmin=-Inf, 
            truncmax=Inf) 
qtruncdist(p, ..., dist='norm', truncmin=-Inf, 
            truncmax=Inf) 
rtruncdist(n, ..., dist='norm', truncmin=-Inf, 
            truncmax=Inf) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="truncdist_+3A_x">x</code>, <code id="truncdist_+3A_q">q</code></td>
<td>
 
<p>numeric vector of quantiles 
</p>
</td></tr>
<tr><td><code id="truncdist_+3A_p">p</code></td>
<td>

<p>numeric vector of probabilities  
</p>
</td></tr>
<tr><td><code id="truncdist_+3A_n">n</code></td>
<td>

<p>number of observations. If <code>length(n)</code> 
&gt; 1, the length is taken to be the number 
required.
</p>
</td></tr>
<tr><td><code id="truncdist_+3A_...">...</code></td>
<td>

<p>other arguments to be passed to the 
corresponding function for the indicated 
<code>dist</code>
</p>
</td></tr>
<tr><td><code id="truncdist_+3A_dist">dist</code></td>
<td>

<p>Standard <code>R</code> name for the family of 
functions for the desired distribution.  By 
default, this is <code>norm</code>, so the 
corresponding function for <code>dtruncdist</code> 
is <code>dnorm</code>, the corresponding function 
for <code>ptrunctist</code> is <code>pnorm</code>, etc.  
</p>
</td></tr>
<tr><td><code id="truncdist_+3A_truncmin">truncmin</code>, <code id="truncdist_+3A_truncmax">truncmax</code></td>
<td>

<p>lower and upper truncation points, 
respectively.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE:  Truncation is different from 
&quot;censoring&quot;, where it's known that an 
observation lies between certain limits; it's just 
not known exactly where it lies between those 
limits.  
</p>
<p>By contrast, with a truncated distribution, events 
below <code>truncmin</code> and above <code>truncmax</code> 
may exist but are not observed.  Thus, it's not 
known how many events occur  outside the given 
range, <code>truncmin</code> to <code>truncmax</code>, if any.  
Given data believed to come from a truncated 
distribution, estimating the parameters provide 
a means of estimating the number of unobserved 
events, assuming a particular form for their 
distribution.  
</p>
<p>1.  Setup
</p>
<p><code>dots &lt;- list(...)</code>
</p>
<p>2.  For <code>dtruncdist</code>, return 0 for all 
<code>x</code> outside <code>truncmin</code> and 
<code>truncmax</code>.  For all others, compute as 
follows:  
</p>
<p><code>dots$x &lt;- truncmin
  ddist &lt;- paste0('d', dist)
  pdist &lt;- paste0('p', dist)
  p.min &lt;- do.call(pdist, dots)
  dots$x &lt;- truncmax
  p.max &lt;- do.call(pdist, dots)
  dots$x &lt;- x
  dx &lt;- do.call(ddist, dots)</code>
</p>
<p><code>return(dx / (p.max-p.min))</code>
</p>
<p>NOTE:  Adjustments must be made if 'log' 
appears in <code>names(dots)</code>
</p>
<p>3.  The computations for <code>ptruncdist</code> 
are similar.  
</p>
<p>4.  The computations for <code>qtruncdist</code> 
are complementary.  
</p>
<p>5.  For <code>rtruncdist</code>, use 
<code>qtruncdist(runif(n), ...)</code>.  
</p>


<h3>Value</h3>

<p><code>dtruncdist</code> gives the density, 
<code>ptruncdist</code> gives the distribution 
function, <code>qtruncdist</code> gives the 
quantile function, and <code>rtruncdist</code> 
generates random deviates. 
</p>
<p>The length of the result is determined by 
<code>n</code> for <code>rtruncdist</code> and is the 
maximum of the lengths of the numerical 
arguments for the other functions. 
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Distributions">Distributions</a></code>
<code><a href="stats.html#topic+Normal">Normal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  dtruncdist
##
#  1.1.  Normal 
dx &lt;- dtruncdist(1:4)

# check 

all.equal(dx, dnorm(1:4))


#  1.2.  Truncated normal between 0 and 1
dx01 &lt;- dtruncdist(seq(-1, 2, .5), truncmin=0, truncmax=1)

# check 
dx01. &lt;- c(0, 0, 0, dnorm(c(.5, 1))/(pnorm(1)-pnorm(0)), 
           0, 0)

all.equal(dx01, dx01.)


#  1.3.  lognormal meanlog=log(100), sdlog = 2, truncmin=500 
x10 &lt;- 10^(0:9)
dx10 &lt;- dtruncdist(x10, log(100), 2, dist='lnorm', 
                   truncmin=500)
                  
# check 
dx10. &lt;- (dtruncdist(log(x10), log(100), 2,  
                    truncmin=log(500)) / x10) 

all.equal(dx10, dx10.)


#  1.4.  log density of the previous example 
dx10log &lt;- dtruncdist(x10, log(100), 2, log=TRUE, 
                  dist='lnorm', truncmin=500)

all.equal(dx10log, log(dx10))


#  1.5.  Poisson without 0.  

dPois0.9 &lt;-dtruncdist(0:9, lambda=1, dist='pois', truncmin=0) 

# check 
dP0.9 &lt;- c(0, dpois(1:9, lambda=1)/ppois(0, lambda=1, lower.tail=FALSE))

all.equal(dPois0.9, dP0.9)


##
## 2.  ptruncdist
##
#  2.1.  Normal 
px &lt;- ptruncdist(1:4)

# check 

all.equal(px, pnorm(1:4))


#  2.2.  Truncated normal between 0 and 1 
px01 &lt;- ptruncdist(seq(-1, 2, .5), truncmin=0, truncmax=1)

# check 
px01. &lt;- c(0, 0, (pnorm(c(0, .5, 1)) - pnorm(0))
                     /(pnorm(1)-pnorm(0)), 1, 1)

all.equal(px01, px01.)


#  2.3.  lognormal meanlog=log(100), sdlog = 2, truncmin=500 
x10 &lt;- 10^(0:9)
px10 &lt;- ptruncdist(x10, log(100), 2, dist='lnorm', 
                  truncmin=500)
                  
# check 
px10. &lt;- (ptruncdist(log(x10), log(100), 2,  
                     truncmin=log(500))) 

all.equal(px10, px10.)


#  2.4.  log of the previous probabilities 
px10log &lt;- ptruncdist(x10, log(100), 2, log=TRUE, 
                  dist='lnorm', truncmin=500)

all.equal(px10log, log(px10))


##
## 3.  qtruncdist
##
#  3.1.  Normal 
qx &lt;- qtruncdist(seq(0, 1, .2))

# check 

all.equal(qx, qnorm(seq(0, 1, .2)))


#  3.2.  Normal truncated outside (0, 1)
qx01 &lt;- qtruncdist(seq(0, 1, .2), 
            truncmin=0, truncmax=1)

# check 
pxmin &lt;- pnorm(0)
pxmax &lt;- pnorm(1)
unp &lt;- (pxmin + seq(0, 1, .2)*(pxmax-pxmin))
qx01. &lt;- qnorm(unp)

all.equal(qx01, qx01.)


#  3.3.  lognormal meanlog=log(100), 
#             sdlog=2, truncmin=500
qlx10 &lt;- qtruncdist(seq(0, 1, .2), log(100), 2, 
                   dist='lnorm', truncmin=500)
                  
# check 
plxmin &lt;- plnorm(500, log(100), 2)
unp. &lt;- (plxmin + seq(0, 1, .2)*(1-plxmin))

qlx10. &lt;- qlnorm(unp., log(100), 2)

all.equal(qlx10, qlx10.)


#  3.4.  previous example with log probabilities 
qlx10l &lt;- qtruncdist(log(seq(0, 1, .2)), 
      log(100), 2, log.p=TRUE, dist='lnorm',
      truncmin=500)

# check 

all.equal(qlx10, qlx10l)


## 
## 4.  rtruncdist 
##
#  4.1.  Normal 
set.seed(1)
rx &lt;- rtruncdist(9)

# check 
set.seed(1)

all.equal(rx[1], rnorm(1))

# Only the first observation matches;  check that.  

#  4.2.  Normal truncated outside (0, 1)
set.seed(1)
rx01 &lt;- rtruncdist(9, truncmin=0, truncmax=1)

# check 
pxmin &lt;- pnorm(0)
pxmax &lt;- pnorm(1)
set.seed(1)
rnp &lt;- (pxmin + runif(9)*(pxmax-pxmin))
rx01. &lt;- qnorm(rnp)

all.equal(rx01, rx01.)


#  4.3.  lognormal meanlog=log(100), sdlog=2, truncmin=500
set.seed(1)
rlx10 &lt;- rtruncdist(9, log(100), 2, 
                   dist='lnorm', truncmin=500)
                  
# check 
plxmin &lt;- plnorm(500, log(100), 2)
set.seed(1)
rnp. &lt;- (plxmin + runif(9)*(1-plxmin))

rlx10. &lt;- qlnorm(rnp., log(100), 2)

all.equal(rlx10, rlx10.)


</code></pre>

<hr>
<h2 id='whichAeqB'>
Index of a single match
</h2><span id='topic+whichAeqB'></span>

<h3>Description</h3>

<p>Return which(A %in% B) if it has length 1;  give an error message
otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whichAeqB(A, B, errNoMatch='no match',
                      err2Match='more than one match')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whichAeqB_+3A_a">A</code></td>
<td>

<p>A vector which may have a single match in <code>B</code>.
</p>
</td></tr>
<tr><td><code id="whichAeqB_+3A_b">B</code></td>
<td>

<p>A vector of possible matches for <code>A</code>.
</p>
</td></tr>
<tr><td><code id="whichAeqB_+3A_errnomatch">errNoMatch</code></td>
<td>

<p>a character string:  error message if no match found.
</p>
</td></tr>
<tr><td><code id="whichAeqB_+3A_err2match">err2Match</code></td>
<td>

<p>a character string:  error message if multiple matches found.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single integer giving the index of the match in <code>A</code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interpPairs">interpPairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a2b &lt;- whichAeqB(letters, 'b')


all.equal(a2b, 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
