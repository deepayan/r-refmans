<!DOCTYPE html><html lang="en"><head><title>Help for package bayesplot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesplot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesplot-package'><p><strong>bayesplot</strong>: Plotting for Bayesian Models</p></a></li>
<li><a href='#available_ppc'><p>Get or view the names of available plotting or data functions</p></a></li>
<li><a href='#bayesplot_grid'><p>Arrange plots in a grid</p></a></li>
<li><a href='#bayesplot_theme_get'><p>Get, set, and modify the active <strong>bayesplot</strong> theme</p></a></li>
<li><a href='#bayesplot-colors'><p>Set, get, or view <strong>bayesplot</strong> color schemes</p></a></li>
<li><a href='#bayesplot-extractors'><p>Extract quantities needed for plotting from model objects</p></a></li>
<li><a href='#bayesplot-helpers'><p>Convenience functions for adding or changing plot details</p></a></li>
<li><a href='#example-data'><p>Example draws to use in demonstrations and tests</p></a></li>
<li><a href='#MCMC-combos'><p>Combination plots</p></a></li>
<li><a href='#MCMC-diagnostics'><p>General MCMC diagnostics</p></a></li>
<li><a href='#MCMC-distributions'><p>Histograms and kernel density plots of MCMC draws</p></a></li>
<li><a href='#MCMC-intervals'><p>Plot interval estimates from MCMC draws</p></a></li>
<li><a href='#MCMC-nuts'><p>Diagnostic plots for the No-U-Turn-Sampler (NUTS)</p></a></li>
<li><a href='#MCMC-overview'><p>Plots for Markov chain Monte Carlo simulations</p></a></li>
<li><a href='#MCMC-parcoord'><p>Parallel coordinates plot of MCMC draws</p></a></li>
<li><a href='#MCMC-recover'><p>Compare MCMC estimates to &quot;true&quot; parameter values</p></a></li>
<li><a href='#MCMC-scatterplots'><p>Scatterplots of MCMC draws</p></a></li>
<li><a href='#MCMC-traces'><p>Trace and rank plots of MCMC draws</p></a></li>
<li><a href='#pp_check'><p>Posterior (or prior) predictive checks (S3 generic and default method)</p></a></li>
<li><a href='#PPC-censoring'><p>PPC censoring</p></a></li>
<li><a href='#PPC-discrete'><p>PPCs for discrete outcomes</p></a></li>
<li><a href='#PPC-distributions'><p>PPC distributions</p></a></li>
<li><a href='#PPC-errors'><p>PPC errors</p></a></li>
<li><a href='#PPC-intervals'><p>PPC intervals</p></a></li>
<li><a href='#PPC-loo'><p>LOO predictive checks</p></a></li>
<li><a href='#PPC-overview'><p>Graphical posterior predictive checking</p></a></li>
<li><a href='#PPC-scatterplots'><p>PPC scatterplots</p></a></li>
<li><a href='#PPC-test-statistics'><p>PPC test statistics</p></a></li>
<li><a href='#PPD-distributions'><p>PPD distributions</p></a></li>
<li><a href='#PPD-intervals'><p>PPD intervals</p></a></li>
<li><a href='#PPD-overview'><p>Plots of posterior or prior predictive distributions</p></a></li>
<li><a href='#PPD-test-statistics'><p>PPD test statistics</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#theme_default'><p>Default <strong>bayesplot</strong> plotting theme</p></a></li>
<li><a href='#tidy-params'><p>Tidy parameter selection</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Plotting for Bayesian Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.11.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonah Gabry &lt;jsg2201@columbia.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Plotting functions for posterior analysis, MCMC diagnostics,
    prior and posterior predictive checks, and other visualizations
    to support the applied Bayesian workflow advocated in
    Gabry, Simpson, Vehtari, Betancourt, and Gelman (2019) &lt;<a href="https://doi.org/10.1111%2Frssa.12378">doi:10.1111/rssa.12378</a>&gt;.
    The package is designed not only to provide convenient functionality
    for users, but also a common set of functions that can be easily used by
    developers working on a variety of R packages for Bayesian modeling,
    particularly (but not exclusively) packages interfacing with 'Stan'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mc-stan.org/bayesplot/">https://mc-stan.org/bayesplot/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stan-dev/bayesplot/issues/">https://github.com/stan-dev/bayesplot/issues/</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>pandoc (&gt;= 1.12.3), pandoc-citeproc</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.8.0), ggplot2 (&ge; 3.4.0), ggridges (&ge; 0.5.5),
glue, posterior, reshape2, rlang (&ge; 0.3.0), stats, tibble (&ge;
2.0.0), tidyselect, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggfortify, gridExtra (&ge; 2.2.1), hexbin, knitr (&ge; 1.16), loo
(&ge; 2.0.0), RColorBrewer, rmarkdown (&ge; 1.0.0), rstan (&ge;
2.17.1), rstanarm (&ge; 2.17.4), rstantools (&ge; 1.5.0), scales,
shinystan (&ge; 2.3.0), survival, testthat (&ge; 2.0.0), vdiffr (&ge;
1.0.2)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-14 20:46:03 UTC; jgabry</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonah Gabry [aut, cre],
  Tristan Mahr [aut],
  Paul-Christian Bürkner [ctb],
  Martin Modrák [ctb],
  Malcolm Barrett [ctb],
  Frank Weber [ctb],
  Eduardo Coronado Sroka [ctb],
  Teemu Sailynoja [ctb],
  Aki Vehtari [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 05:30:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesplot-package'><strong>bayesplot</strong>: Plotting for Bayesian Models</h2><span id='topic+bayesplot-package'></span><span id='topic+bayesplot'></span>

<h3>Description</h3>


<p><img src="../help/figures/stanlogo.png" width="50" alt="mc-stan.org" />

<em>Stan Development Team</em>
</p>
<p>The <strong>bayesplot</strong> package provides a variety of <strong>ggplot2</strong>-based
plotting functions for use after fitting Bayesian models (typically, though
not exclusively, via Markov chain Monte Carlo). The package is designed not
only to provide convenient functionality for users, but also a common set of
functions that can be easily used by developers working on a variety of
packages for Bayesian modeling, particularly (but not necessarily) packages
powered by RStan (the <span class="rlang"><b>R</b></span> interface to Stan).
Examples of packages that will soon (or already are) using <strong>bayesplot</strong> are
<strong>rstan</strong> itself, as well as the <strong>rstan</strong>-dependent <strong>rstanarm</strong> and
<strong>brms</strong> packages for applied regression modeling.
</p>


<h3>Plotting functionality</h3>


<p><img src="../help/figures/bayesplot1.png" width="30%" alt="mcmc\_areas" />
<img src="../help/figures/bayesplot2.png" width="30%" alt="ppc\_hist" />
<img src="../help/figures/bayesplot3.png" width="30%" alt="ppc\_dens\_overlay" />

</p>
<p>The plotting functions in <strong>bayesplot</strong> are organized into several modules:
</p>

<ul>
<li> <p><a href="#topic+MCMC-overview">MCMC</a>: Visualizations of Markov chain
Monte Carlo (MCMC) simulations generated by <em>any</em> MCMC algorithm
as well as diagnostics. There are also additional functions specifically
for use with models fit using the <a href="#topic+NUTS">No-U-Turn Sampler (NUTS)</a>.
</p>
</li>
<li> <p><a href="#topic+PPC-overview">PPC</a>: Graphical (posterior or prior) predictive
checks (PPCs).
</p>
</li>
<li> <p><a href="#topic+PPD-overview">PPD</a>: Plots of (posterior or prior) predictive
distributions without comparisons to observed data.
</p>
</li></ul>



<h3>Resources</h3>


<ul>
<li> <p><strong>Online documentation and vignettes</strong>: Visit the <strong>bayesplot</strong> website at
<a href="https://mc-stan.org/bayesplot/">https://mc-stan.org/bayesplot/</a>
</p>
</li>
<li> <p><strong>Bug reports and feature requests</strong>: If you would like to request a new
feature or if you have noticed a bug that needs to be fixed please let us
know at the <strong>bayesplot</strong> issue tracker at
<a href="https://github.com/stan-dev/bayesplot/issues/">https://github.com/stan-dev/bayesplot/issues/</a>
</p>
</li>
<li> <p><strong>General questions and help</strong>:
To ask a question about <strong>bayesplot</strong> on the Stan Forums forum please visit
<a href="https://discourse.mc-stan.org">https://discourse.mc-stan.org</a>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jonah Gabry <a href="mailto:jsg2201@columbia.edu">jsg2201@columbia.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Tristan Mahr
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Paul-Christian Bürkner [contributor]
</p>
</li>
<li><p> Martin Modrák [contributor]
</p>
</li>
<li><p> Malcolm Barrett [contributor]
</p>
</li>
<li><p> Frank Weber [contributor]
</p>
</li>
<li><p> Eduardo Coronado Sroka [contributor]
</p>
</li>
<li><p> Teemu Sailynoja [contributor]
</p>
</li>
<li><p> Aki Vehtari [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theme_default">theme_default()</a></code> for the default ggplot theme used by
<strong>bayesplot</strong> and <code><a href="#topic+bayesplot_theme_set">bayesplot_theme_set()</a></code> to change it.
</p>
<p><a href="#topic+bayesplot-colors">bayesplot-colors</a> to set or view the color scheme used
for plotting.
</p>
<p><code><a href="ggplot2.html#topic+ggsave">ggplot2::ggsave()</a></code> for saving plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A few quick examples (all of the functions have many examples
# on their individual help pages)

# MCMC plots
x &lt;- example_mcmc_draws(params = 5)
mcmc_intervals(x, prob = 0.5)
mcmc_intervals(x, regex_pars = "beta")

color_scheme_set("purple")
mcmc_areas(x, regex_pars = "beta", prob = 0.8)

color_scheme_set("mix-blue-red")
mcmc_trace(x, pars = c("alpha", "sigma"),
           facet_args = list(nrow = 2))

color_scheme_set("brightblue")
mcmc_scatter(x, pars = c("beta[1]", "sigma"),
             transformations = list(sigma = "log"))


# Graphical PPCs
y &lt;- example_y_data()
yrep &lt;- example_yrep_draws()
ppc_dens_overlay(y, yrep[1:50, ])

color_scheme_set("pink")
ppc_stat(y, yrep, stat = "median") + grid_lines()
ppc_hist(y, yrep[1:8, ])

# Same plots but without y (using ppd_ instead of ppc_)
bayesplot_theme_set(ggplot2::theme_gray())
ypred &lt;- yrep
ppd_dens_overlay(ypred[1:50, ])
ppd_stat(ypred, stat = "median") + grid_lines()
ppd_hist(ypred[1:8, ])


</code></pre>

<hr>
<h2 id='available_ppc'>Get or view the names of available plotting or data functions</h2><span id='topic+available_ppc'></span><span id='topic+available_ppd'></span><span id='topic+available_mcmc'></span>

<h3>Description</h3>

<p>Get or view the names of available plotting or data functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available_ppc(pattern = NULL, fixed = FALSE, invert = FALSE, plots_only = TRUE)

available_ppd(pattern = NULL, fixed = FALSE, invert = FALSE, plots_only = TRUE)

available_mcmc(
  pattern = NULL,
  fixed = FALSE,
  invert = FALSE,
  plots_only = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="available_ppc_+3A_pattern">pattern</code>, <code id="available_ppc_+3A_fixed">fixed</code>, <code id="available_ppc_+3A_invert">invert</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+grep">base::grep()</a></code>.</p>
</td></tr>
<tr><td><code id="available_ppc_+3A_plots_only">plots_only</code></td>
<td>
<p>If <code>TRUE</code> (the default) only plotting functions are
searched for. If <code>FALSE</code> then functions that return data for plotting
(functions ending in <code style="white-space: pre;">&#8288;_data()&#8288;</code>) are also included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A possibly empty character vector of function names with several
additional attributes (for use by a custom print method). If <code>pattern</code>
is missing then the returned object contains the names of all available
plotting functions in the <a href="#topic+MCMC">MCMC</a>, <a href="#topic+PPC">PPC</a>, or <a href="#topic+PPD">PPD</a> module, depending on
which function is called. If <code>pattern</code> is specified then a subset of
function names is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>available_mcmc()
available_mcmc("nuts")
available_mcmc("rhat|neff")

available_ppc()
available_ppc("grouped")
available_ppc("grouped", invert = TRUE)

available_ppd()
available_ppd("grouped")

# can also see which functions that return data are available
available_ppc(plots_only = FALSE)

# only show the _data functions
available_ppc("_data", plots_only = FALSE)
available_ppd("_data", plots_only = FALSE)
available_mcmc("_data", plots_only = FALSE)

</code></pre>

<hr>
<h2 id='bayesplot_grid'>Arrange plots in a grid</h2><span id='topic+bayesplot_grid'></span>

<h3>Description</h3>

<p>The <code>bayesplot_grid</code> function makes it simple to juxtapose plots using
common <code class="reqn">x</code> and/or <code class="reqn">y</code> axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesplot_grid(
  ...,
  plots = list(),
  xlim = NULL,
  ylim = NULL,
  grid_args = list(),
  titles = character(),
  subtitles = character(),
  legends = TRUE,
  save_gg_objects = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesplot_grid_+3A_...">...</code></td>
<td>
<p>One or more ggplot objects.</p>
</td></tr>
<tr><td><code id="bayesplot_grid_+3A_plots">plots</code></td>
<td>
<p>A list of ggplot objects. Can be used as an alternative to
specifying plot objects via <code>...</code>.</p>
</td></tr>
<tr><td><code id="bayesplot_grid_+3A_xlim">xlim</code>, <code id="bayesplot_grid_+3A_ylim">ylim</code></td>
<td>
<p>Optionally, numeric vectors of length 2 specifying lower and
upper limits for the axes that will be shared across all plots.</p>
</td></tr>
<tr><td><code id="bayesplot_grid_+3A_grid_args">grid_args</code></td>
<td>
<p>An optional named list of arguments to pass to
<code><a href="gridExtra.html#topic+arrangeGrob">gridExtra::arrangeGrob()</a></code> (<code>nrow</code>, <code>ncol</code>,
<code>widths</code>, etc.).</p>
</td></tr>
<tr><td><code id="bayesplot_grid_+3A_titles">titles</code>, <code id="bayesplot_grid_+3A_subtitles">subtitles</code></td>
<td>
<p>Optional character vectors of plot titles and
subtitles. If specified, <code>titles</code> and <code>subtitles</code> must must have
length equal to the number of plots specified.</p>
</td></tr>
<tr><td><code id="bayesplot_grid_+3A_legends">legends</code></td>
<td>
<p>If any of the plots have legends should they be displayed?
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bayesplot_grid_+3A_save_gg_objects">save_gg_objects</code></td>
<td>
<p>If <code>TRUE</code>, the default, then the ggplot objects
specified in <code>...</code> or via the <code>plots</code> argument are saved in a
list in the <code>"bayesplots"</code> component of the returned object.
Setting this to <code>FALSE</code> will make the returned object smaller but
these individual plot objects will not be available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"bayesplot_grid"</code> (essentially a gtable object
from <code><a href="gridExtra.html#topic+arrangeGrob">gridExtra::arrangeGrob()</a></code>), which has a <code>plot</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- example_y_data()
yrep &lt;- example_yrep_draws()
stats &lt;- c("sd", "median", "max", "min")

color_scheme_set("pink")
bayesplot_grid(
 plots = lapply(stats, function(s) ppc_stat(y, yrep, stat = s)),
 titles = stats,
 legends = FALSE,
 grid_args = list(ncol = 1)
)

## Not run: 
library(rstanarm)
mtcars$log_mpg &lt;- log(mtcars$mpg)
fit1 &lt;- stan_glm(mpg ~ wt, data = mtcars, refresh = 0)
fit2 &lt;- stan_glm(log_mpg ~ wt, data = mtcars, refresh = 0)

y &lt;- mtcars$mpg
yrep1 &lt;- posterior_predict(fit1, draws = 50)
yrep2 &lt;- posterior_predict(fit2, fun = exp, draws = 50)

color_scheme_set("blue")
ppc1 &lt;- ppc_dens_overlay(y, yrep1)
ppc1
ppc1 + yaxis_text()

color_scheme_set("red")
ppc2 &lt;- ppc_dens_overlay(y, yrep2)
bayesplot_grid(ppc1, ppc2)

# make sure the plots use the same limits for the axes
bayesplot_grid(ppc1, ppc2, xlim = c(-5, 60), ylim = c(0, 0.2))

# remove the legends and add text
bayesplot_grid(ppc1, ppc2, xlim = c(-5, 60), ylim = c(0, 0.2),
               legends = FALSE, subtitles = rep("Predicted MPG", 2))

## End(Not run)

</code></pre>

<hr>
<h2 id='bayesplot_theme_get'>Get, set, and modify the active <strong>bayesplot</strong> theme</h2><span id='topic+bayesplot_theme_get'></span><span id='topic+bayesplot_theme_set'></span><span id='topic+bayesplot_theme_update'></span><span id='topic+bayesplot_theme_replace'></span>

<h3>Description</h3>

<p>These functions are the <strong>bayesplot</strong> equivalent to
<strong>ggplot2</strong>'s <code><a href="ggplot2.html#topic+theme_get">ggplot2::theme_set()</a></code> and friends. They set, get, and update
the active theme but only apply them to <code>bayesplots</code>. The current/active
theme is automatically applied to every <code>bayesplot</code> you draw.
</p>
<p>Use <code>bayesplot_theme_get()</code> to get the current <strong>bayesplot</strong> theme and
<code>bayesplot_theme_set()</code> to set a new theme. <code>bayesplot_theme_update()</code> and
<code>bayesplot_theme_replace()</code> are shorthands for changing individual elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesplot_theme_get()

bayesplot_theme_set(new = theme_default())

bayesplot_theme_update(...)

bayesplot_theme_replace(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesplot_theme_get_+3A_new">new</code></td>
<td>
<p>The new theme (list of theme elements) to use. This is analogous
to the <code>new</code> argument to <code><a href="ggplot2.html#topic+theme_get">ggplot2::theme_set()</a></code>.</p>
</td></tr>
<tr><td><code id="bayesplot_theme_get_+3A_...">...</code></td>
<td>
<p>A named list of theme settings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bayesplot_theme_set()</code> and friends only apply to <code>bayesplots</code>.
However, <code><a href="ggplot2.html#topic+theme_get">ggplot2::theme_set()</a></code> can also be used to change the
<strong>bayesplot</strong> theme. Currently, setting a theme with <code>ggplot2::theme_set()</code>
(other than the <strong>ggplot2</strong> default <code><a href="ggplot2.html#topic+ggtheme">ggplot2::theme_grey()</a></code>) will override
the <strong>bayesplot</strong> theme.
</p>


<h3>Value</h3>

<p><code>bayesplot_theme_get()</code> returns the current theme. The other three
functions (set, update, replace) invisibly return the <em>previous</em> theme
so it can be saved and easily restored later. This is the same behavior as
the <strong>ggplot2</strong> versions of these functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theme_default">theme_default()</a></code> for the default <strong>bayesplot</strong> theme.
</p>
<p><a href="#topic+bayesplot-helpers">bayesplot-helpers</a> for a variety of convenience functions,
many of which provide shortcuts for tweaking theme elements after creating
a plot.
</p>
<p><a href="#topic+bayesplot-colors">bayesplot-colors</a> to set or view the color scheme used
for plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

# plot using the current value of bayesplot_theme_get()
# (the default is bayesplot::theme_default())
x &lt;- example_mcmc_draws()
mcmc_hist(x)

# change the bayesplot theme to theme_minimal and save the old theme
old &lt;- bayesplot_theme_set(theme_minimal())
mcmc_hist(x)

# change back to the previous theme
bayesplot_theme_set(old)
mcmc_hist(x)

# change the default font size and family for bayesplots
bayesplot_theme_update(text = element_text(size = 16, family = "sans"))
mcmc_hist(x)

# change back to the default
bayesplot_theme_set() # same as bayesplot_theme_set(theme_default())
mcmc_hist(x)

# updating theme elements
color_scheme_set("brightblue")
bayesplot_theme_set(theme_dark())
mcmc_hist(x)

bayesplot_theme_update(panel.background = element_rect(fill = "black"))
mcmc_hist(x)

# to get the same plot without updating the theme we could also have
# used the bayeplot convenience function panel_bg()
bayesplot_theme_set(theme_dark())
mcmc_hist(x) + panel_bg(fill = "black")

# reset
bayesplot_theme_set()

</code></pre>

<hr>
<h2 id='bayesplot-colors'>Set, get, or view <strong>bayesplot</strong> color schemes</h2><span id='topic+bayesplot-colors'></span><span id='topic+color_scheme_set'></span><span id='topic+color_scheme_get'></span><span id='topic+color_scheme_view'></span>

<h3>Description</h3>

<p>Set, get, or view color schemes. Choose from a preset scheme or create a
custom scheme. See the <strong>Available color schemes</strong> section below for a list
of available scheme names. The <strong>Custom color schemes</strong> section describes how
to specify a custom scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_scheme_set(scheme = "blue")

color_scheme_get(scheme = NULL, i = NULL)

color_scheme_view(scheme = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesplot-colors_+3A_scheme">scheme</code></td>
<td>
<p>For <code>color_scheme_set()</code>, either a string naming one of the
available color schemes or a character vector of <em>exactly six</em> colors
specifying a custom scheme.
</p>
<p>For <code>color_scheme_get()</code>, <code>scheme</code> can be missing (to get the
current color scheme) or a string naming one of the preset schemes.
</p>
<p>For <code>color_scheme_view()</code>, <code>scheme</code> can be missing (to use the
current color scheme) or a character vector containing a subset of the
available scheme names.
</p>
<p>See the <strong>Available color schemes</strong> section below for a list of available
scheme names. The <strong>Custom color schemes</strong> section describes how to specify
a custom scheme.</p>
</td></tr>
<tr><td><code id="bayesplot-colors_+3A_i">i</code></td>
<td>
<p>For <code>color_scheme_get()</code>, an optional subset of the integers from <code>1</code>
(lightest) to <code>6</code> (darkest) indicating which of the colors in the
scheme to return. If <code>i</code> is not specified then all six colors in the
scheme are included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>color_scheme_set()</code> has the side effect of setting the color scheme
used for plotting. It also returns (<a href="base.html#topic+invisible">invisibly</a>) a list of
the hexadecimal color values used in <code>scheme</code>.
</p>
<p><code>color_scheme_get()</code> returns a list of the hexadecimal color
values (without changing the current scheme). If the <code>scheme</code> argument
is not specified the returned values correspond to the current color
scheme. If the optional argument <code>i</code> is specified then the returned
list only contains <code>length(i)</code> elements.
</p>
<p><code>color_scheme_view()</code> returns a ggplot object if only a single scheme is
specified and a gtable object if multiple schemes names are specified.
</p>


<h3>Available color schemes</h3>

<p>Currently, the available preset color
schemes are:
</p>

<ul>
<li> <p><code>"blue"</code>, <code>"brightblue"</code>
</p>
</li>
<li> <p><code>"gray"</code>, <code>"darkgray"</code>
</p>
</li>
<li> <p><code>"green"</code>
</p>
</li>
<li> <p><code>"pink"</code>
</p>
</li>
<li> <p><code>"purple"</code>
</p>
</li>
<li> <p><code>"red"</code>
</p>
</li>
<li> <p><code>"teal"</code>
</p>
</li>
<li> <p><code>"yellow"</code>
</p>
</li>
<li> <p><a href="https://CRAN.R-project.org/package=viridis"><code>"viridis"</code></a>, <code>"viridisA"</code>,
<code>"viridisB"</code>, <code>"viridisC"</code>, <code>"viridisD"</code>, <code>"viridisE"</code>
</p>
</li>
<li> <p><code>"mix-x-y"</code>, replacing <code>x</code> and <code>y</code> with any two of
the scheme names listed above (e.g. &quot;mix-teal-pink&quot;, &quot;mix-blue-red&quot;,
etc.). The order of <code>x</code> and <code>y</code> matters, i.e., the color schemes
<code>"mix-blue-red"</code> and <code>"mix-red-blue"</code> are not identical. There is no
guarantee that every possible mixed scheme will look good with every
possible plot.
</p>
</li>
<li> <p><code>"brewer-x"</code>, replacing <code>x</code> with the name of a palette available from
<code><a href="RColorBrewer.html#topic+ColorBrewer">RColorBrewer::brewer.pal()</a></code> (e.g., <code>brewer-PuBuGn</code>).
</p>
</li></ul>

<p>If you have a suggestion for a new color scheme please let us know via the
<strong>bayesplot</strong> <a href="https://github.com/stan-dev/bayesplot/issues">issue tracker</a>.
</p>


<h3>Custom color schemes</h3>

<p>A <strong>bayesplot</strong> color scheme consists of six
colors. To specify a custom color scheme simply pass a character vector
containing either the names of six <a href="grDevices.html#topic+colors">colors</a> or six
hexadecimal color values (or a mix of names and hex values). The colors
should be in order from lightest to darkest. See the end of the
<strong>Examples</strong> section for a demonstration.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theme_default">theme_default()</a></code> for the default ggplot theme used by
<strong>bayesplot</strong> and <code><a href="#topic+bayesplot_theme_set">bayesplot_theme_set()</a></code> to change it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>color_scheme_set("blue")
color_scheme_view()

color_scheme_get()
color_scheme_get(i = c(3, 5)) # 3rd and 5th colors only

color_scheme_get("brightblue")
color_scheme_view("brightblue")

# compare multiple schemes
color_scheme_view(c("pink", "gray", "teal"))
color_scheme_view(c("viridis", "viridisA", "viridisB", "viridisC"))

color_scheme_set("pink")
x &lt;- example_mcmc_draws()
mcmc_intervals(x)

color_scheme_set("teal")
color_scheme_view()
mcmc_intervals(x)

color_scheme_set("red")
mcmc_areas(x, regex_pars = "beta")

color_scheme_set("purple")
color_scheme_view()
y &lt;- example_y_data()
yrep &lt;- example_yrep_draws()
ppc_stat(y, yrep, stat = "mean") + legend_none()

############################
### Mixing color schemes ###
############################
color_scheme_set("mix-teal-pink")
ppc_stat(y, yrep, stat = "sd") + legend_none()
mcmc_areas(x, regex_pars = "beta")

##########################
### ColorBrewer scheme ###
##########################
color_scheme_set("brewer-Spectral")
color_scheme_view()
mcmc_trace(x, pars = "sigma")

###########################
### Custom color scheme ###
###########################
orange_scheme &lt;- c("#ffebcc", "#ffcc80",
                   "#ffad33", "#e68a00",
                   "#995c00", "#663d00")
color_scheme_set(orange_scheme)
color_scheme_view()
mcmc_areas(x, regex_pars = "alpha")
mcmc_dens_overlay(x)
ppc_stat(y, yrep, stat = "var") + legend_none()

</code></pre>

<hr>
<h2 id='bayesplot-extractors'>Extract quantities needed for plotting from model objects</h2><span id='topic+bayesplot-extractors'></span><span id='topic+log_posterior'></span><span id='topic+nuts_params'></span><span id='topic+rhat'></span><span id='topic+neff_ratio'></span><span id='topic+log_posterior.stanfit'></span><span id='topic+log_posterior.stanreg'></span><span id='topic+log_posterior.CmdStanMCMC'></span><span id='topic+nuts_params.stanfit'></span><span id='topic+nuts_params.stanreg'></span><span id='topic+nuts_params.list'></span><span id='topic+nuts_params.CmdStanMCMC'></span><span id='topic+rhat.stanfit'></span><span id='topic+rhat.stanreg'></span><span id='topic+rhat.CmdStanMCMC'></span><span id='topic+neff_ratio.stanfit'></span><span id='topic+neff_ratio.stanreg'></span><span id='topic+neff_ratio.CmdStanMCMC'></span>

<h3>Description</h3>

<p>Generics and methods for extracting quantities needed for plotting from
various types of model objects. Currently methods are provided for stanfit
(<strong>rstan</strong>), CmdStanMCMC (<strong>cmdstanr</strong>), and stanreg (<strong>rstanarm</strong>) objects,
but adding new methods should be relatively straightforward.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_posterior(object, ...)

nuts_params(object, ...)

rhat(object, ...)

neff_ratio(object, ...)

## S3 method for class 'stanfit'
log_posterior(object, inc_warmup = FALSE, ...)

## S3 method for class 'stanreg'
log_posterior(object, inc_warmup = FALSE, ...)

## S3 method for class 'CmdStanMCMC'
log_posterior(object, inc_warmup = FALSE, ...)

## S3 method for class 'stanfit'
nuts_params(object, pars = NULL, inc_warmup = FALSE, ...)

## S3 method for class 'stanreg'
nuts_params(object, pars = NULL, inc_warmup = FALSE, ...)

## S3 method for class 'list'
nuts_params(object, pars = NULL, ...)

## S3 method for class 'CmdStanMCMC'
nuts_params(object, pars = NULL, ...)

## S3 method for class 'stanfit'
rhat(object, pars = NULL, ...)

## S3 method for class 'stanreg'
rhat(object, pars = NULL, regex_pars = NULL, ...)

## S3 method for class 'CmdStanMCMC'
rhat(object, pars = NULL, ...)

## S3 method for class 'stanfit'
neff_ratio(object, pars = NULL, ...)

## S3 method for class 'stanreg'
neff_ratio(object, pars = NULL, regex_pars = NULL, ...)

## S3 method for class 'CmdStanMCMC'
neff_ratio(object, pars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesplot-extractors_+3A_object">object</code></td>
<td>
<p>The object to use.</p>
</td></tr>
<tr><td><code id="bayesplot-extractors_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods.</p>
</td></tr>
<tr><td><code id="bayesplot-extractors_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to include warmup draws, if applicable.</p>
</td></tr>
<tr><td><code id="bayesplot-extractors_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names. For
<code>nuts_params()</code> these will be NUTS sampler parameter names rather than
model parameters. If <code>pars</code> is omitted all parameters are included.</p>
</td></tr>
<tr><td><code id="bayesplot-extractors_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional <a href="base.html#topic+grep">regular expression</a> to use for
parameter selection. Can be specified instead of <code>pars</code> or in addition to
<code>pars</code>. When using <code>pars</code> for tidy parameter selection, the <code>regex_pars</code>
argument is ignored since <a href="tidyselect.html#topic+language">select helpers</a>
perform a similar function.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>log_posterior()</code></dt><dd>
<p><code>log_posterior()</code> methods return a molten data frame (see <code><a href="reshape2.html#topic+melt">reshape2::melt()</a></code>).
The data frame should have columns <code>"Iteration"</code> (integer), <code>"Chain"</code>
(integer), and <code>"Value"</code> (numeric). See <strong>Examples</strong>, below.
</p>
</dd>
<dt><code>nuts_params()</code></dt><dd>
<p><code>nuts_params()</code> methods return a molten data frame (see <code><a href="reshape2.html#topic+melt">reshape2::melt()</a></code>).
The data frame should have columns <code>"Parameter"</code> (factor), <code>"Iteration"</code>
(integer), <code>"Chain"</code> (integer), and <code>"Value"</code> (numeric). See <strong>Examples</strong>, below.
</p>
</dd>
<dt><code>rhat()</code>, <code>neff_ratio()</code></dt><dd>
<p>Methods return (named) vectors.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+MCMC-nuts">MCMC-nuts</a>, <a href="#topic+MCMC-diagnostics">MCMC-diagnostics</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rstanarm)
fit &lt;- stan_glm(mpg ~ wt, data = mtcars, refresh = 0)

np &lt;- nuts_params(fit)
head(np)
tail(np)

lp &lt;- log_posterior(fit)
head(lp)
tail(lp)

## End(Not run)

</code></pre>

<hr>
<h2 id='bayesplot-helpers'>Convenience functions for adding or changing plot details</h2><span id='topic+bayesplot-helpers'></span><span id='topic+vline_at'></span><span id='topic+hline_at'></span><span id='topic+vline_0'></span><span id='topic+hline_0'></span><span id='topic+abline_01'></span><span id='topic+lbub'></span><span id='topic+legend_move'></span><span id='topic+legend_none'></span><span id='topic+legend_text'></span><span id='topic+xaxis_title'></span><span id='topic+xaxis_text'></span><span id='topic+xaxis_ticks'></span><span id='topic+yaxis_title'></span><span id='topic+yaxis_text'></span><span id='topic+yaxis_ticks'></span><span id='topic+facet_text'></span><span id='topic+facet_bg'></span><span id='topic+panel_bg'></span><span id='topic+plot_bg'></span><span id='topic+grid_lines'></span><span id='topic+overlay_function'></span>

<h3>Description</h3>

<p>Convenience functions for adding to (and changing details of) ggplot objects
(many of the objects returned by <strong>bayesplot</strong> functions). See the
<strong>Examples</strong> section, below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vline_at(v, fun, ..., na.rm = TRUE)

hline_at(v, fun, ..., na.rm = TRUE)

vline_0(..., na.rm = TRUE)

hline_0(..., na.rm = TRUE)

abline_01(..., na.rm = TRUE)

lbub(p, med = TRUE)

legend_move(position = "right")

legend_none()

legend_text(...)

xaxis_title(on = TRUE, ...)

xaxis_text(on = TRUE, ...)

xaxis_ticks(on = TRUE, ...)

yaxis_title(on = TRUE, ...)

yaxis_text(on = TRUE, ...)

yaxis_ticks(on = TRUE, ...)

facet_text(on = TRUE, ...)

facet_bg(on = TRUE, ...)

panel_bg(on = TRUE, ...)

plot_bg(on = TRUE, ...)

grid_lines(color = "gray50", size = 0.2)

overlay_function(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesplot-helpers_+3A_v">v</code></td>
<td>
<p>Either a numeric vector specifying the value(s) at which to
draw the vertical or horizontal line(s), or an object of any type to use as
the first argument to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="bayesplot-helpers_+3A_fun">fun</code></td>
<td>
<p>A function, or the name of a function, that returns a numeric
vector.</p>
</td></tr>
<tr><td><code id="bayesplot-helpers_+3A_...">...</code></td>
<td>
<p>For the various <code>vline_</code>, <code>hline_</code>, and <code>abline_</code>
functions, <code>...</code> is passed to <code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_vline()</a></code>,
<code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_hline()</a></code>, and <code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_abline()</a></code>,
respectively, to control the appearance of the line(s).
</p>
<p>For functions ending in <code style="white-space: pre;">&#8288;_bg&#8288;</code>, <code>...</code> is passed to
<code><a href="ggplot2.html#topic+element">ggplot2::element_rect()</a></code>.
</p>
<p>For functions ending in <code style="white-space: pre;">&#8288;_text&#8288;</code> or <code style="white-space: pre;">&#8288;_title&#8288;</code>, <code>...</code> is passed
to <code><a href="ggplot2.html#topic+element">ggplot2::element_text()</a></code>.
</p>
<p>For <code>xaxis_ticks</code> and <code>yaxis_ticks</code>, <code>...</code> is passed to
<code><a href="ggplot2.html#topic+element">ggplot2::element_line()</a></code>.
</p>
<p>For <code>overlay_function</code>, <code>...</code> is passed to
<code><a href="ggplot2.html#topic+geom_function">ggplot2::stat_function()</a></code>.</p>
</td></tr>
<tr><td><code id="bayesplot-helpers_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical scalar passed to the appropriate geom (e.g.
<code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_vline()</a></code>). The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bayesplot-helpers_+3A_p">p</code></td>
<td>
<p>The probability mass (in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>) to include in the interval.</p>
</td></tr>
<tr><td><code id="bayesplot-helpers_+3A_med">med</code></td>
<td>
<p>Should the median also be included in addition to the lower
and upper bounds of the interval?</p>
</td></tr>
<tr><td><code id="bayesplot-helpers_+3A_position">position</code></td>
<td>
<p>The position of the legend. Either a numeric vector (of
length 2) giving the relative coordinates (between 0 and 1) for the legend,
or a string among <code>"right"</code>, <code>"left"</code>, <code>"top"</code>,
<code>"bottom"</code>. Using <code>position = "none"</code> is also allowed and is
equivalent to using <code>legend_none()</code>.</p>
</td></tr>
<tr><td><code id="bayesplot-helpers_+3A_on">on</code></td>
<td>
<p>For functions modifying ggplot <a href="ggplot2.html#topic+theme">theme</a> elements,
set <code>on=FALSE</code> to set the element to <code><a href="ggplot2.html#topic+element">ggplot2::element_blank()</a></code>. For
example, facet text can be removed by adding <code>facet_text(on=FALSE)</code>, or
simply <code>facet_text(FALSE)</code> to a ggplot object. If <code>on=TRUE</code> (the default),
then <code>...</code> can be used to customize the appearance of the theme element.</p>
</td></tr>
<tr><td><code id="bayesplot-helpers_+3A_color">color</code>, <code id="bayesplot-helpers_+3A_size">size</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+element">ggplot2::element_line()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Add vertical, horizontal, and diagonal lines to plots</h4>


<ul>
<li> <p><code>vline_at()</code> and <code>hline_at()</code> return an object created by either
<code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_vline()</a></code> or <code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_hline()</a></code> that can be added to a
ggplot object to draw a vertical or horizontal line (at one or several
values). If <code>fun</code> is missing then the lines are drawn at the values in <code>v</code>.
If <code>fun</code> is specified then the lines are drawn at the values returned by <code>fun(v)</code>.
</p>
</li>
<li> <p><code>vline_0()</code> and <code>hline_0()</code> are wrappers for <code>vline_at()</code> and <code>hline_at()</code>
with <code>v = 0</code> and <code>fun</code> missing.
</p>
</li>
<li> <p><code>abline_01()</code> is a wrapper for <code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_abline()</a></code> with the intercept
set to <code>0</code> and the slope set to <code>1</code>.
</p>
</li>
<li> <p><code>lbub()</code> returns a <em>function</em> that takes a single argument <code>x</code> and returns
the lower and upper bounds (<code>lb</code>, <code>ub</code>) of the <code>100*p</code>\
of <code>x</code>, as well as the median (if <code>med=TRUE</code>).
</p>
</li></ul>




<h4>Control appearance of facet strips</h4>


<ul>
<li> <p><code>facet_text()</code> returns ggplot2 theme objects that can be added to an
existing plot (ggplot object) to format the text in facet strips.
</p>
</li>
<li> <p><code>facet_bg()</code> can be added to a plot to change the background of the facet strips.
</p>
</li></ul>




<h4>Move legend, remove legend, or style the legend text</h4>


<ul>
<li> <p><code>legend_move()</code> and <code>legend_none()</code> return a ggplot2 theme object that can
be added to an existing plot (ggplot object) in order to change the
position of the legend or remove it.
</p>
</li>
<li> <p><code>legend_text()</code> works much like <code>facet_text()</code> but for the legend.
</p>
</li></ul>




<h4>Control appearance of <code class="reqn">x</code>-axis and <code class="reqn">y</code>-axis features</h4>


<ul>
<li> <p><code>xaxis_title()</code> and <code>yaxis_title()</code> return a ggplot2 theme object
that can be added to an existing plot (ggplot object) in order to toggle or
format the titles displayed on the <code>x</code> or <code>y</code> axis. (To change
the titles themselves use <code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.)
</p>
</li>
<li> <p><code>xaxis_text()</code> and <code>yaxis_text()</code> return a ggplot2 theme object
that can be added to an existing plot (ggplot object) in order to toggle or
format the text displayed on the <code>x</code> or <code>y</code> axis (e.g. tick
labels).
</p>
</li>
<li> <p><code>xaxis_ticks()</code> and <code>yaxis_ticks()</code> return a ggplot2 theme object
that can be added to an existing plot (ggplot object) to change the
appearance of the axis tick marks.
</p>
</li></ul>




<h4>Customize plot background</h4>


<ul>
<li> <p><code>plot_bg()</code> returns a ggplot2 theme object that can be added to an
existing plot (ggplot object) to format the background of the <em>entire</em> plot.
</p>
</li>
<li> <p><code>panel_bg()</code> returns a ggplot2 theme object that can be added to an
existing plot (ggplot object) to format the background of the just the
plotting area.
</p>
</li>
<li> <p><code>grid_lines()</code> returns a ggplot2 theme object that can be added to
an existing plot (ggplot object) to add grid lines to the plot background.
</p>
</li></ul>




<h4>Superimpose a function on an existing plot</h4>


<ul>
<li> <p><code>overlay_function()</code> is a simple wrapper for <code><a href="ggplot2.html#topic+geom_function">ggplot2::stat_function()</a></code> but
with the <code>inherit.aes</code> argument fixed to <code>FALSE</code>. Fixing <code>inherit.aes=FALSE</code>
will avoid potential errors due to the <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>thetic mapping used by
certain <strong>bayesplot</strong> plotting functions.
</p>
</li></ul>




<h3>Value</h3>

<p>A <strong>ggplot2</strong> layer or <code><a href="ggplot2.html#topic+theme">ggplot2::theme()</a></code> object that can be
added to existing ggplot objects, like those created by many of the
<strong>bayesplot</strong> plotting functions. See the <strong>Details</strong> section.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theme_default">theme_default()</a></code> for the default ggplot theme used by
<strong>bayesplot</strong>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>color_scheme_set("gray")
x &lt;- example_mcmc_draws(chains = 1)
dim(x)
colnames(x)


###################################
### vertical &amp; horizontal lines ###
###################################
(p &lt;- mcmc_intervals(x, regex_pars = "beta"))

# vertical line at zero (with some optional styling)
p + vline_0()
p + vline_0(linewidth = 0.25, color = "darkgray", linetype = 2)

# vertical line(s) at specified values
v &lt;- c(-0.5, 0, 0.5)
p + vline_at(v, linetype = 3, linewidth = 0.25)

my_lines &lt;- vline_at(v, alpha = 0.25, linewidth = 0.75 * c(1, 2, 1),
                     color = c("maroon", "skyblue", "violet"))
p + my_lines


# add vertical line(s) at computed values
# (three ways of getting lines at column means)
color_scheme_set("brightblue")
p &lt;- mcmc_intervals(x, regex_pars = "beta")
p + vline_at(x[, 3:4], colMeans)
p + vline_at(x[, 3:4], "colMeans", color = "darkgray",
             lty = 2, linewidth = 0.25)
p + vline_at(x[, 3:4], function(a) apply(a, 2, mean),
             color = "orange",
             linewidth = 2, alpha = 0.1)


# using the lbub function to get interval lower and upper bounds (lb, ub)
color_scheme_set("pink")
parsed &lt;- ggplot2::label_parsed
p2 &lt;- mcmc_hist(x, pars = "beta[1]", binwidth = 1/20,
                facet_args = list(labeller = parsed))
(p2 &lt;- p2 + facet_text(size = 16))

b1 &lt;- x[, "beta[1]"]
p2 + vline_at(b1, fun = lbub(0.8), color = "gray20",
              linewidth = 2 * c(1,.5,1), alpha = 0.75)
p2 + vline_at(b1, lbub(0.8, med = FALSE), color = "gray20",
              linewidth = 2, alpha = 0.75)


##########################
### format axis titles ###
##########################
color_scheme_set("green")
y &lt;- example_y_data()
yrep &lt;- example_yrep_draws()
(p3 &lt;- ppc_stat(y, yrep, stat = "median", binwidth = 1/4))

# turn off the legend, turn on x-axis title
p3 +
 legend_none() +
 xaxis_title(size = 13, family = "sans") +
 ggplot2::xlab(expression(italic(T(y)) == median(italic(y))))


################################
### format axis &amp; facet text ###
################################
color_scheme_set("gray")
p4 &lt;- mcmc_trace(example_mcmc_draws(), pars = c("alpha", "sigma"))

myfacets &lt;-
 facet_bg(fill = "gray30", color = NA) +
 facet_text(face = "bold", color = "skyblue", size = 14)
p4 + myfacets


##########################
### control tick marks ###
##########################
p4 +
 myfacets +
 yaxis_text(FALSE) +
 yaxis_ticks(FALSE) +
 xaxis_ticks(linewidth = 1, color = "skyblue")


##############################
### change plot background ###
##############################
color_scheme_set("blue")

# add grid lines
ppc_stat(y, yrep) + grid_lines()

# panel_bg vs plot_bg
ppc_scatter_avg(y, yrep) + panel_bg(fill = "gray90")
ppc_scatter_avg(y, yrep) + plot_bg(fill = "gray90")

color_scheme_set("yellow")
p5 &lt;- ppc_scatter_avg(y, yrep, alpha = 1)
p5 + panel_bg(fill = "gray20") + grid_lines(color = "white")

color_scheme_set("purple")
ppc_dens_overlay(y, yrep[1:30, ]) +
 legend_text(size = 14) +
 legend_move(c(0.75, 0.5)) +
 plot_bg(fill = "gray90") +
 panel_bg(color = "black", fill = "gray99", linewidth = 3)



###############################################
### superimpose a function on existing plot ###
###############################################
# compare posterior of beta[1] to Gaussian with same posterior mean
# and sd as beta[1]
x &lt;- example_mcmc_draws(chains = 4)
dim(x)
purple_gaussian &lt;-
  overlay_function(
    fun = dnorm,
    args = list(mean(x[,, "beta[1]"]), sd(x[,, "beta[1]"])),
    color = "purple",
    linewidth = 2
  )

color_scheme_set("gray")
mcmc_hist(x, pars = "beta[1]", freq = FALSE) + purple_gaussian

mcmc_dens(x, pars = "beta[1]") + purple_gaussian


</code></pre>

<hr>
<h2 id='example-data'>Example draws to use in demonstrations and tests</h2><span id='topic+example-data'></span><span id='topic+example_mcmc_draws'></span><span id='topic+example_yrep_draws'></span><span id='topic+example_y_data'></span><span id='topic+example_x_data'></span><span id='topic+example_group_data'></span>

<h3>Description</h3>

<p>These functions return various objects containing data used in the examples
throughout the <strong>bayesplot</strong> package documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_mcmc_draws(chains = 4, params = 4)

example_yrep_draws()

example_y_data()

example_x_data()

example_group_data()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="example-data_+3A_chains">chains</code></td>
<td>
<p>An integer between 1 and 4 indicating the desired number of
chains.</p>
</td></tr>
<tr><td><code id="example-data_+3A_params">params</code></td>
<td>
<p>An integer between 1 and 6 indicating the desired number of
parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of these functions returns an object containing data, parameter draws, or
predictions corresponding to a basic linear regression model with data
<code>y</code> (outcome vector) and <code>X</code> (predictor matrix), and parameters
<code>alpha</code> (intercept), <code>beta</code> (coefficient vector), and <code>sigma</code>
(error sd).
</p>

<dl>
<dt><code>example_mcmc_draws()</code></dt><dd>
<p>If <code>chains &gt; 1</code>, a <code>250</code> (iterations) by <code>chains</code> by
<code>params</code> array or, if <code>chains = 1</code>, a <code>250</code> by <code>params</code>
matrix of MCMC draws from the posterior distribution of the parameters in
the linear regression model described above. If <code>params = 1</code> then only
the draws for <code>alpha</code> are included in the returned object. If
<code>params &gt;= 2</code> then draws for <code>sigma</code> are also included. And if
<code>params</code> is between <code>3</code> and the maximum of <code>6</code> then draws
for regression coefficients <code>beta[k]</code> (<code>k</code> in <code>1:(params-2)</code>)
are also included.
</p>
</dd>
<dt><code>example_y_data()</code></dt><dd>
<p>A numeric vector with <code>434</code> observations of the outcome variable in the
linear regression model.
</p>
</dd>
<dt><code>example_x_data()</code></dt><dd>
<p>A numeric vector with <code>434</code> observations of one of the predictor
variables in the linear regression model.
</p>
</dd>
<dt><code>example_group_data()</code></dt><dd>
<p>A factor variable with <code>434</code> observations of a grouping variable with
two levels.
</p>
</dd>
<dt><code>example_yrep_draws()</code></dt><dd>
<p>A <code>500</code> (draws) by <code>434</code> (data points) matrix of draws from the
posterior predictive distribution. Each row represents a full dataset drawn
from the posterior predictive distribution of the outcome <code>y</code> after
fitting the linear regression model mentioned above.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>See <strong>Details</strong>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>draws &lt;- example_mcmc_draws()
dim(draws)
dimnames(draws)

draws &lt;- example_mcmc_draws(1, 2)
dim(draws)
colnames(draws)

draws &lt;- example_mcmc_draws(params = 6)
dimnames(draws)[[3]]

y &lt;- example_y_data()
x &lt;- example_x_data()
group &lt;- example_group_data()
length(y)
length(x)
length(group)
tail(data.frame(y, x, group), 5)

yrep &lt;- example_yrep_draws()
dim(yrep) # ncol(yrep) = length(y) = length(x) = length(group)

</code></pre>

<hr>
<h2 id='MCMC-combos'>Combination plots</h2><span id='topic+MCMC-combos'></span><span id='topic+mcmc_combo'></span>

<h3>Description</h3>

<p>Combination plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_combo(x, combo = c("dens", "trace"), ..., widths = NULL, gg_theme = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMC-combos_+3A_x">x</code></td>
<td>
<p>An object containing MCMC draws:
</p>

<ul>
<li><p> A 3-D array, matrix, list of matrices, or data frame. The <a href="#topic+MCMC-overview">MCMC-overview</a>
page provides details on how to specify each these.
</p>
</li>
<li><p> A <code>draws</code> object from the <span class="pkg"><a href="posterior.html#topic+posterior">posterior</a></span> package (e.g.,
<code>draws_array</code>, <code>draws_rvars</code>, etc.).
</p>
</li>
<li><p> An object with an <code>as.array()</code> method that returns the same kind of 3-D
array described on the <a href="#topic+MCMC-overview">MCMC-overview</a> page.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MCMC-combos_+3A_combo">combo</code></td>
<td>
<p>A character vector with at least two elements. Each element of
<code>combo</code> corresponds to a column in the resulting graphic and should be the
name of one of the available <a href="#topic+MCMC-overview">MCMC</a> functions (omitting the
<code>mcmc_</code> prefix).</p>
</td></tr>
<tr><td><code id="MCMC-combos_+3A_...">...</code></td>
<td>
<p>Arguments passed to the plotting functions named in <code>combo</code>.</p>
</td></tr>
<tr><td><code id="MCMC-combos_+3A_widths">widths</code></td>
<td>
<p>A numeric vector the same length as <code>combo</code> specifying
relative column widths. For example, if the plot has two columns, then
<code>widths = c(2, 1)</code> will allocate more space for the first column by a
factor of 2 (as would <code>widths = c(.3, .15)</code>, etc.). The default,
<code>NULL</code>, allocates the same horizontal space for each column.</p>
</td></tr>
<tr><td><code id="MCMC-combos_+3A_gg_theme">gg_theme</code></td>
<td>
<p>Unlike most of the other <strong>bayesplot</strong> functions,
<code>mcmc_combo</code> returns a gtable object rather than a ggplot object, and
so theme objects can't be added directly to the returned plot object. The
<code>gg_theme</code> argument helps get around this problem by accepting a
<strong>ggplot2</strong> <a href="ggplot2.html#topic+theme">theme</a> object that is added to each of the
plots <em>before</em> combining them into the gtable object that is returned.
This can be a theme object created by a call to <code><a href="ggplot2.html#topic+theme">ggplot2::theme()</a></code> or
one of the <strong>bayesplot</strong> convenience functions, e.g.
<code><a href="#topic+legend_none">legend_none()</a></code> (see the <strong>Examples</strong> section, below).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gtable object (the result of calling
<code><a href="gridExtra.html#topic+arrangeGrob">gridExtra::arrangeGrob()</a></code>) with <code>length(combo)</code> columns and
a row for each parameter.
</p>


<h3>See Also</h3>

<p>Other MCMC: 
<code><a href="#topic+MCMC-diagnostics">MCMC-diagnostics</a></code>,
<code><a href="#topic+MCMC-distributions">MCMC-distributions</a></code>,
<code><a href="#topic+MCMC-intervals">MCMC-intervals</a></code>,
<code><a href="#topic+MCMC-nuts">MCMC-nuts</a></code>,
<code><a href="#topic+MCMC-overview">MCMC-overview</a></code>,
<code><a href="#topic+MCMC-parcoord">MCMC-parcoord</a></code>,
<code><a href="#topic+MCMC-recover">MCMC-recover</a></code>,
<code><a href="#topic+MCMC-scatterplots">MCMC-scatterplots</a></code>,
<code><a href="#topic+MCMC-traces">MCMC-traces</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some parameter draws to use for demonstration
x &lt;- example_mcmc_draws()
dim(x)
dimnames(x)

mcmc_combo(x, pars = c("alpha", "sigma"))
mcmc_combo(x, pars = c("alpha", "sigma"), widths = c(1, 2))


# change second plot, show log(sigma) instead of sigma,
# and remove the legends
color_scheme_set("mix-blue-red")
mcmc_combo(
 x,
 combo = c("dens_overlay", "trace"),
 pars = c("alpha", "sigma"),
 transformations = list(sigma = "log"),
 gg_theme = legend_none()
)

# same thing but this time also change the entire ggplot theme
mcmc_combo(
 x,
 combo = c("dens_overlay", "trace"),
 pars = c("alpha", "sigma"),
 transformations = list(sigma = "log"),
 gg_theme = ggplot2::theme_gray() + legend_none()
)


</code></pre>

<hr>
<h2 id='MCMC-diagnostics'>General MCMC diagnostics</h2><span id='topic+MCMC-diagnostics'></span><span id='topic+mcmc_rhat'></span><span id='topic+mcmc_rhat_hist'></span><span id='topic+mcmc_rhat_data'></span><span id='topic+mcmc_neff'></span><span id='topic+mcmc_neff_hist'></span><span id='topic+mcmc_neff_data'></span><span id='topic+mcmc_acf'></span><span id='topic+mcmc_acf_bar'></span>

<h3>Description</h3>

<p>Plots of Rhat statistics, ratios of effective sample size to total sample
size, and autocorrelation of MCMC draws. See the <strong>Plot Descriptions</strong>
section, below, for details. For models fit using the No-U-Turn-Sampler, see
also <a href="#topic+MCMC-nuts">MCMC-nuts</a> for additional MCMC diagnostic plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_rhat(rhat, ..., size = NULL)

mcmc_rhat_hist(rhat, ..., binwidth = NULL, bins = NULL, breaks = NULL)

mcmc_rhat_data(rhat, ...)

mcmc_neff(ratio, ..., size = NULL)

mcmc_neff_hist(ratio, ..., binwidth = NULL, bins = NULL, breaks = NULL)

mcmc_neff_data(ratio, ...)

mcmc_acf(
  x,
  pars = character(),
  regex_pars = character(),
  ...,
  facet_args = list(),
  lags = 20,
  size = NULL
)

mcmc_acf_bar(
  x,
  pars = character(),
  regex_pars = character(),
  ...,
  facet_args = list(),
  lags = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMC-diagnostics_+3A_rhat">rhat</code></td>
<td>
<p>A vector of R-hat estimates.</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_size">size</code></td>
<td>
<p>Optional values to override <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>'s
default size (for <code>mcmc_rhat()</code>, <code>mcmc_neff()</code>) or
<code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>'s default line width (for <code>mcmc_acf()</code>).</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_binwidth">binwidth</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_bins">bins</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> as an
alternative to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_ratio">ratio</code></td>
<td>
<p>A vector of <em>ratios</em> of effective sample size estimates to
total sample size. See <code><a href="#topic+neff_ratio">neff_ratio()</a></code>.</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_x">x</code></td>
<td>
<p>An object containing MCMC draws:
</p>

<ul>
<li><p> A 3-D array, matrix, list of matrices, or data frame. The <a href="#topic+MCMC-overview">MCMC-overview</a>
page provides details on how to specify each these.
</p>
</li>
<li><p> A <code>draws</code> object from the <span class="pkg"><a href="posterior.html#topic+posterior">posterior</a></span> package (e.g.,
<code>draws_array</code>, <code>draws_rvars</code>, etc.).
</p>
</li>
<li><p> An object with an <code>as.array()</code> method that returns the same kind of 3-D
array described on the <a href="#topic+MCMC-overview">MCMC-overview</a> page.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names. If neither
<code>pars</code> nor <code>regex_pars</code> is specified then the default is to use <em>all</em>
parameters. As of version <code style="white-space: pre;">&#8288;1.7.0&#8288;</code>, <strong>bayesplot</strong> also supports 'tidy'
parameter selection by specifying <code>pars = vars(...)</code>, where <code>...</code> is
specified the same way as in <a href="dplyr.html#topic+select">dplyr::select(...)</a> and
similar functions. Examples of using <code>pars</code> in this way can be found on the
<a href="#topic+tidy-params">Tidy parameter selection</a> page.</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional <a href="base.html#topic+grep">regular expression</a> to use for
parameter selection. Can be specified instead of <code>pars</code> or in addition to
<code>pars</code>. When using <code>pars</code> for tidy parameter selection, the <code>regex_pars</code>
argument is ignored since <a href="tidyselect.html#topic+language">select helpers</a>
perform a similar function.</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_facet_args">facet_args</code></td>
<td>
<p>A named list of arguments (other than <code>facets</code>) passed
to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> or <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>
to control faceting. Note: if <code>scales</code> is not included in <code>facet_args</code>
then <strong>bayesplot</strong> may use <code>scales="free"</code> as the default (depending
on the plot) instead of the <strong>ggplot2</strong> default of <code>scales="fixed"</code>.</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_lags">lags</code></td>
<td>
<p>The number of lags to show in the autocorrelation plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">&#8288;_data()&#8288;</code> return the data that would have been drawn by the plotting
function.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>mcmc_rhat()</code>, <code>mcmc_rhat_hist()</code></dt><dd>
<p>Rhat values as either points or a histogram. Values are colored using
different shades (lighter is better). The chosen thresholds are somewhat
arbitrary, but can be useful guidelines in practice.
</p>

<ul>
<li> <p><em>light</em>: below 1.05 (good)
</p>
</li>
<li> <p><em>mid</em>: between 1.05 and 1.1 (ok)
</p>
</li>
<li> <p><em>dark</em>: above 1.1 (too high)
</p>
</li></ul>

</dd>
<dt><code>mcmc_neff()</code>, <code>mcmc_neff_hist()</code></dt><dd>
<p>Ratios of effective sample size to total sample size as either points or a
histogram. Values are colored using different shades (lighter is better).
The chosen thresholds are somewhat arbitrary, but can be useful guidelines
in practice.
</p>

<ul>
<li> <p><em>light</em>: between 0.5 and 1 (high)
</p>
</li>
<li> <p><em>mid</em>: between 0.1 and 0.5 (good)
</p>
</li>
<li> <p><em>dark</em>: below 0.1 (low)
</p>
</li></ul>

</dd>
<dt><code>mcmc_acf()</code>, <code>mcmc_acf_bar()</code></dt><dd>
<p>Grid of autocorrelation plots by chain and parameter. The <code>lags</code> argument
gives the maximum number of lags at which to calculate the autocorrelation
function. <code>mcmc_acf()</code> is a line plot whereas <code>mcmc_acf_bar()</code> is a
barplot.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Stan Development Team.
<em>Stan Modeling Language Users Guide and Reference Manual.</em>
<a href="https://mc-stan.org/users/documentation/">https://mc-stan.org/users/documentation/</a>
</p>
<p>Gelman, A. and Rubin, D. B. (1992). Inference from iterative
simulation using multiple sequences. <em>Statistical Science</em>. 7(4),
457&ndash;472.
</p>


<h3>See Also</h3>


<ul>
<li><p> The <a href="https://mc-stan.org/bayesplot/articles/visual-mcmc-diagnostics.html">Visual MCMC Diagnostics</a>
vignette.
</p>
</li>
<li> <p><a href="#topic+MCMC-nuts">MCMC-nuts</a> for additional MCMC diagnostic plots for models fit
using the No-U-Turn-Sampler.
</p>
</li></ul>

<p>Other MCMC: 
<code><a href="#topic+MCMC-combos">MCMC-combos</a></code>,
<code><a href="#topic+MCMC-distributions">MCMC-distributions</a></code>,
<code><a href="#topic+MCMC-intervals">MCMC-intervals</a></code>,
<code><a href="#topic+MCMC-nuts">MCMC-nuts</a></code>,
<code><a href="#topic+MCMC-overview">MCMC-overview</a></code>,
<code><a href="#topic+MCMC-parcoord">MCMC-parcoord</a></code>,
<code><a href="#topic+MCMC-recover">MCMC-recover</a></code>,
<code><a href="#topic+MCMC-scatterplots">MCMC-scatterplots</a></code>,
<code><a href="#topic+MCMC-traces">MCMC-traces</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># autocorrelation
x &lt;- example_mcmc_draws()
dim(x)
dimnames(x)

color_scheme_set("green")
mcmc_acf(x, pars = c("alpha", "beta[1]"))

color_scheme_set("pink")
(p &lt;- mcmc_acf_bar(x, pars = c("alpha", "beta[1]")))

# add horiztonal dashed line at 0.5
p + hline_at(0.5, linetype = 2, size = 0.15, color = "gray")


# fake rhat values to use for demonstration
rhat &lt;- c(runif(100, 1, 1.15))
mcmc_rhat_hist(rhat)
mcmc_rhat(rhat)

# lollipops
color_scheme_set("purple")
mcmc_rhat(rhat[1:10], size = 5)

color_scheme_set("blue")
mcmc_rhat(runif(1000, 1, 1.07))
mcmc_rhat(runif(1000, 1, 1.3)) + legend_move("top") # add legend above plot

# fake neff ratio values to use for demonstration
ratio &lt;- c(runif(100, 0, 1))
mcmc_neff_hist(ratio)
mcmc_neff(ratio)

## Not run: 
# Example using rstanarm model (requires rstanarm package)
library(rstanarm)

# intentionally use small 'iter' so there are some
# problems with rhat and neff for demonstration
fit &lt;- stan_glm(mpg ~ ., data = mtcars, iter = 50, refresh = 0)
rhats &lt;- rhat(fit)
ratios &lt;- neff_ratio(fit)
mcmc_rhat(rhats)
mcmc_neff(ratios, size = 3)

# there's a small enough number of parameters in the
# model that we can display their names on the y-axis
mcmc_neff(ratios) + yaxis_text(hjust = 1)

# can also look at autocorrelation
draws &lt;- as.array(fit)
mcmc_acf(draws, pars = c("wt", "cyl"), lags = 10)

# increase number of iterations and plots look much better
fit2 &lt;- update(fit, iter = 500)
mcmc_rhat(rhat(fit2))
mcmc_neff(neff_ratio(fit2))
mcmc_acf(as.array(fit2), pars = c("wt", "cyl"), lags = 10)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMC-distributions'>Histograms and kernel density plots of MCMC draws</h2><span id='topic+MCMC-distributions'></span><span id='topic+mcmc_hist'></span><span id='topic+mcmc_dens'></span><span id='topic+mcmc_hist_by_chain'></span><span id='topic+mcmc_dens_overlay'></span><span id='topic+mcmc_dens_chains'></span><span id='topic+mcmc_dens_chains_data'></span><span id='topic+mcmc_violin'></span>

<h3>Description</h3>

<p>Various types of histograms and kernel density plots of MCMC draws. See the
<strong>Plot Descriptions</strong> section, below, for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_hist(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  facet_args = list(),
  binwidth = NULL,
  bins = NULL,
  breaks = NULL,
  freq = TRUE,
  alpha = 1
)

mcmc_dens(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  facet_args = list(),
  trim = FALSE,
  bw = NULL,
  adjust = NULL,
  kernel = NULL,
  n_dens = NULL,
  alpha = 1
)

mcmc_hist_by_chain(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  facet_args = list(),
  binwidth = NULL,
  bins = NULL,
  freq = TRUE,
  alpha = 1
)

mcmc_dens_overlay(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  facet_args = list(),
  color_chains = TRUE,
  trim = FALSE,
  bw = NULL,
  adjust = NULL,
  kernel = NULL,
  n_dens = NULL
)

mcmc_dens_chains(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  color_chains = TRUE,
  bw = NULL,
  adjust = NULL,
  kernel = NULL,
  n_dens = NULL
)

mcmc_dens_chains_data(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  bw = NULL,
  adjust = NULL,
  kernel = NULL,
  n_dens = NULL
)

mcmc_violin(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  facet_args = list(),
  probs = c(0.1, 0.5, 0.9)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMC-distributions_+3A_x">x</code></td>
<td>
<p>An object containing MCMC draws:
</p>

<ul>
<li><p> A 3-D array, matrix, list of matrices, or data frame. The <a href="#topic+MCMC-overview">MCMC-overview</a>
page provides details on how to specify each these.
</p>
</li>
<li><p> A <code>draws</code> object from the <span class="pkg"><a href="posterior.html#topic+posterior">posterior</a></span> package (e.g.,
<code>draws_array</code>, <code>draws_rvars</code>, etc.).
</p>
</li>
<li><p> An object with an <code>as.array()</code> method that returns the same kind of 3-D
array described on the <a href="#topic+MCMC-overview">MCMC-overview</a> page.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names. If neither
<code>pars</code> nor <code>regex_pars</code> is specified then the default is to use <em>all</em>
parameters. As of version <code style="white-space: pre;">&#8288;1.7.0&#8288;</code>, <strong>bayesplot</strong> also supports 'tidy'
parameter selection by specifying <code>pars = vars(...)</code>, where <code>...</code> is
specified the same way as in <a href="dplyr.html#topic+select">dplyr::select(...)</a> and
similar functions. Examples of using <code>pars</code> in this way can be found on the
<a href="#topic+tidy-params">Tidy parameter selection</a> page.</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional <a href="base.html#topic+grep">regular expression</a> to use for
parameter selection. Can be specified instead of <code>pars</code> or in addition to
<code>pars</code>. When using <code>pars</code> for tidy parameter selection, the <code>regex_pars</code>
argument is ignored since <a href="tidyselect.html#topic+language">select helpers</a>
perform a similar function.</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_transformations">transformations</code></td>
<td>
<p>Optionally, transformations to apply to parameters
before plotting. If <code>transformations</code> is a function or a single string
naming a function then that function will be used to transform all
parameters. To apply transformations to particular parameters, the
<code>transformations</code> argument can be a named list with length equal to
the number of parameters to be transformed. Currently only univariate
transformations of scalar parameters can be specified (multivariate
transformations will be implemented in a future release). If
<code>transformations</code> is a list, the name of each list element should be a
parameter name and the content of each list element should be a function
(or any item to match as a function via <code><a href="base.html#topic+match.fun">match.fun()</a></code>, e.g. a
string naming a function). If a function is specified by its name as a
string (e.g. <code>"log"</code>), then it can be used to construct a new
parameter label for the appropriate parameter (e.g. <code>"log(sigma)"</code>).
If a function itself is specified
(e.g. <code>log</code> or <code>function(x) log(x)</code>)
then <code>"t"</code> is used in the new parameter label to indicate that the
parameter is transformed (e.g. <code>"t(sigma)"</code>).
</p>
<p>Note: due to partial argument matching <code>transformations</code> can be
abbreviated for convenience in interactive use (e.g., <code>transform</code>).</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_facet_args">facet_args</code></td>
<td>
<p>A named list of arguments (other than <code>facets</code>) passed
to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> or <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>
to control faceting. Note: if <code>scales</code> is not included in <code>facet_args</code>
then <strong>bayesplot</strong> may use <code>scales="free"</code> as the default (depending
on the plot) instead of the <strong>ggplot2</strong> default of <code>scales="fixed"</code>.</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_binwidth">binwidth</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_bins">bins</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> as an
alternative to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_freq">freq</code></td>
<td>
<p>For histograms, <code>freq=TRUE</code> (the default) puts count on the
y-axis. Setting <code>freq=FALSE</code> puts density on the y-axis. (For many
plots the y-axis text is off by default. To view the count or density
labels on the y-axis see the <code><a href="#topic+yaxis_text">yaxis_text()</a></code> convenience
function.)</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_alpha">alpha</code></td>
<td>
<p>Passed to the geom to control the transparency.</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_trim">trim</code></td>
<td>
<p>A logical scalar passed to <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code>.</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_bw">bw</code>, <code id="MCMC-distributions_+3A_adjust">adjust</code>, <code id="MCMC-distributions_+3A_kernel">kernel</code>, <code id="MCMC-distributions_+3A_n_dens">n_dens</code></td>
<td>
<p>Optional arguments passed to
<code><a href="stats.html#topic+density">stats::density()</a></code> to override default kernel density estimation
parameters. <code>n_dens</code> defaults to <code>1024</code>.</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_color_chains">color_chains</code></td>
<td>
<p>Option for whether to separately color chains.</p>
</td></tr>
<tr><td><code id="MCMC-distributions_+3A_probs">probs</code></td>
<td>
<p>A numeric vector passed to <code><a href="ggplot2.html#topic+geom_violin">ggplot2::geom_violin()</a></code>'s
<code>draw_quantiles</code> argument to specify at which quantiles to draw
horizontal lines. Set to <code>NULL</code> to remove the lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object that can be further customized using the <strong>ggplot2</strong> package.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>mcmc_hist()</code></dt><dd>
<p>Histograms of posterior draws with all chains merged.
</p>
</dd>
<dt><code>mcmc_dens()</code></dt><dd>
<p>Kernel density plots of posterior draws with all chains merged.
</p>
</dd>
<dt><code>mcmc_hist_by_chain()</code></dt><dd>
<p>Histograms of posterior draws with chains separated via faceting.
</p>
</dd>
<dt><code>mcmc_dens_overlay()</code></dt><dd>
<p>Kernel density plots of posterior draws with chains separated but
overlaid on a single plot.
</p>
</dd>
<dt><code>mcmc_violin()</code></dt><dd>
<p>The density estimate of each chain is plotted as a violin with
horizontal lines at notable quantiles.
</p>
</dd>
<dt><code>mcmc_dens_chains()</code></dt><dd>
<p>Ridgeline kernel density plots of posterior draws with chains separated
but overlaid on a single plot. In <code>mcmc_dens_overlay()</code> parameters
appear in separate facets; in <code>mcmc_dens_chains()</code> they appear in the
same panel and can overlap vertically.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other MCMC: 
<code><a href="#topic+MCMC-combos">MCMC-combos</a></code>,
<code><a href="#topic+MCMC-diagnostics">MCMC-diagnostics</a></code>,
<code><a href="#topic+MCMC-intervals">MCMC-intervals</a></code>,
<code><a href="#topic+MCMC-nuts">MCMC-nuts</a></code>,
<code><a href="#topic+MCMC-overview">MCMC-overview</a></code>,
<code><a href="#topic+MCMC-parcoord">MCMC-parcoord</a></code>,
<code><a href="#topic+MCMC-recover">MCMC-recover</a></code>,
<code><a href="#topic+MCMC-scatterplots">MCMC-scatterplots</a></code>,
<code><a href="#topic+MCMC-traces">MCMC-traces</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(9262017)
# some parameter draws to use for demonstration
x &lt;- example_mcmc_draws()
dim(x)
dimnames(x)

##################
### Histograms ###
##################

# histograms of all parameters
color_scheme_set("brightblue")
mcmc_hist(x)

# histograms of some parameters
color_scheme_set("pink")
mcmc_hist(x, pars = c("alpha", "beta[2]"))

mcmc_hist(x, pars = "sigma", regex_pars = "beta")

# example of using 'transformations' argument to plot log(sigma),
# and parsing facet labels (e.g. to get greek letters for parameters)
mcmc_hist(x, transformations = list(sigma = "log"),
          facet_args = list(labeller = ggplot2::label_parsed)) +
          facet_text(size = 15)

# instead of list(sigma = "log"), you could specify the transformation as
# list(sigma = log) or list(sigma = function(x) log(x)), but then the
# label for the transformed sigma is 't(sigma)' instead of 'log(sigma)'
mcmc_hist(x, transformations = list(sigma = log))

# separate histograms by chain
color_scheme_set("pink")
mcmc_hist_by_chain(x, regex_pars = "beta")


#################
### Densities ###
#################

mcmc_dens(x, pars = c("sigma", "beta[2]"),
          facet_args = list(nrow = 2))

# separate and overlay chains
color_scheme_set("mix-teal-pink")
mcmc_dens_overlay(x, pars = c("sigma", "beta[2]"),
                  facet_args = list(nrow = 2)) +
                  facet_text(size = 14)
x2 &lt;- example_mcmc_draws(params = 6)
mcmc_dens_chains(x2, pars = c("beta[1]", "beta[2]", "beta[3]"))

# separate chains as violin plots
color_scheme_set("green")
mcmc_violin(x) + panel_bg(color = "gray20", size = 2, fill = "gray30")

</code></pre>

<hr>
<h2 id='MCMC-intervals'>Plot interval estimates from MCMC draws</h2><span id='topic+MCMC-intervals'></span><span id='topic+mcmc_intervals'></span><span id='topic+mcmc_areas'></span><span id='topic+mcmc_areas_ridges'></span><span id='topic+mcmc_intervals_data'></span><span id='topic+mcmc_areas_data'></span><span id='topic+mcmc_areas_ridges_data'></span>

<h3>Description</h3>

<p>Plot central (quantile-based) posterior interval estimates from MCMC draws.
See the <strong>Plot Descriptions</strong> section, below, for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_intervals(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  prob = 0.5,
  prob_outer = 0.9,
  point_est = c("median", "mean", "none"),
  outer_size = 0.5,
  inner_size = 2,
  point_size = 4,
  rhat = numeric()
)

mcmc_areas(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  area_method = c("equal area", "equal height", "scaled height"),
  prob = 0.5,
  prob_outer = 1,
  point_est = c("median", "mean", "none"),
  rhat = numeric(),
  border_size = NULL,
  bw = NULL,
  adjust = NULL,
  kernel = NULL,
  n_dens = NULL
)

mcmc_areas_ridges(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  prob_outer = 1,
  prob = 1,
  border_size = NULL,
  bw = NULL,
  adjust = NULL,
  kernel = NULL,
  n_dens = NULL
)

mcmc_intervals_data(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  prob = 0.5,
  prob_outer = 0.9,
  point_est = c("median", "mean", "none"),
  rhat = numeric()
)

mcmc_areas_data(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  prob = 0.5,
  prob_outer = 1,
  point_est = c("median", "mean", "none"),
  rhat = numeric(),
  bw = NULL,
  adjust = NULL,
  kernel = NULL,
  n_dens = NULL
)

mcmc_areas_ridges_data(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  prob_outer = 1,
  prob = 1,
  bw = NULL,
  adjust = NULL,
  kernel = NULL,
  n_dens = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMC-intervals_+3A_x">x</code></td>
<td>
<p>An object containing MCMC draws:
</p>

<ul>
<li><p> A 3-D array, matrix, list of matrices, or data frame. The <a href="#topic+MCMC-overview">MCMC-overview</a>
page provides details on how to specify each these.
</p>
</li>
<li><p> A <code>draws</code> object from the <span class="pkg"><a href="posterior.html#topic+posterior">posterior</a></span> package (e.g.,
<code>draws_array</code>, <code>draws_rvars</code>, etc.).
</p>
</li>
<li><p> An object with an <code>as.array()</code> method that returns the same kind of 3-D
array described on the <a href="#topic+MCMC-overview">MCMC-overview</a> page.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names. If neither
<code>pars</code> nor <code>regex_pars</code> is specified then the default is to use <em>all</em>
parameters. As of version <code style="white-space: pre;">&#8288;1.7.0&#8288;</code>, <strong>bayesplot</strong> also supports 'tidy'
parameter selection by specifying <code>pars = vars(...)</code>, where <code>...</code> is
specified the same way as in <a href="dplyr.html#topic+select">dplyr::select(...)</a> and
similar functions. Examples of using <code>pars</code> in this way can be found on the
<a href="#topic+tidy-params">Tidy parameter selection</a> page.</p>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional <a href="base.html#topic+grep">regular expression</a> to use for
parameter selection. Can be specified instead of <code>pars</code> or in addition to
<code>pars</code>. When using <code>pars</code> for tidy parameter selection, the <code>regex_pars</code>
argument is ignored since <a href="tidyselect.html#topic+language">select helpers</a>
perform a similar function.</p>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_transformations">transformations</code></td>
<td>
<p>Optionally, transformations to apply to parameters
before plotting. If <code>transformations</code> is a function or a single string
naming a function then that function will be used to transform all
parameters. To apply transformations to particular parameters, the
<code>transformations</code> argument can be a named list with length equal to
the number of parameters to be transformed. Currently only univariate
transformations of scalar parameters can be specified (multivariate
transformations will be implemented in a future release). If
<code>transformations</code> is a list, the name of each list element should be a
parameter name and the content of each list element should be a function
(or any item to match as a function via <code><a href="base.html#topic+match.fun">match.fun()</a></code>, e.g. a
string naming a function). If a function is specified by its name as a
string (e.g. <code>"log"</code>), then it can be used to construct a new
parameter label for the appropriate parameter (e.g. <code>"log(sigma)"</code>).
If a function itself is specified
(e.g. <code>log</code> or <code>function(x) log(x)</code>)
then <code>"t"</code> is used in the new parameter label to indicate that the
parameter is transformed (e.g. <code>"t(sigma)"</code>).
</p>
<p>Note: due to partial argument matching <code>transformations</code> can be
abbreviated for convenience in interactive use (e.g., <code>transform</code>).</p>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_prob">prob</code></td>
<td>
<p>The probability mass to include in the inner interval (for
<code>mcmc_intervals()</code>) or in the shaded region (for <code>mcmc_areas()</code>). The
default is <code>0.5</code> (50% interval) and <code>1</code> for <code>mcmc_areas_ridges()</code>.</p>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_prob_outer">prob_outer</code></td>
<td>
<p>The probability mass to include in the outer interval. The
default is <code>0.9</code> for <code>mcmc_intervals()</code> (90% interval) and
<code>1</code> for <code>mcmc_areas()</code> and for <code>mcmc_areas_ridges()</code>.</p>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_point_est">point_est</code></td>
<td>
<p>The point estimate to show. Either <code>"median"</code> (the
default), <code>"mean"</code>, or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_inner_size">inner_size</code>, <code id="MCMC-intervals_+3A_outer_size">outer_size</code></td>
<td>
<p>For <code>mcmc_intervals()</code>, the size of
the inner and interval segments, respectively.</p>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_point_size">point_size</code></td>
<td>
<p>For <code>mcmc_intervals()</code>, the size of point estimate.</p>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_rhat">rhat</code></td>
<td>
<p>An optional numeric vector of R-hat estimates, with one element
per parameter included in <code>x</code>. If <code>rhat</code> is provided, the intervals/areas
and point estimates in the resulting plot are colored based on R-hat value.
See <code><a href="#topic+rhat">rhat()</a></code> for methods for extracting R-hat estimates.</p>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_area_method">area_method</code></td>
<td>
<p>How to constrain the areas in <code>mcmc_areas()</code>. The
default is <code>"equal area"</code>, setting the density curves to have the same
area. With <code>"equal height"</code>, the curves are scaled so that the highest
points across the curves are the same height. The method <code>"scaled height"</code> tries a compromise between to the two: the heights from
<code>"equal height"</code> are scaled using <code>height*sqrt(height)</code></p>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_border_size">border_size</code></td>
<td>
<p>For <code>mcmc_areas()</code> and <code>mcmc_areas_ridges()</code>, the size of
the ridgelines.</p>
</td></tr>
<tr><td><code id="MCMC-intervals_+3A_bw">bw</code>, <code id="MCMC-intervals_+3A_adjust">adjust</code>, <code id="MCMC-intervals_+3A_kernel">kernel</code>, <code id="MCMC-intervals_+3A_n_dens">n_dens</code></td>
<td>
<p>Optional arguments passed to
<code><a href="stats.html#topic+density">stats::density()</a></code> to override default kernel density estimation
parameters. <code>n_dens</code> defaults to <code>1024</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">&#8288;_data()&#8288;</code> return the data that would have been drawn by the plotting
function.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>mcmc_intervals()</code></dt><dd>
<p>Plots of uncertainty intervals computed from posterior draws with all
chains merged.
</p>
</dd>
<dt><code>mcmc_areas()</code></dt><dd>
<p>Density plots computed from posterior draws with all chains merged,
with uncertainty intervals shown as shaded areas under the curves.
</p>
</dd>
<dt><code>mcmc_areas_ridges()</code></dt><dd>
<p>Density plot, as in <code>mcmc_areas()</code>, but drawn with overlapping
ridgelines. This plot provides a compact display of (hierarchically)
related distributions.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other MCMC: 
<code><a href="#topic+MCMC-combos">MCMC-combos</a></code>,
<code><a href="#topic+MCMC-diagnostics">MCMC-diagnostics</a></code>,
<code><a href="#topic+MCMC-distributions">MCMC-distributions</a></code>,
<code><a href="#topic+MCMC-nuts">MCMC-nuts</a></code>,
<code><a href="#topic+MCMC-overview">MCMC-overview</a></code>,
<code><a href="#topic+MCMC-parcoord">MCMC-parcoord</a></code>,
<code><a href="#topic+MCMC-recover">MCMC-recover</a></code>,
<code><a href="#topic+MCMC-scatterplots">MCMC-scatterplots</a></code>,
<code><a href="#topic+MCMC-traces">MCMC-traces</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(9262017)

# load ggplot2 to use its functions to modify our plots
library(ggplot2)

# some parameter draws to use for demonstration
x &lt;- example_mcmc_draws(params = 6)
dim(x)
dimnames(x)

color_scheme_set("brightblue")
mcmc_intervals(x)
mcmc_intervals(x, pars = c("beta[1]", "beta[2]"))
mcmc_areas(x, regex_pars = "beta\\[[1-3]\\]",  prob = 0.8) +
 labs(
   title = "Posterior distributions",
   subtitle = "with medians and 80% intervals"
 )

color_scheme_set("red")
p &lt;- mcmc_areas(
   x,
   pars = c("alpha", "beta[4]"),
   prob = 2/3,
   prob_outer = 0.9,
   point_est = "mean",
   border_size = 1.5 # make the ridgelines fatter
)
plot(p)


# control spacing at top and bottom of plot
# see ?ggplot2::expansion
p + scale_y_discrete(
  limits = c("beta[4]", "alpha"),
  expand = expansion(add = c(1, 2))
)
p + scale_y_discrete(
  limits = c("beta[4]", "alpha"),
  expand = expansion(add = c(.1, .3))
)

# relabel parameters
p + scale_y_discrete(
  labels = c("alpha" = "param label 1",
             "beta[4]" = "param label 2")
)

# relabel parameters and define the order
p + scale_y_discrete(
  labels = c("alpha" = "param label 1",
             "beta[4]" = "param label 2"),
  limits = c("beta[4]", "alpha")
)

# color by rhat value
color_scheme_set("blue")
fake_rhat_values &lt;- c(1, 1.07, 1.3, 1.01, 1.15, 1.005)
mcmc_intervals(x, rhat = fake_rhat_values)

# get the dataframe that is used in the plotting functions
mcmc_intervals_data(x)
mcmc_intervals_data(x, rhat = fake_rhat_values)
mcmc_areas_data(x, pars = "alpha")

color_scheme_set("gray")
p &lt;- mcmc_areas(x, pars = c("alpha", "beta[4]"), rhat = c(1, 1.1))
p + legend_move("bottom")
p + legend_move("none") # or p + legend_none()



# Different area calculations
b3 &lt;- c("beta[1]", "beta[2]", "beta[3]")

mcmc_areas(x, pars = b3, area_method = "equal area") +
  labs(
    title = "Curves have same area",
    subtitle = "A wide, uncertain interval is spread thin when areas are equal"
   )

mcmc_areas(x, pars = b3, area_method = "equal height") +
  labs(
    title = "Curves have same maximum height",
    subtitle = "Local curvature is clearer but more uncertain curves use more area"
  )

mcmc_areas(x, pars = b3, area_method = "scaled height") +
  labs(
    title = "Same maximum heights but heights scaled by square-root",
    subtitle = "Compromise: Local curvature is accentuated and less area is used"
   )


# apply transformations
mcmc_intervals(
  x,
  pars = c("beta[2]", "sigma"),
  transformations = list("sigma" = "log", "beta[2]" = function(x) x + 3)
)

# apply same transformation to all selected parameters
mcmc_intervals(x, regex_pars = "beta", transformations = "exp")


## Not run: 
# example using fitted model from rstanarm package
library(rstanarm)
fit &lt;- stan_glm(
 mpg ~ 0 + wt + factor(cyl),
 data = mtcars,
 iter = 500,
 refresh = 0
)
x &lt;- as.matrix(fit)

color_scheme_set("teal")
mcmc_intervals(x, point_est = "mean", prob = 0.8, prob_outer = 0.95)
mcmc_areas(x, regex_pars = "cyl", bw = "SJ",
           rhat = rhat(fit, regex_pars = "cyl"))

## End(Not run)

## Not run: 
# Example of hierarchically related parameters
# plotted with ridgelines
m &lt;- shinystan::eight_schools@posterior_sample
mcmc_areas_ridges(m, pars = "mu", regex_pars = "theta", border_size = 0.75) +
  ggtitle("Treatment effect on eight schools (Rubin, 1981)")

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMC-nuts'>Diagnostic plots for the No-U-Turn-Sampler (NUTS)</h2><span id='topic+MCMC-nuts'></span><span id='topic+NUTS'></span><span id='topic+mcmc_nuts_acceptance'></span><span id='topic+mcmc_nuts_divergence'></span><span id='topic+mcmc_nuts_stepsize'></span><span id='topic+mcmc_nuts_treedepth'></span><span id='topic+mcmc_nuts_energy'></span>

<h3>Description</h3>

<p>Diagnostic plots for the No-U-Turn-Sampler (NUTS), the default MCMC algorithm
used by <a href="https://mc-stan.org">Stan</a>. See the <strong>Plot Descriptions</strong> section,
below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_nuts_acceptance(
  x,
  lp,
  chain = NULL,
  ...,
  binwidth = NULL,
  bins = NULL,
  breaks = NULL
)

mcmc_nuts_divergence(x, lp, chain = NULL, ...)

mcmc_nuts_stepsize(x, lp, chain = NULL, ...)

mcmc_nuts_treedepth(x, lp, chain = NULL, ...)

mcmc_nuts_energy(
  x,
  ...,
  binwidth = NULL,
  bins = NULL,
  breaks = NULL,
  alpha = 0.5,
  merge_chains = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMC-nuts_+3A_x">x</code></td>
<td>
<p>A molten data frame of NUTS sampler parameters, either created by
<code><a href="#topic+nuts_params">nuts_params()</a></code> or in the same form as the object returned by
<code><a href="#topic+nuts_params">nuts_params()</a></code>.</p>
</td></tr>
<tr><td><code id="MCMC-nuts_+3A_lp">lp</code></td>
<td>
<p>A molten data frame of draws of the log-posterior or, more
commonly, of a quantity equal to the log-posterior up to a constant.
<code>lp</code> should either be created via <code><a href="#topic+log_posterior">log_posterior()</a></code> or be an
object with the same form as the object returned by
<code><a href="#topic+log_posterior">log_posterior()</a></code>.</p>
</td></tr>
<tr><td><code id="MCMC-nuts_+3A_chain">chain</code></td>
<td>
<p>A positive integer for selecting a particular chain. The default
(<code>NULL</code>) is to merge the chains before plotting. If <code>chain = k</code>
then the plot for chain <code>k</code> is overlaid (in a darker shade but with
transparency) on top of the plot for all chains. The <code>chain</code> argument
is not used by <code>mcmc_nuts_energy()</code>.</p>
</td></tr>
<tr><td><code id="MCMC-nuts_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="MCMC-nuts_+3A_binwidth">binwidth</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="MCMC-nuts_+3A_bins">bins</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="MCMC-nuts_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> as an
alternative to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="MCMC-nuts_+3A_alpha">alpha</code></td>
<td>
<p>For <code>mcmc_nuts_energy()</code> only, the transparency (alpha) level
in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> used for the overlaid histogram.</p>
</td></tr>
<tr><td><code id="MCMC-nuts_+3A_merge_chains">merge_chains</code></td>
<td>
<p>For <code>mcmc_nuts_energy()</code> only, should all chains be
merged or displayed separately? The default is <code>FALSE</code>, i.e., to show
the chains separately.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gtable object (the result of calling
<code><a href="gridExtra.html#topic+arrangeGrob">gridExtra::arrangeGrob()</a></code>) created from several ggplot objects,
except for <code>mcmc_nuts_energy()</code>, which returns a ggplot object.
</p>


<h3>Quick Definitions</h3>

<p>For more details see Stan Development Team (2016) and Betancourt (2017).
</p>

<ul>
<li> <p><code>accept_stat__</code>: the average acceptance probabilities of all
possible samples in the proposed tree.
</p>
</li>
<li> <p><code>divergent__</code>: the number of leapfrog transitions with diverging
error. Because NUTS terminates at the first divergence this will be either
0 or 1 for each iteration.
</p>
</li>
<li> <p><code>stepsize__</code>: the step size used by NUTS in its Hamiltonian
simulation.
</p>
</li>
<li> <p><code>treedepth__</code>: the depth of tree used by NUTS, which is the log
(base 2) of the number of leapfrog steps taken during the Hamiltonian
simulation.
</p>
</li>
<li> <p><code>energy__</code>: the value of the Hamiltonian (up to an additive
constant) at each iteration.
</p>
</li></ul>



<h3>Plot Descriptions</h3>


<dl>
<dt><code>mcmc_nuts_acceptance()</code></dt><dd>
<p>Three plots:
</p>

<ul>
<li><p> Histogram of <code>accept_stat__</code> with vertical lines indicating the
mean (solid line) and median (dashed line).
</p>
</li>
<li><p> Histogram of <code>lp__</code> with vertical
lines indicating the mean (solid line) and median (dashed line).
</p>
</li>
<li><p> Scatterplot of <code>accept_stat__</code> vs <code>lp__</code>.
</p>
</li></ul>

</dd>
<dt><code>mcmc_nuts_divergence()</code></dt><dd>
<p>Two plots:
</p>

<ul>
<li><p> Violin plots of <code>lp__|divergent__=1</code> and <code>lp__|divergent__=0</code>.
</p>
</li>
<li><p> Violin plots of <code>accept_stat__|divergent__=1</code> and
<code>accept_stat__|divergent__=0</code>.
</p>
</li></ul>

</dd>
<dt><code>mcmc_nuts_stepsize()</code></dt><dd>
<p>Two plots:
</p>

<ul>
<li><p> Violin plots of <code>lp__</code> by chain ordered by <code>stepsize__</code> value.
</p>
</li>
<li><p> Violin plots of <code>accept_stat__</code> by chain ordered by <code>stepsize__</code> value.
</p>
</li></ul>

</dd>
<dt><code>mcmc_nuts_treedepth()</code></dt><dd>
<p>Three plots:
</p>

<ul>
<li><p> Violin plots of <code>lp__</code> by value of <code>treedepth__</code>.
</p>
</li>
<li><p> Violin plots of <code>accept_stat__</code> by value of <code>treedepth__</code>.
</p>
</li>
<li><p> Histogram of <code>treedepth__</code>.
</p>
</li></ul>

</dd>
<dt><code>mcmc_nuts_energy()</code></dt><dd>
<p>Overlaid histograms showing <code>energy__</code> vs the change in
<code>energy__</code>. See Betancourt (2016) for details.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Betancourt, M. (2017). A conceptual introduction to Hamiltonian Monte Carlo.
<a href="https://arxiv.org/abs/1701.02434">https://arxiv.org/abs/1701.02434</a>
</p>
<p>Betancourt, M. and Girolami, M. (2013). Hamiltonian Monte Carlo for
hierarchical models. <a href="https://arxiv.org/abs/1312.0906">https://arxiv.org/abs/1312.0906</a>
</p>
<p>Hoffman, M. D. and Gelman, A. (2014). The No-U-Turn Sampler:
adaptively setting path lengths in Hamiltonian Monte Carlo.
<em>Journal of Machine Learning Research</em>. 15:1593&ndash;1623.
</p>
<p>Stan Development Team.
<em>Stan Modeling Language Users Guide and Reference Manual.</em>
<a href="https://mc-stan.org/users/documentation/">https://mc-stan.org/users/documentation/</a>
</p>


<h3>See Also</h3>


<ul>
<li><p> The <a href="https://mc-stan.org/bayesplot/articles/visual-mcmc-diagnostics.html">Visual MCMC Diagnostics</a>
vignette.
</p>
</li>
<li><p> Several other plotting functions are not NUTS-specific but take optional
extra arguments if the model was fit using NUTS:
</p>

<ul>
<li> <p><code><a href="#topic+mcmc_trace">mcmc_trace()</a></code>: show divergences as tick marks below the
trace plot.
</p>
</li>
<li> <p><code><a href="#topic+mcmc_parcoord">mcmc_parcoord()</a></code>: change the color/size/transparency of lines
corresponding to divergences.
</p>
</li>
<li> <p><code><a href="#topic+mcmc_scatter">mcmc_scatter()</a></code>: change the color/size/shape of points
corresponding to divergences.
</p>
</li>
<li> <p><code><a href="#topic+mcmc_pairs">mcmc_pairs()</a></code>: change the color/size/shape of points
corresponding divergences and/or max treedepth saturation.
</p>
</li></ul>

</li></ul>

<p>Other MCMC: 
<code><a href="#topic+MCMC-combos">MCMC-combos</a></code>,
<code><a href="#topic+MCMC-diagnostics">MCMC-diagnostics</a></code>,
<code><a href="#topic+MCMC-distributions">MCMC-distributions</a></code>,
<code><a href="#topic+MCMC-intervals">MCMC-intervals</a></code>,
<code><a href="#topic+MCMC-overview">MCMC-overview</a></code>,
<code><a href="#topic+MCMC-parcoord">MCMC-parcoord</a></code>,
<code><a href="#topic+MCMC-recover">MCMC-recover</a></code>,
<code><a href="#topic+MCMC-scatterplots">MCMC-scatterplots</a></code>,
<code><a href="#topic+MCMC-traces">MCMC-traces</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ggplot2)
library(rstanarm)
fit &lt;- stan_glm(mpg ~ wt + am, data = mtcars, iter = 1000, refresh = 0)
np &lt;- nuts_params(fit)
lp &lt;- log_posterior(fit)

color_scheme_set("brightblue")
mcmc_nuts_acceptance(np, lp)
mcmc_nuts_acceptance(np, lp, chain = 2)

mcmc_nuts_divergence(np, lp)
mcmc_nuts_stepsize(np, lp)
mcmc_nuts_treedepth(np, lp)

color_scheme_set("red")
mcmc_nuts_energy(np)
mcmc_nuts_energy(np, merge_chains = TRUE, binwidth = .15)
mcmc_nuts_energy(np) +
 facet_wrap(vars(Chain), nrow = 1) +
 coord_fixed(ratio = 150) +
 ggtitle("NUTS Energy Diagnostic")

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMC-overview'>Plots for Markov chain Monte Carlo simulations</h2><span id='topic+MCMC-overview'></span><span id='topic+MCMC'></span>

<h3>Description</h3>

<p>The <strong>bayesplot</strong> MCMC module provides various plotting functions for
creating graphical displays of Markov chain Monte Carlo (MCMC) simulations.
The <strong>MCMC plotting functions</strong> section, below, provides links to the
documentation for various categories of MCMC plots. Currently the MCMC
plotting functions accept posterior draws provided in one of the following
formats:
</p>

<ul>
<li> <p><strong>3-D array</strong>: An array with dimensions <code style="white-space: pre;">&#8288;Iteration, Chain, Parameter&#8288;</code> in
that order.
</p>
</li>
<li> <p><strong>list</strong>: A list of matrices, where each matrix corresponds to a Markov
chain. All of the matrices should have the same number of iterations (rows)
and parameters (columns), and parameters should have the same names and be in
the same order.
</p>
</li>
<li> <p><strong>matrix (2-D array)</strong>: A matrix with one column per parameter. If using
matrix there should only be a single Markov chain or all chains should
already be merged (stacked).
</p>
</li>
<li> <p><strong>data frame</strong>: There are two types of data frames allowed. Either a data
frame with one column per parameter (if only a single chain or all chains
have already been merged), or a data frame with one column per parameter plus
an additional column <code>"Chain"</code> that contains the chain number (an integer)
corresponding to each row in the data frame.
</p>
</li>
<li> <p><strong>draws</strong>: Any of the <code>draws</code> formats supported by the
<span class="pkg"><a href="posterior.html#topic+posterior">posterior</a></span> package.
</p>
</li></ul>

<p><strong>Note</strong>: typically the user should <em>not</em> include warmup iterations
in the object passed to <strong>bayesplot</strong> plotting functions, although for
certain plots (e.g. trace plots) it can occasionally be useful to include the
warmup iterations for diagnostic purposes.
</p>


<h3>MCMC plotting functions</h3>


<ul>
<li> <p><a href="#topic+MCMC-distributions">Posterior distributions</a>:
Histograms and kernel density plots of parameter draws, optionally
showing each Markov chain separately.
</p>
</li>
<li> <p><a href="#topic+MCMC-intervals">Uncertainty intervals</a>: Uncertainty intervals computed
from parameter draws.
</p>
</li>
<li> <p><a href="#topic+MCMC-traces">Trace plots</a>: Times series of parameter draws, optionally
including HMC/NUTS diagnostic information.
</p>
</li>
<li> <p><a href="#topic+MCMC-scatterplots">Scatterplots</a>: Scatterplots, heatmaps, and pairs
plots of parameter draws, optionally including HMC/NUTS diagnostic
information.
</p>
</li>
<li> <p><a href="#topic+MCMC-parcoord">Parallel coordinates plots</a>: Parallel coordinates plot
of MCMC draws (one dimension per parameter), optionally including
HMC/NUTS diagnostic information.
</p>
</li>
<li> <p><a href="#topic+MCMC-combos">Combos</a>: Combination plots (e.g. trace plot + histogram).
</p>
</li>
<li> <p><a href="#topic+MCMC-diagnostics">General MCMC diagnostics</a>: MCMC diagnostic plots
including R-hat, effective sample size, autocorrelation.
<a href="#topic+MCMC-nuts">NUTS diagnostics</a>: Special diagnostic plots for
the No-U-Turn Sampler.
</p>
</li>
<li> <p><a href="#topic+MCMC-recover">Comparisons to &quot;true&quot; values</a>: Plots comparing MCMC
estimates to &quot;true&quot; parameter values (e.g., values used to simulate data).
</p>
</li></ul>



<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>


<h3>See Also</h3>

<p>Other MCMC: 
<code><a href="#topic+MCMC-combos">MCMC-combos</a></code>,
<code><a href="#topic+MCMC-diagnostics">MCMC-diagnostics</a></code>,
<code><a href="#topic+MCMC-distributions">MCMC-distributions</a></code>,
<code><a href="#topic+MCMC-intervals">MCMC-intervals</a></code>,
<code><a href="#topic+MCMC-nuts">MCMC-nuts</a></code>,
<code><a href="#topic+MCMC-parcoord">MCMC-parcoord</a></code>,
<code><a href="#topic+MCMC-recover">MCMC-recover</a></code>,
<code><a href="#topic+MCMC-scatterplots">MCMC-scatterplots</a></code>,
<code><a href="#topic+MCMC-traces">MCMC-traces</a></code>
</p>

<hr>
<h2 id='MCMC-parcoord'>Parallel coordinates plot of MCMC draws</h2><span id='topic+MCMC-parcoord'></span><span id='topic+mcmc_parcoord'></span><span id='topic+mcmc_parcoord_data'></span><span id='topic+parcoord_style_np'></span>

<h3>Description</h3>

<p>Parallel coordinates plot of MCMC draws (one dimension per parameter).
See the <strong>Plot Descriptions</strong> section below for details,
and see <a href="https://github.com/jgabry/bayes-vis-paper#readme">Gabry et al. (2019)</a>
for more background and a real example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_parcoord(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  size = 0.2,
  alpha = 0.3,
  np = NULL,
  np_style = parcoord_style_np()
)

mcmc_parcoord_data(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  np = NULL
)

parcoord_style_np(div_color = "red", div_size = 0.2, div_alpha = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMC-parcoord_+3A_x">x</code></td>
<td>
<p>An object containing MCMC draws:
</p>

<ul>
<li><p> A 3-D array, matrix, list of matrices, or data frame. The <a href="#topic+MCMC-overview">MCMC-overview</a>
page provides details on how to specify each these.
</p>
</li>
<li><p> A <code>draws</code> object from the <span class="pkg"><a href="posterior.html#topic+posterior">posterior</a></span> package (e.g.,
<code>draws_array</code>, <code>draws_rvars</code>, etc.).
</p>
</li>
<li><p> An object with an <code>as.array()</code> method that returns the same kind of 3-D
array described on the <a href="#topic+MCMC-overview">MCMC-overview</a> page.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MCMC-parcoord_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names. If neither
<code>pars</code> nor <code>regex_pars</code> is specified then the default is to use <em>all</em>
parameters. As of version <code style="white-space: pre;">&#8288;1.7.0&#8288;</code>, <strong>bayesplot</strong> also supports 'tidy'
parameter selection by specifying <code>pars = vars(...)</code>, where <code>...</code> is
specified the same way as in <a href="dplyr.html#topic+select">dplyr::select(...)</a> and
similar functions. Examples of using <code>pars</code> in this way can be found on the
<a href="#topic+tidy-params">Tidy parameter selection</a> page.</p>
</td></tr>
<tr><td><code id="MCMC-parcoord_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional <a href="base.html#topic+grep">regular expression</a> to use for
parameter selection. Can be specified instead of <code>pars</code> or in addition to
<code>pars</code>. When using <code>pars</code> for tidy parameter selection, the <code>regex_pars</code>
argument is ignored since <a href="tidyselect.html#topic+language">select helpers</a>
perform a similar function.</p>
</td></tr>
<tr><td><code id="MCMC-parcoord_+3A_transformations">transformations</code></td>
<td>
<p>Optionally, transformations to apply to parameters
before plotting. If <code>transformations</code> is a function or a single string
naming a function then that function will be used to transform all
parameters. To apply transformations to particular parameters, the
<code>transformations</code> argument can be a named list with length equal to
the number of parameters to be transformed. Currently only univariate
transformations of scalar parameters can be specified (multivariate
transformations will be implemented in a future release). If
<code>transformations</code> is a list, the name of each list element should be a
parameter name and the content of each list element should be a function
(or any item to match as a function via <code><a href="base.html#topic+match.fun">match.fun()</a></code>, e.g. a
string naming a function). If a function is specified by its name as a
string (e.g. <code>"log"</code>), then it can be used to construct a new
parameter label for the appropriate parameter (e.g. <code>"log(sigma)"</code>).
If a function itself is specified
(e.g. <code>log</code> or <code>function(x) log(x)</code>)
then <code>"t"</code> is used in the new parameter label to indicate that the
parameter is transformed (e.g. <code>"t(sigma)"</code>).
</p>
<p>Note: due to partial argument matching <code>transformations</code> can be
abbreviated for convenience in interactive use (e.g., <code>transform</code>).</p>
</td></tr>
<tr><td><code id="MCMC-parcoord_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="MCMC-parcoord_+3A_size">size</code>, <code id="MCMC-parcoord_+3A_alpha">alpha</code></td>
<td>
<p>Arguments passed on to <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>.</p>
</td></tr>
<tr><td><code id="MCMC-parcoord_+3A_np">np</code></td>
<td>
<p>For models fit using <a href="#topic+NUTS">NUTS</a> (more generally,
any <a href="https://en.wikipedia.org/wiki/Symplectic_integrator">symplectic integrator</a>),
an optional data frame providing NUTS diagnostic information. The data
frame should be the object returned by <code><a href="#topic+nuts_params">nuts_params()</a></code> or one with the same
structure.</p>
</td></tr>
<tr><td><code id="MCMC-parcoord_+3A_np_style">np_style</code></td>
<td>
<p>A call to the <code>parcoord_style_np()</code> helper function to
specify arguments controlling the appearance of superimposed lines
representing NUTS diagnostics (in this case divergences) if the <code>np</code>
argument is specified.</p>
</td></tr>
<tr><td><code id="MCMC-parcoord_+3A_div_color">div_color</code>, <code id="MCMC-parcoord_+3A_div_size">div_size</code>, <code id="MCMC-parcoord_+3A_div_alpha">div_alpha</code></td>
<td>
<p>Optional arguments to the
<code>parcoord_style_np()</code> helper function that are eventually passed to
<code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code> if the <code>np</code> argument is also specified. They control
the color, size, and transparency specifications for showing divergences in
the plot. The default values are displayed in the <strong>Usage</strong> section above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">&#8288;_data()&#8288;</code> return the data that would have been drawn by the plotting
function.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>mcmc_parcoord()</code></dt><dd>
<p><a href="https://en.wikipedia.org/wiki/Parallel_coordinates">Parallel coordinates plot</a>
of MCMC draws. There is one dimension per parameter along the horizontal
axis and each set of connected line segments represents a single MCMC draw
(i.e., a vector of length equal to the number of parameters).
</p>
<p>The parallel coordinates plot is most useful if the optional HMC/NUTS
diagnostic information is provided via the <code>np</code> argument. In that
case divergences are highlighted in the plot. The appearance of the
divergences can be customized using the <code>np_style</code> argument and the
<code>parcoord_style_np</code> helper function. This version of the plot is the
same as the parallel coordinates plot described in Gabry et al. (2019).
</p>
<p>When the plotted model parameters are on very different scales the
<code>transformations</code> argument can be useful. For example, to standardize
all variables before plotting you could use function <code>(x - mean(x))/sd(x)</code>
when specifying the <code>transformations</code> argument to
<code>mcmc_parcoord</code>. See the <strong>Examples</strong> section for how to do this.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>
<p>Hartikainen, A. (2017, Aug 23). Concentration of divergences
(Msg 21). Message posted to The Stan Forums:
<a href="https://discourse.mc-stan.org/t/concentration-of-divergences/1590/21">https://discourse.mc-stan.org/t/concentration-of-divergences/1590/21</a>.
</p>


<h3>See Also</h3>

<p>Other MCMC: 
<code><a href="#topic+MCMC-combos">MCMC-combos</a></code>,
<code><a href="#topic+MCMC-diagnostics">MCMC-diagnostics</a></code>,
<code><a href="#topic+MCMC-distributions">MCMC-distributions</a></code>,
<code><a href="#topic+MCMC-intervals">MCMC-intervals</a></code>,
<code><a href="#topic+MCMC-nuts">MCMC-nuts</a></code>,
<code><a href="#topic+MCMC-overview">MCMC-overview</a></code>,
<code><a href="#topic+MCMC-recover">MCMC-recover</a></code>,
<code><a href="#topic+MCMC-scatterplots">MCMC-scatterplots</a></code>,
<code><a href="#topic+MCMC-traces">MCMC-traces</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>color_scheme_set("pink")
x &lt;- example_mcmc_draws(params = 5)
mcmc_parcoord(x)
mcmc_parcoord(x, regex_pars = "beta")

## Not run: 
# Example using a Stan demo model
library(rstan)
fit &lt;- stan_demo("eight_schools")
draws &lt;- as.array(fit, pars = c("mu", "tau", "theta", "lp__"))
np &lt;- nuts_params(fit)
str(np)
levels(np$Parameter)

color_scheme_set("brightblue")
mcmc_parcoord(draws, alpha = 0.05)
mcmc_parcoord(draws, np = np)

# customize appearance of divergences
color_scheme_set("darkgray")
div_style &lt;- parcoord_style_np(div_color = "green", div_size = 0.05, div_alpha = 0.4)
mcmc_parcoord(draws, size = 0.25, alpha = 0.1,
              np = np, np_style = div_style)

# to use a transformation (e.g., standardizing all the variables can be helpful)
# specify the 'transformations' argument (though partial argument name
# matching means we can just use 'trans' or 'transform')
mcmc_parcoord(
  draws,
  transform = function(x) {(x - mean(x)) / sd(x)},
  size = 0.25,
  alpha = 0.1,
  np = np,
  np_style = div_style
 )

# mcmc_parcoord_data returns just the data in a conventient form for plotting
d &lt;- mcmc_parcoord_data(x, np = np)
head(d)
tail(d)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMC-recover'>Compare MCMC estimates to &quot;true&quot; parameter values</h2><span id='topic+MCMC-recover'></span><span id='topic+mcmc_recover_intervals'></span><span id='topic+mcmc_recover_scatter'></span><span id='topic+mcmc_recover_hist'></span>

<h3>Description</h3>

<p>Plots comparing MCMC estimates to &quot;true&quot; parameter values. Before fitting a
model to real data it is useful to simulate data according to the model using
known (fixed) parameter values and to check that these &quot;true&quot; parameter
values are (approximately) recovered by fitting the model to the simulated
data. See the <strong>Plot Descriptions</strong> section, below, for details on the
available plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_recover_intervals(
  x,
  true,
  batch = rep(1, length(true)),
  ...,
  facet_args = list(),
  prob = 0.5,
  prob_outer = 0.9,
  point_est = c("median", "mean", "none"),
  size = 4,
  alpha = 1
)

mcmc_recover_scatter(
  x,
  true,
  batch = rep(1, length(true)),
  ...,
  facet_args = list(),
  point_est = c("median", "mean"),
  size = 3,
  alpha = 1
)

mcmc_recover_hist(
  x,
  true,
  ...,
  facet_args = list(),
  binwidth = NULL,
  bins = NULL,
  breaks = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMC-recover_+3A_x">x</code></td>
<td>
<p>An object containing MCMC draws:
</p>

<ul>
<li><p> A 3-D array, matrix, list of matrices, or data frame. The <a href="#topic+MCMC-overview">MCMC-overview</a>
page provides details on how to specify each these.
</p>
</li>
<li><p> A <code>draws</code> object from the <span class="pkg"><a href="posterior.html#topic+posterior">posterior</a></span> package (e.g.,
<code>draws_array</code>, <code>draws_rvars</code>, etc.).
</p>
</li>
<li><p> An object with an <code>as.array()</code> method that returns the same kind of 3-D
array described on the <a href="#topic+MCMC-overview">MCMC-overview</a> page.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MCMC-recover_+3A_true">true</code></td>
<td>
<p>A numeric vector of &quot;true&quot; values of the parameters in <code>x</code>.
There should be one value in <code>true</code> for each parameter included in
<code>x</code> and the order of the parameters in <code>true</code> should be the same
as the order of the parameters in <code>x</code>.</p>
</td></tr>
<tr><td><code id="MCMC-recover_+3A_batch">batch</code></td>
<td>
<p>Optionally, a vector-like object (numeric, character, integer,
factor) used to split the parameters into batches. If <code>batch</code> is
specified, it must have the same length as <code>true</code> and be in the same
order as <code>true</code>. Parameters in the same batch will be grouped together
in the same facet in the plot (see the <strong>Examples</strong> section, below).
The default is to group all parameters together into a single batch.
Changing the default is most useful when parameters are on very different
scales, in which case <code>batch</code> can be used to group them into batches
within which it makes sense to use the same y-axis.</p>
</td></tr>
<tr><td><code id="MCMC-recover_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="MCMC-recover_+3A_facet_args">facet_args</code></td>
<td>
<p>A named list of arguments (other than <code>facets</code>) passed
to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> or <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>
to control faceting. Note: if <code>scales</code> is not included in <code>facet_args</code>
then <strong>bayesplot</strong> may use <code>scales="free"</code> as the default (depending
on the plot) instead of the <strong>ggplot2</strong> default of <code>scales="fixed"</code>.</p>
</td></tr>
<tr><td><code id="MCMC-recover_+3A_prob">prob</code></td>
<td>
<p>The probability mass to include in the inner interval. The
default is <code>0.5</code> (50% interval).</p>
</td></tr>
<tr><td><code id="MCMC-recover_+3A_prob_outer">prob_outer</code></td>
<td>
<p>The probability mass to include in the outer interval. The
default is <code>0.9</code> (90% interval).</p>
</td></tr>
<tr><td><code id="MCMC-recover_+3A_point_est">point_est</code></td>
<td>
<p>The point estimate to show. Either <code>"median"</code> (the
default), <code>"mean"</code>, or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="MCMC-recover_+3A_size">size</code>, <code id="MCMC-recover_+3A_alpha">alpha</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> to control the
appearance of plotted points.</p>
</td></tr>
<tr><td><code id="MCMC-recover_+3A_binwidth">binwidth</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="MCMC-recover_+3A_bins">bins</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="MCMC-recover_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> as an
alternative to <code>binwidth</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object that can be further customized using the <strong>ggplot2</strong> package.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>mcmc_recover_intervals()</code></dt><dd>
<p>Central intervals and point estimates computed from MCMC draws, with
&quot;true&quot; values plotted using a different shape.
</p>
</dd>
<dt><code>mcmc_recover_scatter()</code></dt><dd>
<p>Scatterplot of posterior means (or medians) against &quot;true&quot; values.
</p>
</dd>
<dt><code>mcmc_recover_hist()</code></dt><dd>
<p>Histograms of the draws for each parameter with the &quot;true&quot; value overlaid
as a vertical line.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other MCMC: 
<code><a href="#topic+MCMC-combos">MCMC-combos</a></code>,
<code><a href="#topic+MCMC-diagnostics">MCMC-diagnostics</a></code>,
<code><a href="#topic+MCMC-distributions">MCMC-distributions</a></code>,
<code><a href="#topic+MCMC-intervals">MCMC-intervals</a></code>,
<code><a href="#topic+MCMC-nuts">MCMC-nuts</a></code>,
<code><a href="#topic+MCMC-overview">MCMC-overview</a></code>,
<code><a href="#topic+MCMC-parcoord">MCMC-parcoord</a></code>,
<code><a href="#topic+MCMC-scatterplots">MCMC-scatterplots</a></code>,
<code><a href="#topic+MCMC-traces">MCMC-traces</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rstanarm)
alpha &lt;- 1; beta &lt;- rnorm(10, 0, 3); sigma &lt;- 2
X &lt;- matrix(rnorm(1000), 100, 10)
y &lt;- rnorm(100, mean = c(alpha + X %*% beta), sd = sigma)
fit &lt;- stan_glm(y ~ ., data = data.frame(y, X), refresh = 0)
draws &lt;- as.matrix(fit)
print(colnames(draws))
true &lt;- c(alpha, beta, sigma)

mcmc_recover_intervals(draws, true)

# put the coefficients on X into the same batch
mcmc_recover_intervals(draws, true, batch = c(1, rep(2, 10), 1))
# equivalent
mcmc_recover_intervals(draws, true, batch = grepl("X", colnames(draws)))
# same but facets stacked vertically
mcmc_recover_intervals(draws, true,
                       batch = grepl("X", colnames(draws)),
                       facet_args = list(ncol = 1),
                       size = 3)

# each parameter in its own facet
mcmc_recover_intervals(draws, true, batch = 1:ncol(draws))
# same but in a different order
mcmc_recover_intervals(draws, true, batch = c(1, 3, 4, 2, 5:12))
# present as bias by centering with true values
mcmc_recover_intervals(sweep(draws, 2, true), rep(0, ncol(draws))) + hline_0()


# scatterplot of posterior means vs true values
mcmc_recover_scatter(draws, true, point_est = "mean")


# histograms of parameter draws with true value added as vertical line
color_scheme_set("brightblue")
mcmc_recover_hist(draws[, 1:4], true[1:4])

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMC-scatterplots'>Scatterplots of MCMC draws</h2><span id='topic+MCMC-scatterplots'></span><span id='topic+mcmc_scatter'></span><span id='topic+mcmc_hex'></span><span id='topic+mcmc_pairs'></span><span id='topic+scatter_style_np'></span><span id='topic+pairs_style_np'></span><span id='topic+pairs_condition'></span>

<h3>Description</h3>

<p>Scatterplots, hexagonal heatmaps, and pairs plots from MCMC draws. See the
<strong>Plot Descriptions</strong> section, below, for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_scatter(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  size = 2.5,
  alpha = 0.8,
  np = NULL,
  np_style = scatter_style_np()
)

mcmc_hex(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  bins = 30,
  binwidth = NULL
)

mcmc_pairs(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  diag_fun = c("hist", "dens"),
  off_diag_fun = c("scatter", "hex"),
  diag_args = list(),
  off_diag_args = list(),
  condition = pairs_condition(),
  lp = NULL,
  np = NULL,
  np_style = pairs_style_np(),
  max_treedepth = NULL,
  grid_args = list(),
  save_gg_objects = TRUE
)

scatter_style_np(
  div_color = "red",
  div_shape = 16,
  div_size = 2.5,
  div_alpha = 1
)

pairs_style_np(
  div_color = "red",
  div_shape = 4,
  div_size = 1,
  div_alpha = 1,
  td_color = "yellow2",
  td_shape = 3,
  td_size = 1,
  td_alpha = 1
)

pairs_condition(chains = NULL, draws = NULL, nuts = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMC-scatterplots_+3A_x">x</code></td>
<td>
<p>An object containing MCMC draws:
</p>

<ul>
<li><p> A 3-D array, matrix, list of matrices, or data frame. The <a href="#topic+MCMC-overview">MCMC-overview</a>
page provides details on how to specify each these.
</p>
</li>
<li><p> A <code>draws</code> object from the <span class="pkg"><a href="posterior.html#topic+posterior">posterior</a></span> package (e.g.,
<code>draws_array</code>, <code>draws_rvars</code>, etc.).
</p>
</li>
<li><p> An object with an <code>as.array()</code> method that returns the same kind of 3-D
array described on the <a href="#topic+MCMC-overview">MCMC-overview</a> page.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names. If neither
<code>pars</code> nor <code>regex_pars</code> is specified then the default is to use <em>all</em>
parameters. As of version <code style="white-space: pre;">&#8288;1.7.0&#8288;</code>, <strong>bayesplot</strong> also supports 'tidy'
parameter selection by specifying <code>pars = vars(...)</code>, where <code>...</code> is
specified the same way as in <a href="dplyr.html#topic+select">dplyr::select(...)</a> and
similar functions. Examples of using <code>pars</code> in this way can be found on the
<a href="#topic+tidy-params">Tidy parameter selection</a> page.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional <a href="base.html#topic+grep">regular expression</a> to use for
parameter selection. Can be specified instead of <code>pars</code> or in addition to
<code>pars</code>. When using <code>pars</code> for tidy parameter selection, the <code>regex_pars</code>
argument is ignored since <a href="tidyselect.html#topic+language">select helpers</a>
perform a similar function.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_transformations">transformations</code></td>
<td>
<p>Optionally, transformations to apply to parameters
before plotting. If <code>transformations</code> is a function or a single string
naming a function then that function will be used to transform all
parameters. To apply transformations to particular parameters, the
<code>transformations</code> argument can be a named list with length equal to
the number of parameters to be transformed. Currently only univariate
transformations of scalar parameters can be specified (multivariate
transformations will be implemented in a future release). If
<code>transformations</code> is a list, the name of each list element should be a
parameter name and the content of each list element should be a function
(or any item to match as a function via <code><a href="base.html#topic+match.fun">match.fun()</a></code>, e.g. a
string naming a function). If a function is specified by its name as a
string (e.g. <code>"log"</code>), then it can be used to construct a new
parameter label for the appropriate parameter (e.g. <code>"log(sigma)"</code>).
If a function itself is specified
(e.g. <code>log</code> or <code>function(x) log(x)</code>)
then <code>"t"</code> is used in the new parameter label to indicate that the
parameter is transformed (e.g. <code>"t(sigma)"</code>).
</p>
<p>Note: due to partial argument matching <code>transformations</code> can be
abbreviated for convenience in interactive use (e.g., <code>transform</code>).</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_size">size</code>, <code id="MCMC-scatterplots_+3A_alpha">alpha</code></td>
<td>
<p>For <code>mcmc_scatter()</code>, passed to
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> to control the appearance of the points.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_np">np</code></td>
<td>
<p>Optionally, a data frame of NUTS sampler parameters, either created
by <code><a href="#topic+nuts_params">nuts_params()</a></code> or in the same form as the object returned by
<code><a href="#topic+nuts_params">nuts_params()</a></code>. The colors, shapes, and sizes of the
superimposed points can be customized using the <code>np_style</code> argument.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_np_style">np_style</code></td>
<td>
<p>If <code>np</code> is specified, <code>np_style</code> can be a call to
the <code>scatter_style_np()</code> helper function (for <code>mcmc_scatter()</code>) or
the <code>pairs_style_np()</code> helper function (for <code>mcmc_pairs()</code>) to specify
arguments controlling the appearance of superimposed points representing
NUTS diagnostic information. (Note: for <code>pairs_style_np()</code> the
<code>size</code> arguments are interpreted as scaling factors).</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_bins">bins</code>, <code id="MCMC-scatterplots_+3A_binwidth">binwidth</code></td>
<td>
<p>For <code>mcmc_hex()</code>, an optional numeric vector of
<em>length two</em> passed to <code><a href="ggplot2.html#topic+geom_hex">ggplot2::geom_hex()</a></code> to override the
default binwidth in both the vertical and horizontal directions.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_diag_fun">diag_fun</code>, <code id="MCMC-scatterplots_+3A_off_diag_fun">off_diag_fun</code></td>
<td>
<p>For <code>mcmc_pairs()</code>, the plotting function to
use for the plots along the diagonal and for the off-diagonal plots,
respectively. Currently <code>diag_fun</code> can be <code>"hist"</code> for histogram
or <code>"dens"</code> for density, and <code>off_diag_fun</code> can be
<code>"scatter"</code> for scatterplot or <code>"hex"</code> for a hexagonal heatmap.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_diag_args">diag_args</code>, <code id="MCMC-scatterplots_+3A_off_diag_args">off_diag_args</code></td>
<td>
<p>For <code>mcmc_pairs()</code>, optional named lists of
arguments to pass to the functions implied by the <code>diag_fun</code> and
<code>off_diag_fun</code> arguments, respectively. For example, if
<code>off_diag_fun</code> is <code>"scatter"</code> then <code>off_diag_args</code> could
include optional arguments to <code>mcmc_scatter()</code> like <code>size</code> and
<code>alpha</code>.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_condition">condition</code></td>
<td>
<p>For <code>mcmc_pairs()</code>, a call to the <code>pairs_condition()</code>
helper function, which is used to specify a criterion for determining which
chains (or iterations) are shown in the plots above the diagonal and which
are shown in the plots below the diagonal. The histograms (or density
plots) along the diagonal are always made using all chains and iterations,
but the scatterplots (or hex plots) above and below the diagonal show
different combinations of chains/iterations depending on <code>condition</code>.
The default is a call to <code>pairs_condition()</code> with none of its arguments
specified. In this case half of the chains (or roughly half if there are an
odd number) will be used in the plots above the diagonal and the rest in
the plots below the diagonal. The <code>chains</code>, <code>draws</code>, and
<code>nuts</code> arguments to <code>pairs_condition()</code>, which are documented
below, can be used to change this default.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_lp">lp</code></td>
<td>
<p>For <code>mcmc_pairs()</code>, a molten data frame of draws of the
log-posterior or, more commonly, of a quantity equal to the log-posterior
up to a constant. <code>lp</code> should either be created via
<code><a href="#topic+log_posterior">log_posterior()</a></code> or be an object with the same form as the
object returned by <code><a href="#topic+log_posterior">log_posterior()</a></code>.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_max_treedepth">max_treedepth</code></td>
<td>
<p>For <code>mcmc_pairs()</code>, an integer representing the
maximum treedepth allowed when fitting the model (if fit using NUTS). This
is only needed for detecting which transitions (if any) hit the maximum
treedepth.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_grid_args">grid_args</code>, <code id="MCMC-scatterplots_+3A_save_gg_objects">save_gg_objects</code></td>
<td>
<p>For <code>mcmc_pairs()</code>, arguments to pass to
<code><a href="#topic+bayesplot_grid">bayesplot_grid()</a></code>. For example, since <code>mcmc_pairs()</code> returns
more than a single ggplot object, using <code><a href="ggplot2.html#topic+ggtitle">ggtitle()</a></code> afterwards
will not work. But you you can still add a title to the plot using
<code>grid_args = list(top="My title")</code>.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_div_color">div_color</code>, <code id="MCMC-scatterplots_+3A_div_shape">div_shape</code>, <code id="MCMC-scatterplots_+3A_div_size">div_size</code>, <code id="MCMC-scatterplots_+3A_div_alpha">div_alpha</code>, <code id="MCMC-scatterplots_+3A_td_color">td_color</code>, <code id="MCMC-scatterplots_+3A_td_shape">td_shape</code>, <code id="MCMC-scatterplots_+3A_td_size">td_size</code>, <code id="MCMC-scatterplots_+3A_td_alpha">td_alpha</code></td>
<td>
<p>Optional arguments to the <code>scatter_style_np()</code> or <code>pairs_style_np()</code>
helper functions that are eventually passed to
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>.The default values are displayed in the
<strong>Usage</strong> section above.</p>
</td></tr>
<tr><td><code id="MCMC-scatterplots_+3A_chains">chains</code>, <code id="MCMC-scatterplots_+3A_draws">draws</code>, <code id="MCMC-scatterplots_+3A_nuts">nuts</code></td>
<td>
<p>Optional arguments to the <code>pairs_condition()</code>
helper function, which is used to specify the <code>condition</code> argument for
<code>mcmc_pairs()</code>.
</p>

<ul>
<li><p> The <code>chains</code> argument can be used to select some subset of the
chains. If <code>chains</code> is an integer vector then the behavior is the same
as the default (half the chains above the diagonal and half below) except
using only the specified subset of chains. Alternatively, <code>chains</code> can
be a list of two integer vectors with the first specifying the chains to be
shown in the plots above the diagonal and the second for below the
diagonal.
</p>
</li>
<li><p> The <code>draws</code> argument to <code>pairs_condition()</code> can be used to
directly specify which realizations are plotted above and below the
diagonal. <code>draws</code> can be a single proportion, which is interpreted as
the proportion of realizations (among all chains) to plot in the lower
panel starting with the first realization in each chain, with the
complement (from the end of each chain) plotted in the upper panel.
Alternatively <code>draws</code> can be a logical vector with length equal to the
product of the number of iterations and the number of chains, in which case
realizations corresponding to <code>FALSE</code> and <code>TRUE</code> will be plotted
in the lower and upper panels, respectively.
</p>
</li>
<li><p> For models fit using NUTS, the <code>nuts</code> argument to
<code>pairs_condition()</code> can be used. It takes a (possibly abbreviated)
string to select among <code>"accept_stat__"</code>, <code>"stepsize__"</code>,
<code>"treedepth__"</code>, <code>"n_leapfrog__"</code>, <code>"divergent__"</code>,
<code>"energy__"</code>, and <code>"lp__"</code>. These are the sampler parameters
associated with <code><a href="#topic+NUTS">NUTS()</a></code> (and <code>"lp__"</code> is the log-posterior
up to an additive constant). In this case, plots below the diagonal will
contain realizations that are below the median of the indicated variable
(or are zero in the case of <code>"divergent__"</code>), and plots above the
diagonal will contain realizations that are greater than or equal to the
median of the indicated variable (or are one in the case of
<code>"divergent__"</code>). If <code>"lp__"</code> is used then the <code>lp</code>
argument to <code>mcmc_pairs</code> must also be specified. For the other NUTS
parameters the <code>np</code> argument to <code>mcmc_pairs()</code> must also be
specified.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mcmc_scatter()</code> and <code>mcmc_hex()</code> return a ggplot object that
can be further customized using the <strong>ggplot2</strong> package.
</p>
<p><code>mcmc_pairs()</code> returns many ggplot objects organized into a grid via
<code><a href="#topic+bayesplot_grid">bayesplot_grid()</a></code>.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>mcmc_scatter()</code></dt><dd>
<p>Bivariate scatterplot of posterior draws. If using a very large number of
posterior draws then <code>mcmc_hex()</code> may be preferable to avoid
overplotting. For models fit using <a href="#topic+NUTS">NUTS</a> the <code>np</code>,
and <code>np_style</code> arguments can be used to add additional information in
the plot (in this case the approximate location of divergences).
For more on why the scatter plot with divergences is a useful
diagnostic tool see <a href="https://github.com/jgabry/bayes-vis-paper#readme">Gabry et al. (2019)</a>.
</p>
</dd>
<dt><code>mcmc_hex()</code></dt><dd>
<p>Hexagonal heatmap of 2-D bin counts. This plot is useful in cases where
the posterior sample size is large enough that <code>mcmc_scatter()</code> suffers
from overplotting.
</p>
</dd>
<dt><code>mcmc_pairs()</code></dt><dd>
<p>A square plot matrix with univariate marginal distributions along the
diagonal (as histograms or kernel density plots) and bivariate
distributions off the diagonal (as scatterplots or hex heatmaps).
</p>
<p>For the off-diagonal plots, the default is to split the chains so that
(roughly) half are displayed above the diagonal and half are below (all
chains are always merged together for the plots along the diagonal). Other
possibilities are available by setting the <code>condition</code> argument.
</p>
<p>Additionally, extra diagnostic information for models fit using
<a href="#topic+NUTS">NUTS</a> can be added to the pairs plot using the <code>lp</code>,
<code>np</code>, and <code>np_style</code> arguments. If <code>np</code> is specified (and
<code>condition</code> is <em>not</em> <code>"divergent__"</code>), then points (red, by
default) will be superimposed onto the off-diagonal plots indicating which
(if any) iterations encountered a divergent transition. Also, if both
<code>np</code> and <code>max_treedepth</code> are specified then points (yellow, by
default) will be superimposed to indicate a transition that hit the
maximum treedepth rather than terminated its evolution normally. The
<code>np_style</code> argument can be used with the <code>pairs_style_np()</code>
convenience function to change the appearance of these overlaid points.
See the <strong>Examples</strong> section.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>


<h3>See Also</h3>

<p>Other MCMC: 
<code><a href="#topic+MCMC-combos">MCMC-combos</a></code>,
<code><a href="#topic+MCMC-diagnostics">MCMC-diagnostics</a></code>,
<code><a href="#topic+MCMC-distributions">MCMC-distributions</a></code>,
<code><a href="#topic+MCMC-intervals">MCMC-intervals</a></code>,
<code><a href="#topic+MCMC-nuts">MCMC-nuts</a></code>,
<code><a href="#topic+MCMC-overview">MCMC-overview</a></code>,
<code><a href="#topic+MCMC-parcoord">MCMC-parcoord</a></code>,
<code><a href="#topic+MCMC-recover">MCMC-recover</a></code>,
<code><a href="#topic+MCMC-traces">MCMC-traces</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("ggplot2")

# some parameter draws to use for demonstration
x &lt;- example_mcmc_draws(params = 6)
dimnames(x)

# scatterplot of alpha vs log(sigma)
color_scheme_set("teal")
(p &lt;- mcmc_scatter(x, pars = c("alpha", "sigma"),
                  transform = list(sigma = "log")))
p +
  labs(
    title = "Insert your own headline-grabbing title",
    subtitle = "with a provocative subtitle",
    caption = "and a controversial caption",
    x = expression(alpha),
    y = expression(log(sigma))
   )

# add ellipse
p + stat_ellipse(level = 0.9, color = "gray20", size = 1)

# add contour
color_scheme_set("red")
p2 &lt;- mcmc_scatter(x, pars = c("alpha", "sigma"), size = 3.5, alpha = 0.25)
p2 + stat_density_2d(color = "black", size = .5)

# can also add lines/smooths
color_scheme_set("pink")
(p3 &lt;- mcmc_scatter(x, pars = c("alpha", "beta[3]"), alpha = 0.25, size = 3))
p3 + geom_smooth(method = "lm", se = FALSE, color = "gray20",
                 size = .75, linetype = 2)


if (requireNamespace("hexbin", quietly = TRUE)) {
 # hexagonal heatmap
 color_scheme_set("brightblue")
 (p &lt;- mcmc_hex(x, pars = c("sigma", "alpha"), transform = list(sigma = "log")))
 p + plot_bg(fill = "gray95")
 p + plot_bg(fill = "gray95") + panel_bg(fill = "gray70")
}


color_scheme_set("purple")

# pairs plots
# default of condition=NULL implies splitting chains between upper and lower panels
mcmc_pairs(x, pars = "alpha", regex_pars = "beta\\[[1,4]\\]",
           off_diag_args = list(size = 1, alpha = 0.5))

# change to density plots instead of histograms and hex plots instead of
# scatterplots
mcmc_pairs(x, pars = "alpha", regex_pars = "beta\\[[1,4]\\]",
           diag_fun = "dens", off_diag_fun = "hex")

# plot chain 1 above diagonal and chains 2, 3, and 4 below
color_scheme_set("brightblue")
mcmc_pairs(x, pars = "alpha", regex_pars = "beta\\[[1,4]\\]",
           diag_fun = "dens", off_diag_fun = "hex",
           condition = pairs_condition(chains = list(1, 2:4)))


## Not run: 
### Adding NUTS diagnostics to scatterplots and pairs plots

# examples using rstanarm package
library(rstanarm)

# for demonstration purposes, intentionally fit a model that
# will (almost certainly) have some divergences
fit &lt;- stan_glm(
  mpg ~ ., data = mtcars,
  iter = 1000, refresh = 0,
  # this combo of prior and adapt_delta should lead to some divergences
  prior = hs(),
  adapt_delta = 0.9
)
posterior &lt;- as.array(fit)
np &lt;- nuts_params(fit)

# mcmc_scatter with divergences highlighted
color_scheme_set("brightblue")
mcmc_scatter(posterior, pars = c("wt", "sigma"), np = np)

color_scheme_set("darkgray")
div_style &lt;- scatter_style_np(div_color = "green", div_shape = 4, div_size = 4)
mcmc_scatter(posterior, pars = c("sigma", "(Intercept)"),
             np = np, np_style = div_style)

# split the draws according to above/below median accept_stat__
# and show approximate location of divergences (red points)
color_scheme_set("brightblue")
mcmc_pairs(
  posterior,
  pars = c("wt", "cyl", "sigma"),
  off_diag_args = list(size = 1, alpha = 1/3),
  condition = pairs_condition(nuts = "accept_stat__"),
  np = np
)

# more customizations:
# - transform sigma to log(sigma)
# - median log-posterior as 'condition'
# - hex instead of scatter for off-diagonal plots
# - show points where max treedepth hit in blue
color_scheme_set("darkgray")
mcmc_pairs(
  posterior,
  pars = c("wt", "cyl", "sigma"),
  transform = list(sigma = "log"),
  off_diag_fun = "hex",
  condition = pairs_condition(nuts = "lp__"),
  lp = log_posterior(fit),
  np = np,
  np_style = pairs_style_np(div_color = "firebrick",
                            td_color = "blue",
                            td_size = 2),
  # for demonstration purposes, set max_treedepth to a value that will
  # result in at least a few max treedepth warnings
  max_treedepth = with(np, -1 + max(Value[Parameter == "treedepth__"]))
)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMC-traces'>Trace and rank plots of MCMC draws</h2><span id='topic+MCMC-traces'></span><span id='topic+mcmc_trace'></span><span id='topic+mcmc_trace_highlight'></span><span id='topic+trace_style_np'></span><span id='topic+mcmc_rank_overlay'></span><span id='topic+mcmc_rank_hist'></span><span id='topic+mcmc_rank_ecdf'></span><span id='topic+mcmc_trace_data'></span>

<h3>Description</h3>

<p>Trace and rank plots of MCMC draws. See the <strong>Plot Descriptions</strong>
section, below, for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_trace(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  facet_args = list(),
  n_warmup = 0,
  iter1 = 0,
  window = NULL,
  size = NULL,
  np = NULL,
  np_style = trace_style_np(),
  divergences = NULL
)

mcmc_trace_highlight(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  facet_args = list(),
  n_warmup = 0,
  window = NULL,
  size = NULL,
  alpha = 0.2,
  highlight = 1
)

trace_style_np(div_color = "red", div_size = 0.25, div_alpha = 1)

mcmc_rank_overlay(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  facet_args = list(),
  ...,
  n_bins = 20,
  ref_line = FALSE
)

mcmc_rank_hist(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  facet_args = list(),
  n_bins = 20,
  ref_line = FALSE
)

mcmc_rank_ecdf(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  K = NULL,
  facet_args = list(),
  prob = 0.99,
  plot_diff = FALSE,
  interpolate_adj = NULL
)

mcmc_trace_data(
  x,
  pars = character(),
  regex_pars = character(),
  transformations = list(),
  ...,
  highlight = NULL,
  n_warmup = 0,
  iter1 = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMC-traces_+3A_x">x</code></td>
<td>
<p>An object containing MCMC draws:
</p>

<ul>
<li><p> A 3-D array, matrix, list of matrices, or data frame. The <a href="#topic+MCMC-overview">MCMC-overview</a>
page provides details on how to specify each these.
</p>
</li>
<li><p> A <code>draws</code> object from the <span class="pkg"><a href="posterior.html#topic+posterior">posterior</a></span> package (e.g.,
<code>draws_array</code>, <code>draws_rvars</code>, etc.).
</p>
</li>
<li><p> An object with an <code>as.array()</code> method that returns the same kind of 3-D
array described on the <a href="#topic+MCMC-overview">MCMC-overview</a> page.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names. If neither
<code>pars</code> nor <code>regex_pars</code> is specified then the default is to use <em>all</em>
parameters. As of version <code style="white-space: pre;">&#8288;1.7.0&#8288;</code>, <strong>bayesplot</strong> also supports 'tidy'
parameter selection by specifying <code>pars = vars(...)</code>, where <code>...</code> is
specified the same way as in <a href="dplyr.html#topic+select">dplyr::select(...)</a> and
similar functions. Examples of using <code>pars</code> in this way can be found on the
<a href="#topic+tidy-params">Tidy parameter selection</a> page.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional <a href="base.html#topic+grep">regular expression</a> to use for
parameter selection. Can be specified instead of <code>pars</code> or in addition to
<code>pars</code>. When using <code>pars</code> for tidy parameter selection, the <code>regex_pars</code>
argument is ignored since <a href="tidyselect.html#topic+language">select helpers</a>
perform a similar function.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_transformations">transformations</code></td>
<td>
<p>Optionally, transformations to apply to parameters
before plotting. If <code>transformations</code> is a function or a single string
naming a function then that function will be used to transform all
parameters. To apply transformations to particular parameters, the
<code>transformations</code> argument can be a named list with length equal to
the number of parameters to be transformed. Currently only univariate
transformations of scalar parameters can be specified (multivariate
transformations will be implemented in a future release). If
<code>transformations</code> is a list, the name of each list element should be a
parameter name and the content of each list element should be a function
(or any item to match as a function via <code><a href="base.html#topic+match.fun">match.fun()</a></code>, e.g. a
string naming a function). If a function is specified by its name as a
string (e.g. <code>"log"</code>), then it can be used to construct a new
parameter label for the appropriate parameter (e.g. <code>"log(sigma)"</code>).
If a function itself is specified
(e.g. <code>log</code> or <code>function(x) log(x)</code>)
then <code>"t"</code> is used in the new parameter label to indicate that the
parameter is transformed (e.g. <code>"t(sigma)"</code>).
</p>
<p>Note: due to partial argument matching <code>transformations</code> can be
abbreviated for convenience in interactive use (e.g., <code>transform</code>).</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_facet_args">facet_args</code></td>
<td>
<p>A named list of arguments (other than <code>facets</code>) passed
to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> or <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>
to control faceting. Note: if <code>scales</code> is not included in <code>facet_args</code>
then <strong>bayesplot</strong> may use <code>scales="free"</code> as the default (depending
on the plot) instead of the <strong>ggplot2</strong> default of <code>scales="fixed"</code>.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_n_warmup">n_warmup</code></td>
<td>
<p>An integer; the number of warmup iterations included in
<code>x</code>. The default is <code>n_warmup = 0</code>, i.e. to assume no warmup
iterations are included. If <code>n_warmup &gt; 0</code> then the background for
iterations <code>1:n_warmup</code> is shaded gray.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_iter1">iter1</code></td>
<td>
<p>An integer; the iteration number of the first included draw
(default is <code>0</code>). This can be used to make it more obvious that the warmup
iterations have been discarded from the traceplot. It cannot be specified
if <code>n_warmup</code> is also set to a positive value.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_window">window</code></td>
<td>
<p>An integer vector of length two specifying the limits of a
range of iterations to display.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_size">size</code></td>
<td>
<p>An optional value to override the default line size
for <code>mcmc_trace()</code> or the default point size for <code>mcmc_trace_highlight()</code>.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_np">np</code></td>
<td>
<p>For models fit using <a href="#topic+NUTS">NUTS</a> (more generally, any
<a href="https://en.wikipedia.org/wiki/Symplectic_integrator">symplectic integrator</a>),
an optional data frame providing NUTS diagnostic information. The data
frame should be the object returned by <code><a href="#topic+nuts_params">nuts_params()</a></code> or one with the same
structure. If <code>np</code> is specified then tick marks are added to the bottom of
the trace plot indicating within which iterations there was a divergence
(if there were any). See the end of the <strong>Examples</strong> section, below.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_np_style">np_style</code></td>
<td>
<p>A call to the <code>trace_style_np()</code> helper function to
specify arguments controlling the appearance of tick marks representing
divergences (if the <code>np</code> argument is specified).</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_divergences">divergences</code></td>
<td>
<p>Deprecated. Use the <code>np</code> argument instead.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_alpha">alpha</code></td>
<td>
<p>For <code>mcmc_trace_highlight()</code>, passed to
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> to control the transparency of the points
for the chains not highlighted.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_highlight">highlight</code></td>
<td>
<p>For <code>mcmc_trace_highlight()</code>, an integer specifying one
of the chains that will be more visible than the others in the plot.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_div_color">div_color</code>, <code id="MCMC-traces_+3A_div_size">div_size</code>, <code id="MCMC-traces_+3A_div_alpha">div_alpha</code></td>
<td>
<p>Optional arguments to the
<code>trace_style_np()</code> helper function that are eventually passed to
<code><a href="ggplot2.html#topic+geom_rug">ggplot2::geom_rug()</a></code> if the <code>np</code> argument is also specified. They control
the color, size, and transparency specifications for showing divergences in
the plot. The default values are displayed in the <strong>Usage</strong> section above.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_n_bins">n_bins</code></td>
<td>
<p>For the rank plots, the number of bins to use for the histogram
of rank-normalized MCMC samples. Defaults to <code>20</code>.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_ref_line">ref_line</code></td>
<td>
<p>For the rank plots, whether to draw a horizontal line at the
average number of ranks per bin. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_k">K</code></td>
<td>
<p>An optional integer defining the number of equally spaced evaluation
points for the PIT-ECDF. Reducing K when using <code>interpolate_adj = FALSE</code>
makes computing the confidence bands faster. For <code>ppc_pit_ecdf</code> and
<code>ppc_pit_ecdf_grouped</code>, if PIT values are supplied, defaults to
<code>length(pit)</code>, otherwise yrep determines the maximum accuracy of the
estimated PIT values and <code>K</code> is set to <code>min(nrow(yrep) + 1, 1000)</code>. For
<code>mcmc_rank_ecdf</code>, defaults to the number of iterations per chain in <code>x</code>.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_prob">prob</code></td>
<td>
<p>For <code>mcmc_rank_ecdf()</code>, a value between 0 and 1
specifying the desired simultaneous confidence of the confidence bands to be
drawn for the rank ECDF plots.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_plot_diff">plot_diff</code></td>
<td>
<p>For <code>mcmc_rank_ecdf()</code>, a boolean specifying if the
difference between the observed rank ECDFs and the theoretical expectation
should be drawn instead of the unmodified rank ECDF plots.</p>
</td></tr>
<tr><td><code id="MCMC-traces_+3A_interpolate_adj">interpolate_adj</code></td>
<td>
<p>A boolean defining if the simultaneous confidence
bands should be interpolated based on precomputed values rather than
computed exactly. Computing the bands may be computationally intensive and
the approximation gives a fast method for assessing the ECDF trajectory.
The default is to use interpolation if <code>K</code> is greater than 200.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">&#8288;_data()&#8288;</code> return the data that would have been drawn by the plotting
function.
</p>
<p><code>mcmc_trace_data()</code> returns the data for the trace <em>and</em> rank plots
in the same data frame.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>mcmc_trace()</code></dt><dd>
<p>Standard trace plots of MCMC draws. For models fit using <a href="#topic+NUTS">NUTS</a>,
the <code>np</code> argument can be used to also show divergences on the trace plot.
</p>
</dd>
<dt><code>mcmc_trace_highlight()</code></dt><dd>
<p>Traces are plotted using points rather than lines and the opacity of all
chains but one (specified by the <code>highlight</code> argument) is reduced.
</p>
</dd>
<dt><code>mcmc_rank_hist()</code></dt><dd>
<p>Whereas traditional trace plots visualize how the chains mix over the
course of sampling, rank histograms visualize how the values
from the chains mix together in terms of ranking. An ideal plot would
show the rankings mixing or overlapping in a uniform distribution.
See Vehtari et al. (2019) for details.
</p>
</dd>
<dt><code>mcmc_rank_overlay()</code></dt><dd>
<p>Ranks from <code>mcmc_rank_hist()</code> are plotted using overlaid lines in a
single panel.
</p>
</dd>
<dt><code>mcmc_rank_ecdf()</code></dt><dd>
<p>The ECDFs of the ranks from <code>mcmc_rank_hist()</code> are plotted with the
simultaneous confidence bands with a coverage determined by <code>prob</code>, that
is, bands that completely cover all of the rank ECDFs with the probability
<code>prob</code>. If <code>plot_diff = TRUE</code>, the difference between the observed rank
ECDFs and the theoretical expectation for samples originating from the
same distribution is drawn. See Säilynoja et al. (2021) for details.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Vehtari, A., Gelman, A., Simpson, D., Carpenter, B., Bürkner, P.
(2019). Rank-normalization, folding, and localization: An improved <em>R</em>-hat
for assessing convergence of MCMC. <a href="https://arxiv.org/abs/1903.08008">arXiv preprint</a>.
</p>
<p>Säilynoja, T., Bürkner, P., Vehtari, A.
(2021). Graphical Test for Discrete Uniformity and its Applications in
Goodness of Fit Evaluation and Multiple Sample Comparison <a href="https://arxiv.org/abs/2103.10522">arXiv preprint</a>.
</p>


<h3>See Also</h3>

<p>Other MCMC: 
<code><a href="#topic+MCMC-combos">MCMC-combos</a></code>,
<code><a href="#topic+MCMC-diagnostics">MCMC-diagnostics</a></code>,
<code><a href="#topic+MCMC-distributions">MCMC-distributions</a></code>,
<code><a href="#topic+MCMC-intervals">MCMC-intervals</a></code>,
<code><a href="#topic+MCMC-nuts">MCMC-nuts</a></code>,
<code><a href="#topic+MCMC-overview">MCMC-overview</a></code>,
<code><a href="#topic+MCMC-parcoord">MCMC-parcoord</a></code>,
<code><a href="#topic+MCMC-recover">MCMC-recover</a></code>,
<code><a href="#topic+MCMC-scatterplots">MCMC-scatterplots</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some parameter draws to use for demonstration
x &lt;- example_mcmc_draws(chains = 4, params = 6)
dim(x)
dimnames(x)

# trace plots of the betas
color_scheme_set("viridis")
mcmc_trace(x, regex_pars = "beta")

color_scheme_set("viridisA")
mcmc_trace(x, regex_pars = "beta")

color_scheme_set("viridisC")
mcmc_trace(x, regex_pars = "beta")


# mix color schemes
color_scheme_set("mix-blue-red")
mcmc_trace(x, regex_pars = "beta")

# use traditional ggplot discrete color scale
mcmc_trace(x, pars = c("alpha", "sigma")) +
 ggplot2::scale_color_discrete()

# zoom in on a window of iterations, increase line size,
# add tick marks, move legend to the top, add gray background
color_scheme_set("viridisA")
mcmc_trace(x[,, 1:4], window = c(100, 130), size = 1) +
  panel_bg(fill = "gray90", color = NA) +
  legend_move("top")

# Rank-normalized histogram plots. Instead of showing how chains mix over
# time, look at how the ranking of MCMC samples mixed between chains.
color_scheme_set("viridisE")
mcmc_rank_hist(x, "alpha")
mcmc_rank_hist(x, pars = c("alpha", "sigma"), ref_line = TRUE)
mcmc_rank_overlay(x, "alpha")

# ECDF and ECDF difference plots of the ranking of MCMC samples between chains.
# Provide 99% simultaneous confidence intervals for the chains sampling from
# the same distribution.
mcmc_rank_ecdf(x, prob = 0.99)
mcmc_rank_ecdf(x, prob = 0.99, plot_diff = TRUE)

## Not run: 
# parse facet label text
color_scheme_set("purple")
p &lt;- mcmc_trace(
  x,
  regex_pars = "beta\\[[1,3]\\]",
  facet_args = list(labeller = ggplot2::label_parsed)
)
p + facet_text(size = 15)

# mark first 100 draws as warmup
mcmc_trace(x, n_warmup = 100)

# plot as points, highlighting chain 2
color_scheme_set("brightblue")
mcmc_trace_highlight(x, pars = "sigma", highlight = 2, size = 2)

# for models fit using HMC/NUTS divergences can be displayed in the trace plot
library("rstanarm")
fit &lt;- stan_glm(mpg ~ ., data = mtcars, refresh = 0,
  # next line to keep example fast and also ensure we get some divergences
                prior = hs(), iter = 400, adapt_delta = 0.8)

# extract draws using as.array (instead of as.matrix) to keep
# chains separate for trace plot
posterior &lt;- as.array(fit)

# for stanfit and stanreg objects use nuts_params() to get the divergences
mcmc_trace(posterior, pars = "sigma", np = nuts_params(fit))

color_scheme_set("viridis")
mcmc_trace(
  posterior,
  pars = c("wt", "sigma"),
  size = 0.5,
  facet_args = list(nrow = 2),
  np = nuts_params(fit),
  np_style = trace_style_np(div_color = "black", div_size = 0.5)
)

## End(Not run)

</code></pre>

<hr>
<h2 id='pp_check'>Posterior (or prior) predictive checks (S3 generic and default method)</h2><span id='topic+pp_check'></span><span id='topic+pp_check.default'></span>

<h3>Description</h3>

<p>S3 generic with simple default method. The intent is to provide a generic so
authors of other <span class="rlang"><b>R</b></span> packages who wish to provide interfaces to the functions
in <strong>bayesplot</strong> will be encouraged to include <code>pp_check()</code> methods in their
package, preserving the same naming conventions for posterior (and prior)
predictive checking across many <span class="rlang"><b>R</b></span> packages for Bayesian inference. This is
for the convenience of both users and developers. See the <strong>Details</strong> and
<strong>Examples</strong> sections, below, and the package vignettes for examples of
defining <code>pp_check()</code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_check(object, ...)

## Default S3 method:
pp_check(object, yrep, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pp_check_+3A_object">object</code></td>
<td>
<p>Typically a fitted model object. The default method, however,
takes <code>object</code> to be a <code>y</code> (outcome) vector.</p>
</td></tr>
<tr><td><code id="pp_check_+3A_...">...</code></td>
<td>
<p>For the generic, arguments passed to individual methods. For the
default method, these are additional arguments to pass to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="pp_check_+3A_yrep">yrep</code></td>
<td>
<p>For the default method, a <code>yrep</code> matrix passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="pp_check_+3A_fun">fun</code></td>
<td>
<p>For the default method, the plotting function to call. Can be any
of the <a href="#topic+PPC">PPC</a> functions. The <code>"ppc_"</code> prefix can optionally be dropped if
<code>fun</code> is specified as a string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A package that creates fitted model objects of class <code>"foo"</code>
can include a method <code>pp_check.foo()</code> that prepares the appropriate
inputs (<code>y</code>, <code>yrep</code>, etc.) for the <strong>bayesplot</strong> functions. The
<code>pp_check.foo()</code> method may, for example, let the user choose between
various plots, calling the functions from <strong>bayesplot</strong> internally as
needed. See <strong>Examples</strong>, below, and the package vignettes.
</p>


<h3>Value</h3>

<p>The exact form of the value returned by <code>pp_check()</code> may vary by
the class of <code>object</code>, but for consistency we encourage authors of
methods to return the ggplot object created by one of <strong>bayesplot</strong>'s
plotting functions. The default method returns the object returned by <code>fun</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># default method
y &lt;- example_y_data()
yrep &lt;- example_yrep_draws()
pp_check(y, yrep[1:50,], ppc_dens_overlay)

g &lt;- example_group_data()
pp_check(y, yrep, fun = "stat_grouped", group = g, stat = "median")

# defining a method
x &lt;- list(y = rnorm(50), yrep = matrix(rnorm(5000), nrow = 100, ncol = 50))
class(x) &lt;- "foo"
pp_check.foo &lt;- function(object, ..., type = c("multiple", "overlaid")) {
  y &lt;- object[["y"]]
  yrep &lt;- object[["yrep"]]
  switch(match.arg(type),
         multiple = ppc_hist(y, yrep[1:min(8, nrow(yrep)),, drop = FALSE]),
         overlaid = ppc_dens_overlay(y, yrep))
}
pp_check(x)
pp_check(x, type = "overlaid")

</code></pre>

<hr>
<h2 id='PPC-censoring'>PPC censoring</h2><span id='topic+PPC-censoring'></span><span id='topic+ppc_km_overlay'></span><span id='topic+ppc_km_overlay_grouped'></span>

<h3>Description</h3>

<p>Compare the empirical distribution of censored data <code>y</code> to the
distributions of simulated/replicated data <code>yrep</code> from the posterior
predictive distribution. See the <strong>Plot Descriptions</strong> section, below, for
details.
</p>
<p>Although some of the other <span class="pkg">bayesplot</span> plots can be used with censored
data, <code>ppc_km_overlay()</code> is currently the only plotting function designed
<em>specifically</em> for censored data. We encourage you to suggest or contribute
additional plots at
<a href="https://github.com/stan-dev/bayesplot">github.com/stan-dev/bayesplot</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppc_km_overlay(y, yrep, ..., status_y, size = 0.25, alpha = 0.7)

ppc_km_overlay_grouped(y, yrep, group, ..., status_y, size = 0.25, alpha = 0.7)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPC-censoring_+3A_y">y</code></td>
<td>
<p>A vector of observations. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="PPC-censoring_+3A_yrep">yrep</code></td>
<td>
<p>An <code>S</code> by <code>N</code> matrix of draws from the posterior (or prior)
predictive distribution. The number of rows, <code>S</code>, is the size of the
posterior (or prior) sample used to generate <code>yrep</code>. The number of columns,
<code>N</code> is the number of predicted observations (<code>length(y)</code>). The columns of
<code>yrep</code> should be in the same order as the data points in <code>y</code> for the plots
to make sense. See the <strong>Details</strong> and <strong>Plot Descriptions</strong> sections for
additional advice specific to particular plots.</p>
</td></tr>
<tr><td><code id="PPC-censoring_+3A_...">...</code></td>
<td>
<p>Currently only used internally.</p>
</td></tr>
<tr><td><code id="PPC-censoring_+3A_status_y">status_y</code></td>
<td>
<p>The status indicator for the observations from <code>y</code>. This must
be a numeric vector of the same length as <code>y</code> with values in {0, 1} (0 =
right censored, 1 = event).</p>
</td></tr>
<tr><td><code id="PPC-censoring_+3A_size">size</code>, <code id="PPC-censoring_+3A_alpha">alpha</code></td>
<td>
<p>Passed to the appropriate geom to control the appearance of
the <code>yrep</code> distributions.</p>
</td></tr>
<tr><td><code id="PPC-censoring_+3A_group">group</code></td>
<td>
<p>A grouping variable of the same length as <code>y</code>.
Will be coerced to <a href="base.html#topic+factor">factor</a> if not already a factor.
Each value in <code>group</code> is interpreted as the group level pertaining
to the corresponding observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object that can be further customized using the <strong>ggplot2</strong> package.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>ppc_km_overlay()</code></dt><dd>
<p>Empirical CCDF estimates of each dataset (row) in <code>yrep</code> are overlaid,
with the Kaplan-Meier estimate (Kaplan and Meier, 1958) for <code>y</code> itself on
top (and in a darker shade). This is a PPC suitable for right-censored
<code>y</code>. Note that the replicated data from <code>yrep</code> is assumed to be
uncensored.
</p>
</dd>
<dt><code>ppc_km_overlay_grouped()</code></dt><dd>
<p>The same as <code>ppc_km_overlay()</code>, but with separate facets by <code>group</code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. (Ch. 6)
</p>
<p>Kaplan, E. L. and Meier, P. (1958). Nonparametric estimation
from incomplete observations.
<em>Journal of the American Statistical Association</em>. 53(282), 457&ndash;481.
doi:10.1080/01621459.1958.10501452.
</p>


<h3>See Also</h3>

<p>Other PPCs: 
<code><a href="#topic+PPC-discrete">PPC-discrete</a></code>,
<code><a href="#topic+PPC-distributions">PPC-distributions</a></code>,
<code><a href="#topic+PPC-errors">PPC-errors</a></code>,
<code><a href="#topic+PPC-intervals">PPC-intervals</a></code>,
<code><a href="#topic+PPC-loo">PPC-loo</a></code>,
<code><a href="#topic+PPC-overview">PPC-overview</a></code>,
<code><a href="#topic+PPC-scatterplots">PPC-scatterplots</a></code>,
<code><a href="#topic+PPC-test-statistics">PPC-test-statistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>color_scheme_set("brightblue")
y &lt;- example_y_data()
# For illustrative purposes, (right-)censor values y &gt; 110:
status_y &lt;- as.numeric(y &lt;= 110)
y &lt;- pmin(y, 110)
# In reality, the replicated data (yrep) would be obtained from a
# model which takes the censoring of y properly into account. Here,
# for illustrative purposes, we simply use example_yrep_draws():
yrep &lt;- example_yrep_draws()
dim(yrep)

ppc_km_overlay(y, yrep[1:25, ], status_y = status_y)

# With separate facets by group:
group &lt;- example_group_data()

ppc_km_overlay_grouped(y, yrep[1:25, ], group = group, status_y = status_y)

</code></pre>

<hr>
<h2 id='PPC-discrete'>PPCs for discrete outcomes</h2><span id='topic+PPC-discrete'></span><span id='topic+ppc_bars'></span><span id='topic+ppc_bars_grouped'></span><span id='topic+ppc_rootogram'></span><span id='topic+ppc_bars_data'></span>

<h3>Description</h3>

<p>Many of the <a href="#topic+PPC-overview">PPC</a> functions in <strong>bayesplot</strong> can
be used with discrete data. The small subset of these functions that can
<em>only</em> be used if <code>y</code> and <code>yrep</code> are discrete are documented
on this page. Currently these include rootograms for count outcomes and bar
plots for ordinal, categorical, and multinomial outcomes. See the
<strong>Plot Descriptions</strong> section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppc_bars(
  y,
  yrep,
  ...,
  prob = 0.9,
  width = 0.9,
  size = 1,
  fatten = 2.5,
  linewidth = 1,
  freq = TRUE
)

ppc_bars_grouped(
  y,
  yrep,
  group,
  ...,
  facet_args = list(),
  prob = 0.9,
  width = 0.9,
  size = 1,
  fatten = 2.5,
  linewidth = 1,
  freq = TRUE
)

ppc_rootogram(
  y,
  yrep,
  style = c("standing", "hanging", "suspended"),
  ...,
  prob = 0.9,
  size = 1
)

ppc_bars_data(y, yrep, group = NULL, prob = 0.9, freq = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPC-discrete_+3A_y">y</code></td>
<td>
<p>A vector of observations. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="PPC-discrete_+3A_yrep">yrep</code></td>
<td>
<p>An <code>S</code> by <code>N</code> matrix of draws from the posterior (or prior)
predictive distribution. The number of rows, <code>S</code>, is the size of the
posterior (or prior) sample used to generate <code>yrep</code>. The number of columns,
<code>N</code> is the number of predicted observations (<code>length(y)</code>). The columns of
<code>yrep</code> should be in the same order as the data points in <code>y</code> for the plots
to make sense. See the <strong>Details</strong> and <strong>Plot Descriptions</strong> sections for
additional advice specific to particular plots.</p>
</td></tr>
<tr><td><code id="PPC-discrete_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="PPC-discrete_+3A_prob">prob</code></td>
<td>
<p>A value between <code>0</code> and <code>1</code> indicating the desired probability
mass to include in the <code>yrep</code> intervals. Set <code>prob=0</code> to remove the
intervals. (Note: for rootograms these are intervals of the <em>square roots</em>
of the expected counts.)</p>
</td></tr>
<tr><td><code id="PPC-discrete_+3A_width">width</code></td>
<td>
<p>For bar plots only, passed to <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code> to control
the bar width.</p>
</td></tr>
<tr><td><code id="PPC-discrete_+3A_size">size</code>, <code id="PPC-discrete_+3A_fatten">fatten</code>, <code id="PPC-discrete_+3A_linewidth">linewidth</code></td>
<td>
<p>For bar plots, <code>size</code>, <code>fatten</code>, and <code>linewidth</code>
are passed to <code><a href="ggplot2.html#topic+geom_linerange">ggplot2::geom_pointrange()</a></code> to control the appearance of the
<code>yrep</code> points and intervals. For rootograms <code>size</code> is passed to
<code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>.</p>
</td></tr>
<tr><td><code id="PPC-discrete_+3A_freq">freq</code></td>
<td>
<p>For bar plots only, if <code>TRUE</code> (the default) the y-axis will
display counts. Setting <code>freq=FALSE</code> will put proportions on the y-axis.</p>
</td></tr>
<tr><td><code id="PPC-discrete_+3A_group">group</code></td>
<td>
<p>A grouping variable of the same length as <code>y</code>.
Will be coerced to <a href="base.html#topic+factor">factor</a> if not already a factor.
Each value in <code>group</code> is interpreted as the group level pertaining
to the corresponding observation.</p>
</td></tr>
<tr><td><code id="PPC-discrete_+3A_facet_args">facet_args</code></td>
<td>
<p>An optional list of  arguments (other than <code>facets</code>)
passed to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> to control faceting.</p>
</td></tr>
<tr><td><code id="PPC-discrete_+3A_style">style</code></td>
<td>
<p>For <code>ppc_rootogram</code>, a string specifying the rootogram
style. The options are <code>"standing"</code>, <code>"hanging"</code>, and
<code>"suspended"</code>. See the <strong>Plot Descriptions</strong> section, below, for
details on the different styles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all of these plots <code>y</code> and <code>yrep</code> must be integers, although
they need not be integers in the strict sense of <span class="rlang"><b>R</b></span>'s
<a href="base.html#topic+integer">integer</a> type. For rootogram plots <code>y</code> and <code>yrep</code> must also
be non-negative.
</p>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">&#8288;_data()&#8288;</code> return the data that would have been drawn by the plotting
function.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>ppc_bars()</code></dt><dd>
<p>Bar plot of <code>y</code> with <code>yrep</code> medians and uncertainty intervals
superimposed on the bars.
</p>
</dd>
<dt><code>ppc_bars_grouped()</code></dt><dd>
<p>Same as <code>ppc_bars()</code> but a separate plot (facet) is generated for each
level of a grouping variable.
</p>
</dd>
<dt><code>ppc_rootogram()</code></dt><dd>
<p>Rootograms allow for diagnosing problems in count data models such as
overdispersion or excess zeros. They consist of a histogram of <code>y</code> with the
expected counts based on <code>yrep</code> overlaid as a line along with uncertainty
intervals. The y-axis represents the square roots of the counts to
approximately adjust for scale differences and thus ease comparison between
observed and expected counts. Using the <code>style</code> argument, the histogram
style can be adjusted to focus on different aspects of the data:
</p>

<ul>
<li> <p><em>Standing</em>: basic histogram of observed counts with curve
showing expected counts.
</p>
</li>
<li> <p><em>Hanging</em>: observed counts counts hanging from the curve
representing expected counts.
</p>
</li>
<li> <p><em>Suspended</em>: histogram of the differences between expected and
observed counts.
</p>
</li></ul>

<p><strong>All of the rootograms are plotted on the square root scale</strong>. See Kleiber
and Zeileis (2016) for advice on interpreting rootograms and selecting
among the different styles.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Kleiber, C. and Zeileis, A. (2016).
Visualizing count data regressions using rootograms.
<em>The American Statistician</em>. 70(3): 296&ndash;303.
<a href="https://arxiv.org/abs/1605.01311">https://arxiv.org/abs/1605.01311</a>.
</p>


<h3>See Also</h3>

<p>Other PPCs: 
<code><a href="#topic+PPC-censoring">PPC-censoring</a></code>,
<code><a href="#topic+PPC-distributions">PPC-distributions</a></code>,
<code><a href="#topic+PPC-errors">PPC-errors</a></code>,
<code><a href="#topic+PPC-intervals">PPC-intervals</a></code>,
<code><a href="#topic+PPC-loo">PPC-loo</a></code>,
<code><a href="#topic+PPC-overview">PPC-overview</a></code>,
<code><a href="#topic+PPC-scatterplots">PPC-scatterplots</a></code>,
<code><a href="#topic+PPC-test-statistics">PPC-test-statistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(9222017)

# bar plots
f &lt;- function(N) {
  sample(1:4, size = N, replace = TRUE, prob = c(0.25, 0.4, 0.1, 0.25))
}
y &lt;- f(100)
yrep &lt;- t(replicate(500, f(100)))
dim(yrep)
group &lt;- gl(2, 50, length = 100, labels = c("GroupA", "GroupB"))

color_scheme_set("mix-pink-blue")
ppc_bars(y, yrep)

# split by group, change interval width, and display proportion
# instead of count on y-axis
color_scheme_set("mix-blue-pink")
ppc_bars_grouped(y, yrep, group, prob = 0.5, freq = FALSE)

## Not run: 
# example for ordinal regression using rstanarm
library(rstanarm)
fit &lt;- stan_polr(
  tobgp ~ agegp,
  data = esoph,
  method = "probit",
  prior = R2(0.2, "mean"),
  init_r = 0.1,
  seed = 12345,
  # cores = 4,
  refresh = 0
 )

# coded as character, so convert to integer
yrep_char &lt;- posterior_predict(fit)
print(yrep_char[1, 1:4])

yrep_int &lt;- sapply(data.frame(yrep_char, stringsAsFactors = TRUE), as.integer)
y_int &lt;- as.integer(esoph$tobgp)

ppc_bars(y_int, yrep_int)

ppc_bars_grouped(
  y = y_int,
  yrep = yrep_int,
  group = esoph$agegp,
  freq=FALSE,
  prob = 0.5,
  fatten = 1,
  size = 1.5
)

## End(Not run)

# rootograms for counts
y &lt;- rpois(100, 20)
yrep &lt;- matrix(rpois(10000, 20), ncol = 100)

color_scheme_set("brightblue")
ppc_rootogram(y, yrep)
ppc_rootogram(y, yrep, prob = 0)

ppc_rootogram(y, yrep, style = "hanging", prob = 0.8)
ppc_rootogram(y, yrep, style = "suspended")

</code></pre>

<hr>
<h2 id='PPC-distributions'>PPC distributions</h2><span id='topic+PPC-distributions'></span><span id='topic+ppc_data'></span><span id='topic+ppc_dens_overlay'></span><span id='topic+ppc_dens_overlay_grouped'></span><span id='topic+ppc_ecdf_overlay'></span><span id='topic+ppc_ecdf_overlay_grouped'></span><span id='topic+ppc_dens'></span><span id='topic+ppc_hist'></span><span id='topic+ppc_freqpoly'></span><span id='topic+ppc_freqpoly_grouped'></span><span id='topic+ppc_boxplot'></span><span id='topic+ppc_violin_grouped'></span><span id='topic+ppc_pit_ecdf'></span><span id='topic+ppc_pit_ecdf_grouped'></span>

<h3>Description</h3>

<p>Compare the empirical distribution of the data <code>y</code> to the distributions of
simulated/replicated data <code>yrep</code> from the posterior predictive distribution.
See the <strong>Plot Descriptions</strong> section, below, for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppc_data(y, yrep, group = NULL)

ppc_dens_overlay(
  y,
  yrep,
  ...,
  size = 0.25,
  alpha = 0.7,
  trim = FALSE,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  n_dens = 1024
)

ppc_dens_overlay_grouped(
  y,
  yrep,
  group,
  ...,
  size = 0.25,
  alpha = 0.7,
  trim = FALSE,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  n_dens = 1024
)

ppc_ecdf_overlay(
  y,
  yrep,
  ...,
  discrete = FALSE,
  pad = TRUE,
  size = 0.25,
  alpha = 0.7
)

ppc_ecdf_overlay_grouped(
  y,
  yrep,
  group,
  ...,
  discrete = FALSE,
  pad = TRUE,
  size = 0.25,
  alpha = 0.7
)

ppc_dens(y, yrep, ..., trim = FALSE, size = 0.5, alpha = 1)

ppc_hist(
  y,
  yrep,
  ...,
  binwidth = NULL,
  bins = NULL,
  breaks = NULL,
  freq = TRUE
)

ppc_freqpoly(
  y,
  yrep,
  ...,
  binwidth = NULL,
  bins = NULL,
  freq = TRUE,
  size = 0.5,
  alpha = 1
)

ppc_freqpoly_grouped(
  y,
  yrep,
  group,
  ...,
  binwidth = NULL,
  bins = NULL,
  freq = TRUE,
  size = 0.5,
  alpha = 1
)

ppc_boxplot(y, yrep, ..., notch = TRUE, size = 0.5, alpha = 1)

ppc_violin_grouped(
  y,
  yrep,
  group,
  ...,
  probs = c(0.1, 0.5, 0.9),
  size = 1,
  alpha = 1,
  y_draw = c("violin", "points", "both"),
  y_size = 1,
  y_alpha = 1,
  y_jitter = 0.1
)

ppc_pit_ecdf(
  y,
  yrep,
  ...,
  pit = NULL,
  K = NULL,
  prob = 0.99,
  plot_diff = FALSE,
  interpolate_adj = NULL
)

ppc_pit_ecdf_grouped(
  y,
  yrep,
  group,
  ...,
  K = NULL,
  pit = NULL,
  prob = 0.99,
  plot_diff = FALSE,
  interpolate_adj = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPC-distributions_+3A_y">y</code></td>
<td>
<p>A vector of observations. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_yrep">yrep</code></td>
<td>
<p>An <code>S</code> by <code>N</code> matrix of draws from the posterior (or prior)
predictive distribution. The number of rows, <code>S</code>, is the size of the
posterior (or prior) sample used to generate <code>yrep</code>. The number of columns,
<code>N</code> is the number of predicted observations (<code>length(y)</code>). The columns of
<code>yrep</code> should be in the same order as the data points in <code>y</code> for the plots
to make sense. See the <strong>Details</strong> and <strong>Plot Descriptions</strong> sections for
additional advice specific to particular plots.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_group">group</code></td>
<td>
<p>A grouping variable of the same length as <code>y</code>.
Will be coerced to <a href="base.html#topic+factor">factor</a> if not already a factor.
Each value in <code>group</code> is interpreted as the group level pertaining
to the corresponding observation.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_size">size</code>, <code id="PPC-distributions_+3A_alpha">alpha</code></td>
<td>
<p>Passed to the appropriate geom to control the appearance of
the predictive distributions.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_trim">trim</code></td>
<td>
<p>A logical scalar passed to <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code>.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_bw">bw</code>, <code id="PPC-distributions_+3A_adjust">adjust</code>, <code id="PPC-distributions_+3A_kernel">kernel</code>, <code id="PPC-distributions_+3A_n_dens">n_dens</code></td>
<td>
<p>Optional arguments passed to
<code><a href="stats.html#topic+density">stats::density()</a></code> to override default kernel density estimation
parameters. <code>n_dens</code> defaults to <code>1024</code>.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_discrete">discrete</code></td>
<td>
<p>For <code>ppc_ecdf_overlay()</code>, should the data be treated as
discrete? The default is <code>FALSE</code>, in which case <code>geom="line"</code> is
passed to <code><a href="ggplot2.html#topic+stat_ecdf">ggplot2::stat_ecdf()</a></code>. If <code>discrete</code> is set to
<code>TRUE</code> then <code>geom="step"</code> is used.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_pad">pad</code></td>
<td>
<p>A logical scalar passed to <code><a href="ggplot2.html#topic+stat_ecdf">ggplot2::stat_ecdf()</a></code>.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_binwidth">binwidth</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_bins">bins</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> as an
alternative to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_freq">freq</code></td>
<td>
<p>For histograms, <code>freq=TRUE</code> (the default) puts count on the
y-axis. Setting <code>freq=FALSE</code> puts density on the y-axis. (For many
plots the y-axis text is off by default. To view the count or density
labels on the y-axis see the <code><a href="#topic+yaxis_text">yaxis_text()</a></code> convenience
function.)</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_notch">notch</code></td>
<td>
<p>For the box plot, a logical scalar passed to
<code><a href="ggplot2.html#topic+geom_boxplot">ggplot2::geom_boxplot()</a></code>. Note: unlike <code>geom_boxplot()</code>, the default is
<code>notch=TRUE</code>.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_probs">probs</code></td>
<td>
<p>A numeric vector passed to <code><a href="ggplot2.html#topic+geom_violin">ggplot2::geom_violin()</a></code>'s
<code>draw_quantiles</code> argument to specify at which quantiles to draw
horizontal lines. Set to <code>NULL</code> to remove the lines.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_y_draw">y_draw</code></td>
<td>
<p>For <code>ppc_violin_grouped()</code>, a string specifying how to draw
<code>y</code>: <code>"violin"</code> (default), <code>"points"</code> (jittered points), or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_y_jitter">y_jitter</code>, <code id="PPC-distributions_+3A_y_size">y_size</code>, <code id="PPC-distributions_+3A_y_alpha">y_alpha</code></td>
<td>
<p>For <code>ppc_violin_grouped()</code>, if <code>y_draw</code> is
<code>"points"</code> or <code>"both"</code> then <code>y_size</code>, <code>y_alpha</code>, and <code>y_jitter</code> are passed
to to the <code>size</code>, <code>alpha</code>, and <code>width</code> arguments of <code><a href="ggplot2.html#topic+geom_jitter">ggplot2::geom_jitter()</a></code>
to control the appearance of <code>y</code> points. The default of <code>y_jitter=NULL</code>
will let <strong>ggplot2</strong> determine the amount of jitter.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_pit">pit</code></td>
<td>
<p>An optional vector of probability integral transformed values for
which the ECDF is to be drawn. If NULL, PIT values are computed to <code>y</code> with
respect to the corresponding values in <code>yrep</code>.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_k">K</code></td>
<td>
<p>An optional integer defining the number of equally spaced evaluation
points for the PIT-ECDF. Reducing K when using <code>interpolate_adj = FALSE</code>
makes computing the confidence bands faster. For <code>ppc_pit_ecdf</code> and
<code>ppc_pit_ecdf_grouped</code>, if PIT values are supplied, defaults to
<code>length(pit)</code>, otherwise yrep determines the maximum accuracy of the
estimated PIT values and <code>K</code> is set to <code>min(nrow(yrep) + 1, 1000)</code>. For
<code>mcmc_rank_ecdf</code>, defaults to the number of iterations per chain in <code>x</code>.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_prob">prob</code></td>
<td>
<p>The desired simultaneous coverage level of the bands around the
ECDF. A value in (0,1).</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_plot_diff">plot_diff</code></td>
<td>
<p>A boolean defining whether to plot the difference between
the observed PIT- ECDF and the theoretical expectation for uniform PIT
values rather than plotting the regular ECDF. The default is <code>FALSE</code>, but
for large samples we recommend setting <code>plot_diff=TRUE</code> as the difference
plot will visually show a more dynamic range.</p>
</td></tr>
<tr><td><code id="PPC-distributions_+3A_interpolate_adj">interpolate_adj</code></td>
<td>
<p>A boolean defining if the simultaneous confidence
bands should be interpolated based on precomputed values rather than
computed exactly. Computing the bands may be computationally intensive and
the approximation gives a fast method for assessing the ECDF trajectory.
The default is to use interpolation if <code>K</code> is greater than 200.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Binomial data, the plots may be more useful if
the input contains the &quot;success&quot; <em>proportions</em> (not discrete
&quot;success&quot; or &quot;failure&quot; counts).
</p>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">&#8288;_data()&#8288;</code> return the data that would have been drawn by the plotting
function.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code style="white-space: pre;">&#8288;ppc_hist(), ppc_freqpoly(), ppc_dens(), ppc_boxplot()&#8288;</code></dt><dd>
<p>A separate histogram, shaded frequency polygon, smoothed kernel density
estimate, or box and whiskers plot is displayed for <code>y</code> and each
dataset (row) in <code>yrep</code>. For these plots <code>yrep</code> should therefore
contain only a small number of rows. See the <strong>Examples</strong> section.
</p>
</dd>
<dt><code>ppc_freqpoly_grouped()</code></dt><dd>
<p>A separate frequency polygon is plotted for each level of a grouping
variable for <code>y</code> and each dataset (row) in <code>yrep</code>. For this plot
<code>yrep</code> should therefore contain only a small number of rows. See the
<strong>Examples</strong> section.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;ppc_ecdf_overlay(), ppc_dens_overlay(), ppc_ecdf_overlay_grouped(), ppc_dens_overlay_grouped()&#8288;</code></dt><dd>
<p>Kernel density or empirical CDF estimates of each dataset (row) in
<code>yrep</code> are overlaid, with the distribution of <code>y</code> itself on top
(and in a darker shade). When using <code>ppc_ecdf_overlay()</code> with discrete
data, set the <code>discrete</code> argument to <code>TRUE</code> for better results.
For an example of <code>ppc_dens_overlay()</code> also see Gabry et al. (2019).
</p>
</dd>
<dt><code>ppc_violin_grouped()</code></dt><dd>
<p>The density estimate of <code>yrep</code> within each level of a grouping
variable is plotted as a violin with horizontal lines at notable
quantiles. <code>y</code> is overlaid on the plot either as a violin, points, or
both, depending on the <code>y_draw</code> argument.
</p>
</dd>
<dt><code>ppc_pit_ecdf()</code>, <code>ppc_pit_ecdf_grouped()</code></dt><dd>
<p>The PIT-ECDF of the empirical PIT values of <code>y</code> computed with respect to
the corresponding <code>yrep</code> values. <code>100 * prob</code>% central simultaneous
confidence intervals are provided to asses if <code>y</code> and <code>yrep</code> originate
from the same distribution. The PIT values can also be provided directly
as <code>pit</code>.
See Säilynoja et al. (2021) for more details.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>
<p>Säilynoja, T., Bürkner, P., Vehtari, A.
(2021). Graphical Test for Discrete Uniformity and its Applications in
Goodness of Fit Evaluation and Multiple Sample Comparison <a href="https://arxiv.org/abs/2103.10522">arXiv preprint</a>.
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. (Ch. 6)
</p>


<h3>See Also</h3>

<p>Other PPCs: 
<code><a href="#topic+PPC-censoring">PPC-censoring</a></code>,
<code><a href="#topic+PPC-discrete">PPC-discrete</a></code>,
<code><a href="#topic+PPC-errors">PPC-errors</a></code>,
<code><a href="#topic+PPC-intervals">PPC-intervals</a></code>,
<code><a href="#topic+PPC-loo">PPC-loo</a></code>,
<code><a href="#topic+PPC-overview">PPC-overview</a></code>,
<code><a href="#topic+PPC-scatterplots">PPC-scatterplots</a></code>,
<code><a href="#topic+PPC-test-statistics">PPC-test-statistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>color_scheme_set("brightblue")
y &lt;- example_y_data()
yrep &lt;- example_yrep_draws()
group &lt;- example_group_data()
dim(yrep)

ppc_dens_overlay(y, yrep[1:25, ])

# ppc_ecdf_overlay with continuous data (set discrete=TRUE if discrete data)
ppc_ecdf_overlay(y, yrep[sample(nrow(yrep), 25), ])

# PIT-ECDF and PIT-ECDF difference plot of the PIT values of y compared to
# yrep with 99% simultaneous confidence bands.
ppc_pit_ecdf(y, yrep, prob = 0.99, plot_diff = FALSE)
ppc_pit_ecdf(y, yrep, prob = 0.99, plot_diff = TRUE)


# for ppc_hist,dens,freqpoly,boxplot definitely use a subset yrep rows so
# only a few (instead of nrow(yrep)) histograms are plotted
ppc_hist(y, yrep[1:8, ])

color_scheme_set("red")
ppc_boxplot(y, yrep[1:8, ])

# wizard hat plot
color_scheme_set("blue")
ppc_dens(y, yrep[200:202, ])



# frequency polygons
ppc_freqpoly(y, yrep[1:3, ], alpha = 0.1, size = 1, binwidth = 5)

ppc_freqpoly_grouped(y, yrep[1:3, ], group) + yaxis_text()

# if groups are different sizes then the 'freq' argument can be useful
ppc_freqpoly_grouped(y, yrep[1:3, ], group, freq = FALSE) + yaxis_text()


# density and distribution overlays by group
ppc_dens_overlay_grouped(y, yrep[1:25, ], group = group)

ppc_ecdf_overlay_grouped(y, yrep[1:25, ], group = group)


# PIT-ECDF plots of the PIT values by group
# with 99% simultaneous confidence bands.
ppc_pit_ecdf_grouped(y, yrep, group=group, prob=0.99)



# don't need to only use small number of rows for ppc_violin_grouped
# (as it pools yrep draws within groups)
color_scheme_set("gray")
ppc_violin_grouped(y, yrep, group, size = 1.5)
ppc_violin_grouped(y, yrep, group, alpha = 0)

# change how y is drawn
ppc_violin_grouped(y, yrep, group, alpha = 0, y_draw = "points", y_size = 1.5)
ppc_violin_grouped(y, yrep, group,
  alpha = 0, y_draw = "both",
  y_size = 1.5, y_alpha = 0.5, y_jitter = 0.33
)

</code></pre>

<hr>
<h2 id='PPC-errors'>PPC errors</h2><span id='topic+PPC-errors'></span><span id='topic+ppc_error_hist'></span><span id='topic+ppc_error_hist_grouped'></span><span id='topic+ppc_error_scatter'></span><span id='topic+ppc_error_scatter_avg'></span><span id='topic+ppc_error_scatter_avg_grouped'></span><span id='topic+ppc_error_scatter_avg_vs_x'></span><span id='topic+ppc_error_binned'></span><span id='topic+ppc_error_data'></span>

<h3>Description</h3>

<p>Various plots of predictive errors <code>y - yrep</code>. See the
<strong>Details</strong> and <strong>Plot Descriptions</strong> sections, below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppc_error_hist(
  y,
  yrep,
  ...,
  facet_args = list(),
  binwidth = NULL,
  bins = NULL,
  breaks = NULL,
  freq = TRUE
)

ppc_error_hist_grouped(
  y,
  yrep,
  group,
  ...,
  facet_args = list(),
  binwidth = NULL,
  bins = NULL,
  breaks = NULL,
  freq = TRUE
)

ppc_error_scatter(y, yrep, ..., facet_args = list(), size = 2.5, alpha = 0.8)

ppc_error_scatter_avg(y, yrep, ..., size = 2.5, alpha = 0.8)

ppc_error_scatter_avg_grouped(
  y,
  yrep,
  group,
  ...,
  facet_args = list(),
  size = 2.5,
  alpha = 0.8
)

ppc_error_scatter_avg_vs_x(y, yrep, x, ..., size = 2.5, alpha = 0.8)

ppc_error_binned(
  y,
  yrep,
  ...,
  facet_args = list(),
  bins = NULL,
  size = 1,
  alpha = 0.25
)

ppc_error_data(y, yrep, group = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPC-errors_+3A_y">y</code></td>
<td>
<p>A vector of observations. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="PPC-errors_+3A_yrep">yrep</code></td>
<td>
<p>An <code>S</code> by <code>N</code> matrix of draws from the posterior (or prior)
predictive distribution. The number of rows, <code>S</code>, is the size of the
posterior (or prior) sample used to generate <code>yrep</code>. The number of columns,
<code>N</code> is the number of predicted observations (<code>length(y)</code>). The columns of
<code>yrep</code> should be in the same order as the data points in <code>y</code> for the plots
to make sense. See the <strong>Details</strong> and <strong>Plot Descriptions</strong> sections for
additional advice specific to particular plots.</p>
</td></tr>
<tr><td><code id="PPC-errors_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="PPC-errors_+3A_facet_args">facet_args</code></td>
<td>
<p>A named list of arguments (other than <code>facets</code>) passed
to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> or <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>
to control faceting. Note: if <code>scales</code> is not included in <code>facet_args</code>
then <strong>bayesplot</strong> may use <code>scales="free"</code> as the default (depending
on the plot) instead of the <strong>ggplot2</strong> default of <code>scales="fixed"</code>.</p>
</td></tr>
<tr><td><code id="PPC-errors_+3A_binwidth">binwidth</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="PPC-errors_+3A_bins">bins</code></td>
<td>
<p>For <code>ppc_error_binned()</code>, the number of bins to use (approximately).</p>
</td></tr>
<tr><td><code id="PPC-errors_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> as an
alternative to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="PPC-errors_+3A_freq">freq</code></td>
<td>
<p>For histograms, <code>freq=TRUE</code> (the default) puts count on the
y-axis. Setting <code>freq=FALSE</code> puts density on the y-axis. (For many
plots the y-axis text is off by default. To view the count or density
labels on the y-axis see the <code><a href="#topic+yaxis_text">yaxis_text()</a></code> convenience
function.)</p>
</td></tr>
<tr><td><code id="PPC-errors_+3A_group">group</code></td>
<td>
<p>A grouping variable of the same length as <code>y</code>.
Will be coerced to <a href="base.html#topic+factor">factor</a> if not already a factor.
Each value in <code>group</code> is interpreted as the group level pertaining
to the corresponding observation.</p>
</td></tr>
<tr><td><code id="PPC-errors_+3A_size">size</code>, <code id="PPC-errors_+3A_alpha">alpha</code></td>
<td>
<p>For scatterplots, arguments passed to
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> to control the appearance of the points. For the
binned error plot, arguments controlling the size of the outline and
opacity of the shaded region indicating the 2-SE bounds.</p>
</td></tr>
<tr><td><code id="PPC-errors_+3A_x">x</code></td>
<td>
<p>A numeric vector the same length as <code>y</code> to use as the x-axis
variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All of these functions (aside from the <code style="white-space: pre;">&#8288;*_scatter_avg&#8288;</code> functions)
compute and plot predictive errors for each row of the matrix <code>yrep</code>, so
it is usually a good idea for <code>yrep</code> to contain only a small number of
draws (rows). See <strong>Examples</strong>, below.
</p>
<p>For binomial and Bernoulli data the <code>ppc_error_binned()</code> function can be used
to generate binned error plots. Bernoulli data can be input as a vector of 0s
and 1s, whereas for binomial data <code>y</code> and <code>yrep</code> should contain &quot;success&quot;
proportions (not counts). See the <strong>Examples</strong> section, below.
</p>


<h3>Value</h3>

<p>A ggplot object that can be further customized using the <strong>ggplot2</strong> package.
</p>


<h3>Plot descriptions</h3>


<dl>
<dt><code>ppc_error_hist()</code></dt><dd>
<p>A separate histogram is plotted for the predictive errors computed from
<code>y</code> and each dataset (row) in <code>yrep</code>. For this plot <code>yrep</code> should have
only a small number of rows.
</p>
</dd>
<dt><code>ppc_error_hist_grouped()</code></dt><dd>
<p>Like <code>ppc_error_hist()</code>, except errors are computed within levels of a
grouping variable. The number of histograms is therefore equal to the
product of the number of rows in <code>yrep</code> and the number of groups
(unique values of <code>group</code>).
</p>
</dd>
<dt><code>ppc_error_scatter()</code></dt><dd>
<p>A separate scatterplot is displayed for <code>y</code> vs. the predictive errors
computed from <code>y</code> and each dataset (row) in <code>yrep</code>. For this plot <code>yrep</code>
should have only a small number of rows.
</p>
</dd>
<dt><code>ppc_error_scatter_avg()</code></dt><dd>
<p>A single scatterplot of <code>y</code> vs. the average of the errors computed from
<code>y</code> and each dataset (row) in <code>yrep</code>. For each individual data point
<code>y[n]</code> the average error is the average of the errors for <code>y[n]</code> computed
over the the draws from the posterior predictive distribution.
</p>
</dd>
<dt><code>ppc_error_scatter_avg_vs_x()</code></dt><dd>
<p>Same as <code>ppc_error_scatter_avg()</code>, except the average is plotted on the
y-axis and a predictor variable <code>x</code> is plotted on the x-axis.
</p>
</dd>
<dt><code>ppc_error_binned()</code></dt><dd>
<p>Intended for use with binomial data. A separate binned error plot (similar
to <code>arm::binnedplot()</code>) is generated for each dataset (row) in <code>yrep</code>. For
this plot <code>y</code> and <code>yrep</code> should contain proportions rather than counts,
and <code>yrep</code> should have only a small number of rows.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. (Ch. 6)
</p>


<h3>See Also</h3>

<p>Other PPCs: 
<code><a href="#topic+PPC-censoring">PPC-censoring</a></code>,
<code><a href="#topic+PPC-discrete">PPC-discrete</a></code>,
<code><a href="#topic+PPC-distributions">PPC-distributions</a></code>,
<code><a href="#topic+PPC-intervals">PPC-intervals</a></code>,
<code><a href="#topic+PPC-loo">PPC-loo</a></code>,
<code><a href="#topic+PPC-overview">PPC-overview</a></code>,
<code><a href="#topic+PPC-scatterplots">PPC-scatterplots</a></code>,
<code><a href="#topic+PPC-test-statistics">PPC-test-statistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- example_y_data()
yrep &lt;- example_yrep_draws()
ppc_error_hist(y, yrep[1:3, ])

# errors within groups
group &lt;- example_group_data()
(p1 &lt;- ppc_error_hist_grouped(y, yrep[1:3, ], group))
p1 + yaxis_text() # defaults to showing counts on y-axis

table(group) # more obs in GroupB, can set freq=FALSE to show density on y-axis
(p2 &lt;- ppc_error_hist_grouped(y, yrep[1:3, ], group, freq = FALSE))
p2 + yaxis_text()


# scatterplots
ppc_error_scatter(y, yrep[10:14, ])
ppc_error_scatter_avg(y, yrep)

x &lt;- example_x_data()
ppc_error_scatter_avg_vs_x(y, yrep, x)

## Not run: 
# binned error plot with binomial model from rstanarm
library(rstanarm)
example("example_model", package = "rstanarm")
formula(example_model)

# get observed proportion of "successes"
y &lt;- example_model$y  # matrix of "success" and "failure" counts
trials &lt;- rowSums(y)
y_prop &lt;- y[, 1] / trials  # proportions

# get predicted success proportions
yrep &lt;- posterior_predict(example_model)
yrep_prop &lt;- sweep(yrep, 2, trials, "/")

ppc_error_binned(y_prop, yrep_prop[1:6, ])

## End(Not run)

</code></pre>

<hr>
<h2 id='PPC-intervals'>PPC intervals</h2><span id='topic+PPC-intervals'></span><span id='topic+ppc_intervals'></span><span id='topic+ppc_intervals_grouped'></span><span id='topic+ppc_ribbon'></span><span id='topic+ppc_ribbon_grouped'></span><span id='topic+ppc_intervals_data'></span><span id='topic+ppc_ribbon_data'></span>

<h3>Description</h3>

<p>Medians and central interval estimates of <code>yrep</code> with <code>y</code> overlaid.
See the <strong>Plot Descriptions</strong> section, below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppc_intervals(
  y,
  yrep,
  x = NULL,
  ...,
  prob = 0.5,
  prob_outer = 0.9,
  alpha = 0.33,
  size = 1,
  fatten = 2.5,
  linewidth = 1
)

ppc_intervals_grouped(
  y,
  yrep,
  x = NULL,
  group,
  ...,
  facet_args = list(),
  prob = 0.5,
  prob_outer = 0.9,
  alpha = 0.33,
  size = 1,
  fatten = 2.5,
  linewidth = 1
)

ppc_ribbon(
  y,
  yrep,
  x = NULL,
  ...,
  prob = 0.5,
  prob_outer = 0.9,
  alpha = 0.33,
  size = 0.25,
  y_draw = c("line", "points", "both")
)

ppc_ribbon_grouped(
  y,
  yrep,
  x = NULL,
  group,
  ...,
  facet_args = list(),
  prob = 0.5,
  prob_outer = 0.9,
  alpha = 0.33,
  size = 0.25,
  y_draw = c("line", "points", "both")
)

ppc_intervals_data(
  y,
  yrep,
  x = NULL,
  group = NULL,
  ...,
  prob = 0.5,
  prob_outer = 0.9
)

ppc_ribbon_data(
  y,
  yrep,
  x = NULL,
  group = NULL,
  ...,
  prob = 0.5,
  prob_outer = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPC-intervals_+3A_y">y</code></td>
<td>
<p>A vector of observations. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="PPC-intervals_+3A_yrep">yrep</code></td>
<td>
<p>An <code>S</code> by <code>N</code> matrix of draws from the posterior (or prior)
predictive distribution. The number of rows, <code>S</code>, is the size of the
posterior (or prior) sample used to generate <code>yrep</code>. The number of columns,
<code>N</code> is the number of predicted observations (<code>length(y)</code>). The columns of
<code>yrep</code> should be in the same order as the data points in <code>y</code> for the plots
to make sense. See the <strong>Details</strong> and <strong>Plot Descriptions</strong> sections for
additional advice specific to particular plots.</p>
</td></tr>
<tr><td><code id="PPC-intervals_+3A_x">x</code></td>
<td>
<p>A numeric vector to use as the x-axis
variable. For example, <code>x</code> could be a predictor variable from a
regression model, a time variable for time-series models, etc. If <code>x</code>
is missing or <code>NULL</code> then the observation index is used for the x-axis.</p>
</td></tr>
<tr><td><code id="PPC-intervals_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="PPC-intervals_+3A_prob">prob</code>, <code id="PPC-intervals_+3A_prob_outer">prob_outer</code></td>
<td>
<p>Values between <code>0</code> and <code>1</code> indicating the desired
probability mass to include in the inner and outer intervals. The defaults
are <code>prob=0.5</code> and <code>prob_outer=0.9</code>.</p>
</td></tr>
<tr><td><code id="PPC-intervals_+3A_alpha">alpha</code>, <code id="PPC-intervals_+3A_size">size</code>, <code id="PPC-intervals_+3A_fatten">fatten</code>, <code id="PPC-intervals_+3A_linewidth">linewidth</code></td>
<td>
<p>Arguments passed to geoms. For ribbon
plots <code>alpha</code> is passed to <code><a href="ggplot2.html#topic+geom_ribbon">ggplot2::geom_ribbon()</a></code> to control the opacity
of the outer ribbon and <code>size</code> is passed to <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code> to
control the size of the line representing the median prediction (<code>size=0</code>
will remove the line). For interval plots <code>alpha</code>, <code>size</code>, <code>fatten</code>, and
<code>linewidth</code> are passed to <code><a href="ggplot2.html#topic+geom_linerange">ggplot2::geom_pointrange()</a></code> (<code>fatten=0</code> will
remove the point estimates).</p>
</td></tr>
<tr><td><code id="PPC-intervals_+3A_group">group</code></td>
<td>
<p>A grouping variable of the same length as <code>y</code>.
Will be coerced to <a href="base.html#topic+factor">factor</a> if not already a factor.
Each value in <code>group</code> is interpreted as the group level pertaining
to the corresponding observation.</p>
</td></tr>
<tr><td><code id="PPC-intervals_+3A_facet_args">facet_args</code></td>
<td>
<p>A named list of arguments (other than <code>facets</code>) passed
to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> or <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>
to control faceting. Note: if <code>scales</code> is not included in <code>facet_args</code>
then <strong>bayesplot</strong> may use <code>scales="free"</code> as the default (depending
on the plot) instead of the <strong>ggplot2</strong> default of <code>scales="fixed"</code>.</p>
</td></tr>
<tr><td><code id="PPC-intervals_+3A_y_draw">y_draw</code></td>
<td>
<p>For ribbon plots only, a string specifying how to draw <code>y</code>. Can
be <code>"line"</code> (the default), <code>"points"</code>, or <code>"both"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">&#8288;_data()&#8288;</code> return the data that would have been drawn by the plotting
function.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code style="white-space: pre;">&#8288;ppc_intervals(), ppc_ribbon()&#8288;</code></dt><dd>
<p><code>100*prob</code>% central intervals for <code>yrep</code> at each <code>x</code>
value. <code>ppc_intervals()</code> plots intervals as vertical bars with points
indicating <code>yrep</code> medians and darker points indicating observed
<code>y</code> values. <code>ppc_ribbon()</code> plots a ribbon of connected intervals
with a line through the median of <code>yrep</code> and a darker line connecting
observed <code>y</code> values. In both cases an optional <code>x</code> variable can
also be specified for the x-axis variable.
</p>
<p>Depending on the number of observations and the variability in the
predictions at different values of <code>x</code>, one of these plots may be easier
to read than the other.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;ppc_intervals_grouped(), ppc_ribbon_grouped()&#8288;</code></dt><dd>
<p>Same as <code>ppc_intervals()</code> and <code>ppc_ribbon()</code>, respectively, but a
separate plot (facet) is generated for each level of a grouping variable.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. (Ch. 6)
</p>


<h3>See Also</h3>

<p>Other PPCs: 
<code><a href="#topic+PPC-censoring">PPC-censoring</a></code>,
<code><a href="#topic+PPC-discrete">PPC-discrete</a></code>,
<code><a href="#topic+PPC-distributions">PPC-distributions</a></code>,
<code><a href="#topic+PPC-errors">PPC-errors</a></code>,
<code><a href="#topic+PPC-loo">PPC-loo</a></code>,
<code><a href="#topic+PPC-overview">PPC-overview</a></code>,
<code><a href="#topic+PPC-scatterplots">PPC-scatterplots</a></code>,
<code><a href="#topic+PPC-test-statistics">PPC-test-statistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rnorm(50)
yrep &lt;- matrix(rnorm(5000, 0, 2), ncol = 50)

color_scheme_set("brightblue")
ppc_intervals(y, yrep)
ppc_ribbon(y, yrep)
ppc_ribbon(y, yrep, y_draw = "points")
## Not run: 
ppc_ribbon(y, yrep, y_draw = "both")

## End(Not run)

ppc_intervals(y, yrep, size = 1.5, fatten = 0) # remove the yrep point estimates

color_scheme_set("teal")
year &lt;- 1950:1999
ppc_intervals(y, yrep, x = year, fatten = 1) + ggplot2::xlab("Year")
ppc_ribbon(y, yrep, x = year) + ggplot2::xlab("Year")

color_scheme_set("pink")
year &lt;- rep(2000:2009, each = 5)
group &lt;- gl(5, 1, length = 50, labels = LETTERS[1:5])
ppc_ribbon_grouped(y, yrep, x = year, group, y_draw = "both") +
  ggplot2::scale_x_continuous(breaks = pretty)

ppc_ribbon_grouped(y, yrep, x = year, group,
                   facet_args = list(scales = "fixed")) +
 xaxis_text(FALSE) +
 xaxis_ticks(FALSE) +
 panel_bg(fill = "gray20")

# get the data frames used to make the ggplots
ppc_dat &lt;- ppc_intervals_data(y, yrep, x = year, prob = 0.5)
ppc_group_dat &lt;- ppc_intervals_data(y, yrep, x = year, group = group, prob = 0.5)

## Not run: 
library("rstanarm")
fit &lt;- stan_glmer(mpg ~ wt + (1|cyl), data = mtcars, refresh = 0)
yrep &lt;- posterior_predict(fit)

color_scheme_set("purple")
ppc_intervals(y = mtcars$mpg, yrep = yrep, x = mtcars$wt, prob = 0.8) +
 panel_bg(fill="gray90", color = NA) +
 grid_lines(color = "white")

ppc_ribbon(y = mtcars$mpg, yrep = yrep, x = mtcars$wt,
           prob = 0.6, prob_outer = 0.8)

ppc_ribbon_grouped(y = mtcars$mpg, yrep = yrep, x = mtcars$wt,
                   group = mtcars$cyl)


color_scheme_set("gray")
ppc_intervals(mtcars$mpg, yrep, prob = 0.5) +
 ggplot2::scale_x_continuous(
   labels = rownames(mtcars),
   breaks = 1:nrow(mtcars)
 ) +
 xaxis_text(angle = -70, vjust = 1, hjust = 0) +
 xaxis_title(FALSE)


## End(Not run)


</code></pre>

<hr>
<h2 id='PPC-loo'>LOO predictive checks</h2><span id='topic+PPC-loo'></span><span id='topic+ppc_loo_pit_overlay'></span><span id='topic+ppc_loo_pit_data'></span><span id='topic+ppc_loo_pit_qq'></span><span id='topic+ppc_loo_pit'></span><span id='topic+ppc_loo_intervals'></span><span id='topic+ppc_loo_ribbon'></span>

<h3>Description</h3>

<p>Leave-One-Out (LOO) predictive checks. See the <strong>Plot Descriptions</strong> section,
below, and <a href="https://github.com/jgabry/bayes-vis-paper#readme">Gabry et al. (2019)</a>
for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppc_loo_pit_overlay(
  y,
  yrep,
  lw = NULL,
  ...,
  psis_object = NULL,
  pit = NULL,
  samples = 100,
  size = 0.25,
  alpha = 0.7,
  boundary_correction = TRUE,
  grid_len = 512,
  bw = "nrd0",
  trim = FALSE,
  adjust = 1,
  kernel = "gaussian",
  n_dens = 1024
)

ppc_loo_pit_data(
  y,
  yrep,
  lw = NULL,
  ...,
  psis_object = NULL,
  pit = NULL,
  samples = 100,
  bw = "nrd0",
  boundary_correction = TRUE,
  grid_len = 512
)

ppc_loo_pit_qq(
  y,
  yrep,
  lw = NULL,
  ...,
  psis_object = NULL,
  pit = NULL,
  compare = c("uniform", "normal"),
  size = 2,
  alpha = 1
)

ppc_loo_pit(
  y,
  yrep,
  lw,
  pit = NULL,
  compare = c("uniform", "normal"),
  ...,
  size = 2,
  alpha = 1
)

ppc_loo_intervals(
  y,
  yrep,
  psis_object,
  ...,
  subset = NULL,
  intervals = NULL,
  prob = 0.5,
  prob_outer = 0.9,
  alpha = 0.33,
  size = 1,
  fatten = 2.5,
  linewidth = 1,
  order = c("index", "median")
)

ppc_loo_ribbon(
  y,
  yrep,
  psis_object,
  ...,
  subset = NULL,
  intervals = NULL,
  prob = 0.5,
  prob_outer = 0.9,
  alpha = 0.33,
  size = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPC-loo_+3A_y">y</code></td>
<td>
<p>A vector of observations. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_yrep">yrep</code></td>
<td>
<p>An <code>S</code> by <code>N</code> matrix of draws from the posterior (or prior)
predictive distribution. The number of rows, <code>S</code>, is the size of the
posterior (or prior) sample used to generate <code>yrep</code>. The number of columns,
<code>N</code> is the number of predicted observations (<code>length(y)</code>). The columns of
<code>yrep</code> should be in the same order as the data points in <code>y</code> for the plots
to make sense. See the <strong>Details</strong> and <strong>Plot Descriptions</strong> sections for
additional advice specific to particular plots.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_lw">lw</code></td>
<td>
<p>A matrix of (smoothed) log weights with the same dimensions as
<code>yrep</code>. See <code><a href="loo.html#topic+psis">loo::psis()</a></code> and the associated <code>weights()</code> method as well as
the <strong>Examples</strong> section, below. If <code>lw</code> is not specified then
<code>psis_object</code> can be provided and log weights will be extracted.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_psis_object">psis_object</code></td>
<td>
<p>If using <strong>loo</strong> version <code style="white-space: pre;">&#8288;2.0.0&#8288;</code> or greater, an
object returned by the <code>psis()</code> function (or by the <code>loo()</code> function
with argument <code>save_psis</code> set to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_pit">pit</code></td>
<td>
<p>For <code>ppc_loo_pit_overlay()</code> and <code>ppc_loo_pit_qq()</code>, optionally a
vector of precomputed PIT values that can be specified instead of <code>y</code>,
<code>yrep</code>, and <code>lw</code> (these are all ignored if <code>pit</code> is specified). If not
specified the PIT values are computed internally before plotting.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_samples">samples</code></td>
<td>
<p>For <code>ppc_loo_pit_overlay()</code>, the number of data sets (each
the same size as <code>y</code>) to simulate from the standard uniform
distribution. The default is 100. The density estimate of each dataset is
plotted as a thin line in the plot, with the density estimate of the LOO
PITs overlaid as a thicker dark line.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_alpha">alpha</code>, <code id="PPC-loo_+3A_size">size</code>, <code id="PPC-loo_+3A_fatten">fatten</code>, <code id="PPC-loo_+3A_linewidth">linewidth</code></td>
<td>
<p>Arguments passed to code geoms to control plot
aesthetics. For <code>ppc_loo_pit_qq()</code> and <code>ppc_loo_pit_overlay()</code>, <code>size</code> and
<code>alpha</code> are passed to <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> and
<code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code>, respectively. For <code>ppc_loo_intervals()</code>, <code>size</code>
<code>linewidth</code> and <code>fatten</code> are passed to <code><a href="ggplot2.html#topic+geom_linerange">ggplot2::geom_pointrange()</a></code>. For
<code>ppc_loo_ribbon()</code>, <code>alpha</code> and <code>size</code>  are passed to
<code><a href="ggplot2.html#topic+geom_ribbon">ggplot2::geom_ribbon()</a></code>.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_boundary_correction">boundary_correction</code></td>
<td>
<p>For <code>ppc_loo_pit_overlay()</code>, when set to <code>TRUE</code>
(the default) the function will compute boundary corrected density values
via convolution and a Gaussian filter, also known as the reflection method
(Boneva et al., 1971). As a result, parameters controlling the standard
kernel density estimation such as <code>adjust</code>, <code>kernel</code> and <code>n_dens</code> are
ignored. NOTE: The current implementation only works well for continuous
observations.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_grid_len">grid_len</code></td>
<td>
<p>For <code>ppc_loo_pit_overlay()</code>, when <code>boundary_correction</code> is
set to <code>TRUE</code> this parameter specifies the number of points used to
generate the estimations. This is set to 512 by default.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_bw">bw</code>, <code id="PPC-loo_+3A_adjust">adjust</code>, <code id="PPC-loo_+3A_kernel">kernel</code>, <code id="PPC-loo_+3A_n_dens">n_dens</code></td>
<td>
<p>Optional arguments passed to
<code><a href="stats.html#topic+density">stats::density()</a></code> to override default kernel density estimation
parameters. <code>n_dens</code> defaults to <code>1024</code>.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_trim">trim</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_density">ggplot2::stat_density()</a></code>.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_compare">compare</code></td>
<td>
<p>For <code>ppc_loo_pit_qq()</code>, a string that can be either
<code>"uniform"</code> or <code>"normal"</code>. If <code>"uniform"</code> (the default) the Q-Q plot
compares computed PIT values to the standard uniform distribution. If
<code>compare="normal"</code>, the Q-Q plot compares standard normal quantiles
calculated from the PIT values to the theoretical standard normal
quantiles.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_subset">subset</code></td>
<td>
<p>For <code>ppc_loo_intervals()</code> and <code>ppc_loo_ribbon()</code>, an optional
integer vector indicating which observations in <code>y</code> (and <code>yrep</code>) to
include. Dropping observations from <code>y</code> and <code>yrep</code> manually before passing
them to the plotting function will not work because the dimensions will not
match up with the dimensions of <code>psis_object</code>, but if all of <code>y</code> and <code>yrep</code>
are passed along with <code>subset</code> then <strong>bayesplot</strong> can do the subsetting
internally for <code>y</code>, <code>yrep</code> <em>and</em> <code>psis_object</code>. See the <strong>Examples</strong>
section for a demonstration.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_intervals">intervals</code></td>
<td>
<p>For <code>ppc_loo_intervals()</code> and <code>ppc_loo_ribbon()</code>, optionally
a matrix of pre-computed LOO predictive intervals that can be specified
instead of <code>yrep</code> (ignored if <code>intervals</code> is specified). If not specified
the intervals are computed internally before plotting. If specified,
<code>intervals</code> must be a matrix with number of rows equal to the number of
data points and five columns in the following order: lower outer interval,
lower inner interval, median (50%), upper inner interval and upper outer
interval (column names are ignored).</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_prob">prob</code>, <code id="PPC-loo_+3A_prob_outer">prob_outer</code></td>
<td>
<p>Values between <code>0</code> and <code>1</code> indicating the desired
probability mass to include in the inner and outer intervals. The defaults
are <code>prob=0.5</code> and <code>prob_outer=0.9</code>.</p>
</td></tr>
<tr><td><code id="PPC-loo_+3A_order">order</code></td>
<td>
<p>For <code>ppc_loo_intervals()</code>, a string indicating how to arrange
the plotted intervals. The default (<code>"index"</code>) is to plot them in the
order of the observations. The alternative (<code>"median"</code>) arranges them
by median value from smallest (left) to largest (right).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object that can be further customized using the <strong>ggplot2</strong> package.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>ppc_loo_pit_overlay()</code>, <code>ppc_loo_pit_qq()</code></dt><dd>
<p>The calibration of marginal predictions can be assessed using probability
integral transformation (PIT) checks. LOO improves the check by avoiding the
double use of data. See the section on marginal predictive checks in Gelman
et al. (2013, p. 152&ndash;153) and section 5 of Gabry et al. (2019) for an
example of using <strong>bayesplot</strong> for these checks.
</p>
<p>The LOO PIT values are asymptotically uniform (for continuous data) if the
model is calibrated. The <code>ppc_loo_pit_overlay()</code> function creates a plot
comparing the density of the LOO PITs (thick line) to the density estimates
of many simulated data sets from the standard uniform distribution (thin
lines). See Gabry et al. (2019) for an example of interpreting the shape of
the miscalibration that can be observed in these plots.
</p>
<p>The <code>ppc_loo_pit_qq()</code> function provides an alternative visualization of
the miscalibration with a quantile-quantile (Q-Q) plot comparing the LOO
PITs to the standard uniform distribution. Comparing to the uniform is not
good for extreme probabilities close to 0 and 1, so it can sometimes be
useful to set the <code>compare</code> argument to <code>"normal"</code>, which will
produce a Q-Q plot comparing standard normal quantiles calculated from the
PIT values to the theoretical standard normal quantiles. This can help see
the (mis)calibration better for the extreme values. However, in most cases
we have found that the overlaid density plot (<code>ppc_loo_pit_overlay()</code>)
function will provide a clearer picture of calibration problems than the
Q-Q plot.
</p>
</dd>
<dt><code>ppc_loo_intervals()</code>, <code>ppc_loo_ribbon()</code></dt><dd>
<p>Similar to <code><a href="#topic+ppc_intervals">ppc_intervals()</a></code> and <code><a href="#topic+ppc_ribbon">ppc_ribbon()</a></code> but the intervals are for
the LOO predictive distribution.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. (p. 152&ndash;153)
</p>
<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>
<p>Vehtari, A., Gelman, A., and Gabry, J. (2017). Practical
Bayesian model evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing</em>. 27(5), 1413&ndash;1432.
doi:10.1007/s11222-016-9696-4. arXiv preprint:
<a href="https://arxiv.org/abs/1507.04544">https://arxiv.org/abs/1507.04544</a>
</p>
<p>Boneva, L. I., Kendall, D., &amp; Stefanov, I. (1971). Spline
transformations: Three new diagnostic aids for the statistical
data-analyst. <em>J. R. Stat. Soc. B</em> (Methodological), 33(1), 1-71.
https://www.jstor.org/stable/2986005.
</p>


<h3>See Also</h3>

<p>Other PPCs: 
<code><a href="#topic+PPC-censoring">PPC-censoring</a></code>,
<code><a href="#topic+PPC-discrete">PPC-discrete</a></code>,
<code><a href="#topic+PPC-distributions">PPC-distributions</a></code>,
<code><a href="#topic+PPC-errors">PPC-errors</a></code>,
<code><a href="#topic+PPC-intervals">PPC-intervals</a></code>,
<code><a href="#topic+PPC-overview">PPC-overview</a></code>,
<code><a href="#topic+PPC-scatterplots">PPC-scatterplots</a></code>,
<code><a href="#topic+PPC-test-statistics">PPC-test-statistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(rstanarm)
library(loo)

head(radon)
fit &lt;- stan_lmer(
  log_radon ~ floor + log_uranium + floor:log_uranium
               + (1 + floor | county),
  data = radon,
  iter = 100,
  chains = 2,
  cores = 2
 )
y &lt;- radon$log_radon
yrep &lt;- posterior_predict(fit)

loo1 &lt;- loo(fit, save_psis = TRUE, cores = 4)
psis1 &lt;- loo1$psis_object
lw &lt;- weights(psis1) # normalized log weights

# marginal predictive check using LOO probability integral transform
color_scheme_set("orange")
ppc_loo_pit_overlay(y, yrep, lw = lw)

ppc_loo_pit_qq(y, yrep, lw = lw)
ppc_loo_pit_qq(y, yrep, lw = lw, compare = "normal")

# can use the psis object instead of lw
ppc_loo_pit_qq(y, yrep, psis_object = psis1)

# loo predictive intervals vs observations
keep_obs &lt;- 1:50
ppc_loo_intervals(y, yrep, psis_object = psis1, subset = keep_obs)

color_scheme_set("gray")
ppc_loo_intervals(y, yrep, psis_object = psis1, subset = keep_obs,
                  order = "median")

## End(Not run)

</code></pre>

<hr>
<h2 id='PPC-overview'>Graphical posterior predictive checking</h2><span id='topic+PPC-overview'></span><span id='topic+PPC'></span>

<h3>Description</h3>

<p>The <strong>bayesplot</strong> PPC module provides various plotting functions
for creating graphical displays comparing observed data to simulated data
from the posterior (or prior) predictive distribution. See the sections
below for a brief discussion of the ideas behind posterior predictive
checking, an overview of the available PPC plots, and tips on providing an
interface to <strong>bayesplot</strong> from another package.
</p>
<p>For plots of posterior (or prior) predictive distributions that do <em>not</em>
include observed data see <a href="#topic+PPD-overview">PPD-overview</a> instead.
</p>


<h3>Details</h3>

<p>The idea behind posterior predictive checking is simple: if a model
is a good fit then we should be able to use it to generate data that looks
a lot like the data we observed.
</p>


<h4>Posterior predictive distribution</h4>

<p>To generate the data used for posterior predictive checks we simulate from
the <em>posterior predictive distribution</em>. The posterior predictive
distribution is the distribution of the outcome variable implied by a model
after using the observed data <code class="reqn">y</code> (a vector of outcome values), and
typically predictors <code class="reqn">X</code>, to update our beliefs about the unknown
parameters <code class="reqn">\theta</code> in the model. For each draw of the parameters
<code class="reqn">\theta</code> from the posterior distribution
<code class="reqn">p(\theta \,|\, y, X)</code>
we generate an entire vector of outcomes. The result is
an <code class="reqn">S \times N</code> matrix of simulations, where <code class="reqn">S</code> is the the
size of the posterior sample (number of draws from the posterior
distribution) and <code class="reqn">N</code> is the number of data points in <code class="reqn">y</code>. That is,
each row of the matrix is an individual &quot;replicated&quot; dataset of <code class="reqn">N</code>
observations.
</p>



<h4>Notation</h4>

<p>When simulating from the posterior predictive distribution we can use either
the same values of the predictors <code class="reqn">X</code> that we used when fitting the model
or new observations of those predictors. When we use the same values of
<code class="reqn">X</code> we denote the resulting simulations by <code class="reqn">y^{rep}</code> as they
can be thought of as <em>replications</em> of the outcome <code class="reqn">y</code> rather than
predictions for future observations. This corresponds to the notation from
Gelman et. al. (2013) and is the notation used throughout the documentation
for this package.
</p>



<h4>Graphical posterior predictive checking</h4>

<p>Using the datasets <code class="reqn">y^{rep}</code> drawn from the posterior predictive
distribution, the functions in the <strong>bayesplot</strong> package produce various
graphical displays comparing the observed data <code class="reqn">y</code> to the replications.
For a more thorough discussion of posterior predictive checking see
Chapter 6 of Gelman et. al. (2013).
</p>



<h4>Prior predictive checking</h4>

<p>To use <strong>bayesplot</strong> for <em>prior</em> predictive checks you can simply use draws
from the prior predictive distribution instead of the posterior predictive
distribution. See Gabry et al. (2019) for more on prior predictive checking
and when it is reasonable to compare the prior predictive distribution to the
observed data. If you want to avoid using the observed data for prior
predictive checks then you can use the <strong>bayesplot</strong> <a href="#topic+PPD">PPD</a> plots instead,
which do not take a <code>y</code> argument, or you can use the PPC plots but provide
plausible or implausible <code>y</code> values that you want to compare to the prior
predictive realizations.
</p>



<h3>PPC plotting functions</h3>

<p>The plotting functions for prior and
posterior predictive checking all have the prefix <code>ppc_</code> and all require
the arguments <code>y</code>, a vector of observations, and <code>yrep</code>, a matrix of
replications (in-sample predictions). The plots are organized into several
categories, each with its own documentation:
</p>

<ul>
<li> <p><a href="#topic+PPC-distributions">PPC-distributions</a>: Histograms, kernel density estimates, boxplots, and
other plots comparing the empirical distribution of data <code>y</code> to the
distributions of individual simulated datasets (rows) in <code>yrep</code>.
</p>
</li>
<li> <p><a href="#topic+PPC-test-statistics">PPC-test-statistics</a>: The distribution of a statistic, or a pair of
statistics, over the simulated datasets (rows) in <code>yrep</code> compared to value of
the statistic(s) computed from <code>y</code>.
</p>
</li>
<li> <p><a href="#topic+PPC-intervals">PPC-intervals</a>: Interval estimates of <code>yrep</code> with <code>y</code>
overlaid. The x-axis variable can be optionally specified by the user
(e.g. to plot against a predictor variable or over time).
</p>
</li>
<li> <p><a href="#topic+PPC-errors">PPC-errors</a>: Plots of predictive errors (<code>y - yrep</code>) computed from <code>y</code> and
each of the simulated datasets (rows) in <code>yrep</code>. For binomial models binned
error plots are also available.
</p>
</li>
<li> <p><a href="#topic+PPC-scatterplots">PPC-scatterplots</a>: Scatterplots (and similar visualizations) of the data
<code>y</code> vs. individual simulated datasets (rows) in <code>yrep</code>, or vs. the average
value of the distributions of each data point (columns) in <code>yrep</code>.
</p>
</li>
<li> <p><a href="#topic+PPC-discrete">PPC-discrete</a>: PPC functions that can only be used if <code>y</code> and <code>yrep</code> are
discrete. For example, rootograms for count outcomes and bar plots for
ordinal, categorical, and multinomial outcomes.
</p>
</li>
<li> <p><a href="#topic+PPC-loo">PPC-loo</a>: PPC functions for predictive checks based on (approximate)
leave-one-out (LOO) cross-validation.
'
</p>
</li>
<li> <p><a href="#topic+PPC-censoring">PPC-censoring</a>: PPC functions comparing the empirical
distribution of censored data <code>y</code> to the distributions of individual
simulated datasets (rows) in <code>yrep</code>.
</p>
</li></ul>



<h3>Providing an interface for predictive checking from another package</h3>

<p>In addition to the various plotting functions, the <strong>bayesplot</strong> package
provides the S3 generic <code><a href="#topic+pp_check">pp_check()</a></code>. Authors of <span class="rlang"><b>R</b></span> packages for
Bayesian inference are encouraged to define <code>pp_check()</code> methods for the
fitted model objects created by their packages. See the package vignettes for
more details and a simple example, and see the <strong>rstanarm</strong> and <strong>brms</strong>
packages for full examples of <code>pp_check()</code> methods.
</p>


<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. (Ch. 6)
</p>


<h3>See Also</h3>

<p>Other PPCs: 
<code><a href="#topic+PPC-censoring">PPC-censoring</a></code>,
<code><a href="#topic+PPC-discrete">PPC-discrete</a></code>,
<code><a href="#topic+PPC-distributions">PPC-distributions</a></code>,
<code><a href="#topic+PPC-errors">PPC-errors</a></code>,
<code><a href="#topic+PPC-intervals">PPC-intervals</a></code>,
<code><a href="#topic+PPC-loo">PPC-loo</a></code>,
<code><a href="#topic+PPC-scatterplots">PPC-scatterplots</a></code>,
<code><a href="#topic+PPC-test-statistics">PPC-test-statistics</a></code>
</p>

<hr>
<h2 id='PPC-scatterplots'>PPC scatterplots</h2><span id='topic+PPC-scatterplots'></span><span id='topic+ppc_scatter'></span><span id='topic+ppc_scatter_avg'></span><span id='topic+ppc_scatter_avg_grouped'></span><span id='topic+ppc_scatter_data'></span><span id='topic+ppc_scatter_avg_data'></span>

<h3>Description</h3>

<p>Scatterplots of the observed data <code>y</code> vs. simulated/replicated data
<code>yrep</code> from the posterior predictive distribution. See the
<strong>Plot Descriptions</strong> and <strong>Details</strong> sections, below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppc_scatter(
  y,
  yrep,
  ...,
  facet_args = list(),
  size = 2.5,
  alpha = 0.8,
  ref_line = TRUE
)

ppc_scatter_avg(y, yrep, ..., size = 2.5, alpha = 0.8, ref_line = TRUE)

ppc_scatter_avg_grouped(
  y,
  yrep,
  group,
  ...,
  facet_args = list(),
  size = 2.5,
  alpha = 0.8,
  ref_line = TRUE
)

ppc_scatter_data(y, yrep)

ppc_scatter_avg_data(y, yrep, group = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPC-scatterplots_+3A_y">y</code></td>
<td>
<p>A vector of observations. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="PPC-scatterplots_+3A_yrep">yrep</code></td>
<td>
<p>An <code>S</code> by <code>N</code> matrix of draws from the posterior (or prior)
predictive distribution. The number of rows, <code>S</code>, is the size of the
posterior (or prior) sample used to generate <code>yrep</code>. The number of columns,
<code>N</code> is the number of predicted observations (<code>length(y)</code>). The columns of
<code>yrep</code> should be in the same order as the data points in <code>y</code> for the plots
to make sense. See the <strong>Details</strong> and <strong>Plot Descriptions</strong> sections for
additional advice specific to particular plots.</p>
</td></tr>
<tr><td><code id="PPC-scatterplots_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="PPC-scatterplots_+3A_facet_args">facet_args</code></td>
<td>
<p>A named list of arguments (other than <code>facets</code>) passed
to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> or <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>
to control faceting. Note: if <code>scales</code> is not included in <code>facet_args</code>
then <strong>bayesplot</strong> may use <code>scales="free"</code> as the default (depending
on the plot) instead of the <strong>ggplot2</strong> default of <code>scales="fixed"</code>.</p>
</td></tr>
<tr><td><code id="PPC-scatterplots_+3A_size">size</code>, <code id="PPC-scatterplots_+3A_alpha">alpha</code></td>
<td>
<p>Arguments passed to <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> to control the
appearance of the points.</p>
</td></tr>
<tr><td><code id="PPC-scatterplots_+3A_ref_line">ref_line</code></td>
<td>
<p>If <code>TRUE</code> (the default) a dashed line with intercept 0 and
slope 1 is drawn behind the scatter plot.</p>
</td></tr>
<tr><td><code id="PPC-scatterplots_+3A_group">group</code></td>
<td>
<p>A grouping variable of the same length as <code>y</code>.
Will be coerced to <a href="base.html#topic+factor">factor</a> if not already a factor.
Each value in <code>group</code> is interpreted as the group level pertaining
to the corresponding observation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Binomial data, the plots may be more useful if
the input contains the &quot;success&quot; <em>proportions</em> (not discrete
&quot;success&quot; or &quot;failure&quot; counts).
</p>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">&#8288;_data()&#8288;</code> return the data that would have been drawn by the plotting
function.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>ppc_scatter()</code></dt><dd>
<p>For each dataset (row) in <code>yrep</code> a scatterplot is generated showing <code>y</code>
against that row of <code>yrep</code>. For this plot <code>yrep</code> should only contain a
small number of rows.
</p>
</dd>
<dt><code>ppc_scatter_avg()</code></dt><dd>
<p>A single scatterplot of <code>y</code> against the average values of <code>yrep</code>, i.e.,
the points <code style="white-space: pre;">&#8288;(x,y) = (mean(yrep[, n]), y[n])&#8288;</code>, where each <code>yrep[, n]</code> is
a vector of length equal to the number of posterior draws. Unlike
for <code>ppc_scatter()</code>, for <code>ppc_scatter_avg()</code> <code>yrep</code> should contain many
draws (rows).
</p>
</dd>
<dt><code>ppc_scatter_avg_grouped()</code></dt><dd>
<p>The same as <code>ppc_scatter_avg()</code>, but a separate plot is generated for
each level of a grouping variable.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. (Ch. 6)
</p>


<h3>See Also</h3>

<p>Other PPCs: 
<code><a href="#topic+PPC-censoring">PPC-censoring</a></code>,
<code><a href="#topic+PPC-discrete">PPC-discrete</a></code>,
<code><a href="#topic+PPC-distributions">PPC-distributions</a></code>,
<code><a href="#topic+PPC-errors">PPC-errors</a></code>,
<code><a href="#topic+PPC-intervals">PPC-intervals</a></code>,
<code><a href="#topic+PPC-loo">PPC-loo</a></code>,
<code><a href="#topic+PPC-overview">PPC-overview</a></code>,
<code><a href="#topic+PPC-test-statistics">PPC-test-statistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- example_y_data()
yrep &lt;- example_yrep_draws()
p1 &lt;- ppc_scatter_avg(y, yrep)
p1

# don't draw line x=y
ppc_scatter_avg(y, yrep, ref_line = FALSE)

p2 &lt;- ppc_scatter(y, yrep[20:23, ], alpha = 0.5, size = 1.5)
p2

# give x and y axes the same limits
lims &lt;- ggplot2::lims(x = c(0, 160), y = c(0, 160))
p1 + lims
p2 + lims

# for ppc_scatter_avg_grouped the default is to allow the facets
# to have different x and y axes
group &lt;- example_group_data()
ppc_scatter_avg_grouped(y, yrep, group)

# let x-axis vary but force y-axis to be the same
ppc_scatter_avg_grouped(y, yrep, group, facet_args = list(scales = "free_x"))

</code></pre>

<hr>
<h2 id='PPC-test-statistics'>PPC test statistics</h2><span id='topic+PPC-test-statistics'></span><span id='topic+PPC-statistics'></span><span id='topic+ppc_stat'></span><span id='topic+ppc_stat_grouped'></span><span id='topic+ppc_stat_freqpoly'></span><span id='topic+ppc_stat_freqpoly_grouped'></span><span id='topic+ppc_stat_2d'></span><span id='topic+ppc_stat_data'></span>

<h3>Description</h3>

<p>The distribution of a (test) statistic <code>T(yrep)</code>, or a pair of (test)
statistics, over the simulated datasets in <code>yrep</code>, compared to the
observed value <code>T(y)</code> computed from the data <code>y</code>. See the
<strong>Plot Descriptions</strong> and <strong>Details</strong> sections, below, as
well as <a href="https://github.com/jgabry/bayes-vis-paper#readme">Gabry et al. (2019)</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppc_stat(
  y,
  yrep,
  stat = "mean",
  ...,
  binwidth = NULL,
  bins = NULL,
  breaks = NULL,
  freq = TRUE
)

ppc_stat_grouped(
  y,
  yrep,
  group,
  stat = "mean",
  ...,
  facet_args = list(),
  binwidth = NULL,
  bins = NULL,
  breaks = NULL,
  freq = TRUE
)

ppc_stat_freqpoly(
  y,
  yrep,
  stat = "mean",
  ...,
  facet_args = list(),
  binwidth = NULL,
  bins = NULL,
  freq = TRUE
)

ppc_stat_freqpoly_grouped(
  y,
  yrep,
  group,
  stat = "mean",
  ...,
  facet_args = list(),
  binwidth = NULL,
  bins = NULL,
  freq = TRUE
)

ppc_stat_2d(y, yrep, stat = c("mean", "sd"), ..., size = 2.5, alpha = 0.7)

ppc_stat_data(y, yrep, group = NULL, stat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPC-test-statistics_+3A_y">y</code></td>
<td>
<p>A vector of observations. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="PPC-test-statistics_+3A_yrep">yrep</code></td>
<td>
<p>An <code>S</code> by <code>N</code> matrix of draws from the posterior (or prior)
predictive distribution. The number of rows, <code>S</code>, is the size of the
posterior (or prior) sample used to generate <code>yrep</code>. The number of columns,
<code>N</code> is the number of predicted observations (<code>length(y)</code>). The columns of
<code>yrep</code> should be in the same order as the data points in <code>y</code> for the plots
to make sense. See the <strong>Details</strong> and <strong>Plot Descriptions</strong> sections for
additional advice specific to particular plots.</p>
</td></tr>
<tr><td><code id="PPC-test-statistics_+3A_stat">stat</code></td>
<td>
<p>A single function or a string naming a function, except for the
2D plot which requires a vector of exactly two names or functions. In all
cases the function(s) should take a vector input and return a scalar
statistic. If specified as a string (or strings) then the legend will
display the function name(s). If specified as a function (or functions)
then generic naming is used in the legend.</p>
</td></tr>
<tr><td><code id="PPC-test-statistics_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="PPC-test-statistics_+3A_binwidth">binwidth</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="PPC-test-statistics_+3A_bins">bins</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="PPC-test-statistics_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> as an
alternative to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="PPC-test-statistics_+3A_freq">freq</code></td>
<td>
<p>For histograms, <code>freq=TRUE</code> (the default) puts count on the
y-axis. Setting <code>freq=FALSE</code> puts density on the y-axis. (For many
plots the y-axis text is off by default. To view the count or density
labels on the y-axis see the <code><a href="#topic+yaxis_text">yaxis_text()</a></code> convenience
function.)</p>
</td></tr>
<tr><td><code id="PPC-test-statistics_+3A_group">group</code></td>
<td>
<p>A grouping variable of the same length as <code>y</code>.
Will be coerced to <a href="base.html#topic+factor">factor</a> if not already a factor.
Each value in <code>group</code> is interpreted as the group level pertaining
to the corresponding observation.</p>
</td></tr>
<tr><td><code id="PPC-test-statistics_+3A_facet_args">facet_args</code></td>
<td>
<p>A named list of arguments (other than <code>facets</code>) passed
to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> or <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>
to control faceting. Note: if <code>scales</code> is not included in <code>facet_args</code>
then <strong>bayesplot</strong> may use <code>scales="free"</code> as the default (depending
on the plot) instead of the <strong>ggplot2</strong> default of <code>scales="fixed"</code>.</p>
</td></tr>
<tr><td><code id="PPC-test-statistics_+3A_size">size</code>, <code id="PPC-test-statistics_+3A_alpha">alpha</code></td>
<td>
<p>For the 2D plot only, arguments passed to
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> to control the appearance of scatterplot points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Binomial data, the plots may be more useful if
the input contains the &quot;success&quot; <em>proportions</em> (not discrete
&quot;success&quot; or &quot;failure&quot; counts).
</p>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">&#8288;_data()&#8288;</code> return the data that would have been drawn by the plotting
function.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>ppc_stat()</code>, <code>ppc_stat_freqpoly()</code></dt><dd>
<p>A histogram or frequency polygon of the distribution of a statistic
computed by applying <code>stat</code> to each dataset (row) in <code>yrep</code>. The value of
the statistic in the observed data, <code>stat(y)</code>, is overlaid as a vertical
line. More details and example usage of <code>ppc_stat()</code> can be found in Gabry
et al. (2019).
</p>
</dd>
<dt><code>ppc_stat_grouped()</code>,<code>ppc_stat_freqpoly_grouped()</code></dt><dd>
<p>The same as <code>ppc_stat()</code> and <code>ppc_stat_freqpoly()</code>, but a separate plot is
generated for each level of a grouping variable. More details and example
usage of <code>ppc_stat_grouped()</code> can be found in Gabry et al. (2019).
</p>
</dd>
<dt><code>ppc_stat_2d()</code></dt><dd>
<p>A scatterplot showing the joint distribution of two statistics
computed over the datasets (rows) in <code>yrep</code>. The value of the
statistics in the observed data is overlaid as large point.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. (Ch. 6)
</p>


<h3>See Also</h3>

<p>Other PPCs: 
<code><a href="#topic+PPC-censoring">PPC-censoring</a></code>,
<code><a href="#topic+PPC-discrete">PPC-discrete</a></code>,
<code><a href="#topic+PPC-distributions">PPC-distributions</a></code>,
<code><a href="#topic+PPC-errors">PPC-errors</a></code>,
<code><a href="#topic+PPC-intervals">PPC-intervals</a></code>,
<code><a href="#topic+PPC-loo">PPC-loo</a></code>,
<code><a href="#topic+PPC-overview">PPC-overview</a></code>,
<code><a href="#topic+PPC-scatterplots">PPC-scatterplots</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- example_y_data()
yrep &lt;- example_yrep_draws()
ppc_stat(y, yrep)
ppc_stat(y, yrep, stat = "sd") + legend_none()

# use your own function for the 'stat' argument
color_scheme_set("brightblue")
q25 &lt;- function(y) quantile(y, 0.25)
ppc_stat(y, yrep, stat = "q25") # legend includes function name

# can define the function in the 'stat' argument instead of
# using its name but then the legend doesn't include the function name
ppc_stat(y, yrep, stat = function(y) quantile(y, 0.25))

# plots by group
color_scheme_set("teal")
group &lt;- example_group_data()
ppc_stat_grouped(y, yrep, group)
ppc_stat_grouped(y, yrep, group) + yaxis_text()

# force y-axes to have same scales, allow x axis to vary
ppc_stat_grouped(y, yrep, group, facet_args = list(scales = "free_x")) + yaxis_text()

# the freqpoly plots use frequency polygons instead of histograms
ppc_stat_freqpoly(y, yrep, stat = "median")
ppc_stat_freqpoly_grouped(y, yrep, group, stat = "median", facet_args = list(nrow = 2))

# ppc_stat_2d allows 2 statistics and makes a scatterplot
bayesplot_theme_set(ggplot2::theme_linedraw())
color_scheme_set("viridisE")
ppc_stat_2d(y, yrep, stat = c("mean", "sd"))

bayesplot_theme_set(ggplot2::theme_grey())
color_scheme_set("brewer-Paired")
ppc_stat_2d(y, yrep, stat = c("median", "mad"))

# reset aesthetics
color_scheme_set()
bayesplot_theme_set()

</code></pre>

<hr>
<h2 id='PPD-distributions'>PPD distributions</h2><span id='topic+PPD-distributions'></span><span id='topic+ppd_data'></span><span id='topic+ppd_dens_overlay'></span><span id='topic+ppd_ecdf_overlay'></span><span id='topic+ppd_dens'></span><span id='topic+ppd_hist'></span><span id='topic+ppd_freqpoly'></span><span id='topic+ppd_freqpoly_grouped'></span><span id='topic+ppd_boxplot'></span>

<h3>Description</h3>

<p>Plot posterior or prior predictive distributions. Each of these functions
makes the same plot as the corresponding <code><a href="#topic+PPC-distributions">ppc_</a></code> function
but without plotting any observed data <code>y</code>. The <strong>Plot Descriptions</strong> section
at <a href="#topic+PPC-distributions">PPC-distributions</a> has details on the individual plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppd_data(ypred, group = NULL)

ppd_dens_overlay(
  ypred,
  ...,
  size = 0.25,
  alpha = 0.7,
  trim = FALSE,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  n_dens = 1024
)

ppd_ecdf_overlay(
  ypred,
  ...,
  discrete = FALSE,
  pad = TRUE,
  size = 0.25,
  alpha = 0.7
)

ppd_dens(ypred, ..., trim = FALSE, size = 0.5, alpha = 1)

ppd_hist(ypred, ..., binwidth = NULL, bins = NULL, breaks = NULL, freq = TRUE)

ppd_freqpoly(
  ypred,
  ...,
  binwidth = NULL,
  bins = NULL,
  freq = TRUE,
  size = 0.5,
  alpha = 1
)

ppd_freqpoly_grouped(
  ypred,
  group,
  ...,
  binwidth = NULL,
  bins = NULL,
  freq = TRUE,
  size = 0.5,
  alpha = 1
)

ppd_boxplot(ypred, ..., notch = TRUE, size = 0.5, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPD-distributions_+3A_ypred">ypred</code></td>
<td>
<p>An <code>S</code> by <code>N</code> matrix of draws from the posterior (or prior)
predictive distribution. The number of rows, <code>S</code>, is the size of the
posterior (or prior) sample used to generate <code>ypred</code>. The number of
columns, <code>N</code>, is the number of predicted observations.</p>
</td></tr>
<tr><td><code id="PPD-distributions_+3A_group">group</code></td>
<td>
<p>A grouping variable of the same length as <code>y</code>.
Will be coerced to <a href="base.html#topic+factor">factor</a> if not already a factor.
Each value in <code>group</code> is interpreted as the group level pertaining
to the corresponding observation.</p>
</td></tr>
<tr><td><code id="PPD-distributions_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="PPD-distributions_+3A_size">size</code>, <code id="PPD-distributions_+3A_alpha">alpha</code></td>
<td>
<p>Passed to the appropriate geom to control the appearance of
the predictive distributions.</p>
</td></tr>
<tr><td><code id="PPD-distributions_+3A_trim">trim</code></td>
<td>
<p>A logical scalar passed to <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code>.</p>
</td></tr>
<tr><td><code id="PPD-distributions_+3A_bw">bw</code>, <code id="PPD-distributions_+3A_adjust">adjust</code>, <code id="PPD-distributions_+3A_kernel">kernel</code>, <code id="PPD-distributions_+3A_n_dens">n_dens</code></td>
<td>
<p>Optional arguments passed to
<code><a href="stats.html#topic+density">stats::density()</a></code> to override default kernel density estimation
parameters. <code>n_dens</code> defaults to <code>1024</code>.</p>
</td></tr>
<tr><td><code id="PPD-distributions_+3A_discrete">discrete</code></td>
<td>
<p>For <code>ppc_ecdf_overlay()</code>, should the data be treated as
discrete? The default is <code>FALSE</code>, in which case <code>geom="line"</code> is
passed to <code><a href="ggplot2.html#topic+stat_ecdf">ggplot2::stat_ecdf()</a></code>. If <code>discrete</code> is set to
<code>TRUE</code> then <code>geom="step"</code> is used.</p>
</td></tr>
<tr><td><code id="PPD-distributions_+3A_pad">pad</code></td>
<td>
<p>A logical scalar passed to <code><a href="ggplot2.html#topic+stat_ecdf">ggplot2::stat_ecdf()</a></code>.</p>
</td></tr>
<tr><td><code id="PPD-distributions_+3A_binwidth">binwidth</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="PPD-distributions_+3A_bins">bins</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="PPD-distributions_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> as an
alternative to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="PPD-distributions_+3A_freq">freq</code></td>
<td>
<p>For histograms, <code>freq=TRUE</code> (the default) puts count on the
y-axis. Setting <code>freq=FALSE</code> puts density on the y-axis. (For many
plots the y-axis text is off by default. To view the count or density
labels on the y-axis see the <code><a href="#topic+yaxis_text">yaxis_text()</a></code> convenience
function.)</p>
</td></tr>
<tr><td><code id="PPD-distributions_+3A_notch">notch</code></td>
<td>
<p>For the box plot, a logical scalar passed to
<code><a href="ggplot2.html#topic+geom_boxplot">ggplot2::geom_boxplot()</a></code>. Note: unlike <code>geom_boxplot()</code>, the default is
<code>notch=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Binomial data, the plots may be more useful if
the input contains the &quot;success&quot; <em>proportions</em> (not discrete
&quot;success&quot; or &quot;failure&quot; counts).
</p>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">&#8288;_data()&#8288;</code> return the data that would have been drawn by the plotting
function.
</p>


<h3>See Also</h3>

<p>Other PPDs: 
<code><a href="#topic+PPD-intervals">PPD-intervals</a></code>,
<code><a href="#topic+PPD-overview">PPD-overview</a></code>,
<code><a href="#topic+PPD-test-statistics">PPD-test-statistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># difference between ppd_dens_overlay() and ppc_dens_overlay()
color_scheme_set("brightblue")
preds &lt;- example_yrep_draws()
ppd_dens_overlay(ypred = preds[1:50, ])
ppc_dens_overlay(y = example_y_data(), yrep = preds[1:50, ])

</code></pre>

<hr>
<h2 id='PPD-intervals'>PPD intervals</h2><span id='topic+PPD-intervals'></span><span id='topic+ppd_intervals'></span><span id='topic+ppd_intervals_grouped'></span><span id='topic+ppd_ribbon'></span><span id='topic+ppd_ribbon_grouped'></span><span id='topic+ppd_intervals_data'></span><span id='topic+ppd_ribbon_data'></span>

<h3>Description</h3>

<p>Medians and central interval estimates of posterior or prior predictive
distributions. Each of these functions makes the same plot as the
corresponding <code><a href="#topic+PPC-intervals">ppc_</a></code> function but without plotting any
observed data <code>y</code>. The <strong>Plot Descriptions</strong> section at <a href="#topic+PPC-intervals">PPC-intervals</a> has
details on the individual plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppd_intervals(
  ypred,
  x = NULL,
  ...,
  prob = 0.5,
  prob_outer = 0.9,
  alpha = 0.33,
  size = 1,
  fatten = 2.5,
  linewidth = 1
)

ppd_intervals_grouped(
  ypred,
  x = NULL,
  group,
  ...,
  facet_args = list(),
  prob = 0.5,
  prob_outer = 0.9,
  alpha = 0.33,
  size = 1,
  fatten = 2.5,
  linewidth = 1
)

ppd_ribbon(
  ypred,
  x = NULL,
  ...,
  prob = 0.5,
  prob_outer = 0.9,
  alpha = 0.33,
  size = 0.25
)

ppd_ribbon_grouped(
  ypred,
  x = NULL,
  group,
  ...,
  facet_args = list(),
  prob = 0.5,
  prob_outer = 0.9,
  alpha = 0.33,
  size = 0.25
)

ppd_intervals_data(
  ypred,
  x = NULL,
  group = NULL,
  ...,
  prob = 0.5,
  prob_outer = 0.9
)

ppd_ribbon_data(
  ypred,
  x = NULL,
  group = NULL,
  ...,
  prob = 0.5,
  prob_outer = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPD-intervals_+3A_ypred">ypred</code></td>
<td>
<p>An <code>S</code> by <code>N</code> matrix of draws from the posterior (or prior)
predictive distribution. The number of rows, <code>S</code>, is the size of the
posterior (or prior) sample used to generate <code>ypred</code>. The number of
columns, <code>N</code>, is the number of predicted observations.</p>
</td></tr>
<tr><td><code id="PPD-intervals_+3A_x">x</code></td>
<td>
<p>A numeric vector to use as the x-axis
variable. For example, <code>x</code> could be a predictor variable from a
regression model, a time variable for time-series models, etc. If <code>x</code>
is missing or <code>NULL</code> then the observation index is used for the x-axis.</p>
</td></tr>
<tr><td><code id="PPD-intervals_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="PPD-intervals_+3A_prob">prob</code>, <code id="PPD-intervals_+3A_prob_outer">prob_outer</code></td>
<td>
<p>Values between <code>0</code> and <code>1</code> indicating the desired
probability mass to include in the inner and outer intervals. The defaults
are <code>prob=0.5</code> and <code>prob_outer=0.9</code>.</p>
</td></tr>
<tr><td><code id="PPD-intervals_+3A_alpha">alpha</code>, <code id="PPD-intervals_+3A_size">size</code>, <code id="PPD-intervals_+3A_fatten">fatten</code>, <code id="PPD-intervals_+3A_linewidth">linewidth</code></td>
<td>
<p>Arguments passed to geoms. For ribbon
plots <code>alpha</code> is passed to <code><a href="ggplot2.html#topic+geom_ribbon">ggplot2::geom_ribbon()</a></code> to control the opacity
of the outer ribbon and <code>size</code> is passed to <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code> to
control the size of the line representing the median prediction (<code>size=0</code>
will remove the line). For interval plots <code>alpha</code>, <code>size</code>, <code>fatten</code>, and
<code>linewidth</code> are passed to <code><a href="ggplot2.html#topic+geom_linerange">ggplot2::geom_pointrange()</a></code> (<code>fatten=0</code> will
remove the point estimates).</p>
</td></tr>
<tr><td><code id="PPD-intervals_+3A_group">group</code></td>
<td>
<p>A grouping variable of the same length as <code>y</code>.
Will be coerced to <a href="base.html#topic+factor">factor</a> if not already a factor.
Each value in <code>group</code> is interpreted as the group level pertaining
to the corresponding observation.</p>
</td></tr>
<tr><td><code id="PPD-intervals_+3A_facet_args">facet_args</code></td>
<td>
<p>A named list of arguments (other than <code>facets</code>) passed
to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> or <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>
to control faceting. Note: if <code>scales</code> is not included in <code>facet_args</code>
then <strong>bayesplot</strong> may use <code>scales="free"</code> as the default (depending
on the plot) instead of the <strong>ggplot2</strong> default of <code>scales="fixed"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">&#8288;_data()&#8288;</code> return the data that would have been drawn by the plotting
function.
</p>


<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>


<h3>See Also</h3>

<p>Other PPDs: 
<code><a href="#topic+PPD-distributions">PPD-distributions</a></code>,
<code><a href="#topic+PPD-overview">PPD-overview</a></code>,
<code><a href="#topic+PPD-test-statistics">PPD-test-statistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>color_scheme_set("brightblue")
ypred &lt;- example_yrep_draws()
x &lt;- example_x_data()
group &lt;- example_group_data()

ppd_intervals(ypred[, 1:50])
ppd_intervals(ypred[, 1:50], fatten = 0)
ppd_intervals(ypred[, 1:50], fatten = 0, linewidth = 2)
ppd_intervals(ypred[, 1:50], prob_outer = 0.75, fatten = 0, linewidth = 2)

# put a predictor variable on the x-axis
ppd_intervals(ypred[, 1:100], x = x[1:100], fatten = 1) +
  ggplot2::labs(y = "Prediction", x = "Some variable of interest")

# with a grouping variable too
ppd_intervals_grouped(
  ypred = ypred[, 1:100],
  x = x[1:100],
  group = group[1:100],
  size = 2,
  fatten = 0,
  facet_args = list(nrow = 2)
)

# even reducing size, ppd_intervals is too cluttered when there are many
# observations included (ppd_ribbon is better)
ppd_intervals(ypred, size = 0.5, fatten = 0.1, linewidth = 0.5)
ppd_ribbon(ypred)
ppd_ribbon(ypred, size = 0) # remove line showing median prediction

</code></pre>

<hr>
<h2 id='PPD-overview'>Plots of posterior or prior predictive distributions</h2><span id='topic+PPD-overview'></span><span id='topic+PPD'></span>

<h3>Description</h3>

<p>The <strong>bayesplot</strong> PPD module provides various plotting functions
for creating graphical displays of simulated data from the posterior or
prior predictive distribution. These plots are essentially the same as the
corresponding <a href="#topic+PPC">PPC</a> plots but without showing any observed data. Because
these are not &quot;checks&quot; compared to data we use PPD (for prior/posterior
predictive distribution) instead of PPC (for prior/posterior predictive
check).
</p>


<h3>PPD plotting functions</h3>

<p>The functions for plotting prior and
posterior predictive distributions without observed data each have the
prefix <code>ppd_</code> and all have a required argument <code>ypred</code> (a matrix of
predictions). The plots are organized into several categories, each with
its own documentation:
</p>

<ul>
<li> <p><a href="#topic+PPD-distributions">PPD-distributions</a>: Histograms, kernel density estimates, boxplots, and
other plots of multiple simulated datasets (rows) in <code>ypred</code>. These are the
same as the plots in <a href="#topic+PPC-distributions">PPC-distributions</a> but without including any
comparison to <code>y</code>.
</p>
</li>
<li> <p><a href="#topic+PPD-intervals">PPD-intervals</a>: Interval estimates for each predicted observations
(columns) in <code>ypred</code>. The x-axis variable can be optionally specified by
the user (e.g. to plot against against a predictor variable or over
time).These are the same as the plots in <a href="#topic+PPC-intervals">PPC-intervals</a> but without
including any comparison to <code>y</code>.
</p>
</li>
<li> <p><a href="#topic+PPD-test-statistics">PPD-test-statistics</a>: The distribution of a statistic, or a pair of
statistics, over the simulated datasets (rows) in <code>ypred</code>. These are the
same as the plots in <a href="#topic+PPC-test-statistics">PPC-test-statistics</a> but without including any
comparison to <code>y</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>


<h3>See Also</h3>

<p>Other PPDs: 
<code><a href="#topic+PPD-distributions">PPD-distributions</a></code>,
<code><a href="#topic+PPD-intervals">PPD-intervals</a></code>,
<code><a href="#topic+PPD-test-statistics">PPD-test-statistics</a></code>
</p>

<hr>
<h2 id='PPD-test-statistics'>PPD test statistics</h2><span id='topic+PPD-test-statistics'></span><span id='topic+PPD-statistics'></span><span id='topic+ppd_stat'></span><span id='topic+ppd_stat_grouped'></span><span id='topic+ppd_stat_freqpoly'></span><span id='topic+ppd_stat_freqpoly_grouped'></span><span id='topic+ppd_stat_2d'></span><span id='topic+ppd_stat_data'></span>

<h3>Description</h3>

<p>The distribution of a (test) statistic <code>T(ypred)</code>, or a pair of (test)
statistics, over the simulations from the posterior or prior predictive
distribution. Each of these functions makes the same plot as the
corresponding <code><a href="#topic+PPC-test-statistics">ppc_</a></code> function but without comparing to
any observed data <code>y</code>. The <strong>Plot Descriptions</strong> section at
<a href="#topic+PPC-test-statistics">PPC-test-statistics</a> has details on the individual plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppd_stat(
  ypred,
  stat = "mean",
  ...,
  binwidth = NULL,
  bins = NULL,
  breaks = NULL,
  freq = TRUE
)

ppd_stat_grouped(
  ypred,
  group,
  stat = "mean",
  ...,
  facet_args = list(),
  binwidth = NULL,
  bins = NULL,
  breaks = NULL,
  freq = TRUE
)

ppd_stat_freqpoly(
  ypred,
  stat = "mean",
  ...,
  facet_args = list(),
  binwidth = NULL,
  bins = NULL,
  freq = TRUE
)

ppd_stat_freqpoly_grouped(
  ypred,
  group,
  stat = "mean",
  ...,
  facet_args = list(),
  binwidth = NULL,
  bins = NULL,
  freq = TRUE
)

ppd_stat_2d(ypred, stat = c("mean", "sd"), ..., size = 2.5, alpha = 0.7)

ppd_stat_data(ypred, group = NULL, stat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPD-test-statistics_+3A_ypred">ypred</code></td>
<td>
<p>An <code>S</code> by <code>N</code> matrix of draws from the posterior (or prior)
predictive distribution. The number of rows, <code>S</code>, is the size of the
posterior (or prior) sample used to generate <code>ypred</code>. The number of
columns, <code>N</code>, is the number of predicted observations.</p>
</td></tr>
<tr><td><code id="PPD-test-statistics_+3A_stat">stat</code></td>
<td>
<p>A single function or a string naming a function, except for the
2D plot which requires a vector of exactly two names or functions. In all
cases the function(s) should take a vector input and return a scalar
statistic. If specified as a string (or strings) then the legend will
display the function name(s). If specified as a function (or functions)
then generic naming is used in the legend.</p>
</td></tr>
<tr><td><code id="PPD-test-statistics_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="PPD-test-statistics_+3A_binwidth">binwidth</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="PPD-test-statistics_+3A_bins">bins</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="PPD-test-statistics_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> as an
alternative to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="PPD-test-statistics_+3A_freq">freq</code></td>
<td>
<p>For histograms, <code>freq=TRUE</code> (the default) puts count on the
y-axis. Setting <code>freq=FALSE</code> puts density on the y-axis. (For many
plots the y-axis text is off by default. To view the count or density
labels on the y-axis see the <code><a href="#topic+yaxis_text">yaxis_text()</a></code> convenience
function.)</p>
</td></tr>
<tr><td><code id="PPD-test-statistics_+3A_group">group</code></td>
<td>
<p>A grouping variable of the same length as <code>y</code>.
Will be coerced to <a href="base.html#topic+factor">factor</a> if not already a factor.
Each value in <code>group</code> is interpreted as the group level pertaining
to the corresponding observation.</p>
</td></tr>
<tr><td><code id="PPD-test-statistics_+3A_facet_args">facet_args</code></td>
<td>
<p>A named list of arguments (other than <code>facets</code>) passed
to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> or <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>
to control faceting. Note: if <code>scales</code> is not included in <code>facet_args</code>
then <strong>bayesplot</strong> may use <code>scales="free"</code> as the default (depending
on the plot) instead of the <strong>ggplot2</strong> default of <code>scales="fixed"</code>.</p>
</td></tr>
<tr><td><code id="PPD-test-statistics_+3A_size">size</code>, <code id="PPD-test-statistics_+3A_alpha">alpha</code></td>
<td>
<p>For the 2D plot only, arguments passed to
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> to control the appearance of scatterplot points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Binomial data, the plots may be more useful if
the input contains the &quot;success&quot; <em>proportions</em> (not discrete
&quot;success&quot; or &quot;failure&quot; counts).
</p>


<h3>Value</h3>

<p>The plotting functions return a ggplot object that can be further
customized using the <strong>ggplot2</strong> package. The functions with suffix
<code style="white-space: pre;">&#8288;_data()&#8288;</code> return the data that would have been drawn by the plotting
function.
</p>


<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow.
<em>J. R. Stat. Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378.
(<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378">journal version</a>,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>


<h3>See Also</h3>

<p>Other PPDs: 
<code><a href="#topic+PPD-distributions">PPD-distributions</a></code>,
<code><a href="#topic+PPD-intervals">PPD-intervals</a></code>,
<code><a href="#topic+PPD-overview">PPD-overview</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yrep &lt;- example_yrep_draws()
ppd_stat(yrep)
ppd_stat(yrep, stat = "sd") + legend_none()

# use your own function for the 'stat' argument
color_scheme_set("brightblue")
q25 &lt;- function(y) quantile(y, 0.25)
ppd_stat(yrep, stat = "q25") # legend includes function name
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+vars'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+vars">vars</a></code></p>
</dd>
</dl>

<hr>
<h2 id='theme_default'>Default <strong>bayesplot</strong> plotting theme</h2><span id='topic+theme_default'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+theme_default">theme_default()</a></code> function returns the default ggplot
<a href="ggplot2.html#topic+theme">theme</a> used by the <strong>bayesplot</strong> plotting functions. See
<code><a href="#topic+bayesplot_theme_set">bayesplot_theme_set()</a></code> for details on setting and updating the plotting
theme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_default(
  base_size = getOption("bayesplot.base_size", 12),
  base_family = getOption("bayesplot.base_family", "serif")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theme_default_+3A_base_size">base_size</code>, <code id="theme_default_+3A_base_family">base_family</code></td>
<td>
<p>Base font size and family (passed to
<code><a href="ggplot2.html#topic+ggtheme">ggplot2::theme_bw()</a></code>). It is possible to set <code>"bayesplot.base_size"</code> and
<code>"bayesplot.base_family"</code> via <code><a href="base.html#topic+options">options()</a></code> to change the defaults, which are
<code>12</code> and <code>"serif"</code>, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot <a href="ggplot2.html#topic+theme">theme</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesplot_theme_set">bayesplot_theme_set()</a></code> to change the ggplot theme.
</p>
<p><a href="#topic+bayesplot-colors">bayesplot-colors</a> to set or view the color scheme used
for plotting.
</p>
<p><a href="#topic+bayesplot-helpers">bayesplot-helpers</a> for a variety of convenience functions,
many of which provide shortcuts for tweaking theme elements after creating
a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>class(theme_default())

bayesplot_theme_set() # defaults to setting theme_default()
x &lt;- example_mcmc_draws()
mcmc_hist(x)

# change the default font size and family for bayesplots
bayesplot_theme_set(theme_default(base_size = 8, base_family = "sans"))
mcmc_hist(x)
mcmc_areas(x, regex_pars = "beta")

# change back
bayesplot_theme_set()
mcmc_areas(x, regex_pars = "beta")

</code></pre>

<hr>
<h2 id='tidy-params'>Tidy parameter selection</h2><span id='topic+tidy-params'></span><span id='topic+param_range'></span><span id='topic+param_glue'></span>

<h3>Description</h3>

<p>Parameter selection in the style of <strong>dplyr</strong> and other tidyverse packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_range(prefix, range, vars = NULL)

param_glue(pattern, ..., vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy-params_+3A_prefix">prefix</code>, <code id="tidy-params_+3A_range">range</code></td>
<td>
<p>For <code>param_range()</code> only, <code>prefix</code> is a string naming a
parameter and <code>range</code> is an integer vector providing the indices of a
subset of elements to select. For example, using
</p>
<div class="sourceCode"><pre>  param_range("beta", c(1,2,8))
</pre></div>
<p>would select parameters named <code>beta[1]</code>, <code>beta[2]</code>, and <code>beta[8]</code>.
<code>param_range()</code> is only designed for the case that the indices are integers
surrounded by brackets. If there are no brackets use
<a href="tidyselect.html#topic+language">num_range()</a>.</p>
</td></tr>
<tr><td><code id="tidy-params_+3A_vars">vars</code></td>
<td>
<p><code>NULL</code> or a character vector of parameter names to choose from.
This is only needed for the atypical use case of calling the function as a
standalone function outside of <code>vars()</code>, <code>select()</code>, etc. Typically this is
left as <code>NULL</code> and will be set automatically for the user.</p>
</td></tr>
<tr><td><code id="tidy-params_+3A_pattern">pattern</code>, <code id="tidy-params_+3A_...">...</code></td>
<td>
<p>For <code>param_glue()</code> only, <code>pattern</code> is a string containing
expressions enclosed in braces and <code>...</code> should be named arguments
providing one character vector per expression in braces in <code>pattern</code>. It is
easiest to describe how to use these arguments with an example:
</p>
<div class="sourceCode"><pre>param_glue("beta_{var}[{level}]",
           var = c("age", "income"),
           level = c(3,8))
</pre></div>
<p>would select parameters with names
<code>"beta_age[3]"</code>, <code>"beta_income[3]"</code>, <code>"beta_age[8]"</code>, <code>"beta_income[8]"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of version <code style="white-space: pre;">&#8288;1.7.0&#8288;</code>, <strong>bayesplot</strong> allows the <code>pars</code> argument for <a href="#topic+MCMC-overview">MCMC plots</a> to use &quot;tidy&quot; variable selection (in the
style of the <strong>dplyr</strong> package). The <code><a href="dplyr.html#topic+vars">vars()</a></code> function is
re-exported from <strong>dplyr</strong> for this purpose.
</p>
<p>Features of tidy selection includes direct selection (<code>vars(alpha, sigma)</code>),
everything-but selection (<code>vars(-alpha)</code>), ranged selection
(<code>vars(`beta[1]`:`beta[3]`)</code>), support for selection functions
(<code>vars(starts_with("beta"))</code>), and combinations of these features. See the
<strong>Examples</strong> section, below.
</p>
<p>When using <code>pars</code> for tidy parameter selection, the <code>regex_pars</code> argument is
ignored because <strong>bayesplot</strong> supports using <a href="tidyselect.html#topic+language">tidyselect helper functions</a> (<code>starts_with()</code>, <code>contains()</code>,
<code>num_range()</code>, etc.) for the same purpose. <strong>bayesplot</strong> also exports some
additional helper functions to help with parameter selection:
</p>

<ul>
<li> <p><code>param_range()</code>: like <code><a href="tidyselect.html#topic+starts_with">num_range()</a></code> but used
when parameter indexes are in brackets (e.g. <code>beta[2]</code>).
</p>
</li>
<li> <p><code>param_glue()</code>: for more complicated parameter names with multiple
indexes (including variable names) inside the brackets
(e.g., <code style="white-space: pre;">&#8288;beta[(Intercept) age_group:3]&#8288;</code>).
</p>
</li></ul>

<p>These functions can be used inside of <code>vars()</code>, <code>dplyr::select()</code>,
and similar functions, just like the
<a href="tidyselect.html#topic+language">tidyselect helper functions</a>.
</p>


<h3>Extra Advice</h3>

<p>Parameter names in <code>vars()</code> are not quoted. When the names contain special
characters like brackets, they should be wrapped in backticks, as in
<code>vars(`beta[1]`)</code>.
</p>
<p>To exclude a range of variables, wrap the sequence in parentheses and then
negate it. For example, (<code>vars(-(`beta[1]`:`beta[3]`))</code>) would exclude
<code>beta[1]</code>, <code>beta[2]</code>, and <code>beta[3]</code>.
</p>
<p><code>vars()</code> is a helper function. It holds onto the names and expressions used
to select columns. When selecting variables inside a <strong>bayesplot</strong>
function, use <code>vars(...)</code>: <code>mcmc_hist(data, pars = vars(alpha))</code>. When
using <code>select()</code> to prepare a dataframe for a <strong>bayesplot</strong> function, do
not use <code>vars()</code>: <code>data %&gt;% select(alpha) %&gt;% mcmc_hist()</code>.
</p>
<p>Internally, tidy selection works by converting names and expressions
into position numbers. As a result, integers will select parameters;
<code>vars(1, 3)</code> selects the first and third ones. We do not endorse this
approach because positions might change as variables are added and
removed from models. To select a parameter that happens to be called <code>1</code>,
use backticks to escape it <code>vars(`1`)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="glue.html#topic+glue">glue::glue()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_mcmc_draws(params = 6)
dimnames(x)
mcmc_hex(x, pars = vars(alpha, `beta[2]`))
mcmc_dens(x, pars = vars(sigma, contains("beta")))
mcmc_hist(x, pars = vars(-contains("beta")))

# using the param_range() helper
mcmc_hist(x, pars = vars(param_range("beta", c(1, 3, 4))))


#############################
## Examples using rstanarm ##
#############################
if (requireNamespace("rstanarm", quietly = TRUE)) {
  # see ?rstanarm::example_model
  fit &lt;- example("example_model", package = "rstanarm", local=TRUE)$value
  print(fit)
  posterior &lt;- as.data.frame(fit)
  str(posterior)

  color_scheme_set("brightblue")
  mcmc_hist(posterior, pars = vars(size, contains("period")))

  # same as previous but using dplyr::select() and piping
  library("dplyr")
  posterior %&gt;%
    select(size, contains("period")) %&gt;%
    mcmc_hist()

  mcmc_intervals(posterior, pars = vars(contains("herd")))
  mcmc_intervals(posterior, pars = vars(contains("herd"), -contains("Sigma")))

  bayesplot_theme_set(ggplot2::theme_dark())
  color_scheme_set("viridisC")
  mcmc_areas_ridges(posterior, pars = vars(starts_with("b[")))

  bayesplot_theme_set()
  color_scheme_set("purple")
  not_789 &lt;- vars(starts_with("b["), -matches("[7-9]"))
  mcmc_intervals(posterior, pars = not_789)

  # using the param_glue() helper
  just_149 &lt;- vars(param_glue("b[(Intercept) herd:{level}]", level = c(1,4,9)))
  mcmc_intervals(posterior, pars = just_149)

  # same but using param_glue() with dplyr::select()
  # before passing to bayesplot
  posterior %&gt;%
    select(param_glue("b[(Intercept) herd:{level}]",
                      level = c(1, 4, 9))) %&gt;%
    mcmc_intervals()
}

## Not run: 
###################################
## More examples of param_glue() ##
###################################
library(dplyr)
posterior &lt;- tibble(
  b_Intercept = rnorm(1000),
  sd_condition__Intercept = rexp(1000),
  sigma = rexp(1000),
  `r_condition[A,Intercept]` = rnorm(1000),
  `r_condition[B,Intercept]` = rnorm(1000),
  `r_condition[C,Intercept]` = rnorm(1000),
  `r_condition[A,Slope]` = rnorm(1000),
  `r_condition[B,Slope]` = rnorm(1000)
)
posterior

# using one expression in braces
posterior %&gt;%
  select(
    param_glue("r_condition[{level},Intercept]", level = c("A", "B"))
  ) %&gt;%
  mcmc_hist()

# using multiple expressions in braces
posterior %&gt;%
   select(
     param_glue(
       "r_condition[{level},{type}]",
        level = c("A", "B"),
        type = c("Intercept", "Slope"))
   ) %&gt;%
   mcmc_hist()

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
