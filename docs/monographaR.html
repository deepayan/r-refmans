<!DOCTYPE html><html><head><title>Help for package monographaR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {monographaR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#monographaR'><p>Tools for taxonomic monographs.</p></a></li>
<li><a href='#buildMonograph'>
<p>Build and export a monograph skeleton (draft)</p></a></li>
<li><a href='#codeGap'>
<p>Code gap</p></a></li>
<li><a href='#codeMatrix'>
<p>Code character matrix</p></a></li>
<li><a href='#collectorList'>
<p>Generates a collector list</p></a></li>
<li><a href='#dataKey'>
<p>Prepares a data.frame suitable for buildKey</p></a></li>
<li><a href='#dichoKey'>
<p>Dichotomous key</p></a></li>
<li><a href='#dichoKey.app'>
<p>Dichotomous key (shiny app)</p></a></li>
<li><a href='#examinedSpecimens'>
<p>Generates an examined specimens list</p></a></li>
<li><a href='#interactiveKey'>
<p>Interactive key (shiny app)</p></a></li>
<li><a href='#interactiveKeyLabels'>
<p>Text labels for interactiveKey</p></a></li>
<li><a href='#keyCode'>
<p>keyCode</p></a></li>
<li><a href='#mapBatch'>
<p>Generates map in batch mode</p></a></li>
<li><a href='#mapDiversity'>
<p>Diversity heatmap</p></a></li>
<li><a href='#mapPhenology'>
<p>Phenology heatmap</p></a></li>
<li><a href='#mapTable'>
<p>Generates a presence/absence matrix of species on grids or countries</p></a></li>
<li><a href='#monographaR_examples'>
<p>Input data examples</p></a></li>
<li><a href='#phenoHist'>
<p>Circular histograms of phenology</p></a></li>
<li><a href='#tableToDescription'>
<p>Generates species descriptions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-01</td>
</tr>
<tr>
<td>Title:</td>
<td>Taxonomic Monographs Tools</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcelo Reginato</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcelo Reginato &lt;reginatobio@yahoo.com.br&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>circular, png, raster, rmarkdown, rnaturalearth, rpart, sf,
shiny, shinydashboard, shinythemes, shinyWidgets, sp, terra</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions intended to facilitate the production of plant taxonomic monographs. The package includes functions to convert tables into taxonomic descriptions, lists of collectors, examined specimens, identification keys (dichotomous and interactive), and can generate a monograph skeleton. Additionally, wrapper functions to batch the production of phenology histograms and distributional and diversity maps are also available.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-08 12:16:18 UTC; regin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-08 13:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='monographaR'>Tools for taxonomic monographs.</h2><span id='topic+monographaR'></span><span id='topic+monographaR-package'></span>

<h3>Description</h3>

<p>monographaR contains functions intended to facilitate the production
of plant taxonomic monographs. The package includes functions to convert 
tables into taxonomic descriptions, lists of collectors, examined specimens, 
identificatio keys (dichotomous and interactive), and can generate a 
monograph skeleton. Additionally, wrapper functions to batch the 
production of phenology histograms and distributional and diversity 
maps are also available. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> monographaR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-01</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>
<p>Maintainer: Marcelo Reginato &lt;reginatobio@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Reginato, M. (2016) monographaR: an R package to facilitate the production 
of plant taxonomic monographs. Brittonia 68(2): 212-216.
</p>


<h3>See Also</h3>

<p><code><a href="circular.html#topic+circular-package">circular</a></code>
<code><a href="raster.html#topic+raster-package">raster</a></code>
<code><a href="sp.html#topic+sp">sp</a></code>
<code><a href="rmarkdown.html#topic+rmarkdown-package">rmarkdown</a></code>
<code><a href="rpart.html#topic+rpart">rpart</a></code>
</p>

<hr>
<h2 id='buildMonograph'>
Build and export a monograph skeleton (draft)
</h2><span id='topic+buildMonograph'></span>

<h3>Description</h3>

<p>This function will generate a MS-Word or html file with a monograph skeleton (draft)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildMonograph(headings, tableToDescription.data, examinedSpecimens.data = NULL, 
collectorList.data = NULL, output = "Word", title = "Taxonomic treatment", 
open = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildMonograph_+3A_headings">headings</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="buildMonograph_+3A_tabletodescription.data">tableToDescription.data</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="buildMonograph_+3A_examinedspecimens.data">examinedSpecimens.data</code></td>
<td>

<p>data.frame (optional)
</p>
</td></tr>
<tr><td><code id="buildMonograph_+3A_collectorlist.data">collectorList.data</code></td>
<td>

<p>data.frame (optional)
</p>
</td></tr>
<tr><td><code id="buildMonograph_+3A_output">output</code></td>
<td>

<p>&quot;Word&quot; or &quot;html&quot;
</p>
</td></tr>
<tr><td><code id="buildMonograph_+3A_title">title</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="buildMonograph_+3A_open">open</code></td>
<td>

<p>logical
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps around the functions tableToDescription, 
examinedSpecimens and collectorList generating a monograph draft in 
MS-Word or html format. The resulting monograph skeleton will include the
taxonomic heading, the description, comments and examined specimens list 
for all species found in the input tables, and it will append the collector
list in the end of the file. It requires four tables as input. Three of them
are the same tables used for <code><a href="#topic+tableToDescription">tableToDescription</a></code>, <code><a href="#topic+collectorList">collectorList</a></code>, and 
<code><a href="#topic+examinedSpecimens">examinedSpecimens</a></code> functions. The additional input table should have three 
columns: species, taxonomic heading and comments. The examinedSpecimens.data and
collectorList.data tables are optional. It uses functions of the <code><a href="rmarkdown.html#topic+render">rmarkdown</a></code> 
package to export the output file. 
</p>


<h3>Value</h3>

<p>Exports a file (MS-Word or html).
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>See Also</h3>

<p><code><a href="rmarkdown.html#topic+rmarkdown-package">rmarkdown</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(monographaR_examples)
monographaR_examples$taxonomic_headings -&gt; taxonomic.headings
monographaR_examples$collectorList -&gt; col.d
monographaR_examples$examinedSpecimens -&gt; exam.d
monographaR_examples$tableToDescription -&gt; desc.d
desc.d[,-1] -&gt; desc.d

###	buildMonograph(headings=taxonomic.headings, 
###               collectorList.data = col.d, 
###               examinedSpecimens.data = exam.d, 
###               tableToDescription.data = desc.d, 
###               output = "Word", title="Monograph skeleton")


</code></pre>

<hr>
<h2 id='codeGap'>
Code gap
</h2><span id='topic+codeGap'></span>

<h3>Description</h3>

<p>This function takes a numeric vector (or a data.frame with two columns including min and max values of a sample) and tries to find breaks in the distribution (gaps), if any gap is found it returns a coded character based on that. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codeGap(x, n = NULL, max.states = NULL, poly.sep = "/", gap.size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codeGap_+3A_x">x</code></td>
<td>

<p>integer/numeric or a two column data.frame (min and max)
</p>
</td></tr>
<tr><td><code id="codeGap_+3A_n">n</code></td>
<td>

<p>integer, desired number of states (if NULL the function will try to suggest a number)
</p>
</td></tr>
<tr><td><code id="codeGap_+3A_max.states">max.states</code></td>
<td>

<p>integer, the maximum possible number of states
</p>
</td></tr>
<tr><td><code id="codeGap_+3A_poly.sep">poly.sep</code></td>
<td>

<p>character, to indicate polymorphic states (if any)
</p>
</td></tr>
<tr><td><code id="codeGap_+3A_gap.size">gap.size</code></td>
<td>

<p>numeric, the number that should be considered as a &quot;gap&quot;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If n = NULL the function will try to find the best scenario of states (n) based on the number of polymophic samples in the resulting classification. In large data sets it will be a good idea to constrain the search using (e.g., max.states=10). This coding tries to replicate the coding traditionally used in taxonomy.
</p>


<h3>Value</h3>

<p>list, including: 
dat = data.frame including the original value and the coded value (state)
polymorphic = the number of polymorphic samples (if n=NULL, it returns for all tested scenarios)
dist = a histogram of the data distribution 
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c(NA, 1:5, 15:20, 25:42, 49:60, 68:90) -&gt; x
data.frame(x,x=x+2) -&gt; x2

codeGap(x, n=3, max.states = 5) -&gt; code1
code1$dat

### check the distribution

na.omit(unique(code1$dat$state)) -&gt; b
cols &lt;- sort(rep(rainbow(length(b)),2))
as.numeric(unlist(strsplit(b, "-"))) -&gt; b
plot(code1$dist)
abline(v=b, lty="dashed", col=cols, lwd=2)

### estimate "n"

codeGap(x, n=NULL, max.states = NULL) -&gt; code1
code1$dat
plot(code1$dist)

### check the distribution

na.omit(unique(code1$dat$state)) -&gt; b
cols &lt;- sort(rep(rainbow(length(b)),2))
as.numeric(unlist(strsplit(b, "-"))) -&gt; b
plot(code1$dist)
abline(v=b, lty="dashed", col=cols, lwd=2)

### ranges

codeGap(x2, n=NULL, max.states =3 , gap.size=2) -&gt; code1
code1$dat
unique(code1$dat$state)

### check the distribution

na.omit(unique(code1$dat$state)) -&gt; b
cols &lt;- sort(rep(rainbow(length(b)),2))
as.numeric(unlist(strsplit(b, "-"))) -&gt; b
plot(code1$dist)
abline(v=b, lty="dashed", col=cols, lwd=2)


</code></pre>

<hr>
<h2 id='codeMatrix'>
Code character matrix
</h2><span id='topic+codeMatrix'></span>

<h3>Description</h3>

<p>This is a wrapper function to <a href="#topic+codeGap">codeGap</a>, which accepts a data.frame of characters values including ranges (1-10).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codeMatrix(dat, n = NULL, max.states = NULL, poly.sep = "/", gap.size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codeMatrix_+3A_dat">dat</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="codeMatrix_+3A_n">n</code></td>
<td>

<p>integer, see <code><a href="#topic+codeGap">codeGap</a></code>
</p>
</td></tr>
<tr><td><code id="codeMatrix_+3A_max.states">max.states</code></td>
<td>

<p>integer, see <code><a href="#topic+codeGap">codeGap</a></code>
</p>
</td></tr>
<tr><td><code id="codeMatrix_+3A_poly.sep">poly.sep</code></td>
<td>

<p>character, see <code><a href="#topic+codeGap">codeGap</a></code>
</p>
</td></tr>
<tr><td><code id="codeMatrix_+3A_gap.size">gap.size</code></td>
<td>

<p>integer, see <code><a href="#topic+codeGap">codeGap</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>See Also</h3>

<p><code><a href="#topic+codeGap">codeGap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(monographaR_examples)
monographaR_examples$dichoKey_q -&gt; dat
rownames(dat) &lt;- dat[,1]
dat[,-1] -&gt; dat

codeMatrix(dat, max.states = 3) -&gt; mat
head(mat)


</code></pre>

<hr>
<h2 id='collectorList'>
Generates a collector list
</h2><span id='topic+collectorList'></span>

<h3>Description</h3>

<p>This function will generate a txt file with a collector list for all species in data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collectorList(data = data, filename = "collector_list.txt", 
paragraphs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collectorList_+3A_data">data</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="collectorList_+3A_filename">filename</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="collectorList_+3A_paragraphs">paragraphs</code></td>
<td>

<p>logical
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It requires a data.frame with five columns, ordered as species, collector name, collector
number, herbarium acronym and herbarium number. Herbarium columns are only used if 
any collector number is missing (NA). Thus, if there is no missing values in
collector number, then the herbarium columns might be empty.
</p>


<h3>Value</h3>

<p>Exports a txt file.
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## loading the example data

data(monographaR_examples)
monographaR_examples$collectorList -&gt; data
head(data)

## running the function, it will print in the terminal the output. 
## To export a txt, place a ## name in the filename argument
## (i.e., filename = "myoutput.txt")

collectorList(data, filename = "", paragraphs = TRUE)

## or a second option

collectorList(data, filename = "", paragraphs = FALSE)


</code></pre>

<hr>
<h2 id='dataKey'>
Prepares a data.frame suitable for buildKey
</h2><span id='topic+dataKey'></span>

<h3>Description</h3>

<p>This function takes a data.frame with polymorphic and/or 
missing data (NA) characters and prepares 
it to use in the function buildKey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataKey(dat, poly.sep = "/", return.summary = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataKey_+3A_dat">dat</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="dataKey_+3A_poly.sep">poly.sep</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="dataKey_+3A_return.summary">return.summary</code></td>
<td>

<p>boolean
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a data.frame with polymorphic characters and prepares 
it to use in the function buildKey.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dichoKey">dichoKey</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(monographaR_examples)

monographaR_examples$dichoKey -&gt; dat
colnames(dat)[1] &lt;- "species"

### Prepare matrix (polymorphic)

dataKey(dat, poly.sep = "/") -&gt; dat.k
dat.k$dat -&gt; dat.p

</code></pre>

<hr>
<h2 id='dichoKey'>
Dichotomous key
</h2><span id='topic+dichoKey'></span>

<h3>Description</h3>

<p>This function generates a dichotomous key
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dichoKey(dat, cost = NULL, clean.characters = TRUE, cp = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dichoKey_+3A_dat">dat</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="dichoKey_+3A_cost">cost</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="dichoKey_+3A_clean.characters">clean.characters</code></td>
<td>

<p>boolean
</p>
</td></tr>
<tr><td><code id="dichoKey_+3A_cp">cp</code></td>
<td>

<p>numeric
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function based on the rpart function of the rpart package.
It modifies the output of rpart to a more &quot;taxonomic&quot; dichotomous key.
</p>


<h3>Value</h3>

<p>list
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>See Also</h3>

<p><code><a href="rpart.html#topic+rpart">rpart</a></code>
<code><a href="#topic+dataKey">dataKey</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(monographaR_examples)

monographaR_examples$dichoKey -&gt; dat
colnames(dat)[1] &lt;- "species"

### Prepare matrix (polymorphic)

dataKey(dat, poly.sep = "/") -&gt; dat.k
dat.k$dat -&gt; dat.p

### key

dichoKey(dat.p) -&gt; key
length(key$unresolved)

# Export

#cat(key$key, file="Pleiochiton_key.txt")

### key with costs

dat.k$summary
((dat.k$summary)+1) -&gt; dat.c
colnames(dat.p)
dat.c[2] &lt;- max(dat.c)
dat.c[11] &lt;- max(dat.c)

dichoKey(dat.p, dat.c, cp=0) -&gt; key.c
length(key.c$unresolved)

# Export

#cat(key.c$key, file="Pleiochiton_key_costs.txt")



</code></pre>

<hr>
<h2 id='dichoKey.app'>
Dichotomous key (shiny app)
</h2><span id='topic+dichoKey.app'></span>

<h3>Description</h3>

<p>This is a shiny app that generates a dichotomous key
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dichoKey.app()
</code></pre>


<h3>Details</h3>

<p>A shiny app that runs the function &quot;dichoKey&quot;. It allows 
the user to easily subset the data (taxa and characters), 
as well as change the cost values of the characters.
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>See Also</h3>

<p><code><a href="rpart.html#topic+rpart">rpart</a></code>
<code><a href="#topic+dataKey">dataKey</a></code>
<code><a href="#topic+dichoKey">dichoKey</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {

dichoKey.app()

}

</code></pre>

<hr>
<h2 id='examinedSpecimens'>
Generates an examined specimens list
</h2><span id='topic+examinedSpecimens'></span>

<h3>Description</h3>

<p>This function will generate a txt file with an examined specimens list. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>examinedSpecimens(data, filename = "examined.txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="examinedSpecimens_+3A_data">data</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="examinedSpecimens_+3A_filename">filename</code></td>
<td>

<p>character
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It requires a data.frame with eight columns, ordered as: species, collector name, collector
number, herbarium acronym, herbarium number, country, state and municipality. 
</p>


<h3>Value</h3>

<p>Exports a txt file.
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## loading the example data

data(monographaR_examples)
monographaR_examples$examinedSpecimens -&gt; data
head(data)

## running the function, it will print in the terminal the output. 
## To export a txt, place a name in the filename argument
## (i.e., filename = "myoutput.txt")

examinedSpecimens(data, filename = "")

</code></pre>

<hr>
<h2 id='interactiveKey'>
Interactive key (shiny app)
</h2><span id='topic+interactiveKey'></span>

<h3>Description</h3>

<p>Generates code to build an interactive key (shiny app)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interactiveKey(dat = NULL, txt.labels = NULL, poly.sep = "/", 
taxa.in.italics = TRUE, theme = "lumen", about.first = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interactiveKey_+3A_dat">dat</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="interactiveKey_+3A_txt.labels">txt.labels</code></td>
<td>

<p>data.frame 
</p>
</td></tr>
<tr><td><code id="interactiveKey_+3A_poly.sep">poly.sep</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="interactiveKey_+3A_taxa.in.italics">taxa.in.italics</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="interactiveKey_+3A_theme">theme</code></td>
<td>

<p>character 
</p>
</td></tr>
<tr><td><code id="interactiveKey_+3A_about.first">about.first</code></td>
<td>

<p>logical, whether the tab &quot;about&quot; is the first or the last 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See vignette
</p>


<h3>Value</h3>

<p>It generates 6 files (app.R, server.R, ui.R, about.Rmd, Dat_characters.csv, and Dat_matrix.csv)
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interactiveKeyLabels">interactiveKeyLabels</a></code>
<code><a href="shinythemes.html#topic+shinythemes">themes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see vignette
data(monographaR_examples)
monographaR_examples$interactiveKey

</code></pre>

<hr>
<h2 id='interactiveKeyLabels'>
Text labels for interactiveKey
</h2><span id='topic+interactiveKeyLabels'></span>

<h3>Description</h3>

<p>It generates a data.frame with txt labels required to use the function interactiveKey
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interactiveKeyLabels(taxon = "species", language = "english")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interactiveKeyLabels_+3A_taxon">taxon</code></td>
<td>

<p>character, &quot;species&quot;, &quot;genus&quot; or &quot;family&quot;
</p>
</td></tr>
<tr><td><code id="interactiveKeyLabels_+3A_language">language</code></td>
<td>

<p>character, &quot;english&quot; or &quot;portuguese&quot;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It generates a data.frame with txt labels required to use the function interactiveKey.
You can choose what rank will be identified in the key (species, genus or family),
and the language (english and portuguese so far). You can further modify the fields
prior using it with the interactiveKey function.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interactiveKey">interactiveKey</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### standard labels species in english

interactiveKeyLabels(taxon = "species", language = "english") -&gt; labs.spp.eng
labs.spp.eng

### standard labels families in portuguese

interactiveKeyLabels(taxon = "family", language = "portuguese") -&gt; labs.fam.por
labs.fam.por

</code></pre>

<hr>
<h2 id='keyCode'>
keyCode
</h2><span id='topic+keyCode'></span>

<h3>Description</h3>

<p>Internal code (interactiveKey)
</p>

<hr>
<h2 id='mapBatch'>
Generates map in batch mode
</h2><span id='topic+mapBatch'></span>

<h3>Description</h3>

<p>This wrapper function will export maps for all species in data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapBatch(data, zoom = T, margin = 0.1, axes = T, shape = NULL,
export = "pdf", raster = NULL, RGB = NULL, points.col = "black", 
points.border = "gray50", points.cex = 1, shape.col = "white", 
shape.border = "black", raster.col = rev(gray.colors(65, start = 0, end = 1)), 
raster.legend = F, hillshade = F, width = 8, height = 8, 
image.resolution = 100, figure.number = T, title = T, box = T, 
add.minimap = F, minimap.shape = NULL, minimap.shape.col = "white", 
minimap.shape.border = "gray50", minimap.pos = "topleft", 
minimap.add.points = T, minimap.points.col = "black", 
minimap.points.border = "gray50", minimap.points.cex = 1, 
minimap.extent = NULL, minimap.rect.fill = NA, minimap.rect.border = NULL,
maxpixels = 1e+05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapBatch_+3A_data">data</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_zoom">zoom</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_margin">margin</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_axes">axes</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_shape">shape</code></td>
<td>

<p>a single or a list of spatial shape objects
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_export">export</code></td>
<td>

<p>&quot;pdf&quot;, &quot;jpeg&quot; or &quot;tiff&quot;
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_raster">raster</code></td>
<td>

<p>a raster object
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_rgb">RGB</code></td>
<td>

<p>a raster stack object (with three layers)
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_points.col">points.col</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_points.border">points.border</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_points.cex">points.cex</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_shape.col">shape.col</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_shape.border">shape.border</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_raster.col">raster.col</code></td>
<td>

<p>character (a vector of colors)
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_raster.legend">raster.legend</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_hillshade">hillshade</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_width">width</code></td>
<td>

<p>numeric (in inches)
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_height">height</code></td>
<td>

<p>numeric (in inches)
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_image.resolution">image.resolution</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_figure.number">figure.number</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_title">title</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_box">box</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_add.minimap">add.minimap</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_minimap.shape">minimap.shape</code></td>
<td>

<p>a spatial shape object
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_minimap.shape.col">minimap.shape.col</code></td>
<td>

<p>character (color)
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_minimap.shape.border">minimap.shape.border</code></td>
<td>

<p>character (color)
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_minimap.pos">minimap.pos</code></td>
<td>

<p>&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot; or &quot;bottomright&quot;
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_minimap.add.points">minimap.add.points</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_minimap.points.col">minimap.points.col</code></td>
<td>

<p>character (color)
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_minimap.points.border">minimap.points.border</code></td>
<td>

<p>character (color)
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_minimap.points.cex">minimap.points.cex</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_minimap.extent">minimap.extent</code></td>
<td>

<p>numeric (x1, x2, y1, y2)
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_minimap.rect.fill">minimap.rect.fill</code></td>
<td>

<p>character (color)
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_minimap.rect.border">minimap.rect.border</code></td>
<td>

<p>character (color)
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_maxpixels">maxpixels</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="mapBatch_+3A_...">...</code></td>
<td>

<p>additional arguments for plotting the extra shapes
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function has three output options: a single pdf with all maps (export = 
&quot;pdf&quot;) or individual image files for each species (export = &quot;tiff&quot; or &quot;jpeg&quot;). 
It requires a data.frame with three columns, ordered as: species, longitude 
and latitude. If zoom = TRUE, the function will set the limits of the plot 
using the distribution of each species plus the margin (relative value). If 
zoom = FALSE, the function will use the distribution of the whole data to set 
the limits (all maps will have the same limits). Colors can be changed with 
the arguments points.col, shape.col, shape.border, while the size of the 
points can be changed with points.cex. A raster layer can be provided 
(elevation for instance), and the colors of the raster are controlled by 
raster.col. The user can provide a single or a list of shape files, 
otherwise the <code><a href="rnaturalearth.html#topic+ne_countries">rnaturalearth</a></code> map is used.
</p>


<h3>Value</h3>

<p>Exports a pdf or image files.
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>See Also</h3>

<p><code><a href="raster.html#topic+raster-package">raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## loading the example data

data(monographaR_examples)
monographaR_examples$map_data -&gt; data
head(data)

## running the function

# mapBatch(data , type="simple", zoom=T, margin=0.2, points.col="black",
# points.border="white", shape.col="gray90", points.cex=1.5, shape.border 
# = "gray90", export="pdf")

</code></pre>

<hr>
<h2 id='mapDiversity'>
Diversity heatmap
</h2><span id='topic+mapDiversity'></span>

<h3>Description</h3>

<p>This function will generate a diversity heatmap using presence/absence of 
species on grid cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapDiversity(data, resolution = 1, plot = T, plot.with.grid = T, 
col=rev(terrain.colors(55)), alpha=0.8, export = F, legend = T, 
filename = "diversity_map")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapDiversity_+3A_data">data</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="mapDiversity_+3A_resolution">resolution</code></td>
<td>

<p>numeric, size of the grid cells (degrees)
</p>
</td></tr>
<tr><td><code id="mapDiversity_+3A_plot">plot</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapDiversity_+3A_plot.with.grid">plot.with.grid</code></td>
<td>

<p>logical, whether or not to add a grid to the plot
</p>
</td></tr>
<tr><td><code id="mapDiversity_+3A_col">col</code></td>
<td>

<p>character, a vector of colors
</p>
</td></tr>
<tr><td><code id="mapDiversity_+3A_alpha">alpha</code></td>
<td>

<p>numerical, controls color transparency (0-1)
</p>
</td></tr>
<tr><td><code id="mapDiversity_+3A_export">export</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapDiversity_+3A_legend">legend</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapDiversity_+3A_filename">filename</code></td>
<td>

<p>character
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It requires a data.frame with three columns, ordered as: species, longitude 
and latitude. The function will plot and return a raster object. The 
resolution of the grid can be changed by the argument &quot;resolution&quot; (in 
degrees). It uses functions of the package raster.
</p>


<h3>Value</h3>

<p>A raster object.
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>See Also</h3>

<p><code><a href="raster.html#topic+raster-package">raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## loading the example data

data(monographaR_examples)
monographaR_examples$map_data -&gt; data
head(data)

## running the function

mapDiversity(data , resolution=1, plot=TRUE, plot.with.grid=TRUE)

## Without the grid borders

mapDiversity(data , resolution=1, plot=TRUE, plot.with.grid=FALSE)

## Changing colors

mapDiversity(data , resolution=1, plot=TRUE, col=gray.colors(55))

## Changing transparency

mapDiversity(data , resolution=1, plot=TRUE, alpha=0.5)

## The function returns a raster object

mapDiversity(data , resolution=1, plot=TRUE, alpha=0.5, plot.with.grid=FALSE) -&gt; my.div.raster
my.div.raster
# plot(my.div.raster)
# writeRaster(my.div.raster, "mydivraster.tif")

</code></pre>

<hr>
<h2 id='mapPhenology'>
Phenology heatmap
</h2><span id='topic+mapPhenology'></span>

<h3>Description</h3>

<p>This function will generate phenology maps across time (month, week, etc..).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapPhenology(data, resolution = 1, time.range = c(1:12), label = "Month", 
binary = T, by_species = F, plot = T, col = rev(heat.colors(12)), 
alpha = 0.8, mfrow = c(4, 3), legend = T, pdf = F, height = 11, 
width = 8.5, filename = "mapPhenology.pdf")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapPhenology_+3A_data">data</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_resolution">resolution</code></td>
<td>

<p>numeric (degrees)
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_time.range">time.range</code></td>
<td>

<p>numeric (vector of months, weeks, etc...)
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_label">label</code></td>
<td>

<p>character (&quot;Month&quot;, &quot;Week&quot;)
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_binary">binary</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_by_species">by_species</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_plot">plot</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_col">col</code></td>
<td>

<p>character (vector of colors)
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_alpha">alpha</code></td>
<td>

<p>numeric (0-1)
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_mfrow">mfrow</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_legend">legend</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_pdf">pdf</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_height">height</code></td>
<td>

<p>numerical
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_width">width</code></td>
<td>

<p>numerical
</p>
</td></tr>
<tr><td><code id="mapPhenology_+3A_filename">filename</code></td>
<td>

<p>character
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This wrapper function will generate heatmaps of phenology across a time range. 
The default is to produce 12 heatmaps plotted on a single plate. This can be 
changed with the argument time.range, where any numerical range can be provided 
(representing weeks for instance). The argument mfrow controls the plate layout. 
It requires a data.frame with four columns, ordered as: species, longitude, 
latitude and phenology. The phenology column should be numeric (i.e., the number 
of the month, week or day the specimen was collected with flower/fruit). It is 
possible to change the resolution of the resulting rasters. The function can 
produce presence/absence heatmaps (if binary = T) or abundance heatmaps 
(if binary = F). The abundance values are relative (divided by the maximum 
abundance observed across all rasters). The function returns a RasterStack that 
can be exported or used in customized plots. To export a pdf, set &quot;pdf=TRUE&quot;. 
The function wraps around functions of the raster package.
</p>


<h3>Value</h3>

<p>RasterStack
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>See Also</h3>

<p><code><a href="raster.html#topic+raster-package">raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### load the example data

data(monographaR_examples)
monographaR_examples$mapPhenology -&gt; data
head(data) ## check the first rows

### running the function

# mapPhenology(data, binary=FALSE, by_species=FALSE, legend=FALSE)

### changing the colors

# mapPhenology(data, binary=FALSE, by_species=FALSE, legend=FALSE, col=rev(terrain.colors(55)))

### exporting raster

# require(raster)
# mapPhenology(data, binary=FALSE, by_species=FALSE, legend=FALSE) -&gt; myphenorasters
# plot(myphenorasters[[1]]) ## plot first month
# writeRaster(myphenorasters[[2]], "pheno_month2.asc") ## exporting 2nd month

### making an GIF animation

# require(animation)
# saveGIF(
#  {mapPhenology(data, binary=F, resolution=0.5, by_species=F, legend=F, mfrow=c(1,1))},
#  movie.name="phenology.gif", interval=0.5, ani.width=600, ani.height=600
# )



</code></pre>

<hr>
<h2 id='mapTable'>
Generates a presence/absence matrix of species on grids or countries
</h2><span id='topic+mapTable'></span>

<h3>Description</h3>

<p>This function will generate a presence/absence matrix based on a grid (if type=&quot;grid&quot;) or
on countries (if type=&quot;countries&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapTable(data, type = "grid", resolution = 1, pres.abs = TRUE, 
write.output = FALSE, layer = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapTable_+3A_data">data</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="mapTable_+3A_type">type</code></td>
<td>

<p>&quot;grid&quot;, &quot;countries&quot; or &quot;user&quot;
</p>
</td></tr>
<tr><td><code id="mapTable_+3A_resolution">resolution</code></td>
<td>

<p>numeric (degrees)
</p>
</td></tr>
<tr><td><code id="mapTable_+3A_pres.abs">pres.abs</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapTable_+3A_write.output">write.output</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="mapTable_+3A_layer">layer</code></td>
<td>

<p>Spatial DataFrame object
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It requires a data.frame with three columns, ordered as:
species, longitude and latitude. The resolution of the grid can be changed by the argument
&quot;resolution&quot; (in degrees). If type = &quot;user&quot;, a layer to intersect the points and create
the matrix should be supplied (a Spatial DataFrame object). It uses functions of the
package raster, sf and terra. If pres.abs = F the returned matrix will have &quot;x&quot; instead
of 0 and 1.
</p>


<h3>Value</h3>

<p>list, with a matrix and grid (if type=&quot;grid), or a matrix (if type=&quot;countries&quot;).
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>See Also</h3>

<p><code><a href="raster.html#topic+raster-package">raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## loading the example data

data(monographaR_examples)
monographaR_examples$map_data -&gt; data
head(data)

## running the function with grid

map.table &lt;- mapTable(data, type="grid", resolution=3, 
write.output=FALSE)
  
map.table$table
t(map.table$table)

map.table$grid -&gt; grid

### load world map
library(rnaturalearth)
library(sf)
library(sp)
ne_countries(type="countries", returnclass = "sv") -&gt; wrld_simpl
st_as_sf(wrld_simpl) -&gt; wrld_simpl
as_Spatial(wrld_simpl) -&gt; wrld_simpl

### plot
plot(grid, border="white")
plot(wrld_simpl, add=TRUE)
plot(grid, add=TRUE)
raster::text(grid, grid@data$layer, cex=1)


</code></pre>

<hr>
<h2 id='monographaR_examples'>
Input data examples
</h2><span id='topic+monographaR_examples'></span>

<h3>Description</h3>

<p>Input table examples. Seven data.frames are listed in this example data set. 
See help files of the functions for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(monographaR_examples)

names(monographaR_examples)

head(monographaR_examples$colletorList)
head(monographaR_examples$examinedSpecimens)
head(monographaR_examples$phenoHist)
head(monographaR_examples$tableToDescription)
head(monographaR_examples$map_data)
head(monographaR_examples$mapPhenology)
head(monographaR_examples$taxonomic_headings)


</code></pre>

<hr>
<h2 id='phenoHist'>
Circular histograms of phenology
</h2><span id='topic+phenoHist'></span>

<h3>Description</h3>

<p>This wrapper function will generate circular histograms of phenology, using 
functions of the package circular. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenoHist(data = data, mfrow = c(1, 1), shrink = 1.2, axis.cex = 
1.5, title.cex = 1.5, pdf = F, height=11, width=8.5, 
filename = "phenology.pdf", flower = "Flower", fruit = "Fruit", 
both = "Both", flower.col = NULL, flower.border = "black", 
fruit.col = "darkgray", fruit.border = "darkgray", mar=c(2,2,2,2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenoHist_+3A_data">data</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_mfrow">mfrow</code></td>
<td>

<p>numeric, (nrow, ncol)
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_shrink">shrink</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_axis.cex">axis.cex</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_title.cex">title.cex</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_pdf">pdf</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_height">height</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_width">width</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_filename">filename</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_flower">flower</code></td>
<td>

<p>character (how is the flower indicated in data, if missing place &quot;missing&quot;)
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_fruit">fruit</code></td>
<td>

<p>character (how is the fruit indicated in data, if missing place &quot;missing&quot;)
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_both">both</code></td>
<td>

<p>character (how is the both indicated in data, if missing place &quot;missing&quot;)
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_flower.col">flower.col</code></td>
<td>

<p>character (color of flower bars)
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_flower.border">flower.border</code></td>
<td>

<p>character (color of flower border bars)
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_fruit.col">fruit.col</code></td>
<td>

<p>character (color of fruit bars)
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_fruit.border">fruit.border</code></td>
<td>

<p>character (color of fruit border bars)
</p>
</td></tr>
<tr><td><code id="phenoHist_+3A_mar">mar</code></td>
<td>

<p>numeric (plot margins, vector of 4 values)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It requires a data.frame with three columns, ordered as: species, month and 
phenology. The month column should be numeric (month number), while the 
phenology column must have these values: &quot;Flower&quot;, &quot;Fruit&quot; and/or &quot;Both&quot;. If 
any of these are missing is possible to indicate in the &quot;flower&quot;, &quot;fruit&quot; and 
&quot;both&quot; arguments (both=&quot;missing&quot;). The function will plot the bars 
indicating flower observations in white, and fruits in gray by default (is 
possible to change it with the &quot;flower.col&quot;, &quot;flower.border&quot;, &quot;fruit.col&quot; and 
&quot;fruit.border&quot; arguments). The size of the bar corresponds to number of 
observations. The arguments &quot;shrink&quot;, &quot;axis.cex&quot; and &quot;title.cex&quot; control 
sizes, while the &quot;mfrow&quot; changes the number of histograms plotted at the same 
page (rows, columns).
</p>


<h3>Value</h3>

<p>Exports a pdf file.
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>See Also</h3>

<p><code><a href="circular.html#topic+circular-package">circular</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## loading the example data

data(monographaR_examples)
monographaR_examples$phenoHist -&gt; data
head(data)

## running the function

phenoHist(data, mfrow=c(2,2), shrink=1.2, axis.cex=1.5, title.cex=1.5, 
pdf=FALSE)

## changing the color

phenoHist(data, mfrow=c(2,2), shrink=1.2, axis.cex=1.5, title.cex=1.5, 
pdf=FALSE, flower.col=rgb(0.2,1,0.2, 0.5), flower.border=rgb(0.2,1,0.2, 
0.5), fruit.col="darkgreen", fruit.border="black")

## plotting only flower (if "fruit" and/or "both" information are 
## missing for instance)

phenoHist(data, mfrow=c(2,2), shrink=1.2, axis.cex=1.5, title.cex=1.5, 
pdf=FALSE, fruit="missing", both="missing", flower.col="red", 
flower.border="darkgray")

</code></pre>

<hr>
<h2 id='tableToDescription'>
Generates species descriptions
</h2><span id='topic+tableToDescription'></span>

<h3>Description</h3>

<p>This function will generate a txt file with species descriptions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tableToDescription(data, filename = "species_descriptions.txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tableToDescription_+3A_data">data</code></td>
<td>

<p>data.frame
</p>
</td></tr>
<tr><td><code id="tableToDescription_+3A_filename">filename</code></td>
<td>

<p>character
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It requires a data.frame where the first three columns are the character description, putative 
complement and the character to use as separator (i.e., words that will remain constant across 
descriptions). The character description and/or the complement might be empty. The remaining 
columns are the species with their respective character states, where each row is a character. 
The function accepts any number of species and/or characters. 
</p>


<h3>Value</h3>

<p>Exports a txt file
</p>


<h3>Author(s)</h3>

<p>Marcelo Reginato
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## loading the example data

data(monographaR_examples)
monographaR_examples$tableToDescription -&gt; data
head(data)

## the first column is just an identifier for the characters, we need to 
## remove it before running the analysis

data[,-1] -&gt; data

## running the function, it will print in the terminal the output. 
## To export a txt, place a name in the filename argument 
## (i.e., filename = "myoutput.txt")

tableToDescription(data, filename = "")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
