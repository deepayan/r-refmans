<!DOCTYPE html><html><head><title>Help for package traipse</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {traipse}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#traipse-package'><p>traipse: Shared Tools for Tracking Data</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#track_angle'><p>Track angle</p></a></li>
<li><a href='#track_bearing'><p>Track bearing</p></a></li>
<li><a href='#track_bearing_to'><p>Track bearing to location/s</p></a></li>
<li><a href='#track_distance'><p>Track distance</p></a></li>
<li><a href='#track_distance_to'><p>Track distance to location/s</p></a></li>
<li><a href='#track_grid'><p>Track grid</p></a></li>
<li><a href='#track_intermediate'><p>Track intermediate points</p></a></li>
<li><a href='#track_query'><p>Query track data for arbitrary locations</p></a></li>
<li><a href='#track_speed'><p>Track speed</p></a></li>
<li><a href='#track_time'><p>Track time duration</p></a></li>
<li><a href='#track_turn'><p>Track turn angle</p></a></li>
<li><a href='#trips0'><p>Simulated track data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Shared Tools for Tracking Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of commonly used tools for animal movement and other tracking 
 data. Variously distance, angle, bearing, distance-to, bearing-to and speed are 
 provided for geographic data that can be used directly or within 'tidyverse' 
 syntax. Distances and bearings are calculated using modern geodesic methods as 
 provided by Charles F. F. Karney (2013) &lt;<a href="https://doi.org/10.1007%2Fs00190-012-0578-z">doi:10.1007/s00190-012-0578-z</a>&gt; 
 via the 'geodist' and 'geosphere' packages. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, geodist, geosphere, stats</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Trackage/traipse">https://github.com/Trackage/traipse</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Trackage/traipse/issues">https://github.com/Trackage/traipse/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat (&ge; 2.1.0), dplyr, tibble, tidyr, spelling</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-09 22:37:40 UTC; mdsumner</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Sumner <a href="https://orcid.org/0000-0002-2471-7511"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Sumner &lt;mdsumner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-10 07:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='traipse-package'>traipse: Shared Tools for Tracking Data</h2><span id='topic+traipse'></span><span id='topic+traipse-package'></span>

<h3>Description</h3>

<p>A collection of commonly used tools for animal movement and other tracking data. Variously distance, angle, bearing, distance-to, bearing-to and speed are provided for geographic data that can be used directly or within 'tidyverse' syntax. Distances and bearings are calculated using modern geodesic methods as provided by Charles F. F. Karney (2013) <a href="https://doi.org/10.1007/s00190-012-0578-z">doi:10.1007/s00190-012-0578-z</a> via the 'geodist' and 'geosphere' packages.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Sumner <a href="mailto:mdsumner@gmail.com">mdsumner@gmail.com</a> (<a href="https://orcid.org/0000-0002-2471-7511">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Trackage/traipse">https://github.com/Trackage/traipse</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Trackage/traipse/issues">https://github.com/Trackage/traipse/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the output value of the <code>rhs</code> function
</p>

<hr>
<h2 id='track_angle'>Track angle</h2><span id='topic+track_angle'></span>

<h3>Description</h3>

<p>Calculate internal track angle on longitude, latitude input vectors. The unit of angle is degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_angle(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_angle_+3A_x">x</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code id="track_angle_+3A_y">y</code></td>
<td>
<p>latitude</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By convention the first and last values are set to <code>NA</code> missing value, because the angle
applies to the location between each previous and next location.
</p>
<p>To use this on multiple track ids, use a grouped data frame with tidyverse code like
<code>data %&gt;% group_by(id) %&gt;% mutate(angle = track_angle(lon, lat))</code>.
</p>
<p>The maximum possible value is 180 and the minimum is 0.
</p>


<h3>Value</h3>

<p>a numeric vector of the relative internal angle between sequential locations
in degrees, see Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track_angle(trips0$x, trips0$y)[1:10]

## maximum value
track_angle(c(0, 0, 0), c(0, 1, 2))
## minimum value
track_angle(c(0, 0, 0), c(0, 1, 0))
</code></pre>

<hr>
<h2 id='track_bearing'>Track bearing</h2><span id='topic+track_bearing'></span>

<h3>Description</h3>

<p>Calculate sequential bearing on longitude, latitude input vectors. The unit of bearing is degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_bearing(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_bearing_+3A_x">x</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code id="track_bearing_+3A_y">y</code></td>
<td>
<p>latitude</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By convention the last value is set to <code>NA</code> missing value, because the bearing
applies to the segment extending from the current location.
</p>
<p>To use this on multiple track ids, use a grouped data frame with tidyverse code like
<code>data %&gt;% group_by(id) %&gt;% mutate(turn = track_bearing(lon, lat))</code>.
</p>
<p>Absolute bearing is relative to North (0), and proceeds clockwise positive and anti-clockwise
negative <code style="white-space: pre;">&#8288;N = 0, E = 90, S = +/-180, W = -90&#8288;</code>.
</p>
<p>The last value will be <code>NA</code> as the bearing is relative to the first point of each segment.
</p>


<h3>Value</h3>

<p>a numeric vector of absolute bearing in degrees, see Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track_bearing(trips0$x, trips0$y)[1:10]
</code></pre>

<hr>
<h2 id='track_bearing_to'>Track bearing to location/s</h2><span id='topic+track_bearing_to'></span>

<h3>Description</h3>

<p>Calculate geodesic bearing to a location or locations based on longitude,
latitude (from) input vectors and longitude, latitude (to) input vectors. The
unit of bearing is degrees. The <em>to</em> values may be a single value or
individual to each <em>from</em> location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_bearing_to(x, y, to_x, to_y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_bearing_to_+3A_x">x</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code id="track_bearing_to_+3A_y">y</code></td>
<td>
<p>latitude</p>
</td></tr>
<tr><td><code id="track_bearing_to_+3A_to_x">to_x</code></td>
<td>
<p>longitude vector of <em>to</em> location/s</p>
</td></tr>
<tr><td><code id="track_bearing_to_+3A_to_y">to_y</code></td>
<td>
<p>latitude vector of <em>to</em> locations/s</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No missing values are required as padding, but input data with <code>NA</code>s will incur an
<code>NA</code> in the output.
</p>
<p>To use this on multiple track ids, use a grouped data frame with tidyverse code like
<code>data %&gt;% group_by(id) %&gt;% mutate(bearing_to = track_bearing_to(lon, lat, to_lon, to_lat))</code>.
</p>
<p>Absolute bearing is relative to North (0), and proceeds clockwise positive and anti-clockwise
negative <code style="white-space: pre;">&#8288;N = 0, E = 90, S = +/-180, W = -90&#8288;</code>.
</p>
<p>There is no <code>NA</code> padding in the output value (though missing values in the input will be mirrored
in the output).
</p>


<h3>Value</h3>

<p>a numeric vector of absolute bearing-to in degrees, see Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track_bearing_to(trips0$x, trips0$y, to_x = 147, to_y = -42)[1:10]
# N E S W
track_bearing_to(0,0, c(0, 10, 0, -10), c(5, 0, -5, 0))

# maximum and minimum value are the same direction (due south)
track_bearing(c(0, -0.00001), c(0, -1))
track_bearing(c(0,  0.00001), c(0, -1))

# the absolute minimum is north
track_bearing(c(0, 0), c(0, 1))
</code></pre>

<hr>
<h2 id='track_distance'>Track distance</h2><span id='topic+track_distance'></span>

<h3>Description</h3>

<p>Calculate geodesic distance on longitude, latitude input vectors. The unit of
distance is metres.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_distance(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_distance_+3A_x">x</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code id="track_distance_+3A_y">y</code></td>
<td>
<p>latitude</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By convention the first value is set to <code>NA</code> missing value, because the
distance applies to each sequential pair of locations.
</p>
<p>To use this on multiple track ids, use a grouped data frame with tidyverse
code like <code>data %&gt;% group_by(id) %&gt;% mutate(distance = track_distance(lon, lat))</code>
</p>


<h3>Value</h3>

<p>numeric vector of distances between sequential pairs of x, y in
metres, see Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track_distance(trips0$x, trips0$y)[1:10]
</code></pre>

<hr>
<h2 id='track_distance_to'>Track distance to location/s</h2><span id='topic+track_distance_to'></span>

<h3>Description</h3>

<p>Calculate geodesic distance to a location or locations based on longitude,
latitude (from) input vectors and longitude, latitude (to) input vectors. The
unit of distance is metres. The <em>to</em> values may be a single value or
individual to each <em>from</em> location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_distance_to(x, y, to_x, to_y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_distance_to_+3A_x">x</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code id="track_distance_to_+3A_y">y</code></td>
<td>
<p>latitude</p>
</td></tr>
<tr><td><code id="track_distance_to_+3A_to_x">to_x</code></td>
<td>
<p>longitude vector of <em>to</em> location/s</p>
</td></tr>
<tr><td><code id="track_distance_to_+3A_to_y">to_y</code></td>
<td>
<p>latitude vector of <em>to</em> locations/s</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No missing values are required as padding, but input data with <code>NA</code>s will incur an
<code>NA</code> in the output.
</p>
<p>To use this on multiple track ids, use a grouped data frame with tidyverse code like
<code>data %&gt;% group_by(id) %&gt;% mutate(distance = track_distance_to(lon, lat, to_lon, to_lat))</code>
</p>


<h3>Value</h3>

<p>a numeric vector of distance-to values in metres
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track_distance_to(trips0$x, trips0$y, to_x = 147, to_y = -42)[1:10]
</code></pre>

<hr>
<h2 id='track_grid'>Track grid</h2><span id='topic+track_grid'></span>

<h3>Description</h3>

<p>Computes the cell a track location point falls in on a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_grid(x, y, dimension, extent = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_grid_+3A_x">x</code></td>
<td>
<p>longitude or x</p>
</td></tr>
<tr><td><code id="track_grid_+3A_y">y</code></td>
<td>
<p>latitude or y</p>
</td></tr>
<tr><td><code id="track_grid_+3A_dimension">dimension</code></td>
<td>
<p>grid size 'nx', 'ny' 2 element vector (ncol, nrow)</p>
</td></tr>
<tr><td><code id="track_grid_+3A_extent">extent</code></td>
<td>
<p>grid extent, if not supplied we use the range of the data input</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A grid is defined by a 'dimension' ('ncol', 'nrow') and 'extent' ('xmin', 'xmax',
'ymin', 'ymax'). The cell index returned is in 'raster order', this is by top
row, left to right and down as per 'rasterImage'. This is aligned with usage
in the Github organization 'hypertidy' packages 'vaster' and 'ximage', and is
how other raster packages work.
</p>
<p>This function doesn't care if the x,y input values are longitude latitude or
x, y and it makes no difference at all. No account of movement between points
is made.
</p>


<h3>Value</h3>

<p>cell index of each input point in the grid specification
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- c(50, 35)
extent &lt;- c(range(trips0$x), range(trips0$y))
cells &lt;- track_grid(trips0$x, trips0$y, dimension = dimension, extent = extent)
plot(extent[1:2], extent[3:4], asp = 1, type = "n")
tab &lt;- tabulate(cells, nbin = prod(dimension))
rasterImage(matrix(1 - (tab/max(tab)), dimension[2L], byrow = TRUE),
extent[1L], extent[3L], extent[2L], extent[4L], interpolate = FALSE)
points(trips0$x, trips0$y, pch = ".", col = "firebrick")
</code></pre>

<hr>
<h2 id='track_intermediate'>Track intermediate points</h2><span id='topic+track_intermediate'></span>

<h3>Description</h3>

<p>Calculate great circle intermediate points on longitude, latitude input vectors. A
spherical model is used, from the geosphere package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_intermediate(x, y, date = NULL, distance = NULL, duration = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_intermediate_+3A_x">x</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code id="track_intermediate_+3A_y">y</code></td>
<td>
<p>latitude</p>
</td></tr>
<tr><td><code id="track_intermediate_+3A_date">date</code></td>
<td>
<p>optional input date-time in POSIXct</p>
</td></tr>
<tr><td><code id="track_intermediate_+3A_distance">distance</code></td>
<td>
<p>optional minimum distance (metres) between interpolated points</p>
</td></tr>
<tr><td><code id="track_intermediate_+3A_duration">duration</code></td>
<td>
<p>optional minimum duration (seconds) between interpolated point,
if set then <code>distance</code> must be <code>NULL</code> and <code>date</code> must be input</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list of data frames, with a data frame of interpolated locations
for every interval between input locations. There is a final empty data frame to ensure
the list is the same length as the inputs. See embedded usage of the tidyr function 'unnest()'
for ease of use.
</p>
<p>To use on multiple track ids, use a grouped data frame with tidyverse code like
<code style="white-space: pre;">&#8288;inter &lt;- data %&gt;% group_by(id) %&gt;% mutate(inter = track_intermediate(lon, lat, date = , distance = )&#8288;</code>.
</p>
<p>Then, un-nest this result for further use (the 'inter' above retains the information
about the parent locations for custom usage if needed), so the final location of each
group has invalid intermediates:
<code>dd &lt;- inter %&gt;% slice(-1) %&gt;% unnest()</code>
</p>


<h3>Value</h3>

<p>a list of data frames of intermediate points (for use with <code>unnest()</code> from tidyr)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track_intermediate(trips0$x[1:10], trips0$y[1:10], distance = 15000)

track_intermediate(trips0$x[1:10], trips0$y[1:10], date = trips0$date,
                                 distance = 1500)

inter_time &lt;- track_intermediate(trips0$x[1:10], trips0$y[1:10],
                            date = trips0$date, duration = 1800)
</code></pre>

<hr>
<h2 id='track_query'>Query track data for arbitrary locations</h2><span id='topic+track_query'></span>

<h3>Description</h3>

<p>Latent positions may be queried using arbitrary date-time values. The only method
(for now) is 'linear', but default should be 'geodesic'. In time we include more methods
to match the GeoPandas implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_query(x, y, date = NULL, query, type = "linear")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_query_+3A_x">x</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code id="track_query_+3A_y">y</code></td>
<td>
<p>latitude</p>
</td></tr>
<tr><td><code id="track_query_+3A_date">date</code></td>
<td>
<p>date-time in POSIXct (or can be ignore, for relative index-time)</p>
</td></tr>
<tr><td><code id="track_query_+3A_query">query</code></td>
<td>
<p>required argument, date-time values to return inferred x, y positions for</p>
</td></tr>
<tr><td><code id="track_query_+3A_type">type</code></td>
<td>
<p>linear, geodesic, rhumb, forward, backward, nearest (also need open/closed intervals)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>date</code> is not included, time itself is treated as the obvious index on n-locations so
simple relative time, and <code>query</code> is expected to match this.
</p>
<p>We use group_modify to keep the id groups:
<code>trips0 %&gt;% group_by(id) %&gt;% group_modify(~track_query(.x$x, .x$y, query = c(4.5, 6.7)))</code>
</p>


<h3>Value</h3>

<p>data frame of 'x,y,date' of inferred positions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track_query(trips0$x[1:10], trips0$y[1:10], query = c(4.5, 5.5, 6.5))
track_query(trips0$x[1:10], trips0$y[1:10], trips0$date[1:10], query = trips0$date[1:10] + 10)
s &lt;- seq(min(trips0$date), max(trips0$date), by = "1 hour")
</code></pre>

<hr>
<h2 id='track_speed'>Track speed</h2><span id='topic+track_speed'></span>

<h3>Description</h3>

<p>Calculate speed (m/s) based on geodesic distance with longitude, latitude, date-time
input vectors. The unit of speed is metres per second.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_speed(x, y, date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_speed_+3A_x">x</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code id="track_speed_+3A_y">y</code></td>
<td>
<p>latitude</p>
</td></tr>
<tr><td><code id="track_speed_+3A_date">date</code></td>
<td>
<p>date-time in POSIXct</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By convention the first value is set to <code>NA</code> missing value, because the difference
applies to each sequential pair of locations.
</p>
<p>To use this on multiple track ids, use a grouped data frame with tidyverse code like
<code>data %&gt;% group_by(id) %&gt;% mutate(speed = track_speed(lon, lat, date))</code>
</p>


<h3>Value</h3>

<p>numeric vector of sequential distances in metres per second, see Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track_speed(trips0$x, trips0$y, trips0$date)[1:10]
</code></pre>

<hr>
<h2 id='track_time'>Track time duration</h2><span id='topic+track_time'></span>

<h3>Description</h3>

<p>Calculate time duration based on sequential difference of date-time input.
The unit of time duration is seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_time(date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_time_+3A_date">date</code></td>
<td>
<p>date-time in POSIXct</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By convention the first value is set to <code>NA</code> missing value, because the
difference applies to each sequential pair of locations.
</p>
<p>To use this on multiple track ids, use a grouped data frame with tidyverse
code like <code>data %&gt;% group_by(id) %&gt;% mutate(duration = track_time(date))</code>
</p>


<h3>Value</h3>

<p>numeric vector of duration between sequential date-time values in
seconds, see Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track_time(trips0$date)[1:10]
</code></pre>

<hr>
<h2 id='track_turn'>Track turn angle</h2><span id='topic+track_turn'></span>

<h3>Description</h3>

<p>Calculate relative track turning angle on longitude, latitude input vectors.
The unit of turn angle is degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_turn(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_turn_+3A_x">x</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code id="track_turn_+3A_y">y</code></td>
<td>
<p>latitude</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By convention the last value is set to <code>NA</code> missing value, because the angle
applies to the relative turn from the current location.
</p>
<p>To use this on multiple track ids, use a grouped data frame with tidyverse
code like <code>data %&gt;% group_by(id) %&gt;% mutate(turn = track_turn(lon, lat))</code>.
</p>
<p>The maximum possible value is 180 degrees and the minimum is -180, although
these particular values are a special case and will probably always be
positive. Turn angle is a signed quantity with negative values for a left
turn and positive values for a right turn.
</p>


<h3>Value</h3>

<p>a numeric vector of absolute turn angles, in degrees
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track_turn(trips0$x, trips0$y)[1:10]

## maximum turn angle
track_turn(c(0, 0, 0), c(0, 1, 0))
## minimum turn angle
track_turn(c(0, 0, 0), c(0, 1, 2))
</code></pre>

<hr>
<h2 id='trips0'>Simulated track data</h2><span id='topic+trips0'></span>

<h3>Description</h3>

<p><code>trips0</code> is an ungrouped data frame of x, y, date, id
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
