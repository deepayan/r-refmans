<!DOCTYPE html><html><head><title>Help for package greenR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {greenR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accessibility_greenspace'><p>Generate Accessibility Map for Green Spaces</p></a></li>
<li><a href='#accessibility_mapbox'><p>Create a dynamic Accessibility Map Using Mapbox GL JS</p></a></li>
<li><a href='#calculate_and_visualize_GVI'><p>Calculate and Visualize Green View Index (GVI) from an image</p></a></li>
<li><a href='#calculate_green_index'><p>Calculate Green Index</p></a></li>
<li><a href='#calculate_percentage'><p>Calculate the percentage of edges with their respective green index category</p></a></li>
<li><a href='#check_duplicate_columns'><p>Function to check for duplicate columns and print them</p></a></li>
<li><a href='#convert_to_point'><p>Convert Geometries to Points and Reproject to WGS84</p></a></li>
<li><a href='#create_hexmap_3D'><p>Create a 3D Hexagon Map Using H3 and Mapbox GL JS</p></a></li>
<li><a href='#create_linestring_3D'><p>Create a 3D Linestring Map</p></a></li>
<li><a href='#get_osm_data'><p>Download OSM Data</p></a></li>
<li><a href='#green_space_clustering'><p>Green Space Clustering with K-Means and Tile Layer Control in Leaflet</p></a></li>
<li><a href='#gssi'><p>Green Space Similarity Index (GSSI)</p></a></li>
<li><a href='#hexGreenSpace'><p>Visualize Green Space Coverage with Hexagonal Bins</p></a></li>
<li><a href='#nearest_greenspace'><p>Calculate and Visualize the Shortest Walking Path to Specified Type of Nearest Green Space with Estimated Walking Time</p></a></li>
<li><a href='#plot_green_index'><p>Plot the green index</p></a></li>
<li><a href='#rename_duplicate_columns'><p>Helper function to rename duplicate columns</p></a></li>
<li><a href='#run_app'><p>Run Shiny App</p></a></li>
<li><a href='#save_as_leaflet'><p>Save the green index data as a Leaflet map in an HTML file</p></a></li>
<li><a href='#save_json'><p>Save the green index data as a GeoJSON file</p></a></li>
<li><a href='#visualize_green_spaces'><p>Visualize Green Spaces on a Leaflet Map</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Green Index Quantification, Analysis and Visualization</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Quantification, analysis, and visualization of urban greenness within city networks using data from 'OpenStreetMap' <a href="https://www.openstreetmap.org">https://www.openstreetmap.org</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>DT, httr, magrittr, dplyr, ggplot2, osmdata, sf, htmltools,
leaflet, shiny, tibble, SuperpixelImageSegmentation,
OpenImageR, osrm, spatstat.geom, stats, units, duckdb, DBI,
data.table, RColorBrewer, htmlwidgets, viridisLite, rstudioapi,
jsonlite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-28 16:17:22 UTC; smahajan</td>
</tr>
<tr>
<td>Author:</td>
<td>Sachit Mahajan <a href="https://orcid.org/0000-0001-9558-8895"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sachit Mahajan &lt;sachitmahajan90@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-29 06:40:22 UTC</td>
</tr>
</table>
<hr>
<h2 id='accessibility_greenspace'>Generate Accessibility Map for Green Spaces</h2><span id='topic+accessibility_greenspace'></span>

<h3>Description</h3>

<p>This function generates a leaflet map that shows green spaces accessible within
a specified walking time from a given location. The location is specified by its
latitude and longitude coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accessibility_greenspace(
  green_area_data,
  location_lat,
  location_lon,
  max_walk_time = 15,
  green_color = "green",
  location_color = "blue",
  isochrone_color = "viridis"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accessibility_greenspace_+3A_green_area_data">green_area_data</code></td>
<td>
<p>A list containing green area data, usually obtained from the <code>get_osm_data</code> function.</p>
</td></tr>
<tr><td><code id="accessibility_greenspace_+3A_location_lat">location_lat</code></td>
<td>
<p>Numeric latitude of the specified location.</p>
</td></tr>
<tr><td><code id="accessibility_greenspace_+3A_location_lon">location_lon</code></td>
<td>
<p>Numeric longitude of the specified location.</p>
</td></tr>
<tr><td><code id="accessibility_greenspace_+3A_max_walk_time">max_walk_time</code></td>
<td>
<p>Maximum walking time in minutes. Default is 15.</p>
</td></tr>
<tr><td><code id="accessibility_greenspace_+3A_green_color">green_color</code></td>
<td>
<p>Color for the green areas on the map. Default is &quot;green&quot;.</p>
</td></tr>
<tr><td><code id="accessibility_greenspace_+3A_location_color">location_color</code></td>
<td>
<p>Color for the specified location on the map. Default is &quot;blue&quot;.</p>
</td></tr>
<tr><td><code id="accessibility_greenspace_+3A_isochrone_color">isochrone_color</code></td>
<td>
<p>Color palette for the isochrone lines. Default is &quot;viridis&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A leaflet map object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  green_area_data &lt;- data$green_areas
  accessibility_greenspace(data, 47.56, 7.59)

## End(Not run)
</code></pre>

<hr>
<h2 id='accessibility_mapbox'>Create a dynamic Accessibility Map Using Mapbox GL JS</h2><span id='topic+accessibility_mapbox'></span>

<h3>Description</h3>

<p>This function creates a dynamic accessibility map using Mapbox GL JS. The map shows green areas and allows users to generate isochrones for walking times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accessibility_mapbox(
  green_area_data,
  mapbox_token,
  output_file = "accessibility_map.html",
  initial_zoom = 15,
  initial_pitch = 45,
  initial_bearing = -17.6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accessibility_mapbox_+3A_green_area_data">green_area_data</code></td>
<td>
<p>A list containing green area data.</p>
</td></tr>
<tr><td><code id="accessibility_mapbox_+3A_mapbox_token">mapbox_token</code></td>
<td>
<p>Character, your Mapbox access token.</p>
</td></tr>
<tr><td><code id="accessibility_mapbox_+3A_output_file">output_file</code></td>
<td>
<p>Character, the file path to save the HTML file.</p>
</td></tr>
<tr><td><code id="accessibility_mapbox_+3A_initial_zoom">initial_zoom</code></td>
<td>
<p>Numeric, the initial zoom level of the map. Default is 15.</p>
</td></tr>
<tr><td><code id="accessibility_mapbox_+3A_initial_pitch">initial_pitch</code></td>
<td>
<p>Numeric, the initial pitch of the map. Default is 45.</p>
</td></tr>
<tr><td><code id="accessibility_mapbox_+3A_initial_bearing">initial_bearing</code></td>
<td>
<p>Numeric, the initial bearing of the map. Default is -17.6.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL. The function creates an HTML file and opens it in the viewer or browser if run interactively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  data &lt;- get_osm_data("Basel, Switzerland")
  green_areas_data &lt;- data$green_areas
  mapbox_token &lt;- "your_mapbox_access_token_here"
  accessibility_mapbox(green_areas_data, mapbox_token)
}
</code></pre>

<hr>
<h2 id='calculate_and_visualize_GVI'>Calculate and Visualize Green View Index (GVI) from an image</h2><span id='topic+calculate_and_visualize_GVI'></span>

<h3>Description</h3>

<p>This function reads an image, performs superpixel segmentation (using the SuperpixelImageSegmentation library), calculates the Green View Index (GVI),
and returns a list containing the segmented image, the green pixels image, and the calculated GVI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_and_visualize_GVI(image_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_and_visualize_GVI_+3A_image_path">image_path</code></td>
<td>
<p>The path of the image file to be processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the Green View Index (GVI), the segmented image, and the green pixels image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example usage with an image located at the specified path
result &lt;- calculate_and_visualize_GVI("/path/to/your/image.png")

## End(Not run)
</code></pre>

<hr>
<h2 id='calculate_green_index'>Calculate Green Index</h2><span id='topic+calculate_green_index'></span>

<h3>Description</h3>

<p>This function calculates the green index for a given set of OpenStreetMap (OSM) data using DuckDB and Duckplyr.
The green index is calculated based on the proximity of highways to green areas and trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_green_index(osm_data, crs_code, D = 100, buffer_distance = 120)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_green_index_+3A_osm_data">osm_data</code></td>
<td>
<p>List containing OSM data (highways, green_areas, trees).</p>
</td></tr>
<tr><td><code id="calculate_green_index_+3A_crs_code">crs_code</code></td>
<td>
<p>Coordinate reference system code for transformations.</p>
</td></tr>
<tr><td><code id="calculate_green_index_+3A_d">D</code></td>
<td>
<p>Distance decay parameter (default = 100).</p>
</td></tr>
<tr><td><code id="calculate_green_index_+3A_buffer_distance">buffer_distance</code></td>
<td>
<p>Buffer distance for spatial joins (default = 120).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spatial data frame with calculated green index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  osm_data &lt;- get_osm_data("Basel, Switzerland")
  green_index &lt;- calculate_green_index(osm_data, 2056)

</code></pre>

<hr>
<h2 id='calculate_percentage'>Calculate the percentage of edges with their respective green index category</h2><span id='topic+calculate_percentage'></span>

<h3>Description</h3>

<p>This function calculates the percentage of edges within each green index category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_percentage(green_index_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_percentage_+3A_green_index_data">green_index_data</code></td>
<td>
<p>A data frame containing the calculated green index values for each edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the percentage of each green index category.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a sample green_index data frame
green_index_data &lt;- data.frame(
  green_index = runif(1000)
)
calculate_percentage(green_index_data)

## End(Not run)
</code></pre>

<hr>
<h2 id='check_duplicate_columns'>Function to check for duplicate columns and print them</h2><span id='topic+check_duplicate_columns'></span>

<h3>Description</h3>

<p>Function to check for duplicate columns and print them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_duplicate_columns(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_duplicate_columns_+3A_df">df</code></td>
<td>
<p>Data frame to check for duplicate columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of duplicate column names
</p>

<hr>
<h2 id='convert_to_point'>Convert Geometries to Points and Reproject to WGS84</h2><span id='topic+convert_to_point'></span>

<h3>Description</h3>

<p>This function converts geometries (points, lines, polygons) to their centroid points and reprojects them to WGS84.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_point(data, target_crs = 4326)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_point_+3A_data">data</code></td>
<td>
<p>An sf object containing geometries.</p>
</td></tr>
<tr><td><code id="convert_to_point_+3A_target_crs">target_crs</code></td>
<td>
<p>The target coordinate reference system (default is WGS84, EPSG:4326).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with point geometries reprojected to the target CRS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(sf)
  library(dplyr)

  # Create example data with a CRS
  lines &lt;- st_sf(
    id = 1:5,
    geometry = st_sfc(
      st_linestring(matrix(c(0,0, 1,1), ncol=2, byrow=TRUE)),
      st_linestring(matrix(c(1,1, 2,2), ncol=2, byrow=TRUE)),
      st_linestring(matrix(c(2,2, 3,3), ncol=2, byrow=TRUE)),
      st_linestring(matrix(c(3,3, 4,4), ncol=2, byrow=TRUE)),
      st_linestring(matrix(c(4,4, 5,5), ncol=2, byrow=TRUE))
    ),
    crs = 4326 # Assign WGS84 CRS
  )

  # Convert geometries to points
  points &lt;- convert_to_point(lines)

</code></pre>

<hr>
<h2 id='create_hexmap_3D'>Create a 3D Hexagon Map Using H3 and Mapbox GL JS</h2><span id='topic+create_hexmap_3D'></span>

<h3>Description</h3>

<p>This function creates a 3D hexagon map using H3 and Mapbox GL JS. The input data can be points, linestrings, polygons, or multipolygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_hexmap_3D(
  data,
  value_col,
  label_col = NULL,
  mapbox_token,
  output_file = "hexagon_map.html",
  color_palette = "interpolateViridis",
  max_height = 5000,
  map_center = NULL,
  map_zoom = 11,
  h3_resolution = 9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_hexmap_3D_+3A_data">data</code></td>
<td>
<p>An sf object containing geographical data.</p>
</td></tr>
<tr><td><code id="create_hexmap_3D_+3A_value_col">value_col</code></td>
<td>
<p>Character, the name of the value column.</p>
</td></tr>
<tr><td><code id="create_hexmap_3D_+3A_label_col">label_col</code></td>
<td>
<p>Character, the name of the label column (optional).</p>
</td></tr>
<tr><td><code id="create_hexmap_3D_+3A_mapbox_token">mapbox_token</code></td>
<td>
<p>Character, your Mapbox access token.</p>
</td></tr>
<tr><td><code id="create_hexmap_3D_+3A_output_file">output_file</code></td>
<td>
<p>Character, the file path to save the HTML file. Default is &quot;hexagon_map.html&quot;.</p>
</td></tr>
<tr><td><code id="create_hexmap_3D_+3A_color_palette">color_palette</code></td>
<td>
<p>Character, the D3 color scheme to use. Default is &quot;interpolateViridis&quot;.</p>
</td></tr>
<tr><td><code id="create_hexmap_3D_+3A_max_height">max_height</code></td>
<td>
<p>Numeric, the maximum height for the hexagons. Default is 5000.</p>
</td></tr>
<tr><td><code id="create_hexmap_3D_+3A_map_center">map_center</code></td>
<td>
<p>Numeric vector of length 2, the center of the map. Default is NULL.</p>
</td></tr>
<tr><td><code id="create_hexmap_3D_+3A_map_zoom">map_zoom</code></td>
<td>
<p>Numeric, the zoom level of the map. Default is 11.</p>
</td></tr>
<tr><td><code id="create_hexmap_3D_+3A_h3_resolution">h3_resolution</code></td>
<td>
<p>Numeric, the H3 resolution for hexagons. Default is 9.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL. The function creates an HTML file and opens it in the viewer or browser if run interactively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  # Generate random data
  lon &lt;- runif(100, min = 8.49, max = 8.56)
  lat &lt;- runif(100, min = 47.35, max = 47.42)
  green_index &lt;- runif(100, min = 0, max = 1)
  data &lt;- data.frame(lon = lon, lat = lat, green_index = green_index)
  data_sf &lt;- sf::st_as_sf(data, coords = c("lon", "lat"), crs = 4326)

  # Specify your Mapbox access token
  mapbox_token &lt;- "your_mapbox_access_token_here"

  # Create the 3D hexagon map
  create_hexmap_3D(
    data = data_sf,
    value_col = "green_index",
    mapbox_token = mapbox_token,
    output_file = "map.html",
    color_palette = "interpolateViridis"
  )
}
</code></pre>

<hr>
<h2 id='create_linestring_3D'>Create a 3D Linestring Map</h2><span id='topic+create_linestring_3D'></span>

<h3>Description</h3>

<p>This function creates a 3D linestring map using Mapbox GL JS and saves it as an HTML file.
The map visualizes linestring data with an associated green index, allowing for interactive
exploration of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_linestring_3D(
  data,
  green_index_col,
  mapbox_token,
  output_file = "linestring_map.html",
  color_palette = "interpolateViridis",
  map_center = NULL,
  map_zoom = 11
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_linestring_3D_+3A_data">data</code></td>
<td>
<p>An <code>sf</code> object containing linestring geometries and associated data.</p>
</td></tr>
<tr><td><code id="create_linestring_3D_+3A_green_index_col">green_index_col</code></td>
<td>
<p>Character, name of the column containing the green index values.</p>
</td></tr>
<tr><td><code id="create_linestring_3D_+3A_mapbox_token">mapbox_token</code></td>
<td>
<p>Character, Mapbox access token for rendering the map.</p>
</td></tr>
<tr><td><code id="create_linestring_3D_+3A_output_file">output_file</code></td>
<td>
<p>Character, name of the output HTML file. Default is &quot;linestring_map.html&quot;.</p>
</td></tr>
<tr><td><code id="create_linestring_3D_+3A_color_palette">color_palette</code></td>
<td>
<p>Character, name of the D3 color palette to use. Default is &quot;interpolateViridis&quot;.</p>
</td></tr>
<tr><td><code id="create_linestring_3D_+3A_map_center">map_center</code></td>
<td>
<p>Numeric vector, longitude and latitude of the map center. Default is NULL (computed from data).</p>
</td></tr>
<tr><td><code id="create_linestring_3D_+3A_map_zoom">map_zoom</code></td>
<td>
<p>Numeric, initial zoom level of the map. Default is 11.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL. The function creates an HTML file and opens it in the viewer or browser.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  # Create example data
  lines &lt;- st_sf(
    id = 1:5,
    geometry = st_sfc(
      st_linestring(matrix(c(0,0, 1,1), ncol=2, byrow=TRUE)),
      st_linestring(matrix(c(1,1, 2,2), ncol=2, byrow=TRUE)),
      st_linestring(matrix(c(2,2, 3,3), ncol=2, byrow=TRUE)),
      st_linestring(matrix(c(3,3, 4,4), ncol=2, byrow=TRUE)),
      st_linestring(matrix(c(4,4, 5,5), ncol=2, byrow=TRUE))
    ),
    green_index = runif(5)
  )
  st_crs(lines) &lt;- 4326
  mapbox_token &lt;- "your_mapbox_token"
  create_linestring_3D(lines, "green_index", mapbox_token)
}
</code></pre>

<hr>
<h2 id='get_osm_data'>Download OSM Data</h2><span id='topic+get_osm_data'></span>

<h3>Description</h3>

<p>This function downloads OpenStreetMap (OSM) data for a specified location or bounding box.
The OSM data includes information about highways, green areas, and trees in the specified location.
It requires an internet connection. If using RStudio Cloud, or if you need to use a private
Nominatim server, you can specify an alternative server URL and credentials (username and password).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_osm_data(
  bbox,
  server_url = "https://nominatim.openstreetmap.org/search",
  username = NULL,
  password = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_osm_data_+3A_bbox">bbox</code></td>
<td>
<p>A string representing the bounding box area or the location (e.g., &quot;Lausanne, Switzerland&quot;).</p>
</td></tr>
<tr><td><code id="get_osm_data_+3A_server_url">server_url</code></td>
<td>
<p>Optional string representing an alternative Nominatim server URL.</p>
</td></tr>
<tr><td><code id="get_osm_data_+3A_username">username</code></td>
<td>
<p>Optional string for username if authentication is required for the server.</p>
</td></tr>
<tr><td><code id="get_osm_data_+3A_password">password</code></td>
<td>
<p>Optional string for password if authentication is required for the server.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>highways</code></td>
<td>
<p>An sf object with the OSM data about highways in the specified location.</p>
</td></tr>
<tr><td><code>green_areas</code></td>
<td>
<p>An sf object with the OSM data about green areas, such as parks, forests, gardens, and nature reserves, in the specified location.</p>
</td></tr>
<tr><td><code>trees</code></td>
<td>
<p>An sf object with the OSM data about trees in the specified location.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
  osm_data &lt;- get_osm_data("Lausanne, Switzerland")

</code></pre>

<hr>
<h2 id='green_space_clustering'>Green Space Clustering with K-Means and Tile Layer Control in Leaflet</h2><span id='topic+green_space_clustering'></span>

<h3>Description</h3>

<p>This function performs K-means clustering on green spaces based on their area size and visualizes the results on a Leaflet map.
Users must specify the number of clusters. The function includes a layer control for switching between different basemap tiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>green_space_clustering(green_areas_data, num_clusters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="green_space_clustering_+3A_green_areas_data">green_areas_data</code></td>
<td>
<p>List containing green areas data (obtained from get_osm_data function or similar).</p>
</td></tr>
<tr><td><code id="green_space_clustering_+3A_num_clusters">num_clusters</code></td>
<td>
<p>Integer number of clusters to divide the green spaces into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Leaflet map object displaying clustered green spaces with layer control for basemap tiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Create example green_areas_data
  library(sf)
  green_areas &lt;- st_sf(
    id = 1:5,
    geometry = st_sfc(
      st_polygon(list(rbind(c(0, 0), c(0, 1), c(1, 1), c(1, 0), c(0, 0)))),
      st_polygon(list(rbind(c(1, 1), c(1, 2), c(2, 2), c(2, 1), c(1, 1)))),
      st_polygon(list(rbind(c(2, 2), c(2, 3), c(3, 3), c(3, 2), c(2, 2)))),
      st_polygon(list(rbind(c(3, 3), c(3, 4), c(4, 4), c(4, 3), c(3, 3)))),
      st_polygon(list(rbind(c(4, 4), c(4, 5), c(5, 5), c(5, 4), c(4, 4))))
    ),
    crs = 4326  # Assign a CRS (WGS 84)
  )
  green_areas_data &lt;- list(osm_polygons = green_areas)
  # Run the clustering function
  map &lt;- green_space_clustering(green_areas_data, num_clusters = 2)
  map # to display the map

</code></pre>

<hr>
<h2 id='gssi'>Green Space Similarity Index (GSSI)</h2><span id='topic+gssi'></span>

<h3>Description</h3>

<p>This function calculates the Green Space Similarity Index (GSSI) for a list of cities,
based on the variability of green space sizes and their connectivity.
The function uses the <code>spatstat</code> package to calculate proximity measures and combines these
with area-based metrics to form the GSSI. The index is useful for comparing urban green
spaces across different cities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gssi(green_spaces_list, equal_area_crs = "ESRI:54009")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gssi_+3A_green_spaces_list">green_spaces_list</code></td>
<td>
<p>A list of 'sf' objects, each representing the green spaces in a city.</p>
</td></tr>
<tr><td><code id="gssi_+3A_equal_area_crs">equal_area_crs</code></td>
<td>
<p>A character string representing an equal-area CRS for accurate area measurement.
Default is &quot;ESRI:54009&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of normalized GSSI values for each city.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d1 &lt;- get_osm_data("New Delhi, India")
dsf &lt;- d1$green_areas$osm_polygons
d2 &lt;- get_osm_data("Basel, Switzerland")
bsf &lt;- d2$green_areas$osm_polygons
d3 &lt;- get_osm_data("Medellin, Colombia")
msf &lt;- d3$green_areas$osm_polygons
cities_data &lt;- list(dsf, bsf, msf)
gssi_values &lt;- gssi(cities_data)

</code></pre>

<hr>
<h2 id='hexGreenSpace'>Visualize Green Space Coverage with Hexagonal Bins</h2><span id='topic+hexGreenSpace'></span>

<h3>Description</h3>

<p>Creates a hexagonal binning map to visualize the percentage of green space coverage within a specified area.
Users can customize the hexagon size, color palette, and other map features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexGreenSpace(
  green_areas_data = NULL,
  tree_data = NULL,
  hex_size = 500,
  color_palette = "viridis",
  save_path = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hexGreenSpace_+3A_green_areas_data">green_areas_data</code></td>
<td>
<p>List containing green areas data (obtained from the <code>get_osm_data</code> function), default is NULL.</p>
</td></tr>
<tr><td><code id="hexGreenSpace_+3A_tree_data">tree_data</code></td>
<td>
<p>List containing tree data (obtained from the <code>get_osm_data</code> function), default is NULL.</p>
</td></tr>
<tr><td><code id="hexGreenSpace_+3A_hex_size">hex_size</code></td>
<td>
<p>Numeric, size of the hexagons in meters, default is 500.</p>
</td></tr>
<tr><td><code id="hexGreenSpace_+3A_color_palette">color_palette</code></td>
<td>
<p>Character, name of the color palette to use, default is &quot;viridis&quot;.</p>
</td></tr>
<tr><td><code id="hexGreenSpace_+3A_save_path">save_path</code></td>
<td>
<p>Character, file path to save the map as an HTML file, default is NULL (do not save).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a Leaflet map displaying the percentage of green space coverage, and a ggplot2 violin plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data &lt;- get_osm_data("City of London, United Kingdom")
  green_areas_data &lt;- data$green_areas
  tree_data &lt;- data$trees
  hex_map &lt;- hexGreenSpace(green_areas_data, tree_data, hex_size = 300)
  print(hex_map$map) # Display the hex bin map
  print(hex_map$violin) # Display the violin plot

</code></pre>

<hr>
<h2 id='nearest_greenspace'>Calculate and Visualize the Shortest Walking Path to Specified Type of Nearest Green Space with Estimated Walking Time</h2><span id='topic+nearest_greenspace'></span>

<h3>Description</h3>

<p>Determines the nearest specified type of green space from a given location and calculates the
shortest walking route using the road network optimized for walking. The result is visualized on a Leaflet map
displaying the path, the starting location, and the destination green space, with details on distance and estimated walking time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest_greenspace(
  highway_data,
  green_areas_data,
  location_lat,
  location_lon,
  green_space_types = NULL,
  walking_speed_kmh = 4.5,
  osrm_server = "https://router.project-osrm.org/"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearest_greenspace_+3A_highway_data">highway_data</code></td>
<td>
<p>List containing road network data, typically obtained from OpenStreetMap.</p>
</td></tr>
<tr><td><code id="nearest_greenspace_+3A_green_areas_data">green_areas_data</code></td>
<td>
<p>List containing green areas data, obtained from <code>get_osm_data</code>.</p>
</td></tr>
<tr><td><code id="nearest_greenspace_+3A_location_lat">location_lat</code></td>
<td>
<p>Numeric, latitude of the starting location.</p>
</td></tr>
<tr><td><code id="nearest_greenspace_+3A_location_lon">location_lon</code></td>
<td>
<p>Numeric, longitude of the starting location.</p>
</td></tr>
<tr><td><code id="nearest_greenspace_+3A_green_space_types">green_space_types</code></td>
<td>
<p>Vector of strings specifying types of green spaces to consider.</p>
</td></tr>
<tr><td><code id="nearest_greenspace_+3A_walking_speed_kmh">walking_speed_kmh</code></td>
<td>
<p>Numeric, walking speed in kilometers per hour, default is 4.5.</p>
</td></tr>
<tr><td><code id="nearest_greenspace_+3A_osrm_server">osrm_server</code></td>
<td>
<p>URL of the OSRM routing server with foot routing support, default is &quot;https://router.project-osrm.org/&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Leaflet map object showing the route, start point, and nearest green space with popup annotations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data &lt;- get_osm_data("Fulham, London, United Kingdom")
  highway_data &lt;- data$highways
  green_areas_data &lt;- data$green_areas
  map &lt;- nearest_greenspace(highway_data, green_areas_data, 51.4761, -0.2008, c("park", "forest"))
  print(map) # Display the map

</code></pre>

<hr>
<h2 id='plot_green_index'>Plot the green index</h2><span id='topic+plot_green_index'></span>

<h3>Description</h3>

<p>This function plots the green index for the highway network with extensive customization options.
Users can set various parameters like text size, color palette, resolution, base map, line width, line type, and more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_green_index(
  green_index_data,
  base_map = "CartoDB.DarkMatter",
  colors = c("#F0BB62", "#BFDB38", "#367E18"),
  text_size = 12,
  resolution = 350,
  title = NULL,
  xlab = NULL,
  ylab = NULL,
  legend_title = "Green_Index",
  legend_position = "right",
  theme = ggplot2::theme_minimal(),
  line_width = 0.8,
  line_type = "solid",
  interactive = FALSE,
  filename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_green_index_+3A_green_index_data">green_index_data</code></td>
<td>
<p>A data frame containing the calculated green index values for each edge.</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_base_map">base_map</code></td>
<td>
<p>Character, base map to use. Default is &quot;CartoDB.DarkMatter&quot;.
Other options include &quot;Stamen.Toner&quot;, &quot;CartoDB.Positron&quot;, &quot;Esri.NatGeoWorldMap&quot;,
&quot;MtbMap&quot;, &quot;Stamen.TonerLines&quot;, and &quot;Stamen.TonerLabels&quot;.</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_colors">colors</code></td>
<td>
<p>Character vector, colors for the gradient. Default is c(&quot;#F0BB62&quot;, &quot;#BFDB38&quot;, &quot;#367E18&quot;).</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_text_size">text_size</code></td>
<td>
<p>Numeric, size of the text in the plot. Default is 12.</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_resolution">resolution</code></td>
<td>
<p>Numeric, resolution of the plot. Default is 350.</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_title">title</code></td>
<td>
<p>Character, title for the plot. Default is NULL.</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_xlab">xlab</code></td>
<td>
<p>Character, x-axis label for the plot. Default is NULL.</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_ylab">ylab</code></td>
<td>
<p>Character, y-axis label for the plot. Default is NULL.</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_legend_title">legend_title</code></td>
<td>
<p>Character, legend title for the plot. Default is &quot;Green_Index&quot;.</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_legend_position">legend_position</code></td>
<td>
<p>Character, legend position for the plot. Default is &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_theme">theme</code></td>
<td>
<p>ggplot theme object, theme for the plot. Default is ggplot2::theme_minimal().</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_line_width">line_width</code></td>
<td>
<p>Numeric, width of the line for the edges. Default is 0.8.</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_line_type">line_type</code></td>
<td>
<p>Character or numeric, type of the line for the edges. Default is &quot;solid&quot;.</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_interactive">interactive</code></td>
<td>
<p>Logical, whether to return an interactive plot using leaflet. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot_green_index_+3A_filename">filename</code></td>
<td>
<p>Character, filename to save the plot. Supported formats include HTML. Default is NULL (no file saved).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>interactive = TRUE</code>, returns a Leaflet map object. If <code>interactive = FALSE</code>, returns a ggplot object.
If a filename is provided, saves the plot to the specified file.
</p>

<hr>
<h2 id='rename_duplicate_columns'>Helper function to rename duplicate columns</h2><span id='topic+rename_duplicate_columns'></span>

<h3>Description</h3>

<p>Helper function to rename duplicate columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_duplicate_columns(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_duplicate_columns_+3A_df">df</code></td>
<td>
<p>Data frame with potential duplicate columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with unique column names
</p>

<hr>
<h2 id='run_app'>Run Shiny App</h2><span id='topic+run_app'></span>

<h3>Description</h3>

<p>This function runs the included Shiny app. The app provides an interactive
interface to use the functions in this package. You can download OSM data,
calculate green indices, plot green index, and save green index data as a
JSON file or as a Leaflet map in an HTML file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_app()
</code></pre>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  run_app()

## End(Not run)
</code></pre>

<hr>
<h2 id='save_as_leaflet'>Save the green index data as a Leaflet map in an HTML file</h2><span id='topic+save_as_leaflet'></span>

<h3>Description</h3>

<p>This function saves the green index data as a Leaflet map in an HTML file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_as_leaflet(edges, file_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_as_leaflet_+3A_edges">edges</code></td>
<td>
<p>A data frame containing the calculated green index values for each edge.</p>
</td></tr>
<tr><td><code id="save_as_leaflet_+3A_file_path">file_path</code></td>
<td>
<p>The file path where the HTML file will be saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Assuming you have already obtained green index data
save_as_leaflet(green_index, "green_index_map.html")

## End(Not run)
</code></pre>

<hr>
<h2 id='save_json'>Save the green index data as a GeoJSON file</h2><span id='topic+save_json'></span>

<h3>Description</h3>

<p>This function saves the green index data for all the edges as a GeoJSON file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_json(green_index, file_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_json_+3A_green_index">green_index</code></td>
<td>
<p>A data frame containing the calculated green index values for each edge.</p>
</td></tr>
<tr><td><code id="save_json_+3A_file_path">file_path</code></td>
<td>
<p>The file path where the GeoJSON file will be saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a sample green_index data frame
green_index &lt;- data.frame(
  green_index = runif(1000),
  geometry = rep(sf::st_sfc(sf::st_point(c(0, 0))), 1000)
)
save_json(green_index, "green_index_data.geojson")

## End(Not run)
</code></pre>

<hr>
<h2 id='visualize_green_spaces'>Visualize Green Spaces on a Leaflet Map</h2><span id='topic+visualize_green_spaces'></span>

<h3>Description</h3>

<p>This function visualizes green spaces on a Leaflet map using the green_areas_data obtained from the get_osm_data function.
Green spaces are labeled based on their tags and have different colors in the legend. Users can switch the green spaces layer on and off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualize_green_spaces(green_areas_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualize_green_spaces_+3A_green_areas_data">green_areas_data</code></td>
<td>
<p>List containing green areas data (obtained from get_osm_data function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Leaflet map displaying green spaces with labels and a legend, with a layer control for toggling the green spaces layer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Assuming you have already obtained green_areas_data using get_osm_data
  visualize_green_spaces(green_areas_data)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
