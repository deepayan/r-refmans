<!DOCTYPE html><html lang="en"><head><title>Help for package ForLion</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ForLion}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ForLion-package'><p>ForLion: 'ForLion' Algorithm to Find D-Optimal Designs for Experiments</p></a></li>
<li><a href='#design_initial_self'><p>function to generate random initial design with design points and the approximate allocation</p></a></li>
<li><a href='#discrete_rv_self'><p>function to generate discrete uniform random variables for initial random design points in ForLion</p></a></li>
<li><a href='#dprime_func_self'><p>Function to calculate du/dx in the gradient of d(x, Xi), will be used in ForLion_MLM_func() function, details see Appendix C in Huang, Li, Mandal, Yang (2024)</p></a></li>
<li><a href='#EW_design_initial_self'><p>function to generate random initial design with design points and the approximate allocation (For EW)</p></a></li>
<li><a href='#EW_dprime_func_self'><p>Function to calculate dEu/dx in the gradient of d(x, Xi), will be used in EW_ForLion_MLM_func() function</p></a></li>
<li><a href='#EW_Fi_MLM_func'><p>Function to generate the Expectation of fisher information at one design point xi for multinomial logit models</p></a></li>
<li><a href='#EW_ForLion_GLM_Optimal'><p>EW ForLion for generalized linear models</p></a></li>
<li><a href='#EW_ForLion_MLM_Optimal'><p>EW ForLion function for multinomial logit models</p></a></li>
<li><a href='#EW_liftoneDoptimal_GLM_func'><p>EW Lift-one algorithm for D-optimal approximate design</p></a></li>
<li><a href='#EW_liftoneDoptimal_log_GLM_func'><p>EW Lift-one algorithm for D-optimal approximate design in log scale</p></a></li>
<li><a href='#EW_liftoneDoptimal_MLM_func'><p>function of EW liftone for multinomial logit model</p></a></li>
<li><a href='#EW_Xw_maineffects_self'><p>function for calculating X=h(x) and E_w=E(nu(beta^T h(x))) give a design point x=(1,x1,...,xd)^T</p></a></li>
<li><a href='#Fi_MLM_func'><p>Function to generate fisher information at one design point xi for multinomial logit models</p></a></li>
<li><a href='#ForLion_GLM_Optimal'><p>ForLion for generalized linear models</p></a></li>
<li><a href='#ForLion_MLM_Optimal'><p>ForLion function for multinomial logit models</p></a></li>
<li><a href='#GLM_Exact_Design'><p>Approximation to exact design algorithm for generalized linear model</p></a></li>
<li><a href='#liftoneDoptimal_GLM_func'><p>Lift-one algorithm for D-optimal approximate design</p></a></li>
<li><a href='#liftoneDoptimal_log_GLM_func'><p>Lift-one algorithm for D-optimal approximate design in log scale</p></a></li>
<li><a href='#liftoneDoptimal_MLM_func'><p>function of liftone for multinomial logit model</p></a></li>
<li><a href='#MLM_Exact_Design'><p>Approximation to exact design algorithm for multinomial logit model</p></a></li>
<li><a href='#nu_cauchit_self'><p>function to calculate w = nu(eta) given eta for cauchit link</p></a></li>
<li><a href='#nu_identity_self'><p>Function to calculate w = nu(eta) given eta for identity link</p></a></li>
<li><a href='#nu_log_self'><p>Function to calculate w = nu(eta) given eta for log link</p></a></li>
<li><a href='#nu_logit_self'><p>function to calculate w = nu(eta) given eta for logit link</p></a></li>
<li><a href='#nu_loglog_self'><p>function to calculate w = nu(eta) given eta for loglog link</p></a></li>
<li><a href='#nu_probit_self'><p>function to calculate w = nu(eta) given eta for probit link</p></a></li>
<li><a href='#nu1_cauchit_self'><p>Function to calculate first derivative of nu function given eta for cauchit link</p></a></li>
<li><a href='#nu1_identity_self'><p>function to calculate first derivative of nu function given eta for identity link</p></a></li>
<li><a href='#nu1_log_self'><p>function to calculate first derivative of nu function given eta for log link</p></a></li>
<li><a href='#nu1_logit_self'><p>function to calculate the first derivative of nu function given eta for logit link</p></a></li>
<li><a href='#nu1_loglog_self'><p>function to calculate the first derivative of nu function given eta for log-log link</p></a></li>
<li><a href='#nu1_probit_self'><p>function to calculate the first derivative of nu function given eta for probit link</p></a></li>
<li><a href='#nu2_cauchit_self'><p>function to calculate the second derivative of nu function given eta for cauchit link</p></a></li>
<li><a href='#nu2_identity_self'><p>function to calculate the second derivative of nu function given eta for identity link</p></a></li>
<li><a href='#nu2_log_self'><p>function to calculate the second derivative of nu function given eta for log link</p></a></li>
<li><a href='#nu2_logit_self'><p>function to calculate the second derivative of nu function given eta for logit link</p></a></li>
<li><a href='#nu2_loglog_self'><p>function to calculate the second derivative of nu function given eta for loglog link</p></a></li>
<li><a href='#nu2_probit_self'><p>function to calculate the second derivative of nu function given eta for probit link</p></a></li>
<li><a href='#print.design_output'><p>Print Method for Design Output from ForLion Algorithm</p></a></li>
<li><a href='#print.list_output'><p>Print Method for list_output Objects</p></a></li>
<li><a href='#svd_inverse'><p>SVD Inverse Of A Square Matrix</p>
This function returns the inverse of a matrix using singular value decomposition.
If the matrix is a square matrix, this should be equivalent to using the solve function.
If the matrix is not a square matrix, then the result is the Moore-Penrose pseudo inverse.</a></li>
<li><a href='#xmat_discrete_self'><p>Generate GLM random initial designs within ForLion algorithm</p></a></li>
<li><a href='#Xw_maineffects_self'><p>function for calculating X=h(x) and w=nu(beta^T h(x)) given a design point x = (x1,...,xd)^T</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'ForLion' Algorithm to Find D-Optimal Designs for Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Siting Lin &lt;slin95@uic.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Designing experimental plans that involve both discrete and continuous factors with general parametric statistical models using the 'ForLion' algorithm and 'EW ForLion' algorithm. The algorithms will search for locally optimal designs and EW optimal designs under the D-criterion. Reference: Huang, Y., Li, K., Mandal, A., &amp; Yang, J., (2024)&lt;<a href="https://doi.org/10.1007%2Fs11222-024-10465-x">doi:10.1007/s11222-024-10465-x</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>psych, stats, cubature</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-08 23:19:46 UTC; sitin</td>
</tr>
<tr>
<td>Author:</td>
<td>Yifei Huang [aut],
  Siting Lin [aut, cre],
  Jie Yang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-11 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ForLion-package'>ForLion: 'ForLion' Algorithm to Find D-Optimal Designs for Experiments</h2><span id='topic+ForLion'></span><span id='topic+ForLion-package'></span>

<h3>Description</h3>

<p>Designing experimental plans that involve both discrete and continuous factors with general parametric statistical models using the 'ForLion' algorithm and 'EW ForLion' algorithm. The algorithms will search for locally optimal designs and EW optimal designs under the D-criterion. Reference: Huang, Y., Li, K., Mandal, A., &amp; Yang, J., (2024)<a href="https://doi.org/10.1007/s11222-024-10465-x">doi:10.1007/s11222-024-10465-x</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Siting Lin <a href="mailto:slin95@uic.edu">slin95@uic.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Yifei Huang
</p>
</li>
<li><p> Jie Yang
</p>
</li></ul>


<hr>
<h2 id='design_initial_self'>function to generate random initial design with design points and the approximate allocation</h2><span id='topic+design_initial_self'></span>

<h3>Description</h3>

<p>function to generate random initial design with design points and the approximate allocation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_initial_self(
  k.continuous,
  factor.level,
  lvec,
  uvec,
  bvec,
  h.func,
  link = "continuation",
  Fi.func = Fi_MLM_func,
  delta = 1e-06,
  epsilon = 1e-12,
  maxit = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_initial_self_+3A_k.continuous">k.continuous</code></td>
<td>
<p>number of continuous variables</p>
</td></tr>
<tr><td><code id="design_initial_self_+3A_factor.level">factor.level</code></td>
<td>
<p>lower, upper limit of continuous variables, and discrete levels of categorical variables, continuous factors come first</p>
</td></tr>
<tr><td><code id="design_initial_self_+3A_lvec">lvec</code></td>
<td>
<p>lower limit of continuous variables</p>
</td></tr>
<tr><td><code id="design_initial_self_+3A_uvec">uvec</code></td>
<td>
<p>upper limit of continuous variables</p>
</td></tr>
<tr><td><code id="design_initial_self_+3A_bvec">bvec</code></td>
<td>
<p>assumed parameter values of beta</p>
</td></tr>
<tr><td><code id="design_initial_self_+3A_h.func">h.func</code></td>
<td>
<p>function, is used to transfer the design point to model matrix (e.g. add interaction term, add intercept)</p>
</td></tr>
<tr><td><code id="design_initial_self_+3A_link">link</code></td>
<td>
<p>link function, default &quot;continuation&quot;, other options &quot;baseline&quot;, &quot;adjacent&quot; and &quot;cumulative&quot;</p>
</td></tr>
<tr><td><code id="design_initial_self_+3A_fi.func">Fi.func</code></td>
<td>
<p>function, is used to calculate Fisher inforamtion for a design point - default to be Fi_MLM_func() in the package</p>
</td></tr>
<tr><td><code id="design_initial_self_+3A_delta">delta</code></td>
<td>
<p>tuning parameter, the distance threshold, || x_i(0) - x_j(0) || &gt;= delta</p>
</td></tr>
<tr><td><code id="design_initial_self_+3A_epsilon">epsilon</code></td>
<td>
<p>or determining f.det &gt; 0 numerically, f.det &lt;= epsilon will be considered as f.det &lt;= 0</p>
</td></tr>
<tr><td><code id="design_initial_self_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X matrix of initial design point
</p>
<p>p0 initial random approximate allocation
</p>
<p>f.det the determinant of Fisher information matrix for the random initial design
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k.continuous.temp=5
link.temp = "cumulative"
n.factor.temp = c(0,0,0,0,0,2)  # 1 discrete factor w/ 2 levels + 5 continuous
## Note: Always put continuous factors ahead of discrete factors,
## pay attention to the order of coefficients paring with predictors
lvec.temp = c(-25,-200,-150,-100,0,-1)
uvec.temp = c(25,200,0,0,16,1)
hfunc.temp = function(y){
if(length(y) != 6){stop("Input should have length 6");}
 model.mat = matrix(NA, nrow=5, ncol=10, byrow=TRUE)
 model.mat[5,]=0
 model.mat[1:4,1:4] = diag(4)
 model.mat[1:4, 5] =((-1)*y[6])
 model.mat[1:4, 6:10] = matrix(((-1)*y[1:5]), nrow=4, ncol=5, byrow=TRUE)
 return(model.mat)
 }
bvec.temp=c(-1.77994301, -0.05287782,  1.86852211, 2.76330779, -0.94437464, 0.18504420,
-0.01638597, -0.03543202, -0.07060306, 0.10347917)

design_initial_self(k.continuous=k.continuous.temp, factor.level=n.factor.temp, lvec=lvec.temp,
uvec=uvec.temp, bvec=bvec.temp, h.func=hfunc.temp, link=link.temp)


</code></pre>

<hr>
<h2 id='discrete_rv_self'>function to generate discrete uniform random variables for initial random design points in ForLion</h2><span id='topic+discrete_rv_self'></span>

<h3>Description</h3>

<p>function to generate discrete uniform random variables for initial random design points in ForLion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete_rv_self(n, xlist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discrete_rv_self_+3A_n">n</code></td>
<td>
<p>number of discrete random variables</p>
</td></tr>
<tr><td><code id="discrete_rv_self_+3A_xlist">xlist</code></td>
<td>
<p>list of levels for variables to be generated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of discrete uniform random variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=3 #three discrete random variables
xlist=list(c(-1,1),c(-1,1),c(-1,0,1)) #two binary and one three-levels
discrete_rv_self(n, xlist)


</code></pre>

<hr>
<h2 id='dprime_func_self'>Function to calculate du/dx in the gradient of d(x, Xi), will be used in ForLion_MLM_func() function, details see Appendix C in Huang, Li, Mandal, Yang (2024)</h2><span id='topic+dprime_func_self'></span>

<h3>Description</h3>

<p>Function to calculate du/dx in the gradient of d(x, Xi), will be used in ForLion_MLM_func() function, details see Appendix C in Huang, Li, Mandal, Yang (2024)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprime_func_self(
  xi,
  bvec,
  h.func,
  h.prime,
  inv.F.mat,
  Ux,
  link = "continuation",
  k.continuous
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dprime_func_self_+3A_xi">xi</code></td>
<td>
<p>a vector of design point</p>
</td></tr>
<tr><td><code id="dprime_func_self_+3A_bvec">bvec</code></td>
<td>
<p>parameter of the multinomial logistic regression model</p>
</td></tr>
<tr><td><code id="dprime_func_self_+3A_h.func">h.func</code></td>
<td>
<p>function, is used to transfer xi to model matrix (e.g. add interaction term, add intercept)</p>
</td></tr>
<tr><td><code id="dprime_func_self_+3A_h.prime">h.prime</code></td>
<td>
<p>function, is used to find dX/dx</p>
</td></tr>
<tr><td><code id="dprime_func_self_+3A_inv.f.mat">inv.F.mat</code></td>
<td>
<p>inverse of F_Xi matrix, inverse of fisher information of current design w/o new point</p>
</td></tr>
<tr><td><code id="dprime_func_self_+3A_ux">Ux</code></td>
<td>
<p>U_x matrix in the algorithm, get from Fi_MLM_func() function</p>
</td></tr>
<tr><td><code id="dprime_func_self_+3A_link">link</code></td>
<td>
<p>multinomial link function, default is&quot;continuation&quot;, other choices &quot;baseline&quot;, &quot;cumulative&quot;, and &quot;adjacent&quot;</p>
</td></tr>
<tr><td><code id="dprime_func_self_+3A_k.continuous">k.continuous</code></td>
<td>
<p>number of continuous factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dU/dx in the gradient of sensitivity function d(x, Xi)
</p>

<hr>
<h2 id='EW_design_initial_self'>function to generate random initial design with design points and the approximate allocation (For EW)</h2><span id='topic+EW_design_initial_self'></span>

<h3>Description</h3>

<p>function to generate random initial design with design points and the approximate allocation (For EW)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EW_design_initial_self(
  k.continuous,
  factor.level,
  lvec,
  uvec,
  bvec_matrix,
  h.func,
  link = "continuation",
  EW_Fi.func = EW_Fi_MLM_func,
  delta = 1e-06,
  epsilon = 1e-12,
  maxit = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EW_design_initial_self_+3A_k.continuous">k.continuous</code></td>
<td>
<p>number of continuous variables</p>
</td></tr>
<tr><td><code id="EW_design_initial_self_+3A_factor.level">factor.level</code></td>
<td>
<p>lower, upper limit of continuous variables, and discrete levels of categorical variables, continuous factors come first</p>
</td></tr>
<tr><td><code id="EW_design_initial_self_+3A_lvec">lvec</code></td>
<td>
<p>lower limit of continuous variables</p>
</td></tr>
<tr><td><code id="EW_design_initial_self_+3A_uvec">uvec</code></td>
<td>
<p>upper limit of continuous variables</p>
</td></tr>
<tr><td><code id="EW_design_initial_self_+3A_bvec_matrix">bvec_matrix</code></td>
<td>
<p>the matrix of the bootstrap parameter values of beta</p>
</td></tr>
<tr><td><code id="EW_design_initial_self_+3A_h.func">h.func</code></td>
<td>
<p>function, is used to transfer the design point to model matrix (e.g. add interaction term, add intercept)</p>
</td></tr>
<tr><td><code id="EW_design_initial_self_+3A_link">link</code></td>
<td>
<p>link function, default &quot;continuation&quot;, other options &quot;baseline&quot;, &quot;adjacent&quot; and &quot;cumulative&quot;</p>
</td></tr>
<tr><td><code id="EW_design_initial_self_+3A_ew_fi.func">EW_Fi.func</code></td>
<td>
<p>function, is used to calculate the Expectation of Fisher information for a design point - default to be EW_Fi_MLM_func() in the package</p>
</td></tr>
<tr><td><code id="EW_design_initial_self_+3A_delta">delta</code></td>
<td>
<p>tuning parameter, the distance threshold, || x_i(0) - x_j(0) || &gt;= delta</p>
</td></tr>
<tr><td><code id="EW_design_initial_self_+3A_epsilon">epsilon</code></td>
<td>
<p>determining f.det &gt; 0 numerically, f.det &lt;= epsilon will be considered as f.det &lt;= 0</p>
</td></tr>
<tr><td><code id="EW_design_initial_self_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X matrix of initial design point
</p>
<p>p0 initial random approximate allocation
</p>
<p>f.det the determinant of Fisher information matrix for the random initial design
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k.continuous.temp=1
link.temp = "continuation"
n.factor.temp = c(0)
factor.level.temp = list(c(80,200))
hfunc.temp = function(y){
matrix(data=c(1,y,y*y,0,0,0,0,0,1,y,0,0,0,0,0), nrow=3, ncol=5, byrow=TRUE)
}
lvec.temp = 80
uvec.temp = 200
bvec_bootstrap&lt;-matrix(c(-0.2401, -1.9292, -2.7851, -1.614,-1.162,
                         -0.0535, -0.0274, -0.0096,-0.0291, -0.04,
                          0.0004,  0.0003,  0.0002,  0.0003,  0.1,
                         -9.2154, -9.7576, -9.6818, -8.5139, -8.56),nrow=4,byrow=TRUE)
EW_design_initial_self(k.continuous=k.continuous.temp, factor.level=n.factor.temp, lvec=lvec.temp,
uvec=uvec.temp, bvec_matrix=bvec_bootstrap, h.func=hfunc.temp, link=link.temp)
</code></pre>

<hr>
<h2 id='EW_dprime_func_self'>Function to calculate dEu/dx in the gradient of d(x, Xi), will be used in EW_ForLion_MLM_func() function</h2><span id='topic+EW_dprime_func_self'></span>

<h3>Description</h3>

<p>Function to calculate dEu/dx in the gradient of d(x, Xi), will be used in EW_ForLion_MLM_func() function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EW_dprime_func_self(
  xi,
  bvec_matrix,
  h.func,
  h.prime,
  inv.F.mat,
  EUx,
  link = "continuation",
  k.continuous
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EW_dprime_func_self_+3A_xi">xi</code></td>
<td>
<p>a vector of design point</p>
</td></tr>
<tr><td><code id="EW_dprime_func_self_+3A_bvec_matrix">bvec_matrix</code></td>
<td>
<p>the matrix of the bootstrap parameter values of beta</p>
</td></tr>
<tr><td><code id="EW_dprime_func_self_+3A_h.func">h.func</code></td>
<td>
<p>function, is used to transfer xi to model matrix (e.g. add interaction term, add intercept)</p>
</td></tr>
<tr><td><code id="EW_dprime_func_self_+3A_h.prime">h.prime</code></td>
<td>
<p>function, is used to find dX/dx</p>
</td></tr>
<tr><td><code id="EW_dprime_func_self_+3A_inv.f.mat">inv.F.mat</code></td>
<td>
<p>inverse of F_Xi matrix, inverse of the Expectation of fisher information of current design w/o new point</p>
</td></tr>
<tr><td><code id="EW_dprime_func_self_+3A_eux">EUx</code></td>
<td>
<p>EU_x matrix in the algorithm, get from EW_Fi_MLM_func() function</p>
</td></tr>
<tr><td><code id="EW_dprime_func_self_+3A_link">link</code></td>
<td>
<p>link multinomial link function, default is&quot;continuation&quot;, other choices &quot;baseline&quot;, &quot;cumulative&quot;, and &quot;adjacent&quot;</p>
</td></tr>
<tr><td><code id="EW_dprime_func_self_+3A_k.continuous">k.continuous</code></td>
<td>
<p>number of continuous factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dEU/dx in the gradient of sensitivity function d(x, Xi)
</p>

<hr>
<h2 id='EW_Fi_MLM_func'>Function to generate the Expectation of fisher information at one design point xi for multinomial logit models</h2><span id='topic+EW_Fi_MLM_func'></span>

<h3>Description</h3>

<p>Function to generate the Expectation of fisher information at one design point xi for multinomial logit models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EW_Fi_MLM_func(X_x, bvec_matrix, link = "continuation")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EW_Fi_MLM_func_+3A_x_x">X_x</code></td>
<td>
<p>model matrix for a specific design point x_i, X_x=h.func(xi)</p>
</td></tr>
<tr><td><code id="EW_Fi_MLM_func_+3A_bvec_matrix">bvec_matrix</code></td>
<td>
<p>the matrix of the bootstrap parameter values of beta</p>
</td></tr>
<tr><td><code id="EW_Fi_MLM_func_+3A_link">link</code></td>
<td>
<p>multinomial logit model link function name &quot;baseline&quot;, &quot;cumulative&quot;, &quot;adjacent&quot;, or&quot;continuation&quot;, default to be &quot;continuation&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>F_x Fisher information matrix at x_i
</p>
<p>EU_x U matrix for calculation the Expectation of Fisher information matrix at x_i
</p>


<h3>Examples</h3>

<pre><code class='language-R'>link.temp = "continuation"
xi.temp=c(80)
hfunc.temp = function(y){
matrix(data=c(1,y,y*y,0,0,0,0,0,1,y,0,0,0,0,0), nrow=3, ncol=5, byrow=TRUE)
}
X_xtemp=hfunc.temp(xi.temp)
bvec_bootstrap&lt;-matrix(c(-0.2401, -1.9292, -2.7851, -1.614,-1.162,
                         -0.0535, -0.0274, -0.0096,-0.0291, -0.04,
                          0.0004,  0.0003,  0.0002,  0.0003,  0.1,
                         -9.2154, -9.7576, -9.6818, -8.5139, -8.56),nrow=4,byrow=TRUE)
EW_Fi_MLM_func(X_x=X_xtemp, bvec_matrix=bvec_bootstrap, link=link.temp)
</code></pre>

<hr>
<h2 id='EW_ForLion_GLM_Optimal'>EW ForLion for generalized linear models</h2><span id='topic+EW_ForLion_GLM_Optimal'></span>

<h3>Description</h3>

<p>EW ForLion algorithm to find EW D-optimal design for GLM models with mixed factors, reference: .
Factors may include discrete factors with finite number of distinct levels and continuous factors
with specified interval range (min, max), continuous factors, if any, must serve as main-effects
only, allowing merging points that are close enough.Continuous factors first then discrete factors,
model parameters should in the same order of factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EW_ForLion_GLM_Optimal(
  n.factor,
  factor.level,
  hfunc,
  joint_Func_b,
  Lowerbounds,
  Upperbounds,
  link,
  reltol = 1e-05,
  rel.diff = 0,
  optim_grad = TRUE,
  maxit = 100,
  random = FALSE,
  nram = 3,
  logscale = FALSE,
  rowmax = NULL,
  Xini = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_n.factor">n.factor</code></td>
<td>
<p>vector of numbers of distinct levels, &quot;0&quot; indicates continuous factors, &quot;0&quot;s always come first, &quot;2&quot; or above indicates discrete factor, &quot;1&quot; is not allowed</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_factor.level">factor.level</code></td>
<td>
<p>list of distinct levels, (min, max) for continuous factor, continuous factors first, should be the same order as n.factor</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_hfunc">hfunc</code></td>
<td>
<p>function for obtaining model matrix h(y) for given design point y, y has to follow the same order as n.factor</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_joint_func_b">joint_Func_b</code></td>
<td>
<p>The prior joint probability distribution of the parameters</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_lowerbounds">Lowerbounds</code></td>
<td>
<p>The lower limit of the prior distribution for each parameter</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_upperbounds">Upperbounds</code></td>
<td>
<p>The upper limit of the prior distribution for each parameter</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_link">link</code></td>
<td>
<p>link function, default &quot;logit&quot;, other links: &quot;probit&quot;, &quot;cloglog&quot;, &quot;loglog&quot;, &quot;cauchit&quot;, &quot;log&quot;, &quot;identity&quot;</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_reltol">reltol</code></td>
<td>
<p>the relative convergence tolerance, default value 1e-5</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_rel.diff">rel.diff</code></td>
<td>
<p>points with distance less than that will be merged, default value 0</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_optim_grad">optim_grad</code></td>
<td>
<p>TRUE or FALSE, default is FALSE, whether to use the analytical gradient function or numerical gradient for searching optimal new design point</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations, default value 100</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run EW lift-one with additional &quot;nram&quot; number of random approximate allocation, default to be FALSE</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_nram">nram</code></td>
<td>
<p>when random == TRUE, the function will run EW lift-one nram number of initial proportion p00, default is 3</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_logscale">logscale</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the EW ForLion will run EW lift-one with logscale, which is EW_liftoneDoptimal_log_GLM_func(); if FALSE then ForLion will run EW lift-one without logscale, which is EW_liftoneDoptimal_GLM_func()</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_rowmax">rowmax</code></td>
<td>
<p>maximum number of points in the initial design, default NULL indicates no restriction</p>
</td></tr>
<tr><td><code id="EW_ForLion_GLM_Optimal_+3A_xini">Xini</code></td>
<td>
<p>initial list of design points, default NULL will generate random initial design points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m number of design points
</p>
<p>x.factor matrix with rows indicating design point
</p>
<p>p EW D-optimal approximate allocation
</p>
<p>det Optimal determinant of Fisher information matrix
</p>
<p>x.model model matrix X
</p>
<p>E_w vector of E_w such that E_w=diag(p*E_w)
</p>
<p>convergence TRUE or FALSE
</p>
<p>min.diff the minimum Euclidean distance between design points
</p>
<p>x.close  a pair of design points with minimum distance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example  Crystallography Experiment
hfunc.temp = function(y) {c(y,1)}   # y -&gt; h(y)=(y1,1)
n.factor.temp = c(0)  # 1 continuous factors
factor.level.temp = list(c(-1,1))
link.temp="logit"
paras_lowerbound&lt;-c(4,-3)
paras_upperbound&lt;-c(10,3)
 gjoint_b&lt;- function(x) {
 Func_b&lt;-1/(prod(paras_upperbound-paras_lowerbound))
 ##the prior distributions are follow uniform distribution
return(Func_b)
}
EW_ForLion_GLM_Optimal(n.factor=n.factor.temp, factor.level=factor.level.temp,
hfunc=hfunc.temp,joint_Func_b=gjoint_b, Lowerbounds=paras_lowerbound,
Upperbounds=paras_upperbound, link=link.temp, reltol=1e-2, rel.diff=0.01,
optim_grad=FALSE, maxit=500, random=FALSE, nram=3, logscale=FALSE,Xini=NULL)
</code></pre>

<hr>
<h2 id='EW_ForLion_MLM_Optimal'>EW ForLion function for multinomial logit models</h2><span id='topic+EW_ForLion_MLM_Optimal'></span>

<h3>Description</h3>

<p>EW ForLion function for multinomial logit models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EW_ForLion_MLM_Optimal(
  J,
  n.factor,
  factor.level,
  hfunc,
  h.prime,
  bvec_matrix,
  link = "continuation",
  EW_Fi.func = EW_Fi_MLM_func,
  delta = 1e-05,
  epsilon = 1e-12,
  reltol = 1e-05,
  rel.diff = 0,
  maxit = 100,
  random = FALSE,
  nram = 3,
  rowmax = NULL,
  Xini = NULL,
  random.initial = FALSE,
  nram.initial = 3,
  optim_grad = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_j">J</code></td>
<td>
<p>number of response levels in the multinomial logit model</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_n.factor">n.factor</code></td>
<td>
<p>vector of numbers of distinct levels, &quot;0&quot; indicates continuous factors, &quot;0&quot;s always come first, &quot;2&quot; or above indicates discrete factor, &quot;1&quot; is not allowed</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_factor.level">factor.level</code></td>
<td>
<p>list of distinct levels, (min, max) for continuous factor, continuous factors first, should be the same order as n.factor</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_hfunc">hfunc</code></td>
<td>
<p>function for obtaining model matrix h(y) for given design point y, y has to follow the same order as n.factor</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_h.prime">h.prime</code></td>
<td>
<p>function to obtain dX/dx</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_bvec_matrix">bvec_matrix</code></td>
<td>
<p>the matrix of the bootstrap parameter values of beta</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_link">link</code></td>
<td>
<p>link function, default &quot;continuation&quot;, other choices &quot;baseline&quot;, &quot;cumulative&quot;, and &quot;adjacent&quot;</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_ew_fi.func">EW_Fi.func</code></td>
<td>
<p>function to calculate row-wise Expectation of Fisher information Fi, default is EW_Fi_MLM_func</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_delta">delta</code></td>
<td>
<p>tuning parameter, the generated design pints distance threshold, || x_i(0) - x_j(0) || &gt;= delta, default 1e-5</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_epsilon">epsilon</code></td>
<td>
<p>determining f.det &gt; 0 numerically, f.det &lt;= epsilon will be considered as f.det &lt;= 0, default 1e-12</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_reltol">reltol</code></td>
<td>
<p>the relative convergence tolerance, default value 1e-5</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_rel.diff">rel.diff</code></td>
<td>
<p>points with distance less than that will be merged, default value 0</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations, default value 100</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run EW lift-one with additional &quot;nram&quot; number of random approximate allocation, default to be FALSE</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_nram">nram</code></td>
<td>
<p>when random == TRUE, the function will run EW lift-one nram number of initial proportion p00, default is 3</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_rowmax">rowmax</code></td>
<td>
<p>maximum number of points in the initial design, default NULL indicates no restriction</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_xini">Xini</code></td>
<td>
<p>initial list of design points, default NULL will generate random initial design points</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_random.initial">random.initial</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run EW ForLion with additional &quot;nram.initial&quot; number of random initial design points, default FALSE</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_nram.initial">nram.initial</code></td>
<td>
<p>when random.initial == TRUE, the function will run EW ForLion algorithm with nram.initial number of initial design points Xini, default is 3</p>
</td></tr>
<tr><td><code id="EW_ForLion_MLM_Optimal_+3A_optim_grad">optim_grad</code></td>
<td>
<p>TRUE or FALSE, default is FALSE, whether to use the analytical gradient function or numerical gradient for searching optimal new design point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m the number of design points
</p>
<p>x.factor matrix of experimental factors with rows indicating design point
</p>
<p>p the reported EW D-optimal approximate allocation
</p>
<p>det the determinant of the maximum Expectation of Fisher information
</p>
<p>convergence TRUE or FALSE, whether converge
</p>
<p>min.diff the minimum Euclidean distance between design points
</p>
<p>x.close  pair of design points with minimum distance
</p>
<p>itmax iteration of the algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J=3
p=5
hfunc.temp = function(y){
matrix(data=c(1,y,y*y,0,0,0,0,0,1,y,0,0,0,0,0), nrow=3, ncol=5, byrow=TRUE)
} #hfunc is a 3*5 matrix, transfer x design matrix to model matrix for emergence of flies example

hprime.temp = function(y){
matrix(data=c(0, 1, 2*y, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0), nrow=3, ncol=5, byrow=TRUE)
}

link.temp = "continuation"
n.factor.temp = c(0)  # 1 continuous factor no discrete factor in EW ForLion
factor.level.temp = list(c(80,200)) #boundary for continuous parameter in Forlion
bvec_bootstrap&lt;-matrix(c(-0.2401, -1.9292, -2.7851, -1.614,-1.162,
                         -0.0535, -0.0274, -0.0096,-0.0291, -0.04,
                          0.0004,  0.0003,  0.0002,  0.0003,  0.1,
                         -9.2154, -9.7576, -9.6818, -8.5139, -8.56),nrow=4,byrow=TRUE)
EW_ForLion_MLM_Optimal(J=J, n.factor=n.factor.temp, factor.level=factor.level.temp,
         hfunc=hfunc.temp,h.prime=h.prime.temp, bvec_matrix=bvec_bootstrap,rel.diff=1,
         link=link.temp, optim_grad=FALSE)

</code></pre>

<hr>
<h2 id='EW_liftoneDoptimal_GLM_func'>EW Lift-one algorithm for D-optimal approximate design</h2><span id='topic+EW_liftoneDoptimal_GLM_func'></span>

<h3>Description</h3>

<p>EW Lift-one algorithm for D-optimal approximate design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EW_liftoneDoptimal_GLM_func(
  X,
  E_w,
  reltol = 1e-05,
  maxit = 100,
  random = FALSE,
  nram = 3,
  p00 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EW_liftoneDoptimal_GLM_func_+3A_x">X</code></td>
<td>
<p>Model matrix, with nrow = num of design points and ncol = num of parameters</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_GLM_func_+3A_e_w">E_w</code></td>
<td>
<p>Diagonal of E_W matrix in Fisher information matrix, can be calculated EW_Xw_maineffects_self() function in the ForLion package</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_GLM_func_+3A_reltol">reltol</code></td>
<td>
<p>reltol The relative convergence tolerance, default value 1e-5</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_GLM_func_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations, default value 100</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_GLM_func_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run with additional &quot;nram&quot; number of initial allocation p00, default to be TRUE</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_GLM_func_+3A_nram">nram</code></td>
<td>
<p>When random == TRUE, the function will generate nram number of initial points, default is 3</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_GLM_func_+3A_p00">p00</code></td>
<td>
<p>Specified initial design approximate allocation; default to be NULL, this will generate a random initial design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p  EW D-optimal approximate allocation
</p>
<p>p0 Initial approximate allocation that derived the reported EW D-optimal approximate allocation
</p>
<p>Maximum The maximum of the determinant of the Fisher information matrix of the reported EW D-optimal design
</p>
<p>convergence Convergence TRUE or FALSE
</p>
<p>itmax number of the iteration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hfunc.temp = function(y) {c(y,1);};   # y -&gt; h(y)=(y1,y2,y3,1)
link.temp="logit"
paras_lowerbound&lt;-rep(-Inf, 4)
paras_upperbound&lt;-rep(Inf, 4)
gjoint_b&lt;- function(x) {
mu1 &lt;- -0.5; sigma1 &lt;- 1
mu2 &lt;- 0.5; sigma2 &lt;- 1
mu3 &lt;- 1; sigma3 &lt;- 1
mu0 &lt;- 1; sigma0 &lt;- 1
d1 &lt;- stats::dnorm(x[1], mean = mu1, sd = sigma1)
d2 &lt;- stats::dnorm(x[2], mean = mu2, sd = sigma2)
d3 &lt;- stats::dnorm(x[3], mean = mu3, sd = sigma3)
d4 &lt;- stats::dnorm(x[4], mean = mu0, sd = sigma0)
return(d1 * d2 * d3 * d4)
}
x.temp=matrix(data=c(-2,-1,-3,2,-1,-3,-2,1,-3,2,1,-3,-2,-1,3,2,-1,3,-2,1,3,2,1,3),ncol=3,byrow=TRUE)
m.temp=dim(x.temp)[1]     # number of design points
p.temp=length(paras_upperbound)    # number of predictors
Xmat.temp=matrix(0, m.temp, p.temp)
EW_wvec.temp=rep(0, m.temp)
for(i in 1:m.temp) {
htemp=EW_Xw_maineffects_self(x=x.temp[i,],joint_Func_b=gjoint_b, Lowerbounds=paras_lowerbound,
                             Upperbounds=paras_upperbound, link=link.temp, h.func=hfunc.temp);
Xmat.temp[i,]=htemp$X;
EW_wvec.temp[i]=htemp$E_w;
}
EW_liftoneDoptimal_GLM_func(X=Xmat.temp, E_w=EW_wvec.temp, reltol=1e-8, maxit=1000,
                            random=TRUE, nram=3, p00=NULL)
</code></pre>

<hr>
<h2 id='EW_liftoneDoptimal_log_GLM_func'>EW Lift-one algorithm for D-optimal approximate design in log scale</h2><span id='topic+EW_liftoneDoptimal_log_GLM_func'></span>

<h3>Description</h3>

<p>EW Lift-one algorithm for D-optimal approximate design in log scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EW_liftoneDoptimal_log_GLM_func(
  X,
  E_w,
  reltol = 1e-05,
  maxit = 100,
  random = FALSE,
  nram = 3,
  p00 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EW_liftoneDoptimal_log_GLM_func_+3A_x">X</code></td>
<td>
<p>Model matrix, with nrow = num of design points and ncol = num of parameters</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_log_GLM_func_+3A_e_w">E_w</code></td>
<td>
<p>Diagonal of E_W matrix in Fisher information matrix, can be calculated EW_Xw_maineffects_self() function in the ForLion package</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_log_GLM_func_+3A_reltol">reltol</code></td>
<td>
<p>reltol The relative convergence tolerance, default value 1e-5</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_log_GLM_func_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations, default value 100</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_log_GLM_func_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run with additional &quot;nram&quot; number of initial allocation p00, default to be TRUE</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_log_GLM_func_+3A_nram">nram</code></td>
<td>
<p>When random == TRUE, the function will generate nram number of initial points, default is 3</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_log_GLM_func_+3A_p00">p00</code></td>
<td>
<p>Specified initial design approximate allocation; default to be NULL, this will generate a random initial design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p  EW D-optimal approximate allocation
</p>
<p>p0 Initial approximate allocation that derived the reported EW D-optimal approximate allocation
</p>
<p>Maximum The maximum of the determinant of the Fisher information matrix of the reported EW D-optimal design
</p>
<p>convergence Convergence TRUE or FALSE
</p>
<p>itmax number of the iteration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hfunc.temp = function(y) {c(y,1);};   # y -&gt; h(y)=(y1,y2,y3,1)
link.temp="logit"
paras_lowerbound&lt;-rep(-Inf, 4)
paras_upperbound&lt;-rep(Inf, 4)
gjoint_b&lt;- function(x) {
mu1 &lt;- -0.5; sigma1 &lt;- 1
mu2 &lt;- 0.5; sigma2 &lt;- 1
mu3 &lt;- 1; sigma3 &lt;- 1
mu0 &lt;- 1; sigma0 &lt;- 1
d1 &lt;- stats::dnorm(x[1], mean = mu1, sd = sigma1)
d2 &lt;- stats::dnorm(x[2], mean = mu2, sd = sigma2)
d3 &lt;- stats::dnorm(x[3], mean = mu3, sd = sigma3)
d4 &lt;- stats::dnorm(x[4], mean = mu0, sd = sigma0)
return(d1 * d2 * d3 * d4)
}
x.temp=matrix(data=c(-2,-1,-3,2,-1,-3,-2,1,-3,2,1,-3,-2,-1,3,2,-1,3,-2,1,3,2,1,3),
              ncol=3,byrow=TRUE)
m.temp=dim(x.temp)[1]     # number of design points
p.temp=length(paras_upperbound)    # number of predictors
Xmat.temp=matrix(0, m.temp, p.temp)
EW_wvec.temp=rep(0, m.temp)
for(i in 1:m.temp) {
htemp=EW_Xw_maineffects_self(x=x.temp[i,],joint_Func_b=gjoint_b, Lowerbounds=paras_lowerbound,
                             Upperbounds=paras_upperbound, link=link.temp, h.func=hfunc.temp);
Xmat.temp[i,]=htemp$X;
EW_wvec.temp[i]=htemp$E_w;
}
EW_liftoneDoptimal_GLM_func(X=Xmat.temp, E_w=EW_wvec.temp, reltol=1e-8, maxit=1000, random=TRUE,
                            nram=3, p00=NULL)
</code></pre>

<hr>
<h2 id='EW_liftoneDoptimal_MLM_func'>function of EW liftone for multinomial logit model</h2><span id='topic+EW_liftoneDoptimal_MLM_func'></span>

<h3>Description</h3>

<p>function of EW liftone for multinomial logit model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EW_liftoneDoptimal_MLM_func(
  m,
  p,
  Xi,
  J,
  thetavec_matrix,
  link = "continuation",
  reltol = 1e-05,
  maxit = 500,
  p00 = NULL,
  random = FALSE,
  nram = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EW_liftoneDoptimal_MLM_func_+3A_m">m</code></td>
<td>
<p>number of design points</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_MLM_func_+3A_p">p</code></td>
<td>
<p>number of parameters in the multinomial logit model</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_MLM_func_+3A_xi">Xi</code></td>
<td>
<p>model matrix</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_MLM_func_+3A_j">J</code></td>
<td>
<p>number of response levels in the multinomial logit model</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_MLM_func_+3A_thetavec_matrix">thetavec_matrix</code></td>
<td>
<p>the matrix of the bootstrap parameter values of beta</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_MLM_func_+3A_link">link</code></td>
<td>
<p>multinomial logit model link function name &quot;baseline&quot;, &quot;cumulative&quot;, &quot;adjacent&quot;, or&quot;continuation&quot;, default to be &quot;continuation&quot;</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_MLM_func_+3A_reltol">reltol</code></td>
<td>
<p>relative tolerance for convergence, default to 1e-5</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_MLM_func_+3A_maxit">maxit</code></td>
<td>
<p>the number of maximum iteration, default to 500</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_MLM_func_+3A_p00">p00</code></td>
<td>
<p>specified initial approximate allocation, default to NULL, if NULL, will generate a random initial approximate allocation</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_MLM_func_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run with additional &quot;nram&quot; number of initial allocation p00, default to be TRUE</p>
</td></tr>
<tr><td><code id="EW_liftoneDoptimal_MLM_func_+3A_nram">nram</code></td>
<td>
<p>when random == TRUE, the function will generate nram number of initial points, default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p reported EW D-optimal approximate allocation
</p>
<p>p0 the initial approximate allocation that derived the reported EW D-optimal design
</p>
<p>Maximum the maximum of the determinant of the Expectation of Fisher information matrix
</p>
<p>Convergence TRUE or FALSE, whether the algorithm converges
</p>
<p>itmax, maximum iterations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m=7
p=5
J=3
link.temp = "continuation"
factor_x=c(80,100,120,140,160,180,200)
hfunc.temp = function(y){
matrix(data=c(1,y,y*y,0,0,0,0,0,1,y,0,0,0,0,0), nrow=3, ncol=5, byrow=TRUE)
}
Xi=rep(0,J*p*m); dim(Xi)=c(J,p,m)
for(i in 1:m) {
Xi[,,i]=hfunc.temp(factor_x[i])
}
bvec_bootstrap&lt;-matrix(c(-0.2401, -1.9292, -2.7851, -1.614,-1.162,
                         -0.0535, -0.0274, -0.0096,-0.0291, -0.04,
                          0.0004,  0.0003,  0.0002,  0.0003,  0.1,
                         -9.2154, -9.7576, -9.6818, -8.5139, -8.56),nrow=4,byrow=TRUE)
EW_liftoneDoptimal_MLM_func(m=m, p=p, Xi=Xi, J=J, thetavec_matrix=bvec_bootstrap,
link = "continuation",reltol=1e-5, maxit=500, p00=rep(1/7,7), random=FALSE, nram=3)


</code></pre>

<hr>
<h2 id='EW_Xw_maineffects_self'>function for calculating X=h(x) and E_w=E(nu(beta^T h(x))) give a design point x=(1,x1,...,xd)^T</h2><span id='topic+EW_Xw_maineffects_self'></span>

<h3>Description</h3>

<p>function for calculating X=h(x) and E_w=E(nu(beta^T h(x))) give a design point x=(1,x1,...,xd)^T
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EW_Xw_maineffects_self(
  x,
  joint_Func_b,
  Lowerbounds,
  Upperbounds,
  link = "logit",
  h.func = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EW_Xw_maineffects_self_+3A_x">x</code></td>
<td>
<p>x=(x1,...,xd) &ndash; design point/experimental setting</p>
</td></tr>
<tr><td><code id="EW_Xw_maineffects_self_+3A_joint_func_b">joint_Func_b</code></td>
<td>
<p>The prior joint probability distribution of the parameters</p>
</td></tr>
<tr><td><code id="EW_Xw_maineffects_self_+3A_lowerbounds">Lowerbounds</code></td>
<td>
<p>The lower limit of the prior distribution for each parameter</p>
</td></tr>
<tr><td><code id="EW_Xw_maineffects_self_+3A_upperbounds">Upperbounds</code></td>
<td>
<p>The upper limit of the prior distribution for each parameter</p>
</td></tr>
<tr><td><code id="EW_Xw_maineffects_self_+3A_link">link</code></td>
<td>
<p>link = &quot;logit&quot;  &ndash; link function, default: &quot;logit&quot;, other links: &quot;probit&quot;, &quot;cloglog&quot;, &quot;loglog&quot;, &quot;cauchit&quot;, &quot;log&quot;</p>
</td></tr>
<tr><td><code id="EW_Xw_maineffects_self_+3A_h.func">h.func</code></td>
<td>
<p>function h(x)=(h1(x),...,hp(x)), default (1,x1,...,xd)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X=h(x)=(h1(x),...,hp(x)) &ndash; a row for design matrix
</p>
<p>E_w &ndash; E(nu(b^t h(x)))
</p>
<p>link &ndash; link function applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hfunc.temp = function(y) {c(y,1);};   # y -&gt; h(y)=(y1,y2,y3,1)
link.temp="logit"
paras_lowerbound&lt;-rep(-Inf, 4)
paras_upperbound&lt;-rep(Inf, 4)
gjoint_b&lt;- function(x) {
mu1 &lt;- -0.5; sigma1 &lt;- 1
mu2 &lt;- 0.5; sigma2 &lt;- 1
mu3 &lt;- 1; sigma3 &lt;- 1
mu0 &lt;- 1; sigma0 &lt;- 1
d1 &lt;- stats::dnorm(x[1], mean = mu1, sd = sigma1)
d2 &lt;- stats::dnorm(x[2], mean = mu2, sd = sigma2)
d3 &lt;- stats::dnorm(x[3], mean = mu3, sd = sigma3)
d4 &lt;- stats::dnorm(x[4], mean = mu0, sd = sigma0)
return(d1 * d2 * d3 * d4)
}
x.temp = c(2,1,3)
EW_Xw_maineffects_self(x=x.temp,joint_Func_b=gjoint_b, Lowerbounds=paras_lowerbound,
 Upperbounds=paras_upperbound, link=link.temp, h.func=hfunc.temp)
</code></pre>

<hr>
<h2 id='Fi_MLM_func'>Function to generate fisher information at one design point xi for multinomial logit models</h2><span id='topic+Fi_MLM_func'></span>

<h3>Description</h3>

<p>Function to generate fisher information at one design point xi for multinomial logit models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fi_MLM_func(X_x, bvec, link = "continuation")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fi_MLM_func_+3A_x_x">X_x</code></td>
<td>
<p>model matrix for a specific design point x_i, X_x=h.func(xi)</p>
</td></tr>
<tr><td><code id="Fi_MLM_func_+3A_bvec">bvec</code></td>
<td>
<p>beta coefficients in the model</p>
</td></tr>
<tr><td><code id="Fi_MLM_func_+3A_link">link</code></td>
<td>
<p>multinomial logit model link function name &quot;baseline&quot;, &quot;cumulative&quot;, &quot;adjacent&quot;, or&quot;continuation&quot;, default to be &quot;continuation&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>F_x Fisher information matrix at x_i
</p>
<p>U_x U matrix for calculation of Fisher information matrix at x_i (see Corollary 3.1 in Bu, Majumdar, Yang(2020))
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reference minimizing surface example in supplementary material
# Section S.3 in Huang, Li, Mandal, Yang (2024)
xi.temp = c(-1, -25, 199.96, -150, -100, 16)
hfunc.temp = function(y){
if(length(y) != 6){stop("Input should have length 6");}
model.mat = matrix(NA, nrow=5, ncol=10, byrow=TRUE)
model.mat[5,]=0
model.mat[1:4,1:4] = diag(4)
model.mat[1:4, 5] =((-1)*y[6])
model.mat[1:4, 6:10] = matrix(((-1)*y[1:5]), nrow=4, ncol=5, byrow=TRUE)
return(model.mat)
}
X_x.temp = hfunc.temp(xi.temp)
bvec.temp = c(-1.77994301, -0.05287782,  1.86852211, 2.76330779, -0.94437464,
0.18504420,  -0.01638597, -0.03543202, -0.07060306, 0.10347917)
link.temp = "cumulative"
Fi_MLM_func(X_x=X_x.temp, bvec=bvec.temp, link=link.temp)


</code></pre>

<hr>
<h2 id='ForLion_GLM_Optimal'>ForLion for generalized linear models</h2><span id='topic+ForLion_GLM_Optimal'></span>

<h3>Description</h3>

<p>ForLion algorithm to find D-optimal design for GLM models with mixed factors, reference: Section 4 in Huang, Li, Mandal, Yang (2024).
Factors may include discrete factors with finite number of distinct levels and continuous factors with specified interval range (min, max), continuous factors, if any, must serve as main-effects only, allowing merging points that are close enough.
Continuous factors first then discrete factors, model parameters should in the same order of factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ForLion_GLM_Optimal(
  n.factor,
  factor.level,
  hfunc,
  bvec,
  link,
  reltol = 1e-05,
  rel.diff = 0,
  maxit = 100,
  random = FALSE,
  nram = 3,
  logscale = FALSE,
  rowmax = NULL,
  Xini = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ForLion_GLM_Optimal_+3A_n.factor">n.factor</code></td>
<td>
<p>vector of numbers of distinct levels, &quot;0&quot; indicates continuous factors, &quot;0&quot;s always come first, &quot;2&quot; or above indicates discrete factor, &quot;1&quot; is not allowed</p>
</td></tr>
<tr><td><code id="ForLion_GLM_Optimal_+3A_factor.level">factor.level</code></td>
<td>
<p>list of distinct levels, (min, max) for continuous factor, continuous factors first, should be the same order as n.factor</p>
</td></tr>
<tr><td><code id="ForLion_GLM_Optimal_+3A_hfunc">hfunc</code></td>
<td>
<p>function for obtaining model matrix h(y) for given design point y, y has to follow the same order as n.factor</p>
</td></tr>
<tr><td><code id="ForLion_GLM_Optimal_+3A_bvec">bvec</code></td>
<td>
<p>assumed parameter values of model parameters beta, same length of h(y)</p>
</td></tr>
<tr><td><code id="ForLion_GLM_Optimal_+3A_link">link</code></td>
<td>
<p>link function, default &quot;logit&quot;, other links: &quot;probit&quot;, &quot;cloglog&quot;, &quot;loglog&quot;, &quot;cauchit&quot;, &quot;log&quot;, &quot;identity&quot;</p>
</td></tr>
<tr><td><code id="ForLion_GLM_Optimal_+3A_reltol">reltol</code></td>
<td>
<p>the relative convergence tolerance, default value 1e-5</p>
</td></tr>
<tr><td><code id="ForLion_GLM_Optimal_+3A_rel.diff">rel.diff</code></td>
<td>
<p>points with distance less than that will be merged, default value 0</p>
</td></tr>
<tr><td><code id="ForLion_GLM_Optimal_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations, default value 100</p>
</td></tr>
<tr><td><code id="ForLion_GLM_Optimal_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run lift-one with additional &quot;nram&quot; number of random approximate allocation, default to be FALSE</p>
</td></tr>
<tr><td><code id="ForLion_GLM_Optimal_+3A_nram">nram</code></td>
<td>
<p>when random == TRUE, the function will run lift-one nram number of initial proportion p00, default is 3</p>
</td></tr>
<tr><td><code id="ForLion_GLM_Optimal_+3A_logscale">logscale</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the ForLion will run lift-one with logscale, which is liftoneDoptimal_log_GLM_func(); if FALSE then ForLion will run lift-one without logscale, which is liftoneDoptimal_GLM_func()</p>
</td></tr>
<tr><td><code id="ForLion_GLM_Optimal_+3A_rowmax">rowmax</code></td>
<td>
<p>maximum number of points in the initial design, default NULL indicates no restriction</p>
</td></tr>
<tr><td><code id="ForLion_GLM_Optimal_+3A_xini">Xini</code></td>
<td>
<p>initial list of design points, default NULL will generate random initial design points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m number of design points
</p>
<p>x.factor matrix with rows indicating design point
</p>
<p>p D-optimal approximate allocation
</p>
<p>det Optimal determinant of Fisher information matrix
</p>
<p>convergence TRUE or FALSE
</p>
<p>min.diff the minimum Euclidean distance between design points
</p>
<p>x.close  a pair of design points with minimum distance
</p>
<p>itmax iteration of the algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 3 in Huang, Li, Mandal, Yang (2024), electrostatic discharge experiment
hfunc.temp = function(y) {c(y,y[4]*y[5],1);};   # y -&gt; h(y)=(y1,y2,y3,y4,y5,y4*y5,1)
n.factor.temp = c(0, 2, 2, 2, 2)  # 1 continuous factor with 4 discrete factors
factor.level.temp = list(c(25,45),c(-1,1),c(-1,1),c(-1,1),c(-1,1))
link.temp="logit"
b.temp = c(0.3197169,  1.9740922, -0.1191797, -0.2518067,  0.1970956,  0.3981632, -7.6648090)
ForLion_GLM_Optimal(n.factor=n.factor.temp, factor.level=factor.level.temp, hfunc=hfunc.temp,
bvec=b.temp, link=link.temp, reltol=1e-2, rel.diff=0.03, maxit=500, random=FALSE,
nram=3, logscale=TRUE)

</code></pre>

<hr>
<h2 id='ForLion_MLM_Optimal'>ForLion function for multinomial logit models</h2><span id='topic+ForLion_MLM_Optimal'></span>

<h3>Description</h3>

<p>Function for ForLion algorithm to find D-optimal design under multinomial logit models with mixed factors.
Reference Section 3 of Huang, Li, Mandal, Yang (2024).
Factors may include discrete factors with finite number of distinct levels and continuous factors with specified interval range (min, max), continuous factors, if any, must serve as main-effects only, allowing merging points that are close enough.
Continuous factors first then discrete factors, model parameters should in the same order of factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ForLion_MLM_Optimal(
  J,
  n.factor,
  factor.level,
  hfunc,
  h.prime,
  bvec,
  link = "continuation",
  Fi.func = Fi_MLM_func,
  delta = 1e-05,
  epsilon = 1e-12,
  reltol = 1e-05,
  rel.diff = 0,
  maxit = 100,
  random = FALSE,
  nram = 3,
  rowmax = NULL,
  Xini = NULL,
  random.initial = FALSE,
  nram.initial = 3,
  optim_grad = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ForLion_MLM_Optimal_+3A_j">J</code></td>
<td>
<p>number of response levels in the multinomial logit model</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_n.factor">n.factor</code></td>
<td>
<p>vector of numbers of distinct levels, &quot;0&quot; indicates continuous factors, &quot;0&quot;s always come first, &quot;2&quot; or above indicates discrete factor, &quot;1&quot; is not allowed</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_factor.level">factor.level</code></td>
<td>
<p>list of distinct levels, (min, max) for continuous factor, continuous factors first, should be the same order as n.factor</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_hfunc">hfunc</code></td>
<td>
<p>function for obtaining model matrix h(y) for given design point y, y has to follow the same order as n.factor</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_h.prime">h.prime</code></td>
<td>
<p>function to obtain dX/dx</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_bvec">bvec</code></td>
<td>
<p>assumed parameter values of model parameters beta, same length of h(y)</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_link">link</code></td>
<td>
<p>link function, default &quot;continuation&quot;, other choices &quot;baseline&quot;, &quot;cumulative&quot;, and &quot;adjacent&quot;</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_fi.func">Fi.func</code></td>
<td>
<p>function to calculate row-wise Fisher information Fi, default is Fi_MLM_func</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_delta">delta</code></td>
<td>
<p>tuning parameter, the generated design pints distance threshold, || x_i(0) - x_j(0) || &gt;= delta, default 1e-5</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_epsilon">epsilon</code></td>
<td>
<p>for determining f.det &gt; 0 numerically, f.det &lt;= epsilon will be considered as f.det &lt;= 0, default 1e-12</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_reltol">reltol</code></td>
<td>
<p>the relative convergence tolerance, default value 1e-5</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_rel.diff">rel.diff</code></td>
<td>
<p>points with distance less than that will be merged, default value 0</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations, default value 100</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run lift-one with additional &quot;nram&quot; number of random approximate allocation, default to be FALSE</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_nram">nram</code></td>
<td>
<p>when random == TRUE, the function will run lift-one nram number of initial proportion p00, default is 3</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_rowmax">rowmax</code></td>
<td>
<p>maximum number of points in the initial design, default NULL indicates no restriction</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_xini">Xini</code></td>
<td>
<p>initial list of design points, default NULL will generate random initial design points</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_random.initial">random.initial</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run ForLion with additional &quot;nram.initial&quot; number of random initial design points, default FALSE</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_nram.initial">nram.initial</code></td>
<td>
<p>when random.initial == TRUE, the function will run ForLion algorithm with nram.initial number of initial design points Xini, default is 3</p>
</td></tr>
<tr><td><code id="ForLion_MLM_Optimal_+3A_optim_grad">optim_grad</code></td>
<td>
<p>TRUE or FALSE, default is FALSE, whether to use the analytical gradient function or numerical gradient for searching optimal new design point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m the number of design points
</p>
<p>x.factor matrix of experimental factors with rows indicating design point
</p>
<p>p the reported D-optimal approximate allocation
</p>
<p>det the determinant of the maximum Fisher information
</p>
<p>convergence TRUE or FALSE, whether converge
</p>
<p>min.diff the minimum Euclidean distance between design points
</p>
<p>x.close  pair of design points with minimum distance
</p>
<p>itmax iteration of the algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m=5
p=10
J=5
link.temp = "cumulative"
n.factor.temp = c(0,0,0,0,0,2)  # 1 discrete factor w/ 2 levels + 5 continuous
## Note: Always put continuous factors ahead of discrete factors,
## pay attention to the order of coefficients paring with predictors
factor.level.temp = list(c(-25,25), c(-200,200),c(-150,0),c(-100,0),c(0,16),c(-1,1))
hfunc.temp = function(y){
if(length(y) != 6){stop("Input should have length 6");}
 model.mat = matrix(NA, nrow=5, ncol=10, byrow=TRUE)
 model.mat[5,]=0
 model.mat[1:4,1:4] = diag(4)
 model.mat[1:4, 5] =((-1)*y[6])
 model.mat[1:4, 6:10] = matrix(((-1)*y[1:5]), nrow=4, ncol=5, byrow=TRUE)
 return(model.mat)
 }
bvec.temp=c(-1.77994301, -0.05287782,  1.86852211, 2.76330779, -0.94437464, 0.18504420,
-0.01638597, -0.03543202, -0.07060306, 0.10347917)

h.prime.temp = NULL #use numerical gradient (optim_grad=FALSE)
ForLion_MLM_Optimal(J=J, n.factor=n.factor.temp, factor.level=factor.level.temp, hfunc=hfunc.temp,
h.prime=h.prime.temp, bvec=bvec.temp, link=link.temp, optim_grad=FALSE)


</code></pre>

<hr>
<h2 id='GLM_Exact_Design'>Approximation to exact design algorithm for generalized linear model</h2><span id='topic+GLM_Exact_Design'></span>

<h3>Description</h3>

<p>Approximation to exact design algorithm for generalized linear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLM_Exact_Design(
  k.continuous,
  design_x,
  design_p,
  det.design,
  p,
  ForLion,
  bvec,
  joint_Func_b,
  Lowerbounds,
  Upperbounds,
  rel.diff,
  L,
  N,
  hfunc,
  link
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM_Exact_Design_+3A_k.continuous">k.continuous</code></td>
<td>
<p>number of continuous factors</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_design_x">design_x</code></td>
<td>
<p>the matrix with rows indicating design point which we got from the approximate design</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_design_p">design_p</code></td>
<td>
<p>D-optimal approximate allocation</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_det.design">det.design</code></td>
<td>
<p>the determinant of D-optimal approximate allocation</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_p">p</code></td>
<td>
<p>number of parameters</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_forlion">ForLion</code></td>
<td>
<p>TRUE or FALSE, TRUE: this approximate design was generated by ForLion algorithm,
FALSE: this approximate was generated by EW ForLion algorithm</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_bvec">bvec</code></td>
<td>
<p>assumed parameter values of model parameters beta, same length of h(y)</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_joint_func_b">joint_Func_b</code></td>
<td>
<p>The prior joint probability distribution of the parameters</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_lowerbounds">Lowerbounds</code></td>
<td>
<p>The lower limit of the prior distribution for each parameter</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_upperbounds">Upperbounds</code></td>
<td>
<p>The upper limit of the prior distribution for each parameter</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_rel.diff">rel.diff</code></td>
<td>
<p>points with distance less than that will be merged</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_l">L</code></td>
<td>
<p>rounding factor</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_n">N</code></td>
<td>
<p>total number of observations</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_hfunc">hfunc</code></td>
<td>
<p>function for obtaining model matrix h(y) for given design point y, y has to follow the same order as n.factor</p>
</td></tr>
<tr><td><code id="GLM_Exact_Design_+3A_link">link</code></td>
<td>
<p>link function, default &quot;logit&quot;, other links: &quot;probit&quot;, &quot;cloglog&quot;, &quot;loglog&quot;, &quot;cauchit&quot;, &quot;log&quot;, &quot;identity&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x.design matrix with rows indicating design point
</p>
<p>ni.design EW D-optimal or D-optimal exact allocation
</p>
<p>rel.efficiency relative efficiency of the Exact and Approximate Designs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k.continuous=1
design_x=matrix(c(25, -1, -1,-1, -1 ,
                 25, -1, -1, -1, 1,
                 25, -1, -1, 1, -1,
                 25, -1, -1, 1, 1,
                 25, -1, 1, -1, -1,
                 25, -1, 1, -1, 1,
                 25, -1, 1, 1, -1,
                 25, -1, 1, 1, 1,
                 25, 1, -1, 1, -1,
                 25, 1, 1, -1, -1,
                 25, 1, 1, -1, 1,
                 25, 1, 1, 1, -1,
                 25, 1, 1, 1, 1,
                 38.9479, -1, 1, 1, -1,
                 34.0229, -1, 1, -1, -1,
                 35.4049, -1, 1, -1, 1,
                 37.1960, -1, -1, 1, -1,
                 33.0884, -1, 1, 1, 1),nrow=18,ncol=5,byrow = TRUE)
hfunc.temp = function(y) {c(y,y[4]*y[5],1);};   # y -&gt; h(y)=(y1,y2,y3,y4,y5,y4*y5,1)
link.temp="logit"
design_p=c(0.0848, 0.0875, 0.0410, 0.0856, 0.0690, 0.0515,
          0.0901, 0.0845, 0.0743, 0.0356, 0.0621, 0.0443,
          0.0090, 0.0794, 0.0157, 0.0380, 0.0455, 0.0022)
det.design=4.552715e-06
paras_lowerbound&lt;-c(0.25,1,-0.3,-0.3,0.1,0.35,-8.0)
paras_upperbound&lt;-c(0.45,2,-0.1,0.0,0.4,0.45,-7.0)
 gjoint_b&lt;- function(x) {
 Func_b&lt;-1/(prod(paras_upperbound-paras_lowerbound))
 ##the prior distributions are follow uniform distribution
return(Func_b)
}
 GLM_Exact_Design(k.continuous=k.continuous,design_x=design_x,
 design_p=design_p,det.design=det.design,p=7,ForLion=FALSE,joint_Func_b=gjoint_b,
 Lowerbounds=paras_lowerbound, Upperbounds=paras_upperbound,rel.diff=0,L=1,
 N=100,hfunc=hfunc.temp,link=link.temp)
</code></pre>

<hr>
<h2 id='liftoneDoptimal_GLM_func'>Lift-one algorithm for D-optimal approximate design</h2><span id='topic+liftoneDoptimal_GLM_func'></span>

<h3>Description</h3>

<p>Lift-one algorithm for D-optimal approximate design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liftoneDoptimal_GLM_func(
  X,
  w,
  reltol = 1e-05,
  maxit = 100,
  random = FALSE,
  nram = 3,
  p00 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="liftoneDoptimal_GLM_func_+3A_x">X</code></td>
<td>
<p>Model matrix, with nrow = num of design points and ncol = num of parameters</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_GLM_func_+3A_w">w</code></td>
<td>
<p>Diagonal of W matrix in Fisher information matrix, can be calculated Xw_maineffects_self() function in the ForLion package</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_GLM_func_+3A_reltol">reltol</code></td>
<td>
<p>The relative convergence tolerance, default value 1e-5</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_GLM_func_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations, default value 100</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_GLM_func_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run with additional &quot;nram&quot; number of initial allocation p00, default to be TRUE</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_GLM_func_+3A_nram">nram</code></td>
<td>
<p>When random == TRUE, the function will generate nram number of initial points, default is 3</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_GLM_func_+3A_p00">p00</code></td>
<td>
<p>Specified initial design approximate allocation; default to be NULL, this will generate a random initial design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p D-optimal approximate allocation
</p>
<p>p0 Initial approximate allocation that derived the reported D-optimal approximate allocation
</p>
<p>Maximum The maximum of the determinant of the Fisher information matrix of the reported D-optimal design
</p>
<p>convergence Convergence TRUE or FALSE
</p>
<p>itmax number of the iteration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hfunc.temp = function(y) {c(y,y[4]*y[5],1);};   # y -&gt; h(y)=(y1,y2,y3,y4,y5,y4*y5,1)
link.temp="logit"
x.temp = matrix(data=c(25.00000,1,-1,1,-1,25.00000,1,1,1,-1,32.06741,-1,1,-1,1,40.85698,
-1,1,1,-1,28.86602,-1,1,-1,-1,29.21486,-1,-1,1,1,25.00000,1,1,1,1, 25.00000,1,1,-1,-1),
ncol=5, byrow=TRUE)
b.temp = c(0.3197169,  1.9740922, -0.1191797, -0.2518067,  0.1970956,  0.3981632, -7.6648090)
X.mat = matrix(,nrow=8, ncol=7)
w.vec = rep(NA,8)
for(i in 1:8) {
htemp=Xw_maineffects_self(x=x.temp[i,], b=b.temp, link=link.temp, h.func=hfunc.temp);
X.mat[i,]=htemp$X;
w.vec[i]=htemp$w;
};
liftoneDoptimal_GLM_func(X=X.mat, w=w.vec, reltol=1e-5, maxit=500, random=TRUE, nram=3, p00=NULL)

</code></pre>

<hr>
<h2 id='liftoneDoptimal_log_GLM_func'>Lift-one algorithm for D-optimal approximate design in log scale</h2><span id='topic+liftoneDoptimal_log_GLM_func'></span>

<h3>Description</h3>

<p>Lift-one algorithm for D-optimal approximate design in log scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liftoneDoptimal_log_GLM_func(
  X,
  w,
  reltol = 1e-05,
  maxit = 100,
  random = FALSE,
  nram = 3,
  p00 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="liftoneDoptimal_log_GLM_func_+3A_x">X</code></td>
<td>
<p>Model matrix, with nrow = num of design points and ncol = num of parameters</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_log_GLM_func_+3A_w">w</code></td>
<td>
<p>Diagonal of W matrix in Fisher information matrix, can be calculated Xw_maineffects_self() function in the ForLion package</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_log_GLM_func_+3A_reltol">reltol</code></td>
<td>
<p>The relative convergence tolerance, default value 1e-5</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_log_GLM_func_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations, default value 100</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_log_GLM_func_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run with additional &quot;nram&quot; number of initial allocation p00, default to be TRUE</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_log_GLM_func_+3A_nram">nram</code></td>
<td>
<p>When random == TRUE, the function will generate nram number of initial points, default is 3</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_log_GLM_func_+3A_p00">p00</code></td>
<td>
<p>Specified initial design approximate allocation; default to be NULL, this will generate a random initial design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p D-optimal approximate allocation
</p>
<p>p0 Initial approximate allocation that derived the reported D-optimal approximate allocation
</p>
<p>Maximum The maximum of the determinant of the Fisher information matrix of the reported D-optimla design
</p>
<p>convergence Convergence TRUE or FALSE
</p>
<p>itmax number of the iteration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hfunc.temp = function(y) {c(y,y[4]*y[5],1);};   # y -&gt; h(y)=(y1,y2,y3,y4,y5,y4*y5,1)
link.temp="logit"
x.temp = matrix(data=c(25.00000,1,-1,1,-1,25.00000,1,1,1,-1,32.06741,-1,1,-1,1,40.85698,
-1,1,1,-1,28.86602,-1,1,-1,-1,29.21486,-1,-1,1,1,25.00000,1,1,1,1, 25.00000,1,1,-1,-1),
ncol=5, byrow=TRUE)
b.temp = c(0.3197169,  1.9740922, -0.1191797, -0.2518067,  0.1970956,  0.3981632, -7.6648090)
X.mat = matrix(,nrow=8, ncol=7)
w.vec = rep(NA,8)
for(i in 1:8) {
htemp=Xw_maineffects_self(x=x.temp[i,], b=b.temp, link=link.temp, h.func=hfunc.temp);
X.mat[i,]=htemp$X;
w.vec[i]=htemp$w;
};
liftoneDoptimal_log_GLM_func(X=X.mat, w=w.vec, reltol=1e-5, maxit=500,
random=TRUE, nram=3, p00=NULL)
</code></pre>

<hr>
<h2 id='liftoneDoptimal_MLM_func'>function of liftone for multinomial logit model</h2><span id='topic+liftoneDoptimal_MLM_func'></span>

<h3>Description</h3>

<p>function of liftone for multinomial logit model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liftoneDoptimal_MLM_func(
  m,
  p,
  Xi,
  J,
  thetavec,
  link = "continuation",
  reltol = 1e-05,
  maxit = 500,
  p00 = NULL,
  random = FALSE,
  nram = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="liftoneDoptimal_MLM_func_+3A_m">m</code></td>
<td>
<p>number of design points</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_MLM_func_+3A_p">p</code></td>
<td>
<p>number of parameters in the multinomial logit model</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_MLM_func_+3A_xi">Xi</code></td>
<td>
<p>model matrix</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_MLM_func_+3A_j">J</code></td>
<td>
<p>number of response levels in the multinomial logit model</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_MLM_func_+3A_thetavec">thetavec</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_MLM_func_+3A_link">link</code></td>
<td>
<p>multinomial logit model link function name &quot;baseline&quot;, &quot;cumulative&quot;, &quot;adjacent&quot;, or&quot;continuation&quot;, default to be &quot;continuation&quot;</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_MLM_func_+3A_reltol">reltol</code></td>
<td>
<p>relative tolerance for convergence, default to 1e-5</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_MLM_func_+3A_maxit">maxit</code></td>
<td>
<p>the number of maximum iteration, default to 500</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_MLM_func_+3A_p00">p00</code></td>
<td>
<p>specified initial approximate allocation, default to NULL, if NULL, will generate a random initial approximate allocation</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_MLM_func_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run with additional &quot;nram&quot; number of initial allocation p00, default to be TRUE</p>
</td></tr>
<tr><td><code id="liftoneDoptimal_MLM_func_+3A_nram">nram</code></td>
<td>
<p>when random == TRUE, the function will generate nram number of initial points, default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p reported D-optimal approximate allocation
</p>
<p>p0 the initial approximate allocation that derived the reported D-optimal design
</p>
<p>Maximum the maximum of the determinant of the Fisher information matrix
</p>
<p>Convergence TRUE or FALSE, whether the algorithm converges
</p>
<p>itmax, maximum iterations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m=5
p=10
J=5
factor_x = matrix(c(-1,-25,199.96,-150,-100,16,1,23.14,196.35,0,-100,
16,1,-24.99,199.99,-150,0,16,-1,25,-200,0,0,16,-1,-25,-200,-150,0,16),ncol=6,byrow=TRUE)
Xi=rep(0,J*p*m); dim(Xi)=c(J,p,m)
hfunc.temp = function(y){
if(length(y) != 6){stop("Input should have length 6");}
 model.mat = matrix(NA, nrow=5, ncol=10, byrow=TRUE)
 model.mat[5,]=0
 model.mat[1:4,1:4] = diag(4)
 model.mat[1:4, 5] =((-1)*y[6])
 model.mat[1:4, 6:10] = matrix(((-1)*y[1:5]), nrow=4, ncol=5, byrow=TRUE)
 return(model.mat)
 }
for(i in 1:m) {
Xi[,,i]=hfunc.temp(factor_x[i,])
}
thetavec=c(-1.77994301, -0.05287782,  1.86852211, 2.76330779, -0.94437464, 0.18504420,
-0.01638597, -0.03543202, -0.07060306, 0.10347917)
liftoneDoptimal_MLM_func(m=m,p=p,Xi=Xi,J=J,thetavec=thetavec,
link="cumulative",p00=rep(1/5,5), random=FALSE)
</code></pre>

<hr>
<h2 id='MLM_Exact_Design'>Approximation to exact design algorithm for multinomial logit model</h2><span id='topic+MLM_Exact_Design'></span>

<h3>Description</h3>

<p>Approximation to exact design algorithm for multinomial logit model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLM_Exact_Design(
  J,
  k.continuous,
  design_x,
  design_p,
  det.design,
  p,
  ForLion,
  bvec,
  bvec_matrix,
  rel.diff,
  L,
  N,
  hfunc,
  link
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLM_Exact_Design_+3A_j">J</code></td>
<td>
<p>number of response levels in the multinomial logit model</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_k.continuous">k.continuous</code></td>
<td>
<p>number of continuous factors</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_design_x">design_x</code></td>
<td>
<p>the matrix with rows indicating design point which we got from the approximate design</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_design_p">design_p</code></td>
<td>
<p>D-optimal approximate allocation</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_det.design">det.design</code></td>
<td>
<p>the determinant of D-optimal approximate allocation</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_p">p</code></td>
<td>
<p>number of parameters</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_forlion">ForLion</code></td>
<td>
<p>TRUE or FALSE, TRUE: this approximate design was generated by ForLion algorithm,
FALSE: this approximate was generated by EW ForLion algorithm</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_bvec">bvec</code></td>
<td>
<p>If ForLion==TRUE assumed parameter values of model parameters beta, same length of h(y)</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_bvec_matrix">bvec_matrix</code></td>
<td>
<p>If ForLion==FALSE the matrix of the bootstrap parameter values of beta</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_rel.diff">rel.diff</code></td>
<td>
<p>points with distance less than that will be merged</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_l">L</code></td>
<td>
<p>rounding factor</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_n">N</code></td>
<td>
<p>total number of observations</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_hfunc">hfunc</code></td>
<td>
<p>function for obtaining model matrix h(y) for given design point y, y has to follow the same order as n.factor</p>
</td></tr>
<tr><td><code id="MLM_Exact_Design_+3A_link">link</code></td>
<td>
<p>link function, default &quot;continuation&quot;, other choices &quot;baseline&quot;, &quot;cumulative&quot;, and &quot;adjacent&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x.design matrix with rows indicating design point
</p>
<p>ni.design EW D-optimal or D-optimal exact allocation
</p>
<p>rel.efficiency relative efficiency of the Exact and Approximate Designs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J=3
k.continuous=1
design_x&lt;-c(0.0000,103.5451,149.2355)
design_p&lt;-c(0.2027, 0.3981, 0.3992)
det.design=54016609
p=5
theta = c(-1.935, -0.02642, 0.0003174, -9.159, 0.06386)
hfunc.temp = function(y){
   matrix(data=c(1,y,y*y,0,0,0,0,0,1,y,0,0,0,0,0), nrow=3,
            ncol=5, byrow=TRUE)
}
link.temp = "continuation"
MLM_Exact_Design(J=J, k.continuous=k.continuous,design_x=design_x,
design_p=design_p,det.design=det.design,p=p,ForLion=TRUE,bvec=theta,
rel.diff=1,L=0.5,N=1000,hfunc=hfunc.temp,link=link.temp)
</code></pre>

<hr>
<h2 id='nu_cauchit_self'>function to calculate w = nu(eta) given eta for cauchit link</h2><span id='topic+nu_cauchit_self'></span>

<h3>Description</h3>

<p>function to calculate w = nu(eta) given eta for cauchit link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu_cauchit_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu_cauchit_self_+3A_x">x</code></td>
<td>
<p>a list of eta - X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>diagonal element of W matrix which is nu(eta)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu_cauchit_self(eta)


</code></pre>

<hr>
<h2 id='nu_identity_self'>Function to calculate w = nu(eta) given eta for identity link</h2><span id='topic+nu_identity_self'></span>

<h3>Description</h3>

<p>Function to calculate w = nu(eta) given eta for identity link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu_identity_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu_identity_self_+3A_x">x</code></td>
<td>
<p>Numeric vector of eta, eta = X*beta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the diagonal elements of the W matrix (nu(eta)).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu_identity_self(eta)

</code></pre>

<hr>
<h2 id='nu_log_self'>Function to calculate w = nu(eta) given eta for log link</h2><span id='topic+nu_log_self'></span>

<h3>Description</h3>

<p>Function to calculate w = nu(eta) given eta for log link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu_log_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu_log_self_+3A_x">x</code></td>
<td>
<p>Numeric vector of eta, eta = X*beta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the diagonal elements of the W matrix (nu(eta)).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu_log_self(eta)

</code></pre>

<hr>
<h2 id='nu_logit_self'>function to calculate w = nu(eta) given eta for logit link</h2><span id='topic+nu_logit_self'></span>

<h3>Description</h3>

<p>function to calculate w = nu(eta) given eta for logit link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu_logit_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu_logit_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>diagonal element of W matrix which is nu(eta)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu_logit_self(eta)


</code></pre>

<hr>
<h2 id='nu_loglog_self'>function to calculate w = nu(eta) given eta for loglog link</h2><span id='topic+nu_loglog_self'></span>

<h3>Description</h3>

<p>function to calculate w = nu(eta) given eta for loglog link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu_loglog_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu_loglog_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>diagonal element of W matrix which is nu(eta)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu_loglog_self(eta)


</code></pre>

<hr>
<h2 id='nu_probit_self'>function to calculate w = nu(eta) given eta for probit link</h2><span id='topic+nu_probit_self'></span>

<h3>Description</h3>

<p>function to calculate w = nu(eta) given eta for probit link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu_probit_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu_probit_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>diagonal element of W matrix which is nu(eta)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu_probit_self(eta)


</code></pre>

<hr>
<h2 id='nu1_cauchit_self'>Function to calculate first derivative of nu function given eta for cauchit link</h2><span id='topic+nu1_cauchit_self'></span>

<h3>Description</h3>

<p>Function to calculate first derivative of nu function given eta for cauchit link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu1_cauchit_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu1_cauchit_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the first derivative of nu function given eta for cauchit link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu1_cauchit_self(eta)

</code></pre>

<hr>
<h2 id='nu1_identity_self'>function to calculate first derivative of nu function given eta for identity link</h2><span id='topic+nu1_identity_self'></span>

<h3>Description</h3>

<p>function to calculate first derivative of nu function given eta for identity link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu1_identity_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu1_identity_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the first derivative of nu function given eta for identity link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu1_identity_self(eta)

</code></pre>

<hr>
<h2 id='nu1_log_self'>function to calculate first derivative of nu function given eta for log link</h2><span id='topic+nu1_log_self'></span>

<h3>Description</h3>

<p>function to calculate first derivative of nu function given eta for log link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu1_log_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu1_log_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the first derivative of nu function given eta for log link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu1_log_self(eta)

</code></pre>

<hr>
<h2 id='nu1_logit_self'>function to calculate the first derivative of nu function given eta for logit link</h2><span id='topic+nu1_logit_self'></span>

<h3>Description</h3>

<p>function to calculate the first derivative of nu function given eta for logit link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu1_logit_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu1_logit_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the first derivative of nu function given eta for logit link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu1_logit_self(eta)


</code></pre>

<hr>
<h2 id='nu1_loglog_self'>function to calculate the first derivative of nu function given eta for log-log link</h2><span id='topic+nu1_loglog_self'></span>

<h3>Description</h3>

<p>function to calculate the first derivative of nu function given eta for log-log link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu1_loglog_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu1_loglog_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the first derivative of nu function given eta for log-log link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu1_loglog_self(eta)

</code></pre>

<hr>
<h2 id='nu1_probit_self'>function to calculate the first derivative of nu function given eta for probit link</h2><span id='topic+nu1_probit_self'></span>

<h3>Description</h3>

<p>function to calculate the first derivative of nu function given eta for probit link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu1_probit_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu1_probit_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the first derivative of nu function for probit link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu1_probit_self(eta)

</code></pre>

<hr>
<h2 id='nu2_cauchit_self'>function to calculate the second derivative of nu function given eta for cauchit link</h2><span id='topic+nu2_cauchit_self'></span>

<h3>Description</h3>

<p>function to calculate the second derivative of nu function given eta for cauchit link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu2_cauchit_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu2_cauchit_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the second derivative of nu function for cauchit link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu2_cauchit_self(eta)


</code></pre>

<hr>
<h2 id='nu2_identity_self'>function to calculate the second derivative of nu function given eta for identity link</h2><span id='topic+nu2_identity_self'></span>

<h3>Description</h3>

<p>function to calculate the second derivative of nu function given eta for identity link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu2_identity_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu2_identity_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the second derivative of nu function for identity link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu2_identity_self(eta)

</code></pre>

<hr>
<h2 id='nu2_log_self'>function to calculate the second derivative of nu function given eta for log link</h2><span id='topic+nu2_log_self'></span>

<h3>Description</h3>

<p>function to calculate the second derivative of nu function given eta for log link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu2_log_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu2_log_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the second derivative of nu function for log link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu2_log_self(eta)

</code></pre>

<hr>
<h2 id='nu2_logit_self'>function to calculate the second derivative of nu function given eta for logit link</h2><span id='topic+nu2_logit_self'></span>

<h3>Description</h3>

<p>function to calculate the second derivative of nu function given eta for logit link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu2_logit_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu2_logit_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the second derivative of nu function for logit link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu2_logit_self(eta)

</code></pre>

<hr>
<h2 id='nu2_loglog_self'>function to calculate the second derivative of nu function given eta for loglog link</h2><span id='topic+nu2_loglog_self'></span>

<h3>Description</h3>

<p>function to calculate the second derivative of nu function given eta for loglog link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu2_loglog_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu2_loglog_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the second derivative of nu function for loglog link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu2_loglog_self(eta)

</code></pre>

<hr>
<h2 id='nu2_probit_self'>function to calculate the second derivative of nu function given eta for probit link</h2><span id='topic+nu2_probit_self'></span>

<h3>Description</h3>

<p>function to calculate the second derivative of nu function given eta for probit link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu2_probit_self(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nu2_probit_self_+3A_x">x</code></td>
<td>
<p>vector of eta, eta=X*beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the second derivative of nu function for probit link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta = c(1,2,3,4)
nu2_probit_self(eta)

</code></pre>

<hr>
<h2 id='print.design_output'>Print Method for Design Output from ForLion Algorithm</h2><span id='topic+print.design_output'></span>

<h3>Description</h3>

<p>Custom print method for a list containing design information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'design_output'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.design_output_+3A_x">x</code></td>
<td>
<p>An object of class 'design_output'.</p>
</td></tr>
<tr><td><code id="print.design_output_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns 'x'.
</p>

<hr>
<h2 id='print.list_output'>Print Method for list_output Objects</h2><span id='topic+print.list_output'></span>

<h3>Description</h3>

<p>Custom print method for objects of class 'list_output'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list_output'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.list_output_+3A_x">x</code></td>
<td>
<p>An object of class 'list_output'.</p>
</td></tr>
<tr><td><code id="print.list_output_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns 'x' (the input object).
</p>

<hr>
<h2 id='svd_inverse'>SVD Inverse Of A Square Matrix
This function returns the inverse of a matrix using singular value decomposition.
If the matrix is a square matrix, this should be equivalent to using the solve function.
If the matrix is not a square matrix, then the result is the Moore-Penrose pseudo inverse.</h2><span id='topic+svd_inverse'></span>

<h3>Description</h3>

<p>SVD Inverse Of A Square Matrix
This function returns the inverse of a matrix using singular value decomposition.
If the matrix is a square matrix, this should be equivalent to using the solve function.
If the matrix is not a square matrix, then the result is the Moore-Penrose pseudo inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svd_inverse(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svd_inverse_+3A_x">x</code></td>
<td>
<p>the matrix for calculation of inverse</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the inverse of the matrix x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = diag(4)
svd_inverse(x)

</code></pre>

<hr>
<h2 id='xmat_discrete_self'>Generate GLM random initial designs within ForLion algorithm</h2><span id='topic+xmat_discrete_self'></span>

<h3>Description</h3>

<p>Generate GLM random initial designs within ForLion algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmat_discrete_self(xlist, rowmax = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xmat_discrete_self_+3A_xlist">xlist</code></td>
<td>
<p>a list of factor levels within ForLion algorithm, for example, a binary factor might be c(-1,1), a continuous factor within range of (25,45) will be c(25, 45).</p>
</td></tr>
<tr><td><code id="xmat_discrete_self_+3A_rowmax">rowmax</code></td>
<td>
<p>maximum number of rows of the design matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>design matrix of all possible combinations of discrete factors levels with min and max of the continuous factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define list of factor levels for one continuous factor, four binary factors
factor.level.temp = list(c(25,45),c(-1,1),c(-1,1),c(-1,1),c(-1,1))
xmat_discrete_self(xlist = factor.level.temp)


</code></pre>

<hr>
<h2 id='Xw_maineffects_self'>function for calculating X=h(x) and w=nu(beta^T h(x)) given a design point x = (x1,...,xd)^T</h2><span id='topic+Xw_maineffects_self'></span>

<h3>Description</h3>

<p>function for calculating X=h(x) and w=nu(beta^T h(x)) given a design point x = (x1,...,xd)^T
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xw_maineffects_self(x, b, link = "logit", h.func = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Xw_maineffects_self_+3A_x">x</code></td>
<td>
<p>x=(x1,...,xd) &ndash; design point/experimental setting</p>
</td></tr>
<tr><td><code id="Xw_maineffects_self_+3A_b">b</code></td>
<td>
<p>b=(b1,...,bp) &ndash; assumed parameter values</p>
</td></tr>
<tr><td><code id="Xw_maineffects_self_+3A_link">link</code></td>
<td>
<p>link = &quot;logit&quot;  &ndash; link function, default: &quot;logit&quot;, other links: &quot;probit&quot;, &quot;cloglog&quot;, &quot;loglog&quot;, &quot;cauchit&quot;, &quot;log&quot;</p>
</td></tr>
<tr><td><code id="Xw_maineffects_self_+3A_h.func">h.func</code></td>
<td>
<p>function h(x)=(h1(x),...,hp(x)), default (1,x1,...,xd)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X=h(x)=(h1(x),...,hp(x)) &ndash; a row for design matrix
</p>
<p>w &ndash; nu(b^t h(x))
</p>
<p>link &ndash; link function applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'># y -&gt; h(y)=(y1,y2,y3,y4,y5,y4*y5,1) in hfunc
hfunc.temp = function(y) {c(y,y[4]*y[5],1);};
link.temp="logit"
x.temp = c(25,1,1,1,1)
b.temp = c(-7.533386, 1.746778, -0.1937022, -0.09704664, 0.1077859, 0.2729715, 0.4293171)
Xw_maineffects_self(x.temp, b.temp, link=link.temp, h.func=hfunc.temp)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
