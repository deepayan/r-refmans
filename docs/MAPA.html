<!DOCTYPE html><html lang="en"><head><title>Help for package MAPA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MAPA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#admissions'><p>Total Non-elective G&amp;A Admissions (FFCEs)</p></a></li>
<li><a href='#mapa'><p>Multiple Aggregation Prediction Algorithm (Wrapper)</p></a></li>
<li><a href='#mapacalc'><p>MAPA Internal Calculation of Forecasts</p></a></li>
<li><a href='#mapaest'><p>MAPA Estimation</p></a></li>
<li><a href='#mapafor'><p>MAPA Forecast</p></a></li>
<li><a href='#mapasimple'><p>MAPA Single Origin Forecast (Wrapper)</p></a></li>
<li><a href='#plot.mapa.fit'><p>Produce estimated MAPA fit plot</p></a></li>
<li><a href='#tsaggr'><p>Non-overlapping temporal aggregation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Aggregation Prediction Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and wrappers for using the Multiple Aggregation Prediction Algorithm (MAPA) for time series forecasting. MAPA models and forecasts time series at multiple temporal aggregation levels, thus strengthening and attenuating the various time series components for better holistic estimation of its structure. For details see Kourentzes et al. (2014) &lt;<a href="https://doi.org/10.1016%2Fj.ijforecast.2013.09.006">doi:10.1016/j.ijforecast.2013.09.006</a>&gt;.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>forecast (&ge; 5.3), parallel, RColorBrewer, smooth (&ge; 4.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kourentzes.com/forecasting/2014/04/19/multiple-aggregation-prediction-algorithm-mapa/">https://kourentzes.com/forecasting/2014/04/19/multiple-aggregation-prediction-algorithm-mapa/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/trnnick/mapa/issues">https://github.com/trnnick/mapa/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 10:48:55 UTC; nikol</td>
</tr>
<tr>
<td>Author:</td>
<td>Nikolaos Kourentzes [aut, cre],
  Fotios Petropoulos [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nikolaos Kourentzes &lt;nikolaos@kourentzes.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 16:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='admissions'>Total Non-elective G&amp;A Admissions (FFCEs)</h2><span id='topic+admissions'></span>

<h3>Description</h3>

<p>UK NHS Total Non-elective G&amp;A Admissions (FFCEs). April 2008 &ndash; June 2013.</p>


<h3>Usage</h3>

<pre><code class='language-R'>admissions</code></pre>


<h3>Format</h3>

<p>Time series data</p>


<h3>Source</h3>

<p>UK Department of Health: Monthly Activity Return</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsdisplay(admissions)
</code></pre>

<hr>
<h2 id='mapa'>Multiple Aggregation Prediction Algorithm (Wrapper)</h2><span id='topic+mapa'></span>

<h3>Description</h3>

<p>Wrapper to estimate and produce MAPA in- and out-of-sample forecasts. 
Uses mapaest and mapafor.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapa(y, ppy, fh=ppy, ifh=1, minimumAL=1, maximumAL=ppy, 
     comb=c("w.mean","w.median","mean","median","wght"), paral=c(0,1,2), 
     display=c(0,1), outplot=c(0,1), hybrid=c(TRUE,FALSE), model="ZZZ", 
     type=c("ets","es"), conf.lvl=NULL, xreg=NULL, pr.comp=0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapa_+3A_y">y</code></td>
<td>

<p>In sample observations of a time series (vector). If y == &quot;paper&quot; then it prints paper reference.
</p>
</td></tr>
<tr><td><code id="mapa_+3A_ppy">ppy</code></td>
<td>

<p>Periods in a season of the time series at the sampled frequency.
If insample is a ts object then this is taken from its frequency, unless overriden.
</p>
</td></tr>
<tr><td><code id="mapa_+3A_fh">fh</code></td>
<td>

<p>Forecast horizon. Default = ppy.
</p>
</td></tr>
<tr><td><code id="mapa_+3A_ifh">ifh</code></td>
<td>

<p>Lower aggregation level to use. Default = 1.
</p>
</td></tr>
<tr><td><code id="mapa_+3A_minimumal">minimumAL</code></td>
<td>

<p>Lowest aggregation level to use. Default = 1.
</p>
</td></tr>
<tr><td><code id="mapa_+3A_maximumal">maximumAL</code></td>
<td>

<p>Highest aggregation level to use. Default = ppy, maximumAL&gt;1.
</p>
</td></tr>
<tr><td><code id="mapa_+3A_comb">comb</code></td>
<td>

<p>Combination operator. This can be: &quot;mean&quot;; &quot;median&quot;; &quot;wght&quot; - where each aggregation level is weighted inversly to aggregation; &quot;w.mean&quot; - level and trend components are averaged, but seasonal and xreg follow the wght combination; &quot;w.median&quot; - as w.mean, but with median. It is suggested that for data with high sampling frequency to use one of the &quot;w.mean&quot; and &quot;w.median&quot;.
</p>
</td></tr>
<tr><td><code id="mapa_+3A_paral">paral</code></td>
<td>

<p>Use parallel processing. 0 = no; 1 = yes (requires initialised cluster); 2 = yes and initialise cluster. Default is 0.
</p>
</td></tr>
<tr><td><code id="mapa_+3A_display">display</code></td>
<td>

<p>Display calculation progress in console. 0 = no; 1 = yes. Default is 0.
</p>
</td></tr>
<tr><td><code id="mapa_+3A_outplot">outplot</code></td>
<td>

<p>Provide output plot. 0 = no; 1 = yes. Default is 1.
</p>
</td></tr>
<tr><td><code id="mapa_+3A_hybrid">hybrid</code></td>
<td>

<p>Provide hybrid forecasts, as in Kourentzes et al. paper. If minimumAL &gt; 1 then the minimumAL ETS forecasts are used. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="mapa_+3A_model">model</code></td>
<td>

<p>Allow only that type of ETS at each aggregation level. This follows similar coding to the ets function. The first letter refers to the error type (&quot;A&quot;, &quot;M&quot; or &quot;Z&quot;); the second letter refers to the trend type (&quot;N&quot;,&quot;A&quot;,&quot;Ad&quot;,&quot;M&quot;,&quot;Md&quot;, &quot;Z&quot;, &quot;X&quot; or &quot;Y&quot;); and the third letter refers to the season type (&quot;N&quot;,&quot;A&quot;,&quot;M&quot;, &quot;Z&quot;, &quot;X&quot; or &quot;Y&quot;). The letters mean: &quot;N&quot;=none, &quot;A&quot;=additive, &quot;M&quot;=multiplicative, &quot;Z&quot;=automatically selected, &quot;X&quot;=automatically select between none and additive and &quot;Y&quot;=automatically select between none and multiplicative. A &quot;d&quot; for trend implies damped. &quot;X&quot; and &quot;Y&quot; supported only by type==&quot;es&quot;. If used with type==&quot;ets&quot; a warning will be given and they will default to &quot;Z&quot;. By default model=&quot;ZZZ&quot;. If due to sample limitation ETS cannot be calculated at an aggregation level for the selected model, then no estimation is done for that specific level. 
</p>
</td></tr>
<tr><td><code id="mapa_+3A_type">type</code></td>
<td>

<p>What type of exponential smoothing implementation to use. &quot;es&quot; = use from the smooth package; &quot;ets&quot; = use from the forecast package. Default is &quot;es&quot;
</p>
</td></tr>
<tr><td><code id="mapa_+3A_conf.lvl">conf.lvl</code></td>
<td>

<p>Vector of confidence level for prediction intervals. Values must be (0,1). If conf.lvl == NULL then no intervals are calculated. For example to get the intervals for 80% and 95% use conf.lvl=c(0.8,0.95).
</p>
</td></tr>
<tr><td><code id="mapa_+3A_xreg">xreg</code></td>
<td>

<p>Vector or matrix of exogenous variables to be included in the MAPA. If matrix then rows are observations and columns are variables. Must be at least as long as in-sample. Additional observations are unused. Note that including xreg will force type=&quot;es&quot;. 
</p>
</td></tr>
<tr><td><code id="mapa_+3A_pr.comp">pr.comp</code></td>
<td>

<p>MAPAx can use principal component analysis to preprocess xreg. When comp is -1 then the number of retained components is chosen automatically. When comp=0 then no pre-processing is performed and the original xreg is used. Any other value represents the number of principal components retained. 
</p>
</td></tr>
<tr><td><code id="mapa_+3A_...">...</code></td>
<td>

<p>Pass additional arguments to es or ets.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <em>mapaest</em> and <em>mapafor</em> internally.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>infor</code></td>
<td>
<p>In-sample forecasts.</p>
</td></tr>
<tr><td><code>outfor</code></td>
<td>
<p>Out-of-sample forecasts.</p>
</td></tr>
<tr><td><code>PI</code></td>
<td>
<p>Prediction intervals for given confidence levels.</p>
</td></tr>
<tr><td><code>MSE</code></td>
<td>
<p>In-sample MSE error.</p>
</td></tr>
<tr><td><code>MAE</code></td>
<td>
<p>In-sample MAE error.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The calculation of the prediction intervals is based on the empirical multiple step ahead MSE. To speed up calculations set <code>conf.lvl=NULL</code>. If very long forecast horizons are requested then once no more t+h MSE can be calculated the following approximation is used: <code class="reqn">\sqrt{MSE_{t+1}}*\sqrt{h}</code> for the error.</p>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>; Fotios Petropoulos.
</p>


<h3>References</h3>


<ul>
<li><p>Kourentzes N., Petropoulos F., Trapero J.R. (2014) Improving forecasting by estimating time 
series structural components across multiple frequencies. <em>International Journal of Forecasting</em>, <b>30</b>(<b>2</b>), 291&ndash;302.
</p>
</li>
<li><p>Kourentzes N., Petropoulos F. (2015) Forecasting with multivariate temporal aggregation: The case of promotional modelling. <em>International Journal of Production Economics</em>.
</p>
</li>
<li><p>You can find more information about MAPA at Nikos' <a href="https://kourentzes.com/forecasting/tag/mapa/">blog</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mapaest">mapaest</a></code>, <code><a href="#topic+mapafor">mapafor</a></code>, <code><a href="#topic+mapasimple">mapasimple</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- mapa(admissions)
</code></pre>

<hr>
<h2 id='mapacalc'>MAPA Internal Calculation of Forecasts</h2><span id='topic+mapacalc'></span>

<h3>Description</h3>

<p>The following function produces a simple MAPA forecast from a given origin. 
This is meant to be an internal function. Use mapafor instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapacalc(y, mapafit, fh = 0, comb = c("w.mean","w.median","mean","median","wght"), 
         outplot = c(0,1,2), hybrid = c(TRUE,FALSE), xreg=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapacalc_+3A_y">y</code></td>
<td>

<p>In sample observations of a time series (vector).
</p>
</td></tr>
<tr><td><code id="mapacalc_+3A_mapafit">mapafit</code></td>
<td>

<p>Fitted MAPA model (from mapaest).
</p>
</td></tr>
<tr><td><code id="mapacalc_+3A_fh">fh</code></td>
<td>

<p>Forecast horizon. Default = ppy.
</p>
</td></tr>
<tr><td><code id="mapacalc_+3A_comb">comb</code></td>
<td>

<p>Combination operator. This can be: &quot;mean&quot;; &quot;median&quot;; &quot;wght&quot; - where each aggregation level is weighted inversly to aggregation; &quot;w.mean&quot; - level and trend components are averaged, but seasonal and xreg follow the wght combination; &quot;w.median&quot; - as w.mean, but with median. It is suggested that for data with high sampling frequency to use one of the &quot;w.mean&quot; and &quot;w.median&quot;.
</p>
</td></tr>
<tr><td><code id="mapacalc_+3A_outplot">outplot</code></td>
<td>

<p>Provide output plot. 0 = no; 1 = time series and forecast only; 2 = time series, forecasts and components. For the components the spectral colouring scheme is used. Dark red is aggregation level 1. Default is 1. 
</p>
</td></tr>
<tr><td><code id="mapacalc_+3A_hybrid">hybrid</code></td>
<td>

<p>Provide hybrid forecasts, as in Kourentzes et al. paper. If minimumAL &gt; 1 then the minimumAL ETS forecasts are used. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="mapacalc_+3A_xreg">xreg</code></td>
<td>

<p>Vector or matrix of exogenous variables to be included in the MAPA. If matrix then rows are observations and columns are variables. Must be at least as long as in-sample plus fh. Additional observations are unused. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>forecasts</code></td>
<td>
<p>Vector with forecasts.</p>
</td></tr>
<tr><td><code>components</code></td>
<td>
<p>Array with MAPA components.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>; Fotios Petropoulos.
</p>


<h3>References</h3>


<ul>
<li><p>Kourentzes N., Petropoulos F., Trapero J.R. (2014) Improving forecasting by estimating time 
series structural components across multiple frequencies. <em>International Journal of Forecasting</em>, <b>30</b>(<b>2</b>), 291&ndash;302.
</p>
</li>
<li><p>Kourentzes N., Petropoulos F. (2015) Forecasting with multivariate temporal aggregation: The case of promotional modelling. <em>International Journal of Production Economics</em>.
</p>
</li>
<li><p>You can find more information about MAPA at Nikos' <a href="https://kourentzes.com/forecasting/tag/mapa/">blog</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mapafor">mapafor</a></code>, <code><a href="#topic+mapa">mapa</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mapafit &lt;- mapaest(admissions,outplot=0)
mapacalc(admissions,mapafit,outplot=2)
</code></pre>

<hr>
<h2 id='mapaest'>MAPA Estimation</h2><span id='topic+mapaest'></span>

<h3>Description</h3>

<p>The following function estimates MAPA and saves all fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapaest(y, ppy, minimumAL = 1, maximumAL = ppy, paral = c(0,1,2), 
	      display = c(0,1), outplot = c(0,1), model = "ZZZ", type=c("ets","es"), 
	      xreg = NULL, pr.comp = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapaest_+3A_y">y</code></td>
<td>

<p>In sample observations of a time series (vector).
</p>
</td></tr>
<tr><td><code id="mapaest_+3A_ppy">ppy</code></td>
<td>

<p>Periods in a season of the time series at the sampled frequency.
If insample is a ts object then this is taken from its frequency, unless overriden.
</p>
</td></tr>
<tr><td><code id="mapaest_+3A_minimumal">minimumAL</code></td>
<td>

<p>Lowest aggregation level to use. Default = 1, maximumAL&gt;1.
</p>
</td></tr>
<tr><td><code id="mapaest_+3A_maximumal">maximumAL</code></td>
<td>

<p>Highest aggregation level to use. Default = ppy.
</p>
</td></tr>
<tr><td><code id="mapaest_+3A_paral">paral</code></td>
<td>

<p>Use parallel processing. 0 = no; 1 = yes (requires initialised cluster); 2 = yes 
and initialise cluster. Default is 0.
</p>
</td></tr>
<tr><td><code id="mapaest_+3A_display">display</code></td>
<td>

<p>Display calculation progress in console. 0 = no; 1 = yes. Default is 0.
</p>
</td></tr>
<tr><td><code id="mapaest_+3A_outplot">outplot</code></td>
<td>

<p>Provide output plot. 0 = no; 1 = yes. Default is 0.
</p>
</td></tr>
<tr><td><code id="mapaest_+3A_model">model</code></td>
<td>

<p>Allow only that type of ETS at each aggregation level. This follows similar coding to the ets function. The first letter refers to the error type (&quot;A&quot;, &quot;M&quot; or &quot;Z&quot;); the second letter refers to the trend type (&quot;N&quot;,&quot;A&quot;,&quot;Ad&quot;,&quot;M&quot;,&quot;Md&quot;, &quot;Z&quot;, &quot;X&quot; or &quot;Y&quot;); and the third letter refers to the season type (&quot;N&quot;,&quot;A&quot;,&quot;M&quot;, &quot;Z&quot;, &quot;X&quot; or &quot;Y&quot;). The letters mean: &quot;N&quot;=none, &quot;A&quot;=additive, &quot;M&quot;=multiplicative, &quot;Z&quot;=automatically selected, &quot;X&quot;=automatically select between none and additive and &quot;Y&quot;=automatically select between none and multiplicative. A &quot;d&quot; for trend implies damped. &quot;X&quot; and &quot;Y&quot; supported only by type==&quot;es&quot;. If used with type==&quot;ets&quot; a warning will be given and they will default to &quot;Z&quot;. By default model=&quot;ZZZ&quot;. If due to sample limitation ETS cannot be calculated at an aggregation level for the selected model, then no estimation is done for that specific level. For aggregation levels that seasonality becomes 1 then a non-seasonal model is estimated.
</p>
</td></tr>
<tr><td><code id="mapaest_+3A_type">type</code></td>
<td>

<p>What type of exponential smoothing implementation to use. &quot;es&quot; = use from the smooth package; &quot;ets&quot; = use from the forecast package. Default is &quot;es&quot;
</p>
</td></tr>
<tr><td><code id="mapaest_+3A_xreg">xreg</code></td>
<td>

<p>Vector or matrix of exogenous variables to be included in the MAPA. If matrix then rows are observations and columns are variables. Must be at least as long as in-sample. Additional observations are unused. Note that including xreg will force type=&quot;es&quot;. 
</p>
</td></tr>  
<tr><td><code id="mapaest_+3A_pr.comp">pr.comp</code></td>
<td>

<p>MAPAx can use principal component analysis to preprocess xreg. When comp is -1 then the number of retained components is chosen automatically. When comp=0 then no pre-processing is performed and the original xreg is used. Any other value represents the number of principal components retained. 
</p>
</td></tr>
<tr><td><code id="mapaest_+3A_...">...</code></td>
<td>

<p>Pass additional arguments to es or ets.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mapafit</code></td>
<td>
<p>Estimated MAPA model structure.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>; Fotios Petropoulos.
</p>


<h3>References</h3>


<ul>
<li><p>Kourentzes N., Petropoulos F., Trapero J.R. (2014) Improving forecasting by estimating time 
series structural components across multiple frequencies. <em>International Journal of Forecasting</em>, <b>30</b>(<b>2</b>), 291&ndash;302.
</p>
</li>
<li><p>Kourentzes N., Petropoulos F. (2015) Forecasting with multivariate temporal aggregation: The case of promotional modelling. <em>International Journal of Production Economics</em>.
</p>
</li>
<li><p>You can find more information about MAPA at Nikos' <a href="https://kourentzes.com/forecasting/tag/mapa/">blog</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mapa">mapa</a></code>, <code><a href="#topic+mapafor">mapafor</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mapafit &lt;- mapaest(admissions)
</code></pre>

<hr>
<h2 id='mapafor'>MAPA Forecast</h2><span id='topic+mapafor'></span>

<h3>Description</h3>

<p>The following function produces in- and out-of-sample MAPA forecasts, for multiple steps ahead.
This is the recommended function to use in forecasting with MAPA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapafor(y, mapafit, fh = -1, ifh = 1, 
        comb = c("w.mean","w.median","mean","median","wght"), 
        outplot = c(0,1), hybrid = c(TRUE, FALSE), 
        conf.lvl = NULL, xreg=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapafor_+3A_y">y</code></td>
<td>

<p>In sample observations of a time series (vector).
</p>
</td></tr>
<tr><td><code id="mapafor_+3A_mapafit">mapafit</code></td>
<td>

<p>Fitted MAPA model (from mapaest).
</p>
</td></tr>
<tr><td><code id="mapafor_+3A_fh">fh</code></td>
<td>

<p>Forecast horizon. Default = ppy.
</p>
</td></tr>
<tr><td><code id="mapafor_+3A_ifh">ifh</code></td>
<td>

<p>In-sample forecast horizon. Default = 0.
</p>
</td></tr>
<tr><td><code id="mapafor_+3A_comb">comb</code></td>
<td>

<p>Combination operator. This can be: &quot;mean&quot;; &quot;median&quot;; &quot;wght&quot; - where each aggregation level is weighted inversly to aggregation; &quot;w.mean&quot; - level and trend components are averaged, but seasonal and xreg follow the wght combination; &quot;w.median&quot; - as w.mean, but with median. It is suggested that for data with high sampling frequency to use one of the &quot;w.mean&quot; and &quot;w.median&quot;.
</p>
</td></tr>
<tr><td><code id="mapafor_+3A_outplot">outplot</code></td>
<td>

<p>Provide output plot. 0 = no; 1 = yes. Default is 1. 
</p>
</td></tr>
<tr><td><code id="mapafor_+3A_hybrid">hybrid</code></td>
<td>

<p>Provide hybrid forecasts, as in Kourentzes et al. paper. If minimumAL &gt; 1 then the minimumAL ETS forecasts are used. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="mapafor_+3A_conf.lvl">conf.lvl</code></td>
<td>

<p>Vector of confidence level for prediction intervals. Values must be (0,1). If conf.lvl == NULL then no intervals are calculated. For example to get the intervals for 80% and 95% use conf.lvl=c(0.8,0.95).
</p>
</td></tr>
<tr><td><code id="mapafor_+3A_xreg">xreg</code></td>
<td>

<p>Vector or matrix of exogenous variables to be included in the MAPA. If matrix then rows are observations and columns are variables. Must be at least as long as in-sample plus fh. Additional observations are unused. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>infor</code></td>
<td>
<p>In-sample forecasts.</p>
</td></tr>
<tr><td><code>outfor</code></td>
<td>
<p>Out-of-sample forecasts.</p>
</td></tr>
<tr><td><code>PI</code></td>
<td>
<p>Prediction intervals for given confidence levels.</p>
</td></tr>
<tr><td><code>MSE</code></td>
<td>
<p>In-sample MSE error.</p>
</td></tr>
<tr><td><code>MAE</code></td>
<td>
<p>In-sample MAE error.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The calculation of the prediction intervals is based on the empirical multiple step ahead MSE. To speed up calculations set <code>conf.lvl=NULL</code>. If very long forecast horizons are requested then once no more t+h MSE can be calculated the following approximation is used: <code class="reqn">\sqrt{MSE_{t+1}}*\sqrt{h}</code> for the error.</p>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>; Fotios Petropoulos.
</p>


<h3>References</h3>


<ul>
<li><p>Kourentzes N., Petropoulos F., Trapero J.R. (2014) Improving forecasting by estimating time 
series structural components across multiple frequencies. <em>International Journal of Forecasting</em>, <b>30</b>(<b>2</b>), 291&ndash;302.
</p>
</li>
<li><p>Kourentzes N., Petropoulos F. (2015) Forecasting with multivariate temporal aggregation: The case of promotional modelling. <em>International Journal of Production Economics</em>.
</p>
</li>
<li><p>You can find more information about MAPA at Nikos' <a href="https://kourentzes.com/forecasting/tag/mapa/">blog</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mapa">mapa</a></code>, <code><a href="#topic+mapaest">mapaest</a></code>, <code><a href="#topic+mapacalc">mapacalc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mapafit &lt;- mapaest(admissions,outplot=0)
out &lt;- mapafor(admissions,mapafit)
</code></pre>

<hr>
<h2 id='mapasimple'>MAPA Single Origin Forecast (Wrapper)</h2><span id='topic+mapasimple'></span>

<h3>Description</h3>

<p>The following function estimates MAPA and produces out-of-sample forecasts. 
It is not suggested, unless only simple single origin forecasts are required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapasimple(y, ppy=NULL, fh=ppy, minimumAL=1, maximumAL=ppy, 
           comb=c("w.mean","w.median","mean","median","wght"), 
           paral=c(0,1,2), display=c(0,1), 
           outplot=c(0,1), hybrid=c(TRUE,FALSE), model="ZZZ", 
           type=c("ets","es"), xreg=NULL, pr.comp=0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapasimple_+3A_y">y</code></td>
<td>

<p>In sample observations of a time series (vector). If y == &quot;paper&quot; then 
it prints paper reference.
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_ppy">ppy</code></td>
<td>

<p>Periods in a season of the time series at the sampled frequency.
If insample is a ts object then this is taken from its frequency, unless overriden.
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_fh">fh</code></td>
<td>

<p>Forecast horizon. Default = ppy.
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_minimumal">minimumAL</code></td>
<td>

<p>Lowest aggregation level to use. Default = 1, maximumAL&gt;1.
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_maximumal">maximumAL</code></td>
<td>

<p>Highest aggregation level to use. Default = ppy.
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_comb">comb</code></td>
<td>

<p>Combination operator. This can be: &quot;mean&quot;; &quot;median&quot;; &quot;wght&quot; - where each aggregation level is weighted inversly to aggregation; &quot;w.mean&quot; - level and trend components are averaged, but seasonal and xreg follow the wght combination; &quot;w.median&quot; - as w.mean, but with median. It is suggested that for data with high sampling frequency to use one of the &quot;w.mean&quot; and &quot;w.median&quot;.
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_paral">paral</code></td>
<td>

<p>Use parallel processing. 0 = no; 1 = yes (requires initialised cluster); 2 = yes 
and initialise cluster. Default is 0.
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_display">display</code></td>
<td>

<p>Display calculation progress in console. 0 = no; 1 = yes. Default is 0.
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_outplot">outplot</code></td>
<td>

<p>Provide output plot. 0 = no; 1 = time series and forecast only; 2 = time series, forecasts and components. For the components the spectral colouring scheme is used. Dark red is aggregation level 1. Default is 1. 
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_hybrid">hybrid</code></td>
<td>

<p>Provide hybrid forecasts, as in Kourentzes et al. paper. If minimumAL &gt; 1 then the minimumAL ETS forecasts are used. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_model">model</code></td>
<td>

<p>Allow only that type of ETS at each aggregation level. This follows similar coding to the ets function. The first letter refers to the error type (&quot;A&quot;, &quot;M&quot; or &quot;Z&quot;); the second letter refers to the trend type (&quot;N&quot;,&quot;A&quot;,&quot;Ad&quot;,&quot;M&quot;,&quot;Md&quot;, &quot;Z&quot;, &quot;X&quot; or &quot;Y&quot;); and the third letter refers to the season type (&quot;N&quot;,&quot;A&quot;,&quot;M&quot;, &quot;Z&quot;, &quot;X&quot; or &quot;Y&quot;). The letters mean: &quot;N&quot;=none, &quot;A&quot;=additive, &quot;M&quot;=multiplicative, &quot;Z&quot;=automatically selected, &quot;X&quot;=automatically select between none and additive and &quot;Y&quot;=automatically select between none and multiplicative. A &quot;d&quot; for trend implies damped. &quot;X&quot; and &quot;Y&quot; supported only by type==&quot;es&quot;. If used with type==&quot;ets&quot; a warning will be given and they will default to &quot;Z&quot;. By default model=&quot;ZZZ&quot;. If due to sample limitation ETS cannot be calculated at an aggregation level for the selected model, then no estimation is done for that specific level. For aggregation levels that seasonality becomes 1 then a non-seasonal model is estimated.
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_type">type</code></td>
<td>

<p>What type of exponential smoothing implementation to use. &quot;es&quot; = use from the smooth package; &quot;ets&quot; = use from the forecast package. Default is &quot;es&quot;
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_xreg">xreg</code></td>
<td>

<p>Vector or matrix of exogenous variables to be included in the MAPA. If matrix then rows are observations and columns are variables. Must be at least as long as in-sample. Additional observations are unused. Note that including xreg will force type=&quot;es&quot;. 
</p>
</td></tr>  
<tr><td><code id="mapasimple_+3A_pr.comp">pr.comp</code></td>
<td>

<p>MAPAx can use principal component analysis to preprocess xreg. When comp is -1 then the number of retained components is chosen automatically. When comp=0 then no pre-processing is performed and the original xreg is used. Any other value represents the number of principal components retained. 
</p>
</td></tr>
<tr><td><code id="mapasimple_+3A_...">...</code></td>
<td>

<p>Pass additional arguments to es or ets.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <em>mapaest</em> and <em>mapacalc</em> internally.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>forecasts</code></td>
<td>
<p>Vector with forecasts.</p>
</td></tr>
<tr><td><code>components</code></td>
<td>
<p>Array with MAPA components, if output=&quot;all&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>; Fotios Petropoulos.
</p>


<h3>References</h3>


<ul>
<li><p>Kourentzes N., Petropoulos F., Trapero J.R. (2014) Improving forecasting by estimating time 
series structural components across multiple frequencies. <em>International Journal of Forecasting</em>, <b>30</b>(<b>2</b>), 291&ndash;302.
</p>
</li>
<li><p>Kourentzes N., Petropoulos F. (2015) Forecasting with multivariate temporal aggregation: The case of promotional modelling. <em>International Journal of Production Economics</em>.
</p>
</li>
<li><p>You can find more information about MAPA at Nikos' <a href="https://kourentzes.com/forecasting/tag/mapa/">blog</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mapa">mapa</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mapasimple(admissions)
</code></pre>

<hr>
<h2 id='plot.mapa.fit'>Produce estimated MAPA fit plot</h2><span id='topic+plot.mapa.fit'></span>

<h3>Description</h3>

<p>The following function plots the fitted components at each aggregation
level of an estimated MAPA. The plot is the same as the one that can be produced optionally by mapaest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mapa.fit'
plot(x, xreg.plot=c(TRUE,FALSE),...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mapa.fit_+3A_x">x</code></td>
<td>

<p>Fitted MAPA model (from mapaest).
</p>
</td></tr>
<tr><td><code id="plot.mapa.fit_+3A_xreg.plot">xreg.plot</code></td>
<td>

<p>Add infromation about xreg in the figure. 
</p>
</td></tr>
<tr><td><code id="plot.mapa.fit_+3A_...">...</code></td>
<td>

<p>Additional arguments.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>References</h3>


<ul>
<li><p>Kourentzes N., Petropoulos F., Trapero J.R. (2014) Improving forecasting by estimating time 
series structural components across multiple frequencies. <em>International Journal of Forecasting</em>, <b>30</b>(<b>2</b>), 291&ndash;302.
</p>
</li>
<li><p>Kourentzes N., Petropoulos F. (2015) Forecasting with multivariate temporal aggregation: The case of promotional modelling. <em>International Journal of Production Economics</em>.
</p>
</li>
<li><p>You can find more information about MAPA at Nikos' <a href="https://kourentzes.com/forecasting/tag/mapa/">blog</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mapaest">mapaest</a></code>, <code><a href="#topic+mapa">mapa</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mapafit &lt;- mapaest(admissions,outplot=0)
plot(mapafit)
</code></pre>

<hr>
<h2 id='tsaggr'>Non-overlapping temporal aggregation</h2><span id='topic+tsaggr'></span>

<h3>Description</h3>

<p>Non-overlapping temporal aggregation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsaggr(y,fout,fmean=c(FALSE,TRUE),outplot=c(FALSE,TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsaggr_+3A_y">y</code></td>
<td>

<p>Time series vector (can be ts object).
</p>
</td></tr>
<tr><td><code id="tsaggr_+3A_fout">fout</code></td>
<td>

<p>Vector containing desirable aggregation levels. Must be positive and integer. If larger than length(y) then it is ignored.
</p>
</td></tr>
<tr><td><code id="tsaggr_+3A_fmean">fmean</code></td>
<td>

<p>If TRUE the aggregated is done using mean, otherwise sum is used.
</p>
</td></tr>
<tr><td><code id="tsaggr_+3A_outplot">outplot</code></td>
<td>

<p>If TRUE a plot of the original series and the aggregated ones is produced.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>out</code></td>
<td>

<p>List of temporally aggregated series. If y was a ts object, then 'out' has ts objects with appropriate frequencies. Any non-integer frequency is set equal to 1. Series are named ALx, where x is the aggregation level. 
</p>
</td></tr>
<tr><td><code>all</code></td>
<td>

<p>An array containing all aggregated series in the original frequency. Series are named ALx, where x is the aggregation level.
</p>
</td></tr>
<tr><td><code>idx</code></td>
<td>

<p>List of indices used to produce 'out' from 'all': y.out[[i]] &lt;- y.all[y.idx[[i]],i]. Series are named ALx, where x is the aggregation level.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- tsaggr(admissions,fout=2:12,fmean=TRUE,outplot=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
