<!DOCTYPE html><html><head><title>Help for package icrf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {icrf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#getTree.icrf'><p>Extract a single tree from an icrf object</p></a></li>
<li><a href='#icrf'><p>Interval Censored Recursive Forests (ICRF)</p></a></li>
<li><a href='#importance.icrf'><p>'Extract variable importance measure'</p></a></li>
<li><a href='#measure'><p>Prediction error measures</p></a></li>
<li><a href='#plot'><p>icrf IMSE rate plot</p></a></li>
<li><a href='#predict.icrf'><p>icrf predictions</p></a></li>
<li><a href='#rat2'><p>Rat tumor data</p></a></li>
<li><a href='#survplot'><p>'Plotting individual survival curves'</p></a></li>
<li><a href='#treesize.icrf'><p>Size of trees in an <code>icrf</code> ensemble</p></a></li>
<li><a href='#varImpPlot.icrf'><p>'Variable Importance Plot'</p></a></li>
<li><a href='#varUsed.icrf'><p>'Variables used in' an <code>icrf</code> ensemble</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interval Censored Recursive Forests</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-29</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survival, ggplot2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements interval censored recursive forests (ICRF) based on Cho, Jewell, and Kosorok (2021+). 
            ICRF is a variant of random forests where the outcome variable is interval censored survival data.
            It can be used for usual right censored data and current status data as well.
            A recursion technique is used to improve accuracy and smoothed survival curves are provided.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hunyong Cho &lt;hunyong.cho@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-29 13:37:00 UTC; hunyongcho</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-29 22:00:18 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Hunyong Cho [aut, cre],
  Nicholas P Jewell [aut],
  Michael R Kosorok [aut],
  Leo Breiman [ctb] (Author of incldued randomForest C code),
  Adele Cutler [ctb] (Author of included randomForest Fortran code),
  Andy Liaw [ctb] (Author of included randomForest R code),
  Matthew Wiener [ctb] (Author of included randomForest R code),
  Alain Vandal Robert Gentleman [ctb] (Author of included Icens R code),
  Merck &amp; Co. Inc. [cph] (Copyright holder of included randomForest R
    code),
  Alain Vandal Robert Gentleman [cph] (Copyright holder of included Icens
    R code),
  The R Foundation [cph] (Copyright holder of included ksmooth C code)</td>
</tr>
</table>
<hr>
<h2 id='getTree.icrf'>Extract a single tree from an icrf object</h2><span id='topic+getTree.icrf'></span><span id='topic+getTree'></span>

<h3>Description</h3>

<p><code>getTree</code> 'extracts the structure of a tree from an <code>icrf</code> object.'
Among <code>nfold</code> forests, the forest designated when implementing <code>icrf</code> will be
considered. i.e., the <code>k</code>th tree of the last forest, when <code>returnBest = FALSE</code> or
the tree of the best forest, when <code>returnBest = TRUE</code>, will be extracted.
(Quoted statements are from <code>randomForest</code> by Liaw and Wiener unless otherwise mentioned.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTree(x, ...)

## S3 method for class 'icrf'
getTree(x, k = 1, labelVar = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTree.icrf_+3A_x">x</code></td>
<td>
<p>an <code>icrf</code> object.</p>
</td></tr>
<tr><td><code id="getTree.icrf_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="getTree.icrf_+3A_k">k</code></td>
<td>
<p>'which tree to extract?'</p>
</td></tr>
<tr><td><code id="getTree.icrf_+3A_labelvar">labelVar</code></td>
<td>
<p>Splitting variables will be labelled with the original names
when <code>labelVar = TRUE</code>. Otherwise they will be expressed as integers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'For numerical predictors, data with values of the variable less than or equal
to the splitting point go to the left daughter node.'
</p>
<p>'For categorical predictors, the splitting point is represented by an integer,
whose binary expansion gives the identities of the categories that goes to left or right.
For example, if a predictor has four categories, and the split point is 13.
The binary expansion of 13 is (1, 0, 1, 1) (because 13 = 1*2^0 + 0*2^1 + 1*2^2 + 1*2^3),
so cases with categories 1, 3, or 4 in this predictor get sent to the left,
and the rest to the right.'
</p>


<h3>Value</h3>

<p>'A matrix (or data frame, if labelVar=TRUE) with' (5 + number of time points) 'columns and
number of rows equal to total number of nodes in the tree. The columns are:'
</p>

<ul>
<li><p>left daughter: 'the row where the left daughter node is; 0 if the node is terminal'
</p>
</li>
<li><p>right daughter: 'the row where the right daughter node is; 0 if the node is terminal'
</p>
</li>
<li><p>split var: 'which variable was used to split the node; 0 if the node is terminal'
</p>
</li>
<li><p>split point: 'where the best split is; see Details for categorical predictor'
</p>
</li>
<li><p>status: 'is the node terminal' (-1) or not (-3)
</p>
</li>
<li><p>from the 6th to the last columns: the survival probability prediction for the node;
each column represents the distinct time points.
'0 if the node is not terminal'
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(survival) # for Surv()
data(rat2)
L = ifelse(rat2$tumor, 0, rat2$survtime)
R = ifelse(rat2$tumor, rat2$survtime, Inf)
# Note that this is a toy example. Use a larger ntree and nfold in practice.

set.seed(1)
rats.icrf &lt;-
  icrf(Surv(L, R, type = "interval2") ~ dose.lvl + weight + male + cage.no,
       data = rat2, ntree = 10, nfold = 3)
getTree(rats.icrf, k = 2)




</code></pre>

<hr>
<h2 id='icrf'>Interval Censored Recursive Forests (ICRF)</h2><span id='topic+icrf'></span><span id='topic+icrf.default'></span><span id='topic+icrf.formula'></span><span id='topic+print.icrf'></span>

<h3>Description</h3>

<p><code>icrf</code> implements the ICRF algorithm to estimate the
conditional survival probability for interval censored survival data.
(It can also be used for right-censored survival data and current status data.)
<code>icrf</code> recursively builds random forests using the extremely randomized
trees (ERT) algorithm and uses kernel smoothing in the time domain.
This <code>icrf</code> package is built based on the <code>randomForest</code> package
by Andy Liaw and Matthew Wiener. (Quoted statements are from
<code>randomForest</code> by Liaw and Wiener unless otherwise mentioned.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icrf(x, ...)

## Default S3 method:
icrf(
  x,
  L,
  R,
  tau = max(R[is.finite(R)]) * 1.5,
  bandwidth = NULL,
  quasihonesty = TRUE,
  initialSmoothing = TRUE,
  timeSmooth = NULL,
  xtest = NULL,
  ytest = NULL,
  nfold = 5L,
  ntree = 500L,
  mtry = ceiling(sqrt(p)),
  split.rule = c("Wilcoxon", "logrank", "PetoWilcoxon", "PetoLogrank", "GWRS", "GLR",
    "SWRS", "SLR"),
  ERT = FALSE,
  uniformERT = ERT,
  returnBest = sampsize &lt; n,
  imse.monitor = 1,
  replace = !ERT,
  sampsize = ifelse(ERT, 0.95, 0.632) * n,
  nodesize = 6L,
  maxnodes = NULL,
  importance = FALSE,
  nPerm = 1,
  proximity,
  oob.prox = ifelse(sampsize == n &amp; !replace, FALSE, proximity),
  do.trace = FALSE,
  keep.forest = is.null(xtest),
  keep.inbag = FALSE,
  ...
)

## S3 method for class 'formula'
icrf(
  formula,
  data = NULL,
  data.type = c("interval", "right", "currentstatus"),
  interval.label = c("L", "R"),
  right.label = c("T", "status"),
  currentstatus.label = c("monitor", "status"),
  ...,
  na.action = na.fail,
  epsilon = NULL
)

## S3 method for class 'icrf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icrf_+3A_x">x</code></td>
<td>
<p>a data frame or a matrix of predictors. <code>x</code> is not needed when <code>formula</code> is specified.</p>
</td></tr>
<tr><td><code id="icrf_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to icrf.default.</p>
</td></tr>
<tr><td><code id="icrf_+3A_l">L</code>, <code id="icrf_+3A_r">R</code></td>
<td>
<p>the left and right end point of the interval. <code>R</code> should be greater
than or equal to <code>L</code>. In case of equality, a small number <code>epsilon</code> (the smaller of
minimum nonzero interval length and 1e-10) is added.</p>
</td></tr>
<tr><td><code id="icrf_+3A_tau">tau</code></td>
<td>
<p>the study end time. ([0, <code>tau</code>] is the window for the analysis.)</p>
</td></tr>
<tr><td><code id="icrf_+3A_bandwidth">bandwidth</code></td>
<td>
<p>a positive number. The bandwidth of the kernel smoothing. For faster computing,
set <code>bandwidth = 0</code> for no smoothing.</p>
</td></tr>
<tr><td><code id="icrf_+3A_quasihonesty">quasihonesty</code></td>
<td>
<p>if <code>TRUE</code>, the terminal node prediction is given by the NPMLE of the
interval data. If <code>FALSE</code>, the terminal node prediction is given by the average of the
conditional probabilities (exploitative).</p>
</td></tr>
<tr><td><code id="icrf_+3A_initialsmoothing">initialSmoothing</code></td>
<td>
<p>if <code>TRUE</code>, the initial survival curve used for
interval-conditional survival probability estimate is smoothed using the Gaussian kernel.</p>
</td></tr>
<tr><td><code id="icrf_+3A_timesmooth">timeSmooth</code></td>
<td>
<p>a numeric vector of time points at which the smoothed
survival curves are estimated. It should be in an increasing order.
If <code>null</code>, a set of distinct interval end points is used.</p>
</td></tr>
<tr><td><code id="icrf_+3A_xtest">xtest</code></td>
<td>
<p>a dataset or matrix of predictors for the test dataset.</p>
</td></tr>
<tr><td><code id="icrf_+3A_ytest">ytest</code></td>
<td>
<p>a true survival curve for the test set in a form of the dataframe or matrix.
The number of rows is the same as <code>xtest</code> and each column corresponds to the
time points of <code>timeSmooth</code>.</p>
</td></tr>
<tr><td><code id="icrf_+3A_nfold">nfold</code></td>
<td>
<p>Number of forests to iterate. In practice, numbers between 5 and 10 is reasonable.</p>
</td></tr>
<tr><td><code id="icrf_+3A_ntree">ntree</code></td>
<td>
<p>Number of trees to build within each forest. 'This should not be set to too small a number, to ensure that every input
row gets predicted at least a few times.'</p>
</td></tr>
<tr><td><code id="icrf_+3A_mtry">mtry</code></td>
<td>
<p>Number of candidate predictors tried at each split.
The default value is sqrt(p) where p is number of variables in <code>x</code>.</p>
</td></tr>
<tr><td><code id="icrf_+3A_split.rule">split.rule</code></td>
<td>
<p>Splitting rules. See details. The default is
<code>"Wilcoxon", or equivalently "GWRS"</code>.</p>
</td></tr>
<tr><td><code id="icrf_+3A_ert">ERT</code></td>
<td>
<p>If <code>ERT=TRUE</code> ERT algorithm applies. If <code>FALSE</code>,
a comprehensive greedy algorithm (Breiman's random forest algorithm) applies.</p>
</td></tr>
<tr><td><code id="icrf_+3A_uniformert">uniformERT</code></td>
<td>
<p>Only relevant when <code>ERT=TRUE</code>. If <code>uniformERT=TRUE</code>,
random candidate cutpoints are selected using uniform distribution. If
<code>FALSE</code>, random candidate cutpoints are chosen among the midpoints of two
neighboring predictor values.</p>
</td></tr>
<tr><td><code id="icrf_+3A_returnbest">returnBest</code></td>
<td>
<p>If <code>returnBest=TRUE</code>, the survival curve estimate at the
best iteration is returned. If <code>FALSE</code>, the estimate at the last iteration
is returned. The best iteration is determined by the type of IMSE measures specified
in <code>imse.monitor</code>. By default, <code>returnBest=TRUE</code> when the out-of-bag
sample is available (sampsize &lt; n).</p>
</td></tr>
<tr><td><code id="icrf_+3A_imse.monitor">imse.monitor</code></td>
<td>
<p>Which type of IMSE is used to monitor which fold is the best?</p>
</td></tr>
<tr><td><code id="icrf_+3A_replace">replace</code></td>
<td>
<p>Whether the cases are sampled with or without replacement?</p>
</td></tr>
<tr><td><code id="icrf_+3A_sampsize">sampsize</code></td>
<td>
<p>Size of random sampling.</p>
</td></tr>
<tr><td><code id="icrf_+3A_nodesize">nodesize</code></td>
<td>
<p>Each terminal node cannot be smaller than this value. 'Setting this number
larger causes smaller trees to be grown (and thus take less time).'</p>
</td></tr>
<tr><td><code id="icrf_+3A_maxnodes">maxnodes</code></td>
<td>
<p>Up to how many terminal nodes can a tree have?
'If not given, trees are grown to the maximum possible
(subject to limits by nodesize). If set larger than maximum possible,
a warning is issued.'</p>
</td></tr>
<tr><td><code id="icrf_+3A_importance">importance</code></td>
<td>
<p>If <code>TRUE</code>, variable importance measure will be computed.</p>
</td></tr>
<tr><td><code id="icrf_+3A_nperm">nPerm</code></td>
<td>
<p>How many permutations (of OOB data) to do for variable importance assessment?
'Number larger than 1 gives slightly more
stable estimate, but not very effective. Currently only implemented for regression.'</p>
</td></tr>
<tr><td><code id="icrf_+3A_proximity">proximity</code></td>
<td>
<p>If <code>TRUE</code>, proximity measure among the cases is calculated.</p>
</td></tr>
<tr><td><code id="icrf_+3A_oob.prox">oob.prox</code></td>
<td>
<p>If <code>TRUE</code>, proximity is calculated only on &quot;out-of-bag&quot; data.</p>
</td></tr>
<tr><td><code id="icrf_+3A_do.trace">do.trace</code></td>
<td>
<p>If <code>TRUE</code>, intermediate outputs are printed during the tree building
procedure. 'If set to some integer, then running output is printed for every do.trace trees.'</p>
</td></tr>
<tr><td><code id="icrf_+3A_keep.forest">keep.forest</code></td>
<td>
<p>'If set to FALSE, the forest will not be retained in the output
object. If xtest is given, defaults to FALSE.'</p>
</td></tr>
<tr><td><code id="icrf_+3A_keep.inbag">keep.inbag</code></td>
<td>
<p>'Should an n by ntree matrix be returned that keeps track of
which samples are &quot;in-bag&quot; in which trees (but not how many times, if sampling
with replacement)'</p>
</td></tr>
<tr><td><code id="icrf_+3A_formula">formula</code>, <code id="icrf_+3A_data.type">data.type</code>, <code id="icrf_+3A_interval.label">interval.label</code>, <code id="icrf_+3A_right.label">right.label</code>, <code id="icrf_+3A_currentstatus.label">currentstatus.label</code></td>
<td>
<p>a formula object, with the
response in a Surv 'interval2' or <code>cbind</code>.
Alternatively, the survival outcome may be omitted in the formula and the labels relevent
to the survival outcome can be entered in either <code>interval.label</code>, <code>right.label</code>,
or <code>currentstatus.label</code> with the <code>data.type</code> being specified.</p>
</td></tr>
<tr><td><code id="icrf_+3A_data">data</code></td>
<td>
<p>a data frame that includes the intervals and the predictor values.</p>
</td></tr>
<tr><td><code id="icrf_+3A_na.action">na.action</code></td>
<td>
<p>'a function to specify the action to be taken if NAs are
found. (NOTE: If given, this argument must be named.)'</p>
</td></tr>
<tr><td><code id="icrf_+3A_epsilon">epsilon</code></td>
<td>
<p>A small positive value needed to discriminate the left and right
interval end points for the uncensored data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four <code>split.rule</code> options are available: <code>Wilcoxon</code>, <code>logrank</code>,
<code>PetoWilcoxon</code>, <code>PetoLogrank</code>. The aliases are
<code>GWRS</code>, <code>GLR</code>, <code>SWRS</code>, and <code>SLR</code>, respectively.
The first two are generalized
Wilcoxon-rank-sum test and generalized log-rank test proposed in Cho et al (2020+),
and the latter two are score-based Wilcoxon-rank-sum test and score-based
log-rank test proposed by Peto and Peto (1972) &quot;Asymptotically efficient
rank invariant test procedures.&quot;
</p>


<h3>Value</h3>

<p>An <code>icrf</code> class object which contains the following components in a list:
</p>

<p>An <code>icrf</code> class object which contains the following components in a list:
</p>
<ul>
<li><p>callthe original call to <code>icrf</code>
</p>
</li>
<li><p>methodThe input values of <code>split.rule</code>, <code>ERT</code>,
</p>
<p>quasihonest, <code>bandwith</code>, and the subsample ratio
(= <code>sampsize</code> / <code>n</code>)
</p>
</li>
<li><p>predictedthe estimated survival curves of the training set using
out-of-bag samples.
</p>
</li>
<li><p>predictedNOthe estimated survival curves of the training set using
non-out-of-bag samples.
</p>
</li>
<li><p>predictedNO.Smthe smoothed survival curves of the training set using
non-out-of-bag samples.
</p>
</li>
<li><p>time.pointstime points at which the survival curves are estimated.
</p>
</li>
<li><p>time.points.smoothtime points at which the smoothed survival curves
are estimated.
</p>
</li>
<li><p>imse.oobIntegrated mean squared error (IMSE) measured based on the
out-of-bag samples
</p>
</li>
<li><p>imse.NOIntegrated mean squared error (IMSE) measured based on the
non-out-of-bag samples
</p>
</li>
<li><p>oob.timesnumber of times for which each case was 'out-of-bag'
</p>
</li>
<li><p>importancean array of three matrices where each matrix has
<code>nfold</code> columns and <code>p</code> (number of predictors) rows.
The importance is measured based on increase in IMSE types 1 and 2,
respectively, and the node impurity.
</p>
</li>
<li><p>importanceSD'The &quot;standard errors&quot; of the permutation-based
importance measure.' A <code>p</code> by <code>nfold</code> by 2
array corresponding to the first two matrices of the importance array.
</p>
</li>
<li><p>nfoldnumber of forests iterated over.
</p>
</li>
<li><p>ntreenumber of trees built.
</p>
</li>
<li><p>mtrynumber of candidate predictors tried at each node.
</p>
</li>
<li><p>forest'a list that contains the entire forest;' <code>NULL</code> 'if
<code>keep.forest=FALSE</code>.'
</p>
</li>
<li><p>intervals<code>n</code> by 2 matrix of the intervals.
</p>
</li>
<li><p>proximityif <code>proximity=TRUE</code> if <code>proximity=TRUE</code> when
<code>icrf</code> is called, a matrix of proximity measures among
the input (based on the frequency that pairs of data points are in
the same terminal nodes).
</p>
<p>inbagif <code>keep.inbag=TRUE</code> provides a matrix of in-bag indicators
for the last forest iteration.
</p>
<p>runtimestart and end times and the elapsed time.
</p>
<p>testif test set is given (through the <code>xtest</code> or additionally
<code>ytest</code> arguments), this component is a list which contains the
corresponding <code>predicted</code> and  error measures (IMSE's).
If <code>proximity=TRUE</code>, there is also a component, <code>proximity</code>,
which contains the proximity among the test set as well as proximity
between test and training data.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Hunyong Cho, Nicholas P. Jewell, and Michael R. Kosorok.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1912.09983">Cho H., Jewell N. J., and Kosorok M. R. (2020+). &quot;Interval censored
recursive forests&quot;</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.icrf">predict.icrf</a></code>, <code><a href="#topic+plot.icrf">plot.icrf</a></code>, <code><a href="#topic+survplot">survplot</a></code>, <code><a href="#topic+importance.icrf">importance.icrf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rats data example.
# The type of this dataset is current status data.
# Note that this is a toy example. Use a larger ntree and nfold in practice.
data(rat2)


 set.seed(2)
# 1. formula (currentstatus)
rats.icrf &lt;-
  icrf(~ dose.lvl + weight + male + cage.no, data = rat2,
       data.type = "currentstatus", currentstatus.label = c("survtime", "tumor"),
       returnBest = TRUE, ntree=10, nfold=3)

# 2. formula containing the interval
# Alternatively, create the interval endpoints and use the Surv object.
L = ifelse(rat2$tumor, 0, rat2$survtime)
R = ifelse(rat2$tumor, rat2$survtime, Inf)
library(survival) # for Surv function
icrf(Surv(L, R, type = "interval2") ~ dose.lvl + weight + male + cage.no, data = rat2,
     ntree=10, nfold=3)

# Or, 3. formula (interval)
rat2b &lt;- cbind(rat2, L = L, R = R)
set.seed(1)
icrf( ~ dose.lvl + weight + male + cage.no, data = rat2b,
     data.type = "interval", interval.label = c("L", "R"),
     ntree=10, nfold=3)

# 4. default method
set.seed(1)
icrf(rat2[, c("dose.lvl", "weight", "male", "cage.no")], L = L, R = R,
     ntree=10, nfold=3)
 

</code></pre>

<hr>
<h2 id='importance.icrf'>'Extract variable importance measure'</h2><span id='topic+importance.icrf'></span><span id='topic+importance'></span><span id='topic+importance.default'></span>

<h3>Description</h3>

<p>'This is the extractor function for variable importance measures as produced by' <code>icrf</code>.
(Quoted statements are from
<code>randomForest</code> by Liaw and Wiener unless otherwise mentioned.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importance(x, ...)

## Default S3 method:
importance(x, ...)

## S3 method for class 'icrf'
importance(x, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importance.icrf_+3A_x">x</code></td>
<td>
<p>'an object of class' <code>icrf</code></p>
</td></tr>
<tr><td><code id="importance.icrf_+3A_...">...</code></td>
<td>
<p>'not used'</p>
</td></tr>
<tr><td><code id="importance.icrf_+3A_type">type</code></td>
<td>
<p>either 1, 2, 3, or any combination of them, 'specifying the type of importance measure'
(1 = mean increase in IMSE1, 2 = mean increase in IMSE2, 3 = mean decrease in node impurity).
If not specified, all available types of importances are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Here are the definitions of the variable importance measures. The first two measures are
computed from permuting OOB data: For each tree, the prediction error
on the out-of-bag portion of the data is recorded' (IMSE1 and IMSE2).
'Then the same is done after permuting each predictor variable.'
'The difference between the two are then averaged over all trees'
The normalization by the standard deviation of the differences is not supported in this version.
The third measure 'is the total decrease in node impurities from splitting on the variable,
averaged over all trees.'
'For regression, it is measured by residual sum of squares.'
</p>


<h3>Value</h3>

<p>An array of importance measure matrices, one row for each predictor variable.' Each column
corresponds to the forest iteration. Each matrix corresponds to the type of the measure.
</p>


<h3>Author(s)</h3>

<p>Hunyong Cho, Nicholas P. Jewell, and Michael R. Kosorok.
</p>
<p><a href="https://arxiv.org/abs/1912.09983">Cho H., Jewell N. J., and Kosorok M. R. (2020+). &quot;Interval censored
recursive forests&quot;</a>
</p>


<h3>See Also</h3>

<p><code>icrf</code>, <code>varImpPlot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rats data example.
# Note that this is a toy example. Use a larger ntree and nfold in practice.
data(rat2)

set.seed(1)
rats.icrf &lt;-
  icrf(~ dose.lvl + weight + male + cage.no, data = rat2,
       data.type = "currentstatus", currentstatus.label = c("survtime", "tumor"),
       returnBest = TRUE, ntree=10, nfold=3)
importance(rats.icrf)



</code></pre>

<hr>
<h2 id='measure'>Prediction error measures</h2><span id='topic+measure'></span>

<h3>Description</h3>

<p>This function measures the prediction errors including
the IMSE (integrated mean squared error) of type 1 and 2, the integrated
absolute error, and the supremum absolute error.
When the true survival curve is unknown but the observed interval is available,
IMSE is used. When the true survival curve is known, the integrated and supremum
absolute errors are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure(
  surv.hat,
  timepoints,
  tau,
  method = c("all", "imse", "int.error"),
  L = NULL,
  R = NULL,
  surv.true = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measure_+3A_surv.hat">surv.hat</code></td>
<td>
<p>the estimated survival curve matrix with rows representing
the observations and the columns representing the time points at which the
survival curve is estimated.</p>
</td></tr>
<tr><td><code id="measure_+3A_timepoints">timepoints</code></td>
<td>
<p>a vector of time points at which the survival curve is estimated.</p>
</td></tr>
<tr><td><code id="measure_+3A_tau">tau</code></td>
<td>
<p>the study end time. ([0, <code>tau</code>] is the window for the analysis.)</p>
</td></tr>
<tr><td><code id="measure_+3A_method">method</code></td>
<td>
<p>Which measure will be used? Either <code>imse</code>, <code>int.error</code> (<code>int.error</code>
returns both integrated and supremum absolute errors), or <code>all</code> (both) should be entered.</p>
</td></tr>
<tr><td><code id="measure_+3A_l">L</code>, <code id="measure_+3A_r">R</code></td>
<td>
<p>the left and right interval endpoints. These are required when <code>method == "imse"</code>
or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="measure_+3A_surv.true">surv.true</code></td>
<td>
<p>the true survival curve matrix with rows representing
the observations and the columns representing the time points at which the
survival curve is evaluated. This is required when <code>method == "int.error"</code>
or <code>"all"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of the error measures, see
Cho H., Jewell N. J., and Kosorok M. R. (2020+). &quot;Interval censored
recursive forest&quot;
</p>


<h3>Value</h3>

<p>A vector of prediction errors:
</p>

<ul>
<li> <p><code>imse.type1</code> and <code>imse.type2</code>
when <code>method == "imse"</code>
</p>
</li>
<li> <p><code>int.error</code> and <code>sup.error</code>
when <code>method == "int.error"</code>
</p>
</li>
<li> <p><code>imse.type1</code>, <code>imse.type2</code>, <code>int.error</code>, and <code>sup.error</code>
when <code>method == "all"</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Hunyong Cho hunycho@live.unc.edu, based on the code and the documents of
<code>randomForest</code> by Andy Liaw and Matthew Wiener.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1912.09983">Cho H., Jewell N. J., and Kosorok M. R. (2020+). &quot;Interval censored
recursive forests&quot;</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rats data example.
# Note that this is a toy example. Use a larger ntree and nfold in practice.
library(survival)  # for Surv()
data(rat2)
L = ifelse(rat2$tumor, 0, rat2$survtime)
R = ifelse(rat2$tumor, rat2$survtime, Inf)

set.seed(1)
rats.icrf &lt;-
  icrf(Surv(L, R, type = "interval2") ~ dose.lvl + weight + male + cage.no,
       data = rat2, ntree = 10, nfold = 3)

measure(rats.icrf$predicted.Sm, timepoints = rats.icrf$time.points,
        tau = rats.icrf$tau, method = "imse", L = L, R = R)


</code></pre>

<hr>
<h2 id='plot'>icrf IMSE rate plot</h2><span id='topic+plot'></span><span id='topic+plot.icrf'></span>

<h3>Description</h3>

<p>'Plot the error rates or MSE of a randomForest object'
(Quoted statements are from
<code>randomForest</code> by Liaw and Wiener unless otherwise mentioned.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'icrf'
plot(x, type = "l", main = deparse(substitute(x)), oob = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>an object of <code>icrf</code> class.</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>'type of plot.'</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>'main title of the plot.'</p>
</td></tr>
<tr><td><code id="plot_+3A_oob">oob</code></td>
<td>
<p>Whether the out-of-bag error should be returned?</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>'other graphical parameters.'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The IMSE (integrated mean squared error) of the <code>icrf</code> object
is invisibly returned. 'If the object has a non-null test component, then the returned
object is a matrix where the first' (two) column is the IMSE measure (types 1 and 2), 'and
the second column is for the test set.'
The rows represent the forest iterations.
</p>


<h3>Note</h3>

<p>'If the <code>x</code> has a non-null <code>test</code> component, then the test set errors are
also plotted.'
</p>


<h3>Author(s)</h3>

<p>Hunyong Cho, Nicholas P. Jewell, and Michael R. Kosorok.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1912.09983">Cho H., Jewell N. J., and Kosorok M. R. (2020+). &quot;Interval censored
recursive forests&quot;</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rats data example
# Note that this is a toy example. Use a larger ntree and nfold in practice.
data(rat2)
set.seed(1)
samp &lt;- sample(1:dim(rat2)[1], 200)
rats.train &lt;- rat2[samp, ]
rats.test &lt;- rat2[-samp, ]
# Note that this is a toy example. Use a larger ntree and nfold in practice.
set.seed(2)


 rats.icrf.small &lt;-
   icrf(~ dose.lvl + weight + male + cage.no, data = rat2,
        data.type = "currentstatus", currentstatus.label = c("survtime", "tumor"),
        returnBest = TRUE, ntree=10, nfold=3)
 plot(rats.icrf.small)

</code></pre>

<hr>
<h2 id='predict.icrf'>icrf predictions</h2><span id='topic+predict.icrf'></span>

<h3>Description</h3>

<p>Prediction method of test data using interval censored recursive forest.
(Quoted statements are from
<code>randomForest</code> by Liaw and Wiener unless otherwise mentioned.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'icrf'
predict(
  object,
  newdata,
  predict.all = FALSE,
  proximity = FALSE,
  nodes = FALSE,
  smooth = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.icrf_+3A_object">object</code></td>
<td>
<p>an object of <code>icrf</code> class generated by the function <code>icrf</code>.</p>
</td></tr>
<tr><td><code id="predict.icrf_+3A_newdata">newdata</code></td>
<td>
<p>'a data frame or matrix containing new data. (Note: If not given,
the predicted survival estimate of the training data set in the <code>object</code> is returned.)'</p>
</td></tr>
<tr><td><code id="predict.icrf_+3A_predict.all">predict.all</code></td>
<td>
<p>'Should the predictions of all trees be kept?'</p>
</td></tr>
<tr><td><code id="predict.icrf_+3A_proximity">proximity</code></td>
<td>
<p>'Should proximity measures be computed?'</p>
</td></tr>
<tr><td><code id="predict.icrf_+3A_nodes">nodes</code></td>
<td>
<p>'Should the terminal node indicators (an n by ntree matrix)
be returned? If so, it is in the &quot;nodes&quot; attribute of the returned object.'</p>
</td></tr>
<tr><td><code id="predict.icrf_+3A_smooth">smooth</code></td>
<td>
<p>Should smoothed curve be returned?</p>
</td></tr>
<tr><td><code id="predict.icrf_+3A_...">...</code></td>
<td>
<p>'not used currently.'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of predicted survival probabilities is returned where the rows represent
the observations and the columns represent the time points.
'If predict.all=TRUE, then the returned object is a list of two components:
<code>aggregate</code>, which is the vector of predicted values by the forest,
and <code>individual</code>, which is a matrix where each column contains prediction
by a tree in the forest.' The forest is either the last forest or the best forest
as specified by <code>returnBest</code> argument in <code>icrf</code> function.
</p>
<p>'If <code>proximity=TRUE</code>, the returned object is a list with two components:
<code>pred</code> is the prediction (as described above) and
<code>proximity</code> is the proximitry matrix.'
</p>
<p>'If <code>nodes=TRUE</code>, the returned object has a &quot;nodes&quot; attribute,
which is an <code>n</code> by <code>ntree</code> matrix, each column containing the
node number that the cases fall in for that tree.'
</p>


<h3>Author(s)</h3>

<p>Hunyong Cho, Nicholas P. Jewell, and Michael R. Kosorok.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1912.09983">Cho H., Jewell N. J., and Kosorok M. R. (2020+). &quot;Interval censored
recursive forests&quot;</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rats data example
# Note that this is a toy example. Use a larger ntree and nfold in practice.
library(survival)  # for Surv()
data(rat2)
set.seed(1)
samp &lt;- sample(1:dim(rat2)[1], 200)
rats.train &lt;- rat2[samp, ]
rats.test &lt;- rat2[-samp, ]
L = ifelse(rats.train$tumor, 0, rats.train$survtime)
R = ifelse(rats.train$tumor, rats.train$survtime, Inf)

 set.seed(2)
 rats.icrf.small &lt;-
   icrf(survival::Surv(L, R, type = "interval2") ~ dose.lvl + weight + male + cage.no,
        data = rats.train, ntree = 10, nfold = 3, proximity = TRUE)

 # predicted survival curve for the training data
 predict(rats.icrf.small)
 predict(rats.icrf.small, smooth = FALSE) # non-smoothed

 # predicted survival curve for new data
 predict(rats.icrf.small, newdata = rats.test)
 predict(rats.icrf.small, newdata = rats.test, proximity = TRUE)

 # time can be extracted using attr()
 newpred = predict(rats.icrf.small, newdata = rats.test)
 attr(newpred, "time")

 newpred2 = predict(rats.icrf.small, newdata = rats.test, proximity = TRUE)
 attr(newpred2$predicted, "time")




</code></pre>

<hr>
<h2 id='rat2'>Rat tumor data</h2><span id='topic+rat2'></span>

<h3>Description</h3>

<p>This is the &lsquo;Rat tumor data&rsquo; data from Dinse and Lagakos (1984). 112 female and 207 male rats.
This data can be considered as a current status data where
the time (T) from birth to the onset of the tumor is the main variable of interest but
is never observed, but can only be guessed by the set of the death time (survtime) and the
tumor indicator (tumor). Quotes are from Dinse and Lagakos (1984).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rat2)
</code></pre>


<h3>Format</h3>

<p>A data frame with 319 rows and 6 variables:
</p>

<dl>
<dt>dose.lvl</dt><dd><p>'dose level of PBB (coded 0-5).'</p>
</dd>
<dt>weight</dt><dd><p>'initial weight in grams.'</p>
</dd>
<dt>cage.no</dt><dd><p>'number of the cage tier.'</p>
</dd>
<dt>survtime</dt><dd><p>'survival time (age) in weeks.'</p>
</dd>
<dt>tumor</dt><dd><p>'response indicator (1 = hyperplasia present, 0 = hyperplasia absent).'</p>
</dd>
<dt>male</dt><dd><p>The gender (0 = female, 1 = male).</p>
</dd>
</dl>



<h3>References</h3>

<p>Dinse, G. E., &amp; Lagakos, S. W. (1983). Regression analysis of tumour prevalence data.
Journal of the Royal Statistical Society: Series C (Applied Statistics), 32(3), 236-248.
</p>
<p>Dinse, G. E., &amp; Lagakos, S. W. (1984). Correction: Regression analysis of tumour prevalence data.
Journal of the Royal Statistical Society: Series C (Applied Statistics), 33(1), 79-80.
</p>

<hr>
<h2 id='survplot'>'Plotting individual survival curves'</h2><span id='topic+survplot'></span>

<h3>Description</h3>

<p>Plotting individual survival curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survplot(
  x,
  i,
  smooth = TRUE,
  timepoints = NULL,
  title = "Estimated survival curve",
  suppress.inf.time = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survplot_+3A_x">x</code></td>
<td>
<p>an object of class <code>icrf</code> or a survival matrix with rows
representing subjects and columns representing times</p>
</td></tr>
<tr><td><code id="survplot_+3A_i">i</code></td>
<td>
<p>subject index</p>
</td></tr>
<tr><td><code id="survplot_+3A_smooth">smooth</code></td>
<td>
<p>which curve of an <code>icrf</code> object to be plotted? smoothed or non-smoothed.
Ignored when <code>x</code> is a matrix.</p>
</td></tr>
<tr><td><code id="survplot_+3A_timepoints">timepoints</code></td>
<td>
<p>A numeric vector. needed when the time attribute is missing.</p>
</td></tr>
<tr><td><code id="survplot_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="survplot_+3A_suppress.inf.time">suppress.inf.time</code></td>
<td>
<p>Do not draw the curve at <code>timepoints</code> being infinity?</p>
</td></tr>
<tr><td><code id="survplot_+3A_...">...</code></td>
<td>
<p>'Other graphical parameters to be passed on to' <code>ggplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'Invisibly,' the vector of survival probabilities that are plotted.
</p>


<h3>Author(s)</h3>

<p>Hunyong Cho, Nicholas P. Jewell, and Michael R. Kosorok.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1912.09983">Cho H., Jewell N. J., and Kosorok M. R. (2020+). &quot;Interval censored
recursive forests&quot;</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rats data example.
# Note that this is a toy example. Use a larger ntree and nfold in practice.
data(rat2)

 set.seed(1)
 rats.icrf &lt;-
   icrf(~ dose.lvl + weight + male + cage.no, data = rat2,
        data.type = "currentstatus", currentstatus.label = c("survtime", "tumor"),
        returnBest = TRUE, ntree=10, nfold=3)
 survplot(rats.icrf, c(1,3,5))



</code></pre>

<hr>
<h2 id='treesize.icrf'>Size of trees in an <code>icrf</code> ensemble</h2><span id='topic+treesize.icrf'></span><span id='topic+treesize'></span>

<h3>Description</h3>

<p>'Size of trees (number of nodes)' in the returned forest of <code>icrf</code>.
The returned forest depends on the <code>returnBest</code> argument of the <code>icrf</code> function;
It is either the last forest, when <code>returnBest = FALSE</code> or
the the best forest, when <code>returnBest = TRUE</code>.
(Quoted statements are from
<code>randomForest</code> by Liaw and Wiener unless otherwise mentioned.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treesize(x, ...)

## S3 method for class 'icrf'
treesize(x, terminal = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treesize.icrf_+3A_x">x</code></td>
<td>
<p>an object of class <code>icrf</code>, 'which contains a forest component.'</p>
</td></tr>
<tr><td><code id="treesize.icrf_+3A_...">...</code></td>
<td>
<p>'not used.'</p>
</td></tr>
<tr><td><code id="treesize.icrf_+3A_terminal">terminal</code></td>
<td>
<p>'count terminal nodes only (<code>TRUE</code>) or all nodes (<code>FALSE</code>)'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'A vector containing number of nodes for the trees' in the icrf object.
</p>


<h3>Note</h3>

<p>The <code>icrf</code> 'object must contain the forest component; i.e.,
created with' <code>icrf(..., keep.forest=TRUE)</code>.
</p>


<h3>Author(s)</h3>

<p>Hunyong Cho, Nicholas P. Jewell, and Michael R. Kosorok.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1912.09983">Cho H., Jewell N. J., and Kosorok M. R. (2020+). &quot;Interval censored
recursive forests&quot;</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rats data example.
# Note that this is a toy example. Use a larger ntree and nfold in practice.
data(rat2)

 set.seed(1)
 rats.icrf &lt;-
   icrf(~ dose.lvl + weight + male + cage.no, data = rat2,
        data.type = "currentstatus", currentstatus.label = c("survtime", "tumor"),
        returnBest = TRUE, ntree=10, nfold=3)
 treesize(rats.icrf)



</code></pre>

<hr>
<h2 id='varImpPlot.icrf'>'Variable Importance Plot'</h2><span id='topic+varImpPlot.icrf'></span><span id='topic+varImpPlot'></span>

<h3>Description</h3>

<p>'Dotchart of variable importance as measured by' <code>icrf</code>.
(Quoted statements are from
<code>randomForest</code> by Liaw and Wiener unless otherwise mentioned.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varImpPlot(x, ...)

## S3 method for class 'icrf'
varImpPlot(
  x,
  sort = TRUE,
  n.var = min(30, nrow(x$importance)),
  type = NULL,
  forest = NULL,
  main = deparse(substitute(x)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varImpPlot.icrf_+3A_x">x</code></td>
<td>
<p>'an object of class' <code>icrf</code></p>
</td></tr>
<tr><td><code id="varImpPlot.icrf_+3A_...">...</code></td>
<td>
<p>'Other graphical parameters to be passed on to <code>dotchart</code>.'</p>
</td></tr>
<tr><td><code id="varImpPlot.icrf_+3A_sort">sort</code></td>
<td>
<p>'Should the variables be sorted in decreasing order of importance?'</p>
</td></tr>
<tr><td><code id="varImpPlot.icrf_+3A_n.var">n.var</code></td>
<td>
<p>'How many variables to show? (Ignored if sort=FALSE.)'</p>
</td></tr>
<tr><td><code id="varImpPlot.icrf_+3A_type">type</code></td>
<td>
<p>'arguments to be passed on to importance'</p>
</td></tr>
<tr><td><code id="varImpPlot.icrf_+3A_forest">forest</code></td>
<td>
<p>The forest for which the importance is plotted. If <code>NULL</code>,
the best forest is plotted.</p>
</td></tr>
<tr><td><code id="varImpPlot.icrf_+3A_main">main</code></td>
<td>
<p>'plot title'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'Invisibly, the importance of the variables that were plotted.'
</p>


<h3>Author(s)</h3>

<p>Hunyong Cho, Nicholas P. Jewell, and Michael R. Kosorok.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1912.09983">Cho H., Jewell N. J., and Kosorok M. R. (2020+). &quot;Interval censored
recursive forests&quot;</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rats data example.
# Note that this is a toy example. Use a larger ntree and nfold in practice.
data(rat2)

 set.seed(1)
 rats.icrf &lt;-
   icrf(~ dose.lvl + weight + male + cage.no, data = rat2,
        data.type = "currentstatus", currentstatus.label = c("survtime", "tumor"),
        returnBest = TRUE, ntree=10, nfold=3)
 varImpPlot(rats.icrf)



</code></pre>

<hr>
<h2 id='varUsed.icrf'>'Variables used in' an <code>icrf</code> ensemble</h2><span id='topic+varUsed.icrf'></span><span id='topic+varUsed'></span>

<h3>Description</h3>

<p>'Find out which predictor variables are actually used in' the returned forest of
the <code>icrf</code>. The returned forest depends on the <code>returnBest</code> argument of the
<code>icrf</code> function; It is either the last forest, when <code>returnBest = FALSE</code> or
the the best forest, when <code>returnBest = TRUE</code>. (Quoted statements are from
<code>randomForest</code> by Liaw and Wiener unless otherwise mentioned.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varUsed(x, ...)

## S3 method for class 'icrf'
varUsed(x, by.tree = FALSE, count = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varUsed.icrf_+3A_x">x</code></td>
<td>
<p>'an object of class' <code>icrf</code>.</p>
</td></tr>
<tr><td><code id="varUsed.icrf_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="varUsed.icrf_+3A_by.tree">by.tree</code></td>
<td>
<p>'Should the list of variables used be broken down by trees in the forest?'</p>
</td></tr>
<tr><td><code id="varUsed.icrf_+3A_count">count</code></td>
<td>
<p>'Should the frequencies that variables appear in trees be returned?'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'A vector containing number of nodes for the trees' in the icrf object.
</p>
<p>'If <code>count=TRUE</code> and <code>by.tree=FALSE</code>, an integer vector containing
frequencies that variables are used in the forest. If <code>by.tree=TRUE</code>, a matrix is returned,
breaking down the counts by tree (each column corresponding to one tree and each row to a variable).'
</p>
<p>'If <code>count=FALSE</code> and <code>by.tree=TRUE</code>, a list of integer indices is returned giving the
variables used in the trees, else if <code>by.tree=FALSE</code>, a vector of integer indices giving
the variables used in the entire forest.'
</p>


<h3>Author(s)</h3>

<p>Hunyong Cho, Nicholas P. Jewell, and Michael R. Kosorok.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1912.09983">Cho H., Jewell N. J., and Kosorok M. R. (2020+). &quot;Interval censored
recursive forests&quot;</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rats data example.
# Note that this is a toy example. Use a larger ntree and nfold in practice.
data(rat2)

 set.seed(1)
 rats.icrf &lt;-
   icrf(~ dose.lvl + weight + male + cage.no, data = rat2,
        data.type = "currentstatus", currentstatus.label = c("survtime", "tumor"),
        returnBest = TRUE, ntree=10, nfold=3)
 varUsed(rats.icrf)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
