<!DOCTYPE html><html><head><title>Help for package fwildclusterboot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fwildclusterboot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boot_aggregate'><p>Simple tool that aggregates the value of CATT coefficients in</p>
staggered difference-in-difference setups with inference based on
a wild cluster bootstrap (see details) - similar to <code>fixest::aggregate()</code></a></li>
<li><a href='#boot_ssc'><p>set the small sample correction factor applied in <code>boottest()</code></p></a></li>
<li><a href='#boottest'><p>Fast wild cluster bootstrap inference</p></a></li>
<li><a href='#boottest.felm'><p>Fast wild cluster bootstrap inference for object of class felm</p></a></li>
<li><a href='#boottest.fixest'><p>Fast wild cluster bootstrap inference for object of class fixest</p></a></li>
<li><a href='#boottest.ivreg'><p>Fast wild cluster bootstrap inference for object of class lm</p></a></li>
<li><a href='#boottest.lm'><p>Fast wild cluster bootstrap inference for object of class lm</p></a></li>
<li><a href='#confint.boottest'><p>S3 method to obtain wild cluster bootstrapped confidence intervals</p></a></li>
<li><a href='#find_proglang'><p>Check if julia or python are installed /</p>
can be found on the PATH.</a></li>
<li><a href='#glance.boottest'><p>S3 method to glance at objects of class boottest</p></a></li>
<li><a href='#glance.mboottest'><p>S3 method to glance at objects of class boottest</p></a></li>
<li><a href='#mboottest'><p>Arbitrary Linear Hypothesis Testing for Regression Models via Wald-Tests</p></a></li>
<li><a href='#mboottest.felm'><p>Fast wild cluster bootstrap inference for joint hypotheses for object of</p>
class felm</a></li>
<li><a href='#mboottest.fixest'><p>Fast wild cluster bootstrap inference for joint hypotheses for object</p>
of class fixest</a></li>
<li><a href='#mboottest.lm'><p>Fast wild cluster bootstrap inference of joint hypotheses for object of</p>
class lm</a></li>
<li><a href='#nobs.boottest'><p>S3 method to obtain the effective number of observation used in <code>boottest()</code></p></a></li>
<li><a href='#nobs.mboottest'><p>S3 method to obtain the effective number of observation used</p>
in <code>mboottest()</code></a></li>
<li><a href='#plot.boottest'><p>Plot the bootstrap distribution of t-statistics</p></a></li>
<li><a href='#print.boottest'><p>S3 method to print key information for objects of type <code>bboottest</code></p></a></li>
<li><a href='#print.mboottest'><p>S3 method to print key information for objects of type <code>mboottest</code></p></a></li>
<li><a href='#pval'><p><code>pval</code> is a S3 method to collect pvalues for objects</p>
of type <code>boottest</code> and <code>mboottest</code></a></li>
<li><a href='#pval.boottest'><p>S3 method to obtain the wild cluster bootstrapped p-value of an object</p>
of type boottest</a></li>
<li><a href='#pval.mboottest'><p>S3 method to obtain the wild cluster bootstrapped p-value of an object</p>
of type mboottest</a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#setBoottest_engine'><p>Sets the default bootstrap algo for the current R session</p>
to be run via <code>boottest()</code> and <code>mboottest()</code></a></li>
<li><a href='#summary.boottest'><p>S3 method to summarize objects of class boottest</p></a></li>
<li><a href='#summary.mboottest'><p>S3 method to summarize objects of class mboottest</p></a></li>
<li><a href='#teststat'><p><code>teststat</code> is a S3 method to collect teststats for objects</p>
of type <code>boottest</code> and <code>mboottest</code></a></li>
<li><a href='#teststat.boottest'><p>S3 method to obtain the non-bootstrapped t-statistic calculated</p>
via <code>boottest()</code></a></li>
<li><a href='#teststat.mboottest'><p>S3 method to obtain the non-bootstrapped test statistic calculated</p>
via <code>mboottest()</code></a></li>
<li><a href='#tidy.boottest'><p>S3 method to summarize objects of class boottest into tidy data.frame</p></a></li>
<li><a href='#tidy.mboottest'><p>S3 method to summarize objects of class mboottest into tidy data.frame</p></a></li>
<li><a href='#voters'><p>Random example data set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fast Wild Cluster Bootstrap Inference for Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.13.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of fast algorithms for wild cluster bootstrap 
             inference developed in 'Roodman et al' (2019, 'STATA' Journal,
             &lt;<a href="https://doi.org/10.1177%2F1536867X19830877">doi:10.1177/1536867X19830877</a>&gt;) and 'MacKinnon et al' (2022), 
             which makes it feasible to quickly calculate bootstrap test 
             statistics based on a large number of bootstrap draws even for 
             large samples. Multiple bootstrap types as described in 'MacKinnon, 
             Nielsen &amp; Webb' (2022) are supported. 
             Further, 'multiway' clustering, regression weights, 
             bootstrap weights, fixed effects and 'subcluster' bootstrapping
             are supported. Further, both restricted ('WCR') and unrestricted
             ('WCU') bootstrap are supported. Methods are provided for a variety 
             of fitted models, including 'lm()', 'feols()' 
             (from package 'fixest') and 'felm()' (from package 'lfe'). 
             Additionally implements a 'heteroskedasticity-robust' ('HC1') wild 
             bootstrap.
             Last, the package provides an R binding to 'WildBootTests.jl',
             which provides additional speed gains and functionality, 
             including the 'WRE' bootstrap for instrumental variable models 
             (based on models of type 'ivreg()' from package 'ivreg')
             and hypotheses with q &gt; 1.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://s3alfisc.github.io/fwildclusterboot/">https://s3alfisc.github.io/fwildclusterboot/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/s3alfisc/fwildclusterboot/issues/">https://github.com/s3alfisc/fwildclusterboot/issues/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>collapse, dreamerr, Formula, generics, dqrng, gtools, Matrix,
JuliaConnectoR, MASS, Rcpp, summclust, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fixest, lfe, ivreg, clubSandwich, lmtest, data.table,
fabricatr, covr, knitr, rmarkdown, broom, modelsummary, bench,
testthat (&ge; 3.0.0), tibble, sandwich</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp,RcppArmadillo, RcppEigen</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Version Requirements to run the wild bootstrap
through Julia - Julia (&gt;= 1.8), WildBootTests.jl (&gt;=0.9). Julia
is downloadable via the official Julia website
(https://julialang.org/downloads/), WildBootTests.jl via
Julia's package manager
(https://docs.julialang.org/en/v1/stdlib/Pkg/) or its github
repository (https://github.com/droodman/WildBootTests.jl)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-25 15:11:24 UTC; alexa</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Fischer [aut, cre],
  David Roodman [aut],
  Achim Zeileis [ctb] (Author of included sandwich fragments),
  Nathaniel Graham [ctb] (Contributor to included sandwich fragments),
  Susanne Koell [ctb] (Contributor to included sandwich fragments),
  Laurent Berge [ctb] (Author of included fixest fragments),
  Sebastian Krantz [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Fischer &lt;alexander-fischer1801@t-online.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-26 01:00:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='boot_aggregate'>Simple tool that aggregates the value of CATT coefficients in
staggered difference-in-difference setups with inference based on
a wild cluster bootstrap (see details) - similar to <code>fixest::aggregate()</code></h2><span id='topic+boot_aggregate'></span>

<h3>Description</h3>

<p>This is a function helping to replicate the estimator from Sun and
Abraham (2021, Journal of Econometrics). You first need to perform
an estimation with cohort and relative periods dummies
(typically using the function i), this leads to estimators of the
cohort average treatment effect on the treated (CATT). Then you can
use this function to retrieve the average treatment effect on each
relative period,or for any other way you wish to aggregate the CATT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_aggregate(
  x,
  agg,
  full = FALSE,
  use_weights = TRUE,
  clustid = NULL,
  B,
  bootcluster = "max",
  fe = NULL,
  sign_level = 0.05,
  beta0 = NULL,
  type = "rademacher",
  impose_null = TRUE,
  bootstrap_type = "fnw11",
  p_val_type = "two-tailed",
  nthreads = getBoottest_nthreads(),
  tol = 1e-06,
  maxiter = 10,
  ssc = boot_ssc(adj = TRUE, fixef.K = "none", cluster.adj = TRUE, cluster.df =
    "conventional"),
  engine = getBoottest_engine(),
  floattype = "Float64",
  maxmatsize = FALSE,
  bootstrapc = FALSE,
  getauxweights = FALSE,
  sampling = "dqrng",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_aggregate_+3A_x">x</code></td>
<td>
<p>An object of type fixest estimated using <code>sunab()</code></p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_agg">agg</code></td>
<td>
<p>A character scalar describing the variable names to be
aggregated, it is pattern-based. All variables that match the pattern
will be aggregated. It must be of the form <code>"(root)"</code>, the parentheses
must be there and the resulting variable name will be <code>"root"</code>. You
can add another root with parentheses: <code>"(root1)regex(root2)"</code>, in
which case the resulting name is <code>"root1::root2"</code>. To name the resulting
variable differently you can pass a named vector: <code>c("name" = "pattern")</code>
or <code>c("name" = "pattern(root2)")</code>. It's a bit intricate sorry, please
see the examples.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_full">full</code></td>
<td>
<p>Logical scalar, defaults to <code>FALSE</code>. If <code>TRUE</code>, then all
coefficients are returned, not only the aggregated coefficients.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_use_weights">use_weights</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If the estimation was
weighted, whether the aggregation should take into account the weights.
Basically if the weights reflected frequency it should be <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_clustid">clustid</code></td>
<td>
<p>A character vector or rhs formula containing the names of the
cluster variables. If NULL,
a heteroskedasticity-robust (HC1) wild bootstrap is run.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_b">B</code></td>
<td>
<p>Integer. The number of bootstrap iterations. When the number of
clusters is low,
increasing B adds little additional runtime.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_bootcluster">bootcluster</code></td>
<td>
<p>A character vector or rhs formula of length 1. Specifies
the bootstrap clustering variable or variables. If more
than one variable is specified, then bootstrapping is clustered by the
intersections of
clustering implied by the listed variables. To mimic the behavior of
stata's boottest command,
the default is to cluster by the intersection of all the variables
specified via the <code>clustid</code> argument,
even though that is not necessarily recommended (see the paper by
Roodman et al cited below, section 4.2).
Other options include &quot;min&quot;, where bootstrapping is clustered by
the cluster variable with the fewest clusters.
Further, the subcluster bootstrap (MacKinnon &amp; Webb, 2018) is
supported - see the <code>vignette("fwildclusterboot", package = "fwildclusterboot")</code> for details.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_fe">fe</code></td>
<td>
<p>A character vector or rhs formula of length one which contains
the name of the fixed effect to be projected
out in the bootstrap. Note: if regression weights are used, fe
needs to be NULL.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_sign_level">sign_level</code></td>
<td>
<p>A numeric between 0 and 1 which sets the significance level
of the inference procedure. E.g. sign_level = 0.05
returns 0.95% confidence intervals. By default, sign_level = 0.05.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_beta0">beta0</code></td>
<td>
<p>Deprecated function argument. Replaced by function argument 'r'.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_type">type</code></td>
<td>
<p>character or function. The character string specifies the type
of boostrap to use: One of &quot;rademacher&quot;, &quot;mammen&quot;, &quot;norm&quot;
and &quot;webb&quot;. Alternatively, type can be a function(n) for drawing
wild bootstrap factors. &quot;rademacher&quot; by default.
For the Rademacher distribution, if the number of replications B
exceeds
the number of possible draw ombinations, 2^(#number of clusters),
then <code>boottest()</code>
will use each possible combination once (enumeration).</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_impose_null">impose_null</code></td>
<td>
<p>Logical. Controls if the null hypothesis is imposed on
the bootstrap dgp or not. Null imposed <code>(WCR)</code> by default.
If FALSE, the null is not imposed <code>(WCU)</code></p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_bootstrap_type">bootstrap_type</code></td>
<td>
<p>Determines which wild cluster bootstrap type should be
run. Options are &quot;fnw11&quot;, which runs a &quot;11&quot; type
wild cluster bootstrap via the algorithm outlined in &quot;fast and wild&quot;
(Roodman et al (2019)).</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_p_val_type">p_val_type</code></td>
<td>
<p>Character vector of length 1. Type of p-value.
By default &quot;two-tailed&quot;. Other options include &quot;equal-tailed&quot;,
&quot;&gt;&quot; and &quot;&lt;&quot;.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than,
or equal to, the maximum number of threads; b) 0: meaning
all available threads will be used; c) a number strictly
between 0 and 1 which represents the fraction of all threads
to use. The default is to use 1 core.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_tol">tol</code></td>
<td>
<p>Numeric vector of length 1. The desired accuracy
(convergence tolerance) used in the root finding procedure to find
the confidence interval.
1e-6 by default.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer. Maximum number of iterations used in the root
finding procedure to find the confidence interval.
10 by default.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>boot_ssc.type</code> obtained with the function
<code><a href="#topic+boot_ssc">boot_ssc()</a></code>. Represents how the small sample
adjustments are computed. The defaults are <code style="white-space: pre;">&#8288;adj = TRUE, fixef.K = "none", cluster.adj = "TRUE", cluster.df = "conventional"&#8288;</code>.
You can find more details in the help file for <code>boot_ssc()</code>.
The function is purposefully designed to mimic fixest's
<code><a href="fixest.html#topic+ssc">fixest::ssc()</a></code> function.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_engine">engine</code></td>
<td>
<p>Character scalar. Either &quot;R&quot;, &quot;R-lean&quot; or &quot;WildBootTests.jl&quot;.
Controls if <code>boottest()</code> should run via its native R implementation
or <code>WildBootTests.jl</code>.
&quot;R&quot; is the default and implements the cluster bootstrap
as in Roodman (2019). &quot;WildBootTests.jl&quot; executes the
wild cluster bootstrap via the WildBootTests.jl
package. For it to run, Julia and WildBootTests.jl need
to be installed.
The &quot;R-lean&quot; algorithm is a memory friendly, but less
performant rcpp-armadillo based implementation of the wild
cluster bootstrap.
Note that if no cluster is provided, boottest() always
defaults to the &quot;lean&quot; algorithm. You can set the employed
algorithm globally by using the
<code>setBoottest_engine()</code> function.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_floattype">floattype</code></td>
<td>
<p>Float64 by default. Other option: Float32. Should floating
point numbers in Julia be represented as 32 or 64 bit? Only relevant when
'engine = &quot;WildBootTests.jl&quot;'</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_maxmatsize">maxmatsize</code></td>
<td>
<p>NULL by default = no limit. Else numeric scalar to set
the maximum size of auxilliary weight matrix (v), in gigabytes. Only
relevant when 'engine = &quot;WildBootTests.jl&quot;'</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_bootstrapc">bootstrapc</code></td>
<td>
<p>Logical scalar, FALSE by default. TRUE  to request
bootstrap-c instead of bootstrap-t. Only relevant when
'engine = &quot;WildBootTests.jl&quot;'</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_getauxweights">getauxweights</code></td>
<td>
<p>Logical. Whether to save auxilliary weight matrix (v)</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_sampling">sampling</code></td>
<td>
<p>'dqrng' or 'standard'. If 'dqrng', the 'dqrng' package is
used for random number generation (when available). If 'standard',
functions from the 'stats' package are used when available.
This argument is mostly a convenience to control random number generation in
a wrapper package around <code>fwildclusterboot</code>, <code>wildrwolf</code>.
I recommend to use the fast' option.</p>
</td></tr>
<tr><td><code id="boot_aggregate_+3A_...">...</code></td>
<td>
<p>misc function arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that contrary to the SA article, here the cohort share
in the sample is considered to be a perfect measure for the
cohort share in the population.
</p>
<p>Most of this function is written by Laurent Bergé and used
in the fixest package published under GPL-3,
https://cran.r-project.org/web/packages/fixest/index.html
minor changes by Alexander Fischer
</p>


<h3>Value</h3>

<p>A data frame with aggregated coefficients, p-values and
confidence intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
if(requireNamespace("fixest")){
library(fixest)
data(base_stagg)
# The DiD estimation
res_sunab = feols(y ~ x1 + sunab(year_treated, year) | id + year, base_stagg)
res_sunab_3ref = feols(y ~ x1 + sunab(
 year_treated, year, ref.p = c(.F + 0:2, -1)) |
                        id + year, 
                      cluster = "id",
                      base_stagg, 
                      ssc = ssc(adj = FALSE, cluster.adj = FALSE))

aggregate(res_sunab, agg = "ATT")
# test ATT equivalence
boot_att &lt;- 
 boot_aggregate(
   res_sunab, 
   B = 9999, 
   agg = "ATT", 
   clustid = "id" 
 )
head(boot_att)

#'boot_agg2 &lt;- 
 boot_aggregate(
   res_sunab, 
   B = 99999, 
   agg = TRUE,
   ssc = boot_ssc(adj = FALSE, cluster.adj = FALSE)
 )

}

## End(Not run)
</code></pre>

<hr>
<h2 id='boot_ssc'>set the small sample correction factor applied in <code>boottest()</code></h2><span id='topic+boot_ssc'></span>

<h3>Description</h3>

<p>set the small sample correction factor applied in <code>boottest()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_ssc(
  adj = TRUE,
  fixef.K = "none",
  cluster.adj = TRUE,
  cluster.df = "conventional"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_ssc_+3A_adj">adj</code></td>
<td>
<p>Logical scalar, defaults to TRUE. If TRUE, applies a small
sample correction of (N-1) / (N-k) where N is the number of observations
and k is the number of estimated coefficients excluding any fixed
effects projected out in either fixest::feols() or lfe::felm().</p>
</td></tr>
<tr><td><code id="boot_ssc_+3A_fixef.k">fixef.K</code></td>
<td>
<p>Character scalar, equal to 'none': the fixed effects
parameters are discarded when calculating k in (N-1) / (N-k).</p>
</td></tr>
<tr><td><code id="boot_ssc_+3A_cluster.adj">cluster.adj</code></td>
<td>
<p>Logical scalar, defaults to TRUE. If TRUE, a cluster
correction G/(G-1) is performed, with G the number of clusters.</p>
</td></tr>
<tr><td><code id="boot_ssc_+3A_cluster.df">cluster.df</code></td>
<td>
<p>Either &quot;conventional&quot;(the default) or &quot;min&quot;. Controls
how &quot;G&quot; is computed for multiway clustering if cluster.adj = TRUE.
Note that the covariance matrix in the multiway clustering case is of
the form V = V_1 + V_2 - V_12. If &quot;conventional&quot;, then each summand G_i
is multiplied with a small sample adjustment G_i / (G_i - 1). If &quot;min&quot;,
all summands are multiplied with the same value, min(G) / (min(G) - 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with encoded info on how to form small sample corrections
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boot_ssc(adj = TRUE, cluster.adj = TRUE)
boot_ssc(adj = TRUE, cluster.adj = TRUE, cluster.df = "min")
</code></pre>

<hr>
<h2 id='boottest'>Fast wild cluster bootstrap inference</h2><span id='topic+boottest'></span>

<h3>Description</h3>

<p><code>boottest</code> is a S3 method that allows for fast wild cluster
bootstrap inference for objects of class lm, fixest and felm by  implementing
the fast wild bootstrap algorithm developed in Roodman et al., 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boottest(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boottest_+3A_object">object</code></td>
<td>
<p>An object of type lm, fixest, felm or ivreg</p>
</td></tr>
<tr><td><code id="boottest_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>boottest</code>.
</p>


<h3>Setting Seeds</h3>

<p>To guarantee reproducibility, you can either use <code style="white-space: pre;">&#8288;boottest()'s&#8288;</code> <code>seed</code>
function argument, or
set a global random seed via
</p>

<ul>
<li> <p><code>set.seed()</code> when using
</p>

<ol>
<li><p> the lean algorithm (via <code>engine = "R-lean"</code>), 2) the heteroskedastic
wild bootstrap
</p>
</li>
<li><p> the wild cluster bootstrap via <code>engine = "R"</code> with Mammen weights
or 4) <code>engine = "WildBootTests.jl"</code>
</p>
</li></ol>

</li>
<li> <p><code>dqrng::dqset.seed()</code> when using <code>engine = "R"</code> for Rademacher, Webb
or Normal weights
</p>
</li></ul>



<h3>Stata, Julia and Python Implementations</h3>

<p>The fast wild cluster bootstrap algorithms are further implemented in the
following software packages:
</p>

<ul>
<li><p> Stata:<a href="https://github.com/droodman/boottest">boottest</a>
</p>
</li>
<li><p> Julia:<a href="https://github.com/droodman/WildBootTests.jl">WildBootTests.jl</a>
</p>
</li>
<li><p> Python:<a href="https://github.com/s3alfisc/wildboottest">wildboottest</a>
</p>
</li></ul>



<h3>References</h3>

<p>Roodman et al., 2019, &quot;Fast and wild: Bootstrap inference in
STATA using boottest&quot;, The STATA Journal.
(<a href="https://ideas.repec.org/p/qed/wpaper/1406.html">https://ideas.repec.org/p/qed/wpaper/1406.html</a>)
</p>
<p>MacKinnon, James G., Morten Ørregaard Nielsen, and
Matthew D. Webb. Fast and reliable jackknife and bootstrap
methods for cluster-robust inference. No. 1485. 2022.
</p>
<p>Cameron, A. Colin, Jonah B. Gelbach, and Douglas L. Miller.
&quot;Bootstrap-based improvements for inference with clustered errors.&quot;
The Review of Economics and Statistics 90.3 (2008): 414-427.
</p>
<p>Cameron, A.Colin &amp; Douglas L. Miller.
&quot;A practitioner's guide to cluster-robust inference&quot;
Journal of Human Resources (2015) <a href="https://doi.org/10.3368/jhr.50.2.317">doi:10.3368/jhr.50.2.317</a>
</p>
<p>Davidson &amp; MacKinnon. &quot;Wild Bootstrap Tests for IV regression&quot;
Journal of Economics and Business Statistics (2010)
<a href="https://doi.org/10.1198/jbes.2009.07221">doi:10.1198/jbes.2009.07221</a>
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;The wild bootstrap for few (treated) clusters.&quot;
The Econometrics Journal 21.2 (2018): 114-135.
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;Cluster-robust inference: A guide to empirical practice&quot;
Journal of Econometrics (2022)
<a href="https://doi.org/10.1016/j.jeconom.2022.04.001">doi:10.1016/j.jeconom.2022.04.001</a>
</p>
<p>MacKinnon, James. &quot;Wild cluster bootstrap confidence intervals.&quot;
L'Actualite economique 91.1-2 (2015): 11-33.
</p>
<p>Webb, Matthew D.
&quot;Reworking wild bootstrap based inference for clustered errors&quot;
. No. 1315. Queen's Economics Department Working Paper, 2013.
</p>


<h3>See Also</h3>

<p><a href="#topic+boottest.lm">boottest.lm</a>,
<a href="#topic+boottest.fixest">boottest.fixest</a>,
<a href="#topic+boottest.felm">boottest.felm</a>,
<a href="#topic+boottest.ivreg">boottest.ivreg</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
  proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
boot &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
summary(boot)
print(boot)
plot(boot)
nobs(boot)
pval(boot)
confint(boot)
generics::tidy(boot)

</code></pre>

<hr>
<h2 id='boottest.felm'>Fast wild cluster bootstrap inference for object of class felm</h2><span id='topic+boottest.felm'></span>

<h3>Description</h3>

<p><code>boottest.felm</code> is a S3 method that allows for fast wild cluster
bootstrap inference for objects of class felm by  implementing
fast wild bootstrap algorithms as developed in Roodman et al., 2019
and MacKinnon, Nielsen &amp; Webb (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'felm'
boottest(
  object,
  param,
  B,
  clustid = NULL,
  bootcluster = "max",
  fe = NULL,
  conf_int = TRUE,
  R = NULL,
  r = 0,
  beta0 = NULL,
  sign_level = 0.05,
  type = "rademacher",
  impose_null = TRUE,
  bootstrap_type = "fnw11",
  p_val_type = "two-tailed",
  tol = 1e-06,
  maxiter = 10,
  sampling = "dqrng",
  nthreads = getBoottest_nthreads(),
  ssc = boot_ssc(adj = TRUE, fixef.K = "none", cluster.adj = TRUE, cluster.df =
    "conventional"),
  engine = getBoottest_engine(),
  floattype = "Float64",
  maxmatsize = FALSE,
  bootstrapc = FALSE,
  getauxweights = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boottest.felm_+3A_object">object</code></td>
<td>
<p>An object of class felm</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_param">param</code></td>
<td>
<p>A character vector or rhs formula. The name of the regression
coefficient(s) for which the hypothesis is to be tested</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_b">B</code></td>
<td>
<p>Integer. The number of bootstrap iterations. When the number
of clusters is low,
increasing B adds little additional runtime.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_clustid">clustid</code></td>
<td>
<p>A character vector or rhs formula containing the names of
the cluster variables. If NULL,
a heteroskedasticity-robust (HC1) wild bootstrap is run.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_bootcluster">bootcluster</code></td>
<td>
<p>A character vector or rhs formula of length 1.
Specifies the bootstrap clustering variable or variables. If more
than one variable is specified, then bootstrapping is clustered
by the intersections of
clustering implied by the listed variables. To mimic the behavior
of stata's boottest command,
the default is to cluster by the intersection of all the variables
specified via the <code>clustid</code> argument,
even though that is not necessarily recommended (see the paper by
Roodman et al cited below, section 4.2).
Other options include &quot;min&quot;, where bootstrapping is clustered by
the cluster variable with the fewest clusters.
Further, the subcluster bootstrap (MacKinnon &amp; Webb, 2018) is
supported - see the <code>vignette("fwildclusterboot", package = "fwildclusterboot")</code> for details.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_fe">fe</code></td>
<td>
<p>A character vector or rhs formula of length one which contains
the name of the fixed effect to be projected
out in the bootstrap. Note: if regression weights are used, fe
needs to be NULL.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_conf_int">conf_int</code></td>
<td>
<p>A logical vector. If TRUE, boottest computes confidence
intervals by test inversion. If FALSE, only the p-value is returned.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_r">R</code></td>
<td>
<p>Hypothesis Vector giving linear combinations of coefficients.
Must be either NULL or a vector of the same length as <code>param</code>. If NULL,
a vector of ones of length param.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_r">r</code></td>
<td>
<p>A numeric. Shifts the null hypothesis
H0: param = r vs H1: param != r</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_beta0">beta0</code></td>
<td>
<p>Deprecated function argument. Replaced by function argument 'r'.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_sign_level">sign_level</code></td>
<td>
<p>A numeric between 0 and 1 which sets the significance level
of the inference procedure. E.g. sign_level = 0.05
returns 0.95% confidence intervals. By default, sign_level = 0.05.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_type">type</code></td>
<td>
<p>character or function. The character string specifies the type
of boostrap to use: One of &quot;rademacher&quot;, &quot;mammen&quot;, &quot;norm&quot;
and &quot;webb&quot;. Alternatively, type can be a function(n) for drawing
wild bootstrap factors. &quot;rademacher&quot; by default.
For the Rademacher distribution, if the number of replications B
exceeds the number of possible draw ombinations,
2^(#number of clusters), then <code>boottest()</code>
will use each possible combination once (enumeration).</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_impose_null">impose_null</code></td>
<td>
<p>Logical. Controls if the null hypothesis is imposed on
the bootstrap dgp or not. Null imposed <code>(WCR)</code> by default.
If FALSE, the null is not imposed <code>(WCU)</code></p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_bootstrap_type">bootstrap_type</code></td>
<td>
<p>Determines which wild cluster bootstrap type should be
run. Options are &quot;fnw11&quot;,&quot;11&quot;, &quot;13&quot;, &quot;31&quot; and &quot;33&quot; for the wild cluster
bootstrap and &quot;11&quot; and &quot;31&quot; for the heteroskedastic bootstrap.
For more information, see the details section. &quot;fnw11&quot; is the default for
the cluster bootstrap, which runs a &quot;11&quot; type
wild cluster bootstrap via the algorithm outlined in &quot;fast and wild&quot;
(Roodman et al (2019)). &quot;11&quot; is the default for the heteroskedastic
bootstrap.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_p_val_type">p_val_type</code></td>
<td>
<p>Character vector of length 1. Type of p-value.
By default &quot;two-tailed&quot;. Other options include &quot;equal-tailed&quot;,
&quot;&gt;&quot; and &quot;&lt;&quot;.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_tol">tol</code></td>
<td>
<p>Numeric vector of length 1. The desired accuracy
(convergence tolerance) used in the root finding procedure to find
the confidence interval.
1e-6 by default.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer. Maximum number of iterations used in the root
finding procedure to find the confidence interval.
10 by default.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_sampling">sampling</code></td>
<td>
<p>'dqrng' or 'standard'. If 'dqrng', the 'dqrng' package is
used for random number generation (when available). If 'standard',
functions from the 'stats' package are used when available.
This argument is mostly a convenience to control random number generation in
a wrapper package around <code>fwildclusterboot</code>, <code>wildrwolf</code>.
I recommend to use the fast' option.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than,
or equal to, the maximum number of threads; b) 0: meaning
all available threads will be used; c) a number strictly
between 0 and 1 which represents the fraction of all threads
to use. The default is to use 1 core.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>boot_ssc.type</code> obtained with the function
<code><a href="#topic+boot_ssc">boot_ssc()</a></code>. Represents how the small sample
adjustments are computed. The defaults are
adj = TRUE, fixef.K = &quot;none&quot;, cluster.adj = &quot;TRUE&quot;,
cluster.df = &quot;conventional&quot;. You can find more details in the help
file for <code>boot_ssc()</code>. The function is purposefully designed to mimic
fixest's <code><a href="fixest.html#topic+ssc">fixest::ssc()</a></code> function.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_engine">engine</code></td>
<td>
<p>Character scalar. Either &quot;R&quot; or &quot;WildBootTests.jl&quot;.
Controls the algorithm employed by boottest.
&quot;R&quot; is the default and implements the cluster bootstrap
as in Roodman (2019). &quot;WildBootTests.jl&quot; executes the wild
cluster bootstrap by via the WildBootTests.jl
package. For it to run, Julia and WildBootTests.jl need to
be installed. Check out the set_up_ ... functions
The &quot;fast and wild&quot; algorithm is extremely fast for small
number of clusters, but because it is fully vectorized,
very memory-demanding.
For large number of clusters and large number of bootstrap
iterations, the fast and wild algorithm becomes infeasible.
If a out-of-memory error #
occurs, the &quot;lean&quot; algorithm is a memory friendly, but less
performant rcpp-armadillo based implementation of the wild
cluster bootstrap.
Note that if no cluster is provided, boottest() always
defaults to the &quot;lean&quot; algorithm. Note that you can set the
employed algorithm globally by using the
<code>setBoottest_engine()</code> function.</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_floattype">floattype</code></td>
<td>
<p>Float64 by default. Other option: Float32. Should floating
point numbers in Julia be represented as 32 or 64 bit? Only relevant when
'engine = &quot;WildBootTests.jl&quot;'</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_maxmatsize">maxmatsize</code></td>
<td>
<p>NULL by default = no limit. Else numeric scalar to set the
maximum size of auxilliary weight matrix (v), in gigabytes. Only relevant
when 'engine = &quot;WildBootTests.jl&quot;'</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_bootstrapc">bootstrapc</code></td>
<td>
<p>Logical scalar, FALSE by default. TRUE  to request
bootstrap-c instead of bootstrap-t. Only relevant when 'engine =
&quot;WildBootTests.jl&quot;'</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_getauxweights">getauxweights</code></td>
<td>
<p>Logical. Whether to save auxilliary weight matrix (v)</p>
</td></tr>
<tr><td><code id="boottest.felm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>boottest</code>
</p>
<table>
<tr><td><code>p_val</code></td>
<td>
<p>The bootstrap p-value.</p>
</td></tr>
<tr><td><code>conf_int</code></td>
<td>
<p>The bootstrap confidence interval.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>The tested parameter.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Sample size. Might differ from the regression sample size if
the cluster variables contain NA values.</p>
</td></tr>
<tr><td><code>boot_iter</code></td>
<td>
<p>Number of Bootstrap Iterations.</p>
</td></tr>
<tr><td><code>clustid</code></td>
<td>
<p>Names of the cluster Variables.</p>
</td></tr>
<tr><td><code>N_G</code></td>
<td>
<p>Dimension of the cluster variables as used in boottest.</p>
</td></tr>
<tr><td><code>sign_level</code></td>
<td>
<p>Significance level used in boottest.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Distribution of the bootstrap weights.</p>
</td></tr>
<tr><td><code>impose_null</code></td>
<td>
<p>Whether the null was imposed on the bootstrap dgp or not.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>The vector &quot;R&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The scalar &quot;r&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>point_estimate</code></td>
<td>
<p>R'beta. A scalar: the constraints vector times the
regression coefficients.</p>
</td></tr>
<tr><td><code>grid_vals</code></td>
<td>
<p>All t-statistics calculated while calculating the
confidence interval.</p>
</td></tr>
<tr><td><code>p_grid_vals</code></td>
<td>
<p>All p-values calculated while calculating the confidence
interval.</p>
</td></tr>
<tr><td><code>t_stat</code></td>
<td>
<p>The 'original' regression test statistics.</p>
</td></tr>
<tr><td><code>t_boot</code></td>
<td>
<p>All bootstrap t-statistics.</p>
</td></tr>
<tr><td><code>regression</code></td>
<td>
<p>The regression object used in boottest.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Function call of boottest.</p>
</td></tr>
<tr><td><code>engine</code></td>
<td>
<p>The employed bootstrap algorithm.</p>
</td></tr>
<tr><td><code>nthreads</code></td>
<td>
<p>The number of threads employed.</p>
</td></tr>
</table>


<h3>Setting Seeds</h3>

<p>To guarantee reproducibility, you need to
set a global random seed via
</p>

<ul>
<li> <p><code>set.seed()</code> when using
</p>

<ol>
<li><p> the lean algorithm (via <code>engine = "R-lean"</code>) including the
heteroskedastic wild bootstrap
</p>
</li>
<li><p> the wild cluster bootstrap via <code>engine = "R"</code> with Mammen weights or
</p>
</li>
<li> <p><code>engine = "WildBootTests.jl"</code>
</p>
</li></ol>

</li>
<li> <p><code>dqrng::dqset.seed()</code> when using <code>engine = "R"</code> for Rademacher, Webb
or Normal weights
</p>
</li></ul>



<h3>Confidence Intervals</h3>

<p><code>boottest</code> computes confidence intervals by inverting p-values.
In practice, the following procedure is used:
</p>

<ul>
<li><p> Based on an initial guess for starting values, calculate p-values for
26 equal spaced points between the starting values.
</p>
</li>
<li><p> Out of the 26 calculated p-values, find the two pairs of values x
for which the corresponding p-values px cross the significance level
sign_level.
</p>
</li>
<li><p> Feed the two pairs of x into an numerical root finding procedure and
solve for the root. boottest currently relies on
<code>stats::uniroot</code> and sets an absolute tolerance of 1e-06 and
stops the procedure after 10 iterations.
</p>
</li></ul>



<h3>Standard Errors</h3>

<p><code>boottest</code> does not calculate standard errors.
</p>


<h3>Stata, Julia and Python Implementations</h3>

<p>The fast wild cluster bootstrap algorithms are further implemented in the
following software packages:
</p>

<ul>
<li><p> Stata:<a href="https://github.com/droodman/boottest">boottest</a>
</p>
</li>
<li><p> Julia:<a href="https://github.com/droodman/WildBootTests.jl">WildBootTests.jl</a>
</p>
</li>
<li><p> Python:<a href="https://github.com/s3alfisc/wildboottest">wildboottest</a>
</p>
</li></ul>



<h3>References</h3>

<p>Roodman et al., 2019, &quot;Fast and wild: Bootstrap inference in
STATA using boottest&quot;, The STATA Journal.
(<a href="https://ideas.repec.org/p/qed/wpaper/1406.html">https://ideas.repec.org/p/qed/wpaper/1406.html</a>)
</p>
<p>MacKinnon, James G., Morten Ørregaard Nielsen, and
Matthew D. Webb. Fast and reliable jackknife and bootstrap
methods for cluster-robust inference. No. 1485. 2022.
</p>
<p>Cameron, A. Colin, Jonah B. Gelbach, and Douglas L. Miller.
&quot;Bootstrap-based improvements for inference with clustered errors.&quot;
The Review of Economics and Statistics 90.3 (2008): 414-427.
</p>
<p>Cameron, A.Colin &amp; Douglas L. Miller.
&quot;A practitioner's guide to cluster-robust inference&quot;
Journal of Human Resources (2015) <a href="https://doi.org/10.3368/jhr.50.2.317">doi:10.3368/jhr.50.2.317</a>
</p>
<p>Davidson &amp; MacKinnon. &quot;Wild Bootstrap Tests for IV regression&quot;
Journal of Economics and Business Statistics (2010)
<a href="https://doi.org/10.1198/jbes.2009.07221">doi:10.1198/jbes.2009.07221</a>
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;The wild bootstrap for few (treated) clusters.
&quot; The Econometrics Journal 21.2 (2018): 114-135.
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;Cluster-robust inference: A guide to empirical practice&quot;
Journal of Econometrics (2022)
<a href="https://doi.org/10.1016/j.jeconom.2022.04.001">doi:10.1016/j.jeconom.2022.04.001</a>
</p>
<p>MacKinnon, James. &quot;Wild cluster bootstrap confidence intervals.&quot;
L'Actualite economique 91.1-2 (2015): 11-33.
</p>
<p>Webb, Matthew D. Reworking wild bootstrap based inference for
clustered errors. No. 1315. Queen's Economics Department Working Paper,
2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  requireNamespace("lfe") 
  data(voters)
  felm_fit &lt;- felm(proposition_vote ~ treatment + ideology1 + log_income |
    Q1_immigration,
  data = voters
  )
  boot1 &lt;- boottest(felm_fit,
    B = 9999,
    param = "treatment",
    clustid = "group_id1"
  )
  boot2 &lt;- boottest(felm_fit,
    B = 9999,
    param = "treatment",
    clustid = c("group_id1", "group_id2")
  )
  boot3 &lt;- boottest(felm_fit,
    B = 9999,
    param = "treatment",
    clustid = c("group_id1", "group_id2"),
    fe = "Q1_immigration"
  )
  boot4 &lt;- boottest(felm_fit,
    B = 999,
    param = "treatment",
    clustid = c("group_id1", "group_id2"),
    fe = "Q1_immigration",
    sign_level = 0.2,
    r = 2
  )
  # test treatment + ideology1 = 2
  boot5 &lt;- boottest(felm_fit,
    B = 9999,
    clustid = c("group_id1", "group_id2"),
    param = c("treatment", "ideology1"),
    R = c(1, 1),
    r = 2
  )
  summary(boot1)
  print(boot1)
  plot(boot1)
  nobs(boot1)
  pval(boot1)
  confint(boot1)
  generics::tidy(boot1)
  
# run different bootstrap types following MacKinnon, Nielsen &amp; Webb (2022):

# default: the fnw algorithm
boot_fnw11 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1", 
  bootstrap_type = "fnw11"
)

# WCR 31 
boot_WCR31 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1",
  bootstrap_type = "31"
)

# WCU33 
boot_WCR31 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1",
  bootstrap_type = "33", 
  impose_null = FALSE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='boottest.fixest'>Fast wild cluster bootstrap inference for object of class fixest</h2><span id='topic+boottest.fixest'></span>

<h3>Description</h3>

<p><code>boottest.fixest</code> is a S3 method that allows for fast wild cluster
bootstrap inference for objects of class fixest by  implementing
fast wild bootstrap algorithms as developed in Roodman et al., 2019
and MacKinnon, Nielsen &amp; Webb (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
boottest(
  object,
  param,
  B,
  clustid = NULL,
  bootcluster = "max",
  fe = NULL,
  sign_level = 0.05,
  conf_int = TRUE,
  R = NULL,
  r = 0,
  beta0 = NULL,
  type = "rademacher",
  impose_null = TRUE,
  bootstrap_type = "fnw11",
  p_val_type = "two-tailed",
  tol = 1e-06,
  maxiter = 10,
  sampling = "dqrng",
  nthreads = getBoottest_nthreads(),
  ssc = boot_ssc(adj = TRUE, fixef.K = "none", cluster.adj = TRUE, cluster.df =
    "conventional"),
  engine = getBoottest_engine(),
  floattype = "Float64",
  maxmatsize = FALSE,
  bootstrapc = FALSE,
  getauxweights = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boottest.fixest_+3A_object">object</code></td>
<td>
<p>An object of class fixest and estimated via <code>fixest::feols()</code>.
Non-linear models are not supported.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_param">param</code></td>
<td>
<p>A character vector or rhs formula. The name of the regression
coefficient(s) for which the hypothesis is to be tested</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_b">B</code></td>
<td>
<p>Integer. The number of bootstrap iterations. When the number of
clusters is low,
increasing B adds little additional runtime.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_clustid">clustid</code></td>
<td>
<p>A character vector or rhs formula containing the names of the
cluster variables. If NULL,
a heteroskedasticity-robust (HC1) wild bootstrap is run.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_bootcluster">bootcluster</code></td>
<td>
<p>A character vector or rhs formula of length 1. Specifies
the bootstrap clustering variable or variables. If more
than one variable is specified, then bootstrapping is clustered by the
intersections of
clustering implied by the listed variables. To mimic the behavior of
stata's boottest command,
the default is to cluster by the intersection of all the variables
specified via the <code>clustid</code> argument,
even though that is not necessarily recommended (see the paper by
Roodman et al cited below, section 4.2).
Other options include &quot;min&quot;, where bootstrapping is clustered by
the cluster variable with the fewest clusters.
Further, the subcluster bootstrap (MacKinnon &amp; Webb, 2018) is
supported - see the <code>vignette("fwildclusterboot", package = "fwildclusterboot")</code> for details.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_fe">fe</code></td>
<td>
<p>A character vector or rhs formula of length one which contains
the name of the fixed effect to be projected
out in the bootstrap. Note: if regression weights are used, fe
needs to be NULL.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_sign_level">sign_level</code></td>
<td>
<p>A numeric between 0 and 1 which sets the significance level
of the inference procedure. E.g. sign_level = 0.05
returns 0.95% confidence intervals. By default, sign_level = 0.05.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_conf_int">conf_int</code></td>
<td>
<p>A logical vector. If TRUE, boottest computes confidence
intervals by test inversion. If FALSE, only the p-value is returned.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_r">R</code></td>
<td>
<p>Hypothesis Vector giving linear combinations of coefficients.
Must be either NULL or a vector of the same length as <code>param</code>. If NULL,
a vector of ones of length param.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_r">r</code></td>
<td>
<p>A numeric. Shifts the null hypothesis
H0: param = r vs H1: param != r</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_beta0">beta0</code></td>
<td>
<p>Deprecated function argument. Replaced by function argument 'r'.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_type">type</code></td>
<td>
<p>character or function. The character string specifies the type
of boostrap to use: One of &quot;rademacher&quot;, &quot;mammen&quot;, &quot;norm&quot;
and &quot;webb&quot;. Alternatively, type can be a function(n) for drawing
wild bootstrap factors. &quot;rademacher&quot; by default.
For the Rademacher distribution, if the number of replications B
exceeds
the number of possible draw ombinations, 2^(#number of clusters),
then <code>boottest()</code>
will use each possible combination once (enumeration).</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_impose_null">impose_null</code></td>
<td>
<p>Logical. Controls if the null hypothesis is imposed on
the bootstrap dgp or not. Null imposed <code>(WCR)</code> by default.
If FALSE, the null is not imposed <code>(WCU)</code></p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_bootstrap_type">bootstrap_type</code></td>
<td>
<p>Determines which wild cluster bootstrap type should be
run. Options are &quot;fnw11&quot;,&quot;11&quot;, &quot;13&quot;, &quot;31&quot; and &quot;33&quot; for the wild cluster
bootstrap and &quot;11&quot; and &quot;31&quot; for the heteroskedastic bootstrap.
For more information, see the details section. &quot;fnw11&quot; is the default for
the cluster bootstrap, which runs a &quot;11&quot; type
wild cluster bootstrap via the algorithm outlined in &quot;fast and wild&quot;
(Roodman et al (2019)). &quot;11&quot; is the default for the heteroskedastic
bootstrap.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_p_val_type">p_val_type</code></td>
<td>
<p>Character vector of length 1. Type of p-value.
By default &quot;two-tailed&quot;. Other options include &quot;equal-tailed&quot;,
&quot;&gt;&quot; and &quot;&lt;&quot;.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_tol">tol</code></td>
<td>
<p>Numeric vector of length 1. The desired accuracy
(convergence tolerance) used in the root finding procedure to find
the confidence interval.
1e-6 by default.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer. Maximum number of iterations used in the root
finding procedure to find the confidence interval.
10 by default.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_sampling">sampling</code></td>
<td>
<p>'dqrng' or 'standard'. If 'dqrng', the 'dqrng' package is
used for random number generation (when available). If 'standard',
functions from the 'stats' package are used when available.
This argument is mostly a convenience to control random number generation in
a wrapper package around <code>fwildclusterboot</code>, <code>wildrwolf</code>.
I recommend to use the fast' option.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than,
or equal to, the maximum number of threads; b) 0: meaning
all available threads will be used; c) a number strictly
between 0 and 1 which represents the fraction of all threads
to use. The default is to use 1 core.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>boot_ssc.type</code> obtained with the function
<code><a href="#topic+boot_ssc">boot_ssc()</a></code>. Represents how the small sample
adjustments are computed. The defaults are <code style="white-space: pre;">&#8288;adj = TRUE, fixef.K = "none", cluster.adj = "TRUE", cluster.df = "conventional"&#8288;</code>.
You can find more details in the help file for <code>boot_ssc()</code>.
The function is purposefully designed to mimic fixest's
<code><a href="fixest.html#topic+ssc">fixest::ssc()</a></code> function.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_engine">engine</code></td>
<td>
<p>Character scalar. Either &quot;R&quot;, &quot;R-lean&quot; or &quot;WildBootTests.jl&quot;.
Controls if <code>boottest()</code> should run via its native R implementation
or <code>WildBootTests.jl</code>.
&quot;R&quot; is the default and implements the cluster bootstrap
as in Roodman (2019). &quot;WildBootTests.jl&quot; executes the
wild cluster bootstrap via the WildBootTests.jl
package. For it to run, Julia and WildBootTests.jl need
to be installed.
The &quot;R-lean&quot; algorithm is a memory friendly, but less
performant rcpp-armadillo based implementation of the wild
cluster bootstrap.
Note that if no cluster is provided, boottest() always
defaults to the &quot;lean&quot; algorithm. You can set the employed
algorithm globally by using the
<code>setBoottest_engine()</code> function.</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_floattype">floattype</code></td>
<td>
<p>Float64 by default. Other option: Float32. Should floating
point numbers in Julia be represented as 32 or 64 bit? Only relevant when
'engine = &quot;WildBootTests.jl&quot;'</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_maxmatsize">maxmatsize</code></td>
<td>
<p>NULL by default = no limit. Else numeric scalar to set
the maximum size of auxilliary weight matrix (v), in gigabytes. Only
relevant when 'engine = &quot;WildBootTests.jl&quot;'</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_bootstrapc">bootstrapc</code></td>
<td>
<p>Logical scalar, FALSE by default. TRUE  to request
bootstrap-c instead of bootstrap-t. Only relevant when
'engine = &quot;WildBootTests.jl&quot;'</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_getauxweights">getauxweights</code></td>
<td>
<p>Logical. Whether to save auxilliary weight matrix (v)</p>
</td></tr>
<tr><td><code id="boottest.fixest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>boottest</code>
</p>
<table>
<tr><td><code>p_val</code></td>
<td>
<p>The bootstrap p-value.</p>
</td></tr>
<tr><td><code>conf_int</code></td>
<td>
<p>The bootstrap confidence interval.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>The tested parameter.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Sample size. Might differ from the regression sample size if
the cluster variables contain NA values.</p>
</td></tr>
<tr><td><code>boot_iter</code></td>
<td>
<p>Number of Bootstrap Iterations.</p>
</td></tr>
<tr><td><code>clustid</code></td>
<td>
<p>Names of the cluster Variables.</p>
</td></tr>
<tr><td><code>N_G</code></td>
<td>
<p>Dimension of the cluster variables as used in boottest.</p>
</td></tr>
<tr><td><code>sign_level</code></td>
<td>
<p>Significance level used in boottest.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Distribution of the bootstrap weights.</p>
</td></tr>
<tr><td><code>impose_null</code></td>
<td>
<p>Whether the null was imposed on the bootstrap dgp or not.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>The vector &quot;R&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The scalar &quot;r&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>point_estimate</code></td>
<td>
<p>R'beta. A scalar: the constraints vector times the
regression coefficients.</p>
</td></tr>
<tr><td><code>grid_vals</code></td>
<td>
<p>All t-statistics calculated while calculating the
confidence interval.</p>
</td></tr>
<tr><td><code>p_grid_vals</code></td>
<td>
<p>All p-values calculated while calculating the confidence
interval.</p>
</td></tr>
<tr><td><code>t_stat</code></td>
<td>
<p>The 'original' regression test statistics.</p>
</td></tr>
<tr><td><code>t_boot</code></td>
<td>
<p>All bootstrap t-statistics.</p>
</td></tr>
<tr><td><code>regression</code></td>
<td>
<p>The regression object used in boottest.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Function call of boottest.</p>
</td></tr>
<tr><td><code>engine</code></td>
<td>
<p>The employed bootstrap algorithm.</p>
</td></tr>
<tr><td><code>nthreads</code></td>
<td>
<p>The number of threads employed.</p>
</td></tr>
</table>


<h3>Setting Seeds</h3>

<p>To guarantee reproducibility, you need to
set a global random seed via
</p>

<ul>
<li> <p><code>set.seed()</code> when using
</p>

<ol>
<li><p> the lean algorithm (via <code>engine = "R-lean"</code>) including the
heteroskedastic wild bootstrap
</p>
</li>
<li><p> the wild cluster bootstrap via <code>engine = "R"</code> with Mammen weights or
</p>
</li>
<li> <p><code>engine = "WildBootTests.jl"</code>
</p>
</li></ol>

</li>
<li> <p><code>dqrng::dqset.seed()</code> when using <code>engine = "R"</code> for Rademacher, Webb
or Normal weights
</p>
</li></ul>



<h3>Confidence Intervals</h3>

<p><code>boottest</code> computes confidence intervals by inverting p-values.
In practice, the following procedure is used:
</p>

<ul>
<li><p> Based on an initial guess for starting values, calculate p-values
for 26 equal spaced points between the starting values.
</p>
</li>
<li><p> Out of the 26 calculated p-values, find the two pairs of values x
for which the corresponding p-values px cross the significance
sign_level sign_level.
</p>
</li>
<li><p> Feed the two pairs of x into an numerical root finding procedure
and solve for the root. boottest currently relies on
<code>stats::uniroot</code> and sets an absolute tolerance of 1e-06 and
stops the procedure after 10 iterations.
</p>
</li></ul>



<h3>Standard Errors</h3>

<p><code>boottest</code> does not calculate standard errors.
</p>


<h3>Stata, Julia and Python Implementations</h3>

<p>The fast wild cluster bootstrap algorithms are further implemented in the
following software packages:
</p>

<ul>
<li><p> Stata:<a href="https://github.com/droodman/boottest">boottest</a>
</p>
</li>
<li><p> Julia:<a href="https://github.com/droodman/WildBootTests.jl">WildBootTests.jl</a>
</p>
</li>
<li><p> Python:<a href="https://github.com/s3alfisc/wildboottest">wildboottest</a>
</p>
</li></ul>



<h3>References</h3>

<p>Roodman et al., 2019, &quot;Fast and wild: Bootstrap inference in
STATA using boottest&quot;, The STATA Journal.
(<a href="https://ideas.repec.org/p/qed/wpaper/1406.html">https://ideas.repec.org/p/qed/wpaper/1406.html</a>)
</p>
<p>MacKinnon, James G., Morten Ørregaard Nielsen, and
Matthew D. Webb. Fast and reliable jackknife and bootstrap
methods for cluster-robust inference. No. 1485. 2022.
</p>
<p>Cameron, A. Colin, Jonah B. Gelbach, and Douglas L. Miller.
&quot;Bootstrap-based improvements for inference with clustered errors.&quot;
The Review of Economics and Statistics 90.3 (2008): 414-427.
</p>
<p>Cameron, A.Colin &amp; Douglas L. Miller.
&quot;A practitioner's guide to cluster-robust inference&quot;
Journal of Human Resources (2015) <a href="https://doi.org/10.3368/jhr.50.2.317">doi:10.3368/jhr.50.2.317</a>
</p>
<p>Davidson &amp; MacKinnon. &quot;Wild Bootstrap Tests for IV regression&quot;
Journal of Economics and Business Statistics (2010)
<a href="https://doi.org/10.1198/jbes.2009.07221">doi:10.1198/jbes.2009.07221</a>
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;The wild bootstrap for few (treated) clusters.
&quot; The Econometrics Journal 21.2 (2018): 114-135.
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;Cluster-robust inference: A guide to empirical practice&quot;
Journal of Econometrics (2022)
<a href="https://doi.org/10.1016/j.jeconom.2022.04.001">doi:10.1016/j.jeconom.2022.04.001</a>
</p>
<p>MacKinnon, James. &quot;Wild cluster bootstrap confidence intervals.&quot;
L'Actualite economique 91.1-2 (2015): 11-33.
</p>
<p>Webb, Matthew D. Reworking wild bootstrap based inference for
clustered errors. No. 1315. Queen's Economics Department Working Paper,
2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("fixest")
requireNamespace("fwildclusterboot")
data(voters)
feols_fit &lt;- feols(proposition_vote ~ treatment + ideology1 + log_income,
 fixef = "Q1_immigration",
 data = voters
)
boot1 &lt;- boottest(feols_fit,
 B = 9999,
 param = "treatment",
 clustid = "group_id1"
)
boot2 &lt;- boottest(feols_fit,
 B = 9999,
 param = "treatment",
 clustid = c("group_id1", "group_id2")
)
boot3 &lt;- boottest(feols_fit,
  B = 9999,
  param = "treatment",
  clustid = c("group_id1", "group_id2"),
  fe = "Q1_immigration"
)
boot4 &lt;- boottest(feols_fit,
  B = 9999,
  param = "treatment",
  clustid = c("group_id1", "group_id2"),
  fe = "Q1_immigration",
  sign_level = 0.2,
  r = 2
)
# test treatment + ideology1 = 2
boot5 &lt;- boottest(feols_fit,
  B = 9999,
  clustid = c("group_id1", "group_id2"),
  param = c("treatment", "ideology1"),
  R = c(1, 1),
  r = 2
)
summary(boot1)
print(boot1)
plot(boot1)
nobs(boot1)
pval(boot1)
confint(boot1)
generics::tidy(boot1)

# run different bootstrap types following MacKinnon, Nielsen &amp; Webb (2022):

# default: the fnw algorithm
boot_fnw11 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1", 
  bootstrap_type = "fnw11"
)

# WCR 31 
boot_WCR31 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1",
  bootstrap_type = "31"
)

# WCU33 
boot_WCR31 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1",
  bootstrap_type = "33", 
  impose_null = FALSE
)


## End(Not run)

</code></pre>

<hr>
<h2 id='boottest.ivreg'>Fast wild cluster bootstrap inference for object of class lm</h2><span id='topic+boottest.ivreg'></span>

<h3>Description</h3>

<p><code>boottest.ivreg</code> is a S3 method that allows for fast wild cluster
bootstrap inference for objects of class ivreg by  implementing
the fast wild bootstrap algorithm developed in Roodman et al., 2019
for instrumental variable models (WRE, Davidson &amp; McKinnon, 2010)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ivreg'
boottest(
  object,
  clustid,
  param,
  B,
  bootcluster = "max",
  conf_int = TRUE,
  R = NULL,
  r = 0,
  sign_level = 0.05,
  type = "rademacher",
  impose_null = TRUE,
  p_val_type = "two-tailed",
  tol = 1e-06,
  floattype = "Float64",
  getauxweights = FALSE,
  maxmatsize = NULL,
  bootstrapc = FALSE,
  liml = FALSE,
  fuller = NULL,
  kappa = NULL,
  arubin = FALSE,
  ssc = boot_ssc(adj = TRUE, fixef.K = "none", cluster.adj = TRUE, cluster.df =
    "conventional"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boottest.ivreg_+3A_object">object</code></td>
<td>
<p>An object of class lm</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_clustid">clustid</code></td>
<td>
<p>A character vector or rhs formula containing the names of
the cluster variables</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_param">param</code></td>
<td>
<p>A character vector or rhs formula of length one. The name of
the regression
coefficient for which the hypothesis is to be tested</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_b">B</code></td>
<td>
<p>Integer. The number of bootstrap iterations. When the number of
clusters is low,
increasing B adds little additional runtime</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_bootcluster">bootcluster</code></td>
<td>
<p>A character vector or rhs formula of length 1. Specifies
the bootstrap clustering variable or variables. If more
than one variable is specified, then bootstrapping is clustered
by the intersections of
clustering implied by the listed variables. To mimic the behavior
of stata's boottest command,
the default is to cluster by the intersection of all the variables
specified via the <code>clustid</code> argument,
even though that is not necessarily recommended (see the paper by
Roodman et al cited below, section 4.2).
Other options include &quot;min&quot;, where bootstrapping is clustered by
the cluster variable with the fewest clusters.
Further, the subcluster bootstrap (MacKinnon &amp; Webb, 2018) is
supported - see the <code>vignette("fwildclusterboot", package = "fwildclusterboot")</code> for details.</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_conf_int">conf_int</code></td>
<td>
<p>A logical vector. If TRUE, boottest computes confidence
intervals by test inversion. If FALSE, only the p-value is returned.</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_r">R</code></td>
<td>
<p>Hypothesis Vector giving linear combinations of coefficients.
Must be either NULL or a vector of the same length as <code>param</code>. If NULL,
a vector of ones of length param.</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_r">r</code></td>
<td>
<p>A numeric. Shifts the null hypothesis
H0: param = r vs H1: param != r</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_sign_level">sign_level</code></td>
<td>
<p>A numeric between 0 and 1 which sets the significance level
of the inference procedure. E.g. sign_level = 0.05
returns 0.95% confidence intervals. By default, sign_level = 0.05.</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_type">type</code></td>
<td>
<p>character or function. The character string specifies the type
of boostrap to use: One of &quot;rademacher&quot;, &quot;mammen&quot;, &quot;norm&quot;, &quot;gamma&quot;
and &quot;webb&quot;. Alternatively, type can be a function(n) for drawing
wild bootstrap factors. &quot;rademacher&quot; by default.
For the Rademacher and Mammen distribution, if the number of
replications B exceeds
the number of possible draw ombinations, 2^(#number of clusters),
then <code>boottest()</code>
will use each possible combination once (enumeration).</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_impose_null">impose_null</code></td>
<td>
<p>Logical. Controls if the null hypothesis is imposed on
the bootstrap dgp or not. Null imposed <code>(WCR)</code> by default.
If FALSE, the null is not imposed <code>(WCU)</code></p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_p_val_type">p_val_type</code></td>
<td>
<p>Character vector of length 1. Type of p-value.
By default &quot;two-tailed&quot;. Other options include &quot;equal-tailed&quot;,
&quot;&gt;&quot; and &quot;&lt;&quot;.</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_tol">tol</code></td>
<td>
<p>Numeric vector of length 1. The desired accuracy
(convergence tolerance) used in the root finding procedure to find
the confidence interval.
Relative tolerance of 1e-6 by default.</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_floattype">floattype</code></td>
<td>
<p>Float64 by default. Other option: Float32. Should floating
point numbers in Julia be represented as 32 or 64 bit?</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_getauxweights">getauxweights</code></td>
<td>
<p>Logical. FALSE by default. Whether to save auxilliary
weight matrix (v)</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_maxmatsize">maxmatsize</code></td>
<td>
<p>NULL by default = no limit. Else numeric scalar to set
the maximum size of auxilliary weight matrix (v), in gigabytes</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_bootstrapc">bootstrapc</code></td>
<td>
<p>Logical scalar, FALSE by default. TRUE  to request
bootstrap-c instead of bootstrap-t</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_liml">liml</code></td>
<td>
<p>Logical scalar. False by default. TRUE for liml or fuller liml</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_fuller">fuller</code></td>
<td>
<p>NULL by default. Numeric scalar. fuller liml factor</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_kappa">kappa</code></td>
<td>
<p>Null by default. fixed &lt;U+03BA&gt; for k-class estimation</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_arubin">arubin</code></td>
<td>
<p>False by default. Logical scalar. TRUE for Anderson-Rubin Test.</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>boot_ssc.type</code> obtained with the function
<code><a href="#topic+boot_ssc">boot_ssc()</a></code>. Represents how the small sample
adjustments are computed. The defaults are <code style="white-space: pre;">&#8288;adj = TRUE, fixef.K = "none", cluster.adj = "TRUE", cluster.df = "conventional"&#8288;</code>.
You can find more details in the help file for <code>boot_ssc()</code>.
The function is purposefully designed to mimic
fixest's <code><a href="fixest.html#topic+ssc">fixest::ssc()</a></code> function.</p>
</td></tr>
<tr><td><code id="boottest.ivreg_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>boottest</code>
</p>
<table>
<tr><td><code>p_val</code></td>
<td>
<p>The bootstrap p-value.</p>
</td></tr>
<tr><td><code>conf_int</code></td>
<td>
<p>The bootstrap confidence interval.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>The tested parameter.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Sample size. Might differ from the regression sample size if
the cluster variables contain NA values.</p>
</td></tr>
<tr><td><code>boot_iter</code></td>
<td>
<p>Number of Bootstrap Iterations.</p>
</td></tr>
<tr><td><code>clustid</code></td>
<td>
<p>Names of the cluster Variables.</p>
</td></tr>
<tr><td><code>N_G</code></td>
<td>
<p>Dimension of the cluster variables as used in boottest.</p>
</td></tr>
<tr><td><code>sign_level</code></td>
<td>
<p>Significance level used in boottest.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Distribution of the bootstrap weights.</p>
</td></tr>
<tr><td><code>impose_null</code></td>
<td>
<p>Whether the null was imposed on the bootstrap dgp or not.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>The vector &quot;R&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The scalar &quot;r&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>point_estimate</code></td>
<td>
<p>R'beta. A scalar: the constraints vector times the
regression coefficients.</p>
</td></tr>
<tr><td><code>grid_vals</code></td>
<td>
<p>All t-statistics calculated while calculating the
confidence interval.</p>
</td></tr>
<tr><td><code>p_grid_vals</code></td>
<td>
<p>All p-values calculated while calculating the confidence
interval.</p>
</td></tr>
<tr><td><code>t_stat</code></td>
<td>
<p>The 'original' regression test statistics.</p>
</td></tr>
<tr><td><code>t_boot</code></td>
<td>
<p>All bootstrap t-statistics.</p>
</td></tr>
<tr><td><code>regression</code></td>
<td>
<p>The regression object used in boottest.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Function call of boottest.</p>
</td></tr>
<tr><td><code>engine</code></td>
<td>
<p>The employed bootstrap algorithm.</p>
</td></tr>
<tr><td><code>nthreads</code></td>
<td>
<p>The number of threads employed.</p>
</td></tr>
</table>


<h3>Setting Seeds</h3>

<p>To guarantee reproducibility, you need to
set a global random seed via <code>set.seed()</code>
</p>


<h3>References</h3>

<p>Roodman et al., 2019, &quot;Fast and wild: Bootstrap inference in
STATA using boottest&quot;, The STATA Journal.
(<a href="https://ideas.repec.org/p/qed/wpaper/1406.html">https://ideas.repec.org/p/qed/wpaper/1406.html</a>)
</p>
<p>Cameron, A. Colin, Jonah B. Gelbach, and Douglas L. Miller.
&quot;Bootstrap-based improvements for inference with clustered errors.&quot;
The Review of Economics and Statistics 90.3 (2008): 414-427.
</p>
<p>Cameron, A.Colin &amp; Douglas L. Miller. &quot;A practitioner's
guide to cluster-robust inference&quot; Journal of Human Resources (2015)
<a href="https://doi.org/10.3368/jhr.50.2.317">doi:10.3368/jhr.50.2.317</a>
</p>
<p>Davidson &amp; MacKinnon. &quot;Wild Bootstrap Tests for IV regression&quot;
Journal of Economics and Business Statistics (2010)
<a href="https://doi.org/10.1198/jbes.2009.07221">doi:10.1198/jbes.2009.07221</a>
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;The wild bootstrap for few (treated) clusters.&quot;
The Econometrics Journal 21.2 (2018): 114-135.
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;Cluster-robust inference: A guide to empirical practice&quot;
Journal of Econometrics (2022)
<a href="https://doi.org/10.1016/j.jeconom.2022.04.001">doi:10.1016/j.jeconom.2022.04.001</a>
</p>
<p>MacKinnon, James. &quot;Wild cluster bootstrap confidence
intervals.&quot; L'Actualite economique 91.1-2 (2015): 11-33.
</p>
<p>Webb, Matthew D. Reworking wild bootstrap based inference
for clustered errors. No. 1315. Queen's Economics Department Working
Paper, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("ivreg")
requireNamespace("fwildclusterboot")

# drop all NA values from SchoolingReturns
SchoolingReturns &lt;- na.omit(SchoolingReturns)
ivreg_fit &lt;- ivreg(log(wage) ~ education + age +
  ethnicity + smsa + south + parents14 |
  nearcollege + age + ethnicity + smsa
    + south + parents14,
data = SchoolingReturns
)

boot_ivreg &lt;- boottest(
  object = ivreg_fit,
  B = 999,
  param = "education",
  clustid = "kww",
  type = "mammen",
  impose_null = TRUE
)
summary(boot_ivreg)
print(boot_ivreg)
plot(boot_ivreg)
nobs(boot_ivreg)
pval(boot_ivreg)
confint(boot_ivreg)
generics::tidy(boot_ivreg)

## End(Not run)

</code></pre>

<hr>
<h2 id='boottest.lm'>Fast wild cluster bootstrap inference for object of class lm</h2><span id='topic+boottest.lm'></span>

<h3>Description</h3>

<p><code>boottest.lm</code> is a S3 method that allows for fast wild cluster
bootstrap inference for objects of class lm by  implementing
fast wild bootstrap algorithms as developed in Roodman et al., 2019
and MacKinnon, Nielsen &amp; Webb (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
boottest(
  object,
  param,
  B,
  clustid = NULL,
  bootcluster = "max",
  conf_int = TRUE,
  R = NULL,
  r = 0,
  beta0 = NULL,
  sign_level = 0.05,
  type = "rademacher",
  impose_null = TRUE,
  bootstrap_type = "fnw11",
  p_val_type = "two-tailed",
  tol = 1e-06,
  maxiter = 10,
  sampling = "dqrng",
  nthreads = getBoottest_nthreads(),
  ssc = boot_ssc(adj = TRUE, fixef.K = "none", cluster.adj = TRUE, cluster.df =
    "conventional"),
  engine = getBoottest_engine(),
  floattype = "Float64",
  maxmatsize = FALSE,
  bootstrapc = FALSE,
  getauxweights = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boottest.lm_+3A_object">object</code></td>
<td>
<p>An object of class lm</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_param">param</code></td>
<td>
<p>A character vector or rhs formula. The name of the regression
coefficient(s) for which the hypothesis is to be tested</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_b">B</code></td>
<td>
<p>Integer. The number of bootstrap iterations. When the number of
clusters is low,
increasing B adds little additional runtime.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_clustid">clustid</code></td>
<td>
<p>A character vector or rhs formula containing the names of
the cluster variables. If NULL,
a heteroskedasticity-robust (HC1) wild bootstrap is run.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_bootcluster">bootcluster</code></td>
<td>
<p>A character vector or rhs formula of length 1. Specifies
the bootstrap clustering variable or variables. If more
than one variable is specified, then bootstrapping is clustered by
the intersections of
clustering implied by the listed variables. To mimic the behavior
of stata's boottest command,
the default is to cluster by the intersection of all the variables
specified via the <code>clustid</code> argument,
even though that is not necessarily recommended (see the paper by
Roodman et al cited below, section 4.2).
Other options include &quot;min&quot;, where bootstrapping is clustered by
the cluster variable with the fewest clusters.
Further, the subcluster bootstrap (MacKinnon &amp; Webb, 2018) is
supported - see the <code>vignette("fwildclusterboot", package = "fwildclusterboot")</code> for details.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_conf_int">conf_int</code></td>
<td>
<p>A logical vector. If TRUE, boottest computes confidence
intervals by test inversion. If FALSE, only the p-value is returned.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_r">R</code></td>
<td>
<p>Hypothesis Vector giving linear combinations of coefficients.
Must be either NULL or a vector of the same length as <code>param</code>. If NULL,
a vector of ones of length param.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_r">r</code></td>
<td>
<p>A numeric. Shifts the null hypothesis
H0: param = r vs H1: param != r</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_beta0">beta0</code></td>
<td>
<p>Deprecated function argument. Replaced by function argument 'r'.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_sign_level">sign_level</code></td>
<td>
<p>A numeric between 0 and 1 which sets the significance level
of the inference procedure. E.g. sign_level = 0.05
returns 0.95% confidence intervals. By default, sign_level = 0.05.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_type">type</code></td>
<td>
<p>character or function. The character string specifies the type
of boostrap to use: One of &quot;rademacher&quot;, &quot;mammen&quot;, &quot;norm&quot;
and &quot;webb&quot;. Alternatively, type can be a function(n) for drawing
wild bootstrap factors. &quot;rademacher&quot; by default.
For the Rademacher distribution, if the number of replications B
exceeds the number of possible draw ombinations, 2^(#number
of clusters), then <code>boottest()</code>
will use each possible combination once (enumeration).</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_impose_null">impose_null</code></td>
<td>
<p>Logical. Controls if the null hypothesis is imposed on
the bootstrap dgp or not. Null imposed <code>(WCR)</code> by default.
If FALSE, the null is not imposed <code>(WCU)</code></p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_bootstrap_type">bootstrap_type</code></td>
<td>
<p>Determines which wild cluster bootstrap type should be
run. Options are &quot;fnw11&quot;,&quot;11&quot;, &quot;13&quot;, &quot;31&quot; and &quot;33&quot; for the wild cluster
bootstrap and &quot;11&quot; and &quot;31&quot; for the heteroskedastic bootstrap.
For more information, see the details section. &quot;fnw11&quot; is the default for
the cluster bootstrap, which runs a &quot;11&quot; type
wild cluster bootstrap via the algorithm outlined in &quot;fast and wild&quot;
(Roodman et al (2019)). &quot;11&quot; is the default for the heteroskedastic
bootstrap.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_p_val_type">p_val_type</code></td>
<td>
<p>Character vector of length 1. Type of p-value.
By default &quot;two-tailed&quot;. Other options include &quot;equal-tailed&quot;,
&quot;&gt;&quot; and &quot;&lt;&quot;.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_tol">tol</code></td>
<td>
<p>Numeric vector of length 1. The desired accuracy
(convergence tolerance) used in the root finding procedure to find
the confidence interval.
1e-6 by default.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer. Maximum number of iterations used in the root
finding procedure to find the confidence interval.
10 by default.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_sampling">sampling</code></td>
<td>
<p>'dqrng' or 'standard'. If 'dqrng', the 'dqrng' package is
used for random number generation (when available). If 'standard',
functions from the 'stats' package are used when available.
This argument is mostly a convenience to control random number generation in
a wrapper package around <code>fwildclusterboot</code>, <code>wildrwolf</code>.
I recommend to use the fast' option.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than,
or equal to, the maximum number of threads; b) 0: meaning
all available threads will be used; c) a number strictly
between 0 and 1 which represents the fraction of all threads
to use. The default is to use 1 core.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>boot_ssc.type</code> obtained with the function
<code><a href="#topic+boot_ssc">boot_ssc()</a></code>. Represents how the small sample
adjustments are computed. The defaults are <code style="white-space: pre;">&#8288;adj = TRUE, fixef.K = "none", cluster.adj = "TRUE", cluster.df = "conventional"&#8288;</code>.
You can find more details in the help file for <code>boot_ssc()</code>.
The function is purposefully designed to mimic fixest's
<code><a href="fixest.html#topic+ssc">fixest::ssc()</a></code> function.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_engine">engine</code></td>
<td>
<p>Character scalar. Either &quot;R&quot;, &quot;R-lean&quot; or &quot;WildBootTests.jl&quot;.
Controls if <code>boottest()</code> should run via its native R implementation
or <code>WildBootTests.jl</code>.
&quot;R&quot; is the default and implements the cluster bootstrap
as in Roodman (2019). &quot;WildBootTests.jl&quot; executes the
wild cluster bootstrap via the WildBootTests.jl
package. For it to run, Julia and WildBootTests.jl need
to be installed.
The &quot;R-lean&quot; algorithm is a memory friendly, but less
performant rcpp-armadillo based implementation of the wild
cluster bootstrap.
Note that if no cluster is provided, boottest() always
defaults to the &quot;lean&quot; algorithm. You can set the employed
algorithm globally by using the
<code>setBoottest_engine()</code> function.</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_floattype">floattype</code></td>
<td>
<p>Float64 by default. Other option: Float32. Should floating
point numbers in Julia be represented as 32 or 64 bit? Only relevant when
'engine= &quot;WildBootTests.jl&quot;'</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_maxmatsize">maxmatsize</code></td>
<td>
<p>NULL by default = no limit. Else numeric scalar to set
the maximum size of auxilliary weight matrix (v), in gigabytes. Only
relevant when 'engine= &quot;WildBootTests.jl&quot;'</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_bootstrapc">bootstrapc</code></td>
<td>
<p>Logical scalar, FALSE by default. TRUE  to request
bootstrap-c instead of bootstrap-t. Only relevant when 'engine =
&quot;WildBootTests.jl&quot;'</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_getauxweights">getauxweights</code></td>
<td>
<p>Logical. Whether to save auxilliary weight matrix (v)</p>
</td></tr>
<tr><td><code id="boottest.lm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>boottest</code>
</p>
<table>
<tr><td><code>p_val</code></td>
<td>
<p>The bootstrap p-value.</p>
</td></tr>
<tr><td><code>conf_int</code></td>
<td>
<p>The bootstrap confidence interval.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>The tested parameter.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Sample size. Might differ from the regression sample size if
the cluster variables contain NA values.</p>
</td></tr>
<tr><td><code>boot_iter</code></td>
<td>
<p>Number of Bootstrap Iterations.</p>
</td></tr>
<tr><td><code>clustid</code></td>
<td>
<p>Names of the cluster Variables.</p>
</td></tr>
<tr><td><code>N_G</code></td>
<td>
<p>Dimension of the cluster variables as used in boottest.</p>
</td></tr>
<tr><td><code>sign_level</code></td>
<td>
<p>Significance level used in boottest.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Distribution of the bootstrap weights.</p>
</td></tr>
<tr><td><code>impose_null</code></td>
<td>
<p>Whether the null was imposed on the bootstrap dgp or not.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>The vector &quot;R&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The scalar &quot;r&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>point_estimate</code></td>
<td>
<p>R'beta. A scalar: the constraints vector times the
regression coefficients.</p>
</td></tr>
<tr><td><code>grid_vals</code></td>
<td>
<p>All t-statistics calculated while calculating the
confidence interval.</p>
</td></tr>
<tr><td><code>p_grid_vals</code></td>
<td>
<p>All p-values calculated while calculating the confidence
interval.</p>
</td></tr>
<tr><td><code>t_stat</code></td>
<td>
<p>The 'original' regression test statistics.</p>
</td></tr>
<tr><td><code>t_boot</code></td>
<td>
<p>All bootstrap t-statistics.</p>
</td></tr>
<tr><td><code>regression</code></td>
<td>
<p>The regression object used in boottest.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Function call of boottest.</p>
</td></tr>
<tr><td><code>engine</code></td>
<td>
<p>The employed bootstrap algorithm.</p>
</td></tr>
<tr><td><code>nthreads</code></td>
<td>
<p>The number of threads employed.</p>
</td></tr>
</table>


<h3>Setting Seeds</h3>

<p>To guarantee reproducibility, you need to
set a global random seed via
</p>

<ul>
<li> <p><code>set.seed()</code> when using
</p>

<ol>
<li><p> the lean algorithm (via <code>engine = "R-lean"</code>) including the
heteroskedastic wild bootstrap
</p>
</li>
<li><p> the wild cluster bootstrap via <code>engine = "R"</code> with Mammen weights or
</p>
</li>
<li> <p><code>engine = "WildBootTests.jl"</code>
</p>
</li></ol>

</li>
<li> <p><code>dqrng::dqset.seed()</code> when using <code>engine = "R"</code> for Rademacher,
Webb or Normal weights
</p>
</li></ul>

<p>Via the <code>engine</code> function argument, it is possible to specify different
variants of the wild cluster bootstrap, and if the algorithm should
be run via R or <code>WildBootTests.jl</code>.
</p>


<h3>Confidence Intervals</h3>

<p><code>boottest</code> computes confidence intervals by inverting p-values.
In practice, the following procedure is used:
</p>

<ul>
<li><p> Based on an initial guess for starting values, calculate p-values
for 26 equal spaced points between the starting values.
</p>
</li>
<li><p> Out of the 26 calculated p-values, find the two pairs of values x
for which the corresponding p-values px cross the significance level
sign_level.
</p>
</li>
<li><p> Feed the two pairs of x into an numerical root finding procedure and
solve for the root. boottest currently relies on
<code>stats::uniroot</code> and sets an absolute tolerance of 1e-06 and
stops the procedure after 10 iterations.
</p>
</li></ul>



<h3>Standard Errors</h3>

<p><code>boottest</code> does not calculate standard errors.
</p>


<h3>Stata, Julia and Python Implementations</h3>

<p>The fast wild cluster bootstrap algorithms are further implemented in the
following software packages:
</p>

<ul>
<li><p> Stata:<a href="https://github.com/droodman/boottest">boottest</a>
</p>
</li>
<li><p> Julia:<a href="https://github.com/droodman/WildBootTests.jl">WildBootTests.jl</a>
</p>
</li>
<li><p> Python:<a href="https://github.com/s3alfisc/wildboottest">wildboottest</a>
</p>
</li></ul>



<h3>References</h3>

<p>Roodman et al., 2019, &quot;Fast and wild: Bootstrap inference in
STATA using boottest&quot;, The STATA Journal.
(<a href="https://ideas.repec.org/p/qed/wpaper/1406.html">https://ideas.repec.org/p/qed/wpaper/1406.html</a>)
</p>
<p>MacKinnon, James G., Morten Ørregaard Nielsen, and
Matthew D. Webb. Fast and reliable jackknife and bootstrap
methods for cluster-robust inference. No. 1485. 2022.
</p>
<p>Cameron, A. Colin, Jonah B. Gelbach, and Douglas L. Miller.
&quot;Bootstrap-based improvements for inference with clustered errors.&quot;
The Review of Economics and Statistics 90.3 (2008): 414-427.
</p>
<p>Cameron, A.Colin &amp; Douglas L. Miller. &quot;A practitioner's
guide to cluster-robust inference&quot; Journal of Human Resources (2015)
<a href="https://doi.org/10.3368/jhr.50.2.317">doi:10.3368/jhr.50.2.317</a>
</p>
<p>Davidson &amp; MacKinnon. &quot;Wild Bootstrap Tests for IV
regression&quot; Journal of Economics and Business Statistics (2010)
<a href="https://doi.org/10.1198/jbes.2009.07221">doi:10.1198/jbes.2009.07221</a>
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;The wild bootstrap for few (treated) clusters.&quot;
The Econometrics Journal 21.2 (2018): 114-135.
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;Cluster-robust inference: A guide to empirical practice&quot;
Journal of Econometrics (2022)
<a href="https://doi.org/10.1016/j.jeconom.2022.04.001">doi:10.1016/j.jeconom.2022.04.001</a>
</p>
<p>MacKinnon, James. &quot;Wild cluster bootstrap confidence intervals.&quot;
L'Actualite economique 91.1-2 (2015): 11-33.
</p>
<p>Webb, Matthew D. Reworking wild bootstrap based inference for
clustered errors. No. 1315. Queen's Economics Department Working Paper, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(proposition_vote ~ treatment + ideology1 + log_income +
  Q1_immigration,
data = voters
)
boot1 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
boot2 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = c("group_id1", "group_id2")
)
boot3 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = c("group_id1", "group_id2"),
  sign_level = 0.2,
  r = 2
)
# test treatment + ideology1 = 2
boot4 &lt;- boottest(lm_fit,
  B = 9999,
  clustid = c("group_id1", "group_id2"),
  param = c("treatment", "ideology1"),
  R = c(1, 1),
  r = 2
)
summary(boot1)
print(boot1)
plot(boot1)
nobs(boot1)
pval(boot1)
confint(boot1)
generics::tidy(boot1)

# run different bootstrap types following MacKinnon, Nielsen &amp; Webb (2022):

# default: the fnw algorithm
boot_fnw11 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1", 
  bootstrap_type = "fnw11"
)

# WCR 31 
boot_WCR31 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1",
  bootstrap_type = "31"
)

# WCU33 
boot_WCR31 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1",
  bootstrap_type = "33", 
  impose_null = FALSE
)


## End(Not run)
</code></pre>

<hr>
<h2 id='confint.boottest'>S3 method to obtain wild cluster bootstrapped confidence intervals</h2><span id='topic+confint.boottest'></span>

<h3>Description</h3>

<p>S3 method to obtain wild cluster bootstrapped confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boottest'
confint(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.boottest_+3A_object">object</code></td>
<td>
<p>object of type boottest</p>
</td></tr>
<tr><td><code id="confint.boottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the boundaries of the wild cluster
bootstrapped confidence interval
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
  proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
boot &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
teststat(boot)

</code></pre>

<hr>
<h2 id='find_proglang'>Check if julia or python are installed /
can be found on the PATH.</h2><span id='topic+find_proglang'></span>

<h3>Description</h3>

<p>Based on Mauro Lepore's great suggestion
https://github.com/ropensci/software-review/issues/546#issuecomment-1416728843
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_proglang(lang)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_proglang_+3A_lang">lang</code></td>
<td>
<p>which language to check. Either 'julia' or 'python'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical. TRUE if lang is found on path, FALSE if not
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
find_proglang(lang = "julia")

## End(Not run)
</code></pre>

<hr>
<h2 id='glance.boottest'>S3 method to glance at objects of class boottest</h2><span id='topic+glance.boottest'></span>

<h3>Description</h3>

<p>S3 method to glance at objects of class boottest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boottest'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.boottest_+3A_x">x</code></td>
<td>
<p>object of type boottest</p>
</td></tr>
<tr><td><code id="glance.boottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single row summary &quot;glance&quot; of an object of type boottest
- lists characteristics of the input regression model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
boot &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
generics::glance(boot)

## End(Not run)
</code></pre>

<hr>
<h2 id='glance.mboottest'>S3 method to glance at objects of class boottest</h2><span id='topic+glance.mboottest'></span>

<h3>Description</h3>

<p>S3 method to glance at objects of class boottest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mboottest'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.mboottest_+3A_x">x</code></td>
<td>
<p>object of type mboottest</p>
</td></tr>
<tr><td><code id="glance.mboottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single row summary &quot;glance&quot; of an object of type boottest
- lists characteristics of the input regression model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
mboot &lt;- mboottest(
    object = lm_fit,
    clustid = "group_id1",
    B = 999,
    R = R
)
generics::glance(mboot)

## End(Not run)
</code></pre>

<hr>
<h2 id='mboottest'>Arbitrary Linear Hypothesis Testing for Regression Models via Wald-Tests</h2><span id='topic+mboottest'></span>

<h3>Description</h3>

<p><code>mboottest</code> is a S3 method that allows for arbitrary linear
hypothesis testing
for objects of class lm, fixest, felm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mboottest(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mboottest_+3A_object">object</code></td>
<td>
<p>An object of type lm, fixest or felm</p>
</td></tr>
<tr><td><code id="mboottest_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mboottest</code>.
</p>


<h3>Setting Seeds</h3>

<p>To guarantee reproducibility, you can either use <code style="white-space: pre;">&#8288;boottest()'s&#8288;</code> <code>seed</code>
function argument, or
set a global random seed via
</p>

<ul>
<li> <p><code>set.seed()</code> when using
</p>

<ol>
<li><p> the lean algorithm (via <code>engine = "R-lean"</code>),
</p>
</li>
<li><p> the heteroskedastic wild bootstrap
</p>
</li>
<li><p> the wild cluster bootstrap via <code>engine = "R"</code> with Mammen weights or
</p>
</li>
<li> <p><code>engine = "WildBootTests.jl"</code>
</p>
</li></ol>

</li>
<li> <p><code>dqrng::dqset.seed()</code> when using <code>engine = "R"</code> for Rademacher,
Webb or Normal weights
</p>
</li></ul>



<h3>References</h3>

<p>Roodman et al., 2019, &quot;Fast and wild: Bootstrap inference in
STATA using boottest&quot;, The STATA Journal.
(<a href="https://ideas.repec.org/p/qed/wpaper/1406.html">https://ideas.repec.org/p/qed/wpaper/1406.html</a>)
</p>
<p>Cameron, A. Colin, Jonah B. Gelbach, and Douglas L. Miller.
&quot;Bootstrap-based improvements for inference with clustered errors.&quot;
The Review of Economics and Statistics 90.3 (2008): 414-427.
</p>
<p>Cameron, A.Colin &amp; Douglas L. Miller.
&quot;A practitioner's guide to cluster-robust inference&quot;
Journal of Human Resources (2015) <a href="https://doi.org/10.3368/jhr.50.2.317">doi:10.3368/jhr.50.2.317</a>
</p>
<p>Davidson &amp; MacKinnon. &quot;Wild Bootstrap Tests for IV regression&quot;
Journal of Economics and Business Statistics (2010)
<a href="https://doi.org/10.1198/jbes.2009.07221">doi:10.1198/jbes.2009.07221</a>
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;The wild bootstrap for few (treated) clusters.&quot;
The Econometrics Journal 21.2 (2018): 114-135.
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;Cluster-robust inference: A guide to empirical practice&quot;
Journal of Econometrics (2022)
<a href="https://doi.org/10.1016/j.jeconom.2022.04.001">doi:10.1016/j.jeconom.2022.04.001</a>
</p>
<p>MacKinnon, James. &quot;Wild cluster bootstrap confidence intervals.&quot;
L'Actualite economique 91.1-2 (2015): 11-33.
</p>
<p>Webb, Matthew D.
&quot;Reworking wild bootstrap based inference for clustered errors&quot;
. No. 1315. Queen's Economics Department Working Paper, 2013.
</p>


<h3>See Also</h3>

<p><a href="#topic+mboottest.lm">mboottest.lm</a>
<a href="#topic+mboottest.felm">mboottest.felm</a>
<a href="#topic+mboottest.fixest">mboottest.fixest</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("clubSandwich")
R &lt;- clubSandwich::constrain_zero(2:3, coef(lm_fit))
wboottest &lt;-
  mboottest(
    object = lm_fit,
    clustid = "group_id1",
    B = 999,
    R = R
  )
summary(wboottest)
print(wboottest)
nobs(wboottest)
pval(wboottest)
generics::tidy(wboottest)

## End(Not run)

</code></pre>

<hr>
<h2 id='mboottest.felm'>Fast wild cluster bootstrap inference for joint hypotheses for object of
class felm</h2><span id='topic+mboottest.felm'></span>

<h3>Description</h3>

<p><code>mboottest.felm</code> is a S3 method that allows for fast wild cluster
bootstrap inference of multivariate hypotheses for objects of class felm by
implementing the fast wild bootstrap algorithm developed in
Roodman et al., 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'felm'
mboottest(
  object,
  clustid,
  B,
  R,
  r = rep(0, nrow(R)),
  bootcluster = "max",
  fe = NULL,
  type = "rademacher",
  impose_null = TRUE,
  p_val_type = "two-tailed",
  tol = 1e-06,
  floattype = "Float64",
  getauxweights = FALSE,
  maxmatsize = NULL,
  bootstrapc = FALSE,
  ssc = boot_ssc(adj = TRUE, fixef.K = "none", cluster.adj = TRUE, cluster.df =
    "conventional"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mboottest.felm_+3A_object">object</code></td>
<td>
<p>An object of class felm</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_clustid">clustid</code></td>
<td>
<p>A character vector or rhs formula containing the names of
the cluster variables</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_b">B</code></td>
<td>
<p>Integer. The number of bootstrap iterations. When the number of
clusters is low,
increasing B adds little additional runtime.</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_r">R</code></td>
<td>
<p>Hypothesis Vector or Matrix giving linear combinations of
coefficients. Must be either a vector of length k or a matrix of dimension
q x k, where q is the number
of joint hypotheses and k the number of estimated coefficients.</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_r">r</code></td>
<td>
<p>A vector of length q, where q is the number of tested hypotheses.
Shifts the null hypothesis
H0: param = r vs H1: param != r. If not provided, a vector of zeros
of length q.</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_bootcluster">bootcluster</code></td>
<td>
<p>A character vector or rhs formula of length 1. Specifies
the bootstrap clustering variable or variables. If more
than one variable is specified, then bootstrapping is clustered by
the intersections of
clustering implied by the listed variables. To mimic the behavior of
stata's boottest command,
the default is to cluster by the intersection of all the variables
specified via the <code>clustid</code> argument,
even though that is not necessarily recommended (see the paper by
Roodman et al cited below, section 4.2).
Other options include &quot;min&quot;, where bootstrapping is clustered by the
cluster variable with the fewest clusters.
Further, the subcluster bootstrap (MacKinnon &amp; Webb, 2018) is
supported - see the <code>vignette("fwildclusterboot", package = "fwildclusterboot")</code> for details.</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_fe">fe</code></td>
<td>
<p>A character vector or rhs formula of length one which contains
the name of the fixed effect to be projected
out in the bootstrap. Note: if regression weights are used, fe
needs to be NULL.</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_type">type</code></td>
<td>
<p>character or function. The character string specifies the type
of boostrap to use: One of &quot;rademacher&quot;, &quot;mammen&quot;, &quot;norm&quot;, &quot;gamma&quot;
and &quot;webb&quot;. Alternatively, type can be a function(n) for drawing
wild bootstrap factors. &quot;rademacher&quot; by default.
For the Rademacher and Mammen distribution, if the number of
replications B exceeds
the number of possible draw ombinations, 2^(#number of clusters),
then <code>boottest()</code>
will use each possible combination once (enumeration).</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_impose_null">impose_null</code></td>
<td>
<p>Logical. Controls if the null hypothesis is imposed on
the bootstrap dgp or not. Null imposed <code>(WCR)</code> by default.
If FALSE, the null is not imposed <code>(WCU)</code></p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_p_val_type">p_val_type</code></td>
<td>
<p>Character vector of length 1. Type of p-value.
By default &quot;two-tailed&quot;. Other options include &quot;equal-tailed&quot;, &quot;&gt;&quot;
and &quot;&lt;&quot;.</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_tol">tol</code></td>
<td>
<p>Numeric vector of length 1. The desired accuracy
(convergence tolerance) used in the root finding procedure to find
the confidence interval.
Relative tolerance of 1e-6 by default.</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_floattype">floattype</code></td>
<td>
<p>Float64 by default. Other option: Float32. Should floating
point numbers in Julia be represented as 32 or 64 bit?</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_getauxweights">getauxweights</code></td>
<td>
<p>Logical. FALSE by default. Whether to save auxilliary
weight matrix (v)</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_maxmatsize">maxmatsize</code></td>
<td>
<p>NULL by default = no limit. Else numeric scalar to set
the maximum size of auxilliary weight matrix (v), in gigabytes</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_bootstrapc">bootstrapc</code></td>
<td>
<p>Logical scalar, FALSE by default. TRUE  to request
bootstrap-c instead of bootstrap-t</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>boot_ssc.type</code> obtained with the function
<code><a href="#topic+boot_ssc">boot_ssc()</a></code>. Represents how the small sample
adjustments are computed. The defaults are <code style="white-space: pre;">&#8288;adj = TRUE, fixef.K = "none", cluster.adj = "TRUE", cluster.df = "conventional"&#8288;</code>.
You can find more details in the help file for <code>boot_ssc()</code>.
The function is purposefully designed to mimic fixest's
<code><a href="fixest.html#topic+ssc">fixest::ssc()</a></code> function.</p>
</td></tr>
<tr><td><code id="mboottest.felm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mboottest</code>
</p>
<table>
<tr><td><code>p_val</code></td>
<td>
<p>The bootstrap p-value.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Sample size. Might differ from the regression sample size if
the cluster variables contain NA values.</p>
</td></tr>
<tr><td><code>boot_iter</code></td>
<td>
<p>Number of Bootstrap Iterations.</p>
</td></tr>
<tr><td><code>clustid</code></td>
<td>
<p>Names of the cluster Variables.</p>
</td></tr>
<tr><td><code>N_G</code></td>
<td>
<p>Dimension of the cluster variables as used in boottest.</p>
</td></tr>
<tr><td><code>sign_level</code></td>
<td>
<p>Significance level used in boottest.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Distribution of the bootstrap weights.</p>
</td></tr>
<tr><td><code>impose_null</code></td>
<td>
<p>Whether the null was imposed on the bootstrap dgp or not.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>The vector &quot;R&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The scalar &quot;r&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>point_estimate</code></td>
<td>
<p>R'beta. A scalar: the constraints vector times the
regression coefficients.</p>
</td></tr>
<tr><td><code>teststat_stat</code></td>
<td>
<p>The 'original' regression test statistics.</p>
</td></tr>
<tr><td><code>teststat_boot</code></td>
<td>
<p>All bootstrap t-statistics.</p>
</td></tr>
<tr><td><code>regression</code></td>
<td>
<p>The regression object used in boottest.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Function call of boottest.</p>
</td></tr>
</table>


<h3>Setting Seeds</h3>

<p>To guarantee reproducibility, you need to
set a global random seed via <code>set.seed()</code> when using
</p>


<h3>References</h3>

<p>Roodman et al., 2019, &quot;Fast and wild: Bootstrap inference in
STATA using boottest&quot;, The STATA Journal.
(<a href="https://ideas.repec.org/p/qed/wpaper/1406.html">https://ideas.repec.org/p/qed/wpaper/1406.html</a>)
</p>
<p>Cameron, A. Colin, Jonah B. Gelbach, and Douglas L. Miller.
&quot;Bootstrap-based improvements for inference with clustered errors.&quot;
The Review of Economics and Statistics 90.3 (2008): 414-427.
</p>
<p>Cameron, A.Colin &amp; Douglas L. Miller.
&quot;A practitioner's guide to cluster-robust inference&quot;
Journal of Human Resources (2015) <a href="https://doi.org/10.3368/jhr.50.2.317">doi:10.3368/jhr.50.2.317</a>
</p>
<p>Davidson &amp; MacKinnon. &quot;Wild Bootstrap Tests for IV regression&quot;
Journal of Economics and Business Statistics (2010)
<a href="https://doi.org/10.1198/jbes.2009.07221">doi:10.1198/jbes.2009.07221</a>
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;The wild bootstrap for few (treated) clusters.&quot;
The Econometrics Journal 21.2 (2018): 114-135.
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;Cluster-robust inference: A guide to empirical practice&quot;
Journal of Econometrics (2022)
<a href="https://doi.org/10.1016/j.jeconom.2022.04.001">doi:10.1016/j.jeconom.2022.04.001</a>
</p>
<p>MacKinnon, James. &quot;Wild cluster bootstrap confidence intervals.&quot;
L'Actualite economique 91.1-2 (2015): 11-33.
</p>
<p>Webb, Matthew D.
&quot;Reworking wild bootstrap based inference for clustered errors&quot;
. No. 1315. Queen's Economics Department Working Paper, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("lfe")
requireNamespace("clubSandwich")
R &lt;- clubSandwich::constrain_zero(2:3, coef(lm_fit))
wboottest &lt;-
  mboottest(
    object = lm_fit,
    clustid = "group_id1",
    B = 999,
    R = R
  )
summary(wboottest)
print(wboottest)
nobs(wboottest)
pval(wboottest)
generics::tidy(wboottest)

## End(Not run)

</code></pre>

<hr>
<h2 id='mboottest.fixest'>Fast wild cluster bootstrap inference for joint hypotheses for object
of class fixest</h2><span id='topic+mboottest.fixest'></span>

<h3>Description</h3>

<p><code>mboottest.fixest</code> is a S3 method that allows for fast wild cluster
bootstrap inference of multivariate hypotheses for objects of class
fixest by implementing the fast wild bootstrap algorithm developed
in Roodman et al., 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
mboottest(
  object,
  clustid,
  B,
  R,
  r = rep(0, nrow(R)),
  bootcluster = "max",
  fe = NULL,
  type = "rademacher",
  impose_null = TRUE,
  p_val_type = "two-tailed",
  tol = 1e-06,
  floattype = "Float64",
  getauxweights = FALSE,
  maxmatsize = NULL,
  bootstrapc = FALSE,
  ssc = boot_ssc(adj = TRUE, fixef.K = "none", cluster.adj = TRUE, cluster.df =
    "conventional"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mboottest.fixest_+3A_object">object</code></td>
<td>
<p>An object of class feols</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_clustid">clustid</code></td>
<td>
<p>A character vector or rhs formula containing the names of
the cluster variables</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_b">B</code></td>
<td>
<p>Integer. The number of bootstrap iterations. When the number of
clusters is low,
increasing B adds little additional runtime.</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_r">R</code></td>
<td>
<p>Hypothesis Vector or Matrix giving linear combinations of
coefficients. Must be either a vector of length k or a matrix of dimension
q x k, where q is the number
of joint hypotheses and k the number of estimated coefficients.</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_r">r</code></td>
<td>
<p>A vector of length q, where q is the number of tested hypotheses.
Shifts the null hypothesis
H0: param = r vs H1: param != r. If not provided, a vector of zeros
of length q.</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_bootcluster">bootcluster</code></td>
<td>
<p>A character vector or rhs formula of length 1. Specifies
the bootstrap clustering variable or variables. If more
than one variable is specified, then bootstrapping is clustered by
the intersections of
clustering implied by the listed variables. To mimic the behavior of
stata's boottest command,
the default is to cluster by the intersection of all the variables
specified via the <code>clustid</code> argument,
even though that is not necessarily recommended (see the paper by
Roodman et al cited below, section 4.2).
Other options include &quot;min&quot;, where bootstrapping is clustered by the
cluster variable with the fewest clusters.
Further, the subcluster bootstrap (MacKinnon &amp; Webb, 2018) is
supported - see the <code>vignette("fwildclusterboot", package = "fwildclusterboot")</code> for details.</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_fe">fe</code></td>
<td>
<p>A character vector or rhs formula of length one which contains
the name of the fixed effect to be projected
out in the bootstrap. Note: if regression weights are used, fe
needs to be NULL.</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_type">type</code></td>
<td>
<p>character or function. The character string specifies the type
of boostrap to use: One of &quot;rademacher&quot;, &quot;mammen&quot;, &quot;norm&quot;, &quot;gamma&quot;
and &quot;webb&quot;. Alternatively, type can be a function(n) for drawing
wild bootstrap factors. &quot;rademacher&quot; by default.
For the Rademacher and Mammen distribution, if the number of
replications B exceeds
the number of possible draw ombinations, 2^(#number of clusters),
then <code>boottest()</code>
will use each possible combination once (enumeration).</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_impose_null">impose_null</code></td>
<td>
<p>Logical. Controls if the null hypothesis is imposed on
the bootstrap dgp or not. Null imposed <code>(WCR)</code> by default.
If FALSE, the null is not imposed <code>(WCU)</code></p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_p_val_type">p_val_type</code></td>
<td>
<p>Character vector of length 1. Type of p-value.
By default &quot;two-tailed&quot;. Other options include &quot;equal-tailed&quot;, &quot;&gt;&quot;
and &quot;&lt;&quot;.</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_tol">tol</code></td>
<td>
<p>Numeric vector of length 1. The desired accuracy
(convergence tolerance) used in the root finding procedure to find
the confidence interval.
Relative tolerance of 1e-6 by default.</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_floattype">floattype</code></td>
<td>
<p>Float64 by default. Other option: Float32. Should floating
point numbers in Julia be represented as 32 or 64 bit?</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_getauxweights">getauxweights</code></td>
<td>
<p>Logical. FALSE by default. Whether to save auxilliary
weight matrix (v)</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_maxmatsize">maxmatsize</code></td>
<td>
<p>NULL by default = no limit. Else numeric scalar to set
the maximum size of auxilliary weight matrix (v), in gigabytes</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_bootstrapc">bootstrapc</code></td>
<td>
<p>Logical scalar, FALSE by default. TRUE  to request
bootstrap-c instead of bootstrap-t</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>boot_ssc.type</code> obtained with the function
<code><a href="#topic+boot_ssc">boot_ssc()</a></code>. Represents how the small sample
adjustments are computed. The defaults are <code style="white-space: pre;">&#8288;adj = TRUE, fixef.K = "none", cluster.adj = "TRUE", cluster.df = "conventional"&#8288;</code>.
You can find more details in the help file for <code>boot_ssc()</code>.
The function is purposefully designed to mimic fixest's
<code><a href="fixest.html#topic+ssc">fixest::ssc()</a></code> function.</p>
</td></tr>
<tr><td><code id="mboottest.fixest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mboottest</code>
</p>
<table>
<tr><td><code>p_val</code></td>
<td>
<p>The bootstrap p-value.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Sample size. Might differ from the regression sample size if
the cluster variables contain NA values.</p>
</td></tr>
<tr><td><code>boot_iter</code></td>
<td>
<p>Number of Bootstrap Iterations.</p>
</td></tr>
<tr><td><code>clustid</code></td>
<td>
<p>Names of the cluster Variables.</p>
</td></tr>
<tr><td><code>N_G</code></td>
<td>
<p>Dimension of the cluster variables as used in boottest.</p>
</td></tr>
<tr><td><code>sign_level</code></td>
<td>
<p>Significance level used in boottest.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Distribution of the bootstrap weights.</p>
</td></tr>
<tr><td><code>impose_null</code></td>
<td>
<p>Whether the null was imposed on the bootstrap dgp or not.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>The vector &quot;R&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The scalar &quot;r&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>point_estimate</code></td>
<td>
<p>R'beta. A scalar: the constraints vector times the
regression coefficients.</p>
</td></tr>
<tr><td><code>teststat_stat</code></td>
<td>
<p>The 'original' regression test statistics.</p>
</td></tr>
<tr><td><code>teststat_boot</code></td>
<td>
<p>All bootstrap t-statistics.</p>
</td></tr>
<tr><td><code>regression</code></td>
<td>
<p>The regression object used in boottest.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Function call of boottest.</p>
</td></tr>
</table>


<h3>Setting Seeds</h3>

<p>To guarantee reproducibility, you need to
set a global random seed via<code>set.seed()</code>
</p>


<h3>References</h3>

<p>Roodman et al., 2019, &quot;Fast and wild: Bootstrap inference in
STATA using boottest&quot;, The STATA Journal.
(<a href="https://ideas.repec.org/p/qed/wpaper/1406.html">https://ideas.repec.org/p/qed/wpaper/1406.html</a>)
</p>
<p>Cameron, A. Colin, Jonah B. Gelbach, and Douglas L. Miller.
&quot;Bootstrap-based improvements for inference with clustered errors.&quot;
The Review of Economics and Statistics 90.3 (2008): 414-427.
</p>
<p>Cameron, A.Colin &amp; Douglas L. Miller.
&quot;A practitioner's guide to cluster-robust inference&quot;
Journal of Human Resources (2015) <a href="https://doi.org/10.3368/jhr.50.2.317">doi:10.3368/jhr.50.2.317</a>
</p>
<p>Davidson &amp; MacKinnon. &quot;Wild Bootstrap Tests for IV regression&quot;
Journal of Economics and Business Statistics (2010)
<a href="https://doi.org/10.1198/jbes.2009.07221">doi:10.1198/jbes.2009.07221</a>
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;The wild bootstrap for few (treated) clusters.&quot;
The Econometrics Journal 21.2 (2018): 114-135.
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;Cluster-robust inference: A guide to empirical practice&quot;
Journal of Econometrics (2022)
<a href="https://doi.org/10.1016/j.jeconom.2022.04.001">doi:10.1016/j.jeconom.2022.04.001</a>
</p>
<p>MacKinnon, James. &quot;Wild cluster bootstrap confidence intervals.&quot;
L'Actualite economique 91.1-2 (2015): 11-33.
</p>
<p>Webb, Matthew D.
&quot;Reworking wild bootstrap based inference for clustered errors&quot;
. No. 1315. Queen's Economics Department Working Paper, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("fwildclusterboot")
requireNamespace("clubSandwich")
R &lt;- clubSandwich::constrain_zero(2:3, coef(lm_fit))
wboottest &lt;-
  mboottest(
    object = lm_fit,
    clustid = "group_id1",
    B = 999,
    R = R
  )
summary(wboottest)
print(wboottest)
nobs(wboottest)
pval(wboottest)
generics::tidy(wboottest)

## End(Not run)

</code></pre>

<hr>
<h2 id='mboottest.lm'>Fast wild cluster bootstrap inference of joint hypotheses for object of
class lm</h2><span id='topic+mboottest.lm'></span>

<h3>Description</h3>

<p><code>mboottest.lm</code> is a S3 method that allows for fast wild cluster
bootstrap inference of multivariate hypotheses for objects of class lm by
implementing the fast wild bootstrap algorithm developed in
Roodman et al., 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
mboottest(
  object,
  clustid,
  B,
  R,
  r = rep(0, nrow(R)),
  bootcluster = "max",
  type = "rademacher",
  impose_null = TRUE,
  p_val_type = "two-tailed",
  tol = 1e-06,
  floattype = "Float64",
  getauxweights = FALSE,
  maxmatsize = NULL,
  bootstrapc = FALSE,
  ssc = boot_ssc(adj = TRUE, fixef.K = "none", cluster.adj = TRUE, cluster.df =
    "conventional"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mboottest.lm_+3A_object">object</code></td>
<td>
<p>An object of class lm</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_clustid">clustid</code></td>
<td>
<p>A character vector or rhs formula containing the names of
the cluster variables</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_b">B</code></td>
<td>
<p>Integer. The number of bootstrap iterations. When the number of
clusters is low,
increasing B adds little additional runtime.</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_r">R</code></td>
<td>
<p>Hypothesis Vector or Matrix giving linear combinations of
coefficients. Must be either a vector of length k or a matrix of dimension
q x k, where q is the number
of joint hypotheses and k the number of estimated coefficients.</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_r">r</code></td>
<td>
<p>A vector of length q, where q is the number of tested hypotheses.
Shifts the null hypothesis
H0: param = r vs H1: param != r. If not provided, a vector of zeros
of length q.</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_bootcluster">bootcluster</code></td>
<td>
<p>A character vector or rhs formula of length 1. Specifies
the bootstrap clustering variable or variables. If more
than one variable is specified, then bootstrapping is clustered by
the intersections of
clustering implied by the listed variables. To mimic the behavior of
stata's boottest command,
the default is to cluster by the intersection of all the variables
specified via the <code>clustid</code> argument,
even though that is not necessarily recommended (see the paper by
Roodman et al cited below, section 4.2).
Other options include &quot;min&quot;, where bootstrapping is clustered by the
cluster variable with the fewest clusters.
Further, the subcluster bootstrap (MacKinnon &amp; Webb, 2018) is
supported - see the <code>vignette("fwildclusterboot", package = "fwildclusterboot")</code> for details.</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_type">type</code></td>
<td>
<p>character or function. The character string specifies the type
of boostrap to use: One of &quot;rademacher&quot;, &quot;mammen&quot;, &quot;norm&quot;, &quot;gamma&quot;
and &quot;webb&quot;. Alternatively, type can be a function(n) for drawing
wild bootstrap factors. &quot;rademacher&quot; by default.
For the Rademacher and Mammen distribution, if the number of
replications B exceeds
the number of possible draw ombinations, 2^(#number of clusters),
then <code>boottest()</code>
will use each possible combination once (enumeration).</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_impose_null">impose_null</code></td>
<td>
<p>Logical. Controls if the null hypothesis is imposed on
the bootstrap dgp or not. Null imposed <code>(WCR)</code> by default.
If FALSE, the null is not imposed <code>(WCU)</code></p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_p_val_type">p_val_type</code></td>
<td>
<p>Character vector of length 1. Type of p-value.
By default &quot;two-tailed&quot;. Other options include &quot;equal-tailed&quot;, &quot;&gt;&quot;
and &quot;&lt;&quot;.</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_tol">tol</code></td>
<td>
<p>Numeric vector of length 1. The desired accuracy
(convergence tolerance) used in the root finding procedure to find
the confidence interval.
Relative tolerance of 1e-6 by default.</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_floattype">floattype</code></td>
<td>
<p>Float64 by default. Other option: Float32. Should floating
point numbers in Julia be represented as 32 or 64 bit?</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_getauxweights">getauxweights</code></td>
<td>
<p>Logical. FALSE by default. Whether to save auxilliary
weight matrix (v)</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_maxmatsize">maxmatsize</code></td>
<td>
<p>NULL by default = no limit. Else numeric scalar to set
the maximum size of auxilliary weight matrix (v), in gigabytes</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_bootstrapc">bootstrapc</code></td>
<td>
<p>Logical scalar, FALSE by default. TRUE  to request
bootstrap-c instead of bootstrap-t</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>boot_ssc.type</code> obtained with the function
<code><a href="#topic+boot_ssc">boot_ssc()</a></code>. Represents how the small sample
adjustments are computed. The defaults are <code style="white-space: pre;">&#8288;adj = TRUE, fixef.K = "none", cluster.adj = "TRUE", cluster.df = "conventional"&#8288;</code>.
You can find more details in the help file for <code>boot_ssc()</code>.
The function is purposefully designed to mimic fixest's
<code><a href="fixest.html#topic+ssc">fixest::ssc()</a></code> function.</p>
</td></tr>
<tr><td><code id="mboottest.lm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mboottest</code>
</p>
<table>
<tr><td><code>p_val</code></td>
<td>
<p>The bootstrap p-value.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Sample size. Might differ from the regression sample size if
the cluster variables contain NA values.</p>
</td></tr>
<tr><td><code>boot_iter</code></td>
<td>
<p>Number of Bootstrap Iterations.</p>
</td></tr>
<tr><td><code>clustid</code></td>
<td>
<p>Names of the cluster Variables.</p>
</td></tr>
<tr><td><code>N_G</code></td>
<td>
<p>Dimension of the cluster variables as used in boottest.</p>
</td></tr>
<tr><td><code>sign_level</code></td>
<td>
<p>Significance level used in boottest.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Distribution of the bootstrap weights.</p>
</td></tr>
<tr><td><code>impose_null</code></td>
<td>
<p>Whether the null was imposed on the bootstrap dgp or not.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>The vector &quot;R&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The scalar &quot;r&quot; in the null hypothesis of interest Rbeta = r.</p>
</td></tr>
<tr><td><code>point_estimate</code></td>
<td>
<p>R'beta. A scalar: the constraints vector times the
regression coefficients.</p>
</td></tr>
<tr><td><code>teststat_stat</code></td>
<td>
<p>The 'original' regression test statistics.</p>
</td></tr>
<tr><td><code>teststat_boot</code></td>
<td>
<p>All bootstrap t-statistics.</p>
</td></tr>
<tr><td><code>regression</code></td>
<td>
<p>The regression object used in boottest.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Function call of boottest.</p>
</td></tr>
</table>


<h3>Setting Seeds</h3>

<p>To guarantee reproducibility, you need to
set a global random seed via <code>set.seed()</code>
</p>


<h3>References</h3>

<p>Roodman et al., 2019, &quot;Fast and wild: Bootstrap inference in
STATA using boottest&quot;, The STATA Journal.
(<a href="https://ideas.repec.org/p/qed/wpaper/1406.html">https://ideas.repec.org/p/qed/wpaper/1406.html</a>)
</p>
<p>Cameron, A. Colin, Jonah B. Gelbach, and Douglas L. Miller.
&quot;Bootstrap-based improvements for inference with clustered errors.&quot;
The Review of Economics and Statistics 90.3 (2008): 414-427.
</p>
<p>Cameron, A.Colin &amp; Douglas L. Miller.
&quot;A practitioner's guide to cluster-robust inference&quot;
Journal of Human Resources (2015) <a href="https://doi.org/10.3368/jhr.50.2.317">doi:10.3368/jhr.50.2.317</a>
</p>
<p>Davidson &amp; MacKinnon. &quot;Wild Bootstrap Tests for IV regression&quot;
Journal of Economics and Business Statistics (2010)
<a href="https://doi.org/10.1198/jbes.2009.07221">doi:10.1198/jbes.2009.07221</a>
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;The wild bootstrap for few (treated) clusters.&quot;
The Econometrics Journal 21.2 (2018): 114-135.
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
&quot;Cluster-robust inference: A guide to empirical practice&quot;
Journal of Econometrics (2022)
<a href="https://doi.org/10.1016/j.jeconom.2022.04.001">doi:10.1016/j.jeconom.2022.04.001</a>
</p>
<p>MacKinnon, James. &quot;Wild cluster bootstrap confidence intervals.&quot;
L'Actualite economique 91.1-2 (2015): 11-33.
</p>
<p>Webb, Matthew D.
&quot;Reworking wild bootstrap based inference for clustered errors&quot;
. No. 1315. Queen's Economics Department Working Paper, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("clubSandwich")
requireNamespace("fwildclusterboot")
R &lt;- clubSandwich::constrain_zero(2:3, coef(lm_fit))
wboottest &lt;-
  mboottest(
    object = lm_fit,
    clustid = "group_id1",
    B = 999,
    R = R
  )
summary(wboottest)
print(wboottest)
nobs(wboottest)
pval(wboottest)
generics::tidy(wboottest)

## End(Not run)

</code></pre>

<hr>
<h2 id='nobs.boottest'>S3 method to obtain the effective number of observation used in <code>boottest()</code></h2><span id='topic+nobs.boottest'></span>

<h3>Description</h3>

<p>S3 method to obtain the effective number of observation used in <code>boottest()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boottest'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.boottest_+3A_object">object</code></td>
<td>
<p>object of type boottest</p>
</td></tr>
<tr><td><code id="nobs.boottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar containing the effective number of observations
used in <code>boottest()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
boot &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
nobs(boot)
</code></pre>

<hr>
<h2 id='nobs.mboottest'>S3 method to obtain the effective number of observation used
in <code>mboottest()</code></h2><span id='topic+nobs.mboottest'></span>

<h3>Description</h3>

<p>S3 method to obtain the effective number of observation used
in <code>mboottest()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mboottest'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.mboottest_+3A_object">object</code></td>
<td>
<p>object of type mboottest</p>
</td></tr>
<tr><td><code id="nobs.mboottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar containing the effective number of observations
used in <code>mboottest()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("clubSandwich")
R &lt;- clubSandwich::constrain_zero(2:3, coef(lm_fit))
wboottest &lt;-
  mboottest(
    object = lm_fit,
    clustid = "group_id1",
    B = 999,
    R = R
  )
nobs(wboottest)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.boottest'>Plot the bootstrap distribution of t-statistics</h2><span id='topic+plot.boottest'></span>

<h3>Description</h3>

<p>Plot the bootstrap distribution of t-statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boottest'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.boottest_+3A_x">x</code></td>
<td>
<p>An object of type boottest</p>
</td></tr>
<tr><td><code id="plot.boottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of bootstrap t-statistics under different null hypotheses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
boot &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
plot(boot)
</code></pre>

<hr>
<h2 id='print.boottest'>S3 method to print key information for objects of type <code>bboottest</code></h2><span id='topic+print.boottest'></span>

<h3>Description</h3>

<p>S3 method to print key information for objects of type <code>bboottest</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boottest'
print(x, ..., digits = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.boottest_+3A_x">x</code></td>
<td>
<p>object of type boottest</p>
</td></tr>
<tr><td><code id="print.boottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="print.boottest_+3A_digits">digits</code></td>
<td>
<p>Number of rounding digits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar containing the effective number of observations
used in <code>mboottest</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
  proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
boot &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
print(boot)

</code></pre>

<hr>
<h2 id='print.mboottest'>S3 method to print key information for objects of type <code>mboottest</code></h2><span id='topic+print.mboottest'></span>

<h3>Description</h3>

<p>S3 method to print key information for objects of type <code>mboottest</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mboottest'
print(x, ..., digits = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mboottest_+3A_x">x</code></td>
<td>
<p>object of type mboottest</p>
</td></tr>
<tr><td><code id="print.mboottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="print.mboottest_+3A_digits">digits</code></td>
<td>
<p>Number of rounding digits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar containing the effective number of observations used
in <code>mboottest</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("clubSandwich")
R &lt;- clubSandwich::constrain_zero(2:3, coef(lm_fit))
wboottest &lt;-
  mboottest(
    object = lm_fit,
    clustid = "group_id1",
    B = 999,
    R = R
  )
print(wboottest)

## End(Not run)

</code></pre>

<hr>
<h2 id='pval'><code>pval</code> is a S3 method to collect pvalues for objects
of type <code>boottest</code> and <code>mboottest</code></h2><span id='topic+pval'></span>

<h3>Description</h3>

<p><code>pval</code> is a S3 method to collect pvalues for objects
of type <code>boottest</code> and <code>mboottest</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pval_+3A_object">object</code></td>
<td>
<p>An object of type lm, fixest, felm or ivreg</p>
</td></tr>
<tr><td><code id="pval_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar with the bootstrapped p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
boot &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
pval(boot)
</code></pre>

<hr>
<h2 id='pval.boottest'>S3 method to obtain the wild cluster bootstrapped p-value of an object
of type boottest</h2><span id='topic+pval.boottest'></span>

<h3>Description</h3>

<p>S3 method to obtain the wild cluster bootstrapped p-value of an object
of type boottest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boottest'
pval(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pval.boottest_+3A_object">object</code></td>
<td>
<p>object of type boottest</p>
</td></tr>
<tr><td><code id="pval.boottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the boundaries of the wild cluster
bootstrapped p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
  proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
boot &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
confint(boot)

</code></pre>

<hr>
<h2 id='pval.mboottest'>S3 method to obtain the wild cluster bootstrapped p-value of an object
of type mboottest</h2><span id='topic+pval.mboottest'></span>

<h3>Description</h3>

<p>S3 method to obtain the wild cluster bootstrapped p-value of an object
of type mboottest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mboottest'
pval(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pval.mboottest_+3A_object">object</code></td>
<td>
<p>object of type mboottest</p>
</td></tr>
<tr><td><code id="pval.mboottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the boundaries of the wild cluster
bootstrapped p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("clubSandwich")
R &lt;- clubSandwich::constrain_zero(2:3, coef(lm_fit))
wboottest &lt;-
  mboottest(
    object = lm_fit,
    clustid = "group_id1",
    B = 999,
    R = R
  )
pval(wboottest)

## End(Not run)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+glance'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='setBoottest_engine'>Sets the default bootstrap algo for the current R session
to be run via <code>boottest()</code> and <code>mboottest()</code></h2><span id='topic+setBoottest_engine'></span>

<h3>Description</h3>

<p>Sets the default bootstrap algo for the current R session
to be run via <code>boottest()</code> and <code>mboottest()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setBoottest_engine(engine)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setBoottest_engine_+3A_engine">engine</code></td>
<td>
<p>Character scalar. Either 'R' or 'WildBootTests.jl'.
Default is 'R'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setBoottest_engine(engine = "R")
setBoottest_engine(engine = "WildBootTests.jl")

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.boottest'>S3 method to summarize objects of class boottest</h2><span id='topic+summary.boottest'></span>

<h3>Description</h3>

<p>S3 method to summarize objects of class boottest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boottest'
summary(object, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.boottest_+3A_object">object</code></td>
<td>
<p>object of type boottest</p>
</td></tr>
<tr><td><code id="summary.boottest_+3A_digits">digits</code></td>
<td>
<p>rounding of output. 3 by default</p>
</td></tr>
<tr><td><code id="summary.boottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns result summaries for objects of type boottest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
boot &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
summary(boot)
</code></pre>

<hr>
<h2 id='summary.mboottest'>S3 method to summarize objects of class mboottest</h2><span id='topic+summary.mboottest'></span>

<h3>Description</h3>

<p>S3 method to summarize objects of class mboottest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mboottest'
summary(object, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mboottest_+3A_object">object</code></td>
<td>
<p>object of type mboottest</p>
</td></tr>
<tr><td><code id="summary.mboottest_+3A_digits">digits</code></td>
<td>
<p>rounding of output. 3 by default</p>
</td></tr>
<tr><td><code id="summary.mboottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns result summaries for objects of type mboottest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("clubSandwich")
R &lt;- clubSandwich::constrain_zero(2:3, coef(lm_fit))
wboottest &lt;-
  mboottest(
    object = lm_fit,
    clustid = "group_id1",
    B = 999,
    R = R
  )
summary(wboottest)
print(wboottest)
nobs(wboottest)
pval(wboottest)
generics::tidy(wboottest)

## End(Not run)
</code></pre>

<hr>
<h2 id='teststat'><code>teststat</code> is a S3 method to collect teststats for objects
of type <code>boottest</code> and <code>mboottest</code></h2><span id='topic+teststat'></span>

<h3>Description</h3>

<p><code>teststat</code> is a S3 method to collect teststats for objects
of type <code>boottest</code> and <code>mboottest</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>teststat(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="teststat_+3A_object">object</code></td>
<td>
<p>An object of type lm, fixest, felm or ivreg</p>
</td></tr>
<tr><td><code id="teststat_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar with containing the non-bootstrapped
test statistic of interest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
  proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
boot &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
teststat(boot)
</code></pre>

<hr>
<h2 id='teststat.boottest'>S3 method to obtain the non-bootstrapped t-statistic calculated
via <code>boottest()</code></h2><span id='topic+teststat.boottest'></span>

<h3>Description</h3>

<p>S3 method to obtain the non-bootstrapped t-statistic calculated
via <code>boottest()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boottest'
teststat(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="teststat.boottest_+3A_object">object</code></td>
<td>
<p>An object of type boottest</p>
</td></tr>
<tr><td><code id="teststat.boottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the non-bootstrapped t-statistic
calculated in <code>boottest()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
  proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
boot &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
teststat(boot)

</code></pre>

<hr>
<h2 id='teststat.mboottest'>S3 method to obtain the non-bootstrapped test statistic calculated
via <code>mboottest()</code></h2><span id='topic+teststat.mboottest'></span>

<h3>Description</h3>

<p>S3 method to obtain the non-bootstrapped test statistic calculated
via <code>mboottest()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mboottest'
teststat(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="teststat.mboottest_+3A_object">object</code></td>
<td>
<p>An object of type 'mboottest'</p>
</td></tr>
<tr><td><code id="teststat.mboottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the non-bootstrapped t-statistic calculated
in <code>mboottest()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("clubSandwich")
R &lt;- clubSandwich::constrain_zero(2:3, coef(lm_fit))
wboottest &lt;-
  mboottest(
    object = lm_fit,
    clustid = "group_id1",
    B = 999,
    R = R
  )
teststat(wboottest)

## End(Not run)

</code></pre>

<hr>
<h2 id='tidy.boottest'>S3 method to summarize objects of class boottest into tidy data.frame</h2><span id='topic+tidy.boottest'></span>

<h3>Description</h3>

<p>S3 method to summarize objects of class boottest into tidy data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boottest'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.boottest_+3A_x">x</code></td>
<td>
<p>object of type boottest</p>
</td></tr>
<tr><td><code id="tidy.boottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data.frame with estimation results for objects of type
boottest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace("fwildclusterboot")
data(voters)
lm_fit &lt;- lm(
proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration,
  data = voters
)
boot &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1"
)
generics::tidy(boot)
</code></pre>

<hr>
<h2 id='tidy.mboottest'>S3 method to summarize objects of class mboottest into tidy data.frame</h2><span id='topic+tidy.mboottest'></span>

<h3>Description</h3>

<p>S3 method to summarize objects of class mboottest into tidy data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mboottest'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.mboottest_+3A_x">x</code></td>
<td>
<p>object of type mboottest</p>
</td></tr>
<tr><td><code id="tidy.mboottest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data.frame with estimation results for objects of type
mboottest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
requireNamespace("clubSandwich")
R &lt;- clubSandwich::constrain_zero(2:3, coef(lm_fit))
wboottest &lt;-
  mboottest(
    object = lm_fit,
    clustid = "group_id1",
    B = 999,
    R = R
  )
summary(wboottest)
print(wboottest)
nobs(wboottest)
pval(wboottest)
generics::tidy(wboottest)

## End(Not run)
</code></pre>

<hr>
<h2 id='voters'>Random example data set</h2><span id='topic+voters'></span>

<h3>Description</h3>

<p>Random example data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(voters)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 300 rows and 13 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(voters)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
