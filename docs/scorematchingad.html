<!DOCTYPE html><html lang="en"><head><title>Help for package scorematchingad</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scorematchingad}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#scorematchingad-package'><p>scorematchingad: Score Matching Estimation by Automatic Differentiation</p></a></li>
<li><a href='#Bingham'><p>Score Matching Estimators for the Bingham Distribution</p></a></li>
<li><a href='#cppad_closed'><p>Score Matching Estimator for Quadratic-Form Score Matching Discrepancies</p></a></li>
<li><a href='#cppad_search'><p>Iterative Score Matching Estimator Using Conjugate-Gradient Descent</p></a></li>
<li><a href='#dppi'><p>Improper Log-Density of the PPI Model</p></a></li>
<li><a href='#evaltape'><p>Evaluate a CppAD Tape Many Times</p></a></li>
<li><a href='#FB'><p>Estimate the Fisher-Bingham Distribution</p></a></li>
<li><a href='#microbiome'><p>16s Microbiome Data for Soil-Transmitted Helminths</p></a></li>
<li><a href='#ppi'><p>Estimation of Polynomially-Tilted Pairwise Interaction (PPI) Model</p></a></li>
<li><a href='#ppi_cW'><p>Quickly Generate a Vector of Windham Exponents for the PPI Model</p></a></li>
<li><a href='#ppi_mmmm'><p>A PPI Score-Matching Marginal Moment Matching Estimator (dimension=3 only)</p></a></li>
<li><a href='#ppi_param_tools'><p>PPI Parameter Tools</p></a></li>
<li><a href='#ppi_robust'><p>Robustly Estimate Parameters of the PPI Distribution</p></a></li>
<li><a href='#print+2CRcpp_ADFun'><p>Print or show a summary of an Rcpp_ADFun</p></a></li>
<li><a href='#quadratictape_parts'><p>Evaluate the Hessian and Gradient Offset of a Taped Quadratic Function</p></a></li>
<li><a href='#Rcpp_ADFun-class'><p>A Class for CppAD Tapes</p></a></li>
<li><a href='#rppi'><p>Simulate from a PPI Model</p></a></li>
<li><a href='#rsymmetricmatrix'><p>Quickly Generate a Symmetric Matrix for Testing and Examples</p></a></li>
<li><a href='#scorematchingtheory'><p>Introduction to Score Matching</p></a></li>
<li><a href='#smvalues'><p>Compute Score Matching Discrepancy Value, Gradient, and Hessian</p></a></li>
<li><a href='#tape_gradoffset'><p>Tape the Gradient Offset of a Quadratic CppAD Tape</p></a></li>
<li><a href='#tape_Hessian'><p>Tape the Hessian of a CppAD Tape</p></a></li>
<li><a href='#tape_Jacobian'><p>Tape the Jacobian of CppAD Tape</p></a></li>
<li><a href='#tape_logJacdet'><p>Tape the log of Jacobian determinant of a CppAD Tape</p></a></li>
<li><a href='#tape_smd'><p>Build CppAD Tapes for Score Matching</p></a></li>
<li><a href='#tape_swap'><p>Switch Dynamic and Independent Values of a Tape</p></a></li>
<li><a href='#tape_uld'><p>Generate a tape of a custom unnormalised log-density</p></a></li>
<li><a href='#testquadratic'><p>Test Whether a CppAD Tape is a Quadratic Function</p></a></li>
<li><a href='#vMF'><p>Score Matching Estimator for the von-Mises Fisher Distribution</p></a></li>
<li><a href='#vMF_robust'><p>Robust Fitting of von Mises Fisher</p></a></li>
<li><a href='#Windham'><p>Windham Robustification of Point Estimators for Exponential Family Distributions</p></a></li>
<li><a href='#Windham_populationinverse'><p>Inverse Transform for the Population Parameters Under Windham Weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Score Matching Estimation by Automatic Differentiation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Hyvärinen's score matching (Hyvärinen, 2005) <a href="https://jmlr.org/papers/v6/hyvarinen05a.html">https://jmlr.org/papers/v6/hyvarinen05a.html</a> is a useful estimation technique when the normalising constant for a probability distribution is difficult to compute. This package implements score matching estimators using automatic differentiation in the 'CppAD' library <a href="https://github.com/coin-or/CppAD">https://github.com/coin-or/CppAD</a> and is designed for quickly implementing score matching estimators for new models. Also available is general robustification (Windham, 1995) <a href="https://www.jstor.org/stable/2346159">https://www.jstor.org/stable/2346159</a>. Already in the package are estimators for directional distributions (Mardia, Kent and Laha, 2016) &lt;<a href="https://doi.org/10.48550%2FarXiv.1604.08470">doi:10.48550/arXiv.1604.08470</a>&gt; and the flexible Polynomially-Tilted Pairwise Interaction model for compositional data. The latter estimators perform well when there are zeros in the compositions (Scealy and Wood, 2023) &lt;<a href="https://doi.org/10.1080%2F01621459.2021.2016422">doi:10.1080/01621459.2021.2016422</a>&gt;, even many zeros (Scealy, Hingee, Kent, and Wood, 2024) &lt;<a href="https://doi.org/10.1007%2Fs11222-024-10412-w">doi:10.1007/s11222-024-10412-w</a>&gt;. A partial interface to CppAD's ADFun objects is also available.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, ks, movMF, cubature, simdd, numDeriv</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RcppEigen (&ge; 0.3.3.7), MCMCpack, optimx, FixedPoint, Rdpack,
Rcpp (&ge; 1.0.9), methods, stats, utils, rlang (&ge; 1.1.0)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.9), RcppEigen (&ge; 0.3.3.7)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kasselhingee/scorematchingad">https://github.com/kasselhingee/scorematchingad</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kasselhingee/scorematchingad/issues">https://github.com/kasselhingee/scorematchingad/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-07 06:16:24 UTC; kassel</td>
</tr>
<tr>
<td>Author:</td>
<td>Kassel Liam Hingee
    <a href="https://orcid.org/0000-0001-9894-2407"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Janice Scealy <a href="https://orcid.org/0000-0002-9718-869X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Bradley M. Bell [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kassel Liam Hingee &lt;kassel.hingee@anu.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-08 07:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='scorematchingad-package'>scorematchingad: Score Matching Estimation by Automatic Differentiation</h2><span id='topic+scorematchingad'></span><span id='topic+scorematchingad-package'></span>

<h3>Description</h3>

<p>Hyvärinen's score matching (Hyvärinen, 2005) <a href="https://jmlr.org/papers/v6/hyvarinen05a.html">https://jmlr.org/papers/v6/hyvarinen05a.html</a> is a useful estimation technique when the normalising constant for a probability distribution is difficult to compute. This package implements score matching estimators using automatic differentiation in the 'CppAD' library <a href="https://github.com/coin-or/CppAD">https://github.com/coin-or/CppAD</a> and is designed for quickly implementing score matching estimators for new models. Also available is general robustification (Windham, 1995) <a href="https://www.jstor.org/stable/2346159">https://www.jstor.org/stable/2346159</a>. Already in the package are estimators for directional distributions (Mardia, Kent and Laha, 2016) <a href="https://doi.org/10.48550/arXiv.1604.08470">doi:10.48550/arXiv.1604.08470</a> and the flexible Polynomially-Tilted Pairwise Interaction model for compositional data. The latter estimators perform well when there are zeros in the compositions (Scealy and Wood, 2023) <a href="https://doi.org/10.1080/01621459.2021.2016422">doi:10.1080/01621459.2021.2016422</a>, even many zeros (Scealy, Hingee, Kent, and Wood, 2024) <a href="https://doi.org/10.1007/s11222-024-10412-w">doi:10.1007/s11222-024-10412-w</a>. A partial interface to CppAD's ADFun objects is also available.
</p>


<h3>Details</h3>

<p>This package's main features are
</p>

<ul>
<li><p> A general capacity to implement score matching estimators that use algorithmic differentiation to avoid tedious manual algebra.
The package uses <code>CppAD</code> and <code>Eigen</code> to differentiate model densities and compute the score matching discrepancy function (see <code><a href="#topic+scorematchingtheory">scorematchingtheory</a></code>).
The score matching discrepancy is usually minimised by solving a quadratic equation, but a method for solving numerically (through <code><a href="optimx.html#topic+Rcgmin">optimx::Rcgmin()</a></code>) is also included.
New models can be fitted with the help of <code><a href="#topic+tape_uld">tape_uld()</a></code> in a similar fashion to models in the <code>TMB</code> package.
New manifolds or new transforms require small alterations to the source code of this package.
</p>
</li>
<li><p> Score matching estimators for the Polynomially-Tilted Pairwise Interaction (PPI) model (Scealy and Wood 2023; Scealy et al. 2024). See function <code><a href="#topic+ppi">ppi()</a></code>.
</p>
</li>
<li><p> Score matching and hybrid score matching estimators for von Mises Fisher, Bingham and Fisher-Bingham directional distributions (Mardia et al. 2016). See <code><a href="#topic+vMF">vMF()</a></code>, <code><a href="#topic+Bingham">Bingham()</a></code> and <code><a href="#topic+FB">FB()</a></code>.
</p>
</li>
<li><p> Implementation of a modification of Windham's robustifying method (Windham 1995) for many exponential family distributions. See <code><a href="#topic+Windham">Windham()</a></code>.
For some models the density approaches infinity at some locations, creating difficulties for the weights in Windham's original method (Scealy et al. 2024).
</p>
</li>
<li><p> An interface of <code>CppAD</code>'s <code>ADFun</code> tape objects. See <code><a href="#topic+Rcpp_ADFun-class">Rcpp_ADFun</a></code>.
</p>
</li></ul>

<p>For an introduction to score matching estimation, see <code><a href="#topic+scorematchingtheory">scorematchingtheory</a></code>.

</p>


<h3>Acknowledgements</h3>

<p>Colleagues Andrew T. A. Wood and John T. Kent played important roles in developing the statistical ideas and theory for score matching estimation for the PPI model (Scealy et al. 2024).
</p>
<p>We developed this package on Ngunnawal and Ngambri Country. We thank the Country for its influence.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kassel Liam Hingee <a href="mailto:kassel.hingee@anu.edu.au">kassel.hingee@anu.edu.au</a> (<a href="https://orcid.org/0000-0001-9894-2407">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Janice Scealy (<a href="https://orcid.org/0000-0002-9718-869X">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Bradley M. Bell [copyright holder]
</p>
</li></ul>



<h3>References</h3>

<p>Amaral GJA, Dryden IL, Wood ATA (2007).
&ldquo;Pivotal Bootstrap Methods for k-Sample Problems in Directional Statistics and Shape Analysis.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>102</b>(478), 695&ndash;707.
27639898, <a href="http://www.jstor.org/stable/27639898">http://www.jstor.org/stable/27639898</a>.<br /><br /> Bell B (2023).
&ldquo;CppAD: A Package for Differentiation of C++ Algorithms.&rdquo;
<a href="https://github.com/coin-or/CppAD">https://github.com/coin-or/CppAD</a>.<br /><br /> Hyvärinen A (2005).
&ldquo;Estimation of Non-Normalized Statistical Models by Score Matching.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>6</b>(24), 695&ndash;709.
<a href="https://jmlr.org/papers/v6/hyvarinen05a.html">https://jmlr.org/papers/v6/hyvarinen05a.html</a>.<br /><br /> Hyvärinen A (2007).
&ldquo;Some extensions of score matching.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>51</b>(5), 2499&ndash;2512.
<a href="https://doi.org/10.1016/j.csda.2006.09.003">doi:10.1016/j.csda.2006.09.003</a>.<br /><br /> Liu S, Kanamori T, Williams DJ (2019).
&ldquo;Estimating Density Models with Truncation Boundaries using Score Matching.&rdquo;
<a href="https://doi.org/10.48550/arXiv.1910.03834">doi:10.48550/arXiv.1910.03834</a>.<br /><br /> Mardia K (2018).
&ldquo;A New Estimation Methodology for Standard Directional Distributions.&rdquo;
In <em>2018 21st International Conference on Information Fusion (FUSION)</em>, 724&ndash;729.
<a href="https://doi.org/10.23919/ICIF.2018.8455640">doi:10.23919/ICIF.2018.8455640</a>.<br /><br /> Mardia KV, Jupp PE (2000).
<em>Directional Statistics</em>,  Probability and Statistics.
Wiley, Great Britain.
ISBN 0-471-95333-4.<br /><br /> Mardia KV, Kent JT, Laha AK (2016).
&ldquo;Score matching estimators for directional distributions.&rdquo;
<a href="https://doi.org/10.48550/arXiv.1604.08470">doi:10.48550/arXiv.1604.08470</a>.<br /><br /> Martin I, Uh H, Supali T, Mitreva M, Houwing-Duistermaat JJ (2019).
&ldquo;The mixed model for the analysis of a repeated-measurement multivariate count data.&rdquo;
<em>Statistics in Medicine</em>, <b>38</b>(12), 2248&ndash;2268.
<a href="https://doi.org/10.1002/sim.8101">doi:10.1002/sim.8101</a>.<br /><br /> Scealy JL, Hingee KL, Kent JT, Wood ATA (2024).
&ldquo;Robust score matching for compositional data.&rdquo;
<em>Statistics and Computing</em>, <b>34</b>, 93.
<a href="https://doi.org/10.1007/s11222-024-10412-w">doi:10.1007/s11222-024-10412-w</a>.<br /><br /> Scealy JL, Wood ATA (2023).
&ldquo;Score matching for compositional distributions.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>118</b>(543), 1811&ndash;1823.
<a href="https://doi.org/10.1080/01621459.2021.2016422">doi:10.1080/01621459.2021.2016422</a>.<br /><br /> Windham MP (1995).
&ldquo;Robustifying Model Fitting.&rdquo;
<em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, <b>57</b>(3), 599&ndash;609.
2346159, <a href="http://www.jstor.org/stable/2346159">http://www.jstor.org/stable/2346159</a>.<br /><br /> Wiria AE, Prasetyani MA, Hamid F, Wammes LJ, Lell B, Ariawan I, Uh HW, Wibowo H, Djuardi Y, Wahyuni S, Sutanto I, May L, Luty AJ, Verweij JJ, Sartono E, Yazdanbakhsh M, Supali T (2010).
&ldquo;Does treatment of intestinal helminth infections influence malaria?&rdquo;
<em>BMC Infectious Diseases</em>, <b>10</b>, 77.
<a href="https://doi.org/10.1186/1471-2334-10-77">doi:10.1186/1471-2334-10-77</a>.<br /><br /> Yu S, Drton M, Shojaie A (2019).
&ldquo;Generalized Score Matching for Non-Negative Data.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>20</b>(76), 1&ndash;70.
<a href="https://jmlr.org/papers/v20/18-278.html">https://jmlr.org/papers/v20/18-278.html</a>.<br /><br /> Yu S, Drton M, Shojaie A (2020).
&ldquo;Generalized Score Matching for General Domains.&rdquo;
<a href="https://doi.org/10.48550/arXiv.2009.11428">doi:10.48550/arXiv.2009.11428</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/kasselhingee/scorematchingad">https://github.com/kasselhingee/scorematchingad</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/kasselhingee/scorematchingad/issues">https://github.com/kasselhingee/scorematchingad/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Bingham'>Score Matching Estimators for the Bingham Distribution</h2><span id='topic+Bingham'></span>

<h3>Description</h3>

<p>Score matching estimators for the Bingham distribution's parameter matrix. Two methods are available: a full score matching method that estimates the parameter matrix directly and a hybrid method by Mardia et al. (2016) that uses score matching to estimate just the eigenvalues of the parameter matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bingham(Y, A = NULL, w = rep(1, nrow(Y)), method = "Mardia")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bingham_+3A_y">Y</code></td>
<td>
<p>A matrix of multivariate observations in Cartesian coordinates. Each row is a multivariate measurement (i.e. each row corresponds to an individual).</p>
</td></tr>
<tr><td><code id="Bingham_+3A_a">A</code></td>
<td>
<p>For full score matching only: if supplied, then NA elements of <code>A</code> are estimated and the other elements are fixed. For identifiability the final element of <code>diag(A)</code> must be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="Bingham_+3A_w">w</code></td>
<td>
<p>An optional vector of weights for each measurement in <code>Y</code></p>
</td></tr>
<tr><td><code id="Bingham_+3A_method">method</code></td>
<td>
<p>Either &quot;Mardia&quot; or &quot;hybrid&quot; for the hybrid score matching estimator from Mardia et al. (2016)
or &quot;smfull&quot; for the full score matching estimator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bingham distribution has a density proportional to
</p>
<p style="text-align: center;"><code class="reqn">\exp(z^T A z),</code>
</p>

<p>where <code class="reqn">A</code> is a symmetric matrix and the trace (sum of the diagonals) of <code class="reqn">A</code> is zero for identifiability (p181, Mardia and Jupp 2000).
</p>
<p>The full score matching method estimates all elements of <code class="reqn">A</code> directly except the final element of the diagonal, which is calculated from the sum of the other diagonal elements to ensure that the trace of <code class="reqn">A</code> is zero.
</p>
<p>The method by Mardia et al. (2016) first calculates the maximum-likelihood estimate of the eigenvectors <code class="reqn">G</code> of <code class="reqn">A</code>.
The observations <code>Y</code> are then standardised to <code>Y</code><code class="reqn">G</code>.
This standardisation corresponds to diagonalising <code class="reqn">A</code>
where the eigenvalues of <code class="reqn">A</code> become the diagonal elements of the new <code class="reqn">A</code>.
The diagonal elements of the new <code class="reqn">A</code> are then estimated using score matching, with the final diagonal element calculated from the sum of the other elements.
See Mardia et al. (2016) for details.
</p>


<h3>Value</h3>

<p>A list of <code>est</code>, <code>SE</code> and <code>info</code>.
</p>

<ul>
<li> <p><code>est</code> contains the estimated matrix <code>A</code> and a vector form, <code>paramvec</code>, of <code>A</code> (ordered according to <code>c(diag(A)[1:(p-1)], A[upper.tri(A)])</code> ). For the Mardia method, the estimated eigenvalues of <code>A</code> (named <code>evals</code>) and eigenvectors of <code>A</code> (named <code>G</code>) are also returned.
</p>
</li>
<li> <p><code>SE</code> contains estimates of the standard errors if computed. See <code><a href="#topic+cppad_closed">cppad_closed()</a></code>.
</p>
</li>
<li> <p><code>info</code> contains a variety of information about the model fitting procedure and results.
</p>
</li></ul>



<h3>References</h3>

<p>Mardia KV, Jupp PE (2000).
<em>Directional Statistics</em>,  Probability and Statistics.
Wiley, Great Britain.
ISBN 0-471-95333-4.<br /><br /> Mardia KV, Kent JT, Laha AK (2016).
&ldquo;Score matching estimators for directional distributions.&rdquo;
<a href="https://doi.org/10.48550/arXiv.1604.08470">doi:10.48550/arXiv.1604.08470</a>.
</p>


<h3>See Also</h3>

<p>Other directional model estimators: 
<code><a href="#topic+FB">FB</a>()</code>,
<code><a href="#topic+vMF">vMF</a>()</code>,
<code><a href="#topic+vMF_robust">vMF_robust</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 4
A &lt;- rsymmetricmatrix(p)
A[p,p] &lt;- -sum(diag(A)[1:(p-1)]) #to satisfy the trace = 0 constraint
if (requireNamespace("simdd")){
  Y &lt;- simdd::rBingham(100, A)
  Bingham(Y, method = "Mardia")
}
</code></pre>

<hr>
<h2 id='cppad_closed'>Score Matching Estimator for Quadratic-Form Score Matching Discrepancies</h2><span id='topic+cppad_closed'></span>

<h3>Description</h3>

<p>For a tape of a quadratic-form score matching discrepancy function, calculates the vector of parameters such that the gradient of the score matching discrepancy is zero.
Also estimates standard errors and covariance.
Many score matching discrepancy functions have a quadratic form (see <code><a href="#topic+scorematchingtheory">scorematchingtheory</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cppad_closed(
  smdtape,
  Y,
  Yapproxcentres = NA * Y,
  w = rep(1, nrow(Y)),
  approxorder = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cppad_closed_+3A_smdtape">smdtape</code></td>
<td>
<p>A tape (<code><a href="#topic+Rcpp_ADFun">Rcpp_ADFun</a></code> object) of a score matching discrepancy function that has <em>quadratic form</em>. Test for quadratic form using <code><a href="#topic+testquadratic">testquadratic()</a></code>.
The <code>smdtape</code>'s independent variables are assumed to be the model parameters to fit
and the <code>smdtape</code>'s dynamic parameter is a (multivariate) measurement.</p>
</td></tr>
<tr><td><code id="cppad_closed_+3A_y">Y</code></td>
<td>
<p>A matrix of multivariate observations. Each row is an observation. The number of columns of <code>Y</code> must be <code>smdtape$size_dyn_ind</code>.</p>
</td></tr>
<tr><td><code id="cppad_closed_+3A_yapproxcentres">Yapproxcentres</code></td>
<td>
<p>A matrix of Taylor approximation centres for rows of Y that require approximation. <code>NA</code> for rows that do not require approximation.</p>
</td></tr>
<tr><td><code id="cppad_closed_+3A_w">w</code></td>
<td>
<p>Weights for each observation.</p>
</td></tr>
<tr><td><code id="cppad_closed_+3A_approxorder">approxorder</code></td>
<td>
<p>The order of Taylor approximation to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the score matching discrepancy function is of quadratic form, then the gradient of the score matching discrepancy is zero at <code class="reqn">H^{-1}b</code>,
where <code class="reqn">H</code> is the average of the Hessian of the score matching discrepancy function evaluated at each measurement and
<code class="reqn">b</code> is the average of the gradient offset (see <code><a href="#topic+quadratictape_parts">quadratictape_parts()</a></code>) evaluated at each measurement.
Both the Hessian and the gradient offset are constant with respect to the model parameters for quadratic-form score matching discrepancy functions.
</p>
<p>Standard errors are estimated using the Godambe information matrix (aka sandwich method) and are only computed when the weights are constant.
The estimate of the negative of the sensitivity matrix <code class="reqn">-G</code> is
the average of the Hessian of <code>smdtape</code> evaluated at each observation in <code>Y</code>.
The estimate of the variability matrix <code class="reqn">J</code> is
the sample covariance (denominator of <code class="reqn">n-1</code>) of the gradient of <code>smdtape</code> evaluated at each of the observations in <code>Y</code> for the estimated <code class="reqn">\theta</code>.
The estimated variance of the estimator is then as
<code class="reqn">G^{-1}JG^{-1}/n,</code>
where <code>n</code> is the number of observations.
</p>
<p>Taylor approximation is available because boundary weight functions and transformations of the measure in Hyvärinen divergence can remove singularities in the model log-likelihood, however evaluation at these singularities may still involve computing intermediate values that are unbounded.
If the singularity is ultimately removed, then Taylor approximation from a nearby location will give a very accurate evaluation at the removed singularity.
</p>


<h3>See Also</h3>

<p>Other generic score matching tools: 
<code><a href="#topic+Windham">Windham</a>()</code>,
<code><a href="#topic+cppad_search">cppad_search</a>()</code>,
<code><a href="#topic+tape_smd">tape_smd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>smdtape &lt;- tape_smd("sim", "sqrt", "sph", "ppi",
              ytape = rep(1/3, 3),
              usertheta = ppi_paramvec(p = 3),
              bdryw = "minsq", acut = 0.01,
              verbose = FALSE
              )$smdtape
Y &lt;- rppi_egmodel(100)
cppad_closed(smdtape, Y$sample)
</code></pre>

<hr>
<h2 id='cppad_search'>Iterative Score Matching Estimator Using Conjugate-Gradient Descent</h2><span id='topic+cppad_search'></span>

<h3>Description</h3>

<p>Uses conjugate gradient descent to search for a vector of parameters such that gradient of the score matching discrepancy is within tolerance of zero.
Also estimates standard errors and covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cppad_search(
  smdtape,
  theta,
  Y,
  Yapproxcentres = NA * Y,
  w = rep(1, nrow(Y)),
  approxorder = 10,
  control = list(tol = 1e-15, checkgrad = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cppad_search_+3A_smdtape">smdtape</code></td>
<td>
<p>A tape (<code><a href="#topic+Rcpp_ADFun">Rcpp_ADFun</a></code> object) of a score matching discrepancy function.
The <code>smdtape</code>'s independent variables are assumed to be the model parameters to fit
and the <code>smdtape</code>'s dynamic parameter is a (multivariate) measurement.</p>
</td></tr>
<tr><td><code id="cppad_search_+3A_theta">theta</code></td>
<td>
<p>The starting parameter set</p>
</td></tr>
<tr><td><code id="cppad_search_+3A_y">Y</code></td>
<td>
<p>A matrix of multivariate observations. Each row is an observation. The number of columns of <code>Y</code> must be <code>smdtape$size_dyn_ind</code>.</p>
</td></tr>
<tr><td><code id="cppad_search_+3A_yapproxcentres">Yapproxcentres</code></td>
<td>
<p>A matrix of Taylor approximation centres for rows of Y that require approximation. <code>NA</code> for rows that do not require approximation.</p>
</td></tr>
<tr><td><code id="cppad_search_+3A_w">w</code></td>
<td>
<p>Weights for each observation.</p>
</td></tr>
<tr><td><code id="cppad_search_+3A_approxorder">approxorder</code></td>
<td>
<p>The order of Taylor approximation to use.</p>
</td></tr>
<tr><td><code id="cppad_search_+3A_control">control</code></td>
<td>
<p>Control parameters passed to <code><a href="optimx.html#topic+Rcgmin">optimx::Rcgmin()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The score matching discrepancy function and gradient of the score matching function are passed to <code><a href="optimx.html#topic+Rcgmin">optimx::Rcgmin()</a></code>.
The call to <code><a href="optimx.html#topic+Rcgmin">optimx::Rcgmin()</a></code> uses the <em>sum</em> of observations (as opposed to the mean) to reduce floating point inaccuracies. This has implications for the meaning of the control parameters passed to <code>Rcgmin()</code> (e.g. <code>tol</code>). The results are converted into averages so the use of sums can be ignored when not setting control parameters, or studying the behaviour of Rcgmin.
</p>
<p>Standard errors use the Godambe information matrix (aka sandwich method) and are only computed when the weights are constant.
The estimate of the sensitivity matrix <code class="reqn">G</code> is
the negative of the average over the Hessian of <code>smdtape</code> evaluated at each observation in <code>Y</code>.
The estimate of the variability matrix <code class="reqn">J</code> is then
the sample covariance (denominator of <code class="reqn">n-1</code>) of the gradient of <code>smdtape</code> evaluated at each of the observations in <code>Y</code> for the estimated <code class="reqn">\theta</code>.
The variance of the estimator is then estimated as
<code class="reqn">G^{-1}JG^{-1}/n,</code>
where <code>n</code> is the number of observations.
</p>
<p>Taylor approximation is available because boundary weight functions and transformations of the measure in Hyvärinen divergence can remove singularities in the model log-likelihood, however evaluation at these singularities may still involve computing intermediate values that are unbounded.
If the singularity is ultimately removed, then Taylor approximation from a nearby location will give a very accurate evaluation at the removed singularity.
</p>


<h3>See Also</h3>

<p>Other generic score matching tools: 
<code><a href="#topic+Windham">Windham</a>()</code>,
<code><a href="#topic+cppad_closed">cppad_closed</a>()</code>,
<code><a href="#topic+tape_smd">tape_smd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>smdtape &lt;- tape_smd("sim", "sqrt", "sph", "ppi",
              ytape = rep(1/3, 3),
              usertheta = ppi_paramvec(p = 3),
              bdryw = "minsq", acut = 0.01,
              verbose = FALSE
              )$smdtape
Y &lt;- rppi_egmodel(100)
cppad_search(smdtape, 0.9 * Y$theta, Y$sample)
sum((smvalues_wsum(smdtape, Y$sample, Y$theta)$grad/nrow(Y$sample))^2)
</code></pre>

<hr>
<h2 id='dppi'>Improper Log-Density of the PPI Model</h2><span id='topic+dppi'></span>

<h3>Description</h3>

<p>Compute the <strong>natural logarithm</strong> of the improper density for the PPI model for the given matrix of measurements <code>Y</code>. Rows with negative values or with a sum that differs from <code>1</code> by more than <code>1E-15</code> are assigned a value of <code>-Inf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppi(Y, ..., paramvec = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dppi_+3A_y">Y</code></td>
<td>
<p>A matrix of measurements in the simplex. Each row is a multivariate measurement.</p>
</td></tr>
<tr><td><code id="dppi_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+ppi_paramvec">ppi_paramvec</a></code>
</p>

<dl>
<dt><code>AL</code></dt><dd><p>Either <code>NULL</code>, a p-1 x p-1 symmetric matrix, a number, or &quot;diag&quot;.
If NULL then all <code class="reqn">A_L</code> elements will be set to NA.
If a single number, then <code class="reqn">A_L</code> will be fixed as a matrix of the given value.
If &quot;diag&quot; then the non-diagonal elements of <code class="reqn">A_L</code> will be fixed to 0, and the diagonal will be <code>NA</code>.</p>
</dd>
<dt><code>bL</code></dt><dd><p>Either <code>NULL</code>, a number, or a vector of length p-1.
If <code>NULL</code>, then all elements of <code class="reqn">b_L</code> will be set to <code>NA</code>.
If a single number, then <code class="reqn">b_L</code> will be fixed at the supplied value.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Either <code>NULL</code>, a number, or a vector of length p.
If NULL then all elements of <code class="reqn">\beta</code> will be set to <code>NA</code>.
If a single number then the <code class="reqn">\beta</code> elements will be fixed at the given number.</p>
</dd>
<dt><code>betaL</code></dt><dd><p>Either <code>NULL</code>, a number, or a vector of length p-1.
If <code>NULL</code> then the 1...(p-1)th <code class="reqn">\beta</code> elements will be set to <code>NA</code>.
If a single number then the 1...(p-1)th <code class="reqn">\beta</code> elements will be fixed at the given number.</p>
</dd>
<dt><code>betap</code></dt><dd><p>Either <code>NULL</code> or a number.
If <code>NULL</code> then the <code>p</code>th element of <code class="reqn">\beta</code> will be set to <code>NA</code>, and <code><a href="#topic+ppi">ppi()</a></code> will estimate it.
If a number, then the pth element of <code class="reqn">\beta</code> will be fixed at the given value.</p>
</dd>
<dt><code>p</code></dt><dd><p>The number of components. If <code>NULL</code> then <code>p</code> will be inferred from other inputs.</p>
</dd>
<dt><code>Astar</code></dt><dd><p>The <code class="reqn">A^*</code> matrix (a p by p symmetric matrix)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dppi_+3A_paramvec">paramvec</code></td>
<td>
<p>The PPI parameter vector, created easily using <code><a href="#topic+ppi_paramvec">ppi_paramvec()</a></code> and also returned by <code><a href="#topic+ppi">ppi()</a></code>. Use <code>paramvec</code> instead of <code>...</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value calculated by <code>dppi</code> is
</p>
<p style="text-align: center;"><code class="reqn">z_L^TA_Lz_L + b_L^Tz_L + \beta^T \log(z),</code>
</p>

<p>where <code class="reqn">z</code> is the multivariate observation (i.e. a row of <code>Y</code>), and <code class="reqn">z_L</code> omits the final element of <code class="reqn">z</code>.
</p>


<h3>See Also</h3>

<p>Other PPI model tools: 
<code><a href="#topic+ppi">ppi</a>()</code>,
<code><a href="#topic+ppi_param_tools">ppi_param_tools</a></code>,
<code><a href="#topic+ppi_robust">ppi_robust</a>()</code>,
<code><a href="#topic+rppi">rppi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- rppi_egmodel(10)
dppi(m$sample, paramvec = m$theta)
</code></pre>

<hr>
<h2 id='evaltape'>Evaluate a CppAD Tape Many Times</h2><span id='topic+evaltape'></span><span id='topic+evaltape_wsum'></span>

<h3>Description</h3>

<p>Evaluates a tape exactly or approximately for an array of provided variable values and dynamic parameter values.
The function <code>evaltape_wsum()</code> computes the weighted sum of each column of the <code>evaltape()</code> result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaltape(tape, xmat, pmat, xcentres = NA * xmat, approxorder = 10)

evaltape_wsum(
  tape,
  xmat,
  pmat,
  w = NULL,
  xcentres = NA * xmat,
  approxorder = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaltape_+3A_tape">tape</code></td>
<td>
<p>An <code><a href="#topic+Rcpp_ADFun">Rcpp_ADFun</a></code> object (i.e. a tape of a function).</p>
</td></tr>
<tr><td><code id="evaltape_+3A_xmat">xmat</code></td>
<td>
<p>A matrix of (multivariate) independent variables where each represents a single independent variable vector. Or a single independent variable vector that is used for all rows of <code>pmat</code>.</p>
</td></tr>
<tr><td><code id="evaltape_+3A_pmat">pmat</code></td>
<td>
<p>A matrix of dynamic parameters where each row specifies a new set of values for the dynamic parameters of <code>tape</code>. Or a single vector of dynamic parameters to use for all rows of <code>xmat</code>.</p>
</td></tr>
<tr><td><code id="evaltape_+3A_xcentres">xcentres</code></td>
<td>
<p>A matrix of approximation for Taylor approximation centres for <code>xmat</code>. Use values of <code>NA</code> for rows that do not require Taylor approximation.</p>
</td></tr>
<tr><td><code id="evaltape_+3A_approxorder">approxorder</code></td>
<td>
<p>Order of Taylor approximation</p>
</td></tr>
<tr><td><code id="evaltape_+3A_w">w</code></td>
<td>
<p>Weights to apply to each row of <code>xmat</code> for computing the weighted sum. If <code>NULL</code> then each row is given a weight of <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Approximation is via Taylor approximation of the independent variable around the approximation centre provided in <code>xcentres</code>.
</p>


<h3>Value</h3>

<p>A matrix, each row corresponding to the evaluation of the same row in <code>xmat</code>, <code>pmat</code> and <code>xcentres</code>.
</p>


<h3>See Also</h3>

<p>Other tape evaluators: 
<code><a href="#topic+quadratictape_parts">quadratictape_parts</a>()</code>,
<code><a href="#topic+smvalues">smvalues</a>()</code>,
<code><a href="#topic+testquadratic">testquadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- rep(1/3, 3)
tapes &lt;- tape_smd("sim", "sqrt", "sph", "ppi",
              ytape = u,
              usertheta = ppi_paramvec(p = 3),
              bdryw = "minsq", acut = 0.01,
              verbose = FALSE
              )
evaltape(tapes$lltape, u, rppi_egmodel(1)$theta)
evaltape(tapes$smdtape, rppi_egmodel(1)$theta, u)
evaltape(tapes$lltape, rbind(c(0, 0, 1), c(0,0,1)), 
         rppi_egmodel(1)$theta, 
         xcentres = rbind(c(0.0005, 0.0005, 0.999), NA))
</code></pre>

<hr>
<h2 id='FB'>Estimate the Fisher-Bingham Distribution</h2><span id='topic+FB'></span>

<h3>Description</h3>

<p>Estimates parameters for the Fisher-Bingham distribution using score-matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FB(Y, km = NULL, A = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FB_+3A_y">Y</code></td>
<td>
<p>A matrix of multivariate observations in Cartesian coordinates. Each row is a multivariate measurement (i.e. each row corresponds to an individual).</p>
</td></tr>
<tr><td><code id="FB_+3A_km">km</code></td>
<td>
<p>Optional. A vector of the same length as the dimension, representing the parameter vector for the von Mises-Fisher component (i.e. the <code class="reqn">\kappa \mu</code> see <code><a href="#topic+vMF">vMF()</a></code>).
If supplied, the non-NA elements are fixed.</p>
</td></tr>
<tr><td><code id="FB_+3A_a">A</code></td>
<td>
<p>Optional. The Bingham matrix. If supplied the non-NA elements of the Bingham matrix are fixed.
The final element of the diagonal of <code>A</code> must be NA as the software calculates this value to ensure the trace of the Bingham matrix is zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of the Fisher-Bingham distribution is proportional to
</p>
<p style="text-align: center;"><code class="reqn">\exp(z^TAz + \kappa\mu^Tz),</code>
</p>

<p>where <code class="reqn">A</code> is a matrix as in the Bingham distribution, and
<code class="reqn">\kappa</code> and <code class="reqn">\mu</code> are the concentration and mean direction, respectively, as in the von Mises-Fisher distribution.
</p>


<h3>Warning: Slow Convergence with Sample Size</h3>

<p>Score matching estimates of all elements of <code class="reqn">A</code> and <code class="reqn">\kappa\mu</code> converge slowly with sample size.
Even with a million simulated measurements,
the gradient of the score matching discrepancy at the true parameters can have size (L2 Euclidean norm) more than 0.001, which is substantially non-zero.
</p>


<h3>See Also</h3>

<p>Other directional model estimators: 
<code><a href="#topic+Bingham">Bingham</a>()</code>,
<code><a href="#topic+vMF">vMF</a>()</code>,
<code><a href="#topic+vMF_robust">vMF_robust</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 3
A &lt;- rsymmetricmatrix(p, -10, 10)
A[p,p] &lt;- -sum(diag(A)[1:(p-1)]) #to satisfy the trace = 0 constraint
m &lt;- runif(p, -10, 10)
m &lt;- m / sqrt(sum(m^2))
if (requireNamespace("simdd")){
  Y &lt;- simdd::rFisherBingham(1000, 2 * m, A)
  FB(Y)
}
</code></pre>

<hr>
<h2 id='microbiome'>16s Microbiome Data for Soil-Transmitted Helminths</h2><span id='topic+microbiome'></span>

<h3>Description</h3>

<p>The <code>microbiome</code> data contains paired DNA samples from before treatment and 21 months after treatment for helminth infections (Martin et al. 2019).
This data was analysed by Martin et al. (2019) and a further subset was studied by Scealy and Wood (2023).
The data are from a study into the effect of helminth infections on the course of malaria infections (ImmunoSPIN-Malaria) in the Nangapanda subdistrict, Indonesia (Wiria et al. 2010).
As part of the study, some participants were given 400mg of albendazole every three months for 1.5 years,
remaining participants were given a placebo
(Wiria et al. 2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>microbiome
</code></pre>


<h3>Format</h3>

<p>A dataframe with 300 rows (two rows per individual) and 31 columns:
</p>

<dl>
<dt>IndividualID</dt><dd><p>An integer uniquely specifying the individual.</p>
</dd>
<dt>Year</dt><dd><p>The collection year for the sample. <code>2008</code> for before treatment. <code>2010</code> for after treatment.</p>
</dd>
<dt>Sex</dt><dd><p><code>1</code> if female, <code>0</code> otherwise.</p>
</dd>
<dt>Treatment</dt><dd><p><code>TRUE</code> if individual given 400mg of albendazole every three months for 1.5 years, <code>FALSE</code> otherwise.</p>
</dd>
<dt>Age</dt><dd><p>Age at first sample.</p>
</dd>
<dt>ct_Al</dt><dd><p>A Helminth measurement: The qPCR cycle threshold (CT) for <em>Ascaris lumbricoides</em> (large roundworm). <em>Ascaris lumbricoides</em> can be considered present if the value is 30 or less.</p>
</dd>
<dt>ct_Na</dt><dd><p>A Helminth measurement: The qPCR cycle threshold (CT) for <em>Necator americanus</em> (a hookworm). <em>Necator americanus</em> can be considered present if the value is 30 or less.</p>
</dd>
<dt>ct_Ad</dt><dd><p>A Helminth measurement: The qPCR cycle threshold (CT) for <em>Ancylostoma duodenale</em> (a hookworm). <em>Ancylostoma duodenale</em> can be considered present if the value is 30 or less.</p>
</dd>
<dt>micr_Tt</dt><dd><p>A Helminth measurement: The presence of <em>Trichuris trichiura</em> as determined by microscopy. A value of <code>TRUE</code> means <em>Trichuris trichiura</em> was detected.</p>
</dd>
<dt>Helminth</dt><dd><p>A Helminth measurement: If any of the above helminths were detected then <code>TRUE</code>, otherwise <code>FALSE</code>.</p>
</dd>
<dt>Remaining columns</dt><dd><p>Count prevalence of 18 bacterial phyla and 2 unclassified columns.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The measurements in the data come from stool samples before and after treatment.
Gut microbiome prevalence was measured using 16s rRNA 454 sequencing (Martin et al. 2019).
Helminth infections were detected by PCR or microscopy (Martin et al. 2019).
</p>
<p>The subset studied by  Scealy and Wood (2023) contained only the measurements from before treatment, and only those individuals with a helminth infection.
These measurements can be obtained by running
</p>
<div class="sourceCode"><pre>microbiome[(microbiome$Year == 2008) &amp; microbiome$Helminth, ]
</pre></div>
<p>Two further individuals (<code>IndividualID</code> of <code>2079</code> and <code>2280</code>) were deemed outliers by Scealy and Wood (2023).
</p>


<h3>Modifications from the Source</h3>

<p>The <code>microbiome</code> data was created from the file <code>S1_Table.xlsx</code> hosted on <code>Nematode.net</code> at
</p>
<p><code style="white-space: pre;">&#8288;http://nematode.net/Data/environmental_interaction/S1_Table.xlsx&#8288;</code> using the below code.
</p>
<div class="sourceCode"><pre>microbiome &lt;- readxl::read_excel("S1_Table.xlsx",
  range = "A3:AE303") #avoids the genus data, keeping - only phyla
metacolnames &lt;- readxl::read_excel("S1_Table.xlsx",
  range = "A2:J2", 
  col_names = FALSE)
colnames(microbiome)[1:ncol(metacolnames)] &lt;- metacolnames[1, ]
colnames(microbiome)[2] &lt;- "Year"
microbiome[, 11] &lt;- (microbiome$ct_Al &lt;= 30) | (microbiome$ct_Na &lt;= 30) |
  (microbiome$ct_Ad &lt;= 30) | (microbiome$ct_St &lt;= 30) |
  (microbiome$micr_Tt == 1)
colnames(microbiome)[11] &lt;- "Helminth"
microbiome &lt;- microbiome |&gt;
  dplyr::mutate(across(c(1,2,3,12:31), as.integer)) |&gt;
  dplyr::mutate(micr_Tt = as.logical(micr_Tt),
                Treatment = as.logical(Treatment)) |&gt;
  dplyr::rename(IndividualID = `Individual ID`)
microbiome &lt;- as.data.frame(microbiome)
</pre></div>


<h3>Source</h3>

<p><code style="white-space: pre;">&#8288;http://nematode.net/Data/environmental_interaction/S1_Table.xlsx&#8288;</code> from <code style="white-space: pre;">&#8288;http://nematode.net&#8288;</code>.
<code>S1_Table.xlsx</code> was created by Dr. Bruce A Rosa for Martin et al. (2019). Permission to share this data was obtained from Dr. Bruce Rosa and Dr. Ivonne Martin.
</p>


<h3>References</h3>

<p>Martin I, Uh H, Supali T, Mitreva M, Houwing-Duistermaat JJ (2019).
&ldquo;The mixed model for the analysis of a repeated-measurement multivariate count data.&rdquo;
<em>Statistics in Medicine</em>, <b>38</b>(12), 2248&ndash;2268.
<a href="https://doi.org/10.1002/sim.8101">doi:10.1002/sim.8101</a>.<br /><br /> Scealy JL, Wood ATA (2023).
&ldquo;Score matching for compositional distributions.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>118</b>(543), 1811&ndash;1823.
<a href="https://doi.org/10.1080/01621459.2021.2016422">doi:10.1080/01621459.2021.2016422</a>.<br /><br /> Wiria AE, Prasetyani MA, Hamid F, Wammes LJ, Lell B, Ariawan I, Uh HW, Wibowo H, Djuardi Y, Wahyuni S, Sutanto I, May L, Luty AJ, Verweij JJ, Sartono E, Yazdanbakhsh M, Supali T (2010).
&ldquo;Does treatment of intestinal helminth infections influence malaria?&rdquo;
<em>BMC Infectious Diseases</em>, <b>10</b>, 77.
<a href="https://doi.org/10.1186/1471-2334-10-77">doi:10.1186/1471-2334-10-77</a>.
</p>

<hr>
<h2 id='ppi'>Estimation of Polynomially-Tilted Pairwise Interaction (PPI) Model</h2><span id='topic+ppi'></span><span id='topic+ppi_smvalues'></span>

<h3>Description</h3>

<p>Estimates the parameters of the Polynomially-Tilted Pairwise Interaction (PPI) model (Scealy and Wood 2023) for compositional data.
By default <code>ppi()</code> uses <code><a href="#topic+cppad_closed">cppad_closed()</a></code> to find estimate.
For many situations a hard-coded implementation of the score matching estimator is also available.
</p>
<p>For a given parameter vector <code>evalparam</code>, <code>ppi_smvalues()</code> computes the score matching discrepancy, the gradient and the Hessian of the score matching discrepancy (see <code><a href="#topic+smvalues">smvalues()</a></code>) and the gradient offset of the score matching discrepancy (see <code><a href="#topic+quadratictape_parts">quadratictape_parts()</a></code> and <code><a href="#topic+tape_gradoffset">tape_gradoffset()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppi(
  Y,
  paramvec = NULL,
  trans,
  method = "closed",
  w = rep(1, nrow(Y)),
  constrainbeta = FALSE,
  bdryw = "ones",
  acut = NULL,
  bdrythreshold = 1e-10,
  shiftsize = bdrythreshold,
  approxorder = 10,
  control = list(tol = 1e-15, checkgrad = TRUE),
  paramvec_start = NULL
)

ppi_smvalues(
  Y,
  paramvec = NULL,
  evalparam,
  trans,
  method = "closed",
  w = rep(1, nrow(Y)),
  bdryw = "ones",
  acut = NULL,
  bdrythreshold = 1e-10,
  shiftsize = bdrythreshold,
  approxorder = 10,
  average = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppi_+3A_y">Y</code></td>
<td>
<p>A matrix of measurements. Each row is a compositional measurement (i.e. each row sums to 1 and has non-negative elements).</p>
</td></tr>
<tr><td><code id="ppi_+3A_paramvec">paramvec</code></td>
<td>
<p>Optionally a vector of the PPI models parameters. <code>NA</code>-valued elements of this vector are estimated and non-<code>NA</code> values are fixed. Generate <code>paramvec</code> easily using <code><a href="#topic+ppi_paramvec">ppi_paramvec()</a></code>.  If <code>NULL</code> then all elements of <code class="reqn">A_L</code>, <code class="reqn">b_L</code> and <code class="reqn">\beta</code> are estimated.</p>
</td></tr>
<tr><td><code id="ppi_+3A_trans">trans</code></td>
<td>
<p>The name of the transformation of the manifold in Hyvärinen divergence (See <code><a href="#topic+scorematchingtheory">scorematchingtheory</a></code>): &quot;clr&quot; (centred log ratio), &quot;alr&quot; (additive log ratio), &quot;sqrt&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="ppi_+3A_method">method</code></td>
<td>
<p><code>"closed"</code> uses <code>CppAD</code> to solve in closed form the a quadratic score matching discrepancy using <code><a href="#topic+cppad_closed">cppad_closed()</a></code>. <code>"hardcoded"</code> uses hardcoded implementations. &quot;iterative&quot; uses <code><a href="#topic+cppad_search">cppad_search()</a></code> (which uses <code>CppAD</code> and <code><a href="optimx.html#topic+Rcgmin">optimx::Rcgmin()</a></code>) to iteratively find the minimum of the weighted Hyvärinen divergence.</p>
</td></tr>
<tr><td><code id="ppi_+3A_w">w</code></td>
<td>
<p>Weights for each observation, if different observations have different importance. Used by <code><a href="#topic+Windham">Windham()</a></code> and <code><a href="#topic+ppi_robust">ppi_robust()</a></code> for robust estimation.</p>
</td></tr>
<tr><td><code id="ppi_+3A_constrainbeta">constrainbeta</code></td>
<td>
<p>If <code>TRUE</code>, elements of <code class="reqn">\beta</code> that are less than <code>-1</code> are converted to <code>-1 + 1E-7</code>.</p>
</td></tr>
<tr><td><code id="ppi_+3A_bdryw">bdryw</code></td>
<td>
<p>The boundary weight function for down weighting measurements as they approach the manifold boundary. Either &quot;ones&quot;, &quot;minsq&quot; or &quot;prodsq&quot;. See details.</p>
</td></tr>
<tr><td><code id="ppi_+3A_acut">acut</code></td>
<td>
<p>The threshold <code class="reqn">a_c</code> in <code>bdryw</code> to avoid over-weighting measurements interior to the simplex</p>
</td></tr>
<tr><td><code id="ppi_+3A_bdrythreshold">bdrythreshold</code></td>
<td>
<p><code>iterative</code> or <code>closed</code> methods only. For measurements within <code>bdrythreshold</code> of the simplex boundary a Taylor approximation is applied by shifting the measurement <code>shiftsize</code> towards the center of the simplex.</p>
</td></tr>
<tr><td><code id="ppi_+3A_shiftsize">shiftsize</code></td>
<td>
<p><code>iterative</code> or <code>closed</code> methods only. For measurements within <code>bdrythreshold</code> of the simplex boundary a Taylor approximation is applied by shifting the measurement <code>shiftsize</code> towards the center of the simplex.</p>
</td></tr>
<tr><td><code id="ppi_+3A_approxorder">approxorder</code></td>
<td>
<p><code>iterative</code> or <code>closed</code> methods only. Order of the Taylor approximation for measurements on the boundary of the simplex.</p>
</td></tr>
<tr><td><code id="ppi_+3A_control">control</code></td>
<td>
<p><code>iterative</code> only. Passed to <code><a href="optimx.html#topic+Rcgmin">optimx::Rcgmin()</a></code> to control the iterative solver.</p>
</td></tr>
<tr><td><code id="ppi_+3A_paramvec_start">paramvec_start</code></td>
<td>
<p><code>iterative</code> method only. The starting guess for <code>Rcgmin</code>. Generate <code>paramvec_start</code> easily using <code><a href="#topic+ppi_paramvec">ppi_paramvec()</a></code>.</p>
</td></tr>
<tr><td><code id="ppi_+3A_evalparam">evalparam</code></td>
<td>
<p>The parameter set to evaluate the score matching values.
This is different to <code>paramvec</code>, which specifies which parameters to estimate.
All elements of <code>evalparam</code> must be non-NA, and any parameters fixed by <code>paramvec</code> must have the same value in <code>evalparam</code>.</p>
</td></tr>
<tr><td><code id="ppi_+3A_average">average</code></td>
<td>
<p>If TRUE return the (weighted average) of the measurements, otherwise return the values for each measurement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation may be performed via transformation of the measure in Hyvärinen divergence from Euclidean space to the simplex (inverse of the additive log ratio transform), from a hyperplane to the simplex (inverse of the centred log ratio transform), from the positive quadrant of the sphere to the simplex (inverse of the square root transform), or without any transformation. In the latter two situations there is a boundary and <em>weighted Hyvärinen divergence</em> (Equation 7, Scealy and Wood 2023) is used.
Properties of the estimator using the square root transform were studied by Scealy and Wood (2023).
Properties of the estimator using the additive log ratio transform were studied by Scealy et al. (2024).
</p>
<p>There are three boundary weight functions available:
</p>

<ul>
<li><p> The function &quot;ones&quot; applies no weights and should be used whenever the manifold does not have a boundary.
</p>
</li>
<li><p> The function &quot;minsq&quot; is the minima-based boundary weight function for the PPI model (Equation 12, Scealy and Wood 2023)
</p>
<p style="text-align: center;"><code class="reqn">\tilde{h}(z)^2 = \min(z_1^2, z_2^2, ..., z_p^2, a_c^2).</code>
</p>

<p>where <code class="reqn">z</code> is a point in the positive orthant of the p-dimensional unit sphere
and <code class="reqn">z_j</code> is the jth component of z.
</p>
</li>
<li><p> The function &quot;prodsq&quot; is the product-based (Equation 9, Scealy and Wood 2023)
</p>
<p style="text-align: center;"><code class="reqn">\tilde{h}(z)^2 = \min(\prod_{j=1}^{p} z_j^2, a_c^2).</code>
</p>

<p>where <code class="reqn">z</code> is a point in the positive orthant of the p-dimensional unit sphere
and <code class="reqn">z_j</code> is the jth component of z.
</p>
</li></ul>

<p>Scealy and Wood (Theorem 1, Scealy and Wood 2023) prove that minimising the weighted Hyvärinen Divergence is equivalent to minimising <code class="reqn">\psi(f, f_0)</code> (See <code><a href="#topic+scorematchingtheory">scorematchingtheory</a></code>)
when the boundary weight function is smooth or for the functions &quot;minsq&quot; and &quot;prodsq&quot;  above when the manifold is the simplex or positive orthant of a sphere.
</p>
<p>Hard-coded estimators are available for the following situations:
</p>

<ul>
<li><p> Square root transformation (&quot;sqrt&quot;) with the &quot;minsq&quot; boundary weight function:
</p>

<ul>
<li><p> full parameter vector (<code>paramvec</code> not provided)
</p>
</li>
<li> <p><code>paramvec</code> fixes only the final element of <code class="reqn">\beta</code>
</p>
</li>
<li> <p><code>paramvec</code> fixes all elements of <code class="reqn">\beta</code>
</p>
</li>
<li> <p><code>paramvec</code> fixes <code class="reqn">b_L = 0</code> and provides fixed values of <code class="reqn">\beta</code>
</p>
</li>
<li> <p><code>paramvec</code> fixes <code class="reqn">A_L=0</code> and <code class="reqn">b_L=0</code>, leaving <code class="reqn">\beta</code> to be fitted.
</p>
</li></ul>

</li>
<li><p> Square root transformation (&quot;sqrt&quot;) with the &quot;prodsq&quot; boundary weight function:
</p>

<ul>
<li> <p><code>paramvec</code> fixes all elements of <code class="reqn">\beta</code>
</p>
</li>
<li> <p><code>paramvec</code> fixes <code class="reqn">b_L = 0</code> and provides fixed values of <code class="reqn">\beta</code>
</p>
</li>
<li> <p><code>paramvec</code> fixes <code class="reqn">A_L=0</code> and <code class="reqn">b_L=0</code>, leaving <code class="reqn">\beta</code> to be fitted.
</p>
</li></ul>

</li>
<li><p> The additive log ratio transformation (&quot;alr&quot;) using the final component on the denominator, with <code class="reqn">b_L=0</code> and fixed final component of <code class="reqn">\beta</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>ppi()</code> returns:
A list of <code>est</code>, <code>SE</code> and <code>info</code>.
</p>

<ul>
<li> <p><code>est</code> contains the estimates in vector form, <code>paramvec</code>, and as <code class="reqn">A_L</code>, <code class="reqn">b_L</code> and <code class="reqn">\beta</code>.
</p>
</li>
<li> <p><code>SE</code> contains estimates of the standard errors if computed. See <code><a href="#topic+cppad_closed">cppad_closed()</a></code>.
</p>
</li>
<li> <p><code>info</code> contains a variety of information about the model fitting procedure and results.
</p>
</li></ul>

<p><code>ppi_smvalues()</code> returns a list of
</p>

<ul>
<li> <p><code>obj</code> the score matching discrepancy value
</p>
</li>
<li> <p><code>grad</code> the gradient of the score matching discrepancy
</p>
</li>
<li> <p><code>hess</code> the Hessian of the score matching discrepancy
</p>
</li>
<li> <p><code>offset</code> gradient offset (see <code><a href="#topic+quadratictape_parts">quadratictape_parts()</a></code>)
</p>
</li></ul>



<h3>PPI Model</h3>

<p>The PPI model density is proportional to
</p>
<p style="text-align: center;"><code class="reqn">\exp(z_L^TA_Lz_L + b_L^Tz_L)\prod_{i=1}^p z_i^{\beta_i},</code>
</p>

<p>where <code class="reqn">p</code> is the dimension of a compositional measurement <code class="reqn">z</code>, and <code class="reqn">z_L</code> is <code class="reqn">z</code> without the final (<code class="reqn">p</code>th) component.
<code class="reqn">A_L</code> is a <code class="reqn">p-1 \times p-1</code> symmetric matrix that controls the covariance between components.
<code class="reqn">b_L</code> is a <code class="reqn">p-1</code> vector that controls the location within the simplex.
The <code class="reqn">i</code>th component <code class="reqn">\beta_i</code> of <code class="reqn">\beta</code> controls the concentration of density when <code class="reqn">z_i</code> is close to zero: when <code class="reqn">\beta_i \geq 0</code> there is no concentration and <code class="reqn">\beta_i</code> is hard to identify; when <code class="reqn">\beta_i &lt; 0</code> then the probability density of the PPI model increases unboundedly as <code class="reqn">z_i</code> approaches zero, with the increasing occurring more rapidly and sharply the closer <code class="reqn">\beta_i</code> is to <code class="reqn">-1</code>.
</p>


<h3>References</h3>

<p>Scealy JL, Hingee KL, Kent JT, Wood ATA (2024).
&ldquo;Robust score matching for compositional data.&rdquo;
<em>Statistics and Computing</em>, <b>34</b>, 93.
<a href="https://doi.org/10.1007/s11222-024-10412-w">doi:10.1007/s11222-024-10412-w</a>.<br /><br /> Scealy JL, Wood ATA (2023).
&ldquo;Score matching for compositional distributions.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>118</b>(543), 1811&ndash;1823.
<a href="https://doi.org/10.1080/01621459.2021.2016422">doi:10.1080/01621459.2021.2016422</a>.
</p>


<h3>See Also</h3>

<p>Other PPI model tools: 
<code><a href="#topic+dppi">dppi</a>()</code>,
<code><a href="#topic+ppi_param_tools">ppi_param_tools</a></code>,
<code><a href="#topic+ppi_robust">ppi_robust</a>()</code>,
<code><a href="#topic+rppi">rppi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- rppi_egmodel(100)
estalr &lt;- ppi(model$sample,
              paramvec = ppi_paramvec(betap = -0.5, p = ncol(model$sample)),
              trans = "alr")
estsqrt &lt;- ppi(model$sample,
              trans = "sqrt",
              bdryw = "minsq", acut = 0.1)
</code></pre>

<hr>
<h2 id='ppi_cW'>Quickly Generate a Vector of Windham Exponents for the PPI Model</h2><span id='topic+ppi_cW'></span><span id='topic+ppi_cW_auto'></span>

<h3>Description</h3>

<p>These functions help to quickly generate a set of Windham exponents for use in <code><a href="#topic+ppi_robust">ppi_robust()</a></code> or <code><a href="#topic+Windham">Windham()</a></code>.
Rows and columns of <code class="reqn">A_L</code> and <code class="reqn">b_L</code> corresponding to components with strong concentrations of probability mass near zero have non-zero constant tuning exponent, and all other elements have a tuning constant of zero.
All elements of <code class="reqn">\beta</code> have a tuning exponent of zero.
</p>
<p>The function <code>ppi_cW_auto()</code> automatically detects concentrations near zero by fitting a PPI distribution with <code class="reqn">A_L=0</code> and <code class="reqn">b_L=0</code> (i.e. a Dirichlet distribution) with the centred log-ratio transformation of the manifold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppi_cW(cW, ...)

ppi_cW_auto(cW, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppi_cW_+3A_cw">cW</code></td>
<td>
<p>The value of the non-zero Windham tuning exponents.</p>
</td></tr>
<tr><td><code id="ppi_cW_+3A_...">...</code></td>
<td>
<p>Values of <code>TRUE</code> or <code>FALSE</code> in the same order of the components specifying that a component has probability mass concentrated near zero.</p>
</td></tr>
<tr><td><code id="ppi_cW_+3A_y">Y</code></td>
<td>
<p>A matrix of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Windham robustifying method involves weighting observations by a function of the proposed model density (Windham 1995).
Scealy et al. (2024) found that only some of the tuning constants should be non-zero:
the tuning exponents corresponding to <code class="reqn">\beta</code> should be zero to avoid infinite weights;and to improve efficiency any rows or columns of <code class="reqn">A_L</code> corresponding to components without concentrations of probability mass (i.e. outliers can't exist) should have exponents of zero.
Scealy et al. (2024) set the remaining tuning exponents to a constant.
</p>


<h3>Value</h3>

<p>A vector of the same length as the parameter vector of the PPI model. Elements of <code class="reqn">A_L</code> will have a value of <code>cW</code> if both their row and column component has probability mass concentrated near zero. Similarly, elements of <code class="reqn">b_L</code> will have a value of <code>cW</code> if their row corresponds to a component that has a probability mass concentrated near zero. All other elements are zero.
</p>


<h3>References</h3>

<p>Scealy JL, Hingee KL, Kent JT, Wood ATA (2024).
&ldquo;Robust score matching for compositional data.&rdquo;
<em>Statistics and Computing</em>, <b>34</b>, 93.
<a href="https://doi.org/10.1007/s11222-024-10412-w">doi:10.1007/s11222-024-10412-w</a>.<br /><br /> Windham MP (1995).
&ldquo;Robustifying Model Fitting.&rdquo;
<em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, <b>57</b>(3), 599&ndash;609.
2346159, <a href="http://www.jstor.org/stable/2346159">http://www.jstor.org/stable/2346159</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- rppi_egmodel(100)$sample
ppi_cW_auto(0.01, Y)
ppi_cW(0.01, TRUE, TRUE, FALSE)
</code></pre>

<hr>
<h2 id='ppi_mmmm'>A PPI Score-Matching Marginal Moment Matching Estimator (dimension=3 only)</h2><span id='topic+ppi_mmmm'></span>

<h3>Description</h3>

<p>Computes a marginal moment matching estimator (Section 6.2, Scealy and Wood 2023), which assumes <code class="reqn">\beta</code> is a known vector with the same value in each element, and <code class="reqn">b_L = 0</code>.
Only <code class="reqn">A_L</code> is estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppi_mmmm(Y, ni, beta0, w = rep(1, nrow(Y)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppi_mmmm_+3A_y">Y</code></td>
<td>
<p>Count data, each row is a multivariate observation.</p>
</td></tr>
<tr><td><code id="ppi_mmmm_+3A_ni">ni</code></td>
<td>
<p>The total for each sample (sum across rows)</p>
</td></tr>
<tr><td><code id="ppi_mmmm_+3A_beta0">beta0</code></td>
<td>
<p><code class="reqn">\beta=\beta_0</code> is the same for each component.</p>
</td></tr>
<tr><td><code id="ppi_mmmm_+3A_w">w</code></td>
<td>
<p>Weights for each observation. Useful for weighted estimation in <code><a href="#topic+Windham">Windham()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">\beta=\beta_0</code> is fixed and not estimated. <code class="reqn">b_L</code> is fixed at zero.
See (Section 6.2 and A.8 of Scealy and Wood 2023).
The boundary weight function in the score matching discrepancy is the unthresholded product weight function
</p>
<p style="text-align: center;"><code class="reqn">h(z)^2 = \min\left(\prod_{j=1}^{p} z_j^2, a_c^2\right).</code>
</p>



<h3>Value</h3>

<p>A vector of estimates for <code class="reqn">A_L</code> entries (diagonal and off diagonal).
</p>


<h3>References</h3>

<p>Scealy JL, Wood ATA (2023).
&ldquo;Score matching for compositional distributions.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>118</b>(543), 1811&ndash;1823.
<a href="https://doi.org/10.1080/01621459.2021.2016422">doi:10.1080/01621459.2021.2016422</a>.
</p>

<hr>
<h2 id='ppi_param_tools'>PPI Parameter Tools</h2><span id='topic+ppi_param_tools'></span><span id='topic+ppi_paramvec'></span><span id='topic+ppi_parammats'></span><span id='topic+ppi_toAstar'></span><span id='topic+ppi_fromAstar'></span>

<h3>Description</h3>

<p>The default parameterisation of the PPI model is a symmetric covariance-like matrix <code class="reqn">A_L</code>, a location-like vector <code class="reqn">b_L</code> and a set of Dirichlet exponents <code class="reqn">\beta</code>. For <code>p</code> components, <code class="reqn">A_L</code> has <code>p-1</code> rows, <code class="reqn">b_L</code> is a vector with <code>p-1</code> elements and <code class="reqn">\beta</code> is a vector with <code>p</code> elements.
For score matching estimation this form of the parameters must be converted into a single parameter vector using <code>ppi_paramvec()</code>.
<code>ppi_paramvec()</code> also includes easy methods to set parameters to <code>NA</code> for estimation with <code><a href="#topic+ppi">ppi()</a></code> (in <code><a href="#topic+ppi">ppi()</a></code> the NA-valued elements are estimated and all other elements are fixed).
The reverse of <code>ppi_paramvec()</code> is <code>ppi_parammats()</code>.
An alternative parametrisation of the PPI model uses a single <code>p</code> by <code>p</code>  matrix <code class="reqn">A^*</code> instead of <code class="reqn">A_L</code> and <code class="reqn">b_L</code>, and for identifiability <code class="reqn">A^*</code> is such that <code class="reqn">1^T A^* 1 = 0</code> where <code class="reqn">1=(1,1,...,1)</code> and <code class="reqn">0=(0,0,..., 0)</code> (Scealy and Wood 2023).
Convert between parametrisations using <code>ppi_toAstar()</code> and <code>ppi_fromAstar()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppi_paramvec(
  p = NULL,
  AL = NULL,
  bL = NULL,
  Astar = NULL,
  beta = NULL,
  betaL = NULL,
  betap = NULL
)

ppi_parammats(paramvec)

ppi_toAstar(AL, bL)

ppi_fromAstar(Astar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppi_param_tools_+3A_p">p</code></td>
<td>
<p>The number of components. If <code>NULL</code> then <code>p</code> will be inferred from other inputs.</p>
</td></tr>
<tr><td><code id="ppi_param_tools_+3A_al">AL</code></td>
<td>
<p>Either <code>NULL</code>, a p-1 x p-1 symmetric matrix, a number, or &quot;diag&quot;.
If NULL then all <code class="reqn">A_L</code> elements will be set to NA.
If a single number, then <code class="reqn">A_L</code> will be fixed as a matrix of the given value.
If &quot;diag&quot; then the non-diagonal elements of <code class="reqn">A_L</code> will be fixed to 0, and the diagonal will be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="ppi_param_tools_+3A_bl">bL</code></td>
<td>
<p>Either <code>NULL</code>, a number, or a vector of length p-1.
If <code>NULL</code>, then all elements of <code class="reqn">b_L</code> will be set to <code>NA</code>.
If a single number, then <code class="reqn">b_L</code> will be fixed at the supplied value.</p>
</td></tr>
<tr><td><code id="ppi_param_tools_+3A_astar">Astar</code></td>
<td>
<p>The <code class="reqn">A^*</code> matrix (a p by p symmetric matrix)</p>
</td></tr>
<tr><td><code id="ppi_param_tools_+3A_beta">beta</code></td>
<td>
<p>Either <code>NULL</code>, a number, or a vector of length p.
If NULL then all elements of <code class="reqn">\beta</code> will be set to <code>NA</code>.
If a single number then the <code class="reqn">\beta</code> elements will be fixed at the given number.</p>
</td></tr>
<tr><td><code id="ppi_param_tools_+3A_betal">betaL</code></td>
<td>
<p>Either <code>NULL</code>, a number, or a vector of length p-1.
If <code>NULL</code> then the 1...(p-1)th <code class="reqn">\beta</code> elements will be set to <code>NA</code>.
If a single number then the 1...(p-1)th <code class="reqn">\beta</code> elements will be fixed at the given number.</p>
</td></tr>
<tr><td><code id="ppi_param_tools_+3A_betap">betap</code></td>
<td>
<p>Either <code>NULL</code> or a number.
If <code>NULL</code> then the <code>p</code>th element of <code class="reqn">\beta</code> will be set to <code>NA</code>, and <code><a href="#topic+ppi">ppi()</a></code> will estimate it.
If a number, then the pth element of <code class="reqn">\beta</code> will be fixed at the given value.</p>
</td></tr>
<tr><td><code id="ppi_param_tools_+3A_paramvec">paramvec</code></td>
<td>
<p>A PPI parameter vector, typically created by <code><a href="#topic+ppi_paramvec">ppi_paramvec()</a></code> or as an output of <code><a href="#topic+ppi">ppi()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ppi_paramvec()</code> returns a vector starting with the diagonal elements of <code class="reqn">A_L</code>, then the off-diagonal elements extracted by <code><a href="base.html#topic+upper.tri">upper.tri()</a></code> (which extracts elements of <code class="reqn">A_L</code> along each row, left to right, then top to bottom), then <code class="reqn">b_L</code>, then <code class="reqn">\beta</code>.
</p>
<p>The <code>Astar</code> parametrisation rewrites the PPI density as proportional to
</p>
<p style="text-align: center;"><code class="reqn">\exp(z^TA^*z)\prod_{i=1}^p z_i^{\beta_i},</code>
</p>

<p>where <code class="reqn">A^*</code> (<code>Astar</code>) is a <code class="reqn">p</code> by <code class="reqn">p</code> matrix.
Because <code class="reqn">z</code> lies in the simplex (in particular <code class="reqn">\sum z_i = 1</code>), the density is the same regardless of the value of <code class="reqn">1^T A^* 1</code>=<code>sum(Astar)</code>, where <code class="reqn">1</code> is the vector of ones. Thus <code class="reqn">A_L</code> and <code class="reqn">b_L</code> specify <code class="reqn">A^*</code> up to an additive factor. In the conversion <code>ppi_toAstar()</code>, <code class="reqn">A^*</code> is returned such that <code class="reqn">1^T A^* 1 = 0</code>.
<code>NULL</code> values or <code>NA</code> elements are not allowed for <code>ppi_toAstar()</code> and <code>ppi_fromAstar()</code>.
</p>


<h3>Value</h3>

<p><code>ppi_paramvec()</code>: a vector of length <code class="reqn">p + (p-1)(2 + (p-1)/2)</code>.
</p>
<p><code>ppi_parammats()</code>: A named list of <code class="reqn">A_L</code>, <code class="reqn">b_L</code>, and <code class="reqn">\beta</code>.
</p>
<p><code>ppi_toAstar()</code>: The matrix <code class="reqn">A^*</code>.
</p>
<p><code>ppi_fromAstar()</code>: A list of the matrix <code class="reqn">A_L</code>, the vector <code class="reqn">b_L</code> and a discarded constant.
</p>


<h3>PPI Model</h3>

<p>The PPI model density is proportional to
</p>
<p style="text-align: center;"><code class="reqn">\exp(z_L^TA_Lz_L + b_L^Tz_L)\prod_{i=1}^p z_i^{\beta_i},</code>
</p>

<p>where <code class="reqn">p</code> is the dimension of a compositional measurement <code class="reqn">z</code>, and <code class="reqn">z_L</code> is <code class="reqn">z</code> without the final (<code class="reqn">p</code>th) component.
<code class="reqn">A_L</code> is a <code class="reqn">p-1 \times p-1</code> symmetric matrix that controls the covariance between components.
<code class="reqn">b_L</code> is a <code class="reqn">p-1</code> vector that controls the location within the simplex.
The <code class="reqn">i</code>th component <code class="reqn">\beta_i</code> of <code class="reqn">\beta</code> controls the concentration of density when <code class="reqn">z_i</code> is close to zero: when <code class="reqn">\beta_i \geq 0</code> there is no concentration and <code class="reqn">\beta_i</code> is hard to identify; when <code class="reqn">\beta_i &lt; 0</code> then the probability density of the PPI model increases unboundedly as <code class="reqn">z_i</code> approaches zero, with the increasing occurring more rapidly and sharply the closer <code class="reqn">\beta_i</code> is to <code class="reqn">-1</code>.
</p>


<h3>See Also</h3>

<p>Other PPI model tools: 
<code><a href="#topic+dppi">dppi</a>()</code>,
<code><a href="#topic+ppi">ppi</a>()</code>,
<code><a href="#topic+ppi_robust">ppi_robust</a>()</code>,
<code><a href="#topic+rppi">rppi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ppi_paramvec(AL = "diag", bL = 0, betap = -0.5, p = 3)
vec &lt;- ppi_paramvec(AL = rsymmetricmatrix(2), beta = c(-0.8, -0.7, 0))
ppi_parammats(vec)
Astar &lt;- rWishart(1, 6, diag(3))[,,1]
ppi_fromAstar(Astar)
ppi_toAstar(ppi_fromAstar(Astar)$AL, ppi_fromAstar(Astar)$bL)
</code></pre>

<hr>
<h2 id='ppi_robust'>Robustly Estimate Parameters of the PPI Distribution</h2><span id='topic+ppi_robust'></span><span id='topic+ppi_robust_alrgengamma'></span>

<h3>Description</h3>

<p><code>ppi_robust()</code> uses <code><a href="#topic+Windham">Windham()</a></code> and <code><a href="#topic+ppi">ppi()</a></code> to estimate a PPI distribution robustly.
There are many arguments to the <code><a href="#topic+ppi">ppi()</a></code> function and we highly recommend testing your arguments on <code><a href="#topic+ppi">ppi()</a></code> first before running <code>ppi_robust()</code>.
</p>
<p><code>ppi_robust_alrgengamma()</code> performs the Windham robustification algorithm exactly as described in Scealy et al. (2024) for score matching via log-ratio transform of the PPI model with <code class="reqn">b_L = 0</code>. This function calls the more general <code><a href="#topic+Windham">Windham()</a></code> and <code><a href="#topic+ppi">ppi()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppi_robust(Y, cW, ...)

ppi_robust_alrgengamma(
  Y,
  cW,
  ...,
  fpcontrol = list(Method = "Simple", ConvergenceMetricThreshold = 1e-10)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppi_robust_+3A_y">Y</code></td>
<td>
<p>A matrix of measurements. Each row is a measurement, each component is a dimension of the measurement.</p>
</td></tr>
<tr><td><code id="ppi_robust_+3A_cw">cW</code></td>
<td>
<p>A vector of robustness tuning constants. Easy to build using <code><a href="#topic+ppi_cW">ppi_cW()</a></code> and <code><a href="#topic+ppi_cW_auto">ppi_cW_auto()</a></code>. See <code><a href="#topic+Windham">Windham()</a></code> for more details on <code>cW</code>.</p>
</td></tr>
<tr><td><code id="ppi_robust_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+Windham">Windham()</a></code> and on to <code><a href="#topic+ppi">ppi()</a></code>.</p>
</td></tr>
<tr><td><code id="ppi_robust_+3A_fpcontrol">fpcontrol</code></td>
<td>
<p>A named list of control arguments to pass to <code><a href="FixedPoint.html#topic+FixedPoint">FixedPoint::FixedPoint()</a></code> for the fixed point iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ppi_robust_alrgengamma()</code>: must fit a PPI model via additive-log ratio transform of the simplex with <code class="reqn">b_L=0</code> fixed and the final element of <code class="reqn">\beta</code> fixed.
The default convergence metric and threshold are different to the default for <code><a href="#topic+ppi_robust">ppi_robust()</a></code> to match the implementation in (Scealy et al. 2024): convergence is measured by the change in the first element of <code class="reqn">\beta</code>, and convergence is reached when the change is smaller than <code>1E-6</code>. Override this behaviour by specifying the elements <code>ConvergenceMetric</code> and <code>ConvergenceMetricThreshold</code> in a list passed as <code>fpcontrol</code>.
<code><a href="#topic+Windham">Windham()</a></code> is called with <code>alternative_populationinverse = TRUE</code>.
</p>


<h3>Value</h3>

<p>A list:
</p>

<ul>
<li> <p><code>est</code> The estimated parameters in vector form (<code>paramvec</code>) and as <code>AL</code>, <code>bL</code> and <code>beta</code>.
</p>
</li>
<li> <p><code>SE</code> &quot;Not calculated.&quot; Returned for consistency with other estimators.
</p>
</li>
<li> <p><code>info</code> Information returned in the <code>optim</code> slot of <code><a href="#topic+Windham">Windham()</a></code>. Includes the final weights in <code>finalweights</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Scealy JL, Hingee KL, Kent JT, Wood ATA (2024).
&ldquo;Robust score matching for compositional data.&rdquo;
<em>Statistics and Computing</em>, <b>34</b>, 93.
<a href="https://doi.org/10.1007/s11222-024-10412-w">doi:10.1007/s11222-024-10412-w</a>.
</p>


<h3>See Also</h3>

<p>Other PPI model tools: 
<code><a href="#topic+dppi">dppi</a>()</code>,
<code><a href="#topic+ppi">ppi</a>()</code>,
<code><a href="#topic+ppi_param_tools">ppi_param_tools</a></code>,
<code><a href="#topic+rppi">rppi</a>()</code>
</p>
<p>Other Windham robustness functions: 
<code><a href="#topic+Windham">Windham</a>()</code>,
<code><a href="#topic+vMF_robust">vMF_robust</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(7)
model &lt;- rppi_egmodel(100)
estsqrt &lt;- ppi_robust(model$sample,
  cW = ppi_cW_auto(0.01, model$sample),
  paramvec_start = model$theta,
  trans = "sqrt", bdryw = "minsq", acut = 0.1)
set.seed(14)
model &lt;- rppi_egmodel(100)
ppi_robust_alrgengamma(model$sample,
   cW = ppi_cW_auto(0.01, model$sample),
   paramvec = ppi_paramvec(betap = -0.5, p = ncol(model$sample)))
</code></pre>

<hr>
<h2 id='print+2CRcpp_ADFun'>Print or show a summary of an Rcpp_ADFun</h2><span id='topic+print+2CRcpp_ADFun'></span><span id='topic+print+2CRcpp_ADFun-method'></span><span id='topic+show+2CRcpp_ADFun-method'></span>

<h3>Description</h3>

<p>Both <code>print()</code> and <code>show()</code> will display a summary of a <a href="#topic+Rcpp_ADFun-class">Rcpp_ADFun</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_ADFun'
print(x, ...)

## S4 method for signature 'Rcpp_ADFun'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print+2B2CRcpp_ADFun_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+Rcpp_ADFun-class">Rcpp_ADFun</a>.</p>
</td></tr>
<tr><td><code id="print+2B2CRcpp_ADFun_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+format">format()</a></code>.</p>
</td></tr>
<tr><td><code id="print+2B2CRcpp_ADFun_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+Rcpp_ADFun-class">Rcpp_ADFun</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>show()</code> method overrides the default <code>show()</code> method for <code><a href="Rcpp.html#topic+CppObject-class">Rcpp::C++Object</a></code> objects from the <code>Rcpp</code> package.
</p>

<hr>
<h2 id='quadratictape_parts'>Evaluate the Hessian and Gradient Offset of a Taped Quadratic Function</h2><span id='topic+quadratictape_parts'></span>

<h3>Description</h3>

<p>When the score matching discrepancy function is quadratic then the gradient of the score matching discrepancy function can be written using the Hessian and an offset term. This can be useful for solving for the situation when the gradient is zero.
The Hessian and offset term are computed using <code>CppAD</code> tapes.
Taylor approximation can be used for locations at removed singularities (i.e. where intermediate values are unbounded).
<code>quadratictape_parts()</code> will error if <code>testquadratic(tape)</code> returns <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadratictape_parts(tape, tmat, tcentres = NA * tmat, approxorder = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadratictape_parts_+3A_tape">tape</code></td>
<td>
<p>A tape of a quadratic function where the independent and dynamic parameters correspond to the <code class="reqn">x</code> and <code class="reqn">t</code> in the details section, respectively. For score matching <code>tape</code> should be a tape of the score matching discrepancy function <code class="reqn">A(z) + B(z) + C(z)</code> in <code><a href="#topic+scorematchingtheory">scorematchingtheory</a></code> with <code class="reqn">z</code> the <em>dynamic parameters</em> and the model parameters the <em>independent variable</em> (which is the usual for the return of <code><a href="#topic+tape_smd">tape_smd()</a></code>).</p>
</td></tr>
<tr><td><code id="quadratictape_parts_+3A_tmat">tmat</code></td>
<td>
<p>A matrix of vectors corresponding to values of <code class="reqn">t</code> (see details). Each row corresponds to a vector. For score matching, these vectors are measurements.</p>
</td></tr>
<tr><td><code id="quadratictape_parts_+3A_tcentres">tcentres</code></td>
<td>
<p>A matrix of Taylor approximation centres for rows of <code>tmat</code> that require approximation. <code>NA</code> for rows that do not require approximation.</p>
</td></tr>
<tr><td><code id="quadratictape_parts_+3A_approxorder">approxorder</code></td>
<td>
<p>The order of the Taylor approximation to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A quadratic function can be written
</p>
<p style="text-align: center;"><code class="reqn">f(x; t) = \frac{1}{2} x^T W(t) x + b(t)^T x + c,</code>
</p>

<p>where <code class="reqn">t</code> is considered a vector that is constant with respect to the differentiation.
The Hessian of the function is with respect to <code class="reqn">x</code> is
</p>
<p style="text-align: center;"><code class="reqn">H f(x; t) = \frac{1}{2}(W(t) + W(t)^T).</code>
</p>

<p>The gradient of the function with respect to <code class="reqn">x</code> can then be written
</p>
<p style="text-align: center;"><code class="reqn">\Delta f(x;t) = H f(x; t) x + b(t)^T x,</code>
</p>

<p>where the Hessian and offset <code class="reqn">b(t)</code> depend only on <code class="reqn">t</code>.
</p>
<p>The functions here evaluate the Hessian and offset <code class="reqn">b(t)</code> for many values of <code class="reqn">t</code>.
Tapes of the Hessian and gradient offset are created using <code><a href="#topic+tape_Hessian">tape_Hessian()</a></code> and <code><a href="#topic+tape_gradoffset">tape_gradoffset()</a></code> respectively.
These tapes are then evaluated for every row of <code>tmat</code>.
When the corresponding <code>tcentres</code> row is not <code>NA</code>, then approximate (but very accurate) results are calculated using Taylor approximation around the location given by the row of <code>tcentres</code>.
</p>
<p>For score matching <code class="reqn">x</code> is the set of model parameters and the vector <code class="reqn">t</code> is a (multivariate) measurement.
</p>


<h3>Value</h3>

<p>A list of
</p>

<ul>
<li> <p><code>offset</code> Array of offsets <code class="reqn">b(t)</code>, each row corresponding to a row in <code>tmat</code>
</p>
</li>
<li> <p><code>Hessian</code> Array of vectorised <code class="reqn">H f(x; t)</code> (see <code><a href="#topic+tape_Hessian">tape_Hessian()</a></code>), each row corresponding to a row in <code>tmat</code>. For each row, obtain the Hessian in matrix format by using <code>matrix(ncol = length(tape$xtape))</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other tape evaluators: 
<code><a href="#topic+evaltape">evaltape</a>()</code>,
<code><a href="#topic+smvalues">smvalues</a>()</code>,
<code><a href="#topic+testquadratic">testquadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- rep(1/3, 3)
smdtape &lt;- tape_smd("sim", "sqrt", "sph", "ppi",
              ytape = u,
              usertheta = ppi_paramvec(p = 3),
              bdryw = "minsq", acut = 0.01,
              verbose = FALSE
              )$smdtape
quadratictape_parts(smdtape, 
  tmat = rbind(u, c(1/4, 1/4, 1/2)))
</code></pre>

<hr>
<h2 id='Rcpp_ADFun-class'>A Class for CppAD Tapes</h2><span id='topic+Rcpp_ADFun-class'></span><span id='topic+Rcpp_ADFun'></span><span id='topic+ADFun'></span>

<h3>Description</h3>

<p>Objects of type <code>Rcpp_ADFun</code> contain a tape of a <code style="white-space: pre;">&#8288;C++&#8288;</code> function (which has class <code>ADFun</code> in <code>CppAD</code>). These tapes are a record of operations performed by a function. Tapes can be evaluated and differentiated, and have properties (such as domain and range dimensions). Tapes also have dynamic parameters that can be updated. This class, <code>Rcpp_ADFun</code> uses reference semantics, so that copies all point to the same object and changes modify in place (i.e. changes modify the same object).
Properties and methods of an <code>Rcpp_ADFun</code> object are accessed via <code>$</code>.
</p>


<h3>Details</h3>

<p>An object of class <code>Rcpp_ADFun</code> wraps an <code>ADFun</code> object from <code>CppAD</code>. Many of the properties and behaviour of an <code>Rcpp_ADFun</code> object come directly from <code>ADFun</code> objects so more details and context can be found by looking at the <code>ADFun</code> object help in the <code>CppAD</code> <a href="https://cppad.readthedocs.io"><code>help</code></a>.
The methods <code>eval()</code>, <code>Jac()</code> and <code>Hes()</code> have been added by <code>scorematchingad</code> as there were many cases where this seemed like an easier way to evaluate a tape.
</p>
<p>Default printing of an <code>Rcpp_ADFun</code> object gives a short summary of the object, see <code><a href="#topic+print+2CRcpp_ADFun">print,Rcpp_ADFun</a></code>.
</p>
<p>Tapes cannot be saved from session to session.
</p>


<h3>Methods - Tape Properties:</h3>


<ul>
<li> <p><code style="white-space: pre;">&#8288;$size_order&#8288;</code> Number of Taylor coefficient orders, per variable and direction, currently calculated and stored in the object.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$domain&#8288;</code> Dimension of the domain space (i.e., length of the independent variables vector <code>x</code>).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$range&#8288;</code> Dimension of the range space (i.e., length of the vector returned by <code style="white-space: pre;">&#8288;$eval()&#8288;</code>).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$size_dyn_ind&#8288;</code> Number of independent dynamic parameters (i.e., length of the vector of dynamic parameters <code>dyn</code>).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$name&#8288;</code> A name for the tape (may be empty). This is yet to incorporate the <code>CppAD</code> <code>function_name</code> property.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$xtape&#8288;</code> The values of the independent variables used for the initial taping.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$dyntape&#8288;</code> The values of the dynamic parameters used for the initial taping.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$get_check_for_nan()&#8288;</code> Debugging: Return whether the tape is configured to check for NaN values during computation. The check for NaN only occurs if the <code style="white-space: pre;">&#8288;C++&#8288;</code> compilation enables debugging.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$set_check_for_nan(bool)&#8288;</code> Set whether the tape should check for NaN values during computation (only effective if C++ debugging is enabled).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$parameter(i)&#8288;</code> Check if the <code>i</code>th component of the range corresponds to a constant parameter. Indexing is by the <code style="white-space: pre;">&#8288;C++&#8288;</code> default, that is the first component has index <code>0</code>, the last component has index <code style="white-space: pre;">&#8288;$range - 1&#8288;</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$new_dynamic(dyn)&#8288;</code> Specify new values for the dynamic parameters.
</p>
</li></ul>



<h3>Methods - Tape Evaluation:</h3>


<ul>
<li> <p><code style="white-space: pre;">&#8288;$eval(x, dyn)&#8288;</code> Evaluate the function at new values of the variables and dynamic parameters. Returns a vector of length <code style="white-space: pre;">&#8288;$range&#8288;</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$Jac(x, dyn)&#8288;</code> Compute the Jacobian at new values of the variables and dynamic parameters. Returns a vector of length <code style="white-space: pre;">&#8288;$range * $domain&#8288;</code> arranged so that the first <code style="white-space: pre;">&#8288;$domain&#8288;</code> elements correspond to the gradient of the first element of the range. The next <code style="white-space: pre;">&#8288;$domain&#8288;</code> elements correspond to the gradient of the second element of the range, and so on.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$Hes(x, dyn)&#8288;</code> Compute the Hessian of the first element of the range at new values of the variables and dynamic parameters. Returns a vector of length <code style="white-space: pre;">&#8288;$domain * $domain&#8288;</code> where the <code>j*n + l</code> element corresponds to differentiating with respect to the <code>l</code>th element of the domain, then with respect to the <code>j</code>th element of the domain, with <code>n</code> the size of the domain.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$Jacobian(x)&#8288;</code> Evaluate the Jacobian of the function at the current set of dynamic parameters.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$Hessiani(x, i)&#8288;</code> Evaluate the Hessian for the <code>i</code>-th element of the range (where <code>i = 0, 1, ...</code>). Returns a vector arranged the same as <code style="white-space: pre;">&#8288;$Hes()&#8288;</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$Hessian0(x)&#8288;</code> Evaluate the Hessian for the first element of the range (like <code style="white-space: pre;">&#8288;$Hes()&#8288;</code> but uses the current values of the dynamic parameters). Returns a vector arranged the same as <code style="white-space: pre;">&#8288;$Hes()&#8288;</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$Hessianw(x, w)&#8288;</code> Evaluate the Hessian for a weighted sum of the range. Returns a vector arranged the same as <code style="white-space: pre;">&#8288;$Hes()&#8288;</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$forward(q, x)&#8288;</code> Perform forward mode evaluation for the specified Taylor coefficient order <code>q</code>. See the <a href="https://cppad.readthedocs.io"><code>CppAD</code> help</a> for more.
</p>
</li></ul>



<h3>Method Arguments</h3>


<ul>
<li> <p><code>x</code> A vector of independent variables.
</p>
</li>
<li> <p><code>dyn</code> A vector of dynamic parameters.
</p>
</li>
<li> <p><code>q</code> Taylor coefficient order for evaluating derivatives with <code style="white-space: pre;">&#8288;$forward()&#8288;</code>.
</p>
</li>
<li> <p><code>i</code> Index of range result. <code style="white-space: pre;">&#8288;i = 0, 1, ..., $range - 1&#8288;</code>.
</p>
</li>
<li> <p><code>bool</code> Either <code>TRUE</code> or <code>FALSE</code> to set <code>check_for_nan</code> behaviour using <code style="white-space: pre;">&#8288;$set_check_for_nan()&#8288;</code>.
</p>
</li>
<li> <p><code>w</code> Weights assigned to each element of the range, for use with <code style="white-space: pre;">&#8288;$Hessianw()&#8288;</code>.
</p>
</li></ul>



<h3>Extends</h3>

<p>Extends class <code>C++Object</code> from the <code>Rcpp</code> package (<code><a href="Rcpp.html#topic+CppObject-class">Rcpp::C++Object</a></code>), which is a <code style="white-space: pre;">&#8288;reference class&#8288;</code>.
For those familiar with <code style="white-space: pre;">&#8288;C++&#8288;</code>, an object of class <code>Rcpp_ADFun</code> contains a pointer to a <code>CppAD</code> <code>ADFun</code> object.
</p>


<h3>Introduction to CppAD Tapes</h3>

<p>This package uses version 2024000.5 of the algorithmic differentiation library <code>CppAD</code> (Bell 2023) to build score matching estimators.
Full help for <code>CppAD</code> can be found at <a href="https://cppad.readthedocs.io/">https://cppad.readthedocs.io/</a>.
</p>
<p>When using <code>CppAD</code> one first creates a <em>tape</em> of the basic (<em>atomic</em>) operations of a function.
The atomic operations include multiplication, division, addition, sine, cosine, exponential and many more.
These tapes can then be used for evaluating the function and its derivatives, and generating further tapes through argument swapping, differentiation and composition (see for example <code><a href="#topic+tape_swap">tape_swap()</a></code> and <code><a href="#topic+tape_Jacobian">tape_Jacobian()</a></code>).
Tapes can have both <em>independent</em> variables and <em>dynamic</em> parameters, and the differentiation occurs with respect to the independent variables.
The atomic operations within a function are taped by following the function evaluation on example values for the variables and parameters, so care must be taken with any conditional (e.g. if-then) operations, and <a href="https://cppad.readthedocs.io/"><code>CppAD</code></a> has a special tool for this called <code>CondExp</code> (short for <code style="white-space: pre;">&#8288;conditional expressions&#8288;</code>).
</p>
<p>The result of taping, called a <em>tape</em>, is exposed as an object of class <code><a href="#topic+Rcpp_ADFun">Rcpp_ADFun</a></code>, which contains a <code>CppAD</code> <code>ADFun</code> object.
Although the algorithmic differentiation is with respect to the independent variables, a new tape (see <code><a href="#topic+tape_swap">tape_swap()</a></code>) can be created where the dynamic parameters become independent variables.
For the purposes of score matching, there are also <em>fixed</em> parameters, which are the elements of the model's parameter vector that are given and not estimated.
</p>
<p>The example values used for taping are saved in the <code style="white-space: pre;">&#8288;$xtape&#8288;</code> and <code style="white-space: pre;">&#8288;$dyntape&#8288;</code> properties of <code><a href="#topic+Rcpp_ADFun">Rcpp_ADFun</a></code> objects.
</p>


<h3>Warning: multiple CPU</h3>

<p>Each time a tape is evaluated the corresponding <code style="white-space: pre;">&#8288;C++&#8288;</code> object is altered. Parallel use of the same <code>ADFun</code> object thus requires care and is not tested. For now I recommend creating a new <code>ADFun</code> object for each CPU.
</p>


<h3>Improvements</h3>

<p>A few methods for <code>CppAD</code> <code>ADFun</code> objects are not yet available through <code>Rcpp_ADFun</code> objects. These ones would be nice to include:
</p>

<ul>
<li> <p><code>optimize()</code>
</p>
</li>
<li> <p><code>function_name_set()</code> and <code>function_name_get()</code> working with <code style="white-space: pre;">&#8288;$name&#8288;</code>
</p>
</li>
<li> <p><code>Reverse()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>tape &lt;- tape_uld_inbuilt("dirichlet", c(0.1, 0.4, 0.5), c(-0.5, -0.4, -0.2))
# Convenient evaluation
tape$eval(x = c(0.2, 0.3, 0.5), dyn = c(-0.1, -0.1, -0.5))
tape$Jac(x = c(0.2, 0.3, 0.5), dyn = c(-0.1, -0.1, -0.5))
matrix(tape$Hes(x = c(0.2, 0.3, 0.5), dyn = c(-0.1, -0.1, -0.5)), nrow = tape$domain)

# Properties
tape$domain
tape$range
tape$size_dyn_ind
tape$name
tape$xtape
tape$dyntape
tape$size_order
tape$new_dynamic(dyn = c(-0.1, -0.1, -0.5))
tape$parameter(0)
tape$set_check_for_nan(FALSE)
tape$get_check_for_nan()

# Further methods
tape$forward(order = 0, x = c(0.2, 0.3, 0.5))
tape$Jacobian(x = c(0.2, 0.3, 0.5))
tape$Hessiani(x = c(0.2, 0.3, 0.5), i = 0)
tape$Hessian0(x = c(0.2, 0.3, 0.5))
tape$Hessianw(x = c(0.2, 0.3, 0.5), w = c(2))
</code></pre>

<hr>
<h2 id='rppi'>Simulate from a PPI Model</h2><span id='topic+rppi'></span><span id='topic+rppi_egmodel'></span>

<h3>Description</h3>

<p>Given parameters of the PPI model, generates independent samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rppi(n, ..., paramvec = NULL, maxden = 4, maxmemorysize = 1e+05)

rppi_egmodel(n, maxden = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rppi_+3A_n">n</code></td>
<td>
<p>Number of samples to generate</p>
</td></tr>
<tr><td><code id="rppi_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+ppi_paramvec">ppi_paramvec</a></code>
</p>

<dl>
<dt><code>AL</code></dt><dd><p>Either <code>NULL</code>, a p-1 x p-1 symmetric matrix, a number, or &quot;diag&quot;.
If NULL then all <code class="reqn">A_L</code> elements will be set to NA.
If a single number, then <code class="reqn">A_L</code> will be fixed as a matrix of the given value.
If &quot;diag&quot; then the non-diagonal elements of <code class="reqn">A_L</code> will be fixed to 0, and the diagonal will be <code>NA</code>.</p>
</dd>
<dt><code>bL</code></dt><dd><p>Either <code>NULL</code>, a number, or a vector of length p-1.
If <code>NULL</code>, then all elements of <code class="reqn">b_L</code> will be set to <code>NA</code>.
If a single number, then <code class="reqn">b_L</code> will be fixed at the supplied value.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Either <code>NULL</code>, a number, or a vector of length p.
If NULL then all elements of <code class="reqn">\beta</code> will be set to <code>NA</code>.
If a single number then the <code class="reqn">\beta</code> elements will be fixed at the given number.</p>
</dd>
<dt><code>betaL</code></dt><dd><p>Either <code>NULL</code>, a number, or a vector of length p-1.
If <code>NULL</code> then the 1...(p-1)th <code class="reqn">\beta</code> elements will be set to <code>NA</code>.
If a single number then the 1...(p-1)th <code class="reqn">\beta</code> elements will be fixed at the given number.</p>
</dd>
<dt><code>betap</code></dt><dd><p>Either <code>NULL</code> or a number.
If <code>NULL</code> then the <code>p</code>th element of <code class="reqn">\beta</code> will be set to <code>NA</code>, and <code><a href="#topic+ppi">ppi()</a></code> will estimate it.
If a number, then the pth element of <code class="reqn">\beta</code> will be fixed at the given value.</p>
</dd>
<dt><code>p</code></dt><dd><p>The number of components. If <code>NULL</code> then <code>p</code> will be inferred from other inputs.</p>
</dd>
<dt><code>Astar</code></dt><dd><p>The <code class="reqn">A^*</code> matrix (a p by p symmetric matrix)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="rppi_+3A_paramvec">paramvec</code></td>
<td>
<p>The PPI parameter vector, created easily using <code><a href="#topic+ppi_paramvec">ppi_paramvec()</a></code> and also returned by <code><a href="#topic+ppi">ppi()</a></code>. Use <code>paramvec</code> instead of <code>...</code>.</p>
</td></tr>
<tr><td><code id="rppi_+3A_maxden">maxden</code></td>
<td>
<p>This is the constant <code class="reqn">log(C)</code> in (Appendix A.1.3 Scealy and Wood 2023).</p>
</td></tr>
<tr><td><code id="rppi_+3A_maxmemorysize">maxmemorysize</code></td>
<td>
<p>Advanced use. The maximum size, in bytes, for matrices containing simulated Dirichlet samples. The default of <code>1E5</code> corresponds to 100 mega bytes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend running <code>rppi()</code> a number of times to ensure the choice of <code>maxden</code> is good. <code>rppi()</code> will error when <code>maxden</code> is too low.
</p>
<p>The simulation uses a rejection-sampling algorithm with Dirichlet proposal (Appendix A.1.3 Scealy and Wood 2023).
Initially <code>n</code> Dirichlet proposals are generated. After rejection there are fewer samples remaining, say <code class="reqn">n^*</code>.
The ratio <code class="reqn">n^*/n</code> is used to guess the number of new Dirichlet proposals to generate until <code>n</code> samples of the PPI model are reached.
</p>
<p>Advanced use: The number of Dirichlet proposals created at a time is limited such that the matrices storing the Dirchlet proposals are always smaller than <code>maxmemorysize</code> bytes (give or take a few bytes for wrapping).
Larger <code>maxmemorysize</code> leads to faster simulation so long as <code>maxmemorysize</code> bytes are reliably contiguously available in RAM.
</p>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>p</code> columns. Each row is an independent draw from the specified PPI distribution.
</p>
<p><code>rppi_egmodel</code> returns a list:
</p>

<ul>
<li> <p><code>sample</code> A matrix of the simulated samples (<code>n</code> rows)
</p>
</li>
<li> <p><code>p</code> The number of components of the model
</p>
</li>
<li> <p><code>theta</code> The PPI parameter vector
</p>
</li>
<li> <p><code>AL</code> The <code class="reqn">A_L</code> parameter matrix
</p>
</li>
<li> <p><code>bL</code> The <code class="reqn">b_L</code> parameter vector
</p>
</li>
<li> <p><code>beta</code> The <code class="reqn">\beta</code> parameter vector
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>rppi_egmodel()</code>: Simulates the 3-component PPI model from (Section 2.3, Scealy and Wood 2023) and returns both simulations and model parameters.
</p>
</li></ul>


<h3>References</h3>

<p>Scealy JL, Wood ATA (2023).
&ldquo;Score matching for compositional distributions.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>118</b>(543), 1811&ndash;1823.
<a href="https://doi.org/10.1080/01621459.2021.2016422">doi:10.1080/01621459.2021.2016422</a>.
</p>


<h3>See Also</h3>

<p>Other PPI model tools: 
<code><a href="#topic+dppi">dppi</a>()</code>,
<code><a href="#topic+ppi">ppi</a>()</code>,
<code><a href="#topic+ppi_param_tools">ppi_param_tools</a></code>,
<code><a href="#topic+ppi_robust">ppi_robust</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beta0=c(-0.8, -0.8, -0.5)
AL = diag(nrow = 2)
bL = c(2, 3)
samp &lt;- rppi(100,beta=beta0,AL=AL,bL=bL)
rppi_egmodel(1000)
</code></pre>

<hr>
<h2 id='rsymmetricmatrix'>Quickly Generate a Symmetric Matrix for Testing and Examples</h2><span id='topic+rsymmetricmatrix'></span>

<h3>Description</h3>

<p>A simple function for generating a symmetric matrix for use in examples.
The diagonal, and upper-triangular elements of the matrix are simulated independently from a uniform distribution. The lower-triangle of the output matrix is copied from the upper-triangle.
These matrices <strong>do not</strong> represent the full range of possible symmetric matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsymmetricmatrix(p, min = 0, max = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rsymmetricmatrix_+3A_p">p</code></td>
<td>
<p>The desired dimension of the matrix</p>
</td></tr>
<tr><td><code id="rsymmetricmatrix_+3A_min">min</code></td>
<td>
<p>The minimum of the uniform distribution.</p>
</td></tr>
<tr><td><code id="rsymmetricmatrix_+3A_max">max</code></td>
<td>
<p>The maximum of the uniform distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>p</code> x <code>p</code> symmetric matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rsymmetricmatrix(5)
</code></pre>

<hr>
<h2 id='scorematchingtheory'>Introduction to Score Matching</h2><span id='topic+scorematchingtheory'></span>

<h3>Description</h3>

<p>This package includes score matching estimators for particular distributions and a general capacity to implement additional score matching estimators.
Score matching is a popular estimation technique when normalising constants for the proposed model are difficult to calculate or compute.
Score matching was first developed by Hyvärinen (2005) and was further developed for subsets of Euclidean space (Hyvärinen 2007; Yu et al. 2019; Yu et al. 2020; Liu et al. 2019), Riemannian manifolds (Mardia et al. 2016; Mardia 2018),
and Riemannian manifolds with boundary (Scealy and Wood 2023).
In this help entry we briefly describe score matching estimation.
</p>


<h3>Score Matching in General</h3>

<p>In the most general form (Riemannian manifolds with boundary) score matching minimises the weighted Hyvärinen divergence (Equation 7, Scealy and Wood 2023)
</p>
<p style="text-align: center;"><code class="reqn">
\phi(f, f_0) =  \frac{1}{2} \int_M f_0(z)h(z)^2 \left\lVert P(z)\Big(\nabla_z \log(f) - \nabla_z \log(f_0)\Big)\right\rVert^2 dM(z),
</code>
</p>

<p>where
</p>

<ul>
<li> <p><code class="reqn">M</code> is the manifold, isometrically embedded in Euclidean space, and <code class="reqn">dM(z)</code> is the unnormalised uniform measure on <code class="reqn">M</code>.
</p>
</li>
<li> <p><code class="reqn">P(z)</code> is the matrix that projects points onto the tangent space of the manifold at <code class="reqn">z</code>, which is closely related to to Riemannian metric of <code class="reqn">M</code>.
</p>
</li>
<li> <p><code class="reqn">f_0</code> is the density of the data-generating process, defined with respect to <code class="reqn">dM(z)</code>.
</p>
</li>
<li> <p><code class="reqn">f</code> is the density of a posited model, again defined with respect to <code class="reqn">dM(z)</code>.
</p>
</li>
<li> <p><code class="reqn">h(z)</code> is a function, termed the <em>boundary weight function</em>, that is zero on the boundary of <code class="reqn">M</code> and smooth (Section 3.2, Scealy and Wood 2023) or potentially piecewise smooth.
</p>
</li>
<li> <p><code class="reqn">\nabla_z</code> is the Euclidean gradient operator that differentiates with respect to <code class="reqn">z</code>.
</p>
</li>
<li> <p><code class="reqn">\lVert \cdot \rVert</code> is the Euclidean norm.
</p>
</li></ul>

<p>Note that, because <code class="reqn">P(z)</code> is the projection matrix, <code class="reqn">\left\lVert P(z)\Big(\nabla_z \log(f) - \nabla_z \log(f_0)\Big)\right\rVert^2</code> is the natural inner product of the gradient of the log ratio of <code class="reqn">f</code> and <code class="reqn">f_0</code>.
</p>
<p>When the density functions <code class="reqn">f</code> and <code class="reqn">f_0</code> are smooth and positive inside <code class="reqn">M</code>,
and the boundary weight function is smooth or of particular forms for specific manifolds (Section 3.2, Scealy and Wood 2023),
then minimising the weighted Hyvärinen divergence <code class="reqn">\phi(f, f_0)</code> is equivalent to minimising the score matching discrepancy (Theorem 1, Scealy and Wood 2023)
</p>
<p style="text-align: center;"><code class="reqn">
\psi(f, f_0) = \int f_0(z)\big(A(z) + B(z) + C(z)\big)dM(z),
</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">A(z) = \frac{1}{2} h(z)^2 \left(\nabla_z \log(f)\right)^T P(z) \left(\nabla_z \log(f)\right),</code>
</p>

<p style="text-align: center;"><code class="reqn">B(z) = h(z)^2\Delta_z\log(f),</code>
</p>

<p style="text-align: center;"><code class="reqn">C(z) = \left(\nabla_z h(z)^2)\right)^T P(z) \left(\nabla_z \log(f)\right),</code>
</p>

<p>and <code class="reqn">\Delta</code> is the Laplacian operator.
We term </p>
<p style="text-align: center;"><code class="reqn">A(z) + B(z) + C(z)</code>
</p>
<p> the <em>score matching discrepancy function</em>.
</p>
<p>We suspect that  (Theorem 1, Scealy and Wood 2023) holds more generally for nearly all realistic continuous and piecewise-smooth boundary weight functions, although no proof exists to our knowledge.
</p>
<p>When <code class="reqn">n</code> independent observations from <code class="reqn">f_0</code> are available, the integration in <code class="reqn">\psi(f, f_0)</code> can be approximated by an average over the observations,
</p>
<p style="text-align: center;"><code class="reqn">\psi(f, f_0) \approx \hat\psi(f, f_0) = \frac{1}{n} \sum_{i = 1}^n A(z_i) + B(z_i) + C(z_i).</code>
</p>

<p>If we parameterise a family of models <code class="reqn">f_\theta</code> according to a vector of parameters <code class="reqn">\theta</code>, then the <em>score matching estimate</em> is the <code class="reqn">\theta</code> that minimises <code class="reqn">\hat\psi(f_\theta, f_0)</code>.
In general, the score matching estimate must be found via numerical optimisation techniques, such as in the function <code>cppad_search()</code>.
However, when the family of models is a canonical exponential family then often <code class="reqn">\hat\psi(f_\theta, f_0)</code> and the score matching discrepancy function is a quadratic function of <code class="reqn">\theta</code> (Mardia 2018) and the minimum has a closed-form solution found by <code>cppad_closed()</code>.
</p>
<p>Note that when <code class="reqn">M</code> has a few or more dimensions, the calculations of <code class="reqn">A(z)</code>, <code class="reqn">B(z)</code> and <code class="reqn">C(z)</code> can become cumbersome. This package uses <code>CppAD</code> to automatically compute <code class="reqn">A(z)</code>, <code class="reqn">B(z)</code> and <code class="reqn">C(z)</code>, and the quadratic simplification if it exists.
</p>


<h3>Transformations</h3>

<p>Hyvärinen divergence <code class="reqn">\phi(f, f_0)</code> is sensitive to transformations of the measure <code class="reqn">dM(z)</code>, including transforming the manifold.
That is, transforming the manifold <code class="reqn">M</code> changes the divergence between distributions and changes the minimum of <code class="reqn">\hat\psi(f_\theta, f_0)</code>.
The transformation changes measure <code class="reqn">dM(z)</code>, the divergence and the estimator but does <em>not</em> transform the data.
</p>
<p>For example, many different transformations of the simplex (i.e. compositional data) are possible (Appendix A.3, Scealy et al. 2024).
Hyvärinen divergences that use the sphere, obtained from the simplex by a square root, have different behaviour to Hyvärinen divergence using Euclidean space obtained from the simplex using logarithms (Scealy et al. 2024).
The estimator for the latter does not apply logarithms to the observations, in fact the estimator involves only polynomials of the observed compositions (Scealy et al. 2024).
</p>
<p>The variety of estimator behaviour available through different transformations was a major motivator for this package as each transformation has different <code class="reqn">A(z)</code>, <code class="reqn">B(z)</code> and <code class="reqn">C(z)</code>, and without automatic differentiation, implementation of the score matching estimator in each case would require a huge programming effort.
</p>


<h3>References</h3>

<p>Hyvärinen A (2005).
&ldquo;Estimation of Non-Normalized Statistical Models by Score Matching.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>6</b>(24), 695&ndash;709.
<a href="https://jmlr.org/papers/v6/hyvarinen05a.html">https://jmlr.org/papers/v6/hyvarinen05a.html</a>.<br /><br /> Hyvärinen A (2007).
&ldquo;Some extensions of score matching.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>51</b>(5), 2499&ndash;2512.
<a href="https://doi.org/10.1016/j.csda.2006.09.003">doi:10.1016/j.csda.2006.09.003</a>.<br /><br /> Liu S, Kanamori T, Williams DJ (2019).
&ldquo;Estimating Density Models with Truncation Boundaries using Score Matching.&rdquo;
<a href="https://doi.org/10.48550/arXiv.1910.03834">doi:10.48550/arXiv.1910.03834</a>.<br /><br /> Mardia K (2018).
&ldquo;A New Estimation Methodology for Standard Directional Distributions.&rdquo;
In <em>2018 21st International Conference on Information Fusion (FUSION)</em>, 724&ndash;729.
<a href="https://doi.org/10.23919/ICIF.2018.8455640">doi:10.23919/ICIF.2018.8455640</a>.<br /><br /> Mardia KV, Kent JT, Laha AK (2016).
&ldquo;Score matching estimators for directional distributions.&rdquo;
<a href="https://doi.org/10.48550/arXiv.1604.08470">doi:10.48550/arXiv.1604.08470</a>.<br /><br /> Scealy JL, Hingee KL, Kent JT, Wood ATA (2024).
&ldquo;Robust score matching for compositional data.&rdquo;
<em>Statistics and Computing</em>, <b>34</b>, 93.
<a href="https://doi.org/10.1007/s11222-024-10412-w">doi:10.1007/s11222-024-10412-w</a>.<br /><br /> Scealy JL, Wood ATA (2023).
&ldquo;Score matching for compositional distributions.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>118</b>(543), 1811&ndash;1823.
<a href="https://doi.org/10.1080/01621459.2021.2016422">doi:10.1080/01621459.2021.2016422</a>.<br /><br /> Yu S, Drton M, Shojaie A (2019).
&ldquo;Generalized Score Matching for Non-Negative Data.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>20</b>(76), 1&ndash;70.
<a href="https://jmlr.org/papers/v20/18-278.html">https://jmlr.org/papers/v20/18-278.html</a>.<br /><br /> Yu S, Drton M, Shojaie A (2020).
&ldquo;Generalized Score Matching for General Domains.&rdquo;
<a href="https://doi.org/10.48550/arXiv.2009.11428">doi:10.48550/arXiv.2009.11428</a>.
</p>

<hr>
<h2 id='smvalues'>Compute Score Matching Discrepancy Value, Gradient, and Hessian</h2><span id='topic+smvalues'></span><span id='topic+smvalues_wsum'></span>

<h3>Description</h3>

<p>Computes a range of relevant information for investigating score matching estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smvalues(smdtape, xmat, pmat, xcentres = NA * xmat, approxorder = 10)

smvalues_wsum(
  tape,
  xmat,
  pmat,
  w = NULL,
  xcentres = NA * xmat,
  approxorder = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smvalues_+3A_smdtape">smdtape</code></td>
<td>
<p>A taped score matching discrepancy. Most easily created by <code><a href="#topic+tape_smd">tape_smd()</a></code>.</p>
</td></tr>
<tr><td><code id="smvalues_+3A_xmat">xmat</code></td>
<td>
<p>A matrix of (multivariate) independent variables where each represents a single independent variable vector. Or a single independent variable vector that is used for all rows of <code>pmat</code>.</p>
</td></tr>
<tr><td><code id="smvalues_+3A_pmat">pmat</code></td>
<td>
<p>A matrix of dynamic parameters where each row specifies a new set of values for the dynamic parameters of <code>tape</code>. Or a single vector of dynamic parameters to use for all rows of <code>xmat</code>.</p>
</td></tr>
<tr><td><code id="smvalues_+3A_xcentres">xcentres</code></td>
<td>
<p>A matrix of approximation for Taylor approximation centres for <code>xmat</code>. Use values of <code>NA</code> for rows that do not require Taylor approximation.</p>
</td></tr>
<tr><td><code id="smvalues_+3A_approxorder">approxorder</code></td>
<td>
<p>Order of Taylor approximation</p>
</td></tr>
<tr><td><code id="smvalues_+3A_tape">tape</code></td>
<td>
<p>An <code><a href="#topic+Rcpp_ADFun">Rcpp_ADFun</a></code> object (i.e. a tape of a function).</p>
</td></tr>
<tr><td><code id="smvalues_+3A_w">w</code></td>
<td>
<p>Weights to apply to each row of <code>xmat</code> for computing the weighted sum. If <code>NULL</code> then each row is given a weight of <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the score matching discrepancy function from <code><a href="#topic+scorematchingtheory">scorematchingtheory</a></code> or weighted sum of the score matching discrepancy function.
The gradient and Hessian are returned as arrays of row-vectors with each row corresponding to a row in <code>xmat</code> and <code>pmat</code>.
Convert a Hessian row-vector to a matrix using <code>matrix(ncol = length(smdtape$xtape))</code>.
</p>


<h3>Value</h3>

<p>A list of
</p>

<ul>
<li> <p><code>obj</code> the score matching discrepancy values
</p>
</li>
<li> <p><code>grad</code> the gradient of the score matching discrepancy
</p>
</li>
<li> <p><code>hess</code> the Hessian of the score matching discrepancy
</p>
</li></ul>



<h3>See Also</h3>

<p>Other tape evaluators: 
<code><a href="#topic+evaltape">evaltape</a>()</code>,
<code><a href="#topic+quadratictape_parts">quadratictape_parts</a>()</code>,
<code><a href="#topic+testquadratic">testquadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- rppi_egmodel(100)
smdtape &lt;- tape_smd("sim", "sqrt", "sph", "ppi",
              ytape = rep(1/m$p, m$p),
              usertheta = ppi_paramvec(beta = m$beta),
              bdryw = "minsq", acut = 0.01)$smdtape
smvalues(smdtape, xmat = m$sample, pmat = m$theta[1:5])
smvalues_wsum(smdtape, m$sample, m$theta[1:5])$grad/nrow(m$sample)
</code></pre>

<hr>
<h2 id='tape_gradoffset'>Tape the Gradient Offset of a Quadratic CppAD Tape</h2><span id='topic+tape_gradoffset'></span>

<h3>Description</h3>

<p>Tape the Gradient Offset of a Quadratic CppAD Tape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tape_gradoffset(pfun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tape_gradoffset_+3A_pfun">pfun</code></td>
<td>
<p>An <code>Rcpp_ADFun</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A quadratic function can be written as
</p>
<p style="text-align: center;"><code class="reqn">f(x;\theta) = \frac{1}{2} x^T W(\theta) x + b(\theta)^Tx + c.</code>
</p>

<p>The gradient of <code class="reqn">f(x; \theta)</code> with respect to <code class="reqn">x</code> is
</p>
<p style="text-align: center;"><code class="reqn">\Delta f(x; \theta) = \frac{1}{2}(W(\theta) + W(\theta)^T)x + b(\theta).</code>
</p>

<p>The Hessian is
</p>
<p style="text-align: center;"><code class="reqn">H f(x; \theta) = \frac{1}{2}(W(\theta) + W(\theta)^T),</code>
</p>

<p>which does not depend on <code class="reqn">x</code>,
so the gradient of the function can be rewritten as
</p>
<p style="text-align: center;"><code class="reqn">\Delta f(x;\theta) = H f(x; \theta) x + b(\theta)^T.</code>
</p>

<p>The tape calculates <code class="reqn">b(\theta)</code> as
</p>
<p style="text-align: center;"><code class="reqn">b(\theta) = \Delta f(x;\theta) - H f(x; \theta) x,</code>
</p>

<p>which does not depend on <code class="reqn">x</code>.
</p>
<p>For creating this tape, the values of <code>pfun$xtape</code> and <code>pfun$dyntape</code> are used.
</p>


<h3>Value</h3>

<p>An <code>Rcpp_ADFun</code> object. The independent argument to the function are the dynamic parameters of <code>pfun</code>.
</p>


<h3>See Also</h3>

<p>Other tape builders: 
<code><a href="#topic+tape_Hessian">tape_Hessian</a>()</code>,
<code><a href="#topic+tape_Jacobian">tape_Jacobian</a>()</code>,
<code><a href="#topic+tape_logJacdet">tape_logJacdet</a>()</code>,
<code><a href="#topic+tape_smd">tape_smd</a>()</code>,
<code><a href="#topic+tape_swap">tape_swap</a>()</code>,
<code><a href="#topic+tape_uld">tape_uld</a>()</code>
</p>

<hr>
<h2 id='tape_Hessian'>Tape the Hessian of a CppAD Tape</h2><span id='topic+tape_Hessian'></span>

<h3>Description</h3>

<p>Creates a tape of the Hessian of a function taped by <code>CppAD</code>.
The taped function represented by <code>pfun</code> must be scalar-valued (i.e. a vector of length 1).
The <code>x</code> vector and <code>dynparam</code> are used as the values to conduct the taping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tape_Hessian(pfun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tape_Hessian_+3A_pfun">pfun</code></td>
<td>
<p>An <code>Rcpp_ADFun</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the returned tape is evaluated (via say <code><a href="#topic+Rcpp_ADFun-class">eval()</a></code>), the resultant vector contains the Hessian in long format (see <a href="https://cppad.readthedocs.io/latest/Hessian.html">https://cppad.readthedocs.io/latest/Hessian.html</a>):
suppose the function represented by <code>pfun</code> maps from <code class="reqn">n</code>-dimensional space to <code class="reqn">1</code>-dimensional space, then
the first <code class="reqn">n</code> elements of the vector is the gradient of the partial derivative with respect to the first dimension of the function's domain;
the next <code class="reqn">n</code> elements of the vector is the gradient of the partial derivative of the second dimension of the function's domain.
The Hessian as a matrix, can be obtained by using <code><a href="base.html#topic+as.matrix">as.matrix()</a></code> with <code>ncol = n</code>.
</p>
<p>For creating this tape, the values of <code>pfun$xtape</code> and <code>pfun$dyntape</code> are used.
</p>


<h3>Value</h3>

<p>An <code>Rcpp_ADFun</code> object.
</p>


<h3>See Also</h3>

<p>Other tape builders: 
<code><a href="#topic+tape_Jacobian">tape_Jacobian</a>()</code>,
<code><a href="#topic+tape_gradoffset">tape_gradoffset</a>()</code>,
<code><a href="#topic+tape_logJacdet">tape_logJacdet</a>()</code>,
<code><a href="#topic+tape_smd">tape_smd</a>()</code>,
<code><a href="#topic+tape_swap">tape_swap</a>()</code>,
<code><a href="#topic+tape_uld">tape_uld</a>()</code>
</p>

<hr>
<h2 id='tape_Jacobian'>Tape the Jacobian of CppAD Tape</h2><span id='topic+tape_Jacobian'></span>

<h3>Description</h3>

<p>Creates a tape of the Jacobian of a function taped by <code>CppAD</code>.
When the function returns a real value (as is the case for densities and the score matching objective) the Jacobian is equivalent to the gradient.
The <code>x</code> vector is used as the value to conduct the taping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tape_Jacobian(pfun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tape_Jacobian_+3A_pfun">pfun</code></td>
<td>
<p>An <code>Rcpp_ADFun</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the returned tape is evaluated (via say <code style="white-space: pre;">&#8288;$eval()&#8288;</code>, the resultant vector contains the Jacobian in long format (see <a href="https://cppad.readthedocs.io/latest/Jacobian.html">https://cppad.readthedocs.io/latest/Jacobian.html</a>).
Suppose the function represented by <code>pfun</code> maps from <code class="reqn">n</code>-dimensional space to <code class="reqn">m</code>-dimensional space, then
the first <code class="reqn">n</code> elements of vector is the gradient of the first component of function output.
The next <code class="reqn">n</code> elements of the vector is the gradient of the second component of the function output.
The Jacobian as a matrix, could then be obtained by <code><a href="base.html#topic+as.matrix">as.matrix()</a></code> with <code>byrow = TRUE</code> and <code>ncol = n</code>.
</p>
<p>For creating this tape, the values of <code>pfun$xtape</code> and <code>pfun$dyntape</code> are used.
</p>


<h3>Value</h3>

<p>An <code>Rcpp_ADFun</code> object.
</p>


<h3>See Also</h3>

<p>Other tape builders: 
<code><a href="#topic+tape_Hessian">tape_Hessian</a>()</code>,
<code><a href="#topic+tape_gradoffset">tape_gradoffset</a>()</code>,
<code><a href="#topic+tape_logJacdet">tape_logJacdet</a>()</code>,
<code><a href="#topic+tape_smd">tape_smd</a>()</code>,
<code><a href="#topic+tape_swap">tape_swap</a>()</code>,
<code><a href="#topic+tape_uld">tape_uld</a>()</code>
</p>

<hr>
<h2 id='tape_logJacdet'>Tape the log of Jacobian determinant of a CppAD Tape</h2><span id='topic+tape_logJacdet'></span>

<h3>Description</h3>

<p>Creates a tape of the log of the Jacobian determinant of a function taped by CppAD.
The <code>x</code> vector is used as the value to conduct the taping.
</p>
<p>For creating this tape, the values of <code>pfun$xtape</code> and <code>pfun$dyntape</code> are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tape_logJacdet(pfun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tape_logJacdet_+3A_pfun">pfun</code></td>
<td>
<p>An <code>Rcpp_ADFun</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Rcpp_ADFun</code> object.
</p>


<h3>See Also</h3>

<p>Other tape builders: 
<code><a href="#topic+tape_Hessian">tape_Hessian</a>()</code>,
<code><a href="#topic+tape_Jacobian">tape_Jacobian</a>()</code>,
<code><a href="#topic+tape_gradoffset">tape_gradoffset</a>()</code>,
<code><a href="#topic+tape_smd">tape_smd</a>()</code>,
<code><a href="#topic+tape_swap">tape_swap</a>()</code>,
<code><a href="#topic+tape_uld">tape_uld</a>()</code>
</p>

<hr>
<h2 id='tape_smd'>Build CppAD Tapes for Score Matching</h2><span id='topic+tape_smd'></span>

<h3>Description</h3>

<p>For a parametric model family, the function <code>tape_smd()</code> generates <code>CppAD</code> tapes for the unnormalised log-density of the model family and of the score matching discrepancy function <code class="reqn">A(z) + B(z) + C(z)</code> (defined in <code><a href="#topic+scorematchingtheory">scorematchingtheory</a></code>).
Three steps are performed by <code>tape_smd()</code>: first an object that specifies the manifold and any transformation to another manifold is created; then a tape of the unnormalised log-density is created; finally a tape of <code class="reqn">A(z) + B(z) + C(z)</code> is created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tape_smd(
  start,
  tran = "identity",
  end = start,
  ll,
  ytape,
  usertheta,
  bdryw = "ones",
  acut = 1,
  thetatape_creator = function(n) {
     seq(length.out = n)
 },
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tape_smd_+3A_start">start</code></td>
<td>
<p>The starting manifold. Used for checking that <code>tran</code> and <code>man</code> match.</p>
</td></tr>
<tr><td><code id="tape_smd_+3A_tran">tran</code></td>
<td>
<p>The name of a transformation. Available transformations are
</p>

<ul>
<li><p> &ldquo;sqrt&rdquo;
</p>
</li>
<li><p> &ldquo;alr&rdquo;
</p>
</li>
<li><p> &ldquo;clr&rdquo;
</p>
</li>
<li><p> &ldquo;none&rdquo; or &lsquo;identity&rsquo;
</p>
</li></ul>
</td></tr>
<tr><td><code id="tape_smd_+3A_end">end</code></td>
<td>
<p>The name of the manifold that <code>tran</code> maps <code>start</code> to. Available manifolds are:
</p>

<ul>
<li><p> &ldquo;sph&rdquo; unit sphere
</p>
</li>
<li><p> &ldquo;Hn111&rdquo; hyperplane normal to the vector <code class="reqn">1, 1, 1, 1, ...</code>
</p>
</li>
<li><p> &ldquo;sim&rdquo; simplex
</p>
</li>
<li><p> &ldquo;Euc&rdquo; Euclidean space
</p>
</li></ul>
</td></tr>
<tr><td><code id="tape_smd_+3A_ll">ll</code></td>
<td>
<p>An unnormalised log-density with respect to the metric of the starting manifold. <code>ll</code> must be either an <code><a href="#topic+Rcpp_ADFun">Rcpp_ADFun</a></code> object created by <code><a href="#topic+tape_uld">tape_uld()</a></code> for a custom unnormalised log-density function or the name of an inbuilt function.</p>
</td></tr>
<tr><td><code id="tape_smd_+3A_ytape">ytape</code></td>
<td>
<p>An example measurement value to use for creating the tapes. In the natural (i.e. <code>start</code>) manifold of the density function.
Please ensure that <code>ytape</code> is the interior of the manifold and non-zero.</p>
</td></tr>
<tr><td><code id="tape_smd_+3A_usertheta">usertheta</code></td>
<td>
<p>A vector of parameter elements for the likelihood function. <code>NA</code> elements will become <em>dynamic parameters</em>. Other elements will be fixed at the provided value. The length of <code>usertheta</code> must be the correct length for the log-density - <strong>no checking is conducted</strong>.</p>
</td></tr>
<tr><td><code id="tape_smd_+3A_bdryw">bdryw</code></td>
<td>
<p>The name of the boundary weight function. &quot;ones&quot; for manifolds without boundary. For the simplex and positive orthant of the sphere, &quot;prodsq&quot; and &quot;minsq&quot; are possible - see <code><a href="#topic+ppi">ppi()</a></code> for more information on these.</p>
</td></tr>
<tr><td><code id="tape_smd_+3A_acut">acut</code></td>
<td>
<p>A parameter passed to the boundary weight function <code>bdryw</code>. Ignored for <code>bdryw = "ones"</code>.</p>
</td></tr>
<tr><td><code id="tape_smd_+3A_thetatape_creator">thetatape_creator</code></td>
<td>
<p>A function that accepts an integer <code>n</code>, and returns a vector of <code>n</code> length. The function is used to fill in the <code>NA</code> elements of <code>usertheta</code> when building the tapes. Please ensure that the values filled by <code>thetatape_creator</code> lead to plausible parameter vectors for the chosen log-density.</p>
</td></tr>
<tr><td><code id="tape_smd_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> more details are printed when taping. These details are for debugging and will likely be comprehensible only to users familiar with the source code of this package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only some combinations of <code>start</code>, <code>tran</code> and <code>end</code> are available because <code>tran</code> must map between <code>start</code> and <code>end</code>.
These combinations of <code>start</code>-<code>tran</code>-<code>end</code> are currently available:
</p>

<ul>
<li><p> sim-sqrt-sph
</p>
</li>
<li><p> sim-identity-sim
</p>
</li>
<li><p> sim-alr-Euc
</p>
</li>
<li><p> sim-clr-Hn111
</p>
</li>
<li><p> sph-identity-sph
</p>
</li>
<li><p> Euc-identity-Euc
</p>
</li></ul>

<p>To build a tape for the score matching discrepancy function, the <code>scorematchingad</code> first tapes the map from a point <code class="reqn">z</code> on the <code>end</code> manifold to the value of the unnormalised log-density, where the independent variable is the <code class="reqn">z</code>, the dynamic parameter is a vector of the parameters to estimate, and the remaining model parameters are fixed and not estimated.
This tape is then used to generate a tape for the score matching discrepancy function where the parameters to estimate are the independent variable.
</p>
<p>The transforms of the manifold must be implemented in <code style="white-space: pre;">&#8288;C++&#8288;</code> and selected by name.
</p>
<p>Currently available unnormalised log-density functions are:
</p>

<ul>
<li><p> dirichlet
</p>
</li>
<li><p> ppi
</p>
</li>
<li><p> vMF
</p>
</li>
<li><p> Bingham
</p>
</li>
<li><p> FB
</p>
</li></ul>



<h3>Value</h3>

<p>A list of:
</p>

<ul>
<li><p> an <code><a href="#topic+Rcpp_ADFun">Rcpp_ADFun</a></code> object containing a tape of the unnormalised log-density using the metric of the &quot;<code>end</code>&quot; manifold (that is the independent variable is on the <code>end</code> manifold).
</p>
</li>
<li><p> an <code><a href="#topic+Rcpp_ADFun">Rcpp_ADFun</a></code> object containing a tape of the score matching discrepancy function with the non-fixed parameters of the model as the independent variable, and the measurements on the <code>end</code> manifold as the dynamic parameter.
</p>
</li>
<li><p> some information about the tapes
</p>
</li></ul>



<h3>Warning</h3>

<p>There is no checking of the inputs <code>ytape</code> and <code>usertheta</code>.
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p>Other tape builders: 
<code><a href="#topic+tape_Hessian">tape_Hessian</a>()</code>,
<code><a href="#topic+tape_Jacobian">tape_Jacobian</a>()</code>,
<code><a href="#topic+tape_gradoffset">tape_gradoffset</a>()</code>,
<code><a href="#topic+tape_logJacdet">tape_logJacdet</a>()</code>,
<code><a href="#topic+tape_swap">tape_swap</a>()</code>,
<code><a href="#topic+tape_uld">tape_uld</a>()</code>
</p>
<p>Other generic score matching tools: 
<code><a href="#topic+Windham">Windham</a>()</code>,
<code><a href="#topic+cppad_closed">cppad_closed</a>()</code>,
<code><a href="#topic+cppad_search">cppad_search</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 3
u &lt;- rep(1/sqrt(p), p)
ltheta &lt;- p #length of vMF parameter vector
intheta &lt;- rep(NA, length.out = ltheta)
tapes &lt;- tape_smd("sph", "identity", "sph", "vMF",
              ytape = u,
              usertheta = intheta,
              "ones", verbose = FALSE
              )
evaltape(tapes$lltape, u, runif(n = ltheta))
evaltape(tapes$smdtape, runif(n = ltheta), u)

u &lt;- rep(1/3, 3)
tapes &lt;- tape_smd("sim", "sqrt", "sph", "ppi",
              ytape = u,
              usertheta = ppi_paramvec(p = 3),
              bdryw = "minsq", acut = 0.01,
              verbose = FALSE
              )
evaltape(tapes$lltape, u, rppi_egmodel(1)$theta)
evaltape(tapes$smdtape, rppi_egmodel(1)$theta, u)
</code></pre>

<hr>
<h2 id='tape_swap'>Switch Dynamic and Independent Values of a Tape</h2><span id='topic+tape_swap'></span>

<h3>Description</h3>

<p>Convert an <code>Rcpp_ADFun</code> object so that the independent values become dynamic parameters
and the dynamic parameters become independent values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tape_swap(pfun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tape_swap_+3A_pfun">pfun</code></td>
<td>
<p>An <code>Rcpp_ADFun</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For creating this tape, the values of <code>pfun$xtape</code> and <code>pfun$dyntape</code> are used.
</p>


<h3>Value</h3>

<p>An <code>Rcpp_ADFun</code> object.
</p>


<h3>See Also</h3>

<p>Other tape builders: 
<code><a href="#topic+tape_Hessian">tape_Hessian</a>()</code>,
<code><a href="#topic+tape_Jacobian">tape_Jacobian</a>()</code>,
<code><a href="#topic+tape_gradoffset">tape_gradoffset</a>()</code>,
<code><a href="#topic+tape_logJacdet">tape_logJacdet</a>()</code>,
<code><a href="#topic+tape_smd">tape_smd</a>()</code>,
<code><a href="#topic+tape_uld">tape_uld</a>()</code>
</p>

<hr>
<h2 id='tape_uld'>Generate a tape of a custom unnormalised log-density</h2><span id='topic+tape_uld'></span><span id='topic+tape_uld_inbuilt'></span>

<h3>Description</h3>

<p>Generate tapes of unnormalised log-densities.
Use <code>tape_ult()</code> to specify a custom unnormalised log-density using <code style="white-space: pre;">&#8288;C++&#8288;</code> code much like <code>TMB::compile()</code>.
Use <code>tape_uld_inbuilt()</code> for tapes of inbuilt unnormalised log-densities implemented in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tape_uld_inbuilt(name, x, theta)

tape_uld(fileORcode = "", x, theta, Cppopt = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tape_uld_+3A_name">name</code></td>
<td>
<p>Name of an inbuilt function. See details.</p>
</td></tr>
<tr><td><code id="tape_uld_+3A_x">x</code></td>
<td>
<p>Value of independent variables for taping.</p>
</td></tr>
<tr><td><code id="tape_uld_+3A_theta">theta</code></td>
<td>
<p>Value of the dynamic parameter vector for taping.</p>
</td></tr>
<tr><td><code id="tape_uld_+3A_fileorcode">fileORcode</code></td>
<td>
<p>A character string giving the path name of a file containing the unnormalised log-density definition <em>OR</em> code. <code>fileORcode</code> will be treated as a file name if <code>fileORcode</code> contains no new line characters ('\n' or '\r\n') and has a file extension detected by <code><a href="tools.html#topic+fileutils">tools::file_ext()</a></code>.</p>
</td></tr>
<tr><td><code id="tape_uld_+3A_cppopt">Cppopt</code></td>
<td>
<p>List of named options passed to <code>Rcpp::sourceCpp()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>tape_uld_inbuilt()</code>, currently available unnormalised log-density functions are:
</p>

<ul>
<li><p> dirichlet
</p>
</li>
<li><p> ppi
</p>
</li>
<li><p> vMF
</p>
</li>
<li><p> Bingham
</p>
</li>
<li><p> FB
</p>
</li></ul>

<p>The function <code>tape_uld()</code> uses <code><a href="Rcpp.html#topic+sourceCpp">Rcpp::sourceCpp()</a></code> to generate a tape of a function defined in C++.
(An alternative design, where the function is compiled interactively and then taped using a function internal to <code>scorematchingad</code>, was not compatible with Windows OS).
</p>
<p>The result result is NOT safe to save or pass to other CPUs in a parallel operation.
</p>


<h3>Value</h3>

<p>A list of three objects
</p>

<ul>
<li> <p><code>fun</code> a function that evaluates the function directly
</p>
</li>
<li> <p><code>tape</code> a tape of the function
</p>
</li>
<li> <p><code>file</code> the temporary file storing the final source code passed to <code><a href="Rcpp.html#topic+sourceCpp">Rcpp::sourceCpp()</a></code>
</p>
</li></ul>



<h3>Writing the <code>fileORcode</code> Argument</h3>

<p>The code (possibly in the file pointed to by <code>fileORcode</code>) must be <code style="white-space: pre;">&#8288;C++&#8288;</code> that uses only <code>CppAD</code> and <code>Eigen</code>, which makes it very similar to the requirements of the input to <code>TMB::compile()</code> (which also uses <code>CppAD</code> and <code>Eigen</code>).
</p>
<p>The start of <code>code</code> should always be &quot;<code style="white-space: pre;">&#8288;a1type fname(const veca1 &amp;x, const veca1 &amp;theta){&#8288;</code>&quot; where <code>fname</code> is your chosen name of the log-density function, <code>x</code> represents a point in the data space and <code>theta</code> is a vector of parameters for the log-density. This specifies that the function will have two vector arguments (of type <code>veca1</code>) and will return a single numeric value (<code>a1type</code>).
</p>
<p>The type <code>a1type</code> is a double with special ability for being taped by <code>CppAD</code>. The <code>veca1</code> type is a vector of <code>a1type</code> elements, with the vector wrapping supplied by the <code>Eigen</code> C++ package (that is an <code>Eigen</code> matrix with 1 column and dynamic number of rows).
</p>
<p>The body of the function must use operations from Eigen and/or CppAD, prefixed by <code style="white-space: pre;">&#8288;Eigen::&#8288;</code> and <code style="white-space: pre;">&#8288;CppAD::&#8288;</code> respectively.
There are no easy instructions for writing these as it is genuine <code style="white-space: pre;">&#8288;C++&#8288;</code> code, which can be very opaque to those unfamiliar with <code style="white-space: pre;">&#8288;C++&#8288;</code>.
However, recently ChatGPT and claude.ai have been able to very quickly translating <code>R</code> functions to <code style="white-space: pre;">&#8288;C++&#8288;</code> functions (KLH has been telling these A.I. to use Eigen and CppAD, and giving the definitions of <code>a1type</code> and <code>veca1</code>).
I've found the quick reference pages for for <a href="https://eigen.tuxfamily.org/dox/"><code>Eigen</code></a> useful. Limited unary and binary operations are available directly from <a href="https://cppad.readthedocs.io"><code>CppAD</code></a> without <code>Eigen</code>.
For the purposes of score matching the operations should all be smooth to create a smooth log-density and the normalising constant may be omitted.
</p>


<h3>See Also</h3>

<p>Other tape builders: 
<code><a href="#topic+tape_Hessian">tape_Hessian</a>()</code>,
<code><a href="#topic+tape_Jacobian">tape_Jacobian</a>()</code>,
<code><a href="#topic+tape_gradoffset">tape_gradoffset</a>()</code>,
<code><a href="#topic+tape_logJacdet">tape_logJacdet</a>()</code>,
<code><a href="#topic+tape_smd">tape_smd</a>()</code>,
<code><a href="#topic+tape_swap">tape_swap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
out &lt;- tape_uld(system.file("demo_custom_uld.cpp", package = "scorematchingad"), 
                rep(0.2, 5), rep(-0.1, 5))
out$fun(c(0.1, 0.2, 0.2, 0.2, 0.2), c(-0.5, -0.5, -0.1, -0.1, 0))
out$tape$eval(c(0.1, 0.2, 0.2, 0.2, 0.2), c(-0.5, -0.5, -0.1, -0.1, 0))
out$tape$Jac(c(0.1, 0.2, 0.2, 0.2, 0.2), c(-0.5, -0.5, -0.1, -0.1, 0))
out$tape$name

## End(Not run)
</code></pre>

<hr>
<h2 id='testquadratic'>Test Whether a CppAD Tape is a Quadratic Function</h2><span id='topic+testquadratic'></span>

<h3>Description</h3>

<p>Uses the <a href="https://cppad.readthedocs.io/latest/fun_property.html#parameter"><code>CppAD</code> parameter property</a> and derivatives (via <code><a href="#topic+tape_Jacobian">tape_Jacobian()</a></code>) to test whether
the tape is quadratic.
</p>
<p>Uses the <a href="https://cppad.readthedocs.io/latest/fun_property.html#parameter"><code>CppAD</code> parameter property</a> and derivatives (via <code><a href="#topic+tape_Jacobian">tape_Jacobian()</a></code>) to test whether
the tape is quadratic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testquadratic(
  tape,
  xmat = matrix(tape$xtape, nrow = 1),
  dynmat = matrix(tape$dyntape, nrow = 1),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testquadratic_+3A_tape">tape</code></td>
<td>
<p>An <code>ADFun</code> object.</p>
</td></tr>
<tr><td><code id="testquadratic_+3A_xmat">xmat</code></td>
<td>
<p>The third-order derivatives at independent variable values of the rows of <code>xmat</code> and dynamic parameters from the rows of <code>dynmat</code> are tested.</p>
</td></tr>
<tr><td><code id="testquadratic_+3A_dynmat">dynmat</code></td>
<td>
<p>The third-order derivatives at independent variable values of the rows of <code>xmat</code> and dynamic parameters from the rows of <code>dynmat</code> are tested.</p>
</td></tr>
<tr><td><code id="testquadratic_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE information about the failed tests is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the <code>xtape</code> and <code>dyntape</code> values stored in <code>tape</code> to create new tapes.
A tape of the Hessian is obtained by applying <code><a href="#topic+tape_Jacobian">tape_Jacobian()</a></code> twice, and then uses the <a href="https://cppad.readthedocs.io/latest/fun_property.html#parameter"><code>CppAD</code> parameter property</a> to test whether the Hessian is constant. A function of quadratic form should have constant Hessian.
</p>
<p>If <code>xmat</code> and <code>dynmat</code> are non-<code>NULL</code> then <code>testquadratic()</code> also checks the Jacobian of the Hessian at <code>xmat</code> and <code>dynmat</code> values. For quadratic form functions the Jacobian of the Hessian should be zero.
</p>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>See Also</h3>

<p>Other tape evaluators: 
<code><a href="#topic+evaltape">evaltape</a>()</code>,
<code><a href="#topic+quadratictape_parts">quadratictape_parts</a>()</code>,
<code><a href="#topic+smvalues">smvalues</a>()</code>
</p>
<p>Other tape evaluators: 
<code><a href="#topic+evaltape">evaltape</a>()</code>,
<code><a href="#topic+quadratictape_parts">quadratictape_parts</a>()</code>,
<code><a href="#topic+smvalues">smvalues</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tapes &lt;- tape_smd(
   "sim", "sqrt", "sph",
   ll = "ppi",
   ytape = c(0.2, 0.3, 0.5),
   usertheta = ppi_paramvec(p = 3), 
   bdryw = "minsq",
   acut = 0.1,
   verbose = FALSE)

 testquadratic(tapes$smdtape)
</code></pre>

<hr>
<h2 id='vMF'>Score Matching Estimator for the von-Mises Fisher Distribution</h2><span id='topic+vMF'></span>

<h3>Description</h3>

<p>In general the normalising constant in von Mises Fisher distributions is hard to compute, so Mardia et al. (2016) suggested a hybrid method that uses maximum likelihood to estimate the mean direction and score matching for the concentration.
We can also estimate all parameters using score matching (<code>smfull</code> method), although this estimator is likely to be less efficient than the hybrid estimator.
On the circle the hybrid estimators were often nearly as efficient as maximum likelihood estimators (Mardia et al. 2016).
For maximum likelihood estimators of the von Mises Fisher distribution, which all use approximations of the normalising constant, consider <code><a href="movMF.html#topic+movMF">movMF::movMF()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vMF(Y, paramvec = NULL, method = "Mardia", w = rep(1, nrow(Y)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vMF_+3A_y">Y</code></td>
<td>
<p>A matrix of multivariate observations in Cartesian coordinates. Each row is a multivariate measurement (i.e. each row corresponds to an individual).</p>
</td></tr>
<tr><td><code id="vMF_+3A_paramvec">paramvec</code></td>
<td>
<p><code>smfull</code> method only: Optional. A vector of same length as the dimension, representing the elements of the <code class="reqn">\kappa \mu</code> vector.</p>
</td></tr>
<tr><td><code id="vMF_+3A_method">method</code></td>
<td>
<p>Either &quot;Mardia&quot; or &quot;hybrid&quot; for the hybrid score matching estimator from Mardia et al. (2016)
or &quot;smfull&quot; for the full score matching estimator.</p>
</td></tr>
<tr><td><code id="vMF_+3A_w">w</code></td>
<td>
<p>An optional vector of weights for each measurement in <code>Y</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The full score matching estimator (<code>method = "smfull"</code>) estimates <code class="reqn">\kappa \mu</code>.
The hybrid estimator (<code>method = "Mardia"</code>) estimates <code class="reqn">\kappa</code> and <code class="reqn">\mu</code> separately.
Both use <code><a href="#topic+cppad_closed">cppad_closed()</a></code> for score matching estimation.
</p>


<h3>Value</h3>

<p>A list of <code>est</code>, <code>SE</code> and <code>info</code>.
</p>

<ul>
<li> <p><code>est</code> contains the estimates in vector form, <code>paramvec</code>, and with user friendly names <code>k</code> and <code>m</code>.
</p>
</li>
<li> <p><code>SE</code> contains estimates of the standard errors if computed. See <code><a href="#topic+cppad_closed">cppad_closed()</a></code>.
</p>
</li>
<li> <p><code>info</code> contains a variety of information about the model fitting procedure and results.
</p>
</li></ul>



<h3>von Mises Fisher Model</h3>

<p>The von Mises Fisher density is proportional to
</p>
<p style="text-align: center;"><code class="reqn">\exp(\kappa \mu^T z),</code>
</p>

<p>where <code class="reqn">z</code> is on a unit sphere,
<code class="reqn">\kappa</code> is termed the <em>concentration</em>,
and <code class="reqn">\mu</code> is the <em>mean direction unit vector</em>.
The effect of the <code class="reqn">\mu</code> and <code class="reqn">\kappa</code> can be decoupled in a sense (p169, Mardia and Jupp 2000), allowing for estimating <code class="reqn">\mu</code> and <code class="reqn">\kappa</code> separately.
</p>


<h3>References</h3>

<p>Mardia KV, Jupp PE (2000).
<em>Directional Statistics</em>,  Probability and Statistics.
Wiley, Great Britain.
ISBN 0-471-95333-4.<br /><br /> Mardia KV, Kent JT, Laha AK (2016).
&ldquo;Score matching estimators for directional distributions.&rdquo;
<a href="https://doi.org/10.48550/arXiv.1604.08470">doi:10.48550/arXiv.1604.08470</a>.
</p>


<h3>See Also</h3>

<p>Other directional model estimators: 
<code><a href="#topic+Bingham">Bingham</a>()</code>,
<code><a href="#topic+FB">FB</a>()</code>,
<code><a href="#topic+vMF_robust">vMF_robust</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("movMF")){
  Y &lt;- movMF::rmovMF(1000, 100 * c(1, 1) / sqrt(2))
  movMF::movMF(Y, 1) #maximum likelihood estimate
} else {
  Y &lt;- matrix(rnorm(1000 * 2, sd = 0.01), ncol = 2)
  Y &lt;- Y / sqrt(rowSums(Y^2))
}
vMF(Y, method = "smfull")
vMF(Y, method = "Mardia")
vMF(Y, method = "hybrid")
</code></pre>

<hr>
<h2 id='vMF_robust'>Robust Fitting of von Mises Fisher</h2><span id='topic+vMF_robust'></span>

<h3>Description</h3>

<p>Robust estimation for von Mises Fisher distribution using <code><a href="#topic+Windham">Windham()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vMF_robust(Y, cW, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vMF_robust_+3A_y">Y</code></td>
<td>
<p>A matrix of observations in Cartesian coordinates.</p>
</td></tr>
<tr><td><code id="vMF_robust_+3A_cw">cW</code></td>
<td>
<p>Tuning constants for each parameter in the vMF parameter vector. If a single number then the constant is the same for each element of the parameter vector.</p>
</td></tr>
<tr><td><code id="vMF_robust_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+Windham">Windham()</a></code> and then passed onto <code><a href="#topic+vMF">vMF()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other directional model estimators: 
<code><a href="#topic+Bingham">Bingham</a>()</code>,
<code><a href="#topic+FB">FB</a>()</code>,
<code><a href="#topic+vMF">vMF</a>()</code>
</p>
<p>Other Windham robustness functions: 
<code><a href="#topic+Windham">Windham</a>()</code>,
<code><a href="#topic+ppi_robust">ppi_robust</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("movMF")){
  Y &lt;- movMF::rmovMF(1000, 100 * c(1, 1) / sqrt(2))
} else {
  Y &lt;- matrix(rnorm(1000 * 2, sd = 0.01), ncol = 2)
  Y &lt;- Y / sqrt(rowSums(Y^2))
}
vMF_robust(Y, cW = c(0.01, 0.01), method = "smfull")
vMF_robust(Y, cW = c(0.01, 0.01), method = "Mardia")
</code></pre>

<hr>
<h2 id='Windham'>Windham Robustification of Point Estimators for Exponential Family Distributions</h2><span id='topic+Windham'></span>

<h3>Description</h3>

<p>Performs a generalisation of Windham's robustifying method (Windham 1995) for exponential models with natural parameters that are a linear function of the parameters for estimation.
Estimators must solve estimating equations of the form
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i = 1}^n U(z_i; \theta) = 0.</code>
</p>

<p>The estimate is found iteratively through a fixed point method as suggested by Windham (1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Windham(
  Y,
  estimator,
  ldenfun,
  cW,
  ...,
  fpcontrol = list(Method = "Simple", ConvergenceMetricThreshold = 1e-10),
  paramvec_start = NULL,
  alternative_populationinverse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Windham_+3A_y">Y</code></td>
<td>
<p>A matrix of measurements. Each row is a measurement, each component is a dimension of the measurement.</p>
</td></tr>
<tr><td><code id="Windham_+3A_estimator">estimator</code></td>
<td>
<p>A function that estimates parameters from weighted observations.
It must have arguments <code>Y</code> that is a matrix of measurements and <code>w</code> that are weights associated with each row of <code>Y</code>. If it accepts arguments <code>paramvec</code> or <code>paramvec_start</code> then these will be used to specify fixed elements of the parameter vector and the starting guess of the parameter vector, respectively. The estimated parameter vector, including any fixed elements, must be the returned object, or the first element of a returned list, or as the <code>paramvec</code> slot within the <code>est</code> slot of the returned object.</p>
</td></tr>
<tr><td><code id="Windham_+3A_ldenfun">ldenfun</code></td>
<td>
<p>A function that returns a vector of values proportional to the log-density for a matrix of observations <code>Y</code> and parameter vector <code>theta</code>.</p>
</td></tr>
<tr><td><code id="Windham_+3A_cw">cW</code></td>
<td>
<p>A vector of robustness tuning constants. When computing the weight for an observation the parameter vector is multiplied element-wise with <code>cW</code>. For the PPI model, generate <code>cW</code> easily using <code><a href="#topic+ppi_cW">ppi_cW()</a></code> and <code><a href="#topic+ppi_cW_auto">ppi_cW_auto()</a></code>.</p>
</td></tr>
<tr><td><code id="Windham_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>estimator</code>.</p>
</td></tr>
<tr><td><code id="Windham_+3A_fpcontrol">fpcontrol</code></td>
<td>
<p>A named list of control arguments to pass to <code><a href="FixedPoint.html#topic+FixedPoint">FixedPoint::FixedPoint()</a></code> for the fixed point iteration.</p>
</td></tr>
<tr><td><code id="Windham_+3A_paramvec_start">paramvec_start</code></td>
<td>
<p>Initially used to check the function <code>estimator</code>. If <code>estimator</code> accepts a <code>paramvec_start</code>, then the current estimate of the parameter vector is passed as <code>paramvec_start</code> to <code>estimator</code> in each iteration.</p>
</td></tr>
<tr><td><code id="Windham_+3A_alternative_populationinverse">alternative_populationinverse</code></td>
<td>
<p>The default is to use <code><a href="#topic+Windham_populationinverse">Windham_populationinverse()</a></code>. If TRUE an alternative implementation in <code><a href="#topic+Windham_populationinverse_alternative">Windham_populationinverse_alternative()</a></code> is used. So far we have not seen any difference between the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For any family of models with density <code class="reqn">f(z; \theta)</code>, Windham's method finds the parameter set <code class="reqn">\hat\theta</code> such that the estimator applied to observations weighted by <code class="reqn">f(z; \hat\theta)^c</code> returns an estimate that matches the theoretical effect of weighting the full population of the model.
When <code class="reqn">f</code> is proportional to <code class="reqn">\exp(\eta(\theta) \cdot T(z))</code> and <code class="reqn">\eta(\theta)</code> is linear, these weights are equivalent to <code class="reqn">f(z; c\hat\theta)</code> and the theoretical effect of the weighting on the full population is to scale the parameter vector <code class="reqn">\theta</code> by <code class="reqn">1+c</code>.
</p>
<p>The function <code>Windham()</code> assumes that <code class="reqn">f</code> is proportional to <code class="reqn">\exp(\eta(\theta) \cdot T(z))</code> and <code class="reqn">\eta(\theta)</code> is linear. It allows a generalisation where <code class="reqn">c</code> is a vector so the weight for an observation <code class="reqn">z</code> is </p>
<p style="text-align: center;"><code class="reqn">f(z; c \circ \theta),</code>
</p>
<p> where <code class="reqn">\theta</code> is the parameter vector, <code class="reqn">c</code> is a vector of tuning constants, and <code class="reqn">\circ</code> is the element-wise product (Hadamard product).
</p>
<p>The solution is found iteratively (Windham 1995).
Given a parameter set <code class="reqn">\theta_n</code>, <code>Windham()</code> first computes weights <code class="reqn">f(z; c \circ \theta_n)</code> for each observation <code class="reqn">z</code>.
Then, a new parameter set <code class="reqn">\tilde{\theta}_{n+1}</code> is estimated by <code>estimator</code> with the computed weights.
This new parameter set is element-wise-multiplied by the (element-wise) reciprocal of <code class="reqn">1+c</code> to obtain an adjusted parameter set <code class="reqn">\theta_{n+1}</code>.
The estimate returned by <code>Windham()</code> is the parameter set <code class="reqn">\hat{\theta}</code> such that <code class="reqn">\theta_n \approx \theta_{n+1}</code>.
</p>


<h3>Value</h3>

<p>A list:
</p>

<ul>
<li> <p><code>paramvec</code> the estimated parameter vector
</p>
</li>
<li> <p><code>optim</code> information about the fixed point iterations and optimisation process. Including a slot <code>finalweights</code> for the weights in the final iteration.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other generic score matching tools: 
<code><a href="#topic+cppad_closed">cppad_closed</a>()</code>,
<code><a href="#topic+cppad_search">cppad_search</a>()</code>,
<code><a href="#topic+tape_smd">tape_smd</a>()</code>
</p>
<p>Other Windham robustness functions: 
<code><a href="#topic+ppi_robust">ppi_robust</a>()</code>,
<code><a href="#topic+vMF_robust">vMF_robust</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("movMF")){
  Y &lt;- movMF::rmovMF(1000, 100 * c(1, 1) / sqrt(2))
} else {
  Y &lt;- matrix(rnorm(1000 * 2, sd = 0.01), ncol = 2)
  Y &lt;- Y / sqrt(rowSums(Y^2))
}
Windham(Y = Y,
   estimator = vMF,
   ldenfun = function(Y, theta){ #here theta is km
     return(drop(Y %*% theta))
   },
   cW = c(0.01, 0.01),
   method = "Mardia")
</code></pre>

<hr>
<h2 id='Windham_populationinverse'>Inverse Transform for the Population Parameters Under Windham Weights</h2><span id='topic+Windham_populationinverse'></span><span id='topic+Windham_populationinverse_alternative'></span>

<h3>Description</h3>

<p>Returns the matrix which reverses the effect of weights on a population for certain models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Windham_populationinverse(cW)

Windham_populationinverse_alternative(newtheta, previoustheta, cW, cWav)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Windham_populationinverse_+3A_cw">cW</code></td>
<td>
<p>A vector of tuning constants for the Windham robustification method performed by <code><a href="#topic+Windham">Windham()</a></code>.</p>
</td></tr>
<tr><td><code id="Windham_populationinverse_+3A_newtheta">newtheta</code></td>
<td>
<p>The parameter vector most recently estimated</p>
</td></tr>
<tr><td><code id="Windham_populationinverse_+3A_previoustheta">previoustheta</code></td>
<td>
<p>The parameter vector estimated in the previous step</p>
</td></tr>
<tr><td><code id="Windham_populationinverse_+3A_cwav">cWav</code></td>
<td>
<p>The value of the non-zero elements of <code>cW</code>. That is <code>cW</code> have elements that are zero or equal to <code>cWav</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the Windham robustification method (<code><a href="#topic+Windham">Windham()</a></code>) the effect of weighting a population plays a central role.
When the
the model density is proportional to <code class="reqn">\exp(\eta(\theta) \cdot T(u))</code>,
where <code class="reqn">T(u)</code> is a vector of sufficient statistics for a measurement <code class="reqn">u</code>,
and <code class="reqn">\eta</code> is a <em>linear</em> function,
Then weights proportional to
<code class="reqn">\exp(\eta(c \circ \theta) \cdot t(u))</code>,
where <code class="reqn">c</code> is a vector of tuning constants and <code class="reqn">\circ</code> is the Hadamard (element-wise) product,
have a very simple effect on the population parameter vector <code class="reqn">\theta</code>:
the weighted population follows a density of the same form, but with a parameter vector of
<code class="reqn">(1 + c) \circ \theta</code>.
The inverse of this change to the parameter vector is then a matrix multiplication by a diagonal matrix with elements <code class="reqn">1/(1+c_i)</code>, with <code class="reqn">c_i</code> denoting the elements of <code class="reqn">c</code>.
</p>


<h3>Value</h3>

<p>A diagonal matrix with the same number of columns as <code>cW</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Windham_populationinverse()</code>: The matrix with diagonal elements <code class="reqn">1/(1+c_i)</code>
</p>
</li>
<li> <p><code>Windham_populationinverse_alternative()</code>: The transform implemented as described by Scealy et al. (2024). It is mathematically equivalent to multiplication by the result of <code>Windham_populationinverse()</code> in the situation in Scealy et al. (2024).
</p>
</li></ul>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
