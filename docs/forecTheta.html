<!DOCTYPE html><html><head><title>Help for package forecTheta</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {forecTheta}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#forecTheta-Package'>
<p>Forecasting Time Series by Theta Models</p>
</a></li>
<li><a href='#Cross Validation'>
<p>Generalised Rolling Origin Evaluation</p></a></li>
<li><a href='#Error Metric'>
<p>Error Metric Function</p>
</a></li>
<li><a href='#expSmoot'>
<p>Simple Exponential Smoothing Method</p></a></li>
<li><a href='#otm.arxiv'>
<p>Optimised Theta Method</p>
</a></li>
<li><a href='#Plot'><p>Plot forecasts points and prediction intervals for <code>thetaModel</code> objects</p></a></li>
<li><a href='#Theta Models'>
<p>Theta Models</p>
</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forecasting Time Series by Theta Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.6.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose Augusto Fiorucci
    <a href="https://orcid.org/0000-0002-1201-9089"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Francisco Louzada <a href="https://orcid.org/0000-0001-7815-9554"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose Augusto Fiorucci &lt;jafiorucci@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines for forecasting univariate time series using Theta Models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0), forecast, tseries</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jafiorucci/forecTheta/issues">https://github.com/jafiorucci/forecTheta/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.sciencedirect.com/science/article/pii/S0169207016300243">https://www.sciencedirect.com/science/article/pii/S0169207016300243</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-11 22:10:15 UTC; jafio</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-11 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='forecTheta-Package'>
Forecasting Time Series by Theta Models

</h2><span id='topic+forecTheta-package'></span><span id='topic+forecTheta'></span>

<h3>Description</h3>

<p>In this package we implement functions for forecast univariate time series using the several Theta Models (Fiorucci et al, 2015 and 2016) and	the Standard Theta Method of Assimakopoulos and Nikolopoulos (2000).

</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
		Package: </td><td style="text-align: left;"> forecTheta</td>
</tr>
<tr>
 <td style="text-align: left;">
		Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
		Version: </td><td style="text-align: left;"> 2.6.2</td>
</tr>
<tr>
 <td style="text-align: left;">
		Date: </td><td style="text-align: left;"> 2022-11-11</td>
</tr>
<tr>
 <td style="text-align: left;">
		License: </td><td style="text-align: left;"> GPL (&gt;=2.0) </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<p><code>dotm(y, h)</code>
</p>
<p><code>stheta(y, h)</code>
</p>
<p><code>errorMetric(obs, forec, type = "sAPE", statistic = "M")</code>
</p>
<p><code>groe(y, forecFunction = ses, g = "sAPE", n1 = length(y)-10)</code>
</p>


<h3>Author(s)</h3>

<p>Jose Augusto Fiorucci, Francisco Louzada
</p>
<p>Maintainer: Jose Augusto Fiorucci &lt;jafiorucci@gmail.com&gt;

</p>


<h3>References</h3>

<p>Fiorucci J.A., Pellegrini T.R., Louzada F., Petropoulos F., Koehler, A. (2016). <em>Models for optimising the theta method and their relationship to state space models</em>,	International Journal of Forecasting, 32 (4), 1151&ndash;1161, &lt;doi:10.1016/j.ijforecast.2016.02.005&gt;.
</p>
<p>Fioruci J.A., Pellegrini T.R., Louzada F., Petropoulos F. (2015). <em>The Optimised Theta Method</em>. arXiv preprint, arXiv:1503.03529.
</p>
<p>Assimakopoulos, V. and Nikolopoulos k. (2000). <em>The theta model: a decomposition approach to forecasting</em>. International Journal of Forecasting 16, 4, 521&ndash;530, &lt;doi:10.1016/S0169-2070(00)00066-2&gt;.
</p>
<p>Tashman, L.J. (2000). <em>Out-of-sample tests of forecasting accuracy: an analysis and review</em>. International Journal of Forecasting, 16 (4), 437&ndash;450, &lt;doi:10.1016/S0169-2070(00)00065-0&gt;.

</p>


<h3>See Also</h3>

<p><code><a href="#topic+dotm">dotm</a></code>, <code><a href="#topic+stheta">stheta</a></code>, <code><a href="#topic+otm.arxiv">otm.arxiv</a></code>,
<code><a href="#topic+groe">groe</a></code>, <code><a href="#topic+rolOrig">rolOrig</a></code>, <code><a href="#topic+fixOrig">fixOrig</a></code>,
<code><a href="#topic+errorMetric">errorMetric</a></code>


</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############################################################

y1 = 2+ 0.15*(1:20) + rnorm(20)
y2 = y1[20]+ 0.3*(1:30) + rnorm(30)
y =  as.ts(c(y1,y2))
out &lt;- dotm(y, h=10)
summary(out)
plot(out)

out &lt;- dotm(y=as.ts(y[1:40]), h=10)
summary(out)
plot(out)

out2 &lt;- stheta(y=as.ts(y[1:40]), h=10)
summary(out2)
plot(out2)

### sMAPE metric
errorMetric(obs=as.ts(y[41:50]), forec=out$mean, type = "sAPE", statistic = "M")
errorMetric(obs=as.ts(y[41:50]), forec=out2$mean, type = "sAPE", statistic = "M")

### sMdAPE metric
errorMetric(obs=as.ts(y[41:50]), forec=out$mean, type = "sAPE", statistic = "Md")
errorMetric(obs=as.ts(y[41:50]), forec=out2$mean, type = "sAPE", statistic = "Md")

### MASE metric
meanDiff1 = mean(abs(diff(as.ts(y[1:40]), lag = 1)))
errorMetric(obs=as.ts(y[41:50]), forec=out$mean, type = "AE", statistic = "M") / meanDiff1
errorMetric(obs=as.ts(y[41:50]), forec=out2$mean, type = "AE", statistic = "M") / meanDiff1

#### cross validation (2 origins)
#groe( y=y, forecFunction = otm.arxiv, m=5, n1=40, p=2, theta=5)
#groe( y=y, forecFunction = stheta, m=5, n1=40, p=2)

#### cross validation (rolling origin evaluation)
#rolOrig( y=y, forecFunction = otm.arxiv, n1=40, theta=5)
#rolOrig( y=y, forecFunction = stheta, n1=40)

</code></pre>

<hr>
<h2 id='Cross+20Validation'>
Generalised Rolling Origin Evaluation
</h2><span id='topic+groe'></span><span id='topic+fixOrig'></span><span id='topic+rolOrig'></span>

<h3>Description</h3>

<p>This function implements the Generalised Rolling Origin Evaluation of Fioruci et al (2015).
Its particular cases include the cross validation methods: Rolling Origin Evaluation and Fixed Origin Evaluation of Tashman(2000).

</p>


<h3>Usage</h3>

<pre><code class='language-R'>	groe(y, forecFunction, g="sAPE", n1=length(y)-10, m=5,
	        H=length(y)-n1, p=1+floor((length(y)-n1)/m), ...)

	rolOrig(y, forecFunction, g="sAPE", n1=length(y)-10, ...)

	fixOrig(y, forecFunction, g="sAPE", n1=length(y)-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cross+2B20Validation_+3A_y">y</code></td>
<td>

<p>Object of time series class or a vector

</p>
</td></tr>
<tr><td><code id="Cross+2B20Validation_+3A_forecfunction">forecFunction</code></td>
<td>

<p>A forecasting method as one object of the <code>forecast</code> class of forecast package.

</p>
</td></tr>
<tr><td><code id="Cross+2B20Validation_+3A_g">g</code></td>
<td>

<p>The prediction error type of <code>errorMetric</code> function. The possible values are <code>"sAPE", "APE", "AE"</code> and <code>"SE"</code>.

</p>
</td></tr>
<tr><td><code id="Cross+2B20Validation_+3A_n1">n1</code></td>
<td>

<p>The index of the first origin element.

</p>
</td></tr>
<tr><td><code id="Cross+2B20Validation_+3A_m">m</code></td>
<td>

<p>The number of movements of the origin in each update.

</p>
</td></tr>
<tr><td><code id="Cross+2B20Validation_+3A_h">H</code></td>
<td>

<p>The number of predictions forward of each origin.

</p>
</td></tr>
<tr><td><code id="Cross+2B20Validation_+3A_p">p</code></td>
<td>

<p>The number of origin updates.
Default is the maximum.

</p>
</td></tr>
<tr><td><code id="Cross+2B20Validation_+3A_...">...</code></td>
<td>

<p>Additional arguments for <code>forecFunction</code>.

</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>m=1</code> is computed the Rolling Origin Evaluation.
If <code>m&gt;=length(y)-n1</code> is computed the Fixed Origin Evaluation.

</p>


<h3>Value</h3>

<p>The sum of the prediction errors.





</p>


<h3>Note</h3>

<p>The <code>otm.arxiv</code> function use this function for estimate the theta parameter when the <code>theta</code> argument is <code>NULL</code>.
Your computer may go into an infinite looping if you use <code>forecFunction = otm.arxiv</code> without specific a numeric value for the <code>theta</code> argument.

</p>


<h3>Author(s)</h3>

<p>Jose Augusto Fiorucci and Francisco Louzada

</p>


<h3>References</h3>

<p>Fioruci J.A., Pellegrini T.R., Louzada F., Petropoulos F. (2015). <em>The Optimised Theta Method</em>. arXiv preprint, arXiv:1503.03529.
</p>
<p>Tashman, L.J. (2000). <em>Out-of-sample tests of forecasting accuracy: an analysis and review</em>. International Journal of Forecasting 16 (4), 437&ndash;450.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecTheta-package">forecTheta-package</a></code>, <code><a href="#topic+dotm">dotm</a></code>, <code><a href="#topic+otm.arxiv">otm.arxiv</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 = 2+ 0.15*(1:20) + rnorm(20,2)
y2 = y1[20]+ 0.3*(1:30) + rnorm(30,2)
y =  as.ts(c(y1,y2))

## Rolling Origin Evaluation
rolOrig( y=y, forecFunction = dotm, n1=40)
rolOrig( y=y, forecFunction = expSmoot, n1=40)
rolOrig( y=y, forecFunction = stheta, n1=40)
rolOrig( y=y, forecFunction = otm.arxiv, n1=40, theta=3)

## Fixed Origin Evaluation
fixOrig( y=y, forecFunction = dotm, n1=40)
fixOrig( y=y, forecFunction = expSmoot, n1=40)
fixOrig( y=y, forecFunction = stheta, n1=40)
fixOrig( y=y, forecFunction = otm.arxiv, n1=40, theta=3)

## Generalised Rolling Origin Evaluation with two origin updates.
## Where the first is the 40th element and second is the 45th element
groe( y=y, forecFunction = dotm, m=5, n1=40)
groe( y=y, forecFunction = expSmoot, m=5, n1=40)
groe( y=y, forecFunction = stheta, m=5, n1=40)
groe( y=y, forecFunction = otm.arxiv, m=5, n1=40, theta=3)
</code></pre>

<hr>
<h2 id='Error+20Metric'>
Error Metric Function

</h2><span id='topic+errorMetric'></span>

<h3>Description</h3>

<p>This function implements some of the more used error metrics. 
These metrics are &quot;sMAPE&quot;, &quot;MAPE&quot;, &quot;MAE&quot;, &quot;MSE&quot; and they respectively versions with median  
&quot;sMdAPE&quot;, &quot;MdAPE&quot;, &quot;MdAE&quot;, &quot;MdSE&quot;.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>	errorMetric(obs, forec, type="sAPE", statistic="M")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Error+2B20Metric_+3A_obs">obs</code></td>
<td>

<p>A vector or a matrix with the real values.

</p>
</td></tr>
<tr><td><code id="Error+2B20Metric_+3A_forec">forec</code></td>
<td>

<p>A vector or a matrix with the estimated values.

</p>
</td></tr>
<tr><td><code id="Error+2B20Metric_+3A_type">type</code></td>
<td>

<p>The error type of &quot;sAPE&quot;, &quot;APE&quot;, &quot;AE&quot; and &quot;SE&quot;.

</p>
</td></tr>
<tr><td><code id="Error+2B20Metric_+3A_statistic">statistic</code></td>
<td>

<p>The statistic to be returned. Use &quot;M&quot; or &quot;Md&quot; for return the mean or median of the errors. 
If &quot;N&quot; so a vector with all errors will be returned.  

</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The metric sMAPE is obtained using <code>type = "sAPE"</code> and  <code>statistic = "M"</code>
</p>
<p>The metric sMdAPE is obtained using <code>type = "sAPE"</code> and  <code>statistic = "Md"</code>
</p>
<p>The metric MAPE is obtained using <code>type = "APE"</code> and  <code>statistic = "M"</code>
</p>
<p>The metric MdAPE is obtained using <code>type = "APE"</code> and  <code>statistic = "Md"</code>
</p>
<p>The metric MAE is obtained using <code>type = "AE"</code> and  <code>statistic = "M"</code>
</p>
<p>The metric MdAE is obtained using codetype = &quot;AE&quot; and  <code>statistic = "Md"</code>
</p>
<p>The metric MSE is obtained using <code>type = "SE"</code> and  <code>statistic = "M"</code>
</p>
<p>The metric MdSE is obtained using <code>type = "SE"</code> and  <code>statistic = "Md"</code>

</p>


<h3>Value</h3>

<p>If <code>statistic="M"</code> or <code>statistic="Md"</code> it is returned the respectively error metric result.
If <code>statistic="N"</code> so is returned a vector with all errors points according to the chosen error type.  





</p>


<h3>Author(s)</h3>

<p>Jose Augusto Fiorucci and Francisco Louzada

</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecTheta-package">forecTheta-package</a></code>, <code><a href="#topic+groe">groe</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############################################################	

y1 = 2+ 0.15*(1:20) + rnorm(20,2)
y2 = y1[20]+ 0.3*(1:30) + rnorm(30,2)
y =  as.ts(c(y1,y2))

out &lt;- dotm(y=as.ts(y[1:40]), h=10)

### sMAPE metric
errorMetric(obs=as.ts(y[41:50]), forec=out$mean)

### sMdAPE metric
errorMetric(obs=as.ts(y[41:50]), forec=out$mean, statistic = "Md")

### MASE metric
meanDiff1 = mean(abs(diff(as.ts(y[1:40]), lag = 1)))
errorMetric(obs=as.ts(y[41:50]), forec=out$mean, type = "AE", statistic = "M") / meanDiff1
</code></pre>

<hr>
<h2 id='expSmoot'>
Simple Exponential Smoothing Method
</h2><span id='topic+expSmoot'></span>

<h3>Description</h3>

<p>Estimation of Simple Exponential Smoothing Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	expSmoot(y, h=5, ell0=NULL, alpha=NULL, lower = c(-1e+10, 0.1), 
	upper = c(1e+10, 0.99))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expSmoot_+3A_y">y</code></td>
<td>

<p>Object of time series class.
</p>
</td></tr>
<tr><td><code id="expSmoot_+3A_h">h</code></td>
<td>

<p>Number of required forecasting periods.
</p>
</td></tr>
<tr><td><code id="expSmoot_+3A_ell0">ell0</code></td>
<td>

<p>The value of <code>ell0^*</code> parameter.
</p>
</td></tr>
<tr><td><code id="expSmoot_+3A_alpha">alpha</code></td>
<td>

<p>The value of <code>alpha</code> parameter.
</p>
</td></tr>
<tr><td><code id="expSmoot_+3A_lower">lower</code></td>
<td>

<p>The lower limit of parametric space.
</p>
</td></tr>
<tr><td><code id="expSmoot_+3A_upper">upper</code></td>
<td>

<p>The upper limit of parametric space.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the elements:
</p>
<table>
<tr><td><code>$y</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code>$par</code></td>
<td>
<p>The estimated values for <code>(ell^*, alpha)</code> parameters</p>
</td></tr>
<tr><td><code>$mean</code></td>
<td>
<p>The forecasting values</p>
</td></tr>
<tr><td><code>$fitted</code></td>
<td>
<p>A time series element with the fitted points.</p>
</td></tr>
<tr><td><code>$residuals</code></td>
<td>
<p>A time series element with the residual points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Augusto Fiorucci, Francisco Louzada and Bao Yiqi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecTheta-package">forecTheta-package</a></code>, <code><a href="#topic+stheta">stheta</a></code>, <code><a href="#topic+dotm">dotm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y1 = 2+ 0.15*(1:20) + rnorm(20,2)
y2 = y1[20]+ 0.3*(1:30) + rnorm(30,2)
y =  as.ts(c(y1,y2))

expSmoot(y, h=10)

</code></pre>

<hr>
<h2 id='otm.arxiv'>
Optimised Theta Method

</h2><span id='topic+otm.arxiv'></span>

<h3>Description</h3>


<p>Functions for forecast univariate time series using the Optimised Theta Method presented in the arxiv paper (Fioruci et al, 2015).
If the theta parameter is not specified so the Generalised Rolling Origin Evaluation is used
for select the theta value over the thetaList argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	otm.arxiv( y, h=5, s=NULL, theta=NULL, tLineExtrap=expSmoot, g="sAPE",
		approach="c", n1=NULL, m=NULL, H=NULL, p=NULL,
		thetaList=seq(from=1,to=5,by=0.5), mc.cores=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otm.arxiv_+3A_y">y</code></td>
<td>

<p>Object of time series class

</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_h">h</code></td>
<td>

<p>Number of required forecasting periods

</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_s">s</code></td>
<td>

<p>If <code>TRUE</code>, the multiplicative seasonal decomposition is used.
If <code>NULL</code>, quarterly and monthly time series are tested for statistically seasonal behaviour, with 95% of significance. Default is NULL.

</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_theta">theta</code></td>
<td>

<p>The value of theta parameter. If <code>theta = NULL</code> the theta parameter is estimated using the Generalised Rolling Origin Evaluation.


</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_tlineextrap">tLineExtrap</code></td>
<td>

<p>A forecasting function for extrapolation the second theta-line. Default is <code>expSmoot</code>.

</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_g">g</code></td>
<td>

<p>The error type that will be used by <code>groe</code> function for select the <code>theta</code> value in the estimation process.
The possibility values for <code>g</code>	is <code>"sAPE", "APE", "AE"</code> and <code>"SE"</code>.
If <code>theta</code> is not <code>NULL</code> the <code>g</code> argument is not used. Default is &quot;sAPE&quot;.

</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_approach">approach</code></td>
<td>

<p>The approach set-up for <code>groe</code> parameters (<code>n1, m, H, p</code>). One letter between <code>'a'</code> to <code>'h'</code> according to Fioruci et al (2015).
</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_n1">n1</code></td>
<td>

<p>The first origin for Generalised Rolling Origin Evaluation.
This argument is not used if <code>theta!=NULL</code> or <code>approach!=NULL</code>.

</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_m">m</code></td>
<td>

<p>The number of movements of the origin in each step. This argument is not used if <code>theta!=NULL</code> or <code>approach!=NULL</code>.

</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_h">H</code></td>
<td>

<p>The number of predictions in each step. This argument is not used if <code>theta!=NULL</code> or <code>approach!=NULL</code>.

</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_p">p</code></td>
<td>

<p>The number of origin updates. This argument is not used if <code>theta!=NULL</code> or <code>approach!=NULL</code>.

</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_thetalist">thetaList</code></td>
<td>

<p>A vector with the possible values for <code>theta</code>. This argument is not used if <code>theta</code> argument is not <code>NULL</code>.

</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_mc.cores">mc.cores</code></td>
<td>

<p>Number of cores that will be used for estimate the theta parameter. It is not accepted <code>mc.cores&gt;1</code> on Windows SO.

</p>
</td></tr>
<tr><td><code id="otm.arxiv_+3A_...">...</code></td>
<td>

<p>Additional arguments for <code>tLineExtrap</code>.

</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are fully automatic, you just need to pass your time series. Particular cases are obtained by:
If <code>theta = 1</code> the <code>tLineExtrapModel</code> method is computed;
If <code>theta = 2</code> so the Standard Theta Method of Assimakopoulos and Nikolopoulos (2000) is computed.
</p>
<p>By default (<code>s=NULL</code>), the 90% significance seasonal Z-test, used by Assimakopoulos and Nikolopoulos (2000), is applied for quarterly and monthly time series.
</p>


<h3>Value</h3>

<p>An list containing the elements:
</p>
<table>
<tr><td><code>$y</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code>$mean</code></td>
<td>
<p>A time series element with the forecasting points.</p>
</td></tr>
<tr><td><code>$fitted</code></td>
<td>
<p>A time series element with the fitted points.</p>
</td></tr>
<tr><td><code>$residuals</code></td>
<td>
<p>A time series element with the residual points.</p>
</td></tr>
<tr><td><code>$theta</code></td>
<td>
<p>The estimated theta value.</p>
</td></tr>
<tr><td><code>$tLineExtrap_par</code></td>
<td>
<p>The estimated parameters of <code>tLineExtrap</code> method.</p>
</td></tr>
<tr><td><code>$weights</code></td>
<td>
<p>The estimated weights values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>thetaM</code> function is just a particular case of <code>otm</code> with <code>theta=2</code>.
</p>


<h3>Author(s)</h3>

<p>Jose Augusto Fiorucci, Francisco Louzada
</p>


<h3>References</h3>

<p>Fioruci J.A., Pellegrini T.R., Louzada F., Petropoulos F. (2015). <em>The Optimised Theta Method</em>. arXiv preprint, arXiv:1503.03529.
</p>
<p>Assimakopoulos, V. and Nikolopoulos k. (2000). <em>The theta model: a decomposition approach to forecasting</em>. International Journal of Forecasting 16, 4, 521-530.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecTheta-package">forecTheta-package</a></code>, <code><a href="#topic+dotm">dotm</a></code>, <code><a href="#topic+groe">groe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y1 = 2+ 0.15*(1:20) + rnorm(20,2)
y2 = y1[20]+ 0.3*(1:30) + rnorm(30,2)
y =  as.ts(c(y1,y2))

otm.arxiv(y, h=10)

### running the M3-competition data base by OTM approach (a) ###
#require(Mcomp)
#data(M3)
#
#forec = matrix(NA, nrow=3003, ncol=18)
#obs = matrix(NA, nrow=3003, ncol=18) #matrix of the out-sample values
#
#for(i in 1:3003){
#	if(i %% 100 == 0){print(i)}
#	x=M3[[i]]$x
#	h=M3[[i]]$h
#	out = otm.arxiv(x,h,approach='a',tLineExtrap=ses)
#	forec[i,1:h] = out$mean
#	obs[i,1:h] = M3[[i]]$xx
#}
#
#sAPE = errorMetric(obs, forec, type="sAPE", statistic="N") ## sAPE matrix
#
##### sMAPE results ##
### Yearly
#mean( sAPE[1:645, 1:6] )
### QUARTERLY
#mean( sAPE[646:1401, 1:8] )
### MONTHLY
#mean( sAPE[1402:2829, 1:18] )
### Other
#mean( sAPE[2830:3003, 1:8] )
### ALL
#mean( sAPE, na.rm=TRUE )

</code></pre>

<hr>
<h2 id='Plot'>Plot forecasts points and prediction intervals for <code>thetaModel</code> objects</h2><span id='topic+plot.thetaModel'></span>

<h3>Description</h3>

<p>Produces a figure of the time series and the forecasts points from Optimised Theta Method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'thetaModel'
plot(x, ylim=NULL, xlim=NULL, ylab=NULL, xlab=NULL, main=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot_+3A_x">x</code></td>
<td>
<p>Object of class &ldquo;thetaModel&rdquo;.</p>
</td></tr>
<tr><td><code id="Plot_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot.</p>
</td></tr>
<tr><td><code id="Plot_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot.</p>
</td></tr>
<tr><td><code id="Plot_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis.</p>
</td></tr>
<tr><td><code id="Plot_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="Plot_+3A_main">main</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="Plot_+3A_...">...</code></td>
<td>
<p>Other plotting parameters passed to <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Function produces a plot</p>


<h3>Author(s)</h3>

<p>Jose A Fiorucci</p>


<h3>See Also</h3>

<p><code><a href="#topic+dotm">dotm</a></code>, <code><a href="#topic+forecTheta-package">forecTheta-package</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 = 2+ 0.15*(1:20) + rnorm(20,2)
y2 = y1[20]+ 0.3*(1:30) + rnorm(30,2)
y =  as.ts(c(y1,y2))
out &lt;- dotm(y, h=10)
plot(out)
</code></pre>

<hr>
<h2 id='Theta+20Models'>
Theta Models

</h2><span id='topic+dotm'></span><span id='topic+dstm'></span><span id='topic+otm'></span><span id='topic+stm'></span><span id='topic+stheta'></span>

<h3>Description</h3>


<p>Functions for forecast univariate time series using the Dynamic Optimised Theta Model, Dynamic Standard Theta Model,
Optimised Theta Model and Standard Theta Model (Fiorucci et al, 2016).
We also provide an implementation for the Standard Theta Method (STheta) of Assimakopoulos and Nikolopoulos (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	dotm(y, h=5, level=c(80,90,95), s=NULL, par_ini=c(y[1]/2, 0.5, 2),
	estimation=TRUE, lower=c(-1e+10, 0.1, 1.0), upper=c(1e+10, 0.99, 1e+10),
	opt.method="Nelder-Mead", xreg=NULL)

	dstm(y, h=5, level=c(80,90,95), s=NULL, par_ini=c(y[1]/2, 0.5), estimation=TRUE,
	lower=c(-1e+10, 0.1), upper=c(1e+10, 0.99), opt.method="Nelder-Mead", xreg=NULL)

	otm(y, h=5, level=c(80,90,95), s=NULL, par_ini=c(y[1]/2, 0.5, 2),
	estimation=TRUE, lower=c(-1e+10, 0.1, 1.0), upper=c(1e+10, 0.99, 1e+10),
	opt.method="Nelder-Mead", xreg=NULL)

	stm(y, h=5, level=c(80,90,95), s=NULL, par_ini=c(y[1]/2, 0.5), estimation=TRUE,
	lower=c(-1e+10, 0.1), upper=c(1e+10, 0.99), opt.method="Nelder-Mead", xreg=NULL)

	stheta(y, h=5, s=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Theta+2B20Models_+3A_y">y</code></td>
<td>

<p>Object of time series class.
</p>
</td></tr>
<tr><td><code id="Theta+2B20Models_+3A_h">h</code></td>
<td>

<p>Number of required forecasting periods.
</p>
</td></tr>
<tr><td><code id="Theta+2B20Models_+3A_level">level</code></td>
<td>

<p>Levels for prediction intervals.
</p>
</td></tr>
<tr><td><code id="Theta+2B20Models_+3A_s">s</code></td>
<td>

<p>If <code>TRUE</code>, the multiplicative seasonal decomposition is used.
If <code>NULL</code> and <code>frequency(y)&gt;=4</code> the time series is tested for statistically seasonal behaviour, with 90% of significance.
If s='additive' or close zero values been find in the multiplicative decomposition, the additive decomposition is performed hatter than multiplicative.
Default is NULL.
</p>
</td></tr>
<tr><td><code id="Theta+2B20Models_+3A_par_ini">par_ini</code></td>
<td>

<p>Vector of initialization for <code>(ell, alpha, theta)</code> parameters.
</p>
</td></tr>
<tr><td><code id="Theta+2B20Models_+3A_estimation">estimation</code></td>
<td>

<p>If <code>TRUE</code>, the <code>optim()</code> function is consider for compute the minimum square estimator of parameters.
If <code>FALSE</code>, the models/methods are computed for <code>par_ini</code> values.
</p>
</td></tr>
<tr><td><code id="Theta+2B20Models_+3A_lower">lower</code></td>
<td>

<p>The lower limit of parametric space.
</p>
</td></tr>
<tr><td><code id="Theta+2B20Models_+3A_upper">upper</code></td>
<td>

<p>The upper limit of parametric space.
</p>
</td></tr>
<tr><td><code id="Theta+2B20Models_+3A_opt.method">opt.method</code></td>
<td>

<p>The numeric optimisation method for <code>optim()</code> function.
Choose one among <code>'Nelder-Mead', 'L-BFGS-B', 'SANN'</code>.
</p>
</td></tr>
<tr><td><code id="Theta+2B20Models_+3A_xreg">xreg</code></td>
<td>

<p>A matrix with the regressor variables including the out-of-sample data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default (<code>s=NULL</code>), the 90% significance seasonal Z-test, used by Assimakopoulos and Nikolopoulos (2000), is applied for quarterly and monthly time series.
</p>
<p>For details of each model see Fiorucci et al, 2016.
If you are looking for the methods presented in the arXiv paper (Fiorucci et al, 2015), see <code>otm.arxiv()</code> function.
</p>


<h3>Value</h3>

<p>An object of <code>thetaModel</code> class with one list containing the elements:
</p>
<table>
<tr><td><code>$method</code></td>
<td>
<p>The name of the model/method</p>
</td></tr>
<tr><td><code>$y</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code>$s</code></td>
<td>
<p>A binary indication for seasonal decomposition.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Classical seasonal decomposition type.</p>
</td></tr>
<tr><td><code>opt.method</code></td>
<td>
<p>The optimisation method used in the <code>optim()</code> function.</p>
</td></tr>
<tr><td><code>$par</code></td>
<td>
<p>The estimated values for <code>(ell, alpha, theta)</code> parameters</p>
</td></tr>
<tr><td><code>$weights</code></td>
<td>
<p>The estimated weights values.</p>
</td></tr>
<tr><td><code>$fitted</code></td>
<td>
<p>A time series element with the fitted points.</p>
</td></tr>
<tr><td><code>$residuals</code></td>
<td>
<p>A time series element with the residual points.</p>
</td></tr>
<tr><td><code>$mean</code></td>
<td>
<p>The forecasting values.</p>
</td></tr>
<tr><td><code>$level</code></td>
<td>
<p>The levels for prediction intervals.</p>
</td></tr>
<tr><td><code>$lower</code></td>
<td>
<p>Lower limits for prediction intervals.</p>
</td></tr>
<tr><td><code>$upper</code></td>
<td>
<p>Upper limits for prediction intervals.</p>
</td></tr>
<tr><td><code>$tests</code></td>
<td>
<p>The p.value of Teraesvirta Neural Network test applied on unseasoned time series and the p.value of Shapiro-Wilk test applied on unseasoned residuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Augusto Fiorucci, Francisco Louzada
</p>


<h3>References</h3>

<p>Fiorucci J.A., Pellegrini T.R., Louzada F., Petropoulos F., Koehler, A. (2016). <em>Models for optimising the theta method and their relationship to state space models</em>,	International Journal of Forecasting, 32 (4), 1151&ndash;1161, &lt;doi:10.1016/j.ijforecast.2016.02.005&gt;.
</p>
<p>Assimakopoulos, V. and Nikolopoulos k. (2000). <em>The theta model: a decomposition approach to forecasting</em>. International Journal of Forecasting 16, 4, 521&ndash;530, &lt;doi:10.1016/S0169-2070(00)00066-2&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecTheta-package">forecTheta-package</a></code>, <code><a href="#topic+otm.arxiv">otm.arxiv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y1 = 2+ 0.15*(1:20) + rnorm(20)
y2 = y1[20]+ 0.3*(1:30) + rnorm(30)
y =  as.ts(c(y1,y2))
out &lt;- dotm(y, h=10)
summary(out)
plot(out)

#### additive seasonal decomposition ###
x = sin(2*pi*seq(0,9,len=300)) + exp((1:300)/150) + rnorm(mean=0,sd=0.5,n=300)
y = ts(x, frequency=33)
out &lt;- dotm(y, h=50, s='additive')
summary(out)
plot(out)

# #########################################################
# ######### Reproducing the M3 results by DOTM ############
# #########################################################
#
# library(Mcomp)
# data(M3)
#
# forec = matrix(NA, nrow=3003, ncol=18)
# obs = matrix(NA, nrow=3003, ncol=18) #matrix of the out-sample values
# meanDiff &lt;- rep(1, 3003)
#
# for(i in 1:3003){
#   x=M3[[i]]$x
#   h=M3[[i]]$h
#   out = dotm(x,h,level=NULL)
#   forec[i,1:h] = out$mean
#   obs[i,1:h] = M3[[i]]$xx
#   meanDiff[i] = mean(abs(diff(x, lag = frequency(x))))
# }
#
# ############## sMAPE ###################
# sAPE_matrix = errorMetric(obs=obs, forec=forec, type="sAPE", statistic="N")
# #### Yearly ###
# mean( sAPE_matrix[1:645, 1:6] )
# #### QUARTERLY ###
# mean( sAPE_matrix[646:1401, 1:8] )
# #### MONTHLY ###
# mean( sAPE_matrix[1402:2829, 1:18] )
# #### Other ###
# mean( sAPE_matrix[2830:3003, 1:8] )
# #### ALL ###
# mean( sAPE_matrix, na.rm=TRUE )
# #
# ############# MASE ######################
# AE_matrix = errorMetric(obs=obs, forec=forec, type="AE", statistic="N")
# ASE_matrix=AE_matrix/meanDiff
# #### Yearly ###
# mean( ASE_matrix[1:645, 1:6] )
# #### QUARTERLY ###
# mean( ASE_matrix[646:1401, 1:8] )
# #### MONTHLY ###
# mean( ASE_matrix[1402:2829, 1:18] )
# #### Other ###
# mean( ASE_matrix[2830:3003, 1:8] )
# #### ALL ###
# mean( ASE_matrix, na.rm=TRUE )
# ########################################################


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
