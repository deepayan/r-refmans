<!DOCTYPE html><html><head><title>Help for package gbp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gbp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gbp'><p>gbp</p></a></li>
<li><a href='#bpp_solver'><p>bpp_solver</p></a></li>
<li><a href='#bpp_solver_dpp'><p>bpp_solver_dpp</p></a></li>
<li><a href='#bpp_solver_dpp_wrapper'><p>bpp_solver_dpp_wrapper</p></a></li>
<li><a href='#bpp_solver_sgl'><p>bpp_solver_sgl</p></a></li>
<li><a href='#bpp_viewer'><p>bpp_viewer</p></a></li>
<li><a href='#bpp_viewer_single'><p>bpp_viewer_single</p></a></li>
<li><a href='#bppSgl'><p>bppSgl</p></a></li>
<li><a href='#create_bn_rgl_control'><p>create_bn_rgl_control</p></a></li>
<li><a href='#create_it_cube3d'><p>create_it_cube3d</p></a></li>
<li><a href='#create_it_rgl_control'><p>create_it_rgl_control</p></a></li>
<li><a href='#gbp1d'><p>gbp1d</p></a></li>
<li><a href='#gbp1d_solver_dpp'><p>gbp1d_solver_dpp</p></a></li>
<li><a href='#gbp2d'><p>gbp2d</p></a></li>
<li><a href='#gbp2d_checkr'><p>gbp2d_checkr</p></a></li>
<li><a href='#gbp2d_it_create_ktlist'><p>gbp2d_it_create_ktlist</p></a></li>
<li><a href='#gbp2d_solver_dpp'><p>gbp2d_solver_dpp</p></a></li>
<li><a href='#gbp2d_solver_dpp_filt'><p>gbp2d_solver_dpp_filt</p></a></li>
<li><a href='#gbp2d_solver_dpp_prep_create_p'><p>gbp2d_solver_dpp_prep_create_p</p></a></li>
<li><a href='#gbp2d_viewer'><p>gbp2d_viewer</p></a></li>
<li><a href='#gbp2q'><p>gbp2q</p></a></li>
<li><a href='#gbp2q_checkr'><p>gbp2q_checkr</p></a></li>
<li><a href='#gbp2q_viewer'><p>gbp2q_viewer</p></a></li>
<li><a href='#gbp3d'><p>gbp3d</p></a></li>
<li><a href='#gbp3d_checkr'><p>gbp3d_checkr</p></a></li>
<li><a href='#gbp3d_it_create_ktlist'><p>gbp3d_it_create_ktlist</p></a></li>
<li><a href='#gbp3d_solver_dpp'><p>gbp3d_solver_dpp</p></a></li>
<li><a href='#gbp3d_solver_dpp_filt'><p>gbp3d_solver_dpp_filt</p></a></li>
<li><a href='#gbp3d_solver_dpp_prep_create_p'><p>gbp3d_solver_dpp_prep_create_p</p></a></li>
<li><a href='#gbp3d_viewer'><p>gbp3d_viewer</p></a></li>
<li><a href='#gbp3q'><p>gbp3q</p></a></li>
<li><a href='#gbp3q_checkr'><p>gbp3q_checkr</p></a></li>
<li><a href='#gbp3q_viewer'><p>gbp3q_viewer</p></a></li>
<li><a href='#gbp4d'><p>gbp4d</p></a></li>
<li><a href='#gbp4d_checkr'><p>gbp4d_checkr</p></a></li>
<li><a href='#gbp4d_it_create_ktlist'><p>gbp4d_it_create_ktlist</p></a></li>
<li><a href='#gbp4d_solver_dpp'><p>gbp4d_solver_dpp</p></a></li>
<li><a href='#gbp4d_solver_dpp_filt'><p>gbp4d_solver_dpp_filt</p></a></li>
<li><a href='#gbp4d_solver_dpp_prep_create_p'><p>gbp4d_solver_dpp_prep_create_p</p></a></li>
<li><a href='#gbp4d_viewer'><p>gbp4d_viewer</p></a></li>
<li><a href='#gbp4q'><p>gbp4q</p></a></li>
<li><a href='#gbp4q_checkr'><p>gbp4q_checkr</p></a></li>
<li><a href='#gbp4q_viewer'><p>gbp4q_viewer</p></a></li>
<li><a href='#Ktlist2d'><p>Ktlist2d</p></a></li>
<li><a href='#Ktlist3d'><p>Ktlist3d</p></a></li>
<li><a href='#Ktlist4d'><p>Ktlist4d</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Bin Packing Problem Solver</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Guang Yang</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guang Yang &lt;gyang274@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Basic infrastructure and several algorithms for 1d-4d bin packing
    problem. This package provides a set of c-level classes and solvers for
    1d-4d bin packing problem, and an r-level solver for 4d bin packing problem,
    which is a wrapper over the c-level 4d bin packing problem solver.
    The 4d bin packing problem solver aims to solve bin packing problem, a.k.a
    container loading problem, with an additional constraint on weight.
    Given a set of rectangular-shaped items, and a set of rectangular-shaped bins
    with weight limit, the solver looks for an orthogonal packing solution
    such that minimizes the number of bins and maximize volume utilization.
    Each rectangular-shaped item i = 1, .. , n is characterized by length l_i,
    depth d_i, height h_i, and weight w_i, and each rectangular-shaped bin
    j = 1, .. , m is specified similarly by length l_j, depth d_j, height h_j,
    and weight limit w_j.
    The item can be rotated into any orthogonal direction, and no further
    restrictions implied.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), magrittr, data.table</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, rgl, Rcpp (&ge; 0.12.7)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11, GNU make</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gyang274/gbp">https://github.com/gyang274/gbp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gyang274/gbp/issues">https://github.com/gyang274/gbp/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-27 20:05:45 UTC; guang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-28 17:31:25</td>
</tr>
</table>
<hr>
<h2 id='gbp'>gbp</h2><span id='topic+gbp'></span><span id='topic+gbp-package'></span>

<h3>Description</h3>

<p>a collection of 1d, 2d, 3d and 4d bin packing problem solver
</p>


<h3>solver</h3>

<p>r-level:
</p>
<p>wrapper over c-level function aims solving e-commerce bin packing problem
</p>
<p>bpp_solver
</p>
<p>c-level:
</p>
<p>core class and solver on 1d, 2d, 3d and 4d bpp
</p>
<p>gbp1d_solver_dpp
</p>
<p>gbp2d_solver_dpp
</p>
<p>gbp2d_solver_dpp_filt
</p>
<p>gbp3d_solver_dpp
</p>
<p>gbp3d_solver_dpp_filt
</p>
<p>gbp4d_solver_dpp
</p>
<p>gbp4d_solver_dpp_filt
</p>
<p>bpp_solver_sgl
</p>
<p>bpp_solver_dpp
</p>


<h3>optimizer</h3>

<p>TODO: implementing a bin-shuffing optimizer?
</p>


<h3>viewer</h3>

<p>rgl 3d show packing obtained via bpp_solver
</p>
<p>bpp_viewer
</p>

<hr>
<h2 id='bpp_solver'>bpp_solver</h2><span id='topic+bpp_solver'></span>

<h3>Description</h3>

<p>bpp single or multiple order packing solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpp_solver(it, bn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpp_solver_+3A_it">it</code></td>
<td>
<p>it item &lt;data.table&gt;
</p>
<p>- oid: order id &lt;integer&gt;
</p>
<p>- sku: stock keeping unit as it id &lt;character&gt;
</p>
<p>- l: it length which scale will be placed along x-coordinate &lt;numeric&gt;
</p>
<p>- d: it depth  which scale will be placed along y-coordinate &lt;numeric&gt;
</p>
<p>- h: it height which scale will be placed along z-coordinate &lt;numeric&gt;
</p>
<p>- w: it weight optional which scale will be used restriction &lt;integer&gt;</p>
</td></tr>
<tr><td><code id="bpp_solver_+3A_bn">bn</code></td>
<td>
<p>bn bins &lt;data.table&gt;
</p>
<p>- id: bn id &lt;character&gt;
</p>
<p>- l: bn length limit along x-coordinate &lt;numeric&gt;
</p>
<p>- d: bn depth  limit along y-coordinate &lt;numeric&gt;
</p>
<p>- h: bn height limit along z-coordinate &lt;numeric&gt;
</p>
<p>- w: bn weight limit along w - a separate single dimension &lt;numeric&gt;
</p>
<p>- l, d, h will be sorted to have l &gt;= d &gt;= h within solver</p>
</td></tr>
</table>


<h3>Details</h3>

<p>bpp solver is designed to solve packing in warehouse
</p>
<p>bpp solver digest input it as a list of order (oid) and each row contain one
sku (sku) in an order with length (l), depth (d), height (h) and weight (w)
and aims to pack it list into one or more bin from a given list of bin that
bin length (l), depth (d), height (h), and a single weight limit (wlmt).
</p>
<p>bn list must be sorted by volume so that the smaller the eariler and preferred,
and each bn must be sorted so that l &gt;= d &gt;= h
</p>
<p>bpp solver would call bpp_solver_dpp_wrapper and aims to find a packing schema
such that: use as small number of bin as possible, and use small bin whenever
possible, w.r.t the 3d none overlap constraint and weight limit constraint.
</p>


<h3>Value</h3>

<p>sn
</p>
<p>sn bpp_solution &lt;list&gt;
</p>
<p>- it item &lt;data.table&gt;
</p>
<p>- oid: order id &lt;integer&gt;
</p>
<p>- sku: stock keeping unit as it id &lt;character&gt;
</p>
<p>- tid: ticket id - an unique id within oid &lt;integer&gt;
</p>
<p>- otid: order id x ticket id - an unique indentifier indicate it with same tid can be packed into one bin &lt;character&gt;
</p>
<p>- bid: bn id &lt;integer&gt;
</p>
<p>- x, y, z it position in bid bin &lt;numeric&gt;
</p>
<p>- l, d, h it scale along x, y, z &lt;numeric&gt;
</p>
<p>- w it weight &lt;numeric&gt;
</p>
<p>- bn bins &lt;data.table&gt;
</p>
<p>- id bn id &lt;character&gt;
</p>
<p>- l bn length limit along x-coordinate &lt;numeric&gt;
</p>
<p>- d bn depth  limit along y-coordinate &lt;numeric&gt;
</p>
<p>- h bn height limit along z-coordinate &lt;numeric&gt;
</p>
<p>- w bn weight limit along w - a separate single dimension &lt;numeric&gt;
</p>


<h3>Note</h3>

<p>bpp_solver is an r-level wrapper over c-level bpp_solver_dpp_wrapper,
add otid as an unique indentifier.
</p>

<hr>
<h2 id='bpp_solver_dpp'>bpp_solver_dpp</h2><span id='topic+bpp_solver_dpp'></span>

<h3>Description</h3>

<p>main solver of e-commerce warehouse packing algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpp_solver_dpp(id, ldhw, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpp_solver_dpp_+3A_id">id</code></td>
<td>
<p>&lt;vector&gt;
</p>
<p>id order id &lt;integer&gt; vector - should sorted or at least grouped w.r.t order id</p>
</td></tr>
<tr><td><code id="bpp_solver_dpp_+3A_ldhw">ldhw</code></td>
<td>
<p>&lt;matrix&gt;
</p>
<p>it order list
</p>
<p>- l, d, h, w it scale along x, y, z and w &lt;numeric&gt;
</p>
<p>it columns should corresponding to id</p>
</td></tr>
<tr><td><code id="bpp_solver_dpp_+3A_m">m</code></td>
<td>
<p>&lt;matrix&gt;
</p>
<p>m a bin list
</p>
<p>- l, d, h, w bn scale along x, y, z and w &lt;numeric&gt;
</p>
<p>m should sorted w.r.t preference</p>
</td></tr>
</table>


<h3>Details</h3>

<p>bpp init a list of order on sku in data.frame it - oid, sku, l, d, h, w:
order id oid, stock keeping unit sku, length l, depth d, height h and weight w,
</p>
<p>and also a list of available bn in data.frame bn - id, l, d, h, w:
bn id, length l, depth d, height h, and weight limit w, sorted by peference often smaller prefered,
</p>
<p>and a single weight limit wlmt applied on all bin.
</p>
<p>bpp solver would solve
</p>
<p>select least number of bn for packing each order w.r.t bn size and weight limit
and make sure the bn selected are as small as possible.
</p>


<h3>Value</h3>

<p>bppSgl
</p>


<h3>See Also</h3>

<p>Other bpp_solver_dpp: <code><a href="#topic+bpp_solver_dpp_wrapper">bpp_solver_dpp_wrapper</a></code>,
<code><a href="#topic+bpp_solver_sgl">bpp_solver_sgl</a></code>
</p>

<hr>
<h2 id='bpp_solver_dpp_wrapper'>bpp_solver_dpp_wrapper</h2><span id='topic+bpp_solver_dpp_wrapper'></span>

<h3>Description</h3>

<p>a wrapper over bpp_solver_dpp and expose an nicer r interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpp_solver_dpp_wrapper(it, bn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpp_solver_dpp_wrapper_+3A_it">it</code></td>
<td>
<p>&lt;data.frame&gt;
</p>
<p>it order itemSKU list
</p>
<p>- oid: order id &lt;integer&gt;
</p>
<p>- sku: stock keeping unit - it id &lt;character&gt;
</p>
<p>- l, d, h, w it scale along x, y, z and w &lt;numeric&gt;
</p>
<p>- w will be used as constraint while l, d, h will be used as both constraint and objective
</p>
<p>it must be sorted w.r.t oid</p>
</td></tr>
<tr><td><code id="bpp_solver_dpp_wrapper_+3A_bn">bn</code></td>
<td>
<p>&lt;data.frame&gt;
</p>
<p>bn a bin list
</p>
<p>- id: bin id &lt;character&gt;
</p>
<p>- l, d, h, w bn scale along x, y, z and w &lt;numeric&gt;
</p>
<p>bn must be sorted w.r.t preference and have l &gt;= d &gt;= h</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sn &lt;list&gt;
</p>
<p>sn solution - it order itemSKU list with tid, bid, and x, y, z &lt;data.frame&gt;
</p>
<p>- oid: order id inherited from it &lt;character&gt;
</p>
<p>- tid: ticket id implied one order can be packed using several ticket id &lt;character&gt;
</p>
<p>each ticket id corresponding to a bid bin id which indicates which bin to use for packing
</p>
<p>- bid: bin id which bn in bn list should be used in pakcing &lt;character&gt;
</p>
<p>- sku: stock keeping unit it id &lt;character&gt;
</p>
<p>- x, y, z it position in the bin &lt;numeric&gt;
</p>
<p>- l, d, h it scale along x, y, z &lt;numeric&gt;
</p>
<p>l, d, h is not inherited from it as it can be rotated to different orientation for packing
</p>
<p>- w it weight scale inherited from it &lt;numeric&gt;
</p>


<h3>See Also</h3>

<p>Other bpp_solver_dpp: <code><a href="#topic+bpp_solver_dpp">bpp_solver_dpp</a></code>,
<code><a href="#topic+bpp_solver_sgl">bpp_solver_sgl</a></code>
</p>

<hr>
<h2 id='bpp_solver_sgl'>bpp_solver_sgl</h2><span id='topic+bpp_solver_sgl'></span>

<h3>Description</h3>

<p>subroutine of bpp_solver_dpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpp_solver_sgl(ldhw, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpp_solver_sgl_+3A_ldhw">ldhw</code></td>
<td>
<p>&lt;matrix&gt;
</p>
<p>it order list
</p>
<p>- l, d, h, w it scale along x, y, z and w &lt;numeric&gt;
</p>
<p>it columns should corresponding to id</p>
</td></tr>
<tr><td><code id="bpp_solver_sgl_+3A_m">m</code></td>
<td>
<p>&lt;matrix&gt;
</p>
<p>m a bin list
</p>
<p>- l, d, h, w bn scale along x, y, z and w &lt;numeric&gt;
</p>
<p>m should sorted w.r.t preference</p>
</td></tr>
</table>


<h3>Details</h3>

<p>fit a single order into bn list, call gbp4d_solver_dpp_filt() as main solver.
</p>


<h3>Value</h3>

<p>bppSgl
</p>


<h3>See Also</h3>

<p>Other bpp_solver_dpp: <code><a href="#topic+bpp_solver_dpp_wrapper">bpp_solver_dpp_wrapper</a></code>,
<code><a href="#topic+bpp_solver_dpp">bpp_solver_dpp</a></code>
</p>

<hr>
<h2 id='bpp_viewer'>bpp_viewer</h2><span id='topic+bpp_viewer'></span>

<h3>Description</h3>

<p>bpp single or multiple order packing solution viewer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpp_viewer(sn, title = NULL, subtitle = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpp_viewer_+3A_sn">sn</code></td>
<td>
<p>sn bpp_solution from bpp_solver &lt;list&gt;
</p>
<p>- it item &lt;data.table&gt;
</p>
<p>- oid: order id &lt;integer&gt;
</p>
<p>- sku: stock keeping unit as it id &lt;character&gt;
</p>
<p>- tid: ticket id - an unique id within oid &lt;integer&gt;
</p>
<p>- otid: order id x ticket id - an unique indentifier indicate it with same tid can be packed into one bin &lt;character&gt;
</p>
<p>- bid: bn id &lt;integer&gt;
</p>
<p>- x, y, z it position in bid bin &lt;numeric&gt;
</p>
<p>- l, d, h it scale along x, y, z &lt;numeric&gt;
</p>
<p>- w it weight &lt;numeric&gt;
</p>
<p>- bn bins &lt;data.table&gt;
</p>
<p>- id bn id &lt;character&gt;
</p>
<p>- l bn length limit along x-coordinate &lt;numeric&gt;
</p>
<p>- d bn depth  limit along y-coordinate &lt;numeric&gt;
</p>
<p>- h bn height limit along z-coordinate &lt;numeric&gt;
</p>
<p>- w bn weight limit along w - a separate single dimension &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="bpp_viewer_+3A_title">title</code></td>
<td>
<p>title &lt;character&gt;</p>
</td></tr>
<tr><td><code id="bpp_viewer_+3A_subtitle">subtitle</code></td>
<td>
<p>subtitle &lt;character&gt;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other bpp_viewer: <code><a href="#topic+bpp_viewer_single">bpp_viewer_single</a></code>
</p>

<hr>
<h2 id='bpp_viewer_single'>bpp_viewer_single</h2><span id='topic+bpp_viewer_single'></span>

<h3>Description</h3>

<p>bpp solution viewer on single bin all item
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpp_viewer_single(it, bn, title = NULL, subtitle = NULL,
  it_rgl_control = NULL, bn_rgl_control = NULL, label_it = TRUE,
  label_bn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpp_viewer_single_+3A_it">it</code></td>
<td>
<p>it item &lt;data.table&gt;
</p>
<p>- id it id &lt;integer&gt;
</p>
<p>- x, y, z it position w.r.t bins &lt;numeric&gt;
</p>
<p>- l, d, h it scale along x, y, z &lt;numeric&gt;
</p>
<p>- w it weight &lt;numeric&gt;
</p>
<p>- auto: cc, wd, txt point and lines color, size, legend &lt;numeric/character, numeric, character&gt;</p>
</td></tr>
<tr><td><code id="bpp_viewer_single_+3A_bn">bn</code></td>
<td>
<p>bn bins &lt;data.table&gt;
</p>
<p>- id bn id &lt;integer&gt;
</p>
<p>- l, d, h bn scale &lt;numeric&gt;
</p>
<p>- w bn weight limit &lt;numeric&gt;
</p>
<p>- auto: cc, wd, txt point and lines color, size, legend &lt;numeric/character, numeric, character&gt;</p>
</td></tr>
<tr><td><code id="bpp_viewer_single_+3A_title">title</code></td>
<td>
<p>title &lt;character&gt;</p>
</td></tr>
<tr><td><code id="bpp_viewer_single_+3A_subtitle">subtitle</code></td>
<td>
<p>subtitle &lt;character&gt;</p>
</td></tr>
<tr><td><code id="bpp_viewer_single_+3A_it_rgl_control">it_rgl_control</code></td>
<td>
<p>control the color of it in rgl</p>
</td></tr>
<tr><td><code id="bpp_viewer_single_+3A_bn_rgl_control">bn_rgl_control</code></td>
<td>
<p>control the color of bn in rgl</p>
</td></tr>
<tr><td><code id="bpp_viewer_single_+3A_label_it">label_it</code></td>
<td>
<p>label text on it corner or not</p>
</td></tr>
<tr><td><code id="bpp_viewer_single_+3A_label_bn">label_bn</code></td>
<td>
<p>label text on bn corner or not</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other bpp_viewer: <code><a href="#topic+bpp_viewer">bpp_viewer</a></code>
</p>

<hr>
<h2 id='bppSgl'>bppSgl</h2><span id='topic+Rcpp_bppSgl'></span><span id='topic+Rcpp_bppSgl-class'></span><span id='topic+bppSgl'></span>

<h3>Description</h3>

<p>bpp solution of a single one order or multiple order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bppSgl
</code></pre>


<h3>Format</h3>

<p>An object of class <code>C++Class</code> of length 1.</p>


<h3>Details</h3>

<p>packing it into multiple bn w.r.t bn size and weight limit while select bn as small as possible
</p>
<p>a bppSgl class instance has 6 fields:
</p>
<p>- id: order id &lt;integer&gt;
</p>
<p>list - should sorted or at least grouped w.r.t order id
</p>
<p>- it: it position and scale &lt;matrix&gt;
</p>
<p>- x, y, z, w it position and w in the bin &lt;numeric&gt; (w hold in bn when fit it in bn)
</p>
<p>- l, d, h, w it scale along x, y, z and w &lt;numeric&gt; (w of it itself)
</p>
<p>- bn: bn scale &lt;vector&gt;
</p>
<p>- l, d, h, w bn scale along x, y, z and w &lt;numeric&gt;
</p>
<p>- k: ticket id indicator 0 (if cannot fit into any bin), 1, 2, 3, 4, ... &lt;vector&gt;
</p>
<p>- kb: ticket bn id indicator - which bn to use for packing each ticket &lt;vector&gt;
</p>
<p>- ok: ok a quick indicator of any it can not fit into any bn? &lt;bool&gt;
</p>

<hr>
<h2 id='create_bn_rgl_control'>create_bn_rgl_control</h2><span id='topic+create_bn_rgl_control'></span>

<h3>Description</h3>

<p>subroutine of bpp_viewer_single
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_bn_rgl_control()
</code></pre>

<hr>
<h2 id='create_it_cube3d'>create_it_cube3d</h2><span id='topic+create_it_cube3d'></span>

<h3>Description</h3>

<p>subroutine of bpp_viewer_single
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_it_cube3d(id, x, y, z, l, d, h, cc, wd, txt, itxt = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_it_cube3d_+3A_id">id</code></td>
<td>
<p>id</p>
</td></tr>
<tr><td><code id="create_it_cube3d_+3A_x">x</code></td>
<td>
<p>x-coordinate</p>
</td></tr>
<tr><td><code id="create_it_cube3d_+3A_y">y</code></td>
<td>
<p>y-coordinate</p>
</td></tr>
<tr><td><code id="create_it_cube3d_+3A_z">z</code></td>
<td>
<p>z-coordinate</p>
</td></tr>
<tr><td><code id="create_it_cube3d_+3A_l">l</code></td>
<td>
<p>length along x-coordinate</p>
</td></tr>
<tr><td><code id="create_it_cube3d_+3A_d">d</code></td>
<td>
<p>depth  along y-coordinate</p>
</td></tr>
<tr><td><code id="create_it_cube3d_+3A_h">h</code></td>
<td>
<p>height along z-coordinate</p>
</td></tr>
<tr><td><code id="create_it_cube3d_+3A_cc">cc</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="create_it_cube3d_+3A_wd">wd</code></td>
<td>
<p>width</p>
</td></tr>
<tr><td><code id="create_it_cube3d_+3A_txt">txt</code></td>
<td>
<p>text</p>
</td></tr>
<tr><td><code id="create_it_cube3d_+3A_itxt">itxt</code></td>
<td>
<p>plot text or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>add it or bn on current rgl device
</p>

<hr>
<h2 id='create_it_rgl_control'>create_it_rgl_control</h2><span id='topic+create_it_rgl_control'></span>

<h3>Description</h3>

<p>subroutine of bpp_viewer_single
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_it_rgl_control()
</code></pre>

<hr>
<h2 id='gbp1d'>gbp1d</h2><span id='topic+Rcpp_gbp1d'></span><span id='topic+Rcpp_gbp1d-class'></span><span id='topic+gbp1d'></span>

<h3>Description</h3>

<p>generalized bin packing problem in 1 dimension, a.k.a knapsack 0-1 problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp1d
</code></pre>


<h3>Format</h3>

<p>An object of class <code>C++Class</code> of length 1.</p>


<h3>Details</h3>

<p>gbp1d init a profit vector p, a weight vector w, and a weight constraint c,
gbp1d solver would solve
</p>
<p>maximize sum_j=1^n p_j x_j
</p>
<p>subject to sum_j=1^n w_j x_j leq c
x_j in 0, 1, j = 1, ...., n
</p>
<p>and instantiate a gbp1d object with a selectin vector x and an objective z.
</p>
<p>gbp1d is implemented as rcpp class, an instantiate can be solved by calling
gbp1d_solver_dpp(p, w, c) and gbp1d_solver_min(p, w, c)
</p>


<h3>See Also</h3>

<p>Other gbp1d: <code><a href="#topic+gbp1d_solver_dpp">gbp1d_solver_dpp</a></code>
</p>

<hr>
<h2 id='gbp1d_solver_dpp'>gbp1d_solver_dpp</h2><span id='topic+gbp1d_solver_dpp'></span>

<h3>Description</h3>

<p>solve gbp1d via dynamic programming simple - adagio::knapsnak()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp1d_solver_dpp(p, w, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp1d_solver_dpp_+3A_p">p</code></td>
<td>
<p>p profit &lt;vector&gt;::&lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp1d_solver_dpp_+3A_w">w</code></td>
<td>
<p>w weight &lt;vector&gt;::&lt;integer&gt;</p>
</td></tr>
<tr><td><code id="gbp1d_solver_dpp_+3A_c">c</code></td>
<td>
<p>c constraint on weight &lt;integer&gt;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a dynamic programming solver on gbp1d instantiate - knapsack 0-1 problem, see gbp1d.
</p>
<p>gbp1d init a profit vector p, a weight vector w, and a weight constraint c,
gbp1d solver would solve
</p>
<p>maximize sum_j=1^n p_j x_j
</p>
<p>subject to sum_j=1^n w_j x_j leq c
x_j in 0, 1, j = 1, ...., n
</p>
<p>and instantiate a gbp1d object with a selectin vector x and an objective z.
</p>
<p>gbp1d is implemented as rcpp class, an instantiate can be solved by calling
gbp1d_solver_dpp(p, w, c) and gbp1d_solver_min(p, w, c)
</p>


<h3>Value</h3>

<p>gbp1d
a gbp1d instantiate with p profit, w weight, c constraint on weight,
k selection, o objective, and ok an indicator of all fit or not.
</p>


<h3>See Also</h3>

<p>Other gbp1d: <code><a href="#topic+gbp1d">gbp1d</a></code>
</p>

<hr>
<h2 id='gbp2d'>gbp2d</h2><span id='topic+Rcpp_gbp2d'></span><span id='topic+Rcpp_gbp2d-class'></span><span id='topic+gbp2d'></span>

<h3>Description</h3>

<p>generalized bin packing problem in 2 dimension, a.k.a rectangle fill.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp2d
</code></pre>


<h3>Format</h3>

<p>An object of class <code>C++Class</code> of length 1.</p>


<h3>Details</h3>

<p>gbp2d init a profit vector p, a length vector l, a depth vector d,
a length constraint ml, and a depth constraint md on l x d rectangle
with geometry intepretation.
</p>
<p>gbp2d solver would solve
</p>
<p>maximize   sum_j=1^n p_j k_j
</p>
<p>subject to fit (l_j, d_j) at coordinate (x_j, y_j)
such that no overlap in ml x md, j = 1, ...., n
</p>
<p>and instantiate a gbp2d object with a x-axis coordinate vector x, a y-axis coordinate vector y,
a selection vector k, and an objective o.
</p>
<p>a gbp2d class instance has 6 fields:
</p>
<p>- p: profit of it fit into bn &lt;vector&gt;
</p>
<p>created via cluster max(l, d) and min(l, d) via gbp2d_solver_dpp_prep_create_p()
</p>
<p>- it: it position and scale &lt;matrix&gt;
</p>
<p>- x, y it position in the bin &lt;numeric&gt;
</p>
<p>- l, d it scale along x and y &lt;numeric&gt;
</p>
<p>- bn: bn scale &lt;vector&gt;
</p>
<p>- l, d bn scale along x and y &lt;numeric&gt;
</p>
<p>- k: selection indicator 0, 1 &lt;vector&gt;
</p>
<p>- o: objective achivement volumn fit in over volumn overall &lt;numeric&gt;
</p>
<p>- ok: a quick indicator of all it fit into bn? &lt;bool&gt;
</p>


<h3>Note</h3>

<p>p is a proxy of ranking on rectangle fit difficulty, often a function w.r.t max(l, d) and l x d
</p>


<h3>See Also</h3>

<p>Other gbp2d: <code><a href="#topic+gbp2d_checkr">gbp2d_checkr</a></code>,
<code><a href="#topic+gbp2d_solver_dpp">gbp2d_solver_dpp</a></code>
</p>

<hr>
<h2 id='gbp2d_checkr'>gbp2d_checkr</h2><span id='topic+gbp2d_checkr'></span>

<h3>Description</h3>

<p>auxilium of gbp2d and gbp2d_solver_dpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp2d_checkr(sn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp2d_checkr_+3A_sn">sn</code></td>
<td>
<p>&lt;gbp2d&gt;
gbp2d object from gbp2d_solver_dpp() solution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>check fit solution is valid:
no conflict between item and bin, and no conflict between each pair of item.
</p>


<h3>Value</h3>

<p>okfit? &lt;bool&gt;
</p>


<h3>See Also</h3>

<p>Other gbp2d: <code><a href="#topic+gbp2d_solver_dpp">gbp2d_solver_dpp</a></code>,
<code><a href="#topic+gbp2d">gbp2d</a></code>
</p>

<hr>
<h2 id='gbp2d_it_create_ktlist'>gbp2d_it_create_ktlist</h2><span id='topic+gbp2d_it_create_ktlist'></span>

<h3>Description</h3>

<p>create ktlist from itlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp2d_it_create_ktlist(bn, it, xp, ktinit, nlmt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp2d_it_create_ktlist_+3A_bn">bn</code></td>
<td>
<p>bn scale &lt;vector&gt;
- l, d bn scale along x and y &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp2d_it_create_ktlist_+3A_it">it</code></td>
<td>
<p>it position and scale &lt;matrix&gt;
- x, y it position in the bin &lt;numeric&gt;
- l, d it scale along x and y &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp2d_it_create_ktlist_+3A_xp">xp</code></td>
<td>
<p>xp extreme point position and residual space scale &lt;matrix&gt;
- x, y xp position in the bin &lt;numeric&gt;
- l, d xp residual space scale along x and y &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp2d_it_create_ktlist_+3A_ktinit">ktinit</code></td>
<td>
<p>kt candidate scale without position &lt;matrix&gt;
- l, d kt scale along x and y which open to orientation &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp2d_it_create_ktlist_+3A_nlmt">nlmt</code></td>
<td>
<p>nlmt: limit on ktlist n max-value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>core function in gbp2d_solver_dpp
select highest profitable it not yet fit into bn and return all possbile fit w.r.t xp and orientation
</p>


<h3>Value</h3>

<p>Ktlist2d
</p>


<h3>Note</h3>

<p>should make sure it kt can be fit in bin outside
</p>
<p>internal function use in gbp2d_solver_dpp() for creating Ktlist2d object for fit.
</p>


<h3>See Also</h3>

<p>Other gbp2d_it: <code><a href="#topic+Ktlist2d">Ktlist2d</a></code>
</p>

<hr>
<h2 id='gbp2d_solver_dpp'>gbp2d_solver_dpp</h2><span id='topic+gbp2d_solver_dpp'></span>

<h3>Description</h3>

<p>solve gbp2d via extreme point heuristic and best information score fit strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp2d_solver_dpp(p, ld, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp2d_solver_dpp_+3A_p">p</code></td>
<td>
<p>p profit of it fit into bn &lt;vector&gt;
- cluster max(l, d) and min(l, d) via gbp2d_solver_dpp_prep_create_p()</p>
</td></tr>
<tr><td><code id="gbp2d_solver_dpp_+3A_ld">ld</code></td>
<td>
<p>it position and scale &lt;matrix&gt;
- l, d it scale along x and y, subject to orientation rotation &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp2d_solver_dpp_+3A_m">m</code></td>
<td>
<p>bn scale &lt;vector&gt;
- l, d bn scale along x and y &lt;numeric&gt;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>gbp2d init a profit vector p, a length vector l, a depth vector d,
a length constraint ml, and a depth constraint md on l x d rectangle
with geometry intepretation.
</p>
<p>gbp2d solver would solve
</p>
<p>maximize   sum_j=1^n p_j k_j
</p>
<p>subject to fit (l_j, d_j) at coordinate (x_j, y_j)
such that no overlap in ml x md, j = 1, ...., n
</p>
<p>and instantiate a gbp2d object with a x-axis coordinate vector x, a y-axis coordinate vector y,
a selection vector k, and an objective o.
</p>


<h3>Value</h3>

<p>gbp2d
a gbp2d instantiate with p profit, it item (x, y, l, d) position scale matrix, bn bin (l, d) scale vector,
k selection, o objective, and ok an indicator of all fit or not.
</p>


<h3>See Also</h3>

<p>Other gbp2d: <code><a href="#topic+gbp2d_checkr">gbp2d_checkr</a></code>,
<code><a href="#topic+gbp2d">gbp2d</a></code>
</p>

<hr>
<h2 id='gbp2d_solver_dpp_filt'>gbp2d_solver_dpp_filt</h2><span id='topic+gbp2d_solver_dpp_filt'></span>

<h3>Description</h3>

<p>solve gbp2d w.r.t select most preferable often smallest bin from bn list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp2d_solver_dpp_filt(ld, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp2d_solver_dpp_filt_+3A_ld">ld</code></td>
<td>
<p>it scale &lt;matrix&gt;
- l, d it scale along x and y &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp2d_solver_dpp_filt_+3A_m">m</code></td>
<td>
<p>bn scale &lt;matrix&gt;
- l, d bn scale along x and y &lt;numeric&gt;
- l, d in row and each col is a single bn
</p>
<p>should make sure bn list are sorted via volume
so that the first col is the most prefered smallest bn, and also
the last col is the least prefered largest and often dominant bn
</p>
<p>should make sure no X in front of Y if bnX dominant bnY,
bnX dominant bnY if all(X(l, d) &gt; Y(l, d)) and should always prefer Y.
</p>
<p>should make sure bn such that l &gt;= d or vice versa.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>gbp2d_solver_dpp_filt is built on top of gbp2d_solver_dpp
aims to select the most preferable bn from a list of bn that can fit all or most it
</p>
<p>gbp2d_solver_dpp()'s objective is fit all or most it into a single given bn (l, d)
</p>
<p>gbp2d_solver_dpp_filt()'s objective is select the most preferable given a list of bn
where bn list is specified in 2xN matrix that the earlier column the more preferable
</p>
<p>gbp2d_solver_dpp_filt() use an approx binary search and determine f w.r.t bn.n_cols
where f = 1 indicate the bn being selected and only one of 1 in result returned.
</p>
<p>ok = true if any bin can fit all it and algorithm will select smallest bn can fit all
otherwise ok = false and algorithm will select a bn can maximize volume of fitted it
</p>
<p>often recommend to make the last and least preferable bn dominate all other bn in list
when design bn list, bnX dominant bnY if all(X(l, d) &gt; Y(l, d)).
</p>


<h3>Value</h3>

<p>gbp2q
a gbp2q instantiate with p profit, it item (x, y, l, d) position scale matrix, bn bin (l, d) scale matrix,
k it selection, o objective, f bn selection, and ok an indicator of all fit or not.
</p>


<h3>See Also</h3>

<p>Other gbp2q: <code><a href="#topic+gbp2q_checkr">gbp2q_checkr</a></code>,
<code><a href="#topic+gbp2q">gbp2q</a></code>
</p>

<hr>
<h2 id='gbp2d_solver_dpp_prep_create_p'>gbp2d_solver_dpp_prep_create_p</h2><span id='topic+gbp2d_solver_dpp_prep_create_p'></span>

<h3>Description</h3>

<p>auxilium of gbp2d_solver_dpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp2d_solver_dpp_prep_create_p(ld, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp2d_solver_dpp_prep_create_p_+3A_ld">ld</code></td>
<td>
<p>2xN matrix of l, d of it</p>
</td></tr>
<tr><td><code id="gbp2d_solver_dpp_prep_create_p_+3A_m">m</code></td>
<td>
<p>2x1 vector of l, d of bn</p>
</td></tr>
</table>


<h3>Details</h3>

<p>create p via ld and m via cluster max(l, d) and min(l, d) strategy
</p>


<h3>Value</h3>

<p>p
</p>

<hr>
<h2 id='gbp2d_viewer'>gbp2d_viewer</h2><span id='topic+gbp2d_viewer'></span>

<h3>Description</h3>

<p>gbp2d solution viewer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp2d_viewer(sn, title = NULL, subtitle = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp2d_viewer_+3A_sn">sn</code></td>
<td>
<p>sn gbp2d object, solution from gbp2d_solver_dpp, see gbp2d.</p>
</td></tr>
<tr><td><code id="gbp2d_viewer_+3A_title">title</code></td>
<td>
<p>title &lt;character&gt;</p>
</td></tr>
<tr><td><code id="gbp2d_viewer_+3A_subtitle">subtitle</code></td>
<td>
<p>subtitle &lt;character&gt;</p>
</td></tr>
</table>

<hr>
<h2 id='gbp2q'>gbp2q</h2><span id='topic+Rcpp_gbp2q'></span><span id='topic+Rcpp_gbp2q-class'></span><span id='topic+gbp2q'></span>

<h3>Description</h3>

<p>generalized bin packing problem in 2 dimension, a.k.a rectangle fill.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp2q
</code></pre>


<h3>Format</h3>

<p>An object of class <code>C++Class</code> of length 1.</p>


<h3>Details</h3>

<p>gbp2d init a profit vector p, a length vector l, a depth vector d,
a length constraint ml, and a depth constraint md on l x d rectangle
with geometry intepretation.
</p>
<p>gbp2d solver would solve
</p>
<p>maximize   sum_j=1^n p_j k_j
</p>
<p>subject to fit (l_j, d_j) at coordinate (x_j, y_j)
such that no overlap in ml x md, j = 1, ...., n
</p>
<p>and instantiate a gbp2d object with a x-axis coordinate vector x, a y-axis coordinate vector y,
a selection vector k, and an objective o.
</p>
<p>gbp2q solver would also select the most preferred often smallest m from a list of m(l, d) after
determine all or the higest volume set of ld can fit into one m(l, d).
</p>
<p>a gbp2q class instance has 7 fields:
</p>
<p>- p: profit of it fit into bn &lt;vector&gt;
</p>
<p>created via cluster max(l, d) and min(l, d) via gbp2d_solver_dpp_prep_create_p()
</p>
<p>- it: it position and scale &lt;matrix&gt;
</p>
<p>- x, y it position in the bin &lt;numeric&gt;
</p>
<p>- l, d it scale along x and y &lt;numeric&gt;
</p>
<p>- bn: bn scale &lt;matrix&gt;
</p>
<p>- l, d bn scale along x and y &lt;numeric&gt;
</p>
<p>matrix of 2 rows and each column is a single bn
</p>
<p>should make sure bn list are sorted via volume
so that the first col is the most prefered smallest bn, and also
the last col is the least prefered largest and often dominant bn
</p>
<p>should make sure no X in front of Y if bnX dominant bnY,
bnX dominant bnY if all(X(l, d) &gt; Y(l, d)) and should always prefer Y.
</p>
<p>should make sure bn such that l &gt;= d or vice versa.
</p>
<p>- k: selection indicator 0, 1 on it &lt;vector&gt;
</p>
<p>- f: selection indicator 0, 1, 2, 3 on bn &lt;vector&gt;
</p>
<p>f in result should have no 0 and only one of 1
</p>
<p>- o: objective achivement volumn fit in over volumn overall &lt;numeric&gt;
</p>
<p>- ok: a quick indicator of all it fit into bn? &lt;bool&gt;
</p>


<h3>See Also</h3>

<p>Other gbp2q: <code><a href="#topic+gbp2d_solver_dpp_filt">gbp2d_solver_dpp_filt</a></code>,
<code><a href="#topic+gbp2q_checkr">gbp2q_checkr</a></code>
</p>

<hr>
<h2 id='gbp2q_checkr'>gbp2q_checkr</h2><span id='topic+gbp2q_checkr'></span>

<h3>Description</h3>

<p>auxilium of gbp2q and gbp2d_solver_dpp_filt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp2q_checkr(sn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp2q_checkr_+3A_sn">sn</code></td>
<td>
<p>&lt;gbp2q&gt;
gbp2q object from gbp2d_solver_dpp_filt() solution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>check fit solution is valid:
no conflict between item and bin, and no conflict between each pair of item.
</p>


<h3>Value</h3>

<p>okfit? &lt;bool&gt;
</p>


<h3>See Also</h3>

<p>Other gbp2q: <code><a href="#topic+gbp2d_solver_dpp_filt">gbp2d_solver_dpp_filt</a></code>,
<code><a href="#topic+gbp2q">gbp2q</a></code>
</p>

<hr>
<h2 id='gbp2q_viewer'>gbp2q_viewer</h2><span id='topic+gbp2q_viewer'></span>

<h3>Description</h3>

<p>gbp2q solution viewer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp2q_viewer(sn, title = NULL, subtitle = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp2q_viewer_+3A_sn">sn</code></td>
<td>
<p>sn gbp2q object, solution from gbp2d_solver_dpp_filt, see gbp2q.</p>
</td></tr>
<tr><td><code id="gbp2q_viewer_+3A_title">title</code></td>
<td>
<p>title &lt;character&gt;</p>
</td></tr>
<tr><td><code id="gbp2q_viewer_+3A_subtitle">subtitle</code></td>
<td>
<p>subtitle &lt;character&gt;</p>
</td></tr>
</table>

<hr>
<h2 id='gbp3d'>gbp3d</h2><span id='topic+Rcpp_gbp3d'></span><span id='topic+Rcpp_gbp3d-class'></span><span id='topic+gbp3d'></span>

<h3>Description</h3>

<p>generalized bin packing problem in 3 dimension, a.k.a bin packing problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp3d
</code></pre>


<h3>Format</h3>

<p>An object of class <code>C++Class</code> of length 1.</p>


<h3>Details</h3>

<p>gbp3d init a profit vector p, a length vector l, a depth vector d, a height vector h, and also
a length constraint ml, a depth constraint md, and a height constraint mh on l x d x h cuboid
with geometry intepretation.
</p>
<p>gbp3d solver would solve
</p>
<p>maximize   sum_j=1^n p_j k_j
</p>
<p>subject to fit (l_j, d_j, h_j) at coordinate (x_j, y_j, z_j)
such that no overlap in ml x md x mh cuboid, j = 1, ......, n
</p>
<p>and instantiate a gbp3d object with a x-axis coordinate vector x, a y-axis coordinate vector y,
a z-axis coordinate vector z, a selection vector k, and an objective o.
</p>
<p>a gbp3d class instance has 6 fields:
</p>
<p>- p: profit of it fit into bn &lt;vector&gt;
</p>
<p>created via cluster max(l, d, h) and area via gbp3d_solver_dpp_main_create_p()
</p>
<p>- it: it position and scale &lt;matrix&gt;
</p>
<p>- x, y, z it position in the bin &lt;numeric&gt;
</p>
<p>- l, d, h it scale along x, y, z &lt;numeric&gt;
</p>
<p>- bn: bn scale &lt;vector&gt;
</p>
<p>- l, d, h bn scale along x, y, z &lt;numeric&gt;
</p>
<p>- k: selection indicator 0, 1 &lt;vector&gt;
</p>
<p>- o: objective achivement volumn fit in over volumn overall &lt;numeric&gt;
</p>
<p>- ok: a quick indicator of all it fit into bn? &lt;bool&gt;
</p>


<h3>Note</h3>

<p>p is a proxy of ranking on cuboid fit difficulty, often a func of max(l, d, h), surface, volume
and solver would often maximize sum_j=1^n v_j k_j instead of sum_j=1^n p_j k_j
</p>


<h3>See Also</h3>

<p>Other gbp3d: <code><a href="#topic+gbp3d_checkr">gbp3d_checkr</a></code>,
<code><a href="#topic+gbp3d_solver_dpp">gbp3d_solver_dpp</a></code>
</p>

<hr>
<h2 id='gbp3d_checkr'>gbp3d_checkr</h2><span id='topic+gbp3d_checkr'></span>

<h3>Description</h3>

<p>auxilium of gbp3d_solver_dpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp3d_checkr(sn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp3d_checkr_+3A_sn">sn</code></td>
<td>
<p>&lt;gbp3d&gt;
gbp3d object from gbp3d_solver_dpp() solution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>check fit solution is valid:
no conflict between item and bin, and no conflict between each pair of item.
</p>


<h3>Value</h3>

<p>okfit? &lt;bool&gt;
</p>


<h3>See Also</h3>

<p>Other gbp3d: <code><a href="#topic+gbp3d_solver_dpp">gbp3d_solver_dpp</a></code>,
<code><a href="#topic+gbp3d">gbp3d</a></code>
</p>

<hr>
<h2 id='gbp3d_it_create_ktlist'>gbp3d_it_create_ktlist</h2><span id='topic+gbp3d_it_create_ktlist'></span>

<h3>Description</h3>

<p>create ktlist from itlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp3d_it_create_ktlist(bn, it, xp, ktinit, nlmt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp3d_it_create_ktlist_+3A_bn">bn</code></td>
<td>
<p>bn scale &lt;vector&gt;
- l, d, h bn scale along x, y, z &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp3d_it_create_ktlist_+3A_it">it</code></td>
<td>
<p>it position and scale &lt;matrix&gt;
- x, y, z it position in the bin &lt;numeric&gt;
- l, d, h it scale along x, y, z &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp3d_it_create_ktlist_+3A_xp">xp</code></td>
<td>
<p>xp extreme point position and residual space scale &lt;matrix&gt;
- x, y, z xp position in the bin &lt;numeric&gt;
- l, d, h xp residual space scale along x, y, z &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp3d_it_create_ktlist_+3A_ktinit">ktinit</code></td>
<td>
<p>kt candidate scale without position &lt;matrix&gt;
- l, d, h kt scale along x, y, z which open to orientation &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp3d_it_create_ktlist_+3A_nlmt">nlmt</code></td>
<td>
<p>nlmt: limit on ktlist n max-value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>core function in gbp3d_solver_dpp
select highest profitable it not yet fit into bn and return all possbile fit w.r.t xp and orientation
</p>


<h3>Value</h3>

<p>Ktlist3d
</p>


<h3>Note</h3>

<p>should make sure it kt can be fit in bin outside
</p>
<p>internal function use in gbp3d_solver_dpp() for creating Ktlist3d object for fit.
</p>


<h3>See Also</h3>

<p>Other gbp3d_it: <code><a href="#topic+Ktlist3d">Ktlist3d</a></code>
</p>

<hr>
<h2 id='gbp3d_solver_dpp'>gbp3d_solver_dpp</h2><span id='topic+gbp3d_solver_dpp'></span>

<h3>Description</h3>

<p>solve gbp3d via extreme point heuristic and best information score fit strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp3d_solver_dpp(p, ldh, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp3d_solver_dpp_+3A_p">p</code></td>
<td>
<p>p profit of it fit into bn &lt;vector&gt;
- cluster max(l, d) and min(l, d) via gbp3d_solver_dpp_prep_create_p()</p>
</td></tr>
<tr><td><code id="gbp3d_solver_dpp_+3A_ldh">ldh</code></td>
<td>
<p>it position and scale &lt;matrix&gt;
- l, d, h it scale along x, y, z, subject to orientation rotation &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp3d_solver_dpp_+3A_m">m</code></td>
<td>
<p>bn scale &lt;vector&gt;
- l, d, h bn scale along x, y, z &lt;numeric&gt;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>gbp3d init a profit vector p, a length vector l, a depth vector d, a height vector h, and also
a length constraint ml, a depth constraint md, and a height constraint mh on l x d x h cuboid
with geometry intepretation.
</p>
<p>gbp3d solver would solve
</p>
<p>maximize   sum_j=1^n p_j k_j
</p>
<p>subject to fit (l_j, d_j, h_j) at coordinate (x_j, y_j, z_j)
such that no overlap in ml x md x mh cuboid, j = 1, ......, n
</p>
<p>and instantiate a gbp3d object with a x-axis coordinate vector x, a y-axis coordinate vector y,
a z-axis coordinate vector z, a selection vector k, and an objective o.
</p>


<h3>Value</h3>

<p>gbp3d
a gbp3d instantiate with p profit, it item (x, y, z, l, d, h) position scale matrix, bn bin (l, d, h) scale vector,
k selection, o objective, and ok an indicator of all fit or not.
</p>


<h3>See Also</h3>

<p>Other gbp3d: <code><a href="#topic+gbp3d_checkr">gbp3d_checkr</a></code>,
<code><a href="#topic+gbp3d">gbp3d</a></code>
</p>

<hr>
<h2 id='gbp3d_solver_dpp_filt'>gbp3d_solver_dpp_filt</h2><span id='topic+gbp3d_solver_dpp_filt'></span>

<h3>Description</h3>

<p>solve gbp3d w.r.t select most preferable often smallest bin from bn list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp3d_solver_dpp_filt(ldh, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp3d_solver_dpp_filt_+3A_ldh">ldh</code></td>
<td>
<p>it scale &lt;matrix&gt;
- l, d, h it scale along x, y, z &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp3d_solver_dpp_filt_+3A_m">m</code></td>
<td>
<p>bn scale &lt;matrix&gt;
- l, d, h bn scale along x, y, z &lt;numeric&gt;
- l, d, h in row and each col is a single bn
</p>
<p>should make sure bn list are sorted via volume
so that the first col is the most prefered smallest bn, and also
the last col is the least prefered largest and often dominant bn
</p>
<p>should make sure no X in front of Y if bnX dominant bnY,
bnX dominant bnY if all(X(l, d, h) &gt; Y(l, d, h)) and should always prefer Y.
</p>
<p>should make sure bn such that l &gt;= d &gt;= h or vice versa.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>gbp3d_solver_dpp_filt is built on top of gbp3d_solver_dpp
aims to select the most preferable bn from a list of bn that can fit all or most it
</p>
<p>gbp3d_solver_dpp()'s objective is fit all or most it into a single given bn (l, d, h)
</p>
<p>gbp3d_solver_dpp_filt()'s objective is select the most preferable given a list of bn
where bn list is specified in 3xN matrix that the earlier column the more preferable
</p>
<p>gbp3d_solver_dpp_filt() use an approx binary search and determine f w.r.t bn.n_cols
where f = 1 indicate the bn being selected and only one of 1 in result returned.
</p>
<p>ok = true if any bin can fit all it and algorithm will select smallest bn can fit all
otherwise ok = false and algorithm will select a bn can maximize volume of fitted it
</p>
<p>often recommend to make the last and least preferable bn dominate all other bn in list
when design bn list, bnX dominant bnY if all(X(l, d, h) &gt; Y(l, d, h)).
</p>


<h3>Value</h3>

<p>gbp3q
a gbp3q instantiate with p profit, it item (x, y, z, l, d, h) position scale matrix, bn bin (l, d, h) scale matrix,
k it selection, o objective, f bn selection, and ok an indicator of all fit or not.
</p>


<h3>See Also</h3>

<p>Other gbp3q: <code><a href="#topic+gbp3q_checkr">gbp3q_checkr</a></code>,
<code><a href="#topic+gbp3q">gbp3q</a></code>
</p>

<hr>
<h2 id='gbp3d_solver_dpp_prep_create_p'>gbp3d_solver_dpp_prep_create_p</h2><span id='topic+gbp3d_solver_dpp_prep_create_p'></span>

<h3>Description</h3>

<p>auxilium of gbp3d_solver_dpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp3d_solver_dpp_prep_create_p(ldh, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp3d_solver_dpp_prep_create_p_+3A_ldh">ldh</code></td>
<td>
<p>3xN matrix of l, d, h of it</p>
</td></tr>
<tr><td><code id="gbp3d_solver_dpp_prep_create_p_+3A_m">m</code></td>
<td>
<p>3x1 vector of l, d, h of bn</p>
</td></tr>
</table>


<h3>Details</h3>

<p>create p via ldh and m via cluster max(l, d, h) and area strategy
</p>


<h3>Value</h3>

<p>p
</p>

<hr>
<h2 id='gbp3d_viewer'>gbp3d_viewer</h2><span id='topic+gbp3d_viewer'></span>

<h3>Description</h3>

<p>gbp3d solution viewer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp3d_viewer(sn, title = NULL, subtitle = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp3d_viewer_+3A_sn">sn</code></td>
<td>
<p>sn gbp3d object, solution from gbp3d_solver_dpp, see gbp3d.</p>
</td></tr>
<tr><td><code id="gbp3d_viewer_+3A_title">title</code></td>
<td>
<p>title &lt;character&gt;</p>
</td></tr>
<tr><td><code id="gbp3d_viewer_+3A_subtitle">subtitle</code></td>
<td>
<p>subtitle &lt;character&gt;</p>
</td></tr>
</table>

<hr>
<h2 id='gbp3q'>gbp3q</h2><span id='topic+Rcpp_gbp3q'></span><span id='topic+Rcpp_gbp3q-class'></span><span id='topic+gbp3q'></span>

<h3>Description</h3>

<p>generalized bin packing problem in 3 dimension, a.k.a bin packing problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp3q
</code></pre>


<h3>Format</h3>

<p>An object of class <code>C++Class</code> of length 1.</p>


<h3>Details</h3>

<p>gbp3d init a profit vector p, a length vector l, a depth vector d, a height vector h, and also
a length constraint ml, a depth constraint md, and a height constraint mh on l x d x h cuboid
with geometry intepretation.
</p>
<p>gbp3d solver would solve
</p>
<p>maximize   sum_j=1^n p_j k_j
</p>
<p>subject to fit (l_j, d_j, h_j) at coordinate (x_j, y_j, z_j)
such that no overlap in ml x md x mh cuboid, j = 1, ......, n
</p>
<p>and instantiate a gbp3d object with a x-axis coordinate vector x, a y-axis coordinate vector y,
a z-axis coordinate vector z, a selection vector k, and an objective o.
</p>
<p>gbp3q solver would also select the most preferred often smallest m from a list of m(l, d, h) after
determine all or the higest volume set of ld can fit into one m(l, d, h).
</p>
<p>a gbp3q class instance has 7 fields:
</p>
<p>- p: profit of it fit into bn &lt;vector&gt;
</p>
<p>created via cluster max(l, d, h) and area via gbp3d_solver_dpp_main_create_p()
</p>
<p>- it: it position and scale &lt;matrix&gt;
</p>
<p>- x, y, z it position in the bin &lt;numeric&gt;
</p>
<p>- l, d, h it scale along x, y, z &lt;numeric&gt;
</p>
<p>- bn: bn scale &lt;matrix&gt;
</p>
<p>- l, d, h bn scale along x, y, z &lt;numeric&gt;
</p>
<p>matrix of 3 rows and each column is a single bn
</p>
<p>should make sure bn list are sorted via volume
so that the first col is the most prefered smallest bn, and also
the last col is the least prefered largest and often dominant bn
</p>
<p>should make sure no X in front of Y if bnX dominant bnY,
bnX dominant bnY if all(X(l, d, h) &gt; Y(l, d, h)) and should always prefer Y.
</p>
<p>should make sure bn such that l &gt;= d or vice versa.
</p>
<p>- k: selection indicator 0, 1 on it &lt;vector&gt;
</p>
<p>- f: selection indicator 0, 1, 2, 3 on bn &lt;vector&gt;
</p>
<p>f in result should have no 0 and only one of 1
</p>
<p>- o: objective achivement volumn fit in over volumn overall &lt;numeric&gt;
</p>
<p>- ok: a quick indicator of all it fit into bn? &lt;bool&gt;
</p>


<h3>See Also</h3>

<p>Other gbp3q: <code><a href="#topic+gbp3d_solver_dpp_filt">gbp3d_solver_dpp_filt</a></code>,
<code><a href="#topic+gbp3q_checkr">gbp3q_checkr</a></code>
</p>

<hr>
<h2 id='gbp3q_checkr'>gbp3q_checkr</h2><span id='topic+gbp3q_checkr'></span>

<h3>Description</h3>

<p>auxilium of gbp3d_solver_dpp_filt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp3q_checkr(sn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp3q_checkr_+3A_sn">sn</code></td>
<td>
<p>&lt;gbp3q&gt;
gbp3q object from gbp3d_solver_dpp_filt() solution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>check fit solution is valid:
no conflict between item and bin, and no conflict between each pair of item.
</p>


<h3>Value</h3>

<p>okfit? &lt;bool&gt;
</p>


<h3>See Also</h3>

<p>Other gbp3q: <code><a href="#topic+gbp3d_solver_dpp_filt">gbp3d_solver_dpp_filt</a></code>,
<code><a href="#topic+gbp3q">gbp3q</a></code>
</p>

<hr>
<h2 id='gbp3q_viewer'>gbp3q_viewer</h2><span id='topic+gbp3q_viewer'></span>

<h3>Description</h3>

<p>gbp3q solution viewer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp3q_viewer(sn, title = NULL, subtitle = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp3q_viewer_+3A_sn">sn</code></td>
<td>
<p>sn gbp3q object, solution from gbp3d_solver_dpp_filt, see gbp3q.</p>
</td></tr>
<tr><td><code id="gbp3q_viewer_+3A_title">title</code></td>
<td>
<p>title &lt;character&gt;</p>
</td></tr>
<tr><td><code id="gbp3q_viewer_+3A_subtitle">subtitle</code></td>
<td>
<p>subtitle &lt;character&gt;</p>
</td></tr>
</table>

<hr>
<h2 id='gbp4d'>gbp4d</h2><span id='topic+Rcpp_gbp4d'></span><span id='topic+Rcpp_gbp4d-class'></span><span id='topic+gbp4d'></span>

<h3>Description</h3>

<p>generalized bin packing problem in 4 dimension, a.k.a bin packing problem with weight limit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp4d
</code></pre>


<h3>Format</h3>

<p>An object of class <code>C++Class</code> of length 1.</p>


<h3>Details</h3>

<p>gbp4d init a profit vector p, a length l, a depth d, a height h, and a weight w, along with
associate constraints ml, md, mh and mw.
gbp4d should fit it (l, d, h, w) into bn (ml, md, mh, mw) with w on weight limit constraint
and l, d, h on geometry intepretation.
gbp4d solver would solve
</p>
<p>maximize   sum_j=1^n p_j k_j
</p>
<p>subject to sum_j=1^n w_j k_j leq mw and
</p>
<p>fit (l_j, d_j, h_j) at coordinate (x_j, y_j, z_j)
such that no overlap in ml x md x mh cuboid, j = 1, ......, n
</p>
<p>and instantiate a gbp4d object with a x-axis coordinate vector x, a y-axis coordinate vector y,
a z-axis coordinate vector z, a selection vector k, and an objective o.
</p>
<p>a gbp4d class instance has 6 fields:
</p>
<p>- p: profit of it fit into bn &lt;vector&gt;
</p>
<p>created via cluster w via gbp1d, cluster max(l, d, h) and area via gbp4d_solver_dpp_main_create_p()
</p>
<p>- it: it position and scale &lt;matrix&gt;
</p>
<p>- x, y, z, w it position and w in the bin &lt;numeric&gt; (w hold in bn when fit it in bn)
</p>
<p>- l, d, h, w it scale along x, y, z and w &lt;numeric&gt; (w of it itself)
</p>
<p>- bn: bn scale &lt;vector&gt;
</p>
<p>- l, d, h, w bn scale along x, y, z and w &lt;numeric&gt;
</p>
<p>- k: selection indicator 0, 1 &lt;vector&gt;
</p>
<p>- o: objective achivement volumn fit in over volumn overall &lt;numeric&gt;
</p>
<p>- ok: a quick indicator of all it fit into bn? &lt;bool&gt;
</p>


<h3>Note</h3>

<p>p is a proxy of ranking on cuboid fit difficulty, often a func of max(l, d, h), surface, volume
and solver would often maximize sum_j=1^n v_j k_j instead of sum_j=1^n p_j k_j
</p>


<h3>See Also</h3>

<p>Other gbp4d: <code><a href="#topic+gbp4d_checkr">gbp4d_checkr</a></code>,
<code><a href="#topic+gbp4d_solver_dpp">gbp4d_solver_dpp</a></code>
</p>

<hr>
<h2 id='gbp4d_checkr'>gbp4d_checkr</h2><span id='topic+gbp4d_checkr'></span>

<h3>Description</h3>

<p>auxilium of gbp4d_solver_dpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp4d_checkr(sn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp4d_checkr_+3A_sn">sn</code></td>
<td>
<p>&lt;gbp4d&gt;
gbp4d object from gbp4d_solver_dpp() solution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>check fit solution is valid:
no conflict between item and bin, and no conflict between each pair of item, and no conflict on weight limit.
</p>


<h3>Value</h3>

<p>okfit? &lt;bool&gt;
</p>


<h3>See Also</h3>

<p>Other gbp4d: <code><a href="#topic+gbp4d_solver_dpp">gbp4d_solver_dpp</a></code>,
<code><a href="#topic+gbp4d">gbp4d</a></code>
</p>

<hr>
<h2 id='gbp4d_it_create_ktlist'>gbp4d_it_create_ktlist</h2><span id='topic+gbp4d_it_create_ktlist'></span>

<h3>Description</h3>

<p>create ktlist from itlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp4d_it_create_ktlist(bn, it, xp, ktinit, nlmt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp4d_it_create_ktlist_+3A_bn">bn</code></td>
<td>
<p>bn scale &lt;vector&gt;
- l, d, h, w bn scale along x, y, z and w &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp4d_it_create_ktlist_+3A_it">it</code></td>
<td>
<p>it position and scale &lt;matrix&gt;
- x, y, z, w it position and w in the bin &lt;numeric&gt;
- l, d, h, w it scale along x, y, z and w &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp4d_it_create_ktlist_+3A_xp">xp</code></td>
<td>
<p>xp extreme point position and residual space scale &lt;matrix&gt;
- x, y, z, w xp position and w in the bin &lt;numeric&gt;
- l, d, h, w xp residual space scale along x, y, z and w &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp4d_it_create_ktlist_+3A_ktinit">ktinit</code></td>
<td>
<p>kt candidate scale without position &lt;matrix&gt;
- l, d, h, w kt scale along x, y, z, w which open to orientation &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp4d_it_create_ktlist_+3A_nlmt">nlmt</code></td>
<td>
<p>nlmt: limit on ktlist n max-value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>core function in gbp4d_solver_dpp
select highest profitable it not yet fit into bn and return all possbile fit w.r.t xp and orientation
</p>


<h3>Value</h3>

<p>Ktlist4d
</p>


<h3>Note</h3>

<p>should make sure it kt can be fit in bin outside
</p>
<p>internal function use in gbp4d_solver_dpp() for creating Ktlist4d object for fit.
</p>


<h3>See Also</h3>

<p>Other gbp4d_it: <code><a href="#topic+Ktlist4d">Ktlist4d</a></code>
</p>

<hr>
<h2 id='gbp4d_solver_dpp'>gbp4d_solver_dpp</h2><span id='topic+gbp4d_solver_dpp'></span>

<h3>Description</h3>

<p>solve gbp4d via extreme point heuristic and best information score fit strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp4d_solver_dpp(p, ldhw, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp4d_solver_dpp_+3A_p">p</code></td>
<td>
<p>p profit of it fit into bn &lt;vector&gt;
- cluster w via gbp1d, cluster max(l,d,h) and area via gbp4d_solver_dpp_main_create_p()</p>
</td></tr>
<tr><td><code id="gbp4d_solver_dpp_+3A_ldhw">ldhw</code></td>
<td>
<p>it scales &lt;matrix&gt;
- l, d, h, w it scale along x, y, z and w (weight on separate single dimension) &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp4d_solver_dpp_+3A_m">m</code></td>
<td>
<p>bn scales &lt;vector&gt;
- l, d, h, w bn scale along x, y, z and w (weight on separate single dimension) &lt;numeric&gt;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>gbp4d init a profit vector p, a length l, a depth d, a height h, and a weight w, along with
associate constraints ml, md, mh and mw.
gbp4d should fit it (l, d, h, w) into bn (ml, md, mh, mw) with w on weight limit constraint
and l, d, h on geometry intepretation.
gbp4d solver would solve
</p>
<p>maximize   sum_j=1^n p_j k_j
</p>
<p>subject to sum_j=1^n w_j k_j leq mw and
</p>
<p>fit (l_j, d_j, h_j) at coordinate (x_j, y_j, z_j)
such that no overlap in ml x md x mh cuboid, j = 1, ......, n
</p>
<p>and instantiate a gbp4d object with a x-axis coordinate vector x, a y-axis coordinate vector y,
a z-axis coordinate vector z, a selection vector k, and an objective o.
</p>


<h3>Value</h3>

<p>gbp4d
a gbp4d instantiate with p profit, it item (x, y, z, w, l, d, h, w) position scale matrix, bn bin (l, d, h, w) scale vector,
k selection, o objective, and ok an indicator of all fit or not.
</p>


<h3>See Also</h3>

<p>Other gbp4d: <code><a href="#topic+gbp4d_checkr">gbp4d_checkr</a></code>,
<code><a href="#topic+gbp4d">gbp4d</a></code>
</p>

<hr>
<h2 id='gbp4d_solver_dpp_filt'>gbp4d_solver_dpp_filt</h2><span id='topic+gbp4d_solver_dpp_filt'></span>

<h3>Description</h3>

<p>solve gbp4d w.r.t select most preferable often smallest bin from bn list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp4d_solver_dpp_filt(ldhw, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp4d_solver_dpp_filt_+3A_ldhw">ldhw</code></td>
<td>
<p>it scale &lt;matrix&gt;
- l, d, h, w it scale along x, y, z and w &lt;numeric&gt;</p>
</td></tr>
<tr><td><code id="gbp4d_solver_dpp_filt_+3A_m">m</code></td>
<td>
<p>bn scale &lt;matrix&gt;
- l, d, h, w bn scale along x, y, z and w &lt;numeric&gt;
- l, d, h, w in row and each col is a single bn
</p>
<p>should make sure bn list are sorted via volume
so that the first col is the most prefered smallest bn, and also
the last col is the least prefered largest and often dominant bn
</p>
<p>should make sure no X in front of Y if bnX dominant bnY,
bnX dominant bnY if all(X(l, d, h) &gt; Y(l, d, h)) and should always prefer Y.
</p>
<p>should make sure bn such that l &gt;= d &gt;= h or vice versa.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>gbp4d_solver_dpp_filt is built on top of gbp4d_solver_dpp
aims to select the most preferable bn from a list of bn that can fit all or most it
</p>
<p>gbp4d_solver_dpp()'s objective is fit all or most it into a single given bn (l, d, h, w)
</p>
<p>gbp4d_solver_dpp_filt()'s objective is select the most preferable given a list of bn
where bn list is specified in 4xN matrix that the earlier column the more preferable
</p>
<p>gbp4d_solver_dpp_filt() use an approx binary search and determine f w.r.t bn.n_cols
where f = 1 indicate the bn being selected and only one of 1 in result returned.
</p>
<p>ok = true if any bin can fit all it and algorithm will select smallest bn can fit all
otherwise ok = false and algorithm will select a bn can maximize volume of fitted it
</p>
<p>often recommend to make the last and least preferable bn dominate all other bn in list
when design bn list, bnX dominant bnY if all(X(l, d, h) &gt; Y(l, d, h)).
</p>


<h3>Value</h3>

<p>gbp4q
a gbp4q instantiate with p profit, it item (x, y, z, w, l, d, h, w) position scale matrix, bn bin (l, d, h, w) scale matrix,
k it selection, o objective, f bn selection, and ok an indicator of all fit or not.
</p>


<h3>See Also</h3>

<p>Other gbp4q: <code><a href="#topic+gbp4q_checkr">gbp4q_checkr</a></code>,
<code><a href="#topic+gbp4q">gbp4q</a></code>
</p>

<hr>
<h2 id='gbp4d_solver_dpp_prep_create_p'>gbp4d_solver_dpp_prep_create_p</h2><span id='topic+gbp4d_solver_dpp_prep_create_p'></span>

<h3>Description</h3>

<p>auxilium of gbp4d_solver_dpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp4d_solver_dpp_prep_create_p(ldhw, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp4d_solver_dpp_prep_create_p_+3A_ldhw">ldhw</code></td>
<td>
<p>4xN matrix of l, d, h, w of it</p>
</td></tr>
<tr><td><code id="gbp4d_solver_dpp_prep_create_p_+3A_m">m</code></td>
<td>
<p>4x1 vector of l, d, h, w of bn</p>
</td></tr>
</table>


<h3>Details</h3>

<p>create p via ldhw and m via cluster w, cluster max(l, d, h) and area strategy
</p>


<h3>Value</h3>

<p>p
</p>

<hr>
<h2 id='gbp4d_viewer'>gbp4d_viewer</h2><span id='topic+gbp4d_viewer'></span>

<h3>Description</h3>

<p>gbp4d solution viewer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp4d_viewer(sn, title = NULL, subtitle = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp4d_viewer_+3A_sn">sn</code></td>
<td>
<p>sn gbp4d object, solution from gbp4d_solver_dpp, see gbp4d.</p>
</td></tr>
<tr><td><code id="gbp4d_viewer_+3A_title">title</code></td>
<td>
<p>title &lt;character&gt;</p>
</td></tr>
<tr><td><code id="gbp4d_viewer_+3A_subtitle">subtitle</code></td>
<td>
<p>subtitle &lt;character&gt;</p>
</td></tr>
</table>

<hr>
<h2 id='gbp4q'>gbp4q</h2><span id='topic+Rcpp_gbp4q'></span><span id='topic+Rcpp_gbp4q-class'></span><span id='topic+gbp4q'></span>

<h3>Description</h3>

<p>generalized bin packing problem in 4 dimension, a.k.a bin packing problem with weight limit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp4q
</code></pre>


<h3>Format</h3>

<p>An object of class <code>C++Class</code> of length 1.</p>


<h3>Details</h3>

<p>gbp4d init a profit vector p, a length l, a depth d, a height h, and a weight w, along with
associate constraints ml, md, mh and mw.
gbp4d should fit it (l, d, h, w) into bn (ml, md, mh, mw) with w on weight limit constraint
and l, d, h on geometry intepretation.
gbp4d solver would solve
</p>
<p>maximize   sum_j=1^n p_j k_j
</p>
<p>subject to sum_j=1^n w_j k_j leq mw and
</p>
<p>fit (l_j, d_j, h_j) at coordinate (x_j, y_j, z_j)
such that no overlap in ml x md x mh cuboid, j = 1, ......, n
</p>
<p>and instantiate a gbp4d object with a x-axis coordinate vector x, a y-axis coordinate vector y,
a z-axis coordinate vector z, a selection vector k, and an objective o.
</p>
<p>gbp4q solver would also select the most preferred often smallest m from a list of m(l, d, h) after
determine all or the higest volume set of ld can fit into one m(l, d, h) w.r.t the weight constraint.
</p>
<p>a gbp4q class instance has 7 fields:
</p>
<p>- p: profit of it fit into bn &lt;vector&gt;
</p>
<p>created via cluster w via gbp1d, cluster max(l, d, h) and area via gbp4d_solver_dpp_main_create_p()
</p>
<p>- it: it position and scale &lt;matrix&gt;
</p>
<p>- x, y, z, w it position and w in the bin &lt;numeric&gt; (w hold in bn when fit it in bn)
</p>
<p>- l, d, h, w it scale along x, y, z and w &lt;numeric&gt; (w of it itself)
</p>
<p>- bn: bn scale &lt;matrix&gt;
</p>
<p>- l, d, h, w bn scale along x, y, z and w &lt;numeric&gt;
</p>
<p>matrix of 4 rows and each column is a single bn
</p>
<p>should make sure bn list are sorted via volume
so that the first col is the most prefered smallest bn, and also
the last col is the least prefered largest and often dominant bn
</p>
<p>should make sure no X in front of Y if bnX dominant bnY,
bnX dominant bnY if all(X(l, d, h) &gt; Y(l, d, h)) and should always prefer Y.
</p>
<p>should make sure bn such that l &gt;= d or vice versa.
</p>
<p>- k: selection indicator 0, 1 on it &lt;vector&gt;
</p>
<p>- f: selection indicator 0, 1, 2, 3 on bn &lt;vector&gt;
</p>
<p>f in result should have no 0 and only one of 1
</p>
<p>- o: objective achivement volumn fit in over volumn overall &lt;numeric&gt;
</p>
<p>- ok: a quick indicator of all it fit into bn? &lt;bool&gt;
</p>


<h3>See Also</h3>

<p>Other gbp4q: <code><a href="#topic+gbp4d_solver_dpp_filt">gbp4d_solver_dpp_filt</a></code>,
<code><a href="#topic+gbp4q_checkr">gbp4q_checkr</a></code>
</p>

<hr>
<h2 id='gbp4q_checkr'>gbp4q_checkr</h2><span id='topic+gbp4q_checkr'></span>

<h3>Description</h3>

<p>auxilium of gbp4d_solver_dpp_filt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp4q_checkr(sn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp4q_checkr_+3A_sn">sn</code></td>
<td>
<p>&lt;gbp4q&gt;
gbp4q object from gbp4d_solver_dpp_filt() solution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>check fit solution is valid:
no conflict between item and bin, and no conflict between each pair of item, and no conflict on weight limit.
</p>


<h3>Value</h3>

<p>okfit? &lt;bool&gt;
</p>


<h3>See Also</h3>

<p>Other gbp4q: <code><a href="#topic+gbp4d_solver_dpp_filt">gbp4d_solver_dpp_filt</a></code>,
<code><a href="#topic+gbp4q">gbp4q</a></code>
</p>

<hr>
<h2 id='gbp4q_viewer'>gbp4q_viewer</h2><span id='topic+gbp4q_viewer'></span>

<h3>Description</h3>

<p>gbp4q solution viewer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbp4q_viewer(sn, title = NULL, subtitle = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbp4q_viewer_+3A_sn">sn</code></td>
<td>
<p>sn gbp4q object, solution from gbp4d_solver_dpp_filt, see gbp4q.</p>
</td></tr>
<tr><td><code id="gbp4q_viewer_+3A_title">title</code></td>
<td>
<p>title &lt;character&gt;</p>
</td></tr>
<tr><td><code id="gbp4q_viewer_+3A_subtitle">subtitle</code></td>
<td>
<p>subtitle &lt;character&gt;</p>
</td></tr>
</table>

<hr>
<h2 id='Ktlist2d'>Ktlist2d</h2><span id='topic+Ktlist2d'></span><span id='topic+Rcpp_Ktlist2d'></span><span id='topic+Rcpp_Ktlist2d-class'></span>

<h3>Description</h3>

<p>Ktlist2d hold multiple kt for recursive fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ktlist2d
</code></pre>


<h3>Format</h3>

<p>An object of class <code>C++Class</code> of length 1.</p>


<h3>Details</h3>

<p>Ktlist2d hold multiple kt via consider all possible fit onto different xp and different rotation and nlimit
</p>
<p>a Ktlist2d class instance has 4 fields:
</p>
<p>- n: length of kt candidate position scale vector list
</p>
<p>- kt: candidate (x, y, l, d) fit of it current investigating
</p>
<p>- xp: candidate extreme point list after kt fit into each corresponding (x, y, l, d) position scale
</p>
<p>- s: score of each kt fit: calculate overall extrem point residual space entropy as score, the smaller the better,
since smaller entropy indicate concentrated residual space and less number of extreme point.
</p>


<h3>Note</h3>

<p>internal cpp class use in gbp2d_solver_dpp()
</p>


<h3>See Also</h3>

<p>Other gbp2d_it: <code><a href="#topic+gbp2d_it_create_ktlist">gbp2d_it_create_ktlist</a></code>
</p>

<hr>
<h2 id='Ktlist3d'>Ktlist3d</h2><span id='topic+Ktlist3d'></span><span id='topic+Rcpp_Ktlist3d'></span><span id='topic+Rcpp_Ktlist3d-class'></span>

<h3>Description</h3>

<p>Ktlist3d hold multiple kt for recursive fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ktlist3d
</code></pre>


<h3>Format</h3>

<p>An object of class <code>C++Class</code> of length 1.</p>


<h3>Details</h3>

<p>Ktlist3d hold multiple kt via consider all possible fit onto different xp and different rotation and nlimit
</p>
<p>a Ktlist3d class instance has 4 fields:
</p>
<p>- n: length of kt candidate position scale vector list
</p>
<p>- kt: candidate (x, y, z, l, d, h) fit of it current investigating
</p>
<p>- xp: candidate extreme point list after kt fit into each corresponding (x, y, z, l, d, h) position scale
</p>
<p>- s: score of each kt fit: calculate overall extrem point residual space entropy as score, the smaller the better,
since smaller entropy indicate concentrated residual space and less number of extreme point.
</p>


<h3>Note</h3>

<p>internal cpp class use in gbp3d_solver_dpp()
</p>


<h3>See Also</h3>

<p>Other gbp3d_it: <code><a href="#topic+gbp3d_it_create_ktlist">gbp3d_it_create_ktlist</a></code>
</p>

<hr>
<h2 id='Ktlist4d'>Ktlist4d</h2><span id='topic+Ktlist4d'></span><span id='topic+Rcpp_Ktlist4d'></span><span id='topic+Rcpp_Ktlist4d-class'></span>

<h3>Description</h3>

<p>Ktlist4d hold multiple kt for recursive fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ktlist4d
</code></pre>


<h3>Format</h3>

<p>An object of class <code>C++Class</code> of length 1.</p>


<h3>Details</h3>

<p>Ktlist4d hold multiple kt via consider all possible fit onto different xp and different rotation and nlimit
</p>
<p>a Ktlist4d class instance has 4 fields
</p>
<p>- n: length of kt candidate position scale vector list
</p>
<p>- kt: candidate (x, y, z, w, l, d, h, w) fit of it current investigating
</p>
<p>x, y, z, w - weight holding in bn when fit; l, d, h, w - weight of it itself
</p>
<p>- xp: candidate extreme point list after kt fit into each corresponding (x, y, z, l, d, h) position scale
</p>
<p>- s: score of each kt fit: calculate overall extrem point residual space entropy as score, the smaller the better,
since smaller entropy indicate concentrated residual space and less number of extreme point.
</p>


<h3>Note</h3>

<p>internal cpp class use in gbp4d_solver_dpp()
</p>


<h3>See Also</h3>

<p>Other gbp4d_it: <code><a href="#topic+gbp4d_it_create_ktlist">gbp4d_it_create_ktlist</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
