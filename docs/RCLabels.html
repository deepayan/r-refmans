<!DOCTYPE html><html><head><title>Help for package RCLabels</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RCLabels}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#arrow_notation'><p>Arrow notation</p></a></li>
<li><a href='#bracket_arrow_notation'><p>Bracket arrow notation</p></a></li>
<li><a href='#bracket_notation'><p>Bracket notation</p></a></li>
<li><a href='#dash_notation'><p>A description of dash notation.</p></a></li>
<li><a href='#first_dot_notation'><p>First dot notation</p></a></li>
<li><a href='#from_notation'><p>From notation</p></a></li>
<li><a href='#get_nouns'><p>Extract nouns from row and column labels</p></a></li>
<li><a href='#get_objects'><p>Extract objects of prepositional phrases in row and column labels</p></a></li>
<li><a href='#get_piece'><p>Get a piece of a label</p></a></li>
<li><a href='#get_pps'><p>Extract prepositional phrases of row and column labels</p></a></li>
<li><a href='#get_prepositions'><p>Extract prepositions from row and column labels</p></a></li>
<li><a href='#in_notation'><p>In notation</p></a></li>
<li><a href='#infer_notation'><p>Infer the notation(s) for a row or column label</p></a></li>
<li><a href='#infer_notation_for_one_label'><p>Infer the notation from one row or column label</p></a></li>
<li><a href='#make_list'><p>Make a list of items in x, regardless of x's type</p></a></li>
<li><a href='#make_or_pattern'><p>Create &quot;or&quot; regex patterns</p></a></li>
<li><a href='#modify_label_pieces'><p>Modify pieces of row and column labels</p></a></li>
<li><a href='#modify_nouns'><p>Modify nouns in labels</p></a></li>
<li><a href='#notations_list'><p>Notations list</p></a></li>
<li><a href='#of_notation'><p>Of notation</p></a></li>
<li><a href='#paren_notation'><p>Parenthetical notation</p></a></li>
<li><a href='#paste_noun_pp'><p>Recombine row and column labels</p></a></li>
<li><a href='#prepositions'><p>Prepositions</p></a></li>
<li><a href='#prepositions_list'><p>Prepositions</p></a></li>
<li><a href='#regex_funcs'><p>Find or replace row or column labels that match a regular expression</p></a></li>
<li><a href='#remove_label_pieces'><p>Remove a prepositional phrase in a row or column label</p></a></li>
<li><a href='#row-col-notation'><p>Row and column notation</p></a></li>
<li><a href='#split_noun_pp'><p>Split row and column labels into nouns and prepositional phrases</p></a></li>
<li><a href='#strip_label_part'><p>A convenience function to help splitting prefixes and suffixes</p></a></li>
<li><a href='#to_notation'><p>To notation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Manipulate Matrix Row and Column Labels with Ease</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-26</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to assist manipulation of matrix 
             row and column labels for all types of matrix mathematics
             where row and column labels are to be respected.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, Hmisc, magrittr, purrr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, knitr, rmarkdown, spelling, stringr, testthat (&ge;
3.0.0), tibble</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>notation</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://matthewheun.github.io/RCLabels/">https://matthewheun.github.io/RCLabels/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 14:48:37 UTC; mkh2</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Heun <a href="https://orcid.org/0000-0002-7438-214X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Heun &lt;matthew.heun@me.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 00:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='arrow_notation'>Arrow notation</h2><span id='topic+arrow_notation'></span>

<h3>Description</h3>

<p>A description of arrow notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrow_notation
</code></pre>


<h3>Format</h3>

<p>A vector of notational symbols that provides an arrow separator (&quot;a -&gt; b&quot;)
between prefix and suffix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arrow_notation
</code></pre>

<hr>
<h2 id='bracket_arrow_notation'>Bracket arrow notation</h2><span id='topic+bracket_arrow_notation'></span>

<h3>Description</h3>

<p>A description of bracket arrow notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bracket_arrow_notation
</code></pre>


<h3>Format</h3>

<p>A vector of notational symbols that provides bracket arrow (&quot;a [-&gt; b]&quot;) notation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bracket_arrow_notation
</code></pre>

<hr>
<h2 id='bracket_notation'>Bracket notation</h2><span id='topic+bracket_notation'></span>

<h3>Description</h3>

<p>A description of bracket notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bracket_notation
</code></pre>


<h3>Format</h3>

<p>A vector of notational symbols that provides bracket (&quot;a [b]&quot;) notation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bracket_notation
</code></pre>

<hr>
<h2 id='dash_notation'>A description of dash notation.</h2><span id='topic+dash_notation'></span>

<h3>Description</h3>

<p>A description of dash notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dash_notation
</code></pre>


<h3>Format</h3>

<p>A vector of notational symbols that provides an dash separator (&quot;a - b&quot;)
between prefix and suffix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dash_notation
</code></pre>

<hr>
<h2 id='first_dot_notation'>First dot notation</h2><span id='topic+first_dot_notation'></span>

<h3>Description</h3>

<p>A description of first dot notation.
Note that &quot;a.b.c&quot; splits into prefix (&quot;a&quot;) and suffix (&quot;b.c&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_dot_notation
</code></pre>


<h3>Format</h3>

<p>A vector of notational symbols that provides first dot (&quot;a.b&quot;) notation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>first_dot_notation
</code></pre>

<hr>
<h2 id='from_notation'>From notation</h2><span id='topic+from_notation'></span>

<h3>Description</h3>

<p>A description of from notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_notation
</code></pre>


<h3>Format</h3>

<p>A vector of notational symbols that provides from (&quot;a [from b]&quot;) notation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>from_notation
</code></pre>

<hr>
<h2 id='get_nouns'>Extract nouns from row and column labels</h2><span id='topic+get_nouns'></span>

<h3>Description</h3>

<p>Nouns are the first part of a row-column label,
&quot;a&quot; in &quot;a [b]&quot;.
Internally, this function calls <code>get_pref_suff(which = "pref")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nouns(
  labels,
  inf_notation = TRUE,
  notation = RCLabels::notations_list,
  choose_most_specific = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nouns_+3A_labels">labels</code></td>
<td>
<p>A list or vector of labels from which nouns are to be extracted.</p>
</td></tr>
<tr><td><code id="get_nouns_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.
See <code>infer_notation()</code> for details.</p>
</td></tr>
<tr><td><code id="get_nouns_+3A_notation">notation</code></td>
<td>
<p>The notation type to be used when extracting nouns.
Default is <code>RCLabels::notations_list</code>, meaning that
the notation is inferred using <code>infer_notation()</code>.</p>
</td></tr>
<tr><td><code id="get_nouns_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that tells whether to choose the most specific
notation from <code>notation</code> when inferring notation.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of nouns from row and column labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_nouns("a [b]", notation = bracket_notation)
# Also works with vectors and lists.
get_nouns(c("a [b]", "c [d]"))
get_nouns(list("a [b]", "c [d]"))
</code></pre>

<hr>
<h2 id='get_objects'>Extract objects of prepositional phrases in row and column labels</h2><span id='topic+get_objects'></span>

<h3>Description</h3>

<p>This function extracts the objects of prepositional phrases
from row and column labels.
The format of the output is a list of
named items, one name for each preposition encountered in labels.
Objects are <code>NA</code> if there is no prepositional phrase starting
with that preposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_objects(
  labels,
  inf_notation = TRUE,
  notation = RCLabels::notations_list,
  choose_most_specific = FALSE,
  prepositions = RCLabels::prepositions_list
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_objects_+3A_labels">labels</code></td>
<td>
<p>The row and column labels from which prepositional phrases are to be extracted.</p>
</td></tr>
<tr><td><code id="get_objects_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.
See <code>infer_notation()</code> for details.</p>
</td></tr>
<tr><td><code id="get_objects_+3A_notation">notation</code></td>
<td>
<p>The notation type to be used when extracting prepositions.
Default is <code>RCLabels::notations_list</code>, meaning that
the notation is inferred using <code>infer_notation()</code>.</p>
</td></tr>
<tr><td><code id="get_objects_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that tells whether to choose the most specific
notation from <code>notation</code> when inferring notation.
Default is <code>FALSE</code> so that a less specific notation can be
inferred.
In combination with <code>RCLabels::notations_list</code>,
the default value of <code>FALSE</code> means that
<code>RCLabels::bracket_notation</code> will be selected instead of
anything more specific, such as
<code>RCLabels::from_notation</code>.</p>
</td></tr>
<tr><td><code id="get_objects_+3A_prepositions">prepositions</code></td>
<td>
<p>A vector of strings to be treated as prepositions.
Note that a space is appended to each word internally,
so, e.g., &quot;to&quot; becomes &quot;to &quot;.
Default is <code>RCLabels::prepositions_list</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects of prepositional phrases,
with names being prepositions, and values being objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_objects(c("a [of b into c]", "d [of Coal from e -&gt; f]"))
</code></pre>

<hr>
<h2 id='get_piece'>Get a piece of a label</h2><span id='topic+get_piece'></span>

<h3>Description</h3>

<p>This is a wrapper function for <code>get_pref_suff()</code>, <code>get_nouns()</code>, and
<code>get_objects()</code>.
It returns a <code>piece</code> of a row or column label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_piece(
  labels,
  piece = "all",
  inf_notation = TRUE,
  notation = RCLabels::notations_list,
  choose_most_specific = FALSE,
  prepositions = RCLabels::prepositions_list
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_piece_+3A_labels">labels</code></td>
<td>
<p>The row and column labels from which prepositional phrases are to be extracted.</p>
</td></tr>
<tr><td><code id="get_piece_+3A_piece">piece</code></td>
<td>
<p>The name of the item to return.</p>
</td></tr>
<tr><td><code id="get_piece_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.
See <code>infer_notation()</code> for details.</p>
</td></tr>
<tr><td><code id="get_piece_+3A_notation">notation</code></td>
<td>
<p>The notation type to be used when extracting prepositions.
Default is <code>RCLabels::notations_list</code>, meaning that
the notation is inferred using <code>infer_notation()</code>.</p>
</td></tr>
<tr><td><code id="get_piece_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that tells whether to choose the most specific
notation from <code>notation</code> when inferring notation.
Default is <code>FALSE</code> so that a less specific notation can be
inferred.
In combination with <code>RCLabels::notations_list</code>,
the default value of <code>FALSE</code> means that
<code>RCLabels::bracket_notation</code> will be selected instead of
anything more specific, such as
<code>RCLabels::from_notation</code>.</p>
</td></tr>
<tr><td><code id="get_piece_+3A_prepositions">prepositions</code></td>
<td>
<p>A vector of strings to be treated as prepositions.
Note that a space is appended to each word internally,
so, e.g., &quot;to&quot; becomes &quot;to &quot;.
Default is <code>RCLabels::prepositions_list</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>piece</code> is typically one of
</p>

<ul>
<li><p> &quot;all&quot; (which returns <code>labels</code> directly),
</p>
</li>
<li><p> &quot;pref&quot; (for the prefixes),
</p>
</li>
<li><p> &quot;suff&quot; (for the suffixes),
</p>
</li>
<li><p> &quot;noun&quot; (returns the noun),
</p>
</li>
<li><p> &quot;pps&quot; (prepositional phrases, returns prepositional phrases in full),
</p>
</li>
<li><p> &quot;prepositions&quot; (returns a list of prepositions),
</p>
</li>
<li><p> &quot;objects&quot; (returns a list of objects with prepositions as names), or
</p>
</li>
<li><p> a preposition in <code>prepositions</code> (as a string), which will return
the object of that preposition named by the preposition itself.
</p>
</li></ul>

<p><code>piece</code> must be a character vector of length 1.
If a <code>piece</code> is missing in a label, &quot;&quot; (empty string) is returned.
</p>
<p>If specifying more than one <code>notation</code>, be sure the notations are in a list.
<code>notation = c(RCLabels::bracket_notation, RCLabels::arrow_notation)</code>
is unlikely to produce the desired result, because the notations
are concatenated together to form a long string vector.
Rather say
<code>notation = list(RCLabels::bracket_notation, RCLabels::arrow_notation)</code>.
</p>


<h3>Value</h3>

<p>A <code>piece</code> of <code>labels</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>labs &lt;- c("a [from b in c]", "d [of e in f]", "Export [of Coal from USA to MEX]")
get_piece(labs, "pref")
get_piece(labs, "suff")
get_piece(labs, piece = "noun")
get_piece(labs, piece = "pps")
get_piece(labs, piece = "prepositions")
get_piece(labs, piece = "objects")
get_piece(labs, piece = "from")
get_piece(labs, piece = "in")
get_piece(labs, piece = "of")
get_piece(labs, piece = "to")
</code></pre>

<hr>
<h2 id='get_pps'>Extract prepositional phrases of row and column labels</h2><span id='topic+get_pps'></span>

<h3>Description</h3>

<p>This function extracts prepositional phrases from suffixes of row and column labels
of the form &quot;a [preposition b]&quot;, where &quot;preposition b&quot; is the prepositional phrase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pps(
  labels,
  inf_notation = TRUE,
  notation = RCLabels::notations_list,
  choose_most_specific = FALSE,
  prepositions = RCLabels::prepositions_list
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pps_+3A_labels">labels</code></td>
<td>
<p>A list or vector of labels from which prepositional phrases are to be extracted.</p>
</td></tr>
<tr><td><code id="get_pps_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.
See <code>infer_notation()</code> for details.</p>
</td></tr>
<tr><td><code id="get_pps_+3A_notation">notation</code></td>
<td>
<p>The notation type to be used when extracting prepositional phrases.
Default is <code>RCLabels::notations_list</code>, meaning that
the notation is inferred using <code>infer_notation()</code>.</p>
</td></tr>
<tr><td><code id="get_pps_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that tells whether to choose the most specific
notation from <code>notation</code> when inferring notation.
Default is <code>FALSE</code> so that a less specific notation can be
inferred.
In combination with <code>RCLabels::notations_list</code>,
the default value of <code>FALSE</code> means that
<code>RCLabels::bracket_notation</code> will be selected instead of
anything more specific, such as
<code>RCLabels::from_notation</code>.</p>
</td></tr>
<tr><td><code id="get_pps_+3A_prepositions">prepositions</code></td>
<td>
<p>A list of prepositions for which to search.
Default is <code>RCLabels::prepositions_list</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All prepositional phrases in a suffix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_pps(c("a [in b]", "c [of d]"))
get_pps(c("a [of b in c]", "d [-&gt; e of f]"))
</code></pre>

<hr>
<h2 id='get_prepositions'>Extract prepositions from row and column labels</h2><span id='topic+get_prepositions'></span>

<h3>Description</h3>

<p>This function extracts prepositions from a list of row and column labels.
The list has outer structure of the number of labels and
an inner structure of each prepositional phrase in the specific label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_prepositions(
  labels,
  inf_notation = TRUE,
  notation = RCLabels::notations_list,
  choose_most_specific = FALSE,
  prepositions = RCLabels::prepositions_list
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_prepositions_+3A_labels">labels</code></td>
<td>
<p>The row and column labels from which prepositional phrases are to be extracted.</p>
</td></tr>
<tr><td><code id="get_prepositions_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.
See <code>infer_notation()</code> for details.</p>
</td></tr>
<tr><td><code id="get_prepositions_+3A_notation">notation</code></td>
<td>
<p>The notation type to be used when extracting prepositions.
Default is <code>RCLabels::notations_list</code>, meaning that
the notation is inferred using <code>infer_notation()</code>.</p>
</td></tr>
<tr><td><code id="get_prepositions_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that tells whether to choose the most specific
notation from <code>notation</code> when inferring notation.
Default is <code>FALSE</code> so that a less specific notation can be
inferred.
In combination with <code>RCLabels::notations_list</code>,
the default value of <code>FALSE</code> means that
<code>RCLabels::bracket_notation</code> will be selected instead of
anything more specific, such as
<code>RCLabels::from_notation</code>.</p>
</td></tr>
<tr><td><code id="get_prepositions_+3A_prepositions">prepositions</code></td>
<td>
<p>A vector of strings to be treated as prepositions.
Note that a space is appended to each word internally,
so, e.g., &quot;to&quot; becomes &quot;to &quot;.
Default is <code>RCLabels::prepositions_list</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of prepositions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_prepositions(c("a [of b into c]", "d [-&gt; e of f]"))
</code></pre>

<hr>
<h2 id='in_notation'>In notation</h2><span id='topic+in_notation'></span>

<h3>Description</h3>

<p>A description of in notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_notation
</code></pre>


<h3>Format</h3>

<p>A vector of notational symbols that provides to (&quot;a [in b]&quot;) notation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>in_notation
</code></pre>

<hr>
<h2 id='infer_notation'>Infer the notation(s) for a row or column label</h2><span id='topic+infer_notation'></span>

<h3>Description</h3>

<p>It is convenient to know which notation is applicable to row or column labels.
This function infers which <code>notations</code> are appropriate for <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_notation(
  x,
  inf_notation = TRUE,
  notations = RCLabels::notations_list,
  allow_multiple = FALSE,
  retain_names = FALSE,
  choose_most_specific = TRUE,
  must_succeed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_notation_+3A_x">x</code></td>
<td>
<p>A row or column label (or vector of labels).</p>
</td></tr>
<tr><td><code id="infer_notation_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="infer_notation_+3A_notations">notations</code></td>
<td>
<p>A list of notations from which matches will be inferred.
This function might not work as expected if
<code>notation</code> is not a list.
If <code>notation</code> is not a list,
<code>notations</code> is returned in full.
Default is <code>RCLabels::notations_list</code>.</p>
</td></tr>
<tr><td><code id="infer_notation_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>A boolean that tells whether multiple notation matches
are allowed.
If <code>FALSE</code> (the default), multiple matches give an error.</p>
</td></tr>
<tr><td><code id="infer_notation_+3A_retain_names">retain_names</code></td>
<td>
<p>A boolean that tells whether to retain names from <code>notations</code> on the
outgoing matches.
Default is <code>FALSE</code>.
If <code>TRUE</code>, the return value is <em>always</em> a named list.
If only one of <code>notations</code> is returned
(for example, because <code>choose_most_specific = TRUE</code>),
names are never supplied.</p>
</td></tr>
<tr><td><code id="infer_notation_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that indicates whether the most-specific notation
will be returned when more than one of <code>notations</code> matches <code>x</code>
and <code>allow_multiple = FALSE</code>.
When <code>FALSE</code>, the first matching notation in <code>notations</code>
is returned when <code>allow_multiple = FALSE</code>.
Default is <code>TRUE</code>.
See details.</p>
</td></tr>
<tr><td><code id="infer_notation_+3A_must_succeed">must_succeed</code></td>
<td>
<p>A boolean that if <code>TRUE</code> (the default),
causes an error to be thrown if a matching notation is not found
for any label in <code>x</code>.
When <code>FALSE</code>, an unsuccessful notation inference will return <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is vectorized.
Thus, <code>x</code> can be a vector, in which case the output is a list of notations.
</p>
<p><code>notations</code> is treated as a store from which matches for each label in <code>x</code>
can be determined.
<code>notations</code> should be a named list of notations.
When <code>retain_names = TRUE</code>, the names on <code>notations</code> will be retained,
and the return value is <em>always</em> a list.
</p>
<p>By default (<code>allow_multiple = FALSE</code>),
a single notation object is returned for each item in <code>x</code>
if only one notation in <code>notations</code>
is appropriate for <code>x</code>.
If <code>allow_multiple = FALSE</code> (the default) and more than one <code>notation</code> is applicable to <code>x</code>,
an error is thrown.
Multiple matches can be returned when <code>allow_multiple = TRUE</code>.
</p>
<p>If multiple notations are matched, the return value is a list.
</p>
<p>When <code>choose_most_specific = TRUE</code> (the default),
the most specific notation in <code>notations</code> is returned.
&quot;Most specific&quot; is defined as the matching notation
whose sum of characters in the <code>pref_start</code>, <code>pref_end</code>,
<code>suff_start</code> and <code>suff_end</code> elements
is greatest.
If <code>choose_most_specific = TRUE</code> and
two matching notations in <code>notations</code> have the same number of characters,
only the first match is returned.
When <code>choose_most_specific = TRUE</code>,
the value of <code>allow_multiple</code> no longer matters.
<code>allow_multiple = FALSE</code> is implied and
at most one of the <code>notations</code> will be returned.
</p>
<p>When <code>inf_notation = FALSE</code> (default is <code>TRUE</code>),
<code>notations</code> are returned unmodified,
essentially disabling this function.
Although calling with <code>inf_notation = FALSE</code> seems daft,
this behavior enables cleaner code elsewhere.
</p>


<h3>Value</h3>

<p>A single notation object (if <code>x</code> is a single row or column label)
or a list of notation objects (if <code>x</code> is a vector or a list).
If no <code>notations</code> match <code>x</code>, <code>NULL</code> is returned,
either alone or in a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Does not match any notations in RCLabels::notations_list
# and throws an error, because the default value for `must_succeed`
# is `TRUE`.
## Not run: 
infer_notation("abc")

## End(Not run)
# This returns `NULL`, because `must_succeed = FALSE`.
infer_notation("abc", must_succeed = FALSE)
# This succeeds, because the label is in the form of a
# notation in `RCLabels::notation_list`,
# the default value of the `notation` argument.
infer_notation("a -&gt; b")
# Names of the notations can be retained, in which case
# the return value is always a list.
infer_notation("a -&gt; b", retain_names = TRUE)
# This function is vectorized.
# The list of labels matches
# all known notations in `RCLabels::notations_list`.
infer_notation(c("a -&gt; b", "a (b)", "a [b]", "a [from b]", "a [of b]",
                 "a [to b]", "a [in b]", "a [-&gt; b]", "a.b"),
                 retain_names = TRUE)
# By default, the most specific notation is returned.
# But when two or more matches are present,
# multiple notations can be returned, too.
infer_notation("a [from b]",
               allow_multiple = TRUE, retain_names = TRUE,
               choose_most_specific = FALSE)
infer_notation(c("a [from b]", "c [to d]"),
               allow_multiple = TRUE, retain_names = TRUE,
               choose_most_specific = FALSE)
# As shown above, "a \[from b\]" matches 2 notations:
# `RCLabels::bracket_notation` and `RCLabels::from_notation`.
# The default value for the notation argument is
# RCLabels::notations_list,
# which includes `RCLabels::bracket_notation`
# and `RCLabels::from_notation` in that order.
# Thus, there is some flexibility to how this function works
# if the value of the `notation` argument is a list of notations
# ordered from least specific to most specific,
# as `RCLabels::notations_list` is ordered.
# To review, the next call returns both `RCLabels::bracket_notation` and
# `RCLabels::from_notation`, because `allow_multiple = TRUE` and
# `choose_most_specific = FALSE`, neither of which are default.
infer_notation("a [from b]",
               allow_multiple = TRUE,
               choose_most_specific = FALSE,
               retain_names = TRUE)
# The next call returns `RCLabels::from_notation`, because
# the most specific notation is requested, and
# `RCLabels::from_notation` has more characters in its specification than
# `RCLabels::bracket_notation`.
infer_notation("a [from b]",
               choose_most_specific = TRUE,
               retain_names = TRUE)
# The next call returns the `RCLabels::bracket_notation`, because
# `choose_most_specific = FALSE`, and the first matching
# notation in `RCLabels::notations_list` is `RCLabels::bracket_notation`.
infer_notation("a [from b]",
               choose_most_specific = FALSE,
               retain_names = TRUE)
</code></pre>

<hr>
<h2 id='infer_notation_for_one_label'>Infer the notation from one row or column label</h2><span id='topic+infer_notation_for_one_label'></span>

<h3>Description</h3>

<p>This is a non-public helper function for vectorized <code>infer_notation()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_notation_for_one_label(
  x,
  inf_notation = TRUE,
  notations = RCLabels::notations_list,
  allow_multiple = FALSE,
  retain_names = FALSE,
  choose_most_specific = TRUE,
  must_succeed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_notation_for_one_label_+3A_x">x</code></td>
<td>
<p>A single row or column label.</p>
</td></tr>
<tr><td><code id="infer_notation_for_one_label_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.</p>
</td></tr>
<tr><td><code id="infer_notation_for_one_label_+3A_notations">notations</code></td>
<td>
<p>A list of notations from which matches will be inferred
This function might not work as expected if
<code>notation</code> is not a list.
If <code>notation</code> is not a list,
<code>notations</code> is returned in full.
Default is <code>RCLabels::notations_list</code>.</p>
</td></tr>
<tr><td><code id="infer_notation_for_one_label_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>A boolean that tells whether multiple notation matches
are allowed.
If <code>FALSE</code> (the default), multiple matches give an error.</p>
</td></tr>
<tr><td><code id="infer_notation_for_one_label_+3A_retain_names">retain_names</code></td>
<td>
<p>A boolean that tells whether to retain names on the
outgoing matches.
Default is <code>FALSE</code>.
If <code>TRUE</code>, the return value is a named list.
If only one of <code>notations</code> is returned,
names are never supplied.</p>
</td></tr>
<tr><td><code id="infer_notation_for_one_label_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that indicates if the most-specific notation
will be returned when more than one of <code>notations</code> matches <code>x</code>.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="infer_notation_for_one_label_+3A_must_succeed">must_succeed</code></td>
<td>
<p>A boolean that if <code>TRUE</code> (the default),
causes an error to be thrown if a matching notation is not found
for any label in <code>x</code>.
When <code>FALSE</code>, an unsuccessful label inference will return <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single matching notation object (if <code>allow_multiple = FALSE</code>, the default)
or possibly multiple matching notation objects (if <code>allow_multiple = TRUE</code>).
If no <code>notations</code> match <code>x</code>, <code>NULL</code>.
</p>

<hr>
<h2 id='make_list'>Make a list of items in x, regardless of x's type</h2><span id='topic+make_list'></span>

<h3>Description</h3>

<p>Repeats <code>x</code> as necessary to make <code>n</code> of them.
Does not try to simplify <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_list(x, n, lenx = ifelse(is.vector(x), length(x), 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_list_+3A_x">x</code></td>
<td>
<p>The object to be duplicated.</p>
</td></tr>
<tr><td><code id="make_list_+3A_n">n</code></td>
<td>
<p>The number of times to be duplicated.</p>
</td></tr>
<tr><td><code id="make_list_+3A_lenx">lenx</code></td>
<td>
<p>The length of item <code>x</code>.
Be default, <code>lenx</code> is taken to be <code>length(x)</code>,</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is itself a vector or list,
you may want to override the default value for <code>lenx</code>.
For example, if <code>x</code> is a list that should be duplicated several times,
set <code>lenx = 1</code>.
</p>


<h3>Value</h3>

<p>A list of <code>x</code> duplicated <code>n</code> times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1:6), nrow=3, dimnames = list(c("r1", "r2", "r3"), c("c2", "c1")))
make_list(m, n = 1)
make_list(m, n = 2)
make_list(m, n = 5)
make_list(list(c(1,2), c(1,2)), n = 4)
m &lt;- matrix(1:4, nrow = 2)
l &lt;- list(m, m+100)
make_list(l, n = 4)
make_list(l, n = 1) # Warning because l is trimmed.
make_list(l, n = 5) # Warning because length(l) (i.e., 2) not evenly divisible by 5
make_list(list(c("r10", "r11"), c("c10", "c11")), n = 2) # Confused by x being a list
make_list(list(c("r10", "r11"), c("c10", "c11")), n = 2, lenx = 1) # Fix by setting lenx = 1
</code></pre>

<hr>
<h2 id='make_or_pattern'>Create &quot;or&quot; regex patterns</h2><span id='topic+make_or_pattern'></span>

<h3>Description</h3>

<p>This function makes &quot;or&quot; regex patterns from vectors or lists of strings.
This function can be used with the <code>matsbyname::select_rows_byname()</code>
and <code>matsbyname::select_cols_byname</code> functions.
<code>make_or_pattern()</code> correctly escapes special characters in <code>strings</code>,
such as <code>(</code> and <code style="white-space: pre;">&#8288;)&#8288;</code>, as needed.
Thus, it is highly recommended that <code>make_or_pattern</code> be used when
constructing patterns for row and column selections with
<code>matsbyname::select_rows_byname()</code> and <code>matsbyname::select_cols_byname()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_or_pattern(
  strings,
  pattern_type = c("exact", "leading", "trailing", "anywhere", "literal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_or_pattern_+3A_strings">strings</code></td>
<td>
<p>A vector of row and column names.</p>
</td></tr>
<tr><td><code id="make_or_pattern_+3A_pattern_type">pattern_type</code></td>
<td>
<p>One of &quot;exact&quot;, &quot;leading&quot;, &quot;trailing&quot;, &quot;anywhere&quot;, or &quot;literal&quot;. Default is &quot;exact&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pattern_type</code> controls the type of pattern created:
</p>

<ul>
<li><p><code>exact</code> produces a regex pattern that selects row or column names by exact match.
</p>
</li>
<li><p><code>leading</code> produces a regex pattern that selects row or column names if the item in <code>strings</code> matches
the beginnings of row or column names.
</p>
</li>
<li><p><code>trailing</code> produces a regex pattern that selects row or column names if the item in <code>strings</code> matches
the ends of row or column names.
</p>
</li>
<li><p><code>anywhere</code> produces a regex pattern that selects row or column names if the item in <code>strings</code> matches
any substring of row or column names.
</p>
</li>
<li><p><code>literal</code> returns <code>strings</code> unmodified, and it is up to the caller to formulate a correct regex.
</p>
</li></ul>



<h3>Value</h3>

<p>An &quot;or&quot; regex pattern suitable for selecting row and column names.
Amenable for use with <code>matsbyname::select_rows_byname</code> or <code>matsbyname::select_cols_byname</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_or_pattern(strings = c("a", "b"), pattern_type = "exact")
make_or_pattern(strings = c("a", "b"), pattern_type = "leading")
make_or_pattern(strings = c("a", "b"), pattern_type = "trailing")
make_or_pattern(strings = c("a", "b"), pattern_type = "anywhere")
make_or_pattern(strings = c("a", "b"), pattern_type = "literal")
</code></pre>

<hr>
<h2 id='modify_label_pieces'>Modify pieces of row and column labels</h2><span id='topic+modify_label_pieces'></span>

<h3>Description</h3>

<p>Typical <code>piece</code>s include &quot;noun&quot; or a preposition,
such as &quot;in&quot; or &quot;from&quot;.
See <code>RCLabels::prepositions</code> for additional examples.
This argument may be a single string or a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_label_pieces(
  labels,
  piece,
  mod_map,
  prepositions = RCLabels::prepositions_list,
  inf_notation = TRUE,
  notation = RCLabels::bracket_notation,
  choose_most_specific = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify_label_pieces_+3A_labels">labels</code></td>
<td>
<p>A vector of row or column labels in which pieces will be modified.</p>
</td></tr>
<tr><td><code id="modify_label_pieces_+3A_piece">piece</code></td>
<td>
<p>The piece (or pieces) of the row or column label that will be modified.</p>
</td></tr>
<tr><td><code id="modify_label_pieces_+3A_mod_map">mod_map</code></td>
<td>
<p>A modification map. See details.</p>
</td></tr>
<tr><td><code id="modify_label_pieces_+3A_prepositions">prepositions</code></td>
<td>
<p>A list of prepositions, used to detect prepositional phrases.
Default is <code>RCLabels::prepositions_list</code>.</p>
</td></tr>
<tr><td><code id="modify_label_pieces_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.
See <code>infer_notation()</code> for details.</p>
</td></tr>
<tr><td><code id="modify_label_pieces_+3A_notation">notation</code></td>
<td>
<p>The notation type to be used when extracting prepositions.
Default is <code>RCLabels::notations_list</code>, meaning that
the notation is inferred using <code>infer_notation()</code>.</p>
</td></tr>
<tr><td><code id="modify_label_pieces_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that tells whether the most specific
notation is selected when more than one notation match.
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function modifies pieces of row and column labels
according to <code>label_map</code> that defines &quot;one or many to one&quot; relationships.
This function is useful for aggregations.
For example, replacing nouns can be done by
<code style="white-space: pre;">&#8288;modify_label_pieces(labels, piece = "noun", label_map = list(new_noun = c("a", "b", "c"))&#8288;</code>.
The string &quot;new_noun&quot; will replace any of &quot;a&quot;, &quot;b&quot;, or &quot;c&quot;
when they appear as nouns in a row or column label.
See examples for details.
</p>
<p>The <code>mod_map</code> argument should consist of a
named list of character vectors in which names indicate
strings to be inserted and values indicate
values that should be replaced.
The sense is <code>new = old</code> or <code>new = olds</code>,
where &quot;new&quot; is the new name (the replacement) and
&quot;old&quot;/&quot;olds&quot; is/are a string/vector of strings,
any one of which will be replaced by &quot;new&quot;.
</p>
<p>Note <code>piece</code> can be &quot;pref&quot;/&quot;suff&quot; or &quot;noun&quot;/&quot;prepositions&quot;
If any <code>piece</code> is &quot;pref&quot; or &quot;suff&quot;,
all pieces are assumed to be a prefix or a suffix.
If non of the <code>piece</code>s are &quot;pref&quot; or &quot;suff&quot;,
all <code>piece</code>s are assumed to be nouns or prepositions,
such as &quot;in&quot; or &quot;from&quot;.
See <code>RCLabels::prepositions</code> for additional examples.
This argument may be a single string or a character vector.
</p>


<h3>Value</h3>

<p><code>labels</code> with replacements according to <code>piece</code> and <code>mod_map</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple case
modify_label_pieces("a [of b in c]",
                    piece = "noun",
                    mod_map = list(new_noun = c("a", "b")))
# Works with a vector or list of labels
modify_label_pieces(c("a [of b in c]", "d [-&gt; e in f]"),
                    piece = "noun",
                    mod_map = list(new_noun = c("d", "e")))
# Works with multiple items in the mod_map
modify_label_pieces(c("a [of b in c]", "d [-&gt; e in f]"),
                    piece = "noun",
                    mod_map = list(new_noun1 = c("a", "b", "c"),
                                   new_noun2 = c("d", "e", "f")))
# Works with multiple pieces to be modified
modify_label_pieces(c("a [of b in c]", "d [-&gt; e in f]"),
                    piece = c("noun", "in"),
                    mod_map = list(new_noun = c("a", "b", "c"),
                                   new_in   = c("c", "f")))
</code></pre>

<hr>
<h2 id='modify_nouns'>Modify nouns in labels</h2><span id='topic+modify_nouns'></span>

<h3>Description</h3>

<p>This function modifies the nouns of row and column labels.
The length of <code>new_nouns</code> must be the same as the length of <code>labels</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_nouns(
  labels,
  new_nouns,
  inf_notation = TRUE,
  notation = RCLabels::notations_list,
  choose_most_specific = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify_nouns_+3A_labels">labels</code></td>
<td>
<p>The row and column labels in which the nouns will be modified.</p>
</td></tr>
<tr><td><code id="modify_nouns_+3A_new_nouns">new_nouns</code></td>
<td>
<p>The new nouns to be set in <code>labels</code>.
Must be same length as <code>labels</code>.</p>
</td></tr>
<tr><td><code id="modify_nouns_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>labels</code>.
Default is <code>TRUE</code>.
See <code>infer_notation()</code> for details.</p>
</td></tr>
<tr><td><code id="modify_nouns_+3A_notation">notation</code></td>
<td>
<p>The notation type to be used when extracting prepositions.
Default is <code>RCLabels::notations_list</code>, meaning that
the notation is inferred using <code>infer_notation()</code>.</p>
</td></tr>
<tr><td><code id="modify_nouns_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that tells whether to choose the most specific
notation from <code>notation</code> when inferring notation.
Default is <code>FALSE</code> so that a less specific notation can be
inferred.
In combination with <code>RCLabels::notations_list</code>,
the default value of <code>FALSE</code> means that
<code>RCLabels::bracket_notation</code> will be selected instead of
anything more specific, such as
<code>RCLabels::from_notation</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of same length as labels
with nouns modified to be <code>new_nouns</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>labels &lt;- c("a [of b in c]", "d [of e in USA]")
modify_nouns(labels, c("a_plus", "g"))
</code></pre>

<hr>
<h2 id='notations_list'>Notations list</h2><span id='topic+notations_list'></span>

<h3>Description</h3>

<p>A list of all bundled notations.
This list is organized by least specific to most specific,
thereby enabling some unique behaviors in <code>infer_notation()</code>.
See the examples for <code>infer_notation()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>notations_list
</code></pre>


<h3>Format</h3>

<p>A list of bundled notations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>notations_list
</code></pre>

<hr>
<h2 id='of_notation'>Of notation</h2><span id='topic+of_notation'></span>

<h3>Description</h3>

<p>A description of of notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>of_notation
</code></pre>


<h3>Format</h3>

<p>A vector of notational symbols that provides of (&quot;a [of b]&quot;) notation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>of_notation
</code></pre>

<hr>
<h2 id='paren_notation'>Parenthetical notation</h2><span id='topic+paren_notation'></span>

<h3>Description</h3>

<p>A description of parenthetical notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paren_notation
</code></pre>


<h3>Format</h3>

<p>A vector of notational symbols that provides a parenthetical (&quot;a (b)&quot;) notation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>paren_notation
</code></pre>

<hr>
<h2 id='paste_noun_pp'>Recombine row and column labels</h2><span id='topic+paste_noun_pp'></span>

<h3>Description</h3>

<p>This function recombines (unsplits) row or column labels that have
been separated by <code>split_noun_pp()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_noun_pp(
  splt_labels,
  notation = RCLabels::bracket_notation,
  squish = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paste_noun_pp_+3A_splt_labels">splt_labels</code></td>
<td>
<p>A vector of split row or column labels, probably created by <code>split_noun_pp()</code>.</p>
</td></tr>
<tr><td><code id="paste_noun_pp_+3A_notation">notation</code></td>
<td>
<p>The notation object that describes the labels.
Default is <code>RCLabels::bracket_notation</code>.</p>
</td></tr>
<tr><td><code id="paste_noun_pp_+3A_squish">squish</code></td>
<td>
<p>A boolean that tells whether to remove extra spaces in the output of <code style="white-space: pre;">&#8288;paste_*()&#8288;</code> functions.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Recombined row and column labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>labs &lt;- c("a [of b in c]", "d [from Coal mines in USA]")
labs
split &lt;- split_noun_pp(labs)
split
paste_noun_pp(split)
# Also works in a data frame
df &lt;- tibble::tibble(labels = c("a [in b]", "c [of d into USA]",
                                "e [of f in g]", "h [-&gt; i in j]"))
recombined &lt;- df %&gt;%
  dplyr::mutate(
    splits = split_noun_pp(labels),
    recombined = paste_noun_pp(splits)
  )
all(recombined$labels == recombined$recombined)
</code></pre>

<hr>
<h2 id='prepositions'>Prepositions</h2><span id='topic+prepositions'></span>

<h3>Description</h3>

<p>This constant is deprecated.
Please use <code>prepositiions_list</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepositions
</code></pre>


<h3>Format</h3>

<p>A vector of prepositions used in row and column labels.
</p>

<hr>
<h2 id='prepositions_list'>Prepositions</h2><span id='topic+prepositions_list'></span>

<h3>Description</h3>

<p>Prepositions used in row and column labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepositions_list
</code></pre>


<h3>Format</h3>

<p>A vector of prepositions used in row and column labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prepositions_list
</code></pre>

<hr>
<h2 id='regex_funcs'>Find or replace row or column labels that match a regular expression</h2><span id='topic+regex_funcs'></span><span id='topic+match_by_pattern'></span><span id='topic+replace_by_pattern'></span>

<h3>Description</h3>

<p><code>match_by_pattern()</code> tells whether row or column labels
match a regular expression.
Internally, <code>grepl()</code> decides whether a match occurs.
<code>replace_by_pattern()</code> replaces portions of row of column labels
when a regular expression is matched.
Internally, <code>gsub()</code> performs the replacements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_by_pattern(
  labels,
  regex_pattern,
  pieces = "all",
  prepositions = RCLabels::prepositions_list,
  notation = RCLabels::bracket_notation,
  ...
)

replace_by_pattern(
  labels,
  regex_pattern,
  replacement,
  pieces = "all",
  prepositions = RCLabels::prepositions_list,
  notation = RCLabels::bracket_notation,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regex_funcs_+3A_labels">labels</code></td>
<td>
<p>The row and column labels to be modified.</p>
</td></tr>
<tr><td><code id="regex_funcs_+3A_regex_pattern">regex_pattern</code></td>
<td>
<p>The regular expression pattern to determine matches and replacements.
Consider using <code>Hmisc::escapeRegex()</code> to escape <code>regex_pattern</code>
before calling this function.</p>
</td></tr>
<tr><td><code id="regex_funcs_+3A_pieces">pieces</code></td>
<td>
<p>The pieces of row or column labels to be checked for matches or replacements.
See details.</p>
</td></tr>
<tr><td><code id="regex_funcs_+3A_prepositions">prepositions</code></td>
<td>
<p>A vector of strings that count as prepositions.
Default is <code>RCLabels::prepositions_list</code>.
Used to detect prepositional phrases
if <code>pieces</code> are to be interpreted as prepositions.</p>
</td></tr>
<tr><td><code id="regex_funcs_+3A_notation">notation</code></td>
<td>
<p>The notation used in <code>labels</code>.
Default is <code>RCLabels::bracket_notation</code>.</p>
</td></tr>
<tr><td><code id="regex_funcs_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>grepl()</code> or <code>gsub()</code>,
such as <code>ignore.case</code>, <code>perl</code>, <code>fixed</code>,
or <code>useBytes</code>.
See examples.</p>
</td></tr>
<tr><td><code id="regex_funcs_+3A_replacement">replacement</code></td>
<td>
<p>For <code>replace_by_pattern()</code>, the string that replaces
all matches to <code>regex_pattern</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default (<code>pieces = "all"</code>), complete labels (as strings) are checked for matches
and replacements.
If <code>pieces == "pref"</code> or <code>pieces == "suff"</code>,
only the prefix or the suffix is checked for matches and replacements.
Alternatively, <code>pieces = "noun"</code> or <code style="white-space: pre;">&#8288;pieces = &lt;&lt;preposition&gt;&gt;&#8288;</code> indicate
that only specific pieces of labels are to be checked for matches and replacements.
When <code style="white-space: pre;">&#8288;pieces = &lt;&lt;preposition&gt;&gt;&#8288;</code>, only the object of <code style="white-space: pre;">&#8288;&lt;&lt;preposition&gt;&gt;&#8288;</code> is
checked for matches and replacement.
</p>
<p><code>pieces</code> can be a vector, indicating multiple pieces to be checked for matches
and replacements.
But if any of the <code>pieces</code> are &quot;all&quot;, all pieces are checked and replaced.
If <code>pieces</code> is &quot;pref&quot; or &quot;suff&quot;, only one can be specified.
</p>


<h3>Value</h3>

<p>A logical vector of same length as <code>labels</code>,
where <code>TRUE</code> indicates a match was found and <code>FALSE</code> indicates otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>labels &lt;- c("Production [of b in c]", "d [of Coal in f]", "g [of h in USA]")
# With default `pieces` argument, matching is done for whole labels.
match_by_pattern(labels, regex_pattern = "Production")
match_by_pattern(labels, regex_pattern = "Coal")
match_by_pattern(labels, regex_pattern = "USA")
# Check beginnings of labels
match_by_pattern(labels, regex_pattern = "^Production")
# Check at ends of labels: no match.
match_by_pattern(labels, regex_pattern = "Production$")
# Can match on nouns or prepositions.
match_by_pattern(labels, regex_pattern = "Production", pieces = "noun")
# Gives FALSE, because "Production" is a noun.
match_by_pattern(labels, regex_pattern = "Production", pieces = "in")
</code></pre>

<hr>
<h2 id='remove_label_pieces'>Remove a prepositional phrase in a row or column label</h2><span id='topic+remove_label_pieces'></span>

<h3>Description</h3>

<p>This function removes pieces from
row and column labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_label_pieces(
  labels,
  pieces_to_remove,
  prepositions = RCLabels::prepositions_list,
  inf_notation = TRUE,
  notation = RCLabels::notations_list,
  choose_most_specific = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_label_pieces_+3A_labels">labels</code></td>
<td>
<p>The row and column labels from which prepositional phrases will be removed.</p>
</td></tr>
<tr><td><code id="remove_label_pieces_+3A_pieces_to_remove">pieces_to_remove</code></td>
<td>
<p>The names of pieces of the label to be removed,
typically &quot;noun&quot; or a preposition such as &quot;of&quot; or &quot;in&quot;
See <code>RCLabels::prepositions_list</code> for a list of known prepositions.</p>
</td></tr>
<tr><td><code id="remove_label_pieces_+3A_prepositions">prepositions</code></td>
<td>
<p>A list of prepositions, used to detect prepositional phrases.
Default is <code>RCLabels::prepositions_list</code>.</p>
</td></tr>
<tr><td><code id="remove_label_pieces_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.
See <code>infer_notation()</code> for details.</p>
</td></tr>
<tr><td><code id="remove_label_pieces_+3A_notation">notation</code></td>
<td>
<p>The notation type to be used when extracting prepositions.
Default is <code>RCLabels::notations_list</code>, meaning that
the notation is inferred using <code>infer_notation()</code>.</p>
</td></tr>
<tr><td><code id="remove_label_pieces_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that tells whether the most specific
notation is selected when more than one notation match.
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>labels</code> with pieces removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>labs &lt;- c("a [of b in c]", "d [-&gt; e in f]")
remove_label_pieces(labs, pieces_to_remove = "of")
remove_label_pieces(labs, pieces_to_remove = c("of", "-&gt;"))
remove_label_pieces(labs, pieces_to_remove = c("in", "into"))
remove_label_pieces(labs, pieces_to_remove = c("of", "in"))
</code></pre>

<hr>
<h2 id='row-col-notation'>Row and column notation</h2><span id='topic+row-col-notation'></span><span id='topic+notation_vec'></span><span id='topic+preposition_notation'></span><span id='topic+split_pref_suff'></span><span id='topic+paste_pref_suff'></span><span id='topic+flip_pref_suff'></span><span id='topic+get_pref_suff'></span><span id='topic+switch_notation'></span>

<h3>Description</h3>

<p>It is often convenient to represent matrix row and column names
with notation that includes a prefix and a suffix,
with corresponding separators or start-end string sequences.
There are several functions to generate specialized versions
or otherwise manipulate row and column names on their own or as row or column names.
</p>

<ul>
<li> <p><code>flip_pref_suff()</code> Switches the location of prefix and suffix, such that the prefix becomes the suffix, and
the suffix becomes the prefix.
E.g., &quot;a -&gt; b&quot; becomes &quot;b -&gt; a&quot; or &quot;a [b]&quot; becomes &quot;b [a]&quot;.
</p>
</li>
<li> <p><code>get_pref_suff()</code> Selects only prefix or suffix, discarding notational elements
and the rejected part.
Internally, this function calls <code>split_pref_suff()</code> and selects only the desired portion.
</p>
</li>
<li> <p><code>notation_vec()</code> Builds a vector of notation symbols in a standard format.
By default, it builds a list of notation symbols that provides an arrow
separator (&quot; -&gt; &quot;) between prefix and suffix.
</p>
</li>
<li> <p><code>paste_pref_suff()</code> <code>paste0</code>'s prefixes and suffixes, the inverse of <code>split_pref_suff()</code>.
Always returns a character vector.
</p>
</li>
<li> <p><code>preposition_notation()</code> Builds a list of notation symbols that provides (by default) square brackets around the suffix with a preposition (&quot;prefix [preposition suffix]&quot;).
</p>
</li>
<li> <p><code>split_pref_suff()</code> Splits prefixes from suffixes, returning each in a list with names <code>pref</code> and <code>suff</code>.
If no prefix or suffix delimiters are found, <code>x</code> is returned in the <code>pref</code> item, unmodified,
and the <code>suff</code> item is returned as <code>""</code> (an empty string).
If there is no prefix, and empty string is returned for the <code>pref</code> item.
If there is no suffix, and empty string is returned for the <code>suff</code> item.
</p>
</li>
<li> <p><code>switch_notation()</code> Switches from one type of notation to another based on the <code>from</code> and <code>to</code> arguments.
Optionally, prefix and suffix can be <code>flip</code>ped.
</p>
</li></ul>

<p>Parts of a <code>notation</code> vector are
&quot;pref_start&quot;, &quot;pref_end&quot;, &quot;suff_start&quot;, and &quot;suff_end&quot;.
None of the strings in a notation vector are considered part of the prefix or suffix.
E.g., &quot;a -&gt; b&quot; in arrow notation means that &quot;a&quot; is the prefix and &quot;b&quot; is the suffix.
If <code>sep</code> only is specified for <code>notation_vec()</code> (default is &quot; -&gt; &quot;),
<code>pref_start</code>, <code>pref_end</code>, <code>suff_start</code>, and <code>suff_end</code> are
set appropriately.
</p>
<p>For functions where the <code>notation</code> argument is used to identify portions of the row or column label
(such as <code>split_pref_suff()</code>, <code>get_pref_suff()</code>,
and the <code>from</code> argument to <code>switch_notation()</code>),
(Note: <code>flip_pref_suff()</code> cannot infer notation, because it switches prefix and suffix in a known, single notation.)
if <code>notation</code> is a list, it is treated as a store from which
the most appropriate notation is inferred by <code>infer_notation(choose_most_specific = TRUE)</code>.
Because default is <code>RCLabels::notations_list</code>,
notation is inferred by default.
The argument <code>choose_most_specific</code> tells what to do when two <code>notation</code>s match a label:
if <code>TRUE</code> (the default), the notation with most characters is selected.
If <code>FALSE</code>, the first matching notation in <code>notation</code> will be selected.
See details at <code>infer_notation()</code>.
</p>
<p>If specifying more than one <code>notation</code>, be sure the notations are in a list.
<code>notation = c(RCLabels::bracket_notation, RCLabels::arrow_notation)</code>
is unlikely to produce the desired result, because the notations
are concatenated together to form a long string vector.
Rather say
<code>notation = list(RCLabels::bracket_notation, RCLabels::arrow_notation)</code>.
</p>
<p>For functions that construct labels (such as <code>paste_pref_suff()</code>),
<code>notation</code> can be a list of notations
over which the paste tasks is mapped.
If <code>notation</code> is a list, it must have as many items as
there are prefix/suffix pairs to be pasted.
</p>
<p>If either <code>pref</code> or <code>suff</code> are a zero-length character vector
(essentially an empty character vector
such as obtained from <code>character()</code>)
input to <code>paste_pref_suff()</code>,
an error is thrown.
Instead, use an empty character string
(such as obtained from <code>""</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>notation_vec(
  sep = " -&gt; ",
  pref_start = "",
  pref_end = "",
  suff_start = "",
  suff_end = ""
)

preposition_notation(preposition, suff_start = " [", suff_end = "]")

split_pref_suff(
  x,
  transpose = FALSE,
  inf_notation = TRUE,
  notation = RCLabels::notations_list,
  choose_most_specific = TRUE
)

paste_pref_suff(
  ps = list(pref = pref, suff = suff),
  pref = NULL,
  suff = NULL,
  notation = RCLabels::arrow_notation,
  squish = TRUE
)

flip_pref_suff(
  x,
  notation = RCLabels::notations_list,
  inf_notation = TRUE,
  choose_most_specific = TRUE
)

get_pref_suff(
  x,
  which = c("pref", "suff"),
  inf_notation = TRUE,
  notation = RCLabels::notations_list,
  choose_most_specific = TRUE
)

switch_notation(
  x,
  from = RCLabels::notations_list,
  to,
  flip = FALSE,
  inf_notation = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row-col-notation_+3A_sep">sep</code></td>
<td>
<p>A string separator between prefix and suffix. Default is &quot; -&gt; &quot;.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_pref_start">pref_start</code></td>
<td>
<p>A string indicating the start of a prefix. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_pref_end">pref_end</code></td>
<td>
<p>A string indicating the end of a prefix. Default is the value of <code>sep</code>.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_suff_start">suff_start</code></td>
<td>
<p>A string indicating the start of a suffix. Default is the value of <code>sep</code>.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_suff_end">suff_end</code></td>
<td>
<p>A string indicating the end of a suffix. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_preposition">preposition</code></td>
<td>
<p>A string used to indicate position for energy flows, typically &quot;from&quot; or &quot;to&quot; in different notations.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_x">x</code></td>
<td>
<p>A string or vector of strings to be operated upon.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_transpose">transpose</code></td>
<td>
<p>A boolean that tells whether to <code>purr::transpose()</code> the result.
Set <code>transpose = TRUE</code> when using <code>split_pref_suff()</code> in a <code>dplyr::mutate()</code>
call in the context of a data frame.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.
See <code>infer_notation()</code> for details.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_notation">notation</code></td>
<td>
<p>A notation vector generated by one of the <code style="white-space: pre;">&#8288;*_notation()&#8288;</code> functions, such as
<code>notation_vec()</code>, <code>arrow_notation</code>, or <code>bracket_notation</code>.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that tells whether to choose the most specific
notation from the <code>notation</code> argument when the <code>notation</code> argument is a list.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_ps">ps</code></td>
<td>
<p>A list of prefixes and suffixes in which each item of the list is itself a list with two items named <code>pref</code> and <code>suff</code>.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_pref">pref</code></td>
<td>
<p>A string or list of strings that are prefixes. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_suff">suff</code></td>
<td>
<p>A string of list of strings that are suffixes. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_squish">squish</code></td>
<td>
<p>A boolean that tells whether to remove extra spaces in the output of <code style="white-space: pre;">&#8288;paste_*()&#8288;</code> functions.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_which">which</code></td>
<td>
<p>Tells which to keep, the prefix (&quot;pref&quot;) or the suffix (&quot;suff&quot;).</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_from">from</code></td>
<td>
<p>The <code>notation</code> to switch <em>away from</em>.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_to">to</code></td>
<td>
<p>The <code>notation</code> to switch <em>to</em>.</p>
</td></tr>
<tr><td><code id="row-col-notation_+3A_flip">flip</code></td>
<td>
<p>A boolean that tells whether to also flip the notation. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>notation_vec()</code>, <code>arrow_notation</code>, and <code>bracket_notation</code>,
a string vector with named items <code>pref_start</code>, <code>pref_end</code>, <code>suff_start</code>, and <code>suff_end</code>;
For <code>split_pref_suff()</code>, a string list with named items <code>pref</code> and <code>suff</code>.
For <code>paste_pref_suff()</code>, <code>split_pref_suff()</code>, and <code>switch_notation()</code>,
a string list in notation format specified by various <code>notation</code> arguments, including
<code>from</code>, and <code>to</code>.
For <code>keep_pref_suff</code>, one of the prefix or suffix or a list of prefixes or suffixes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>notation_vec()
arrow_notation
bracket_notation
split_pref_suff("a -&gt; b", notation = arrow_notation)
# Or infer the notation (by default from notations_list)
split_pref_suff("a -&gt; b")
split_pref_suff(c("a -&gt; b", "c -&gt; d", "e -&gt; f"))
split_pref_suff(c("a -&gt; b", "c -&gt; d", "e -&gt; f"), transpose = TRUE)
flip_pref_suff("a [b]", notation = bracket_notation)
# Infer notation
flip_pref_suff("a [b]")
get_pref_suff("a -&gt; b", which = "suff")
switch_notation("a -&gt; b", from = arrow_notation, to = bracket_notation)
# Infer notation and flip prefix and suffix
switch_notation("a -&gt; b", to = bracket_notation, flip = TRUE)
# Also works for vectors
switch_notation(c("a -&gt; b", "c -&gt; d"),
                from = arrow_notation,
                to = bracket_notation)
# Functions can infer the correct notation and return multiple matches
infer_notation("a [to b]",
               allow_multiple = TRUE,
               choose_most_specific = FALSE)
# Or choose the most specific notation
infer_notation("a [to b]",
               allow_multiple = TRUE,
               choose_most_specific = TRUE)
# When setting the from notation, only that type of notation will be switched
switch_notation(c("a -&gt; b", "c [to d]"),
                from = arrow_notation,
                to = bracket_notation)
# But if notations are inferred, all notations can be switched
switch_notation(c("a -&gt; b", "c [to d]"), to = bracket_notation)
# A double-switch can be accomplished.
# In this first example, `RCLabels::first_dot_notation` is inferred.
switch_notation("a.b.c", to = arrow_notation)
# In this second example,
# it is easier to specify the `from` and `to` notations.
switch_notation("a.b.c", to = arrow_notation) %&gt;%
  switch_notation(from = first_dot_notation, to = arrow_notation)
# "" can be used as an input
paste_pref_suff(pref = "a", suff = "", notation = RCLabels::from_notation)
</code></pre>

<hr>
<h2 id='split_noun_pp'>Split row and column labels into nouns and prepositional phrases</h2><span id='topic+split_noun_pp'></span>

<h3>Description</h3>

<p>This function is similar to <code>split_pref_suff()</code> in that it returns a list.
However, this function's list is more detailed than
<code>split_pref_suff()</code>.
The return value from this function is a list
with the first named item being the prefix (with the name <code>noun</code>)
followed by objects of prepositional phrases
(with names being prepositions that precede the objects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_noun_pp(
  labels,
  inf_notation = TRUE,
  notation = RCLabels::notations_list,
  choose_most_specific = FALSE,
  prepositions = RCLabels::prepositions_list
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_noun_pp_+3A_labels">labels</code></td>
<td>
<p>The row and column labels from which prepositional phrases are to be extracted.</p>
</td></tr>
<tr><td><code id="split_noun_pp_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.
See <code>infer_notation()</code> for details.</p>
</td></tr>
<tr><td><code id="split_noun_pp_+3A_notation">notation</code></td>
<td>
<p>The notation type to be used when extracting prepositions.
Default is <code>RCLabels::notations_list</code>, meaning that
the notation is inferred using <code>infer_notation()</code>.</p>
</td></tr>
<tr><td><code id="split_noun_pp_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that tells whether to choose the most specific
notation from <code>notation</code> when inferring notation.
Default is <code>FALSE</code> so that a less specific notation can be
inferred.
In combination with <code>RCLabels::notations_list</code>,
the default value of <code>FALSE</code> means that
<code>RCLabels::bracket_notation</code> will be selected instead of
anything more specific, such as
<code>RCLabels::from_notation</code>.</p>
</td></tr>
<tr><td><code id="split_noun_pp_+3A_prepositions">prepositions</code></td>
<td>
<p>A vector of strings to be treated as prepositions.
Note that a space is appended to each word internally,
so, e.g., &quot;to&quot; becomes &quot;to &quot;.
Default is <code>RCLabels::prepositions_list</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code>split_pref_suff()</code>, it does not make sense to have a <code>transpose</code>
argument on <code>split_noun_pp()</code>.
Labels may not have the same structure,
e.g., they may have different prepositions.
</p>


<h3>Value</h3>

<p>A list of lists with items named <code>noun</code> and <code>pp</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Specify the notation
split_noun_pp(c("a [of b in c]", "d [of e into f]"),
              notation = bracket_notation)
# Infer the notation via default arguments
split_noun_pp(c("a [of b in c]", "d [of e into f]"))
</code></pre>

<hr>
<h2 id='strip_label_part'>A convenience function to help splitting prefixes and suffixes</h2><span id='topic+strip_label_part'></span>

<h3>Description</h3>

<p>This function should only ever see a single label (<code>x</code>)
and a single <code>notation</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_label_part(x, notation, part, pattern_pref = "", pattern_suff = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip_label_part_+3A_x">x</code></td>
<td>
<p>The label(s) to be split.</p>
</td></tr>
<tr><td><code id="strip_label_part_+3A_notation">notation</code></td>
<td>
<p>The notations to be used for each <code>x</code>.</p>
</td></tr>
<tr><td><code id="strip_label_part_+3A_part">part</code></td>
<td>
<p>The part of the label to work on, such as &quot;pref_start&quot;, &quot;pref_end&quot;, &quot;suff_start&quot;, or &quot;suff_end&quot;.</p>
</td></tr>
<tr><td><code id="strip_label_part_+3A_pattern_pref">pattern_pref</code></td>
<td>
<p>The prefix to a regex pattern to be used in <code>gsub()</code>.</p>
</td></tr>
<tr><td><code id="strip_label_part_+3A_pattern_suff">pattern_suff</code></td>
<td>
<p>The suffix to a regex pattern to be used in <code>gsub()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>notation</code> is <code>NULL</code>, <code>x</code> is returned, unmodified.
</p>


<h3>Value</h3>

<p>A label shorn of the part to be stripped.
</p>

<hr>
<h2 id='to_notation'>To notation</h2><span id='topic+to_notation'></span>

<h3>Description</h3>

<p>A description of to notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_notation
</code></pre>


<h3>Format</h3>

<p>A vector of notational symbols that provides to (&quot;a [to b]&quot;) notation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to_notation
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
