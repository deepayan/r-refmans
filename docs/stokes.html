<!DOCTYPE html><html><head><title>Help for package stokes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stokes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Alt'><p>Alternating multilinear forms</p></a></li>
<li><a href='#as.1form'><p>Coerce vectors to 1-forms</p></a></li>
<li><a href='#coeffs'><p>Extract and manipulate coefficients</p></a></li>
<li><a href='#consolidate'><p>Various low-level helper functions</p></a></li>
<li><a href='#contract'><p>Contractions of <code class="reqn">k</code>-forms</p></a></li>
<li><a href='#dovs'><p>Dimension of the underlying vector space</p></a></li>
<li><a href='#dx'><p>Elementary forms in three-dimensional space</p></a></li>
<li><a href='#ex'><p>Basis vectors in three-dimensional space</p></a></li>
<li><a href='#hodge'><p>Hodge star operator</p></a></li>
<li><a href='#inner'><p>Inner product operator</p></a></li>
<li><a href='#issmall'><p>Is a form zero to within numerical precision?</p></a></li>
<li><a href='#keep'><p>Keep or drop variables</p></a></li>
<li><a href='#kform'><p>k-forms</p></a></li>
<li><a href='#kinner'><p>Inner product of two kforms</p></a></li>
<li><a href='#ktensor'><p>k-tensors</p></a></li>
<li><a href='#Ops.kform'><p>Arithmetic Ops Group Methods for <code>kform</code> and <code>ktensor</code></p>
objects</a></li>
<li><a href='#print.stokes'><p>Print methods for <code class="reqn">k</code>-tensors and <code class="reqn">k</code>-forms</p></a></li>
<li><a href='#rform'><p>Random kforms and ktensors</p></a></li>
<li><a href='#scalar'><p>Scalars and losing attributes</p></a></li>
<li><a href='#stokes-package'>
<p>The Exterior Calculus</p></a></li>
<li><a href='#summary.stokes'><p>Summaries of tensors and alternating forms</p></a></li>
<li><a href='#symbolic'><p>Symbolic form</p></a></li>
<li><a href='#tensorprod'><p>Tensor products of <code class="reqn">k</code>-tensors</p></a></li>
<li><a href='#transform'><p>Linear transforms of <code class="reqn">k</code>-forms</p></a></li>
<li><a href='#vector_cross_product'><p>The Vector cross product</p></a></li>
<li><a href='#volume'><p>The volume element</p></a></li>
<li><a href='#wedge'><p>Wedge products</p></a></li>
<li><a href='#zap'><p>Zap small values in <code class="reqn">k</code>-forms and <code class="reqn">k</code>-tensors</p></a></li>
<li><a href='#zero'><p>Zero tensors and zero forms</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Exterior Calculus</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, Deriv, testthat, markdown, rmarkdown, emulator,
magrittr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>permutations (&ge; 1.1-2), partitions, methods, mathjaxr,
disordR (&ge; 0.9-7), spray (&ge; 1.0-24)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality for working with tensors, alternating
           forms, wedge products, Stokes's theorem, and related concepts
	   from the exterior calculus.   Uses 'disordR' discipline
	   (Hankin, 2022, &lt;<a href="https://doi.org/10.48550%2FARXIV.2210.03856">doi:10.48550/ARXIV.2210.03856</a>&gt;).  The
	   canonical reference would be M. Spivak
	   (1965, ISBN:0-8053-9021-9) "Calculus on Manifolds".  To cite
	   the package in publications please use Hankin (2022)
           &lt;<a href="https://doi.org/10.48550%2FARXIV.2210.17008">doi:10.48550/ARXIV.2210.17008</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/stokes">https://github.com/RobinHankin/stokes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/stokes/issues">https://github.com/RobinHankin/stokes/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-18 22:29:40 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Alt'>Alternating multilinear forms</h2><span id='topic+Alt'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Converts a \(k\)-tensor to alternating form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Alt(S,give_kform)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Alt_+3A_s">S</code></td>
<td>
<p>A multilinear form, an object of class <code>ktensor</code></p>
</td></tr>
<tr><td><code id="Alt_+3A_give_kform">give_kform</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return
an alternating \(k\)-tensor [that is, an object of class
<code>ktensor</code> that happens to be alternating] and <code>TRUE</code>
meaning to return a \(k\)-form [that is, an object of class
<code>kform</code>]</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Given a \(k\)-tensor \(T\), we have
</p>
\[\mathrm{Alt}(T)\left(v_1,\ldots,v_k\right)=
    \frac{1}{k!}\sum_{\sigma\in S_k}\mathrm{sgn}(\sigma)\cdot
    T\left(v_{\sigma(1)},\ldots,v_{\sigma(k)}\right)
  \]
<p>Thus for example if \(k=3\):
</p>
\[\mathrm{Alt}(T)\left(v_1,v_2,v_3\right)=
      \frac{1}{6}\left(\begin{array}{c}
      +T\left(v_1,v_2,v_3\right)\quad
      -T\left(v_1,v_3,v_2\right)\cr
      -T\left(v_2,v_1,v_3\right)\quad
      +T\left(v_2,v_3,v_1\right)\cr
      +T\left(v_3,v_1,v_2\right)\quad
      -T\left(v_3,v_2,v_1\right)
      \end{array}
      \right)
    \]
<p>and it is reasonably easy to see that \(\mathrm{Alt}(T)\)
is alternating, in the sense that
</p>
\[\mathrm{Alt}(T)\left(v_1,\ldots,v_i,\ldots,v_j,\ldots,v_k\right)=
    -\mathrm{Alt}(T)\left(v_1,\ldots,v_j,\ldots,v_i,\ldots,v_k\right)
  \]
<p>Function <code>Alt()</code> is intended to take and return an object of
class <code>ktensor</code>; but if given a <code>kform</code> object, it just
returns its argument unchanged.
</p>
<p>A short vignette is provided with the package: type
<code>vignette("Alt")</code> at the commandline.
</p>


<h3>Value</h3>

<p>Returns an alternating \(k\)-tensor.  To work with \(k\)-forms,
which are a much more efficient representation of alternating tensors,
use <code>as.kform()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+kform">kform</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

(X &lt;- ktensor(spray(rbind(1:3),6)))
Alt(X)
Alt(X,give_kform=TRUE)

S &lt;- as.ktensor(expand.grid(1:3,1:3),rnorm(9))
S
Alt(S)

issmall(Alt(S) - Alt(Alt(S)))  # should be TRUE; Alt() is idempotent

a &lt;- rtensor()
V &lt;- matrix(rnorm(21),ncol=3)
LHS &lt;- as.function(Alt(a))(V)
RHS &lt;- as.function(Alt(a,give_kform=TRUE))(V)
c(LHS=LHS,RHS=RHS,diff=LHS-RHS)

</code></pre>

<hr>
<h2 id='as.1form'>Coerce vectors to 1-forms</h2><span id='topic+as.1form'></span><span id='topic+grad'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Given a vector, return the corresponding 1-form; the exterior
derivative of a 0-form (that is, a scalar function).  Function
<code>grad()</code> is a synonym.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.1form(v)
grad(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.1form_+3A_v">v</code></td>
<td>
<p>A vector with element \(i\) being \(\partial f/\partial
      x_i\)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exterior derivative of a \(k\)-form \(\phi\) is a
\((k+1)\)-form \(\mathbf{d}\phi\) given by
</p>
\[
  \mathbf{d}\phi
  \left(
  P_\mathbf{x}\left(\mathbf{v}_i,\ldots,\mathbf{v}_{k+1}\right)
  \right)
  =
  \lim_{h\longrightarrow 0}\frac{1}{h^{k+1}}\int_{\partial
  P_\mathbf{x}\left(h\mathbf{v}_1,\ldots,h\mathbf{v}_{k+1}\right)}\phi
  \]
<p>We can use the facts that
</p>
\[
    \mathbf{d}\left(f\,dx_{i_1}\wedge\cdots\wedge dx_{i_k}\right)=
    \mathbf{d}f\wedge dx_{i_1}\wedge\cdots\wedge dx_{i_k}
  \]
<p>and
\[
    \mathbf{d}f=\sum_{j=1}^n\left(D_j f\right)\,dx_j
  \]
</p>
<p>to calculate differentials  of general \(k\)-forms. Specifically, if
</p>
\[
    \phi=\sum_{1\leq i_i < \cdots < i_k\leq n} a_{i_1\ldots
      i_k}dx_{i_1}\wedge\cdots\wedge dx_{i_k}
  \]
<p>then
\[
    \mathbf{d}\phi=
    \sum_{1\leq i_i < \cdots < i_k\leq n}
    [\sum_{j=1}^nD_ja_{i_1\ldots i_k}dx_j]\wedge dx_{i_1}\wedge\cdots\wedge dx_{i_k.}
  \]
</p>
<p>The entry in square brackets is given by <code>grad()</code>.  See the
examples for appropriate <span class="rlang"><b>R</b></span> idiom.
</p>


<h3>Value</h3>

<p>A one-form</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+kform">kform</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.1form(1:9)  # note ordering of terms


as.1form(rnorm(20))

grad(c(4,7)) ^ grad(1:4)




</code></pre>

<hr>
<h2 id='coeffs'>Extract and manipulate coefficients</h2><span id='topic+coeffs'></span><span id='topic+coeff'></span><span id='topic+coeffs+3C-'></span><span id='topic+coeffs+3C-.spray'></span><span id='topic+coeffs.ktensor'></span><span id='topic+coeffs.kform'></span><span id='topic+coeffs+3C-.ktensor'></span><span id='topic+coeffs+3C-.kform'></span><span id='topic+coeffs+2Cktensor-method'></span><span id='topic+coeffs+2Ckform-method'></span><span id='topic+value+3C-'></span><span id='topic+coeffs+3C-+2Cktensor-method'></span><span id='topic+coeffs+3C-+2Ckform-method'></span><span id='topic+spray'></span><span id='topic+as.spray'></span><span id='topic+nterms'></span>

<h3>Description</h3>

<p>Extract and manipulate coefficients of ktensor and kform objects;
this using the methods of the <a href="https://CRAN.R-project.org/package=spray"><span class="pkg">spray</span></a> package.
</p>
<p>Functions <code>as.spray()</code> and <code>nterms()</code> are imoported from
<a href="https://CRAN.R-project.org/package=spray"><span class="pkg">spray</span></a>.
</p>


<h3>Details</h3>

<p>To see the coefficients of a <code>kform</code> or <code>ktensor</code> object,
use <code>coeffs()</code>, which returns a <code>disord</code> object (this is
actually <code>spray::coeffs()</code>).  Replacement methods also use the
methods of the <a href="https://CRAN.R-project.org/package=spray"><span class="pkg">spray</span></a> package.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>(a &lt;- kform_general(5,2,1:10))
coeffs(a) # a disord object
coeffs(a)[coeffs(a)%%2==1] &lt;- 100  # replace every odd coeff with 100
a

coeffs(a*0)
</code></pre>

<hr>
<h2 id='consolidate'>Various low-level helper functions</h2><span id='topic+consolidate'></span><span id='topic+lose_repeats'></span><span id='topic+kill_trivial_rows'></span><span id='topic+include_perms'></span><span id='topic+kform_to_ktensor'></span>

<h3>Description</h3>

<p>Various low-level helper functions used in <code>Alt()</code> and
<code>kform()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consolidate(S)
kill_trivial_rows(S)
include_perms(S)
kform_to_ktensor(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consolidate_+3A_s">S</code></td>
<td>
<p>Object of class <code>spray</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Low-level helper functions.
</p>

<ul>
<li><p> Function <code>consolidate()</code> takes a spray object, and
combines any rows that are identical up to a permutation, respecting
the sign of the permutation
</p>
</li>
<li><p> Function <code>kill_trivial_rows()</code> takes a spray object and
deletes any rows with a repeated entry (which have \(k\)-forms
identically zero)
</p>
</li>
<li><p> Function <code>include_perms()</code> replaces each row of a
<code>spray</code> object with all its permutations, respecting the sign
of the permutation
</p>
</li>
<li><p> Function <code>ktensor_to_kform()</code> coerces a \(k\)-form
to a \(k\)-tensor
</p>
</li></ul>



<h3>Value</h3>

<p>The functions documented here all return a <code>spray</code> object.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ktensor">ktensor</a></code>,<code><a href="#topic+kform">kform</a></code>,<code><a href="#topic+Alt">Alt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
(S &lt;- spray(matrix(c(1,1,2,2,1,3,3,1,3,5),ncol=2,byrow=TRUE),1:5))

kill_trivial_rows(S)  # (rows 1 and 3 killed, repeated entries)
consolidate(S)        # (merges rows 2 and 4)
include_perms(S)      # returns a spray object, not alternating tensor.

</code></pre>

<hr>
<h2 id='contract'>Contractions of <i>k</i>-forms</h2><span id='topic+contract'></span><span id='topic+contract_elementary'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>A contraction is a natural linear map from \(k\)-forms to \(k-1\)-forms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contract(K,v,lose=TRUE)
contract_elementary(o,v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contract_+3A_k">K</code></td>
<td>
<p>A \(k\)-form</p>
</td></tr>
<tr><td><code id="contract_+3A_o">o</code></td>
<td>
<p>Integer-valued vector corresponding to one row of an index
matrix</p>
</td></tr>
<tr><td><code id="contract_+3A_lose">lose</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to coerce a
\(0\)-form to a scalar and <code>FALSE</code> meaning to return the
formal \(0\)-form</p>
</td></tr>
<tr><td><code id="contract_+3A_v">v</code></td>
<td>
<p>A vector; in function <code>contract()</code>, if a matrix,
interpret each column as a vector to contract with</p>
</td></tr>
</table>


<h3>Details</h3>

  
<p>Given a \(k\)-form \(\phi\) and a vector \(\mathbf{v}\),
the <dfn>contraction</dfn> \(\phi_\mathbf{v}\) of \(\phi\)
and \(\mathbf{v}\) is a \(k-1\)-form with
</p>
\[
  \phi_\mathbf{v}\left(\mathbf{v}^1,\ldots,\mathbf{v}^{k-1}\right) =
  \phi\left(\mathbf{v},\mathbf{v}^1,\ldots,\mathbf{v}^{k-1}\right)
  \]
<p>provided \(k>1\); if \(k=1\) we specify
\(\phi_\mathbf{v}=\phi(\mathbf{v})\).
</p>
<p>Function <code>contract_elementary()</code> is a low-level helper function
that translates elementary \(k\)-forms with coefficient 1 (in the form
of an integer vector corresponding to one row of an index matrix) into
its contraction with \(\mathbf{v}\).
</p>
<p>There is an extensive vignette in the package,
<code>vignette("contract")</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>kform</code>.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Steven H. Weintraub 2014. &ldquo;Differential forms: theory and
practice&rdquo;, Elsevier (Definition 2.2.23, chapter 2, page 77).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wedge">wedge</a></code>,<code><a href="#topic+lose">lose</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>contract(as.kform(1:5),1:8)
contract(as.kform(1),3)   # 0-form



contract_elementary(c(1,2,5),c(1,2,10,11,71))


## Now some verification [takes ~10s to run]:
#o &lt;- kform(spray(t(replicate(2, sample(9,4))), runif(2)))
#V &lt;- matrix(rnorm(36),ncol=4)
#jj &lt;- c(
#   as.function(o)(V),
#   as.function(contract(o,V[,1,drop=TRUE]))(V[,-1]), # scalar
#   as.function(contract(o,V[,1:2]))(V[,-(1:2),drop=FALSE]),
#   as.function(contract(o,V[,1:3]))(V[,-(1:3),drop=FALSE]),
#   as.function(contract(o,V[,1:4],lose=FALSE))(V[,-(1:4),drop=FALSE])
#)

#print(jj)
#max(jj) - min(jj) # zero to numerical precision

</code></pre>

<hr>
<h2 id='dovs'>Dimension of the underlying vector space</h2><span id='topic+dovs'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>A \(k\)-form \(\omega\in\Lambda^k(V)\) maps
\(V^k\) to the reals, where \(V=\mathcal{R}^n\).
Function <code>dovs()</code> returns \(n\), the dimensionality of the
underlying vector space.  The function itself is almost trivial,
returning the maximum of the index matrix.
</p>
<p>Special dispensation is given for zero-forms and zero tensors, which
return zero.
</p>
<p>Vignette <code>dovs</code> provides more discussion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dovs(K)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dovs_+3A_k">K</code></td>
<td>
<p>A \(k\)-form or \(k\)-tensor</p>
</td></tr></table>


<h3>Value</h3>

<p>Returns a non-negative integer</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>dovs(rform())

table(replicate(20,dovs(rform(3))))  

</code></pre>

<hr>
<h2 id='dx'>Elementary forms in three-dimensional space</h2><span id='topic+dx'></span><span id='topic+dy'></span><span id='topic+dz'></span>

<h3>Description</h3>

<p>Objects <code>dx</code>, <code>dy</code> and <code>dz</code> are the three elementary
one-forms on three-dimensional space.  These objects can be generated by
running script &lsquo;<span class="file">vignettes/dx.Rmd</span>&rsquo;, which includes some further
discussion and technical documentation and creates file &lsquo;<span class="file">dx.rda</span>&rsquo;
which resides in the <code>data/</code> directory.
</p>
<p>The default print method is a little opaque for these objects.  To print
them more intuitively, use
</p>
<pre>options(kform_symbolic_print = "dx")</pre>
<p>which is documented at <code>print.Rd</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dx)</code></pre>


<h3>Details</h3>

<p>See vignettes <code>dx</code> and <code>exeyez</code> for an extended
discussion; a use-case is given in <code>vector_cross_product</code>.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<ul>
<li><p> M. Spivak 1971. <em>Calculus on manifolds</em>,
Addison-Wesley</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+d">d</a></code>,<code><a href="#topic+print.kform">print.kform</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
dx
hodge(dx)
hodge(dx,3)


dx  # default print method, not particularly intelligible
options(kform_symbolic_print = 'dx')  # shows dx dy dz
dx
dx^dz
hodge(dx,3)

as.function(dx)(ex)


options(kform_symbolic_print = NULL)  # revert to default


</code></pre>

<hr>
<h2 id='ex'>Basis vectors in three-dimensional space</h2><span id='topic+ex'></span><span id='topic+ey'></span><span id='topic+ez'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Objects <code>ex</code>, <code>ey</code> and <code>ez</code> are the three elementary
one-forms on three-dimensional space, sometimes denoted
\((e_x,e_y,e_z)\).  These objects can be generated by running
script &lsquo;<span class="file">vignettes/ex.Rmd</span>&rsquo;, which includes some further discussion
and technical documentation and creates file &lsquo;<span class="file">exeyez.rda</span>&rsquo; which
resides in the <code>data/</code> directory.
</p>


<h3>Details</h3>

<p>See vignettes <code>dx</code> and <code>exeyez</code> for an extended
discussion; a use-case is given in <code>vector_cross_product</code>.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<ul>
<li><p> M. Spivak 1971. <em>Calculus on manifolds</em>,
Addison-Wesley</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+d">d</a></code>,<code><a href="#topic+print.kform">print.kform</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.function(dx)(ex)

(X &lt;- as.kform(matrix(1:12,nrow=4),c(1,2,7,11)))
as.function(X)(cbind(e(2,12),e(6,12),e(10,12)))

</code></pre>

<hr>
<h2 id='hodge'>Hodge star operator</h2><span id='topic+hodge'></span><span id='topic+Hodge'></span><span id='topic+star'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Given a \(k\)-form, return its Hodge dual</p>


<h3>Usage</h3>

<pre><code class='language-R'>hodge(K, n=dovs(K), g, lose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hodge_+3A_k">K</code></td>
<td>
<p>Object of class <code>kform</code></p>
</td></tr>
<tr><td><code id="hodge_+3A_n">n</code></td>
<td>
<p>Dimensionality of space, defaulting the the largest element
of the index</p>
</td></tr>
<tr><td><code id="hodge_+3A_g">g</code></td>
<td>
<p>Diagonal of the metric tensor, with missing default being the
standard metric of the identity matrix.  Currently, only entries of
\(\pm 1\) are accepted</p>
</td></tr>
<tr><td><code id="hodge_+3A_lose">lose</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to coerce to a
scalar if appropriate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Given a \(k\)-form, in an \(n\)-dimensional space,
return a \((n-k)\)-form.</p>


<h3>Note</h3>

<p>Most authors write the Hodge dual of \(\psi\) as
\(*\psi\) or \(\star\psi\), but Weintraub
uses \(\psi *\).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+wedge">wedge</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

(o &lt;- kform_general(5,2,1:10))
hodge(o)
o == hodge(hodge(o))

Faraday &lt;- kform_general(4,2,runif(6)) # Faraday electromagnetic tensor
mink &lt;- c(-1,1,1,1)  # Minkowski metric
hodge(Faraday,g=mink)

Faraday  == Faraday |&gt;
      hodge(g=mink) |&gt;
      hodge(g=mink) |&gt;
      hodge(g=mink) |&gt;
      hodge(g=mink)

hodge(dx,3) == dy^dz


## Some edge-cases:
hodge(scalar(1),2)
hodge(zeroform(5),9)
hodge(volume(5))
hodge(volume(5),lose=TRUE)
hodge(scalar(7),n=9)



</code></pre>

<hr>
<h2 id='inner'>Inner product operator</h2><span id='topic+inner'></span><span id='topic+inner_product'></span><span id='topic+inner.product'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The inner product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner(M)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inner_+3A_m">M</code></td>
<td>
<p>square matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inner product of two vectors \(\mathbf{x}\) and
\(\mathbf{y}\) is usually written
\(\left\langle\mathbf{x},\mathbf{y}\right\rangle\) or
\(\mathbf{x}\cdot\mathbf{y}\), but the most general form would
be \(\mathbf{x}^TM\mathbf{y}\) where \(M\) is a matrix.
Noting that inner products are multilinear, that is
\(\left\langle\mathbf{x},a\mathbf{y}+b\mathbf{z}\right\rangle=a\left\langle\mathbf{x},\mathbf{y}\right\rangle+b\left\langle\mathbf{x},\mathbf{z}\right\rangle\)
and \(\left\langle
a\mathbf{x}+b\mathbf{y},\mathbf{z}\right\rangle=a\left\langle\mathbf{x},\mathbf{z}\right\rangle+b\left\langle\mathbf{y},\mathbf{z}\right\rangle\),
we see that the inner product is indeed a multilinear map, that is, a
tensor.
</p>
<p>Given a square matrix \(M\), function <code>inner(M)</code> returns the
\(2\)-form that maps \(\mathbf{x},\mathbf{y}\) to
\(\mathbf{x}^TM\mathbf{y}\).  Non-square matrices are
effectively padded with zeros.
</p>
<p>A short vignette is provided with the package: type
<code>vignette("inner")</code> at the commandline.
</p>


<h3>Value</h3>

<p>Returns a \(k\)-tensor, an inner product</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+kform">kform</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
inner(diag(7))
inner(matrix(1:9,3,3))

## Compare the following two:
Alt(inner(matrix(1:9,3,3)))      # An alternating k tensor
as.kform(inner(matrix(1:9,3,3))) # Same thing coerced to a kform

f &lt;- as.function(inner(diag(7)))
X &lt;- matrix(rnorm(14),ncol=2)  # random element of (R^7)^2
f(X) - sum(X[,1]*X[,2]) # zero to numerical precision

## verify positive-definiteness:
g &lt;- as.function(inner(crossprod(matrix(rnorm(56),8,7))))
stopifnot(g(kronecker(rnorm(7),t(c(1,1))))&gt;0)

</code></pre>

<hr>
<h2 id='issmall'>Is a form zero to within numerical precision?</h2><span id='topic+issmall'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Given a \(k\)-form, return <code>TRUE</code> if it is &ldquo;small&rdquo;</p>


<h3>Usage</h3>

<pre><code class='language-R'>issmall(M, tol=1e-8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="issmall_+3A_m">M</code></td>
<td>
<p>Object of class <code>kform</code> or <code>ktensor</code></p>
</td></tr>
<tr><td><code id="issmall_+3A_tol">tol</code></td>
<td>
<p>Small tolerance, defaulting to <code>1e-8</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a logical</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
o &lt;- kform_general(3,2,runif(3))
M &lt;- matrix(rnorm(9),3,3)

discrepancy &lt;- o - pullback(pullback(o,M),solve(M))

discrepancy # print method might imply coefficents are zeros

issmall(discrepancy)  # should be TRUE
is.zero(discrepancy)  # might be FALSE
</code></pre>

<hr>
<h2 id='keep'>Keep or drop variables</h2><span id='topic+keep'></span><span id='topic+discard'></span><span id='topic+retain'></span><span id='topic+drop.free'></span>

<h3>Description</h3>

<p>Keep or drop variables</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep(K, yes)
discard(K, no)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keep_+3A_k">K</code></td>
<td>
<p>Object of class <code>kform</code></p>
</td></tr>
<tr><td><code id="keep_+3A_yes">yes</code>, <code id="keep_+3A_no">no</code></td>
<td>
<p>Specification of dimensions to either keep (yes) or discard 
(no), coerced to a free object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>keep(omega,yes)</code> keeps the terms specified and
<code>discard(omega,no)</code> discards the terms specified.  It is not clear
to me what these functions mean from a mathematical perspective.
</p>


<h3>Value</h3>

<p>The functions documented here all return a <code>kform</code> object.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+lose">lose</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
(o &lt;- kform_general(7,3,seq_len(choose(7,3))))
keep(o,1:4)   # keeps only terms with dimensions 1-4
discard(o,1:2)  # loses any term with a "1" in the index

</code></pre>

<hr>
<h2 id='kform'>k-forms</h2><span id='topic+kform'></span><span id='topic+as.kform'></span><span id='topic+is.kform'></span><span id='topic+is.form'></span><span id='topic+kform_basis'></span><span id='topic+as.function.kform'></span><span id='topic+kform_general'></span><span id='topic+general_kform'></span><span id='topic+d'></span><span id='topic+e'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Functionality for dealing with \(k\)-forms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kform(S)
as.kform(M,coeffs,lose=TRUE)
kform_basis(n, k)
kform_general(W,k,coeffs,lose=TRUE)
is.kform(x)
d(i)
e(i,n)
## S3 method for class 'kform'
as.function(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kform_+3A_n">n</code></td>
<td>
<p>Dimension of the vector space \(V=R^n\)</p>
</td></tr>
<tr><td><code id="kform_+3A_i">i</code></td>
<td>
<p>Integer</p>
</td></tr>
<tr><td><code id="kform_+3A_k">k</code></td>
<td>
<p>A \(k\)-form maps \(V^k\) to \(R\)</p>
</td></tr>
<tr><td><code id="kform_+3A_w">W</code></td>
<td>
<p>Integer vector of dimensions</p>
</td></tr>
<tr><td><code id="kform_+3A_m">M</code>, <code id="kform_+3A_coeffs">coeffs</code></td>
<td>
<p>Index matrix and coefficients for a \(k\)-form</p>
</td></tr>
<tr><td><code id="kform_+3A_s">S</code></td>
<td>
<p>Object of class <code>spray</code></p>
</td></tr>
<tr><td><code id="kform_+3A_lose">lose</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to coerce a
\(0\)-form to a scalar and <code>FALSE</code> meaning to return the
formal \(0\)-form</p>
</td></tr>
<tr><td><code id="kform_+3A_x">x</code></td>
<td>
<p>Object of class <code>kform</code></p>
</td></tr>
<tr><td><code id="kform_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <dfn>\(k\)-form</dfn> is an alternating \(k\)-tensor.  In the
package, \(k\)-forms are represented as sparse arrays
(<code>spray</code> objects), but with a class of <code>c("kform",
  "spray")</code>.  The constructor function <code>kform()</code> takes a
<code>spray</code> object and returns a <code>kform</code> object: it ensures that
rows of the index matrix are strictly nonnegative integers, have no
repeated entries, and are strictly increasing.  Function
<code>as.kform()</code> is more user-friendly.
</p>

<ul>
<li><p><code>kform()</code> is the constructor function.  It takes a
<code>spray</code> object and returns a <code>kform</code>.
</p>
</li>
<li><p><code>as.kform()</code> also returns a <code>kform</code> but is a bit more
user-friendly  than <code>kform()</code>.
</p>
</li>
<li><p><code>kform_basis()</code> is a low-level helper function that 
returns a matrix whose rows constitute a basis for the vector space
\(\Lambda^k(R^n)\) of \(k\)-forms.
</p>
</li>
<li><p><code>kform_general()</code> returns a <code>kform</code> object with terms
that span the space of alternating tensors.
</p>
</li>
<li><p><code>is.kform()</code> returns <code>TRUE</code> if its argument is a
<code>kform</code> object.
</p>
</li>
<li><p><code>d()</code> is an easily-typed synonym for
<code>as.kform()</code>.  The idea is that <code>d(1) = dx</code>,
<code>d(2)=dy</code>, <code>d(5)=dx^5</code>, etc.  Also note that, for
example, <code>d(1:3)=dx^dy^dz</code>, the volume form.
</p>
</li></ul>

<p>Recall that a \(k\)-tensor is a multilinear map from \(V^k\) to
the reals, where \(V=R^n\) is a vector space.  A multilinear
\(k\)-tensor \(T\) is <dfn>alternating</dfn> if it satisfies
</p>
\[T\left(v_1,\ldots,v_i,\ldots,v_j,\ldots,v_k\right)=
    -T\left(v_1,\ldots,v_j,\ldots,v_i,\ldots,v_k\right)
  \]
<p>In the package, an object of class <code>kform</code> is an efficient
representation of an alternating tensor.
</p>
<p>Function <code>kform_basis()</code> is a low-level helper function that
returns a matrix whose rows constitute a basis for the vector space
\(\Lambda^k(R^n)\) of \(k\)-forms:
</p>
\[\phi=\sum_{1\leq i_1 < \cdots < i_k\leq n} a_{i_1\ldots i_k}dx_{i_1}\wedge\cdots\wedge dx_{i_k}\]
<p>and indeed we have:
</p>
\[a_{i_1\ldots i_k}=\phi\left(\mathbf{e}_{i_1},\ldots,\mathbf{e}_{i_k}\right)
  \]
<p>where \(\mathbf{e}_j,1\leq j\leq k\) is a basis for
\(V\).
</p>


<h3>Value</h3>

<p>All functions documented here return a <code>kform</code> object except
<code>as.function.kform()</code>, which returns a function, and
<code>is.kform()</code>, which returns a Boolean, and <code>e()</code>, which
returns a conjugate basis to that of <code>d()</code>.
</p>


<h3>Note</h3>

<p>Hubbard and Hubbard use the term &ldquo;\(k\)-form&rdquo;, but Spivak
does not.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Hubbard and Hubbard; Spivak</p>


<h3>See Also</h3>

<p><code><a href="#topic+ktensor">ktensor</a></code>,<code><a href="#topic+lose">lose</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.kform(cbind(1:5,2:6),rnorm(5))
kform_general(1:4,2,coeffs=1:6)  # used in electromagnetism

K1 &lt;- as.kform(cbind(1:5,2:6),rnorm(5))
K2 &lt;- kform_general(5:8,2,1:6)
K1^K2  # or wedge(K1,K2)

d(1:3)
dx^dy^dz   # same thing

d(sample(9)) # coeff is +/-1 depending on even/odd permutation of 1:9

f &lt;- as.function(wedge(K1,K2))
E &lt;- matrix(rnorm(32),8,4)
f(E) + f(E[,c(1,3,2,4)])  # should be zero by alternating property

options(kform_symbolic_print = 'd')
(d(5)+d(7)) ^ (d(2)^d(5) + 6*d(4)^d(7))
options(kform_symbolic_print = NULL)  # revert to default

</code></pre>

<hr>
<h2 id='kinner'>Inner product of two kforms</h2><span id='topic+kinner'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Given two \(k\)-forms \(\alpha\) and \(\beta\),
return the inner product
\(\left\langle\alpha,\beta\right\rangle\).  Here our
underlying vector space \(V\) is \(\mathcal{R}^n\).
</p>
<p>The inner product is a symmetric bilinear form defined in two stages.
First, we specify its behaviour on decomposable \(k\)-forms
\(\alpha=\alpha_1\wedge\cdots\wedge\alpha_k\) and
\(\beta=\beta_1\wedge\cdots\wedge\beta_k\) as
</p>
\[
    \left\langle\alpha,\beta\right\rangle=\det\left(
    \left\langle\alpha_i,\beta_j\right\rangle_{1\leq i,j\leq n}\right)
  \]
<p>and secondly, we extend to the whole of \(\Lambda^k(V)\)
through linearity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinner(o1,o2,M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinner_+3A_o1">o1</code>, <code id="kinner_+3A_o2">o2</code></td>
<td>
<p>Objects of class <code>kform</code></p>
</td></tr>
<tr><td><code id="kinner_+3A_m">M</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a real number</p>


<h3>Note</h3>

<p>There is a vignette available: type <code>vignette("kinner")</code> at
the command line.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+hodge">hodge</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- (2*dx)^(3*dy)
b &lt;- (5*dx)^(7*dy)

kinner(a,b)
det(matrix(c(2*5,0,0,3*7),2,2))  # mathematically identical, slight numerical mismatch


</code></pre>

<hr>
<h2 id='ktensor'>k-tensors</h2><span id='topic+ktensor'></span><span id='topic+as.ktensor'></span><span id='topic+is.ktensor'></span><span id='topic+is.tensor'></span><span id='topic+as.function.ktensor'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Functionality for \(k\)-tensors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ktensor(S)
as.ktensor(M,coeffs)
is.ktensor(x)
## S3 method for class 'ktensor'
as.function(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ktensor_+3A_m">M</code>, <code id="ktensor_+3A_coeffs">coeffs</code></td>
<td>
<p>Matrix of indices and coefficients, as in
<code>spray(M,coeffs)</code></p>
</td></tr>
<tr><td><code id="ktensor_+3A_s">S</code></td>
<td>
<p>Object of class <code>spray</code></p>
</td></tr>
<tr><td><code id="ktensor_+3A_x">x</code></td>
<td>
<p>Object of class <code>ktensor</code></p>
</td></tr>
<tr><td><code id="ktensor_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <dfn>\(k\)-tensor</dfn> object \(S\) is a map from \(V^k\)
to the reals \(R\), where \(V\) is a vector space (here
\(R^n\)) that satisfies multilinearity:
</p>
\[S\left(v_1,\ldots,av_i,\ldots,v_k\right)=a\cdot
  S\left(v_1,\ldots,v_i,\ldots,v_k\right)\]
<p>and
</p>
\[S\left(v_1,\ldots,v_i+{v_i}',\ldots,v_k\right)=S\left(v_1,\ldots,v_i,\ldots,x_v\right)+
  S\left(v_1,\ldots,{v_i}',\ldots,v_k\right).\]
<p>Note that this is <em>not</em> equivalent to linearity over
\(V^{nk}\) (see examples).
</p>
<p>In the <a href="https://CRAN.R-project.org/package=stokes"><span class="pkg">stokes</span></a> package, \(k\)-tensors are represented as
sparse arrays (<code>spray</code> objects), but with a class of
<code>c("ktensor", "spray")</code>.  This is a natural and efficient
representation for tensors that takes advantage of sparsity using
<a href="https://CRAN.R-project.org/package=spray"><span class="pkg">spray</span></a> package features.
</p>
<p>Function <code>as.ktensor()</code> will coerce a \(k\)-form to a
\(k\)-tensor via <code>kform_to_ktensor()</code>.
</p>


<h3>Value</h3>

<p>All functions documented here return a <code>ktensor</code> object
except <code>as.function.ktensor()</code>, which returns a function.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Spivak 1961</p>


<h3>See Also</h3>

<p><code><a href="#topic+tensorprod">tensorprod</a></code>,<code><a href="#topic+kform">kform</a></code>,<code><a href="#topic+wedge">wedge</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.ktensor(cbind(1:4,2:5,3:6),1:4)


## Test multilinearity:
k &lt;- 4
n &lt;- 5
u &lt;- 3

## Define a randomish k-tensor:
S  &lt;- ktensor(spray(matrix(1+sample(u*k)%%n,u,k),seq_len(u)))

## And a random point in V^k:
E &lt;- matrix(rnorm(n*k),n,k)  

E1 &lt;- E2 &lt;- E3 &lt;- E

x1 &lt;- rnorm(n)
x2 &lt;- rnorm(n)
r1 &lt;- rnorm(1)
r2 &lt;- rnorm(1)

# change one column:
E1[,2] &lt;- x1
E2[,2] &lt;- x2
E3[,2] &lt;- r1*x1 + r2*x2

f &lt;- as.function(S)

r1*f(E1) + r2*f(E2) -f(E3) # should be small

## Note that multilinearity is different from linearity:
r1*f(E1) + r2*f(E2) - f(r1*E1 + r2*E2)  # not small!


</code></pre>

<hr>
<h2 id='Ops.kform'>Arithmetic Ops Group Methods for <code>kform</code> and <code>ktensor</code>
objects</h2><span id='topic+Ops.kform'></span><span id='topic+Ops.stokes'></span><span id='topic+Ops.ktensor'></span><span id='topic+Ops'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Allows arithmetic operators to be used for \(k\)-forms and
\(k\)-tensors such as addition, multiplication, etc, where
defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kform'
Ops(e1, e2 = NULL)
## S3 method for class 'ktensor'
Ops(e1, e2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.kform_+3A_e1">e1</code>, <code id="Ops.kform_+3A_e2">e2</code></td>
<td>
<p>Objects of class <code>kform</code> or <code>ktensor</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>Ops.kform()</code> and <code>Ops.ktensor()</code> pass unary
and binary arithmetic operators (&ldquo;<code>+</code>&rdquo;, &ldquo;<code>-</code>&rdquo;,
&ldquo;<code>*</code>&rdquo;, &ldquo;<code>/</code>&rdquo; and &ldquo;<code>^</code>&rdquo;) to the
appropriate specialist function by coercing to <code>spray</code> objects.
</p>
<p>For wedge products of \(k\)-forms, use <code>wedge()</code> or
<code>%^%</code> or <code>^</code>; and for tensor products of
\(k\)-tensors, use <code>tensorprod()</code> or <code>%X%</code>.
</p>


<h3>Value</h3>

<p>All functions documented here return an object of class
<code>kform</code> or <code>ktensor</code>.
</p>


<h3>Note</h3>

<p>A plain asterisk, &ldquo;<code>*</code>&rdquo; behaves differently for ktensors
and kforms.  Given two ktensors <code>T1</code>, <code>T2</code>, then
&ldquo;<code>T1*T2</code>&rdquo; will return the their tensor product.  This on
the grounds that the idiom has only one natural interpretation.  But
its use is discouraged (use <code>%X%</code> or <code>tensorprod()</code>
instead).  An asterisk can also be used to multiply a tensor by a
scalar, as in <code>T1*5</code>.
</p>
<p>An asterisk cannot be used to multiply two kforms <code>K1</code>,
<code>K2</code>, as in <code>K1*K2</code>, which will always return an error.
This on the grounds that it has no sensible interpretation in general
and you probably meant to use a wedge product, <code>K1^K2</code>.  Note
that multiplication by scalars is acceptable, as in <code>K1*6</code>.
Further note that <code>K1*K2</code> returns an error even if one or both is
a 0-form (or scalar), as in <code>K1*scalar(3)</code>.  This behaviour may
change in the future.
</p>
<p>In the package the caret (&ldquo;<code>^</code>&rdquo;) evaluates the wedge
product; note that <code>%^%</code> is also acceptable.  Powers simply do
not make sense for alternating forms: <code>S %^% S = S^S</code> is zero
identically.  Here the caret is interpreted consistently as a wedge
product, and if one of the factors is numeric it is interpreted as a
zero-form (that is, a scalar).  Thus <code>S^2 = wedge(S,2) = 2^S =
  S*2 = S+S</code>, and indeed <code>S^n==S*n</code>.  Caveat emptor!  If <code>S</code>
is a <code>kform</code> object, it is very tempting [but incorrect] to
interpret &ldquo;<code>S^3</code>&rdquo; as something like &ldquo;<code>S</code> to
the power 3&rdquo;.  See also the note at <code>Ops.clifford</code> in the
<a href="https://CRAN.R-project.org/package=clifford"><span class="pkg">clifford</span></a> package.
</p>
<p>Powers are not implemented for ktensors on the grounds that a ktensor
to the power zero is not defined.
</p>
<p>Note that one has to take care with order of operations if we mix
<code>^</code> with <code>*</code>.  For example, <code>dx ^ (6*dy)</code> is perfectly
acceptable; but <code>(dx ^ 6)*dy)</code> will return an error, as will the
unbracketed form <code>dx ^ 6 * dy</code>.  In the second case we attempt to
use an asterisk to multiply two k-forms, which triggers the error.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>## dx_1 ^ dx_2 + 6dx_5 ^ dx_6:
as.kform(1) ^ as.kform(2) + 6*as.kform(5) ^ as.kform(6)

k1 &lt;- kform_general(4,2,rnorm(6))
k2 &lt;- kform_general(4,2,rnorm(6))

E &lt;- matrix(rnorm(8),4,2)
as.function(k1+k2)(E)

## verify linearity, here 2*k1 + 3*k2:
as.function(2*k1+3*k2)(E)-(2*as.function(k1)(E) + 3*as.function(k2)(E))
## should be small
</code></pre>

<hr>
<h2 id='print.stokes'>Print methods for <i>k</i>-tensors and <i>k</i>-forms</h2><span id='topic+print.stokes'></span><span id='topic+print.kform'></span><span id='topic+print.ktensor'></span><span id='topic+stokes_symbolic_print'></span><span id='topic+kform_symbolic_print'></span><span id='topic+ktensor_symbolic_print'></span><span id='topic+polyform'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Print methods for
objects with options for printing in matrix form
or multivariate polynomial form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kform'
print(x, ...)
## S3 method for class 'ktensor'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.stokes_+3A_x">x</code></td>
<td>
<p>\(k\)-form or \(k\)-tensor</p>
</td></tr>
<tr><td><code id="print.stokes_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print method is designed to tell the user that an object is a
tensor or a \(k\)-form.  It prints a message to this effect (with
special dispensation for zero tensors), then calls the <code>spray</code>
print method.
</p>


<h3>Value</h3>

<p>Returns its argument invisibly.</p>


<h3>Note</h3>

<p>The print method asserts that its argument is a map from \(V^k\)
to \(R\) with \(V=R^n\).  Here, \(n\) is the largest
element in the index matrix.  However, such a map naturally furnishes
a map from \((R^m)^k\) to \(R\) provided that \(m\geq
  n\) via the natural projection from \(R^n\) to \(R^m\).
Formally this would be
\(\left(x_1,\ldots,x_n\right)\mapsto\left(x_1,\ldots,x_n,0,\ldots,0\right)\in
  R^m\).  In the case of the zero \(k\)-form or
\(k\)-tensor, &ldquo;<code>n</code>&rdquo; is to be interpreted as
&ldquo;any \(n\geq 0\)&rdquo;.  See also <code>dovs()</code>.
</p>
<p>By default, the print method uses the <a href="https://CRAN.R-project.org/package=spray"><span class="pkg">spray</span></a> print methods,
and as such respects the <code>polyform</code> option.  However, setting
<code>polyform</code> to <code>TRUE</code> can give misleading output, because
<code>spray</code> objects are interpreted as multivariate polynomials not
differential forms (and in particular uses the caret to signify
powers).
</p>
<p>It is much better to use options <code>ktensor_symbolic_print</code> or
<code>kform_symbolic_print</code> instead.  If these options are non-null,
the print method uses <code>as.symbolic()</code> to give an alternate way of
displaying \(k\)-tensors and \(k\)-forms.  The generic
non-null value would be &ldquo;<code>x</code>&rdquo; which gives output like
&ldquo;<code>dx1 ^ dx2</code>&rdquo;.  However, it has two special values: set
<code>kform_symbolic_print</code> to &ldquo;<code>dx</code>&rdquo; for output like
&ldquo;<code>dx ^ dz</code>&rdquo; and &ldquo;<code>txyz</code>&rdquo; for output like
&ldquo;<code>dt ^ dx</code>&rdquo;, useful in relativistic physics with a
Minkowski metric.  See the examples.
</p>
<p>More detail is given at <code>symbolic.Rd</code> and the
<code>dx</code> vignette.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.symbolic">as.symbolic</a></code>,<code><a href="#topic+dovs">dovs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- rform()
a

options(kform_symbolic_print = "x")
a


options(kform_symbolic_print = "dx")
kform(spray(kform_basis(3,2),1:3))


kform(spray(kform_basis(4,2),1:6))  # runs out of symbols


options(kform_symbolic_print = "txyz")
kform(spray(kform_basis(4,2),1:6))  # standard notation


options(kform_symbolic_print = NULL) # revert to default
a

</code></pre>

<hr>
<h2 id='rform'>Random kforms and ktensors</h2><span id='topic+rform'></span><span id='topic+rkform'></span><span id='topic+rtensor'></span><span id='topic+rktensor'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Random \(k\)-form objects and \(k\)-tensors,
intended as quick &ldquo;get you going&rdquo; examples</p>


<h3>Usage</h3>

<pre><code class='language-R'>rform(terms=9,k=3,n=7,coeffs,ensure=TRUE)
rtensor(terms=9,k=3,n=7,coeffs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rform_+3A_terms">terms</code></td>
<td>
<p>Number of distinct terms</p>
</td></tr>
<tr><td><code id="rform_+3A_k">k</code>, <code id="rform_+3A_n">n</code></td>
<td>
<p>A \(k\)-form maps \(V^k\) to \(R\), where
\(V=R^n\)</p>
</td></tr> 
<tr><td><code id="rform_+3A_coeffs">coeffs</code></td>
<td>
<p>The coefficients of the form; if missing use
<code>seq_len(terms)</code></p>
</td></tr>
<tr><td><code id="rform_+3A_ensure">ensure</code></td>
<td>
<p>Boolean with default <code>TRUE</code> meaning to ensure that
the <code>dovs()</code> of the returned value is in fact equal to <code>n</code>.
If <code>FALSE</code>, sometimes the <code>dovs()</code> is strictly less than
<code>n</code> because of random sampling</p>
</td></tr>
</table>


<h3>Details</h3>

<p>What you see is what you get, basically.
</p>
<p>Note that argument <code>terms</code> is an upper bound, as the index matrix
might contain repeats which are combined.
</p>


<h3>Value</h3>

<p>All functions documented here return an object of class <code>kform</code> or
<code>ktensor</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rform()
rform() %^% rform()

rtensor() %X% rtensor()

rform() ^ dx
rform() ^ dx ^ dy

</code></pre>

<hr>
<h2 id='scalar'>Scalars and losing attributes</h2><span id='topic+scalar'></span><span id='topic+is.scalar'></span><span id='topic+0form'></span><span id='topic+0tensor'></span><span id='topic+lose'></span><span id='topic+lose.kform'></span><span id='topic+lose.ktensor'></span><span id='topic+drop'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Scalars: \(0\)-forms and \(0\)-tensors</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalar(s,kform=TRUE,lose=FALSE)
is.scalar(M)
`0form`(s=1,lose=FALSE)
`0tensor`(s=1,lose=FALSE)
## S3 method for class 'kform'
lose(M)
## S3 method for class 'ktensor'
lose(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalar_+3A_s">s</code></td>
<td>
<p>A scalar value; a number</p>
</td></tr>
<tr><td><code id="scalar_+3A_kform">kform</code></td>
<td>
<p>Boolean with default <code>TRUE</code> meaning to return a
kform and <code>FALSE</code> meaning to return a ktensor</p>
</td></tr>
<tr><td><code id="scalar_+3A_m">M</code></td>
<td>
<p>Object of class <code>ktensor</code> or <code>kform</code></p>
</td></tr>
<tr><td><code id="scalar_+3A_lose">lose</code></td>
<td>
<p>In function <code>scalar()</code>, Boolean with <code>TRUE</code>
meaning to return a normal scalar, and default <code>FALSE</code> meaning
to return a formal \(0\)-form or \(0\)-tensor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A \(k\)-tensor (including \(k\)-forms) maps \(k\) vectors
to a scalar.  If \(k=0\), then a \(0\)-tensor maps no vectors
to a scalar, that is, mapping nothing at all to a scalar, or what normal
people would call a plain old scalar.  Such forms are created by a
couple of constructions in the package, specifically <code>scalar()</code>,
<code>kform_general(1,0)</code> and <code>contract()</code>.  These functions take a
<code>lose</code> argument that behaves much like the <code>drop</code> argument in
base extraction.  Functions '0form()' and '0tensor()' are wrappers for
'scalar()'.
</p>
<p>Function <code>lose()</code> takes an object of class <code>ktensor</code> or
<code>kform</code> and, if of arity zero, returns the coefficient.
</p>
<p>Note that function <code>kform()</code> <em>always</em> returns a <code>kform</code>
object, it never loses attributes.
</p>
<p>There is a slight terminological problem.  A \(k\)-form maps
\(k\) vectors to the reals: so a \(0\)-form maps \(0\)
vectors to the reals.  This is what anyone on the planet would call a
scalar.  Similarly, a \(0\)-tensor maps \(0\) vectors to the
reals, and so is a scalar.  Mathematically, there is no difference
between \(0\)-forms and \(0\)-tensors, but the package makes a
distinction:
</p>
<pre>
&gt; scalar(5,kform=TRUE)
An alternating linear map from V^0 to R with V=R^0:
     val
  =    5
&gt; scalar(5,kform=FALSE)
A linear map from V^0 to R with V=R^0:
     val
  =    5
&gt; 
</pre>
<p>Compare zero tensors and zero forms.  A zero tensor maps \(V^k\) to
the real number zero, and a zero form is an alternating tensor mapping
\(V^k\) to zero (so a zero tensor is necessarily alternating).  See
<code>zero.Rd</code>.
</p>


<h3>Value</h3>

<p>The functions documented here return an object of class
<code>kform</code> or <code>ktensor</code>, except for <code>is.scalar()</code>, which
returns a Boolean.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+zeroform">zeroform</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
o &lt;- scalar(5)
o
lose(o)

kform_general(1,0)  
kform_general(1,0,lose=FALSE)

</code></pre>

<hr>
<h2 id='stokes-package'>
The Exterior Calculus
</h2><span id='topic+stokes-package'></span><span id='topic+stokes'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Provides functionality for working with tensors, alternating
           forms, wedge products, Stokes's theorem, and related concepts
	   from the exterior calculus.   Uses 'disordR' discipline
	   (Hankin, 2022, &lt;doi:10.48550/ARXIV.2210.03856&gt;).  The
	   canonical reference would be M. Spivak
	   (1965, ISBN:0-8053-9021-9) &quot;Calculus on Manifolds&quot;.  To cite
	   the package in publications please use Hankin (2022)
           &lt;doi:10.48550/ARXIV.2210.17008&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> stokes</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> The Exterior Calculus</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2-0</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr,
Deriv,
testthat,
markdown,
rmarkdown,
emulator,
magrittr</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> permutations (&gt;= 1.1-2), partitions, methods, mathjaxr, disordR (&gt;= 0.9-7), spray (&gt;= 1.0-24)</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(
	   given=c("Robin", "K. S."),
	   family="Hankin",
	   role = c("aut","cre"),
	   email="hankin.robin@gmail.com",
	   comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Provides functionality for working with tensors, alternating
           forms, wedge products, Stokes's theorem, and related concepts
	   from the exterior calculus.   Uses 'disordR' discipline
	   (Hankin, 2022, &lt;doi:10.48550/ARXIV.2210.03856&gt;).  The
	   canonical reference would be M. Spivak
	   (1965, ISBN:0-8053-9021-9) "Calculus on Manifolds".  To cite
	   the package in publications please use Hankin (2022)
           &lt;doi:10.48550/ARXIV.2210.17008&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/stokes</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/stokes/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
RdMacros: </td><td style="text-align: left;"> mathjaxr</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Alt                     Alternating multilinear forms
Ops.kform               Arithmetic Ops Group Methods for 'kform' and
                        'ktensor' objects
as.1form                Coerce vectors to 1-forms
coeffs                  Extract and manipulate coefficients
consolidate             Various low-level helper functions
contract                Contractions of k-forms
dovs                    Dimension of the underlying vector space
dx                      Elementary forms in three-dimensional space
ex                      Basis vectors in three-dimensional space
hodge                   Hodge star operator
inner                   Inner product operator
issmall                 Is a form zero to within numerical precision?
keep                    Keep or drop variables
kform                   k-forms
kinner                  Inner product of two kforms
ktensor                 k-tensors
print.stokes            Print methods for k-tensors and k-forms
rform                   Random kforms and ktensors
scalar                  Scalars and losing attributes
stokes-package          The Exterior Calculus
summary.stokes          Summaries of tensors and alternating forms
symbolic                Symbolic form
tensorprod              Tensor products of k-tensors
transform               Linear transforms of k-forms
vector_cross_product    The Vector cross product
volume                  The volume element
wedge                   Wedge products
zap                     Zap small values in k-forms and k-tensors
zero                    Zero tensors and zero forms
</pre>
<p>Generally in the package, arguments that are \(k\)-forms are
denoted <code>K</code>, \(k\)-tensors by <code>U</code>, and spray objects by
<code>S</code>.  Multilinear maps (which may be either \(k\)-forms or
\(k\)-tensors) are denoted by <code>M</code>.
</p>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> J. H. Hubbard and B. B. Hubbard 2015.  <em>Vector
calculus, linear algebra and differential forms: a unified
approach</em>.  Ithaca, NY.
</p>
</li>
<li><p> M. Spivak 1971. <em>Calculus on manifolds</em>,
Addison-Wesley.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="spray.html#topic+spray-package">spray</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some k-tensors:
U1 &lt;- as.ktensor(matrix(1:15,5,3))
U2 &lt;- as.ktensor(cbind(1:3,2:4),1:3)

## Coerce a tensor to functional form, here mapping V^3  -&gt; R (here V=R^15):
as.function(U1)(matrix(rnorm(45),15,3))

## Tensor product is tensorprod() or %X%:
U1 %X% U2


## A k-form is an alternating k-tensor:
K1 &lt;- as.kform(cbind(1:5,2:6),rnorm(5))
K2 &lt;- kform_general(3:6,2,1:6)
K3 &lt;- rform(9,3,9,runif(9))

## The distributive law is true

(K1 + K2) ^ K3 == K1 ^ K3 + K2 ^ K3 # TRUE to numerical precision

## Wedge product is associative (non-trivial):
(K1 ^ K2) ^ K3
K1 ^ (K2 ^ K3)


## k-forms can be coerced to a function and wedge product:
f &lt;- as.function(K1 ^ K2 ^ K3)

## E is a a random point in V^k:
E &lt;- matrix(rnorm(63),9,7)

## f() is alternating:
f(E)
f(E[,7:1])



## The package blurs the distinction between symbolic and numeric computing:
dx &lt;- as.kform(1)
dy &lt;- as.kform(2)
dz &lt;- as.kform(3)

dx ^ dy ^ dz

K3 ^ dx ^ dy ^ dz
</code></pre>

<hr>
<h2 id='summary.stokes'>Summaries of tensors and alternating forms</h2><span id='topic+summary.stokes'></span><span id='topic+summary.kform'></span><span id='topic+summary.ktensor'></span><span id='topic+print.summary.kform'></span><span id='topic+print.summary.ktensor'></span><span id='topic+summary'></span><span id='topic+print.summary.spray'></span>

<h3>Description</h3>

<p>A summary method for tensors and alternating forms, and a print method for summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kform'
summary(object, ...)
## S3 method for class 'ktensor'
summary(object, ...)
## S3 method for class 'summary.kform'
print(x, ...)
## S3 method for class 'summary.ktensor'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stokes_+3A_object">object</code>, <code id="summary.stokes_+3A_x">x</code></td>
<td>
<p>Object of class <code>ktensor</code> or <code>kform</code></p>
</td></tr>
<tr><td><code id="summary.stokes_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code>head()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summary method for tensors and alternating forms.  Uses <code>spray::summary()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rform(100)
summary(a)
options(kform_symbolic_print = TRUE)
summary(a)
options(kform_symbolic_print = NULL)  # restore default


</code></pre>

<hr>
<h2 id='symbolic'>Symbolic form</h2><span id='topic+symbolic'></span><span id='topic+as.symbolic'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Returns a character string representing \(k\)-tensor and
\(k\)-form objects in symbolic form.  Used by the print method if
either option <code>kform_symbolic_print</code> or
<code>ktensor_symbolic_print</code> is non-null.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.symbolic(M,symbols=letters,d="")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbolic_+3A_m">M</code></td>
<td>
<p>Object of class <code>kform</code> or <code>ktensor</code>; a map from
\(V^k\) to \(R\), where \(V=R^n\)</p>
</td></tr>
<tr><td><code id="symbolic_+3A_symbols">symbols</code></td>
<td>
<p>A character vector giving the names of the symbols</p>
</td></tr>
<tr><td><code id="symbolic_+3A_d">d</code></td>
<td>
<p>String specifying the appearance of the differential operator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spivak (p89), in archetypically terse writing, states:
</p>
<p>A function \(f\) is considered to be a 0-form and
\(f\cdot\omega\) is also written
\(f\wedge\omega\).  If
\(f\colon\mathcal{R}^n\longrightarrow\mathcal{R}\) is
differentiable, then
\(Df(p)\in\Lambda^1\left(\mathcal{R}^n\right)\).
By a minor modification we therefore obtain a 1-form \(df\),
defined by
</p>
\[df(p)\left(v_p\right)=Df(p)(v)\]
<p>Let us consider in particular the 1-forms \(d\pi^i\).  It is customary to let \(x^i\) denote the <em>function</em>
\(\pi^i\) (On \(\mathcal{R}^3\) we
often denote \(x^1\), \(x^2\), and \(x^3\) by
\(x\), \(y\), and \(z\)).  This standard notation has
obvious disadvantages but it allows many classical results to be
expressed by formulas of equally classical appearance.  Since
\(dx^i(p)(v_p)=d\pi^i(p)(v_p)=D\pi^i(p)(v)=v^i\), we see that \(dx^1(p),\ldots,dx^n(p)\)
is just the dual basis to
\((e_1)_p,\ldots,(e_n)_p\).  Thus every
k-form \(\omega\) can be written
</p>
\[
    \omega=\sum_{i_1 < \cdots < i_k}\omega_{i_1,\ldots,i_k}
    dx^{i_1}\wedge\cdots\wedge dx^{i_k}.\]
<p>Function <code>as.symbolic()</code> uses this format.  For completeness, we
add (p77) that k-tensors may be expressed in the form
</p>
\[
    \sum_{i_1,\ldots, i_k=1}^n a_{i_1,\ldots,i_k}\cdot
\phi_{i_1}\otimes\cdots\otimes\phi_{i_k}.\]
<p>and this form is used for k-tensors.
</p>


<h3>Value</h3>

<p>Returns a &ldquo;noquote&rdquo; character string.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.stokes">print.stokes</a></code>,<code><a href="#topic+dx">dx</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(o &lt;- kform_general(3,2,1:3))
as.symbolic(o,d="d",symbols=letters[23:26])

(a &lt;- rform(n=50))
as.symbolic(a,symbols=state.abb)

</code></pre>

<hr>
<h2 id='tensorprod'>Tensor products of <i>k</i>-tensors</h2><span id='topic+tensorprod'></span><span id='topic+tensorprod2'></span><span id='topic++25X+25'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Tensor products of <i>k</i>-tensors</p>


<h3>Usage</h3>

<pre><code class='language-R'>tensorprod(U, ...)
tensorprod2(U1,U2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tensorprod_+3A_u">U</code>, <code id="tensorprod_+3A_u1">U1</code>, <code id="tensorprod_+3A_u2">U2</code></td>
<td>
<p>Object of class <code>ktensor</code></p>
</td></tr>
<tr><td><code id="tensorprod_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a \(k\)-tensor \(S\) and an \(l\)-tensor
\(T\), we can form the tensor product \(S\otimes T\), defined as
</p>
\[S\otimes T\left(v_1,\ldots,v_k,v_{k+1},\ldots, v_{k+l}\right)=
  S\left(v_1,\ldots v_k\right)\cdot T\left(v_{k+1},\ldots
  v_{k+l}\right).\]
<p>Package idiom for this includes <code>tensorprod(S,T)</code> and <code>S %X%
T</code>; note that the tensor product is not commutative.  Function
<code>tensorprod()</code> can take any number of arguments (the result is
well-defined because the tensor product is associative); it uses
<code>tensorprod2()</code> as a low-level helper function.
</p>


<h3>Value</h3>

<p>The functions documented here all return a <code>spray</code> object.</p>


<h3>Note</h3>

<p>The binary form <code>%X%</code> uses uppercase X to avoid clashing with
<code>%x%</code> which is the Kronecker product in base <span class="rlang"><b>R</b></span>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Spivak 1961</p>


<h3>See Also</h3>

<p><code><a href="#topic+ktensor">ktensor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(A &lt;- ktensor(spray(matrix(c(1,1,2,2,3,3),2,3,byrow=TRUE),1:2)))
(B &lt;- ktensor(spray(10+matrix(4:9,3,2),5:7)))
tensorprod(A,B)

A %X% B - B %X% A


Va &lt;- matrix(rnorm(9),3,3)
Vb &lt;- matrix(rnorm(38),19,2)

LHS &lt;- as.function(A %X% B)(cbind(rbind(Va,matrix(0,19-3,3)),Vb))
RHS &lt;-  as.function(A)(Va) * as.function(B)(Vb)

c(LHS=LHS,RHS=RHS,diff=LHS-RHS)



</code></pre>

<hr>
<h2 id='transform'>Linear transforms of <i>k</i>-forms</h2><span id='topic+transform'></span><span id='topic+pullback'></span><span id='topic+pull-back'></span><span id='topic+pushforward'></span><span id='topic+push-forward'></span><span id='topic+stretch'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Given a \(k\)-form, express it in terms of linear
combinations of the \(dx_i\)</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullback(K,M)
stretch(K,d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_+3A_k">K</code></td>
<td>
<p>Object of class <code>kform</code></p>
</td></tr>
<tr><td><code id="transform_+3A_m">M</code></td>
<td>
<p>Matrix of transformation</p>
</td></tr>
<tr><td><code id="transform_+3A_d">d</code></td>
<td>
<p>Numeric vector representing the diagonal elements of a
diagonal matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>pullback()</code> calculates the pullback of a function.  A
vignette is provided at &lsquo;<span class="file">pullback.Rmd</span>&rsquo;.
</p>
<p>Suppose we are given a two-form
</p>
\[
    \omega=\sum_{i < j}a_{ij}dx_i\wedge dx_j\]
<p>and relationships
</p>
\[dx_i=\sum_rM_{ir}dy_r\]
<p>then we would have
</p>
\[\omega =
    \sum_{i < j}
    a_{ij}\left(\sum_rM_{ir}dy_r\right)\wedge\left(\sum_rM_{jr}dy_r\right).
  \]
<p>The general situation would be  a \(k\)-form where we would have
\[
    \omega=\sum_{i_1 < \cdots < i_k}a_{i_1\ldots i_k}dx_{i_1}\wedge\cdots\wedge dx_{i_k}\]
</p>
<p>giving
</p>
\[\omega =
    \sum_{i_1 < \cdots < i_k}\left[
    a_{i_1,\ldots, i_k}\left(\sum_rM_{i_1r}dy_r\right)\wedge\cdots\wedge\left(\sum_rM_{i_kr}dy_r\right)\right].
  \]
<p>The <code>transform()</code> function does all this but it is slow.  I am not
100% sure that there isn't a much more efficient way to do such a
transformation.  There are a few tests in <code>tests/testthat</code> and a
discussion in the <code>stokes</code> vignette.
</p>
<p>Function <code>stretch()</code> carries out the same operation but for \(M\)
a diagonal matrix.  It is much faster than <code>transform()</code>.
</p>


<h3>Value</h3>

<p>The functions documented here return an object of class
<code>kform</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>S. H. Weintraub 2019. <em>Differential forms: theory and practice</em>.
Elsevier.  (Chapter 3)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wedge">wedge</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example in the text:
K &lt;- as.kform(matrix(c(1,1,2,3),2,2),c(1,5))
M &lt;- matrix(1:9,3,3)
pullback(K,M)

# Demonstrate that the result can be complicated:
M &lt;- matrix(rnorm(25),5,5)
pullback(as.kform(1:2),M)

# Numerical verification:
o &lt;- volume(3)

o2 &lt;- pullback(pullback(o,M),solve(M))
max(abs(coeffs(o-o2))) # zero to numerical precision

# Following should be zero:
pullback(as.kform(1),M)-as.kform(matrix(1:5),c(crossprod(M,c(1,rep(0,4)))))

# Following should be TRUE:
issmall(pullback(o,crossprod(matrix(rnorm(10),2,5))))

# Some stretch() use-cases:

p &lt;- rform()
p
stretch(p,seq_len(7))
stretch(p,c(1,0,0,1,1,1,1))   # kills dimensions 2 and 3

</code></pre>

<hr>
<h2 id='vector_cross_product'>The Vector cross product</h2><span id='topic+vector_cross_product'></span><span id='topic+vcp3'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The vector cross product \(\mathbf{u}\times\mathbf{v}\)
for \(\mathbf{u},\mathbf{u}\in\mathbb{R}^3\) is defined
in elementary school as
</p>
\[
    \mathbf{u}\times\mathbf{v}=\left(u_2v_3-u_3v_2,u_2v_3-u_3v_2,u_2v_3-u_3v_2\right).
  \]
<p>Function <code>vcp3()</code> is a convenience wrapper for this.  However, the
vector cross product may easily be generalized to a product of
\(n-1\)-tuples of vectors in \(\mathbb{R}^3\), given by
package function <code>vector_cross_product()</code>.
</p>
<p>Vignette <code>vector_cross_product</code>, supplied with the package, gives
an extensive discussion of vector cross products, including formal
definitions and verification of identities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_cross_product(M)
vcp3(u,v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector_cross_product_+3A_m">M</code></td>
<td>
<p>Matrix with one more row than column; columns are interpreted
as vectors</p>
</td></tr>
<tr><td><code id="vector_cross_product_+3A_u">u</code>, <code id="vector_cross_product_+3A_v">v</code></td>
<td>
<p>Vectors of length 3, representing vectors in \(\mathbb{R}^3\)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See vignette <code>vector_cross_product</code>
</p>


<h3>Value</h3>

<p>Returns a vector</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="clifford.html#topic+cross">cross</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
vector_cross_product(matrix(1:6,3,2))


M &lt;- matrix(rnorm(30),6,5)
LHS &lt;- hodge(as.1form(M[,1])^as.1form(M[,2])^as.1form(M[,3])^as.1form(M[,4])^as.1form(M[,5]))
RHS &lt;- as.1form(vector_cross_product(M))
LHS-RHS  # zero to numerical precision

# Alternatively:
hodge(Reduce(`^`,sapply(seq_len(5),function(i){as.1form(M[,i])},simplify=FALSE)))
</code></pre>

<hr>
<h2 id='volume'>The volume element</h2><span id='topic+volume'></span><span id='topic+is.volume'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The volume element in \(n\) dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volume(n)
is.volume(K,n=dovs(K))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volume_+3A_n">n</code></td>
<td>
<p>Dimension of the space</p>
</td></tr>
<tr><td><code id="volume_+3A_k">K</code></td>
<td>
<p>Object of class <code>kform</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spivak phrases it well (theorem 4.6, page 82):
</p>
<p>If \(V\) has dimension \(n\), it follows that
\(\Lambda^n(V)\) has dimension 1. Thus all alternating
\(n\)-tensors on \(V\) are multiples of any non-zero one.
Since the determinant is an example of such a member of
\(\Lambda^n(V)\) it is not surprising to find it in the following
theorem:
</p>
<p>Let \(v_1,\ldots,v_n\) be a basis for \(V\) and
let \(\omega\in\Lambda^n(V)\).  If \(w_i=\sum_{j=1}^n
a_{ij}v_j\)  then
</p>
\[
  \omega\left(w_1,\ldots,w_n\right)=\det\left(a_{ij}\right)\cdot\omega\left(v_1,\ldots
  v_n\right)\]
<p>(see the examples for numerical verification of this).
</p>
<p>Neither the zero \(k\)-form, nor scalars, are considered to be a
volume element.
</p>


<h3>Value</h3>

<p>Function <code>volume()</code> returns an object of class <code>kform</code>;
function <code>is.volume()</code> returns a Boolean.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<ul>
<li><p> M. Spivak 1971. <em>Calculus on manifolds</em>,
Addison-Wesley</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+zeroform">zeroform</a></code>,<code><a href="#topic+as.1form">as.1form</a></code>,<code><a href="#topic+dovs">dovs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

dx^dy^dz == volume(3) 

p &lt;- 1
for(i in 1:7){p &lt;- p ^ as.kform(i)}
p
p == volume(7)  # should be TRUE

o &lt;- volume(5)
M &lt;- matrix(runif(25),5,5)
det(M) - as.function(o)(M)   # should be zero


is.volume(d(1) ^ d(2) ^ d(3) ^ d(4))
is.volume(d(1:9))

</code></pre>

<hr>
<h2 id='wedge'>Wedge products</h2><span id='topic+wedge'></span><span id='topic+wedge2'></span><span id='topic++25+5E+25'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Wedge products of \(k\)-forms</p>


<h3>Usage</h3>

<pre><code class='language-R'>wedge2(K1,K2)
wedge(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wedge_+3A_k1">K1</code>, <code id="wedge_+3A_k2">K2</code>, <code id="wedge_+3A_x">x</code>, <code id="wedge_+3A_...">...</code></td>
<td>
<p>\(k\)-forms</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wedge product of \(k\)-forms.  
</p>


<h3>Value</h3>

<p>The functions documented here return an object of class
<code>kform</code>.
</p>


<h3>Note</h3>

<p>In general use, use <code>wedge()</code> or <code>^</code> or <code>%^%</code>, as
documented under <code>Ops</code>.  Function <code>wedge()</code> uses low-level
helper function <code>wedge2()</code>, which takes only two arguments.
</p>
<p>A short vignette is provided with the package: type
<code>vignette("wedge")</code> at the commandline.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ops">Ops</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
k1 &lt;- as.kform(cbind(1:5,2:6),1:5)
k2 &lt;- as.kform(cbind(5:7,6:8,7:9),1:3)
k3 &lt;- kform_general(1:6,2)

a1 &lt;- wedge2(k1,wedge2(k2,k3))
a2 &lt;- wedge2(wedge2(k1,k2),k3)

is.zero(a1-a2)  # NB terms of a1, a2 in a different order!

# This is why wedge(k1,k2,k3) is well-defined.  Can also use ^:
k1 ^ k2 ^ k3
</code></pre>

<hr>
<h2 id='zap'>Zap small values in <i>k</i>-forms and <i>k</i>-tensors</h2><span id='topic+zap'></span><span id='topic+zap'></span><span id='topic+zapsmall'></span><span id='topic+zaptiny'></span><span id='topic+zap.spray'></span><span id='topic+zap.kform'></span><span id='topic+zap.ktensor'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Equivalent to <code>zapsmall()</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>zap(X)
## S3 method for class 'kform'
zap(X)
## S3 method for class 'ktensor'
zap(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zap_+3A_x">X</code></td>
<td>
<p>Tensor or \(k\)-form to be zapped</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an object of class <code>ktensor</code> or <code>kform</code>, coefficients
close to zero are &lsquo;zapped&rsquo;, i.e., replaced by &lsquo;0&rsquo;, using
<code>base::zapsmall()</code>.
</p>
<p>Note, <code>zap()</code> actually changes the numeric value, it is not just
a print method.
</p>


<h3>Value</h3>

<p>Returns an object of the same class</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
S &lt;- rform(7)
S == zap(S)
</code></pre>

<hr>
<h2 id='zero'>Zero tensors and zero forms</h2><span id='topic+zero'></span><span id='topic+zeroform'></span><span id='topic+zerotensor'></span><span id='topic+is.zero'></span><span id='topic+is.empty'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Correct idiom for generating zero \(k\)-tensors and \(k\)-forms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeroform(n)
zerotensor(n)
is.zero(x)
is.empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_+3A_n">n</code></td>
<td>
<p>Arity of the \(k\)-form or \(k\)-tensor</p>
</td></tr>
<tr><td><code id="zero_+3A_x">x</code></td>
<td>
<p>Object to be tested for zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>kform</code> or <code>ktensor</code>.</p>


<h3>Note</h3>

<p>Idiom such as <code>as.ktensor(rep(1,n),0)</code> and
<code>as.kform(rep(1,5),0)</code> and indeed <code>as.kform(1:5,0)</code> is
incorrect as the arity of the tensor is lost.
</p>
<p>A \(0\)-form is not the same thing as a zero tensor.  A
\(0\)-form maps \(V^0\) to the reals; a scalar.  A zero
tensor maps \(V^k\) to zero.  Some discussion is given at
<code>scalar.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalar">scalar</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
zerotensor(5)
zeroform(3)


x &lt;- rform(k=3)
x*0 == zeroform(3)       # should be true
x   == x + zeroform(3)  # should be true

y &lt;- rtensor(k=3)
y*0 == zerotensor(3)    # should be true
y   == y+zerotensor(3)  # should be true


## Following idiom is plausible but fails because as.ktensor(coeffs=0)
## and as.kform(coeffs=0) do not retain arity:

## as.ktensor(1+diag(5)) +  as.ktensor(rep(1,5),0)   # fails
## as.kform(matrix(1:6,2,3)) + as.kform(1:3,0)   # also fails


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
