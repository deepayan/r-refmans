<!DOCTYPE html><html><head><title>Help for package GIMMEgVAR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GIMMEgVAR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#environmentSetup'><p>GIMMEgVAR: Environment Setup</p></a></li>
<li><a href='#fitGIMMEgVAR'><p>FIT 'GIMMEgVAR'</p></a></li>
<li><a href='#fitGraphicalVAR'><p>fitgraphicalVAR</p></a></li>
<li><a href='#GIMMEgVAR'><p>GIMMEgVAR</p>
'
This function calls all the functions needed to fit 'GIMMEgVAR'.</a></li>
<li><a href='#graphKappa'><p>GIMMEgVAR: GraphGIMMEgVAR</p></a></li>
<li><a href='#prepareData'><p>PREPARE DATA FOR FITTING 'GIMMEgVAR'</p></a></li>
<li><a href='#sampleData'><p>sampleData</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Group Iterative Multiple Model Estimation with 'graphicalVAR'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphicalVAR, here, qgraph, png</td>
</tr>
<tr>
<td>Description:</td>
<td>Data-driven approach for arriving at person-specific time series models from within a Graphical Vector Autoregression (VAR) framework. The method first identifies which relations replicate across the majority of individuals to detect signal from noise. These group-level relations are then used as a foundation for starting the search for person-specific (or individual-level) relations. All estimates are obtained uniquely for each individual in the final models. The method for the 'graphicalVAR' approach is found in Epskamp, Waldorp, Mottus &amp; Borsboom (2018) &lt;<a href="https://doi.org/10.1080%2F00273171.2018.1454823">doi:10.1080/00273171.2018.1454823</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-15 15:51:13 UTC; wsandra</td>
</tr>
<tr>
<td>Author:</td>
<td>Sandra Williams Lee [aut, cre],
  Kathleen M. Gates [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sandra Williams Lee &lt;wsandra@live.unc.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-16 14:10:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='environmentSetup'>GIMMEgVAR: Environment Setup</h2><span id='topic+environmentSetup'></span>

<h3>Description</h3>

<p>Loads needed packages and creates directories
where logfiles and output from 'GIMMEgVAR'
will be stored
</p>


<h3>Usage</h3>

<pre><code class='language-R'>environmentSetup(outputPath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="environmentSetup_+3A_outputpath">outputPath</code></td>
<td>
<p>The user specified path to the directory where results files should be stored.</p>
</td></tr>
</table>

<hr>
<h2 id='fitGIMMEgVAR'>FIT 'GIMMEgVAR'</h2><span id='topic+fitGIMMEgVAR'></span>

<h3>Description</h3>

<p>This function fits 'GIMMEgVAR' using the original input data supplied by the user
and the logical matrices that result across people after fitting individual
'graphicalVAR'.  The logical matrices are determined via the gimmeThreshold specified
by the user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGIMMEgVAR(
  inData,
  variableNames,
  gimmeGVARThreshold = 0.5,
  nLambda = 50,
  verbose = TRUE,
  gamma = 0.5,
  scale = TRUE,
  lambda_beta,
  lambda_kappa,
  maxit.in = 100,
  maxit.out = 100,
  deleteMissings = TRUE,
  penalize.diagonal = TRUE,
  lambda_min_kappa = 0.05,
  lambda_min_beta = lambda_min_kappa,
  mimic = c("current", "0.1.2", "0.1.4", "0.1.5", "0.2"),
  beepvar,
  dayvar,
  idvar,
  lags = 1,
  centerWithin = TRUE,
  likelihood = c("unpenalized", "penalized"),
  logicals,
  RES_matrixData,
  outputPath,
  labelNames = variableNames
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitGIMMEgVAR_+3A_indata">inData</code></td>
<td>
<p>A matrix or data frame containing repeated measures (rows) on a set of variables (columns).
Must not contain missing data.</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_variablenames">variableNames</code></td>
<td>
<p>The vector containing name of variables to be analyzed</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_gimmegvarthreshold">gimmeGVARThreshold</code></td>
<td>
<p>The cutoff value for group-level paths. Defaults to .50, indicating
that a path must be non-zero across &gt;= .50
included as a group-level path.</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_nlambda">nLambda</code></td>
<td>
<p>The number of both lambda parameters to test. Defaults to 50,
which results in 2500 models to evaluate.</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_verbose">verbose</code></td>
<td>
<p>Logical, should a progress bar be printed to the console?</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_gamma">gamma</code></td>
<td>
<p>The EBIC hyper-parameter. Set to 0 to use regular BIC.</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_scale">scale</code></td>
<td>
<p>Logical, should responses be standardized before estimation?</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_lambda_beta">lambda_beta</code></td>
<td>
<p>An optional vector of lambda_beta values to test.
Set lambda_beta = 0 argument and lambda_kappa = 0 for unregularized estimation.</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_lambda_kappa">lambda_kappa</code></td>
<td>
<p>An optional vector of lambda_kappa values to test.
Set lambda_beta = 0 argument and lambda_kappa = 0 for unregularized estimation.</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_maxit.in">maxit.in</code></td>
<td>
<p>Maximum number of iterations in the inner loop (computing beta)</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_maxit.out">maxit.out</code></td>
<td>
<p>Maximum number of iterations in the outer loop</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_deletemissings">deleteMissings</code></td>
<td>
<p>Logical, should missing responses be deleted?</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_penalize.diagonal">penalize.diagonal</code></td>
<td>
<p>Logical, should the diagonal of beta be penalized (i.e., penalize auto-regressions)?</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_lambda_min_kappa">lambda_min_kappa</code></td>
<td>
<p>Multiplier of maximal tuning parameter for kappa</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_lambda_min_beta">lambda_min_beta</code></td>
<td>
<p>Multiplier of maximal tuning parameter for beta</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_mimic">mimic</code></td>
<td>
<p>Allows one to mimic earlier versions of 'graphicalVAR'</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_beepvar">beepvar</code></td>
<td>
<p>String indicating assessment beep per day (if missing, is added).
Adding this argument will cause non-consecutive beeps to be treated as missing!</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_dayvar">dayvar</code></td>
<td>
<p>String indicating assessment day. Adding this argument makes sure that the first measurement of a day is not
regressed on the last measurement of the previous day.
IMPORTANT: only add this if the data has multiple observations per day.</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_idvar">idvar</code></td>
<td>
<p>String indicating the subject ID</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_lags">lags</code></td>
<td>
<p>Vector of lags to include</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_centerwithin">centerWithin</code></td>
<td>
<p>logical, should subject data be within-person centered before estimating fixed effects?</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_likelihood">likelihood</code></td>
<td>
<p>Should likelihood be computed based on penalized contemporaneous matrix or</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_logicals">logicals</code></td>
<td>
<p>Logical matrices that determine which elements of the beta and kappa matrices will be regularized
when fititng 'GIMMEgVAR'.  The matrices are determined in the algorithm by obtaining counts across all fitted individual
network results for beta and kappa, respectively.  Elements with proportions &gt;= gimmeGVARThreshold value
will not be regularized when fitting 'GIMMEgVAR'.</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_res_matrixdata">RES_matrixData</code></td>
<td>
<p>List containing results of fitting individual 'graphicalVAR' to each individual.</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_outputpath">outputPath</code></td>
<td>
<p>The user specified path to the directory where results files should be stored.</p>
</td></tr>
<tr><td><code id="fitGIMMEgVAR_+3A_labelnames">labelNames</code></td>
<td>
<p>Vector of names used to label nodes in Network graph. Defaults to variable names if no
vector is supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can pass in additional 'graphicalVAR' options as specified in the R
package 'graphicalVAR' created by Sacha Epskamp.  See 'graphicalVAR' documentation
for details.
</p>
<p>The following results are returned in the 'GIMMEgVAR' Files directory:
(1) Data frames containing individual paths.  These are the person-specific results
for each individual obtained by not regularizing the group paths indicated
by the logical matrices for both beta and kappa.  They are prefaced
RESULTS_GIMMEgVAR_SUBJECT_.
</p>
<p>(2) Data frames that indicate the proportion of paths across individuals:
These are dataframes containing the proportion of paths present across
individuals after fitting 'GIMMEgVAR'.  These proportions are used to determine
the final group model.  They are named proportionKappa.RData and proportionBeta.RData.
</p>
<p>(3) Group path data frames for beta and kappa:
These are dataframes with 1 indicating the presence of a group path and 0 indicating
the absence of a group path.
These data frames are derived from #2 above for both beta and kappa.  They are the
dataframes used to graph the final group models and are prefaced
GIMMEgVAR_RESULTS_GRP_BETA_THRESHOLD_ and GIMMEgVAR_RESULTS_GRP_KAPPA_THRESHOLD_.
The number following threshold indicates the gimmeThreshold used for the analysis.
</p>
<p>(4) Final network graphs are added to the gimmegvarFiles folder in .png format.
These contain overlay graphs of the group and individual paths for the beta and
kappa network respectively.
</p>

<hr>
<h2 id='fitGraphicalVAR'>fitgraphicalVAR</h2><span id='topic+fitGraphicalVAR'></span>

<h3>Description</h3>

<p>Fits 'graphicalVAR' with defaults used in 'graphicalVAR' package developed by Sacha Epskamp.
See 'graphicalVAR' documentation by Sacha Epskamp for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGraphicalVAR(
  data,
  nLambda = 50,
  verbose = TRUE,
  gamma,
  scale = TRUE,
  lambda_beta,
  lambda_kappa,
  regularize_mat_beta,
  regularize_mat_kappa,
  maxit.in = 100,
  maxit.out = 100,
  deleteMissings = TRUE,
  penalize.diagonal = TRUE,
  lambda_min_kappa = 0.05,
  lambda_min_beta = lambda_min_kappa,
  mimic = c("current"),
  variableNames,
  beepvar,
  dayvar,
  idvar,
  lags = 1,
  centerWithin = TRUE,
  likelihood = c("unpenalized", "penalized"),
  outputPath
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitGraphicalVAR_+3A_data">data</code></td>
<td>
<p>A matrix or data frame containing repeated measures (rows) on a set of variables (columns).
Must not contain missing data.</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_nlambda">nLambda</code></td>
<td>
<p>The number of both lambda parameters to test. Defaults to 50,
which results in 2500 models to evaluate.</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_verbose">verbose</code></td>
<td>
<p>Logical, should a progress bar be printed to the console?</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_gamma">gamma</code></td>
<td>
<p>The EBIC hyper-parameter. Set to 0 to use regular BIC.</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_scale">scale</code></td>
<td>
<p>Logical, should responses be standardized before estimation?</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_lambda_beta">lambda_beta</code></td>
<td>
<p>An optional vector of lambda_beta values to test.
Set lambda_beta = 0 argument and lambda_kappa = 0 for unregularized estimation.</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_lambda_kappa">lambda_kappa</code></td>
<td>
<p>An optional vector of lambda_kappa values to test.
Set lambda_beta = 0 argument and lambda_kappa = 0 for unregularized estimation.</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_regularize_mat_beta">regularize_mat_beta</code></td>
<td>
<p>A logical matrix indicating which elements of the beta matrix should be regularized (experimental).</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_regularize_mat_kappa">regularize_mat_kappa</code></td>
<td>
<p>A logical matrix indicating which elements of the kappa matrix should be regularized (experimental).</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_maxit.in">maxit.in</code></td>
<td>
<p>Maximum number of iterations in the inner loop (computing beta)</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_maxit.out">maxit.out</code></td>
<td>
<p>Maximum number of iterations in the outer loop</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_deletemissings">deleteMissings</code></td>
<td>
<p>Logical, should missing responses be deleted?</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_penalize.diagonal">penalize.diagonal</code></td>
<td>
<p>Logical, should the diagonal of beta be penalized (i.e., penalize auto-regressions)?</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_lambda_min_kappa">lambda_min_kappa</code></td>
<td>
<p>Multiplier of maximal tuning parameter for kappa</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_lambda_min_beta">lambda_min_beta</code></td>
<td>
<p>Multiplier of maximal tuning parameter for beta</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_mimic">mimic</code></td>
<td>
<p>Allows one to mimic earlier versions of 'graphicalVAR'</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_variablenames">variableNames</code></td>
<td>
<p>The vector containing name of variables to be analyzed</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_beepvar">beepvar</code></td>
<td>
<p>String indicating assessment beep per day (if missing, is added).
Adding this argument will cause non-consecutive beeps to be treated as missing!</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_dayvar">dayvar</code></td>
<td>
<p>String indicating assessment day. Adding this argument makes sure that the first measurement of a day is not
regressed on the last measurement of the previous day.
IMPORTANT: only add this if the data has multiple observations per day.</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_idvar">idvar</code></td>
<td>
<p>String indicating the subject ID</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_lags">lags</code></td>
<td>
<p>Vector of lags to include</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_centerwithin">centerWithin</code></td>
<td>
<p>logical, should subject data be within-person centered before estimating fixed effects?</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_likelihood">likelihood</code></td>
<td>
<p>Should likelihood be computed based on penalized contemporaneous matrix or</p>
</td></tr>
<tr><td><code id="fitGraphicalVAR_+3A_outputpath">outputPath</code></td>
<td>
<p>The user specified path to the directory where results files should be stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following results are returned in the gvarFiles directory:
(1) Separate data frames containing the usual individual 'graphicalVAR' results.
These dataframes contain the person-specific results for each individual obtained by fitting 'graphicalVAR'.
They are prefixed RESULTS_GVAR_SUBJECT
The number of data frames returned equals the number of individuals whose models were successfully
fitted from the input data file.
</p>

<hr>
<h2 id='GIMMEgVAR'>GIMMEgVAR
'
This function calls all the functions needed to fit 'GIMMEgVAR'.</h2><span id='topic+GIMMEgVAR'></span>

<h3>Description</h3>

<p>GIMMEgVAR
'
This function calls all the functions needed to fit 'GIMMEgVAR'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GIMMEgVAR(
  outputPath,
  data,
  nLambda = 50,
  verbose = TRUE,
  gamma,
  scale = TRUE,
  lambda_beta,
  lambda_kappa,
  regularize_mat_beta,
  regularize_mat_kappa,
  maxit.in = 100,
  maxit.out = 100,
  deleteMissings = TRUE,
  penalize.diagonal = TRUE,
  lambda_min_kappa = 0.05,
  lambda_min_beta = lambda_min_kappa,
  mimic = c("current"),
  variableNames,
  beepvar,
  dayvar,
  idvar,
  lags = 1,
  centerWithin = TRUE,
  likelihood = c("unpenalized", "penalized"),
  gimmeGVARThreshold = 0.5,
  labelNames = variableNames
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GIMMEgVAR_+3A_outputpath">outputPath</code></td>
<td>
<p>The user specified path to the directory where results files should be stored.</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_data">data</code></td>
<td>
<p>A matrix or data frame containing repeated measures (rows) on a set of variables (columns).
Must not contain missing data.</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_nlambda">nLambda</code></td>
<td>
<p>The number of both lambda parameters to test. Defaults to 50,
which results in 2500 models to evaluate.</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_verbose">verbose</code></td>
<td>
<p>Logical, should a progress bar be printed to the console?</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_gamma">gamma</code></td>
<td>
<p>The EBIC hyper-parameter. Set to 0 to use regular BIC.</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_scale">scale</code></td>
<td>
<p>Logical, should responses be standardized before estimation?</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_lambda_beta">lambda_beta</code></td>
<td>
<p>An optional vector of lambda_beta values to test.
Set lambda_beta = 0 argument and lambda_kappa = 0 for unregularized estimation.</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_lambda_kappa">lambda_kappa</code></td>
<td>
<p>An optional vector of lambda_kappa values to test.
Set lambda_beta = 0 argument and lambda_kappa = 0 for unregularized estimation.</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_regularize_mat_beta">regularize_mat_beta</code></td>
<td>
<p>A logical matrix indicating which elements of the beta matrix should be regularized (experimental).
Note: In 'GIMMEgVAR' this matrix is determined and set for the user based on their gimmeThreshold
and the results of fitting individual 'graphicalVAR' across all individuals. The logical matrix used
to fit determine which elements of the beta matrix are regularized is returned in the gimmegvarFiles folder
and is named logicalKappa.</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_regularize_mat_kappa">regularize_mat_kappa</code></td>
<td>
<p>A logical matrix indicating which elements of the kappa matrix should be regularized (experimental).
Note: In 'GIMMEgVAR' this matrix is determined and set for the user based on their gimmeThreshold
and the results of fitting individual 'graphicalVAR' across all individuals. The logical matrix used
to fit determine which elements of the beta matrix are regularized is returned in the gvarFiles folder
and is named logicalKappa.</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_maxit.in">maxit.in</code></td>
<td>
<p>Maximum number of iterations in the inner loop (computing beta)</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_maxit.out">maxit.out</code></td>
<td>
<p>Maximum number of iterations in the outer loop</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_deletemissings">deleteMissings</code></td>
<td>
<p>Logical, should missing responses be deleted?</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_penalize.diagonal">penalize.diagonal</code></td>
<td>
<p>Logical, should the diagonal of beta be penalized (i.e., penalize auto-regressions)?</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_lambda_min_kappa">lambda_min_kappa</code></td>
<td>
<p>Multiplier of maximal tuning parameter for kappa</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_lambda_min_beta">lambda_min_beta</code></td>
<td>
<p>Multiplier of maximal tuning parameter for beta</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_mimic">mimic</code></td>
<td>
<p>Allows one to mimic earlier versions of graphicalVAR</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_variablenames">variableNames</code></td>
<td>
<p>The vector containing name of variables to be analyzed in the network model</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_beepvar">beepvar</code></td>
<td>
<p>String indicating assessment beep per day (if missing, is added).
Adding this argument will cause non-consecutive beeps to be treated as missing!</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_dayvar">dayvar</code></td>
<td>
<p>String indicating assessment day. Adding this argument makes sure that the first measurement of a day is not
regressed on the last measurement of the previous day.
IMPORTANT: only add this if the data has multiple observations per day.</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_idvar">idvar</code></td>
<td>
<p>String indicating the subject ID</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_lags">lags</code></td>
<td>
<p>Vector of lags to include</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_centerwithin">centerWithin</code></td>
<td>
<p>logical, should subject data be within-person centered before estimating fixed effects?</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_likelihood">likelihood</code></td>
<td>
<p>Should likelihood be computed based on penalized contemporaneous matrix or
unpenalized contemporaneous matrix. Set to &quot;penalized&quot; to mimic version 2.5 and later of sparseTSCGM.</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_gimmegvarthreshold">gimmeGVARThreshold</code></td>
<td>
<p>The cutoff value for group-level paths. Defaults to .50, indicating
that a path must be non-zero across &gt;= .50
included as a group-level path.</p>
</td></tr>
<tr><td><code id="GIMMEgVAR_+3A_labelnames">labelNames</code></td>
<td>
<p>Vector of names used to label nodes in Network graph. Defaults to variable names if no
vector is supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing 7 elements.  The first 6 elements are the group level results indicating the count, proportion
and presence (coded 1 for present, 0 for absent) of the edges estimated by the algorithm in the kappa and beta matrices.
These results are stored in matrix objects named pathCountBeta, pathProportionBeta, groupBeta and pathCountKappa,
pathProportionKappa, and groupKappa respectively and are used to construct the final group level network. The remaining
element is a list which contains the person-specific network results for every subject in the data. This is estimated using
information from the group-level network model. Along with the the data used to estimate the networks, it contains the following for each subject:
</p>
<table>
<tr><td><code>PCC</code></td>
<td>
<p>The partial contemporaneous correlation network</p>
</td></tr>
<tr><td><code>PDC</code></td>
<td>
<p>The  partial directed correlation network</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The estimated beta matrix</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>The estimated kappa matrix</p>
</td></tr>
<tr><td><code>EBIC</code></td>
<td>
<p>The optimal EBIC</p>
</td></tr>
<tr><td><code>path</code></td>
<td>
<p>Results of all tested tuning parameters</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A vector containing the node labels</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A &quot;tsData&quot; object detailing the features of the data used for estimating the network</p>
</td></tr>
</table>

<hr>
<h2 id='graphKappa'>GIMMEgVAR: GraphGIMMEgVAR</h2><span id='topic+graphKappa'></span>

<h3>Description</h3>

<p>Produces network graphs for beta and kappa matrices
as .png files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphKappa(
  outputPathGIMMEgVAR,
  gimmeGVARThreshold,
  pathProportionKappa,
  lableNames,
  groupKappa
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphKappa_+3A_outputpathgimmegvar">outputPathGIMMEgVAR</code></td>
<td>
<p>Directory where network graphs will be saved.</p>
</td></tr>
<tr><td><code id="graphKappa_+3A_gimmegvarthreshold">gimmeGVARThreshold</code></td>
<td>
<p>The cutoff value for group-level paths. Defaults to .50, indicating
that a path must be non-zero across &gt;= .50
included as a group-level path.</p>
</td></tr>
<tr><td><code id="graphKappa_+3A_pathproportionkappa">pathProportionKappa</code></td>
<td>
<p>The proportion of individuals identified as having a path in the Kappa
matrix.  Used to determine group-level paths in the final group Kappa network.</p>
</td></tr>
<tr><td><code id="graphKappa_+3A_lablenames">lableNames</code></td>
<td>
<p>Vector of names used to label nodes in Network graph. Defaults to variable names if no
vector is supplied.</p>
</td></tr>
<tr><td><code id="graphKappa_+3A_groupkappa">groupKappa</code></td>
<td>
<p>Matrix that identifies the presence of a group path in the Kappa matrix. 0 indicates no
group path present, 1 indicates group path present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Group and individual network paths are overlayed to form
a single network graph for each matrix, respectively.
</p>
<p>Kappa matrix is depicted using solid lines, beta network is depicted using dashed lines.
In both networks, group paths appear as black lines. Individual paths appear as light grey lines.
</p>
<p>For individual paths, line thickness is weighted by the proportion of individuals with paths
present.
</p>

<hr>
<h2 id='prepareData'>PREPARE DATA FOR FITTING 'GIMMEgVAR'</h2><span id='topic+prepareData'></span>

<h3>Description</h3>

<p>Reads in results data from fitting 'graphicalVAR'
and creates the logical matrices for kappa and
beta needed to fit 'GIMMEgVAR'.  The logical matrices determine
which paths will not be regularized in the fitting of 'GIMMEgVAR' to determine
the group level network model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareData(gimmeGVARThreshold = 0.5, RES_matrixData, outputPath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareData_+3A_gimmegvarthreshold">gimmeGVARThreshold</code></td>
<td>
<p>The cutoff value for group-level paths. Defaults to .50, indicating
that a path must be non-zero across &gt;= .50
included as a group-level path.</p>
</td></tr>
<tr><td><code id="prepareData_+3A_res_matrixdata">RES_matrixData</code></td>
<td>
<p>List containing results of fitting individual 'graphicalVAR' to each individual.</p>
</td></tr>
<tr><td><code id="prepareData_+3A_outputpath">outputPath</code></td>
<td>
<p>The user specified path to the directory where results files should be stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following results are returned in the gvarFiles directory:
(1) Returns two data frames that hold the logical matrices for beta and kappa.  These
are named logicalBeta and logicalKappa
</p>
<p>(2) Returns two data frames that indicate the proportion of paths across individuals.
These are data frames containing the proportion of paths present across
individuals after fitting 'graphicalVAR'.  These proportions are used to determine
potential group paths which will not be regularized for individuals when fitting the
final 'GIMMEgVAR'. The output files are named proportionKappa.RData and proportionBeta.RData
</p>

<hr>
<h2 id='sampleData'>sampleData</h2><span id='topic+sampleData'></span>

<h3>Description</h3>

<p>List containing 10 elements.  Each element consists of a data frame with time series data that was
generated via simulation.
</p>


<h3>Format</h3>

<p>## 'sampleData'
Each element in the list contains a data frame for an individual subject.  Each data frame has 150 observations
of 10 variables (V1-V10) that can be used for fitting GIMMEgVAR.  The variable Idnum is the unique subject ID.
</p>

<dl>
<dt>V1-V10</dt><dd><p>Ten variables availalbe for us in fitting GIMMEgVAR</p>
</dd>
<dt>IDnum</dt><dd><p>Unique subject ID</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Sandra AW Lee <a href="mailto:wsandra@live.unc.edu">wsandra@live.unc.edu</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
