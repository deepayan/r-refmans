<!DOCTYPE html><html><head><title>Help for package conjurer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {conjurer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#buildCust'><p>Build a Unique Customer Identifier</p></a></li>
<li><a href='#buildDistr'><p>Build Data Distribution</p></a></li>
<li><a href='#buildHierarchy'><p>Generate hierarchical data</p></a></li>
<li><a href='#buildId'><p>Build identifier</p></a></li>
<li><a href='#buildModelData'><p>Generate Synthetic Data using uncovr API</p></a></li>
<li><a href='#buildName'><p>Build Dynamic Strings</p></a></li>
<li><a href='#buildNames'><p>Generate Names</p></a></li>
<li><a href='#buildNum'><p>Build Numeric Data</p></a></li>
<li><a href='#buildOutliers'><p>Build Outliers in Data Distribution</p></a></li>
<li><a href='#buildPareto'><p>Map Factors Based on Pareto Arguments</p></a></li>
<li><a href='#buildPattern'><p>Build a pattern</p></a></li>
<li><a href='#buildProd'><p>Build Product Data</p></a></li>
<li><a href='#buildSpike'><p>Build Spikes in the Data Distribution</p></a></li>
<li><a href='#extractDf'><p>Extract Dataframe from uncovr API Response</p></a></li>
<li><a href='#genFirstPairs'><p>Extracts the First Two Alphabets of the String</p></a></li>
<li><a href='#genIndepDepJson'><p>Generate Body for the POST Function of Uncovr</p></a></li>
<li><a href='#genMatrix'><p>Generate Frequency Distribution Matrix</p></a></li>
<li><a href='#genPattern'><p>Generate a pattern</p></a></li>
<li><a href='#genTrans'><p>Build Transaction Data</p></a></li>
<li><a href='#genTree'><p>Generate complete m-ary connected graph</p></a></li>
<li><a href='#genTriples'><p>Extracts Three Consecutive Alphabets of the String</p></a></li>
<li><a href='#missingArgHandler'><p>Handle Missing Arguments in Function</p></a></li>
<li><a href='#nextAlphaProb'><p>Generate Next Alphabet</p></a></li>
<li><a href='#treeDf'><p>A supporting function.</p></a></li>
<li><a href='#uncovrApi'><p>POST Function for Calling uncovr API</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Parametric Method for Generating Synthetic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-15</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates synthetic data distributions to enable testing various modelling techniques in ways that real data does not allow. Noise can be added in a controlled manner such that the data seems real. This methodology is generic and therefore benefits both the academic and industrial research.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>jsonlite(&ge; 1.8.0), httr (&ge; 1.4.2), methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.foyi.co.nz/posts/documentation/documentationconjurer/">https://www.foyi.co.nz/posts/documentation/documentationconjurer/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SidharthMacherla/conjurer/issues">https://github.com/SidharthMacherla/conjurer/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-18 00:21:38 UTC; Sidharth Macherla</td>
</tr>
<tr>
<td>Author:</td>
<td>Sidharth Macherla <a href="https://orcid.org/0000-0002-4825-2026"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sidharth Macherla &lt;msidharthrasik@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-18 08:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='buildCust'>Build a Unique Customer Identifier</h2><span id='topic+buildCust'></span>

<h3>Description</h3>

<p>Builds a customer identifier. This is often used as a primary key of the customer dim table in databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildCust(numOfCust)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildCust_+3A_numofcust">numOfCust</code></td>
<td>
<p>A natural number. This specifies the number of unique customer identifiers to be built.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A customer is identified by a unique customer identifier(ID). A customer ID is alphanumeric with prefix &quot;cust&quot; followed by a numeric. This numeric ranges from 1 and extend to the number of customers provided as the argument within the function. For example, if there are 100 customers, then the customer ID will range from cust001 to cust100. This ensures that the customer ID is always of the same length.
</p>


<h3>Value</h3>

<p>A character with unique customer identifiers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- buildCust(numOfCust = 1000)
df &lt;- buildCust(numOfCust = 223)
</code></pre>

<hr>
<h2 id='buildDistr'>Build Data Distribution</h2><span id='topic+buildDistr'></span>

<h3>Description</h3>

<p>Builds data distribution. For example, the function <code><a href="#topic+genTrans">genTrans</a></code> uses this function to build the data distributions necessary. This function uses trigonometry based functions to generate data. This is an internal function and is currently not exported in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildDistr(st, en, cycles, trend, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildDistr_+3A_st">st</code></td>
<td>
<p>A number. This defines the starting value of the number of data points.</p>
</td></tr>
<tr><td><code id="buildDistr_+3A_en">en</code></td>
<td>
<p>A number. This defines the ending value of the number of data points.</p>
</td></tr>
<tr><td><code id="buildDistr_+3A_cycles">cycles</code></td>
<td>
<p>A string. This defines the cyclicality of data distribution.</p>
</td></tr>
<tr><td><code id="buildDistr_+3A_trend">trend</code></td>
<td>
<p>A number. This defines the trend of data distribution i.e if the data has a positive slope or a negative slope.</p>
</td></tr>
<tr><td><code id="buildDistr_+3A_n">n</code></td>
<td>
<p>A numeric. This specifies the number of values to be generated. It should be non-zero natural number. This parameter is currently used by the function <code><a href="#topic+buildNum">buildNum</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A parametric method is used to build data distribution. The data distribution function uses the formulation of
</p>
<p style="text-align: center;"><code class="reqn">sin(a*x) + cos(b*x) + c</code>
</p>

<p>Where,
</p>

<ol>
<li><p> a and b are the parameters
</p>
</li>
<li><p> x is a variable
</p>
</li>
<li><p> c is a constant
</p>
</li></ol>

<p>Firstly, parameter 'a' defines the number of outer level crests (peaks in the data distribution). Generally speaking, the number of crests is approximately twice the value of a. This means that if a is set to a value 0.5, there will be one crest and if it is set to 2, there will be 4 crests. On account of this behavior, this parameter is set based on the argument cycles of the function. For example, if the argument cycles is set to &quot;y&quot; i.e yearly cycle, it means that there must be one crest i.e peak in the distribution. To have one crest, the parameter must be around 0.5. A random number is then generated between 0.2 and 0.6 to get to that one crest.
</p>
<p>Secondly, the variable 'x' is the x-axis of the data distribution. Since the function  <code><a href="#topic+buildDistr">buildDistr</a></code> is used internally to generate data at different levels, this variable could have a range of 1 to 12 or 1 to 31 depending on the arguments 'st' and 'en'. For example, if the data is generated at the month level, then arguments 'st' is set to 1 and 'en' is set to 12. Similarly, if the data is set to day level, the 'st' is set to 1 and 'en' is set to the number of days in that month i.e 28 for month 2 and 31 for month 12 etc.
</p>
<p>Thirdly, the parameter 'b' defines the inner level crests(peaks in data distribution). This parameter helps in making the data distribution seem more realistic by adding more &quot;ruggedness&quot; of the distribution.
</p>
<p>Finally, the constant 'c' is the intercept part of the formulation and primarily serves as a way to ensure that the data distribution has a positive 'y' axis component. This value is randomly generated between 2 and 5.
</p>


<h3>Value</h3>

<p>A data frame with data distribution is returned.
</p>

<hr>
<h2 id='buildHierarchy'>Generate hierarchical data</h2><span id='topic+buildHierarchy'></span>

<h3>Description</h3>

<p>Generates hierarchical data by using an internal function <code><a href="#topic+genTree">genTree</a></code>. For a working example, please see the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildHierarchy(type, splits, numOfLevels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildHierarchy_+3A_type">type</code></td>
<td>
<p>A string. In its current state, this is only a placeholder function and is not mandatory. Currently, only one type of hierarchy is permitted namely <code class="reqn">equalSplit</code>.</p>
</td></tr>
<tr><td><code id="buildHierarchy_+3A_splits">splits</code></td>
<td>
<p>A positive number. This specifies the number of splits at each branch. For instance, if <code class="reqn">split</code> is 2 then, each branch will have 2 sub-branches.</p>
</td></tr>
<tr><td><code id="buildHierarchy_+3A_numoflevels">numOfLevels</code></td>
<td>
<p>A positive number. This specifies the number of layers in the hierarchy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function helps in generating hierarchical data. If there are multiple categorical variables i.e. classes that are mapped to other classes in a hierarchical manner, this function helps in building the same. Some common use cases for this type of data are Linnaean system of classification in life sciences and product hierarchy in retail industry.
The number of terminal nodes are dependent on the arguments <code class="reqn">splits</code> and <code class="reqn">numOfLevels</code>. More precisely, the number of terminal nodes has the formulation of <code class="reqn">splits^numOfLevels</code>. For instance, if <code class="reqn">splits</code> is 2 and <code class="reqn">numOfLevels</code> is 3, then the number of terminal nodes are <code class="reqn">2^3</code> i.e. 8. Furthermore, the number of columns of the output dataframe is equal to the <code class="reqn">numOfLevels</code>. Although a hierarchical data sctructure is often represented as a tree structure, this function outputs the data in a denormalized form i.e a dataframe.
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>productHierarchy &lt;- buildHierarchy(type = "equalSplit", splits = 2, numOfLevels = 3)
productHierarchy &lt;- buildHierarchy(splits = 2, numOfLevels = 3)
</code></pre>

<hr>
<h2 id='buildId'>Build identifier</h2><span id='topic+buildId'></span>

<h3>Description</h3>

<p>Builds strings that could be used as identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildId(numOfItems, prefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildId_+3A_numofitems">numOfItems</code></td>
<td>
<p>A number. This defines the number of elements to be output.</p>
</td></tr>
<tr><td><code id="buildId_+3A_prefix">prefix</code></td>
<td>
<p>A string. This defines the prefix for the strings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to build an alphanumeric sequence that can be used as a primary key in a data table or a unique identifier of an element.
</p>


<h3>Value</h3>

<p>A character with the alphanumeric strings is returned. These strings use the prefix that is mentioned in the argument &quot;prefix&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>userId &lt;- buildId(numOfItems = 3, prefix = "uid")
</code></pre>

<hr>
<h2 id='buildModelData'>Generate Synthetic Data using uncovr API</h2><span id='topic+buildModelData'></span>

<h3>Description</h3>

<p>Please refer to the official documentation of uncovr at <em>https://www.foyi.co.nz/posts/documentation/documentationuncovr/</em> for a detailed explanation. This function generates data i.e. independent variables and dependent variable. Besides these variables, this function sources the linear function i.e. model formula.This function needs to be used along with other function such as <code><a href="#topic+extractDf">extractDf</a></code> so as to extract relevant portions of the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildModelData(numOfObs, numOfVars, key, modelObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildModelData_+3A_numofobs">numOfObs</code></td>
<td>
<p>A number. This represents the number of observations in the data. In other words, the number of rows of data that are requested to be generated. The <em>numOfObs</em> argument must be a non-negative integer and in the current version, this function accepts a range of 100 to 10,000.</p>
</td></tr>
<tr><td><code id="buildModelData_+3A_numofvars">numOfVars</code></td>
<td>
<p>A number. This represents the number of independent variables in the data. In other words, the number of columns besides the dependent variable of data that are requested to be generated. The <em>numOfVars</em> argument must be a non-negative integer and in the current version, this function accepts a range of 1 to 100.</p>
</td></tr>
<tr><td><code id="buildModelData_+3A_key">key</code></td>
<td>
<p>An alpha numeric. This is the subscription key that can be sourced from the developer portal of uncovr API available at <em>https://foyi.developer.azure-api.net/</em>.</p>
</td></tr>
<tr><td><code id="buildModelData_+3A_modelobj">modelObj</code></td>
<td>
<p>Optional argument. A glm or lm model object where both the dependent and independent variables are continuous.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function that helps in sending the details of the requested data to uncovr API end point and source its response. The purpose of this function can be best understood when explained within the context that is given below. There is a closed source SaaS(Software as a Service) software named <em>uncovr</em> that provides an API(Application Programming Interface). In its current state, the SaaS software is free to use with some constraints around the volume of data and the frequency of API calls. One of the functions of <em>uncovr</em> API takes an input of number of observations i.e. rows and number of independent variables namely columns and gives an output. The input of the <em>uncovr</em> function is required to be sent as part of the body of the html POST functionality. This function <em>buildModelData</em> creates the json in the form required by <em>uncovr</em> API and sources the response. This function uses an internal function <code><a href="#topic+uncovrApi">uncovrApi</a></code> to connect to the API endpoint and uses another internal function namely <code><a href="#topic+genIndepDepJson">genIndepDepJson</a></code> to build the necessary body of the POST function.
</p>


<h3>Value</h3>

<p>A json with details such as the requested data, model performance metrics and the model formula.
</p>

<hr>
<h2 id='buildName'>Build Dynamic Strings</h2><span id='topic+buildName'></span>

<h3>Description</h3>

<p>Builds strings that could be further used as identifiers. This is an internal function and is currently not exported in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildName(numOfItems, prefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildName_+3A_numofitems">numOfItems</code></td>
<td>
<p>A number. This defines the number of elements to be output.</p>
</td></tr>
<tr><td><code id="buildName_+3A_prefix">prefix</code></td>
<td>
<p>A string. This defines the prefix for the strings. For example, the function buildCust uses this function and passes the prefix &quot;cust&quot; while the function buildProd passes the prefix &quot;sku&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by other internal functions namely, buildCust and buildProd to produce the alphanumeric identifiers for customers and products respectively.
</p>


<h3>Value</h3>

<p>A character with the alphanumeric strings is returned. These strings use the prefix that is mentioned in the argument &quot;prefix&quot;
</p>

<hr>
<h2 id='buildNames'>Generate Names</h2><span id='topic+buildNames'></span>

<h3>Description</h3>

<p>Generates names based on a given training data or using the default data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildNames(dframe, numOfNames, minLength, maxLength)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildNames_+3A_dframe">dframe</code></td>
<td>
<p>A dataframe. This argument is passed on to another function <code><a href="#topic+genMatrix">genMatrix</a></code> for generating an alphabet frequency table. This dataframe is single column dataframe with rows that contain names. These names must only contain english alphabets(upper or lower case) from A to Z.</p>
</td></tr>
<tr><td><code id="buildNames_+3A_numofnames">numOfNames</code></td>
<td>
<p>A numeric. This specifies the number of names to be generated. It should be non-zero natural number.</p>
</td></tr>
<tr><td><code id="buildNames_+3A_minlength">minLength</code></td>
<td>
<p>A numeric. This specifies the minimum number of alphabets in the name. It must be a non-zero natural number.</p>
</td></tr>
<tr><td><code id="buildNames_+3A_maxlength">maxLength</code></td>
<td>
<p>A numeric. This specifies the maximum number of alphabets in the name. It must be a non-zero natural number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates names. There are two options to generate names. The first option is to use an existing sample of names and generate names. The second option is to use the default table of prior probabilities.
</p>


<h3>Value</h3>

<p>A list of names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>buildNames(numOfNames = 3, minLength = 5, maxLength = 7)
</code></pre>

<hr>
<h2 id='buildNum'>Build Numeric Data</h2><span id='topic+buildNum'></span>

<h3>Description</h3>

<p>Build Numeric Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildNum(n, st, en, disp, outliers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildNum_+3A_n">n</code></td>
<td>
<p>A number. This specifies the number of values to be generated.</p>
</td></tr>
<tr><td><code id="buildNum_+3A_st">st</code></td>
<td>
<p>A number. This defines the starting value of the number of data points.</p>
</td></tr>
<tr><td><code id="buildNum_+3A_en">en</code></td>
<td>
<p>A number. This defines the ending value of the number of data points.</p>
</td></tr>
<tr><td><code id="buildNum_+3A_disp">disp</code></td>
<td>
<p>A number between <code class="reqn">-(pi/2)</code> and  <code class="reqn">(pi/2)</code>. This defines the dispersion of the distribution.</p>
</td></tr>
<tr><td><code id="buildNum_+3A_outliers">outliers</code></td>
<td>
<p>A number. This signifies the presence of outliers. If set to value 1, then outliers are generated randomly. If set to value 0, then no outliers are generated. The presence of outliers is a very common occurrence and hence setting the outliers to 1 is recommended. However, there are instances where outliers are not needed. For example, if the objective of data generation is solely for visualization purposes then outliers may not be needed. The default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function helps in generating numeric data such as age, height, weight etc. This function could be used along with other functions such as <code><a href="#topic+buildCust">buildCust</a></code> to make it more meaningful. The data distribution function uses the formulation of
</p>
<p style="text-align: center;"><code class="reqn">sin((r*a)*x) + c</code>
</p>

<p>Where,
</p>

<ol>
<li><p> r is the random value such that <code class="reqn">0.8 &lt;= r &lt;= 1.2</code>. This adds <code class="reqn">+/-</code> 20% randomness to the parameter <code class="reqn">a</code>.
</p>
</li>
<li><p> a is the parameter such that, <code class="reqn">-(pi/2) &lt;= a &lt;= (pi/2)</code>.
</p>
</li>
<li><p> x is a variable such that,  <code class="reqn">(pi/2) &lt;= x &lt;= (pi/2)</code>.
</p>
</li>
<li><p> c is a constant such that <code class="reqn">2 &lt;= c &lt;= 5</code>.
</p>
</li></ol>

<p>The key component of this function is <code class="reqn">disp</code>. This helps in controlling the dispersion of the distribution. Let us assume that one would like to generate age of people in years. Furthermore, let us assume that the range of the age is between 23 and 80. If <code class="reqn">disp = 1</code>, then the function will generate more data with a negative slope i.e more people with age closer to 23 than 80. If <code class="reqn">disp = 1</code> is used, then the opposite will be true. However, if one would like to generate data that is visually similar to normal distribution i.e more people in the middle age group and less towards 23 or 80, then <code class="reqn">disp = 0.5</code> could be used.
</p>
<p>It is recommended to firstly plot the code and inspect visually to check which distribution is needed.
</p>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>age &lt;- buildNum(n = 10, st = 23, en = 80, disp = 0.5, outliers = 1)
plot(age) #visualize the resulting distribution
</code></pre>

<hr>
<h2 id='buildOutliers'>Build Outliers in Data Distribution</h2><span id='topic+buildOutliers'></span>

<h3>Description</h3>

<p>Builds outlier values and replaces random data points with outliers. This is an internal function and is currently not exported in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildOutliers(distr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildOutliers_+3A_distr">distr</code></td>
<td>
<p>numeric vector. This is the target vector which is processed for outlier generation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a common occurrence to have outliers in production data. For instance, in the retail industry, there are days such as black Friday where the sales for that day are far more than the daily average for the year. For the synthetic data generated to seem similar to production data, package conjurer uses this function to build such outlier data.
</p>
<p>This function takes a numeric vector and then randomly selects at least 1 data point and a maximum of 3 percent data points to be replaced with an outlier. The process for generating outliers is as follows. This methodology of outlier generation is based on a popular method of identifying outliers. For more details refer to the function 'outlier' in R package 'GmAMisc'.
</p>

<ol>
<li><p> First, the interquartile range(IQR) of the numeric vector is computed.
</p>
</li>
<li><p> Second, a random number between 1.5 and 3 is generated.
</p>
</li>
<li><p> Finally, the random number above is multiplied with the IQR to compute the outlier.
</p>
<p>These steps mentioned above are repeated for at least once and a maximum of 3
</p>
</li></ol>



<h3>Value</h3>

<p>A numeric vector with random values replaced with outlier values.
</p>

<hr>
<h2 id='buildPareto'>Map Factors Based on Pareto Arguments</h2><span id='topic+buildPareto'></span>

<h3>Description</h3>

<p>Maps a factor to another factor in a one to many relationship following Pareto principle. For example, 80 percent of transactions can be mapped to 20 percent of customers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildPareto(factor1, factor2, pareto)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildPareto_+3A_factor1">factor1</code></td>
<td>
<p>A factor. This factor is mapped to factor2 as given in the details section.</p>
</td></tr>
<tr><td><code id="buildPareto_+3A_factor2">factor2</code></td>
<td>
<p>A factor. This factor is mapped to factor1 as given in the details section.</p>
</td></tr>
<tr><td><code id="buildPareto_+3A_pareto">pareto</code></td>
<td>
<p>This defines the percentage allocation and is a numeric data type. This argument takes the form of c(x,y) where x and y are numeric and their sum is 100. If we set Pareto to c(80,20), it then allocates 80 percent of factor1 to 20 percent of factor 2. This is based on a well-known concept of the Pareto principle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to map one factor to another based on the Pareto argument supplied. If factor1 is a factor of customer identifiers, factor2 is a factor of transactions and Pareto is set to c(80,20), then 80 percent of customer identifiers will be mapped to 20 percent of transactions and vice versa.
</p>


<h3>Value</h3>

<p>A data frame with factor 1 and factor 2 as columns. Based on the Pareto arguments passed, column factor 1 is mapped to factor 2.
</p>

<hr>
<h2 id='buildPattern'>Build a pattern</h2><span id='topic+buildPattern'></span>

<h3>Description</h3>

<p>Builds data based on a pattern. This function uses another internal function <code><a href="#topic+genPattern">genPattern</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildPattern(n, parts, probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildPattern_+3A_n">n</code></td>
<td>
<p>A natural number. This specifies the number of data points to build.</p>
</td></tr>
<tr><td><code id="buildPattern_+3A_parts">parts</code></td>
<td>
<p>A natural number. This specifies the parts that make up the pattern.</p>
</td></tr>
<tr><td><code id="buildPattern_+3A_probs">probs</code></td>
<td>
<p>A number between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function helps in generating data based on a pattern. To explain in simple terms, this function aims to perform the exact opposite of a regular expression i.e regex function. In other words, this function generates data given a generic pattern.
The steps in the process of building data from a pattern is as follows.
</p>

<ol>
<li><p> Identify the parts that make up the data. Ideally, these parts have a pattern and a probabilistic distribution of their own. For example, a phone number has three parts namely, country code, area code and a number.
</p>
</li>
<li><p> Assign probabilities to each of the above parts. If a part contains only one member, then the corresponding probability must be 1. However, if there are multiple members in the part, then each member must have a probability provided in the respective order.
</p>
</li></ol>



<h3>Value</h3>

<p>A vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genPattern">genPattern</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parts &lt;- list(c("+91","+44","+64"), c(491,324,211), c(7821:8324))
probs &lt;- list(c(0.25,0.25,0.50), c(0.30,0.60,0.10), c())
phoneNumbers &lt;- buildPattern(n=20,parts = parts, probs = probs)
head(phoneNumbers)
parts &lt;- list(c("+91","+44","+64"), c("("), c(491,324,211), c(")"), c(7821:8324))
probs &lt;- list(c(0.25,0.25,0.50), c(1), c(0.30,0.60,0.10), c(1), c())
phoneNumbers &lt;- buildPattern(n=20,parts = parts, probs = probs)
head(phoneNumbers)
</code></pre>

<hr>
<h2 id='buildProd'>Build Product Data</h2><span id='topic+buildProd'></span>

<h3>Description</h3>

<p>Builds a unique product identifier and price. The price of the product is generated randomly within the minimum and the maximum range provided as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildProd(numOfProd, minPrice, maxPrice)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildProd_+3A_numofprod">numOfProd</code></td>
<td>
<p>A number. This defines the number of unique products.</p>
</td></tr>
<tr><td><code id="buildProd_+3A_minprice">minPrice</code></td>
<td>
<p>A number. This is the minimum value of the product's price range.</p>
</td></tr>
<tr><td><code id="buildProd_+3A_maxprice">maxPrice</code></td>
<td>
<p>A number. This is the maximum value of the product's price range.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A product ID is alphanumeric with prefix &quot;sku&quot; which signifies a stock keeping unit. This prefix is followed by a numeric ranging from 1 and extending to the number of products provided as the argument within the function. For example, if there are 10 products, then the product ID will range from sku01 to sku10. This ensures that the product ID is always of the same length. For these product IDs, the product price will be within the range of minPrice and maxPrice arguments.
</p>


<h3>Value</h3>

<p>A character with product identifier and price.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- buildProd(numOfProd = 1000, minPrice = 5, maxPrice = 100)
df &lt;- buildProd(numOfProd = 29, minPrice = 3, maxPrice = 50)
</code></pre>

<hr>
<h2 id='buildSpike'>Build Spikes in the Data Distribution</h2><span id='topic+buildSpike'></span>

<h3>Description</h3>

<p>Builds spikes in the data distribution. For example, in retail industry transactions are generally higher during the holiday season such as December. This function is used to set the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildSpike(distr, spike)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildSpike_+3A_distr">distr</code></td>
<td>
<p>numeric vector. This is the input vector for which the spike value needs to be set.</p>
</td></tr>
<tr><td><code id="buildSpike_+3A_spike">spike</code></td>
<td>
<p>A number. This represents the seasonality of data. It can take any value from 1 to 12. These numbers represent months in a year, from January to December respectively. For example, if the spike is set to 12, it means that December has the highest number of transactions. This is an internal function and is currently not exported in the package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector reordered
</p>

<hr>
<h2 id='extractDf'>Extract Dataframe from uncovr API Response</h2><span id='topic+extractDf'></span>

<h3>Description</h3>

<p>This function extracts the dataframe from the output of the <code><a href="#topic+buildModelData">buildModelData</a></code> function. Please refer to the official documentation of uncovr at <em>https://www.foyi.co.nz/posts/documentation/documentationuncovr/</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractDf(uncovrJson)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractDf_+3A_uncovrjson">uncovrJson</code></td>
<td>
<p>A json. This is the output of the <code><a href="#topic+buildModelData">buildModelData</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function can be best understood when explained within the context that is given below. There is a closed source SaaS(Software as a Service) software named <em>uncovr</em> that provides an API(Application Programming Interface). In its current state, the SaaS software is free to use with some constraints around the volume of data and the frequency of API calls. One of the functions of <em>uncovr</em> API takes an input of number of observations i.e. rows and number of independent variables namely columns and gives an output. This output is in the form of a json file and has many other elements besides the dependent and independent variables. This function <em>extractDf</em> helps in extracting the dataframe from the json.
</p>


<h3>Value</h3>

<p>A dataframe with dependent and independent variables. The independent variables are prefixed with <em>iv</em> and the dependent variable is named <em>dv</em>.
</p>

<hr>
<h2 id='genFirstPairs'>Extracts the First Two Alphabets of the String</h2><span id='topic+genFirstPairs'></span>

<h3>Description</h3>

<p>For a given string, this function extracts the first two alphabets. This function is further used by <code><a href="#topic+genMatrix">genMatrix</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genFirstPairs(s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genFirstPairs_+3A_s">s</code></td>
<td>
<p>A string. This is the string from which the first two alphabets are to be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>First two alphabets of the string input.
</p>

<hr>
<h2 id='genIndepDepJson'>Generate Body for the POST Function of Uncovr</h2><span id='topic+genIndepDepJson'></span>

<h3>Description</h3>

<p>This is an internal function used by <code><a href="#topic+buildModelData">buildModelData</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genIndepDepJson(numOfObs, numOfVars, modelObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genIndepDepJson_+3A_numofobs">numOfObs</code></td>
<td>
<p>A number. This represents the number of observations in the data. In other words, the number of rows of data that are requested to be generated. The <em>numOfObs</em> argument must be a non-negative integer.</p>
</td></tr>
<tr><td><code id="genIndepDepJson_+3A_numofvars">numOfVars</code></td>
<td>
<p>A number. This represents the number of variables in the data. In other words, the number of columns of data that are requested to be generated. The <em>numOfVars</em> argument must be a non-negative integer.</p>
</td></tr>
<tr><td><code id="genIndepDepJson_+3A_modelobj">modelObj</code></td>
<td>
<p>An optional argument. An lm or glm model object. The current limitation is that the independent and dependent variables must be continuous.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is one of the core functions for the generation of data that comprises of independent and dependent variables. The purpose of this function can be best understood when explained within the context that is given below. There is a proprietary SaaS(Software as a Service) software named <em>uncovr</em> that provides an API(Application Programming Interface). In its current state, the SaaS software is free to use with some constraints around the volume of data and the frequency of API calls. One of the functions of <em>uncovr</em> API takes is to source inputs such as number of observations i.e. rows and number of independent variables namely columns and gives an output. The input of the <em>uncovr</em> function is required to be sent as part of the body of the html POST functionality. This function <em>genIndepDepJson</em> creates the json in the form required by <em>uncovr</em> API.
As an optional argument, an lm or glm model object can be passed using the <em>modelObj</em> argument. This will ensure that the coefficients of the independent variables are sourced from the model object instead of generating  randomly by the <em>uncovr</em> API. The current limitation is that the independent and dependent variables must be continuous.
</p>


<h3>Value</h3>

<p>A json with the details of independent variable and the dependent variable. The format of this json is as required by the <em>uncovr</em> api end point.
</p>

<hr>
<h2 id='genMatrix'>Generate Frequency Distribution Matrix</h2><span id='topic+genMatrix'></span>

<h3>Description</h3>

<p>For a given names dataframe and placement, a frequency distribution table is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genMatrix(dframe, placement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genMatrix_+3A_dframe">dframe</code></td>
<td>
<p>A dataframe with one column that has one name per row. These names must be english alphabets from A to Z and must not include any non-alphabet characters such as as hyphen or apostrophe.</p>
</td></tr>
<tr><td><code id="genMatrix_+3A_placement">placement</code></td>
<td>
<p>A string argument that takes three values namely &quot;first&quot;, &quot;last&quot; and &quot;all&quot;. Currently, only &quot;first&quot; and &quot;all&quot; are used while the option &quot;last&quot; is a placeholder for future versions of the package **conjurer**</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to generate a frequency distribution table of alphabets. There are currently 2 tables that could be generated using this function.
The first table is generated using the internal function <code><a href="#topic+genFirstPairs">genFirstPairs</a></code>. For this, the argument <em>placement</em> is assigned the value &quot;first&quot;. The rows of the table returned by the function represent the first alphabet of the string and the columns represent the second alphabet. The values in the table represent the number of times the combination is observed i.e the combination of the row and column alphabets.
</p>
<p>The second table is generated using the internal function <code><a href="#topic+genTriples">genTriples</a></code>. For this, the argument <em>placement</em> is assigned the value &quot;all&quot;. The rows of the table returned by the function represent two consecutive alphabets of the string and the columns represent the third consecutive alphabet. The values in the table represent the number of times the combination is observed i.e the combination of the row and column alphabets.
</p>


<h3>Value</h3>

<p>A table. The rows and columns of the table depend on the argument <em>placement</em>. A detailed explanation is as given below in the detail section.
</p>

<hr>
<h2 id='genPattern'>Generate a pattern</h2><span id='topic+genPattern'></span>

<h3>Description</h3>

<p>Generates data based on a pattern. This function is used by another internal function <code><a href="#topic+buildPattern">buildPattern</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genPattern(orderedList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genPattern_+3A_orderedlist">orderedList</code></td>
<td>
<p>A list of lists. The element <code class="reqn">values</code> of the sublist is a vector of characters(string or numeric or special character) and the element <code class="reqn">probs</code> is a vector of probabilities. The range of the probs is 0 to 1 and length of the <code class="reqn">probs</code> vector is either equal to length of <code class="reqn">values</code> or NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function helps in generating data based on a pattern. To explain in simple terms, this function aims to perform the exact opposite of a regular expression i.e regex function. In other words, this function generates data given a generic pattern.
The input is a list of components that make up the pattern. Each component i.e element of the list is a also list with two vectors namely <code class="reqn">values</code> and <code class="reqn">probs</code>. The vector <code class="reqn">values</code> has the set of values out of which one of them is selected randomly. If this random selection is supposed to be completely random, then the next vector <code class="reqn">probs</code> can be left empty i.e. NULL. However, if the random selection of values is expected to follow a a pre-determined probabilistic distribution, then the probabilities must be provided explicitly. To explain further, if there are three values <code class="reqn">a</code>, <code class="reqn">b</code>, <code class="reqn">c</code> and their probabilistic distribution must be 25 percent, 50 percent and 25 percent respectively, then the vector <code class="reqn">values</code> will take the form <code class="reqn">c(a,b,c)</code> and the vector <code class="reqn">probs</code> will take the form <code class="reqn">c(0.25,0.5,0.25)</code>.
</p>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>See Also</h3>

<p>[buildPattern()]
</p>

<hr>
<h2 id='genTrans'>Build Transaction Data</h2><span id='topic+genTrans'></span>

<h3>Description</h3>

<p>Build Transaction Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genTrans(cycles, trend, transactions, spike, outliers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genTrans_+3A_cycles">cycles</code></td>
<td>
<p>This represents the cyclicality of data. It can take the following values
</p>

<ol>
<li><p> &quot;y&quot;. If cycles is set to the value &quot;y&quot;, it means that there is only one instance of a high number of transactions during the entire year. This is a very common situation for some retail clients where the highest number of sales are during the holiday period in December.
</p>
</li>
<li><p> &quot;q&quot;. If cycles is set to the value &quot;q&quot;, it means that there are 4 instances of a high number of transactions. This is generally noticed in the financial services industry where the financial statements are revised every quarter and have an impact on the equity transactions in the secondary market.
</p>
</li>
<li><p> &quot;m&quot;. If cycles is set to the value &quot;m&quot;, it means that there are 12 instances of a high number of transactions for a year. This means that the number of transactions increases once every month and then subside for the rest of the month.
</p>
</li></ol>
</td></tr>
<tr><td><code id="genTrans_+3A_trend">trend</code></td>
<td>
<p>A number. This represents the slope of data distribution. It can take a value of 1 or -1. If the trend is set to value 1, then the aggregated monthly transactions will exhibit an upward trend from January to December and vice versa if it is set to -1.</p>
</td></tr>
<tr><td><code id="genTrans_+3A_transactions">transactions</code></td>
<td>
<p>A number. This represents the number of transactions to be generated.</p>
</td></tr>
<tr><td><code id="genTrans_+3A_spike">spike</code></td>
<td>
<p>A number. This represents the seasonality of data. It can take any value from 1 to 12. These numbers represent months in a year, from January to December respectively. For example, if the spike is set to 12, it means that December has the highest number of transactions.</p>
</td></tr>
<tr><td><code id="genTrans_+3A_outliers">outliers</code></td>
<td>
<p>A number. This signifies the presence of outliers. If set to value 1, then outliers are generated randomly. If set to value 0, then no outliers are generated. The presence of outliers is a very common occurrence and hence setting the outliers to 1 is recommended. However, there are instances where outliers are not needed. For example, if the objective of data generation is solely for visualization purposes then outliers may not be needed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with day number and count of transactions on that day
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- genTrans(cycles = "y", trend = 1, transactions = 10000, spike = 10, outliers = 0)
df &lt;- genTrans(cycles = "q", trend = -1, transactions = 32000, spike = 12, outliers = 1)
</code></pre>

<hr>
<h2 id='genTree'>Generate complete m-ary connected graph</h2><span id='topic+genTree'></span>

<h3>Description</h3>

<p>Generates an m-ary connected graph that is complete. This function is used by another internal function <code><a href="#topic+buildHierarchy">buildHierarchy</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genTree(m, depth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genTree_+3A_m">m</code></td>
<td>
<p>A positive number. This specifies the number of splits at each branch.</p>
</td></tr>
<tr><td><code id="genTree_+3A_depth">depth</code></td>
<td>
<p>A positive number. This specifies the number of levels of the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function helps in generating data that is of a tree structure. To explain further, this function generates a data where there are less number of classes i.e. branches at the top i.e. the root and increase in number and increase towards the end i.e. the leaf nodes. The number of terminal nodes are dependent on the arguments <code class="reqn">m</code> and <code class="reqn">depth</code>. More precisely, the number of terminal nodes has the formulation of </p>
<p style="text-align: center;"><code class="reqn">m^depth</code>
</p>
<p>. For instance, if <code class="reqn">m</code> is 2 and <code class="reqn">depth</code> is 3, then the number of terminal nodes are <code class="reqn">2^3</code> i.e. 8.
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>See Also</h3>

<p>[buildHierarchy()] to build hierarchical data.
</p>

<hr>
<h2 id='genTriples'>Extracts Three Consecutive Alphabets of the String</h2><span id='topic+genTriples'></span>

<h3>Description</h3>

<p>For a given string, this function extracts three consecutive alphabets. This function is further used by <code><a href="#topic+genMatrix">genMatrix</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genTriples(s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genTriples_+3A_s">s</code></td>
<td>
<p>A string. This is the string from which three consecutive alphabets are to be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of three alphabet combinations of the string input.
</p>

<hr>
<h2 id='missingArgHandler'>Handle Missing Arguments in Function</h2><span id='topic+missingArgHandler'></span>

<h3>Description</h3>

<p>Replaces the missing argument with the default value. This is an internal function and is currently not exported in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missingArgHandler(argMissed, argDefault)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missingArgHandler_+3A_argmissed">argMissed</code></td>
<td>
<p>This is the argument that needs to be handled.</p>
</td></tr>
<tr><td><code id="missingArgHandler_+3A_argdefault">argDefault</code></td>
<td>
<p>This is the default value of the argument that is missing in the function called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plays the role of error handler by setting the default values of the arguments when a function is called without specifying any arguments.
</p>


<h3>Value</h3>

<p>The default value of the missing argument.
</p>

<hr>
<h2 id='nextAlphaProb'>Generate Next Alphabet</h2><span id='topic+nextAlphaProb'></span>

<h3>Description</h3>

<p>Generates next alphabet based on prior probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextAlphaProb(alphaMatrix, currentAlpha, placement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextAlphaProb_+3A_alphamatrix">alphaMatrix</code></td>
<td>
<p>A table. This table is generated using the <code><a href="#topic+genMatrix">genMatrix</a></code> function .</p>
</td></tr>
<tr><td><code id="nextAlphaProb_+3A_currentalpha">currentAlpha</code></td>
<td>
<p>A string. This is the alphabet(s) for which the next alphabet is generated.</p>
</td></tr>
<tr><td><code id="nextAlphaProb_+3A_placement">placement</code></td>
<td>
<p>A string. This takes one of the two values namely &quot;first&quot; or &quot;all&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to generate the next alphabet for a given alphabet(s). This function uses prior probabilities to generate the next alphabet. Although there are two types of input tables passed into the function by using the parameter <em>alphaMatrix</em>, the process to generate the next alphabet remains the same as given below.
</p>
<p>Firstly, the input table contains frequencies of the combination of current alphabet <em>currentAlpha</em> (represented by rows) and next alphabet(represented by columns). These frequencies are converted into a percentage at a row level. This means that for each row, the sum of all the column values will add to 1.
</p>
<p>Secondly, for the given <em>currentAlpha</em>, the table is looked up for the corresponding column where the probability is the highest. The alphabet for the column with maximum prior probability is selected as the next alphabet and is returned by the function.
</p>


<h3>Value</h3>

<p>The next alphabet following the input alphabet(s) passed by the argument <em>currentAlpha</em>.
</p>

<hr>
<h2 id='treeDf'>A supporting function.</h2><span id='topic+treeDf'></span>

<h3>Description</h3>

<p>This is used by another internal function <code><a href="#topic+genTree">genTree</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeDf(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeDf_+3A_...">...</code></td>
<td>
<p>This is a placeholder argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe.
</p>

<hr>
<h2 id='uncovrApi'>POST Function for Calling uncovr API</h2><span id='topic+uncovrApi'></span>

<h3>Description</h3>

<p>This function makes the POST call to the <em>uncovr</em> API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncovrApi(body, key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncovrApi_+3A_body">body</code></td>
<td>
<p>A json with the details of the independent and dependent variable.</p>
</td></tr>
<tr><td><code id="uncovrApi_+3A_key">key</code></td>
<td>
<p>An alpha numeric. This is the subscription key that can be sourced from the developer portal of uncovr API available at <em>https://foyi.developer.azure-api.net/</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function can be best understood when explained within the context that is given below. There is a closed source SaaS(Software as a Service) software named <em>uncovr</em> that provides an API(Application Programming Interface). In its current state, the SaaS software is free to use with some constraints around the volume of data and the frequency of API calls. One of the functions of <em>uncovr</em> API takes an input of number of observations i.e. rows and number of independent variables namely columns and gives an output. This function <em>uncovrApi</em> makes the connection to <em>uncovr</em> API and sources the response.
#function to call uncovr api
</p>


<h3>Value</h3>

<p>A json.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
