<!DOCTYPE html><html><head><title>Help for package RESI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RESI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.resi'><p>Anova method for resi objects</p></a></li>
<li><a href='#chisq2S'><p>Compute the robust effect size index estimate from chi-squared statistic.</p></a></li>
<li><a href='#d2S'><p>Covert Cohen's <em>d</em> to |S|</p></a></li>
<li><a href='#depression'><p>Depression Treatment Data</p></a></li>
<li><a href='#f2S'><p>Compute the robust effect size index estimate from F-statistic</p></a></li>
<li><a href='#fsq2S'><p>Covert Cohen's <em>f</em>^2 to S</p></a></li>
<li><a href='#ggplot.resi'><p>Plotting RESI Estimates and CIs</p></a></li>
<li><a href='#insurance'><p>US Health Insurance Data</p></a></li>
<li><a href='#omnibus'><p>Omnibus (Overall) Wald Test for resi objects</p></a></li>
<li><a href='#plot.resi'><p>Plotting RESI Estimates and CIs</p></a></li>
<li><a href='#resi'><p>Robust Effect Size Index (RESI) point and interval estimation for models</p></a></li>
<li><a href='#resi_pe'><p>Robust Effect Size Index (RESI) Point Estimation</p></a></li>
<li><a href='#Rsq2S'><p>Covert R^2 to S</p></a></li>
<li><a href='#S2d'><p>Convert S to Cohen's d</p></a></li>
<li><a href='#S2fsq'><p>Covert S to Cohen's <em>f</em>^2</p></a></li>
<li><a href='#S2Rsq'><p>Covert S to R^2</p></a></li>
<li><a href='#summary.resi'><p>Summary method for resi objects</p></a></li>
<li><a href='#t2S'><p>Compute the robust effect size index estimate from t statistic (default)</p></a></li>
<li><a href='#z2S'><p>Compute the robust effect size index estimate from Z statistic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Effect Size Index (RESI) Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Summarize model output using a robust effect size index. The index is introduced in Vandekar, Tao, &amp; Blume (2020) &lt;<a href="https://doi.org/10.1007%2Fs11336-020-09698-2">doi:10.1007/s11336-020-09698-2</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'internal_functions.R' 'summary.resi.R' 'resi.R' 'resi_pe.R'
'Anova.resi.R' 'data.R' 'chisq2S.R' 'f2S.R' 't2S.R' 'z2S.R'
'Rsq2S.R' 'S2Rsq.R' 'S2d.R' 'S2fsq.R' 'd2S.R' 'fsq2S.R'
'plot.R' 'ggplot.R' 'print.R' 'omnibus.R'</td>
</tr>
<tr>
<td>Imports:</td>
<td>aod, boot, car, clubSandwich, ggplot2, lmtest, nlme, sandwich</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gee, geepack, knitr, lme4, pscl, regtools, rmarkdown,
splines, survival, tibble, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statimagcoll.github.io/RESI/">https://statimagcoll.github.io/RESI/</a>,
<a href="https://github.com/statimagcoll/RESI">https://github.com/statimagcoll/RESI</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statimagcoll/RESI/issues">https://github.com/statimagcoll/RESI/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-16 18:32:37 UTC; megan</td>
</tr>
<tr>
<td>Author:</td>
<td>Megan Jones [aut, cre],
  Kaidi Kang [aut],
  Simon Vandekar [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Megan Jones &lt;megan.n.taylor@vanderbilt.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-16 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.resi'>Anova method for resi objects</h2><span id='topic+anova.resi'></span>

<h3>Description</h3>

<p>After running the <code><a href="#topic+resi">resi</a></code> function on a fitted model, this function can be used to print the Anova-style table component. If the resi function was run with the &lsquo;store.boot = TRUE' option to store the full matrix of bootstrapped estimates, the user can specify a different alpha level for this function&rsquo;s confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'resi'
anova(object, alpha = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.resi_+3A_object">object</code></td>
<td>
<p>an object resulting from resi function</p>
</td></tr>
<tr><td><code id="anova.resi_+3A_alpha">alpha</code></td>
<td>
<p>an optional new specification for the confidence level. Can be vector-valued</p>
</td></tr>
<tr><td><code id="anova.resi_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resi function uses the car::Anova function to compute the Anova table.
</p>


<h3>Value</h3>

<p>Returns an 'anova' object containing the computed Anova-style table
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit a model
mod = lm(charges ~ bmi + sex, data = RESI::insurance)

# run resi with the store.boot = TRUE option
resi.obj = resi(mod, nboot = 100, store.boot = TRUE, alpha = 0.01)

# run anova, specifying a different alpha level if desired
anova(resi.obj, alpha = 0.05)
</code></pre>

<hr>
<h2 id='chisq2S'>Compute the robust effect size index estimate from chi-squared statistic.</h2><span id='topic+chisq2S'></span>

<h3>Description</h3>

<p>This function computes the robust effect size index from Vandekar, Tao, &amp; Blume (2020).
Vector arguments are accepted. If different length arguments are passed they are dealt with in the usual way of R.
For mixed effects models, RESI is conditional on the average correlation
structure within subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chisq2S(chisq, df, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chisq2S_+3A_chisq">chisq</code></td>
<td>
<p>The chi-square statistic for the parameter of interest.</p>
</td></tr>
<tr><td><code id="chisq2S_+3A_df">df</code></td>
<td>
<p>Number of degrees of freedom of the chi-square statistic.</p>
</td></tr>
<tr><td><code id="chisq2S_+3A_n">n</code></td>
<td>
<p>Number of independent samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula for converting a Chi-square statistic to RESI is:
</p>
<p><code class="reqn"> S = \sqrt(max( 0, (chisq - df)/n))</code>
</p>


<h3>Value</h3>

<p>Returns a scalar or vector argument of the the robust effect size index estimate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain Chi-sq value by fitting an lm and running a Wald test
mod = lm(charges ~ region * age + bmi + sex, data = RESI::insurance)

# run a Wald test with robust variance
wt = lmtest::waldtest(mod, vcov = sandwich::vcovHC, test = "Chisq")

# get Chi-sq value and degrees of freedom
chisq = wt$Chisq[2]
df = abs(wt$Df[2])

# run chisq2S to convert to RESI
chisq2S(chisq, df = df, n = nrow(mod$model))

</code></pre>

<hr>
<h2 id='d2S'>Covert Cohen's <em>d</em> to |S|</h2><span id='topic+d2S'></span>

<h3>Description</h3>

<p>Converts Cohen's <em>d</em> robust effect size index (S) using the formula from
Vandekar, Tao, &amp; Blume (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2S(d, pi = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d2S_+3A_d">d</code></td>
<td>
<p>Numeric, value of Cohen's <em>d</em>.</p>
</td></tr>
<tr><td><code id="d2S_+3A_pi">pi</code></td>
<td>
<p>Numeric, the sampling proportions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pi parameter comes from the fact that Cohen's d doesn't account
for unequal sample proportions in the population, but S does.
</p>
<p>The default is set to a natural value 1/2, which corresponds to a case
control design, for example, where sampling proportions always are
controlled by the experimenter.
</p>
<p>The formula to convert Cohen's <em>d</em> to S is:
</p>
<p><code class="reqn">S = d/\sqrt( 1/\pi + 1/ (1 - \pi))</code>
</p>


<h3>Value</h3>

<p>Returns an estimate the robust effect size index
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider an experiment with equal sampling proportions and a medium effect size
# corresponding to a Cohen's d of 0.5.
# convert to RESI (S)
d2S(d = 0.5)

# This corresponds to a RESI of 0.25.
</code></pre>

<hr>
<h2 id='depression'>Depression Treatment Data</h2><span id='topic+depression'></span>

<h3>Description</h3>

<p>A longitudinal dataset comparing two treatments for depression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depression
</code></pre>


<h3>Format</h3>

<p>A data frame with 1020 rows and 5 variables:
</p>

<dl>
<dt>diagnose</dt><dd><p>diagnosed depression severity</p>
</dd>
<dt>drug</dt><dd><p>treatment; standard or new</p>
</dd>
<dt>id</dt><dd><p>patient id</p>
</dd>
<dt>time</dt><dd><p>time point of treatment</p>
</dd>
<dt>depression</dt><dd><p>depression response at time of treatment. 1 = Normal, 0 = Abnormal</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://static.lib.virginia.edu/statlab/materials/data/depression.csv">http://static.lib.virginia.edu/statlab/materials/data/depression.csv</a>
</p>


<h3>References</h3>

<p>Agresti, A. (2002). Categorical Data Analysis. Wiley, 2nd Edition.
</p>

<hr>
<h2 id='f2S'>Compute the robust effect size index estimate from F-statistic</h2><span id='topic+f2S'></span>

<h3>Description</h3>

<p>This function computes the robust effect size index from Vandekar, Tao, &amp; Blume (2020).
Vector arguments are accepted. If different length arguments are passed they are dealt with in the usual way of R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f2S(f, df, rdf, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f2S_+3A_f">f</code></td>
<td>
<p>The F statistic for the parameter of interest.</p>
</td></tr>
<tr><td><code id="f2S_+3A_df">df</code></td>
<td>
<p>Number of degrees of freedom of the F statistic.</p>
</td></tr>
<tr><td><code id="f2S_+3A_rdf">rdf</code></td>
<td>
<p>Model residual degrees of freedom.</p>
</td></tr>
<tr><td><code id="f2S_+3A_n">n</code></td>
<td>
<p>Number of independent samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula for converting an F statistic to S is:
</p>
<p><code class="reqn"> S = \sqrt(max(0, (f * df * (rdf - 2)/rdf - df)/n))</code>
</p>
<p>The estimator is derived by setting the statistic equal to the expected value of
the test statistic and solving for S.
</p>


<h3>Value</h3>

<p>Returns a scalar or vector argument of the the robust effect size index estimate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# to obtain example F values, first fit a lm
mod = lm(charges ~ region * age + bmi + sex, data = RESI::insurance)

# run Anova, using a robust variance-covariance function
# get the F values and Df values
fs = car::Anova(mod, vcov. = sandwich::vcovHC)[1:5, "F"]
dfs = car::Anova(mod, vcov. = sandwich::vcovHC)[1:5, "Df"]

# get RESI estimates
f2S(fs, df = dfs, rdf = mod$df.residual, n = nrow(RESI::insurance))
</code></pre>

<hr>
<h2 id='fsq2S'>Covert Cohen's <em>f</em>^2 to S</h2><span id='topic+fsq2S'></span>

<h3>Description</h3>

<p>Converts Cohen's <em>f</em>^2 to robust effect size index (S)
using the formula from Vandekar, Tao, &amp; Blume (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsq2S(fsq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsq2S_+3A_fsq">fsq</code></td>
<td>
<p>Numeric, value of Cohen's <em>f</em>^2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula for the conversion is:
</p>
<p><code class="reqn">S =  \sqrt(f^2)</code>
</p>


<h3>Value</h3>

<p>Returns an estimate the robust effect size index
</p>


<h3>Examples</h3>

<pre><code class='language-R'># consider a moderate effect size of f^2 = 0.3
fsq2S(0.3)
# This corresponds to a RESI of 0.5477226
</code></pre>

<hr>
<h2 id='ggplot.resi'>Plotting RESI Estimates and CIs</h2><span id='topic+ggplot.resi'></span>

<h3>Description</h3>

<p>This function uses ggplot2 graphics to plot robust effect size (RESI) estimates and confidence intervals
from 'resi', 'summary_resi', and 'anova_resi' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'resi'
ggplot(data, mapping, alpha = NULL, error.bars = TRUE, ..., environment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot.resi_+3A_data">data</code></td>
<td>
<p>Object of 'resi', 'summary_resi', or 'anova_resi' class</p>
</td></tr>
<tr><td><code id="ggplot.resi_+3A_mapping">mapping</code></td>
<td>
<p>Ignored, included for consistency with 'ggplot' generic</p>
</td></tr>
<tr><td><code id="ggplot.resi_+3A_alpha">alpha</code></td>
<td>
<p>Numeric, desired alpha level for confidence intervals</p>
</td></tr>
<tr><td><code id="ggplot.resi_+3A_error.bars">error.bars</code></td>
<td>
<p>Logical, whether to include end caps on the confidence intervals. Default = 'TRUE'</p>
</td></tr>
<tr><td><code id="ggplot.resi_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="ggplot.resi_+3A_environment">environment</code></td>
<td>
<p>Ignored, included for consistency with 'ggplot' generic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot of RESI point estimates
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a resi object
resi_obj &lt;- resi(lm(charges ~ region * age + bmi + sex, data = RESI::insurance),
nboot = 10)

# plot ANOVA table
ggplot2::ggplot(anova(resi_obj))
</code></pre>

<hr>
<h2 id='insurance'>US Health Insurance Data</h2><span id='topic+insurance'></span>

<h3>Description</h3>

<p>A dataset with 1338 observations on health insurance charges and demographic factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insurance
</code></pre>


<h3>Format</h3>

<p>A data frame with 1338 rows and 7 variables:
</p>

<dl>
<dt>age</dt><dd><p>age of primary beneficiary in years</p>
</dd>
<dt>sex</dt><dd><p>insurance contractor sex, male/female</p>
</dd>
<dt>bmi</dt><dd><p>body mass index</p>
</dd>
<dt>children</dt><dd><p>number of dependents</p>
</dd>
<dt>smoker</dt><dd><p>smoker/non-smoker</p>
</dd>
<dt>region</dt><dd><p>beneficiary's region of US</p>
</dd>
<dt>charges</dt><dd><p>individual medical costs billed by health insurance</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.kaggle.com/datasets/teertha/ushealthinsurancedataset">https://www.kaggle.com/datasets/teertha/ushealthinsurancedataset</a>
</p>

<hr>
<h2 id='omnibus'>Omnibus (Overall) Wald Test for resi objects</h2><span id='topic+omnibus'></span>

<h3>Description</h3>

<p>After running the <code><a href="#topic+resi">resi</a></code> function on a fitted model, this function
can be used to print the overall Wald test component. If the resi function was run
with the 'store.boot = TRUE' option to store the full matrix of bootstrapped estimates,
the user can specify a different alpha level for this function's confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omnibus(object, alpha = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omnibus_+3A_object">object</code></td>
<td>
<p>an object resulting from resi function</p>
</td></tr>
<tr><td><code id="omnibus_+3A_alpha">alpha</code></td>
<td>
<p>an optional new specification for the confidence level. Can be vector-valued</p>
</td></tr>
<tr><td><code id="omnibus_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 'omnibus_resi' object containing the computed omnibus Wald test
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit a model
mod = lm(charges ~ bmi + sex, data = RESI::insurance)

# run resi with the store.boot = TRUE option
resi_obj = resi(mod, nboot = 100, store.boot = TRUE, alpha = 0.01)

# run summary, specifying a different alpha level if desired
omnibus(resi_obj, alpha = 0.05)
</code></pre>

<hr>
<h2 id='plot.resi'>Plotting RESI Estimates and CIs</h2><span id='topic+plot.resi'></span>

<h3>Description</h3>

<p>This function uses base graphics to plot robust effect size (RESI) estimates and confidence intervals
from 'resi', 'summary_resi', and 'anova_resi' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'resi'
plot(
  x,
  alpha = NULL,
  ycex.axis = NULL,
  yaxis.args = list(),
  automar = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.resi_+3A_x">x</code></td>
<td>
<p>Object of 'resi', 'summary_resi', or 'anova_resi' class</p>
</td></tr>
<tr><td><code id="plot.resi_+3A_alpha">alpha</code></td>
<td>
<p>Numeric, desired alpha level for confidence intervals</p>
</td></tr>
<tr><td><code id="plot.resi_+3A_ycex.axis">ycex.axis</code></td>
<td>
<p>Numeric, scale specifically for the variable name labels</p>
</td></tr>
<tr><td><code id="plot.resi_+3A_yaxis.args">yaxis.args</code></td>
<td>
<p>List, other arguments to be passed to <code><a href="graphics.html#topic+axis">axis</a></code> for the y-axis</p>
</td></tr>
<tr><td><code id="plot.resi_+3A_automar">automar</code></td>
<td>
<p>Logical, whether to automatically adjust the plotting margins to accommodate variable names. Default = 'TRUE'</p>
</td></tr>
<tr><td><code id="plot.resi_+3A_...">...</code></td>
<td>
<p>Other graphical parameters passed to <code><a href="base.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+lines">lines</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a forest-like plot with RESI estimates for each variable or factor.
The size of the left margin will be automatically adjusted (and returned to original after plotting)
unless 'automar = FALSE'. Additional graphics parameters will be passed to the main
plot function, the confidence intervals. Arguments specifically for the y-axis (variable names)
can be specified using 'yaxis.args'. To manually adjust the size of the y-axis labels without
affecting the x-axis, the user can specify a value for 'ycex.axis'.
</p>


<h3>Value</h3>

<p>Returns a plot of RESI point estimates
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a resi object
resi_obj &lt;- resi(lm(charges ~ region * age + bmi + sex, data = RESI::insurance),
nboot = 10)

# plot coefficients table, changing size of labels for both axes in the usual way
plot(resi_obj, cex.axis = 0.7)

# plot ANOVA table, changing the size of just the y-axis
plot(resi_obj, ycex.axis = 0.8)
</code></pre>

<hr>
<h2 id='resi'>Robust Effect Size Index (RESI) point and interval estimation for models</h2><span id='topic+resi'></span><span id='topic+resi.default'></span><span id='topic+resi.glm'></span><span id='topic+resi.lm'></span><span id='topic+resi.nls'></span><span id='topic+resi.survreg'></span><span id='topic+resi.coxph'></span><span id='topic+resi.hurdle'></span><span id='topic+resi.zeroinfl'></span><span id='topic+resi.geeglm'></span><span id='topic+resi.gee'></span><span id='topic+resi.lme'></span><span id='topic+resi.lmerMod'></span>

<h3>Description</h3>

<p>This function will estimate the robust effect size (RESI) from Vandekar, Tao, &amp; Blume (2020) and its confidence interval in various ways for a fitted model object. The overall RESI is estimated via a Wald test. RESI is (optionally) estimated for each factor in coefficients-style table. RESI is (optionally) estimated for each variable/interaction in an Anova-style table for models with existing Anova methods. CIs can be calculated using either non-parametric or Bayesian bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resi(model.full, ...)

## Default S3 method:
resi(
  model.full,
  model.reduced = NULL,
  data,
  anova = TRUE,
  coefficients = TRUE,
  overall = TRUE,
  nboot = 1000,
  boot.method = "nonparam",
  vcovfunc = sandwich::vcovHC,
  alpha = 0.05,
  store.boot = FALSE,
  Anova.args = list(),
  vcov.args = list(),
  unbiased = TRUE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("boot.ncpus", 1L),
  long = FALSE,
  clvar = NULL,
  ...
)

## S3 method for class 'glm'
resi(
  model.full,
  model.reduced = NULL,
  data,
  anova = TRUE,
  coefficients = TRUE,
  overall = TRUE,
  nboot = 1000,
  vcovfunc = sandwich::vcovHC,
  alpha = 0.05,
  store.boot = FALSE,
  Anova.args = list(),
  vcov.args = list(),
  unbiased = TRUE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("boot.ncpus", 1L),
  ...
)

## S3 method for class 'lm'
resi(
  model.full,
  model.reduced = NULL,
  data,
  anova = TRUE,
  coefficients = TRUE,
  overall = TRUE,
  nboot = 1000,
  boot.method = "nonparam",
  vcovfunc = sandwich::vcovHC,
  alpha = 0.05,
  store.boot = FALSE,
  Anova.args = list(),
  vcov.args = list(),
  unbiased = TRUE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("boot.ncpus", 1L),
  ...
)

## S3 method for class 'nls'
resi(
  model.full,
  model.reduced = NULL,
  data,
  coefficients = TRUE,
  overall = TRUE,
  nboot = 1000,
  boot.method = "nonparam",
  anova = FALSE,
  vcovfunc = r_nlshc,
  alpha = 0.05,
  store.boot = FALSE,
  vcov.args = list(),
  unbiased = TRUE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("boot.ncpus", 1L),
  ...
)

## S3 method for class 'survreg'
resi(
  model.full,
  model.reduced = NULL,
  data,
  anova = TRUE,
  coefficients = TRUE,
  overall = TRUE,
  nboot = 1000,
  vcovfunc = vcov,
  alpha = 0.05,
  store.boot = FALSE,
  Anova.args = list(),
  unbiased = TRUE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("boot.ncpus", 1L),
  ...
)

## S3 method for class 'coxph'
resi(
  model.full,
  model.reduced = NULL,
  data,
  anova = TRUE,
  coefficients = TRUE,
  overall = TRUE,
  nboot = 1000,
  vcovfunc = vcov,
  alpha = 0.05,
  store.boot = FALSE,
  Anova.args = list(),
  unbiased = TRUE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("boot.ncpus", 1L),
  ...
)

## S3 method for class 'hurdle'
resi(
  model.full,
  model.reduced = NULL,
  data,
  coefficients = TRUE,
  overall = TRUE,
  nboot = 1000,
  vcovfunc = sandwich::sandwich,
  anova = FALSE,
  alpha = 0.05,
  store.boot = FALSE,
  vcov.args = list(),
  unbiased = TRUE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("boot.ncpus", 1L),
  ...
)

## S3 method for class 'zeroinfl'
resi(
  model.full,
  model.reduced = NULL,
  data,
  coefficients = TRUE,
  overall = TRUE,
  nboot = 1000,
  vcovfunc = sandwich::sandwich,
  anova = FALSE,
  alpha = 0.05,
  store.boot = FALSE,
  vcov.args = list(),
  unbiased = TRUE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("boot.ncpus", 1L),
  ...
)

## S3 method for class 'geeglm'
resi(
  model.full,
  model.reduced = NULL,
  data,
  anova = TRUE,
  coefficients = TRUE,
  overall = TRUE,
  nboot = 1000,
  alpha = 0.05,
  store.boot = FALSE,
  unbiased = TRUE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("boot.ncpus", 1L),
  ...
)

## S3 method for class 'gee'
resi(
  model.full,
  data,
  nboot = 1000,
  alpha = 0.05,
  store.boot = FALSE,
  unbiased = TRUE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("boot.ncpus", 1L),
  ...
)

## S3 method for class 'lme'
resi(
  model.full,
  alpha = 0.05,
  nboot = 1000,
  anova = TRUE,
  vcovfunc = clubSandwich::vcovCR,
  vcov.args = list(),
  ...
)

## S3 method for class 'lmerMod'
resi(
  model.full,
  alpha = 0.05,
  nboot = 1000,
  anova = TRUE,
  vcovfunc = clubSandwich::vcovCR,
  vcov.args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resi_+3A_model.full">model.full</code></td>
<td>
<p><code>lm, glm, nls, survreg, coxph, hurdle, zeroinfl, gee, geeglm</code> or <code>lme</code> model object.</p>
</td></tr>
<tr><td><code id="resi_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="resi_+3A_model.reduced">model.reduced</code></td>
<td>
<p>Fitted model object of same type as model.full. By default 'NULL'; the same model as the full model but only having intercept.</p>
</td></tr>
<tr><td><code id="resi_+3A_data">data</code></td>
<td>
<p>Data.frame or object coercible to data.frame of model.full data (required for some model types).</p>
</td></tr>
<tr><td><code id="resi_+3A_anova">anova</code></td>
<td>
<p>Logical, whether to produce an Anova table with the RESI columns added. By default = 'TRUE'.</p>
</td></tr>
<tr><td><code id="resi_+3A_coefficients">coefficients</code></td>
<td>
<p>Logical, whether to produce a coefficients (summary) table with the RESI columns added. By default = 'TRUE'.</p>
</td></tr>
<tr><td><code id="resi_+3A_overall">overall</code></td>
<td>
<p>Logical, whether to produce an overall Wald test comparing full to reduced model with RESI columns added. By default = 'TRUE'.</p>
</td></tr>
<tr><td><code id="resi_+3A_nboot">nboot</code></td>
<td>
<p>Numeric, the number of bootstrap replicates. By default, 1000.</p>
</td></tr>
<tr><td><code id="resi_+3A_boot.method">boot.method</code></td>
<td>
<p>String, which type of bootstrap to use: 'nonparam' = non-parametric bootstrap (default); 'bayes' = Bayesian bootstrap.</p>
</td></tr>
<tr><td><code id="resi_+3A_vcovfunc">vcovfunc</code></td>
<td>
<p>The variance estimator function for constructing the Wald test statistic. By default, sandwich::vcovHC (the robust (sandwich) variance estimator).</p>
</td></tr>
<tr><td><code id="resi_+3A_alpha">alpha</code></td>
<td>
<p>Numeric, significance level of the constructed CIs. By default, 0.05.</p>
</td></tr>
<tr><td><code id="resi_+3A_store.boot">store.boot</code></td>
<td>
<p>Logical, whether to store all the bootstrapped estimates. By default, 'FALSE'.</p>
</td></tr>
<tr><td><code id="resi_+3A_anova.args">Anova.args</code></td>
<td>
<p>List, additional arguments to be passed to <a href="car.html#topic+Anova">Anova</a> function.</p>
</td></tr>
<tr><td><code id="resi_+3A_vcov.args">vcov.args</code></td>
<td>
<p>List, additional arguments to be passed to vcovfunc.</p>
</td></tr>
<tr><td><code id="resi_+3A_unbiased">unbiased</code></td>
<td>
<p>Logical, whether to use the unbiased or alternative T/Z statistic to RESI conversion. By default, 'TRUE'. See details.</p>
</td></tr>
<tr><td><code id="resi_+3A_parallel">parallel</code></td>
<td>
<p>See documentation for <code><a href="boot.html#topic+boot">boot</a></code>.</p>
</td></tr>
<tr><td><code id="resi_+3A_ncpus">ncpus</code></td>
<td>
<p>See documentation for <code><a href="boot.html#topic+boot">boot</a></code>.</p>
</td></tr>
<tr><td><code id="resi_+3A_long">long</code></td>
<td>
<p>Logical, whether the data is longitudinal/clustered. By default, 'FALSE'.</p>
</td></tr>
<tr><td><code id="resi_+3A_clvar">clvar</code></td>
<td>
<p>Character, the name of the cluster/id variable if data is clustered. By default, 'NULL'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RESI, denoted as S, is applicable across many model types. It is a unitless
index and can be easily be compared across models. The RESI can also be
converted to Cohen's <em>d</em> (<code><a href="#topic+S2d">S2d</a></code>) under  model homoskedasticity.
</p>
<p>This function computes the RESI point estimates and bootstrapped confidence
intervals based on Chi-square, F, T, or Z statistics. The robust (sandwich)
variance is used by default, allowing for consistency under
model-misspecification. The RESI is related to the non-centrality parameter
of the test statistic. The RESI estimate is consistent for all four
(Chi-square, F, T, and Z) types of statistics used. The Chi-square and F-based
calculations rely on asymptotic theory, so they may be biased in small samples.
When possible, the T and Z statistics are used. There are two formulas for both
the T and Z statistic conversion. The first (default, unbiased = TRUE)
are based on solving the expected value of the T or Z statistic for the RESI.
The alternative is based on squaring the T or Z statistic and using the
F or Chi-square statistic conversion. Both of these methods are consistent, but
the alternative exhibits a notable amount of finite sample bias. The alternative
may be appealing because its absolute value will be equal to the RESI based on
the F or Chi-square statistic. The RESI based on the Chi-Square and F statistics
is always greater than or equal to 0. The type of statistic
used is listed with the output. See <code><a href="#topic+f2S">f2S</a></code>, <code><a href="#topic+chisq2S">chisq2S</a></code>,
<code><a href="#topic+t2S">t2S</a></code>, and <code><a href="#topic+z2S">z2S</a></code> for more details on the formulas.
</p>
<p>For GEE (<code>geeglm</code>) models, a longitudinal RESI (L-RESI) and a cross-sectional,
per-measurement RESI (CS-RESI) is estimated. The longitudinal RESI takes the
specified clustering into account, while the cross-sectional RESI is estimated
using a model where each measurement is its own cluster.
</p>
<p>For most <code>lm</code> and <code>nls</code> model types, there is a Bayesian bootstrap
option available as an alternative to the default, standard non-parametric
bootstrap. The interpretation of a Bayesian bootstrapped interval is similar to
that of a credible interval.
</p>
<p>Certain model types require the data used for the model be entered as an argument.
These are: <code>nls, survreg,</code> and <code>coxph</code>. Additionally, if a model
includes certain functions (splines, factor, I), the data needs to be provided.
</p>
<p>If running into convergence issues with nls models, it is advised to refit the
nls model with starting values equal to the estimates provided by the model
and then try rerunning <code>resi</code>.
</p>


<h3>Value</h3>

<p>Returns a list that includes function arguments, RESI point estimates,
and confidence intervals in coefficients/anova-style tables
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>resi(default)</code>: RESI point and interval estimation for models
</p>
</li>
<li> <p><code>resi(glm)</code>: RESI point and interval estimation for models
</p>
</li>
<li> <p><code>resi(lm)</code>: RESI point and interval estimation for lm models
</p>
</li>
<li> <p><code>resi(nls)</code>: RESI point and interval estimation for nls models
</p>
</li>
<li> <p><code>resi(survreg)</code>: RESI point and interval estimation for survreg models
</p>
</li>
<li> <p><code>resi(coxph)</code>: RESI point and interval estimation for coxph models
</p>
</li>
<li> <p><code>resi(hurdle)</code>: RESI point and interval estimation for hurdle models
</p>
</li>
<li> <p><code>resi(zeroinfl)</code>: RESI point and interval estimation for zeroinfl models
</p>
</li>
<li> <p><code>resi(geeglm)</code>: RESI point and interval estimation for GEE models
</p>
</li>
<li> <p><code>resi(gee)</code>: RESI point and interval estimation for GEE models
</p>
</li>
<li> <p><code>resi(lme)</code>: RESI point and interval estimation for LME (nlme) models
</p>
</li>
<li> <p><code>resi(lmerMod)</code>: RESI point and interval estimation for lmerMod models
</p>
</li></ul>


<h3>References</h3>

<p>Vandekar S, Tao R, Blume J. A Robust Effect Size Index. <em>Psychometrika</em>. 2020 Mar;85(1):232-246. doi: 10.1007/s11336-020-09698-2.
</p>
<p>Kang, K., Armstrong, K., Avery, S., McHugo, M., Heckers, S., &amp; Vandekar, S. (2021). Accurate confidence interval estimation for non-centrality parameters and effect size indices. <em>arXiv preprint arXiv:2111.05966</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resi_pe">resi_pe</a></code>, <code><a href="sandwich.html#topic+vcovHC">vcovHC</a></code>,
<code><a href="#topic+f2S">f2S</a></code>, <code><a href="#topic+chisq2S">chisq2S</a></code>, <code><a href="#topic+z2S">z2S</a></code>, <code><a href="#topic+t2S">t2S</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## for timing purposes, a small number of bootstrap replicates is used in the
## examples. Run them with a higher or default `nboot` argument for better performance

## RESI on a linear model
# fit linear model
mod = lm(charges ~ region * age + bmi + sex, data = RESI::insurance)

# run resi on fitted model with desired number of bootstrap replicates
# store bootstrap results for calculating different CIs later
resi_obj = resi(mod, nboot = 50, store.boot = TRUE)
# print output
resi_obj

# fit a reduced model for comparison
mod_red = lm(charges ~ bmi, data = RESI::insurance)

# running resi and including the reduced model will provide almost the exact same
# output as not including a reduced model. The difference is that the "overall"
# portion of the output will compare the full model to the reduced model.
# The "summary" and "anova" RESI estimates will be the same. (The bootstrapped
# confidence intervals may differ.)
resi(model.full = mod, model.reduced = mod_red, nboot = 10)

# used stored bootstrap results to get a different alpha-level confidence interval
summary(resi_obj, alpha = c(0.01, 0.1))
car::Anova(resi_obj, alpha = c(0.01, 0.1))

# the result of resi, as well as the summary or Anova of a `resi` object can be plotted
# if the resi object was created with the store.boot = `TRUE` option, any alpha
# can be specified
plot(resi_obj, alpha = 0.01)
# if the variable names on the y-axis are too long, you can reduce their size with
# the ycex.axis argument (or use regular common solutions like changing the margins)
plot(resi_obj, alpha = 0.01, ycex.axis = 0.5)

# for some model types and formula structures, data argument is required
if(requireNamespace("splines")){
  # fit logistic regression model with splines
  mod = glm(smoker ~ splines::ns(age, df = 3) + region, data = RESI::insurance,
    family = "binomial")

  # specify additional arguments to the variance-covariance function via vcov.args
  resi_obj = resi(mod, data = RESI::insurance, alpha = 0.01,
    vcov.args = list(type = "HC0"), nboot = 25)
  summary(resi_obj)
  car::Anova(resi_obj)}


## RESI on a survival model with alternate Z2S
if(requireNamespace("survival")){
  # fit coxph model on example data from survival package
  # Note: for survival models, you need to specify robust variance in the model
  # creation. resi will ignore the vcovfunc argument for this reason.
  mod.coxph =  survival::coxph(survival::Surv(time, status) ~ age + sex + wt.loss,
   data=survival::lung, robust = TRUE)

  # run resi on the model
  # to use the alternative Z to RESI formula (which is equal in absolute value to the
  # chi-square to RESI (S) formula), specify unbiased = FALSE.
  resi(mod.coxph, data = survival::lung, unbiased = FALSE, nboot = 10)}

</code></pre>

<hr>
<h2 id='resi_pe'>Robust Effect Size Index (RESI) Point Estimation</h2><span id='topic+resi_pe'></span><span id='topic+resi_pe.default'></span><span id='topic+resi_pe.glm'></span><span id='topic+resi_pe.lm'></span><span id='topic+resi_pe.nls'></span><span id='topic+resi_pe.survreg'></span><span id='topic+resi_pe.coxph'></span><span id='topic+resi_pe.hurdle'></span><span id='topic+resi_pe.zeroinfl'></span><span id='topic+resi_pe.geeglm'></span><span id='topic+resi_pe.gee'></span><span id='topic+resi_pe.lme'></span><span id='topic+resi_pe.lmerMod'></span>

<h3>Description</h3>

<p>This function will estimate the robust effect size (RESI) from Vandekar, Tao, &amp; Blume (2020).
The overall RESI is estimated via a Wald test. RESI is (optionally) estimated for each factor in coefficients-style table.
RESI is (optionally) estimated for each variable/interaction in an Anova-style table
for models with existing Anova methods. This function is the building block for the <code><a href="#topic+resi">resi</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resi_pe(model.full, ...)

## Default S3 method:
resi_pe(
  model.full,
  model.reduced = NULL,
  data,
  anova = TRUE,
  coefficients = TRUE,
  overall = TRUE,
  vcovfunc = sandwich::vcovHC,
  Anova.args = list(),
  vcov.args = list(),
  unbiased = TRUE,
  waldtype = 0,
  ...
)

## S3 method for class 'glm'
resi_pe(
  model.full,
  model.reduced = NULL,
  data,
  anova = TRUE,
  coefficients = TRUE,
  overall = TRUE,
  vcovfunc = sandwich::vcovHC,
  Anova.args = list(),
  vcov.args = list(),
  unbiased = TRUE,
  waldtype = 0,
  ...
)

## S3 method for class 'lm'
resi_pe(
  model.full,
  model.reduced = NULL,
  data,
  anova = TRUE,
  coefficients = TRUE,
  vcovfunc = sandwich::vcovHC,
  Anova.args = list(),
  vcov.args = list(),
  unbiased = TRUE,
  overall = TRUE,
  ...
)

## S3 method for class 'nls'
resi_pe(
  model.full,
  model.reduced = NULL,
  data,
  coefficients = TRUE,
  anova = FALSE,
  vcovfunc = r_nlshc,
  vcov.args = list(),
  unbiased = TRUE,
  overall = TRUE,
  ...
)

## S3 method for class 'survreg'
resi_pe(
  model.full,
  model.reduced = NULL,
  data,
  anova = TRUE,
  coefficients = TRUE,
  vcovfunc = vcov,
  Anova.args = list(),
  unbiased = TRUE,
  overall = TRUE,
  ...
)

## S3 method for class 'coxph'
resi_pe(
  model.full,
  model.reduced = NULL,
  data,
  anova = TRUE,
  coefficients = TRUE,
  vcovfunc = vcov,
  Anova.args = list(),
  unbiased = TRUE,
  overall = TRUE,
  ...
)

## S3 method for class 'hurdle'
resi_pe(
  model.full,
  model.reduced = NULL,
  data,
  coefficients = TRUE,
  anova = TRUE,
  vcovfunc = sandwich::sandwich,
  vcov.args = list(),
  unbiased = TRUE,
  overall = TRUE,
  ...
)

## S3 method for class 'zeroinfl'
resi_pe(
  model.full,
  model.reduced = NULL,
  data,
  coefficients = TRUE,
  anova = TRUE,
  vcovfunc = sandwich::sandwich,
  vcov.args = list(),
  unbiased = TRUE,
  overall = TRUE,
  ...
)

## S3 method for class 'geeglm'
resi_pe(
  model.full,
  model.reduced = NULL,
  data,
  anova = TRUE,
  coefficients = TRUE,
  overall = TRUE,
  unbiased = TRUE,
  ...
)

## S3 method for class 'gee'
resi_pe(model.full, data, unbiased = TRUE, ...)

## S3 method for class 'lme'
resi_pe(
  model.full,
  anova = TRUE,
  vcovfunc = clubSandwich::vcovCR,
  Anova.args = list(),
  vcov.args = list(),
  ...
)

## S3 method for class 'lmerMod'
resi_pe(
  model.full,
  anova = TRUE,
  vcovfunc = clubSandwich::vcovCR,
  Anova.args = list(),
  vcov.args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resi_pe_+3A_model.full">model.full</code></td>
<td>
<p><code>lm, glm, nls, survreg, coxph, hurdle, zeroinfl, gee, geeglm</code> or <code>lme</code> model object.</p>
</td></tr>
<tr><td><code id="resi_pe_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="resi_pe_+3A_model.reduced">model.reduced</code></td>
<td>
<p>Fitted model object of same type as model.full. By default 'NULL'; the same model as the full model but only having intercept.</p>
</td></tr>
<tr><td><code id="resi_pe_+3A_data">data</code></td>
<td>
<p>Data.frame or object coercible to data.frame of model.full data (required for some model types).</p>
</td></tr>
<tr><td><code id="resi_pe_+3A_anova">anova</code></td>
<td>
<p>Logical, whether to produce an Anova table with the RESI columns added. By default = 'TRUE'.</p>
</td></tr>
<tr><td><code id="resi_pe_+3A_coefficients">coefficients</code></td>
<td>
<p>Logical, whether to produce a coefficients (summary) table with the RESI columns added. By default = 'TRUE'.</p>
</td></tr>
<tr><td><code id="resi_pe_+3A_overall">overall</code></td>
<td>
<p>Logical, whether to produce an overall Wald test comparing full to reduced model with RESI columns added. By default = 'TRUE'.</p>
</td></tr>
<tr><td><code id="resi_pe_+3A_vcovfunc">vcovfunc</code></td>
<td>
<p>The variance estimator function for constructing the Wald test statistic. By default, sandwich::vcovHC (the robust (sandwich) variance estimator).</p>
</td></tr>
<tr><td><code id="resi_pe_+3A_anova.args">Anova.args</code></td>
<td>
<p>List, additional arguments to be passed to Anova function.</p>
</td></tr>
<tr><td><code id="resi_pe_+3A_vcov.args">vcov.args</code></td>
<td>
<p>List, additional arguments to be passed to vcovfunc.</p>
</td></tr>
<tr><td><code id="resi_pe_+3A_unbiased">unbiased</code></td>
<td>
<p>Logical, whether to use the unbiased or alternative T/Z statistic to RESI conversion. By default, 'TRUE'. See details.</p>
</td></tr>
<tr><td><code id="resi_pe_+3A_waldtype">waldtype</code></td>
<td>
<p>Numeric, indicates which function to use for overall Wald test. 0 (default) = lmtest::waldtest Chi-square, 1 = lmtest::waldtest F, 2 = aod::wald.test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Robust Effect Size Index (RESI) is an effect size measure based on M-estimators.
This function is called by <code><a href="#topic+resi">resi</a></code> a specified number of times to
form bootstrapped confidence intervals. Called by itself, this function will
only calculate point estimates.
</p>
<p>The RESI, denoted as S, is applicable across many model types. It is a unitless
index and can be easily be compared across models. The RESI can also be
converted to Cohen's <em>d</em> (<code><a href="#topic+S2d">S2d</a></code>) under model homoskedasticity.
</p>
<p>The RESI is related to the non-centrality parameter
of the test statistic. The RESI estimate is consistent for all four
(Chi-square, F, T, and Z) types of statistics used. The Chi-square and F-based
calculations rely on asymptotic theory, so they may be biased in small samples.
When possible, the T and Z statistics are used. There are two formulas for both
the T and Z statistic conversion. The first (default, unbiased = TRUE)
are based on solving the expected value of the T or Z statistic for the RESI.
The alternative is based on squaring the T or Z statistic and using the
F or Chi-square statistic conversion. Both of these methods are consistent, but
the alternative exhibits a notable amount of finite sample bias. The alternative
may be appealing because its absolute value will be equal to the RESI based on
the F or Chi-square statistic. The RESI based on the Chi-Square and F statistics
is always greater than or equal to 0. The type of statistic
used is listed with the output. See <code><a href="#topic+f2S">f2S</a></code>, <code><a href="#topic+chisq2S">chisq2S</a></code>,
<code><a href="#topic+t2S">t2S</a></code>, and <code><a href="#topic+z2S">z2S</a></code> for more details on the formulas.
</p>
<p>For GEE (<code>geeglm</code>) models, a longitudinal RESI (L-RESI) and a cross-sectional,
per-measurement RESI (CS-RESI) is estimated. The longitudinal RESI takes the
specified clustering into account, while the cross-sectional RESI is estimated
using a model where each measurement is its own cluster.
</p>


<h3>Value</h3>

<p>Returns a list containing RESI point estimates
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>resi_pe(default)</code>: RESI point estimation
</p>
</li>
<li> <p><code>resi_pe(glm)</code>: RESI point estimation for generalized linear models
</p>
</li>
<li> <p><code>resi_pe(lm)</code>: RESI point estimation for linear models
</p>
</li>
<li> <p><code>resi_pe(nls)</code>: RESI point estimation for nonlinear least squares models
</p>
</li>
<li> <p><code>resi_pe(survreg)</code>: RESI point estimation for survreg
</p>
</li>
<li> <p><code>resi_pe(coxph)</code>: RESI point estimation for coxph models
</p>
</li>
<li> <p><code>resi_pe(hurdle)</code>: RESI point estimation for hurdle models
</p>
</li>
<li> <p><code>resi_pe(zeroinfl)</code>: RESI point estimation for zeroinfl models
</p>
</li>
<li> <p><code>resi_pe(geeglm)</code>: RESI point estimation for geeglm object
</p>
</li>
<li> <p><code>resi_pe(gee)</code>: RESI point estimation for gee object
</p>
</li>
<li> <p><code>resi_pe(lme)</code>: RESI point estimation for lme object
</p>
</li>
<li> <p><code>resi_pe(lmerMod)</code>: RESI point estimation for lmerMod object
</p>
</li></ul>


<h3>References</h3>

<p>Vandekar S, Tao R, Blume J. A Robust Effect Size Index. <em>Psychometrika</em>. 2020 Mar;85(1):232-246. doi: 10.1007/s11336-020-09698-2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function produces point estimates for the RESI. The resi function will
# provide the same point estimates but adds confidence intervals. See resi for
# more detailed examples.

## resi_pe for a linear model
# fit linear model
mod &lt;- lm(charges ~ region * age + bmi + sex, data = RESI::insurance)
# run resi_pe on the model
resi_pe(mod)

# if you want to have RESI estimates in the coefficient table that are equal in absolute
# value to those in the Anova table (except for those with &gt;1 df and/or included in other
# interaction terms), you can specify unbiased = FALSE to use the alternate conversion.
resi_pe(mod, unbiased = FALSE)
</code></pre>

<hr>
<h2 id='Rsq2S'>Covert R^2 to S</h2><span id='topic+Rsq2S'></span>

<h3>Description</h3>

<p>Converts R^2, the partial coefficient of determination, to
robust effect size index (S) using the formula from Vandekar, Tao, &amp; Blume (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rsq2S(Rsq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rsq2S_+3A_rsq">Rsq</code></td>
<td>
<p>Numeric, R^2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula for the conversion is:
</p>
<p><code class="reqn">S = \sqrt((-R^2)/(R^2 - 1))</code>
</p>


<h3>Value</h3>

<p>Returns an estimate of R^2 based on the RESI
</p>


<h3>Examples</h3>

<pre><code class='language-R'># consider a moderate effect size of R^2 = 0.1
Rsq2S(0.1)
# this corresponds to a RESI of 0.333
</code></pre>

<hr>
<h2 id='S2d'>Convert S to Cohen's d</h2><span id='topic+S2d'></span>

<h3>Description</h3>

<p>Converts the robust effect size index (S) to Cohen's d using the formula from
Vandekar, Tao, &amp; Blume (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S2d(S, pi = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S2d_+3A_s">S</code></td>
<td>
<p>Numeric, the robust effect size index.</p>
</td></tr>
<tr><td><code id="S2d_+3A_pi">pi</code></td>
<td>
<p>Numeric, the sampling proportions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pi parameter comes from the fact that Cohen's d doesn't account
for unequal sample proportions in the population, but S does.
</p>
<p>The default is set to a natural value 1/2, which corresponds to a case
control design, for example, where sampling proportions always are
controlled by the experimenter.
</p>
<p>The formula for the conversion is:
</p>
<p><code class="reqn"> d = | S * \sqrt(1/\pi + 1/(1 - \pi)) |</code>
</p>


<h3>Value</h3>

<p>Returns an estimate of Cohen's <em>d</em> based on the RESI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit a simple linear regression with a binary predictor
mod = lm(charges ~ sex, data = RESI::insurance)

# calculate t-value
t = summary(mod)$coefficients[2, "t value"]

# calculate RESI (S)
S = t2S(t, n = 1338, rdf = 1336)

# determine sample proportions
pi = length(which(RESI::insurance[,"sex"]=="male"))/1338

# convert S to Cohen's d
S2d(S = S, pi = pi)

</code></pre>

<hr>
<h2 id='S2fsq'>Covert S to Cohen's <em>f</em>^2</h2><span id='topic+S2fsq'></span>

<h3>Description</h3>

<p>Converts robust effect size index (S) to Cohen's <em>f</em>^2
(effect size for multiple regression) using the formula from Vandekar, Tao, &amp; Blume (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S2fsq(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S2fsq_+3A_s">S</code></td>
<td>
<p>Numeric,the robust effect size index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula for the conversion is:
</p>
<p><code class="reqn"> f^2 = S^2</code>
</p>


<h3>Value</h3>

<p>Returns an estimate of Cohen's <em>f</em>^2 based on the RESI
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit a linear regression model with continuous outcome and predictor
mod = lm(charges ~ age, data = RESI::insurance)

# obtain t value for calculating RESI
t = summary(mod)$coefficients[2, "t value"]

# calculate RESI
S = t2S(t, n = 1338, rdf = 1336)

# convert to f^2
S2fsq(S)

</code></pre>

<hr>
<h2 id='S2Rsq'>Covert S to R^2</h2><span id='topic+S2Rsq'></span>

<h3>Description</h3>

<p>Converts robust effect size index (S) to R^2, the partial
coefficient of determination, using the formula from Vandekar, Tao, &amp; Blume (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S2Rsq(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S2Rsq_+3A_s">S</code></td>
<td>
<p>Numeric, the robust effect size index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula for the conversion is:
</p>
<p><code class="reqn"> R^2 = S^2 / (1 + S^2)</code>
</p>


<h3>Value</h3>

<p>Returns an estimate of R^2 based on the RESI
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit a simple linear regression with a binary predictor
mod = lm(charges ~ sex, data = RESI::insurance)

# calculate t-value
t = summary(mod)$coefficients[2, "t value"]

# calculate RESI (S)
S = t2S(t, n = 1338, rdf = 1336)

# convert S to R^2
S2Rsq(S)

</code></pre>

<hr>
<h2 id='summary.resi'>Summary method for resi objects</h2><span id='topic+summary.resi'></span>

<h3>Description</h3>

<p>After running the <code><a href="#topic+resi">resi</a></code> function on a fitted model, this function can
be used to print the coefficients table component. If the resi function was run with
the 'store.boot = TRUE' option to store the full matrix of bootstrapped estimates,
the user can specify a different alpha level for this function's confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'resi'
summary(object, alpha = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.resi_+3A_object">object</code></td>
<td>
<p>an object resulting from resi function</p>
</td></tr>
<tr><td><code id="summary.resi_+3A_alpha">alpha</code></td>
<td>
<p>an optional new specification for the confidence level. Can be vector-valued</p>
</td></tr>
<tr><td><code id="summary.resi_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 'summary_resi' object containing the computed coefficients table
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit a model
mod = lm(charges ~ bmi + sex, data = RESI::insurance)

# run resi with the store.boot = TRUE option
resi_obj = resi(mod, nboot = 100, store.boot = TRUE, alpha = 0.01)

# run summary, specifying a different alpha level if desired
summary(resi_obj, alpha = 0.05)
</code></pre>

<hr>
<h2 id='t2S'>Compute the robust effect size index estimate from t statistic (default)</h2><span id='topic+t2S'></span>

<h3>Description</h3>

<p>This function computes the robust effect size index from Vandekar, Tao, &amp; Blume (2020).
Vector arguments are accepted. If different length arguments are passed they are dealt with in the usual way of R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t2S(t, rdf, n, unbiased = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t2S_+3A_t">t</code></td>
<td>
<p>The t statistic for the parameter of interest.</p>
</td></tr>
<tr><td><code id="t2S_+3A_rdf">rdf</code></td>
<td>
<p>Model residual degrees of freedom/degrees of freedom of the t statistic.</p>
</td></tr>
<tr><td><code id="t2S_+3A_n">n</code></td>
<td>
<p>Number of independent samples.</p>
</td></tr>
<tr><td><code id="t2S_+3A_unbiased">unbiased</code></td>
<td>
<p>Logical, whether to use unbiased or alternative estimator. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes S, the RESI, from a t statistic. The formula for the
unbiased estimator (default) is derived by solving the expected value of the
t statistic for S. It is unbiased and consistent.
</p>
<p>The formula for the unbiased conversion is:
</p>
<p><code class="reqn">S = (t * \sqrt(2) * \Gamma(rdf/2)) / (\sqrt(n * rdf) * \Gamma((rdf - 1)/2))</code>
</p>
<p>The formula for the alternative estimator is derived by squaring the t statistic
and using the <code><a href="#topic+f2S">f2S</a></code> formula. This estimator may be appealing for its
intuitive relationship to the F statistic; the absolute value of RESI estimates
using this formula will be equal to a RESI estimate using an F statistic for
the same model. However, this estimator does have finite sample bias, which is an
important consideration for the coverage of the bootstrapping that <code>resi</code> uses.
</p>
<p>The formula for the alternative conversion is:
</p>
<p><code class="reqn"> \sqrt(max(0, (t^2 * (rdf - 2)/rdf - 1)/rdf))</code>
</p>


<h3>Value</h3>

<p>Returns a scalar or vector argument of the the robust effect size index estimate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to obtain t values, first fit a lm
mod = lm(charges ~ region * age + bmi + sex, data = RESI::insurance)
# run lmtest::coeftest to get t values, using a robust variance-covariance formula
ts = lmtest::coeftest(mod, vcov. = sandwich::vcovHC)[,'t value']

# get RESI estimates using unbiased estimator
t2S(ts, n = nrow(RESI::insurance), rdf = mod$df.residual)

# get RESI estimates using alternative estimator
t2S(ts, n = nrow(RESI::insurance), rdf = mod$df.residual, unbiased = FALSE)
</code></pre>

<hr>
<h2 id='z2S'>Compute the robust effect size index estimate from Z statistic</h2><span id='topic+z2S'></span>

<h3>Description</h3>

<p>This function computes the robust effect size index from Vandekar, Tao, &amp; Blume (2020).
Vector arguments are accepted. If different length arguments are passed they are dealt with in the usual way of R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z2S(z, n, unbiased = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z2S_+3A_z">z</code></td>
<td>
<p>The Z statistic for the parameter of interest.</p>
</td></tr>
<tr><td><code id="z2S_+3A_n">n</code></td>
<td>
<p>Number of independent samples.</p>
</td></tr>
<tr><td><code id="z2S_+3A_unbiased">unbiased</code></td>
<td>
<p>Logical, whether to use unbiased or alternative estimator. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes S, the RESI, from a Z statistic. The formula for the
unbiased estimator (default) is derived by solving the expected value of the
Z statistic for S. It is unbiased and consistent.
</p>
<p>The formula for the unbiased conversion is:
</p>
<p><code class="reqn">S = Z/\sqrt(n)</code>
</p>
<p>The formula for the alternative estimator is derived by squaring the Z statistic
and using the <code><a href="#topic+chisq2S">chisq2S</a></code> formula. This estimator may be appealing for its
intuitive relationship to the Chi-square statistic; the absolute value of RESI estimates
using this formula will be equal to a RESI estimate using a Chi-square statistic for
the same model. However, this estimator does have finite sample bias, which is an
important consideration for the coverage of the bootstrapping that <code>resi</code> uses.
</p>
<p>The formula for the alternative conversion is:
</p>
<p><code class="reqn"> \sqrt(max(0, (Z^2 - 1)/n)) * sign(Z)</code>
</p>


<h3>Value</h3>

<p>Returns a scalar or vector argument of the the robust effect size index estimate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to obtain example z values, first fit a glm
mod = glm(charges ~ region * age + bmi + sex, data = RESI::insurance)
# run coeftest to get z values using a robust variance-covariance function
zs = lmtest::coeftest(mod, vcov. = sandwich::vcovHC)[,'z value']

# get RESI estimates using unbiased estimator
z2S(zs, n = nrow(RESI::insurance))

# get RESI estimates usng alternative estimator
z2S(zs, n = nrow(RESI::insurance), unbiased = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
