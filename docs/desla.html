<!DOCTYPE html><html lang="en"><head><title>Help for package desla</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {desla}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.desla'><p>Extract coefficients</p></a></li>
<li><a href='#confint.desla'><p>Confidence intervals for desla objects</p></a></li>
<li><a href='#create_state_dummies'><p>Create State Dummies</p></a></li>
<li><a href='#create_state_dummies_from_datamatrix'><p>Create State Dummies from Matrix</p></a></li>
<li><a href='#create_state_dummies_from_vector'><p>Create State Dummies from Vector</p></a></li>
<li><a href='#desla'><p>Desparsified lasso</p></a></li>
<li><a href='#HDLP'><p>State Dependent High-Dimensional Local Projection</p></a></li>
<li><a href='#plot.hdlp'><p>Plot Impulse Responses obtained from HDLP.</p></a></li>
<li><a href='#print.desla'><p>Print desla output</p></a></li>
<li><a href='#print.summary.desla'><p>Print desla summary output</p></a></li>
<li><a href='#summary.desla'><p>Summary of desla output</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Desparsified Lasso Inference for Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates the desparsified lasso as originally introduced in van de Geer et al. (2014) &lt;<a href="https://doi.org/10.1214%2F14-AOS1221">doi:10.1214/14-AOS1221</a>&gt;, and provides inference suitable for high-dimensional time series, based on the long run covariance estimator in Adamek et al. (2020) &lt;<a href="https://doi.org/10.48550/arXiv.2007.10952">doi:10.48550/arXiv.2007.10952</a>&gt;. Also estimates high-dimensional local projections by the desparsified lasso, as described in Adamek et al. (2022) &lt;<a href="https://doi.org/10.48550/arXiv.2209.03218">doi:10.48550/arXiv.2209.03218</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress, sitmo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, Rdpack, stats, parallelly</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobertAdamek/desla">https://github.com/RobertAdamek/desla</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobertAdamek/desla/issues">https://github.com/RobertAdamek/desla/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-27 15:34:22 UTC; au720495</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert Adamek [cre, aut],
  Stephan Smeekes [aut],
  Ines Wilms [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert Adamek &lt;robertadamek94@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-29 11:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.desla'>Extract coefficients</h2><span id='topic+coef.desla'></span>

<h3>Description</h3>

<p>Extract coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'desla'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.desla_+3A_object">object</code></td>
<td>
<p>a <code>desla</code> object.</p>
</td></tr>
<tr><td><code id="coef.desla_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
</table>

<hr>
<h2 id='confint.desla'>Confidence intervals for desla objects</h2><span id='topic+confint.desla'></span>

<h3>Description</h3>

<p>Confidence intervals for desla objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'desla'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.desla_+3A_object">object</code></td>
<td>
<p>a <code>desla</code> object.</p>
</td></tr>
<tr><td><code id="confint.desla_+3A_parm">parm</code></td>
<td>
<p>which parameters is the confidence interval needed for.</p>
</td></tr>
<tr><td><code id="confint.desla_+3A_level">level</code></td>
<td>
<p>confidence level(s).</p>
</td></tr>
<tr><td><code id="confint.desla_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
</table>

<hr>
<h2 id='create_state_dummies'>Create State Dummies</h2><span id='topic+create_state_dummies'></span>

<h3>Description</h3>

<p>Creates state dummies for use in <code><a href="#topic+HDLP">HDLP</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_state_dummies(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_state_dummies_+3A_x">x</code></td>
<td>
<p>Contains the variables that define the states. Each column should either represent a categorical variable indicating the state of each observation, or each column should be a binary indicator for one particular state.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first checks if <code>x</code> is already in the correct output format by evaluating if each row sums up to one. If this is not the case, each column is treated as a categorical variable for which its unique entries define the states it can take. If <code>x</code> contains more than one column, interactions between the variables are created. Example, inputting two variables that can take two states each, results in a total of four possible states, and hence the output matrix contains four columns.
</p>


<h3>Value</h3>

<p>A matrix where each column is a binary indicator for one state.
</p>

<hr>
<h2 id='create_state_dummies_from_datamatrix'>Create State Dummies from Matrix</h2><span id='topic+create_state_dummies_from_datamatrix'></span>

<h3>Description</h3>

<p>Creates state dummies from matrix-like objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_state_dummies_from_datamatrix(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_state_dummies_from_datamatrix_+3A_x">x</code></td>
<td>
<p>Matrix or data frame where each column represents a state variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each column is a binary indicator for one state.
</p>

<hr>
<h2 id='create_state_dummies_from_vector'>Create State Dummies from Vector</h2><span id='topic+create_state_dummies_from_vector'></span>

<h3>Description</h3>

<p>Creates state dummies from vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_state_dummies_from_vector(x, varname = "StateVar")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_state_dummies_from_vector_+3A_x">x</code></td>
<td>
<p>Vector representing the state variable.</p>
</td></tr>
<tr><td><code id="create_state_dummies_from_vector_+3A_varname">varname</code></td>
<td>
<p>Name of the state variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each column is a binary indicator for one state.
</p>

<hr>
<h2 id='desla'>Desparsified lasso</h2><span id='topic+desla'></span>

<h3>Description</h3>

<p>Calculates the desparsified lasso as originally introduced in van de Geer et al. (2014), and provides inference suitable for high-dimensional time series, based on the long run covariance estimator in Adamek et al. (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desla(
  X,
  y,
  H,
  alphas = 0.05,
  penalize_H = TRUE,
  R = NULL,
  q = NULL,
  demean = TRUE,
  scale = TRUE,
  progress_bar = TRUE,
  parallel = TRUE,
  threads = NULL,
  PI_constant = NULL,
  LRV_bandwidth = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="desla_+3A_x">X</code></td>
<td>
<p><code>T_</code> x <code>N</code> regressor matrix</p>
</td></tr>
<tr><td><code id="desla_+3A_y">y</code></td>
<td>
<p><code>T_</code> x 1 dependent variable vector</p>
</td></tr>
<tr><td><code id="desla_+3A_h">H</code></td>
<td>
<p>indexes of relevant regressors</p>
</td></tr>
<tr><td><code id="desla_+3A_alphas">alphas</code></td>
<td>
<p>(optional) vector of significance levels (0.05 by default)</p>
</td></tr>
<tr><td><code id="desla_+3A_penalize_h">penalize_H</code></td>
<td>
<p>(optional) boolean, true if you want the variables in H to be penalized (<code>TRUE</code> by default)</p>
</td></tr>
<tr><td><code id="desla_+3A_r">R</code></td>
<td>
<p>(optional) matrix with number of columns the dimension of <code>H</code>, used to test the null hypothesis <code>R</code>*beta=<code>q</code> (identity matrix as default)</p>
</td></tr>
<tr><td><code id="desla_+3A_q">q</code></td>
<td>
<p>(optional) vector of size same as the rows of <code>H</code>, used to test the null hypothesis <code>R</code>*beta=<code>q</code> (zeroes by default)</p>
</td></tr>
<tr><td><code id="desla_+3A_demean">demean</code></td>
<td>
<p>(optional) boolean, true if <code>X</code> and <code>y</code> should be demeaned before the desparsified lasso is calculated. This is recommended, due to the assumptions for the method (true by default)</p>
</td></tr>
<tr><td><code id="desla_+3A_scale">scale</code></td>
<td>
<p>(optional) boolean, true if <code>X</code> and <code>y</code> should be scaled by the column-wise standard deviations. Recommended for lasso based methods in general, since the penalty is scale-sensitive (true by default)</p>
</td></tr>
<tr><td><code id="desla_+3A_progress_bar">progress_bar</code></td>
<td>
<p>(optional) boolean, displays a progress bar while running if true, tracking the progress of estimating the nodewise regressions (TRUE by default)</p>
</td></tr>
<tr><td><code id="desla_+3A_parallel">parallel</code></td>
<td>
<p>boolean, whether parallel computing should be used (TRUE by default)</p>
</td></tr>
<tr><td><code id="desla_+3A_threads">threads</code></td>
<td>
<p>(optional) integer, how many threads should be used for parallel computing if <code>parallel=TRUE</code> (default is to use all but two)</p>
</td></tr>
<tr><td><code id="desla_+3A_pi_constant">PI_constant</code></td>
<td>
<p>(optional) constant, used in the plug-in selection method (0.8 by default). For details see Adamek et al. (2021)</p>
</td></tr>
<tr><td><code id="desla_+3A_lrv_bandwidth">LRV_bandwidth</code></td>
<td>
<p>(optional) vector of parameters controlling the bandwidth <code>Q_T</code> used in the long run covariance matrix, <code>Q_T</code>=ceil(<code>LRV_bandwidth[1]</code>*<code>T_</code>^<code>LRV_bandwidth[2]</code>). When <code>LRV_bandwidth=NULL</code>, the bandwidth is selected according to Andrews (1991) (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements: <br />
</p>
<table role = "presentation">
<tr><td><code>bhat</code></td>
<td>
<p>desparsified lasso estimates for the parameters indexed by <code>H</code>, unscaled to be in the original scale of <code>y</code> and <code>X</code></p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>
<p>standard errors of the estimates for variables indexed by <code>H</code></p>
</td></tr>
<tr><td><code>intervals</code></td>
<td>
<p>matrix containing the confidence intervals for parameters indexed in <code>H</code>, unscaled to be in the original scale of <code>y</code> and <code>X</code></p>
</td></tr>
<tr><td><code>betahat</code></td>
<td>
<p>lasso estimates from the initial regression of <code>y</code> on <code>X</code></p>
</td></tr>
<tr><td><code>DSL_matrices</code></td>
<td>
<p>list containing the matrices <code>Gammahat</code>, <code>Upsilonhat_inv</code> and <code>Thetahat</code> used for calculating the desparsified lasso, as well as <code>Omegahat</code>, the long run covariance matrix for the variables indexed by <code>H</code>. For details see Adamek et al. (2021)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>list containing the vector of residuals from the initial lasso regression (<code>init</code>) and the matrix of residuals from the nodewise regressions (<code>nw</code>)</p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>
<p>values of lambda selected in the initial lasso regression (<code>init</code>) and the nodewise lasso regressions (<code>nw</code>)</p>
</td></tr>
<tr><td><code>selected_vars</code></td>
<td>
<p>vector of indexes of the nonzero parameters in the initial lasso (<code>init</code>) and each nodewise regression (<code>nw</code>)</p>
</td></tr>
<tr><td><code>wald_test</code></td>
<td>
<p>list containing elements for inference on <code>R</code> beta=<code>q</code>. <code>joint_test</code> contains the test statistic for the overall null hypothesis <code>R</code> beta=<code>q</code> along with the p-value. At default values of <code>R</code> and <code>q</code>, this tests the joint significance of all variables indexed by <code>H</code>. <code>row_tests</code> contains the vector of z-statistics and confidence intervals associated with each row of <code>R</code> beta - <code>q</code>, unscaled to be in the original scale of <code>y</code> and <code>X</code>. This output is only given when either <code>R</code> or <code>q</code> are supplied</p>
</td></tr>
</table>


<h3>References</h3>

<p>Adamek R, Smeekes S, Wilms I (2021).
&ldquo;LASSO inference for high-dimensional time series.&rdquo;
<em>arXiv preprint arXiv:2007.10952</em>.<br /><br /> Andrews DW (1991).
&ldquo;Heteroskedasticity and autocorrelation consistent covariance matrix estimation.&rdquo;
<em>Econometrica</em>, <b>59</b>(3), 817&ndash;858.<br /><br /> van de Geer S, Buhlmann P, Ritov Y, Dezeure R (2014).
&ldquo;On asymptotically optimal confidence regions and tests for high-dimensional models.&rdquo;
<em>Annals of Statistics</em>, <b>42</b>(3), 1166&ndash;1202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-matrix(rnorm(50*50), nrow=50)
y&lt;-X[,1:4] %*% c(1, 2, 3, 4) + rnorm(50)
H&lt;-c(1, 2, 3, 4)
d&lt;-desla(X, y, H)
</code></pre>

<hr>
<h2 id='HDLP'>State Dependent High-Dimensional Local Projection</h2><span id='topic+HDLP'></span>

<h3>Description</h3>

<p>Calculates impulse responses with local projections, using the desla function to estimate the high-dimensional linear models, and provide asymptotic inference. The naming conventions in this function follow the notation in Plagborg-Moller and Wolf (2021), in particular Equation 1 therein. This function also allows for estimating state-dependent responses, as in Ramey and Zubairy (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HDLP(
  x,
  y,
  r = NULL,
  q = NULL,
  state_variables = NULL,
  y_predetermined = FALSE,
  cumulate_y = FALSE,
  hmax = 24,
  lags = 12,
  alphas = 0.05,
  penalize_x = FALSE,
  PI_constant = NULL,
  progress_bar = TRUE,
  OLS = FALSE,
  parallel = TRUE,
  threads = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HDLP_+3A_x">x</code></td>
<td>
<p><code>T_</code>x1 vector containing the shock variable, see Plagborg-Moller and Wolf (2021) for details</p>
</td></tr>
<tr><td><code id="HDLP_+3A_y">y</code></td>
<td>
<p><code>T_</code>x1 vector containing the response variable, see Plagborg-Moller and Wolf (2021) for details</p>
</td></tr>
<tr><td><code id="HDLP_+3A_r">r</code></td>
<td>
<p>(optional) vector or matrix with <code>T_</code> rows, containing the &quot;slow&quot; variables, ones which do not react within the same period to a shock, see Plagborg-Moller and Wolf (2021) for details(NULL by default)</p>
</td></tr>
<tr><td><code id="HDLP_+3A_q">q</code></td>
<td>
<p>(optional) vector or matrix with <code>T_</code> rows, containing the &quot;fast&quot; variables, ones which may react within the same period to a shock, see Plagborg-Moller and Wolf (2021) for details (NULL by default)</p>
</td></tr>
<tr><td><code id="HDLP_+3A_state_variables">state_variables</code></td>
<td>
<p>(optional) matrix or data frame with <code>T_</code> rows, containing the variables that define the states. Each column should either represent a categorical variable indicating the state of each observation, or each column should be a binary indicator for one particular state; see 'Details'.</p>
</td></tr>
<tr><td><code id="HDLP_+3A_y_predetermined">y_predetermined</code></td>
<td>
<p>(optional) boolean, true if the response variable <code>y</code> is predetermined with respect to <code>x</code>, i.e. cannot react within the same period to the shock. If true, the impulse response at horizon 0 is 0 (false by default)</p>
</td></tr>
<tr><td><code id="HDLP_+3A_cumulate_y">cumulate_y</code></td>
<td>
<p>(optional) boolean, true if the impulse response of <code>y</code> should be cumulated, i.e. using the cumulative sum of <code>y</code> as the dependent variable (false by default)</p>
</td></tr>
<tr><td><code id="HDLP_+3A_hmax">hmax</code></td>
<td>
<p>(optional) integer, the maximum horizon up to which the impulse responses are computed. Should not exceed the <code>T_</code>-<code>lags</code> (24 by default)</p>
</td></tr>
<tr><td><code id="HDLP_+3A_lags">lags</code></td>
<td>
<p>(optional) integer, the number of lags to be included in the local projection model. Should not exceed <code>T_</code>-<code>hmax</code>(12 by default)</p>
</td></tr>
<tr><td><code id="HDLP_+3A_alphas">alphas</code></td>
<td>
<p>(optional) vector of significance levels (0.05 by default)</p>
</td></tr>
<tr><td><code id="HDLP_+3A_penalize_x">penalize_x</code></td>
<td>
<p>(optional) boolean, true if the parameter of interest should be penalized (<code>FALSE</code> by default)</p>
</td></tr>
<tr><td><code id="HDLP_+3A_pi_constant">PI_constant</code></td>
<td>
<p>(optional) constant, used in the plug-in selection method (0.8 by default). For details see Adamek et al. (2021)</p>
</td></tr>
<tr><td><code id="HDLP_+3A_progress_bar">progress_bar</code></td>
<td>
<p>(optional) boolean, true if a progress bar should be displayed during execution (true by default)</p>
</td></tr>
<tr><td><code id="HDLP_+3A_ols">OLS</code></td>
<td>
<p>(optional) boolean, whether the local projections should be computed by OLS instead of the desparsified lasso. This should only be done for low-dimensional regressions (FALSE by default)</p>
</td></tr>
<tr><td><code id="HDLP_+3A_parallel">parallel</code></td>
<td>
<p>boolean, whether parallel computing should be used. Default is TRUE.</p>
</td></tr>
<tr><td><code id="HDLP_+3A_threads">threads</code></td>
<td>
<p>(optional) integer, how many threads should be used for parallel computing if <code>parallel=TRUE</code>. Default is to use all but two.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input to <code>state_variables</code> is transformed to a suitable matrix where each column represents one state using the function <code><a href="#topic+create_state_dummies">create_state_dummies</a></code>. See that function for further details.
</p>


<h3>Value</h3>

<p>Returns a list with the following elements: <br />
</p>
<table role = "presentation">
<tr><td><code>intervals</code></td>
<td>
<p>list of matrices containing the point estimates and confidence intervals for the impulse response functions in each state, for significance levels given in <code>alphas</code></p>
</td></tr>
<tr><td><code>Thetahat</code></td>
<td>
<p>matrix (row vector) calculated from the nodewise regression at horizon 0, which is re-used at later horizons</p>
</td></tr>
<tr><td><code>betahats</code></td>
<td>
<p>list of matrices (column vectors), giving the initial lasso estimate at each horizon</p>
</td></tr>
</table>


<h3>References</h3>

<p>Adamek R, Smeekes S, Wilms I (2021).
&ldquo;LASSO inference for high-dimensional time series.&rdquo;
<em>arXiv preprint arXiv:2007.10952</em>.<br /><br /> Plagborg-Moller M, Wolf CK (2021).
&ldquo;Local projections and VARs estimate the same impulse responses.&rdquo;
<em>Econometrica</em>, <b>89</b>(2), 955&ndash;980.<br /><br /> Ramey VA, Zubairy S (2018).
&ldquo;Government spending multipliers in good times and in bad: evidence from US historical data.&rdquo;
<em>Journal of Political Economy</em>, <b>126</b>(2), 850&ndash;901.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-matrix(rnorm(50*50), nrow=50)
y&lt;-X[,1:4] %*% c(1, 2, 3, 4) + rnorm(50)
s&lt;-matrix(c(rep(1,25),rep(0,50),rep(1,25)), ncol=2, dimnames = list(NULL, c("A","B")))
h&lt;-HDLP(x=X[,4], y=y, q=X[,-4], state_variables=s, hmax=5, lags=1)
plot(h)
</code></pre>

<hr>
<h2 id='plot.hdlp'>Plot Impulse Responses obtained from HDLP.</h2><span id='topic+plot.hdlp'></span>

<h3>Description</h3>

<p>Plot Impulse Responses obtained from HDLP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdlp'
plot(
  x,
  y = NULL,
  response = NULL,
  impulse = NULL,
  states = NULL,
  units = NULL,
  title = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.hdlp_+3A_x">x</code></td>
<td>
<p>Output of the <code>HDLP()</code> function.</p>
</td></tr>
<tr><td><code id="plot.hdlp_+3A_y">y</code></td>
<td>
<p>Has no function, included for compatibility with <code>plot.default()</code>.</p>
</td></tr>
<tr><td><code id="plot.hdlp_+3A_response">response</code></td>
<td>
<p>Name of the response variable (<code>y</code> in <code>HDLP()</code>).</p>
</td></tr>
<tr><td><code id="plot.hdlp_+3A_impulse">impulse</code></td>
<td>
<p>Name of the shock variable (<code>x</code> in <code>HDLP()</code>).</p>
</td></tr>
<tr><td><code id="plot.hdlp_+3A_states">states</code></td>
<td>
<p>Optional names of the states (when applicable). If not provided, names
will be determined from <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.hdlp_+3A_units">units</code></td>
<td>
<p>Units of the response variable (y-axis label).</p>
</td></tr>
<tr><td><code id="plot.hdlp_+3A_title">title</code></td>
<td>
<p>String containing title of the plot; can be used to overwrite default
generated based on the names of the <code>response</code> and <code>impulse</code> variables.</p>
</td></tr>
<tr><td><code id="plot.hdlp_+3A_...">...</code></td>
<td>
<p>Other arguments forwarded to plot function (currently inactive).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>

<hr>
<h2 id='print.desla'>Print desla output</h2><span id='topic+print.desla'></span>

<h3>Description</h3>

<p>Print desla output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'desla'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  show_selected = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.desla_+3A_x">x</code></td>
<td>
<p>a <code>desla</code> object.</p>
</td></tr>
<tr><td><code id="print.desla_+3A_digits">digits</code></td>
<td>
<p>digits.</p>
</td></tr>
<tr><td><code id="print.desla_+3A_signif.stars">signif.stars</code></td>
<td>
<p>show stars of significance.</p>
</td></tr>
<tr><td><code id="print.desla_+3A_show_selected">show_selected</code></td>
<td>
<p>upper bound for which to show the names of selected variables in the
lasso regressions (default is 10)</p>
</td></tr>
<tr><td><code id="print.desla_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.desla'>Print desla summary output</h2><span id='topic+print.summary.desla'></span>

<h3>Description</h3>

<p>Print desla summary output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.desla'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  show_selected = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.desla_+3A_x">x</code></td>
<td>
<p>a <code>desla</code> object.</p>
</td></tr>
<tr><td><code id="print.summary.desla_+3A_digits">digits</code></td>
<td>
<p>digits.</p>
</td></tr>
<tr><td><code id="print.summary.desla_+3A_signif.stars">signif.stars</code></td>
<td>
<p>show stars of significance.</p>
</td></tr>
<tr><td><code id="print.summary.desla_+3A_show_selected">show_selected</code></td>
<td>
<p>upper bound for which to show the names of selected variables in the
lasso regressions (default is 10)</p>
</td></tr>
<tr><td><code id="print.summary.desla_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
</table>

<hr>
<h2 id='summary.desla'>Summary of desla output</h2><span id='topic+summary.desla'></span>

<h3>Description</h3>

<p>Summary of desla output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'desla'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.desla_+3A_object">object</code></td>
<td>
<p>a <code>desla</code> object.</p>
</td></tr>
<tr><td><code id="summary.desla_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
