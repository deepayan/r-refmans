<!DOCTYPE html><html><head><title>Help for package pensynth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pensynth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cv_pensynth'><p>Cross-validated penalized synthetic control estimator</p></a></li>
<li><a href='#in_convex_hull'><p>Is the treated unit in the convex hull</p></a></li>
<li><a href='#pensynth'><p>Penalized synthetic control estimator</p></a></li>
<li><a href='#plot_path'><p>Plotting for cross-validated penalized synthetic control objects</p></a></li>
<li><a href='#standardize_X'><p>Function to scale the X matrices in synthetic control</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Penalized Synthetic Control Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimate penalized synthetic control models
    and perform hold-out validation to determine their 
    penalty parameter. This method is based on the work by
    Abadie &amp; L'Hour (2021) &lt;<a href="https://doi.org/10.1080%2F01621459.2021.1971535">doi:10.1080/01621459.2021.1971535</a>&gt;.
    Penalized synthetic controls smoothly interpolate between 
    one-to-one matching and the synthetic control method.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>geometry, clarabel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-15 08:54:50 UTC; erikj</td>
</tr>
<tr>
<td>Author:</td>
<td>Erik-Jan van Kesteren
    <a href="https://orcid.org/0000-0003-1548-1663"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Isaac Slaughter <a href="https://orcid.org/0000-0002-1911-2374"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Erik-Jan van Kesteren &lt;e.vankesteren1@uu.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-15 11:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='cv_pensynth'>Cross-validated penalized synthetic control estimator</h2><span id='topic+cv_pensynth'></span>

<h3>Description</h3>

<p>Compute a penalized synthetic control estimator with cross-validation for the
lambda penalty parameter. Lambda will be determined by minimizing the mean squared
error on a hold-out set of pre-intervention outcome time-series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_pensynth(
  X1,
  X0,
  v,
  Z1,
  Z0,
  nlambda = 100,
  opt_pars = clarabel::clarabel_control(),
  standardize = TRUE,
  return_solver_info = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_pensynth_+3A_x1">X1</code></td>
<td>
<p><code style="white-space: pre;">&#8288;N_covars by 1 matrix&#8288;</code> of treated unit covariates</p>
</td></tr>
<tr><td><code id="cv_pensynth_+3A_x0">X0</code></td>
<td>
<p><code style="white-space: pre;">&#8288;N_covars by N_donors matrix&#8288;</code> of donor unit covariates</p>
</td></tr>
<tr><td><code id="cv_pensynth_+3A_v">v</code></td>
<td>
<p><code style="white-space: pre;">&#8288;N_covars vector&#8288;</code> of variable weights</p>
</td></tr>
<tr><td><code id="cv_pensynth_+3A_z1">Z1</code></td>
<td>
<p><code style="white-space: pre;">&#8288;N_targets by 1 matrix&#8288;</code> of treated unit hold-out outcome</p>
</td></tr>
<tr><td><code id="cv_pensynth_+3A_z0">Z0</code></td>
<td>
<p><code style="white-space: pre;">&#8288;N_targets by N_donors matrix&#8288;</code> of donor unit hold-out outcome</p>
</td></tr>
<tr><td><code id="cv_pensynth_+3A_nlambda">nlambda</code></td>
<td>
<p><code>integer</code> length of lambda sequence (see details)</p>
</td></tr>
<tr><td><code id="cv_pensynth_+3A_opt_pars">opt_pars</code></td>
<td>
<p><code>clarabel</code> settings using <code><a href="clarabel.html#topic+clarabel_control">clarabel::clarabel_control()</a></code></p>
</td></tr>
<tr><td><code id="cv_pensynth_+3A_standardize">standardize</code></td>
<td>
<p><code>boolean</code> whether to standardize the input matrices (default TRUE)</p>
</td></tr>
<tr><td><code id="cv_pensynth_+3A_return_solver_info">return_solver_info</code></td>
<td>
<p><code>boolean</code> whether to return diagnostic information concerning solver (default FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lambda sequence is an exponentially increasing sequence where
The minimum lambda is always 1e-7, the max lambda is determined by the data.
</p>


<h3>Value</h3>

<p>A list of the lambda sequence, the associated weights, and the mses. If
<code>return_solver_info</code> is <code>TRUE</code>, the list will also contain diagnostic information about
the solvers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pensynth">pensynth()</a></code> <code><a href="#topic+plot_path">plot_path()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(45)
N_covar &lt;- 7
N_donor &lt;- 50
N_target &lt;- 12

w  &lt;- runif(N_donor)
w[5:N_donor] &lt;- 0
w  &lt;- w / sum(w)
v  &lt;- rep(1, N_covar)
X0 &lt;- matrix(rnorm(N_covar*N_donor), N_covar)
X1 &lt;- X0%*%w
Z0 &lt;- matrix(rnorm(N_target*N_donor), N_target)
Z1 &lt;- Z0%*%w

res &lt;- cv_pensynth(X1, X0, v, Z1, Z0)
plot_path(res)

</code></pre>

<hr>
<h2 id='in_convex_hull'>Is the treated unit in the convex hull</h2><span id='topic+in_convex_hull'></span>

<h3>Description</h3>

<p>This function finds out if the treated unit is in the convex hull
of the donor units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_convex_hull(X1, X0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_convex_hull_+3A_x1">X1</code></td>
<td>
<p><code style="white-space: pre;">&#8288;N_covars by 1 matrix&#8288;</code> of treated unit covariates</p>
</td></tr>
<tr><td><code id="in_convex_hull_+3A_x0">X0</code></td>
<td>
<p><code style="white-space: pre;">&#8288;N_covars by N_donors matrix&#8288;</code> of donor unit covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bool</code> whether the treated unit is in the convex hull of
the donor units.
</p>


<h3>See Also</h3>

<p><code><a href="geometry.html#topic+convhulln">geometry::convhulln()</a></code> <code><a href="geometry.html#topic+inhulln">geometry::inhulln()</a></code>
</p>

<hr>
<h2 id='pensynth'>Penalized synthetic control estimator</h2><span id='topic+pensynth'></span>

<h3>Description</h3>

<p>For a given set of variable weights (v) this function estimates
the unit weights for a synthetic control with penalization
according to Abadie &amp; L'Hour (2021). This function deals with only a
single treated unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pensynth(
  X1,
  X0,
  v,
  lambda = 0,
  opt_pars = clarabel::clarabel_control(),
  standardize = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pensynth_+3A_x1">X1</code></td>
<td>
<p><code style="white-space: pre;">&#8288;N_covars by 1 matrix&#8288;</code> of treated unit covariates</p>
</td></tr>
<tr><td><code id="pensynth_+3A_x0">X0</code></td>
<td>
<p><code style="white-space: pre;">&#8288;N_covars by N_donors matrix&#8288;</code> of donor unit covariates</p>
</td></tr>
<tr><td><code id="pensynth_+3A_v">v</code></td>
<td>
<p><code style="white-space: pre;">&#8288;N_covars vector&#8288;</code> of variable weights</p>
</td></tr>
<tr><td><code id="pensynth_+3A_lambda">lambda</code></td>
<td>
<p><code>numeric</code> penalization parameter</p>
</td></tr>
<tr><td><code id="pensynth_+3A_opt_pars">opt_pars</code></td>
<td>
<p><code>clarabel</code> settings using <code><a href="clarabel.html#topic+clarabel_control">clarabel::clarabel_control()</a></code></p>
</td></tr>
<tr><td><code id="pensynth_+3A_standardize">standardize</code></td>
<td>
<p><code>boolean</code> whether to standardize the input matrices (default TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine uses the same notation of the original <code><a href="Synth.html#topic+synth">Synth::synth()</a></code> implementation
but uses a different, faster quadratic program solver (namely, <code><a href="osqp.html#topic+osqp">osqp::osqp()</a></code>). Additionally, it
implements the penalization procedure described in Abadie &amp; L'Hour (2021), such that the loss
function is as in equation 5 of that paper (but for a single treated unit).
</p>
<p>Variable weights are not optimized by this function, meaning they need to be pre-specified.
This is by design.
</p>
<p>The original synthetic control method can be recovered by setting lambda = 0. For determining
lambda based on data, see <code><a href="#topic+cv_pensynth">cv_pensynth()</a></code>.
</p>


<h3>Value</h3>

<p>A list with two values: <code>w</code>, the estimated weights; and
<code>solution</code>, the result of the optimization.
</p>


<h3>References</h3>

<p>Abadie, A., &amp; L’Hour, J. (2021).
A penalized synthetic control estimator for disaggregated data.
<em>Journal of the American Statistical Association, 116</em>(536), 1817-1834.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv_pensynth">cv_pensynth()</a></code> <code><a href="Synth.html#topic+synth">Synth::synth()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some data
X0 &lt;- matrix(
  c(1, 1.3,
    0.5, 1.8,
    1.1, 2.4,
    1.8, 1.8,
    1.3, 1.8), 2)
X1 &lt;- matrix(c(0.8, 1.65), 2)
v &lt;- rep(1, 2)

# run classic synthetic control (no penalization)
res &lt;- pensynth(X1, X0, v)
plot(t(X0))
points(t(X1), pch = 2)
points(t(X0%*%res$w), pch = 3)

# run synthetic control with penalty
res &lt;- pensynth(X1, X0, v, lambda = 0.5)
points(t(X0 %*% res$w), pch = 4)

</code></pre>

<hr>
<h2 id='plot_path'>Plotting for cross-validated penalized synthetic control objects</h2><span id='topic+plot_path'></span>

<h3>Description</h3>

<p>Displays a mean squared error curve and weights curve as a function
of lambda, the penalization parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_path(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_path_+3A_object">object</code></td>
<td>
<p>a <code>cvpensynth</code> output object</p>
</td></tr>
<tr><td><code id="plot_path_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>plot()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv_pensynth">cv_pensynth()</a></code> <code><a href="#topic+pensynth">pensynth()</a></code>
</p>

<hr>
<h2 id='standardize_X'>Function to scale the X matrices in synthetic control</h2><span id='topic+standardize_X'></span>

<h3>Description</h3>

<p>The default implementation of synthetic control first
scales the X matrices using the mean and standard
deviation of the X1 and X0 matrices together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_X(X1, X0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_X_+3A_x1">X1</code></td>
<td>
<p>the X1 matrix</p>
</td></tr>
<tr><td><code id="standardize_X_+3A_x0">X0</code></td>
<td>
<p>the X0 matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the pre-processing in <code><a href="Synth.html#topic+synth">Synth::synth()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">base::scale()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
