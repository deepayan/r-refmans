<!DOCTYPE html><html><head><title>Help for package adehabitatLT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adehabitatLT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acfdist.ltraj'>
<p>Compute correlogram for angular and linear descriptors of a movement path</p></a></li>
<li><a href='#albatross'><p>Argos Monitoring of Adult Albatross Movement</p></a></li>
<li><a href='#as.ltraj'><p>Working with Trajectories in 2D Space: the Class ltraj</p></a></li>
<li><a href='#bear'><p>GPS monitoring of one brown bear</p></a></li>
<li><a href='#buffalo'>
<p>GPS monitoring of a buffalo</p></a></li>
<li><a href='#burst'><p>ID, Bursts and infolocs of an Object of Class ltraj</p></a></li>
<li><a href='#c.ltraj'><p>Combine Bursts of Relocations in Objects of Class &quot;ltraj&quot;</p></a></li>
<li><a href='#capreochiz'><p>GPS Monitoring of one Roe Deer in Chize (France)</p></a></li>
<li><a href='#capreotf'><p>GPS Monitoring of one Roe Deer in Trois-Fontaines (France)</p></a></li>
<li><a href='#Chi'><p>The Chi Distribution</p></a></li>
<li><a href='#cutltraj'><p>Split Trajectories into Several Bursts</p></a></li>
<li><a href='#Extract.ltraj'><p>Extract or Replace Parts of an Object of Class ltraj</p></a></li>
<li><a href='#fpt'><p>Computation of the First Passage Time From Trajectories</p></a></li>
<li><a href='#gdltraj'><p>Working with Trajectories: Specify a Time Period</p></a></li>
<li><a href='#hbrown'><p> Estimates the value of h for a Brownian motion</p></a></li>
<li><a href='#hist.ltraj'><p>Histogram of the Descriptive Parameters of a Trajectory</p></a></li>
<li><a href='#hseal'><p>Argos Monitoring of Hooded Seal</p></a></li>
<li><a href='#ibex'><p>GPS Monitoring of Four Ibex in the Belledonne Mountain</p></a></li>
<li><a href='#ibexraw'><p>GPS Monitoring of Four Ibex in the Belledonne Mountain (irregular</p>
data)</a></li>
<li><a href='#indmove'><p>Testing Independence in Regular Trajectory Parameters</p></a></li>
<li><a href='#is.regular'><p>Regular Trajectories</p></a></li>
<li><a href='#is.sd'><p>Handling of Trajectories of the Same Duration</p></a></li>
<li><a href='#lavielle'><p>Segmentation of a time series using the method of Lavielle (1999,</p>
2005)</a></li>
<li><a href='#ld'>
<p>Quick Conversion of Objects of Class ltraj from and to Dataframes</p></a></li>
<li><a href='#ltraj2spdf'><p> Conversion of the class &quot;ltraj&quot; to the package &quot;sp&quot;</p></a></li>
<li><a href='#mindistkeep'><p>Detecting Absence of Movement in an Object of Class 'ltraj'</p></a></li>
<li><a href='#modpartltraj'><p>Segmentation of a trajectory based on Markov models</p></a></li>
<li><a href='#mouflon'><p>GPS Monitoring of One Mouflon in the Caroux Mountain</p></a></li>
<li><a href='#na.omit.ltraj'><p>Removes the missing values in a trajectory</p></a></li>
<li><a href='#offsetdate'><p>Date Handling in an Object of Class 'ltraj'</p></a></li>
<li><a href='#plot.ltraj'><p>Graphical Display of an Object of Class &quot;ltraj&quot;</p></a></li>
<li><a href='#plotltr'><p>Changes in Traject Parameters Over Time</p></a></li>
<li><a href='#porpoise'><p>Argos monitoring of Porpoise Movements</p></a></li>
<li><a href='#puechcirc'><p>Movements of wild boars tracked at Puechabon</p></a></li>
<li><a href='#qqchi'><p>Quantile-Quantile Plots for Trajectories of Class 'ltraj'</p></a></li>
<li><a href='#rasterize.ltraj'>
<p>Rasterize a Trajectory</p></a></li>
<li><a href='#redisltraj'><p>Rediscretization of a Trajectory With Regular Step Length or Duration</p></a></li>
<li><a href='#residenceTime'><p>Trajectory Analysis using the Residence Time Method</p></a></li>
<li><a href='#runsNAltraj'><p>Highlighting the Patterns in Missing Values in Trajects</p></a></li>
<li><a href='#rupicabau'><p>GPS Monitoring of One Chamois in the Bauges Mountains</p></a></li>
<li><a href='#set.limits'><p>Define the Same Time Limits for several Bursts in a</p>
Regular Trajectory</a></li>
<li><a href='#setNA'><p> Place Missing Values in Objects of Class 'ltraj'</p></a></li>
<li><a href='#sett0'><p>Round the Timing of Collection of Relocations to Obtain Regular</p>
Trajectory</a></li>
<li><a href='#simm.bb'><p>Brownian bridge motion</p></a></li>
<li><a href='#simm.brown'><p>Simulate a Bivariate Brownian Motion</p></a></li>
<li><a href='#simm.crw'><p>Simulation of a Correlated Random Walk</p></a></li>
<li><a href='#simm.levy'><p>Simulates a Levy Walk</p></a></li>
<li><a href='#simm.mba'><p>Simulation of an Arithmetic Brownian Motion</p></a></li>
<li><a href='#simm.mou'><p>Simulation of a Bivariate Ornstein-Uhlenbeck Process</p></a></li>
<li><a href='#sliwinltr'><p>Apply a Function on an Object of Class &quot;ltraj&quot;, Using a Sliding</p>
Window</a></li>
<li><a href='#subsample'><p>Subsample a Trajectory</p></a></li>
<li><a href='#teal'><p>Teal (Anas crecca) Ring Recovery Dataset</p></a></li>
<li><a href='#testNM'><p>Null Model Approach for Animal Movement Analysis</p></a></li>
<li><a href='#trajdyn'><p>Interactive Display of Objects of Class 'ltraj'</p></a></li>
<li><a href='#typeII2typeI'><p>Change the Type of a Trajectory</p></a></li>
<li><a href='#wawotest'><p>Wald-Wolfowitz Test of Randomness</p></a></li>
<li><a href='#whale'><p>Argos Monitoring of Whale Movement</p></a></li>
<li><a href='#which.ltraj'><p>Identify Relocations Fullfilling a Condition in an Object of</p>
Class &quot;ltraj&quot;</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3.27</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-06</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), sp, methods, ade4, adehabitatMA, CircStats,
stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tkrplot, MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, utils</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Animal Movements</td>
</tr>
<tr>
<td>Author:</td>
<td>Clement Calenge, contributions from Stephane Dray and Manuela Royer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Clement Calenge &lt;clement.calenge@ofb.gouv.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of tools for the analysis of animal movements.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-06 11:29:06 UTC; calenge</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-06 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acfdist.ltraj'>
Compute correlogram for angular and linear descriptors of a movement path
</h2><span id='topic+acfdist.ltraj'></span><span id='topic+acfang.ltraj'></span>

<h3>Description</h3>

<p>The functions <code>acfdist.ltraj</code> and <code>acfang.ltraj</code> compute
(and by default plot) a correlogram-like function .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfdist.ltraj(x, which = c("dist", "dx", "dy"), nrep = 999, lag = 1,
              plot = TRUE, xlab = "Lag", ylab = "autocorrelation")

acfang.ltraj(x, which = c("absolute", "relative"), nrep = 999, lag = 1,
             plot = TRUE, xlab = "Lag", ylab = "autocorrelation")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acfdist.ltraj_+3A_x">x</code></td>
<td>
<p>an object of the class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="acfdist.ltraj_+3A_which">which</code></td>
<td>
<p> to select on which parameter the autocorrelation should
be computed (see details).</p>
</td></tr>
<tr><td><code id="acfdist.ltraj_+3A_nrep">nrep</code></td>
<td>
<p> the number of repetitions used to test the significance
of autocorrelation for each lag value.</p>
</td></tr>
<tr><td><code id="acfdist.ltraj_+3A_lag">lag</code></td>
<td>
<p> maximum lag at which to calculate the autocorrelation.
Default is 1.</p>
</td></tr>
<tr><td><code id="acfdist.ltraj_+3A_plot">plot</code></td>
<td>
<p> logical. If 'TRUE' (the default) the autocorrelation
is plotted.</p>
</td></tr>
<tr><td><code id="acfdist.ltraj_+3A_xlab">xlab</code></td>
<td>
<p> a title for the x axis</p>
</td></tr>
<tr><td><code id="acfdist.ltraj_+3A_ylab">ylab</code></td>
<td>
<p> a title for the y axis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>acfdist.ltraj</code> is used to compute a correlogram for
linear descriptors and <code>acfang.ltraj</code> for angular descriptors
(see <code>as.ltraj</code> for a description of these descriptors).
</p>
<p>Statistics used are defined in Dray et al. (in press). They are based
on squared differences between successive values. For angular
descriptors, the statistic is based on the chord distance.
</p>
<p>In the case of missing data, the computation of the correlograms is
restricted to the pairs of successive observed data and only observed
data are permuted (i.e. the structure of the missing data is kept
constant under permutation).
</p>
<p>The grey area represents a 95 % interval obtained after permutation
of the data. If the observed data is outside this region, it is
considered as significant and represetend by a black symbol. Note that
no multiple-comparison adjustement is performed.
</p>


<h3>Value</h3>

<p>A list of matrices. Each matrix corresponds to a 'burst'. The matrix
contains for each lag value (column), the values of autocorrelation
(observed, and the 2.5 %, 50 % and 97.5 % quantiles of for the set
of <code>nrep</code> permutations of  values).
</p>


<h3>Author(s)</h3>

<p>Stephane Dray <a href="mailto:dray@biomserv.univ-lyon1.fr">dray@biomserv.univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Dray, S., Royer-Carenzi, M. and Calenge, C. The exploratory analysis
of autocorrelation in animal movement studies. <em>Ecological
Research</em>, in press.<br />
</p>
<p>Calenge, C., Dray, S. and Royer-Carenzi, M. (2009) The concept of animals
trajectories from a data analysis perspective.  <em>Ecological
Informatics</em>, <b>4</b>,34&ndash;41.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+as.ltraj">as.ltraj</a></code> for additional information on the class
<code>ltraj</code>,  <code><a href="#topic+wawotest">wawotest</a></code> for a simple test of the
autocorrelation of the descriptive parameters on the trajectory. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(puechcirc)
puechcirc
acfang.ltraj(puechcirc, lag=5)
acfdist.ltraj(puechcirc, lag=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='albatross'>Argos Monitoring of Adult Albatross Movement</h2><span id='topic+albatross'></span>

<h3>Description</h3>

<p>This data set contains the relocations of 6 adult albatross monitored
in the Crozets Islands by the team of H. Weimerskirch from the
CEBC-CNRS (Centre d'Etudes Biologiques de Chize, France).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(albatross)</code></pre>


<h3>Format</h3>

<p>This data set is an object of class <code>ltraj</code>.
</p>


<h3>Details</h3>

<p>The coordinates are given in meters (UTM - zone 42).
</p>


<h3>Source</h3>

<p>http://suivi-animal.u-strasbg.fr/index.htm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(albatross)

plot(albatross)

</code></pre>

<hr>
<h2 id='as.ltraj'>Working with Trajectories in 2D Space: the Class ltraj</h2><span id='topic+as.ltraj'></span><span id='topic+ltraj'></span><span id='topic+print.ltraj'></span><span id='topic+summary.ltraj'></span><span id='topic+rec'></span>

<h3>Description</h3>

<p>The class <code>ltraj</code> is intended to store trajectories of
animals.  Trajectories of type II correspond to trajectories for which the
time is available for each relocation (mainly GPS and
radio-tracking).  Trajectories of type I correspond to trajectories for which
the time has not been recorded (e.g. sampling of tracks in the snow).
</p>
<p><code>as.ltraj</code> creates an object of this class.
</p>
<p><code>summary.ltraj</code> returns the number of relocations (and missing
values) for each &quot;burst&quot; of relocations and each animal.
</p>
<p><code>rec</code> recalculates the descriptive parameters of an object of
class ltraj (e.g. after a modification of the contents of this object,
see examples)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ltraj(xy, date, id, burst = id, typeII = TRUE,
         slsp = c("remove", "missing"),
         infolocs = data.frame(pkey = paste(id, date, sep="."),
                               row.names=row.names(xy)),
         proj4string = CRS())
## S3 method for class 'ltraj'
print(x, ...)
## S3 method for class 'ltraj'
summary(object, ...)
rec(x, slsp = c("remove", "missing"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ltraj_+3A_x">x</code>, <code id="as.ltraj_+3A_object">object</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="as.ltraj_+3A_xy">xy</code></td>
<td>
<p>a data.frame containing the x and y coordinates of the
relocations</p>
</td></tr> 
<tr><td><code id="as.ltraj_+3A_date">date</code></td>
<td>
<p>for trajectories of type II, a vector of class <code>POSIXct</code>
giving the date for each relocation. For trajectories of type I, this
argument is not taken into account.</p>
</td></tr>
<tr><td><code id="as.ltraj_+3A_id">id</code></td>
<td>
<p>either a character string indicating the identity of the
animal or a factor with length equal to <code>nrow(xy)</code> </p>
</td></tr>
<tr><td><code id="as.ltraj_+3A_burst">burst</code></td>
<td>
<p>either a character string indicating the identity of the
burst of relocations or a factor with length equal to
<code>nrow(xy)</code></p>
</td></tr>
<tr><td><code id="as.ltraj_+3A_typeii">typeII</code></td>
<td>
<p>logical. <code>TRUE</code> indicates a trajectory of type II
(time recorded, e.g. radio-tracking), whereas <code>FALSE</code> indicates
a trajectory of type I (time not recorded, e.g. sampling of tracks in
the snow)</p>
</td></tr>
<tr><td><code id="as.ltraj_+3A_slsp">slsp</code></td>
<td>
<p>a character string used for the computation of the
turning angles (see details)</p>
</td></tr>
<tr><td><code id="as.ltraj_+3A_infolocs">infolocs</code></td>
<td>
<p>if not <code>NULL</code>, a data frame containing
additionnal information on the relocations (e.g., precision).  By
default, a primary key is generated.</p>
</td></tr>
<tr><td><code id="as.ltraj_+3A_proj4string">proj4string</code></td>
<td>
<p>an object of class CRS storing the projection
information of the relocations.</p>
</td></tr>
<tr><td><code id="as.ltraj_+3A_...">...</code></td>
<td>
<p>For other functions, arguments to be passed to the generic
functions <code>summary</code> and <code>print</code></p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Objects of class <code>ltraj</code> allow the analysis of animal
movements.  They contain the descriptive parameters of the moves
generally used in such studies (coordinates of the relocations, date,
time lag, relative and absolute angles, length of moves, increases
in the x and y direction, and dispersion R2n, see below), as well as
optionally metadata on the relocations (precision, etc.).
</p>
<p>The computation of turning angles may be problematic when successive
relocations are located at the same place.  In such cases, at least
one missing value is returned.  For example, let r1, r2, r3 and r4 be
4 successive relocations of a given animal (with coordinates (x1,y1),
(x2,y2), etc.).  The turning angle in r2 is computed between the moves
r1-r2 and r2-r3.  If r2 = r3, then a missing value is returned for the
turning angle at relocation r2.  The argument <code>slsp</code> controls the
value returned for relocation r3 in such cases.  If <code>slsp ==
    "missing"</code>, a missing value is returned also for the relocation r3.
If <code>slsp == "remove"</code>, the turning angle computed in r3 is the
angle between the moves r1-r2 and r3-r4.
</p>
<p>For a given individual, trajectories are often sampled as &quot;bursts&quot;
of relocations.  For example, when an animal is monitored using
radio-tracking, the data may consist of several circuits of activity
(two successive relocations on one circuit are often highly
autocorrelated, but the data from two circuits may be sampled at long
intervals in time).  These bursts are indicated by the attribute
<code>burst</code>. Note that the bursts should be unique: do not use the
same burst id for bursts collected on different animals.
</p>
<p>Two types of trajectories can be stored in objects of class
<code>ltraj</code>: trajectories of type I correspond to trajectories where
the time of relocations is not recorded.  It may be because it could
not be noted at the time of sampling (e.g. sampling of animals' tracks
in the snow) or because the analyst decided that he did not want to
take it into account, i.e. to study only its geometrical
properties. In this case, the variable <code>date</code> in each burst of
the object contains a vector of integer giving the order of the
relocations in the trajectory (i.e. 1, 2, 3, ...). Trajectories of
type II correspond to trajectories for which the time is available for
each relocation. It is stored as a vector of class <code>POSIXct</code> in
the column <code>date</code> of each burst of relocations. The type of
trajectory should be defined when the object of class <code>ltraj</code> is
defined, with the argument <code>typeII</code>.  Note that the time zone of
dates in objects of type II should be the same for all bursts (this is
checked by the functions of adehabitatLT).
</p>
<p>Concerning trajectories of type II, in theory, it is expected that the
time lag between two relocations is constant in all the bursts and all
the ids of one object of class 
<code>ltraj</code> (don't mix animals located every 10 minutes and animals
located every day in the same object).  Indeed, some of the
descriptive parameters of the trajectory do not have any sense when
the time lag varies.  For example, the  distribution of relative
angles (angles between successive moves) depends on a given time
scale; the angle between two during 10-min moves of a whitestork
does not have the same biological meaning as the angle between two
1-day move.  If the time lag varies, the underlying process varies
too.  For this reason, most functions of adehabitatLT have been
developed for &quot;regular&quot; trajectories, i.e. trajectories with a
constant time lag (see <code>help(sett0)</code>).  Furthermore, several
functions are intended to help the user to transform an object of
class <code>ltraj</code> into a regular object (see for example
<code>help(sett0)</code>, and particularly the examples to see how regular
trajectories can be obtained from GPS data).
</p>
<p>Nevertheless, the class <code>ltraj</code> allows for variable time lag,
which often occur with some modes of data collection (e.g. with Argos
collars). But *we stress that their analysis is still an open
question!!*
</p>
<p>Finally, the class <code>ltraj</code> deals with missing values in the
trajectories.  Missing values are frequent in the trajectories of
animals collected using telemetry: for example, GPS collar may not
receive the signal of the satellite at the time of relocation. Most
functions dealing with the class <code>ltraj</code> have a specified
behavior in case of missing values.
</p>
<p>It is recommended to store the missing values in the data *before*
the creation of the object of class <code>ltraj</code>.  For example, the
GPS data imported within R contain missing values.  It is recommended
to *not remove* these missing values before the creation of the
object!!!  These missing values may present patterns (e.g. failure to
locate the animal at certain time of the day or in certain habitat
types), and *the analysis of these missing values should be part of the
analysis of the trajectory* (e.g. see <code>help(runsNAltraj)</code> and
<code>help(plotNAltraj)</code>.
</p>
<p>However, sometimes, the data come without any information concerning
the location of these missing values.  If the trajectory is
approximately regular (i.e. approximately constant time lag), it is
possible to determine where these missing values should occur in the
object of class <code>ltraj</code>.  This is the role of the function
<code>setNA</code>.
</p>
<p>One word now about the attribute <code>infolocs</code> of the object of
class <code>ltraj</code>.  This attribute is intended to store metadata
concerning the relocations building the trajectory (the precision
of the relocations, the value of environmental variables at this
place, etc.).  There are constraints on the structure of this
attribute. Although any variable can be stored in this attribute, it
is required that: (i) all the relocations take a value (or a missing
value) for all variables, (ii) all the variables are measured (or
correspond to missing values) for all bursts and ids.  This means for
example that the function <code>c.ltraj</code> cannot be used to combine an
object where only variable &quot;A&quot; is stored as metadata and an object
where only variable &quot;B&quot; is stored as metadata.  The function
<code>removeinfo</code> can be used to remove this attribute.  Note also
that the data.frames in the list infolocs should have the same
row.names as the corresponding elements in the object of class
<code>"ltraj"</code>.
</p>
<p>Finally, note that an object of class <code>ltraj</code> *can* have an
attribute named <code>"proj4string"</code>, storing the projection
information of the object.  The package adehabitatLT does not manage
projection information, but this attribute can be useful when an
object of class <code>ltraj</code> is converted to other classes (in
particular spatial classes).  Note that this attribute can be NULL
(identical to a NA CRS).
</p>


<h3>Value</h3>

<p><code>summary.ltraj</code> returns a data frame.<br />
All other functions return objects of class <code>ltraj</code>.  An object
of class <code>ltraj</code> is a list with one component per burst of
relocations.  Each component is a data frame with two attributes and
one optionnal attribute:
the attribute <code>"id"</code> indicates the identity of the animal, and
the attribute <code>"burst"</code> indicates the identity of the
burst.  An optional attribute <code>"infolocs"</code> contains any
additional information desired by the user (precision, etc.).
Each main data frame stores the following columns:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the x coordinate for each relocation</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the y coordinate for each relocation</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>the date for each relocation (type II) or a vector of
integer giving the order of the relocations in the trajectory.</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>the increase of the move in the x direction.  At least two
successive relocations are needed to compute <code>dx</code>.  Missing
values are returned otherwise.</p>
</td></tr>
<tr><td><code>dy</code></td>
<td>
<p>the increase of the move in the y direction.  At least two
successive relocations are needed to compute <code>dy</code>.  Missing
values are returned otherwise.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>the length of each move.  At least two
successive relocations are needed to compute <code>dist</code>.  Missing
values are returned otherwise.</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>the time interval between successive relocations</p>
</td></tr>
<tr><td><code>R2n</code></td>
<td>
<p>the squared net displacement between the current relocation
and the first relocation of the trajectory</p>
</td></tr>
<tr><td><code>abs.angle</code></td>
<td>
<p>the angle between each move and the x axis.  At least two
successive relocations are needed to compute <code>abs.angle</code>.  Missing
values are returned otherwise.</p>
</td></tr>
<tr><td><code>rel.angle</code></td>
<td>
<p>the turning angles between successive moves.  At least
three successive relocations are needed to compute <code>rel.angle</code>.
Missing values are returned otherwise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a><br />
Stephane Dray <a href="mailto:dray@biomserv.univ-lyon1.fr">dray@biomserv.univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Calenge, C., Dray, S. and Royer, M. (2009) The concept of animals'
trajectories from a data analysis perspective. <em>Ecological
Informatics</em>, <b>4</b>: 34&ndash;41.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.regular">is.regular</a></code> and <code><a href="#topic+sett0">sett0</a></code> for additional
information on &quot;regular&quot; trajectories.  <code><a href="#topic+setNA">setNA</a></code> and
<code><a href="#topic+runsNAltraj">runsNAltraj</a></code> for additional information on missing values
in trajectories.  <code><a href="#topic+c.ltraj">c.ltraj</a></code> to combine several objects of
class <code>ltraj</code>, <code><a href="#topic+Extract.ltraj">Extract.ltraj</a></code> to extract or replace
bursts of relocations, <code><a href="#topic+plot.ltraj">plot.ltraj</a></code> and
<code><a href="#topic+trajdyn">trajdyn</a></code> for graphical displays, <code><a href="#topic+gdltraj">gdltraj</a></code> to
specify a time period. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(puechabonsp)
locs &lt;- puechabonsp$relocs
head(locs)
xy &lt;- coordinates(locs)
df &lt;- as.data.frame(locs)
id &lt;- df[,1]

######################################################
##
## Example of a trajectory of type I (time not recorded)

(litrI &lt;- as.ltraj(xy, id = id, typeII=FALSE))
plot(litrI)

## The components of the object of class "ltraj"
head(litrI[[1]])


######################################################
##
## Example of a trajectory of type II (time recorded)


### Conversion of the date to the format POSIX
da &lt;- as.character(df$Date)
da &lt;- as.POSIXct(strptime(as.character(df$Date),"%y%m%d", tz="Europe/Paris"))


### Creation of an object of class "ltraj", with for 
### example the first animal
(tr1 &lt;- as.ltraj(xy[id=="Brock",],
                 date = da[id=="Brock"],
                 id="Brock"))

## The components of the object of class "ltraj"
head(tr1[[1]])

## With all animals
(litr &lt;- as.ltraj(xy, da, id = id))

## Change something manually in the first burst:
head(litr[[1]])
litr[[1]][3,"x"] &lt;- 700000

## Recompute the trajectory
litr &lt;- rec(litr)
## Note that descriptive statistics have changed (e.g. dx)
head(litr[[1]])



######################################################
##
## Example of a trajectory of type II (time recorded)
## with an infolocs attribute:

data(capreochiz)
head(capreochiz)

## Create an object of class "ltraj"
cap &lt;- as.ltraj(xy = capreochiz[,c("x","y")], date = capreochiz$date,
                id = "Roe.Deer", typeII = TRUE,
                infolocs = capreochiz[,4:8])
cap


</code></pre>

<hr>
<h2 id='bear'>GPS monitoring of one brown bear</h2><span id='topic+bear'></span>

<h3>Description</h3>

<p>These data contain the relocations of one female brown bear monitored
using GPS collars during May 2004 in Sweden.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bear)</code></pre>


<h3>Source</h3>

<p>Scandinavian Bear Research Project. Skandinaviska
Bjornprojektet. Tackasen - Kareliusvag 2. 79498 Orsa, Sweden.
email: info@bearproject.info
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bear)
plot(bear)
</code></pre>

<hr>
<h2 id='buffalo'>
GPS monitoring of a buffalo
</h2><span id='topic+buffalo'></span>

<h3>Description</h3>

<p>This data set contains the relocations of an African buffalo (Syncerus
caffer) monitored in the W National Park (Niger) by D. Cornelis, as
well as the habitat map of the study area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(buffalo)</code></pre>


<h3>Format</h3>

<p>This dataset is a list containing an object of class <code>ltraj</code> and
a SpatialPixelsDataFrame.
</p>


<h3>Details</h3>

<p>The &quot;infolocs&quot; component of the ltraj stores the proportion of the
time duration between relocation i-1 and relocation i during which the
animal was active.
</p>


<h3>Source</h3>

<p>Cornelis D., Benhamou S., Janeau G., Morellet N., Ouedraogo M. &amp; de Vissher
M.-N. (submitted). The spatiotemporal segregation of limiting resources
shapes space use patterns of West African savanna buffalo. Journal of
Mammalogy.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(buffalo)
plot(buffalo$traj, spixdf=buffalo$habitat)

</code></pre>

<hr>
<h2 id='burst'>ID, Bursts and infolocs of an Object of Class ltraj</h2><span id='topic+burst'></span><span id='topic+id'></span><span id='topic+burst+3C-'></span><span id='topic+id+3C-'></span><span id='topic+removeinfo'></span><span id='topic+infolocs'></span><span id='topic+infolocs+3C-'></span>

<h3>Description</h3>

<p>Functions to get or set the attribute <code>"id"</code>, <code>"burst"</code>, and
<code>"infolocs"</code> of the components of an object of class
<code>ltraj</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>burst(ltraj)
burst(ltraj) &lt;- value
id(ltraj)
id(ltraj) &lt;- value
infolocs(ltraj, which)
infolocs(ltraj) &lt;- value
removeinfo(ltraj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="burst_+3A_ltraj">ltraj</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="burst_+3A_value">value</code></td>
<td>
<p>for the assignment functions <code>burst</code> and <code>id</code>,
a character vector of up to the same length as <code>ltraj</code>.  For
<code>infolocs</code> a list of data frames of the same length of
<code>ltraj</code> (with each component having the same number of rows as
the corresponding element in <code>ltraj</code>).</p>
</td></tr>
<tr><td><code id="burst_+3A_which">which</code></td>
<td>
<p>an optional character vector containing the names of the
variables in the <code>infolocs</code> attribute to be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>id</code>, <code>burst</code> and <code>infolocs</code> are
accessor functions, and <code>id&lt;-</code> and <code>burst&lt;-</code> are
replacement function.  <code>removeinfo</code> removes the attribute
<code>infolocs</code> from the object <code>ltraj</code> (see the help page of
<code>as.ltraj</code>).
</p>


<h3>Value</h3>

<p>For <code>id</code> and <code>burst</code>, a character vector of the same length
as <code>ltraj</code>.  For <code>infolocs</code>, the data frame containing the
information on the relocations.  <code>removeinfo</code> returns an object
of class <code>ltraj</code>.<br />
</p>
<p>For <code>id&lt;-</code> and <code>burst&lt;-</code>, the updated object.  (Note that
the value of <code>burst(x) &lt;- value</code> is that of the assignment,
<code>value</code>, not the return value from the left-hand side.)
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code>, <code><a href="base.html#topic+names">names</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(puechcirc)
puechcirc

## To see the ID and the burst
id(puechcirc)
burst(puechcirc)

## Change the burst
burst(puechcirc) &lt;- c("glou", "toto", "titi")
puechcirc

burst(puechcirc)[2] &lt;- "new name"
puechcirc

## Change the ID
id(puechcirc)[id(puechcirc)=="CH93"] &lt;- "WILD BOAR"
puechcirc

## example of an object with an attribute "infolocs"
data(capreochiz)
head(capreochiz)

## Create an object of class "ltraj"
cap &lt;- as.ltraj(xy = capreochiz[,c("x","y")], date = capreochiz$date,
                id = "Roe.Deer", typeII = TRUE,
                infolocs = capreochiz[,4:8])
cap
cap2 &lt;- removeinfo(cap)
cap2

infolocs(cap)



</code></pre>

<hr>
<h2 id='c.ltraj'>Combine Bursts of Relocations in Objects of Class &quot;ltraj&quot;</h2><span id='topic+c.ltraj'></span>

<h3>Description</h3>

<p>This function combines several objects of class <code>ltraj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ltraj'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.ltraj_+3A_...">...</code></td>
<td>
<p>objects of class <code>ltraj</code> to be combined</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ltraj</code>.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for further information on the class
<code>ltraj</code>, <code><a href="#topic+Extract.ltraj">Extract.ltraj</a></code> to extract or replace 
bursts of relocations, <code><a href="#topic+plot.ltraj">plot.ltraj</a></code> and
<code><a href="#topic+trajdyn">trajdyn</a></code> for graphical
displays, <code><a href="#topic+gdltraj">gdltraj</a></code> to specify a time period</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(puechcirc)

(i &lt;- puechcirc[1])
(j &lt;- puechcirc[3])

(toto &lt;- c(i,j))

</code></pre>

<hr>
<h2 id='capreochiz'>GPS Monitoring of one Roe Deer in Chize (France)</h2><span id='topic+capreochiz'></span>

<h3>Description</h3>

<p>This dataset contains the relocations of a roe deer collected using
GPS collars in the Chize reserve (Deux-Sevres, France) by the ONCFS 
(Office national de la chasse et de la faune sauvage).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(capreochiz)</code></pre>


<h3>Format</h3>

<p>This dataset is a data.frame containing the relocations and
metadata on these relocations (DOP, status, etc.).
</p>


<h3>Source</h3>

<p>Sonia Said, Office national de la chasse et de la faune sauvage,
CNERA-CS, 1 place Exelmans, 55000 Bar-le-Duc (France).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(capreochiz)

head(capreochiz)

</code></pre>

<hr>
<h2 id='capreotf'>GPS Monitoring of one Roe Deer in Trois-Fontaines (France)</h2><span id='topic+capreotf'></span>

<h3>Description</h3>

<p>This dataset contains the relocations of a roe deer collected from
May 1st to May 4th 2004 (every 5 minutes) using GPS collars in the
wildlife reserve of Trois-Fontaines (Haute Marne, France) by the ONCFS
(Office national de la chasse et de la faune sauvage).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(capreotf)</code></pre>


<h3>Format</h3>

<p>This dataset is a regular object of class <code>ltraj</code> (i.e. constant
time lag).
</p>


<h3>Source</h3>

<p>Sonia Said, Office national de la chasse et de la faune sauvage,
CNERA-CS, 1 place Exelmans, 55000 Bar-le-Duc (France).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(capreotf)

plot(capreotf)

</code></pre>

<hr>
<h2 id='Chi'>The Chi Distribution</h2><span id='topic+chi'></span><span id='topic+dchi'></span><span id='topic+pchi'></span><span id='topic+qchi'></span><span id='topic+rchi'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the chi distribution with <code>df</code> degrees of
freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dchi(x, df = 2)
pchi(q, df = 2, lower.tail = TRUE, ...)
qchi(p, df = 2, lower.tail = TRUE)
rchi(n, df = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Chi_+3A_x">x</code>, <code id="Chi_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Chi_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Chi_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="Chi_+3A_df">df</code></td>
<td>
<p>degrees of freedom (non-negative, but can be non-integer).</p>
</td></tr>
<tr><td><code id="Chi_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x],
otherwise, P[X &gt; x].</p>
</td></tr>
<tr><td><code id="Chi_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function
<code>integrate</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The chi distribution with <code>df</code> = n &gt; 0 degrees of freedom
has density
</p>
<p style="text-align: center;"><code class="reqn">f_n (x) = 2^{1-n/2} x^{n-1} e^{\frac{-(x^2)}{2}} / \Gamma (n/2)</code>
</p>

<p>for x &gt; 0.  This distribution is used to describe the square root of a
variable distributed according to a chi-square distribution.
</p>


<h3>Value</h3>

<p><code>dchi</code> gives the density, <code>pchi</code> gives the distribution
function, <code>qchi</code> gives the quantile function, and <code>rchi</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>References</h3>

<p>Evans, M., Hastings, N. and Peacock, B. (2000) Statistical
Distributions, 3rd ed. Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Chisquare">Chisquare</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
opar &lt;- par(mfrow = c(2,2))

hist(rchi(100), ncla = 20, main="The Chi distribution")

plot(tutu &lt;- seq(0, 5, length=20), dchi(tutu, df = 2), xlab = "x",
     ylab = "probability density", type = "l")

plot(tutu, pchi(tutu), xlab = "x", ylab = "Repartition function",
     type = "l")

par(opar)

</code></pre>

<hr>
<h2 id='cutltraj'>Split Trajectories into Several Bursts</h2><span id='topic+cutltraj'></span><span id='topic+bindltraj'></span>

<h3>Description</h3>

<p>The function <code>cutltraj</code> split the bursts in an object of class
<code>ltraj</code> into several &quot;sub-bursts&quot;, according to some specified
criterion.
</p>
<p>The function <code>bindltraj</code> binds the bursts an object of class
<code>ltraj</code> with the same attributes <code>"id"</code> into one unique
burst.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutltraj(ltraj, criterion, value.NA = FALSE, nextr = TRUE, ...)
bindltraj(ltraj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutltraj_+3A_ltraj">ltraj</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="cutltraj_+3A_criterion">criterion</code></td>
<td>
<p>a character string giving any syntactically correct R
logical expression implying the descriptive parameters in <code>x</code></p>
</td></tr>
<tr><td><code id="cutltraj_+3A_value.na">value.NA</code></td>
<td>
<p>logical.  The value that should be used to replace the
missing values.</p>
</td></tr>
<tr><td><code id="cutltraj_+3A_nextr">nextr</code></td>
<td>
<p>logical.  Whether the current &quot;sub-burst&quot; should stop
after (<code>nextr = TRUE</code>) or before (<code>nextr = FALSE</code>) the
first relocation matching <code>criterion</code></p>
</td></tr>
<tr><td><code id="cutltraj_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Splitting a trajectory may be of interest in many situations. For
example, if it is known that two kinds of activities of the monitored
animals correspond to different properties of, say, the distance
between successive relocations, it may be of interest to split the
trajectory according to the values of these distances.
</p>
<p>The criterion used to cut the trajectory may imply any of the
parameters describing a trajectory in the object <code>ltraj</code> (e.g.,
<code>"dt"</code>, <code>"dist"</code>, <code>"dx"</code>, etc. see the help page of
<code>as.ltraj</code>), as well as any variable stored in the attribute
<code>"infolocs"</code> of the object.
</p>
<p>Two options are available in <code>cutltraj</code>, depending on the value
of <code>nextr</code>. If <code>nextr = FALSE</code>, any sequence of
successive relocations that *do not* match the criterion is considered
as a new burst.  For example, if for a given burst, the criterion
returns the vector <code>(FALSE, FALSE, FALSE, TRUE, TRUE, TRUE,
    FALSE, FALSE, FALSE)</code>, then the function <code>cutltraj</code> creates
two new bursts of relocations, the first one containing the first 3
relocations and the second one the last 3 relocations.
</p>
<p>If <code>nextr = TRUE</code>, any sequence of successive relocations that
*do not* match the criterion, *as well as the first relocation that
does match it after this sequence* is considered as a new burst. 
This option is available because many of the descriptive parameters
associated to a given relocation in an object of class <code>ltraj</code>
measure some specific feature concerning the position of the next
relocation.  For example, one may want to consider as a burst any
sequence of relocations for which the time lag is below one hour (the
criterion is <code>"dt &gt; 3600"</code>.  The first relocation for which this
criterion is TRUE belong to the burst, and it is the next one which
is excluded from the burst.  For example, if for a given burst, the
criterion returns the vector <code>(FALSE, FALSE, FALSE, TRUE, TRUE,
    TRUE, FALSE, FALSE, FALSE)</code>, then the function <code>cutltraj</code>
creates two new bursts of relocations, the first one containing the
first 4 relocations and the second one the last 3 relocations.
</p>


<h3>Value</h3>

<p>An object of class <code>ltraj</code>.
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for additional information about objects
of class <code>ltraj</code> (and especially concerning the names of the
descriptive parameters that can be used in
<code>cutltraj</code>).  <code><a href="#topic+is.sd">is.sd</a></code> (especially the examples of this
help page) for other examples of use of this function</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#######################################################
##
## GPS monitoring of one bear

data(bear)

## We want to study the trajectory of the day at the scale
## of the day. We define one trajectory per day. The trajectory should begin
## at 22H00
## The following function returns TRUE if the date is comprised between
## 21H00 and 22H00 (i.e. correspond to the relocation taken at 21H30)

foo &lt;- function(date) {
     da &lt;- as.POSIXlt(date, "UTC")
     ho &lt;- da$hour + da$min/60
     return(ho&gt;21&amp;ho&lt;22)
}

## We cut the trajectory into bursts after the relocation taken at 21H30:

bea1 &lt;- cutltraj(bear, "foo(date)", nextr = TRUE)
bea1

## Remove the first and last burst:
bea2 &lt;- bea1[-c(1,length(bea1))]


#######################################################
##
## Bind the trajectories

bea3 &lt;- bindltraj(bea2)
bea3

## End(Not run)
</code></pre>

<hr>
<h2 id='Extract.ltraj'>Extract or Replace Parts of an Object of Class ltraj</h2><span id='topic+Extract.ltraj'></span><span id='topic++5B.ltraj'></span><span id='topic++5B+3C-.ltraj'></span>

<h3>Description</h3>

<p>Extract or replace subsets of objects of class <code>ltraj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ltraj'
x[i, id, burst]
  ## S3 replacement method for class 'ltraj'
x[i, id, burst] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.ltraj_+3A_x">x</code></td>
<td>
<p>an object of class <code>ltraj</code> </p>
</td></tr>
<tr><td><code id="Extract.ltraj_+3A_i">i</code></td>
<td>
<p>numeric.  The elements to extract or replace</p>
</td></tr>
<tr><td><code id="Extract.ltraj_+3A_id">id</code></td>
<td>
<p>a character vector indicating the identity of the animals to
extract or replace</p>
</td></tr>
<tr><td><code id="Extract.ltraj_+3A_burst">burst</code></td>
<td>
<p>a character vector indicating the identity of the bursts of
relocations to extract or replace</p>
</td></tr>
<tr><td><code id="Extract.ltraj_+3A_value">value</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>ltraj</code> contain several bursts of
relocations.  This function subsets or replaces these bursts, based
on their indices or on the attributes <code>id</code> *or* <code>burst</code>.<br />
</p>
<p>When replacement is done, it is required that <code>value</code> and
<code>x</code> have the same variables in attribute <code>infolocs</code> (i.e.,
both contain the same variables or both do not contain any variable,
see the help page of <code>as.ltraj</code>)
</p>


<h3>Value</h3>

<p>An object of class <code>ltraj</code>.
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ltraj">ltraj</a></code>, <code><a href="#topic+gdltraj">gdltraj</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(puechcirc)
  puechcirc

  ## Extract the second and third bursts
  (toto &lt;- puechcirc[2:3])

  ## Extracts all bursts collected on the animal JE
  puechcirc[id = "JE93"]

  
  ## Replace one burst
  toto[2] &lt;- puechcirc[1]
  toto
</code></pre>

<hr>
<h2 id='fpt'>Computation of the First Passage Time From Trajectories</h2><span id='topic+fpt'></span><span id='topic+plot.fipati'></span><span id='topic+varlogfpt'></span><span id='topic+meanfpt'></span>

<h3>Description</h3>

<p>These functions compute the first passage time using trajectories of
class <code>"ltraj"</code> of type II (time recorded).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpt(lt, radii, units = c("seconds", "hours", "days"))
varlogfpt(f, graph = TRUE)
meanfpt(f, graph = TRUE)
## S3 method for class 'fipati'
plot(x, scale, warn = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpt_+3A_lt">lt</code></td>
<td>
<p>an object of class <code>"ltraj"</code> of type II (time
recorded)</p>
</td></tr>
<tr><td><code id="fpt_+3A_radii">radii</code></td>
<td>
<p>a numeric vector giving the radii of the circles</p>
</td></tr>
<tr><td><code id="fpt_+3A_units">units</code></td>
<td>
<p>The time units of the results</p>
</td></tr>
<tr><td><code id="fpt_+3A_f">f</code>, <code id="fpt_+3A_x">x</code></td>
<td>
<p>an object of class <code>fipati</code> returned by the function
<code>fpt</code></p>
</td></tr>
<tr><td><code id="fpt_+3A_graph">graph</code></td>
<td>
<p>logical.  Whether the results should be plotted</p>
</td></tr>
<tr><td><code id="fpt_+3A_scale">scale</code></td>
<td>
<p>the value of the radius to be plotted</p>
</td></tr>
<tr><td><code id="fpt_+3A_warn">warn</code></td>
<td>
<p>logical. Whether the function should warn the user when
the given scale does not correspond to possible radii available in
the object of class <code>fipati</code></p>
</td></tr>
<tr><td><code id="fpt_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the generic function
<code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first passage time (FPT) is a parameter often used to describe the
scale at which patterns occur in a trajectory.  For a given scale r,
it is defined as the time required by the animals to pass through a
circle of radius r.  Johnson et al. (1992) indicated that the mean
first passage time scales proportionately to the square of the radius
of the circle for an uncorrelated random walk.  They used this
property to differenciate facilitated diffusion and impeded diffusion,
according to the value of the coefficient of the linear regression
<code>log(FPT) = a * log(radius) + b</code>. Under the hypothesis of a
random walk, <code>a</code> should be equal to 2 (higher for impeded
diffusion, and lower for facilitated diffusion).  Note however, that
the value of a converges to 2 only for large values of radius.
</p>
<p>Fauchald &amp; Tveraa (2003) proposed another use of the FPT.  Instead of
computing the mean of FPT, they propose the use of the variance of the
log(FPT).  This variance should be high for scales at which patterns
occur in the trajectory (e.g. area restricted search).  This method is
often used to determine the scale at which an animal seaches for food.
</p>


<h3>Value</h3>

<p><code>fpt</code> computes the FPT for each relocation and each radius, and
for each animals.  This function returns an object of class
<code>"fipati"</code>, i.e. a list with one component per animal.  Each
component is a data frame with each column corresponding to a value
of <code>radii</code> and each row corresponding to a relocation.  An object
of class <code>fipati</code> has an attribute named <code>"radii"</code>
corresponding to the argument <code>radii</code> of the function
<code>fpt</code>.
</p>
<p><code>meanfpt</code> and <code>varlogfpt</code> return a data frame giving
respectively the mean FPT and the variance of the log(FPT) for each
animal (rows) and rach radius (column).  These objects also have an
attribute <code>"radii"</code>.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>References</h3>

<p>Johnson, A. R., Milne, B.T., &amp; Wiens, J.A. (1992) Diffusion in
fractal landscapes: simulations and experimental studies of
tenebrionid beetle movements. <em>Ecology</em> <b>73</b>: 1968&ndash;1983.
</p>
<p>Fauchald, P. &amp; Tveraa, T. (2003) Using first passage time in the
analysis of area restricted search and habitat selection. <em>Ecology</em>
<b>84</b>: 282&ndash;288. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for additional information on objects of
class <code>ltraj</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(puechcirc)
i &lt;- fpt(puechcirc, seq(300,1000, length=30))
plot(i, scale = 500, warn = FALSE)

toto &lt;- meanfpt(i)
toto
attr(toto, "radii")


toto &lt;- varlogfpt(i)
toto
attr(toto, "radii")


</code></pre>

<hr>
<h2 id='gdltraj'>Working with Trajectories: Specify a Time Period</h2><span id='topic+gdltraj'></span>

<h3>Description</h3>

<p>Gets the parts of the trajectories stored in an object of class
<code>ltraj</code> of type II (time recorded), corresponding to a specified
time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdltraj(x, min, max, type = c("POSIXct", "sec", "min", "hour", "mday",
        "mon", "year", "wday", "yday")) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdltraj_+3A_x">x</code></td>
<td>
<p>an object of class <code>ltraj</code> of type II (time recorded)</p>
</td></tr>
<tr><td><code id="gdltraj_+3A_min">min</code></td>
<td>
<p>numeric.  The beginning of the period to consider</p>
</td></tr>
<tr><td><code id="gdltraj_+3A_max">max</code></td>
<td>
<p>numeric.  The end of the period to consider</p>
</td></tr>
<tr><td><code id="gdltraj_+3A_type">type</code></td>
<td>
<p>character.  The time units of <code>min</code> and
<code>max</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The limits of the period to consider may correspond to any of the
components of the list of class <code>POSIXlt</code> (hour, day, month,
etc.; see <code>help(POSIXlt)</code>), or to dates stored in objects of
class <code>POSIXct</code> (see examples).  The corresponding metadata in
the attribute <code>infolocs</code> are also returned.
</p>


<h3>Value</h3>

<p>an object of class <code>ltraj</code>.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for further information about objects of
class <code>ltraj</code>, <code><a href="base.html#topic+POSIXlt">POSIXlt</a></code> for further information
about objects of class <code>POSIXlt</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(puechcirc)
plot(puechcirc, perani = FALSE)

## Gets all the relocations collected
## between midnight and 3H AM 
toto &lt;- gdltraj(puechcirc, min = 0, max = 3, type="hour")
plot(toto, perani = FALSE)

## Gets all relocations collected between the 15th
## and the 25th august 1993
lim &lt;- as.POSIXct(strptime(c("15/08/1993", "25/08/1993"),
                  "%d/%m/%Y", tz="Europe/Paris"))
tutu &lt;- gdltraj(puechcirc, min = lim[1],
                max = lim[2], type="POSIXct")
plot(tutu, perani = FALSE)

</code></pre>

<hr>
<h2 id='hbrown'> Estimates the value of h for a Brownian motion </h2><span id='topic+hbrown'></span>

<h3>Description</h3>

<p><code>hbrown</code> estimates the scaling factor <code>h</code> (used in the
Brownian motion, see <code>help(simm.brown)</code>) from a trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbrown(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hbrown_+3A_x">x</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with one estimate per burst of the object of class
<code>ltraj</code>.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+simm.brown">simm.brown</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>toto &lt;- simm.brown(1:200, h=4)
hbrown(toto)

toto &lt;- simm.brown(1:200, h=20)
hbrown(toto)


</code></pre>

<hr>
<h2 id='hist.ltraj'>Histogram of the Descriptive Parameters of a Trajectory</h2><span id='topic+hist.ltraj'></span>

<h3>Description</h3>

<p>This function draws an histogram of any tranformation of the
descriptive parameters of a trajectory in objects of class
<code>ltraj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ltraj'
hist(x, which = "dx/sqrt(dt)", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.ltraj_+3A_x">x</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="hist.ltraj_+3A_which">which</code></td>
<td>
<p>a character string giving any syntactically correct R
expression implying the descriptive elements in <code>x</code>, or the
variables in the optional attribute <code>infolocs</code> .</p>
</td></tr>
<tr><td><code id="hist.ltraj_+3A_...">...</code></td>
<td>
<p>parameters to be passed to the generic function
<code>hist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of objects of class <code>"histogram"</code>  
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="#topic+ltraj">ltraj</a></code> for additional
information on the descriptive parameters of the trajectory,
<code><a href="#topic+qqnorm.ltraj">qqnorm.ltraj</a></code> for examination of distribution. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulation of a Brownian Motion
a &lt;- simm.brown(c(1:300, seq(301,6000,by=20)))
plot(a, addpoints = FALSE)


## dx/sqrt(dt) and dy/sqrt(dt) are normally distributed (see
## ?qqchi) 
hist(a, "dx/sqrt(dt)", freq = FALSE)
lines(tutu &lt;- seq(-5,5, length=50), dnorm(tutu), col="red")

hist(a, "dy/sqrt(dt)", freq = FALSE)
lines(tutu, dnorm(tutu), col="red")


## Look at the distribution of distances between
## successive relocations
hist(a, "dist/sqrt(dt)", freq = FALSE)
lines(tutu &lt;- seq(0,5, length=50), dchi(tutu), col="red")
</code></pre>

<hr>
<h2 id='hseal'>Argos Monitoring of Hooded Seal</h2><span id='topic+hseal'></span>

<h3>Description</h3>

<p>This data set contains the trajectory of one hooded seal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hseal)</code></pre>


<h3>Format</h3>

<p>The dataset <code>hseal</code> is an object of class <code>ltraj</code>.  The
coordinates are stored in meters (UTM - zone 21).
</p>


<h3>Source</h3>

<p>Jonsen, I.D., Flemming, J.M. and Myers, R.A. (2005). Robust state-space
modeling of animal movement data. <em>Ecology</em>, <b>86</b>, 2874&ndash;2880.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hseal)

plot(hseal)

</code></pre>

<hr>
<h2 id='ibex'>GPS Monitoring of Four Ibex in the Belledonne Mountain</h2><span id='topic+ibex'></span>

<h3>Description</h3>

<p>This dataset is an object of class &quot;ltraj&quot; (regular trajectory,
relocations every 4 hours) containing the GPS relocations of four ibex
during 15 days in the Belledonne mountain (French Alps).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ibex)</code></pre>


<h3>Source</h3>

<p>Office national de la chasse et de la faune sauvage, CNERA Faune de
Montagne, 95 rue Pierre Flourens, 34000 Montpellier, France.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ibex)
plot(ibex)
</code></pre>

<hr>
<h2 id='ibexraw'>GPS Monitoring of Four Ibex in the Belledonne Mountain (irregular
data)</h2><span id='topic+ibexraw'></span>

<h3>Description</h3>

<p>This dataset is an object of class &quot;ltraj&quot; (irregular trajectory,
relocations roughly every 4 hours) containing the raw GPS relocations
of four ibex during 15 days in the Belledonne mountain (French Alps).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ibexraw)</code></pre>


<h3>Details</h3>

<p>This dataset is nearly the same as the dataset <code>ibex</code>, except
that the timing of relocations has not been rounded and the missing
values have not been placed in the trajectory.
</p>


<h3>Source</h3>

<p>Office national de la chasse et de la faune sauvage, CNERA Faune
de Montagne, 95 rue Pierre Flourens, 34000 Montpellier, France.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ibexraw)
plot(ibexraw)
</code></pre>

<hr>
<h2 id='indmove'>Testing Independence in Regular Trajectory Parameters</h2><span id='topic+indmove'></span><span id='topic+indmove.detail'></span><span id='topic+testang.ltraj'></span><span id='topic+testdist.ltraj'></span>

<h3>Description</h3>

<p>The function <code>indmove</code> tests for the independence between
successive components <code>c(dx, dy)</code> for each burst in a regular
object of class <code>ltraj</code>.
</p>
<p>The function <code>indmove.detail</code> tests for the independence between
successive <code>dx</code> or <code>dy</code> for each burst in a regular object 
of class <code>ltraj</code>.
</p>
<p>The function <code>testang.ltraj</code> tests for the independence between
successive angles (relative or absolute) for each burst in a regular
object of class <code>ltraj</code>.
</p>
<p>The function <code>testdist.ltraj</code> tests for the independence between
successive distances between successive relocations for each burst in
a regular object of class <code>ltraj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indmove(ltr, nrep = 200, conflim = seq(0.95, 0.5, length=5),
        sep = ltr[[1]]$dt[1], units = c("seconds", "minutes",
                                        "hours", "days"),
        plotit = TRUE)


testang.ltraj(x, which = c("absolute", "relative"),
              nrep = 999, alter = c("two-sided","less","greater"))


testdist.ltraj(x, nrep = 999, alter = c("two-sided","less","greater"))


indmove.detail(x, detail=c("dx","dy"), nrep=999,
               alter = c("two-sided","less","greater"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indmove_+3A_ltr">ltr</code>, <code id="indmove_+3A_x">x</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="indmove_+3A_conflim">conflim</code></td>
<td>
<p>a vector giving the limits of the confidence intervals
to be plotted</p>
</td></tr>
<tr><td><code id="indmove_+3A_nrep">nrep</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="indmove_+3A_units">units</code></td>
<td>
<p>a character string indicating the time units for the result</p>
</td></tr>
<tr><td><code id="indmove_+3A_alter">alter</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of &quot;greater&quot;, &quot;less&quot; or &quot;two-sided&quot; (default)</p>
</td></tr>
<tr><td><code id="indmove_+3A_which">which</code></td>
<td>
<p>a character string indicating whether the absolute or
relative angles are under focus</p>
</td></tr>
<tr><td><code id="indmove_+3A_detail">detail</code></td>
<td>
<p>a character string indicating whether <code>"dx"</code> or
<code>"dy"</code> should be tested for independence</p>
</td></tr>
<tr><td><code id="indmove_+3A_plotit">plotit</code></td>
<td>
<p>logical.  Whether the results should be plotted on a graph</p>
</td></tr>
<tr><td><code id="indmove_+3A_sep">sep</code></td>
<td>
<p>used in the case of variable time lag between
relocations.  Indicates the theoretical time lag between two relocations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>indmove</code> randomises the order of the increments
<code>c(dx, dy)</code> in a trajectory.  The criteria of the test is the
Mean Squared Displacement (<code>R^2_n</code>) (Root &amp; Kareiva 1984).
</p>
<p>The function <code>testang.ltraj</code> randomises the order of the angles in a
trajectory.  The criteria of the test is <code>f^2 = sum_(i=1)^(n-1) 2*(1 -
    cos(angle[i+1] - angle[i]))</code>.  This measure corresponds to the
mean squared length of the segment joining two successive angles on
the trigonometric circle (see examples for an illustration).
</p>
<p>The function <code>testdist.ltraj</code> randomises the order of the
distances between successive relocations in a trajectory.  The
criteria of the test is <code>sum_(i=1)^(n-1) (dist[i+1] -
    dist[i])^2 </code> (Neuman 1941, Neuman et al. 1941).  The same criteria is
used in <code>indmove.detail()</code>.
</p>
<p>Note that these functions require &quot;regular&quot; trajectories,
i.e. trajectories for which the relocations are separated by a
constant time lag.
</p>
<p>Finally, note that the functions <code>testang.ltraj</code> and
<code>testdist.ltraj</code> are not affected by the presence of missing
values in the bursts of relocations. The function <code>indmove</code> may
be greatly affected by these missing values (they are removed prior to
the test).
</p>


<h3>Value</h3>

<p><code>indmove()</code> returns a list with one component per burst.  Each
component is a list of two data frames. The data frame <code>Time</code>
contains the time points at which R2n is computed for the
observation (first column) and the simulations (other ones).  The data
frame <code>R2n</code> contains the values for the R2n (same dimensions).
</p>
<p><code>testang.ltraj()</code>, <code>testdist.ltraj</code> and
<code>indmove.detail</code> return lists of
objects of class <code>randtest</code>.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a><br />
Stephane Dray <a href="mailto:dray@biomserv.univ-lyon1.fr">dray@biomserv.univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Root, R.B. &amp; Kareiva, P.M. (1984) The search for resources by
cabbage butterflies (Pieris Rapae): Ecological consequences and
adaptive significance of markovian movements in a patchy
environment. <em>Ecology</em>, <b>65</b>: 147&ndash;165.
</p>
<p>Neumann, J.V., Kent, R.H., Bellinson, H.R. &amp; Hart, B.I. (1941) The mean
square successive difference. <em>Annals of Mathematical
Statistics</em>, <b>12</b>: 153&ndash;162.
</p>
<p>Neumann, J.V. (1941) Distribution of the ration of the mean square
successive difference to the variance. <em>The Annals of
Mathematical Statistics</em>, <b>12</b>: 367&ndash;395.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## theoretical independence between
br &lt;- simm.brown(1:1000)
testang.ltraj(br)
testdist.ltraj(br)

indmove(br)

## End(Not run)

## Illustration of the statistic used for the test of the independence
## of the angles
opar &lt;- par(mar = c(0,0,4,0))
plot(0,0, asp=1, xlim=c(-1, 1), ylim=c(-1, 1), ty="n", axes=FALSE,
main="Criteria f for the measure of independence between successive
angles at time i-1 and i") 
box()
symbols(0,0,circle=1, inches=FALSE, lwd=2, add=TRUE)
abline(h=0, v=0)
x &lt;- c( cos(pi/3), cos(pi/2 + pi/4))
y &lt;- c( sin(pi/3), sin(pi/2 + pi/4))
arrows(c(0,0), c(0,0), x, y)
lines(x,y, lwd=2, col="red")
text(0, 0.9, expression(f^2 == 2*sum((1 - cos(alpha[i]-alpha[i-1])),
i==1, n-1)), col="red")
foo &lt;- function(t, alpha)
{
  xa &lt;- sapply(seq(0, alpha, length=20), function(x) t*cos(x))
  ya &lt;- sapply(seq(0, alpha, length=20), function(x) t*sin(x))
  lines(xa, ya)
}
foo(0.3, pi/3)
foo(0.1, pi/2 + pi/4)
foo(0.11, pi/2 + pi/4)
text(0.34,0.18,expression(alpha[i]), cex=1.5)
text(0.15,0.11,expression(alpha[i-1]), cex=1.5)
par(opar)
</code></pre>

<hr>
<h2 id='is.regular'>Regular Trajectories</h2><span id='topic+is.regular'></span>

<h3>Description</h3>

<p><code>is.regular</code> tests whether a trajectory is regular (i.e. constant
time lag between successive relocations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.regular(ltraj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.regular_+3A_ltraj">ltraj</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.regular</code> returns a logical value
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(capreotf)
is.regular(capreotf)
plotltr(capreotf, "dt")

data(albatross)
is.regular(albatross)
plotltr(albatross, "dt")
</code></pre>

<hr>
<h2 id='is.sd'>Handling of Trajectories of the Same Duration</h2><span id='topic+is.sd'></span><span id='topic+sd2df'></span>

<h3>Description</h3>

<p><code>is.sd</code> tests whether the bursts of relocations in an object of
class <code>ltraj</code> contain the same number of relocations, and cover
the same duration (&quot;sd&quot; = &quot;same duration&quot;).<br />
<code>sd2df</code> gets one of the descriptive parameters of a regular &quot;sd&quot;
trajectory (e.g. <code>"dt"</code>, <code>"dist"</code>, etc.) and returns a data
frame with one relocation per row, and one burst per column. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.sd(ltraj)
sd2df(ltraj, what)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.sd_+3A_ltraj">ltraj</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="is.sd_+3A_what">what</code></td>
<td>
<p>a character string indicating the descriptive parameter of
the trajectory to be exported</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.sd</code> returns a logical value.<br />
<code>sd2df</code> returns a data frame with one column per burst of
relocations, and one row per relocation.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+set.limits">set.limits</a></code> for additional information about
&quot;sd&quot; regular trajectories </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Takes the example from the help page of cutltraj (bear):
data(bear)

## We want to study the trajectory of the animal at the scale
## of the day. We define one trajectory per day. The trajectory should begin
## at 22H00.
## The following function returns TRUE if the date is comprised between
## 21H00 and 22H00 and FALSE otherwise (i.e. correspond to the
## relocation taken at 21H30)

foo &lt;- function(date) {
     da &lt;- as.POSIXlt(date, "UTC")
     ho &lt;- da$hour + da$min/60
     return(ho&gt;21.1&amp;ho&lt;21.9)
}

## We cut the trajectory into bursts after the relocation taken at 21H30:

bea1 &lt;- cutltraj(bear, "foo(date)", nextr = TRUE)
bea1

## Remove the first and last burst:
bea2 &lt;- bea1[-c(1,length(bea1))]

## Is the resulting object "sd" ?
is.sd(bea2)

## Converts to data frame:
df &lt;- sd2df(bea2, "dist")

## Plots the average distance per hour
meandi &lt;- apply(df[-nrow(df),], 1, mean, na.rm = TRUE)
sedi &lt;- apply(df[-nrow(df),], 1, sd, na.rm = TRUE) / sqrt(ncol(df))
plot(seq(0, 23.5, length = 47),
     meandi,
     ty = "b", pch = 16, xlab = "Hours (time 0 = 22H00)",
     ylab="Average distance covered by the bear in 30 mins",
     ylim=c(0, 500))
lines(seq(0, 23.5, length = 47),
      meandi+sedi, col="grey")
lines(seq(0, 23.5, length = 47),
      meandi-sedi, col="grey")



## End(Not run)
</code></pre>

<hr>
<h2 id='lavielle'>Segmentation of a time series using the method of Lavielle (1999,
2005)</h2><span id='topic+lavielle'></span><span id='topic+lavielle.default'></span><span id='topic+lavielle.ltraj'></span><span id='topic+print.lavielle'></span><span id='topic+chooseseg'></span><span id='topic+findpath'></span>

<h3>Description</h3>

<p>These functions allow to perform a non-parametric segmentation of a
time series using the penalized contrast method of Lavielle (1999,
2005). The function <code>lavielle</code> computes the contrast matrix
(i.e., the matrix used to segment the series) either from a series of
observations or from an animal trajectory.  The function
<code>chooseseg</code> can be used to estimate the number of segments
building up the trajectory.  The function <code>findpath</code> can be used
to find the limits of the segments (see Details). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavielle(x, ...)

## Default S3 method:
lavielle(x, Lmin, Kmax, ld = 1,
                           type = c("mean", "var", "meanvar"), ...) 

## S3 method for class 'ltraj'
lavielle(x, Lmin, Kmax, ld = 1, which = "dist",
                         type = c("mean", "var", "meanvar"), ...) 

## S3 method for class 'lavielle'
print(x, ...)

chooseseg(lav, S = 0.75, output = c("full","opt"),
          draw = TRUE)

findpath(lav, K, plotit = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lavielle_+3A_x">x</code></td>
<td>
<p>for <code>lavielle.default</code>, a vector containing the
successive observations building up the series.  For
<code>lavielle.ltraj</code>, an object of class <code>ltraj</code>.</p>
</td></tr>
<tr><td><code id="lavielle_+3A_lmin">Lmin</code></td>
<td>
<p>an integer value indicating the minimum number of
observations in each segment.  Should be a multiple of <code>ld</code>.</p>
</td></tr>
<tr><td><code id="lavielle_+3A_kmax">Kmax</code></td>
<td>
<p>an integer value indicating the maximum number of segments
expected in the series</p>
</td></tr>
<tr><td><code id="lavielle_+3A_ld">ld</code></td>
<td>
<p>an integer value indicating the resolution for the
calculation of the contrast function.  The contrast function will be
evaluated for segments containing the observations <code>c(1:ld)</code>,
<code>c(1:(2*ld))</code>, <code>c(1:(3*ld))</code>, and all segments will
necessarily contain a multiple of <code>ld</code> observations.  Note that
<code>ld</code> should be set to values greater than 1 if memory problem
occur</p>
</td></tr>
<tr><td><code id="lavielle_+3A_type">type</code></td>
<td>
<p>the type of contrast function to be used to segment the
series (see Details)</p>
</td></tr>
<tr><td><code id="lavielle_+3A_which">which</code></td>
<td>
<p>a character string giving any syntactically correct R
expression implying the descriptive elements in <code>x</code> or the
variables in the optional attribute <code>infolocs</code>.</p>
</td></tr>
<tr><td><code id="lavielle_+3A_lav">lav</code></td>
<td>
<p>an object of class <code>"lavielle"</code></p>
</td></tr>
<tr><td><code id="lavielle_+3A_s">S</code></td>
<td>
<p>a value indicating the threshold in the second derivative of
the contrast function</p>
</td></tr>
<tr><td><code id="lavielle_+3A_output">output</code></td>
<td>
<p>type of output expected (see the section value)</p>
</td></tr>
<tr><td><code id="lavielle_+3A_draw">draw</code></td>
<td>
<p>a logical value indicating whether the decrease in the
contrast function should be plotted</p>
</td></tr>
<tr><td><code id="lavielle_+3A_k">K</code></td>
<td>
<p>The number of segments</p>
</td></tr>
<tr><td><code id="lavielle_+3A_plotit">plotit</code></td>
<td>
<p>a logical value indicating whether the segmentation should
be plotted</p>
</td></tr>
<tr><td><code id="lavielle_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed from or to other
functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method of Lavielle (1999, 2005) per se finds the best segmentation
of a time series, given that it is built by <code>K</code> segments.  It
searches the segmentation for which a contrast function (measuring the
contrast between the actual series and the segmented series) is
minimized.  Different contrast functions are available measuring
different aspects of the variation of the series from one segment to
the next: when <code>type = "mean"</code>, we suppose that only
the mean of the segments varies between segments; when <code>type =
    "var"</code>, we suppose that only the variance of the segments varies
between segments; when <code>type = "meanvar"</code>, we suppose that both
the mean and the variance varies between segments.  It is required to
specify a value for the minimum number of observations <code>Lmin</code> in
a segment, as well as the maximum number of segments <code>Kmax</code> in
the series.
</p>
<p>There are several approaches to estimate the best number of segments
<code>K</code> to partition the time series.  One possible approach is
the graphical examination of the decrease of the contrast function
with the number of segments.  In theory, there should be a clear
&quot;break&quot; in the decrease of this function after the optimal value of
<code>K</code>.  Lavielle (2005) suggested an alternative way to estimate
automatically the optimal number of segments, also relying on the
presence of a &quot;break&quot; in the decrease of the contrast function.  He
proposed to choose the last value of <code>K</code> for which the second
derivative of a standardized constrast function is greater than a
threshold <code>S</code> (see Lavielle, 2005 for details).  Based on
numerical experiments, he proposed to choose the value <code>S =
  0.75</code>. Note, however, that for short time series (i.e. less than 500
observations) some simulations indicated that this value may not be
optimal and may depend on the value of <code>Kmax</code>, so that the
graphical method is maybe more appropriate.
</p>


<h3>Value</h3>

<p>The function <code>lavielle.default</code> returns a list of class
<code>lavielle</code>, with an attribute <code>"typeseg"</code> set to
<code>"default"</code>. This list contains the following elements:
</p>
<table>
<tr><td><code>contmat</code></td>
<td>
<p>The contrast matrix</p>
</td></tr>
<tr><td><code>sumcont</code></td>
<td>
<p>The optimal contrast</p>
</td></tr>
<tr><td><code>matpath</code></td>
<td>
<p>The matrix of the paths from the first to the last
observation</p>
</td></tr>
<tr><td><code>Kmax</code></td>
<td>
<p>The maximum number of segments</p>
</td></tr>
<tr><td><code>Lmin</code></td>
<td>
<p>The minimum number of observations in a segment</p>
</td></tr>
<tr><td><code>ld</code></td>
<td>
<p>the value of the resolution <code>ld</code></p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>The time series</p>
</td></tr>
</table>
<p>The function <code>lavielle.ltraj</code> also returns a list of class
<code>lavielle</code>, with an attribute <code>"typeseg"</code> set to
<code>"ltraj"</code>. 
</p>
<p>The function <code>chooseseg</code> returns the optimal number of segments
when <code>output = "opt"</code>, and a dataframe containing the value of
the contrast function <code>Jk</code> and of the second derivative <code>D</code>
of the standardized contrast function for each possible value of
<code>K</code>, if <code>output = "full"</code>.
</p>
<p>The function <code>findpath</code> return a list containing vectors giving
the index of the first and last observations in each segment, when the
object of class <code>"lavielle"</code> passed as argument is characterized
by an attribute <code>"typeseg"</code> set to <code>"default"</code>.  When the
attribute <code>"typeseg"</code> is set to <code>"ltraj"</code>, this function
returns an object of class ltraj where each burst correspond to a
segment. 
</p>


<h3>Note</h3>

<p>The contrast matrix is a matrix of size <code>n*n</code> (with <code>n</code> the
number of observations in the series).  If <code>n</code> is large, memory
problems may occur.  In this case, setting <code>ld</code> to a value
greater than one will allow to reduce the size of this matrix (i.e. it
will be of size <code>k*k</code>, where <code>k = floor(n/ld)</code>).  However,
this will also reduce the resolution of the segmentation, so that the
segment limits will be less precisely estimated.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a>.  The code
is a C translation based on the Matlab code of M. Lavielle</p>


<h3>References</h3>

<p>Lavielle, M. (1999) Detection of multiple changes in a sequence of
dependent variables. <em>Stochastic Processes and their
Applications</em>, <b>83</b>: 79&ndash;102.
</p>
<p>Lavielle, M. (2005) Using penalized contrasts for the change-point
problem. Report number 5339, Institut national de recherche en
informatique et en automatique.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#################################################
##
## A simulated series

suppressWarnings(RNGversion("3.5.0"))
set.seed(129)
seri &lt;- c(rnorm(100), rnorm(100, mean=2),
          rnorm(100), rnorm(100, mean=-3),
          rnorm(100), rnorm(100, mean=2))
plot(seri, ty="l", xlab="time", ylab="Series")

## Segmentation:
(l &lt;- lavielle(seri, Lmin=10, Kmax=20))

## choose the number of segments
chooseseg(l)

## There is a clear break in the
## decrease of the contrast function after K = 6
## Moreover, Jk(6) &gt;&gt; 0.75 and Jk(7) &lt;&lt; 0.75
## We choose 6 segments:
fp &lt;- findpath(l, 6)
fp

## This list gives the limits of the segments
## for example, to get the first segment:
seg &lt;- 1
firstseg &lt;- seri[fp[[seg]][1]:fp[[seg]][2]]

####################################################
##
## Now, changes of variance

## A simulated series
suppressWarnings(RNGversion("3.5.0"))
set.seed(129)
seri &lt;- c(rnorm(100), rnorm(100, sd=2),
          rnorm(100), rnorm(100, sd=3),
          rnorm(100), rnorm(100, sd=2))
plot(seri, ty="l", xlab="time", ylab="Series")

## Segmentation:
(l &lt;- lavielle(seri, Lmin=10, Kmax=20, type="var"))

## choose the number of segments
chooseseg(l)

## There is a clear break in the
## decrease of the contrast function after K = 6
## Moreover, Jk(6) &gt;&gt; 0.75 and Jk(7) &lt;&lt; 0.75
## We choose 6 segments:
fp &lt;- findpath(l, 6)
fp

## This list gives the limits of the segments
## for example, to get the first segment:
seg &lt;- 1
firstseg &lt;- seri[fp[[seg]][1]:fp[[seg]][1]]

#################################################
##
## Example of segmentation of a trajectory

## Show the trajectory
data(porpoise)
gus &lt;- porpoise[1]
plot(gus)

## Show the changes in the distance between
## successive relocations with the time
plotltr(gus, "dist")

## Segmentation of the trajectory based on these distances
lav &lt;- lavielle(gus, Lmin=2, Kmax=20)

## Choose the number of segments
chooseseg(lav)
## 4 segments seem a good choice

## Show the partition
kk &lt;- findpath(lav, 4)
plot(kk)

</code></pre>

<hr>
<h2 id='ld'>
Quick Conversion of Objects of Class ltraj from and to Dataframes
</h2><span id='topic+ld'></span><span id='topic+dl'></span>

<h3>Description</h3>

<p>The two functions <code>ld</code> and <code>dl</code> are useful to quickly
convert objects of class ltraj from and to dataframes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ld(ltraj)
dl(x, proj4string=CRS())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ld_+3A_ltraj">ltraj</code></td>
<td>

<p>an object of class <code>ltraj</code>
</p>
</td></tr>
<tr><td><code id="ld_+3A_x">x</code></td>
<td>

<p>an object of class <code>data.frame</code>, containing at least columns
named <code>x,y,date</code>.
</p>
</td></tr>
<tr><td><code id="ld_+3A_proj4string">proj4string</code></td>
<td>

<p>a valid CRS object containing the projection information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>ld</code> concatenates all bursts in an object of class
<code>ltraj</code>, adds two columns named <code>id</code> and <code>burst</code>, and,
when it is present, also adds the variables in the <code>infolocs</code>
component.
</p>
<p>The function <code>dl</code> creates an object of class <code>ltraj</code> from a
<code>data.frame</code>.  If no column named <code>id</code> exists, a random ID
is generated.  If no column named <code>burst</code> exists, the ID is used
as burst.  The columns named &quot;dx&quot;, &quot;dy&quot;, &quot;dist&quot;, &quot;dt&quot;, &quot;R2n&quot;,
&quot;abs.angle&quot; and &quot;rel.angle&quot; are recomputed by the function (see
<code>?as.ltraj</code>).  Additional columns are used as the <code>infolocs</code>
component.
</p>


<h3>Value</h3>

<p><code>ld</code> returns an object of class <code>data.frame</code>.<br /> 
<code>dl</code> returns an object of class <code>ltraj</code>. 
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.ltraj">as.ltraj</a></code> for additional information about objects of
class <code>ltraj</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(puechcirc)
 puechcirc ## class ltraj
 uu &lt;- ld(puechcirc)
 head(uu)
 dl(uu)
</code></pre>

<hr>
<h2 id='ltraj2spdf'> Conversion of the class &quot;ltraj&quot; to the package &quot;sp&quot; </h2><span id='topic+ltraj2spdf'></span><span id='topic+ltraj2sldf'></span>

<h3>Description</h3>

<p>These functions convert the class &quot;ltraj&quot; available in adehabitatLT toward
classes available in the package <code>sp</code>.
</p>
<p><code>ltraj2spdf</code> converts an object of class <code>ltraj</code> into an
object of class <code>SpatialPointsDataFrame</code>.
</p>
<p><code>ltraj2sldf</code> converts an object of class <code>ltraj</code> into an
object of class <code>SpatialLinesDataFrame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltraj2spdf(ltr)
ltraj2sldf(ltr, byid = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltraj2spdf_+3A_ltr">ltr</code></td>
<td>
<p>an object of class <code>ltraj</code>.</p>
</td></tr>
<tr><td><code id="ltraj2spdf_+3A_byid">byid</code></td>
<td>
<p>logical.  If <code>TRUE</code>, one objects of class
<code>Lines</code> correspond to one animal.  if <code>FALSE</code>,
one object of class <code>Lines</code> correspond to one burst.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+ltraj">ltraj</a></code> for objects of class
<code>ltraj</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(sp)) {



#########################################
##
## Conversion ltraj -&gt; SpatialPointsDataFrame
##

data(puechcirc)
plot(puechcirc)

toto &lt;- ltraj2spdf(puechcirc)
plot(toto)



#########################################
##
## Conversion ltraj -&gt; SpatialLinesDataFrame
##

toto &lt;- ltraj2sldf(puechcirc)
plot(toto)


}

## End(Not run)
</code></pre>

<hr>
<h2 id='mindistkeep'>Detecting Absence of Movement in an Object of Class 'ltraj'</h2><span id='topic+mindistkeep'></span>

<h3>Description</h3>

<p>Objects of class <code>ltraj</code> are often created with data collected
using some form of telemetry (radio-tracking, G.P.S., etc.).  However,
the relocations of the monitored animals are always somewhat
imprecise.  The function mindistkeep considers that when
the distance between two successive relocations is lower than a given
threshold distance, the animal actually does not move (and replaces
the coordinates of relocation i+1 by the coordinates of relocation
i).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mindistkeep(x, threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mindistkeep_+3A_x">x</code></td>
<td>
<p>An object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="mindistkeep_+3A_threshold">threshold</code></td>
<td>
<p>The minimum distance under which is is considered
that the animal does not move</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ltraj</code>
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(puechcirc)
plot(puechcirc)

i &lt;- mindistkeep(puechcirc, 10)
plot(i)

</code></pre>

<hr>
<h2 id='modpartltraj'>Segmentation of a trajectory based on Markov models</h2><span id='topic+modpartltraj'></span><span id='topic+print.modpartltraj'></span><span id='topic+partmod.ltraj'></span><span id='topic+print.partltraj'></span><span id='topic+bestpartmod'></span><span id='topic+plot.partltraj'></span>

<h3>Description</h3>

<p>These functions partition a trajectory into several segments
corresponding to different behaviours of the animal.
</p>
<p><code>modpartltraj</code> is used to generate the models to which the trajectory
is compared.
</p>
<p><code>bestpartmod</code> is used to compute the optimal number of segments
of the partition.
</p>
<p><code>partmod.ltraj</code> is used to partition the trajectory into
<code>npart</code> segments.  <code>plot.partltraj</code> can be used to plot the
results. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modpartltraj(tr, limod)
## S3 method for class 'modpartltraj'
print(x, ...)

bestpartmod(mods, Km = 30, plotit = TRUE,
            correction = TRUE, nrep = 100)

partmod.ltraj(tr, npart, mods, na.manage = c("prop.move","locf"))
## S3 method for class 'partltraj'
print(x, ...)
## S3 method for class 'partltraj'
plot(x, col, addpoints = TRUE, lwd = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modpartltraj_+3A_tr">tr</code></td>
<td>
<p>an object of class <code>ltraj</code> containing only one trajectory
(one burst of relocation)</p>
</td></tr>
<tr><td><code id="modpartltraj_+3A_limod">limod</code></td>
<td>
<p>a list of syntactically correct R expression giving the
models for the trajectory, implying one or several elements in
<code>tr</code> (see details and examples)</p>
</td></tr>
<tr><td><code id="modpartltraj_+3A_x">x</code>, <code id="modpartltraj_+3A_mods">mods</code></td>
<td>
<p>an object of class <code>modpartltraj</code> (for
<code>print.modpartltraj</code>), <code>partltraj</code> (for
<code>print.partltraj</code> and <code>plot.partltraj</code>) returned
respectively by the function <code>genmod.crw</code> and
<code>partmod.ltraj</code></p>
</td></tr>
<tr><td><code id="modpartltraj_+3A_na.manage">na.manage</code></td>
<td>
<p>a character string indicating what should be done
with the missing values located between two segments.  With
<code>"locf"</code>, the missing values are added at the end of the first
segment. With <code>"prop.move"</code>, the missing values are distributed
at the end of the first and the beginning of the second segment.  The
proportion of missing values added at the end of the first segment
correspond the relative proportion of &quot;internal&quot; missing values
found within the segments predicted by the model used to predict the
first segment.</p>
</td></tr>
<tr><td><code id="modpartltraj_+3A_npart">npart</code></td>
<td>
<p>the number of partitions of the trajectory</p>
</td></tr>
<tr><td><code id="modpartltraj_+3A_km">Km</code></td>
<td>
<p>the maximum number of partitions of the trajectory</p>
</td></tr>
<tr><td><code id="modpartltraj_+3A_plotit">plotit</code></td>
<td>
<p>logical. Whether the results should be plotted.</p>
</td></tr>
<tr><td><code id="modpartltraj_+3A_correction">correction</code></td>
<td>
<p>logical. Whether the log-likelihood should be
corrected (see details).</p>
</td></tr>
<tr><td><code id="modpartltraj_+3A_nrep">nrep</code></td>
<td>
<p>logical. The number of Monte Carlo simulations used to
correct the log-likelihood for each number of segments.</p>
</td></tr>
<tr><td><code id="modpartltraj_+3A_col">col</code></td>
<td>
<p>the colors to be used for the models</p>
</td></tr>
<tr><td><code id="modpartltraj_+3A_addpoints">addpoints</code></td>
<td>
<p>logical.  Whether the relocations should be added to
the graph</p>
</td></tr>
<tr><td><code id="modpartltraj_+3A_lwd">lwd</code></td>
<td>
<p>the line width</p>
</td></tr>
<tr><td><code id="modpartltraj_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A trajectory is made of successive steps traveled by an organism in the
geographical space.  These steps (the line connecting two successive
relocations) can be described by a certain number of descriptive
parameters (relative angles between successive steps, length of the
step, etc.).  One aim of the trajectory analysis is to identify 
the structure of the trajectory, i.e.  the parts of the trajectory where the
steps have homogeneous properties. Indeed, an animal may have a wide
variety of behaviours (feeding, traveling, escape from a predator,
etc.). As a result, partitioning a trajectory occupies a central place in
trajectory analysis.
</p>
<p>These functions are to be used to partition a trajectory based on Markov
models of animal movements.  For example, one may suppose that a
normal distribution generated the step lengths, with a different mean
for each type of behaviour.  These models and the value of their
parameters are supposed a priori by the analyst.  These functions
allow, based on these a priori models, to find both the number and the
limits of the segments building up the trajectory (see examples).  Any
model can be supposed for any parameter of the steps (the distance,
relative angles, etc.), provided that the model is Markovian.
</p>
<p>The rationale behind this algorithm is the following.  First, the user
should propose a set of model describing the movements of the animals,
in the different segments of the trajectory.  For example, the user may
define two models of normal distribution for the step length, with
means equal to 10 meters (i.e. a trajectory with relatively small steps)
and 100 meters (i.e. a trajectory with longer step lengths).  For a
given step of the trajectory, it is possible to compute the probability
density that the step has been generated by each model of the set.
The function <code>modpartltraj</code> computes the matrix containing the
probability densities associated to each step (rows), under each model
of the set (columns).  This matrix is of class <code>modpartltraj</code>.
</p>
<p>Then, the user can estimate the optimal number of segments in the
trajectory, given the set of a priori models, using the function
<code>bestpartmod</code>, taking as argument the matrix of class
<code>modpartltraj</code>.  If <code>correction = FALSE</code>, this function
returns the log of the probability (log-likelihood) that the trajectory
is actually made of <code>K</code> segments, with each one described by one
model.  The resulting graph can be used to choose an optimal number of
segment for the partition.  Note that Gueguen (2009) noted that this
algorithm tends to overestimate the number of segments in a
trajectory. He proposed to correct this estimation using Monte Carlo
simulations of the independence of the steps within the trajectory.  At
each step of the randomization process, the order of the rows of the
matrix is randomized, and the curve of log-likelihood is computed for
each number of segments, for the randomized trajectory.  Then, the
observed log-likelihood is corrected by these simulations: for a given
number of segments, the corrected log-likelihood is equal to the
observed log-likelihood minus the simulated log-likelihood.  Because
there is a large number of simulations of the independence, a
distribution of corrected log-likelihoods is available for each number
of segments.  The &quot;best&quot; number of segments is the one for which the
median of the distribution of corrected log-likelihood is maximum.
</p>
<p>Finally, once the optimal number of segments <code>npart</code> has been
chosen, the function <code>partmod.ltraj</code> can be used to compute the
partition.
</p>
<p>The mathematical rationale underlying these two functions is the
following: given an optimal k-partition of the trajectory, if the ith
step of the trajectory belongs to the segment k predicted by the model d,
then either the relocation (i-1) belongs to the same segment, in which
case the segment containing (i-1) is predicted by d, or the relocation
(i-1) belongs to another segment, and the other (k-1) segments
together constitute an optimal (k-1) partition of the trajectory
1-(i-1). These two probabilities are computed recursively by the
functions from the matrix of class <code>partmodltraj</code>, observing that
the probability of a 1-partition of the trajectory from 1 to i described
by the model m (i.e. only one segment describing the trajectory) is
simply the product of the probability densities of the steps from 1 to
i under the model m.  Further details can be found in Gueguen (2001, 2009).
</p>


<h3>Value</h3>

<p><code>partmodltraj</code> returns a matrix of class <code>partmodltraj</code>
containing the probability densities of the steps of the trajectory
(rows) for each model (columns).
</p>
<p><code>bestpartmod</code> returns a list with two elements: (i) the element
<code>mk</code> is a vector containing the values of the log-probabilities
for each number of segments (varying from 1 to <code>Km</code>), and (ii)
the element <code>correction</code> contains either <code>"none"</code> or a
matrix containing the corrected log-likelihood for each number of
segments (rows) and each simulation of the independence (column).
</p>
<p><code>partmod.ltraj</code> returns a list of class <code>partltraj</code> with the
following components: <code>ltraj</code> is an object of class <code>ltraj</code>
containing the segmented trajectory (one burst of relocations per segment
of the partition); <code>stats</code> is a list containing the following
elements:
</p>
<table>
<tr><td><code>locs</code></td>
<td>
<p>The number ID of the relocations starting the segments
(except the last one which ends the last segment)</p>
</td></tr>
<tr><td><code>Mk</code></td>
<td>
<p>The value of the cumulative log-probability for the Partition
(i.e. the log-probability associated to a K-partition is equal to the
log-probability associated to the (K-1)-partition plus the
log-probability associated to the Kth segment)</p>
</td></tr>
<tr><td><code>mod</code></td>
<td>
<p>The number ID of the model chosen for each segment</p>
</td></tr>
<tr><td><code>which.mod</code></td>
<td>
<p>the name of the model chosen for each segment</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>References</h3>

<p>Calenge, C., Gueguen, L., Royer, M. and Dray, S. (unpublished)
Partitioning the trajectory of an animal with Markov models.
</p>
<p>Gueguen, L. (2001) Segmentation by maximal predictive partitioning
according to composition biases. Pp 32&ndash;44 in: Gascuel, O. and Sagot,
M.F. (Eds.), <em>Computational Biology</em>, LNCS, 2066.
</p>
<p>Gueguen, L. (2009) Computing the likelihood of sequence segmentation
under Markov modelling. Arxiv preprint arXiv:0911.3070.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Example on the porpoise
data(porpoise)

## Keep the first porpoise
gus &lt;- porpoise[1]
plot(gus)

## First test the independence of the step length
indmove(gus)
## There is a lack of independence between successive distances

## plots the distance according to the date
plotltr(gus, "dist")

## One supposes that the distance has been generated
## by normal distribution, with different means for the
## different behaviours
## The means of the normal distribution range from 0 to
## 130000. We suppose a standard deviation equal to 5000:

tested.means &lt;- round(seq(0, 130000, length = 10), 0)
(limod &lt;- as.list(paste("dnorm(dist, mean =",
                  tested.means,
                  ", sd = 5000)")))

## Build the probability matrix
mod &lt;- modpartltraj(gus, limod)

## computes the corrected log-likelihood for each
## number of segments
bestpartmod(mod)

## The best number of segments is 4. Compute the partition:
(pm &lt;- partmod.ltraj(gus, 4, mod))
plot(pm)


## Shows the partition on the distances:
plotltr(gus, "dist")

lapply(1:length(pm$ltraj), function(i) {
   lines(pm$ltraj[[i]]$date, rep(tested.means[pm$stats$mod[i]],
         nrow(pm$ltraj[[i]])),
         col=c("red","green","blue")[as.numeric(factor(pm$stats$mod))[i]],
         lwd=2)
})


## Computes the residuals of the partition
res &lt;- unlist(lapply(1:length(pm$ltraj), function(i) {
   pm$ltraj[[i]]$dist - rep(tested.means[pm$stats$mod[i]],
         nrow(pm$ltraj[[i]]))
}))

plot(res, ty = "l")

## Test of independence of the residuals of the partition:
wawotest(res)


## End(Not run)
</code></pre>

<hr>
<h2 id='mouflon'>GPS Monitoring of One Mouflon in the Caroux Mountain</h2><span id='topic+mouflon'></span>

<h3>Description</h3>

<p>This dataset is an object of class &quot;ltraj&quot; (regular trajectory,
relocations every 20 minutes) containing the GPS relocations of one
mouflon during two week-ends in the Caroux mountain (South of
France).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mouflon)</code></pre>


<h3>Source</h3>

<p>Office national de la chasse et de la faune sauvage, CNERA Faune de
Montagne, 95 rue Pierre Flourens, 34000 Montpellier, France.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mouflon)
plot(mouflon)
</code></pre>

<hr>
<h2 id='na.omit.ltraj'>Removes the missing values in a trajectory</h2><span id='topic+na.omit.ltraj'></span>

<h3>Description</h3>

<p><code>na.omit.ltraj</code> can be used to remove missing relocations from a
trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ltraj'
na.omit(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.omit.ltraj_+3A_object">object</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="na.omit.ltraj_+3A_...">...</code></td>
<td>
<p>additionnal arguments to be passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ltraj</code>
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+setNA">setNA</a></code> to place the missing values in the trajectory
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(puechcirc)
puechcirc

na.omit(puechcirc)

</code></pre>

<hr>
<h2 id='offsetdate'>Date Handling in an Object of Class 'ltraj'</h2><span id='topic+offsetdate'></span>

<h3>Description</h3>

<p>This functions allows to set an offset value from the date in an
object of class <code>ltraj</code> of type II (time recorded).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>offsetdate(ltraj, offset, units = c("sec", "min", "hour", "day"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="offsetdate_+3A_ltraj">ltraj</code></td>
<td>
<p>an object of class <code>ltraj</code> of type II (time
recorded)</p>
</td></tr>
<tr><td><code id="offsetdate_+3A_offset">offset</code></td>
<td>
<p>a numeric value indicating the offset to be deducted
from the date</p>
</td></tr>
<tr><td><code id="offsetdate_+3A_units">units</code></td>
<td>
<p>a character string indicating the time units for
<code>offset</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use of offset is a convenient way to define reference dates in an
object of class <code>ltraj</code>.  For example, if the animal is monitored
every night, from 18H00 to 06H00, the fact that the beginning and the
end of the monitoring do not correspond to the same day may cause
difficulties to handle the trajectory.  Though these difficulties are
not unsurmountable, it is often convenient to deduct an offset to the
trajectory, so that the first relocation is collected at 0H and the
last one at 12H00 the same day (i.e., in this example, an offset of
18 hours).
</p>


<h3>Value</h3>

<p>an object of class <code>ltraj</code>
</p>


<h3>Author(s)</h3>

<p>  Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ltraj">ltraj</a></code> for additional information on objects of
class <code>ltraj</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(puechcirc)

plotltr(puechcirc, "dt")

toto &lt;- offsetdate(puechcirc, 17, "hour")

plotltr(puechcirc, "dt")

</code></pre>

<hr>
<h2 id='plot.ltraj'>Graphical Display of an Object of Class &quot;ltraj&quot;</h2><span id='topic+plot.ltraj'></span>

<h3>Description</h3>

<p><code>plot.ltraj</code> allows various graphical displays of the
trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ltraj'
plot(x, id = unique(unlist(lapply(x, attr, which = "id"))),
           burst = unlist(lapply(x, attr, which = "burst")), spixdf = NULL,
           spoldf = NULL, xlim = NULL, ylim = NULL, colspixdf =
           gray((240:1)/256), colspoldf = "green",  addpoints = TRUE,
           addlines = TRUE, perani = TRUE, final = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ltraj_+3A_x">x</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_id">id</code></td>
<td>
<p>a character vector containing the identity of the
individuals of interest</p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_burst">burst</code></td>
<td>
<p>a character vector containing the burst levels of
interest</p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_spixdf">spixdf</code></td>
<td>
<p>an object of class <code>SpatialPixelsDataFrame</code></p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_spoldf">spoldf</code></td>
<td>
<p>an object of class <code>SpatialPolygons</code></p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x axis</p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the y axis</p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_colspixdf">colspixdf</code></td>
<td>
<p>a character vector giving the colors of the map 
<code>spixdf</code></p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_colspoldf">colspoldf</code></td>
<td>
<p>a character vector giving the colors of the polygon contour
map, when <code>spoldf</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_addpoints">addpoints</code></td>
<td>
<p>logical.  If <code>TRUE</code>, points corresponding to
each relocation are drawn</p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_addlines">addlines</code></td>
<td>
<p>logical.  If <code>TRUE</code>, points corresponding to each
relocation are drawn</p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_perani">perani</code></td>
<td>
<p>logical.  If <code>TRUE</code>, one plot is drawn for each
value of <code>id</code>, and the several bursts are superposed on the
same plot for a given animal.  If <code>FALSE</code>, one plot is drawn
for each value of <code>burst</code> </p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_final">final</code></td>
<td>
<p>logical. If <code>TRUE</code>, the initial and final
relocations of each burst are indicated in blue and red,
respectively</p>
</td></tr>
<tr><td><code id="plot.ltraj_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the generic
function <code>plot</code> </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>  Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

<p>For further information on the class <code>ltraj</code>,
<code><a href="#topic+ltraj">ltraj</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(puechcirc)

plot(puechcirc)
plot(puechcirc, perani = FALSE)
plot(puechcirc, id = "JE93", perani = FALSE)

data(puechabonsp)
plot(puechcirc, perani = FALSE, spixdf = puechabonsp$map[,1])

cont &lt;- getcontour(puechabonsp$map[,1])
plot(puechcirc, spoldf = cont)

</code></pre>

<hr>
<h2 id='plotltr'>Changes in Traject Parameters Over Time</h2><span id='topic+plotltr'></span>

<h3>Description</h3>

<p>This function allows a graphical examination of the changes in
descriptive parameters in objects of class <code>ltraj</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotltr(x, which = "dist", pch = 16, cex = 0.7, addlines = TRUE,
        addpoints = TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotltr_+3A_x">x</code></td>
<td>
<p>An object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="plotltr_+3A_which">which</code></td>
<td>
<p>a character string giving any syntactically correct R
expression implying the descriptive elements in <code>x</code> or the
variables in the optional attribute <code>infolocs</code>.</p>
</td></tr>
<tr><td><code id="plotltr_+3A_pch">pch</code></td>
<td>
<p>the type of points on the plot (see <code>help(par)</code>).</p>
</td></tr>
<tr><td><code id="plotltr_+3A_cex">cex</code></td>
<td>
<p>the size of points on the plot (see <code>help(par)</code>).</p>
</td></tr>
<tr><td><code id="plotltr_+3A_addlines">addlines</code></td>
<td>
<p>logical.  Indicates whether lines should be added to
the plot.</p>
</td></tr>
<tr><td><code id="plotltr_+3A_addpoints">addpoints</code></td>
<td>
<p>logical.  Indicates whether points should be added to
the plot.</p>
</td></tr>
<tr><td><code id="plotltr_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the generic
function <code>plot</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+ltraj">ltraj</a></code> for additional information about
objects of class <code>ltraj</code>, and <code><a href="#topic+sliwinltr">sliwinltr</a></code> for a
sliding window smoothing</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(puechcirc)

plotltr(puechcirc, "cos(rel.angle)")
plotltr(puechcirc, "dist")
plotltr(puechcirc, "dx")

</code></pre>

<hr>
<h2 id='porpoise'>Argos monitoring of Porpoise Movements</h2><span id='topic+porpoise'></span>

<h3>Description</h3>

<p>This data set contains the relocations of 3 porpoises
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(porpoise)</code></pre>


<h3>Format</h3>

<p>This data set is a regular object of class <code>ltraj</code> (i.e. constant
time lag of 24H).
</p>


<h3>Details</h3>

<p>The coordinates are given in meters (UTM - zone 19).
</p>


<h3>Source</h3>

<p>http://whale.wheelock.edu/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(porpoise)

plot(porpoise)

</code></pre>

<hr>
<h2 id='puechcirc'>Movements of wild boars tracked at Puechabon</h2><span id='topic+puechcirc'></span>

<h3>Description</h3>

<p>This data set is an object of class <code>ltraj</code>, giving the results of the
monitoring of 2 wild boars by radio-tracking at Puechabon (Mediterranean
habitat, South of France).  These data have been
collected by Daniel Maillard (Office national de la chasse et de la
faune sauvage), and correspond to the activity period of the wild boar
(during the night, when the animals forage. The data set
<code>puechabonsp</code> in the package <code>adehabitatMA</code> describes the
resting sites). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(puechcirc)</code></pre>


<h3>Format</h3>

<p>This object has, in total, 204 relocations distributed among two
animals and three bursts of relocations (<code>CH930803</code>, <code>CH930824</code>,
<code>CH930827</code>, and <code>JE930827</code>).
</p>


<h3>Source</h3>

<p>Maillard, D. (1996). <em>Occupation et utilisation de la garrigue et
du vignoble mediterraneens par le Sanglier</em>.
Universite d'Aix-Marseille III: PhD thesis.
</p>

<hr>
<h2 id='qqchi'>Quantile-Quantile Plots for Trajectories of Class 'ltraj'</h2><span id='topic+qqchi'></span><span id='topic+qqchi.default'></span><span id='topic+qqchi.ltraj'></span><span id='topic+qqnorm.ltraj'></span>

<h3>Description</h3>

<p>The functions allow the examination of the distribution of trajectories
descriptors (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## Chi distribution of the increment length / sqrt(dt)
qqchi(y, ...)

## Default S3 method:
qqchi(y, df = 2, ylim, main = "Chi Q-Q Plot",
              xlab = "Theoretical Quantiles", ylab = "Sample Quantiles",
              plot.it = TRUE, datax = FALSE, ...) 

## S3 method for class 'ltraj'
qqchi(y, xlab = "Theoretical Quantiles", 
            ylab = "Sample Quantiles (Distances)", ...)

## Normal Distribution of dx/sqrt(dt) or dy/sqrt(dt)
## S3 method for class 'ltraj'
qqnorm(y, which=c("dx","dy"), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqchi_+3A_y">y</code></td>
<td>
<p>a vector containing the data sample for <code>qqchi.default</code>.
an object of class <code>ltraj</code> for other functions.</p>
</td></tr>
<tr><td><code id="qqchi_+3A_df">df</code></td>
<td>
<p>the number of degrees of freedom of the Chi distribution
(default to 2).</p>
</td></tr>
<tr><td><code id="qqchi_+3A_xlab">xlab</code>, <code id="qqchi_+3A_ylab">ylab</code>, <code id="qqchi_+3A_main">main</code></td>
<td>
<p>plot labels.</p>
</td></tr>
<tr><td><code id="qqchi_+3A_plot.it">plot.it</code></td>
<td>
<p>logical. Should the result be plotted?</p>
</td></tr>
<tr><td><code id="qqchi_+3A_datax">datax</code></td>
<td>
<p>logical. Should data values be on the x-axis?</p>
</td></tr>
<tr><td><code id="qqchi_+3A_which">which</code></td>
<td>
<p>a character string indicating the component (dx or dy) to
be examined.</p>
</td></tr>
<tr><td><code id="qqchi_+3A_ylim">ylim</code>, <code id="qqchi_+3A_...">...</code></td>
<td>
<p>graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Among the numerous statistics that can be used to describe the
movements of an animal, the length of the increment between two
successive relocations is very common.  This increment can be
described by a vector <code>i = c(dx, dy)</code>.  Under the hypothesis
of a Brownian motion, dx and dy should be normally distributed with
mean = 0 and variance = dt (where dt is the time interval between the
two relocations).  Therefore, <code>dx/sqrt(dt)</code> and
<code>dy/sqrt(dt)</code> should be normally distributed with mean = 0 and
variance = 1.  The function <code>qqnorm.ltraj</code> performs a
quantile-quantile plot of <code>dx/sqrt(dt)</code> or <code>dy/sqrt(dt)</code>
vs. a normal distribution to verify wether the Brownian motion
assumption is correct.
</p>
<p>Furthermore, the quantity <code>(dx^2 + dy^2)/dt</code> should be
distributed according to a Chi-squared distribution with two degrees
of freedom.  Thus, the quantity <code>distance / sqrt(dt)</code> should be
distributed according to a Chi distribution with two degrees of
freedom (where <code>distance</code> is the distance between the two
relocations). The function <code>qqchi.ltraj</code> performs
quantile-quantile plot of <code>distance/sqrt(dt)</code> vs. a Chi
distribution to verify wether the Brownian motion
assumption is correct.
</p>


<h3>Value</h3>

<p>for functions dealing with objects of class <code>ltraj</code>, a list with
components being themselves lists, with components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The x coordinates of the points that were/would be plotted</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The original <code>y</code> vector, i.e., the corresponding y
coordinates including 'NA's.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+chi">chi</a></code>, <code><a href="stats.html#topic+qqplot">qqplot</a></code>, <code><a href="#topic+ltraj">ltraj</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example with an Arithmetic Brownian Process
toto &lt;- simm.mba(1:500, sig = diag(c(5, 5)))
qqnorm(toto, "dx")
qqnorm(toto, "dy")
qqchi(toto)

## Example of wild boar
data(puechcirc)
qqnorm(puechcirc, "dx")
qqnorm(puechcirc, "dy")
qqchi(puechcirc)


</code></pre>

<hr>
<h2 id='rasterize.ltraj'>
Rasterize a Trajectory
</h2><span id='topic+rasterize.ltraj'></span>

<h3>Description</h3>

<p>The function <code>rasterize.ltraj</code> allows to rasterize a trajectory.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterize.ltraj(ltr, map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterize.ltraj_+3A_ltr">ltr</code></td>
<td>

<p>An object of class <code>ltraj</code>
</p>
</td></tr>
<tr><td><code id="rasterize.ltraj_+3A_map">map</code></td>
<td>

<p>An object inheriting the class <code>SpatialPixels</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects of class <code>SpatialPointsDataFrame</code>, with one
component per burst in the object of class <code>ltraj</code>. Each object
contains the coordinates of the pixels of the maps traversed by the
trajectory. The number of the step that traverse each pixel is
indicated. 
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.ltraj">as.ltraj</a></code> for additional information about objects of
class <code>ltraj</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(puechabonsp)
data(puechcirc)

## Show the trajectories on the map
plot(puechcirc, spixdf = puechabonsp$map)

## rasterize the trajectories
ii &lt;- rasterize.ltraj(puechcirc, puechabonsp$map)

## show, e.g. the first rasterized trajectory
tr1 &lt;- ii[[1]]
head(tr1)
plot(tr1)

## so, for example, to see the pixels traversed by the third step of the
##  trajectory
points(tr1[tr1[[1]]==3,], col="red")

## So, if we want to calculate the mean elevation for each step:
mel &lt;- over(tr1, puechabonsp$map)
mo &lt;- tapply(mel[[1]], tr1[[1]], mean)
plot(mo, ty="l")

## It is clear that elevation decreases at the middle of the monitoring
## and increases again at the end (the animal sleeps on the plateau
## and goes down in the vineyards during the night).

## Now define an infolocs component in puechcirc corresponding to the
## mean elevation:

val &lt;- lapply(1:length(ii), function(i) {

    ## get the rasterized trajectory
    tr &lt;- ii[[i]]

    ## get the pixels of the map
    mel &lt;- over(tr, puechabonsp$map)

    ## calculate the mean elevation
    mo &lt;- tapply(mel[[1]], tr[[1]], mean)

    ## prepare the output
    elev &lt;- rep(NA, nrow(puechcirc[[i]]))

    ## place the average values at the right place
    ## names(mo) contains the step number (i.e. relocation
    ## number +1)
    elev[as.numeric(names(mo))+1] &lt;- mo

    ## Checks that the row.names are the same for
    ## the result and the ltraj component
    df &lt;- data.frame(elevation = elev)
    row.names(df) &lt;- row.names(puechcirc[[i]])

    return(df)
})

## define the infolocs component
infolocs(puechcirc) &lt;- val

## and draw the trajectory
plotltr(puechcirc, "elevation")

</code></pre>

<hr>
<h2 id='redisltraj'>Rediscretization of a Trajectory With Regular Step Length or Duration</h2><span id='topic+redisltraj'></span>

<h3>Description</h3>

<p>This functions rediscretizes one or several trajectories in an object
of class <code>ltraj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redisltraj(l, u, burst = NULL, samplex0 = FALSE, addbit = FALSE,
           nnew = 5, type = c("space", "time"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redisltraj_+3A_l">l</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="redisltraj_+3A_u">u</code></td>
<td>
<p>the new step length in units of the coordinates or step
duration in seconds</p>
</td></tr>
<tr><td><code id="redisltraj_+3A_burst">burst</code></td>
<td>
<p>The burst identity of trajectories to be rediscretized.</p>
</td></tr>
<tr><td><code id="redisltraj_+3A_samplex0">samplex0</code></td>
<td>
<p>Whether the first relocation of the trajectory should
be sampled </p>
</td></tr>
<tr><td><code id="redisltraj_+3A_addbit">addbit</code></td>
<td>
<p>logical. When <code>type="space"</code>, whether the line
segment linking the last relocation of the rediscretized trajectory
and the last relocation of the raw trajectory should be added to the
result (can be useful for computation of fractal dimension)</p>
</td></tr>
<tr><td><code id="redisltraj_+3A_nnew">nnew</code></td>
<td>
<p>optionnally, you may specify the maximum ratio between number of
relocations of the new trajectory.  If not specified, this maximum
is equal to 5 times the number of relocations of the raw
trajectory.</p>
</td></tr>
<tr><td><code id="redisltraj_+3A_type">type</code></td>
<td>
<p>a character string indicating whether the step duration
(<code>"time"</code>) or length (<code>"space"</code> should be constant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rediscretization of trajectory has been advocated by several
authors in the literature (Turchin 1998, Bovet &amp; Benhamou 1988).  It
is also the first step of the computation of the fractal dimension of
the path (Sugihara &amp; May 1990).
</p>
<p>When <code>type="time"</code>, a linear interpolation is performed to find
new relocations separated by the given time lag.
</p>


<h3>Value</h3>

<p>An object of class <code>"ltraj"</code>
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>References</h3>

<p>Bovet, P., &amp; Benhamou, S. (1988) Spatial analysis of animal's
movements using a correlated random walk model. <em>Journal of
Theoretical Biology</em> <b>131</b>: 419&ndash;433.
</p>
<p>Turchin, P. (1998) <em>Quantitative analysis of movement</em>,
Sunderland, MA.
</p>
<p>Sugihara, G., &amp; May, R. (1990) Applications of fractals in
Ecology. <em>Trends in Ecology and Evolution</em> <b>5</b>: 79&ndash;86.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for further information on objects of
class <code>ltraj</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################################
##
## Example of space rediscretization

data(puechcirc)

puechcirc

## before rediscretization
plot(puechcirc, perani = FALSE)

## after rediscretization
toto &lt;- redisltraj(puechcirc, 100)
plot(toto, perani = FALSE)


#####################################
##
## Example of time rediscretization

data(buffalo)
tr &lt;- buffalo$traj

## Show the time lag before rediscretization
plotltr(tr, "dt")

## Rediscretization every 1800 seconds
tr &lt;- redisltraj(tr, 1800, type="time")

## Show the time lag after rediscretization
plotltr(tr, "dt")

</code></pre>

<hr>
<h2 id='residenceTime'>Trajectory Analysis using the Residence Time Method</h2><span id='topic+residenceTime'></span><span id='topic+print.resiti'></span><span id='topic+plot.resiti'></span>

<h3>Description</h3>

<p>These functions can be used to apply the residence time method
(Barraquand and Benhamou, 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residenceTime(lt, radius, maxt, addinfo = FALSE,
              units = c("seconds", "hours", "days"))

## S3 method for class 'resiti'
print(x, ...)

## S3 method for class 'resiti'
plot(x, addpoints = FALSE, addlines = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residenceTime_+3A_lt">lt</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="residenceTime_+3A_radius">radius</code></td>
<td>
<p>the radius of the patch (in units of the coordinates)</p>
</td></tr>
<tr><td><code id="residenceTime_+3A_maxt">maxt</code></td>
<td>
<p>maximum time threshold that the animal is allowed to spend
outside the patch before that we consider that the animal actually
left the patch (see Details)</p>
</td></tr> 
<tr><td><code id="residenceTime_+3A_addinfo">addinfo</code></td>
<td>
<p>logical value.  If <code>TRUE</code>, then the residence time
method is added as a variable in the <code>infolocs</code> component of
the object <code>lt</code>.  If <code>FALSE</code> this function returns an
object of class <code>resiti</code></p>
</td></tr>
<tr><td><code id="residenceTime_+3A_units">units</code></td>
<td>
<p>a character string indicating the time units of
<code>maxt</code></p>
</td></tr>
<tr><td><code id="residenceTime_+3A_x">x</code></td>
<td>
<p>an object of class <code>"resiti"</code></p>
</td></tr>
<tr><td><code id="residenceTime_+3A_addpoints">addpoints</code></td>
<td>
<p>logical.  Whether points should be added to the plot.</p>
</td></tr>
<tr><td><code id="residenceTime_+3A_addlines">addlines</code></td>
<td>
<p>logical.  Whether lines should be added to the plot.</p>
</td></tr>
<tr><td><code id="residenceTime_+3A_...">...</code></td>
<td>
<p>additionnal arguments to be passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Barraquand and Benhamou (2008) proposed a new approach to identify the
places where the animals spend the most of their time, relying on the
calculation of their residence time in the various places where they
have been relocated.  This approach is similar to the
first passage time method: for a given value of <code>radius</code> and for
a given relocation, the first passage time is defined as the time
required by the animal to pass through a circle of given radius
centred  on the relocation  (see the help page of the function
<code>fpt</code> for additional details).  The residence time associated to
a given relocation corresponds to the first passage time calculated at
this place plus the passage times that occurred in this circle
before or after the current relocation, *given* that 
the animal did not spent a time greater than <code>maxt</code> before
reentering the circle (see Barraquand and Benhamou, 2008, for
details).  It is therefore computed by determining the various times
at which the path intersects the perimeter of the circle
centred on the current relocation, both forward and backward, and
then by summing the durations associated with the
various portions of the path occurring within the circle. The
graphical examination of the changes with time allow to identify the
dates and places where the animal spent most of its time.
</p>
<p>A partitionning method can be used to segment the series formed by the
residence time into homogeneous segments.  Barraquand and Benhamou
(2008) propose the method of Lavielle (1999, 2005). See the function
<code>lavielle</code> for details about this method.
</p>


<h3>Value</h3>

<p>If <code>addinfo = FALSE</code>, the function <code>residenceTime</code> returns a
list of class <code>"resiti"</code> where each element corresponds to a
burst of the object <code>lt</code>.  Each element is a <code>data.frame</code>
with two columns: the date and the residence time associated with the
date.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>References</h3>

<p>Barraquand, F. and Benhamou, S. (2008) Animal movement in
heterogeneous landscapes: identifying profitable places and
homogeneous movement bouts. <em>Ecology</em>, <b>89</b>, 3336&ndash;3348. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavielle">lavielle</a></code> for the partitionning of the trajectory based
on the residence time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(albatross)
ltr &lt;- albatross[1]

## show the distances between successive relocations as a function
## of date
plotltr(ltr)

## focus on the first period
ltr &lt;- gdltraj(ltr, as.POSIXct("2001-12-15", tz="UTC"),
               as.POSIXct("2003-01-10", tz="UTC"))

plot(ltr)
## We identify places that seem to be a patch and, with locator,
## we measure approximately their size.
## The approximate patch radius can be set equal to 100 km as a first try

plotltr(ltr, "dt")
## As a first try, we could set maxt equal to 15000 seconds, i.e.
## approximately 4 hours

## calculation of the residence time
res &lt;- residenceTime(ltr, radius = 100000, maxt=4, units="hour")
plot(res)

## There seems to be about 10 segments. Let us try the method
## of Lavielle (1999, 2005) to segment this series:
## First calculate again the residence time as the infolocs attribute
## of the trajectory
res &lt;- residenceTime(ltr, radius = 100000, maxt=4, addinfo = TRUE, units="hour")
res

## Note that the residence time is now an attribute of the infolocs
## component of res


## Now, use the Lavielle method, with Kmax set to 2-3 times the
## "optimal" number of segments, assessed visually according
## to the recommendations of Barraquand and Benhamou (2008)
## We set the minimum number of relocations in each segment to
## 10 observations (given that the relocations were theoretically
## taken every hour, this defines a patch as a place where the animal
## stays at least 10 hours: this also defines the scale of our study)

ii &lt;- lavielle(res, which="RT.100000", Kmax=20, Lmin=10)

## Both the graphical method and the automated method to choose
## the optimal number of segments indicate 4 segments
## (see ?lavielle for a description of these methods):

chooseseg(ii)

## We identify the 4 segments: the method of Lavielle seems to do a good
## job:
(pa &lt;- findpath(ii, 4))

## and we plot this partition:
plot(pa, perani=FALSE)


## Now, we could try a study at a smaller scale (patch = 50km):
res &lt;- residenceTime(ltr, radius = 50000, maxt=4, addinfo = TRUE,
                     units="hour")
ii &lt;- lavielle(res, which="RT.50000", Kmax=20, Lmin=10)

## 5 segments seem a good choice:
chooseseg(ii)

## There is more noise in the residence time, but
## the partition is still pretty clear:
(pa &lt;- findpath(ii, 5))

## show the partition:
plot(pa, perani = FALSE)


## Now try at a larger scale (patch size=250 km)
res &lt;- residenceTime(ltr, radius = 250000, maxt=4, addinfo = TRUE,
                     units="hour")
ii &lt;- lavielle(res, which="RT.250000", Kmax=15, Lmin=10)

## 5 segments seem a good choice again:
chooseseg(ii)

## There is more noise in the residence time, but
## the partition is still pretty clear:
(pa &lt;- findpath(ii, 5))

## show the partition:
plot(pa, perani = FALSE)


## End(Not run)
</code></pre>

<hr>
<h2 id='runsNAltraj'>Highlighting the Patterns in Missing Values in Trajects</h2><span id='topic+runsNAltraj'></span><span id='topic+summaryNAltraj'></span><span id='topic+plotNAltraj'></span>

<h3>Description</h3>

<p><code>runsNAltraj</code> performs a runs test to detect any autocorrelation
in the location of missing relocations, for each burst of an object of
class <code>ltraj</code>.
</p>
<p><code>summaryNAltraj</code> returns a summary of the number and proportion
of missing values for each burst of an object of class
<code>ltraj</code>.
</p>
<p><code>plotNAltraj</code> plots the missing values in an object of class
<code>ltraj</code> against the time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runsNAltraj(x, nrep = 500, plotit = TRUE, ...) 

summaryNAltraj(x)

plotNAltraj(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runsNAltraj_+3A_x">x</code></td>
<td>
<p> An object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="runsNAltraj_+3A_nrep">nrep</code></td>
<td>
<p>Number of randomisations</p>
</td></tr>
<tr><td><code id="runsNAltraj_+3A_plotit">plotit</code></td>
<td>
<p>logical.  Whether the results should be plotted on a
graph</p>
</td></tr>
<tr><td><code id="runsNAltraj_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the generic function
<code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistics used here for the test is the number
of runs in the sequence of relocations. For example, the sequence
reloc-NA-NA-reloc-reloc-reloc-NA-NA-NA-reloc contains 5 runs, 3 runs
of successful relocations and 2 runs of missing values. Under the
hypothesis of random distribution of the missing values in the
sequence, the theoretical expectation and standard deviation of the
number of runs is known. The runs test is a randomization test that
compares the standardized value of the number of runs
(i.e. (value-expectation)/(standard deviation)) to the distribution of
values obtained after randomizing the distribution of the NA in the
sequence. Thus, a negative value of this standardized number of runs
indicates that the missing values tend to be clustered together in the
sequence.
</p>


<h3>Value</h3>

<p><code>runsNAltraj</code> returns a list of objects of class
<code>randtest</code> (if a burst does not contain any missing value, the
corresponding component is NULL).
</p>


<h3>Note</h3>

<p>In the versions of adehabitatLT prior to 0.3.21, a bug occurred in the
calculation of the P-value (the test actually presented the value
1-P). This bug is now corrected.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for additional information about objects of
class <code>ltraj</code>, <code><a href="#topic+setNA">setNA</a></code> for additional information
about missing values in such objects</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Two relocations are theoretically separated by
## 10 minutes (600 seconds)
data(puechcirc)
puechcirc

## plot the missing values
plotNAltraj(puechcirc)


## Test for an autocorrelation pattern in the missing values
(runsNAltraj(puechcirc))

</code></pre>

<hr>
<h2 id='rupicabau'>GPS Monitoring of One Chamois in the Bauges Mountains</h2><span id='topic+rupicabau'></span>

<h3>Description</h3>

<p>This dataset is an object of class &quot;ltraj&quot; (regular trajectory,
relocations every 20 minutes) containing the GPS relocations of two
chamois during one day in the Bauges mountain (French Alps).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rupicabau)</code></pre>


<h3>Source</h3>

<p>Office national de la chasse et de la faune sauvage, CNERA Faune de
Montagne, 95 rue Pierre Flourens, 34000 Montpellier, France.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rupicabau)
plot(rupicabau)
</code></pre>

<hr>
<h2 id='set.limits'>Define the Same Time Limits for several Bursts in a
Regular Trajectory</h2><span id='topic+set.limits'></span>

<h3>Description</h3>

<p>This function sets the same time limits for several
bursts in a regular trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.limits(ltraj, begin, dur, pattern,
           units = c("sec", "min", "hour", "day"),
           tz = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.limits_+3A_ltraj">ltraj</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="set.limits_+3A_begin">begin</code></td>
<td>
<p>a character string which is used to determine the
time of beginning of the study period (see below) </p>
</td></tr>
<tr><td><code id="set.limits_+3A_dur">dur</code></td>
<td>
<p>the duration of the study period</p>
</td></tr>
<tr><td><code id="set.limits_+3A_pattern">pattern</code></td>
<td>
<p>a character string indicating the conversion
specifications for <code>begin</code> (see below)</p>
</td></tr>
<tr><td><code id="set.limits_+3A_units">units</code></td>
<td>
<p>a character string indicating the time units of
<code>dur</code></p>
</td></tr>
<tr><td><code id="set.limits_+3A_tz">tz</code></td>
<td>
<p>A timezone specification to be used for the conversion of
<code>begin</code>.  System-specific, but <code>""</code> is the current time
zone, and <code>"GMT"</code> is UTC (see <code>help(strptime)</code>)</p>
</td></tr>
<tr><td><code id="set.limits_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some studies are intended to compare regular trajectories of the same
duration collected at different period.  For example, the aim may be to
identify the differences/similarities between different days (each one
corresponding to a burst of relocation) in the pattern of movements of
an animal between 05H00 and 08H00, with a time lag of 5 minutes.  In
such cases, it is often convenient that the relocations of the bursts
are paired (e.g. the fifth relocation correspond to the position of
the animal at 5H30 for all bursts).
</p>
<p>The function <code>set.limits</code> is intended to ensure that the time of
beginning, the end, and the duration of the trajectory is the same for
all bursts of the object <code>ltraj</code>.  If relocations are collected
outside the limits, they are removed (and so is the corresponding
metadata in the attribute <code>infolocs</code>).  If the actual time limits
of the burst cover a shorter period than those specified, missing values
are added to the trajectory (and in the corresponding
metadata in the attribute <code>infolocs</code>).
</p>
<p>Note that &quot;time of beginning&quot; is not a synonym for &quot;date&quot;.  That is,
two trajectories of the same animal, both beginning at 05H00 and
ending at 08H00, have the same time of beginning, but are necessarily
not sampled on the same day, which implies that they correspond to
different dates.  For this reason, the time of beginning is indicated
to the function <code>set.limits</code> by a character string, and the
parameter <code>pattern</code> should indicate the conversion specifications.
These conversions specifications are widely documented on the help
page of the function <code>strptime</code>.  For example, to indicate that the
trajectory begins at 5H00, the value for <code>begin</code> should be
<code>"05:00"</code> and the value for <code>pattern</code> should be
<code>"%H:%M"</code>. If the trajectory should begin on january 10th, the
value for <code>begin</code> should be <code>"01:10"</code> and <code>pattern</code>
should be <code>"%m:%d"</code>.  Note that the only conversion
specifications allowed in this function are <code>%S</code> (seconds),
<code>%M</code> (minutes), <code>%H</code> (hours), <code>%d</code> (day), <code>%m</code>
(month), <code>%Y</code> (year with century), <code>%w</code> (weekday), and
<code>%j</code> (yearday). See <code>help(strptime)</code> for additional
information on these convention specifications.
</p>


<h3>Value</h3>

<p>an object of class <code>ltraj</code>
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for additional information on objects of
class <code>ltraj</code>, <code><a href="#topic+sett0">sett0</a></code> for additional
information on regular trajectories, and <code><a href="#topic+sd2df">sd2df</a></code> for
additionnal information about regular trajectories of the same
duration.  See also <code><a href="base.html#topic+strptime">strptime</a></code> for further information
about conversion specifications for dates.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load data on the ibex
data(ibex)
ibex

## The monitoring of the 4 ibex should start and end at the same time
## define the time limits

ib2 &lt;- set.limits(ibex, begin="2003-06-01 00:00", dur=14,
                  units="day", pattern="%Y-%m-%d %H:%M", tz="Europe/Paris")
ib2
is.sd(ib2)

## All the trajectories cover the same study period
## Relocations are collected at the same time. This dataset can now be
## used for studies of interactions between animals

</code></pre>

<hr>
<h2 id='setNA'> Place Missing Values in Objects of Class 'ltraj' </h2><span id='topic+setNA'></span>

<h3>Description</h3>

<p>This function places missing values in an (approximately) regular
trajectory, when a relocation should have been collected, but is
actually missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setNA(ltraj, date.ref, dt, tol = dt/10,
      units = c("sec", "min", "hour", "day"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setNA_+3A_ltraj">ltraj</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="setNA_+3A_date.ref">date.ref</code></td>
<td>
<p>an object of class <code>POSIXt</code> (see below)</p>
</td></tr>
<tr><td><code id="setNA_+3A_dt">dt</code></td>
<td>
<p>the time lag between relocations</p>
</td></tr>
<tr><td><code id="setNA_+3A_tol">tol</code></td>
<td>
<p>the tolerance, which measures the imprecision in the timing
of data collection (see below)</p>
</td></tr>
<tr><td><code id="setNA_+3A_units">units</code></td>
<td>
<p>a character string indicating the time units for
<code>dt</code> and <code>tol</code></p>
</td></tr>
<tr><td><code id="setNA_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function
<code>rec</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>During the field study, the collection of the relocations of a
trajectory may sometimes fail, which results into missing values.  The
class <code>ltraj</code> deal with these missing values, so that it is
recommended to store the missing values in the data *before* the
creation of the object of class <code>ltraj</code>.  For example, GPS
collars often fail to locate the animal, so that the GPS data imported
within R contain missing values.  It is recommended to *not remove*
these missing values.
</p>
<p>However, sometimes, the data come without any information concerning
the placement of these missing values.  If the trajectory is
approximately regular (i.e. approximately constant time lag), it is
possible to determine where these missing values should occur in the
object of class <code>ltraj</code> (and in the optional attribute
<code>infolocs</code>).  This is the role of the function <code>setNA</code>.
</p>
<p>The relocations in the object of class <code>ltraj</code> may not have been
collected at exactly identical time lag (e.g. a relocation is
collected at 17H57 instead of 18H00). The function <code>setNA</code>
requires that the imprecision in the timing is at most equal to
<code>tol</code>.  Because of this imprecision, it is necessary to pass a
reference date as argument to the function <code>setNA</code>. This
reference date is used to determine at which time the missing values
should be placed.
</p>
<p>The reference date is chosen so that the rest of the division of
(date.relocations - reference.date) by the time lag <code>dt</code> is equal
to zero.  For example, if it is known that one of the relocations of the
trajectory has been collected on January 16th 1996 at 18H00,
and if the theoretical time lag between two relocations is of one
hour, the date of reference could be (for example) the August 1st 2017
at 05H00, because these two dates are separated by an exact number of
hours (i.e. an exact number of <code>dt</code>). Therefore, any date
fulfilling this condition could be passed as reference date.
Alternatively, the August 1st 2007 at 05H30 is an uncorrect reference
date, because the number of hours separating these two dates is not an
integer.
</p>


<h3>Value</h3>

<p>An object of class <code>ltraj</code>
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for additional information about objects
of class <code>ltraj</code>. <code><a href="#topic+sett0">sett0</a></code> (especially the examples
of this help page) and <code><a href="#topic+is.regular">is.regular</a></code> for additional
information about regular trajectories.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(porpoise)
foc &lt;- porpoise[1]

## the list foc does not contain any missing value:
foc
plotNAltraj(foc)

## we remove the second to tenth relocation
foc[[1]] &lt;- foc[[1]][-c(2:10),]
foc &lt;- rec(foc)

## The missing values are not visible:
foc
plotNAltraj(foc)

## The porpoise is located once a day.
## We use the first relocation as the reference date
foc2 &lt;- setNA(foc, foc[[1]]$date[1], 24*3600)

## Missing values are now present
foc2
plotNAltraj(foc2)

</code></pre>

<hr>
<h2 id='sett0'>Round the Timing of Collection of Relocations to Obtain Regular
Trajectory</h2><span id='topic+sett0'></span>

<h3>Description</h3>

<p>This function rounds the timing of collection of relocations in an
object of class <code>ltraj</code> to obtain a regular trajectory, based on
a reference date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sett0(ltraj, date.ref, dt, correction.xy = c("none", "cs"),
      tol = dt/10, units = c("sec", "min", "hour", "day"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sett0_+3A_ltraj">ltraj</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="sett0_+3A_date.ref">date.ref</code></td>
<td>
<p>an object of class <code>POSIXt</code> containing either one
reference date (the same for all animals) or n reference dates, where
n is the number of bursts in <code>ltraj</code> (see below)</p>
</td></tr>
<tr><td><code id="sett0_+3A_dt">dt</code></td>
<td>
<p>the time lag between relocations</p>
</td></tr>
<tr><td><code id="sett0_+3A_correction.xy">correction.xy</code></td>
<td>
<p>the correction for the coordinates.
<code>"none"</code> (default), does not performs any correction.
<code>"cs"</code> performs a correction based on the hypothesis that the
animal moves at constant speed (see below).</p>
</td></tr>
<tr><td><code id="sett0_+3A_tol">tol</code></td>
<td>
<p>the tolerance, which measures the imprecision in the timing
of data collection (see below)</p>
</td></tr>
<tr><td><code id="sett0_+3A_units">units</code></td>
<td>
<p>the time units for <code>dt</code> and <code>tol</code></p>
</td></tr>
<tr><td><code id="sett0_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function
<code>rec</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trajectories are stored in adehabitatLT as lists of &quot;bursts&quot; of
successive relocations with the timing of relocation.  Regular
trajectories are characterized by a constant time lag <code>dt</code>
between successive relocations (don't mix animals located every 10
minutes and animals located every day in a regular trajectory).
</p>
<p>However, in many cases, the actual time lag in the data may not be
equal to the theoretical time lag <code>dt</code>: there may be some
negligible imprecision in the time of collection of the data (e.g. an
error of a few seconds on a time lag of one hour).
</p>
<p>But many functions of adehabitatLT require exact regular
trajectories. <code>sett0</code> allows to round the date so that all the
successive relocations are separated exactly by <code>dt</code>.  The
function <code>sett0</code> requires that the imprecision is at most equal
to <code>tol</code>. To proceed, it is necessary to pass a reference date as
argument.
</p>
<p>The reference date is chosen so that the rest of the division of
(date.relocations - reference.date) by <code>dt</code> is equal to zero.
For example, if it is known that one of the relocations of the
trajectory should have been collected on January 16th 1996 at 18H00,
and if the theoretical time lag between two relocations is of one
hour, the date of reference could be (for example) the August 1st 2017
at 05H00, because these two dates are separated by an exact number of
hours.  Alternatively, the August 1st 2007 at 05H30 is an uncorrect
reference date, because the number of hours separating these two dates
is not an integer.
</p>
<p>Note that this rounding adds an error on the relocation.  For example,
the position of a moving animal at 17H57 is not the same as its
position at 18H00.  If the time imprecision in the data collection is
negligible (e.g. a few seconds, while <code>dt</code> is equal to an hour),
this &quot;noise&quot; in the relocations can be ignored, but if it is more
important, a correction on the relocation is needed.  The function
<code>sett0</code> may correct the relocations based on the hypothesis of
constant speed (which is not necessarily biologically relevant, see
examples).
</p>
<p>Note finally that missing values can be present in the trajectory.
Indeed, there are modes of data collection that fail to locate the
animal at some dates.  These failures should appear as missing values
in the regular trajectory.  It is often convenient to use the function
<code>setNA</code> before the function <code>sett0</code> to set the missing
values in a (nearly) regular trajectory.
</p>


<h3>Value</h3>

<p>an object of class <code>ltraj</code> containing a regular trajectory.
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for additional information on objects of
class <code>ltraj</code>, <code><a href="#topic+is.regular">is.regular</a></code> for regular trajectories,
<code><a href="#topic+setNA">setNA</a></code> to place missing values in the trajectory and
<code><a href="#topic+cutltraj">cutltraj</a></code> to cut a trajectory into several bursts based
on a criteria. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#########################################################################
##
##
## Transform a GPS monitoring on 4 ibex into a regular trajectory
##

data(ibexraw)
is.regular(ibexraw)

## the data are not regular: see the distribution of dt (in hours)
## according to the date

plotltr(ibexraw, "dt/3600")

## The relocations have been collected every 4 hours, and there are some
## missing data

## The reference date: the hour should be exact (i.e. minutes=0):
refda &lt;- strptime("00:00", "%H:%M", tz="Europe/Paris")
refda

## Set the missing values
ib2 &lt;- setNA(ibexraw, refda, 4, units = "hour") 

## now, look at dt for the bursts:
plotltr(ib2, "dt")

## dt is nearly regular: round the date:

ib3 &lt;- sett0(ib2, refda, 4, units = "hour") 

plotltr(ib3, "dt")
is.regular(ib3)

## ib3 is now regular

## End(Not run)
</code></pre>

<hr>
<h2 id='simm.bb'>Brownian bridge motion</h2><span id='topic+simm.bb'></span>

<h3>Description</h3>

<p>This function simulates a brownian bridge motion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simm.bb(date = 1:100, begin = c(0, 0), end = begin, id = "A1",
        burst = id, proj4string=CRS())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simm.bb_+3A_date">date</code></td>
<td>
<p>a vector indicating the date (in seconds) at which
relocations should be simulated.  This vector can be of class
<code>POSIXct</code></p>
</td></tr>
<tr><td><code id="simm.bb_+3A_begin">begin</code></td>
<td>
<p>a vector of length 2 giving the x and y coordinates of
the location beginning of the trajectory</p>
</td></tr>
<tr><td><code id="simm.bb_+3A_end">end</code></td>
<td>
<p>a vector of length 2 giving the x and y coordinates of
the location ending the trajectory</p>
</td></tr>
<tr><td><code id="simm.bb_+3A_id">id</code></td>
<td>
<p> a character string indicating the identity of the simulated
animal (see <code>help(ltraj)</code>)</p>
</td></tr>
<tr><td><code id="simm.bb_+3A_burst">burst</code></td>
<td>
<p> a character string indicating the identity of the
simulated animal (see <code>help(ltraj)</code>)</p>
</td></tr>
<tr><td><code id="simm.bb_+3A_proj4string">proj4string</code></td>
<td>
<p>a valid CRS object containing the projection
information (see <code>?CRS</code> from the package <code>sp</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ltraj</code>.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a><br />
Stephane Dray <a href="mailto:dray@biomserv.univ-lyon1.fr">dray@biomserv.univ-lyon1.fr</a><br />
Manuela Royer <a href="mailto:royer@biomserv.univ-lyon1.fr">royer@biomserv.univ-lyon1.fr</a><br />
Daniel Chessel <a href="mailto:chessel@biomserv.univ-lyon1.fr">chessel@biomserv.univ-lyon1.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code>, <code><a href="#topic+hbrown">hbrown</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(simm.bb(1:1000, end=c(100,100)), addpoints = FALSE)

</code></pre>

<hr>
<h2 id='simm.brown'>Simulate a Bivariate Brownian Motion</h2><span id='topic+simm.brown'></span>

<h3>Description</h3>

<p>This function simulates a Bivariate Brownian Motion. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simm.brown(date = 1:100, x0 = c(0, 0), h = 1, id = "A1", burst = id,
           proj4string=CRS())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simm.brown_+3A_date">date</code></td>
<td>
<p>a vector indicating the date (in seconds) at which
relocations should be simulated.  This vector can be of class
<code>POSIXct</code></p>
</td></tr>
<tr><td><code id="simm.brown_+3A_x0">x0</code></td>
<td>
<p>a vector of length 2 containing the coordinates of the
startpoint of the trajectory</p>
</td></tr>
<tr><td><code id="simm.brown_+3A_h">h</code></td>
<td>
<p>Scaling parameter for the brownian motion (larger values give
smaller dispersion)</p>
</td></tr>
<tr><td><code id="simm.brown_+3A_id">id</code></td>
<td>
<p>a character string indicating the identity of the simulated
animal (see <code>help(ltraj)</code>)</p>
</td></tr>
<tr><td><code id="simm.brown_+3A_burst">burst</code></td>
<td>
<p>a character string indicating the identity of the simulated
burst (see <code>help(ltraj)</code>)</p>
</td></tr>
<tr><td><code id="simm.brown_+3A_proj4string">proj4string</code></td>
<td>
<p>a valid CRS object containing the projection
information (see <code>?CRS</code> from the package <code>sp</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A bivariate Brownian motion can be described by a vector
<code>B2(t) = (Bx(t), By(t))</code>, where <code>Bx</code> and <code>By</code> are
unidimensional Brownian motions.  Let <code>F(t)</code> the set of all
possible realisations of the process <code>(B2(s), 0 &lt; s &lt; t)</code>.
<code>F(t)</code> therefore corresponds to the known information at time
<code>t</code>.  The properties of the bivariate Brownian motion are
therefore the following: (i) <code>B2(0)= c(0,0)</code> (no uncertainty at
time <code>t = 0</code>); (ii) <code>B2(t) - B2(s)</code> is independent of
<code>F(s)</code> (the next increment does not depend on the present or past
location); (iii) <code>B2(t) - B2(s)</code> follows a bivariate normal
distribution with mean <code>c(0,0)</code> and with variance equal to
<code>(t-s)</code>.
</p>
<p>Note that for a given parameter <code>h</code>, the process <code>1/h * B2(
    t * h^2 )</code> is a Brownian motion.  The function <code>simm.brown</code>
simulates the process <code>B2(t * h^2)</code>.  Note that the function
<code>hbrown</code> allows the estimation of this scaling factor from data. 
</p>


<h3>Value</h3>

<p>An object of class <code>ltraj</code>
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a><br />
Stephane Dray <a href="mailto:dray@biomserv.univ-lyon1.fr">dray@biomserv.univ-lyon1.fr</a><br />
Manuela Royer <a href="mailto:royer@biomserv.univ-lyon1.fr">royer@biomserv.univ-lyon1.fr</a><br />
Daniel Chessel <a href="mailto:chessel@biomserv.univ-lyon1.fr">chessel@biomserv.univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p> ~put references to the literature/web site here ~ </p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code>, <code><a href="#topic+hbrown">hbrown</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(simm.brown(1:1000), addpoints = FALSE)

## Note the difference in dispersion:
plot(simm.brown(1:1000, h = 4), addpoints = FALSE)

</code></pre>

<hr>
<h2 id='simm.crw'>Simulation of a Correlated Random Walk</h2><span id='topic+simm.crw'></span>

<h3>Description</h3>

<p>This function simulates a correlated random walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simm.crw(date=1:100, h = 1, r = 0,
         x0=c(0,0), id="A1", burst=id,
         typeII=TRUE, proj4string=CRS())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simm.crw_+3A_date">date</code></td>
<td>
<p>a vector indicating the date (in seconds) at which
relocations should be simulated.  This vector can be of class
<code>POSIXct</code>. *Note that the time lag between two relocations
should be constant* (regular trajectories required)</p>
</td></tr>
<tr><td><code id="simm.crw_+3A_h">h</code></td>
<td>
<p>the scaling parameter for the movement length</p>
</td></tr>
<tr><td><code id="simm.crw_+3A_r">r</code></td>
<td>
<p>The concentration parameter for wrapped normal distribution
of turning angles</p>
</td></tr>
<tr><td><code id="simm.crw_+3A_x0">x0</code></td>
<td>
<p>a vector of length 2 containing the coordinates of the
startpoint of the trajectory</p>
</td></tr>
<tr><td><code id="simm.crw_+3A_id">id</code></td>
<td>
<p>a character string indicating the identity of the simulated
animal (see <code>help(ltraj)</code>)</p>
</td></tr>
<tr><td><code id="simm.crw_+3A_burst">burst</code></td>
<td>
<p>a character string indicating the identity of the simulated
burst (see <code>help(ltraj)</code>)</p>
</td></tr>
<tr><td><code id="simm.crw_+3A_typeii">typeII</code></td>
<td>
<p>logical.  Whether the simulated trajectory should be of
type II (<code>TRUE</code>, time recorded) or not (<code>FALSE</code>, time not
recorded). See <code>help(ltraj)</code>.</p>
</td></tr>
<tr><td><code id="simm.crw_+3A_proj4string">proj4string</code></td>
<td>
<p>a valid CRS object containing the projection
information (see <code>?CRS</code> from the package <code>sp</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the seminal paper of Kareiva and Shigesada (1983), most
biologists describe the trajectories of an animal with the help of
two distributions: the distribution of distances between successive
relocations, and the distribution of turning angles between successive
moves (relative angles in the class <code>ltraj</code>).  The CRW is
built iteratively.  At each step of the simulation process,
the orientation of the move is drawn from a wrapped normal
distribution (with concentration parameter <code>r</code>).  The length of
the move is drawn from a chi distribution, multiplied by <code>h *
    sqrt(dt)</code>. <code>h</code> is a scale parameter (the same as in the
function <code>simm.brown()</code>, and the distribution is
multiplied by sqrt(t) to make it similar to the discretized Brownian
motion if <code>r == 0</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>ltraj</code>
</p>


<h3>Note</h3>

<p>This function requires the package <code>CircStats</code>.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a><br />
Stephane Dray <a href="mailto:dray@biomserv.univ-lyon1.fr">dray@biomserv.univ-lyon1.fr</a><br />
Manuela Royer <a href="mailto:royer@biomserv.univ-lyon1.fr">royer@biomserv.univ-lyon1.fr</a><br />
Daniel Chessel <a href="mailto:chessel@biomserv.univ-lyon1.fr">chessel@biomserv.univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Kareiva, P. M. &amp; Shigesada, N. (1983) Analysing insect movement as a
correlated random walk. <em>Oecologia</em>, <b>56</b>: 234&ndash;238.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chi">chi</a></code>, <code><a href="CircStats.html#topic+rwrpnorm">rwrpnorm</a></code>,
<code><a href="#topic+simm.brown">simm.brown</a></code>, <code><a href="#topic+ltraj">ltraj</a></code>,
<code><a href="#topic+simm.crw">simm.crw</a></code>, <code><a href="#topic+simm.mba">simm.mba</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(876)
u &lt;- simm.crw(1:500, r = 0.99, burst = "r = 0.99")
v &lt;- simm.crw(1:500, r = 0.9, burst = "r = 0.9", h = 2)
w &lt;- simm.crw(1:500, r = 0.6, burst = "r = 0.6", h = 5)
x &lt;- simm.crw(1:500, r = 0, burst = "r = 0 (Uncorrelated random walk)",
              h = 0.1)
z &lt;- c(u, v, w, x)
plot(z, addpoints = FALSE, perani = FALSE)

</code></pre>

<hr>
<h2 id='simm.levy'>Simulates a Levy Walk</h2><span id='topic+simm.levy'></span>

<h3>Description</h3>

<p>This function simulates a Levy walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simm.levy(date = 1:500, mu = 2, l0 = 1, x0 = c(0, 0),
          id = "A1", burst = id, typeII = TRUE,
          proj4string=CRS())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simm.levy_+3A_date">date</code></td>
<td>
<p>a vector indicating the date (in seconds) at which
relocations should be simulated.  This vector can be of class
<code>POSIXct</code>. *Note that the time lag between two relocations
should be constant* (regular trajectories required)</p>
</td></tr>
<tr><td><code id="simm.levy_+3A_mu">mu</code></td>
<td>
<p>The exponent of the Levy distribution</p>
</td></tr>
<tr><td><code id="simm.levy_+3A_l0">l0</code></td>
<td>
<p>The minimum length of a step</p>
</td></tr>
<tr><td><code id="simm.levy_+3A_x0">x0</code></td>
<td>
<p>a vector of length 2 containing the coordinates of the
startpoint of the trajectory</p>
</td></tr>
<tr><td><code id="simm.levy_+3A_id">id</code></td>
<td>
<p>a character string indicating the identity of the simulated
animal (see <code>help(ltraj)</code>)</p>
</td></tr>
<tr><td><code id="simm.levy_+3A_burst">burst</code></td>
<td>
<p>a character string indicating the identity of the simulated
burst (see <code>help(ltraj)</code>)</p>
</td></tr>
<tr><td><code id="simm.levy_+3A_typeii">typeII</code></td>
<td>
<p>logical.  Whether the simulated trajectory should be of
type II (<code>TRUE</code>, time recorded) or not (<code>FALSE</code>, time not
recorded). See <code>help(ltraj)</code>.</p>
</td></tr>
<tr><td><code id="simm.levy_+3A_proj4string">proj4string</code></td>
<td>
<p>a valid CRS object containing the projection
information (see <code>?CRS</code> from the package <code>sp</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates a Levy flight with exponent <code>mu</code>.
This is done by sampling a random relative angle from a uniform
distribution (-pi, pi) for each step, and a step length generated by
<code>dt * (l0 * (runif(1)^(1/(1 - mu))))</code>
</p>


<h3>Value</h3>

<p>an object of class <code>ltraj</code>
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>References</h3>

<p>Bartumeus, F., da Luz, M.G.E., Viswanathan, G.M. Catalan, J. (2005)
Animal search strategies: a quantitative random-walk
analysis. <em>Ecology</em>, <b>86</b>: 3078&ndash;3087.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chi">chi</a></code>, <code><a href="CircStats.html#topic+rwrpnorm">rwrpnorm</a></code>,
<code><a href="#topic+simm.brown">simm.brown</a></code>, <code><a href="#topic+ltraj">ltraj</a></code>,
<code><a href="#topic+simm.crw">simm.crw</a></code>, <code><a href="#topic+simm.mba">simm.mba</a></code>,
<code><a href="#topic+simm.levy">simm.levy</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(411)
w &lt;- simm.levy(1:500, mu = 1.5, burst = "mu = 1.5")
u &lt;- simm.levy(1:500, mu = 2, burst = "mu = 2")
v &lt;- simm.levy(1:500, mu = 2.5, burst = "mu = 2.5")
x &lt;- simm.levy(1:500, mu = 3, burst = "mu = 3")
par(mfrow=c(2,2))
lapply(list(w,u,v,x), plot, perani=FALSE)

</code></pre>

<hr>
<h2 id='simm.mba'>Simulation of an Arithmetic Brownian Motion</h2><span id='topic+simm.mba'></span>

<h3>Description</h3>

<p>This function simulates an Arithmetic Brownian Motion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simm.mba(date = 1:100, x0 = c(0, 0), mu = c(0, 0),
         sigma = diag(2), id = "A1", burst = id,
         proj4string=CRS())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simm.mba_+3A_date">date</code></td>
<td>
<p>a vector indicating the date (in seconds) at which
relocations should be simulated.  This vector can be of class
<code>POSIXct</code></p>
</td></tr>
<tr><td><code id="simm.mba_+3A_x0">x0</code></td>
<td>
<p>a vector of length 2 containing the coordinates of the
startpoint of the trajectory</p>
</td></tr>
<tr><td><code id="simm.mba_+3A_mu">mu</code></td>
<td>
<p>a vector of length 2 describing the drift of the movement</p>
</td></tr>
<tr><td><code id="simm.mba_+3A_sigma">sigma</code></td>
<td>
<p>a 2*2 positive definite matrix</p>
</td></tr>
<tr><td><code id="simm.mba_+3A_id">id</code></td>
<td>
<p>a character string indicating the identity of the simulated
animal (see <code>help(ltraj)</code>)</p>
</td></tr>
<tr><td><code id="simm.mba_+3A_burst">burst</code></td>
<td>
<p>a character string indicating the identity of the simulated
burst (see <code>help(ltraj)</code>)</p>
</td></tr>
<tr><td><code id="simm.mba_+3A_proj4string">proj4string</code></td>
<td>
<p>a valid CRS object containing the projection
information (see <code>?CRS</code> from the package <code>sp</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arithmetic Brownian motion (Brillinger et al. 2002) can be
described by the stochastic differential equation:
</p>
<p style="text-align: center;"><code class="reqn">d \mathbf{z}(t) = \mathbf{\mu} dt + \mathbf{\Sigma} d
    \mathbf{B}2(t)</code>
</p>

<p>Coordinates of the animal at time t are contained in the vector
<code>z(t)</code>.  <code>dz = c(dx, dy)</code> is the increment of the
movement during dt.  <code>dB2(t)</code> is a bivariate brownian Motion (see
<code>?simm.brown</code>).  The vector <code>mu</code> measures the drift of the
motion.  The matrix <code>Sigma</code> controls for perturbations due to the
random noise modeled by the Brownian motion. It can also be used to
take into account a potential correlation between the components dx
and dy of the animal moves during dt (see Examples).
</p>


<h3>Value</h3>

<p>An object of class <code>ltraj</code>
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a><br />
Stephane Dray <a href="mailto:dray@biomserv.univ-lyon1.fr">dray@biomserv.univ-lyon1.fr</a><br />
Manuela Royer <a href="mailto:royer@biomserv.univ-lyon1.fr">royer@biomserv.univ-lyon1.fr</a><br />
Daniel Chessel <a href="mailto:chessel@biomserv.univ-lyon1.fr">chessel@biomserv.univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Brillinger, D.R., Preisler, H.K., Ager, A.A. Kie, J.G. &amp; Stewart,
B.S. (2002) Employing stochastic differential equations to
model wildlife motion. <em>Bulletin of the Brazilian Mathematical
Society</em> <b>33</b>: 385&ndash;408.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+simm.brown">simm.brown</a></code>, <code><a href="#topic+ltraj">ltraj</a></code>,
<code><a href="#topic+simm.crw">simm.crw</a></code>, <code><a href="#topic+simm.mou">simm.mou</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(253)
u &lt;- simm.mba(1:1000, sigma = diag(c(4,4)), 
              burst = "Brownian motion")
v &lt;- simm.mba(1:1000, sigma = matrix(c(2,-0.8,-0.8,2), ncol = 2),
              burst = "cov(x,y) &gt; 0")
w &lt;- simm.mba(1:1000, mu = c(0.1,0), burst = "drift &gt; 0")
x &lt;- simm.mba(1:1000, mu = c(0.1,0),
              sigma = matrix(c(2, -0.8, -0.8, 2), ncol=2),
              burst = "Drift and cov(x,y) &gt; 0")
z &lt;- c(u, v, w, x)
plot(z, addpoints = FALSE, perani = FALSE)

</code></pre>

<hr>
<h2 id='simm.mou'>Simulation of a Bivariate Ornstein-Uhlenbeck Process</h2><span id='topic+simm.mou'></span>

<h3>Description</h3>

<p>This function simulates a bivariate Ornstein-Uhlenbeck process for
animal movement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simm.mou(date = 1:100, b = c(0, 0),
         a = diag(0.5, 2), x0 = b,
         sigma = diag(2), id = "A1",
         burst = id, proj4string=CRS())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simm.mou_+3A_date">date</code></td>
<td>
<p>a vector indicating the date (in seconds) at which
relocations should be simulated.  This vector can be of class
<code>POSIXct</code></p>
</td></tr>
<tr><td><code id="simm.mou_+3A_b">b</code></td>
<td>
<p>a vector of length 2 containing the coordinates of the
attraction point</p>
</td></tr>
<tr><td><code id="simm.mou_+3A_a">a</code></td>
<td>
<p>a 2*2 matrix</p>
</td></tr>
<tr><td><code id="simm.mou_+3A_x0">x0</code></td>
<td>
<p>a vector of length 2 containing the coordinates of the
startpoint of the trajectory</p>
</td></tr>
<tr><td><code id="simm.mou_+3A_sigma">sigma</code></td>
<td>
<p>a 2*2 positive definite matrix</p>
</td></tr>
<tr><td><code id="simm.mou_+3A_id">id</code></td>
<td>
<p>a character string indicating the identity of the simulated
animal (see <code>help(ltraj)</code>)</p>
</td></tr>
<tr><td><code id="simm.mou_+3A_burst">burst</code></td>
<td>
<p>a character string indicating the identity of the simulated
burst (see <code>help(ltraj)</code>)</p>
</td></tr>
<tr><td><code id="simm.mou_+3A_proj4string">proj4string</code></td>
<td>
<p>a valid CRS object containing the projection
information (see <code>?CRS</code> from the package <code>sp</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Ornstein-Uhlenbeck process can be used to take into account an
&quot;attraction point&quot; into the animal movements (Dunn and Gipson 1977).
This process can be simulated using the stochastic differential
equation: 
</p>
<p style="text-align: center;"><code class="reqn">d\mathbf{z} = \mathbf{a} ( \mathbf{b} - \mathbf{z}(t)) dt
    + \mathbf{\Sigma} d \mathbf{B2(t)}</code>
</p>

<p>The vector <code>b</code> contains the coordinates of the attraction
point. The matrix <code>a</code> (2 rows and 2 columns) contains
coefficients controlling the force of the attraction.  The matrix
<code>Sigma</code> controls the noise added to the movement (see
<code>?simm.mba</code> for details on this matrix). 
</p>


<h3>Value</h3>

<p>An object of class <code>ltraj</code>
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a><br />
Stephane Dray <a href="mailto:dray@biomserv.univ-lyon1.fr">dray@biomserv.univ-lyon1.fr</a><br />
Manuela Royer <a href="mailto:royer@biomserv.univ-lyon1.fr">royer@biomserv.univ-lyon1.fr</a><br />
Daniel Chessel <a href="mailto:chessel@biomserv.univ-lyon1.fr">chessel@biomserv.univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Dunn, J.E., &amp; Gipson, P.S. (1977) Analysis of radio telemetry data in
studies of home range. <em>Biometrics</em> <b>33</b>: 85&ndash;101. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simm.brown">simm.brown</a></code>, <code><a href="#topic+ltraj">ltraj</a></code>,
<code><a href="#topic+simm.crw">simm.crw</a></code>, <code><a href="#topic+simm.mba">simm.mba</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressWarnings(RNGversion("3.5.0"))
set.seed(253)
u &lt;- simm.mou(1:50, burst="Start at the attraction point")
v &lt;- simm.mou(1:50, x0=c(-3,3),
              burst="Start elsewhere")
w &lt;- simm.mou(1:50, a=diag(c(0.5,0.1)), x0=c(-3,3),
              burst="Variable attraction")
x &lt;- simm.mou(1:50, a=diag(c(0.1,0.5)), x0=c(-3,7),
              burst="Both")
z &lt;- c(u,v,w,x)

plot(z, addpoints = FALSE, perani = FALSE)

</code></pre>

<hr>
<h2 id='sliwinltr'>Apply a Function on an Object of Class &quot;ltraj&quot;, Using a Sliding
Window</h2><span id='topic+sliwinltr'></span>

<h3>Description</h3>

<p>This function applies a function on an object of class &quot;ltraj&quot;, using
a sliding window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sliwinltr(ltraj, fun, step, type = c("locs", "time"),
          units = c("sec", "min", "hour", "day"),
          plotit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sliwinltr_+3A_ltraj">ltraj</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="sliwinltr_+3A_fun">fun</code></td>
<td>
<p>the function to be applied, implying at least one of the
descriptive  parameters in the object of class <code>ltraj</code> (see
below)</p>
</td></tr>
<tr><td><code id="sliwinltr_+3A_step">step</code></td>
<td>
<p>the half-width of the sliding window.  If
<code>type=="locs"</code>, it is a number of relocations.  If
<code>type=="time"</code> it is a number described by <code>units</code></p>
</td></tr>
<tr><td><code id="sliwinltr_+3A_type">type</code></td>
<td>
<p>character string.  If <code>type == "locs"</code>, <code>step</code>
describes a number of relocations: if <code>type == "time"</code>,
<code>step</code> describes a time lag.</p>
</td></tr>
<tr><td><code id="sliwinltr_+3A_units">units</code></td>
<td>
<p>if <code>type == "time"</code>, the time units described by
<code>step</code>.  Ignored otherwise</p>
</td></tr>
<tr><td><code id="sliwinltr_+3A_plotit">plotit</code></td>
<td>
<p>logical.  Whether the result should be plotted</p>
</td></tr>
<tr><td><code id="sliwinltr_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function
<code>rec</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class ltraj is a list with one component per burst of
relocations.  The function <code>fun</code> is applied to each burst of
relocations.  This burst of relocations should be refered as <code>x</code>
in <code>fun</code>.  For example, to compute the mean of the distance
between successive relocations, the function <code>fun</code> is equal to
<code>function(x) mean(x$dist)</code>.
</p>
<p>Do not forget that some of the descriptive parameters in the object
<code>ltraj</code> may contain missing values (see
<code>help(ltraj)</code>).  The function should therefore specify how to
manage these missing values.
</p>


<h3>Value</h3>

<p>If <code>type=="locs"</code>, a list with one component per burst of
relocation containing the smoothed values for each relocation.
</p>
<p>If <code>type=="locs"</code>, a list with one component per burst of
relocation.  Each component is a data frame containing the time and
the corresponding smoothed values for each date.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for additional information about objects
of class <code>ltraj</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(capreotf)

## computes the average speed of the roe deer in a moving window of width
## equal to 60 minutes
toto &lt;- sliwinltr(capreotf, function(x) mean(x$dist/x$dt, na.rm = TRUE),
                  step = 30, type = "time", units = "min")

## zoom before the peak
head(toto[[1]])
plot(toto[[1]][1:538,], ty="l")

## End(Not run)
</code></pre>

<hr>
<h2 id='subsample'>Subsample a Trajectory</h2><span id='topic+subsample'></span>

<h3>Description</h3>

<p>This function subsamples a regular trajectory (i.e. changes the time
lag between successive relocations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample(ltraj, dt, nlo = 1,
          units = c("sec", "min", "hour", "day"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsample_+3A_ltraj">ltraj</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="subsample_+3A_dt">dt</code></td>
<td>
<p>numeric value.  The new time lag (should be a multiple of
the time lag in <code>ltraj</code>)</p>
</td></tr>
<tr><td><code id="subsample_+3A_nlo">nlo</code></td>
<td>
<p>an integer, or a vector of integers (with length equal to
the number of bursts in <code>ltraj</code>), indicating the position of
the first location of the new bursts in the old bursts.  For
example, if the previous time lag is equal to 300 seconds and the
new time lag is 900 seconds, the new bursts may begin at the first,
second or third relocations of the old bursts in <code>ltraj</code>.</p>
</td></tr>
<tr><td><code id="subsample_+3A_units">units</code></td>
<td>
<p>character string. The time units of <code>dt</code></p>
</td></tr>
<tr><td><code id="subsample_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ltraj</code>
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for additional information on objects of
class <code>ltraj</code>, <code><a href="#topic+is.regular">is.regular</a></code> for regular trajectories. </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(capreotf)
plot(capreotf)

toto &lt;- subsample(capreotf, dt = 900)
plot(toto)
</code></pre>

<hr>
<h2 id='teal'>Teal (Anas crecca) Ring Recovery Dataset</h2><span id='topic+teal'></span>

<h3>Description</h3>

<p>This dataset describes the location and date of recovery of 800 teal
ringed in Camargue, southern France between
January 1952 and February 1978 using standard dabbling duck funnel
traps hidden in the vegetation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(teal)</code></pre>


<h3>Format</h3>

<p>The following variables are given for each recovery:
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector giving the longitude of the
recovery</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector giving the latitude of the
recovery</p>
</dd>
<dt><code>date</code></dt><dd><p>a vector of class POSIXct containing the date of
recovery.  Actually, only the day and month have been indicated.
The year of recovery has been set to 1900 or 1901, and should not
be taken into account in the analysis.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The Camargue teal ringing program led to the recovery of 9,114 teals
after the ringing of 59,187 birds. These 800 recoveries of this
dataset are a subsample of the 4,652 birds recovered during the first
year following ringing.  Note that both the coordinates and the date
have been jittered to preserve copyright on the data.
</p>


<h3>Source</h3>

<p>La Tour du Valat. A research centre for the conservation of
Mediterranean wetlands. Le Sambuc - 13200 Arles, France.
http://en.tourduvalat.org/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(teal)

plot(teal[,1:2], asp=1,
     xlab="longitude", ylab="latitude",
     main="Capture site (red) and recoveries")

points(attr(teal, "CaptureSite"), pch=16,
       cex=2, col="red")
</code></pre>

<hr>
<h2 id='testNM'>Null Model Approach for Animal Movement Analysis</h2><span id='topic+NMs.randomCRW'></span><span id='topic+NMs.randomShiftRotation'></span><span id='topic+NMs.CRW'></span><span id='topic+NMs.randomCs'></span><span id='topic+NMs2NMm'></span><span id='topic+print.NMm'></span><span id='topic+print.NMs'></span><span id='topic+testNM'></span>

<h3>Description</h3>

<p>The functions <code>NMs.*</code> allow to define &quot;single null models&quot; (see
details).  The function <code>NMs2NMm</code> can be used on an object of
class <code>"NMs"</code> to define &quot;multiple null models&quot;.  The function
<code>testNM</code> can be used to simulate the defined null models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMs.randomCRW(ltraj, rangles = TRUE, rdist = TRUE, fixedStart = TRUE,
              x0 = NULL, rx = NULL, ry = NULL, treatment.func = NULL,
              treatment.par = NULL, constraint.func = NULL,
              constraint.par = NULL, nrep = 999)

NMs.randomShiftRotation(ltraj, rshift = TRUE, rrot = TRUE,
                        rx = NULL, ry = NULL, treatment.func = NULL,
                        treatment.par = NULL, constraint.func = NULL,
                        constraint.par = NULL, nrep = 999)


NMs.CRW(N = 1, nlocs = 100, rho = 0, h = 1, x0 = c(0,0),
        treatment.func = NULL,
        treatment.par = NULL, constraint.func = NULL,
        constraint.par = NULL, nrep = 999)


NMs.randomCs(ltraj, Cs = NULL, rDistCs = TRUE,
             rAngleCs = TRUE,
             rCentroidAngle = TRUE, rCs = TRUE,
             newCs = NULL, newDistances = NULL,
             treatment.func = NULL, treatment.par = NULL,
             constraint.func = NULL, constraint.par = NULL,
             nrep=999)

NMs2NMm(NMs, treatment.func = NULL,
        treatment.par = NULL, constraint.func = NULL,
        constraint.par = NULL, nrep = 999)

## S3 method for class 'NMm'
print(x, ...)

## S3 method for class 'NMs'
print(x, ...)

testNM(NM, count = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testNM_+3A_ltraj">ltraj</code></td>
<td>
<p>an object of class <code>"ltraj"</code></p>
</td></tr>
<tr><td><code id="testNM_+3A_rangles">rangles</code></td>
<td>
<p>logical.  Whether the turning angles should be
randomized.</p>
</td></tr>
<tr><td><code id="testNM_+3A_rdist">rdist</code></td>
<td>
<p>logical.  Whether the distances between successive
relocations should be randomized.</p>
</td></tr>
<tr><td><code id="testNM_+3A_fixedstart">fixedStart</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the first location of the
randomized trajectories corresponds to <code>x0</code>.  If <code>FALSE</code>,
the first location <code>(x, y)</code> is sampled in the interval
<code>(rx, ry)</code></p>
</td></tr>
<tr><td><code id="testNM_+3A_x0">x0</code></td>
<td>
<p>a vector of length 2 giving the x and y coordinates of the
first relocations.  If <code>NULL</code> and <code>fixedStart=TRUE</code>, the first
location of the trajectory corresponds to the first location of the
actual trajectory</p>
</td></tr>
<tr><td><code id="testNM_+3A_rx">rx</code></td>
<td>
<p>a vector of length 2 giving the x
coordinates of the bounding box where the first location of the
trajectory should be sampled</p>
</td></tr>
<tr><td><code id="testNM_+3A_ry">ry</code></td>
<td>
<p>a vector of length 2 giving the range (min, max) of the y
coordinates of the bounding box where the first location of the
trajectory should be sampled</p>
</td></tr>
<tr><td><code id="testNM_+3A_treatment.func">treatment.func</code></td>
<td>
<p>any function taking two arguments <code>x</code> and
<code>par</code>, where <code>x</code> is the trajectory generated by the
function, and par can be any R object (e.g. a list containing the
parameters needed by the function.  Note that the argument
<code>par</code> should be present in the function definition even if it
is not needed in the function). See details and examples.  If
<code>NULL</code>, a function is defined internally that simply returns
the raw trajectory simulated by the model</p>
</td></tr>
<tr><td><code id="testNM_+3A_treatment.par">treatment.par</code></td>
<td>
<p>the R object that will be passed as
an argument to the parameter <code>par</code> of the function
<code>treatment.func</code></p>
</td></tr>
<tr><td><code id="testNM_+3A_constraint.func">constraint.func</code></td>
<td>
<p>any function taking two arguments <code>x</code> and
<code>par</code>, where <code>x</code> is the trajectory generated by the
function, and par can be any R object (e.g. a list containing the
parameters needed by the function).  **This function should
necessarily return a logical value** (See details and examples).  If
<code>NULL</code>, a function is defined internally that always returns
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="testNM_+3A_constraint.par">constraint.par</code></td>
<td>
<p>The R object that will be passed as an argument
to the parameter <code>par</code> of the function <code>constraint.func</code></p>
</td></tr>
<tr><td><code id="testNM_+3A_nrep">nrep</code></td>
<td>
<p>The number of repetitions of the null model</p>
</td></tr>
<tr><td><code id="testNM_+3A_rshift">rshift</code></td>
<td>
<p>logical. Whether the trajectory should be shifted over
the study area.</p>
</td></tr>
<tr><td><code id="testNM_+3A_rrot">rrot</code></td>
<td>
<p>logical. Whether the trajectory should be rotated around
its barycentre.</p>
</td></tr>
<tr><td><code id="testNM_+3A_n">N</code></td>
<td>
<p>The number of animals to simulate.</p>
</td></tr>
<tr><td><code id="testNM_+3A_nlocs">nlocs</code></td>
<td>
<p>The number of relocations building up each trajectory</p>
</td></tr>
<tr><td><code id="testNM_+3A_rho">rho</code></td>
<td>
<p>The concentration parameter for wrapped normal distribution
of turning angles (see <code>?simm.crw</code>)</p>
</td></tr>
<tr><td><code id="testNM_+3A_h">h</code></td>
<td>
<p>the scaling parameter for the movement length  (see
<code>?simm.crw</code>)</p>
</td></tr>
<tr><td><code id="testNM_+3A_cs">Cs</code></td>
<td>
<p>a list of vectors of length 2.  Each vector should contain
the x and y coordinates of the capture sites of the animals in
<code>ltraj</code>.  This list should therefore have the same number of
elements as <code>ltraj</code></p>
</td></tr>
<tr><td><code id="testNM_+3A_rdistcs">rDistCs</code></td>
<td>
<p>logical.  Whether the distances between the barycentre
of the trajectories and the corresponding capture sites should be
randomized among trajectories</p>
</td></tr>
<tr><td><code id="testNM_+3A_ranglecs">rAngleCs</code></td>
<td>
<p>logical. Whether the angle between the east direction
and the line connecting the capture site and the barycentre of the
trajectory should be drawn from an uniform distribution.</p>
</td></tr>
<tr><td><code id="testNM_+3A_rcentroidangle">rCentroidAngle</code></td>
<td>
<p>logical.  Whether the trajectory should be
randomly rotated around its barycentre.</p>
</td></tr>
<tr><td><code id="testNM_+3A_rcs">rCs</code></td>
<td>
<p>logical. Whether the trajectory should be randomly
associated to a new capture site.</p>
</td></tr>
<tr><td><code id="testNM_+3A_newcs">newCs</code></td>
<td>
<p>a list of vectors of length 2.  Each vector should contain
the x and y coordinates of new capture sites.  If <code>NULL</code> and
<code>rcs=TRUE</code>, the new capture sites are sampled in <code>cs</code></p>
</td></tr>
<tr><td><code id="testNM_+3A_newdistances">newDistances</code></td>
<td>
<p>a vector of new distances that will be used to
define the distances between capture sites and centroid of simulated
trajectories if <code>rDistCs=TRUE</code></p>
</td></tr>
<tr><td><code id="testNM_+3A_nm">NM</code>, <code id="testNM_+3A_x">x</code></td>
<td>
<p>a null model of class <code>"NMs"</code> or <code>"NMm"</code></p>
</td></tr>
<tr><td><code id="testNM_+3A_nms">NMs</code></td>
<td>
<p>a null model of class <code>"NMs"</code></p>
</td></tr>
<tr><td><code id="testNM_+3A_count">count</code></td>
<td>
<p>whether the iterations should be displayed</p>
</td></tr>
<tr><td><code id="testNM_+3A_...">...</code></td>
<td>
<p>additionnal arguments to be passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null model approach has been considered as a useful approach in
many fields of ecology to study biological processes.  According to
Gotelli and Graves (1996), &quot;A null model is a pattern-generating model
that is based on randomization of ecological data or random sampling
from a known or imagined distribution. The null model is designed with
respect to some ecological or evolutionary process of
interest. Certain elements of the data are held constant, and others
are allowed to vary stochastically to create new assemblage
patterns. The randomization is designed to produce a pattern that
would be expected in the absence of a particular ecological
mechanism&quot;.
</p>
<p>This approach can be very useful to test hypotheses related to animal
movements.  The package adehabitatLT propose several general null
models that can be used to test biological hypotheses.  For example,
imagine that we want to test the hypothesis that no habitat selection
occurs when the animal moves.  The shape of the trajectory, under this
hypothesis would be the pure result of changing activity (moving,
foraging, resting).  Therefore, a possible approach to test whether
habitat selection actually occurs would be to randomly rotate the
trajectory around its barycentre and shifting it over the study area.
The function <code>NMs.randomShiftRotation</code> can be used to define such
a model.  It is possible to constrain the randomization by defining a
&quot;constraint function&quot; (e.g. to keep only the randomized trajectories
satisfying a given criterion).  It is required to specify a &quot;treatment
function&quot; (i.e., a function that will be applied to each randomized
trajectory).  Once the null model has been defined, it is then possible
to perform the randomizations using the function <code>testNM</code>. We
give below the details concerning the available null models, as well
as the constraint and the treatment functions.
</p>
<p>First, two types of null models can be defined: single (NMs) and
multiple (NMm) null models.  Consider an object of class
<code>"ltraj"</code> containing <code>N</code> bursts.  With NMs, the treatment
function will be applied to each randomized burst of relocations. Thus,
for example, if <code>nrep</code> repetitions of the null model are
required, <code>nrep</code> repetitions of the null models will be carried
out for each burst separately. The treatment function will be applied
on each randomized burst.  With NMm, for each repetition, <code>N</code>
randomized bursts of relocations are generated.  The treatment is then
applied, for each repetition, to the whole set of <code>N</code> randomized
bursts.  Thus, <code>NMs</code> are useful to test hypothesis on each
trajectory separately (e.g. individual habitat selection), whereas
<code>NMm</code> are useful to test hypotheses relative to the whole set of
animals stored in an object of class <code>ltraj</code> (e.g. interactions
between animals).  The only current way to define an object of class
<code>NMm</code> is to first define an object of class <code>NMs</code> and then
use the function <code>NMs2NMm</code> to indicate the treatment function
that should be applied on the whole set of trajectories.
</p>
<p>The constraint function should be user-defined. It should return a
logical value indicating whether the constraint is satisfied.  With
<code>NMs</code>, this function should take only two parameters: <code>x</code>
and <code>par</code>.  The argument <code>x</code> is a data frame with three
columns describing a trajectory (the X and Y coordinates, and the date
as a vector of class <code>"POSIXct"</code>), and the argument <code>par</code>
can be any R object required by the constraint function (e.g. if the
constraint to keep 80% of the relocations of the randomized
trajectories within a given habitat type, the parameter <code>par</code> 
can be a raster map, or a list of raster maps).  With
<code>NMm</code>, this function should also take only the two parameters
<code>x</code> and <code>par</code>.  The argument <code>par</code> can be any R object
required by the constraint function.  However, when <code>"NMm"</code> are
defined, the argument <code>x</code> of the constraint function should be an
object of class <code>"ltraj"</code>.  If the function <code>NMs2NMm</code> is
used to define the object of class <code>"NMm"</code>, two types of
constraint can therefore be defined: at the individual level (in the
function <code>NMs.*</code>) and for the whole set of animals (in the
function <code>NMs2NMm</code>).  In this case, some constraints will be
satisfied at the individual level, and others at the scale of the
whole set of animals.  If no constraint function is defined by the
user, a constraint function always returning <code>TRUE</code> is
automatically defined internally.
</p>
<p>The treatment function can be any function defined by the user, but
should take two arguments <code>x</code> and <code>par</code>, identical to those
passed to the constraint function (i.e., <code>x</code> should be a data
frame with three columns for <code>NMs</code> and an object of class
<code>"ltraj"</code> for <code>NMm</code>. Note that only one treatment function
can be applied to the randomization: if <code>NMs2NMm</code> is used to
define an object of class <code>NMm</code>, the treatment function defined
in the function <code>NMs.*</code> will be ignored, and only the treatment
function defined in the function <code>NMs2NMm</code> will be taken into
account.  If no treatment function is defined by the user, a treatment
function will be defined internally, simply returning the randomized
trajectory (i.e. a data.frame with three columns for <code>NMs</code>, and
an object of class <code>ltraj</code> for <code>NMm</code>).
</p>
<p>We now describe the list of available null models:
</p>
<p><code>NMs.CRW</code>: this model is a purely parametric model. It
simulates a correlated random walk with specified parameters (see
<code>?simm.crw</code> for a complete description of this model).
</p>
<p><code>NMs.randomCRW</code>: this model also simulates a correlated
random walk, but the distributions of the turning angles and/or
distances between successive relocations are derived from the
trajectories passed as arguments.  It is possible to randomize the
turning angles, the distances between successive relocations, or
both (default).
</p>
<p><code>NMs.randomShiftRotation</code>: this model randomly rotates the
trajectory around its barycentre and randomly shifts it over the study
area (but does not change its shape).  The function allows for a
random rotation, a random shift or both operations (default).
</p>
<p><code>NMs.randomCs</code>: this model is similar to the previous one:
it keeps the shape of the trajectory unchanged.  However, it
randomizes the position of the trajectories with respect to a set of
capture sites (it can be
used to take into account the fact that a the home range of a
sedentary animal captured at a given place is likely to be close to
this place).  First a
capture site may be randomly drawn from a list of capture sites
(either the actual capture sites or a list passed by the user). Then,
the angle between the east direction and the line connecting the
capture site of the animal and the barycentre of its trajectory is
randomly drawn from a uniform distribution.  Then, the distance
between this barycentre and the capture site is randomly drawn from
the observed distribution of distances between capture sites and
trajectory barycentre (or from a set of distances passed as
argument).  Finally, the trajectory is randomly rotated around its
barycentre.
</p>


<h3>Value</h3>

<p>For objects of class <code>"NMs"</code> a list of <code>N</code> elements (where
<code>N</code> is the number of trajectories in the object of class
<code>"ltraj"</code> passed as argument, with each element is a list storing
the <code>nrep</code> results of the treatment function applied to each randomized
trajectory.
</p>
<p>For objects of class <code>"NMm"</code>, a list of <code>nrep</code> elements,
each element storing the result of the treatment function applied to
each set of <code>N</code> randomized trajectories.
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>References</h3>

<p>Gotelli, N. and Graves, G. (1996) <em>Null models in
Ecology</em>. Smithsonian Institution Press.
</p>
<p>Richard, E., Calenge, C., Said, S., Hamann, J.L. and Gaillard,
J.M. (2012) Studying spatial interactions between sympatric
populations of large herbivores: a null model
approach. <em>Ecography</em>, in press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.ltraj">as.ltraj</a></code> for additional information about objects of
class <code>"ltraj"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
########################################
##
## example using NMs.randomShiftRotation

## first load the data:
data(puechcirc)
data(puechabonsp)
map &lt;- puechabonsp$map

## Consider the first animal
## on an elevation map
anim1 &lt;- puechcirc[1]
plot(anim1, spixdf=map[,1])

## We define a very simple treatment function
## for a NMs model: it just plots the randomized trajectory
## over the study area
## As required, the function takes two arguments:
## x is a data.frame storing a randomized trajectory (three
## columns: the x, y coordinates and the date)
## par contains the map of the study area

myfunc &lt;- function(x, par)
{
   par(mar = c(0,0,0,0))
   ## first plot the map
   image(par)

   ## then add the trajectory
   lines(x[,1], x[,2], lwd=2)
}

## Then we define the null model
##
## We define the range of the study area where the trajectory
## will be shifted:
rxy &lt;- apply(coordinates(map),2,range)
rxy

## We define the null model with 9 repetitions
nmo &lt;- NMs.randomShiftRotation(na.omit(anim1), rshift = TRUE, rrot = TRUE,
                               rx = rxy[,1], ry = rxy[,2], treatment.func = myfunc,
                               treatment.par = map, nrep=9)

## Then apply the null model
par(mfrow = c(3,3))
tmp &lt;- testNM(nmo)

## You may try variations, by setting rshift or rrot to FALSE, to see
## the differences

## Note that some of the randomized trajectories are located outside the
## study area, although all barycentres are located within the X and Y
## limits of this study area.
## We may define a constraint function returning TRUE only if all
## relocations are located within the study area

## again, note that the two parameters are x and par
consfun &lt;- function(x, par)
{
   ## first convert x to the class SpatialPointsDataFrame
   coordinates(x) &lt;- x[,1:2]

   ## then use the function over from the package sp
   ## to check whether all points in x are located inside
   ## the study area
   ov &lt;- over(x, geometry(map))
   return(all(!is.na(ov)))  
}

## Now fit again the null model under these constraints:
nmo2 &lt;- NMs.randomShiftRotation(na.omit(anim1), rshift = TRUE, rrot = TRUE,
                                rx = rxy[,1], ry = rxy[,2], treatment.func = myfunc,
                                treatment.par = map,
                                constraint.func = consfun,
                                constraint.par = map, nrep=9)

## Then apply the null model
par(mfrow = c(3,3))
tmp &lt;- testNM(nmo2)

## all the relocations are now inside the study area.


########################################
##
## example using NMs.randomCRW


## We generate correlated random walks with the same starting
## point as the original trajectory, the same turning angle
## distribution, and the same distance between relocation
## distribution. We use the same constraint function as previously
## (all relocations falling within the study area), and we
## use the same treatment function as previously (just plot
## the result).
mo &lt;- NMs.randomCRW(na.omit(anim1), rangles=TRUE, rdist=TRUE,
                    treatment.func = myfunc,
                    treatment.par = map, constraint.func=consfun,
                    constraint.par = map, nrep=9)

par(mfrow = c(3,3))
tmp &lt;- testNM(mo)

## Now, try a different treatment function: e.g. measure
## the distance between the first and last relocation,
## to test whether the animal is performing a return trip
myfunc2 &lt;- function(x, par)
{
    sqrt(sum(unlist(x[1,1:2] - x[nrow(x),1:2])^2))
}

## Now fit again the null model with this new treatment and 499 repetitions:
mo2 &lt;- NMs.randomCRW(na.omit(anim1), rangles=TRUE, rdist=TRUE,
                     treatment.func = myfunc2,
                     treatment.par = map, constraint.func=consfun,
                     constraint.par = map, nrep=499)

## Then apply the null model
suppressWarnings(RNGversion("3.5.0"))
set.seed(298) ## to make the calculation reproducible
rand &lt;- testNM(mo2)

## rand is a list with one element (there is one trajectory in anim1).
length(rand[[1]])

## The first element of rand is a list of length 499 (there are 499
## randomizations).
head(rand[[1]])

## unlist this list:
rand2 &lt;- unlist(rand[[1]])

## calculate the observed average elevation:
obs &lt;- myfunc2(na.omit(anim1)[[1]][,1:3], map)

## and performs a randomization test:
(rt &lt;- as.randtest(rand2, obs, alter="less"))
plot(rt)

## Comparing to a model where the animal is moving randomly, and based
## on the chosen criterion (distance between the first and last
## relocation), we can see that the distance between the first and last
## relocation is rarely observed.  It seems to indicate that the animal
## tends to perform a loop.



########################################
##
## example using NMs2NMm

## Given the previous results, we may try to see if all
## the trajectories in puechcirc are characterized by return
## trips
## We need a NMm approach. Because we have 3 burst in puechcirc
## we need a summary criterion. For example, the mean
## distance between the first and last relocation.

## We program a treatment function: it also takes two arguments, but x
## is now an object of class "ltraj" ! 
## par is needed, but will not be used in the function

myfunm &lt;- function(x, par)
{
   di &lt;- unlist(lapply(x, function(y) {
      sqrt(sum(unlist(y[1,1:2] - y[nrow(y),1:2])^2))
   }))
   return(mean(di))
}

## Now, prepare the NMs object: we do not indicate any treatment
## function (it would not be taken into account when NMs would be
## transformed to NMm).  However, we keep the constraint function
## the simulated trajectories should fall within the study area
mo2s &lt;- NMs.randomCRW(na.omit(puechcirc), constraint.func=consfun,
                      constraint.par = map)

## We convert this object to NMm, and we pass the treatment function
mo2m &lt;- NMs2NMm(mo2s, treatment.func = myfunm, nrep=499)

## and we fit the model
suppressWarnings(RNGversion("3.5.0"))
set.seed(908)
resu &lt;- testNM(mo2m)

## We calculate the observed mean distance between the
## first and last relocation
obs &lt;- myfunm(na.omit(puechcirc))

## and performs a randomization test:
(rt &lt;- as.randtest(unlist(resu), obs, alter="less"))
plot(rt)

## The test is no longer significant


########################################
##
## example using NMs.randomCs

## Consider this sample of 5 capture sites:
cs &lt;- list(c(701184, 3161020), c(700164, 3160473),
           c(698797, 3159908), c(699034, 3158559),
           c(701020, 3159489))
image(map)
lapply(cs, function(x) points(x[1], x[2], pch=16))

## Consider this sample of distances:
dist &lt;- c(100, 200, 150)

## change the treatment function so that the capture sites are showed as
## well. Now, par is a list with two elements: the first one is the map
## and the second one is the list of capture sites

myfunc &lt;- function(x, par)
{
   par(mar = c(0,0,0,0))
   ## first plot the map
   image(par[[1]])

   lapply(par[[2]], function(x) points(x[1], x[2], pch=16))

   ## then add the trajectory
   lines(x[,1], x[,2], lwd=2)
}


## Now define the null model, with the same constraints
## and treatment as before
mod &lt;- NMs.randomCs(na.omit(anim1), newCs=cs, newDistances=dist,
                    treatment.func=myfunc, treatment.par=list(map, cs),
                    constraint.func=consfun, constraint.par=map,
                    nrep=9)

## apply the null model
par(mfrow = c(3,3))
tmp &lt;- testNM(mod)

## End(Not run)


</code></pre>

<hr>
<h2 id='trajdyn'>Interactive Display of Objects of Class 'ltraj'</h2><span id='topic+trajdyn'></span>

<h3>Description</h3>

<p>This function provides an interactive version of <code>plot.ltraj</code>, 
for the exploration of objects of class <code>ltraj</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trajdyn(x, burst = attr(x[[1]], "burst"), hscale = 1, vscale = 1,
        recycle = TRUE, display = c("guess", "windows", "tk"), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trajdyn_+3A_x">x</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="trajdyn_+3A_burst">burst</code></td>
<td>
<p>a character string indicating the burst identity to
explore</p>
</td></tr>
<tr><td><code id="trajdyn_+3A_hscale">hscale</code></td>
<td>
<p>passed to tkrplot</p>
</td></tr>
<tr><td><code id="trajdyn_+3A_vscale">vscale</code></td>
<td>
<p>passed to tkrplot</p>
</td></tr>
<tr><td><code id="trajdyn_+3A_recycle">recycle</code></td>
<td>
<p>logical.  Whether the trajectory should be recycled
at the end of the display</p>
</td></tr>
<tr><td><code id="trajdyn_+3A_display">display</code></td>
<td>
<p>type of display.  The default <code>guess</code> uses a
windows graphics device if <code>getOption('device')=='windows'</code>,
otherwise it uses tk (requiring the <code>tkrplot</code> package).</p>
</td></tr>
<tr><td><code id="trajdyn_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function
<code>plot.ltraj</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for further information on the class
<code>ltraj</code>, and <code><a href="#topic+plot.ltraj">plot.ltraj</a></code> for information on arguments
that can be passed to this function.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Without map
data(puechcirc)
trajdyn(puechcirc)


## With map
data(puechabonsp)
trajdyn(puechcirc, spixdf = puechabonsp$map)


## End(Not run)
</code></pre>

<hr>
<h2 id='typeII2typeI'>Change the Type of a Trajectory</h2><span id='topic+typeII2typeI'></span>

<h3>Description</h3>

<p>This function transforms a trajectory of type II (time recorded) into a
trajectory of type I (time not recorded).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>typeII2typeI(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="typeII2typeI_+3A_x">x</code></td>
<td>
<p>a object of class &quot;ltraj&quot; of type II</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;ltraj&quot;
</p>


<h3>Author(s)</h3>

<p>  Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+as.ltraj">as.ltraj</a></code> for additional information on the
objects of class &quot;ltraj&quot; </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(puechcirc)
puechcirc
typeII2typeI(puechcirc)
</code></pre>

<hr>
<h2 id='wawotest'>Wald-Wolfowitz Test of Randomness</h2><span id='topic+wawotest'></span><span id='topic+wawotest.default'></span><span id='topic+wawotest.ltraj'></span>

<h3>Description</h3>

<p>The function <code>wawotest.default</code> performs a Wald Wolfowitz test of
the random distribution of the values in a vector.  The function
<code>wawotest.ltraj</code> performs this tests for the descriptive
parameters <code>dx</code>, <code>dy</code> and <code>dist</code> in an object of class
<code>ltraj</code>.  The function <code>wawotest</code> is generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wawotest(x, ...)
## Default S3 method:
wawotest(x, alter = c("greater", "less"), ...)
## S3 method for class 'ltraj'
wawotest(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wawotest_+3A_x">x</code></td>
<td>
<p>for <code>wawotest.default</code>, a vector containing the
successive observations building the series.
For <code>wawotest.ltraj</code>, an object of class <code>ltraj</code>.</p>
</td></tr>
<tr><td><code id="wawotest_+3A_alter">alter</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of &quot;greater&quot; (default), &quot;less&quot; or &quot;two-sided&quot;</p>
</td></tr>
<tr><td><code id="wawotest_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic of the test is equal to A = sum(y(i) y(i+1)),
with y(N+1) = y(1).  Under the hypothesis of a random distribution of
the values in the vector, this statistic is normally distributed, with
theoretical means and variances given in Wald &amp; Wolfowitz (1943).
</p>


<h3>Value</h3>

<p><code>wawotest.default</code> returns a vector containing the value of the
statistic (<code>a</code>), its esperance (<code>ea</code>), its variance
(<code>va</code>), the normed statistic (<code>za</code>) and the
P-value. <code>wawotest.ltraj</code> returns a table giving these values for
the descriptive parameters of the trajectory.
</p>


<h3>Author(s)</h3>

<p>  Stephane Dray <a href="mailto:dray@biomserv.univ-lyon1.fr">dray@biomserv.univ-lyon1.fr</a> </p>


<h3>References</h3>

<p>Wald, A. &amp; Wolfowitz, J. (1943) An exact test for randomness in the
non-parametric case based on serial
correlation. <em>Ann. Math. Statist.</em>, <b>14</b>, 378&ndash;388.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+indmove">indmove</a></code> and <code><a href="#topic+runsNAltraj">runsNAltraj</a></code> for other
tests of independence to be used with objects of class &quot;ltraj&quot; </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(puechcirc)
puechcirc
wawotest(puechcirc)

</code></pre>

<hr>
<h2 id='whale'>Argos Monitoring of Whale Movement</h2><span id='topic+whale'></span>

<h3>Description</h3>

<p>This data set contains the relocations of one right whale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(whale)</code></pre>


<h3>Format</h3>

<p>This data set is a regular object of class <code>ltraj</code> (i.e. constant
time lag of 24H00)
</p>


<h3>Details</h3>

<p>The coordinates are given in decimal degrees (Longitude - latitude).
</p>


<h3>Source</h3>

<p>http://whale.wheelock.edu/Welcome.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(whale)

plot(whale)

</code></pre>

<hr>
<h2 id='which.ltraj'>Identify Relocations Fullfilling a Condition in an Object of
Class &quot;ltraj&quot;</h2><span id='topic+which.ltraj'></span>

<h3>Description</h3>

<p>This function identifies the relocations fullfilling a condition in an
object of class <code>ltraj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.ltraj(ltraj, expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.ltraj_+3A_ltraj">ltraj</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="which.ltraj_+3A_expr">expr</code></td>
<td>
<p>a character string giving any syntactically correct R
logical expression implying the descriptive elements in
<code>ltraj</code> (or the name of a variable in the optional attribute
<code>infolocs</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame giving the ID, the Bursts and the relocations for which
the condition described by <code>expr</code> is verified.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ltraj">ltraj</a></code> for additional information about objects
of class <code>ltraj</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(puechcirc)
puechcirc

## Identifies the relocations for which time lag is
## upper than one hour
which.ltraj(puechcirc, "dt&gt;3600")
puechcirc[burst="CH930824"][[1]][27:28,]


## Identifies the speed between successive
## relocations upper than 0.8 meters/second
which.ltraj(puechcirc, "dist/dt &gt; 0.8")

## This is the case for example for the
## relocations #28, 58, 59 and 60 of "CH930824"
puechcirc[burst="CH930824"][[1]][c(28,58,59,60),]

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
