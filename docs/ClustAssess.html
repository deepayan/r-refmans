<!DOCTYPE html><html lang="en"><head><title>Help for package ClustAssess</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ClustAssess}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_metadata'><p>Add metadata to ClustAssess ShinyApp</p></a></li>
<li><a href='#assess_clustering_stability'><p>Assessment of Stability for Graph Clustering</p></a></li>
<li><a href='#assess_feature_stability'><p>Assess the stability for configurations of feature types and sizes</p></a></li>
<li><a href='#assess_nn_stability'><p>Assess the stability for Graph Building Parameters</p></a></li>
<li><a href='#automatic_stability_assessment'><p>Assessment of Stability for Graph Clustering</p></a></li>
<li><a href='#calculate_markers'><p>Calculate markers</p></a></li>
<li><a href='#calculate_markers_shiny'><p>Calculate markers - Shiny</p></a></li>
<li><a href='#choose_stable_clusters'><p>Choose stable clusters based on ECC and frequency</p></a></li>
<li><a href='#Clustering-class'><p>The Clustering Class</p></a></li>
<li><a href='#consensus_cluster'><p>Consensus Clustering and Proportion of Ambiguously Clustered Pairs</p></a></li>
<li><a href='#create_clustering'><p>Create Clustering Object</p></a></li>
<li><a href='#create_monocle_default'><p>Create monocle object</p></a></li>
<li><a href='#create_monocle_from_clustassess'><p>Create monocle object from a ClustAssess object</p></a></li>
<li><a href='#create_monocle_from_clustassess_app'><p>Create monocle object from a ClustAssess shiny app</p></a></li>
<li><a href='#create_seurat_object_default'><p>Create Seurat object</p></a></li>
<li><a href='#create_seurat_object_from_clustassess_app'><p>Create Seurat object from a ClustAssess shiny app</p></a></li>
<li><a href='#element_agreement'><p>Element-Wise Average Agreement Between a Set of Clusterings</p></a></li>
<li><a href='#element_consistency'><p>Element-Wise Consistency Between a Set of Clusterings</p></a></li>
<li><a href='#element_sim'><p>The Element-Centric Clustering Similarity</p></a></li>
<li><a href='#element_sim_elscore'><p>The Element-Centric Clustering Similarity for each Element</p></a></li>
<li><a href='#element_sim_matrix'><p>Pairwise Comparison of Clusterings</p></a></li>
<li><a href='#get_clusters_from_clustassess_object'><p>Extract config-specific clusters from a ClustAssess object</p></a></li>
<li><a href='#get_highest_prune_param'><p>Calculate the highest pruning parameter for the SNN graph given NN matrix</p></a></li>
<li><a href='#get_highest_prune_param_embedding'><p>Calculate the highest pruning parameter for the SNN graph given Embedding</p></a></li>
<li><a href='#get_nn_conn_comps'><p>Relationship Between Nearest Neighbours and Connected Components</p></a></li>
<li><a href='#getNNmatrix'><p>Computes the NN adjacency matrix given the neighbours</p></a></li>
<li><a href='#length+2CClustering-method'><p>Length of an Object</p></a></li>
<li><a href='#marker_overlap'><p>Cell-Wise Marker Gene Overlap</p></a></li>
<li><a href='#merge_partitions'><p>Merge Partitions</p></a></li>
<li><a href='#merge_resolutions'><p>Merge Partitions from different Resolutions</p></a></li>
<li><a href='#pac_convergence'><p>PAC Convergence Plot</p></a></li>
<li><a href='#pac_landscape'><p>PAC Landscape Plot</p></a></li>
<li><a href='#plot_clustering_difference_facet'><p>Clustering Method Stability Facet Plot</p></a></li>
<li><a href='#plot_clustering_overall_stability'><p>Clustering Method Overall Stability Boxplot</p></a></li>
<li><a href='#plot_clustering_per_value_stability'><p>Clustering Method per value Stability Boxplot</p></a></li>
<li><a href='#plot_connected_comps_evolution'><p>Relationship Between Number of Nearest Neighbours and Graph Connectivity</p></a></li>
<li><a href='#plot_feature_overall_stability_boxplot'><p>Overall Feature Stability Boxplot</p></a></li>
<li><a href='#plot_feature_overall_stability_incremental'><p>Overall Feature Stability Incremental Boxplot</p></a></li>
<li><a href='#plot_feature_per_resolution_stability_boxplot'><p>Per resolution Feature Stability Boxplot</p></a></li>
<li><a href='#plot_feature_per_resolution_stability_incremental'><p>Per resolution - Feature Stability Incremental Boxplot</p></a></li>
<li><a href='#plot_feature_stability_ecs_facet'><p>Feature Stability - EC Consistency Facet Plot</p></a></li>
<li><a href='#plot_feature_stability_mb_facet'><p>Feature Stability - Cluster Membership Facet Plot</p></a></li>
<li><a href='#plot_k_n_partitions'><p>Relationship Between the Number of Clusters and the Number of Unique Partitions</p></a></li>
<li><a href='#plot_k_resolution_corresp'><p>Correspondence Between Resolution and the Number of Clusters</p></a></li>
<li><a href='#plot_n_neigh_ecs'><p>Graph construction parameters - ECC facet</p></a></li>
<li><a href='#plot_n_neigh_k_correspondence'><p>Relationship Between Number of Nearest Neighbours and Number of Clusters</p></a></li>
<li><a href='#print+2CClustering-method'><p>Print an Object</p></a></li>
<li><a href='#server_comparisons'><p>Server - Comparison module</p></a></li>
<li><a href='#server_dimensionality_reduction'><p>Server - Dimensionality reduction module</p></a></li>
<li><a href='#server_graph_clustering'><p>Server - Graph clustering module</p></a></li>
<li><a href='#server_graph_construction'><p>Server - Graph construction module</p></a></li>
<li><a href='#server_landing_page'><p>Server - Landing page module</p></a></li>
<li><a href='#server_sandbox'><p>Server - Sandbox module</p></a></li>
<li><a href='#ui_comparisons'><p>UI - Comparison module</p></a></li>
<li><a href='#ui_dimensionality_reduction'><p>UI - Dimensionality reduction module</p></a></li>
<li><a href='#ui_graph_clustering'><p>UI - Graph clustering module</p></a></li>
<li><a href='#ui_graph_construction'><p>UI - Graph construction module</p></a></li>
<li><a href='#ui_landing_page'><p>UI - Landing page module</p></a></li>
<li><a href='#ui_sandbox'><p>UI - Sandbox module</p></a></li>
<li><a href='#weighted_element_consistency'><p>Weighted Element-Centric Consistency</p></a></li>
<li><a href='#write_objects'><p>Write the objects for the ClustAssess ShinyApp</p></a></li>
<li><a href='#write_shiny_app'><p>Create the ClustAssess ShinyApp</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Assessing Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for evaluating clustering robustness using 
    proportion of ambiguously clustered pairs (Senbabaoglu et al. (2014) 
    &lt;<a href="https://doi.org/10.1038%2Fsrep06207">doi:10.1038/srep06207</a>&gt;), as well as similarity across methods 
    and method stability using element-centric clustering comparison (Gates et 
    al. (2019) &lt;<a href="https://doi.org/10.1038%2Fs41598-019-44892-y">doi:10.1038/s41598-019-44892-y</a>&gt;). Additionally, this package 
    enables stability-based parameter assessment for graph-based clustering 
    pipelines typical in single-cell data analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://blaserlab.r-universe.dev">https://blaserlab.r-universe.dev</a></td>
</tr>
<tr>
<td>biocViews:</td>
<td>Software, SingleCell, RNASeq, ATACSeq, Normalization,
Preprocessing, DimensionReduction, Visualization,
QualityControl, Clustering, Classification, Annotation,
GeneExpression, DifferentialExpression</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), methods, stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, DT, fastcluster, foreach, glue, Gmedian, ggnewscale,
ggplot2, ggrastr, ggrepel, ggtext, gprofiler2, igraph,
jsonlite, leiden, Matrix (&ge; 1.5.0), matrixStats, progress,
stringr, paletteer, plotly, qualpalr, RANN, reshape2, rlang,
Seurat, shiny, shinyjs, shinyLP, shinyWidgets, utils, uwot,
vioplot</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BiocManager, colourpicker, ComplexHeatmap, data.table,
DelayedMatrixStats, devtools, doParallel, knitr, leidenbase,
monocle3, patchwork, ragg, reticulate, rhdf5, RhpcBLASctl,
rmarkdown, scales, SeuratObject, SharedObject, styler, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Core-Bioinformatics/ClustAssess">https://github.com/Core-Bioinformatics/ClustAssess</a>,
<a href="https://core-bioinformatics.github.io/ClustAssess/">https://core-bioinformatics.github.io/ClustAssess/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Core-Bioinformatics/ClustAssess/issues">https://github.com/Core-Bioinformatics/ClustAssess/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-31 20:53:28 UTC; am3019</td>
</tr>
<tr>
<td>Author:</td>
<td>Andi Munteanu [aut, cre],
  Arash Shahsavari [aut],
  Rafael Kollyfas [ctb],
  Miguel Larraz Lopez de Novales [aut],
  Liviu Ciortuz [ctb],
  Irina Mohorianu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andi Munteanu &lt;am3019@cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-31 22:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_metadata'>Add metadata to ClustAssess ShinyApp</h2><span id='topic+add_metadata'></span>

<h3>Description</h3>

<p>Adds new metadata into the ClustAssess ShinyApp without having
to update the object and re-create the app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_metadata(app_folder, metadata, qualpalr_colorspace = "pretty")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_metadata_+3A_app_folder">app_folder</code></td>
<td>
<p>The folder containing the ClustAssess ShinyApp</p>
</td></tr>
<tr><td><code id="add_metadata_+3A_metadata">metadata</code></td>
<td>
<p>The new metadata to be added. This parameter should be a
dataframe that follows the same row ordering as the already existing
metadata from the ClustAssess app.</p>
</td></tr>
<tr><td><code id="add_metadata_+3A_qualpalr_colorspace">qualpalr_colorspace</code></td>
<td>
<p>The colorspace to be used for the metadata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL - the metadata object is updated in the app folder
</p>

<hr>
<h2 id='assess_clustering_stability'>Assessment of Stability for Graph Clustering</h2><span id='topic+assess_clustering_stability'></span>

<h3>Description</h3>

<p>Evaluates the stability of different graph clustering methods
in the clustering pipeline. The method will iterate through different values of
the resolution parameter and compare, using the EC Consistency score, the
partitions obtained at different seeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assess_clustering_stability(
  graph_adjacency_matrix,
  resolution,
  n_repetitions = 100,
  seed_sequence = NULL,
  ecs_thresh = 1,
  clustering_algorithm = 1:3,
  clustering_arguments = list(),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assess_clustering_stability_+3A_graph_adjacency_matrix">graph_adjacency_matrix</code></td>
<td>
<p>A square adjacency matrix based on which an igraph
object will be built. The matrix should have rownames and colnames that correspond
to the names of the cells.</p>
</td></tr>
<tr><td><code id="assess_clustering_stability_+3A_resolution">resolution</code></td>
<td>
<p>A sequence of resolution values. The resolution parameter
controls the coarseness of the clustering. The higher the resolution, the more
clusters will be obtained. The resolution parameter is used in the community
detection algorithms.</p>
</td></tr>
<tr><td><code id="assess_clustering_stability_+3A_n_repetitions">n_repetitions</code></td>
<td>
<p>The number of repetitions of applying the pipeline with
different seeds; ignored if seed_sequence is provided by the user. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="assess_clustering_stability_+3A_seed_sequence">seed_sequence</code></td>
<td>
<p>A custom seed sequence; if the value is NULL, the
sequence will be built starting from 1 with a step of 100.</p>
</td></tr>
<tr><td><code id="assess_clustering_stability_+3A_ecs_thresh">ecs_thresh</code></td>
<td>
<p>The ECS threshold used for merging similar clusterings.</p>
</td></tr>
<tr><td><code id="assess_clustering_stability_+3A_clustering_algorithm">clustering_algorithm</code></td>
<td>
<p>An index or a list of indexes indicating which community detection
algorithm will be used: Louvain (1), Louvain refined (2), SLM (3) or Leiden (4).
More details can be found in the Seurat's <code>FindClusters</code> function. Defaults to <code>1:3</code>.</p>
</td></tr>
<tr><td><code id="assess_clustering_stability_+3A_clustering_arguments">clustering_arguments</code></td>
<td>
<p>A list of additional arguments that will be passed to the
clustering method. More details can be found in the Seurat's <code>FindClusters</code> function.</p>
</td></tr>
<tr><td><code id="assess_clustering_stability_+3A_verbose">verbose</code></td>
<td>
<p>Boolean value used for displaying the progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having two fields:
</p>

<ul>
<li> <p><code>all</code> - a list that contains, for each clustering method and each resolution
value, the EC consistency between the partitions obtained by changing the seed
</p>
</li>
<li> <p><code>filtered</code> - similar to <code>all</code>, but for each configuration, we determine the
number of clusters that appears the most and use only the partitions with this
size
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial PCA embedding
pca_embedding &lt;- matrix(runif(100 * 30), nrow = 100)
rownames(pca_embedding) &lt;- paste0("cell_", seq_len(nrow(pca_embedding)))
colnames(pca_embedding) &lt;- paste0("PC_", 1:30)


adj_matrix &lt;- getNNmatrix(
    RANN::nn2(pca_embedding, k = 10)$nn.idx,
    10,
    0,
    -1
)$nn
rownames(adj_matrix) &lt;- paste0("cell_", seq_len(nrow(adj_matrix)))
colnames(adj_matrix) &lt;- paste0("cell_", seq_len(ncol(adj_matrix)))

# alternatively, the adj_matrix can be calculated
# using the `Seurat::FindNeighbors` function.

clust_diff_obj &lt;- assess_clustering_stability(
    graph_adjacency_matrix = adj_matrix,
    resolution = c(0.5, 1),
    n_repetitions = 10,
    clustering_algorithm = 1:2,
    verbose = TRUE
)
plot_clustering_overall_stability(clust_diff_obj)
</code></pre>

<hr>
<h2 id='assess_feature_stability'>Assess the stability for configurations of feature types and sizes</h2><span id='topic+assess_feature_stability'></span>

<h3>Description</h3>

<p>Evaluate the stability of clusterings obtained
based on incremental subsets of a given feature set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assess_feature_stability(
  data_matrix,
  feature_set,
  steps,
  feature_type,
  resolution,
  n_repetitions = 100,
  seed_sequence = NULL,
  graph_reduction_type = "PCA",
  ecs_thresh = 1,
  matrix_processing = function(dt_mtx, actual_npcs = 30, ...) {
     actual_npcs &lt;-
    min(actual_npcs, ncol(dt_mtx)%/%2)
    
    RhpcBLASctl::blas_set_num_threads(foreach::getDoParWorkers())
     embedding &lt;-
    stats::prcomp(x = dt_mtx, rank. = actual_npcs)$x
    
    RhpcBLASctl::blas_set_num_threads(1)
     rownames(embedding) &lt;- rownames(dt_mtx)
   
     colnames(embedding) &lt;- paste0("PC_", seq_len(ncol(embedding)))
    
    return(embedding)
 },
  umap_arguments = list(),
  prune_value = -1,
  clustering_algorithm = 1,
  clustering_arguments = list(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assess_feature_stability_+3A_data_matrix">data_matrix</code></td>
<td>
<p>A data matrix having the features on the rows
and the observations on the columns.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_feature_set">feature_set</code></td>
<td>
<p>A set of feature names that can be found on the rownames
of the data matrix.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_steps">steps</code></td>
<td>
<p>Vector containing the sizes of the subsets; negative values will
be interpreted as using all features.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_feature_type">feature_type</code></td>
<td>
<p>A name associated to the feature_set.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_resolution">resolution</code></td>
<td>
<p>A vector containing the resolution values used for
clustering.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_n_repetitions">n_repetitions</code></td>
<td>
<p>The number of repetitions of applying the pipeline with
different seeds; ignored if seed_sequence is provided by the user. Defaults
to <code>100</code>.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_seed_sequence">seed_sequence</code></td>
<td>
<p>A custom seed sequence; if the value is NULL, the
sequence will be built starting from 1 with a step of 100. Defaults to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_graph_reduction_type">graph_reduction_type</code></td>
<td>
<p>The graph reduction type, denoting if the graph
should be built on either the PCA or the UMAP embedding. Defaults to <code>PCA</code>.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_ecs_thresh">ecs_thresh</code></td>
<td>
<p>The ECS threshold used for merging similar clusterings. We
recommend using the 1 value. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_matrix_processing">matrix_processing</code></td>
<td>
<p>A function that will be used to process the data
matrix
by using a dimensionality reduction technique. The function should have
one parameter, the data matrix, and should return an embedding describing the
reduced space. By default, the function will use the precise PCA method with
<code>prcomp</code>.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_umap_arguments">umap_arguments</code></td>
<td>
<p>A list containing the arguments that will be passed
to the UMAP function. Refer to the <code>uwot::umap</code> function for more details.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_prune_value">prune_value</code></td>
<td>
<p>Argument indicating whether to prune the SNN graph. If the
value is 0, the graph won't be pruned. If the value is between 0 and 1, the
edges with weight under the pruning value will be removed. If the value is
-1, the highest pruning value will be calculated automatically and used.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_clustering_algorithm">clustering_algorithm</code></td>
<td>
<p>An index indicating which community detection
algorithm will be used: Louvain (1), Louvain refined (2), SLM (3) or
Leiden (4). More details can be found in the Seurat's
<code>FindClusters</code> function.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_clustering_arguments">clustering_arguments</code></td>
<td>
<p>A list containing the arguments that will be
passed to the community detection algorithm, such as the number of iterations
and the number of starts. Refer to the Seurat's <code>FindClusters</code> function
for more details.</p>
</td></tr>
<tr><td><code id="assess_feature_stability_+3A_verbose">verbose</code></td>
<td>
<p>A boolean indicating if the intermediate progress will
be printed or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having one field associated with a step value. Each step
contains a list with three fields:
</p>

<ul>
<li><p> ecc - the EC-Consistency of the partitions obtained on all repetitions
</p>
</li>
<li><p> embedding - one UMAP embedding generated on the feature subset
</p>
</li>
<li><p> most_frequent_partition - the most common partition obtained across
repetitions
</p>
</li></ul>



<h3>Note</h3>

<p>The algorithm assumes that the feature_set is already sorted when
performing the subsetting based on the steps values. For example, if the
user wants to analyze highly variable feature set, they should provide them
sorted by their variability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial expression matrix
expr_matrix &lt;- matrix(
    c(runif(100 * 10), runif(100 * 10, min = 3, max = 4)),
    nrow = 200, byrow = TRUE
)
rownames(expr_matrix) &lt;- as.character(1:200)
colnames(expr_matrix) &lt;- paste("feature", 1:10)

feature_stability_result &lt;- assess_feature_stability(
    data_matrix = t(expr_matrix),
    feature_set = colnames(expr_matrix),
    steps = 5,
    feature_type = "feature_name",
    resolution = c(0.1, 0.5, 1),
    n_repetitions = 10,
    umap_arguments = list(
        # the following parameters are used by the umap function
        # and are not mandatory
        n_neighbors = 3,
        approx_pow = TRUE,
        n_epochs = 0,
        init = "random",
        min_dist = 0.3
    ),
    clustering_algorithm = 1
)
plot_feature_overall_stability_boxplot(feature_stability_result)
</code></pre>

<hr>
<h2 id='assess_nn_stability'>Assess the stability for Graph Building Parameters</h2><span id='topic+assess_nn_stability'></span>

<h3>Description</h3>

<p>Evaluates clustering stability when changing the values of different
parameters involved in the graph building step,
namely the base embedding, the graph type and the number of neighbours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assess_nn_stability(
  embedding,
  n_neigh_sequence,
  n_repetitions = 100,
  seed_sequence = NULL,
  graph_reduction_type = "PCA",
  ecs_thresh = 1,
  graph_type = 2,
  prune_value = -1,
  clustering_algorithm = 1,
  clustering_arguments = list(),
  umap_arguments = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assess_nn_stability_+3A_embedding">embedding</code></td>
<td>
<p>A matrix associated with a PCA embedding. Embeddings from
other dimensionality reduction techniques (such as LSI) can be used.</p>
</td></tr>
<tr><td><code id="assess_nn_stability_+3A_n_neigh_sequence">n_neigh_sequence</code></td>
<td>
<p>A sequence of the number of nearest neighbours.</p>
</td></tr>
<tr><td><code id="assess_nn_stability_+3A_n_repetitions">n_repetitions</code></td>
<td>
<p>The number of repetitions of applying the pipeline with
different seeds; ignored if seed_sequence is provided by the user.</p>
</td></tr>
<tr><td><code id="assess_nn_stability_+3A_seed_sequence">seed_sequence</code></td>
<td>
<p>A custom seed sequence; if the value is NULL,
the sequence will be built starting from 1 with a step of 100.</p>
</td></tr>
<tr><td><code id="assess_nn_stability_+3A_graph_reduction_type">graph_reduction_type</code></td>
<td>
<p>The graph reduction type, denoting if the graph
should be built on either the PCA or the UMAP embedding.</p>
</td></tr>
<tr><td><code id="assess_nn_stability_+3A_ecs_thresh">ecs_thresh</code></td>
<td>
<p>The ECS threshold used for merging similar clusterings.</p>
</td></tr>
<tr><td><code id="assess_nn_stability_+3A_graph_type">graph_type</code></td>
<td>
<p>Argument indicating whether the graph should be
unweighted (0), weighted (1) or both (2).</p>
</td></tr>
<tr><td><code id="assess_nn_stability_+3A_prune_value">prune_value</code></td>
<td>
<p>Argument indicating whether to prune the SNN graph. If the
value is 0, the graph won't be pruned. If the value is between 0 and 1, the
edges with weight under the pruning value will be removed. If the value is
-1, the highest pruning value will be calculated automatically and used.</p>
</td></tr>
<tr><td><code id="assess_nn_stability_+3A_clustering_algorithm">clustering_algorithm</code></td>
<td>
<p>An index indicating which community detection algorithm will
be used: Louvain (1), Louvain refined (2), SLM (3) or Leiden (4). More
details can be found in the Seurat's <code>FindClusters</code> function.</p>
</td></tr>
<tr><td><code id="assess_nn_stability_+3A_clustering_arguments">clustering_arguments</code></td>
<td>
<p>A list of arguments that will be passed to the
clustering algorithm. See the <code>FindClusters</code> function in Seurat for more details.</p>
</td></tr>
<tr><td><code id="assess_nn_stability_+3A_umap_arguments">umap_arguments</code></td>
<td>
<p>Additional arguments passed to the the <code>uwot::umap</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having three fields:
</p>

<ul>
<li> <p><code>n_neigh_k_corresp</code> - list containing the number of the clusters obtained by running
the pipeline multiple times with different seed, number of neighbours and graph type (weighted vs unweigted)
</p>
</li>
<li> <p><code>n_neigh_ec_consistency</code> - list containing the EC consistency of the partitions obtained
at multiple runs when changing the number of neighbours or the graph type
</p>
</li>
<li> <p><code>n_different_partitions</code> - the number of different partitions obtained by each
number of neighbours
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial PCA embedding
pca_emb &lt;- matrix(runif(100 * 30), nrow = 100, byrow = TRUE)
rownames(pca_emb) &lt;- as.character(1:100)
colnames(pca_emb) &lt;- paste0("PC_", 1:30)

nn_stability_obj &lt;- assess_nn_stability(
    embedding = pca_emb,
    n_neigh_sequence = c(10, 15, 20),
    n_repetitions = 10,
    graph_reduction_type = "PCA",
    clustering_algorithm = 1
)
plot_n_neigh_ecs(nn_stability_obj)
</code></pre>

<hr>
<h2 id='automatic_stability_assessment'>Assessment of Stability for Graph Clustering</h2><span id='topic+automatic_stability_assessment'></span>

<h3>Description</h3>

<p>Evaluates the stability of different graph clustering methods
in the clustering pipeline. The method will iterate through different values of
the resolution parameter and compare, using the EC Consistency score, the
partitions obtained at different seeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>automatic_stability_assessment(
  expression_matrix,
  n_repetitions,
  n_neigh_sequence,
  resolution_sequence,
  features_sets,
  steps,
  seed_sequence = NULL,
  graph_reduction_embedding = "PCA",
  include_umap_nn_assessment = FALSE,
  n_top_configs = 3,
  ranking_criterion = "iqr",
  overall_summary = "median",
  ecs_threshold = 1,
  matrix_processing = function(dt_mtx, actual_npcs = 30, ...) {
     actual_npcs &lt;-
    min(actual_npcs, ncol(dt_mtx)%/%2)
    
    RhpcBLASctl::blas_set_num_threads(foreach::getDoParWorkers())
     embedding &lt;-
    stats::prcomp(x = dt_mtx, rank. = actual_npcs)$x
    
    RhpcBLASctl::blas_set_num_threads(1)
     rownames(embedding) &lt;- rownames(dt_mtx)
   
     colnames(embedding) &lt;- paste0("PC_", seq_len(ncol(embedding)))
    
    return(embedding)
 },
  umap_arguments = list(),
  prune_value = -1,
  algorithm_dim_reduction = 1,
  algorithm_graph_construct = 1,
  algorithms_clustering_assessment = 1:3,
  clustering_arguments = list(),
  verbose = TRUE,
  temp_file = NULL,
  save_temp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="automatic_stability_assessment_+3A_expression_matrix">expression_matrix</code></td>
<td>
<p>An expression matrix having the features on the rows
and the cells on the columns.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_n_repetitions">n_repetitions</code></td>
<td>
<p>The number of repetitions of applying the pipeline with
different seeds; ignored if seed_sequence is provided by the user. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_n_neigh_sequence">n_neigh_sequence</code></td>
<td>
<p>A sequence of the number of nearest neighbours.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_resolution_sequence">resolution_sequence</code></td>
<td>
<p>A sequence of resolution values. The resolution parameter
controls the coarseness of the clustering. The higher the resolution, the more
clusters will be obtained. The resolution parameter is used in the community
detection algorithms.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_features_sets">features_sets</code></td>
<td>
<p>A list of the feature sets. A feature set is a list of genes
from the expression matrix that will be used in the dimensionality reduction.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_steps">steps</code></td>
<td>
<p>A list with the same names as <code>feature_sets</code>. Each name has assigned
a ector containing the sizes of the subsets; negative values will
be interpreted as using all features.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_seed_sequence">seed_sequence</code></td>
<td>
<p>A custom seed sequence; if the value is NULL, the
sequence will be built starting from 1 with a step of 100.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_graph_reduction_embedding">graph_reduction_embedding</code></td>
<td>
<p>The type of dimensionality reduction used for
the graph construction. The options are &quot;PCA&quot; and &quot;UMAP&quot;. Defaults to <code>PCA</code>.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_include_umap_nn_assessment">include_umap_nn_assessment</code></td>
<td>
<p>A boolean value indicating if the UMAP embeddings
will be used for the nearest neighbours assessment. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_n_top_configs">n_top_configs</code></td>
<td>
<p>The number of top configurations that will be used for the
downstream analysis in the dimensionality reduction step. Defaults to <code>3</code>.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_ranking_criterion">ranking_criterion</code></td>
<td>
<p>The criterion used for ranking the configurations from
the dimensionality reduction step. The options are &quot;iqr&quot;, &quot;median&quot;, &quot;max&quot;, &quot;top_qt&quot;,
&quot;top_qt_max&quot;, &quot;iqr_median&quot;, &quot;iqr_median_coeff&quot; and &quot;mean&quot;. Defaults to <code>iqr</code>.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_overall_summary">overall_summary</code></td>
<td>
<p>A function used to summarize the stability of the configurations
from the dimensionality reduction step across the different resolution values.
The options are &quot;median&quot;, &quot;max&quot;, &quot;top_qt&quot;, &quot;top_qt_max&quot;, &quot;iqr&quot;, &quot;iqr_median&quot;,
&quot;iqr_median_coeff&quot; and &quot;mean&quot;. Defaults to <code>median</code>.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_ecs_threshold">ecs_threshold</code></td>
<td>
<p>The ECS threshold used for merging similar clusterings.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_matrix_processing">matrix_processing</code></td>
<td>
<p>A function that will be used to process the data matrix
by using a dimensionality reduction technique. The function should have
one parameter, the data matrix, and should return an embedding describing the
reduced space. By default, the function will use the precise PCA method with
<code>prcomp</code>.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_umap_arguments">umap_arguments</code></td>
<td>
<p>A list containing the arguments that will be passed to the
UMAP function. Refer to the <code>uwot::umap</code> function for more details.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_prune_value">prune_value</code></td>
<td>
<p>Argument indicating whether to prune the SNN graph. If the
value is 0, the graph won't be pruned. If the value is between 0 and 1, the
edges with weight under the pruning value will be removed. If the value is
-1, the highest pruning value will be calculated automatically and used.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_algorithm_dim_reduction">algorithm_dim_reduction</code></td>
<td>
<p>An index indicating the community detection
algorithm that will be used in the Dimensionality reduction step.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_algorithm_graph_construct">algorithm_graph_construct</code></td>
<td>
<p>An index indicating the community detection
algorithm that will be used in the Graph construction step.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_algorithms_clustering_assessment">algorithms_clustering_assessment</code></td>
<td>
<p>An index indicating which community
detection algorithm will be used for the clustering step: Louvain (1),
Louvain refined (2), SLM (3) or Leiden (4). More details can be found in
the Seurat's <code>FindClusters</code> function.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_clustering_arguments">clustering_arguments</code></td>
<td>
<p>A list containing the arguments that will be passed to the
community detection algorithm, such as the number of iterations and the number of starts.
Refer to the Seurat's <code>FindClusters</code> function for more details.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_verbose">verbose</code></td>
<td>
<p>Boolean value used for displaying the progress
of the assessment.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_temp_file">temp_file</code></td>
<td>
<p>The path to the file where the object will be saved.</p>
</td></tr>
<tr><td><code id="automatic_stability_assessment_+3A_save_temp">save_temp</code></td>
<td>
<p>A boolean value indicating if the object
will be saved to a file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having two fields:
</p>

<ul>
<li><p> all - a list that contains, for each clustering method and each resolution
value, the EC consistency between the partitions obtained by changing the seed
</p>
</li>
<li><p> filtered - similar to <code>all</code>, but for each configuration, we determine the
number of clusters that appears the most and use only the partitions with this
size
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(2024)
# create an already-transposed artificial expression matrix
expr_matrix &lt;- matrix(
    c(runif(20 * 10), runif(30 * 10, min = 3, max = 4)),
    nrow = 10, byrow = FALSE
)
colnames(expr_matrix) &lt;- as.character(seq_len(ncol(expr_matrix)))
rownames(expr_matrix) &lt;- paste("feature", seq_len(nrow(expr_matrix)))

autom_object &lt;- automatic_stability_assessment(
    expression_matrix = expr_matrix,
    n_repetitions = 3,
    n_neigh_sequence = c(5),
    resolution_sequence = c(0.1, 0.5),
    features_sets = list(
        "set1" = rownames(expr_matrix)
    ),
    steps = list(
        "set1" = c(5, 7)
    ),
    umap_arguments = list(
        # the following parameters have been modified
        # from the default values to ensure that
        # the function will run under 5 seconds
        n_neighbors = 3,
        approx_pow = TRUE,
        n_epochs = 0,
        init = "random",
        min_dist = 0.3
    ),
    n_top_configs = 1,
    algorithms_clustering_assessment = 1,
    save_temp = FALSE,
    verbose = FALSE
)

# the object can be further used to plot the assessment results
plot_feature_overall_stability_boxplot(autom_object$feature_stability)
plot_n_neigh_ecs(autom_object$set1$"5"$nn_stability)
plot_k_n_partitions(autom_object$set1$"5"$clustering_stability)

## End(Not run)
</code></pre>

<hr>
<h2 id='calculate_markers'>Calculate markers</h2><span id='topic+calculate_markers'></span>

<h3>Description</h3>

<p>Performs the Wilcoxon rank sum test to identify differentially
expressed genes between two groups of cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_markers(
  expression_matrix,
  cells1,
  cells2,
  logfc_threshold = 0,
  min_pct_threshold = 0.1,
  avg_expr_threshold_group1 = 0,
  min_diff_pct_threshold = -Inf,
  rank_matrix = NULL,
  feature_names = NULL,
  used_slot = "data",
  norm_method = "SCT",
  pseudocount_use = 1,
  base = 2,
  adjust_pvals = TRUE,
  check_cells_set_diff = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_markers_+3A_expression_matrix">expression_matrix</code></td>
<td>
<p>A matrix of gene expression values having genes
in rows and cells in columns.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_cells1">cells1</code></td>
<td>
<p>A vector of cell indices for the first group of cells.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_cells2">cells2</code></td>
<td>
<p>A vector of cell indices for the second group of cells.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_logfc_threshold">logfc_threshold</code></td>
<td>
<p>The minimum absolute log fold change to consider a
gene as differentially expressed. Defaults to <code>0</code>, meaning all genes are
taken into considereation.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_min_pct_threshold">min_pct_threshold</code></td>
<td>
<p>The minimum fraction of cells expressing a gene
form each cell population to consider the gene as differentially expressed.
Increasing the value will speed up the function. Defaults to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_avg_expr_threshold_group1">avg_expr_threshold_group1</code></td>
<td>
<p>The minimum average expression that a gene
should have in the first group of cells to be considered as differentially
expressed. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_min_diff_pct_threshold">min_diff_pct_threshold</code></td>
<td>
<p>The minimum difference in the fraction of cells
expressing a gene between the two cell populations to consider the gene as
differentially expressed. Defaults to <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_rank_matrix">rank_matrix</code></td>
<td>
<p>A matrix where the cells are ranked based on their
expression levels with respect to each gene. Defaults to <code>NULL</code>, in which
case the function will calculate the rank matrix. We recommend calculating
the rank matrix beforehand and passing it to the function to speed up the
computation.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_feature_names">feature_names</code></td>
<td>
<p>A vector of gene names. Defaults to <code>NULL</code>, in which
case the function will use the row names of the expression matrix as gene
names.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_used_slot">used_slot</code></td>
<td>
<p>Parameter that provides additional information about the
expression matrix, whether it was scaled or not. The value of this parameter
impacts the calculation of the fold change. If <code>data</code>, the function will
calculates the fold change as the fraction between the log value of the
average of the expression raised to exponential for the two cell groups. If
<code>scale.data</code>, the function will calculate the fold change as the fraction
between the average of the expression values for the two cell groups.
Other options will default to calculating the fold change as the fraction
between the log value of the average of the expression values for the two
cell groups. Defaults to <code>data</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_norm_method">norm_method</code></td>
<td>
<p>The normalization method used to normalize the expression
matrix. The value of this parameter impacts the calculation of the average
expression of the genes when <code>used_slot = "data"</code>. If <code>LogNormalize</code>, the
log fold change will be calculated as described for the <code>used_slot</code>
parameter. Otherwise, the log fold change will be calculated as the fraction
between the log value of the average of the expression values for the two
cell groups. Defaults to <code>SCT</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_pseudocount_use">pseudocount_use</code></td>
<td>
<p>The pseudocount to add to the expression values when
calculating the average expression of the genes, to avoid the 0 value for
the denominator. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_base">base</code></td>
<td>
<p>The base of the logharithm. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_adjust_pvals">adjust_pvals</code></td>
<td>
<p>A logical value indicating whether to adjust the p-values
for multiple testing using the Bonferonni method. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_+3A_check_cells_set_diff">check_cells_set_diff</code></td>
<td>
<p>A logical value indicating whether to check if
thw two cell groups are disjoint or not. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following columns:
</p>

<ul>
<li> <p><code>gene</code>: The gene name.
</p>
</li>
<li> <p><code>avg_log2FC</code>: The average log fold change between the two cell groups.
</p>
</li>
<li> <p><code>p_val</code>: The p-value of the Wilcoxon rank sum test.
</p>
</li>
<li> <p><code>p_val_adj</code>: The adjusted p-value of the Wilcoxon rank sum test.
</p>
</li>
<li> <p><code>pct.1</code>: The fraction of cells expressing the gene in the first cell group.
</p>
</li>
<li> <p><code>pct.2</code>: The fraction of cells expressing the gene in the second cell group.
</p>
</li>
<li> <p><code>avg_expr_group1</code>: The average expression of the gene in the first cell group.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial expression matrix
expr_matrix &lt;- matrix(
    c(runif(100 * 50), runif(100 * 50, min = 3, max = 4)),
    ncol = 200, byrow = FALSE
)
colnames(expr_matrix) &lt;- as.character(1:200)
rownames(expr_matrix) &lt;- paste("feature", 1:50)

calculate_markers(
    expression_matrix = expr_matrix,
    cells1 = 101:200,
    cells2 = 1:100
)
# TODO should be rewritten such that you don't create new matrix objects inside
# just
</code></pre>

<hr>
<h2 id='calculate_markers_shiny'>Calculate markers - Shiny</h2><span id='topic+calculate_markers_shiny'></span>

<h3>Description</h3>

<p>Performs the Wilcoxon rank sum test to identify differentially
expressed genes between two groups of cells in the shiny context. The
method can be also used outside the shiny context, as long as the expression
matrix is stored in a h5 file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_markers_shiny(
  cells1,
  cells2,
  logfc_threshold = 0,
  min_pct_threshold = 0.1,
  average_expression_threshold = 0,
  average_expression_group1_threshold = 0,
  min_diff_pct_threshold = -Inf,
  used_slot = "data",
  norm_method = "SCT",
  expression_h5_path = "expression.h5",
  pseudocount_use = 1,
  base = 2,
  verbose = TRUE,
  check_difference = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_markers_shiny_+3A_cells1">cells1</code></td>
<td>
<p>A vector of cell indices for the first group of cells.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_cells2">cells2</code></td>
<td>
<p>A vector of cell indices for the second group of cells.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_logfc_threshold">logfc_threshold</code></td>
<td>
<p>The minimum absolute log fold change to consider a
gene as differentially expressed. Defaults to <code>0</code>, meaning all genes are
taken into considereation.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_min_pct_threshold">min_pct_threshold</code></td>
<td>
<p>The minimum fraction of cells expressing a gene
form each cell population to consider the gene as differentially expressed.
Increasing the value will speed up the function. Defaults to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_average_expression_threshold">average_expression_threshold</code></td>
<td>
<p>The minimum average expression that a
gene should have in order to be considered as differentially expressed.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_average_expression_group1_threshold">average_expression_group1_threshold</code></td>
<td>
<p>The minimum average expression
that a gene should have in the first group of cells to be considered as
differentially expressed. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_min_diff_pct_threshold">min_diff_pct_threshold</code></td>
<td>
<p>The minimum difference in the fraction of cells
expressing a gene between the two cell populations to consider the gene as
differentially expressed. Defaults to <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_used_slot">used_slot</code></td>
<td>
<p>Parameter that provides additional information about the
expression matrix, whether it was scaled or not. The value of this parameter
impacts the calculation of the fold change. If <code>data</code>, the function will
calculates the fold change as the fraction between the log value of the
average of the expression raised to exponential for the two cell groups. If
<code>scale.data</code>, the function will calculate the fold change as the fraction
between the average of the expression values for the two cell groups.
Other options will default to calculating the fold change as the fraction
between the log value of the average of the expression values for the two
cell groups. Defaults to <code>data</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_norm_method">norm_method</code></td>
<td>
<p>The normalization method used to normalize the expression
matrix. The value of this parameter impacts the calculation of the average
expression of the genes when <code>used_slot = "data"</code>. If <code>LogNormalize</code>, the
log fold change will be calculated as described for the <code>used_slot</code>
parameter. Otherwise, the log fold change will be calculated as the fraction
between the log value of the average of the expression values for the two
cell groups. Defaults to <code>SCT</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_expression_h5_path">expression_h5_path</code></td>
<td>
<p>The path to the h5 file containing the expression
matrix. The h5 file should contain the following fields: <code>expression_matrix</code>,
<code>rank_matrix</code>, <code>average_expression</code>, <code>genes</code>. The file path
defaults to <code>expression.h5</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_pseudocount_use">pseudocount_use</code></td>
<td>
<p>The pseudocount to add to the expression values when
calculating the average expression of the genes, to avoid the 0 value for
the denominator. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_base">base</code></td>
<td>
<p>The base of the logharithm. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print messages about the progress of the function.
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="calculate_markers_shiny_+3A_check_difference">check_difference</code></td>
<td>
<p>Whether to perform set difference between the two
cells. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following columns:
</p>

<ul>
<li> <p><code>gene</code>: The gene name.
</p>
</li>
<li> <p><code>avg_log2FC</code>: The average log fold change between the two cell groups.
</p>
</li>
<li> <p><code>p_val</code>: The p-value of the Wilcoxon rank sum test.
</p>
</li>
<li> <p><code>p_val_adj</code>: The adjusted p-value of the Wilcoxon rank sum test.
</p>
</li>
<li> <p><code>pct.1</code>: The fraction of cells expressing the gene in the first cell group.
</p>
</li>
<li> <p><code>pct.2</code>: The fraction of cells expressing the gene in the second cell group.
</p>
</li>
<li> <p><code>avg_expr_group1</code>: The average expression of the gene in the first cell group.
</p>
</li>
<li> <p><code>avg_expr</code>: The average expression of the gene.
</p>
</li></ul>


<hr>
<h2 id='choose_stable_clusters'>Choose stable clusters based on ECC and frequency</h2><span id='topic+choose_stable_clusters'></span>

<h3>Description</h3>

<p>Filter the list of clusters obtained by the automatic
ClustAssess pipeline using the ECC and frequency thresholds. The ECC
threshold is meant to filter out the partitions that are highly sensitive
to the change of the random seed, while the purpose of the frequency
threshold is to assure a statistical significance of the inferred stability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choose_stable_clusters(
  clusters_list,
  ecc_threshold = 0.9,
  freq_threshold = 30,
  summary_function = mean
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choose_stable_clusters_+3A_clusters_list">clusters_list</code></td>
<td>
<p>List of clusters obtained from the
<code>get_clusters_from_clustassess_object</code> function.</p>
</td></tr>
<tr><td><code id="choose_stable_clusters_+3A_ecc_threshold">ecc_threshold</code></td>
<td>
<p>Minimum ECC value to consider a cluster as stable.
Default is 0.9.</p>
</td></tr>
<tr><td><code id="choose_stable_clusters_+3A_freq_threshold">freq_threshold</code></td>
<td>
<p>Minimum total frequency of the partitions to consider.
Default is 30.</p>
</td></tr>
<tr><td><code id="choose_stable_clusters_+3A_summary_function">summary_function</code></td>
<td>
<p>Function to summarize the ECC values. Default
is <code>mean</code>. To match the results from the ClustAssess Shiny App, use
<code>median</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of stable clusters that satisfy the ECC and frequency.
</p>

<hr>
<h2 id='Clustering-class'>The Clustering Class</h2><span id='topic+Clustering-class'></span><span id='topic+Clustering'></span>

<h3>Description</h3>

<p>A class containing relevant data for comparing clusterings,
including the affinity matrix for the Clustering.
</p>


<h3>Slots</h3>


<dl>
<dt><code>names</code></dt><dd><p>A character vector of element names; will be 1:n_elements if no
names were available when creating the Clustering object.</p>
</dd>
<dt><code>n_elements</code></dt><dd><p>A numeric giving the number of elements.</p>
</dd>
<dt><code>is_hierarchical</code></dt><dd><p>A logical indicating whether the clustering is
hierarchical or flat.</p>
</dd>
<dt><code>is_disjoint</code></dt><dd><p>A logical indicating whether the clustering is disjoint or
overlapping.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</dd>
<dt><code>r</code></dt><dd><p>A numeric hierarchical scaling parameter.</p>
</dd>
<dt><code>elm2clu_dict</code></dt><dd><p>A list giving the clusters each element is a member of.</p>
</dd>
<dt><code>clu2elm_dict</code></dt><dd><p>A list giving the element members of each cluster.</p>
</dd>
<dt><code>affinity_matrix</code></dt><dd><p>A Matrix containing the personalized pagerank
equilibrium distribution.</p>
</dd>
</dl>

<hr>
<h2 id='consensus_cluster'>Consensus Clustering and Proportion of Ambiguously Clustered Pairs</h2><span id='topic+consensus_cluster'></span>

<h3>Description</h3>

<p>Calculate consensus clustering and proportion of ambiguously
clustered pairs (PAC) with hierarchical clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus_cluster(
  x,
  k_min = 3,
  k_max = 100,
  n_reps = 100,
  p_sample = 0.8,
  p_feature = 1,
  p_minkowski = 2,
  dist_method = "euclidean",
  linkage = "complete",
  lower_lim = 0.1,
  upper_lim = 0.9,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consensus_cluster_+3A_x">x</code></td>
<td>
<p>A samples x features normalized data matrix.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_k_min">k_min</code></td>
<td>
<p>The minimum number of clusters calculated.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_k_max">k_max</code></td>
<td>
<p>The maximum number of clusters calculated.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_n_reps">n_reps</code></td>
<td>
<p>The total number of subsamplings and reclusterings of the data;
this value needs to be high enough to ensure PAC converges; convergence can
be assessed with pac_convergence.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_p_sample">p_sample</code></td>
<td>
<p>The proportion of samples included in each subsample.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_p_feature">p_feature</code></td>
<td>
<p>The proportion of features included in each subsample.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_p_minkowski">p_minkowski</code></td>
<td>
<p>The power of the Minkowski distance.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_dist_method">dist_method</code></td>
<td>
<p>The distance measure for the distance matrix used in
hclust; must be one of &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;,
&quot;binary&quot; or &quot;minkowski&quot;.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_linkage">linkage</code></td>
<td>
<p>The linkage method used in hclust; must be one of &quot;ward.D&quot;,
&quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot; or
&quot;centroid&quot;</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_lower_lim">lower_lim</code></td>
<td>
<p>The lower limit for determining whether a pair is
clustered ambiguously; the lower this value, the higher the PAC.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_upper_lim">upper_lim</code></td>
<td>
<p>The upper limit for determining whether a pair is
clustered ambiguously; the higher this value, the higher the PAC.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_verbose">verbose</code></td>
<td>
<p>Logical value used for choosing to display a progress bar or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with PAC values across iterations, as well as parameter
values used when calling the method.
</p>


<h3>References</h3>

<p>Monti, S., Tamayo, P., Mesirov, J., &amp; Golub, T. (2003).
Consensus clustering: a resampling-based method for class discovery and
visualization of gene expression microarray data. Machine learning, 52(1),
91-118. https://doi.org/10.1023/A:1023949509487
</p>
<p>Senbabaoglu, Y., Michailidis, G., &amp; Li, J. Z. (2014).
Critical limitations of consensus clustering in class discovery.
Scientific reports, 4(1), 1-13. https://doi.org/10.1038/srep06207
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pac.res &lt;- consensus_cluster(iris[, 1:4], k_max = 20)
pac_convergence(pac.res, k_plot = c(3, 5, 7, 9))
</code></pre>

<hr>
<h2 id='create_clustering'>Create Clustering Object</h2><span id='topic+create_clustering'></span><span id='topic+create_clustering+2Cnumeric-method'></span><span id='topic+create_clustering+2Cinteger-method'></span><span id='topic+create_clustering+2Ccharacter-method'></span><span id='topic+create_clustering+2Cfactor-method'></span><span id='topic+create_clustering+2Cmatrix-method'></span><span id='topic+create_clustering+2CMatrix-method'></span><span id='topic+create_clustering+2Chclust-method'></span>

<h3>Description</h3>

<p>Creates a Clustering object from the output of a clustering
method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_clustering(clustering_result, ...)

## S4 method for signature 'numeric'
create_clustering(clustering_result, alpha = 0.9)

## S4 method for signature 'integer'
create_clustering(clustering_result, alpha = 0.9)

## S4 method for signature 'character'
create_clustering(clustering_result, alpha = 0.9)

## S4 method for signature 'factor'
create_clustering(clustering_result, alpha = 0.9)

## S4 method for signature 'matrix'
create_clustering(
  clustering_result,
  alpha = 0.9,
  ppr_implementation = "prpack",
  row_normalize = TRUE
)

## S4 method for signature 'Matrix'
create_clustering(
  clustering_result,
  alpha = 0.9,
  ppr_implementation = "prpack",
  row_normalize = TRUE
)

## S4 method for signature 'hclust'
create_clustering(
  clustering_result,
  alpha = 0.9,
  r = 1,
  rescale_path_type = "max",
  ppr_implementation = "prpack",
  dist_rescaled = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_clustering_+3A_clustering_result">clustering_result</code></td>
<td>
<p>The clustering result, either:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="create_clustering_+3A_...">...</code></td>
<td>
<p>This argument is not used.</p>
</td></tr>
<tr><td><code id="create_clustering_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</td></tr>
<tr><td><code id="create_clustering_+3A_ppr_implementation">ppr_implementation</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="create_clustering_+3A_row_normalize">row_normalize</code></td>
<td>
<p>Whether to normalize all rows in clustering_result
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
<tr><td><code id="create_clustering_+3A_r">r</code></td>
<td>
<p>A numeric hierarchical scaling parameter.</p>
</td></tr>
<tr><td><code id="create_clustering_+3A_rescale_path_type">rescale_path_type</code></td>
<td>
<p>A string; rescale the hierarchical height by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="create_clustering_+3A_dist_rescaled">dist_rescaled</code></td>
<td>
<p>A logical: if TRUE, the linkage distances are linearly
rescaled to be in-between 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Clustering object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>create_clustering(numeric)</code>: Create Clustering Object from Numeric Vector
</p>
</li>
<li> <p><code>create_clustering(integer)</code>: Create Clustering Object from Integer Vector
</p>
</li>
<li> <p><code>create_clustering(character)</code>: Create Clustering Object from Character Vector
</p>
</li>
<li> <p><code>create_clustering(factor)</code>: Create Clustering Object from Factor Vector
</p>
</li>
<li> <p><code>create_clustering(matrix)</code>: Create Clustering Object from base matrix
</p>
</li>
<li> <p><code>create_clustering(Matrix)</code>: Create Clustering Object from Matrix::Matrix
</p>
</li>
<li> <p><code>create_clustering(hclust)</code>: Create Clustering Object from hclust
</p>
</li></ul>

<hr>
<h2 id='create_monocle_default'>Create monocle object</h2><span id='topic+create_monocle_default'></span>

<h3>Description</h3>

<p>Use a normalized expression matrix and, potentially, an already
generated PCA / UMAP embedding, to create a Monocle object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_monocle_default(
  normalized_expression_matrix,
  count_matrix = NULL,
  pca_embedding = NULL,
  umap_embedding = NULL,
  metadata_df = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_monocle_default_+3A_normalized_expression_matrix">normalized_expression_matrix</code></td>
<td>
<p>The normalized expression matrix
having genes on rows and cells on columns.</p>
</td></tr>
<tr><td><code id="create_monocle_default_+3A_count_matrix">count_matrix</code></td>
<td>
<p>The count matrix having genes on rows and cells on
columns. If NULL, the normalized_expression_matrix will be used.</p>
</td></tr>
<tr><td><code id="create_monocle_default_+3A_pca_embedding">pca_embedding</code></td>
<td>
<p>The PCA embedding of the expression matrix. If NULL, the
pca will be created using the <code>monocle3</code> package (default parameters).</p>
</td></tr>
<tr><td><code id="create_monocle_default_+3A_umap_embedding">umap_embedding</code></td>
<td>
<p>The UMAP embedding of the expression matrix. If NULL, the
umap will be created using the <code>monocle3</code> package (default parameters).</p>
</td></tr>
<tr><td><code id="create_monocle_default_+3A_metadata_df">metadata_df</code></td>
<td>
<p>The metadata dataframe having the cell names as rownames.
If NULL, a dataframe with a single column named <code>identical_ident</code> will be
created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Monocle object of the expression matrix, having the stable number
of clusters identified by ClustAssess.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(2024)
# create an already-transposed artificial expression matrix
expr_matrix &lt;- matrix(
    c(runif(20 * 10), runif(30 * 10, min = 3, max = 4)),
    nrow = 10, byrow = FALSE
)
colnames(expr_matrix) &lt;- as.character(seq_len(ncol(expr_matrix)))
rownames(expr_matrix) &lt;- paste("feature", seq_len(nrow(expr_matrix)))

# uncomment to create the monocle object
mon_obj &lt;- create_monocle_default(
    normalized_expression_matrix = expr_matrix,
    pca_emb = NULL,
    umap_emb = NULL,
    metadata_df = NULL
)

## End(Not run)
</code></pre>

<hr>
<h2 id='create_monocle_from_clustassess'>Create monocle object from a ClustAssess object</h2><span id='topic+create_monocle_from_clustassess'></span>

<h3>Description</h3>

<p>Use the object generated using the ClustAssess
<code>automatic_stability_assessment</code> function to create a Monocle object
which has the stable number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_monocle_from_clustassess(
  normalized_expression_matrix,
  count_matrix = NULL,
  clustassess_object,
  metadata_df,
  stable_feature_type,
  stable_feature_set_size,
  stable_clustering_method,
  stable_n_clusters = NULL,
  use_all_genes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_monocle_from_clustassess_+3A_normalized_expression_matrix">normalized_expression_matrix</code></td>
<td>
<p>The normalized expression matrix
having genes on rows and cells on columns.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_+3A_count_matrix">count_matrix</code></td>
<td>
<p>The count matrix having genes on rows and cells on
columns. If NULL, the normalized_expression_matrix will be used.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_+3A_clustassess_object">clustassess_object</code></td>
<td>
<p>The output of the <code>automatic_stability_assessment</code>.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_+3A_metadata_df">metadata_df</code></td>
<td>
<p>The metadata dataframe having the cell names as rownames.
If NULL, a dataframe with a single column named <code>identical_ident</code> will be
created.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_+3A_stable_feature_type">stable_feature_type</code></td>
<td>
<p>The feature type which leads to stable clusters.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_+3A_stable_feature_set_size">stable_feature_set_size</code></td>
<td>
<p>The feature size which leads to stable
clusters.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_+3A_stable_clustering_method">stable_clustering_method</code></td>
<td>
<p>The clustering method which leads to stable
clusters.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_+3A_stable_n_clusters">stable_n_clusters</code></td>
<td>
<p>The number of clusters that are stable. If NULL,
all the clusters will be provided. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_+3A_use_all_genes">use_all_genes</code></td>
<td>
<p>A boolean value indicating if the expression matrix
should be truncated to the genes used in the stability assessment. Defaults
to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Monocle object of the expression matrix, having the stable number
of clusters identified by ClustAssess.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(2024)
# create an already-transposed artificial expression matrix
expr_matrix &lt;- matrix(
    c(runif(20 * 10), runif(30 * 10, min = 3, max = 4)),
    nrow = 10, byrow = FALSE
)
colnames(expr_matrix) &lt;- as.character(seq_len(ncol(expr_matrix)))
rownames(expr_matrix) &lt;- paste("feature", seq_len(nrow(expr_matrix)))

autom_object &lt;- automatic_stability_assessment(
    expression_matrix = expr_matrix,
    n_repetitions = 3,
    n_neigh_sequence = c(5),
    resolution_sequence = c(0.1, 0.5),
    features_sets = list(
        "set1" = rownames(expr_matrix)
    ),
    steps = list(
        "set1" = c(5, 7)
    ),
    umap_arguments = list(
        # the following parameters have been modified
        # from the default values to ensure that the function
        # will run under 5 seconds
        n_neighbors = 3,
        approx_pow = TRUE,
        n_epochs = 0,
        init = "random",
        min_dist = 0.3
    ),
    n_top_configs = 1,
    algorithms_clustering_assessment = 1,
    save_temp = FALSE,
    verbose = FALSE
)


# uncomment to create the monocle object
# mon_obj &lt;- create_monocle_from_clustassess(
#     normalized_expression_matrix = expr_matrix,
#     clustassess_object = autom_object,
#     metadata = NULL,
#     stable_feature_type = "set1",
#     stable_feature_set_size = "5",
#     stable_clustering_method = "Louvain"
# )

## End(Not run)
</code></pre>

<hr>
<h2 id='create_monocle_from_clustassess_app'>Create monocle object from a ClustAssess shiny app</h2><span id='topic+create_monocle_from_clustassess_app'></span>

<h3>Description</h3>

<p>Use the files generated in the ClustAssess app to create a
Monocle object which has the stable number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_monocle_from_clustassess_app(
  app_folder,
  stable_feature_type,
  stable_feature_set_size,
  stable_clustering_method,
  stable_n_clusters = NULL,
  use_all_genes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_monocle_from_clustassess_app_+3A_app_folder">app_folder</code></td>
<td>
<p>Path pointing to the folder containing a ClustAssess app.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_app_+3A_stable_feature_type">stable_feature_type</code></td>
<td>
<p>The feature type which leads to stable clusters.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_app_+3A_stable_feature_set_size">stable_feature_set_size</code></td>
<td>
<p>The feature size which leads to stable
clusters.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_app_+3A_stable_clustering_method">stable_clustering_method</code></td>
<td>
<p>The clustering method which leads to stable
clusters.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_app_+3A_stable_n_clusters">stable_n_clusters</code></td>
<td>
<p>The number of clusters that are stable. If NULL,
all the clusters will be provided. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create_monocle_from_clustassess_app_+3A_use_all_genes">use_all_genes</code></td>
<td>
<p>A boolean value indicating if the expression matrix
should be truncated to the genes used in the stability assessment. Defaults
to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Monocle object of the expression matrix, having the stable number
of clusters identified by ClustAssess.
</p>

<hr>
<h2 id='create_seurat_object_default'>Create Seurat object</h2><span id='topic+create_seurat_object_default'></span>

<h3>Description</h3>

<p>Use a normalized expression matrix and, potentially, an already
generated PCA / UMAP embedding, to create a Seurat object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_seurat_object_default(
  normalized_expression_matrix,
  count_matrix = NULL,
  pca_embedding = NULL,
  umap_embedding = NULL,
  metadata_df = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_seurat_object_default_+3A_normalized_expression_matrix">normalized_expression_matrix</code></td>
<td>
<p>The normalized expression matrix
having genes on rows and cells on columns.</p>
</td></tr>
<tr><td><code id="create_seurat_object_default_+3A_count_matrix">count_matrix</code></td>
<td>
<p>The count matrix having genes on rows and cells on
columns. If NULL, the normalized_expression_matrix will be used.</p>
</td></tr>
<tr><td><code id="create_seurat_object_default_+3A_pca_embedding">pca_embedding</code></td>
<td>
<p>The PCA embedding of the expression matrix. If NULL, the
pca will be created using the <code>Seurat</code> package (default parameters).</p>
</td></tr>
<tr><td><code id="create_seurat_object_default_+3A_umap_embedding">umap_embedding</code></td>
<td>
<p>The UMAP embedding of the expression matrix. If NULL, the
umap will be created using the <code>Seurat</code> package (default parameters).</p>
</td></tr>
<tr><td><code id="create_seurat_object_default_+3A_metadata_df">metadata_df</code></td>
<td>
<p>The metadata dataframe having the cell names as rownames.
If NULL, a dataframe with a single column named <code>identical_ident</code> will be
created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object of the expression matrix, having the stable number
of clusters identified by ClustAssess.
</p>

<hr>
<h2 id='create_seurat_object_from_clustassess_app'>Create Seurat object from a ClustAssess shiny app</h2><span id='topic+create_seurat_object_from_clustassess_app'></span>

<h3>Description</h3>

<p>Use the files generated in the ClustAssess app to create a
Seurat object which has the stable number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_seurat_object_from_clustassess_app(
  app_folder,
  stable_feature_type,
  stable_feature_set_size,
  stable_clustering_method,
  stable_n_clusters = NULL,
  use_all_genes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_seurat_object_from_clustassess_app_+3A_app_folder">app_folder</code></td>
<td>
<p>Path pointing to the folder containing a ClustAssess app.</p>
</td></tr>
<tr><td><code id="create_seurat_object_from_clustassess_app_+3A_stable_feature_type">stable_feature_type</code></td>
<td>
<p>The feature type which leads to stable clusters.</p>
</td></tr>
<tr><td><code id="create_seurat_object_from_clustassess_app_+3A_stable_feature_set_size">stable_feature_set_size</code></td>
<td>
<p>The feature size which leads to stable
clusters.</p>
</td></tr>
<tr><td><code id="create_seurat_object_from_clustassess_app_+3A_stable_clustering_method">stable_clustering_method</code></td>
<td>
<p>The clustering method which leads to stable
clusters.</p>
</td></tr>
<tr><td><code id="create_seurat_object_from_clustassess_app_+3A_stable_n_clusters">stable_n_clusters</code></td>
<td>
<p>The number of clusters that are stable. If NULL,
all the clusters will be provided. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create_seurat_object_from_clustassess_app_+3A_use_all_genes">use_all_genes</code></td>
<td>
<p>A boolean value indicating if the expression matrix
should be truncated to the genes used in the stability assessment. Defaults
to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object of the expression matrix, having the stable number
of clusters identified by ClustAssess.
</p>

<hr>
<h2 id='element_agreement'>Element-Wise Average Agreement Between a Set of Clusterings</h2><span id='topic+element_agreement'></span>

<h3>Description</h3>

<p>Inspect how consistently of a set of clusterings agree with
a reference clustering by calculating their element-wise average agreement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_agreement(
  reference_clustering,
  clustering_list,
  alpha = 0.9,
  r = 1,
  rescale_path_type = "max",
  ppr_implementation = "prpack",
  dist_rescaled = FALSE,
  row_normalize = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="element_agreement_+3A_reference_clustering">reference_clustering</code></td>
<td>
<p>The reference clustering, that each clustering in
clustering_list is compared to. It can be either:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_agreement_+3A_clustering_list">clustering_list</code></td>
<td>
<p>The list of clustering results, each of which is either:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_agreement_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</td></tr>
<tr><td><code id="element_agreement_+3A_r">r</code></td>
<td>
<p>A numeric hierarchical scaling parameter.</p>
</td></tr>
<tr><td><code id="element_agreement_+3A_rescale_path_type">rescale_path_type</code></td>
<td>
<p>A string; rescale the hierarchical height by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_agreement_+3A_ppr_implementation">ppr_implementation</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_agreement_+3A_dist_rescaled">dist_rescaled</code></td>
<td>
<p>A logical: if TRUE, the linkage distances are linearly
rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_agreement_+3A_row_normalize">row_normalize</code></td>
<td>
<p>Whether to normalize all rows in clustering_result
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the element-wise average agreement.
</p>


<h3>References</h3>

<p>Gates, A. J., Wood, I. B., Hetrick, W. P., &amp; Ahn, Y. Y. (2019).
Element-centric clustering comparison unifies overlaps and hierarchy.
Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y
</p>


<h3>Examples</h3>

<pre><code class='language-R'># perform k-means clustering across 20 random seeds
reference.clustering &lt;- iris$Species
clustering.list &lt;- lapply(1:20, function(x) kmeans(iris[, 1:4], centers = 3)$cluster)
element_agreement(reference.clustering, clustering.list)
</code></pre>

<hr>
<h2 id='element_consistency'>Element-Wise Consistency Between a Set of Clusterings</h2><span id='topic+element_consistency'></span>

<h3>Description</h3>

<p>Inspect the consistency of a set of clusterings by calculating
their element-wise clustering consistency (also known as element-wise frustration).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_consistency(
  clustering_list,
  alpha = 0.9,
  r = 1,
  rescale_path_type = "max",
  ppr_implementation = "prpack",
  dist_rescaled = FALSE,
  row_normalize = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="element_consistency_+3A_clustering_list">clustering_list</code></td>
<td>
<p>The list of clustering results, each of which is either:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_consistency_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</td></tr>
<tr><td><code id="element_consistency_+3A_r">r</code></td>
<td>
<p>A numeric hierarchical scaling parameter.</p>
</td></tr>
<tr><td><code id="element_consistency_+3A_rescale_path_type">rescale_path_type</code></td>
<td>
<p>A string; rescale the hierarchical height by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_consistency_+3A_ppr_implementation">ppr_implementation</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_consistency_+3A_dist_rescaled">dist_rescaled</code></td>
<td>
<p>A logical: if TRUE, the linkage distances are linearly
rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_consistency_+3A_row_normalize">row_normalize</code></td>
<td>
<p>Whether to normalize all rows in clustering_result
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the element-wise consistency. If
<code>calculate_sim_matrix</code> is set to <code>TRUE</code>, the element similarity matrix
will be returned as well.
</p>


<h3>References</h3>

<p>Gates, A. J., Wood, I. B., Hetrick, W. P., &amp; Ahn, Y. Y. (2019).
Element-centric clustering comparison unifies overlaps and hierarchy.
Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y
</p>


<h3>Examples</h3>

<pre><code class='language-R'># cluster across 20 random seeds
clustering.list &lt;- lapply(1:20, function(x) kmeans(mtcars, centers = 3)$cluster)
element_consistency(clustering.list)
</code></pre>

<hr>
<h2 id='element_sim'>The Element-Centric Clustering Similarity</h2><span id='topic+element_sim'></span>

<h3>Description</h3>

<p>Calculates the average element-centric similarity between two
clustering results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_sim(
  clustering1,
  clustering2,
  alpha = 0.9,
  r_cl1 = 1,
  rescale_path_type_cl1 = "max",
  ppr_implementation_cl1 = "prpack",
  dist_rescaled_cl1 = FALSE,
  row_normalize_cl1 = TRUE,
  r_cl2 = 1,
  rescale_path_type_cl2 = "max",
  ppr_implementation_cl2 = "prpack",
  dist_rescaled_cl2 = FALSE,
  row_normalize_cl2 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="element_sim_+3A_clustering1">clustering1</code></td>
<td>
<p>The first clustering result, which can be one of:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_+3A_clustering2">clustering2</code></td>
<td>
<p>The second clustering result, which can be one of:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</td></tr>
<tr><td><code id="element_sim_+3A_r_cl1">r_cl1</code></td>
<td>
<p>A numeric hierarchical scaling parameter for the first clustering.</p>
</td></tr>
<tr><td><code id="element_sim_+3A_rescale_path_type_cl1">rescale_path_type_cl1</code></td>
<td>
<p>A string; rescale the hierarchical height of
the first clustering by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_+3A_ppr_implementation_cl1">ppr_implementation_cl1</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation for the first clustering:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_+3A_dist_rescaled_cl1">dist_rescaled_cl1</code></td>
<td>
<p>A logical: if TRUE, the linkage distances of the first
clustering are linearly rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_sim_+3A_row_normalize_cl1">row_normalize_cl1</code></td>
<td>
<p>Whether to normalize all rows in the first clustering
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
<tr><td><code id="element_sim_+3A_r_cl2">r_cl2</code></td>
<td>
<p>A numeric hierarchical scaling parameter for the second clustering.</p>
</td></tr>
<tr><td><code id="element_sim_+3A_rescale_path_type_cl2">rescale_path_type_cl2</code></td>
<td>
<p>A string; rescale the hierarchical height of
the second clustering by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_+3A_ppr_implementation_cl2">ppr_implementation_cl2</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation for the second clustering:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_+3A_dist_rescaled_cl2">dist_rescaled_cl2</code></td>
<td>
<p>A logical: if TRUE, the linkage distances of the second
clustering are linearly rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_sim_+3A_row_normalize_cl2">row_normalize_cl2</code></td>
<td>
<p>Whether to normalize all rows in the second clustering
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The average element-wise similarity between the two Clusterings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>km.res &lt;- kmeans(mtcars, centers = 3)$cluster
hc.res &lt;- hclust(dist(mtcars))
element_sim(km.res, hc.res)
</code></pre>

<hr>
<h2 id='element_sim_elscore'>The Element-Centric Clustering Similarity for each Element</h2><span id='topic+element_sim_elscore'></span>

<h3>Description</h3>

<p>Calculates the element-wise element-centric similarity between
two clustering results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_sim_elscore(
  clustering1,
  clustering2,
  alpha = 0.9,
  r_cl1 = 1,
  rescale_path_type_cl1 = "max",
  ppr_implementation_cl1 = "prpack",
  dist_rescaled_cl1 = FALSE,
  row_normalize_cl1 = TRUE,
  r_cl2 = 1,
  rescale_path_type_cl2 = "max",
  ppr_implementation_cl2 = "prpack",
  dist_rescaled_cl2 = FALSE,
  row_normalize_cl2 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="element_sim_elscore_+3A_clustering1">clustering1</code></td>
<td>
<p>The first clustering result, which can be one of:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_clustering2">clustering2</code></td>
<td>
<p>The second clustering result, which can be one of:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_r_cl1">r_cl1</code></td>
<td>
<p>A numeric hierarchical scaling parameter for the first clustering.</p>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_rescale_path_type_cl1">rescale_path_type_cl1</code></td>
<td>
<p>A string; rescale the hierarchical height of
the first clustering by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_ppr_implementation_cl1">ppr_implementation_cl1</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation for the first clustering:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_dist_rescaled_cl1">dist_rescaled_cl1</code></td>
<td>
<p>A logical: if TRUE, the linkage distances of the first
clustering are linearly rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_row_normalize_cl1">row_normalize_cl1</code></td>
<td>
<p>Whether to normalize all rows in the first clustering
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_r_cl2">r_cl2</code></td>
<td>
<p>A numeric hierarchical scaling parameter for the second clustering.</p>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_rescale_path_type_cl2">rescale_path_type_cl2</code></td>
<td>
<p>A string; rescale the hierarchical height of
the second clustering by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_ppr_implementation_cl2">ppr_implementation_cl2</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation for the second clustering:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_dist_rescaled_cl2">dist_rescaled_cl2</code></td>
<td>
<p>A logical: if TRUE, the linkage distances of the second
clustering are linearly rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_row_normalize_cl2">row_normalize_cl2</code></td>
<td>
<p>Whether to normalize all rows in the second clustering
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of element-centric similarity between the two clusterings for
each element.
</p>


<h3>References</h3>

<p>Gates, A. J., Wood, I. B., Hetrick, W. P., &amp; Ahn, Y. Y. (2019).
Element-centric clustering comparison unifies overlaps and hierarchy.
Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>km.res &lt;- kmeans(iris[, 1:4], centers = 8)$cluster
hc.res &lt;- hclust(dist(iris[, 1:4]))
element_sim_elscore(km.res, hc.res)
</code></pre>

<hr>
<h2 id='element_sim_matrix'>Pairwise Comparison of Clusterings</h2><span id='topic+element_sim_matrix'></span>

<h3>Description</h3>

<p>Compare a set of clusterings by calculating their pairwise
average element-centric clustering similarities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_sim_matrix(
  clustering_list,
  output_type = "matrix",
  alpha = 0.9,
  r = 1,
  rescale_path_type = "max",
  ppr_implementation = "prpack",
  dist_rescaled = FALSE,
  row_normalize = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="element_sim_matrix_+3A_clustering_list">clustering_list</code></td>
<td>
<p>The list of clustering results, each of which is either:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_output_type">output_type</code></td>
<td>
<p>A string specifying whether the output should be a
matrix or a data.frame.</p>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_r">r</code></td>
<td>
<p>A numeric hierarchical scaling parameter.</p>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_rescale_path_type">rescale_path_type</code></td>
<td>
<p>A string; rescale the hierarchical height by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_ppr_implementation">ppr_implementation</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_dist_rescaled">dist_rescaled</code></td>
<td>
<p>A logical: if TRUE, the linkage distances are linearly
rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_row_normalize">row_normalize</code></td>
<td>
<p>Whether to normalize all rows in clustering_result
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or data.frame containing the pairwise ECS values.
</p>


<h3>References</h3>

<p>Gates, A. J., Wood, I. B., Hetrick, W. P., &amp; Ahn, Y. Y. (2019).
Element-centric clustering comparison unifies overlaps and hierarchy.
Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y
</p>


<h3>Examples</h3>

<pre><code class='language-R'># cluster across 20 random seeds
clustering.list &lt;- lapply(1:20, function(x) kmeans(mtcars, centers = 3)$cluster)
element_sim_matrix(clustering.list, output_type = "matrix")
</code></pre>

<hr>
<h2 id='get_clusters_from_clustassess_object'>Extract config-specific clusters from a ClustAssess object</h2><span id='topic+get_clusters_from_clustassess_object'></span>

<h3>Description</h3>

<p>Given the output of the <code>automatic_stability_assessment</code>
function, extract the clusters that are specific to a particular
configuration of feature type, feature size, clustering method and,
optionally, the number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clusters_from_clustassess_object(
  clustassess_object,
  feature_type = NULL,
  feature_size = NULL,
  clustering_method = NULL,
  nclusters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_clusters_from_clustassess_object_+3A_clustassess_object">clustassess_object</code></td>
<td>
<p>Output of the <code>automatic_stability_assessment</code>.</p>
</td></tr>
<tr><td><code id="get_clusters_from_clustassess_object_+3A_feature_type">feature_type</code></td>
<td>
<p>Type of feature used for dimensionality reduction. If
<code>NULL</code>, it will select the first available feature.</p>
</td></tr>
<tr><td><code id="get_clusters_from_clustassess_object_+3A_feature_size">feature_size</code></td>
<td>
<p>Size of the feature set used for clustering. If <code>NULL</code>,
it will select the first available feature size.</p>
</td></tr>
<tr><td><code id="get_clusters_from_clustassess_object_+3A_clustering_method">clustering_method</code></td>
<td>
<p>Clustering method used. If <code>NULL</code>, it will select
the first available clustering method.</p>
</td></tr>
<tr><td><code id="get_clusters_from_clustassess_object_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters to extract. If <code>NULL</code>, all clusters are
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of clusters that are specific to the given configuration.
Each number of cluster will contain the list of partitions with that
specific k and the ECC value indicating the overall stability of k.
</p>

<hr>
<h2 id='get_highest_prune_param'>Calculate the highest pruning parameter for the SNN graph given NN matrix</h2><span id='topic+get_highest_prune_param'></span>

<h3>Description</h3>

<p>Given a NN adjacency matrix, the function calculates the highest pruning
parameter for the SNN graph that preserves the connectivity of the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_highest_prune_param(nn_matrix, n_neigh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_highest_prune_param_+3A_nn_matrix">nn_matrix</code></td>
<td>
<p>The adjacency matrix of the nearest neighbour graph.</p>
</td></tr>
<tr><td><code id="get_highest_prune_param_+3A_n_neigh">n_neigh</code></td>
<td>
<p>The number of nearest neighbours.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>

<ul>
<li> <p><code>prune_value</code>: The value of the highest pruning parameter.
</p>
</li>
<li> <p><code>adj_matrix</code>: The adjacency matrix of the SNN graph after pruning.
</p>
</li></ul>



<h3>Note</h3>

<p>Given the way the SNN graph is built, the possible values for the pruning
parameter are limited and can be determined by the formula <code>i / (2 * n_neigh - i)</code>,
where <code>i</code> is a number of nearest neighbours between 0 and <code>n_neigh</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial pca embedding
pca_embedding &lt;- matrix(
    c(runif(100 * 10), runif(100 * 10, min = 3, max = 4)),
    nrow = 200, byrow = TRUE
)
rownames(pca_embedding) &lt;- as.character(1:200)
colnames(pca_embedding) &lt;- paste("PC", 1:10)

# calculate the nn adjacency matrix
nn_matrix &lt;- getNNmatrix(
    RANN::nn2(pca_embedding, k = 5)$nn.idx,
    5,
    0,
    -1
)$nn

get_highest_prune_param(nn_matrix, 5)$prune_value
</code></pre>

<hr>
<h2 id='get_highest_prune_param_embedding'>Calculate the highest pruning parameter for the SNN graph given Embedding</h2><span id='topic+get_highest_prune_param_embedding'></span>

<h3>Description</h3>

<p>Given an embedding, the function calculates the highest pruning
parameter for the SNN graph that preserves the connectivity of the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_highest_prune_param_embedding(embedding, n_neigh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_highest_prune_param_embedding_+3A_embedding">embedding</code></td>
<td>
<p>A matrix associated with a PCA embedding. Embeddings from
other dimensionality reduction techniques (such as LSI) can be used.</p>
</td></tr>
<tr><td><code id="get_highest_prune_param_embedding_+3A_n_neigh">n_neigh</code></td>
<td>
<p>The number of nearest neighbours.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the highest pruning parameter.
</p>


<h3>Note</h3>

<p>Given the way the SNN graph is built, the possible values for the pruning
parameter are limited and can be determined by the formula <code>i / (2 * n_neigh - i)</code>,
where <code>i</code> is a number of nearest neighbours between 0 and <code>n_neigh</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial pca embedding
pca_embedding &lt;- matrix(
    c(runif(100 * 10), runif(100 * 10, min = 3, max = 4)),
    nrow = 200, byrow = TRUE
)
rownames(pca_embedding) &lt;- as.character(1:200)
colnames(pca_embedding) &lt;- paste("PC", 1:10)

get_highest_prune_param_embedding(pca_embedding, 5)
</code></pre>

<hr>
<h2 id='get_nn_conn_comps'>Relationship Between Nearest Neighbours and Connected Components</h2><span id='topic+get_nn_conn_comps'></span>

<h3>Description</h3>

<p>One of the steps in the clustering pipeline is building a
k-nearest neighbour graph on a reduced-space embedding. This method assesses
the relationship between different number of nearest
neighbours and the connectivity of the graph. In the context of graph clustering,
the number of connected components can be used as a
lower bound for the number of clusters. The calculations are performed multiple
times by changing the seed at each repetition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nn_conn_comps(
  embedding,
  n_neigh_sequence,
  n_repetitions = 100,
  seed_sequence = NULL,
  include_umap = FALSE,
  umap_arguments = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_nn_conn_comps_+3A_embedding">embedding</code></td>
<td>
<p>A matrix associated with a PCA embedding. Embeddings from
other dimensionality reduction techniques (such as LSI) can be used.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_n_neigh_sequence">n_neigh_sequence</code></td>
<td>
<p>A sequence of the number of nearest neighbours.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_n_repetitions">n_repetitions</code></td>
<td>
<p>The number of repetitions of applying the pipeline with
different seeds; ignored if seed_sequence is provided by the user. Defaults to '100&ldquo;.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_seed_sequence">seed_sequence</code></td>
<td>
<p>A custom seed sequence; if the value is NULL, the
sequence will be built starting from 1 with a step of 100.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_include_umap">include_umap</code></td>
<td>
<p>A boolean value indicating whether to calculate the number
of connected components for the UMAP embedding. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_umap_arguments">umap_arguments</code></td>
<td>
<p>Additional arguments passed to the the <code>uwot::umap</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having one field associated with a number of nearest neighbours.
Each value contains an array of the number of connected components
obtained on the specified number of repetitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial PCA embedding
pca_emb &lt;- matrix(runif(100 * 30), nrow = 100, byrow = TRUE)
rownames(pca_emb) &lt;- as.character(1:100)
colnames(pca_emb) &lt;- paste0("PCA_", 1:30)

nn_conn_comps_obj &lt;- get_nn_conn_comps(
    embedding = pca_emb,
    n_neigh_sequence = c(2, 5),
    n_repetitions = 3,
    # arguments that are passed to the uwot function
    umap_arguments = list(
        min_dist = 0.3,
        metric = "cosine"
    )
)
plot_connected_comps_evolution(nn_conn_comps_obj)
</code></pre>

<hr>
<h2 id='getNNmatrix'>Computes the NN adjacency matrix given the neighbours</h2><span id='topic+getNNmatrix'></span>

<h3>Description</h3>

<p>Computes the NN adjacency matrix given the neighbours
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNNmatrix(nnRanked, k = -1L, start = 0L, prune = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getNNmatrix_+3A_nnranked">nnRanked</code></td>
<td>
<p>A matrix with the lists of the nearest neighbours for each point</p>
</td></tr>
<tr><td><code id="getNNmatrix_+3A_k">k</code></td>
<td>
<p>The number of neighbours to consider. Defaults to <code>-1</code>, which means all neighbours.</p>
</td></tr>
<tr><td><code id="getNNmatrix_+3A_start">start</code></td>
<td>
<p>The index of the first neighbour to consider. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="getNNmatrix_+3A_prune">prune</code></td>
<td>
<p>The threshold to prune the SNN matrix. If -1, the function will only return the NN matrix. Defaults to <code>0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the NN and SNN adjacency matrices.
</p>

<hr>
<h2 id='length+2CClustering-method'>Length of an Object</h2><span id='topic+length+2CClustering-method'></span>

<h3>Description</h3>

<p>Get the number of elements in the Clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Clustering'
length(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="length+2B2CClustering-method_+3A_x">x</code></td>
<td>
<p>The Clustering object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of elements.
</p>

<hr>
<h2 id='marker_overlap'>Cell-Wise Marker Gene Overlap</h2><span id='topic+marker_overlap'></span>

<h3>Description</h3>

<p>Calculates the per-cell overlap of previously calculated
marker genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marker_overlap(
  markers1,
  markers2,
  clustering1,
  clustering2,
  n = 25,
  overlap_type = "jsi",
  rank_by = "-p_val",
  use_sign = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marker_overlap_+3A_markers1">markers1</code></td>
<td>
<p>The first data frame of marker genes, must contain columns
called 'gene' and 'cluster'.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_markers2">markers2</code></td>
<td>
<p>The second data frame of marker genes, must contain columns
called 'gene' and 'cluster'.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_clustering1">clustering1</code></td>
<td>
<p>The first vector of cluster assignments.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_clustering2">clustering2</code></td>
<td>
<p>The second vector of cluster assignments.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_n">n</code></td>
<td>
<p>The number of top n markers (ranked by rank_by) to use when
calculating the overlap.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_overlap_type">overlap_type</code></td>
<td>
<p>The type of overlap to calculated: must be one of 'jsi'
for Jaccard similarity index and 'intersect' for intersect size.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_rank_by">rank_by</code></td>
<td>
<p>A character string giving the name of the column to rank
marker genes by. Note the sign here: to rank by lowest p-value, preface
the column name with a minus sign; to rank by highest value, where higher
value indicates more discriminative genes (for example power in the ROC
test), no sign is needed.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_use_sign">use_sign</code></td>
<td>
<p>A logical: should the sign of markers match for overlap
calculations? So a gene must be a positive or a negative marker in both
clusters being compared. If TRUE, markers1 and markers2 must have a
'avg_logFC' or 'avg_log2FC' column, from which the sign of the DE will be
extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the marker gene overlap per cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressWarnings({
    set.seed(1234)
    library(Seurat)
    data("pbmc_small")

    # cluster with Louvain algorithm
    pbmc_small &lt;- FindClusters(pbmc_small, resolution = 0.8, verbose = FALSE)

    # cluster with k-means
    pbmc.pca &lt;- Embeddings(pbmc_small, "pca")
    pbmc_small@meta.data$kmeans_clusters &lt;- kmeans(pbmc.pca, centers = 3)$cluster

    # compare the markers
    Idents(pbmc_small) &lt;- pbmc_small@meta.data$seurat_clusters
    louvain.markers &lt;- FindAllMarkers(pbmc_small,
        logfc.threshold = 1,
        test.use = "t",
        verbose = FALSE
    )

    Idents(pbmc_small) &lt;- pbmc_small@meta.data$kmeans_clusters
    kmeans.markers &lt;- FindAllMarkers(pbmc_small,
        logfc.threshold = 1,
        test.use = "t",
        verbose = FALSE
    )

    pbmc_small@meta.data$jsi &lt;- marker_overlap(
        louvain.markers, kmeans.markers,
        pbmc_small@meta.data$seurat_clusters, pbmc_small@meta.data$kmeans_clusters
    )

    # which cells have the same markers, regardless of clustering?
    FeaturePlot(pbmc_small, "jsi")
})
</code></pre>

<hr>
<h2 id='merge_partitions'>Merge Partitions</h2><span id='topic+merge_partitions'></span>

<h3>Description</h3>

<p>Merge flat disjoint clusterings whose pairwise ECS score is
above a given threshold. The merging is done using a complete linkage approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_partitions(
  partition_list,
  ecs_thresh = 1,
  order_logic = c("freq", "avg_agreement", "none"),
  return_ecs_matrix = FALSE,
  check_ties = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_partitions_+3A_partition_list">partition_list</code></td>
<td>
<p>A list of flat disjoint membership vectors.</p>
</td></tr>
<tr><td><code id="merge_partitions_+3A_ecs_thresh">ecs_thresh</code></td>
<td>
<p>A numeric: the ecs threshold.</p>
</td></tr>
<tr><td><code id="merge_partitions_+3A_order_logic">order_logic</code></td>
<td>
<p>Variable indicating the method of ordering the partitions.
It can take these three values:
</p>

<ul>
<li><p> &quot;freq&quot;: order the partitions based on their frequencies. The partition with
the highest frequency will be the first on the list (default).
</p>
</li>
<li><p> &quot;avg_agreement&quot;: order the partitions based on their average agreement index.
The average agreement index of a partition is calculated as the mean of
the ECS scores between that partition and the other partitions from the list.
The partition with the highest agreement will be  the first on the list.
</p>
</li>
<li><p> &quot;none&quot;: do not perform any ordering (not recommended). If selected, the
average agreement scores will not be calculated.
</p>
</li></ul>
</td></tr>
<tr><td><code id="merge_partitions_+3A_return_ecs_matrix">return_ecs_matrix</code></td>
<td>
<p>A logical: if TRUE, the function will add the
ECS matrix to the return list. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="merge_partitions_+3A_check_ties">check_ties</code></td>
<td>
<p>A logical value that indicates whether to check for ties
in the highest frequency partitions or not. If TRUE, the function will put
at the first position the partition that has the highest similarity
with the other partitions. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the merged partitions, together with their associated
ECC score. If <code>return_ecs_matrix</code> is set to TRUE, the function will also
return the ECS matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initial_list &lt;- list(c(1, 1, 2), c(2, 2, 2), c("B", "B", "A"))
merge_partitions(initial_list, 1)
</code></pre>

<hr>
<h2 id='merge_resolutions'>Merge Partitions from different Resolutions</h2><span id='topic+merge_resolutions'></span>

<h3>Description</h3>

<p>Merge partitions obtained with different resolution values. The
partitions will be grouped based on the number of clusters. The identical
partitions will be merged into a single partition by updating the frequency
using the <code>merge_partitions</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_resolutions(res_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_resolutions_+3A_res_obj">res_obj</code></td>
<td>
<p>A list associated to a configuration field from the object
returned by the <code>assess_clustering_importance</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having one field assigned to each number of clusters. A number
of cluster will contain a list of all merged partitions. To avoid duplicates,
<code>merged_partitions</code> with threshold 1 is applied.
</p>

<hr>
<h2 id='pac_convergence'>PAC Convergence Plot</h2><span id='topic+pac_convergence'></span>

<h3>Description</h3>

<p>Plot PAC across iterations for a set of k to assess convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pac_convergence(pac_res, k_plot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pac_convergence_+3A_pac_res">pac_res</code></td>
<td>
<p>The data.frame output by consensus_cluster.</p>
</td></tr>
<tr><td><code id="pac_convergence_+3A_k_plot">k_plot</code></td>
<td>
<p>A vector with values of k to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with the convergence plot. Convergence has been
reached when the lines flatten out across k_plot values.
out across
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pac.res &lt;- consensus_cluster(iris[, 1:4], k_max = 20)
pac_convergence(pac.res, k_plot = c(3, 5, 7, 9))
</code></pre>

<hr>
<h2 id='pac_landscape'>PAC Landscape Plot</h2><span id='topic+pac_landscape'></span>

<h3>Description</h3>

<p>Plot final PAC values across range of k to find optimal number
of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pac_landscape(pac_res, n_shade = max(pac_res$iteration)/5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pac_landscape_+3A_pac_res">pac_res</code></td>
<td>
<p>The data.frame output by consensus_cluster.</p>
</td></tr>
<tr><td><code id="pac_landscape_+3A_n_shade">n_shade</code></td>
<td>
<p>The PAC values across the last n_shade iterations will be
shaded to illustrate the how stable the PAC score is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with the final PAC vs k plot. A local minimum in the
landscape indicates an especially stable value of k.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pac.res &lt;- consensus_cluster(iris[, 1:4], k_max = 20)
pac_landscape(pac.res)
</code></pre>

<hr>
<h2 id='plot_clustering_difference_facet'>Clustering Method Stability Facet Plot</h2><span id='topic+plot_clustering_difference_facet'></span>

<h3>Description</h3>

<p>Display the distribution of the EC consistency for each
clustering method and each resolution value on a given embedding The <code>all</code>
field of the object returned by the <code>get_clustering_difference_object</code> method is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_clustering_difference_facet(
  clust_object,
  embedding,
  low_limit = 0,
  high_limit = 1,
  grid = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_clustering_difference_facet_+3A_clust_object">clust_object</code></td>
<td>
<p>An object returned by the
<code>assess_clustering_stability</code> method.</p>
</td></tr>
<tr><td><code id="plot_clustering_difference_facet_+3A_embedding">embedding</code></td>
<td>
<p>An embedding (only the first two dimensions will be used for
visualization).</p>
</td></tr>
<tr><td><code id="plot_clustering_difference_facet_+3A_low_limit">low_limit</code></td>
<td>
<p>The lowest value of ECC that will be displayed on the embedding.</p>
</td></tr>
<tr><td><code id="plot_clustering_difference_facet_+3A_high_limit">high_limit</code></td>
<td>
<p>The highest value of ECC that will be displayed on the embedding.</p>
</td></tr>
<tr><td><code id="plot_clustering_difference_facet_+3A_grid">grid</code></td>
<td>
<p>Boolean value indicating whether the facet should be a grid (where each
row is associated with a resolution value and each column with a clustering method) or
a wrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
#TODO should export
</p>


<h3>Examples</h3>

<pre><code class='language-R'># FIXME fix the examples
# set.seed(2021)
# # create an artificial PCA embedding
# pca_embedding &lt;- matrix(runif(100 * 30), nrow = 100)
# rownames(pca_embedding) &lt;- as.character(1:100)
# colnames(pca_embedding) &lt;- paste0("PCA_", 1:30)

# adj_matrix &lt;- Seurat::FindNeighbors(pca_embedding,
#     k.param = 10,
#     nn.method = "rann",
#     verbose = FALSE,
#     compute.SNN = FALSE
# )$nn
# clust_diff_obj &lt;- assess_clustering_stability(
#     graph_adjacency_matrix = adj_matrix,
#     resolution = c(0.5, 1),
#     n_repetitions = 10,
#     algorithm = 1:2,
#     verbose = FALSE
# )
# plot_clustering_difference_facet(clust_diff_obj, pca_embedding)
</code></pre>

<hr>
<h2 id='plot_clustering_overall_stability'>Clustering Method Overall Stability Boxplot</h2><span id='topic+plot_clustering_overall_stability'></span>

<h3>Description</h3>

<p>Display EC consistency across clustering methods by summarising
the distribution of the EC consistency for each number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_clustering_overall_stability(
  clust_object,
  value_type = c("k", "resolution"),
  summary_function = stats::median
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_clustering_overall_stability_+3A_clust_object">clust_object</code></td>
<td>
<p>An object returned by the
<code>assess_clustering_stability</code> method.</p>
</td></tr>
<tr><td><code id="plot_clustering_overall_stability_+3A_value_type">value_type</code></td>
<td>
<p>A string that specifies the type of value that was used
for grouping the partitions and calculating the ECC score. It can be either
<code>k</code> or <code>resolution</code>. Defaults to <code>k</code>.</p>
</td></tr>
<tr><td><code id="plot_clustering_overall_stability_+3A_summary_function">summary_function</code></td>
<td>
<p>The function that will be used to summarize the
distribution of the ECC values obtained for each number of clusters. Defaults
to <code>median</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with the EC consistency distributions grouped by
the clustering methods. Higher consistency indicates
a more stable clustering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial PCA embedding
pca_embedding &lt;- matrix(runif(100 * 30), nrow = 100)
rownames(pca_embedding) &lt;- paste0("cell_", seq_len(nrow(pca_embedding)))
colnames(pca_embedding) &lt;- paste0("PC_", 1:30)


adj_matrix &lt;- getNNmatrix(
    RANN::nn2(pca_embedding, k = 10)$nn.idx,
    10,
    0,
    -1
)$nn
rownames(adj_matrix) &lt;- paste0("cell_", seq_len(nrow(adj_matrix)))
colnames(adj_matrix) &lt;- paste0("cell_", seq_len(ncol(adj_matrix)))

# alternatively, the adj_matrix can be calculated
# using the `Seurat::FindNeighbors` function.

clust_diff_obj &lt;- assess_clustering_stability(
    graph_adjacency_matrix = adj_matrix,
    resolution = c(0.5, 1),
    n_repetitions = 10,
    clustering_algorithm = 1:2,
    verbose = FALSE
)
plot_clustering_overall_stability(clust_diff_obj)
</code></pre>

<hr>
<h2 id='plot_clustering_per_value_stability'>Clustering Method per value Stability Boxplot</h2><span id='topic+plot_clustering_per_value_stability'></span>

<h3>Description</h3>

<p>Display EC consistency across clustering methods, calculated
for each value of the resolution parameter or the number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_clustering_per_value_stability(
  clust_object,
  value_type = c("k", "resolution")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_clustering_per_value_stability_+3A_clust_object">clust_object</code></td>
<td>
<p>An object returned by the
<code>assess_clustering_stability</code> method.</p>
</td></tr>
<tr><td><code id="plot_clustering_per_value_stability_+3A_value_type">value_type</code></td>
<td>
<p>A string that specifies the type of value that was used
for grouping the partitions and calculating the ECC score. It can be either
<code>k</code> or <code>resolution</code>. Defaults to <code>k</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with the EC consistency distributions grouped by
the clustering methods. Higher consistency indicates a more stable clustering.
The X axis is decided by the <code>value_type</code> parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial PCA embedding
pca_embedding &lt;- matrix(runif(100 * 30), nrow = 100)
rownames(pca_embedding) &lt;- paste0("cell_", seq_len(nrow(pca_embedding)))
colnames(pca_embedding) &lt;- paste0("PC_", 1:30)


adj_matrix &lt;- getNNmatrix(
    RANN::nn2(pca_embedding, k = 10)$nn.idx,
    10,
    0,
    -1
)$nn
rownames(adj_matrix) &lt;- paste0("cell_", seq_len(nrow(adj_matrix)))
colnames(adj_matrix) &lt;- paste0("cell_", seq_len(ncol(adj_matrix)))

# alternatively, the adj_matrix can be calculated
# using the `Seurat::FindNeighbors` function.

clust_diff_obj &lt;- assess_clustering_stability(
    graph_adjacency_matrix = adj_matrix,
    resolution = c(0.5, 1),
    n_repetitions = 10,
    clustering_algorithm = 1:2,
    verbose = FALSE
)
plot_clustering_per_value_stability(clust_diff_obj)
</code></pre>

<hr>
<h2 id='plot_connected_comps_evolution'>Relationship Between Number of Nearest Neighbours and Graph Connectivity</h2><span id='topic+plot_connected_comps_evolution'></span>

<h3>Description</h3>

<p>Display the distribution of the number connected components
obtained for each number of neighbours across random seeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_connected_comps_evolution(nn_conn_comps_object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_connected_comps_evolution_+3A_nn_conn_comps_object">nn_conn_comps_object</code></td>
<td>
<p>An object or a concatenation of objects returned
by the <code>get_nn_conn_comps</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with boxplots for the connected component distributions.
</p>


<h3>Note</h3>

<p>The number of connected components is displayed on a logarithmic scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial PCA embedding
pca_emb &lt;- matrix(runif(100 * 30), nrow = 100, byrow = TRUE)
rownames(pca_emb) &lt;- as.character(1:100)
colnames(pca_emb) &lt;- paste0("PCA_", 1:30)

nn_conn_comps_obj &lt;- get_nn_conn_comps(
    embedding = pca_emb,
    n_neigh_sequence = c(2, 5),
    n_repetitions = 3,
    # arguments that are passed to the uwot function
    umap_arguments = list(
        min_dist = 0.3,
        metric = "cosine"
    )
)
plot_connected_comps_evolution(nn_conn_comps_obj)
</code></pre>

<hr>
<h2 id='plot_feature_overall_stability_boxplot'>Overall Feature Stability Boxplot</h2><span id='topic+plot_feature_overall_stability_boxplot'></span>

<h3>Description</h3>

<p>Display EC consistency for each feature set and for each step.
Above each boxplot there is a number representing
the step (or the size of the subset). The ECC values are extracted for each
resolution value and summarized using the <code>summary_function</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_feature_overall_stability_boxplot(
  feature_object_list,
  summary_function = stats::median,
  text_size = 4,
  boxplot_width = 0.4,
  dodge_width = 0.7,
  return_df = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_feature_overall_stability_boxplot_+3A_feature_object_list">feature_object_list</code></td>
<td>
<p>An object or a concatenation of objects returned
by the <code>assess_feature_stability</code> method</p>
</td></tr>
<tr><td><code id="plot_feature_overall_stability_boxplot_+3A_summary_function">summary_function</code></td>
<td>
<p>The function that will be used to summarize the ECC
values. Defaults to <code>median</code>.</p>
</td></tr>
<tr><td><code id="plot_feature_overall_stability_boxplot_+3A_text_size">text_size</code></td>
<td>
<p>The size of the labels above boxplots</p>
</td></tr>
<tr><td><code id="plot_feature_overall_stability_boxplot_+3A_boxplot_width">boxplot_width</code></td>
<td>
<p>Used for adjusting the width of the boxplots; the value
will be passed to the <code>width</code> argument of the <code>ggplot2::geom_boxplot</code> method.</p>
</td></tr>
<tr><td><code id="plot_feature_overall_stability_boxplot_+3A_dodge_width">dodge_width</code></td>
<td>
<p>Used for adjusting the horizontal position of the boxplot;
the value will be passed to the <code>width</code> argument of the
<code>ggplot2::position_dodge</code> method.</p>
</td></tr>
<tr><td><code id="plot_feature_overall_stability_boxplot_+3A_return_df">return_df</code></td>
<td>
<p>If TRUE, the function will return the ECS values as a
dataframe. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial expression matrix
expr_matrix &lt;- matrix(
    c(runif(100 * 10), runif(100 * 10, min = 3, max = 4)),
    nrow = 200, byrow = TRUE
)
rownames(expr_matrix) &lt;- as.character(1:200)
colnames(expr_matrix) &lt;- paste("feature", 1:10)

feature_stability_result &lt;- assess_feature_stability(
    data_matrix = t(expr_matrix),
    feature_set = colnames(expr_matrix),
    steps = 5,
    feature_type = "feature_name",
    resolution = c(0.1, 0.5, 1),
    n_repetitions = 10,
    umap_arguments = list(
        # the following parameters are used by the umap function
        # and are not mandatory
        n_neighbors = 3,
        approx_pow = TRUE,
        n_epochs = 0,
        init = "random",
        min_dist = 0.3
    ),
    clustering_algorithm = 1
)
plot_feature_overall_stability_boxplot(feature_stability_result)
</code></pre>

<hr>
<h2 id='plot_feature_overall_stability_incremental'>Overall Feature Stability Incremental Boxplot</h2><span id='topic+plot_feature_overall_stability_incremental'></span>

<h3>Description</h3>

<p>Perform an incremental ECS between two consecutive feature
steps. The ECS values are extracted for every resolution value and summarized
using a function (e.g. median, mean, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_feature_overall_stability_incremental(
  feature_object_list,
  summary_function = stats::median,
  dodge_width = 0.7,
  text_size = 4,
  boxplot_width = 0.4,
  return_df = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_feature_overall_stability_incremental_+3A_feature_object_list">feature_object_list</code></td>
<td>
<p>An object or a concatenation of objects returned
by the <code>assess_feature_stability</code> method.</p>
</td></tr>
<tr><td><code id="plot_feature_overall_stability_incremental_+3A_summary_function">summary_function</code></td>
<td>
<p>The function used to summarize the ECS values.
Default is <code>median</code>.</p>
</td></tr>
<tr><td><code id="plot_feature_overall_stability_incremental_+3A_dodge_width">dodge_width</code></td>
<td>
<p>Used for adjusting the horizontal position of the boxplot;
the value will be passed to the <code>width</code> argument of the
<code>ggplot2::position_dodge</code> method.</p>
</td></tr>
<tr><td><code id="plot_feature_overall_stability_incremental_+3A_text_size">text_size</code></td>
<td>
<p>The size of the labels above boxplots.</p>
</td></tr>
<tr><td><code id="plot_feature_overall_stability_incremental_+3A_boxplot_width">boxplot_width</code></td>
<td>
<p>Used for adjusting the width of the boxplots; the value
will be passed to the <code>width</code> argument of the <code>ggplot2::geom_boxplot</code> method.</p>
</td></tr>
<tr><td><code id="plot_feature_overall_stability_incremental_+3A_return_df">return_df</code></td>
<td>
<p>If TRUE, the function will return the ECS values as
a dataframe. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with ECS distribution will be displayed as a
boxplot. Above each boxplot there will be a pair of numbers representing the
two steps that are compared.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial expression matrix
expr_matrix &lt;- matrix(
    c(runif(50 * 10), runif(50 * 10, min = 3, max = 4)),
    nrow = 100, byrow = TRUE
)
rownames(expr_matrix) &lt;- as.character(1:100)
colnames(expr_matrix) &lt;- paste("feature", 1:10)

feature_stability_result &lt;- assess_feature_stability(
    data_matrix = t(expr_matrix),
    feature_set = colnames(expr_matrix),
    steps = c(5, 10),
    feature_type = "feature_name",
    resolution = c(0.1, 0.5),
    n_repetitions = 3,
    umap_arguments = list(
        # the following parameters are used by the umap function
        # and are not mandatory
        n_neighbors = 3,
        approx_pow = TRUE,
        n_epochs = 0,
        init = "random",
        min_dist = 0.3
    ),
    clustering_algorithm = 1
)
plot_feature_overall_stability_incremental(feature_stability_result)
</code></pre>

<hr>
<h2 id='plot_feature_per_resolution_stability_boxplot'>Per resolution Feature Stability Boxplot</h2><span id='topic+plot_feature_per_resolution_stability_boxplot'></span>

<h3>Description</h3>

<p>Display EC consistency for each feature set and for each step.
Above each boxplot there is a number representing
the step (or the size of the subset). The ECC values are extracted depdening
on the resolution value provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_feature_per_resolution_stability_boxplot(
  feature_object_list,
  resolution,
  violin_plot = FALSE,
  text_size = 4,
  boxplot_width = 0.4,
  dodge_width = 0.7,
  return_df = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_feature_per_resolution_stability_boxplot_+3A_feature_object_list">feature_object_list</code></td>
<td>
<p>An object or a concatenation of objects returned
by the <code>assess_feature_stability</code> method</p>
</td></tr>
<tr><td><code id="plot_feature_per_resolution_stability_boxplot_+3A_resolution">resolution</code></td>
<td>
<p>The resolution value for which the ECC will be extracted.</p>
</td></tr>
<tr><td><code id="plot_feature_per_resolution_stability_boxplot_+3A_violin_plot">violin_plot</code></td>
<td>
<p>If TRUE, the function will return a violin plot instead
of a boxplot. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_feature_per_resolution_stability_boxplot_+3A_text_size">text_size</code></td>
<td>
<p>The size of the labels above boxplots</p>
</td></tr>
<tr><td><code id="plot_feature_per_resolution_stability_boxplot_+3A_boxplot_width">boxplot_width</code></td>
<td>
<p>Used for adjusting the width of the boxplots; the value
will be passed to the <code>width</code> argument of the <code>ggplot2::geom_boxplot</code> method.</p>
</td></tr>
<tr><td><code id="plot_feature_per_resolution_stability_boxplot_+3A_dodge_width">dodge_width</code></td>
<td>
<p>Used for adjusting the horizontal position of the boxplot;
the value will be passed to the <code>width</code> argument of the
<code>ggplot2::position_dodge</code> method.</p>
</td></tr>
<tr><td><code id="plot_feature_per_resolution_stability_boxplot_+3A_return_df">return_df</code></td>
<td>
<p>If TRUE, the function will return the ECS values as a
dataframe. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial expression matrix
expr_matrix &lt;- matrix(
    c(runif(100 * 10), runif(100 * 10, min = 3, max = 4)),
    nrow = 200, byrow = TRUE
)
rownames(expr_matrix) &lt;- as.character(1:200)
colnames(expr_matrix) &lt;- paste("feature", 1:10)

feature_stability_result &lt;- assess_feature_stability(
    data_matrix = t(expr_matrix),
    feature_set = colnames(expr_matrix),
    steps = 5,
    feature_type = "feature_name",
    resolution = c(0.1, 0.5, 1),
    n_repetitions = 10,
    umap_arguments = list(
        # the following parameters are used by the umap function
        # and are not mandatory
        n_neighbors = 3,
        approx_pow = TRUE,
        n_epochs = 0,
        init = "random",
        min_dist = 0.3
    ),
    clustering_algorithm = 1
)
plot_feature_per_resolution_stability_boxplot(feature_stability_result, 0.5)
</code></pre>

<hr>
<h2 id='plot_feature_per_resolution_stability_incremental'>Per resolution - Feature Stability Incremental Boxplot</h2><span id='topic+plot_feature_per_resolution_stability_incremental'></span>

<h3>Description</h3>

<p>Perform an incremental ECS between two consecutive feature
steps. The ECS values are extracted only for a specified resolution value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_feature_per_resolution_stability_incremental(
  feature_object_list,
  resolution,
  dodge_width = 0.7,
  text_size = 4,
  boxplot_width = 0.4,
  return_df = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_feature_per_resolution_stability_incremental_+3A_feature_object_list">feature_object_list</code></td>
<td>
<p>An object or a concatenation of objects returned
by the <code>assess_feature_stability</code> method.</p>
</td></tr>
<tr><td><code id="plot_feature_per_resolution_stability_incremental_+3A_resolution">resolution</code></td>
<td>
<p>The resolution value for which the ECS will be extracted.</p>
</td></tr>
<tr><td><code id="plot_feature_per_resolution_stability_incremental_+3A_dodge_width">dodge_width</code></td>
<td>
<p>Used for adjusting the horizontal position of the boxplot;
the value will be passed to the <code>width</code> argument of the
<code>ggplot2::position_dodge</code> method.</p>
</td></tr>
<tr><td><code id="plot_feature_per_resolution_stability_incremental_+3A_text_size">text_size</code></td>
<td>
<p>The size of the labels above boxplots.</p>
</td></tr>
<tr><td><code id="plot_feature_per_resolution_stability_incremental_+3A_boxplot_width">boxplot_width</code></td>
<td>
<p>Used for adjusting the width of the boxplots; the value
will be passed to the <code>width</code> argument of the <code>ggplot2::geom_boxplot</code> method.</p>
</td></tr>
<tr><td><code id="plot_feature_per_resolution_stability_incremental_+3A_return_df">return_df</code></td>
<td>
<p>If TRUE, the function will return the ECS values as a
dataframe. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with ECS distribution will be displayed as a
boxplot. Above each boxplot there will be a pair of numbers representing the
two steps that are compared.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial expression matrix
expr_matrix &lt;- matrix(
    c(runif(50 * 10), runif(50 * 10, min = 3, max = 4)),
    nrow = 100, byrow = TRUE
)
rownames(expr_matrix) &lt;- as.character(1:100)
colnames(expr_matrix) &lt;- paste("feature", 1:10)

feature_stability_result &lt;- assess_feature_stability(
    data_matrix = t(expr_matrix),
    feature_set = colnames(expr_matrix),
    steps = c(5, 10),
    feature_type = "feature_name",
    resolution = c(0.1, 0.5),
    n_repetitions = 3,
    umap_arguments = list(
        # the following parameters are used by the umap function
        # and are not mandatory
        n_neighbors = 3,
        approx_pow = TRUE,
        n_epochs = 0,
        init = "random",
        min_dist = 0.3
    ),
    clustering_algorithm = 1
)
plot_feature_per_resolution_stability_incremental(feature_stability_result, 0.1)
</code></pre>

<hr>
<h2 id='plot_feature_stability_ecs_facet'>Feature Stability - EC Consistency Facet Plot</h2><span id='topic+plot_feature_stability_ecs_facet'></span>

<h3>Description</h3>

<p>Display a facet of plots where each subpanel is associated with
a feature set and illustrates the distribution of the EC consistency score
over the UMAP embedding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_feature_stability_ecs_facet(
  feature_object_list,
  resolution,
  n_facet_cols = 3,
  point_size = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_feature_stability_ecs_facet_+3A_feature_object_list">feature_object_list</code></td>
<td>
<p>An object or a concatenation of objects returned
by the <code>assess_feature_stability</code> method</p>
</td></tr>
<tr><td><code id="plot_feature_stability_ecs_facet_+3A_resolution">resolution</code></td>
<td>
<p>The resolution value for which the ECS will be extracted.</p>
</td></tr>
<tr><td><code id="plot_feature_stability_ecs_facet_+3A_n_facet_cols">n_facet_cols</code></td>
<td>
<p>The number of facet's columns.</p>
</td></tr>
<tr><td><code id="plot_feature_stability_ecs_facet_+3A_point_size">point_size</code></td>
<td>
<p>The size of the points displayed on the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial expression matrix
expr_matrix &lt;- matrix(
    c(runif(100 * 10), runif(50 * 10, min = 3, max = 4)),
    nrow = 150, byrow = TRUE
)
rownames(expr_matrix) &lt;- as.character(1:150)
colnames(expr_matrix) &lt;- paste("feature", 1:10)

feature_stability_result &lt;- assess_feature_stability(
    data_matrix = t(expr_matrix),
    feature_set = colnames(expr_matrix),
    steps = 5,
    feature_type = "feature_name",
    resolution = c(0.1, 0.5, 1),
    n_repetitions = 10,
    clustering_algorithm = 1
)
plot_feature_stability_ecs_facet(
    feature_stability_result,
    0.5,
    point_size = 2
)
</code></pre>

<hr>
<h2 id='plot_feature_stability_mb_facet'>Feature Stability - Cluster Membership Facet Plot</h2><span id='topic+plot_feature_stability_mb_facet'></span>

<h3>Description</h3>

<p>Display a facet of plots where each subpanel is associated with
a feature set and illustrates the distribution of the most frequent partition
over the UMAP embedding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_feature_stability_mb_facet(
  feature_object_list,
  resolution,
  text_size = 5,
  n_facet_cols = 3,
  point_size = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_feature_stability_mb_facet_+3A_feature_object_list">feature_object_list</code></td>
<td>
<p>An object or a concatenation of objects returned
by the <code>assess_feature_stability</code> method</p>
</td></tr>
<tr><td><code id="plot_feature_stability_mb_facet_+3A_resolution">resolution</code></td>
<td>
<p>The resolution value for which the ECS will be extracted.</p>
</td></tr>
<tr><td><code id="plot_feature_stability_mb_facet_+3A_text_size">text_size</code></td>
<td>
<p>The size of the cluster label</p>
</td></tr>
<tr><td><code id="plot_feature_stability_mb_facet_+3A_n_facet_cols">n_facet_cols</code></td>
<td>
<p>The number of facet's columns.</p>
</td></tr>
<tr><td><code id="plot_feature_stability_mb_facet_+3A_point_size">point_size</code></td>
<td>
<p>The size of the points displayed on the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial expression matrix
expr_matrix &lt;- matrix(
    c(runif(100 * 10), runif(50 * 10, min = 3, max = 4)),
    nrow = 150, byrow = TRUE
)
rownames(expr_matrix) &lt;- as.character(1:150)
colnames(expr_matrix) &lt;- paste("feature", 1:10)

feature_stability_result &lt;- assess_feature_stability(
    data_matrix = t(expr_matrix),
    feature_set = colnames(expr_matrix),
    steps = 5,
    feature_type = "feature_name",
    resolution = c(0.1, 0.5, 1),
    n_repetitions = 10,
    clustering_algorithm = 1
)
plot_feature_stability_mb_facet(
    feature_stability_result,
    0.5,
    point_size = 2
)
</code></pre>

<hr>
<h2 id='plot_k_n_partitions'>Relationship Between the Number of Clusters and the Number of Unique Partitions</h2><span id='topic+plot_k_n_partitions'></span>

<h3>Description</h3>

<p>For each configuration provided in clust_object, display how
many different partitions with the same number of clusters can be obtained
by changing the seed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_k_n_partitions(
  clust_object,
  colour_information = c("ecc", "freq_part"),
  dodge_width = 0.3,
  pt_size_range = c(1.5, 4),
  summary_function = stats::median,
  y_step = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_k_n_partitions_+3A_clust_object">clust_object</code></td>
<td>
<p>An object returned by the
<code>assess_clustering_stability</code> method.</p>
</td></tr>
<tr><td><code id="plot_k_n_partitions_+3A_colour_information">colour_information</code></td>
<td>
<p>String that specifies the information type that will be
illustrated using gradient colour: either <code>freq_part</code> for the frequency of the
most common partition or <code>ecc</code> for the Element-Centric Consistency
of the partitions obtained when the the number of clusters is fixed. Defaults to <code>ecc</code>.</p>
</td></tr>
<tr><td><code id="plot_k_n_partitions_+3A_dodge_width">dodge_width</code></td>
<td>
<p>Used for adjusting the distance between the boxplots representing
a clustering method. Defaults to <code>0.3</code>.</p>
</td></tr>
<tr><td><code id="plot_k_n_partitions_+3A_pt_size_range">pt_size_range</code></td>
<td>
<p>Indicates the minimum and the maximum size a point on the plot can have.
Defaults to <code>c(1.5, 4)</code>.</p>
</td></tr>
<tr><td><code id="plot_k_n_partitions_+3A_summary_function">summary_function</code></td>
<td>
<p>The function that will be used to summarize the
distribution of the ECC values obtained for each number of clusters. Defaults
to <code>median</code>.</p>
</td></tr>
<tr><td><code id="plot_k_n_partitions_+3A_y_step">y_step</code></td>
<td>
<p>The step used for the y-axis. Defaults to <code>5</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object. The color gradient suggests the frequency of the most
common partition relative to the total number of appearances of that specific
number of clusters or the Element-Centric Consistency of the partitions. The size
illustrates the frequency of the partitions with <em>k</em> clusters relative to the
total number of partitions. The shape of the points indicates the clustering method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial PCA embedding
pca_embedding &lt;- matrix(runif(100 * 30), nrow = 100)
rownames(pca_embedding) &lt;- paste0("cell_", seq_len(nrow(pca_embedding)))
colnames(pca_embedding) &lt;- paste0("PC_", 1:30)


adj_matrix &lt;- getNNmatrix(
    RANN::nn2(pca_embedding, k = 10)$nn.idx,
    10,
    0,
    -1
)$nn
rownames(adj_matrix) &lt;- paste0("cell_", seq_len(nrow(adj_matrix)))
colnames(adj_matrix) &lt;- paste0("cell_", seq_len(ncol(adj_matrix)))

# alternatively, the adj_matrix can be calculated
# using the `Seurat::FindNeighbors` function.

clust_diff_obj &lt;- assess_clustering_stability(
    graph_adjacency_matrix = adj_matrix,
    resolution = c(0.5, 1),
    n_repetitions = 10,
    clustering_algorithm = 1:2,
    verbose = FALSE
)
plot_k_n_partitions(clust_diff_obj)
</code></pre>

<hr>
<h2 id='plot_k_resolution_corresp'>Correspondence Between Resolution and the Number of Clusters</h2><span id='topic+plot_k_resolution_corresp'></span>

<h3>Description</h3>

<p>For each configuration provided in the clust_object, display
what number of clusters appear for different values of the
resolution parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_k_resolution_corresp(
  clust_object,
  colour_information = c("ecc", "freq_k"),
  dodge_width = 0.3,
  pt_size_range = c(1.5, 4),
  summary_function = stats::median
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_k_resolution_corresp_+3A_clust_object">clust_object</code></td>
<td>
<p>An object returned by the
<code>assess_clustering_stability</code> method.</p>
</td></tr>
<tr><td><code id="plot_k_resolution_corresp_+3A_colour_information">colour_information</code></td>
<td>
<p>String that specifies the information type that
will be illustrated using gradient colour: either <code>freq_part</code> for the
frequency of the most common partition or <code>ecc</code> for the
Element-Centric Consistency of the partitions obtained when the the number
of clusters is fixed. Defaults to <code>ecc</code>.</p>
</td></tr>
<tr><td><code id="plot_k_resolution_corresp_+3A_dodge_width">dodge_width</code></td>
<td>
<p>Used for adjusting the distance between the boxplots
representing a clustering method. Defaults to <code>0.3</code>.</p>
</td></tr>
<tr><td><code id="plot_k_resolution_corresp_+3A_pt_size_range">pt_size_range</code></td>
<td>
<p>Indicates the minimum and the maximum size a point
on the plot can have. Defaults to <code>c(1.5, 4)</code>.</p>
</td></tr>
<tr><td><code id="plot_k_resolution_corresp_+3A_summary_function">summary_function</code></td>
<td>
<p>The function that will be used to summarize the
distribution of the ECC values obtained for each number of clusters. Defaults
to <code>median</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object. Different shapes of points indicate different
parameter configuration, while the color
illustrates the frequency of the most common partition or the Element-Centric Consistency
of the partitions. The frequency is calculated
as the fraction between the number of total appearances of partitions with a specific
number of clusters and resolution value and the number of
runs. The size
illustrates the frequency of the most common partition with <em>k</em> clusters relative to the
partitions obtained with the same resolution value and have <em>k</em> clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial PCA embedding
pca_embedding &lt;- matrix(runif(100 * 30), nrow = 100)
rownames(pca_embedding) &lt;- paste0("cell_", seq_len(nrow(pca_embedding)))
colnames(pca_embedding) &lt;- paste0("PC_", 1:30)


adj_matrix &lt;- getNNmatrix(
    RANN::nn2(pca_embedding, k = 10)$nn.idx,
    10,
    0,
    -1
)$nn
rownames(adj_matrix) &lt;- paste0("cell_", seq_len(nrow(adj_matrix)))
colnames(adj_matrix) &lt;- paste0("cell_", seq_len(ncol(adj_matrix)))

# alternatively, the adj_matrix can be calculated
# using the `Seurat::FindNeighbors` function.

clust_diff_obj &lt;- assess_clustering_stability(
    graph_adjacency_matrix = adj_matrix,
    resolution = c(0.5, 1),
    n_repetitions = 10,
    clustering_algorithm = 1:2,
    verbose = FALSE
)
plot_k_resolution_corresp(clust_diff_obj)
</code></pre>

<hr>
<h2 id='plot_n_neigh_ecs'>Graph construction parameters - ECC facet</h2><span id='topic+plot_n_neigh_ecs'></span>

<h3>Description</h3>

<p>Display, for all configurations consisting in different number
of neighbours, graph types and base embeddings, the EC Consistency of the partitions
obtained over multiple runs on an UMAP embedding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_n_neigh_ecs(nn_ecs_object, boxplot_width = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_n_neigh_ecs_+3A_nn_ecs_object">nn_ecs_object</code></td>
<td>
<p>An object or a concatenation of objects returned by the
<code>get_nn_importance</code> method.</p>
</td></tr>
<tr><td><code id="plot_n_neigh_ecs_+3A_boxplot_width">boxplot_width</code></td>
<td>
<p>Used for adjusting the width of the boxplots; the value will
be passed to the <code>width</code> argument of the <code>ggplot2::geom_boxplot</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial PCA embedding
pca_emb &lt;- matrix(runif(100 * 30), nrow = 100, byrow = TRUE)
rownames(pca_emb) &lt;- as.character(1:100)
colnames(pca_emb) &lt;- paste0("PC_", 1:30)

nn_stability_obj &lt;- assess_nn_stability(
    embedding = pca_emb,
    n_neigh_sequence = c(10, 15, 20),
    n_repetitions = 10,
    graph_reduction_type = "PCA",
    clustering_algorithm = 1
)
plot_n_neigh_ecs(nn_stability_obj)
</code></pre>

<hr>
<h2 id='plot_n_neigh_k_correspondence'>Relationship Between Number of Nearest Neighbours and Number of Clusters</h2><span id='topic+plot_n_neigh_k_correspondence'></span>

<h3>Description</h3>

<p>Display the distribution of the
number of clusters obtained for each number of neighbours across random seeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_n_neigh_k_correspondence(nn_object_n_clusters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_n_neigh_k_correspondence_+3A_nn_object_n_clusters">nn_object_n_clusters</code></td>
<td>
<p>An object or a concatenation of objects returned by the
<code>get_nn_importance</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with the distributions displayed as boxplots.
</p>


<h3>Note</h3>

<p>The number of clusters is displayed on a logarithmic scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2024)
# create an artificial PCA embedding
pca_emb &lt;- matrix(runif(100 * 30), nrow = 100, byrow = TRUE)
rownames(pca_emb) &lt;- as.character(1:100)
colnames(pca_emb) &lt;- paste0("PC_", 1:30)

nn_stability_obj &lt;- assess_nn_stability(
    embedding = pca_emb,
    n_neigh_sequence = c(10, 15, 20),
    n_repetitions = 10,
    graph_reduction_type = "PCA",
    clustering_algorithm = 1
)
plot_n_neigh_k_correspondence(nn_stability_obj)
</code></pre>

<hr>
<h2 id='print+2CClustering-method'>Print an Object</h2><span id='topic+print+2CClustering-method'></span>

<h3>Description</h3>

<p>Prints out information about the Clustering, including
number of elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Clustering'
print(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print+2B2CClustering-method_+3A_x">x</code></td>
<td>
<p>The Clustering object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The printed character string.
</p>

<hr>
<h2 id='server_comparisons'>Server - Comparison module</h2><span id='topic+server_comparisons'></span>

<h3>Description</h3>

<p>Creates the backend interface for the comparison module inside
the ClustAssess Shiny application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>server_comparisons(id, chosen_config, chosen_method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="server_comparisons_+3A_id">id</code></td>
<td>
<p>The id of the module, used to acess the UI elements.</p>
</td></tr>
<tr><td><code id="server_comparisons_+3A_chosen_config">chosen_config</code></td>
<td>
<p>A reactive object that contains the chosen configuration
from the Dimensionality Reduction tab.</p>
</td></tr>
<tr><td><code id="server_comparisons_+3A_chosen_method">chosen_method</code></td>
<td>
<p>A reactive object that contains the chosen method from
the Clustering tab.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should not be called directly, but in the context of the
app that is created using the <code>write_shiny_app</code> function.
</p>

<hr>
<h2 id='server_dimensionality_reduction'>Server - Dimensionality reduction module</h2><span id='topic+server_dimensionality_reduction'></span>

<h3>Description</h3>

<p>Creates the backend interface for the dimensionality
reduction module inside the ClustAssess Shiny application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>server_dimensionality_reduction(id, parent_session)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="server_dimensionality_reduction_+3A_id">id</code></td>
<td>
<p>The id of the module, used to acess the UI elements.</p>
</td></tr>
<tr><td><code id="server_dimensionality_reduction_+3A_parent_session">parent_session</code></td>
<td>
<p>The session of the parent module, used to control the
tabs of the application.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should not be called directly, but in the context of the
app that is created using the <code>write_shiny_app</code> function.
</p>

<hr>
<h2 id='server_graph_clustering'>Server - Graph clustering module</h2><span id='topic+server_graph_clustering'></span>

<h3>Description</h3>

<p>Creates the backend interface for the graph clustering module
inside the ClustAssess Shiny application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>server_graph_clustering(id, feature_choice, parent_session)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="server_graph_clustering_+3A_id">id</code></td>
<td>
<p>The id of the module, used to acess the UI elements.</p>
</td></tr>
<tr><td><code id="server_graph_clustering_+3A_feature_choice">feature_choice</code></td>
<td>
<p>A reactive object that contains the chosen configuration
from the Dimensionality Reduction tab.</p>
</td></tr>
<tr><td><code id="server_graph_clustering_+3A_parent_session">parent_session</code></td>
<td>
<p>The session of the parent module, used to control the
tabs of the application.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should not be called directly, but in the context of the
app that is created using the <code>write_shiny_app</code> function.
</p>

<hr>
<h2 id='server_graph_construction'>Server - Graph construction module</h2><span id='topic+server_graph_construction'></span>

<h3>Description</h3>

<p>Creates the backend interface for the graph construction
module inside the ClustAssess Shiny application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>server_graph_construction(id, chosen_config)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="server_graph_construction_+3A_id">id</code></td>
<td>
<p>The id of the module, used to acess the UI elements.</p>
</td></tr>
<tr><td><code id="server_graph_construction_+3A_chosen_config">chosen_config</code></td>
<td>
<p>A reactive object that contains the chosen configuration
from the Dimensionality Reduction tab.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should not be called directly, but in the context of the
app that is created using the <code>write_shiny_app</code> function.
</p>

<hr>
<h2 id='server_landing_page'>Server - Landing page module</h2><span id='topic+server_landing_page'></span>

<h3>Description</h3>

<p>Creates the backend interface for the landing page module inside
the ClustAssess Shiny application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>server_landing_page(
  id,
  height_ratio,
  dimension,
  parent_session,
  organism = "hsapiens"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="server_landing_page_+3A_id">id</code></td>
<td>
<p>The id of the module, used to acess the UI elements.</p>
</td></tr>
<tr><td><code id="server_landing_page_+3A_height_ratio">height_ratio</code></td>
<td>
<p>A reactive object that contains the height ratio of the
plots in the application (the height of the plot is calculated using the
height ratio and the height of the webpage).</p>
</td></tr>
<tr><td><code id="server_landing_page_+3A_dimension">dimension</code></td>
<td>
<p>A reactive object that contains the dimensions of the
webpage.</p>
</td></tr>
<tr><td><code id="server_landing_page_+3A_parent_session">parent_session</code></td>
<td>
<p>The session of the parent module, used to control the
tabs of the application.</p>
</td></tr>
<tr><td><code id="server_landing_page_+3A_organism">organism</code></td>
<td>
<p>The organism of the dataset, which will be used in the
enrichment analysis.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should not be called directly, but in the context of the
app that is created using the <code>write_shiny_app</code> function.
</p>

<hr>
<h2 id='server_sandbox'>Server - Sandbox module</h2><span id='topic+server_sandbox'></span>

<h3>Description</h3>

<p>Creates the backend interface for the sandbox module inside
the ClustAssess Shiny application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>server_sandbox(id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="server_sandbox_+3A_id">id</code></td>
<td>
<p>The id of the module, used to acess the UI elements.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should not be called directly, but in the context of the
app that is created using the <code>write_shiny_app</code> function.
</p>

<hr>
<h2 id='ui_comparisons'>UI - Comparison module</h2><span id='topic+ui_comparisons'></span>

<h3>Description</h3>

<p>Creates the UI interface for the comparison module inside
the ClustAssess Shiny application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui_comparisons(id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ui_comparisons_+3A_id">id</code></td>
<td>
<p>The id of the module, used to identify the UI elements.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should not be called directly, but in the context of the
app that is created using the <code>write_shiny_app</code> function.
</p>

<hr>
<h2 id='ui_dimensionality_reduction'>UI - Dimensionality reduction module</h2><span id='topic+ui_dimensionality_reduction'></span>

<h3>Description</h3>

<p>Creates the UI interface for the dimensionality reduction
module inside the ClustAssess Shiny application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui_dimensionality_reduction(id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ui_dimensionality_reduction_+3A_id">id</code></td>
<td>
<p>The id of the module, used to identify the UI elements.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should not be called directly, but in the context of the
app that is created using the <code>write_shiny_app</code> function.
</p>

<hr>
<h2 id='ui_graph_clustering'>UI - Graph clustering module</h2><span id='topic+ui_graph_clustering'></span>

<h3>Description</h3>

<p>Creates the UI interface for the graph clustering module inside
the ClustAssess Shiny application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui_graph_clustering(id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ui_graph_clustering_+3A_id">id</code></td>
<td>
<p>The id of the module, used to identify the UI elements.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should not be called directly, but in the context of the
app that is created using the <code>write_shiny_app</code> function.
</p>

<hr>
<h2 id='ui_graph_construction'>UI - Graph construction module</h2><span id='topic+ui_graph_construction'></span>

<h3>Description</h3>

<p>Creates the UI interface for the graph construction module inside
the ClustAssess Shiny application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui_graph_construction(id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ui_graph_construction_+3A_id">id</code></td>
<td>
<p>The id of the module, used to identify the UI elements.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should not be called directly, but in the context of the
app that is created using the <code>write_shiny_app</code> function.
</p>

<hr>
<h2 id='ui_landing_page'>UI - Landing page module</h2><span id='topic+ui_landing_page'></span>

<h3>Description</h3>

<p>Creates the UI interface for the landing page module inside
the ClustAssess Shiny application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui_landing_page(id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ui_landing_page_+3A_id">id</code></td>
<td>
<p>The id of the module, used to identify the UI elements.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should not be called directly, but in the context of the
app that is created using the <code>write_shiny_app</code> function.
</p>

<hr>
<h2 id='ui_sandbox'>UI - Sandbox module</h2><span id='topic+ui_sandbox'></span>

<h3>Description</h3>

<p>Creates the UI interface for the sandbox module inside
the ClustAssess Shiny application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui_sandbox(id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ui_sandbox_+3A_id">id</code></td>
<td>
<p>The id of the module, used to identify the UI elements.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should not be called directly, but in the context of the
app that is created using the <code>write_shiny_app</code> function.
</p>

<hr>
<h2 id='weighted_element_consistency'>Weighted Element-Centric Consistency</h2><span id='topic+weighted_element_consistency'></span>

<h3>Description</h3>

<p>Calculate the weighted element-centric consistency of a set of
clusterings. The weights are used to give more importance to some clusterings
over others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_element_consistency(
  clustering_list,
  weights = NULL,
  calculate_sim_matrix = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_element_consistency_+3A_clustering_list">clustering_list</code></td>
<td>
<p>The list of clustering results, each of which is either:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="weighted_element_consistency_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights for each clustering in
<code>clustering_list</code>. If <code>NULL</code>, then all weights will be equal to 1. Defaults
to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="weighted_element_consistency_+3A_calculate_sim_matrix">calculate_sim_matrix</code></td>
<td>
<p>A logical value that indicates whether to
calculate the similarity matrix or not along with the consistency score.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the weighted element-wise consistency. If
<code>calculate_sim_matrix</code> is set to <code>TRUE</code>, the element similarity matrix
will be returned as well.
</p>


<h3>Note</h3>

<p>The weighted ECC will be calculated as <code class="reqn">\displaystyle \frac{\sum_{i} \sum_{j} w_i w_j ECS(i, j)}{\sum_{i} w_i}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># cluster across 20 random seeds
clustering_list &lt;- lapply(1:20, function(x) kmeans(mtcars, centers = 3)$cluster)
weights &lt;- sample(1:10, 20, replace = TRUE)
weighted_element_consistency(clustering_list, weights = weights)
</code></pre>

<hr>
<h2 id='write_objects'>Write the objects for the ClustAssess ShinyApp</h2><span id='topic+write_objects'></span>

<h3>Description</h3>

<p>Given the output of the ClustAssess pipeline, the expression matrix
and the metadata, this function creates the files needed for the ClustAssess
ShinyApp. The files are written in the project_folder and are the following:
</p>

<ul>
<li><p> metadata.rds: the metadata file
</p>
</li>
<li><p> stability.h5: contains the stability results
</p>
</li>
<li><p> expression.h5: contains the expression matrix and the rank matrix
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>write_objects(
  clustassess_object,
  expression_matrix,
  metadata,
  project_folder = ".",
  compression_level = 6,
  chunk_size = 100,
  gene_variance_threshold = 0,
  summary_function = stats::median,
  qualpalr_colorspace = "pretty"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_objects_+3A_clustassess_object">clustassess_object</code></td>
<td>
<p>The output of the ClustAssess automatic pipeline</p>
</td></tr>
<tr><td><code id="write_objects_+3A_expression_matrix">expression_matrix</code></td>
<td>
<p>The expression matrix</p>
</td></tr>
<tr><td><code id="write_objects_+3A_metadata">metadata</code></td>
<td>
<p>The metadata</p>
</td></tr>
<tr><td><code id="write_objects_+3A_project_folder">project_folder</code></td>
<td>
<p>The folder where the files will be written</p>
</td></tr>
<tr><td><code id="write_objects_+3A_compression_level">compression_level</code></td>
<td>
<p>The compression level for the h5 files (See 'rhdf5::h5createFile&ldquo; for more details)</p>
</td></tr>
<tr><td><code id="write_objects_+3A_chunk_size">chunk_size</code></td>
<td>
<p>The chunk size for the rank matrix (See <code>rhdf5::h5createDataset</code> for more details)</p>
</td></tr>
<tr><td><code id="write_objects_+3A_gene_variance_threshold">gene_variance_threshold</code></td>
<td>
<p>The threshold for the gene variance; genes with variance below this threshold will be removed</p>
</td></tr>
<tr><td><code id="write_objects_+3A_summary_function">summary_function</code></td>
<td>
<p>The function used for summarizing the stability values; the default is <code>median</code></p>
</td></tr>
<tr><td><code id="write_objects_+3A_qualpalr_colorspace">qualpalr_colorspace</code></td>
<td>
<p>The colorspace used for generating the colors; the default is <code>pretty</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (the files are written in the project_folder)
</p>

<hr>
<h2 id='write_shiny_app'>Create the ClustAssess ShinyApp</h2><span id='topic+write_shiny_app'></span><span id='topic+write_shiny_app.Seurat'></span><span id='topic+write_shiny_app.default'></span>

<h3>Description</h3>

<p>Creates the ClustAssess ShinyApp based on the output of the
automatic ClustAssess pipeline. In addition to that, the expression matrix
and the metadata dataframe are provided as input to the ShinyApp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_shiny_app(
  object,
  metadata = NULL,
  assay_name = NULL,
  clustassess_object,
  project_folder,
  compression_level = 6,
  summary_function = stats::median,
  shiny_app_title = "",
  organism_enrichment = "hsapiens",
  height_ratio = 0.6,
  qualpalr_colorspace = "pretty"
)

## S3 method for class 'Seurat'
write_shiny_app(
  object,
  metadata = NULL,
  assay_name,
  clustassess_object,
  project_folder,
  compression_level = 6,
  summary_function = stats::median,
  shiny_app_title = "",
  organism_enrichment = "hsapiens",
  height_ratio = 0.6,
  qualpalr_colorspace = "pretty"
)

## Default S3 method:
write_shiny_app(
  object,
  metadata = NULL,
  assay_name = NULL,
  clustassess_object,
  project_folder,
  compression_level = 6,
  summary_function = stats::median,
  shiny_app_title = "",
  organism_enrichment = "hsapiens",
  height_ratio = 0.6,
  qualpalr_colorspace = "pretty"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_shiny_app_+3A_object">object</code></td>
<td>
<p>A Seurat object or an expression matrix</p>
</td></tr>
<tr><td><code id="write_shiny_app_+3A_metadata">metadata</code></td>
<td>
<p>The metadata dataframe. This parameter will be ignored if
the object is a Seurat object.</p>
</td></tr>
<tr><td><code id="write_shiny_app_+3A_assay_name">assay_name</code></td>
<td>
<p>The name of the assay to be used to extract the expression matrix
from the Seurat object. This parameter will be ignored if the object is not
a Seurat object.</p>
</td></tr>
<tr><td><code id="write_shiny_app_+3A_clustassess_object">clustassess_object</code></td>
<td>
<p>The output of the ClustAssess automatic pipeline</p>
</td></tr>
<tr><td><code id="write_shiny_app_+3A_project_folder">project_folder</code></td>
<td>
<p>The folder where the files will be written</p>
</td></tr>
<tr><td><code id="write_shiny_app_+3A_compression_level">compression_level</code></td>
<td>
<p>The compression level for the h5 files (See 'rhdf5::h5createFile&ldquo; for more details)</p>
</td></tr>
<tr><td><code id="write_shiny_app_+3A_summary_function">summary_function</code></td>
<td>
<p>The function used for summarizing the stability values; the default is <code>median</code></p>
</td></tr>
<tr><td><code id="write_shiny_app_+3A_shiny_app_title">shiny_app_title</code></td>
<td>
<p>The title of the shiny app</p>
</td></tr>
<tr><td><code id="write_shiny_app_+3A_organism_enrichment">organism_enrichment</code></td>
<td>
<p>The organism used for the enrichment analysis; the default is <code>hsapiens</code></p>
</td></tr>
<tr><td><code id="write_shiny_app_+3A_height_ratio">height_ratio</code></td>
<td>
<p>The ratio of the height of the plot to the height of the browser; the default is <code>0.6</code></p>
</td></tr>
<tr><td><code id="write_shiny_app_+3A_qualpalr_colorspace">qualpalr_colorspace</code></td>
<td>
<p>The colorspace used for generating the colors; the default is <code>pretty</code></p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
