<!DOCTYPE html><html><head><title>Help for package ClustAssess</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ClustAssess}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#Clustering-class'><p>The Clustering Class</p></a></li>
<li><a href='#consensus_cluster'><p>Consensus Clustering and Proportion of Ambiguously Clustered Pairs</p></a></li>
<li><a href='#create_clustering'><p>Create Clustering Object</p></a></li>
<li><a href='#element_agreement'><p>Element-Wise Average Agreement Between a Set of Clusterings</p></a></li>
<li><a href='#element_consistency'><p>Element-Wise Consistency Between a Set of Clusterings</p></a></li>
<li><a href='#element_sim'><p>The Element-Centric Clustering Similarity</p></a></li>
<li><a href='#element_sim_elscore'><p>The Element-Centric Clustering Similarity for each Element</p></a></li>
<li><a href='#element_sim_matrix'><p>Pairwise Comparison of Clusterings</p></a></li>
<li><a href='#get_clustering_difference'><p>Graph Clustering Method Stability</p></a></li>
<li><a href='#get_feature_stability'><p>Evaluate Feature Set Stability</p></a></li>
<li><a href='#get_nn_conn_comps'><p>Relationship Between Nearest Neighbors and Connected Components</p></a></li>
<li><a href='#get_nn_importance'><p>Assess Graph Building Parameters</p></a></li>
<li><a href='#get_resolution_importance'><p>Evaluate Stability Across Resolution, Number of Neighbors, and Graph Type</p></a></li>
<li><a href='#length+2CClustering-method'><p>Length of an Object</p></a></li>
<li><a href='#marker_overlap'><p>Cell-Wise Marker Gene Overlap</p></a></li>
<li><a href='#merge_partitions'><p>Merge Partitions</p></a></li>
<li><a href='#merge_resolutions'><p>Merge Resolutions</p></a></li>
<li><a href='#pac_convergence'><p>PAC Convergence Plot</p></a></li>
<li><a href='#pac_landscape'><p>PAC Landscape Plot</p></a></li>
<li><a href='#plot_clustering_difference_boxplot'><p>Clustering Method Stability Boxplot</p></a></li>
<li><a href='#plot_clustering_difference_facet'><p>Clustering Method Stability Facet Plot</p></a></li>
<li><a href='#plot_connected_comps_evolution'><p>Relationship Between Number of Nearest Neighbors and Graph Connectivity</p></a></li>
<li><a href='#plot_feature_stability_boxplot'><p>Feature Stability Boxplot</p></a></li>
<li><a href='#plot_feature_stability_ecs_facet'><p>Feature Stability - EC Consistency Facet Plot</p></a></li>
<li><a href='#plot_feature_stability_ecs_incremental'><p>Feature Stability Incremental Boxplot</p></a></li>
<li><a href='#plot_feature_stability_mb_facet'><p>Feature Stability - Cluster Membership Facet Plot</p></a></li>
<li><a href='#plot_k_n_partitions'><p>Relationship Between the Number of Clusters and the Number of Unique Partitions</p></a></li>
<li><a href='#plot_k_resolution_corresp'><p>Correspondence Between Resolution and the Number of Clusters</p></a></li>
<li><a href='#plot_n_neigh_ecs'><p>Graph construction parameters - ECC facet</p></a></li>
<li><a href='#plot_n_neigh_k_correspondence'><p>Relationship Between Number of Nearest Neighbors and Number of Clusters</p></a></li>
<li><a href='#print+2CClustering-method'><p>Print an Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Assessing Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arash Shahsavari &lt;as3006@cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for evaluating clustering robustness using 
    proportion of ambiguously clustered pairs (Senbabaoglu et al. (2014) 
    &lt;<a href="https://doi.org/10.1038%2Fsrep06207">doi:10.1038/srep06207</a>&gt;), as well as similarity across methods 
    and method stability using element-centric clustering comparison (Gates et 
    al. (2019) &lt;<a href="https://doi.org/10.1038%2Fs41598-019-44892-y">doi:10.1038/s41598-019-44892-y</a>&gt;). Additionally, this package 
    enables stability-based parameter assessment for graph-based clustering 
    pipelines typical in single-cell data analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, dplyr, fastcluster, rlang, Matrix, igraph, magrittr,
Rcpp, methods, stats, foreach, doParallel, irlba, progress,
reshape2, stringr, uwot</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, e1071, dbscan, dendextend, Seurat, readr,
patchwork</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Core-Bioinformatics/ClustAssess">https://github.com/Core-Bioinformatics/ClustAssess</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Core-Bioinformatics/ClustAssess/issues">https://github.com/Core-Bioinformatics/ClustAssess/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-26 16:10:05 UTC; as3006</td>
</tr>
<tr>
<td>Author:</td>
<td>Arash Shahsavari [aut, cre],
  Andi Munteanu [aut],
  Irina Mohorianu [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-26 16:52:46 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p>return value of rhs function
</p>

<hr>
<h2 id='Clustering-class'>The Clustering Class</h2><span id='topic+Clustering-class'></span><span id='topic+Clustering'></span>

<h3>Description</h3>

<p>A class containing relevant data for comparing clusterings,
including the affinity matrix for the Clustering.
</p>


<h3>Slots</h3>


<dl>
<dt><code>names</code></dt><dd><p>A character vector of element names; will be 1:n_elements if no
names were available when creating the Clustering object.</p>
</dd>
<dt><code>n_elements</code></dt><dd><p>A numeric giving the number of elements.</p>
</dd>
<dt><code>is_hierarchical</code></dt><dd><p>A logical indicating whether the clustering is
hierarchical or flat.</p>
</dd>
<dt><code>is_disjoint</code></dt><dd><p>A logical indicating whether the clustering is disjoint or
overlapping.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</dd>
<dt><code>r</code></dt><dd><p>A numeric hierarchical scaling parameter.</p>
</dd>
<dt><code>elm2clu_dict</code></dt><dd><p>A list giving the clusters each element is a member of.</p>
</dd>
<dt><code>clu2elm_dict</code></dt><dd><p>A list giving the element members of each cluster.</p>
</dd>
<dt><code>affinity_matrix</code></dt><dd><p>A Matrix containing the personalized pagerank
equilibrium distribution.</p>
</dd>
</dl>

<hr>
<h2 id='consensus_cluster'>Consensus Clustering and Proportion of Ambiguously Clustered Pairs</h2><span id='topic+consensus_cluster'></span>

<h3>Description</h3>

<p>Calculate consensus clustering and proportion of ambiguously
clustered pairs (PAC) with hierarchical clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus_cluster(
  x,
  k_min = 3,
  k_max = 100,
  n_reps = 100,
  p_sample = 0.8,
  p_feature = 1,
  p_minkowski = 2,
  dist_method = "euclidean",
  linkage = "complete",
  lower_lim = 0.1,
  upper_lim = 0.9,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensus_cluster_+3A_x">x</code></td>
<td>
<p>A samples x features normalized data matrix.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_k_min">k_min</code></td>
<td>
<p>The minimum number of clusters calculated.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_k_max">k_max</code></td>
<td>
<p>The maximum number of clusters calculated.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_n_reps">n_reps</code></td>
<td>
<p>The total number of subsamplings and reclusterings of the data;
this value needs to be high enough to ensure PAC converges; convergence can
be assessed with pac_convergence.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_p_sample">p_sample</code></td>
<td>
<p>The proportion of samples included in each subsample.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_p_feature">p_feature</code></td>
<td>
<p>The proportion of features included in each subsample.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_p_minkowski">p_minkowski</code></td>
<td>
<p>The power of the Minkowski distance.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_dist_method">dist_method</code></td>
<td>
<p>The distance measure for the distance matrix used in
hclust; must be one of &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;,
&quot;binary&quot; or &quot;minkowski&quot;.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_linkage">linkage</code></td>
<td>
<p>The linkage method used in hclust; must be one of &quot;ward.D&quot;,
&quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot; or
&quot;centroid&quot;</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_lower_lim">lower_lim</code></td>
<td>
<p>The lower limit for determining whether a pair is
clustered ambiguously; the lower this value, the higher the PAC.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_upper_lim">upper_lim</code></td>
<td>
<p>The upper limit for determining whether a pair is
clustered ambiguously; the higher this value, the higher the PAC.</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_verbose">verbose</code></td>
<td>
<p>Logical value used for choosing to display a progress bar or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with PAC values across iterations, as well as parameter
values used when calling the method.
</p>


<h3>References</h3>

<p>Monti, S., Tamayo, P., Mesirov, J., &amp; Golub, T. (2003).
Consensus clustering: a resampling-based method for class discovery and
visualization of gene expression microarray data. Machine learning, 52(1),
91-118. https://doi.org/10.1023/A:1023949509487
</p>
<p>Senbabaoglu, Y., Michailidis, G., &amp; Li, J. Z. (2014).
Critical limitations of consensus clustering in class discovery.
Scientific reports, 4(1), 1-13. https://doi.org/10.1038/srep06207
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pac.res = consensus_cluster(iris[,1:4], k_max=20)
pac_convergence(pac.res, k_plot=c(3,5,7,9))
</code></pre>

<hr>
<h2 id='create_clustering'>Create Clustering Object</h2><span id='topic+create_clustering'></span><span id='topic+create_clustering+2Cnumeric-method'></span><span id='topic+create_clustering+2Cinteger-method'></span><span id='topic+create_clustering+2Ccharacter-method'></span><span id='topic+create_clustering+2Cfactor-method'></span><span id='topic+create_clustering+2Cmatrix-method'></span><span id='topic+create_clustering+2CMatrix-method'></span><span id='topic+create_clustering+2Chclust-method'></span>

<h3>Description</h3>

<p>Creates a Clustering object from the output of a clustering
method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_clustering(clustering_result, ...)

## S4 method for signature 'numeric'
create_clustering(clustering_result, alpha = 0.9)

## S4 method for signature 'integer'
create_clustering(clustering_result, alpha = 0.9)

## S4 method for signature 'character'
create_clustering(clustering_result, alpha = 0.9)

## S4 method for signature 'factor'
create_clustering(clustering_result, alpha = 0.9)

## S4 method for signature 'matrix'
create_clustering(
  clustering_result,
  alpha = 0.9,
  ppr_implementation = "prpack",
  row_normalize = TRUE
)

## S4 method for signature 'Matrix'
create_clustering(
  clustering_result,
  alpha = 0.9,
  ppr_implementation = "prpack",
  row_normalize = TRUE
)

## S4 method for signature 'hclust'
create_clustering(
  clustering_result,
  alpha = 0.9,
  r = 1,
  rescale_path_type = "max",
  ppr_implementation = "prpack",
  dist_rescaled = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_clustering_+3A_clustering_result">clustering_result</code></td>
<td>
<p>The clustering result, either:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="create_clustering_+3A_...">...</code></td>
<td>
<p>This argument is not used.</p>
</td></tr>
<tr><td><code id="create_clustering_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</td></tr>
<tr><td><code id="create_clustering_+3A_ppr_implementation">ppr_implementation</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="create_clustering_+3A_row_normalize">row_normalize</code></td>
<td>
<p>Whether to normalize all rows in clustering_result
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
<tr><td><code id="create_clustering_+3A_r">r</code></td>
<td>
<p>A numeric hierarchical scaling parameter.</p>
</td></tr>
<tr><td><code id="create_clustering_+3A_rescale_path_type">rescale_path_type</code></td>
<td>
<p>A string; rescale the hierarchical height by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="create_clustering_+3A_dist_rescaled">dist_rescaled</code></td>
<td>
<p>A logical: if TRUE, the linkage distances are linearly
rescaled to be in-between 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Clustering object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>numeric</code>: Create Clustering Object from Numeric Vector
</p>
</li>
<li> <p><code>integer</code>: Create Clustering Object from Integer Vector
</p>
</li>
<li> <p><code>character</code>: Create Clustering Object from Character Vector
</p>
</li>
<li> <p><code>factor</code>: Create Clustering Object from Factor Vector
</p>
</li>
<li> <p><code>matrix</code>: Create Clustering Object from base matrix
</p>
</li>
<li> <p><code>Matrix</code>: Create Clustering Object from Matrix::Matrix
</p>
</li>
<li> <p><code>hclust</code>: Create Clustering Object from hclust
</p>
</li></ul>

<hr>
<h2 id='element_agreement'>Element-Wise Average Agreement Between a Set of Clusterings</h2><span id='topic+element_agreement'></span>

<h3>Description</h3>

<p>Inspect how consistently of a set of clusterings agree with
a reference clustering by calculating their element-wise average agreement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_agreement(
  reference_clustering,
  clustering_list,
  alpha = 0.9,
  r = 1,
  rescale_path_type = "max",
  ppr_implementation = "prpack",
  dist_rescaled = FALSE,
  row_normalize = TRUE,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_agreement_+3A_reference_clustering">reference_clustering</code></td>
<td>
<p>The reference clustering, that each clustering in
clustering_list is compared to. It can be either:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_agreement_+3A_clustering_list">clustering_list</code></td>
<td>
<p>The list of clustering results, each of which is either:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_agreement_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</td></tr>
<tr><td><code id="element_agreement_+3A_r">r</code></td>
<td>
<p>A numeric hierarchical scaling parameter.</p>
</td></tr>
<tr><td><code id="element_agreement_+3A_rescale_path_type">rescale_path_type</code></td>
<td>
<p>A string; rescale the hierarchical height by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_agreement_+3A_ppr_implementation">ppr_implementation</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_agreement_+3A_dist_rescaled">dist_rescaled</code></td>
<td>
<p>A logical: if TRUE, the linkage distances are linearly
rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_agreement_+3A_row_normalize">row_normalize</code></td>
<td>
<p>Whether to normalize all rows in clustering_result
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
<tr><td><code id="element_agreement_+3A_ncores">ncores</code></td>
<td>
<p>the number of parallel R instances that will run the code.
If the value is set to 1, the code will be run sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the element-wise average agreement.
</p>


<h3>References</h3>

<p>Gates, A. J., Wood, I. B., Hetrick, W. P., &amp; Ahn, Y. Y. (2019).
Element-centric clustering comparison unifies overlaps and hierarchy.
Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reference.clustering = iris$Species
clustering.list = list()
for (i in 1:20){
  clustering.list[[i]] = kmeans(iris[,1:4], 3)$cluster
}
element_agreement(reference.clustering, clustering.list)
</code></pre>

<hr>
<h2 id='element_consistency'>Element-Wise Consistency Between a Set of Clusterings</h2><span id='topic+element_consistency'></span>

<h3>Description</h3>

<p>Inspect the consistency of a set of clusterings by calculating
their element-wise clustering consistency (also known as element-wise frustration).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_consistency(
  clustering_list,
  alpha = 0.9,
  r = 1,
  rescale_path_type = "max",
  ppr_implementation = "prpack",
  dist_rescaled = FALSE,
  row_normalize = TRUE,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_consistency_+3A_clustering_list">clustering_list</code></td>
<td>
<p>The list of clustering results, each of which is either:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_consistency_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</td></tr>
<tr><td><code id="element_consistency_+3A_r">r</code></td>
<td>
<p>A numeric hierarchical scaling parameter.</p>
</td></tr>
<tr><td><code id="element_consistency_+3A_rescale_path_type">rescale_path_type</code></td>
<td>
<p>A string; rescale the hierarchical height by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_consistency_+3A_ppr_implementation">ppr_implementation</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_consistency_+3A_dist_rescaled">dist_rescaled</code></td>
<td>
<p>A logical: if TRUE, the linkage distances are linearly
rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_consistency_+3A_row_normalize">row_normalize</code></td>
<td>
<p>Whether to normalize all rows in clustering_result
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
<tr><td><code id="element_consistency_+3A_ncores">ncores</code></td>
<td>
<p>the number of parallel R instances that will run the code.
If the value is set to 1, the code will be run sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the element-wise consistency.
</p>


<h3>References</h3>

<p>Gates, A. J., Wood, I. B., Hetrick, W. P., &amp; Ahn, Y. Y. (2019).
Element-centric clustering comparison unifies overlaps and hierarchy.
Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clustering.list = list()
for (i in 1:20){
  clustering.list[[i]] = kmeans(mtcars, 3)$cluster
}
element_consistency(clustering.list)
</code></pre>

<hr>
<h2 id='element_sim'>The Element-Centric Clustering Similarity</h2><span id='topic+element_sim'></span>

<h3>Description</h3>

<p>Calculates the average element-centric similarity between two
clustering results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_sim(
  clustering1,
  clustering2,
  alpha = 0.9,
  r_cl1 = 1,
  rescale_path_type_cl1 = "max",
  ppr_implementation_cl1 = "prpack",
  dist_rescaled_cl1 = FALSE,
  row_normalize_cl1 = TRUE,
  r_cl2 = 1,
  rescale_path_type_cl2 = "max",
  ppr_implementation_cl2 = "prpack",
  dist_rescaled_cl2 = FALSE,
  row_normalize_cl2 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_sim_+3A_clustering1">clustering1</code></td>
<td>
<p>The first clustering result, which can be one of:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_+3A_clustering2">clustering2</code></td>
<td>
<p>The second clustering result, which can be one of:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</td></tr>
<tr><td><code id="element_sim_+3A_r_cl1">r_cl1</code></td>
<td>
<p>A numeric hierarchical scaling parameter for the first clustering.</p>
</td></tr>
<tr><td><code id="element_sim_+3A_rescale_path_type_cl1">rescale_path_type_cl1</code></td>
<td>
<p>A string; rescale the hierarchical height of
the first clustering by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_+3A_ppr_implementation_cl1">ppr_implementation_cl1</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation for the first clustering:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_+3A_dist_rescaled_cl1">dist_rescaled_cl1</code></td>
<td>
<p>A logical: if TRUE, the linkage distances of the first
clustering are linearly rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_sim_+3A_row_normalize_cl1">row_normalize_cl1</code></td>
<td>
<p>Whether to normalize all rows in the first clustering
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
<tr><td><code id="element_sim_+3A_r_cl2">r_cl2</code></td>
<td>
<p>A numeric hierarchical scaling parameter for the second clustering.</p>
</td></tr>
<tr><td><code id="element_sim_+3A_rescale_path_type_cl2">rescale_path_type_cl2</code></td>
<td>
<p>A string; rescale the hierarchical height of
the second clustering by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_+3A_ppr_implementation_cl2">ppr_implementation_cl2</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation for the second clustering:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_+3A_dist_rescaled_cl2">dist_rescaled_cl2</code></td>
<td>
<p>A logical: if TRUE, the linkage distances of the second
clustering are linearly rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_sim_+3A_row_normalize_cl2">row_normalize_cl2</code></td>
<td>
<p>Whether to normalize all rows in the second clustering
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The average element-wise similarity between the two Clusterings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>km.res = kmeans(mtcars, 3)$cluster
hc.res = hclust(dist(mtcars))
element_sim(km.res, hc.res)
</code></pre>

<hr>
<h2 id='element_sim_elscore'>The Element-Centric Clustering Similarity for each Element</h2><span id='topic+element_sim_elscore'></span>

<h3>Description</h3>

<p>Calculates the element-wise element-centric similarity between
two clustering results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_sim_elscore(
  clustering1,
  clustering2,
  alpha = 0.9,
  r_cl1 = 1,
  rescale_path_type_cl1 = "max",
  ppr_implementation_cl1 = "prpack",
  dist_rescaled_cl1 = FALSE,
  row_normalize_cl1 = TRUE,
  r_cl2 = 1,
  rescale_path_type_cl2 = "max",
  ppr_implementation_cl2 = "prpack",
  dist_rescaled_cl2 = FALSE,
  row_normalize_cl2 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_sim_elscore_+3A_clustering1">clustering1</code></td>
<td>
<p>The first clustering result, which can be one of:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_clustering2">clustering2</code></td>
<td>
<p>The second clustering result, which can be one of:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_r_cl1">r_cl1</code></td>
<td>
<p>A numeric hierarchical scaling parameter for the first clustering.</p>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_rescale_path_type_cl1">rescale_path_type_cl1</code></td>
<td>
<p>A string; rescale the hierarchical height of
the first clustering by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_ppr_implementation_cl1">ppr_implementation_cl1</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation for the first clustering:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_dist_rescaled_cl1">dist_rescaled_cl1</code></td>
<td>
<p>A logical: if TRUE, the linkage distances of the first
clustering are linearly rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_row_normalize_cl1">row_normalize_cl1</code></td>
<td>
<p>Whether to normalize all rows in the first clustering
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_r_cl2">r_cl2</code></td>
<td>
<p>A numeric hierarchical scaling parameter for the second clustering.</p>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_rescale_path_type_cl2">rescale_path_type_cl2</code></td>
<td>
<p>A string; rescale the hierarchical height of
the second clustering by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_ppr_implementation_cl2">ppr_implementation_cl2</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation for the second clustering:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_dist_rescaled_cl2">dist_rescaled_cl2</code></td>
<td>
<p>A logical: if TRUE, the linkage distances of the second
clustering are linearly rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_sim_elscore_+3A_row_normalize_cl2">row_normalize_cl2</code></td>
<td>
<p>Whether to normalize all rows in the second clustering
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of element-centric similarity between the two clusterings for
each element.
</p>


<h3>References</h3>

<p>Gates, A. J., Wood, I. B., Hetrick, W. P., &amp; Ahn, Y. Y. (2019).
Element-centric clustering comparison unifies overlaps and hierarchy.
Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>km.res = kmeans(iris[,1:4], centers=8)$cluster
hc.res = hclust(dist(iris[,1:4]))
element_sim_elscore(km.res, hc.res)
</code></pre>

<hr>
<h2 id='element_sim_matrix'>Pairwise Comparison of Clusterings</h2><span id='topic+element_sim_matrix'></span>

<h3>Description</h3>

<p>Compare a set of clusterings by calculating their pairwise
average element-centric clustering similarities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_sim_matrix(
  clustering_list,
  output_type = "matrix",
  alpha = 0.9,
  r = 1,
  rescale_path_type = "max",
  ppr_implementation = "prpack",
  dist_rescaled = FALSE,
  row_normalize = TRUE,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_sim_matrix_+3A_clustering_list">clustering_list</code></td>
<td>
<p>The list of clustering results, each of which is either:
</p>

<ul>
<li><p> A numeric/character/factor vector of cluster labels for each element.
</p>
</li>
<li><p> A samples x clusters matrix/Matrix::Matrix of nonzero membership values.
</p>
</li>
<li><p> An hclust object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_output_type">output_type</code></td>
<td>
<p>A string specifying whether the output should be a
matrix or a data.frame.</p>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the personalized PageRank damping factor;
1 - alpha is the restart probability for the PPR random walk.</p>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_r">r</code></td>
<td>
<p>A numeric hierarchical scaling parameter.</p>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_rescale_path_type">rescale_path_type</code></td>
<td>
<p>A string; rescale the hierarchical height by:
</p>

<ul>
<li><p> &quot;max&quot; : the maximum path from the root.
</p>
</li>
<li><p> &quot;min&quot; : the minimum path form the root.
</p>
</li>
<li><p> &quot;linkage&quot; : use the linkage distances in the clustering.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_ppr_implementation">ppr_implementation</code></td>
<td>
<p>Choose a implementation for personalized
page-rank calculation:
</p>

<ul>
<li><p> &quot;prpack&quot;: use PPR algorithms in igraph.
</p>
</li>
<li><p> &quot;power_iteration&quot;: use power_iteration method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_dist_rescaled">dist_rescaled</code></td>
<td>
<p>A logical: if TRUE, the linkage distances are linearly
rescaled to be in-between 0 and 1.</p>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_row_normalize">row_normalize</code></td>
<td>
<p>Whether to normalize all rows in clustering_result
so they sum to one before calculating ECS. It is recommended to set this to
TRUE, which will lead to slightly different ECS values compared to clusim.</p>
</td></tr>
<tr><td><code id="element_sim_matrix_+3A_ncores">ncores</code></td>
<td>
<p>the number of parallel R instances that will run the code.
If the value is set to 1, the code will be run sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or data.frame containing the pairwise ECS values.
</p>


<h3>References</h3>

<p>Gates, A. J., Wood, I. B., Hetrick, W. P., &amp; Ahn, Y. Y. (2019).
Element-centric clustering comparison unifies overlaps and hierarchy.
Scientific reports, 9(1), 1-13. https://doi.org/10.1038/s41598-019-44892-y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clustering.list = list()
for (i in 1:20) {
  clustering.list[[i]] = kmeans(mtcars, 3)$cluster
}
element_sim_matrix(clustering.list, output_type="matrix")
</code></pre>

<hr>
<h2 id='get_clustering_difference'>Graph Clustering Method Stability</h2><span id='topic+get_clustering_difference'></span>

<h3>Description</h3>

<p>Evaluates the stability of different graph clustering methods
in the clustering pipeline. The method will iterate through different values of
the resolution parameter and compare, using the EC Consistency score, the
partitions obtained at different seeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clustering_difference(
  graph_adjacency_matrix,
  resolution,
  n_repetitions = 100,
  seed_sequence = NULL,
  ecs_thresh = 1,
  ncores = 1,
  algorithm = 1:4,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_clustering_difference_+3A_graph_adjacency_matrix">graph_adjacency_matrix</code></td>
<td>
<p>A square adjacency matrix based on which an igraph
object will be built.</p>
</td></tr>
<tr><td><code id="get_clustering_difference_+3A_resolution">resolution</code></td>
<td>
<p>A sequence of resolution values.</p>
</td></tr>
<tr><td><code id="get_clustering_difference_+3A_n_repetitions">n_repetitions</code></td>
<td>
<p>The number of repetitions of applying the pipeline with
different seeds; ignored if seed_sequence is provided by the user.</p>
</td></tr>
<tr><td><code id="get_clustering_difference_+3A_seed_sequence">seed_sequence</code></td>
<td>
<p>A custom seed sequence; if the value is NULL, the
sequence will be built starting from 1 with a step of 100.</p>
</td></tr>
<tr><td><code id="get_clustering_difference_+3A_ecs_thresh">ecs_thresh</code></td>
<td>
<p>The ECS threshold used for merging similar clusterings.</p>
</td></tr>
<tr><td><code id="get_clustering_difference_+3A_ncores">ncores</code></td>
<td>
<p>The number of parallel R instances that will run the code.
If the value is set to 1, the code will be run sequentially.</p>
</td></tr>
<tr><td><code id="get_clustering_difference_+3A_algorithm">algorithm</code></td>
<td>
<p>An index or a list of indexes indicating which community detection
algorithm will be used: Louvain (1), Louvain refined (2), SLM (3) or Leiden (4).
More details can be found in the Seurat's <code>FindClusters</code> function.</p>
</td></tr>
<tr><td><code id="get_clustering_difference_+3A_verbose">verbose</code></td>
<td>
<p>Boolean value used for displaying the progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having two fields:
</p>

<ul>
<li><p> all - a list that contains, for each clustering method and each resolution
value, the EC consistency between the partitions obtained by changing the seed
</p>
</li>
<li><p> filtered - similar to <code>all</code>, but for each configuration, we determine the
number of clusters that appears the most and use only the partitions with this
size
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(runif(100*10), nrow = 100)
rownames(expr_matrix) = as.character(1:100)

adj_matrix = Seurat::FindNeighbors(expr_matrix,
    k.param = 10,
    nn.method = "rann",
    verbose = FALSE,
    compute.SNN = FALSE)$nn
clust_diff_obj = get_clustering_difference(graph_adjacency_matrix = adj_matrix,
    resolution = c(0.5, 1),
    n_repetitions = 10,
    algorithm = 1:2,
    verbose = FALSE)
plot_clustering_difference_boxplot(clust_diff_obj)
</code></pre>

<hr>
<h2 id='get_feature_stability'>Evaluate Feature Set Stability</h2><span id='topic+get_feature_stability'></span>

<h3>Description</h3>

<p>Evaluate the stability of clusterings obtained
based on incremental subsets of a given feature set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_feature_stability(
  data_matrix,
  feature_set,
  steps,
  feature_type,
  n_repetitions = 100,
  seed_sequence = NULL,
  graph_reduction_type = "PCA",
  npcs = 30,
  ecs_thresh = 1,
  ncores = 1,
  algorithm = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_feature_stability_+3A_data_matrix">data_matrix</code></td>
<td>
<p>A data matrix having the features on the rows
and the observations on the columns.</p>
</td></tr>
<tr><td><code id="get_feature_stability_+3A_feature_set">feature_set</code></td>
<td>
<p>A set of feature names that can be found on the rownames of
the data matrix.</p>
</td></tr>
<tr><td><code id="get_feature_stability_+3A_steps">steps</code></td>
<td>
<p>Vector containing the sizes of the subsets; negative values will
be interpreted as using all features.</p>
</td></tr>
<tr><td><code id="get_feature_stability_+3A_feature_type">feature_type</code></td>
<td>
<p>A name associated to the feature_set.</p>
</td></tr>
<tr><td><code id="get_feature_stability_+3A_n_repetitions">n_repetitions</code></td>
<td>
<p>The number of repetitions of applying the pipeline with
different seeds; ignored if seed_sequence is provided by the user.</p>
</td></tr>
<tr><td><code id="get_feature_stability_+3A_seed_sequence">seed_sequence</code></td>
<td>
<p>A custom seed sequence; if the value is NULL, the
sequence will be built starting from 1 with a step of 100.</p>
</td></tr>
<tr><td><code id="get_feature_stability_+3A_graph_reduction_type">graph_reduction_type</code></td>
<td>
<p>The graph reduction type, denoting if the graph
should be built on either the PCA or the UMAP embedding.</p>
</td></tr>
<tr><td><code id="get_feature_stability_+3A_npcs">npcs</code></td>
<td>
<p>The number of principal components.</p>
</td></tr>
<tr><td><code id="get_feature_stability_+3A_ecs_thresh">ecs_thresh</code></td>
<td>
<p>The ECS threshold used for merging similar clusterings.</p>
</td></tr>
<tr><td><code id="get_feature_stability_+3A_ncores">ncores</code></td>
<td>
<p>The number of parallel R instances that will run the code. If
the value is set to 1, the code will be run sequentially.</p>
</td></tr>
<tr><td><code id="get_feature_stability_+3A_algorithm">algorithm</code></td>
<td>
<p>An index indicating which community detection algorithm will
be used: Louvain (1), Louvain refined (2), SLM (3) or Leiden (4). More details
can be found in the Seurat's <code>FindClusters</code> function.</p>
</td></tr>
<tr><td><code id="get_feature_stability_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the umap method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having one field associated with a step value. Each step
contains a list with three fields:
</p>

<ul>
<li><p> ecc - the EC-Consistency of the partitions obtained on all repetitions
</p>
</li>
<li><p> embedding - one UMAP embedding generated on the feature subset
</p>
</li>
<li><p> most_frequent_partition - the most common partition obtained across repetitions
</p>
</li></ul>



<h3>Note</h3>

<p>The algorithm assumes that the feature_set is already sorted when performing
the subsetting. For example, if the user wants to analyze highly variable feature set,
they should provide them sorted by their variability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(c(runif(100*10), runif(100*10, min = 3, max = 4)), nrow = 200, byrow = TRUE)
rownames(expr_matrix) = as.character(1:200)
colnames(expr_matrix) = paste("feature", 1:10)

feature_stability_result = get_feature_stability(data_matrix = t(expr_matrix),
   feature_set = colnames(expr_matrix),
   feature_type = "feature_name",
   steps = 5,
   npcs = 2,
   n_repetitions = 10,
   algorithm = 1,
   # the following parameters are used by the umap function and are not mandatory
   n_neighbors = 3,
   approx_pow = TRUE,
   n_epochs = 0,
   init = "random",
   min_dist = 0.3)
plot_feature_stability_boxplot(feature_stability_result)
</code></pre>

<hr>
<h2 id='get_nn_conn_comps'>Relationship Between Nearest Neighbors and Connected Components</h2><span id='topic+get_nn_conn_comps'></span>

<h3>Description</h3>

<p>One of the steps in the clustering pipeline is building a
k-nearest neighbor graph on a reduced-space embedding. This method assesses
the relationship between different number of nearest
neighbors and the connectivity of the graph. In the context of graph clustering,
the number of connected components can be used as a
lower bound for the number of clusters. The calculations are performed multiple
times by changing the seed at each repetition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nn_conn_comps(
  object,
  n_neigh_sequence,
  config_name = "",
  n_repetitions = 100,
  seed_sequence = NULL,
  graph_reduction_type = "UMAP",
  transpose = (graph_reduction_type == "PCA"),
  ncores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nn_conn_comps_+3A_object">object</code></td>
<td>
<p>A data matrix. If the graph reduction type is PCA, the object
should be an expression matrix, with features on rows and observations on columns;
in the case of UMAP, the user could also provide a matrix associated to a PCA embedding.
See also the transpose argument.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_n_neigh_sequence">n_neigh_sequence</code></td>
<td>
<p>A sequence of the number of nearest neighbors.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_config_name">config_name</code></td>
<td>
<p>User specified string that uniquely describes the embedding characteristics.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_n_repetitions">n_repetitions</code></td>
<td>
<p>The number of repetitions of applying the pipeline with different seeds; ignored if seed_sequence is provided by the user.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_seed_sequence">seed_sequence</code></td>
<td>
<p>A custom seed sequence; if the value is NULL, the sequence will be built starting from 1 with a step of 100.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_graph_reduction_type">graph_reduction_type</code></td>
<td>
<p>The graph reduction type, denoting if the graph should be built on either the PCA or the UMAP embedding.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_transpose">transpose</code></td>
<td>
<p>Logical: whether the input object will be transposed or not.
Set to FALSE if the input is an observations X features matrix, and set to TRUE
if the input is a features X observations matrix.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_ncores">ncores</code></td>
<td>
<p>The number of parallel R instances that will run the code. If the value is set to 1, the code will be run sequentially.</p>
</td></tr>
<tr><td><code id="get_nn_conn_comps_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the 'irlba::irlba' or the 'uwot::umap' method, depending on the value of graph_reduction_type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having one field associated with a number of nearest neighbors.
Each value contains an array of the number of connected components
obtained on the specified number of repetitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(c(runif(50*10), runif(50*10, min = 1, max = 2)), nrow = 100, byrow = TRUE)
rownames(expr_matrix) = as.character(1:100)

# the graph reduction type is PCA, so we can provide the expression matrix as argument
nn_conn_comps_obj = get_nn_conn_comps(object = expr_matrix,
    n_neigh_sequence = c(2,3,5),
    config_name = "example_config",
    n_repetitions = 10,
    graph_reduction_type = "PCA",
    transpose = FALSE,
    # the following parameter is used by the irlba function and is not mandatory
    nv = 3)
plot_connected_comps_evolution(nn_conn_comps_obj)
</code></pre>

<hr>
<h2 id='get_nn_importance'>Assess Graph Building Parameters</h2><span id='topic+get_nn_importance'></span>

<h3>Description</h3>

<p>Evaluates clustering stability when changing the values of different
parameters involved in the graph building step,
namely the base embedding, the graph type and the number of neighbours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nn_importance(
  object,
  n_neigh_sequence,
  n_repetitions = 100,
  seed_sequence = NULL,
  graph_reduction_type = "PCA",
  ecs_thresh = 1,
  ncores = 1,
  transpose = (graph_reduction_type == "PCA"),
  graph_type = 2,
  algorithm = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nn_importance_+3A_object">object</code></td>
<td>
<p>The data matrix. If the graph reduction type is PCA, the object
should be an expression matrix, with features on rows and observations on columns;
in the case of UMAP, the user could also provide a matrix associated to a PCA embedding.
See also the transpose argument.</p>
</td></tr>
<tr><td><code id="get_nn_importance_+3A_n_neigh_sequence">n_neigh_sequence</code></td>
<td>
<p>A sequence of the number of nearest neighbours.</p>
</td></tr>
<tr><td><code id="get_nn_importance_+3A_n_repetitions">n_repetitions</code></td>
<td>
<p>The number of repetitions of applying the pipeline with
different seeds; ignored if seed_sequence is provided by the user.</p>
</td></tr>
<tr><td><code id="get_nn_importance_+3A_seed_sequence">seed_sequence</code></td>
<td>
<p>A custom seed sequence; if the value is NULL,
the sequence will be built starting from 1 with a step of 100.</p>
</td></tr>
<tr><td><code id="get_nn_importance_+3A_graph_reduction_type">graph_reduction_type</code></td>
<td>
<p>The graph reduction type, denoting if the graph
should be built on either the PCA or the UMAP embedding.</p>
</td></tr>
<tr><td><code id="get_nn_importance_+3A_ecs_thresh">ecs_thresh</code></td>
<td>
<p>The ECS threshold used for merging similar clusterings.</p>
</td></tr>
<tr><td><code id="get_nn_importance_+3A_ncores">ncores</code></td>
<td>
<p>The number of parallel R instances that will run the code.
If the value is set to 1, the code will be run sequentially.</p>
</td></tr>
<tr><td><code id="get_nn_importance_+3A_transpose">transpose</code></td>
<td>
<p>Logical: whether the input object will be transposed or not.
Set to FALSE if the input is an observations X features matrix, and set to TRUE
if the input is a features X observations matrix.</p>
</td></tr>
<tr><td><code id="get_nn_importance_+3A_graph_type">graph_type</code></td>
<td>
<p>Argument indicating whether the graph should be
unweighted (0), weighted (1) or both (2).</p>
</td></tr>
<tr><td><code id="get_nn_importance_+3A_algorithm">algorithm</code></td>
<td>
<p>An index indicating which community detection algorithm will
be used: Louvain (1), Louvain refined (2), SLM (3) or Leiden (4). More details
can be found in the Seurat's <code>FindClusters</code> function.</p>
</td></tr>
<tr><td><code id="get_nn_importance_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>irlba::irlba</code> or the <code>uwot::umap</code>
method, depending on the value of graph_reduction_type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having three fields:
</p>

<ul>
<li><p> n_neigh_k_corresp - list containing the number of the clusters obtained by running
the pipeline multiple times with different seed, number of neighbors and graph type (weighted vs unweigted)
</p>
</li>
<li><p> n_neigh_ec_consistency - list containing the EC consistency of the partitions obtained
at multiple runs when changing the number of neighbors or the graph type
</p>
</li>
<li><p> n_different_partitions - the number of different partitions obtained by each
number of neighbors
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(c(runif(100*10), runif(100*10, min=5, max=6)), nrow = 200)
rownames(expr_matrix) = as.character(1:200)

nn_importance_obj = get_nn_importance(object = expr_matrix,
    n_neigh_sequence = c(10,15,20),
    n_repetitions = 10,
    graph_reduction_type = "PCA",
    algorithm = 1,
    transpose = FALSE, # the matrix is already observations x features, so we won't transpose it
    # the following parameter is used by the irlba function and is not mandatory
    nv = 2)
plot_n_neigh_ecs(nn_importance_obj)
</code></pre>

<hr>
<h2 id='get_resolution_importance'>Evaluate Stability Across Resolution, Number of Neighbors, and Graph Type</h2><span id='topic+get_resolution_importance'></span>

<h3>Description</h3>

<p>Perform a grid search over the resolution, number of neighbors
and graph type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_resolution_importance(
  embedding,
  resolution,
  n_neigh,
  n_repetitions = 100,
  seed_sequence = NULL,
  clustering_method = 4,
  graph_type = 0,
  object_name = NULL,
  ecs_thresh = 1,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_resolution_importance_+3A_embedding">embedding</code></td>
<td>
<p>The base embedding for the graph construction.</p>
</td></tr>
<tr><td><code id="get_resolution_importance_+3A_resolution">resolution</code></td>
<td>
<p>A sequence of resolution values.</p>
</td></tr>
<tr><td><code id="get_resolution_importance_+3A_n_neigh">n_neigh</code></td>
<td>
<p>A value or a sequence of number of neighbors used for graph construction.</p>
</td></tr>
<tr><td><code id="get_resolution_importance_+3A_n_repetitions">n_repetitions</code></td>
<td>
<p>The number of repetitions of applying the pipeline with
different seeds; ignored if seed_sequence is provided by the user.</p>
</td></tr>
<tr><td><code id="get_resolution_importance_+3A_seed_sequence">seed_sequence</code></td>
<td>
<p>A custom seed sequence; if the value is NULL, the sequence
will be built starting from 1 with a step of 100.</p>
</td></tr>
<tr><td><code id="get_resolution_importance_+3A_clustering_method">clustering_method</code></td>
<td>
<p>An index or a list of indexes indicating which community detection
algorithm will be used: Louvain (1), Louvain refined (2), SLM (3) or Leiden (4).
More details can be found in the Seurat's <code>FindClusters</code> function.</p>
</td></tr>
<tr><td><code id="get_resolution_importance_+3A_graph_type">graph_type</code></td>
<td>
<p>Argument indicating whether the graph should be
unweighted (0), weighted (1) or both (2).</p>
</td></tr>
<tr><td><code id="get_resolution_importance_+3A_object_name">object_name</code></td>
<td>
<p>User specified string that uniquely describes the
embedding characteristics.</p>
</td></tr>
<tr><td><code id="get_resolution_importance_+3A_ecs_thresh">ecs_thresh</code></td>
<td>
<p>The ECS threshold used for merging similar clusterings.</p>
</td></tr>
<tr><td><code id="get_resolution_importance_+3A_ncores">ncores</code></td>
<td>
<p>The number of parallel R instances that will run the code.
If the value is set to 1, the code will be run sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having two fields:
</p>

<ul>
<li><p> split_by_resolution: A five-level list. The hierarchy is as follows:
</p>

<ul>
<li><p> the configuration name: concatenation between the object name provided by
the user, the number of neighbors, the graph type and the clustering method
</p>
</li>
<li><p> the resolution value <code class="reqn">\gamma</code>
</p>
</li>
<li><p> the number of clusters <em>k</em> that can be obtained using the specified resolution
</p>
</li>
<li><p> the partitions obtained with resolution <code class="reqn">\gamma</code> and have <em>k</em> clusters
</p>
</li>
<li><p> the structure of a partitions, which consists in having a <code>mb</code> field with
the flat membership vector, <code>freq</code> denoting its frequency and <code>seed</code>, that is
the seed used to obtain this partition in this configuration.
</p>
</li></ul>

</li>
<li><p> split_by_k: has a similar structure, but the resolution level is removed.
The partitions obtained in a configuration with the same number of clusters
will be merged into the same list.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(runif(500*10), nrow = 500)

# get the PCA embedding of the data
pca_embedding = irlba::irlba(expr_matrix, nv = 2)
pca_embedding = pca_embedding$u %*% diag(pca_embedding$d)
rownames(pca_embedding) = as.character(1:500)

# run the function on the pca embedding
resolution_result = get_resolution_importance(embedding = pca_embedding,
   resolution = c(0.8, 1),
   n_neigh = c(5, 7),
   n_repetitions = 5,
   clustering_method = 1,
   graph_type = 2,
   object_name = "name_example")

plot_k_resolution_corresp(resolution_result)
</code></pre>

<hr>
<h2 id='length+2CClustering-method'>Length of an Object</h2><span id='topic+length+2CClustering-method'></span>

<h3>Description</h3>

<p>Get the number of elements in the Clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Clustering'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length+2B2CClustering-method_+3A_x">x</code></td>
<td>
<p>The Clustering object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of elements.
</p>

<hr>
<h2 id='marker_overlap'>Cell-Wise Marker Gene Overlap</h2><span id='topic+marker_overlap'></span>

<h3>Description</h3>

<p>Calculates the per-cell overlap of previously calculated
marker genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marker_overlap(
  markers1,
  markers2,
  clustering1,
  clustering2,
  n = 25,
  overlap_type = "jsi",
  rank_by = "-p_val",
  use_sign = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker_overlap_+3A_markers1">markers1</code></td>
<td>
<p>The first data frame of marker genes, must contain columns
called 'gene' and 'cluster'.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_markers2">markers2</code></td>
<td>
<p>The second data frame of marker genes, must contain columns
called 'gene' and 'cluster'.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_clustering1">clustering1</code></td>
<td>
<p>The first vector of cluster assignments.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_clustering2">clustering2</code></td>
<td>
<p>The second vector of cluster assignments.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_n">n</code></td>
<td>
<p>The number of top n markers (ranked by rank_by) to use when
calculating the overlap.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_overlap_type">overlap_type</code></td>
<td>
<p>The type of overlap to calculated: must be one of 'jsi'
for Jaccard similarity index and 'intersect' for intersect size.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_rank_by">rank_by</code></td>
<td>
<p>A character string giving the name of the column to rank
marker genes by. Note the sign here: to rank by lowest p-value, preface
the column name with a minus sign; to rank by highest value, where higher
value indicates more discriminative genes (for example power in the ROC
test), no sign is needed.</p>
</td></tr>
<tr><td><code id="marker_overlap_+3A_use_sign">use_sign</code></td>
<td>
<p>A logical: should the sign of markers match for overlap
calculations? So a gene must be a positive or a negative marker in both
clusters being compared. If TRUE, markers1 and markers2 must have a
'avg_logFC' column, from which the sign of the DE will be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the marker gene overlap per cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressWarnings({
set.seed(1234)
library(Seurat)

# cluster with Louvain algorithm
pbmc_small = FindClusters(pbmc_small, resolution=0.8, verbose=FALSE)

# cluster with k-means
pbmc.pca = Embeddings(pbmc_small, 'pca')
pbmc_small@meta.data$kmeans_clusters = kmeans(pbmc.pca, centers=3)$cluster

# compare the markers
Idents(pbmc_small) = pbmc_small@meta.data$seurat_clusters
louvain.markers = FindAllMarkers(pbmc_small,
                                 logfc.threshold=1,
                                 test.use='t',
                                 verbose=FALSE)

Idents(pbmc_small) = pbmc_small@meta.data$kmeans_clusters
kmeans.markers = FindAllMarkers(pbmc_small,
                                logfc.threshold=1,
                                test.use='t',
                                verbose=FALSE)

pbmc_small@meta.data$jsi = marker_overlap(louvain.markers, kmeans.markers,
  pbmc_small@meta.data$seurat_clusters, pbmc_small@meta.data$kmeans_clusters)

# which cells have the same markers, regardless of clustering?
FeaturePlot(pbmc_small, 'jsi')
})
</code></pre>

<hr>
<h2 id='merge_partitions'>Merge Partitions</h2><span id='topic+merge_partitions'></span>

<h3>Description</h3>

<p>Merge flat disjoint clusterings whose pairwise ECS score is
above a given threshold. The merging is done using a complete linkage approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_partitions(partition_list, ecs_thresh = 1, ncores = 1, order = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_partitions_+3A_partition_list">partition_list</code></td>
<td>
<p>A list of flat disjoint membership vectors.</p>
</td></tr>
<tr><td><code id="merge_partitions_+3A_ecs_thresh">ecs_thresh</code></td>
<td>
<p>A numeric: the ecs threshold.</p>
</td></tr>
<tr><td><code id="merge_partitions_+3A_ncores">ncores</code></td>
<td>
<p>The number of parallel R instances that will run the code.
If the value is set to 1, the code will be run sequentially.</p>
</td></tr>
<tr><td><code id="merge_partitions_+3A_order">order</code></td>
<td>
<p>A logical: if TRUE, order the partitions based on their frequencies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the merged partitions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initial_list = list(c(1,1,2), c(2,2,2), c('B','B','A'))
merge_partitions(initial_list, 0.99)
</code></pre>

<hr>
<h2 id='merge_resolutions'>Merge Resolutions</h2><span id='topic+merge_resolutions'></span>

<h3>Description</h3>

<p>Merge partitions obtained with different resolution values
that have the same number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_resolutions(res_obj, object_name, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_resolutions_+3A_res_obj">res_obj</code></td>
<td>
<p>A list associated to a configuration field from the object
returned by the <code>get_resolution_importance</code> method.</p>
</td></tr>
<tr><td><code id="merge_resolutions_+3A_ncores">ncores</code></td>
<td>
<p>The number of parallel R instances that will run the code.
If the value is set to 1, the code will be run sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having one field assigned to each number of clusters. A number
of cluster will contain a list of all merged partitions. To avoid duplicates,
<code>merged_partitions</code> with threshold 1 is applied.
</p>

<hr>
<h2 id='pac_convergence'>PAC Convergence Plot</h2><span id='topic+pac_convergence'></span>

<h3>Description</h3>

<p>Plot PAC across iterations for a set of k to assess convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pac_convergence(pac_res, k_plot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pac_convergence_+3A_pac_res">pac_res</code></td>
<td>
<p>The data.frame output by consensus_cluster.</p>
</td></tr>
<tr><td><code id="pac_convergence_+3A_k_plot">k_plot</code></td>
<td>
<p>A vector with values of k to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with the convergence plot. Convergence has been
reached when the lines flatten out across k_plot values.
out across
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pac.res = consensus_cluster(iris[,1:4], k_max=20)
pac_convergence(pac.res, k_plot=c(3,5,7,9))
</code></pre>

<hr>
<h2 id='pac_landscape'>PAC Landscape Plot</h2><span id='topic+pac_landscape'></span>

<h3>Description</h3>

<p>Plot final PAC values across range of k to find optimal number
of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pac_landscape(pac_res, n_shade = max(pac_res$iteration)/5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pac_landscape_+3A_pac_res">pac_res</code></td>
<td>
<p>The data.frame output by consensus_cluster.</p>
</td></tr>
<tr><td><code id="pac_landscape_+3A_n_shade">n_shade</code></td>
<td>
<p>The PAC values across the last n_shade iterations will be
shaded to illustrate the how stable the PAC score is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with the final PAC vs k plot. A local minimum in the
landscape indicates an especially stable value of k.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pac.res = consensus_cluster(iris[,1:4], k_max=20)
pac_landscape(pac.res)
</code></pre>

<hr>
<h2 id='plot_clustering_difference_boxplot'>Clustering Method Stability Boxplot</h2><span id='topic+plot_clustering_difference_boxplot'></span>

<h3>Description</h3>

<p>Display EC consistency across clustering method and resolution
values. The 'filtered' field of the object returned by the
'get_clustering_difference_object' method is used.
Above each boxplot, the number of clusters is displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_clustering_difference_boxplot(clustering_difference_object, text_size = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_clustering_difference_boxplot_+3A_clustering_difference_object">clustering_difference_object</code></td>
<td>
<p>An object returned by the
'get_clustering_difference_object' method.</p>
</td></tr>
<tr><td><code id="plot_clustering_difference_boxplot_+3A_text_size">text_size</code></td>
<td>
<p>The size of the labels above boxplots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with the EC consistency distributions. Higher
consistency indicates a more stable clustering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(runif(500*10), nrow = 500)
rownames(expr_matrix) = as.character(1:500)

adj_matrix = Seurat::FindNeighbors(expr_matrix,
    k.param = 10,
    nn.method = "rann",
    verbose = FALSE,
    compute.SNN = FALSE)$nn
clust_diff_obj = get_clustering_difference(graph_adjacency_matrix = adj_matrix,
    resolution = c(0.5, 1),
    n_repetitions = 10,
    algorithm = 1:2,
    verbose = FALSE)
plot_clustering_difference_boxplot(clust_diff_obj)
</code></pre>

<hr>
<h2 id='plot_clustering_difference_facet'>Clustering Method Stability Facet Plot</h2><span id='topic+plot_clustering_difference_facet'></span>

<h3>Description</h3>

<p>Display the distribution of the EC consistency for each
clustering method and each resolution value on a given embedding The 'all'
field of the object returned by the 'get_clustering_difference_object' method is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_clustering_difference_facet(
  clustering_difference_object,
  embedding,
  low_limit = 0,
  high_limit = 1,
  grid = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_clustering_difference_facet_+3A_clustering_difference_object">clustering_difference_object</code></td>
<td>
<p>An object returned by the
'get_clustering_difference_object' method.</p>
</td></tr>
<tr><td><code id="plot_clustering_difference_facet_+3A_embedding">embedding</code></td>
<td>
<p>An embedding (only the first two dimensions will be used for
visualisation).</p>
</td></tr>
<tr><td><code id="plot_clustering_difference_facet_+3A_low_limit">low_limit</code></td>
<td>
<p>The lowest value of ECC that will be displayed on the embedding.</p>
</td></tr>
<tr><td><code id="plot_clustering_difference_facet_+3A_high_limit">high_limit</code></td>
<td>
<p>The highest value of ECC that will be displayed on the embedding.</p>
</td></tr>
<tr><td><code id="plot_clustering_difference_facet_+3A_grid">grid</code></td>
<td>
<p>Boolean value indicating whether the facet should be a grid (where each
row is associated with a resolution value and each column with a clustering method) or
a wrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(c(runif(250*10), runif(250*10, min = 5, max = 7)), nrow = 500)
rownames(expr_matrix) = as.character(1:500)

pca_embedding = irlba::irlba(expr_matrix, nv = 2)
pca_embedding = pca_embedding$u %*% diag(pca_embedding$d)
rownames(pca_embedding) = as.character(1:500)

adj_matrix = Seurat::FindNeighbors(pca_embedding,
    k.param = 10,
    nn.method = "rann",
    verbose = FALSE,
    compute.SNN = FALSE)$nn
clust_diff_obj = get_clustering_difference(graph_adjacency_matrix = adj_matrix,
    resolution = c(0.5, 1),
    n_repetitions = 10,
    algorithm = 1:2,
    verbose = FALSE)
plot_clustering_difference_facet(clust_diff_obj,pca_embedding)
</code></pre>

<hr>
<h2 id='plot_connected_comps_evolution'>Relationship Between Number of Nearest Neighbors and Graph Connectivity</h2><span id='topic+plot_connected_comps_evolution'></span>

<h3>Description</h3>

<p>Display the distribution of the number connected components
obtained for each number of neighbors across random seeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_connected_comps_evolution(nn_conn_comps_object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_connected_comps_evolution_+3A_nn_conn_comps_object">nn_conn_comps_object</code></td>
<td>
<p>An object or a concatenation of objects returned by the
'get_nn_conn_comps' method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with boxplots for the connected component distributions.
</p>


<h3>Note</h3>

<p>The number of connected components is displayed on a logarithmic scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(c(runif(50*10), runif(50*10, min = 1, max = 2)), nrow = 100, byrow = TRUE)
rownames(expr_matrix) = as.character(1:100)

# the graph reduction type is PCA, so we can provide the expression matrix as argument
nn_conn_comps_obj = get_nn_conn_comps(object = expr_matrix,
    n_neigh_sequence = c(2,3,5),
    config_name = "example_config",
    n_repetitions = 10,
    graph_reduction_type = "PCA",
    transpose = FALSE,
    # the following parameter is used by the irlba function and is not mandatory
    nv = 3)
plot_connected_comps_evolution(nn_conn_comps_obj)
</code></pre>

<hr>
<h2 id='plot_feature_stability_boxplot'>Feature Stability Boxplot</h2><span id='topic+plot_feature_stability_boxplot'></span>

<h3>Description</h3>

<p>Display EC consistency for each feature set and for each step.
Above each boxplot there is a number representing
the step (or the size of the subset)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_feature_stability_boxplot(feature_object_list, text_size = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_feature_stability_boxplot_+3A_feature_object_list">feature_object_list</code></td>
<td>
<p>An object or a concatenation of objects returned by the
'get_feature_stability' method</p>
</td></tr>
<tr><td><code id="plot_feature_stability_boxplot_+3A_text_size">text_size</code></td>
<td>
<p>The size of the labels above boxplots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(c(runif(100*10), runif(100*10, min = 3, max = 4)), nrow = 200, byrow = TRUE)
rownames(expr_matrix) = as.character(1:200)
colnames(expr_matrix) = paste("feature", 1:10)

feature_stability_result = get_feature_stability(data_matrix = t(expr_matrix),
   feature_set = colnames(expr_matrix),
   feature_type = "feature_name",
   steps = 5,
   npcs = 2,
   n_repetitions = 10,
   algorithm = 1,
   # the following parameters are used by the umap function and are not mandatory
   n_neighbors = 3,
   approx_pow = TRUE,
   n_epochs = 0,
   init = "random",
   min_dist = 0.3)
plot_feature_stability_boxplot(feature_stability_result)
</code></pre>

<hr>
<h2 id='plot_feature_stability_ecs_facet'>Feature Stability - EC Consistency Facet Plot</h2><span id='topic+plot_feature_stability_ecs_facet'></span>

<h3>Description</h3>

<p>Display a facet of plots where each subpanel is associated with a
feature set and illustrates the distribution of the EC consistency score
over the UMAP embedding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_feature_stability_ecs_facet(
  feature_object_list,
  n_facet_cols = 3,
  point_size = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_feature_stability_ecs_facet_+3A_feature_object_list">feature_object_list</code></td>
<td>
<p>An object or a concatenation of objects returned by the
'get_feature_stability' method</p>
</td></tr>
<tr><td><code id="plot_feature_stability_ecs_facet_+3A_n_facet_cols">n_facet_cols</code></td>
<td>
<p>The number of facet's columns.</p>
</td></tr>
<tr><td><code id="plot_feature_stability_ecs_facet_+3A_point_size">point_size</code></td>
<td>
<p>The size of the points displayed on the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(c(runif(100*10), runif(50*10, min = 5, max = 7)), nrow = 150, byrow = TRUE)
rownames(expr_matrix) = as.character(1:150)
colnames(expr_matrix) = paste("feature", 1:10)

feature_stability_result = get_feature_stability(data_matrix = t(expr_matrix),
   feature_set = colnames(expr_matrix),
   feature_type = "feature_name",
   steps = c(5,10),
   npcs = 2,
   n_repetitions = 3,
   algorithm = 1,
   # the following parameters are used by the umap function and are not mandatory
   n_neighbors = 3,
   approx_pow = TRUE,
   n_epochs = 0,
   init = "random",
   min_dist = 0.3)
plot_feature_stability_ecs_facet(feature_stability_result)
</code></pre>

<hr>
<h2 id='plot_feature_stability_ecs_incremental'>Feature Stability Incremental Boxplot</h2><span id='topic+plot_feature_stability_ecs_incremental'></span>

<h3>Description</h3>

<p>Perform an incremental ECS between two consecutive feature steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_feature_stability_ecs_incremental(
  feature_object_list,
  dodge_width = 0.7,
  text_size = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_feature_stability_ecs_incremental_+3A_feature_object_list">feature_object_list</code></td>
<td>
<p>An object or a concatenation of objects returned by the
'get_feature_stability' method.</p>
</td></tr>
<tr><td><code id="plot_feature_stability_ecs_incremental_+3A_dodge_width">dodge_width</code></td>
<td>
<p>Used for adjusting the horizontal position of the boxplot; the value
will be passed in the 'width' argument of the 'ggplot2::position_dodge' method.</p>
</td></tr>
<tr><td><code id="plot_feature_stability_ecs_incremental_+3A_text_size">text_size</code></td>
<td>
<p>The size of the labels above boxplots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with ECS distribution will be displayed as a
boxplot. Above each boxplot there will be a pair of numbers representing the
two steps that are compared.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(c(runif(25*10), runif(75*10, min = 5, max = 7)), nrow = 100, byrow = TRUE)
rownames(expr_matrix) = as.character(1:100)
colnames(expr_matrix) = paste("feature", 1:10)

feature_stability_result = get_feature_stability(data_matrix = t(expr_matrix),
   feature_set = colnames(expr_matrix),
   feature_type = "feature_name",
   steps = c(5,10),
   npcs = 2,
   n_repetitions = 3,
   algorithm = 1,
   # the following parameters are used by the umap function and are not mandatory
   n_neighbors = 3,
   approx_pow = TRUE,
   n_epochs = 0,
   init = "random",
   min_dist = 0.3)
plot_feature_stability_ecs_incremental(feature_stability_result)
</code></pre>

<hr>
<h2 id='plot_feature_stability_mb_facet'>Feature Stability - Cluster Membership Facet Plot</h2><span id='topic+plot_feature_stability_mb_facet'></span>

<h3>Description</h3>

<p>Display a facet of plots where each subpanel is associated with
a feature set and illustrates the distribution of the most frequent partition
over the UMAP embedding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_feature_stability_mb_facet(
  feature_object_list,
  text_size = 5,
  n_facet_cols = 3,
  point_size = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_feature_stability_mb_facet_+3A_feature_object_list">feature_object_list</code></td>
<td>
<p>An object or a concatenation of objects returned by the
'get_feature_stability' method</p>
</td></tr>
<tr><td><code id="plot_feature_stability_mb_facet_+3A_text_size">text_size</code></td>
<td>
<p>The size of the cluster label</p>
</td></tr>
<tr><td><code id="plot_feature_stability_mb_facet_+3A_n_facet_cols">n_facet_cols</code></td>
<td>
<p>The number of facet's columns.</p>
</td></tr>
<tr><td><code id="plot_feature_stability_mb_facet_+3A_point_size">point_size</code></td>
<td>
<p>The size of the points displayed on the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(c(runif(100*10), runif(50*10, min = 5, max = 7)), nrow = 150, byrow = TRUE)
rownames(expr_matrix) = as.character(1:150)
colnames(expr_matrix) = paste("feature", 1:10)

feature_stability_result = get_feature_stability(data_matrix = t(expr_matrix),
   feature_set = colnames(expr_matrix),
   feature_type = "feature_name",
   steps = c(5,10),
   npcs = 2,
   n_repetitions = 3,
   algorithm = 1,
   # the following parameters are used by the umap function and are not mandatory
   n_neighbors = 3,
   approx_pow = TRUE,
   n_epochs = 0,
   init = "random",
   min_dist = 0.3)
plot_feature_stability_mb_facet(feature_stability_result)
</code></pre>

<hr>
<h2 id='plot_k_n_partitions'>Relationship Between the Number of Clusters and the Number of Unique Partitions</h2><span id='topic+plot_k_n_partitions'></span>

<h3>Description</h3>

<p>For each configuration provided in partition_obj_list, display how
many different partitions with the same number of clusters can be obtained
by changing the seed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_k_n_partitions(partition_obj_list, object_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_k_n_partitions_+3A_partition_obj_list">partition_obj_list</code></td>
<td>
<p>An object or a concatenation of objects returned by the
'merge_resolutions' method.</p>
</td></tr>
<tr><td><code id="plot_k_n_partitions_+3A_object_names">object_names</code></td>
<td>
<p>Custom names that the user could assing to each
configuration; if not specified, the plot will use the generated configuration
names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object. The color gradient suggests the frequency of the most
common partition relative to the total number of appearances of that specific
number of clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(runif(500*10), nrow = 500)

# get the PCA embedding of the data
pca_embedding = irlba::irlba(expr_matrix, nv = 2)
pca_embedding = pca_embedding$u %*% diag(pca_embedding$d)
rownames(pca_embedding) = as.character(1:500)

# run the function on the pca embedding
resolution_result = get_resolution_importance(embedding = pca_embedding,
   resolution = c(0.8, 1),
   n_neigh = c(5, 7),
   n_repetitions = 5,
   clustering_method = 1,
   graph_type = 2,
   object_name = "name_example")

plot_k_n_partitions(resolution_result)
</code></pre>

<hr>
<h2 id='plot_k_resolution_corresp'>Correspondence Between Resolution and the Number of Clusters</h2><span id='topic+plot_k_resolution_corresp'></span>

<h3>Description</h3>

<p>For each configuration provided in the res_object_list, display what
number of clusters appear for different values of the resolution parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_k_resolution_corresp(
  res_object_list,
  res_object_names = NULL,
  given_height = 0.7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_k_resolution_corresp_+3A_res_object_list">res_object_list</code></td>
<td>
<p>An object returned by the
'get_resolution_importance' method.</p>
</td></tr>
<tr><td><code id="plot_k_resolution_corresp_+3A_res_object_names">res_object_names</code></td>
<td>
<p>Custom names that the user could assing to each
configuration; if not specified, the plot will use the generated configuration
names.</p>
</td></tr>
<tr><td><code id="plot_k_resolution_corresp_+3A_given_height">given_height</code></td>
<td>
<p>Used for adjusting the vertical position of the boxplot; the value
will be passed in the 'width' argument of the 'ggplot::position_dodge' method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object. Different shapes of points indicate different
parameter configuration, while the color
illustrates the frequency of the most common partition. The frequency is calculated
as the fraction between the number of total appearances and the number of
runs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(runif(500*10), nrow = 500)

# get the PCA embedding of the data
pca_embedding = irlba::irlba(expr_matrix, nv = 2)
pca_embedding = pca_embedding$u %*% diag(pca_embedding$d)
rownames(pca_embedding) = as.character(1:500)

# run the function on the pca embedding
resolution_result = get_resolution_importance(embedding = pca_embedding,
   resolution = c(0.8, 1),
   n_neigh = c(5, 7),
   n_repetitions = 5,
   clustering_method = 1,
   graph_type = 2,
   object_name = "name_example")

plot_k_resolution_corresp(resolution_result)
</code></pre>

<hr>
<h2 id='plot_n_neigh_ecs'>Graph construction parameters - ECC facet</h2><span id='topic+plot_n_neigh_ecs'></span>

<h3>Description</h3>

<p>Display, for all configurations consisting in different number
of neighbors, graph types and base embeddings, the EC Consistency of the partitions
obtained over multiple runs on an UMAP embedding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_n_neigh_ecs(nn_ecs_object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_n_neigh_ecs_+3A_nn_ecs_object">nn_ecs_object</code></td>
<td>
<p>An object or a concatenation of objects returned by the
'get_nn_importance' method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(c(runif(100*10), runif(100*10, min=5, max=6)), nrow = 200)
rownames(expr_matrix) = as.character(1:200)

nn_importance_obj = get_nn_importance(object = expr_matrix,
    n_neigh_sequence = c(10,15,20),
    n_repetitions = 10,
    graph_reduction_type = "PCA",
    algorithm = 1,
    transpose = FALSE, # the matrix is already observations x features, so we won't transpose it
    # the following parameter is used by the irlba function and is not mandatory
    nv = 2)
plot_n_neigh_ecs(nn_importance_obj)
</code></pre>

<hr>
<h2 id='plot_n_neigh_k_correspondence'>Relationship Between Number of Nearest Neighbors and Number of Clusters</h2><span id='topic+plot_n_neigh_k_correspondence'></span>

<h3>Description</h3>

<p>Display the distribution of the
number of clusters obtained for each number of neighbors across random seeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_n_neigh_k_correspondence(nn_object_n_clusters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_n_neigh_k_correspondence_+3A_nn_object_n_clusters">nn_object_n_clusters</code></td>
<td>
<p>An object or a concatenation of objects returned by the
'get_nn_importance' method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with the distributions displayed as boxplots.
</p>


<h3>Note</h3>

<p>The number of clusters is displayed on a logarithmic scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
# create an artificial expression matrix
expr_matrix = matrix(runif(100*10), nrow = 100)
rownames(expr_matrix) = as.character(1:100)

nn_importance_obj = get_nn_importance(object = expr_matrix,
    n_neigh_sequence = c(2,5),
    n_repetitions = 5,
    graph_reduction_type = "PCA",
    algorithm = 1,
    transpose = FALSE, # the matrix is already observations x features, so we won't transpose it
    # the following parameter is used by the irlba function and is not mandatory
    nv = 2)
plot_n_neigh_k_correspondence(nn_importance_obj)
</code></pre>

<hr>
<h2 id='print+2CClustering-method'>Print an Object</h2><span id='topic+print+2CClustering-method'></span>

<h3>Description</h3>

<p>Prints out information about the Clustering, including
number of elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Clustering'
print(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CClustering-method_+3A_x">x</code></td>
<td>
<p>The Clustering object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The printed character string.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
