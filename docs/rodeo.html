<!DOCTYPE html><html><head><title>Help for package rodeo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rodeo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rodeo-package'><p>Package to Facilitate ODE-Based Modeling</p></a></li>
<li><a href='#compile'><p>Generate Executable Code</p></a></li>
<li><a href='#dynamics'><p>Numerical Integration</p></a></li>
<li><a href='#exportDF'><p>Export a Data Frame as HTML/TEX Code</p></a></li>
<li><a href='#finalize'><p>Clean-up a <code>rodeo</code> Object</p></a></li>
<li><a href='#forcingFunctions'><p>Generation of Forcing Functions in Fortran</p></a></li>
<li><a href='#funs'><p>Declaration of Functions</p></a></li>
<li><a href='#generate'><p>Code Generator</p></a></li>
<li><a href='#getPars'><p>Query Values of Parameters</p></a></li>
<li><a href='#getVars'><p>Query Values of State Variables</p></a></li>
<li><a href='#initialize'><p>Initialize a <code>rodeo</code> Object</p></a></li>
<li><a href='#initStepper'><p>Initialize Internal ODE Solver</p></a></li>
<li><a href='#libFunc'><p>Return name of library function</p></a></li>
<li><a href='#libName'><p>Return library name</p></a></li>
<li><a href='#pars'><p>Declaration of Parameters</p></a></li>
<li><a href='#plotStoichiometry'><p>Plot Qualitative Stoichiometry Matrix</p></a></li>
<li><a href='#pros'><p>Declaration of Processes</p></a></li>
<li><a href='#rodeo-class'><p><code>rodeo</code> Class</p></a></li>
<li><a href='#setPars'><p>Assign Values to Parameters</p></a></li>
<li><a href='#setVars'><p>Assign Values to State Variables</p></a></li>
<li><a href='#step'><p>Numerical Integration Over a Single Time Step</p></a></li>
<li><a href='#stoi'><p>Specification of Stoichiometry</p></a></li>
<li><a href='#stoiCheck'><p>Validation of a Stoichiometry Matrix</p></a></li>
<li><a href='#stoichiometry'><p>Return the Stoichiometry Matrix</p></a></li>
<li><a href='#stoiCreate'><p>Stoichiometry Matrix from Reaction Equations</p></a></li>
<li><a href='#vars'><p>Declaration of Variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Title:</td>
<td>A Code Generator for ODE-Based Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-15</td>
</tr>
<tr>
<td>Author:</td>
<td>David Kneis &lt;david.kneis@tu-dresden.de&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Kneis &lt;david.kneis@tu-dresden.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an R6 class and several utility methods to
    facilitate the implementation of models based on ordinary
    differential equations. The heart of the package is a code generator
    that creates compiled 'Fortran' (or 'R') code which can be passed to
    a numerical solver. There is direct support for solvers contained
    in packages 'deSolve' and 'rootSolve'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dkneis/rodeo">https://github.com/dkneis/rodeo</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, deSolve</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, xtable, rootSolve</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>The tools to run 'R CMD SHLIB' on 'Fortran' code.
The used 'Fortran' compiler must support pointer initialization
which is a feature of the 2008 standard. The compiler from
Oracle Developer Studio 12.6 on Solaris 10 currently does not
meet this requirement.</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-15 12:41:20 UTC; dkneis</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-15 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rodeo-package'>Package to Facilitate ODE-Based Modeling</h2><span id='topic+rodeo-package'></span>

<h3>Description</h3>

<p>This package provides methods to
</p>

<ul>
<li><p> import a conceptual ODE-based model stored in tabular form (i.e.
as text files or spreadsheets).
</p>
</li>
<li><p> generate source code (either R or Fortran) to be passed to an
ODE-solver.
</p>
</li>
<li><p> visualize and export basic information about a model, e.g. for
documentation purposes.
</p>
</li></ul>



<h3>Details</h3>

<p>Consult the package vignette for details. The concept of writing an ODE
system in tabular/matrix form is nicely introduced, e. g., in the book of
Reichert, P., Borchardt, D., Henze, M., Rauch, W., Shanahan, P.,
Somlyody, L., and Vanrolleghem, P. A. (2001): River water quality model
No. 1, IWA publishing, ISBN 9781900222822.
</p>
<p>The current source code repository is <a href="https://github.com/dkneis/rodeo">https://github.com/dkneis/rodeo</a>.
</p>


<h3>Class and class methods</h3>

<p>See <code><a href="#topic+rodeo-class">rodeo-class</a></code> for the <code>rodeo</code> class
and the corresponding class methods.
</p>


<h3>Non-class methods</h3>

<p>Type <code>help(package="rodeo")</code> or see the links below to access the
documentation of non-class methods contained in the package.
</p>

<ul>
<li><p><code><a href="#topic+forcingFunctions">forcingFunctions</a></code> Generation of forcing functions
in Fortran.
</p>
</li>
<li><p><code><a href="#topic+exportDF">exportDF</a></code> Export of data frames as TEX or HTML code.
</p>
</li>
<li><p><code><a href="#topic+stoiCreate">stoiCreate</a></code> Creates a stoichiometry matrix from a set
of chemical reactions.
</p>
</li>
<li><p><code><a href="#topic+stoiCheck">stoiCheck</a></code> Validates a stoichiometry matrix by checking
for conservation of mass.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>

<hr>
<h2 id='compile'>Generate Executable Code</h2><span id='topic+compile'></span>

<h3>Description</h3>

<p>Creates and 'compiles' a function for use with numerical methods from
package <code><a href="deSolve.html#topic+deSolve">deSolve</a></code> or <code><a href="rootSolve.html#topic+rootSolve">rootSolve</a></code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="compile_+3A_sources">sources</code></td>
<td>
<p>Name(s) of source files(s) where functions appearing in
process rates or stoichiometric factors are implemented. Can be <code>NULL</code>
if no external functions are required, the name of a single file, or a
vector of file names. See notes below.</p>
</td></tr>
<tr><td><code id="compile_+3A_fortran">fortran</code></td>
<td>
<p>If <code>TRUE</code>, Fortran code is generated and compiled into a shared
library. If <code>FALSE</code>, R code is generated.</p>
</td></tr>
<tr><td><code id="compile_+3A_target">target</code></td>
<td>
<p>Name of a 'target environment'. Currently, 'deSolve' is the
only supported value.</p>
</td></tr>
<tr><td><code id="compile_+3A_lib">lib</code></td>
<td>
<p>File path to be used for the generated library (without
the platform specific extension). Note that any uppercase characters will
be converted to lowercase. By default, the file is created in R's
temporary folder under a random name.</p>
</td></tr>
<tr><td><code id="compile_+3A_reuse">reuse</code></td>
<td>
<p>If <code>TRUE</code>, an already existing library file will be loaded.
Use this to prevent
unnecessary re-compilation but note that R is likely to crash in case
of any mismatches between the object and the existing library. Default is
<code>FALSE</code>, i.e. the library is unconditionally build from scratch.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(NULL)</code>
</p>


<h3>Note</h3>

<p>The expected language of the external code passed in <code>sources</code>
depends on the value of <code>fortran</code>.
</p>
<p>If <code>fortran</code> is <code>FALSE</code>, R code is generated and made executable
by <code><a href="base.html#topic+eval">eval</a></code> and <code><a href="base.html#topic+parse">parse</a></code>. Auxiliary code
passed via <code>sources</code> is made available via <code><a href="base.html#topic+source">source</a></code>.
The created R function is stored in the object.
</p>
<p>If <code>fortran</code> is <code>TRUE</code>, the external code passed in 
<code>sources</code> must implement a module with the fixed name 'functions'.
This module must contain all user-defined functions referenced in process
rates or stoichiometric factors.
</p>
<p>If <code>fortran</code> is <code>TRUE</code>, a shared library is created. The library
is immediately loaded with <code><a href="base.html#topic+dyn.load">dyn.load</a></code> and it is
automatically unloaded with <code><a href="base.html#topic+dyn.unload">dyn.unload</a></code> when the
object's <code><a href="#topic+finalize">finalize</a></code> method is called.
</p>
<p>The name of the library (base name without extension) as well as the name
of the function to compute the  derivatives are stored in the object.
These names can be queried with the
<code><a href="#topic+libName">libName</a></code> and <code><a href="#topic+libFunc">libFunc</a></code> methods, respectively.
Unless a file path is specified via the <code>lib</code> argument, the library is
created in the folder returned by <code><a href="base.html#topic+tempdir">tempdir</a></code> under a
unique random name.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>This method internally calls <code><a href="#topic+generate">generate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vars, pars, funs, pros, stoi)
model &lt;- rodeo$new(vars, pars, funs, pros, stoi, dim=c(1))
# This would trigger compilation assuming that 'functionsCode.f95' contains
# a Fortran implementation of all functions; see vignette for full example
## Not run: 
model$compile(sources="functionsCode.f95")

## End(Not run)
</code></pre>

<hr>
<h2 id='dynamics'>Numerical Integration</h2><span id='topic+dynamics'></span>

<h3>Description</h3>

<p>Compute a dynamic solution with the numerical algorithms from package
<code><a href="deSolve.html#topic+deSolve">deSolve</a></code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamics_+3A_times">times</code></td>
<td>
<p>Times of interest (numeric vector).</p>
</td></tr>
<tr><td><code id="dynamics_+3A_fortran">fortran</code></td>
<td>
<p>Switch between compiled Fortran and R code (logical). Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dynamics_+3A_pronames">proNames</code></td>
<td>
<p>Assign names to output columns holding the process rates?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dynamics_+3A_...">...</code></td>
<td>
<p>Auxiliary arguments passed to <code><a href="deSolve.html#topic+ode">ode</a></code>.
See notes below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix returned by the integrator (see <code><a href="deSolve.html#topic+ode">ode</a></code>).
</p>


<h3>Note</h3>

<p>This method can only be used after <code><a href="#topic+compile">compile</a></code> has been
called.
</p>
<p>The <code>...</code> argument should <em>not</em> be used to assign values to any of 
<code>y</code>, <code>parms</code>, <code>times</code>, <code>func</code>. If <code>fortran</code> is
<code>TRUE</code> it should also not assign values to <code>dllname</code>, 
<code>nout</code>, or <code>outnames</code>. All these arguments of
<code><a href="deSolve.html#topic+ode">ode</a></code> get their appropriate values automatically.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+step">step</a></code> for integration over a single time step
with a built-in, Fortran-based solver.
</p>

<hr>
<h2 id='exportDF'>Export a Data Frame as HTML/TEX Code</h2><span id='topic+exportDF'></span>

<h3>Description</h3>

<p>Generates code to include tabular data in a tex document or web site.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportDF(
  x,
  tex = FALSE,
  colnames = NULL,
  width = NULL,
  align = NULL,
  funHead = NULL,
  funCell = NULL,
  lines = TRUE,
  indent = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportDF_+3A_x">x</code></td>
<td>
<p>The data frame being exported.</p>
</td></tr>
<tr><td><code id="exportDF_+3A_tex">tex</code></td>
<td>
<p>Logical. Allows to switch between generation of TEX code and HTML.</p>
</td></tr>
<tr><td><code id="exportDF_+3A_colnames">colnames</code></td>
<td>
<p>Displayed column names. If <code>NULL</code>, the original names
of <code>x</code> are used. Otherwise it must be a named vector with element
names corresponding to column names in <code>x</code>. It is OK to supply
alternative names for selected columns only.</p>
</td></tr>
<tr><td><code id="exportDF_+3A_width">width</code></td>
<td>
<p>Either <code>NULL</code> (all columns get equal width) or a named
vector with element names corresponding to column names in <code>x</code>. If
<code>tex == TRUE</code>, values (between 0 and 1) are needed for columns with
align code 'p' only. They are interpreted as a multiplier for '\textwidth'.
If <code>tex == FALSE</code>, values (between 0 and 100) should be
supplied for all columns of <code>x</code>.</p>
</td></tr>
<tr><td><code id="exportDF_+3A_align">align</code></td>
<td>
<p>Either <code>NULL</code> (to use automatic alignment) or a named
vector with element names corresponding to column names in <code>x</code>.
If <code>tex == FALSE</code> valid alignment codes are 'left', 'right', 'center'.
If <code>tex == TRUE</code> valid alignment codes are 'l', 'r', 'c', and 'p'. For
columns with code 'p' a corresponding value of <code>width</code> should be set.
It is OK to supply alignment codes for selected columns only.</p>
</td></tr>
<tr><td><code id="exportDF_+3A_funhead">funHead</code></td>
<td>
<p>Either <code>NULL</code> or a list of functions whose names
correspond to column names of <code>x</code>. The functions should have a single
formal argument; the respective column names of <code>x</code> are used as the
actual arguments. It is OK to supply functions for selected columns only
(an empty function is applied to the remaining columns). See below for some
typical examples.</p>
</td></tr>
<tr><td><code id="exportDF_+3A_funcell">funCell</code></td>
<td>
<p>Like <code>funHead</code> but these functions are applied to the
cells in columns rather that to the column names.</p>
</td></tr>
<tr><td><code id="exportDF_+3A_lines">lines</code></td>
<td>
<p>Logical. Switches table borders on/off.</p>
</td></tr>
<tr><td><code id="exportDF_+3A_indent">indent</code></td>
<td>
<p>Integer. Number of blanks used to indent the generated code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string (usually needs to be exported to a file).
</p>


<h3>Note</h3>

<p>The functions <code>funHead</code> and <code>funCell</code> are useful to apply
formatting or character replacement. For example, one could use
</p>
<p><code>function(x) {paste0("\\bold{",toupper(x),"}")}</code>
</p>
<p>to generate bold, uppercase column names in a TEX table.
</p>


<h3>Author(s)</h3>

<p>David Kneis <a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>The <code>xtable</code> packages provides similar functionality with
more sophisticated options. Consider the 'pandoc' software do convert
documents from one markup language to another one. Finally, consider the
latex package 'datatools' for direct inclusion of delimited text files
(e.g. produced by <code>write.table</code>) in tex documents.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create example table
df &lt;- data.frame(stringsAsFactors=FALSE, name= c("growth", "dead"),
  unit= c("1/d","1/d"), expression= c("r * N * (1 - N/K)"," d * N"))

# Export as TEX: header in bold, 1st colum in italics, last column as math
tex &lt;- exportDF(df, tex=TRUE,
  colnames=c(expression="process rate expression"),
  width=c(expression=0.5),
  align=c(expression="p"),
  funHead=setNames(replicate(ncol(df),
    function(x){paste0("\\textbf{",x,"}")}),names(df)),
  funCell=c(name=function(x){paste0("\\textit{",x,"}")},
    expression=function(x){paste0("$",x,"$")})
)
cat(tex,"\n")

# Export as HTML: non-standard colors are used for all columns
tf &lt;- tempfile(fileext=".html")
write(x= exportDF(df, tex=FALSE,
  funHead=setNames(replicate(ncol(df),
    function(x){paste0("&lt;font color='red'&gt;",x,"&lt;/font&gt;")}),names(df)),
  funCell=setNames(replicate(ncol(df),
    function(x){paste0("&lt;font color='blue'&gt;",x,"&lt;/font&gt;")}),names(df))
), file=tf)
## Not run: 
  browseURL(tf)
  file.remove(tf)

## End(Not run)
</code></pre>

<hr>
<h2 id='finalize'>Clean-up a <code>rodeo</code> Object</h2><span id='topic+finalize'></span>

<h3>Description</h3>

<p>Clean-up method for objects of the <code><a href="#topic+rodeo-class">rodeo-class</a></code>.
</p>


<h3>Value</h3>

<p>The method is called implicitly for its side effects when a
<code><a href="#topic+rodeo">rodeo</a></code> object is destroyed.
</p>


<h3>Note</h3>

<p>At present, the method just unloads the object-specific
shared libraries created with the <code><a href="#topic+compile">compile</a></code> or
<code><a href="#topic+initStepper">initStepper</a></code> methods.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>

<hr>
<h2 id='forcingFunctions'>Generation of Forcing Functions in Fortran</h2><span id='topic+forcingFunctions'></span>

<h3>Description</h3>

<p>Generates Fortran code to return the current values of forcing functions
based on interpolation in tabulated time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forcingFunctions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forcingFunctions_+3A_x">x</code></td>
<td>
<p>Data frame with colums 'name', 'file', 'column', 'mode', 'default'.
See below for expected entries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string holding generated Fortran code. Must be written to
disk, e.g. using <code><a href="base.html#topic+write">write</a></code>, prior to compilation.
</p>


<h3>Note</h3>

<p>The fields of the input data frame are interpreted as follows:
</p>

<ul>
<li><p><code>name </code> Name of the forcing function as declared in the table
of functions.
</p>
</li>
<li><p><code>file </code> Name of the text file containing the time series data
either as an absolute or relative path.
Time information is expected as numeric values in the first column (e.g.
as number of seconds after some reference date).
The period is used as the decimal character in floating point numbers, 
numeric values can also be given in scientific format (e.g. as 0.314e+1).
Allowed column delimiters are blank, tab, or comma. A sequence of white
spaces collapses to a single delimiter but this is not the case for
commas. It is strictly recommended to use a consistent delimiter
character within a particular file.
Blank lines are allowed everywhere in the file, comment lines must start
with a '#'. The first non-blank, non-comment line is interpreted as
column headers and the name of the first column (holding time info)
is essentially ignored).

</p>
</li>
<li><p><code>column </code> Name of the column in <code>file</code> from which data are
to be read.
</p>
</li>
<li><p><code>mode </code> Integer code to control how the interpolation is
performed. Use 0 for constant interpolation with full weight given to the
value at the end of a time interval. Use 1 for constant interpolation
with full weight given to the value at the begin of a time interval. Any
other values (&lt; 0 or &gt; 1) result in linear interpolation with weights
being set automatically.
</p>
</li>
<li><p><code>default </code> Logical. If <code>FALSE</code>, the generated function has
the interface 'f(time)'. If <code>TRUE</code>, the generated function has a
two-argument interface 'f(time, z)'. If the actual argument 'z' is
<code>NaN</code>, the function behaves just like the single-argument version,
i.e. interpolation in tabulated data is performed. If 'z' is not
<code>NaN</code>, the function returns the value of 'z'.
</p>
</li></ul>

<p>The generated code provides a single module named 'forcings' which defines
as many forcing functions as there are rows in <code>x</code>.
The module 'forcings' needs to be made available to the compiler
(either at the command line or via inclusion in another file with Fortran's
include mechanism). In addition, it must be referenced in the module
'functions' with an appropriate 'use' statement (see example below).
</p>
<p>The generated function return scalar values of type double precision. If an
error condition is encountered, the return value of a functions equals the
largest possible double precision value (generated by Fortran's 'huge'
function). In addition, errors trigger calls of the subroutines 'rexit'
(at top level) or 'rwarn' (at lower levels). These two functions are
available automatically if the Fortran code is compiled using 'R CMD SHLIB'.
Otherwise, the two functions need to be defined (see examples below).
</p>
<p>In the two-argument version, the second argument is tested against <code>NaN</code>
using 'ISNAN'. This function is not part of the Fortran standard but it is
supported by most compilers, including gfortan. The Fortran 2003 standard
conformal function would be 'IS_IEEE_NAN' which is not yet supported by
compiler versions normally installed with R (March 2016).
</p>


<h3>Author(s)</h3>

<p>David Kneis <a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ! Example of a Fortran file to define functions
  include 'forcings.f95'   ! include generated forcings file in compilation
  module functions
  use forcings             ! make forcings available as functions
  implicit none
  contains
  ! ... any non-forcing functions go here ...
  end module

## End(Not run)

## Not run: 
  ! Definition of 'rexit' and 'rwarn' for testing of the generated code
  ! outside of R
  subroutine rexit (x)
    character(len=*), intent(in):: x
    write(*,*) "ERROR: ",trim(adjustl(x))
    stop 1
  end subroutine
  
  subroutine rwarn (x)
    character(len=*), intent(in):: x
    write(*,*) "WARNING: ",trim(adjustl(x))
  end subroutine

## End(Not run)
</code></pre>

<hr>
<h2 id='funs'>Declaration of Functions</h2><span id='topic+funs'></span>

<h3>Description</h3>

<p>Declaration of functions referenced at the ODE's right hand sides
of the bacteria growth example model.
</p>


<h3>Format</h3>

<p>A data frame with the following fields:
</p>

<dl>
<dt>name : </dt><dd><p>Name of the function</p>
</dd>
<dt>unit : </dt><dd><p>Unit of the return value</p>
</dd>
<dt>description : </dt><dd><p>Short description (text)</p>
</dd>
</dl>


<hr>
<h2 id='generate'>Code Generator</h2><span id='topic+generate'></span>

<h3>Description</h3>

<p>This is a low-level method to translate the ODE-model specification into a
function that computes process rates and the state variables derivatives
(either in R or Fortran). You probably want to use the high-level method
<code><a href="#topic+compile">compile</a></code> instead, which uses <code>generate</code> internally.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_+3A_lang">lang</code></td>
<td>
<p>Character string to select the language of the generated source
code. Currently either 'f95' (for Fortran) or 'r' (for R).</p>
</td></tr>
<tr><td><code id="generate_+3A_name">name</code></td>
<td>
<p>Name for the generated function (character string). It should
start with a letter, optionally followed by letters, numbers, or
underscores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated source code as a string. Must be written to
disk, e.g. using <code><a href="base.html#topic+write">write</a></code>, prior to compilation.
</p>


<h3>Note</h3>

<p>Details of this low-level method may change in the future.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>See other methods of the <code><a href="#topic+rodeo-class">rodeo-class</a></code>, especially
<code><a href="#topic+compile">compile</a></code> which internally uses this method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vars, pars, funs, pros, stoi)
model &lt;- rodeo$new(vars, pars, funs, pros, stoi, dim=c(1))
fortranCode &lt;- model$generate(lang="f95")
## Not run: 
write(fortranCode, file="")

## End(Not run)
</code></pre>

<hr>
<h2 id='getPars'>Query Values of Parameters</h2><span id='topic+getPars'></span>

<h3>Description</h3>

<p>Query values of parameters of a <code><a href="#topic+rodeo">rodeo</a></code>-based model.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPars_+3A_asarray">asArray</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the values of parameters are returned
as vector irrespective of the model's spatial resolution. If <code>TRUE</code>,
the values are returned as an <code><a href="base.html#topic+array">array</a></code> with properly named
dimensions. The array's last dimension represents the parameters and its
first (fastest cycling) dimension, if any, refers to the model's highest
spatial dimension.</p>
</td></tr>
<tr><td><code id="getPars_+3A_usenames">useNames</code></td>
<td>
<p>Logical. Used to enable/disable element names for the return
vector when <code>asArray</code> is <code>FALSE</code>. The names follow the pattern
'x.i.j' where 'x' is the parameter name and 'i', 'j' are indices of the
sub-units in the first and second spatial dimension. The actual suffix is
controlled by the number of dimensions and in the 0-dimensional case, no
suffix is applied at all, i.e. the pure parameter names are used to label the
elements of the vector.
If <code>isArray</code> is <code>TRUE</code>, this argument is simply ignored, hence
the dimensions of a returned array are always named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector or array.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>The corresponding 'set' method is <code><a href="#topic+setPars">setPars</a></code> and examples
can be found there. Use <code><a href="#topic+getVars">getVars</a></code> to query the values of
variables rather than parameters.
</p>

<hr>
<h2 id='getVars'>Query Values of State Variables</h2><span id='topic+getVars'></span>

<h3>Description</h3>

<p>Query values of state variables of a <code><a href="#topic+rodeo">rodeo</a></code>-based model.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVars_+3A_asarray">asArray</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the values of variables are returned
as vector irrespective of the model's spatial resolution. If <code>TRUE</code>,
the values are returned as an <code><a href="base.html#topic+array">array</a></code> with properly named
dimensions. The array's last dimension represents the variables and its
first (fastest cycling) dimension, if any, refers to the model's highest
spatial dimension.</p>
</td></tr>
<tr><td><code id="getVars_+3A_usenames">useNames</code></td>
<td>
<p>Logical. Used to enable/disable element names for the return
vector when <code>asArray</code> is <code>FALSE</code>. The names follow the pattern
'x.i.j' where 'x' is the variable name and 'i', 'j' are indices of the
sub-units in the first and second spatial dimension. The actual suffix is
controlled by the number of dimensions and in the 0-dimensional case, no
suffix is applied at all, i.e. the pure variable names are used to label the
elements of the vector.
If <code>isArray</code> is <code>TRUE</code>, this argument is simply ignored, hence
the dimensions of a returned array are always named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector or array.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>The corresponding 'set' method is <code><a href="#topic+setVars">setVars</a></code> and examples
can be found there. Use <code><a href="#topic+getPars">getPars</a></code> to query the values of
parameters rather than variables.
</p>

<hr>
<h2 id='initialize'>Initialize a <code>rodeo</code> Object</h2><span id='topic+initialize'></span><span id='topic+new'></span>

<h3>Description</h3>

<p>Initializes an object of the <code><a href="#topic+rodeo-class">rodeo-class</a></code> with data frames
holding the specification of an ODE system.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_+3A_vars">vars</code></td>
<td>
<p>Declaration of state variables appearing in the ODE system.
Data frame with mandatory columns 'name', 'unit', 'description'.</p>
</td></tr>
<tr><td><code id="initialize_+3A_pars">pars</code></td>
<td>
<p>Declaration of parameters (i.e. constants) appearing in the ODE
system. Data frame with the same mandatory columns as <code>vars</code>.</p>
</td></tr>
<tr><td><code id="initialize_+3A_funs">funs</code></td>
<td>
<p>Declaration of functions being referenced in the ODE
system. Data frame with the same mandatory columns as <code>vars</code> or
<code>NULL</code> if no function calls are present at the ODEs' right-hand sides.</p>
</td></tr>
<tr><td><code id="initialize_+3A_pros">pros</code></td>
<td>
<p>Declaration of process rates. Data frame with mandatory columns
'name', 'unit', 'description', 'expression'.</p>
</td></tr>
<tr><td><code id="initialize_+3A_stoi">stoi</code></td>
<td>
<p>Declaration of stoichiometric factors. A data frame with
mandatory columns 'variable', 'process', 'expression', if <code>asMatrix</code>
is <code>FALSE</code>. The 'expression' colum holds the stoichiometric factors.
If <code>asMatrix</code> is <code>TRUE</code>, this must be a matrix of type character
with row names (processes) and colum names (variables). Empty or <code>NA</code>
matrix elements are interpreted as zero stoichiometry factors.</p>
</td></tr>
<tr><td><code id="initialize_+3A_asmatrix">asMatrix</code></td>
<td>
<p>Logical. Specifies whether stoichiometry information is given
in matrix or data base format.</p>
</td></tr>
<tr><td><code id="initialize_+3A_dim">dim</code></td>
<td>
<p>An integer vector, specifying the number of boxes in each spatial
dimension. Use <code>c(1)</code> to create a zero-dimensional
(i.e. single-box) model. This is the default.
Use, e.g. <code>c(5)</code> to create a 1-dimensional model with 5 boxes.
To create, e.g., a 2-dimensional model with 4 x 5 boxes, use <code>c(4,5)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The method is called implicitly for its side effects when a
<code><a href="#topic+rodeo">rodeo</a></code> object is instantiated with <code><a href="methods.html#topic+new">new</a></code>.
It has no accessible return value.
</p>


<h3>Note</h3>

<p>The mandatory fields of the input data frames should be of type
character. Additional fields may be present in these data frames and the
contents becomes part of the <code><a href="#topic+rodeo">rodeo</a></code> object.
The 'expression' fields of <code>pros</code> and <code>stoi</code> (or the contents of
the stoichiometry matrix) should be valid mathematical expressions in R and
Fortran. These can involve the names of declared state variables,
parameters, and functions as well as numeric constants or basic math
operators. Branching or loop constructs are not allowed (but these can
appear inside referenced functions).
There are currently few reserved words that cannot be used as variable,
parameter, function, or process names. The reserved words are 'time',
'left', and 'right'.
</p>
<p>Initialization does not assign numeric values to state variables or
parameters. Use the decicated methods <code><a href="#topic+setVars">setVars</a></code> and 
<code><a href="#topic+setPars">setPars</a></code> for that purpose.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>See the package vignette for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vars, pars, funs, pros, stoi)
model &lt;- rodeo$new(vars, pars, funs, pros, stoi, dim=c(1))
print(model)
</code></pre>

<hr>
<h2 id='initStepper'>Initialize Internal ODE Solver</h2><span id='topic+initStepper'></span>

<h3>Description</h3>

<p>Initializes <code>rodeo</code>'s built-in ODE solver. This method must be called
prior to using <code><a href="#topic+step">step</a></code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="initStepper_+3A_sources">sources</code></td>
<td>
<p>Name(s) of fortran source file(s) where a module with the
fixed name 'functions' is implemented. This module must contain all
user-defined functions referenced in process rates or
stoichiometric factors. Can be <code>NULL</code>, the name of a single file, or
a vector of file names if the Fortran code is split over several files.</p>
</td></tr>
<tr><td><code id="initStepper_+3A_method">method</code></td>
<td>
<p>Name of a the solver. Currently, 'rk5' is the only supported
value (Runge-Kutta method of Cash and Karp).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(NULL)</code>
</p>


<h3>Note</h3>

<p>After this method was called, <code><a href="#topic+step">step</a></code> can be used to
perform the integration.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>To perform integration with the solvers from package
<code><a href="deSolve.html#topic+deSolve">deSolve</a></code> use <code><a href="#topic+compile">compile</a></code> instead of this
method.
</p>

<hr>
<h2 id='libFunc'>Return name of library function</h2><span id='topic+libFunc'></span>

<h3>Description</h3>

<p>Return the name of the library function for use with
<code><a href="deSolve.html#topic+deSolve">deSolve</a></code> or <code><a href="rootSolve.html#topic+rootSolve">rootSolve</a></code> methods.
</p>


<h3>Value</h3>

<p>The name of the function to compute derivatives which is contained in
the library built with <code><a href="#topic+compile">compile</a></code>. This name has to be supplied as
the <code>func</code> argument of the solver methods
in <code><a href="deSolve.html#topic+deSolve">deSolve</a></code> or <code><a href="rootSolve.html#topic+rootSolve">rootSolve</a></code>.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>

<hr>
<h2 id='libName'>Return library name</h2><span id='topic+libName'></span>

<h3>Description</h3>

<p>Return the pure name of the shared library for use with
<code><a href="deSolve.html#topic+deSolve">deSolve</a></code> or <code><a href="rootSolve.html#topic+rootSolve">rootSolve</a></code> methods.
</p>


<h3>Value</h3>

<p>The base name of the shared library file created with
<code><a href="#topic+compile">compile</a></code> after stripping of the the platform specific
extension. This name has to be supplied as the <code>dllname</code> argument of
the solver methods in <code><a href="deSolve.html#topic+deSolve">deSolve</a></code> or
<code><a href="rootSolve.html#topic+rootSolve">rootSolve</a></code>.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>

<hr>
<h2 id='pars'>Declaration of Parameters</h2><span id='topic+pars'></span>

<h3>Description</h3>

<p>Declaration of parameters of the bacteria growth example model.
</p>


<h3>Format</h3>

<p>A data frame with the following fields:
</p>

<dl>
<dt>name : </dt><dd><p>Name of the parameter</p>
</dd>
<dt>unit : </dt><dd><p>Unit</p>
</dd>
<dt>description : </dt><dd><p>Short description (text)</p>
</dd>
</dl>


<hr>
<h2 id='plotStoichiometry'>Plot Qualitative Stoichiometry Matrix</h2><span id='topic+plotStoichiometry'></span>

<h3>Description</h3>

<p>Visualizes the stoichiometry matrix using standard plot methods. The sign
of stoichiometric factors is displayed as upward and downward pointing
triangles. Also visualized are dependencies of process rates on variables.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotStoichiometry_+3A_box">box</code></td>
<td>
<p>A positive integer pointing to a spatial sub-unit of the model.</p>
</td></tr>
<tr><td><code id="plotStoichiometry_+3A_time">time</code></td>
<td>
<p>Time. The value is ignored in the case of autonomous models.</p>
</td></tr>
<tr><td><code id="plotStoichiometry_+3A_cex">cex</code></td>
<td>
<p>Character expansion factor.</p>
</td></tr>
<tr><td><code id="plotStoichiometry_+3A_colpositive">colPositive</code></td>
<td>
<p>Color for positive stoichiometric factors.</p>
</td></tr>
<tr><td><code id="plotStoichiometry_+3A_colnegative">colNegative</code></td>
<td>
<p>Color for negative stoichiometric factors.</p>
</td></tr>
<tr><td><code id="plotStoichiometry_+3A_colinteract">colInteract</code></td>
<td>
<p>Color used to highlight dependencies.</p>
</td></tr>
<tr><td><code id="plotStoichiometry_+3A_colback">colBack</code></td>
<td>
<p>Color of background.</p>
</td></tr>
<tr><td><code id="plotStoichiometry_+3A_colgrid">colGrid</code></td>
<td>
<p>Color of a grid.</p>
</td></tr>
<tr><td><code id="plotStoichiometry_+3A_lwdgrid">lwdGrid</code></td>
<td>
<p>Grid line width.</p>
</td></tr>
<tr><td><code id="plotStoichiometry_+3A_translatevars">translateVars</code></td>
<td>
<p>Optional function to recode variable labels.
Must take the original vector as argument and return the altered version.</p>
</td></tr>
<tr><td><code id="plotStoichiometry_+3A_translatepros">translatePros</code></td>
<td>
<p>Optional function to recode process labels.
Must take the original vector as argument and return the altered version.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The values of state variables and parameters must have been set using
the <code><a href="#topic+setVars">setVars</a></code> and <code><a href="#topic+setPars">setPars</a></code> methods. If the
stoichiometric factors are mathematical expressions involving
function references, these functions must be defined in R (even if the
numerical computations are based on generated Fortran code).
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>See other methods of the <code><a href="#topic+rodeo-class">rodeo-class</a></code> or
<code><a href="#topic+stoichiometry">stoichiometry</a></code> for computing the stoichiometric factors only.
Alternative options for displaying stoichiometry information are described
in the package vignette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vars, pars, funs, pros, stoi)
model &lt;- rodeo$new(vars, pars, funs, pros, stoi, dim=c(1))
model$setVars(c(bac=0.1, sub=0.5))
model$setPars(c(mu=0.8, half=0.1, yield= 0.1, vol=1000, flow=50, sub_in=1))
monod &lt;- function(c,h) {c/(c+h)}
model$plotStoichiometry(box=c(1))
</code></pre>

<hr>
<h2 id='pros'>Declaration of Processes</h2><span id='topic+pros'></span>

<h3>Description</h3>

<p>Definition of processes of the bacteria growth example model.
</p>


<h3>Format</h3>

<p>A data frame with the following fields:
</p>

<dl>
<dt>name : </dt><dd><p>Name of the process</p>
</dd>
<dt>unit : </dt><dd><p>Unit of the rate expression</p>
</dd>
<dt>description : </dt><dd><p>Short description (text)</p>
</dd>
<dt>expression : </dt><dd><p>Mathematical expression (as a string)</p>
</dd>
</dl>


<hr>
<h2 id='rodeo-class'><code>rodeo</code> Class</h2><span id='topic+rodeo-class'></span><span id='topic+rodeo'></span>

<h3>Description</h3>

<p>This documents the <code>rodeo</code> class to represent an ODE-based
model. See the <code><a href="#topic+rodeo-package">rodeo-package</a></code> main page or type
<code>help(package="rodeo")</code> for an introduction to the package of
the same name.
</p>


<h3>Fields</h3>


<dl>
<dt><code>prosTbl</code></dt><dd><p>A data frame with fields 'name', 'unit', 'description', and
'expression' defining the process rates.</p>
</dd>
<dt><code>stoiTbl</code></dt><dd><p>A data frame with fields 'variable', 'process', and 'expression'
reprenting the stoichiometry matrix in data base format.</p>
</dd>
<dt><code>varsTbl</code></dt><dd><p>A data frame with fields 'name', 'unit', 'description' declaring
the state variables of the model. The declared names become valid
identifiers to be used in the expression fields of <code>prosTbl</code> or <code>stoiTbl</code>.</p>
</dd>
<dt><code>parsTbl</code></dt><dd><p>A data frame of the same structure as <code>vars</code> declaring the
parameters of the model. The declared names become valid
identifiers to be used in the expression fields of <code>prosTbl</code> or <code>stoiTbl</code>.</p>
</dd>
<dt><code>funsTbl</code></dt><dd><p>A data frame of the same structure as <code>vars</code> declaring any
functions referenced in the expression fields of <code>prosTbl</code> or <code>stoiTbl</code>.</p>
</dd>
<dt><code>dim</code></dt><dd><p>Integer vector specifying the spatial dimensions.</p>
</dd>
<dt><code>vars</code></dt><dd><p>Numeric vector, holding values of state variables.</p>
</dd>
<dt><code>pars</code></dt><dd><p>Numeric vector, holding values of parameters.</p>
</dd>
</dl>


<h3>Class methods</h3>

<p>For most of the methods below, a separate help page is available describing
its arguments and usage.
</p>

<ul>
<li><p><code><a href="#topic+initialize">initialize</a></code> Initialization method for new objects.
</p>
</li>
<li><p><code>namesVars, namesPars, namesFuns, namesPros</code> Functions
returning the names of declared state variables, parameters,
functions, and processes, respectively (character vectors). No arguments.
</p>
</li>
<li><p><code>lenVars, lenPars, lenFuns, lenPros</code> Functions
returning the number of declared state variables, parameters, functions
and processes, respectively (integer). No arguments.
</p>
</li>
<li><p><code>getVarsTable, getParsTable, getFunsTable, getProsTable,
    getStoiTable</code> Functions returning the data frames used to initialize
the object. No arguments
</p>
</li>
<li><p><code>getDim</code> Returns the spatial dimensions as an integer vector.
No arguments.
</p>
</li>
<li><p><code><a href="#topic+compile">compile</a></code> Compiles a Fortran library for use with
numerical methods from packages <code><a href="deSolve.html#topic+deSolve">deSolve</a></code> or
<code><a href="rootSolve.html#topic+rootSolve">rootSolve</a></code>.
</p>
</li>
<li><p><code><a href="#topic+generate">generate</a></code> Translate the ODE-model specification into a
function that computes process rates and the state variables' derivatives
(either in R or Fortran). Consider to use the high-level method
<code><a href="#topic+compile">compile</a></code>.
</p>
</li>
<li><p><code><a href="#topic+setVars">setVars</a></code> Assign values to state variables.
</p>
</li>
<li><p><code><a href="#topic+setPars">setPars</a></code> Assign values to parameters.
</p>
</li>
<li><p><code><a href="#topic+getVars">getVars</a></code> Returns the values of state variables.
</p>
</li>
<li><p><code><a href="#topic+getPars">getPars</a></code> Returns the values of parameters.
</p>
</li>
<li><p><code><a href="#topic+stoichiometry">stoichiometry</a></code> Returns the stoichiometry matrix, either
evaluated (numeric) or as text.
</p>
</li>
<li><p><code><a href="#topic+plotStoichiometry">plotStoichiometry</a></code> Plots qualitative stoichiometry
information.
</p>
</li></ul>



<h3>See Also</h3>

<p>See the <code><a href="#topic+rodeo-package">rodeo-package</a></code> main page or type
<code>help(package="rodeo")</code> to find the documentation of any non-class
methods contained in the <code>rodeo</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bacteria growth in a continuous flow culture
library("deSolve")

# Creation of model object
data(vars, pars, funs, pros, stoi)
model &lt;- rodeo$new(vars, pars, funs, pros, stoi, dim=c(1))

# Parameters, initial values
model$setPars(c(mu=0.8, half=0.1, yield= 0.1, vol=1000, flow=50, sub_in=1))
model$setVars(c(bac=0.01, sub=0))

# Implementation of functions declared in 'funs'
monod &lt;- function(c,h) {c/(c+h)}

# Creation of derivatives function
code &lt;- model$generate(name="derivs", lang="r")
derivs &lt;- eval(parse(text=code))

# Integration
times &lt;- 0:96
out &lt;- deSolve::ode(y=model$getVars(), times=times, func=derivs,
  parms=model$getPars())
colnames(out) &lt;- c("time", model$namesVars(), model$namesPros())
plot(out)
</code></pre>

<hr>
<h2 id='setPars'>Assign Values to Parameters</h2><span id='topic+setPars'></span>

<h3>Description</h3>

<p>Assign values to parameters of a <code><a href="#topic+rodeo">rodeo</a></code>-based model.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPars_+3A_x">x</code></td>
<td>
<p>A numeric vector or array, depending on the model's spatial
dimensions. Consult the help page of the sister method
<code><a href="#topic+setVars">setVars</a></code> for details on the required input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisible). The assigned numeric data are stored in the
object and can be accessed by the <code><a href="#topic+getPars">getPars</a></code> method.
</p>


<h3>Note</h3>

<p>Look at the notes and examples for the <code><a href="#topic+setVars">setVars</a></code> method.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>The corresponding 'get' method is <code><a href="#topic+getPars">getPars</a></code>. Use
<code><a href="#topic+setVars">setVars</a></code> to assign values to variables rather than parameters.
Consult the help page of the latter function for examples.
</p>

<hr>
<h2 id='setVars'>Assign Values to State Variables</h2><span id='topic+setVars'></span>

<h3>Description</h3>

<p>Assign values to state variables of a <code><a href="#topic+rodeo">rodeo</a></code>-based model.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="setVars_+3A_x">x</code></td>
<td>
<p>A numeric vector or array, depending on the model's spatial
dimensions. See details below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisible). The assigned numeric data are stored in the
object and can be accessed by the <code><a href="#topic+getVars">getVars</a></code> method.
</p>


<h3>Note</h3>

<p>For a 0-dimensional model (i.e. a model without spatial resolution),
<code>x</code> must be a numeric vector whose length equals the number of state
variables. The element names of <code>x</code> must match those returned by the
object's <code>namesVars</code> method. See the examples for how to bring the
vector elements into required order.
</p>
<p>For models with a spatial resolution, <code>x</code> must be a numeric array of
proper dimensions. The last dimension (cycling slowest) corresponds to the
variables and the first dimension (cycling fastest) corresponds to the
models' highest spatial dimension. Thus, <code>dim(x)</code> must be equal to
<code>c(rev(obj$getDim()), obj$namesVars())</code> where <code>obj</code> is the object
whose variables are to be assigned. The names of the array's last dimension
must match the return value of  <code>obj$namesVars()</code>.
</p>
<p>In the common 1-dimensional case, this just means that <code>x</code> must be a
matrix with column names matching the return value of
<code>obj$namesVars()</code> and as many rows as given by <code>obj$getDim()</code>.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>The corresponding 'get' method is <code><a href="#topic+getVars">getVars</a></code>. Use
<code><a href="#topic+setPars">setPars</a></code> to assign values to parameters rather than variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vars, pars, funs, pros, stoi)
x0 &lt;- c(bac=0.1, sub=0.5)

# 0-dimensional model
model &lt;- rodeo$new(vars, pars, funs, pros, stoi, dim=c(1))
model$setVars(x0)
print(model$getVars())

# How to sort vector elements
x0 &lt;- c(sub=0.5, bac=0.1)              # doesn't match order of variables
model$setVars(x0[model$namesVars()])

# 1-dimensional model with 3 boxes
nBox &lt;- 3
model &lt;- rodeo$new(vars, pars, funs, pros, stoi, dim=c(nBox))
x1 &lt;- matrix(rep(x0, each=nBox), nrow=nBox, ncol=model$lenVars(),
  dimnames=list(NULL, model$namesVars()))
model$setVars(x1)
print(model$getVars())
print(model$getVars(asArray=TRUE))

# 2-dimensional model with 3 x 4 boxes
model &lt;- rodeo$new(vars, pars, funs, pros, stoi, dim=c(3,4))
x2 &lt;- array(rep(x0, each=3*4), dim=c(4,3,model$lenVars()),
  dimnames=list(dim2=NULL, dim1=NULL, variables=model$namesVars()))
model$setVars(x2)
print(model$getVars())
print(model$getVars(asArray=TRUE))
</code></pre>

<hr>
<h2 id='step'>Numerical Integration Over a Single Time Step</h2><span id='topic+step'></span>

<h3>Description</h3>

<p>Performs integration over a single time step using a built-in ODE solver.
At present, a single solver is implement with limited options. The interface
of this method may change when support for other solvers is added.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_+3A_t0">t0</code></td>
<td>
<p>Numeric. Initial time.</p>
</td></tr>
<tr><td><code id="step_+3A_h">h</code></td>
<td>
<p>Numeric. Length of time step of interest.</p>
</td></tr>
<tr><td><code id="step_+3A_hmin">hmin</code></td>
<td>
<p>Minimum tolerated internal step size. The default of <code>NULL</code>
sets this to 10 times the value of <code>.Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="step_+3A_maxsteps">maxsteps</code></td>
<td>
<p>Maximum tolerated number of sub-steps.</p>
</td></tr>
<tr><td><code id="step_+3A_tol">tol</code></td>
<td>
<p>Numeric. Relative accuracy requested. This is currently a global value, i.e.
one cannot set the accuracy per state variable.</p>
</td></tr>
<tr><td><code id="step_+3A_method">method</code></td>
<td>
<p>String. Currently, 'rk5' is the only method implemented. This is
a Runge-Kutta Cash-Karp solver adapted from Press et al. (2002), Numerical
recipes in Fortran 90. It is designed to handle non-stiff problems only.</p>
</td></tr>
<tr><td><code id="step_+3A_check">check</code></td>
<td>
<p>Logical. Can be used to avoid repeated checks of arguments. This
may increase performance in repeated calls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector holding the values of state variables and
process rates in all boxes.
</p>


<h3>Note</h3>

<p>This method can only be used after a call to <code><a href="#topic+initStepper">initStepper</a></code>
has been made.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>Use <code><a href="deSolve.html#topic+deSolve">deSolve</a></code> for advanced solvers with more
options and capabilities to handle stiff problems.
</p>

<hr>
<h2 id='stoi'>Specification of Stoichiometry</h2><span id='topic+stoi'></span>

<h3>Description</h3>

<p>Definition of the links between simulated processes and state variables
in the bacteria growth example model.
</p>


<h3>Format</h3>

<p>A data frame with the following fields:
</p>

<dl>
<dt>variable : </dt><dd><p>Name of the state variable</p>
</dd>
<dt>process : </dt><dd><p>Name of the process</p>
</dd>
<dt>expression : </dt><dd><p>Mathematical expression (as a string)</p>
</dd>
</dl>


<hr>
<h2 id='stoiCheck'>Validation of a Stoichiometry Matrix</h2><span id='topic+stoiCheck'></span>

<h3>Description</h3>

<p>Validates the stoichiometry matrix by checking for conservation of mass
(more typically conservation of moles).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stoiCheck(stoi, comp, env = globalenv(), zero = .Machine$double.eps * 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoiCheck_+3A_stoi">stoi</code></td>
<td>
<p>Stoichiometry matrix either in evaluated
(<code><a href="base.html#topic+numeric">numeric</a></code>) or non-evaluated
(<code><a href="base.html#topic+character">character</a></code>) form. A suitable matrix can be created with
<code><a href="#topic+stoiCreate">stoiCreate</a></code>, for example.</p>
</td></tr>
<tr><td><code id="stoiCheck_+3A_comp">comp</code></td>
<td>
<p>Matrix defining the elemental composition of compounds.
Column names of <code>comp</code> need to match column names of <code>stoi</code> (but
additional columns are allowed and columns can be in different order).
There must be one row per element whose balance is to be checked and the
elements' names must appear as row names. The elements of the matrix
specify how much of an element is contained in a certain amount of a
compound. Typically, these are molar ratios. If one works with mass ratios
(not being a good idea), the information in <code>stoi</code> must be based on mass
concentrations as well.
The elements of <code>comp</code> are treated as mathematical expressions. Any
variables, functions, or operators needed to evaluate those expressions
must be provided by the specified environment <code>env</code>.</p>
</td></tr>
<tr><td><code id="stoiCheck_+3A_env">env</code></td>
<td>
<p>An environment or list supplying constants, functions, and
operators needed to evaluate expressions in <code>comp</code> or <code>stoi</code>.</p>
</td></tr>
<tr><td><code id="stoiCheck_+3A_zero">zero</code></td>
<td>
<p>A number close to zero. If the absolute result value of a mass
balance computation is less than this, the result is set to 0 (exactly).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the following properties:
</p>

<ul>
<li><p>There is one row for each process, thus the number and names of rows
are the same as in <code>stoi</code>.
</p>
</li>
<li><p>There is one column per checked element, hence column names are
equal to the row names of <code>comp</code>.
</p>
</li>
<li><p>A matrix element at position <code class="reqn">[i,k]</code> represent the mass balance
for the process in row <code class="reqn">i</code> with respect to the element in column
<code class="reqn">k</code>. A value of zero indicates a close balance. Positive (negative)
values indicate that mass is gained (lost) in the respective process.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>David Kneis <a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+stoiCreate">stoiCreate</a></code> to create a stoichiometry matrix
from a set of reactions in common notation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Eq. 1 and 2 are from Soetaert et al. (1996), Geochimica et Cosmochimica
# Acta, 60 (6), 1019-1040. 'OM' is organic matter. Constants 'nc' and 'pc'
# represent the nitrogen/carbon and phosphorus/carbon ratio, respectively.
reactions &lt;- c(
  oxicDegrad= "OM + O2 -&gt; CO2 + nc * NH3 + pc * H3PO4 + H2O",
  denitrific= "OM + 0.8*HNO3 -&gt; CO2 + nc*NH3 + 0.4*N2 + pc*H3PO4 + 1.4*H2O",
  dissPhosp1= "H3PO4 &lt;-&gt; H + H2PO4",
  dissPhosp2= "H2PO4 &lt;-&gt; H + HPO4"
)
# Non-evaluated stoichiometry matrix
stoi &lt;- stoiCreate(reactions, toRight="_f", toLeft="_b")
# Parameters ('nc' and 'pc' according to Redfield ratio)
pars &lt;- list(nc=16/106, pc=1/106)
# Elemental composition
comp &lt;- rbind(
  OM=    c(C=1, N="nc", P="pc", H="2 + 3*nc + 3*pc"),
  O2=    c(C=0, N=0,    P=0,    H=0),
  CO2=   c(C=1, N=0,    P=0,    H=0),
  NH3=   c(C=0, N=1,    P=0,    H=3),
  H3PO4= c(C=0, N=0,    P=1,    H=3),
  H2PO4= c(C=0, N=0,    P=1,    H=2),
  HPO4=  c(C=0, N=0,    P=1,    H=1),
  H2O=   c(C=0, N=0,    P=0,    H=2),
  HNO3=  c(C=0, N=1,    P=0,    H=1),
  N2=    c(C=0, N=2,    P=0,    H=0),
  H=     c(C=0, N=0,    P=0,    H=1)
)
# We need the transposed form
comp &lt;- t(comp)
# Mass balance check
bal &lt;- stoiCheck(stoi, comp=comp, env=pars)
print(bal)
print(colSums(bal) == 0)
</code></pre>

<hr>
<h2 id='stoichiometry'>Return the Stoichiometry Matrix</h2><span id='topic+stoichiometry'></span>

<h3>Description</h3>

<p>Return and optionally evaluate the mathematical expression appearing in the
stoichiometry matrix.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoichiometry_+3A_box">box</code></td>
<td>
<p>Either <code>NULL</code> or a vector of positive integers pointing
to a spatial sub-unit of the model.
If <code>NULL</code>, the mathematical expressions appearing in the
stoichiometry matrix are not evaluated, hence, they are returned as
character strings. If a spatial sub-unit is specified, a numeric matrix is
returned. In the latter case, the values of state variables and parameters
must have been set using the <code><a href="#topic+setVars">setVars</a></code> and
<code><a href="#topic+setPars">setPars</a></code> methods.</p>
</td></tr>
<tr><td><code id="stoichiometry_+3A_time">time</code></td>
<td>
<p>Time. The value is ignored in the case of autonomous models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of numeric or character type, depending on the value of
<code>box</code>.
</p>


<h3>Note</h3>

<p>If the stoichiometric factors are mathematical expressions involving
function references, these functions must be defined in R (even if the
numerical computations are based on generated Fortran code).
</p>


<h3>Author(s)</h3>

<p><a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>See other methods of the <code><a href="#topic+rodeo-class">rodeo-class</a></code> or
<code><a href="#topic+plotStoichiometry">plotStoichiometry</a></code> for a graphical representation of the
stoichiometric factors only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vars, pars, funs, pros, stoi)
model &lt;- rodeo$new(vars, pars, funs, pros, stoi, dim=c(1))
model$setPars(c(mu=0.8, half=0.1, yield= 0.1, vol=1000, flow=50, sub_in=1))
model$setVars(c(bac=0.1, sub=0.5))
monod &lt;- function(c,h) {c/(c+h)}
print(model$stoichiometry(box=NULL))
print(model$stoichiometry(box=c(1)))
</code></pre>

<hr>
<h2 id='stoiCreate'>Stoichiometry Matrix from Reaction Equations</h2><span id='topic+stoiCreate'></span>

<h3>Description</h3>

<p>Creates a stoichiometry matrix from a set of reaction equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stoiCreate(
  reactions,
  eval = FALSE,
  env = globalenv(),
  toRight = "_forward",
  toLeft = "_backward"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoiCreate_+3A_reactions">reactions</code></td>
<td>
<p>A named vector of character strings, each representing
a (chemical) reaction. See syntax details below.</p>
</td></tr>
<tr><td><code id="stoiCreate_+3A_eval">eval</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), the returned matrix is of
type <code><a href="base.html#topic+character">character</a></code> and any mathematical expressions are
returned as text. If <code>TRUE</code>, an attempt is made to return a
<code><a href="base.html#topic+numeric">numeric</a></code> matrix by evaluating the expression making use
<code>env</code>.</p>
</td></tr>
<tr><td><code id="stoiCreate_+3A_env">env</code></td>
<td>
<p>Only relevant if <code>eval</code> is <code>TRUE</code>. Must be an
environment or list supplying constants, functions, and operators needed to
evaluate expressions in the generated matrix.</p>
</td></tr>
<tr><td><code id="stoiCreate_+3A_toright">toRight</code></td>
<td>
<p>Only relevant for reversible reactions. The passed character
string is appended to the name of the respective element of
<code>reactions</code> to create a unique name for the forward reaction.</p>
</td></tr>
<tr><td><code id="stoiCreate_+3A_toleft">toLeft</code></td>
<td>
<p>Like <code>toRight</code>, but this is the suffix for the backward
reaction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the following properties:
</p>

<ul>
<li><p>The number of columns equals the total number of components present
in <code>reactions</code>. The components' names are used as column names.
</p>
</li>
<li><p>The number of rows equals the length of <code>reactions</code> plus the
number of reversible reactions. Thus, a single row is created for each
non-reversible reaction but two rows are created for reversible ones.
The latter represent the forward and backward reaction (in that order).
The row names are constructed from the names of <code>reactions</code>, making
use of the suffixes <code>toRight</code> and <code>toLeft</code> in the case of
reversible reactions.
</p>
</li>
<li><p>The matrix is filled with the stoichiometric factors extracted from
<code>reactions</code>. Empty elements are set to zero.
</p>
</li>
<li><p>The type of the matrix (<code><a href="base.html#topic+character">character</a></code> or
<code><a href="base.html#topic+numeric">numeric</a></code>) depends on the value of <code>eval</code>.
</p>
</li></ul>



<h3>Note</h3>

<p>The syntax rules for reaction equations are as follows (see examples):
</p>

<ul>
<li><p>There must be a left hand side and a right hand side. Sides must be
separated by one of the arrows '-&gt;', '&lt;-', or '&lt;-&gt;' with the latter
indicating a reversible reaction.
</p>
</li>
<li><p>Names of component(s) must appear at each side of the reaction. These
must be legal row/column names in R. If multiple
components are consumed or produced, they must be separated by '+'.
</p>
</li>
<li><p>Any stoichiometric factors need to appear before the respective
component name using '*' as the separating character. Stoichiometric
factors being equal to unity can be omitted.
</p>
</li>
<li><p>A stoichiometric factor is treated as a mathematical expression.
In common cases, it is just a numeric constant. However, the
expression can also involve references to variables or functions. If such
an expression contains math operators '*' or '+' it needs to be enclosed
in parenthesis.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>David Kneis <a href="mailto:david.kneis@tu-dresden.de">david.kneis@tu-dresden.de</a>
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+stoiCheck">stoiCheck</a></code> to validate the mass balance of
the generated matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: From https://en.wikipedia.org/wiki/Petersen_matrix (July 2016)
#
reactions &lt;- c(
  formS=  "A + 2 * B -&gt; S",
  equiES= "E + S &lt;-&gt; ES",
  decoES= "ES -&gt; E + P"
)
stoi &lt;- stoiCreate(reactions, eval=TRUE, toRight="_f", toLeft="_b")
print(stoi)

# EXAMPLE 2: Decomposition of organic matter (selected equations only)
#
# Eq. 1 and 2 are from Soetaert et al. (1996), Geochimica et Cosmochimica
# Acta, 60 (6), 1019-1040. 'OM' is organic matter. Constants 'nc' and 'pc'
# represent the nitrogen/carbon and phosphorus/carbon ratio, respectively.
reactions &lt;- c(
  oxicDegrad= "OM + O2 -&gt; CO2 + nc * NH3 + pc * H3PO4 + H2O",
  denitrific= "OM + 0.8*HNO3 -&gt; CO2 + nc*NH3 + 0.4*N2 + pc*H3PO4 + 1.4*H2O",
  dissPhosp1= "H3PO4 &lt;-&gt; H + H2PO4",
  dissPhosp2= "H2PO4 &lt;-&gt; H + HPO4"
)
# Non-evaluated matrix
stoi &lt;- stoiCreate(reactions, toRight="_f", toLeft="_b")
print(stoi)
# Evaluated matrix ('nc' and 'pc' according to Redfield ratio)
pars &lt;- list(nc=16/106, pc=1/106)
stoi &lt;- stoiCreate(reactions, eval=TRUE, env=pars, toRight="_f", toLeft="_b")
print(stoi)
</code></pre>

<hr>
<h2 id='vars'>Declaration of Variables</h2><span id='topic+vars'></span>

<h3>Description</h3>

<p>Declaration of variables of the bacteria growth example model.
</p>


<h3>Format</h3>

<p>A data frame with the following fields:
</p>

<dl>
<dt>name : </dt><dd><p>Name of the variable</p>
</dd>
<dt>unit : </dt><dd><p>Unit</p>
</dd>
<dt>description : </dt><dd><p>Short description (text)</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
