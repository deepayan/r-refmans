<!DOCTYPE html><html><head><title>Help for package gsignal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gsignal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gsignal-package'><p>gsignal: Signal Processing</p></a></li>
<li><a href='#ar_psd'><p>Power spectrum of AR model</p></a></li>
<li><a href='#arburg'><p>Autoregressive model coefficients - Burg's method</p></a></li>
<li><a href='#Arma'><p>Autoregressive moving average (ARMA) model</p></a></li>
<li><a href='#aryule'><p>Autoregressive model coefficients - Yule-Walker method</p></a></li>
<li><a href='#barthannwin'><p>Modified Bartlett-Hann window</p></a></li>
<li><a href='#bartlett'><p>Bartlett window</p></a></li>
<li><a href='#besselap'><p>Bessel analog low-pass filter prototype</p></a></li>
<li><a href='#besself'><p>Bessel analog filter design</p></a></li>
<li><a href='#bilinear'><p>Bilinear transformation</p></a></li>
<li><a href='#bitrevorder'><p>Permute input to bit-reversed order</p></a></li>
<li><a href='#blackman'><p>Blackman window</p></a></li>
<li><a href='#blackmanharris'><p>Blackman-Harris window</p></a></li>
<li><a href='#blackmannuttall'><p>Blackman-Nuttall window</p></a></li>
<li><a href='#bohmanwin'><p>Bohman window</p></a></li>
<li><a href='#boxcar'><p>Rectangular window</p></a></li>
<li><a href='#buffer'><p>Buffer signal vector into matrix of data segments</p></a></li>
<li><a href='#buttap'><p>Butterworth filter prototype</p></a></li>
<li><a href='#butter'><p>Butterworth filter design</p></a></li>
<li><a href='#buttord'><p>Butterworth filter order and cutoff frequency</p></a></li>
<li><a href='#cceps'><p>Complex cepstral analysis</p></a></li>
<li><a href='#cconv'><p>Circular convolution</p></a></li>
<li><a href='#cheb'><p>Chebyshev polynomials</p></a></li>
<li><a href='#cheb1ap'><p>Chebyshev Type I filter prototype</p></a></li>
<li><a href='#cheb1ord'><p>Chebyshev Type I filter order</p></a></li>
<li><a href='#cheb2ap'><p>Chebyshev Type II filter prototype</p></a></li>
<li><a href='#cheb2ord'><p>Chebyshev Type II filter order</p></a></li>
<li><a href='#chebwin'><p>Chebyshev window</p></a></li>
<li><a href='#cheby1'><p>Chebyshev Type I filter design</p></a></li>
<li><a href='#cheby2'><p>Chebyshev Type II filter design</p></a></li>
<li><a href='#chirp'><p>Chirp signal</p></a></li>
<li><a href='#cl2bp'><p>Constrained L2 bandpass FIR filter design</p></a></li>
<li><a href='#clustersegment'><p>Cluster Segments</p></a></li>
<li><a href='#cmorwavf'><p>Complex Morlet Wavelet</p></a></li>
<li><a href='#conv'><p>Convolution and polynomial multiplication</p></a></li>
<li><a href='#conv2'><p>2-D convolution</p></a></li>
<li><a href='#convmtx'><p>Convolution matrix</p></a></li>
<li><a href='#cplxpair'><p>Complex conjugate pairs</p></a></li>
<li><a href='#cplxreal'><p>Sort complex conjugate pairs and real</p></a></li>
<li><a href='#cpsd'><p>Cross power spectral density</p></a></li>
<li><a href='#czt'><p>Chirp Z-transform</p></a></li>
<li><a href='#dct'><p>Discrete Cosine Transform</p></a></li>
<li><a href='#dct2'><p>2-D Discrete Cosine Transform</p></a></li>
<li><a href='#dctmtx'><p>Discrete Cosine Transform Matrix</p></a></li>
<li><a href='#decimate'><p>Decrease sample rate</p></a></li>
<li><a href='#detrend'><p>Remove Polynomial Trend</p></a></li>
<li><a href='#dftmtx'><p>Discrete Fourier Transform Matrix</p></a></li>
<li><a href='#digitrevorder'><p>Permute input to digit-reversed order</p></a></li>
<li><a href='#diric'><p>Dirichlet function</p></a></li>
<li><a href='#downsample'><p>Decrease sample rate</p></a></li>
<li><a href='#dst'><p>Discrete Sine Transform</p></a></li>
<li><a href='#dwt'><p>1-D Discrete Wavelet Transform</p></a></li>
<li><a href='#ellip'><p>Elliptic filter design</p></a></li>
<li><a href='#ellipap'><p>Low-pass analog elliptic filter</p></a></li>
<li><a href='#ellipord'><p>Elliptic Filter Order</p></a></li>
<li><a href='#fftconv'><p>FFT-based convolution</p></a></li>
<li><a href='#fftfilt'><p>FFT-based FIR filtering</p></a></li>
<li><a href='#fftshift'><p>Zero-frequency shift</p></a></li>
<li><a href='#fht'><p>Fast Hartley Transform</p></a></li>
<li><a href='#filter'><p>Filter a signal</p></a></li>
<li><a href='#filter_zi'><p>Filter initial conditions</p></a></li>
<li><a href='#filter.sgolayFilter'><p>Savitzky-Golay filtering</p></a></li>
<li><a href='#filter2'><p>2-D digital filter</p></a></li>
<li><a href='#FilterSpecs'><p>Filter specifications</p></a></li>
<li><a href='#filtfilt'><p>Zero-phase digital filtering</p></a></li>
<li><a href='#filtic'><p>Filter Initial Conditions</p></a></li>
<li><a href='#findpeaks'><p>Find local extrema</p></a></li>
<li><a href='#fir1'><p>Window-based FIR filter design</p></a></li>
<li><a href='#fir2'><p>Frequency sampling-based FIR filter design</p></a></li>
<li><a href='#firls'><p>Least-squares linear-phase FIR filter design</p></a></li>
<li><a href='#flattopwin'><p>Flat top window</p></a></li>
<li><a href='#fracshift'><p>Fractional shift</p></a></li>
<li><a href='#freqs'><p>Frequency response of analog filters</p></a></li>
<li><a href='#freqs_plot'><p>Plot frequency response</p></a></li>
<li><a href='#freqz'><p>Frequency response of digital filter</p></a></li>
<li><a href='#fwhm'><p>Full width at half maximum</p></a></li>
<li><a href='#gauspuls'><p>Gaussian-modulated sinusoidal RF pulse</p></a></li>
<li><a href='#gaussian'><p>Gaussian convolution window</p></a></li>
<li><a href='#gausswin'><p>Gaussian window</p></a></li>
<li><a href='#gmonopuls'><p>Gaussian monopulse</p></a></li>
<li><a href='#grpdelay'><p>Group delay</p></a></li>
<li><a href='#hamming'><p>Hamming window</p></a></li>
<li><a href='#hann'><p>Hann window</p></a></li>
<li><a href='#hilbert'><p>Hilbert transform</p></a></li>
<li><a href='#idct'><p>Inverse Discrete Cosine Transform</p></a></li>
<li><a href='#idct2'><p>Inverse 2-D Discrete Cosine Transform</p></a></li>
<li><a href='#idst'><p>Inverse Discrete Sine Transform</p></a></li>
<li><a href='#ifft'><p>Inverse Fast Fourier Transform</p></a></li>
<li><a href='#ifftshift'><p>Inverse zero-frequency shift</p></a></li>
<li><a href='#ifwht'><p>Fast Walsh-Hadamard Transform</p></a></li>
<li><a href='#iirlp2mb'><p>IIR lowpass filter to IIR multiband</p></a></li>
<li><a href='#impinvar'><p>Impulse invariance method for A/D filter conversion</p></a></li>
<li><a href='#impz'><p>Impulse response of digital filter</p></a></li>
<li><a href='#interp'><p>Interpolation</p></a></li>
<li><a href='#invfreq'><p>Inverse Frequency Response</p></a></li>
<li><a href='#invimpinvar'><p>Inverse impulse invariance method</p></a></li>
<li><a href='#kaiser'><p>Kaiser window</p></a></li>
<li><a href='#kaiserord'><p>Kaiser filter order and cutoff frequency</p></a></li>
<li><a href='#levinson'><p>Durbin-Levinson Recursion</p></a></li>
<li><a href='#Ma'><p>Moving average (MA) model</p></a></li>
<li><a href='#marcumq'><p>Marcum Q function</p></a></li>
<li><a href='#medfilt1'><p>1-D median filtering</p></a></li>
<li><a href='#mexihat'><p>Mexicat Hat</p></a></li>
<li><a href='#meyeraux'><p>Meyer wavelet auxiliary function</p></a></li>
<li><a href='#morlet'><p>Morlet Wavelet</p></a></li>
<li><a href='#movingrms'><p>Moving Root Mean Square</p></a></li>
<li><a href='#mpoles'><p>Multiplicity of poles</p></a></li>
<li><a href='#mscohere'><p>Magnitude-squared coherence</p></a></li>
<li><a href='#ncauer'><p>ncauer analog filter design</p></a></li>
<li><a href='#nuttallwin'><p>Nuttall-defined minimum 4-term Blackman-Harris window</p></a></li>
<li><a href='#pad'><p>Pad data</p></a></li>
<li><a href='#parzenwin'><p>Parzen (de la Vallée Poussin) window</p></a></li>
<li><a href='#pburg'><p>Autoregressive PSD estimate - Burg's method</p></a></li>
<li><a href='#peak2peak'><p>Maximum-to-minimum difference</p></a></li>
<li><a href='#peak2rms'><p>Peak-magnitude-to-RMS ratio</p></a></li>
<li><a href='#pei_tseng_notch'><p>Pei-Tseng notch filter</p></a></li>
<li><a href='#poly'><p>Polynomial with specified roots</p></a></li>
<li><a href='#polyreduce'><p>Reduce polynomial</p></a></li>
<li><a href='#polystab'><p>Stabilize polynomial</p></a></li>
<li><a href='#pow2db'><p>Power - decibel conversion</p></a></li>
<li><a href='#primitive'><p>Primitive</p></a></li>
<li><a href='#pulstran'><p>Pulse train</p></a></li>
<li><a href='#pwelch'><p>Welch’s power spectral density estimate</p></a></li>
<li><a href='#pyulear'><p>Autoregressive PSD estimate - Yule-Walker method</p></a></li>
<li><a href='#qp_kaiser'><p>Kaiser FIR filter design</p></a></li>
<li><a href='#rceps'><p>Real cepstrum</p></a></li>
<li><a href='#rectpuls'><p>Rectangular pulse</p></a></li>
<li><a href='#rectwin'><p>Rectangular window</p></a></li>
<li><a href='#remez'><p>Parks-McClellan optimal FIR filter design</p></a></li>
<li><a href='#resample'><p>Change sampling rate</p></a></li>
<li><a href='#residue'><p>Partial fraction expansion</p></a></li>
<li><a href='#residued'><p>delayed z-transform partial fraction expansion</p></a></li>
<li><a href='#residuez'><p>Z-transform partial fraction expansion</p></a></li>
<li><a href='#rms'><p>Root-mean-square</p></a></li>
<li><a href='#rssq'><p>Root-sum-of-squares</p></a></li>
<li><a href='#sampled2continuous'><p>Signal reconstruction</p></a></li>
<li><a href='#sawtooth'><p>Sawtooth or triangle wave</p></a></li>
<li><a href='#schtrig'><p>Schmitt Trigger</p></a></li>
<li><a href='#sftrans'><p>Transform filter band edges</p></a></li>
<li><a href='#sgolay'><p>Savitzky-Golay filter design</p></a></li>
<li><a href='#shanwavf'><p>Complex Shannon Wavelet</p></a></li>
<li><a href='#shiftdata'><p>Shift data to operate on specified dimension</p></a></li>
<li><a href='#sigmoid_train'><p>Sigmoid Train</p></a></li>
<li><a href='#signals'><p>signals</p></a></li>
<li><a href='#sinetone'><p>Sine tone</p></a></li>
<li><a href='#sinewave'><p>Sine wave</p></a></li>
<li><a href='#Sos'><p>Second-order sections</p></a></li>
<li><a href='#sos2tf'><p>Sos to transfer function</p></a></li>
<li><a href='#sos2zp'><p>Sos to zero-pole-gain</p></a></li>
<li><a href='#sosfilt'><p>Second-order sections filtering</p></a></li>
<li><a href='#specgram'><p>Spectrogram</p></a></li>
<li><a href='#square'><p>Square wave</p></a></li>
<li><a href='#stft'><p>Short-Term Fourier Transform</p></a></li>
<li><a href='#tf2sos'><p>Transfer function to second-order sections form</p></a></li>
<li><a href='#tf2zp'><p>Transfer function to zero-pole-gain form</p></a></li>
<li><a href='#tfestimate'><p>Transfer Function Estimate</p></a></li>
<li><a href='#triang'><p>Triangular window</p></a></li>
<li><a href='#tripuls'><p>Sampled aperiodic triangle</p></a></li>
<li><a href='#tukeywin'><p>Tukey (tapered cosine) window</p></a></li>
<li><a href='#udecode'><p>Uniform decoder</p></a></li>
<li><a href='#uencode'><p>Uniform encoder</p></a></li>
<li><a href='#ultrwin'><p>Ultraspherical window</p></a></li>
<li><a href='#unshiftdata'><p>Inverse of shiftdata</p></a></li>
<li><a href='#unwrap'><p>Unwrap phase angles</p></a></li>
<li><a href='#upfirdn'><p>Upsample, apply FIR filter, downsample</p></a></li>
<li><a href='#upsample'><p>Increase sample rate</p></a></li>
<li><a href='#upsamplefill'><p>Upsample and Fill</p></a></li>
<li><a href='#wconv'><p>1-D or 2-D convolution</p></a></li>
<li><a href='#welchwin'><p>Welch window</p></a></li>
<li><a href='#wkeep'><p>Keep part of vector or matrix</p></a></li>
<li><a href='#xcorr'><p>Cross-correlation</p></a></li>
<li><a href='#xcorr2'><p>2-D cross-correlation</p></a></li>
<li><a href='#xcov'><p>Cross-covariance</p></a></li>
<li><a href='#zerocrossing'><p>Zero Crossing</p></a></li>
<li><a href='#zp2sos'><p>Zero-pole-gain to second-order section format</p></a></li>
<li><a href='#zp2tf'><p>Zero-pole-gain to transfer function</p></a></li>
<li><a href='#Zpg'><p>Zero pole gain model</p></a></li>
<li><a href='#zplane'><p>Zero-pole plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Signal Processing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-14</td>
</tr>
<tr>
<td>Description:</td>
<td>R implementation of the 'Octave' package 'signal', containing
    a variety of signal processing tools, such as signal generation and
    measurement, correlation and convolution, filtering, filter design,
    filter analysis and conversion, power spectrum analysis, system
    identification, decimation and sample rate change, and windowing.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>pracma, Rcpp, grDevices</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gjmvanboxtel/gsignal">https://github.com/gjmvanboxtel/gsignal</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gjmvanboxtel/gsignal/issues">https://github.com/gjmvanboxtel/gsignal/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, ggplot2, gridExtra,
microbenchmark, imager, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-15 11:20:53 UTC; geert</td>
</tr>
<tr>
<td>Author:</td>
<td>Geert van Boxtel [aut, cre] (Maintainer),
  Tom Short [aut] (Author of 'signal' package),
  Paul Kienzle [aut] (Majority of the original sources),
  Ben Abbott [ctb],
  Juan Aguado [ctb],
  Muthiah Annamalai [ctb],
  Leonardo Araujo [ctb],
  William Asquith [ctb],
  David Bateman [ctb],
  David Billinghurst [ctb],
  Juan Pablo Carbajal [ctb],
  André Carezia [ctb],
  Vincent Cautaerts [ctb],
  Eric Chassande-Mottin [ctb],
  Luca Citi [ctb],
  Dave Cogdell [ctb],
  Carlo de Falco [ctb],
  Carne Draug [ctb],
  Pascal Dupuis [ctb],
  John W. Eaton [ctb],
  R.G.H Eschauzier [ctb],
  Andrew Fitting [ctb],
  Alan J. Greenberger [ctb],
  Mike Gross [ctb],
  Daniel Gunyan [ctb],
  Kai Habel [ctb],
  Kurt Hornik [ctb],
  Jake Janovetz [ctb],
  Alexander Klein [ctb],
  Peter V. Lanspeary [ctb],
  Bill Lash [ctb],
  Friedrich Leissh [ctb],
  Laurent S. Mazet [ctb],
  Mike Miller [ctb],
  Petr Mikulik [ctb],
  Paolo Neis [ctb],
  Georgios Ouzounis [ctb],
  Sylvain Pelissier [ctb],
  Francesco Potortì [ctb],
  Charles Praplan [ctb],
  Lukas F. Reichlin [ctb],
  Tony Richardson [ctb],
  Asbjorn Sabo [ctb],
  Thomas Sailer [ctb],
  Rolf Schirmacher [ctb],
  Rolf Schirmacher [ctb],
  Ivan Selesnick [ctb],
  Julius O. Smith III [ctb],
  Peter L. Soendergaard [ctb],
  Quentin Spencer [ctb],
  Doug Stewart [ctb],
  P. Sudeepam [ctb],
  Stefan van der Walt [ctb],
  Andreas Weber [ctb],
  P. Sudeepam [ctb],
  Andreas Weingessel [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Geert van Boxtel &lt;G.J.M.vanBoxtel@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-15 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gsignal-package'>gsignal: Signal Processing</h2><span id='topic+gsignal'></span><span id='topic+gsignal-package'></span>

<h3>Description</h3>

<p>R implementation of the 'Octave' package 'signal', containing a variety of signal processing tools, such as signal generation and measurement, correlation and convolution, filtering, filter design, filter analysis and conversion, power spectrum analysis, system identification, decimation and sample rate change, and windowing.
</p>


<h3>Details</h3>

<p>The package 'gsignal' is an implementation in R of the 'Octave' package
'signal'. It provides signal processing algorithms for use with R, include
the creation of waveforms, FIR and IIR filter design, spectral analysis,
Fourier and other transforms, window functions, and resampling and rate
changing.
</p>
<p>The 'Octave' package 'signal' release 1.4.1 (2019-02-08) was used to port the
functions to R. Note that compatibility of function parameters and return
values was not explicitly pursued.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a> (Maintainer)
</p>
<p>Authors:
</p>

<ul>
<li><p> Tom Short <a href="mailto:tshort@eprisolutions.com">tshort@eprisolutions.com</a> (Author of 'signal' package)
</p>
</li>
<li><p> Paul Kienzle (Majority of the original sources)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Ben Abbott [contributor]
</p>
</li>
<li><p> Juan Aguado [contributor]
</p>
</li>
<li><p> Muthiah Annamalai [contributor]
</p>
</li>
<li><p> Leonardo Araujo [contributor]
</p>
</li>
<li><p> William Asquith [contributor]
</p>
</li>
<li><p> David Bateman [contributor]
</p>
</li>
<li><p> David Billinghurst [contributor]
</p>
</li>
<li><p> Juan Pablo Carbajal [contributor]
</p>
</li>
<li><p> André Carezia [contributor]
</p>
</li>
<li><p> Vincent Cautaerts [contributor]
</p>
</li>
<li><p> Eric Chassande-Mottin [contributor]
</p>
</li>
<li><p> Luca Citi [contributor]
</p>
</li>
<li><p> Dave Cogdell [contributor]
</p>
</li>
<li><p> Carlo de Falco [contributor]
</p>
</li>
<li><p> Carne Draug [contributor]
</p>
</li>
<li><p> Pascal Dupuis [contributor]
</p>
</li>
<li><p> John W. Eaton [contributor]
</p>
</li>
<li><p> R.G.H Eschauzier [contributor]
</p>
</li>
<li><p> Andrew Fitting [contributor]
</p>
</li>
<li><p> Alan J. Greenberger [contributor]
</p>
</li>
<li><p> Mike Gross [contributor]
</p>
</li>
<li><p> Daniel Gunyan [contributor]
</p>
</li>
<li><p> Kai Habel [contributor]
</p>
</li>
<li><p> Kurt Hornik [contributor]
</p>
</li>
<li><p> Jake Janovetz [contributor]
</p>
</li>
<li><p> Alexander Klein [contributor]
</p>
</li>
<li><p> Peter V. Lanspeary [contributor]
</p>
</li>
<li><p> Bill Lash [contributor]
</p>
</li>
<li><p> Friedrich Leissh [contributor]
</p>
</li>
<li><p> Laurent S. Mazet [contributor]
</p>
</li>
<li><p> Mike Miller [contributor]
</p>
</li>
<li><p> Petr Mikulik [contributor]
</p>
</li>
<li><p> Paolo Neis [contributor]
</p>
</li>
<li><p> Georgios Ouzounis [contributor]
</p>
</li>
<li><p> Sylvain Pelissier [contributor]
</p>
</li>
<li><p> Francesco Potortì [contributor]
</p>
</li>
<li><p> Charles Praplan [contributor]
</p>
</li>
<li><p> Lukas F. Reichlin [contributor]
</p>
</li>
<li><p> Tony Richardson [contributor]
</p>
</li>
<li><p> Asbjorn Sabo [contributor]
</p>
</li>
<li><p> Thomas Sailer [contributor]
</p>
</li>
<li><p> Rolf Schirmacher [contributor]
</p>
</li>
<li><p> Rolf Schirmacher [contributor]
</p>
</li>
<li><p> Ivan Selesnick [contributor]
</p>
</li>
<li><p> Julius O. Smith III [contributor]
</p>
</li>
<li><p> Peter L. Soendergaard [contributor]
</p>
</li>
<li><p> Quentin Spencer [contributor]
</p>
</li>
<li><p> Doug Stewart [contributor]
</p>
</li>
<li><p> P. Sudeepam [contributor]
</p>
</li>
<li><p> Stefan van der Walt [contributor]
</p>
</li>
<li><p> Andreas Weber [contributor]
</p>
</li>
<li><p> P. Sudeepam [contributor]
</p>
</li>
<li><p> Andreas Weingessel [contributor]
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://wiki.octave.org/Signal_package">https://wiki.octave.org/Signal_package</a>,<br />
<a href="https://octave.sourceforge.io/signal/">https://octave.sourceforge.io/signal/</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/gjmvanboxtel/gsignal">https://github.com/gjmvanboxtel/gsignal</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/gjmvanboxtel/gsignal/issues">https://github.com/gjmvanboxtel/gsignal/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ar_psd'>Power spectrum of AR model</h2><span id='topic+ar_psd'></span><span id='topic+plot.ar_psd'></span><span id='topic+print.ar_psd'></span>

<h3>Description</h3>

<p>Compute the power spectral density of an autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar_psd(
  a,
  v = 1,
  freq = 256,
  fs = 1,
  range = ifelse(is.numeric(a), "half", "whole"),
  method = ifelse(length(freq) == 1 &amp;&amp; bitwAnd(freq, freq - 1) == 0, "fft", "poly")
)

## S3 method for class 'ar_psd'
plot(
  x,
  yscale = c("linear", "log", "dB"),
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ...
)

## S3 method for class 'ar_psd'
print(
  x,
  yscale = c("linear", "log", "dB"),
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar_psd_+3A_a">a</code></td>
<td>
<p>numeric vector of autoregressive model coefficients. The first
element is the zero-lag coefficient, which always has a value of 1.</p>
</td></tr>
<tr><td><code id="ar_psd_+3A_v">v</code></td>
<td>
<p>square of the moving average coefficient, specified as a positive
scalar Default: 1</p>
</td></tr>
<tr><td><code id="ar_psd_+3A_freq">freq</code></td>
<td>
<p>vector of frequencies at which power spectral density is
calculated, or a scalar indicating the number of uniformly distributed
frequency values at which spectral density is calculated. Default: 256.</p>
</td></tr>
<tr><td><code id="ar_psd_+3A_fs">fs</code></td>
<td>
<p>sampling frequency (Hz). Default: 1</p>
</td></tr>
<tr><td><code id="ar_psd_+3A_range">range</code></td>
<td>
<p>character string. one of:
</p>

<dl>
<dt><code>"half"</code> or <code>"onesided"</code></dt><dd><p>frequency range of the spectrum
is from zero up to but not including <code>fs / 2</code>. Power from negative
frequencies is added to the positive side of the spectrum.</p>
</dd>
<dt><code>"whole"</code> or <code>"twosided"</code></dt><dd><p>frequency range of the spectrum
is <code>-fs / 2</code> to <code>fs / 2</code>, with negative frequencies stored in
&quot;wrap around order&quot; after the positive frequencies; e.g. frequencies for a
10-point <code>"twosided"</code> spectrum are 0 0.1 0.2 0.3 0.4 0.5 -0.4 -0.3
-0.2. -0.1.</p>
</dd>
<dt><code>"shift"</code> or <code>"centerdc"</code></dt><dd><p>same as <code>"whole"</code> but with
the first half of the spectrum swapped with second half to put the
zero-frequency value in the middle. If <code>freq</code> is a vector,
<code>"shift"</code> is ignored.</p>
</dd>
</dl>

<p>Default: If model coefficients <code>a</code> are real, the default range is
<code>"half"</code>, otherwise the default range is <code>"whole"</code>.</p>
</td></tr>
<tr><td><code id="ar_psd_+3A_method">method</code></td>
<td>
<p>method used to calculate the power spectral density, either
<code>"fft"</code> (use the Fast Fourier Transform) or <code>"poly"</code> (calculate
the power spectrum as a polynomial). This argument is ignored if the
<code>freq</code> argument is a vector. The default is <code>"poly"</code> unless the
<code>freq</code> argument is an integer power of 2.</p>
</td></tr>
<tr><td><code id="ar_psd_+3A_x">x</code></td>
<td>
<p>object to plot.</p>
</td></tr>
<tr><td><code id="ar_psd_+3A_yscale">yscale</code></td>
<td>
<p>character string specifying scaling of Y-axis; one of
<code>"linear"</code>, <code>"log"</code>, <code>"dB"</code></p>
</td></tr>
<tr><td><code id="ar_psd_+3A_xlab">xlab</code>, <code id="ar_psd_+3A_ylab">ylab</code>, <code id="ar_psd_+3A_main">main</code></td>
<td>
<p>labels passed to plotting function. Default: NULL</p>
</td></tr>
<tr><td><code id="ar_psd_+3A_...">...</code></td>
<td>
<p>additional arguments passed to functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the power spectrum of the autoregressive model

</p>
<pre>
                       M
x(n) = sqrt(v).e(n) + SUM a(k).x(n-k)
                      k=1
</pre>
<p>where <code>x(n)</code> is the output of the model and <code>e(n)</code> is white noise.
</p>


<h3>Value</h3>

<p>An object of class <code>"ar_psd"</code> , which is a list containing two
elements, <code>freq</code> and <code>psd</code> containing the frequency values and
the estimates of power-spectral density, respectively.
</p>


<h3>Author(s)</h3>

<p>Peter V. Lanspeary, <a href="mailto:pvl@mecheng.adelaide.edu.au">pvl@mecheng.adelaide.edu.au</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(1, -2.7607, 3.8106, -2.6535, 0.9238)
psd &lt;- ar_psd(a)

</code></pre>

<hr>
<h2 id='arburg'>Autoregressive model coefficients - Burg's method</h2><span id='topic+arburg'></span>

<h3>Description</h3>

<p>Calculate the coefficients of an autoregressive model using the whitening
lattice-filter method of Burg (1968)[1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arburg(x, p, criterion = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arburg_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric or complex vector or matrix. In
case of a vector it represents a single signal; in case of a matrix each
column is a signal.</p>
</td></tr>
<tr><td><code id="arburg_+3A_p">p</code></td>
<td>
<p>model order; number of poles in the AR model or limit to the number
of poles if a valid criterion is provided. Must be &lt; length(x) - 2.</p>
</td></tr>
<tr><td><code id="arburg_+3A_criterion">criterion</code></td>
<td>
<p>model-selection criterion. Limits the number of poles so
that spurious poles are not added when the whitened data has no more
information in it. Recognized values are:
</p>

<dl>
<dt>AKICc</dt><dd><p>approximate corrected Kullback information criterion
(recommended)</p>
</dd>
<dt>KIC</dt><dd><p>Kullback information criterion</p>
</dd>
<dt>AICc</dt><dd><p>corrected Akaike information criterion</p>
</dd>
<dt>AIC</dt><dd><p>Akaike information criterion</p>
</dd>
<dt>FPE</dt><dd><p>final prediction error</p>
</dd>
</dl>

<p>The default is to NOT use a model-selection criterion (NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse of the autoregressive model is a moving-average filter which
reduces <code>x</code> to white noise. The power spectrum of the AR model is an
estimate of the maximum entropy power spectrum of the data. The function
<code>ar_psd</code> calculates the power spectrum of the AR model.
</p>
<p>For data input <code>x(n)</code> and white noise <code>e(n)</code>, the autoregressive
model is

</p>
<pre>
                          p+1
    x(n) = sqrt(v).e(n) + SUM a(k).x(n-k)
                          k=1
 </pre>
<p><code>arburg</code> does not remove the mean from the data. You should remove the
mean from the data if you want a power spectrum. A non-zero mean can produce
large errors in a power-spectrum estimate.  See <code><a href="#topic+detrend">detrend</a></code>
</p>


<h3>Value</h3>

<p>A <code>list</code> containing the following elements:
</p>

<dl>
<dt>a</dt><dd><p>vector or matrix containing <code>(p+1)</code> autoregression
coefficients. If <code>x</code> is a matrix, then each row of a corresponds to
a column of <code>x</code>. <code>a</code> has <code>p + 1</code> columns.</p>
</dd>
<dt>e</dt><dd><p>white noise input variance, returned as a vector. If <code>x</code> is
a matrix, then each element of e corresponds to a column of <code>x</code>.</p>
</dd>
<dt>k</dt><dd><p>Reflection coefficients defining the lattice-filter embodiment
of the model returned as vector or a matrix. If <code>x</code> is a matrix,
then each column of <code>k</code> corresponds to a column of <code>x</code>.
<code>k</code> has <code>p</code> rows.</p>
</dd>
</dl>



<h3>Note</h3>

<p>AIC, AICc, KIC and AKICc are based on information theory. They  attempt
to balance the complexity (or length) of the model against how well the
model fits the data.  AIC and KIC are biased estimates of the asymmetric
and the symmetric Kullback-Leibler divergence, respectively. AICc and AKICc
attempt to correct the bias. See reference [2].
</p>


<h3>Author(s)</h3>

<p>Peter V. Lanspeary, <a href="mailto:pvl@mecheng.adelaide.edu.au">pvl@mecheng.adelaide.edu.au</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] Burg, J.P. (1968) A new analysis technique for time series
data, NATO advanced study Institute on Signal Processing with Emphasis on
Underwater Acoustics, Enschede, Netherlands, Aug. 12-23, 1968.<br />
[2] Seghouane, A. and Bekara, M. (2004). A small sample model selection
criterion based on Kullback’s symmetric divergence. IEEE Trans. Sign.
Proc., 52(12), pp 3314-3323,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ar_psd">ar_psd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Arma(1, c(1, -2.7607, 3.8106, -2.6535, 0.9238))
y &lt;- filter(A, 0.2 * rnorm(1024))
coefs &lt;- arburg(y, 4)

</code></pre>

<hr>
<h2 id='Arma'>Autoregressive moving average (ARMA) model</h2><span id='topic+Arma'></span><span id='topic+as.Arma'></span><span id='topic+as.Arma.Arma'></span><span id='topic+as.Arma.Ma'></span><span id='topic+as.Arma.Sos'></span><span id='topic+as.Arma.Zpg'></span>

<h3>Description</h3>

<p>Create an ARMA model representing a filter or system model, or
convert other forms to an ARMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Arma(b, a)

as.Arma(x, ...)

## S3 method for class 'Arma'
as.Arma(x, ...)

## S3 method for class 'Ma'
as.Arma(x, ...)

## S3 method for class 'Sos'
as.Arma(x, ...)

## S3 method for class 'Zpg'
as.Arma(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arma_+3A_b">b</code></td>
<td>
<p>moving average (MA) polynomial coefficients.</p>
</td></tr>
<tr><td><code id="Arma_+3A_a">a</code></td>
<td>
<p>autoregressive (AR) polynomial coefficients.</p>
</td></tr>
<tr><td><code id="Arma_+3A_x">x</code></td>
<td>
<p>model or filter to be converted to an ARMA representation.</p>
</td></tr>
<tr><td><code id="Arma_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ARMA model is defined by:
</p>
<p style="text-align: center;"><code class="reqn">a(L)y(t) = b(L)x(t)</code>
</p>

<p>The ARMA model can define an analog or digital model. The AR and MA
polynomial coefficients follow the convention in 'Matlab' and 'Octave' where
the coefficients are in decreasing order of the polynomial (the opposite of
the definitions for <code><a href="stats.html#topic+filter">filter</a></code>filter and
<code><a href="base.html#topic+polyroot">polyroot</a></code>). For an analog model,

</p>
<pre>
  H(s) = (b[1]*s^(m-1) + b[2]*s^(m-2) + ... + b[m]) / (a[1]*s^(n-1) +
  a[2]*s^(n-2) + ... + a[n])
</pre>
<p>For a z-plane digital model,

</p>
<pre>
  H(z) = (b[1] + b[2]*z^(-1) + … + b[m]*z^(-m+1)) / (a[1] + a[2]*z^(-1) + … +
  a[n]*z^(-n+1))
</pre>
<p><code>as.Arma</code> converts from other forms, including <code>Zpg</code> and <code>Ma</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>'Arma'</code> with the following list elements:
</p>

<dl>
<dt>b</dt><dd><p>moving average (MA) polynomial coefficients</p>
</dd>
<dt>a</dt><dd><p>autoregressive (AR) polynomial coefficients</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tom Short, <a href="mailto:tshort@eprisolutions.com">tshort@eprisolutions.com</a>,<br />
adapted by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+Zpg">Zpg</a></code>, <code><a href="#topic+Ma">Ma</a></code>, <code><a href="#topic+filter">filter</a></code>,
and various filter-generation functions like <code><a href="#topic+butter">butter</a></code> and
<code><a href="#topic+cheby1">cheby1</a></code> that return Arma models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filt &lt;- Arma(b = c(1, 2, 1)/3, a = c(1, 1))
zplane(filt)

</code></pre>

<hr>
<h2 id='aryule'>Autoregressive model coefficients - Yule-Walker method</h2><span id='topic+aryule'></span>

<h3>Description</h3>

<p>compute autoregressive all-pole model parameters using the Yule-Walker
method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aryule(x, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aryule_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric or complex vector or matrix. In
case of a vector it represents a single signal; in case of a matrix each
column is a signal.</p>
</td></tr>
<tr><td><code id="aryule_+3A_p">p</code></td>
<td>
<p>model order; number of poles in the AR model or limit to the number
of poles if a valid criterion is provided. Must be smaller than the length
of <code>x</code> minus 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>aryule</code> uses the Levinson-Durbin recursion on the biased estimate of
the sample autocorrelation sequence to compute the parameters.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing the following elements:
</p>

<dl>
<dt>a</dt><dd><p>vector or matrix containing <code>(p + 1)</code> autoregression
coefficients. If <code>x</code> is a matrix, then each row of a corresponds to
a column of <code>x</code>. <code>a</code> has <code>p + 1</code> columns.</p>
</dd>
<dt>e</dt><dd><p>white noise input variance, returned as a vector. If <code>x</code> is
a matrix, then each element of e corresponds to a column of <code>x</code>.</p>
</dd>
<dt>k</dt><dd><p>Reflection coefficients defining the lattice-filter embodiment
of the model returned as vector or a matrix. If <code>x</code> is a matrix,
then each column of <code>k</code> corresponds to a column of <code>x</code>.
<code>k</code> has <code>p</code> rows.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The power spectrum of the resulting filter can be plotted with
<code>pyulear(x, p)</code>, or you can plot it directly with
<code>ar_psd(a,v,...)</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Peter V. Lanspeary, <a href="mailto:pvl@mecheng.adelaide.edu.au">pvl@mecheng.adelaide.edu.au</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ar_psd">ar_psd</a></code>, <code><a href="#topic+arburg">arburg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- Arma(1, c(1, -2.7607, 3.8106, -2.6535, 0.9238))
y &lt;- filter(a, rnorm(1024))
coefs &lt;- aryule(y, 4)

</code></pre>

<hr>
<h2 id='barthannwin'>Modified Bartlett-Hann window</h2><span id='topic+barthannwin'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a modified Bartlett-Hann window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barthannwin(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barthannwin_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Like Bartlett, Hann, and Hamming windows, the Bartlett-Hann window has a
mainlobe at the origin and asymptotically decaying sidelobes on both sides.
It is a linear combination of weighted Bartlett and Hann windows with near
sidelobes lower than both Bartlett and Hann and with far sidelobes lower than
both Bartlett and Hamming windows. The mainlobe width of the modified
Bartlett-Hann window is not increased relative to either Bartlett or Hann
window mainlobes.
</p>


<h3>Value</h3>

<p>Modified Bartlett-Hann window, returned as a vector. If you specify a
one-point window <code>(n = 1)</code>, the value 1 is returned.
</p>


<h3>Author(s)</h3>

<p>Andreas Weingessel, <a href="mailto:Andreas.Weingessel@ci.tuwien.ac.at">Andreas.Weingessel@ci.tuwien.ac.at</a>.
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bartlett">bartlett</a></code>, <code><a href="#topic+hann">hann</a></code>, <code><a href="#topic+hamming">hamming</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t &lt;- barthannwin(64)
plot (t, type = "l", xlab = "Samples", ylab =" Amplitude")

</code></pre>

<hr>
<h2 id='bartlett'>Bartlett window</h2><span id='topic+bartlett'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a Bartlett (triangular) window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bartlett(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bartlett_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bartlett window is very similar to a triangular window as returned by the
<code><a href="#topic+triang">triang</a></code> function. However, the Bartlett window always has zeros
at the first and last samples, while the triangular window is nonzero at
those points.
</p>


<h3>Value</h3>

<p>Bartlett window, returned as a vector. If you specify a one-point
window <code>(n = 1)</code>, the value 1 is returned.
</p>


<h3>Author(s)</h3>

<p>Andreas Weingessel, <a href="mailto:Andreas.Weingessel@ci.tuwien.ac.at">Andreas.Weingessel@ci.tuwien.ac.at</a>.
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triang">triang</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bw &lt;- bartlett(64)
plot (bw, type = "l", xlab = "Samples", ylab =" Amplitude")

</code></pre>

<hr>
<h2 id='besselap'>Bessel analog low-pass filter prototype</h2><span id='topic+besselap'></span>

<h3>Description</h3>

<p>Return the poles and gain of a Bessel analog low-pass filter prototype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>besselap(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="besselap_+3A_n">n</code></td>
<td>
<p>order of the filter; must be &lt; 25.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transfer function is

</p>
<pre>
                     k
 H(s) = -----------------------------
         (s-p(1))(s-p(2))...(s-p(n))

</pre>
<p><code>besselap</code> normalizes the poles and gain so that at low frequency and
high frequency the Bessel prototype is asymptotically equivalent to the
Butterworth prototype of the same order. The magnitude of the filter is less
than <code class="reqn">1/\sqrt{2}</code> at the unity cutoff frequency <code class="reqn">\Omega_c = 1</code>.
</p>
<p>Analog Bessel filters are characterized by a group delay that is maximally
flat at zero frequency and almost constant throughout the passband. The group
delay at zero frequency is

</p>
<pre>
   /  (2n!) \ 2
   | ------ |
   \ 2^n n! /
</pre>


<h3>Value</h3>

<p>List of class <code><a href="#topic+Zpg">Zpg</a></code> containing poles and gain of the
filter
</p>


<h3>Author(s)</h3>

<p>Thomas Sailer, emailt.sailer@alumni.ethz.ch.<br /> Conversion to R by
Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Bessel_polynomials">https://en.wikipedia.org/wiki/Bessel_polynomials</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 6th order Bessel low-pass analog filter
zp &lt;- besselap(6)
w &lt;- seq(0, 4, length.out = 128)
freqs(zp, w)

</code></pre>

<hr>
<h2 id='besself'>Bessel analog filter design</h2><span id='topic+besself'></span>

<h3>Description</h3>

<p>Compute the transfer function coefficients of an analog Bessel filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>besself(n, w, type = c("low", "high", "stop", "pass"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="besself_+3A_n">n</code></td>
<td>
<p>filter order.</p>
</td></tr>
<tr><td><code id="besself_+3A_w">w</code></td>
<td>
<p>critical frequencies of the filter. <code>w</code> must be a scalar for
low-pass and high-pass filters, and <code>w</code> must be a two-element vector
c(low, high) specifying the lower and upper bands in radians/second.</p>
</td></tr>
<tr><td><code id="besself_+3A_type">type</code></td>
<td>
<p>filter type, one of <code>"low"</code> (default), <code>"high"</code>,
<code>"stop"</code>, or <code>"pass"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bessel filters are characterized by an almost constant group delay across the
entire passband, thus preserving the wave shape of filtered signals in the
passband.
</p>
<p>Lowpass Bessel filters have a monotonically decreasing magnitude response, as
do lowpass Butterworth filters. Compared to the Butterworth, Chebyshev, and
elliptic filters, the Bessel filter has the slowest rolloff and requires the
highest order to meet an attenuation specification.
</p>


<h3>Value</h3>

<p>List of class <code>'<a href="#topic+Zpg">Zpg</a>'</code> containing poles and gain of the
filter.
</p>


<h3>Note</h3>

<p>As the important characteristic of a Bessel filter is its
maximally-flat group delay, and not the amplitude response, it is
inappropriate to use the bilinear transform to convert the analog Bessel
filter into a digital form (since this preserves the amplitude response but
not the group delay) [1].
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Doug Stewart, <a href="mailto:dastew@sympatico.ca">dastew@sympatico.ca</a>,<br />
Thomas Sailer, <a href="mailto:t.sailer@alumni.ethz.ch">t.sailer@alumni.ethz.ch</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] <a href="https://en.wikipedia.org/wiki/Bessel_filter">https://en.wikipedia.org/wiki/Bessel_filter</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- seq(0, 4, length.out = 128)

## 5th order Bessel low-pass analog filter
zp &lt;- besself(5, 1.0)
freqs(zp, w)

## 5th order Bessel high-pass analog filter
zp &lt;- besself(5, 1.0, 'high')
freqs(zp, w)

## 5th order Bessel band-pass analog filter
zp &lt;- besself(5, c(1, 2), 'pass')
freqs(zp, w)

## 5th order Bessel band-stop analog filter
zp &lt;- besself(5, c(1, 2), 'stop')
freqs(zp, w)

</code></pre>

<hr>
<h2 id='bilinear'>Bilinear transformation</h2><span id='topic+bilinear'></span><span id='topic+bilinear.Zpg'></span><span id='topic+bilinear.Arma'></span><span id='topic+bilinear.default'></span>

<h3>Description</h3>

<p>Transform a s-plane (analog) filter specification into a z-plane (digital)
specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bilinear(Sz, ...)

## S3 method for class 'Zpg'
bilinear(Sz, T = 2 * tan(1/2), ...)

## S3 method for class 'Arma'
bilinear(Sz, T = 2 * tan(1/2), ...)

## Default S3 method:
bilinear(Sz, Sp, Sg, T = 2 * tan(1/2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bilinear_+3A_sz">Sz</code></td>
<td>
<p>In the generic case, a model to be transformed. In the default
case, a vector containing the zeros in a pole-zero-gain model.</p>
</td></tr>
<tr><td><code id="bilinear_+3A_...">...</code></td>
<td>
<p>arguments passed to the generic function.</p>
</td></tr>
<tr><td><code id="bilinear_+3A_t">T</code></td>
<td>
<p>the sampling frequency represented in the z plane. Default:
<code>2 * tan(1 / 2)</code>.</p>
</td></tr>
<tr><td><code id="bilinear_+3A_sp">Sp</code></td>
<td>
<p>a vector containing the poles in a pole-zero-gain model.</p>
</td></tr>
<tr><td><code id="bilinear_+3A_sg">Sg</code></td>
<td>
<p>a vector containing the gain in a pole-zero-gain model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a piecewise flat filter design, you can transform it from the s-plane
to the z-plane while maintaining the band edges by means of the bilinear
transform. This maps the left hand side of the s-plane into the interior of
the unit circle. The mapping is highly non-linear, so you must design your
filter with band edges in the s-plane positioned at <code class="reqn">2/T tan(wT / 2)</code> so
that they will be positioned at <code>w</code> after the bilinear transform is
complete.
</p>
<p>The bilinear transform is:
</p>
<p style="text-align: center;"><code class="reqn">z = (1 + sT / 2) / (1 - sT / 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">s = (T / 2) (z - 1) / (z + 1)</code>
</p>

<p>Please note that a pole and a zero at the same place exactly cancel. This is
significant since the bilinear transform creates numerous extra poles and
zeros, most of which cancel. Those which do not cancel have a “fill-in”
effect, extending the shorter of the sets to have the same number of as the
longer of the sets of poles and zeros (or at least split the difference in
the case of the band pass filter). There may be other opportunistic
cancellations, but it will not check for them.
</p>
<p>Also note that any pole on the unit circle or beyond will result in an
unstable filter. Because of cancellation, this will only happen if the number
of poles is smaller than the number of zeros. The analytic design methods all
yield more poles than zeros, so this will not be a problem.
</p>


<h3>Value</h3>

<p>For the default case or for bilinear.Zpg, an object of class
<code>'Zpg'</code>, containing the list elements:
</p>

<dl>
<dt>z</dt><dd><p>complex vector of the zeros of the transformed model</p>
</dd>
<dt>p</dt><dd><p>complex vector of the poles of the transformed model</p>
</dd>
<dt>g</dt><dd><p>gain of the transformed model</p>
</dd>
</dl>

<p>For bilinear.Arma, an object of class <code>'Arma'</code>, containing the list
elements:
</p>

<dl>
<dt>b</dt><dd><p>moving average (MA) polynomial coefficients</p>
</dd>
<dt>a</dt><dd><p>autoregressive (AR) polynomial coefficients</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Paul Kienzle <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>. Conversion to R by Tom
Short, adapted by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Bilinear_transform">https://en.wikipedia.org/wiki/Bilinear_transform</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 6th order Bessel low-pass analog filter
zp &lt;- besselap(6)
w &lt;- seq(0, 4, length.out = 128)
freqs(zp, w)
zzp &lt;- bilinear(zp)
freqz(zzp)

</code></pre>

<hr>
<h2 id='bitrevorder'>Permute input to bit-reversed order</h2><span id='topic+bitrevorder'></span>

<h3>Description</h3>

<p>Reorder the elements of the input vector in bit-reversed order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bitrevorder(x, index.return = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bitrevorder_+3A_x">x</code></td>
<td>
<p>input data, specified as a vector. The length of <code>x</code> must be an
integer power of 2.</p>
</td></tr>
<tr><td><code id="bitrevorder_+3A_index.return">index.return</code></td>
<td>
<p>logical indicating if the ordering index vector should be
returned as well. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is equivalent to calling <code>digitrevorder(x, 2)</code>, and is
useful for prearranging filter coefficients so that bit-reversed ordering
does not have to be performed as part of an fft or ifft computation.
</p>


<h3>Value</h3>

<p>The bit-reversed input vector. If <code>index.return = TRUE</code>, then
a list containing the bit-reversed input vector (<code>y</code>), and the
digit-reversed indices (<code>i</code>).
</p>


<h3>Author(s)</h3>

<p>Mike Miller.<br />
Port to to by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+digitrevorder">digitrevorder</a></code>, <code><a href="stats.html#topic+fft">fft</a></code>, <code><a href="#topic+ifft">ifft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0:15
v &lt;- bitrevorder(x)
dec2bin &lt;- function(x, l)
  substr(paste(as.integer(rev(intToBits(x))), collapse = ""),
  32 - l + 1, 32)
x_bin &lt;- sapply(x, dec2bin, 4)
v_bin &lt;- sapply(v, dec2bin, 4)
data.frame(x, x_bin, v, v_bin)

</code></pre>

<hr>
<h2 id='blackman'>Blackman window</h2><span id='topic+blackman'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a Blackman window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blackman(n, method = c("symmetric", "periodic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blackman_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="blackman_+3A_method">method</code></td>
<td>
<p>Character string. Window sampling method, specified as:
</p>

<dl>
<dt>&quot;symmetric&quot; (Default)</dt><dd><p>Use this option when using windows for filter
design.</p>
</dd>
<dt>&quot;periodic&quot;</dt><dd><p>This option is useful for spectral analysis because it
enables a windowed signal to have the perfect periodic extension implicit
in the discrete Fourier transform. When &quot;periodic&quot; is specified, the
function computes a window of length <code>n + 1</code> and returns the first
<code>n</code> points.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The Blackman window is a member of the family of cosine sum windows.
</p>


<h3>Value</h3>

<p>Blackman window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Andreas Weingessel, <a href="mailto:Andreas.Weingessel@ci.tuwien.ac.at">Andreas.Weingessel@ci.tuwien.ac.at</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
h &lt;- blackman(64)
plot (h, type = "l", xlab = "Samples", ylab =" Amplitude")

bs = blackman(64,'symmetric')
bp = blackman(63,'periodic')
plot (bs, type = "l", xlab = "Samples", ylab =" Amplitude")
lines(bp, col="red")

</code></pre>

<hr>
<h2 id='blackmanharris'>Blackman-Harris window</h2><span id='topic+blackmanharris'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a minimum four-term Blackman-Harris window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blackmanharris(n, method = c("symmetric", "periodic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blackmanharris_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="blackmanharris_+3A_method">method</code></td>
<td>
<p>Character string. Window sampling method, specified as:
</p>

<dl>
<dt>&quot;symmetric&quot; (Default)</dt><dd><p>Use this option when using windows for filter
design.</p>
</dd>
<dt>&quot;periodic&quot;</dt><dd><p>This option is useful for spectral analysis because it
enables a windowed signal to have the perfect periodic extension implicit
in the discrete Fourier transform. When &quot;periodic&quot; is specified, the
function computes a window of length <code>n + 1</code> and returns the first
<code>n</code> points.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The Blackman window is a member of the family of cosine sum windows. It is a
generalization of the Hamming family, produced by adding more shifted sinc
functions, meant to minimize side-lobe levels.
</p>


<h3>Value</h3>

<p>Blackman-Harris window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
b &lt;- blackmanharris(64)
plot (b, type = "l", xlab = "Samples", ylab =" Amplitude")

bs = blackmanharris(64,'symmetric')
bp = blackmanharris(63,'periodic')
plot (bs, type = "l", xlab = "Samples", ylab =" Amplitude")
lines(bp, col="red")

</code></pre>

<hr>
<h2 id='blackmannuttall'>Blackman-Nuttall window</h2><span id='topic+blackmannuttall'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a Blackman-Nuttal window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blackmannuttall(n, method = c("symmetric", "periodic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blackmannuttall_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="blackmannuttall_+3A_method">method</code></td>
<td>
<p>Character string. Window sampling method, specified as:
</p>

<dl>
<dt>&quot;symmetric&quot; (Default)</dt><dd><p>Use this option when using windows for filter
design.</p>
</dd>
<dt>&quot;periodic&quot;</dt><dd><p>This option is useful for spectral analysis because it
enables a windowed signal to have the perfect periodic extension implicit
in the discrete Fourier transform. When &quot;periodic&quot; is specified, the
function computes a window of length <code>n + 1</code> and returns the first
<code>n</code> points.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The Blackman-Nuttall window is a member of the family of cosine sum windows.
</p>


<h3>Value</h3>

<p>Blackman-Nuttall window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Muthiah Annamalai, <a href="mailto:muthiah.annamalai@uta.edu">muthiah.annamalai@uta.edu</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
b &lt;- blackmannuttall(64)
plot (b, type = "l", xlab = "Samples", ylab =" Amplitude")

bs = blackmannuttall(64,'symmetric')
bp = blackmannuttall(63,'periodic')
plot (bs, type = "l", xlab = "Samples", ylab =" Amplitude")
lines(bp, col="red")

</code></pre>

<hr>
<h2 id='bohmanwin'>Bohman window</h2><span id='topic+bohmanwin'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a Bohman window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bohmanwin(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bohmanwin_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Bohman window is the convolution of two half-duration cosine lobes. In the
time domain, it is the product of a triangular window and a single cycle of a
cosine with a term added to set the first derivative to zero at the boundary.
</p>


<h3>Value</h3>

<p>Bohman window, returned as a vector. If you specify a one-point
window <code>(n = 1)</code>, the value 1 is returned.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triang">triang</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
b &lt;- bohmanwin(64)
plot (b, type = "l", xlab = "Samples", ylab =" Amplitude")

</code></pre>

<hr>
<h2 id='boxcar'>Rectangular window</h2><span id='topic+boxcar'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a boxcar (rectangular) window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcar(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcar_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rectangular window (sometimes known as the boxcar or Dirichlet window) is
the simplest window, equivalent to replacing all but <code>n</code> values of a
data sequence by zeros, making it appear as though the waveform suddenly
turns on and off. Other windows are designed to moderate these sudden
changes, which reduces scalloping loss and improves dynamic range.
</p>


<h3>Value</h3>

<p>rectangular window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triang">triang</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
b &lt;- boxcar(64)
plot (b, type = "l", xlab = "Samples", ylab =" Amplitude")

</code></pre>

<hr>
<h2 id='buffer'>Buffer signal vector into matrix of data segments</h2><span id='topic+buffer'></span>

<h3>Description</h3>

<p>Partition a signal vector into nonoverlapping, overlapping, or underlapping
data segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buffer(x, n, p = 0, opt, zopt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buffer_+3A_x">x</code></td>
<td>
<p>The data to be buffered.</p>
</td></tr>
<tr><td><code id="buffer_+3A_n">n</code></td>
<td>
<p>The number of rows in the produced data buffer. This is an positive
integer value and must be supplied.</p>
</td></tr>
<tr><td><code id="buffer_+3A_p">p</code></td>
<td>
<p>An integer less than <code>n</code> that specifies the under- or overlap
between column in the data frame. Default 0.</p>
</td></tr>
<tr><td><code id="buffer_+3A_opt">opt</code></td>
<td>
<p>In the case of an overlap, <code>opt</code> can be either a vector of
length <code>p</code> or the string <code>'nodelay'</code>. If <code>opt</code> is a vector,
then the first <code>p</code> entries in <code>y</code> will be filled with these
values. If <code>opt</code> is the string <code>'nodelay'</code>, then the first value
of <code>y</code> corresponds to the first value of <code>x</code>. In the case of an
underlap, <code>opt</code> must be an integer between 0 and <code>-p</code>. The
represents the initial underlap of the first <code>y</code>. The default value
for <code>opt</code> the vector <code>matrix (0L, 1, p)</code> in the case of an
overlap, or 0 otherwise.</p>
</td></tr>
<tr><td><code id="buffer_+3A_zopt">zopt</code></td>
<td>
<p>Logical. If TRUE, return values for <code>z</code> and <code>opt</code> in
addition to <code>y</code>. Default is FALSE (return only <code>y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y &lt;- buffer(x, n)</code> partitions a signal vector <code>x</code> of length
<code>L</code> into nonoverlapping data segments of length <code>n</code>. Each data
segment occupies one column of matrix output <code>y</code>, which has <code>n</code>
rows and <code>ceil(L / n)</code> columns. If <code>L</code> is not evenly divisible by
<code>n</code>, the last column is zero-padded to length <code>n</code>.
</p>
<p><code>y &lt;- buffer(x, n, p)</code> overlaps or underlaps successive frames in the
output matrix by <code>p</code> samples.
</p>

<ul>
<li> <p>For <code>0 &lt; p &lt; n</code> (overlap), buffer repeats the final <code>p</code>
samples of each segment at the beginning of the following segment. See the
example where <code>x = 1:30</code>, <code>n = 7</code>, and an overlap of <code>p = 3</code>.
In this case, the first segment starts with <code>p</code> zeros (the default
initial condition), and the number of columns in <code>y</code> is <code>ceil(L /
(n - p))</code>.
</p>
</li>
<li>  <p>For <code>p &lt; 0</code> (underlap), buffer skips <code>p</code> samples between
consecutive segments. See the example where <code>x = 1:30</code>, <code>n = 7</code>,
and <code>p = -3</code>. The number of columns in <code>y</code> is <code>ceil(L / (n -
p))</code>.
</p>
</li></ul>

<p>In <code>y &lt;- buffer(x, n, p, opt)</code>, <code>opt</code> specifies a vector of samples
to precede <code>x[1]</code> in an overlapping buffer, or the number of initial
samples to skip in an underlapping buffer.
</p>

<ul>
<li> <p>For <code>0 &lt; p &lt; n</code> (overlap), <code>opt</code> specifies a vector of
length <code>p</code> to insert before <code>x[1]</code> in the buffer. This vector can
be considered an initial condition, which is needed when the current
buffering operation is one in a sequence of consecutive buffering
operations. To maintain the desired segment overlap from one buffer to the
next, <code>opt</code> should contain the final <code>p</code> samples of the previous
buffer in the sequence. Set <code>opt</code> to <code>"nodelay"</code> to skip the
initial condition and begin filling the buffer immediately with
<code>x[1]</code>. In this case, <code>L</code> must be <code>length(p)</code> or longer. See
the example where <code>x = 1:30</code>, <code>n = 7</code>, <code>p = 3</code>, and
<code>opt = "nodelay"</code>.
</p>
</li>
<li> <p>For <code>p &lt; 0</code> (underlap), <code>opt</code> is an integer value in the
range <code>0 : -p</code> specifying the number of initial input samples,
<code>x[1:opt]</code>, to skip before adding samples to the buffer. The first
value in the buffer is therefore <code>x[opt + 1]</code>.
</p>
</li></ul>

<p>The <code>opt</code> option is especially useful when the current buffering
operation is one in a sequence of consecutive buffering operations. To
maintain the desired frame underlap from one buffer to the next, <code>opt</code>
should equal the difference between the total number of points to skip
between frames (<code>p</code>) and the number of points that were available to be
skipped in the previous input to buffer. If the previous input had fewer than
p points that could be skipped after filling the final frame of that buffer,
the remaining opt points need to be removed from the first frame of the
current buffer. See Continuous Buffering for an example of how this works in
practice.
</p>
<p><code>buf &lt;- buffer(..., zopt = TRUE)</code> returns the last <code>p</code> samples of a
overlapping buffer in output <code>buf$opt</code>. In an underlapping buffer,
<code>buf$opt</code> is the difference between the total number of points to skip
between frames (<code>-p</code>) and the number of points in <code>x</code> that were
available to be skipped after filling the last frame:
</p>

<ul>
<li> <p>For <code>0 &lt; p &lt; n</code> (overlap), <code>buf$opt</code> contains the final
<code>p</code> samples in the last frame of the buffer. This vector can be used
as the initial condition for a subsequent buffering operation in a sequence
of consecutive buffering operations. This allows the desired frame overlap
to be maintained from one buffer to the next. See Continuous Buffering
below.
</p>
</li>
<li> <p>For <code>p &lt; 0</code> (underlap), <code>buf$opt</code> is the difference
between the total number of points to skip between frames <code>(-p)</code> and
the number of points in <code>x</code> that were available to be skipped after
filling the last frame: <code>buf$opt = m*(n-p) + opt - L</code> where <code>opt</code>
on the right is the input argument to buffer, and <code>buf$opt</code> on the
left is the output argument. Note that for an underlapping buffer output
<code>buf$opt</code> is always zero when output <code>buf$z</code> contains data.<br />
The opt output for an underlapping buffer is especially useful when the
current buffering operation is one in a sequence of consecutive buffering
operations. The <code>buf$opt</code> output from each buffering operation
specifies the number of samples that need to be skipped at the start of the
next buffering operation to maintain the desired frame underlap from one
buffer to the next. If fewer than <code>p</code> points were available to be
skipped after filling the final frame of the current buffer, the remaining
opt points need to be removed from the first frame of the next buffer.
</p>
</li></ul>

<p>In a sequence of buffering operations, the <code>buf$opt</code> output from each
operation should be used as the <code>opt</code> input to the subsequent buffering
operation. This ensures that the desired frame overlap or underlap is
maintained from buffer to buffer, as well as from frame to frame within the
same buffer. See Continuous Buffering below for an example of how this works
in practice.
<br />
</p>
<p><strong>Continuous Buffering</strong><br /><br />
In a continuous buffering operation, the vector input to the buffer function
represents one frame in a sequence of frames that make up a discrete signal.
These signal frames can originate in a frame-based data acquisition process,
or within a frame-based algorithm like the FFT.<br />
As an example, you might acquire data from an A/D card in frames of 64
samples. In the simplest case, you could rebuffer the data into frames of 16
samples; <code>buffer</code> with <code>n = 16</code> creates a buffer of four frames
from each 64-element input frame. The result is that the signal of frame size
64 has been converted to a signal of frame size 16; no samples were added or
removed.<br />
In the general case where the original signal frame size, <code>L</code>, is not
equally divisible by the new frame size, <code>n</code>, the overflow from the last
frame needs to be captured and recycled into the following buffer. You can do
this by iteratively calling buffer on input x with the <code>zopt</code> parameter
set to <code>TRUE</code>. This simply captures any buffer overflow in <code>buf$z</code>,
and prepends the data to the subsequent input in the next call to buffer.<br />
Note that continuous buffering cannot be done without the <code>zopt</code>
parameter being set to <code>TRUE</code>, because the last frame of y (<code>buf$y</code>
in this case) is zero padded, which adds new samples to the signal.<br />
Continuous buffering in the presence of overlap and underlap is handled with
the <code>opt</code> parameter, which is used as both an input (<code>opt</code> and
output (<code>buf$opt</code>) to buffer. The two examples on this page demonstrate
how the <code>opt</code> parameter should be used.
</p>


<h3>Value</h3>

<p>If <code>zopt</code> equals FALSE (the default), this function returns a
single numerical array containing the buffered data (<code>y</code>). If
<code>zopt</code> equals TRUE, then a <code>list</code> containing 3 variables is
returned: <code>y</code>: the buffered data, <code>z</code>: the over or underlap (if
any), <code>opt</code>: the over- or underlap that might be used for a future
call to <code>buffer</code> to allow continuous buffering.
</p>


<h3>Author(s)</h3>

<p>David Bateman, <a href="mailto:adb014@gmail.com">adb014@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples without continuous buffering
y &lt;- buffer(1:10, 5)
y &lt;- buffer(1:10, 4)
y &lt;- buffer(1:30, 7, 3)
y &lt;- buffer(1:30, 7, -3)
y &lt;- buffer(1:30, 7, 3, 'nodelay')

## Continuous buffering examples
# with overlap:
data &lt;- buffer(1:1100, 11)
n &lt;- 4
p &lt;- 1
buf &lt;- list(y = NULL, z = NULL, opt = -5)
for (i in 1:ncol(data)) {
  x &lt;- data[,i]
  buf &lt;- buffer(x = c(buf$z,x), n, p, opt=buf$opt, zopt = TRUE)
}
# with underlap:
data &lt;- buffer(1:1100, 11)
n &lt;- 4
p &lt;- -2
buf &lt;- list(y = NULL, z = NULL, opt = 1)
for (i in 1:ncol(data)) {
  x &lt;- data[,i]
  buf &lt;- buffer(x = c(buf$z,x), n, p, opt=buf$opt, zopt = TRUE)
}

</code></pre>

<hr>
<h2 id='buttap'>Butterworth filter prototype</h2><span id='topic+buttap'></span>

<h3>Description</h3>

<p>Return the poles and gain of an analog Butterworth lowpass filter prototype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buttap(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buttap_+3A_n">n</code></td>
<td>
<p>Order of the filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exists for compatibility with 'Matlab' and 'Octave' only, and
is equivalent to <code>butter(n, 1, "low", "s")</code>.
</p>


<h3>Value</h3>

<p>List of class <code><a href="#topic+Zpg">Zpg</a></code> containing poles and gain of the
filter.
</p>


<h3>Author(s)</h3>

<p>Carne Draug, <a href="mailto:carandraug+dev@gmail.com">carandraug+dev@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 9th order Butterworth low-pass analog filter
zp &lt;- buttap(9)
w &lt;- seq(0, 4, length.out = 128)
freqs(zp, w)

</code></pre>

<hr>
<h2 id='butter'>Butterworth filter design</h2><span id='topic+butter'></span><span id='topic+butter.FilterSpecs'></span><span id='topic+butter.default'></span>

<h3>Description</h3>

<p>Compute the transfer function coefficients of a Butterworth filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>butter(n, ...)

## S3 method for class 'FilterSpecs'
butter(n, ...)

## Default S3 method:
butter(
  n,
  w,
  type = c("low", "high", "stop", "pass"),
  plane = c("z", "s"),
  output = c("Arma", "Zpg", "Sos"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="butter_+3A_n">n</code></td>
<td>
<p>filter order.</p>
</td></tr>
<tr><td><code id="butter_+3A_...">...</code></td>
<td>
<p>additional arguments passed to butter, overriding those given by
<code>n</code> of class <code><a href="#topic+FilterSpecs">FilterSpecs</a></code>.</p>
</td></tr>
<tr><td><code id="butter_+3A_w">w</code></td>
<td>
<p>critical frequencies of the filter. <code>w</code> must be a scalar for
low-pass and high-pass filters, and <code>w</code> must be a two-element vector
c(low, high) specifying the lower and upper bands in radians/second. For
digital filters, w must be between 0 and 1 where 1 is the Nyquist
frequency.</p>
</td></tr>
<tr><td><code id="butter_+3A_type">type</code></td>
<td>
<p>filter type, one of <code>"low"</code>, (default) <code>"high"</code>,
<code>"stop"</code>, or <code>"pass"</code>.</p>
</td></tr>
<tr><td><code id="butter_+3A_plane">plane</code></td>
<td>
<p>&quot;z&quot; for a digital filter or &quot;s&quot; for an analog filter.</p>
</td></tr>
<tr><td><code id="butter_+3A_output">output</code></td>
<td>
<p>Type of output, one of:
</p>

<dl>
<dt>&quot;Arma&quot;</dt><dd><p>Autoregressive-Moving average (aka numerator/denominator, aka
b/a)</p>
</dd>
<dt>&quot;Zpg&quot;</dt><dd><p>Zero-pole-gain format</p>
</dd>
<dt>&quot;Sos&quot;</dt><dd><p>Second-order sections</p>
</dd>
</dl>

<p>Default is <code>"Arma"</code> for compatibility with the 'signal' package and the
'Matlab' and 'Octave' equivalents, but <code>"Sos"</code> should be preferred for
general-purpose filtering because of numeric stability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Butterworth filters have a magnitude response that is maximally flat in the
passband and monotonic overall. This smoothness comes at the price of
decreased rolloff steepness. Elliptic and Chebyshev filters generally provide
steeper rolloff for a given filter order.
</p>
<p>Because butter is generic, it can be extended to accept other inputs, using
<code>buttord</code> to generate filter criteria for example.
</p>


<h3>Value</h3>

<p>Depending on the value of the <code>output</code> parameter, a list of
class <code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+Zpg">Zpg</a></code>, or <code><a href="#topic+Sos">Sos</a></code>
containing the filter coefficients
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Doug Stewart, <a href="mailto:dastew@sympatico.ca">dastew@sympatico.ca</a>,<br />
Alexander Klein, <a href="mailto:alexander.klein@math.uni-giessen.de">alexander.klein@math.uni-giessen.de</a>,<br />
John W. Eaton.<br />
Conversion to R by Tom Short,<br />
adapted by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Butterworth_filter">https://en.wikipedia.org/wiki/Butterworth_filter</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+Zpg">Zpg</a></code>, <code><a href="#topic+Sos">Sos</a></code>,
<code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+cheby1">cheby1</a></code>, <code><a href="#topic+ellip">ellip</a></code>,
<code><a href="#topic+buttord">buttord</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 50 Hz notch filter
fs &lt;- 256
bf &lt;- butter(4, c(48, 52) / (fs / 2), "stop")
freqz(bf, fs = fs)

## EEG alpha rhythm (8 - 12 Hz) bandpass filter
fs &lt;- 128
fpass &lt;- c(8, 12)
wpass &lt;- fpass / (fs / 2)
but &lt;- butter(5, wpass, "pass")
freqz(but, fs = fs)

## filter to remove vocals from songs, 25 dB attenuation in stop band
## (not optimal with a Butterworth filter)
fs &lt;- 44100
specs &lt;- buttord(230/(fs/2), 450/(fs/2), 1, 25)
bf &lt;- butter(specs)
freqz(bf, fs = fs)
zplane(bf)

</code></pre>

<hr>
<h2 id='buttord'>Butterworth filter order and cutoff frequency</h2><span id='topic+buttord'></span>

<h3>Description</h3>

<p>Compute the minimum filter order of a Butterworth filter with the desired
response characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buttord(Wp, Ws, Rp, Rs, plane = c("z", "s"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buttord_+3A_wp">Wp</code>, <code id="buttord_+3A_ws">Ws</code></td>
<td>
<p>pass-band and stop-band edges. For a low-pass or high-pass
filter, <code>Wp</code> and <code>Ws</code> are scalars. For a band-pass or
band-rejection filter, both are vectors of length 2. For a low-pass filter,
<code>Wp &lt; Ws</code>. For a high-pass filter, <code>Ws &gt; Wp</code>. For a band-pass
<code>(Ws[1] &lt; Wp[1] &lt; Wp[2] &lt; Ws[2])</code> or band-reject <code>(Wp[1] &lt; Ws[1]
&lt; Ws[2] &lt; Wp[2])</code> filter design, <code>Wp</code> gives the edges of the pass
band, and <code>Ws</code> gives the edges of the stop band. For digital filters,
frequencies are normalized to [0, 1], corresponding to the range [0, fs/2].
In case of an analog filter, all frequencies are specified in radians per
second.</p>
</td></tr>
<tr><td><code id="buttord_+3A_rp">Rp</code></td>
<td>
<p>allowable decibels of ripple in the pass band.</p>
</td></tr>
<tr><td><code id="buttord_+3A_rs">Rs</code></td>
<td>
<p>minimum attenuation in the stop band in dB.</p>
</td></tr>
<tr><td><code id="buttord_+3A_plane">plane</code></td>
<td>
<p>&quot;z&quot; for a digital filter or &quot;s&quot; for an analog filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deriving the order and cutoff is based on:

</p>
<pre>
       2                  (2N)       (-R / 10)
 |H(W)|  = 1/[1 + (W / Wc)    ] = 10

</pre>
<p>With some algebra, you can solve simultaneously for <code>Wc</code> and <code>N</code>
given <code>Ws</code>, <code>Rs</code> and Wp,Rp. Rounding N to the next greater integer,
one can recalculate the allowable range for <code>Wc</code> (filter characteristic
touching the pass band edge or the stop band edge).
</p>
<p>For other types of filter, before making the above calculation, the
requirements must be transformed to lowpass requirements. After the
calculation, <code>Wc</code> must be transformed back to the original filter type.
</p>


<h3>Value</h3>

<p>A list of class <code><a href="#topic+FilterSpecs">FilterSpecs</a></code> with the following list
elements:
</p>

<dl>
<dt>n</dt><dd><p>filter order</p>
</dd>
<dt>Wc</dt><dd><p>cutoff frequency</p>
</dd>
<dt>type</dt><dd><p>filter type, normally one of &quot;low&quot;, &quot;high&quot;, &quot;stop&quot;, or &quot;pass&quot;.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Paul Kienzle,<br />
adapted by Charles Praplan.<br />
Conversion to R by Tom Short,<br />
adapted by Geert van Boxtel,  <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+butter">butter</a></code>, <code><a href="#topic+FilterSpecs">FilterSpecs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## low-pass 30 Hz filter
fs &lt;- 128
butspec &lt;- buttord(30/(fs/2), 40/(fs/2), 0.5, 40)
but &lt;- butter(butspec)
freqz(but, fs = fs)

</code></pre>

<hr>
<h2 id='cceps'>Complex cepstral analysis</h2><span id='topic+cceps'></span>

<h3>Description</h3>

<p>Return the complex cepstrum of the input vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cceps(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cceps_+3A_x">x</code></td>
<td>
<p>input data, specified as a real vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cepstral analysis is a nonlinear signal processing technique that is applied
most commonly in speech and image processing, or as a tool to investigate
periodic structures within frequency spectra, for instance resulting from
echos/reflections in the signal or to the occurrence of harmonic frequencies
(partials, overtones).
</p>
<p>The cepstrum is used in many variants. Most important are the power cepstrum,
the complex cepstrum, and real cepstrum. The function <code>cceps</code> implements
the complex cepstrum by computing the inverse of the log-transformed FFT,
i.e.,
</p>
<p style="text-align: center;"><code class="reqn">cceps(x) &lt;- ifft(log(fft(x)))</code>
</p>

<p>However, because taking the logarithm of a complex number can lead to
unexpected results, the phase of <code>fft(x)</code> needs to be unwrapped before
taking the log.
</p>


<h3>Value</h3>

<p>Complex cepstrum, returned as a vector.
</p>


<h3>Note</h3>

<p>This function returns slightly different results in comparison with the
'Matlab' and 'Octave' equivalents. The 'Octave' version does not apply phase
unwrapping, but has an optional correction procedure in case of zero phase
at <code class="reqn">\pi</code> radians. The present implementation does apply phase
unwrapping so that the correction procedure is unnecessary. The 'Matlab'
implementation also applies phase unwrapping, and a circular shift if
necessary to avoid zero phase at <code class="reqn">\pi</code> radians. The circular shift is
not done here. In addition, the 'Octave' version shifts the zero frequency to
the center of the series, which neither the 'Matlab' nor the present
implementation do.
</p>


<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Cepstrum">https://en.wikipedia.org/wiki/Cepstrum</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rceps">rceps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a sine of frequency 45 Hz, sampled at 100 Hz.
fs &lt;- 100
t &lt;- seq(0, 1.27, 1/fs)
s1 &lt;- sin(2 * pi * 45 * t)
## Add an echo with half the amplitude and 0.2 s later.
s2 &lt;- s1 + 0.5 * c(rep(0L, 20), s1[1:108])
## Compute the complex cepstrum of the signal. Notice the echo at 0.2 s.
cep &lt;- cceps(s2)
plot(t, cep, type="l")

</code></pre>

<hr>
<h2 id='cconv'>Circular convolution</h2><span id='topic+cconv'></span>

<h3>Description</h3>

<p>Compute the modulo-n circular convolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cconv(a, b, n = length(a) + length(b) - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cconv_+3A_a">a</code>, <code id="cconv_+3A_b">b</code></td>
<td>
<p>Input, coerced to vectors, can be different lengths or data types.</p>
</td></tr>
<tr><td><code id="cconv_+3A_n">n</code></td>
<td>
<p>Convolution length, specified as a positive integer. Default:
<code>length(a) + length(b) - 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Linear and circular convolution are fundamentally different operations.
Linear convolution of an n-point vector x, and an l-point vector y, has
length n + l - 1, and can be computed by the function <code><a href="#topic+conv">conv</a></code>,
which uses <code><a href="#topic+filter">filter</a></code>. The circular convolution, by contrast, is
equal to the inverse discrete Fourier transform (DFT) of the product of the
vectors' DFTs.
</p>
<p>For the circular convolution of <code>x</code> and <code>y</code> to be equivalent to
their linear convolution, the vectors must be padded with zeros to length at
least <code>n + l - 1</code> before taking the DFT. After inverting the product of
the DFTs, only the first <code>n + l - 1</code> elements should be retained.
</p>
<p>For long sequences circular convolution may be more efficient than linear
convolution. You can also use <code>cconv</code> to compute the circular
cross-correlation of two sequences.
</p>


<h3>Value</h3>

<p>Circular convolution of input vectors, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Leonardo Araujo.<br /> Conversion to R by Geert van Boxtel,
<a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conv">conv</a></code>, <code><a href="stats.html#topic+convolve">convolve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(1, 2, -1, 1)
b &lt;- c(1, 1, 2, 1, 2, 2, 1, 1)
c &lt;- cconv(a, b)       # Circular convolution
cref = conv(a, b)      # Linear convolution
all.equal(max(c - cref), 0)

cconv(a, b, 6)

</code></pre>

<hr>
<h2 id='cheb'>Chebyshev polynomials</h2><span id='topic+cheb'></span>

<h3>Description</h3>

<p>Return the value of the Chebyshev polynomial at specific points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cheb(n, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cheb_+3A_n">n</code></td>
<td>
<p>Order of the polynomial, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="cheb_+3A_x">x</code></td>
<td>
<p>Point or points at which to calculate the Chebyshev polynomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Chebyshev polynomials are defined by the equations:

</p>
<pre>
  Tn(x) = cos(n . acos(x),    |x|&lt;= 1
  Tn(x) = cosh(n . acosh(x),  |x|&gt; 1
</pre>
<p>If <code>x</code> is a vector, the output is a vector of the same size, where each
element is calculated as <code class="reqn">y(i) = Tn(x(i))</code>.
</p>


<h3>Value</h3>

<p>Polynomial of order <code>x</code>, evaluated at point(s) <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>André Carezia, <a href="mailto:acarezia@uol.com.br">acarezia@uol.com.br</a>.<br /> Conversion to R by
Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cp &lt;- cheb(5, 1)
cp &lt;- cheb(5, c(2,3))

</code></pre>

<hr>
<h2 id='cheb1ap'>Chebyshev Type I filter prototype</h2><span id='topic+cheb1ap'></span>

<h3>Description</h3>

<p>Return the poles and gain of an analog Chebyshev Type I lowpass filter
prototype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cheb1ap(n, Rp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cheb1ap_+3A_n">n</code></td>
<td>
<p>Order of the filter.</p>
</td></tr>
<tr><td><code id="cheb1ap_+3A_rp">Rp</code></td>
<td>
<p>dB of pass-band ripple.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exists for compatibility with 'Matlab' and 'OCtave' only, and
is equivalent to <code>cheby1(n, Rp, 1, "low", "s")</code>.
</p>


<h3>Value</h3>

<p>List of class <code><a href="#topic+Zpg">Zpg</a></code> containing the poles and gain of the
filter.
</p>


<h3>Author(s)</h3>

<p>Carne Draug, <a href="mailto:carandraug+dev@gmail.com">carandraug+dev@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 9th order Chebyshev type I low-pass analog filter
zp &lt;- cheb1ap(9, .1)
w &lt;- seq(0, 4, length.out = 128)
freqs(zp, w)

</code></pre>

<hr>
<h2 id='cheb1ord'>Chebyshev Type I filter order</h2><span id='topic+cheb1ord'></span>

<h3>Description</h3>

<p>Compute Chebyshev type-I filter order and cutoff for the desired
response characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cheb1ord(Wp, Ws, Rp, Rs, plane = c("z", "s"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cheb1ord_+3A_wp">Wp</code>, <code id="cheb1ord_+3A_ws">Ws</code></td>
<td>
<p>pass-band and stop-band edges. For a low-pass or high-pass
filter, <code>Wp</code> and <code>Ws</code> are scalars. For a band-pass or
band-rejection filter, both are vectors of length 2. For a low-pass filter,
<code>Wp &lt; Ws</code>. For a high-pass filter, <code>Ws &gt; Wp</code>. For a band-pass
<code>(Ws[1] &lt; Wp[1] &lt; Wp[2] &lt; Ws[2])</code> or band-reject <code>(Wp[1] &lt; Ws[1]
&lt; Ws[2] &lt; Wp[2])</code> filter design, <code>Wp</code> gives the edges of the pass
band, and <code>Ws</code> gives the edges of the stop band. For digital filters,
frequencies are normalized to [0, 1], corresponding to the range [0, fs/2].
In case of an analog filter, all frequencies are specified in radians per
second.</p>
</td></tr>
<tr><td><code id="cheb1ord_+3A_rp">Rp</code></td>
<td>
<p>allowable decibels of ripple in the pass band.</p>
</td></tr>
<tr><td><code id="cheb1ord_+3A_rs">Rs</code></td>
<td>
<p>minimum attenuation in the stop band in dB.</p>
</td></tr>
<tr><td><code id="cheb1ord_+3A_plane">plane</code></td>
<td>
<p>&quot;z&quot; for a digital filter or &quot;s&quot; for an analog filter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>'FilterSpecs'</code> with the following list
elements:
</p>

<dl>
<dt>n</dt><dd><p>filter order</p>
</dd>
<dt>Wc</dt><dd><p>cutoff frequency</p>
</dd>
<dt>type</dt><dd><p>filter type, normally one of <code>"low"</code>, <code>"high"</code>,
<code>"stop"</code>, or <code>"pass"</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Paul Kienzle, Laurent S. Mazet, Charles Praplan.<br />
Conversion to R by Tom Short, adapted by Geert van Boxtel,
<a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cheby1">cheby1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## low-pass 30 Hz filter
fs &lt;- 128
spec &lt;- cheb1ord(30/(fs/2), 40/(fs/2), 0.5, 40)
cf &lt;- cheby1(spec)
freqz(cf, fs = fs)

</code></pre>

<hr>
<h2 id='cheb2ap'>Chebyshev Type II filter prototype</h2><span id='topic+cheb2ap'></span>

<h3>Description</h3>

<p>Return the poles and gain of an analog Chebyshev Type II lowpass filter
prototype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cheb2ap(n, Rs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cheb2ap_+3A_n">n</code></td>
<td>
<p>Order of the filter.</p>
</td></tr>
<tr><td><code id="cheb2ap_+3A_rs">Rs</code></td>
<td>
<p>dB of stop-band ripple.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exists for compatibility with 'Matlab' and 'Octave' only, and
is equivalent to <code>cheby2(n, Rp, 1, "low", "s")</code>.
</p>


<h3>Value</h3>

<p>list of class <code><a href="#topic+Zpg">Zpg</a></code> containing poles and gain of the
filter
</p>


<h3>Author(s)</h3>

<p>Carne Draug, <a href="mailto:carandraug+dev@gmail.com">carandraug+dev@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 9th order Chebyshev type II low-pass analog filter
zp &lt;- cheb2ap(9, 30)
w &lt;- seq(0, 4, length.out = 128)
freqs(zp, w)

</code></pre>

<hr>
<h2 id='cheb2ord'>Chebyshev Type II filter order</h2><span id='topic+cheb2ord'></span>

<h3>Description</h3>

<p>Compute Chebyshev type-II filter order and cutoff for the desired
response characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cheb2ord(Wp, Ws, Rp, Rs, plane = c("z", "s"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cheb2ord_+3A_wp">Wp</code>, <code id="cheb2ord_+3A_ws">Ws</code></td>
<td>
<p>pass-band and stop-band edges. For a low-pass or high-pass
filter, <code>Wp</code> and <code>Ws</code> are scalars. For a band-pass or
band-rejection filter, both are vectors of length 2. For a low-pass filter,
<code>Wp &lt; Ws</code>. For a high-pass filter, <code>Ws &gt; Wp</code>. For a band-pass
<code>(Ws[1] &lt; Wp[1] &lt; Wp[2] &lt; Ws[2])</code> or band-reject <code>(Wp[1] &lt; Ws[1]
&lt; Ws[2] &lt; Wp[2])</code> filter design, <code>Wp</code> gives the edges of the pass
band, and <code>Ws</code> gives the edges of the stop band. For digital filters,
frequencies are normalized to [0, 1], corresponding to the range [0, fs /
2]. In case of an analog filter, all frequencies are specified in radians
per second.</p>
</td></tr>
<tr><td><code id="cheb2ord_+3A_rp">Rp</code></td>
<td>
<p>allowable decibels of ripple in the pass band.</p>
</td></tr>
<tr><td><code id="cheb2ord_+3A_rs">Rs</code></td>
<td>
<p>minimum attenuation in the stop band in dB.</p>
</td></tr>
<tr><td><code id="cheb2ord_+3A_plane">plane</code></td>
<td>
<p>&quot;z&quot; for a digital filter or &quot;s&quot; for an analog filter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>'FilterSpecs'</code> with the following list
elements:
</p>

<dl>
<dt>n</dt><dd><p>filter order</p>
</dd>
<dt>Wc</dt><dd><p>cutoff frequency</p>
</dd>
<dt>type</dt><dd><p>filter type, normally one of <code>"low"</code>, <code>"high"</code>,
<code>"stop"</code>, or <code>"pass"</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Paul Kienzle, Charles Praplan.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cheby1">cheby1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## low-pass 30 Hz filter
fs &lt;- 128
spec &lt;- cheb2ord(30/(fs/2), 40/(fs/2), 0.5, 40)
cf &lt;- cheby2(spec)
freqz(cf, fs = fs)

</code></pre>

<hr>
<h2 id='chebwin'>Chebyshev window</h2><span id='topic+chebwin'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a Dolph-Chebyshev window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chebwin(n, at = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chebwin_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="chebwin_+3A_at">at</code></td>
<td>
<p>Stop-band attenuation in dB. Default: 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The window is described in frequency domain by the expression:

</p>
<pre>
                Cheb(m - 1, Beta * cos(\pi * k / m))
         W(k) = ------------------------------------
                       Cheb(m - 1, Beta)
</pre>
<p>with

</p>
<pre>
  Beta = cosh(1 / (m - 1) * acosh(10^(at / 20))
</pre>
<p>and and <code class="reqn">Cheb(m, x)</code> denoting the <code class="reqn">m</code>-th order Chebyshev polynomial
calculated at the point <code class="reqn">x</code>.
</p>
<p>Note that the denominator in W(k) above is not computed, and after the
inverse Fourier transform the window is scaled by making its maximum value
unitary.
</p>


<h3>Value</h3>

<p>Chebyshev window, returned as a vector. If you specify a one-point
window <code>(n = 1)</code>, the value 1 is returned.
</p>


<h3>Author(s)</h3>

<p>André Carezia, <a href="mailto:acarezia@uol.com.br">acarezia@uol.com.br</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cw &lt;- chebwin(64)
plot (cw, type = "l", xlab = "Samples", ylab =" Amplitude")


</code></pre>

<hr>
<h2 id='cheby1'>Chebyshev Type I filter design</h2><span id='topic+cheby1'></span><span id='topic+cheby1.FilterSpecs'></span><span id='topic+cheby1.default'></span>

<h3>Description</h3>

<p>Compute the transfer function coefficients of a Chebyshev Type I filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cheby1(n, ...)

## S3 method for class 'FilterSpecs'
cheby1(n, ...)

## Default S3 method:
cheby1(
  n,
  Rp,
  w,
  type = c("low", "high", "stop", "pass"),
  plane = c("z", "s"),
  output = c("Arma", "Zpg", "Sos"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cheby1_+3A_n">n</code></td>
<td>
<p>filter order.</p>
</td></tr>
<tr><td><code id="cheby1_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>cheby1</code>, overriding those
given by <code>n</code> of class <code><a href="#topic+FilterSpecs">FilterSpecs</a></code>.</p>
</td></tr>
<tr><td><code id="cheby1_+3A_rp">Rp</code></td>
<td>
<p>dB of passband ripple.</p>
</td></tr>
<tr><td><code id="cheby1_+3A_w">w</code></td>
<td>
<p>critical frequencies of the filter. <code>w</code> must be a scalar for
low-pass and high-pass filters, and <code>w</code> must be a two-element vector
c(low, high) specifying the lower and upper bands in radians/second. For
digital filters, W must be between 0 and 1 where 1 is the Nyquist
frequency.</p>
</td></tr>
<tr><td><code id="cheby1_+3A_type">type</code></td>
<td>
<p>filter type, one of <code>"low"</code>, <code>"high"</code>, <code>"stop"</code>,
or <code>"pass"</code>.</p>
</td></tr>
<tr><td><code id="cheby1_+3A_plane">plane</code></td>
<td>
<p>&quot;z&quot; for a digital filter or &quot;s&quot; for an analog filter.</p>
</td></tr>
<tr><td><code id="cheby1_+3A_output">output</code></td>
<td>
<p>Type of output, one of:
</p>

<dl>
<dt>&quot;Arma&quot;</dt><dd><p>Autoregressive-Moving average (aka numerator/denominator, aka
b/a)</p>
</dd>
<dt>&quot;Zpg&quot;</dt><dd><p>Zero-pole-gain format</p>
</dd>
<dt>&quot;Sos&quot;</dt><dd><p>Second-order sections</p>
</dd>
</dl>

<p>Default is <code>"Arma"</code> for compatibility with the 'signal' package and the
'Matlab' and 'Octave' equivalents, but <code>"Sos"</code> should be preferred for
general-purpose filtering because of numeric stability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chebyshev filters are analog or digital filters having a steeper roll-off
than Butterworth filters, and have passband ripple (type I) or stopband
ripple (type II).
</p>
<p>Because <code>cheby1</code> is generic, it can be extended to accept other inputs,
using <code>cheb1ord</code> to generate filter criteria for example.
</p>


<h3>Value</h3>

<p>Depending on the value of the <code>output</code> parameter, a list of
class <code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+Zpg">Zpg</a></code>, or <code><a href="#topic+Sos">Sos</a></code>
containing the filter coefficients
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Doug Stewart, <a href="mailto:dastew@sympatico.ca">dastew@sympatico.ca</a>.<br />
Conversion to R Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Chebyshev_filter">https://en.wikipedia.org/wiki/Chebyshev_filter</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+butter">butter</a></code>,
<code><a href="#topic+ellip">ellip</a></code>, <code><a href="#topic+cheb1ord">cheb1ord</a></code>, <code><a href="#topic+FilterSpecs">FilterSpecs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## compare the frequency responses of 5th-order
## Butterworth and Chebyshev filters.
bf &lt;- butter(5, 0.1)
cf &lt;- cheby1(5, 3, 0.1)
bfr &lt;- freqz(bf)
cfr &lt;- freqz(cf)
plot(bfr$w / pi, 20 * log10(abs(bfr$h)), type = "l", ylim = c(-40, 0),
  xlim = c(0, .5), xlab = "Frequency", ylab = c("dB"))
lines(cfr$w / pi, 20 * log10(abs(cfr$h)), col = "red")

# compare type I and type II Chebyshev filters.
c1fr &lt;- freqz(cheby1(5, .5, 0.5))
c2fr &lt;- freqz(cheby2(5, 20, 0.5))
plot(c1fr$w / pi, abs(c1fr$h), type = "l", ylim = c(0, 1),
  xlab = "Frequency", ylab = c("Magnitude"))
  lines(c2fr$w / pi, abs(c2fr$h), col = "red")

</code></pre>

<hr>
<h2 id='cheby2'>Chebyshev Type II filter design</h2><span id='topic+cheby2'></span><span id='topic+cheby2.FilterSpecs'></span><span id='topic+cheby2.default'></span>

<h3>Description</h3>

<p>Compute the transfer function coefficients of a Chebyshev Type II filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cheby2(n, ...)

## S3 method for class 'FilterSpecs'
cheby2(n, ...)

## Default S3 method:
cheby2(
  n,
  Rs,
  w,
  type = c("low", "high", "stop", "pass"),
  plane = c("z", "s"),
  output = c("Arma", "Zpg", "Sos"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cheby2_+3A_n">n</code></td>
<td>
<p>filter order.</p>
</td></tr>
<tr><td><code id="cheby2_+3A_...">...</code></td>
<td>
<p>additional arguments passed to cheby1, overriding those given by
<code>n</code> of class <code>FilterSpecs</code>.</p>
</td></tr>
<tr><td><code id="cheby2_+3A_rs">Rs</code></td>
<td>
<p>dB of stopband ripple.</p>
</td></tr>
<tr><td><code id="cheby2_+3A_w">w</code></td>
<td>
<p>critical frequencies of the filter. <code>w</code> must be a scalar for
low-pass and high-pass filters, and <code>w</code> must be a two-element vector
c(low, high) specifying the lower and upper bands in radians/second. For
digital filters, W must be between 0 and 1 where 1 is the Nyquist
frequency.</p>
</td></tr>
<tr><td><code id="cheby2_+3A_type">type</code></td>
<td>
<p>filter type, one of <code>"low"</code>, <code>"high"</code>, <code>"stop"</code>,
or <code>"pass"</code>.</p>
</td></tr>
<tr><td><code id="cheby2_+3A_plane">plane</code></td>
<td>
<p>&quot;z&quot; for a digital filter or &quot;s&quot; for an analog filter.</p>
</td></tr>
<tr><td><code id="cheby2_+3A_output">output</code></td>
<td>
<p>Type of output, one of:
</p>

<dl>
<dt>&quot;Arma&quot;</dt><dd><p>Autoregressive-Moving average (aka numerator/denominator, aka
b/a)</p>
</dd>
<dt>&quot;Zpg&quot;</dt><dd><p>Zero-pole-gain format</p>
</dd>
<dt>&quot;Sos&quot;</dt><dd><p>Second-order sections</p>
</dd>
</dl>

<p>Default is <code>"Arma"</code> compatibility with the 'signal' package and the
'Matlab' and 'Octave' equivalents, but <code>"Sos"</code> should be preferred for
general-purpose filtering because of numeric stability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chebyshev filters are analog or digital filters having a steeper roll-off
than Butterworth filters, and have passband ripple (type I) or stopband
ripple (type II).
</p>
<p>Because <code>cheby2</code> is generic, it can be extended to accept other inputs,
using <code>cheb2ord</code> to generate filter criteria for example.
</p>


<h3>Value</h3>

<p>Depending on the value of the <code>output</code> parameter, a list of
class <code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+Zpg">Zpg</a></code>, or <code><a href="#topic+Sos">Sos</a></code>
containing the filter coefficients
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Doug Stewart, <a href="mailto:dastew@sympatico.ca">dastew@sympatico.ca</a>.<br />
Conversion to R Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Chebyshev_filter">https://en.wikipedia.org/wiki/Chebyshev_filter</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+butter">butter</a></code>,
<code><a href="#topic+ellip">ellip</a></code>, <code><a href="#topic+cheb2ord">cheb2ord</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## compare the frequency responses of 5th-order
## Butterworth and Chebyshev filters.
bf &lt;- butter(5, 0.1)
cf &lt;- cheby2(5, 20, 0.1)
bfr &lt;- freqz(bf)
cfr &lt;- freqz(cf)
plot(bfr$w / pi, 20 * log10(abs(bfr$h)), type = "l", ylim = c(-40, 0),
  xlim = c(0, .5), xlab = "Frequency", ylab = c("dB"))
lines(cfr$w / pi, 20 * log10(abs(cfr$h)), col = "red")

# compare type I and type II Chebyshev filters.
c1fr &lt;- freqz(cheby1(5, .5, 0.5))
c2fr &lt;- freqz(cheby2(5, 20, 0.5))
plot(c1fr$w / pi, abs(c1fr$h), type = "l", ylim = c(0, 1.1),
  xlab = "Frequency", ylab = c("Magnitude"))
lines(c2fr$w / pi, abs(c2fr$h), col = "red")

</code></pre>

<hr>
<h2 id='chirp'>Chirp signal</h2><span id='topic+chirp'></span>

<h3>Description</h3>

<p>Evaluate a chirp signal (frequency swept cosine wave).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chirp(
  t,
  f0,
  t1 = 1,
  f1 = 100,
  shape = c("linear", "quadratic", "logarithmic"),
  phase = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chirp_+3A_t">t</code></td>
<td>
<p>Time array, specified as a vector.</p>
</td></tr>
<tr><td><code id="chirp_+3A_f0">f0</code></td>
<td>
<p>Initial instantaneous frequency at time 0, specified as a positive
scalar expressed in Hz. Default: 0 Hz for linear and quadratic shapes; 1e-6
for logarithmic shape.</p>
</td></tr>
<tr><td><code id="chirp_+3A_t1">t1</code></td>
<td>
<p>Reference time, specified as a positive scalar expressed in
seconds. Default: 1 sec.</p>
</td></tr>
<tr><td><code id="chirp_+3A_f1">f1</code></td>
<td>
<p>Instantaneous frequency at time t1, specified as a positive scalar
expressed in Hz. Default: 100 Hz.</p>
</td></tr>
<tr><td><code id="chirp_+3A_shape">shape</code></td>
<td>
<p>Sweep method, specified as <code>"linear"</code>, <code>"quadratic"</code>,
or <code>"logarithmic"</code> (see Details). Default: <code>"linear"</code>.</p>
</td></tr>
<tr><td><code id="chirp_+3A_phase">phase</code></td>
<td>
<p>Initial phase, specified as a positive scalar expressed in
degrees. Default: 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A chirp is a signal in which the frequency changes with time, commonly used
in sonar, radar, and laser. The name is a reference to the chirping sound
made by birds.
</p>
<p>The chirp can have one of three shapes:
</p>

<dl>
<dt>&quot;linear&quot;</dt><dd><p>Specifies an instantaneous frequency sweep <code class="reqn">f_i(t)</code>
given by <code class="reqn">f_i(t) = f_0 + \beta t</code>, where <code class="reqn">\beta = (f_1 - f_0) /
  t_1</code> and the default value for <code class="reqn">f_0</code> is 0. The coefficient <code class="reqn">\beta</code>
ensures that the desired frequency breakpoint <code class="reqn">f_1</code> at time <code class="reqn">t_1</code>
is maintained.</p>
</dd>
<dt>&quot;quadratic&quot;</dt><dd><p>Specifies an instantaneous frequency sweep <code class="reqn">f_i(t)</code>
given by <code class="reqn">f_i(t) = f_0 + \beta t^2</code>, where <code class="reqn">\beta = (f_1 - f_0) /
  t_1^2</code> and the default value for <code class="reqn">f_0</code> is 0. If <code class="reqn">f_0 &gt; f_1</code>
(downsweep), the default shape is convex. If <code class="reqn">f_0 &lt; f_1</code> (upsweep), the
default shape is concave.</p>
</dd>
<dt>&quot;logarithmic&quot;</dt><dd><p>Specifies an instantaneous frequency sweep
<code class="reqn">f_i(t)</code> given by <code class="reqn">f_i(t) = f_0 \times \beta t</code>, where <code class="reqn">\beta =
  \left( \frac {f_1}{f_0} \right) ^ \frac{1}{t1}</code> and the default value for
<code class="reqn">f_0</code> is <code class="reqn">10^{-6}</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Chirp signal, returned as an array of the same length as <code>t</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Mike Miller.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Shows linear sweep of 100 Hz/sec starting at zero for 5 sec
# since the sample rate is 1000 Hz, this should be a diagonal
# from bottom left to top right.
t &lt;- seq(0, 5, 0.001)
y &lt;- chirp (t)
specgram (y, 256, 1000)

# Shows a quadratic chirp of 400 Hz at t=0 and 100 Hz at t=10
# Time goes from -2 to 15 seconds.
specgram(chirp(seq(-2, 15, by = 0.001), 400, 10, 100, "quadratic"))

# Shows a logarithmic chirp of 200 Hz at t = 0 and 500 Hz at t = 2
# Time goes from 0 to 5 seconds at 8000 Hz.
specgram(chirp(seq(0, 5, by = 1/8000), 200, 2, 500, "logarithmic"),
         fs = 8000)

</code></pre>

<hr>
<h2 id='cl2bp'>Constrained L2 bandpass FIR filter design</h2><span id='topic+cl2bp'></span>

<h3>Description</h3>

<p>Constrained least square band-pass FIR filter design without specified
transition bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl2bp(m = 30, w1, w2, up, lo, L = 2048)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl2bp_+3A_m">m</code></td>
<td>
<p>degree of cosine polynomial, resulting in a filter of length
<code>2 * m + 1</code>. Must be an even number. Default: 30.</p>
</td></tr>
<tr><td><code id="cl2bp_+3A_w1">w1</code>, <code id="cl2bp_+3A_w2">w2</code></td>
<td>
<p>bandpass filter cutoffs in the range <code>0 &lt;= w1 &lt; w2 &lt;= pi</code>,
where pi is the Nyquist frequency.</p>
</td></tr>
<tr><td><code id="cl2bp_+3A_up">up</code></td>
<td>
<p>vector of 3 upper bounds for c(stopband1, passband, stopband2).</p>
</td></tr>
<tr><td><code id="cl2bp_+3A_lo">lo</code></td>
<td>
<p>vector of 3 lower bounds for c(stopband1, passband, stopband2).</p>
</td></tr>
<tr><td><code id="cl2bp_+3A_l">L</code></td>
<td>
<p>search grid size; larger values may improve accuracy, but greatly
increase calculation time. Default: 2048, maximum: 1e6.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a fast implementation of the algorithm cited below. Compared to
<code>remez</code>, it offers implicit specification of transition bands, a higher
likelihood of convergence, and an error criterion combining features of both
L2 and Chebyshev approaches
</p>


<h3>Value</h3>

<p>The FIR filter coefficients, a vector of length <code>2 * m + 1</code>, of
class <code>Ma</code>.
</p>


<h3>Author(s)</h3>

<p>Ivan Selesnick, Rice University, 1995,
downloaded from <a href="https://www.ece.rice.edu/dsp/software/cl2.shtml">https://www.ece.rice.edu/dsp/software/cl2.shtml</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>Selesnick, I.W., Lang, M., and Burrus, C.S. (1998) A modified
algorithm for constrained least square design of multiband FIR filters
without specified transition bands. IEEE Trans. on Signal Processing,
46(2), 497-501. <br />
<a href="https://www.ece.rice.edu/dsp/software/cl2.shtml">https://www.ece.rice.edu/dsp/software/cl2.shtml</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ma">Ma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+remez">remez</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w1 &lt;- 0.3 * pi
w2 &lt;- 0.6 * pi
up &lt;- c(0.02, 1.02, 0.02)
lo &lt;- c(-0.02, 0.98, -0.02)
h  &lt;- cl2bp(30, w1, w2, up, lo, 2^11)
freqz(h)

</code></pre>

<hr>
<h2 id='clustersegment'>Cluster Segments</h2><span id='topic+clustersegment'></span>

<h3>Description</h3>

<p>Calculate boundary indexes of clusters of 1’s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustersegment(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustersegment_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix, coerced to
contain only 0's and 1's, i.e., every nonzero element in <code>x</code> will
be replaced by 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the initial index and end index of sequences of 1s
rising and falling phases of the signal in <code>x</code>. The clusters are sought
in the rows of the array <code>x</code>. The function works by finding the indexes
of jumps between consecutive values in the rows of <code>x</code>.
</p>


<h3>Value</h3>

<p>A list of size <code>nr</code>, where <code>nr</code> is the number
of rows in <code>x</code>. Each element of the list contains a matrix with two
rows. The first row is the initial index of a sequence of 1’s and the
second row is the end index of that sequence.
</p>


<h3>Author(s)</h3>

<p>Juan Pablo Carbajal, <a href="mailto:carbajal@ifi.uzh.ch">carbajal@ifi.uzh.ch</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- c(0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1))
(ranges &lt;- clustersegment(x))
# The first sequence of 1's in x lies in the interval
(r &lt;- ranges[1,1]:ranges[2,1])

x &lt;- matrix(as.numeric(runif(30) &gt; 0.4), 3, 10)
ranges &lt;- clustersegment(x)

x &lt;- c(0, 1.2, 3, -8, 0)
ranges &lt;- clustersegment(x)

</code></pre>

<hr>
<h2 id='cmorwavf'>Complex Morlet Wavelet</h2><span id='topic+cmorwavf'></span>

<h3>Description</h3>

<p>Compute the complex Morlet wavelet on a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmorwavf(lb = -8, ub = 8, n = 1000, fb = 5, fc = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmorwavf_+3A_lb">lb</code>, <code id="cmorwavf_+3A_ub">ub</code></td>
<td>
<p>Lower and upper bounds of the interval to evaluate the complex
Morlet waveform on. Default: -8 to 8.</p>
</td></tr>
<tr><td><code id="cmorwavf_+3A_n">n</code></td>
<td>
<p>Number of points on the grid between <code>lb</code> and <code>ub</code> (length
of the wavelet). Default: 1000.</p>
</td></tr>
<tr><td><code id="cmorwavf_+3A_fb">fb</code></td>
<td>
<p>Time-decay parameter of the wavelet (bandwidth in the frequency
domain). Must be a positive scalar. Default: 5.</p>
</td></tr>
<tr><td><code id="cmorwavf_+3A_fc">fc</code></td>
<td>
<p>Center frequency of the wavelet. Must be a positive scalar.
Default: 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Morlet (or Gabor) wavelet is a wavelet composed of a complex exponential
(carrier) multiplied by a Gaussian window (envelope). The wavelet exists as a
complex version or a purely real-valued version. Some distinguish between the
&quot;real Morlet&quot; versus the &quot;complex Morlet&quot;. Others consider the complex
version to be the &quot;Gabor wavelet&quot;, while the real-valued version is the
&quot;Morlet wavelet&quot;. This function returns the complex Morlet wavelet, with
time-decay parameter <code>fb</code>, and center frequency <code>fc</code>. The general
expression for the complex Morlet wavelet is

</p>
<pre>
 Psi(x) = ((pi * fb)^-0.5) *  exp(2 * pi * i * fc * x) * exp(-(x^2) / fb)
</pre>
<p><code>x</code> is evaluated on an <code>n</code>-point regular grid in the interval (lb,
ub).
</p>
<p><code>fb</code> controls the decay in the time domain and the corresponding energy
spread (bandwidth) in the frequency domain.
<code>fb</code> is the inverse of the variance in the frequency domain. Increasing
<code>fb</code> makes the wavelet energy more concentrated around the center
frequency and results in slower decay of the wavelet in the time domain.
Decreasing <code>fb</code> results in faster decay of the wavelet in the time
domain and less energy spread in the frequency domain. The value of <code>fb</code>
does not affect the center frequency. When converting from scale to
frequency, only the center frequency affects the frequency values. The energy
spread or bandwidth parameter affects how localized the wavelet is in the
frequency domain. See the examples.
</p>


<h3>Value</h3>

<p>A list containing 2 variables; <code>x</code>, the grid on which the
complex Morlet wavelet was evaluated, and <code>psi</code> (<code class="reqn">\Psi</code>), the
evaluated wavelet on the grid <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Construct a complex-valued Morlet wavelet with a bandwidth parameter
##  of 1.5 and a center frequency of 1. Set the effective support to [-8,8]
## and the length of the wavelet to 1000.
cmw &lt;- cmorwavf(-8, 8, 1000, 1.5, 1)

# Plot the real and imaginary parts of the wavelet.
op &lt;- par(mfrow = c(2, 1))
plot(cmw$x, Re(cmw$psi), type = "l", main = "Real Part")
plot(cmw$x, Im(cmw$psi), type = "l", main = "Imaginary Part")
par(op)

## This example shows how the complex Morlet wavelet shape in the frequency
## domain is affected by the value of the bandwidth parameter (fb). Both
## wavelets have a center frequency of 1. One wavelet has an fb value of
## 0.5 and the other wavelet has a value of 8.

op &lt;- par(mfrow = c(2,1))
cmw1 &lt;- cmorwavf(fb = 0.5)
cmw2 &lt;- cmorwavf(fb = 8)

# time domain plot
plot(cmw1$x, Re(cmw1$psi), type = "l", xlab = "Time", ylab = "",
     main = "Time domain, Real part")
lines(cmw2$x, Re(cmw2$psi), col = "red")
legend("topright", legend = c("fb = 0.5", "fb = 8"), lty= 1, col = c(1,2))

# frequency domain plot
f &lt;- seq(-5, 5, .01)
Fc &lt;- 1
Fb1 &lt;- 0.5
Fb2 &lt;- 8
PSI1 &lt;- exp(-pi^2 * Fb1 * (f-Fc)^2)
PSI2 &lt;- exp(-pi^2 * Fb2 * (f-Fc)^2)
plot(f, PSI1, type="l", xlab = "Frequency", ylab = "",
     main = "Frequency domain")
lines(f, PSI2, col = "red")
legend("topright", legend = c("fb = 0.5", "fb = 8"),
       lty= 1, col = c(1,2))
par(op)

## The fb bandwidth parameter for the complex Morlet wavelet is the
## inverse of the variance in frequency. Therefore, increasing Fb results
## in a narrower concentration of energy around the center frequency.

## alternative to the above frequency plot:
fs &lt;- length(cmw1$x) / sum(abs(range(cmw1$x)))
hz  &lt;- seq(0, fs/2, len=floor(length(cmw1$psi)/2)+1)
PSI1 &lt;- fft(cmw1$psi) / length(cmw1$psi)
PSI2 &lt;- fft(cmw2$psi) / length(cmw2$psi)
plot(hz, 2 * abs(PSI1)[1:length(hz)], type="l", xlab = "Frequency",
     ylab = "", main = "Frequency domain", xlim=c(0,5))
lines(hz, 2 * abs(PSI2)[1:length(hz)], col = 2)
legend("topright", legend = c("fb = 0.5", "fb = 8"), lty= 1, col = c(1,2))

</code></pre>

<hr>
<h2 id='conv'>Convolution and polynomial multiplication</h2><span id='topic+conv'></span>

<h3>Description</h3>

<p>Convolve two vectors <code>a</code> and <code>b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv(a, b, shape = c("full", "same", "valid"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_+3A_a">a</code>, <code id="conv_+3A_b">b</code></td>
<td>
<p>Input, coerced to vectors, can be different lengths or data types.</p>
</td></tr>
<tr><td><code id="conv_+3A_shape">shape</code></td>
<td>
<p>Subsection of convolution, partially matched to <code>"full"</code>
(full convolution - default), <code>"same"</code> (central part of the
convolution of the same size as <code>a</code>), or <code>"valid"</code> (only those
parts of the convolution that are computed without the zero-padded edges)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The convolution of two vectors, <code>a</code> and <code>b</code>, represents the area of
overlap under the points as <code>B</code> slides across <code>a</code>. Algebraically,
convolution is the same operation as multiplying polynomials whose
coefficients are the elements of <code>a</code> and <code>b</code>.
</p>
<p>The function <code>conv</code> uses the <code><a href="#topic+filter">filter</a></code> function, NOT
<code>fft</code>, which may be faster for large vectors.
</p>


<h3>Value</h3>

<p>Output vector with length equal to <code>length (a) + length (b) -
  1</code>. When the parameter <code>shape</code> is set to <code>"valid"</code>, the length of
the output is <code>max(length(a) - length(b) + 1, 0)</code>, except when
length(b) is zero. In that case, the length of the output vector equals
<code>length(a)</code>.
</p>
<p>When <code>a</code> and <code>b</code> are the coefficient vectors of two polynomials,
the convolution represents the coefficient vector of the product
polynomial.
</p>


<h3>Author(s)</h3>

<p>Tony Richardson, <a href="mailto:arichard@stark.cc.oh.us">arichard@stark.cc.oh.us</a>, adapted by John W.
Eaton.<br /> Conversion to R by Geert van Boxtel,
<a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- rep(1L, 3)
v &lt;- c(1, 1, 0, 0, 0, 1, 1)
w &lt;- conv(u, v)

## Create vectors u and v containing the coefficients of the polynomials
## x^2 + 1 and 2x + 7.
u &lt;- c(1, 0, 1)
v &lt;- c(2, 7)
## Use convolution to multiply the polynomials.
w &lt;- conv(u, v)
## w contains the polynomial coefficients for 2x^3 + 7x^2 + 2x + 7.

## Central part of convolution
u &lt;- c(-1, 2, 3, -2, 0, 1, 2)
v &lt;- c(2, 4, -1, 1)
w &lt;- conv(u, v, 'same')

</code></pre>

<hr>
<h2 id='conv2'>2-D convolution</h2><span id='topic+conv2'></span>

<h3>Description</h3>

<p>Compute the two-dimensional convolution of two matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv2(a, b, shape = c("full", "same", "valid"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv2_+3A_a">a</code>, <code id="conv2_+3A_b">b</code></td>
<td>
<p>Input matrices, coerced to numeric.</p>
</td></tr>
<tr><td><code id="conv2_+3A_shape">shape</code></td>
<td>
<p>Subsection of convolution, partially matched to:
</p>

<dl>
<dt>&quot;full&quot;</dt><dd><p>Return the full convolution (default)</p>
</dd>
<dt>&quot;same&quot;</dt><dd><p>Return the central part of the convolution with the same size
as A. The central part of the convolution begins at the indices
<code>floor(c(nrow(b), ncol(b)) / 2 + 1)</code></p>
</dd>
<dt>&quot;valid&quot;</dt><dd><p>Return only the parts which do not include zero-padded
edges. The size of the result is <code>max(nrow(a) - nrow(a) + 1, 0)</code> by
<code>max(ncol(A) - ncol(B) + 1, 0)</code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Convolution of input matrices, returned as a matrix.
</p>


<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conv">conv</a></code>, <code><a href="stats.html#topic+convolve">convolve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(1:16, 4, 4)
b &lt;- matrix(1:9, 3,3)
cnv &lt;- conv2(a, b)
cnv &lt;- conv2(a, b, "same")
cnv &lt;- conv2(a, b, "valid")

</code></pre>

<hr>
<h2 id='convmtx'>Convolution matrix</h2><span id='topic+convmtx'></span>

<h3>Description</h3>

<p>Returns the convolution matrix for a filter kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convmtx(h, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convmtx_+3A_h">h</code></td>
<td>
<p>Input, coerced to a vector, representing the filter kernel</p>
</td></tr>
<tr><td><code id="convmtx_+3A_n">n</code></td>
<td>
<p>Length of vector(s) that <code>h</code> is to be convolved with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing a convolution using <code>conv</code> when the signals are vectors is
generally more efficient than using <code>convmtx</code>. For multichannel signals,
however, when  a large number of vectors are to be convolved with the same
filter kernel, <code>convmtx</code> might be more efficient.
</p>
<p>The code <code>cm &lt;- convmtx(h, n)</code> computes the convolution matrix of the
filter kernel <code>h</code> with a vector of length <code>n</code>. Then, <code>cm 
x</code> gives the convolution of <code>h</code> and <code>x</code>.
</p>


<h3>Value</h3>

<p>Convolution matrix of input <code>h</code> for a vector of length <code>n</code>.
If <code>h</code> is a vector of length <code>m</code>, then the convolution matrix has
<code>m + n - 1</code> rows and <code>n</code> columns.
</p>


<h3>Author(s)</h3>

<p>David Bateman <a href="mailto:adb014@gmail.com">adb014@gmail.com</a>.<br /> Conversion to R by Geert
van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conv">conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000
a &lt;- runif(N)
b &lt;- runif(N)
cm &lt;- convmtx(b, N)
d &lt;- cm %*% a

cref = conv(a, b)
all.equal(max(d - cref), 0)

</code></pre>

<hr>
<h2 id='cplxpair'>Complex conjugate pairs</h2><span id='topic+cplxpair'></span>

<h3>Description</h3>

<p>Sort complex numbers into complex conjugate pairs ordered by increasing real
part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplxpair(z, tol = 100 * .Machine$double.eps, MARGIN = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplxpair_+3A_z">z</code></td>
<td>
<p>Vector, matrix, or array of complex numbers.</p>
</td></tr>
<tr><td><code id="cplxpair_+3A_tol">tol</code></td>
<td>
<p>Weighting factor <code>0 &lt; tol &lt; 1</code>, which determines the
tolerance of matching. Default: <code>100 * .Machine$double.eps</code>. (This
definition differs from the 'Octave' usage).</p>
</td></tr>
<tr><td><code id="cplxpair_+3A_margin">MARGIN</code></td>
<td>
<p>Vector giving the subscripts which the function will be applied
over. E.g., for a matrix 1 indicates rows, 2 indicates columns, c(1, 2)
indicates rows and columns. Where X has named dimnames, it can be a
character vector selecting dimension names. Default: 2 (columns).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The negative imaginary complex numbers are placed first within each pair. All
real numbers (those with <code>abs(Im (z) / z) &lt; tol)</code> are placed after the
complex pairs.
</p>
<p>An error is signaled if some complex numbers could not be paired and if all
complex numbers are not exact conjugates (to within <code>tol</code>).
</p>


<h3>Value</h3>

<p>Vector, matrix or array containing ordered complex conjugate pairs by
increasing real parts.
</p>


<h3>Note</h3>

<p>There is no defined order for pairs with identical real parts but
differing imaginary parts.
</p>


<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cplxreal">cplxreal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rbind(t(cplxpair(exp(2i * pi * 0:4 / 5))),
           t(exp(2i * pi *c(3, 2, 4, 1, 0) / 5)))

</code></pre>

<hr>
<h2 id='cplxreal'>Sort complex conjugate pairs and real</h2><span id='topic+cplxreal'></span>

<h3>Description</h3>

<p>Sort numbers into into complex-conjugate-valued and real-valued elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplxreal(z, tol = 100 * .Machine$double.eps, MARGIN = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplxreal_+3A_z">z</code></td>
<td>
<p>Vector, matrix, or array of complex numbers.</p>
</td></tr>
<tr><td><code id="cplxreal_+3A_tol">tol</code></td>
<td>
<p>Weighting factor <code>0 &lt; tol &lt; 1</code>, which determines the
tolerance of matching. Default: <code>100 * .Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="cplxreal_+3A_margin">MARGIN</code></td>
<td>
<p>Vector giving the subscripts which the function will be applied
over. E.g., for a matrix 1 indicates rows, 2 indicates columns, c(1, 2)
indicates rows and columns. Where X has named dimnames, it can be a
character vector selecting dimension names. Default: 2 (columns).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An error is signaled if some complex numbers could not be paired and if all
complex numbers are not exact conjugates (to within tol). Note that here is
no defined order for pairs with identical real parts but differing imaginary
parts.
</p>


<h3>Value</h3>

<p>A list containing two variables:
</p>

<dl>
<dt>zc</dt><dd><p>Vector, matrix or array containing ordered complex conjugate
pairs by increasing real parts. Only the positive imaginary complex numbers
of each complex conjugate pair are returned.</p>
</dd>
<dt>zr</dt><dd><p>Vector, matrix or array containing ordered real numbers.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cplxpair">cplxpair</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- cplxreal(c(1, 1 + 3i, 2 - 5i, 1-3i, 2 + 5i, 4, 3))

</code></pre>

<hr>
<h2 id='cpsd'>Cross power spectral density</h2><span id='topic+cpsd'></span><span id='topic+csd'></span>

<h3>Description</h3>

<p>Estimates the cross power spectral density (CPSD) of discrete-time signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpsd(
  x,
  window = nextpow2(sqrt(NROW(x))),
  overlap = 0.5,
  nfft = ifelse(isScalar(window), window, length(window)),
  fs = 1,
  detrend = c("long-mean", "short-mean", "long-linear", "short-linear", "none")
)

csd(
  x,
  window = nextpow2(sqrt(NROW(x))),
  overlap = 0.5,
  nfft = ifelse(isScalar(window), window, length(window)),
  fs = 1,
  detrend = c("long-mean", "short-mean", "long-linear", "short-linear", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpsd_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="cpsd_+3A_window">window</code></td>
<td>
<p>If <code>window</code> is a vector, each segment has the same length
as <code>window</code> and is multiplied by <code>window</code> before (optional)
zero-padding and calculation of its periodogram. If <code>window</code> is a
scalar, each segment has a length of <code>window</code> and a Hamming window is
used. Default: <code>nextpow2(sqrt(length(x)))</code> (the square root of the
length of <code>x</code> rounded up to the next power of two). The window length
must be larger than 3.</p>
</td></tr>
<tr><td><code id="cpsd_+3A_overlap">overlap</code></td>
<td>
<p>segment overlap, specified as a numeric value expressed as a
multiple of window or segment length. 0 &lt;= overlap &lt; 1. Default: 0.5.</p>
</td></tr>
<tr><td><code id="cpsd_+3A_nfft">nfft</code></td>
<td>
<p>Length of FFT, specified as an integer scalar. The default is the
length of the <code>window</code> vector or has the same value as the scalar
<code>window</code> argument.  If <code>nfft</code> is larger than the segment length,
(seg_len), the data segment is padded <code>nfft - seg_len</code> zeros. The
default is no padding. Nfft values smaller than the length of the data
segment (or window) are ignored. Note that the use of padding to increase
the frequency resolution of the spectral estimate is controversial.</p>
</td></tr>
<tr><td><code id="cpsd_+3A_fs">fs</code></td>
<td>
<p>sampling frequency (Hertz), specified as a positive scalar.
Default: 1.</p>
</td></tr>
<tr><td><code id="cpsd_+3A_detrend">detrend</code></td>
<td>
<p>character string specifying detrending option; one of:
</p>

<dl>
<dt><code>"long-mean"</code></dt><dd><p>remove the mean from the data before
splitting into segments (default)</p>
</dd>
<dt><code>"short-mean"</code></dt><dd><p>remove the mean value of each segment</p>
</dd>
<dt><code>"long-linear"</code></dt><dd><p>remove linear trend from the data before
splitting into segments</p>
</dd>
<dt><code>"short-linear"</code></dt><dd><p>remove linear trend from each segment</p>
</dd>
<dt><code>"none"</code></dt><dd><p>no detrending</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cpsd</code> estimates the cross power spectral density function using
Welch’s overlapped averaged periodogram method [1].
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>freq</code></dt><dd><p>vector of frequencies at which the spectral variables
are estimated. If <code>x</code> is numeric, power from negative frequencies is
added to the positive side of the spectrum, but not at zero or Nyquist
(fs/2) frequencies. This keeps power equal in time and spectral domains.
If <code>x</code> is complex, then the whole frequency range is returned.</p>
</dd>
<dt><code>cross</code></dt><dd><p>NULL for univariate series. For multivariate series,
a matrix containing the squared coherence between different series.
Column <code class="reqn">i + (j - 1) * (j - 2)/2 </code> of <code>coh</code> contains the
cross-spectral estimates between columns <code class="reqn">i</code> and <code class="reqn">j</code> of <code class="reqn">x</code>,
where <code class="reqn">i &lt; j</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The function <code>cpsd</code> (and its deprecated alias <code>csd</code>)
is a wrapper for the function <code>pwelch</code>, which is more complete and
more flexible.
</p>


<h3>Author(s)</h3>

<p>Peter V. Lanspeary, <a href="mailto:pvl@mecheng.adelaide.edu.au">pvl@mecheng.adelaide.edu.au</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] Welch, P.D. (1967). The use of Fast Fourier Transform for
the estimation of power spectra: A method based on time averaging over
short, modified periodograms. IEEE Transactions on Audio and
Electroacoustics, AU-15 (2): 70–73.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- 1000
f &lt;- 250
t &lt;- seq(0, 1 - 1/fs, 1/fs)
s1 &lt;- sin(2 * pi * f * t) + runif(length(t))
s2 &lt;- sin(2 * pi * f * t - pi / 3) + runif(length(t))
rv &lt;- cpsd(cbind(s1, s2), fs = fs)
plot(rv$freq, 10 * log10(rv$cross), type="l", xlab = "Frequency",
     ylab = "Cross Spectral Density (dB)")

</code></pre>

<hr>
<h2 id='czt'>Chirp Z-transform</h2><span id='topic+czt'></span>

<h3>Description</h3>

<p>Compute the Chirp Z-transform along a spiral contour on the z-plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>czt(x, m = NROW(x), w = exp(complex(real = 0, imaginary = -2 * pi/m)), a = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="czt_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="czt_+3A_m">m</code></td>
<td>
<p>transform length, specified as a positive integer scalar. Default:
<code>NROW(x)</code>.</p>
</td></tr>
<tr><td><code id="czt_+3A_w">w</code></td>
<td>
<p>ratio between spiral contour points in each step (i.e., radius
increases exponentially, and angle increases linearly), specified as a
complex scalar. Default: <code>exp(0-1i * 2 * pi / m)</code>.</p>
</td></tr>
<tr><td><code id="czt_+3A_a">a</code></td>
<td>
<p>initial spiral contour point, specified as a complex scalar.
Default: 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The chirp Z-transform (CZT) is a generalization of the discrete Fourier
transform (DFT). While the DFT samples the Z plane at uniformly-spaced points
along the unit circle, the chirp Z-transform samples along spiral arcs in the
Z-plane, corresponding to straight lines in the S plane. The DFT, real DFT,
and zoom DFT can be calculated as special cases of the CZT[1]. For the
specific case of the DFT, <code>a = 0</code>, <code>m = NCOL(x)</code>, and <code>w = 2 *
pi / m</code>[2, p. 656].
</p>


<h3>Value</h3>

<p>Chirp Z-transform, returned as a vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Daniel Gunyan.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] <a href="https://en.wikipedia.org/wiki/Chirp_Z-transform">https://en.wikipedia.org/wiki/Chirp_Z-transform</a><br />
[2]Oppenheim, A.V., Schafer, R.W., and Buck, J.R. (1999). Discrete-Time
Signal Processing, 2nd edition. Prentice-Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- 1000                                           # sampling frequency
secs &lt;- 10                                           # number of seconds
t &lt;- seq(0, secs, 1/fs)                              # time series
x &lt;- sin(100 * 2 * pi * t) + runif(length(t))        # 100 Hz signal + noise
m &lt;- 32                                              # n of points desired
f0 &lt;- 75; f1 &lt;- 175;                                 # desired freq range
w &lt;- exp(-1i * 2 * pi * (f1 - f0) / ((m - 1) * fs))  # freq step of f1-f0/m
a &lt;- exp(1i * 2 * pi * f0 / fs);                     # starting at freq f0
y &lt;- czt(x, m, w, a)

# compare DFT and FFT
fs &lt;- 1000
h &lt;- as.numeric(fir1(100, 125/(fs / 2), type = "low"))
m &lt;- 1024
y &lt;- stats::fft(postpad(h, m))

f1 &lt;- 75; f2 &lt;- 175;
w &lt;- exp(-1i * 2 * pi * (f2 - f1) / (m * fs))
a &lt;- exp(1i * 2 * pi * f1 / fs)
z &lt;- czt(h, m, w, a)

fn &lt;- seq(0, m - 1, 1) / m
fy &lt;- fs * fn
fz = (f2 - f1) * fn + f1
plot(fy, 10 * log10(abs(y)), type = "l", xlim = c(50, 200),
  xlab = "Frequency", ylab = "Magnitude (dB")
lines(fz, 10 * log10(abs(z)), col = "red")
legend("topright", legend = c("FFT", "CZT"), col=1:2, lty = 1)

</code></pre>

<hr>
<h2 id='dct'>Discrete Cosine Transform</h2><span id='topic+dct'></span>

<h3>Description</h3>

<p>Compute the unitary discrete cosine transform of a signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dct(x, n = NROW(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dct_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="dct_+3A_n">n</code></td>
<td>
<p>transform length, specified as a positive integer scalar. Default:
<code>NROW(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrete cosine transform (DCT) is closely related to the discrete
Fourier transform. You can often reconstruct a sequence very accurately from
only a few DCT coefficients. This property is useful for applications
requiring data reduction.
</p>
<p>The DCT has four standard variants. This function implements the DCT-II
according to the definition in [1], which is the most common variant, and
the original variant first proposed for image processing.
</p>


<h3>Value</h3>

<p>Discrete cosine transform, returned as a vector or matrix.
</p>


<h3>Note</h3>

<p>The transform is faster if <code>x</code> is real-valued and has even length.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] <a href="https://en.wikipedia.org/wiki/Discrete_cosine_transform">https://en.wikipedia.org/wiki/Discrete_cosine_transform</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idct">idct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(seq_len(100) + 50 * cos(seq_len(100) * 2 * pi / 40))
X &lt;- dct(x)

# Find which cosine coefficients are significant (approx.)
# zero the rest
nsig &lt;- which(abs(X) &lt; 1)
N &lt;- length(X) - length(nsig) + 1
X[nsig] &lt;- 0

# Reconstruct the signal and compare it to the original signal.
xx &lt;- idct(X)
plot(x, type = "l")
lines(xx, col = "red")
legend("bottomright", legend = c("Original", paste("Reconstructed, N =", N)),
       lty = 1, col = 1:2)

</code></pre>

<hr>
<h2 id='dct2'>2-D Discrete Cosine Transform</h2><span id='topic+dct2'></span>

<h3>Description</h3>

<p>Compute the two-dimensional discrete cosine transform of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dct2(x, m = NROW(x), n = NCOL(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dct2_+3A_x">x</code></td>
<td>
<p>2-D numeric matrix</p>
</td></tr>
<tr><td><code id="dct2_+3A_m">m</code></td>
<td>
<p>Number of rows, specified as a positive integer. <code>dct2</code> pads or
truncates <code>x</code> so that is has <code>m</code> rows. Default: <code>NROW(x)</code>.</p>
</td></tr>
<tr><td><code id="dct2_+3A_n">n</code></td>
<td>
<p>Number of columns, specified as a positive integer. <code>dct2</code> pads
or truncates <code>x</code> so that is has <code>n</code> columns. Default:
<code>NCOL(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrete cosine transform (DCT) is closely related to the discrete
Fourier transform. It is a separable linear transformation; that is, the
two-dimensional transform is equivalent to a one-dimensional DCT performed
along a single dimension followed by a one-dimensional DCT in the other
dimension.
</p>


<h3>Value</h3>

<p><code>m</code>-by-<code>n</code> numeric discrete cosine transformed matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br /> Conversion to R by
Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idct2">idct2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(runif(100), 10, 10)
B &lt;- dct2(A)

</code></pre>

<hr>
<h2 id='dctmtx'>Discrete Cosine Transform Matrix</h2><span id='topic+dctmtx'></span>

<h3>Description</h3>

<p>Compute the discrete cosine transform matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dctmtx(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dctmtx_+3A_n">n</code></td>
<td>
<p>Size of DCT matrix, specified as a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A DCT transformation matrix is useful for doing things like JPEG image
compression, in which an 8x8 DCT matrix is applied to non-overlapping blocks
throughout an image and only a sub-block on the top left of each block is
kept.  During restoration, the remainder of the block is filled with zeros
and the inverse transform is applied to the block.
</p>
<p>The two-dimensional DCT of A can be computed as <code>D %*% A %*% t(D)</code>.
This computation is sometimes faster than using <code>dct2</code>, especially if
you are computing a large number of small DCTs, because D needs to be
determined only once. For example, in JPEG compression, the DCT of each
8-by-8 block is computed. To perform this computation, use <code>dctmtx</code> to
determine D of input image A, and then calculate each DCT using <code>D %*%
A %*% t(D)</code> (where A is each 8-by-8 block). This is faster than calling
<code>dct2</code> for each individual block.
</p>


<h3>Value</h3>

<p>Discrete cosine transform, returned as a vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dct">dct</a></code>, <code><a href="#topic+dct2">dct2</a></code>, <code><a href="#topic+idct">idct</a></code>,
<code><a href="#topic+idct2">idct2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- dctmtx(8)

#if (requireNamespace("imager", quietly = TRUE)) {
#   boats &lt;- imager::boats
#   A &lt;- imager::grayscale(boats)[1:256, 65:320, 1, 1]  # make it 256*256
#   plot(imager::as.cimg(A), axes = FALSE, main = "Boats from imager package")
#   D &lt;- dctmtx(nrow(A))
#   ctrans &lt;- D %*% A %*% t(D)
#   ctrans2 &lt;- dct2(A)
#   all.equal(ctrans, ctrans2)
# }

</code></pre>

<hr>
<h2 id='decimate'>Decrease sample rate</h2><span id='topic+decimate'></span>

<h3>Description</h3>

<p>Downsample a signal by an integer factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decimate(x, q, n = ifelse(ftype == "iir", 8, 30), ftype = c("iir", "fir"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decimate_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="decimate_+3A_q">q</code></td>
<td>
<p>decimation factor, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="decimate_+3A_n">n</code></td>
<td>
<p>Order of the filter used prior to the downsampling, specified as a
positive integer. Default: 8 if <code>ftype</code> equals <code>"iir"</code>; 30 of
<code>ftype</code> equals <code>"fir"</code>.</p>
</td></tr>
<tr><td><code id="decimate_+3A_ftype">ftype</code></td>
<td>
<p>filter type; either <code>"fir"</code>, specifying a FIR filter of
length <code>n</code> designed with the function <code><a href="#topic+fir1">fir1</a></code>, or
<code>"iir"</code> (default), specifying an IIR Chebyshev filter of order 8 using
the function <code><a href="#topic+cheby1">cheby1</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>downsampled signal, returned as a vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cheby1">cheby1</a></code>, <code><a href="#topic+fir1">fir1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- seq(0, 2, 0.01)
x &lt;- chirp(t, 2, .5, 10, 'quadratic') + sin(2 * pi * t * 0.4)
w &lt;- 1:121
plot(t[w] * 1000, x[w], type = "h", col = "green")
points(t[w] * 1000, x[w], col = "green")
y = decimate(x, 4)
lines(t[seq(1, 121, 4)] * 1000, y[1:31], type = "h", col = "red")
points(t[seq(1, 121, 4)] * 1000, y[1:31], col = "red")

</code></pre>

<hr>
<h2 id='detrend'>Remove Polynomial Trend</h2><span id='topic+detrend'></span>

<h3>Description</h3>

<p><code>detrend</code> removes the polynomial trend of order <code>p</code> from the data
<code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detrend(x, p = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detrend_+3A_x">x</code></td>
<td>
<p>Input vector or matrix. If <code>x</code> is a matrix, the trend is
removed from the columns.</p>
</td></tr>
<tr><td><code id="detrend_+3A_p">p</code></td>
<td>
<p>Order of the polynomial. Default: 1. The order of the polynomial can
also be given as a string, in which case <code>p</code> must be either
<code>"constant"</code> (corresponds to <code>p = 0</code>) or <code>"linear"</code>
(corresponds to <code>p = 1</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The detrended data, of same type and dimensions as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Kurt Hornik, <a href="mailto:Kurt.Hornik@wu-wien.ac.at">Kurt.Hornik@wu-wien.ac.at</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- 0:20
x &lt;- 3 * sin(t) + t
y &lt;- detrend(x)
plot(t, x, type = "l", ylim = c(-5, 25), xlab = "", ylab = "")
lines(t, y, col = "red")
lines(t, x - y, lty = 2)
legend('topleft', legend = c('Input Data', 'Detrended Data', 'Trend'),
 col = c(1, 2 ,1), lty = c(1, 1, 2))

</code></pre>

<hr>
<h2 id='dftmtx'>Discrete Fourier Transform Matrix</h2><span id='topic+dftmtx'></span>

<h3>Description</h3>

<p>Compute the discrete Fourier transform matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dftmtx(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dftmtx_+3A_n">n</code></td>
<td>
<p>Size of Fourier transformation matrix, specified as a positive
integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A discrete Fourier transform matrix is a complex matrix whose matrix product
with a vector computes the discrete Fourier transform of the vector.
<code>dftmtx</code> takes the FFT of the identity matrix to generate the transform
matrix. For a column vector <code>x</code>, <code>y &lt;- dftmtx(n) * x</code> is the same
as <code>y &lt;- fft(x, postpad(x, n)</code>. The inverse discrete Fourier transform
matrix is <code>inv &lt;- Conj(dftmtx(n)) / n</code>.
</p>
<p>In general this is less efficient than calling the <code>fft</code> and <code>ifft</code>
functions directly.
</p>


<h3>Value</h3>

<p>Fourier transform matrix.
</p>


<h3>Author(s)</h3>

<p>David Bateman, <a href="mailto:adb014@gmail.com">adb014@gmail.com</a>.<br /> Conversion to R by Geert
van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fft">fft</a></code>, <code><a href="#topic+ifft">ifft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq_len(256)
y1 &lt;- stats::fft(x)
n &lt;- length(x)
y2 &lt;- drop(x %*% dftmtx(n))
mx &lt;- max(abs(y1 - y2))

</code></pre>

<hr>
<h2 id='digitrevorder'>Permute input to digit-reversed order</h2><span id='topic+digitrevorder'></span>

<h3>Description</h3>

<p>Reorder the elements of the input vector in digit-reversed order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>digitrevorder(x, r, index.return = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="digitrevorder_+3A_x">x</code></td>
<td>
<p>input data, specified as a vector. The length of <code>x</code> must be an
integer power of <code>r</code>.</p>
</td></tr>
<tr><td><code id="digitrevorder_+3A_r">r</code></td>
<td>
<p>radix base used for the number conversion, which can be any integer
from 2 to 36. The elements of <code>x</code> are converted to radix <code>r</code> and
reversed.</p>
</td></tr>
<tr><td><code id="digitrevorder_+3A_index.return">index.return</code></td>
<td>
<p>logical indicating if the ordering index vector should be
returned as well. Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for pre-ordering a vector of filter coefficients for
use in frequency-domain filtering algorithms, in which the fft and ifft
transforms are computed without digit-reversed ordering for improved run-time
efficiency.
</p>


<h3>Value</h3>

<p>The digit-reversed input vector. If <code>index.return = TRUE</code>, then
a list containing the digit-reversed input vector (<code>y</code>, and the
digit-reversed indices (<code>i</code>).
</p>


<h3>Author(s)</h3>

<p>Mike Miller.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bitrevorder">bitrevorder</a></code>, <code><a href="stats.html#topic+fft">fft</a></code>, <code><a href="#topic+ifft">ifft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
res &lt;- digitrevorder(0:8, 3)

</code></pre>

<hr>
<h2 id='diric'>Dirichlet function</h2><span id='topic+diric'></span>

<h3>Description</h3>

<p>Compute the Dirichlet or periodic sinc function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diric(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diric_+3A_x">x</code></td>
<td>
<p>Input array, specified as a real scalar, vector, matrix, or
multidimensional array. When <code>x</code> is non-scalar, <code>diric</code> is an
element-wise operation.</p>
</td></tr>
<tr><td><code id="diric_+3A_n">n</code></td>
<td>
<p>Function degree, specified as a positive integer scalar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y &lt;- diric(x, n)</code> returns the Dirichlet Function of degree <code>n</code>
evaluated at the elements of the input array x.
</p>
<p>The Dirichlet function, or periodic sinc function, has period <code class="reqn">2 \pi</code> for
odd <code class="reqn">N</code> and period <code class="reqn">4 \pi</code> for even <code class="reqn">N</code>. Its maximum value is 1
for all N, and its minimum value is -1 for even N. The magnitude of the
function is 1 / N times the magnitude of the discrete-time Fourier transform
of the N-point rectangular window.
</p>


<h3>Value</h3>

<p>Output array, returned as a real-valued scalar, vector, matrix, or
multidimensional array of the same size as x.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Compute and plot the Dirichlet function between -2pi and 2pi for N = 7
## and N = 8. The function has a period of 2pi for odd N and 4pi for even N.
x &lt;- seq(-2*pi, 2*pi, len = 301)
d7 &lt;- diric(x, 7)
d8 &lt;- diric(x, 8)
op &lt;- par(mfrow = c(2,1))
plot(x/pi, d7, type="l", main = "Dirichlet function",
     xlab = "", ylab = "N = 7")
plot(x/pi, d8, type="l", ylab = "N = 8", xlab = expression(x / pi))
par(op)

</code></pre>

<hr>
<h2 id='downsample'>Decrease sample rate</h2><span id='topic+downsample'></span>

<h3>Description</h3>

<p>Downsample a signal by an integer factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsample(x, n, phase = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsample_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="downsample_+3A_n">n</code></td>
<td>
<p>downsampling factor, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="downsample_+3A_phase">phase</code></td>
<td>
<p>offset, specified as a positive integer from <code>0</code> to <code>n
- 1</code>. Default: 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For most signals you will want to use <code><a href="#topic+decimate">decimate</a></code> instead since it
prefilters the high frequency components of the signal and avoids aliasing
effects.
</p>


<h3>Value</h3>

<p>Downsampled signal, returned as a vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decimate">decimate</a></code>, <code><a href="#topic+resample">resample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq_len(10)
xd &lt;- downsample(x, 3)     # returns 1  4  7 10
xd &lt;- downsample(x, 3, 2)  # returns 3 6 9

x &lt;- matrix(seq_len(12), 4, 3, byrow = TRUE)
xd &lt;- downsample(x, 3)

</code></pre>

<hr>
<h2 id='dst'>Discrete Sine Transform</h2><span id='topic+dst'></span>

<h3>Description</h3>

<p>Compute the discrete sine transform of a signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dst(x, n = NROW(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dst_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="dst_+3A_n">n</code></td>
<td>
<p>transform length, specified as a positive integer scalar. Default:
<code>NROW(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrete sine transform (DST) is closely related to the discrete Fourier
transform. but using a purely real matrix. It is equivalent to the imaginary
parts of a DFT of roughly twice the length.
</p>
<p>The DST has four standard variants. This function implements the DCT-I
according to the definition in [1], which is the most common variant, and
the original variant first proposed for image processing.
</p>
<p>The 'Matlab' documentation for the DST warns that the use of the function is
not recommended. They do not state the reason why, but it is likely that use
of the discrete cosine transform (DCT)is preferred for image processing.
Because cos(0) is 1, the first coefficient of the DCT (II) is the mean of the
values being transformed. This makes the first coefficient of each 8x8 block
represent the average tone of its constituent pixels, which is obviously a
good start. Subsequent coefficients add increasing levels of detail, starting
with sweeping gradients and continuing into increasingly fiddly patterns, and
it just so happens that the first few coefficients capture most of the signal
in photographic images. Sin(0) is 0, so the DSTs start with an offset of 0.5
or 1, and the first coefficient is a gentle mound rather than a flat plain.
That is unlikely to suit ordinary images, and the result is that DSTs require
more coefficients than DCTs to encode most blocks. This explanation was
provided by Douglas Bagnall on Stackoverflow.
</p>


<h3>Value</h3>

<p>Discrete sine transform, returned as a vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] <a href="https://en.wikipedia.org/wiki/Discrete_sine_transform">https://en.wikipedia.org/wiki/Discrete_sine_transform</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idst">idst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(seq_len(100) + 50 * cos(seq_len(100) * 2 * pi / 40))
ct &lt;- dct(x)
st &lt;- dst(x)

</code></pre>

<hr>
<h2 id='dwt'>1-D Discrete Wavelet Transform</h2><span id='topic+dwt'></span><span id='topic+wfilters'></span>

<h3>Description</h3>

<p>Compute the single-level discrete wavelet transform of a signal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt(x, wname = "d8", lo = NULL, hi = NULL)

wfilters(wname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwt_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector.</p>
</td></tr>
<tr><td><code id="dwt_+3A_wname">wname</code></td>
<td>
<p>analyzing wavelet, specified as a character string consisting of
a class name followed by the wavelet length Only two classes of wavelets
are supported; Daubechies (denoted by the prefix <code>'d'</code> of even
lengths 2 - 20, and Coiflet (denoted by the prefix '<code>'c'</code> of
lengths 6, 12, 18, 24, and 30. The wavelet name <code>'haar'</code> is
the equivalent of <code>'d2'</code>. Default: d8.</p>
</td></tr>
<tr><td><code id="dwt_+3A_lo">lo</code></td>
<td>
<p>scaling (low-pass) filter, specified as an even-length numeric
vector. <code>lo</code> must be the same length as <code>hi</code>. Ignored when
<code>wname != NULL</code>.</p>
</td></tr>
<tr><td><code id="dwt_+3A_hi">hi</code></td>
<td>
<p>wavelet (high-pass) filter, specified as an even-length numeric
vector. <code>hi</code> must be the same length as <code>lo</code>, Ignored when
<code>wname != NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only included because of compatibility with the 'Octave'
'signal' package. Specialized packages exist in R to perform the discrete
wavelet transform, e.g., the <code>wavelets</code> package [1]. this function
recognizes only a few wavelet names, namely those for which scale
coefficients are available (Daubechies [2] and Coiflet [3]).
</p>
<p>The wavelet and scaling coefficients are returned by the function
<code>wfilters</code>, which returns the coefficients for reconstruction filters
associated with the wavelet <code>wname</code>. Decomposition filters are the time
reverse of the reconstruction filters (see examples).
</p>


<h3>Value</h3>

<p>A list containing two numeric vectors:
</p>

<dl>
<dt>a</dt><dd><p>approximation (average) coefficients, obtained from convolving
<code>x</code> with the scaling (low-pass) filter <code>lo</code>, and then
downsampled (keep the even-indexed elements).</p>
</dd>
<dt>d</dt><dd><p>detail (difference) coefficients, obtained from convolving
<code>x</code> with the wavelet (high-pass) filter <code>hi</code>, and then
downsampled (keep the even-indexed elements).</p>
</dd>
</dl>



<h3>Note</h3>

<p>The notations <code>g</code> and <code>h</code> are often used to denote low-pass
(scaling) and high-pass (wavelet) coefficients, respectively, but
inconsistently. Ref [4] uses it, as does the R <code>wavelets</code> package.
'Octave' uses the reverse notation. To avoid confusion, more neutral terms
are used here.
</p>
<p>There are two naming schemes for wavelet names in use. For instance for
Daubechies wavelets (d), dN using the length or number of taps, and dbA
referring to the number of vanishing moments. So d4 and db2 are the same
wavelet transform. This function uses the formed (dN) notation; 'Matlab'
uses the latter (dbA).
</p>


<h3>Author(s)</h3>

<p>Lukas F. Reichlin.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] <a href="https://CRAN.R-project.org/package=wavelets">https://CRAN.R-project.org/package=wavelets</a>
</p>
<p>[2] <a href="https://en.wikipedia.org/wiki/Daubechies_wavelet">https://en.wikipedia.org/wiki/Daubechies_wavelet</a>
</p>
<p>[3] <a href="https://en.wikipedia.org/wiki/Coiflet">https://en.wikipedia.org/wiki/Coiflet</a>
</p>
<p>[4]
<a href="https://en.wikipedia.org/wiki/Discrete_wavelet_transform">https://en.wikipedia.org/wiki/Discrete_wavelet_transform</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get Coiflet 30 coefficients
wv &lt;- wfilters('c30')
lo &lt;- rev(wv$lo)
hi &lt;- rev(wv$hi)

# general time-varying signal
time &lt;- 1
fs &lt;- 1000
x &lt;- seq(0,time, length.out=time*fs)
y &lt;- c(cos(2*pi*100*x)[1:300], cos(2*pi*50*x)[1:300],
       cos(2*pi*25*x)[1:200], cos(2*pi*10*x)[1:200])
op &lt;- par(mfrow = c(3,1))
plot(x, y, type = "l", xlab = "Time", ylab = "Amplitude",
     main = "Original signal")
wt &lt;- dwt(y, wname = NULL, lo, hi)

x2 &lt;- seq(1, length(x) - length(hi) + 1, 2)
plot(x2, wt$a, type = "h", xlab = "Time", ylab = "",
    main = "Approximation coefficients")
plot(x2, wt$d, type = "h", xlab = "Time", ylab = "",
     main = "Detail coefficients")
par (op)

</code></pre>

<hr>
<h2 id='ellip'>Elliptic filter design</h2><span id='topic+ellip'></span><span id='topic+ellip.FilterSpecs'></span><span id='topic+ellip.default'></span>

<h3>Description</h3>

<p>Compute the transfer function coefficients of an elliptic filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellip(n, ...)

## S3 method for class 'FilterSpecs'
ellip(n, Rp = n$Rp, Rs = n$Rs, w = n$Wc, type = n$type, plane = n$plane, ...)

## Default S3 method:
ellip(
  n,
  Rp,
  Rs,
  w,
  type = c("low", "high", "stop", "pass"),
  plane = c("z", "s"),
  output = c("Arma", "Zpg", "Sos"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellip_+3A_n">n</code></td>
<td>
<p>filter order.</p>
</td></tr>
<tr><td><code id="ellip_+3A_...">...</code></td>
<td>
<p>additional arguments passed to ellip, overriding those given by
<code>n</code> of class <code>FilterSpecs</code>.</p>
</td></tr>
<tr><td><code id="ellip_+3A_rp">Rp</code></td>
<td>
<p>dB of passband ripple.</p>
</td></tr>
<tr><td><code id="ellip_+3A_rs">Rs</code></td>
<td>
<p>dB of stopband ripple.</p>
</td></tr>
<tr><td><code id="ellip_+3A_w">w</code></td>
<td>
<p>critical frequencies of the filter. <code>w</code> must be a scalar for
low-pass and high-pass filters, and <code>w</code> must be a two-element vector
<code>c(low, high)</code> specifying the lower and upper bands in radians/second.
For digital filters, w must be between 0 and 1 where 1 is the Nyquist
frequency.</p>
</td></tr>
<tr><td><code id="ellip_+3A_type">type</code></td>
<td>
<p>filter type, one of <code>"low"</code>, <code>"high"</code>, <code>"stop"</code>,
or <code>"pass"</code>.</p>
</td></tr>
<tr><td><code id="ellip_+3A_plane">plane</code></td>
<td>
<p>&quot;z&quot; for a digital filter or &quot;s&quot; for an analog filter.</p>
</td></tr>
<tr><td><code id="ellip_+3A_output">output</code></td>
<td>
<p>Type of output, one of:
</p>

<dl>
<dt>&quot;Arma&quot;</dt><dd><p>Autoregressive-Moving average (aka numerator/denominator, aka
b/a)</p>
</dd>
<dt>&quot;Zpg&quot;</dt><dd><p>Zero-pole-gain format</p>
</dd>
<dt>&quot;Sos&quot;</dt><dd><p>Second-order sections</p>
</dd>
</dl>

<p>Default is <code>"Arma"</code> for compatibility with the 'signal' package and the
'Matlab' and 'Octave' equivalents, but <code>"Sos"</code> should be preferred for
general-purpose filtering because of numeric stability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An elliptic filter is a filter with equalized ripple (equiripple) behavior in
both the passband and the stopband. The amount of ripple in each band is
independently adjustable, and no other filter of equal order can have a
faster transition in gain between the passband and the stopband, for the
given values of ripple.
</p>
<p>As the ripple in the stopband approaches zero, the filter becomes a type I
Chebyshev filter. As the ripple in the passband approaches zero, the filter
becomes a type II Chebyshev filter and finally, as both ripple values
approach zero, the filter becomes a Butterworth filter.
</p>
<p>Because <code>ellip</code> is generic, it can be extended to accept other inputs,
using <code>ellipord</code> to generate filter criteria for example.
</p>


<h3>Value</h3>

<p>Depending on the value of the <code>output</code> parameter, a list of
class <code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+Zpg">Zpg</a></code>, or <code><a href="#topic+Sos">Sos</a></code>
containing the filter coefficients
</p>


<h3>Author(s)</h3>

<p>Paulo Neis, <a href="mailto:p_neis@yahoo.com.br">p_neis@yahoo.com.br</a>,<br />
adapted by Doug Stewart, <a href="mailto:dastew@sympatico.ca">dastew@sympatico.ca</a>.<br />
Conversion to R Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Elliptic_filter">https://en.wikipedia.org/wiki/Elliptic_filter</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+butter">butter</a></code>,
<code><a href="#topic+cheby1">cheby1</a></code>, <code><a href="#topic+ellipord">ellipord</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## compare the frequency responses of 5th-order Butterworth
## and elliptic filters.
bf &lt;- butter(5, 0.1)
ef &lt;- ellip(5, 3, 40, 0.1)
bfr &lt;- freqz(bf)
efr &lt;- freqz(ef)
plot(bfr$w, 20 * log10(abs(bfr$h)), type = "l", ylim = c(-80, 0),
     xlab = "Frequency (Rad)", ylab = c("dB"), lwd = 2,
     main = paste("Elliptic versus Butterworth filter",
     "low-pass -3 dB cutoff at 0.1 rad", sep = "\n"))
lines(efr$w, 20 * log10(abs(efr$h)), col = "red", lwd = 2)
legend ("topright", legend = c("Butterworh", "Elliptic"),
        lty = 1, lwd = 2, col = 1:2)

</code></pre>

<hr>
<h2 id='ellipap'>Low-pass analog elliptic filter</h2><span id='topic+ellipap'></span>

<h3>Description</h3>

<p>Return the zeros, poles and gain of an analog elliptic low-pass filter
prototype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipap(n, Rp, Rs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipap_+3A_n">n</code></td>
<td>
<p>Order of the filter.</p>
</td></tr>
<tr><td><code id="ellipap_+3A_rp">Rp</code></td>
<td>
<p>dB of passband ripple.</p>
</td></tr>
<tr><td><code id="ellipap_+3A_rs">Rs</code></td>
<td>
<p>dB of stopband ripple.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exists for compatibility with 'Matlab' and 'OCtave' only, and
is equivalent to <code>ellip(n, Rp, Rs, 1, "low", "s")</code>.
</p>


<h3>Value</h3>

<p>list of class <code><a href="#topic+Zpg">Zpg</a></code> containing zeros, poles and gain of
the filter.
</p>


<h3>Author(s)</h3>

<p>Carne Draug, <a href="mailto:carandraug+dev@gmail.com">carandraug+dev@gmail.com</a>.
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 9th order elliptic low-pass analog filter
zp &lt;- ellipap(9, .1, 40)
w &lt;- seq(0, 4, length.out = 128)
freqs(zp, w)

</code></pre>

<hr>
<h2 id='ellipord'>Elliptic Filter Order</h2><span id='topic+ellipord'></span>

<h3>Description</h3>

<p>Compute elliptic filter order and cutoff for the desired
response characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipord(Wp, Ws, Rp, Rs, plane = c("z", "s"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipord_+3A_wp">Wp</code>, <code id="ellipord_+3A_ws">Ws</code></td>
<td>
<p>pass-band and stop-band edges. For a low-pass or high-pass
filter, <code>Wp</code> and <code>Ws</code> are scalars. For a band-pass or
band-rejection filter, both are vectors of length 2. For a low-pass filter,
<code>Wp &lt; Ws</code>. For a high-pass filter, <code>Ws &gt; Wp</code>. For a band-pass
<code>(Ws[1] &lt; Wp[1] &lt; Wp[2] &lt; Ws[2])</code> or band-reject <code>(Wp[1] &lt; Ws[1]
&lt; Ws[2] &lt; Wp[2])</code> filter design, <code>Wp</code> gives the edges of the pass
band, and <code>Ws</code> gives the edges of the stop band. For digital filters,
frequencies are normalized to [0, 1], corresponding to the range [0, fs/2].
In case of an analog filter, all frequencies are specified in radians per
second.</p>
</td></tr>
<tr><td><code id="ellipord_+3A_rp">Rp</code></td>
<td>
<p>allowable decibels of ripple in the pass band.</p>
</td></tr>
<tr><td><code id="ellipord_+3A_rs">Rs</code></td>
<td>
<p>minimum attenuation in the stop band in dB.</p>
</td></tr>
<tr><td><code id="ellipord_+3A_plane">plane</code></td>
<td>
<p>&quot;z&quot; for a digital filter or &quot;s&quot; for an analog filter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code><a href="#topic+FilterSpecs">FilterSpecs</a></code> with the following list
elements:
</p>

<dl>
<dt>n</dt><dd><p>filter order</p>
</dd>
<dt>Wc</dt><dd><p>cutoff frequency</p>
</dd>
<dt>type</dt><dd><p>filter type, one of <code>"low"</code>, <code>"high"</code>, <code>"stop"</code>,
or <code>"pass"</code>.</p>
</dd>
<dt>Rp</dt><dd><p>dB of passband ripple.</p>
</dd>
<dt>Rs</dt><dd><p>dB of stopband ripple.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Paulo Neis, <a href="mailto:p_neis@yahoo.com.br">p_neis@yahoo.com.br</a>,<br />
adapted by Charles Praplan.<br />
Conversion to R by Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buttord">buttord</a></code>, <code><a href="#topic+cheb1ord">cheb1ord</a></code>,
<code><a href="#topic+cheb2ord">cheb2ord</a></code>, <code><a href="#topic+ellip">ellip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- 10000
spec &lt;- ellipord(1000/(fs/2), 1200/(fs/2), 0.5, 29)
ef &lt;- ellip(spec)
hf &lt;- freqz(ef, fs = fs)
plot(c(0, 1000, 1000, 0, 0), c(0, 0, -0.5, -0.5, 0),
     type = "l", xlab = "Frequency (Hz)", ylab = "Attenuation (dB)",
     col = "red", ylim = c(-35,0), xlim = c(0,2000))
lines(c(5000, 1200, 1200, 5000, 5000), c(-1000, -1000, -29, -29, -1000),
      col = "red")
lines(hf$w, 20*log10(abs(hf$h)))

</code></pre>

<hr>
<h2 id='fftconv'>FFT-based convolution</h2><span id='topic+fftconv'></span>

<h3>Description</h3>

<p>Convolve two vectors using the FFT for computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fftconv(x, y, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftconv_+3A_x">x</code>, <code id="fftconv_+3A_y">y</code></td>
<td>
<p>input vectors.</p>
</td></tr>
<tr><td><code id="fftconv_+3A_n">n</code></td>
<td>
<p>FFT length, specified as a positive integer. The FFT size must be an
even power of 2 and must be greater than or equal to the length of
<code>filt</code>. If the specified <code>n</code> does not meet these criteria, it is
automatically adjusted to the nearest value that does. If <code>n = NULL</code>
(default), then the overlap-add method is not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation uses the FFT by calling the function <code>fftfilt</code>. If the
optional argument <code>n</code> is specified, an <code>n</code>-point overlap-add FFT is
used.
</p>


<h3>Value</h3>

<p>Convoluted signal, specified as a a vector of length equal to
<code>length (x) + length (y) - 1</code>. If <code>x</code> and <code>y</code> are the
coefficient vectors of two polynomials, the returned value is the
coefficient vector of the product polynomial.
</p>


<h3>Author(s)</h3>

<p>Kurt Hornik, <a href="mailto:Kurt.Hornik@wu-wien.ac.at">Kurt.Hornik@wu-wien.ac.at</a>,<br />
adapted by John W. Eaton.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conv">conv</a></code>, <code><a href="#topic+conv2">conv2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
u &lt;- rep(1L, 3)
v &lt;- c(1, 1, 0, 0, 0, 1, 1)
w1 &lt;- conv(u, v)              # time-domain convolution
w2 &lt;- fftconv(u, v)           # frequency domain convolution
all.equal(w1, w2)             # same results

</code></pre>

<hr>
<h2 id='fftfilt'>FFT-based FIR filtering</h2><span id='topic+fftfilt'></span><span id='topic+fftfilt.default'></span><span id='topic+fftfilt.Ma'></span>

<h3>Description</h3>

<p>FFT-based FIR filtering using the overlap-add method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fftfilt(b, x, n = NULL)

## Default S3 method:
fftfilt(b, x, n = NULL)

## S3 method for class 'Ma'
fftfilt(b, x, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftfilt_+3A_b">b</code></td>
<td>
<p>moving average (Ma) coefficients of a FIR filter, specified as a
vector.</p>
</td></tr>
<tr><td><code id="fftfilt_+3A_x">x</code></td>
<td>
<p>the input signal to be filtered. If x is a matrix, its columns are
filtered.</p>
</td></tr>
<tr><td><code id="fftfilt_+3A_n">n</code></td>
<td>
<p>FFT length, specified as a positive integer. The FFT size must be an
even power of 2 and must be greater than or equal to the length of
<code>filt</code>. If the specified <code>n</code> does not meet these criteria, it is
automatically adjusted to the nearest value that does. If <code>n = NULL</code>
(default), then the overlap-add method is not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines two important techniques to speed up filtering of long
signals, the overlap-add method, and FFT convolution. The overlap-add method
is used to break long signals into smaller segments for easier processing or
preventing memory problems. FFT convolution uses the overlap-add method
together with the Fast Fourier Transform, allowing signals to be convolved by
multiplying their frequency spectra. For filter kernels longer than about 64
points, FFT convolution is faster than standard convolution, while producing
exactly the same result.
</p>
<p>The overlap-add technique works as follows. When an <code>N</code> length signal is
convolved with a filter kernel of length <code>M</code>, the output signal is
<code>N + M - 1</code> samples long, i.e., the signal is expanded 'to the right'.
The signal is then broken into <code>k</code> smaller segments, and the convolution
of each segment with the f kernel will have a result of length <code>N / k +
M -1</code>. The individual segments are then added together. The rightmost <code>M
- 1</code> samples overlap with the leftmost <code>M - 1</code> samples of the next
segment. The overlap-add method produces exactly the same output signal as
direct convolution.
</p>
<p>FFT convolution uses the principle that multiplication in the frequency
domain corresponds to convolution in the time domain. The input signal is
transformed into the frequency domain using the FFT, multiplied by the
frequency response of the filter, and then transformed back into the time
domain using the inverse FFT. With FFT convolution, the filter kernel can be
made very long, with very little penalty in execution time.
</p>


<h3>Value</h3>

<p>The filtered signal, returned as a vector or matrix with the same
dimensions as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Kurt Hornik, <a href="mailto:Kurt.Hornik@wu-wien.ac.at">Kurt.Hornik@wu-wien.ac.at</a>,<br />
adapted by John W. Eaton.<br />
Conversion to R by Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Overlap-add_method">https://en.wikipedia.org/wiki/Overlap-add_method</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter">filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- seq(0, 1, len = 10000)                          # 1 second sample
x &lt;- sin(2* pi * t * 2.3) + 0.25 * rnorm(length(t))  # 2.3 Hz sinusoid+noise
filt &lt;- rep(0.1, 10)                                 # filter kernel
y1 &lt;- filter(filt, 1, x)                             # use normal convolution
y2 &lt;- fftfilt(filt, x)                               # FFT convolution
plot(t, x, type = "l")
lines(t, y1, col = "red")
lines(t, y2, col = "blue")

## use 'filter' with different classes
t &lt;- seq(0, 1, len = 10000)                          # 1 second sample
x &lt;- sin(2* pi * t * 2.3) + 0.25 * rnorm(length(t))  # 2.3 Hz sinusoid+noise
ma &lt;- Ma(rep(0.1, 10))                               # filter kernel
y1 &lt;- filter(ma, x)                                  # convulution filter
y2 &lt;- fftfilt(ma, x)                                 # FFT filter
all.equal(y1, y2)                                    # same result

</code></pre>

<hr>
<h2 id='fftshift'>Zero-frequency shift</h2><span id='topic+fftshift'></span>

<h3>Description</h3>

<p>Perform a shift in order to move the frequency 0 to the center of the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fftshift(x, MARGIN = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftshift_+3A_x">x</code></td>
<td>
<p>input data, specified as a vector or matrix.</p>
</td></tr>
<tr><td><code id="fftshift_+3A_margin">MARGIN</code></td>
<td>
<p>dimension to operate along, 1 = row, 2 = columns (default).
Specifying <code>MARGIN = c(1, 2)</code> centers along both rows and columns.
Ignored when <code>x</code> is a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a vector of <code>N</code> elements corresponding to <code>N</code> time
samples spaced by <code>dt</code>, then <code>fftshift(x)</code> corresponds to
frequencies <code>f = c(-seq(ceiling((N-1)/2), 1, -1), 0, (1:floor((N-1)/2)))
* df</code>, where <code>df = 1 / (N * dt)</code>. In other words, the left and right
halves of <code>x</code> are swapped.
</p>
<p>If <code>x</code> is a matrix, then <code>fftshift</code> operates on the rows or columns
of <code>x</code>, according to the <code>MARGIN</code> argument, i.e. it swaps the the
upper and lower halves of the matrix <code>(MARGIN = 1)</code>, or the left and
right halves of the matrix <code>(MARGIN = 2)</code>. Specifying <code>MARGIN =
c(1, 2)</code> swaps along both dimensions, i.e., swaps the first quadrant with the
fourth, and the second with the third.
</p>


<h3>Value</h3>

<p>vector or matrix with centered frequency.
</p>


<h3>Author(s)</h3>

<p>Vincent Cautaerts, <a href="mailto:vincent@comf5.comm.eng.osaka-u.ac.jp">vincent@comf5.comm.eng.osaka-u.ac.jp</a>,<br />
adapted by John W. Eaton.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code>ifftshift</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Xeven &lt;- 1:6
ev &lt;- fftshift(Xeven)   # returns 4 5 6 1 2 3

Xodd &lt;- 1:7
odd &lt;- fftshift(Xodd)   # returns 5 6 7 1 2 3 4

fs &lt;- 100                      # sampling frequency
t &lt;- seq(0, 10 - 1/fs, 1/fs)   # time vector
S &lt;- cos(2 * pi * 15 * t)
n &lt;- length(S)
X &lt;- fft(S)
f &lt;- (0:(n - 1)) * (fs / n);   # frequency range
power &lt;- abs(X)^2 / n          # power
plot(f, power, type="l")
Y &lt;- fftshift(X)
fsh &lt;- ((-n/2):(n/2-1)) * (fs / n)  # zero-centered frequency range
powersh &lt;- abs(Y)^2 / n             # zero-centered power
plot(fsh, powersh, type = "l")

</code></pre>

<hr>
<h2 id='fht'>Fast Hartley Transform</h2><span id='topic+fht'></span><span id='topic+ifht'></span>

<h3>Description</h3>

<p>Compute the (inverse) Hartley transform of a signal using FFT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fht(x, n = NROW(x))

ifht(x, n = NROW(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fht_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="fht_+3A_n">n</code></td>
<td>
<p>transform length, specified as a positive integer scalar. Default:
<code>NROW(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hartley transform is an integral transform closely related to the Fourier
transform, but which transforms real-valued functions to real-valued
functions. Compared to the Fourier transform, the Hartley transform has
the advantages of transforming real functions to real functions (as opposed
to requiring complex numbers) and of being its own inverse [1].
</p>
<p>This function implements the Hartley transform by calculating the difference
between the real- and imaginary-valued parts of the Fourier-transformed
signal [1]. The forward and inverse Hartley transforms are the same (except
for a scale factor of 1/N for the inverse Hartley transform), but implemented
using different functions.
</p>


<h3>Value</h3>

<p>(inverse) Hartley transform, returned as a vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Muthiah Annamalai, <a href="mailto:muthiah.annamalai@uta.edu">muthiah.annamalai@uta.edu</a>.\
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] <a href="https://en.wikipedia.org/wiki/Hartley_transform">https://en.wikipedia.org/wiki/Hartley_transform</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fft">fft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># FHT of a 2.5 Hz signal with offset
fs &lt;- 100
secs &lt;- 10
freq &lt;- 2.5
t &lt;- seq(0, secs - 1 / fs, 1 / fs)
x &lt;- 5 * t + 50 * cos(freq * 2 * pi * t)
X &lt;- fht(x)
op &lt;- par(mfrow = c(2, 1))
plot(t, x, type = "l", xlab = "", ylab = "", main = "Signal")
f &lt;- seq(0, fs - (1 / fs), length.out = length(t))
to &lt;- which(f &gt;= 5)[1]
plot(f[1:to], X[1:to], type = "l", xlab = "", ylab = "",
     main = "Hartley Transform")
par(op)

</code></pre>

<hr>
<h2 id='filter'>Filter a signal</h2><span id='topic+filter'></span><span id='topic+filter.default'></span><span id='topic+filter.Arma'></span><span id='topic+filter.Ma'></span><span id='topic+filter.Sos'></span><span id='topic+filter.Zpg'></span><span id='topic+filter_zi.Zpg'></span>

<h3>Description</h3>

<p>Apply a 1-D digital filter compatible with 'Matlab' and 'Octave'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter(filt, ...)

## Default S3 method:
filter(filt, a, x, zi = NULL, ...)

## S3 method for class 'Arma'
filter(filt, x, ...)

## S3 method for class 'Ma'
filter(filt, x, ...)

## S3 method for class 'Sos'
filter(filt, x, ...)

## S3 method for class 'Zpg'
filter(filt, x, ...)

## S3 method for class 'Zpg'
filter(filt, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_+3A_filt">filt</code></td>
<td>
<p>For the default case, the moving-average coefficients of an ARMA
filter (normally called <code>b</code>), specified as a numeric or complex
vector. Generically, <code>filt</code> specifies an arbitrary filter operation.</p>
</td></tr>
<tr><td><code id="filter_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
<tr><td><code id="filter_+3A_a">a</code></td>
<td>
<p>the autoregressive (recursive) coefficients of an ARMA filter,
specified as a numeric or complex vector. If <code>a[1]</code> is not equal to 1,
then filter normalizes the filter coefficients by <code>a[1]</code>. Therefore,
<code>a[1]</code> must be nonzero.</p>
</td></tr>
<tr><td><code id="filter_+3A_x">x</code></td>
<td>
<p>the input signal to be filtered, specified as a numeric or complex
vector or matrix. If <code>x</code> is a matrix, each column is filtered.</p>
</td></tr>
<tr><td><code id="filter_+3A_zi">zi</code></td>
<td>
<p>If <code>zi</code> is provided, it is taken as the initial state of the
system and the final state is returned as zf. The state vector is a vector
or a matrix (depending on <code>x</code>) whose length or number of rows is equal
to the length of the longest coefficient vector <code>b</code> or <code>a</code> minus
one. If <code>zi</code> is not supplied (NULL), the initial state vector is set
to all zeros. Alternatively, <code>zi</code> may be the character string
<code>"zf"</code>, which specifies to return the final state vector even though
the initial state vector is set to all zeros. Default: NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The filter is a direct form II transposed implementation of the standard
linear time-invariant difference equation:

</p>
<pre>
  N                  M
 SUM a(k+1)y(n-k) + SUM b(k+1)x(n-k) = 0;   1 &lt;= n &lt;= length(x)
 k=0                k=0
</pre>
<p>where <code>N = length(a) - 1</code> and <code>M = length(b) - 1</code>.
</p>
<p>The initial and final conditions for filter delays can be used to filter data
in sections, especially if memory limitations are a consideration. See the
examples.
</p>


<h3>Value</h3>

<p>The filtered signal, of the same dimensions as the input signal. In
case the <code>zi</code> input argument was specified, a list with two elements
is returned containing the variables <code>y</code>, which represents the output
signal, and <code>zf</code>, which contains the final state vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter_zi">filter_zi</a></code>, <code><a href="#topic+sosfilt">sosfilt</a></code> (preferred because it
avoids numerical problems).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bf &lt;- butter(3, 0.1)                                 # 10 Hz low-pass filter
t &lt;- seq(0, 1, len = 100)                            # 1 second sample
x &lt;- sin(2* pi * t * 2.3) + 0.25 * rnorm(length(t))  # 2.3 Hz sinusoid+noise
z &lt;- filter(bf, x)                                   # apply filter
plot(t, x, type = "l")
lines(t, z, col = "red")

## specify initial conditions
## from Python scipy.signal.lfilter() documentation
t &lt;- seq(-1, 1, length.out =  201)
x &lt;- (sin(2 * pi * 0.75 * t * (1 - t) + 2.1)
      + 0.1 * sin(2 * pi * 1.25 * t + 1)
      + 0.18 * cos(2 * pi * 3.85 * t))
h &lt;- butter(3, 0.05)
lab &lt;- max(length(h$b), length(h$a)) - 1
zi &lt;- filtic(h$b, h$a, rep(1, lab), rep(1, lab))
z1 &lt;- filter(h, x)
z2 &lt;- filter(h, x, zi * x[1])
plot(t, x, type = "l")
lines(t, z1, col = "red")
lines(t, z2$y, col = "green")
legend("bottomright", legend = c("Original signal",
        "Filtered without initial conditions",
        "Filtered with initial conditions"),
       lty = 1, col = c("black", "red", "green"))

</code></pre>

<hr>
<h2 id='filter_zi'>Filter initial conditions</h2><span id='topic+filter_zi'></span><span id='topic+filter_zi.default'></span><span id='topic+filter_zi.Arma'></span><span id='topic+filter_zi.Ma'></span><span id='topic+filter_zi.Sos'></span>

<h3>Description</h3>

<p>Construct initial conditions for a filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_zi(filt, ...)

## Default S3 method:
filter_zi(filt, a, ...)

## S3 method for class 'Arma'
filter_zi(filt, ...)

## S3 method for class 'Ma'
filter_zi(filt, ...)

## S3 method for class 'Sos'
filter_zi(filt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_zi_+3A_filt">filt</code></td>
<td>
<p>For the default case, the moving-average coefficients of an ARMA
filter (normally called <code>b</code>), specified as a vector.</p>
</td></tr>
<tr><td><code id="filter_zi_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
<tr><td><code id="filter_zi_+3A_a">a</code></td>
<td>
<p>the autoregressive (recursive) coefficients of an ARMA filter,
specified as a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes an initial state for the filter function that
corresponds to the steady state of the step response. In other words, it
finds the initial condition for which the response to an input of all ones is
a constant. Therefore, the results returned by this function can also be
obtained using the function <code><a href="#topic+filtic">filtic</a></code> by setting <code>x</code> and
<code>y</code> to all 1s (see the examples).
</p>
<p>A typical use of this function is to set the initial state so that the output
of the filter starts at the same value as the first element of the signal to
be filtered.
</p>


<h3>Value</h3>

<p>The initial state for the filter, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>,
converted to R from Python scipy.signal.lfilter_zi.
</p>


<h3>References</h3>

<p>Gustafsson, F. (1996). Determining the initial states in
forward-backward filtering. IEEE Transactions on Signal Processing, 44(4),
988 - 992.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filtic">filtic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## taken from Python scipy.signal.lfilter_zi documentation

h &lt;- butter(5, 0.25)
zi &lt;- filter_zi(h)
y &lt;- filter(h, rep(1, 10), zi)
## output is all 1, as expected.
y2 &lt;- filter(h, rep(1, 10))
## if the zi argument is not given, the output
## does not return the final conditions

x &lt;- c(0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0)
y &lt;- filter(h, x, zi = zi*x[1])
## Note that the zi argument to filter was computed using
## filter_zi and scaled by x[1]. Then the output y has no
## transient until the input drops from 0.5 to 0.0.

## obtain the same results with filtic
lab &lt;- max(length(h$b), length(h$a)) - 1
ic &lt;- filtic(h, rep(1, lab), rep(1, lab))
all.equal(zi, ic)

</code></pre>

<hr>
<h2 id='filter.sgolayFilter'>Savitzky-Golay filtering</h2><span id='topic+filter.sgolayFilter'></span><span id='topic+sgolayfilt'></span>

<h3>Description</h3>

<p>Filter a signal with a Savitzky-Golay FIR filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgolayFilter'
filter(filt, x, ...)

sgolayfilt(x, p = 3, n = p + 3 - p%%2, m = 0, ts = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.sgolayFilter_+3A_filt">filt</code></td>
<td>
<p>Filter characteristics, usually the result of a call to
<code>sgolay</code></p>
</td></tr>
<tr><td><code id="filter.sgolayFilter_+3A_x">x</code></td>
<td>
<p>the input signal to be filtered, specified as a vector or as a
matrix. If <code>x</code> is a matrix, each column is filtered.</p>
</td></tr>
<tr><td><code id="filter.sgolayFilter_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored)</p>
</td></tr>
<tr><td><code id="filter.sgolayFilter_+3A_p">p</code></td>
<td>
<p>Polynomial filter order; must be smaller than <code>n</code>.</p>
</td></tr>
<tr><td><code id="filter.sgolayFilter_+3A_n">n</code></td>
<td>
<p>Filter length; must a an odd positive integer.</p>
</td></tr>
<tr><td><code id="filter.sgolayFilter_+3A_m">m</code></td>
<td>
<p>Return the m-th derivative of the filter coefficients. Default: 0</p>
</td></tr>
<tr><td><code id="filter.sgolayFilter_+3A_ts">ts</code></td>
<td>
<p>Scaling factor. Default: 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Savitzky-Golay smoothing filters are typically used to &quot;smooth out&quot; a noisy
signal whose frequency span (without noise) is large. They are also called
digital smoothing polynomial filters or least-squares smoothing filters.
Savitzky-Golay filters perform better in some applications than standard
averaging FIR filters, which tend to filter high-frequency content along with
the noise. Savitzky-Golay filters are more effective at preserving high
frequency signal components but less successful at rejecting noise.
</p>
<p>Savitzky-Golay filters are optimal in the sense that they minimize the
least-squares error in fitting a polynomial to frames of noisy data.
</p>


<h3>Value</h3>

<p>The filtered signal, of the same dimensions as the input signal.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sgolay">sgolay</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare a 5 sample averager, an order-5 butterworth lowpass
# filter (cutoff 1/3) and sgolayfilt(x, 3, 5), the best cubic
# estimated from 5 points.
bf &lt;- butter(5, 1/3)
x &lt;- c(rep(0, 15), rep(10, 10), rep(0, 15))
sg &lt;- sgolayfilt(x)
plot(sg, type="l", xlab = "", ylab = "")
lines(filtfilt(rep(1, 5) / 5, 1, x), col = "red") # averaging filter
lines(filtfilt(bf, x), col = "blue")              # butterworth
points(x, pch = "x")                              # original data
legend("topleft", c("sgolay (3,5)", "5 sample average", "order 5
Butterworth", "original data"), lty=c(1, 1, 1, NA),
pch = c(NA, NA, NA, "x"), col = c(1, "red", "blue", 1))

</code></pre>

<hr>
<h2 id='filter2'>2-D digital filter</h2><span id='topic+filter2'></span>

<h3>Description</h3>

<p>Apply a 2-D digital filter to the data in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter2(h, x, shape = c("same", "full", "valid"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter2_+3A_h">h</code></td>
<td>
<p>transfer function, specified as a matrix.</p>
</td></tr>
<tr><td><code id="filter2_+3A_x">x</code></td>
<td>
<p>numeric matrix containing the input signal to be filtered.</p>
</td></tr>
<tr><td><code id="filter2_+3A_shape">shape</code></td>
<td>
<p>Subsection of convolution, partially matched to:
</p>

<dl>
<dt>&quot;same&quot;</dt><dd><p>Return the central part of the filtered data; same size as
<code>x</code> (Default)</p>
</dd>
<dt>&quot;full&quot;</dt><dd><p>Return the full 2-D filtered data, with zero-padding on all
sides before filtering</p>
</dd>
<dt>&quot;valid&quot;</dt><dd><p>Return only the parts which do not include zero-padded
edges.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>filter2</code> function filters data by taking the 2-D convolution of the
input <code>x</code> and the coefficient matrix <code>h</code> rotated 180 degrees. More
specifically, <code>filter2(h, x, shape)</code> is equivalent to <code>conv2(x,
rot90(h, 2), shape)</code>.
</p>


<h3>Value</h3>

<p>The filtered signal, returned as a matrix
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle.
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conv2">conv2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>op &lt;- par(mfcol = c(1, 2))
x &lt;- seq(-10, 10, length.out = 30)
y &lt;- x
f &lt;- function(x, y) { r &lt;- sqrt(x^2+y^2); 10 * sin(r)/r }
z &lt;- outer(x, y, f)
z[is.na(z)] &lt;- 1
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue")
title( main = "Original")

h &lt;- matrix(c(1, -2, 1, -2, 3, -2, 1, -2, 1), 3, 3)
zf &lt;-filter2(h, z, 'same')
persp(x, y, zf, theta = 30, phi = 30, expand = 0.5, col = "lightgreen")
title( main = "Filtered")
par(op)

</code></pre>

<hr>
<h2 id='FilterSpecs'>Filter specifications</h2><span id='topic+FilterSpecs'></span>

<h3>Description</h3>

<p>Filter specifications, including order, frequency cutoff, type, and
possibly others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterSpecs(n, Wc, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterSpecs_+3A_n">n</code></td>
<td>
<p>filter order.</p>
</td></tr>
<tr><td><code id="FilterSpecs_+3A_wc">Wc</code></td>
<td>
<p>cutoff frequency.</p>
</td></tr>
<tr><td><code id="FilterSpecs_+3A_type">type</code></td>
<td>
<p>filter type, normally one of <code>"low"</code>, <code>"high"</code>,
<code>"stop"</code>, or <code>"pass"</code>.</p>
</td></tr>
<tr><td><code id="FilterSpecs_+3A_...">...</code></td>
<td>
<p>other filter description characteristics, possibly including Rp
for dB of pass band ripple or Rs for dB of stop band ripple, depending on
filter type (Butterworth, Chebyshev, etc.).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>'FilterSpecs'</code> with the following list elements
(repeats of the input arguments):
</p>

<dl>
<dt>n</dt><dd><p>filter order</p>
</dd>
<dt>Wc</dt><dd><p>cutoff frequency</p>
</dd>
<dt>type</dt><dd><p>filter type, normally one of <code>"low"</code>, <code>"high"</code>,
<code>"stop"</code>, or <code>"pass"</code>.</p>
</dd>
<dt>...</dt><dd><p>other filter description characteristics, possibly including Rp
for dB of pass band ripple or Rs for dB of stop band ripple, depending on
filter type (Butterworth, Chebyshev, etc.).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tom Short, <a href="mailto:tshort@eprisolutions.com">tshort@eprisolutions.com</a>,<br />
renamed and adapted by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+butter">butter</a></code> and
<code><a href="#topic+buttord">buttord</a></code>, <code><a href="#topic+cheby1">cheby1</a></code> and <code><a href="#topic+cheb1ord">cheb1ord</a></code>,
<code><a href="#topic+ellip">ellip</a></code> and <code><a href="#topic+ellipord">ellipord</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filt &lt;- FilterSpecs(3, 0.1, "low")

</code></pre>

<hr>
<h2 id='filtfilt'>Zero-phase digital filtering</h2><span id='topic+filtfilt'></span><span id='topic+filtfilt.default'></span><span id='topic+filtfilt.Arma'></span><span id='topic+filtfilt.Ma'></span><span id='topic+filtfilt.Sos'></span><span id='topic+filtfilt.Zpg'></span>

<h3>Description</h3>

<p>Forward and reverse filter the signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filtfilt(filt, ...)

## Default S3 method:
filtfilt(filt, a, x, ...)

## S3 method for class 'Arma'
filtfilt(filt, x, ...)

## S3 method for class 'Ma'
filtfilt(filt, x, ...)

## S3 method for class 'Sos'
filtfilt(filt, x, ...)

## S3 method for class 'Zpg'
filtfilt(filt, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filtfilt_+3A_filt">filt</code></td>
<td>
<p>For the default case, the moving-average coefficients of an ARMA
filter (normally called <code>b</code>). Generically, <code>filt</code> specifies an
arbitrary filter operation.</p>
</td></tr>
<tr><td><code id="filtfilt_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
<tr><td><code id="filtfilt_+3A_a">a</code></td>
<td>
<p>the autoregressive (recursive) coefficients of an ARMA filter,
specified as a vector. If <code>a[1]</code> is not equal to 1, then filter
normalizes the filter coefficients by <code>a[1]</code>. Therefore, <code>a[1]</code>
must be nonzero.</p>
</td></tr>
<tr><td><code id="filtfilt_+3A_x">x</code></td>
<td>
<p>the input signal to be filtered. If <code>x</code> is a matrix, all
colums are filtered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Forward and reverse filtering the signal corrects for phase distortion
introduced by a one-pass filter, though it does square the magnitude response
in the process. That’s the theory at least. In practice the phase correction
is not perfect, and magnitude response is distorted, particularly in the stop
band.
</p>
<p>Before filtering the input signal is extended with a reflected part of both
ends of the signal. The length of this extension is 3 times the filter order.
The Gustafsson [1] method is then used to specify the initial conditions used
to further handle the edges of the signal.
</p>


<h3>Value</h3>

<p>The filtered signal, normally of the same length of the input signal
<code>x</code>, returned as a vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br /> Francesco Potortì,
<a href="mailto:pot@gnu.org">pot@gnu.org</a>,<br /> Luca Citi, <a href="mailto:lciti@essex.ac.uk">lciti@essex.ac.uk</a>.<br />
Conversion to R and adapted by Geert van Boxtel
<a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] Gustafsson, F. (1996). Determining the initial states in
forward-backward filtering. IEEE Transactions on Signal Processing, 44(4),
988 - 992.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+filter_zi">filter_zi</a></code>, <code><a href="#topic+Arma">Arma</a></code>,
<code><a href="#topic+Sos">Sos</a></code>, <code><a href="#topic+Zpg">Zpg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bf &lt;- butter(3, 0.1)                                 # 10 Hz low-pass filter
t &lt;- seq(0, 1, len = 100)                            # 1 second sample
x &lt;- sin(2* pi * t * 2.3) + 0.25 * rnorm(length(t))  # 2.3 Hz sinusoid+noise
z &lt;- filter(bf, x)                                   # apply filter
plot(t, x, type = "l")
lines(t, z, col = "red")
zz &lt;- filtfilt(bf, x)
lines(t, zz, col="blue")
legend("bottomleft", legend = c("original", "filter", "filtfilt"), lty = 1,
 col = c("black", "red", "blue"))

</code></pre>

<hr>
<h2 id='filtic'>Filter Initial Conditions</h2><span id='topic+filtic'></span><span id='topic+filtic.default'></span><span id='topic+filtic.Arma'></span><span id='topic+filtic.Ma'></span><span id='topic+filtic.Sos'></span><span id='topic+filtic.Zpg'></span>

<h3>Description</h3>

<p>Compute the initial conditions for a filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filtic(filt, ...)

## Default S3 method:
filtic(filt, a, y, x = 0, ...)

## S3 method for class 'Arma'
filtic(filt, y, x = 0, ...)

## S3 method for class 'Ma'
filtic(filt, y, x = 0, ...)

## S3 method for class 'Sos'
filtic(filt, y, x = 0, ...)

## S3 method for class 'Zpg'
filtic(filt, y, x = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filtic_+3A_filt">filt</code></td>
<td>
<p>For the default case, the moving-average coefficients of an ARMA
filter (normally called <code>b</code>), specified as a vector. Generically,
<code>filt</code> specifies an arbitrary filter operation.</p>
</td></tr>
<tr><td><code id="filtic_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
<tr><td><code id="filtic_+3A_a">a</code></td>
<td>
<p>the autoregressive (recursive) coefficients of an ARMA filter.</p>
</td></tr>
<tr><td><code id="filtic_+3A_y">y</code></td>
<td>
<p>output vector, with the most recent values first.</p>
</td></tr>
<tr><td><code id="filtic_+3A_x">x</code></td>
<td>
<p>input vector, with the most recent values first. Default: 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the same values that would be obtained from the
function <code>filter</code> given past inputs <code>x</code> and outputs <code>y</code>.
</p>
<p>The vectors <code>x</code> and <code>y</code> contain the most recent inputs and outputs
respectively, with the newest values first:
</p>
<p><code>x = c(x(-1), x(-2), ... x(-nb)); nb = length(b)-1</code><br />
<code>y = c(y(-1), y(-2), ... y(-na)); na = length(a)-a</code>
</p>
<p>If <code>length(x) &lt; nb</code> then it is zero padded. If <code>length(y) &lt; na</code>
then it is zero padded.
</p>


<h3>Value</h3>

<p>Initial conditions for filter specified by <code>filt</code>, input vector
<code>x</code>, and output vector <code>y</code>, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>David Billinghurst, <a href="mailto:David.Billinghurst@riotinto.com">David.Billinghurst@riotinto.com</a>.<br />
Adapted and converted to R by Geert van Boxtel
<a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+sosfilt">sosfilt</a></code>, <code><a href="#topic+filtfilt">filtfilt</a></code>,
<code><a href="#topic+filter_zi">filter_zi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple low pass filter
b &lt;- c(0.25, 0.25)
a &lt;- c(1.0, -0.5)
ic &lt;- filtic(b, a, 1, 1)

## Simple high pass filter
b &lt;- c(0.25, -0.25)
a &lt;- c(1.0, 0.5)
ic &lt;- filtic(b, a, 0, 1)

## Example from Python scipy.signal.lfilter() documentation
t &lt;- seq(-1, 1, length.out =  201)
x &lt;- (sin(2 * pi * 0.75 * t * (1 - t) + 2.1)
      + 0.1 * sin(2 * pi * 1.25 * t + 1)
      + 0.18 * cos(2 * pi * 3.85 * t))
h &lt;- butter(3, 0.05)
l &lt;- max(length(h$b), length(h$a)) - 1
zi &lt;- filtic(h, rep(1, l), rep(1, l))
z &lt;- filter(h, x, zi * x[1])

</code></pre>

<hr>
<h2 id='findpeaks'>Find local extrema</h2><span id='topic+findpeaks'></span>

<h3>Description</h3>

<p>Return peak values and their locations of the vector <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findpeaks(
  data,
  MinPeakHeight = .Machine$double.eps,
  MinPeakDistance = 1,
  MinPeakWidth = 1,
  MaxPeakWidth = Inf,
  DoubleSided = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findpeaks_+3A_data">data</code></td>
<td>
<p>the data, expected to be a vector or one-dimensional array.</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_minpeakheight">MinPeakHeight</code></td>
<td>
<p>Minimum peak height (non-negative scalar). Only peaks
that exceed this value will be returned. For data taking positive and
negative values use the option <code>DoubleSided</code>. Default:
<code>.Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_minpeakdistance">MinPeakDistance</code></td>
<td>
<p>Minimum separation between peaks (positive integer).
Peaks separated by less than this distance are considered a single peak.
This distance is also used to fit a second order polynomial to the peaks to
estimate their width, therefore it acts as a smoothing parameter. The
neighborhood size is equal to the value of <code>MinPeakDistance</code>. Default:
1.</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_minpeakwidth">MinPeakWidth</code></td>
<td>
<p>Minimum width of peaks (positive integer). The width of
the peaks is estimated using a parabola fitted to the neighborhood of each
peak. The width is calculated with the formula <code class="reqn">a * (width - x0)^{2} =
1</code>, where a is the the concavity of the parabola and x0 its vertex.
Default: 1.</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_maxpeakwidth">MaxPeakWidth</code></td>
<td>
<p>Maximum width of peaks (positive integer). Default:
<code>Inf</code>.</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_doublesided">DoubleSided</code></td>
<td>
<p>Tells the function that data takes positive and negative
values. The baseline for the peaks is taken as the mean value of the
function. This is equivalent as passing the absolute value of the data
after removing the mean. Default: FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Peaks of a positive array of <code>data</code> are defined as local maxima. For
double-sided data, they are maxima of the positive part and minima of the
negative part. <code>data</code> is expected to be a one-dimensional vector.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>pks</dt><dd><p>The value of data at the peaks.</p>
</dd>
<dt>loc</dt><dd><p>The index indicating the position of the peaks.</p>
</dd>
<dt>parabol</dt><dd><p>A list containing the parabola fitted to each returned peak.
The list has two fields, <code>x</code> and <code>pp</code>. The field <code>pp</code>
contains the coefficients of the 2nd degree polynomial and <code>x</code> the
extrema of the interval where it was fitted.</p>
</dd>
<dt>height</dt><dd><p>The estimated height of the returned peaks (in units of
data).</p>
</dd>
<dt>baseline</dt><dd><p>The height at which the roots of the returned peaks were
calculated (in units of data).</p>
</dd>
<dt>roots</dt><dd><p>The abscissa values (in index units) at which the parabola
fitted to each of the returned peaks realizes its width as defined below.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Juan Pablo Carbajal, <a href="mailto:carbajal@ifi.uzh.ch">carbajal@ifi.uzh.ch</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### demo 1
t &lt;- 2 * pi * seq(0, 1,length = 1024)
y &lt;- sin(3.14 * t) + 0.5 * cos(6.09 * t) +
     0.1 * sin(10.11 * t + 1 / 6) + 0.1 * sin(15.3 * t + 1 / 3)

data1 &lt;- abs(y) # Positive values
peaks1 &lt;- findpeaks(data1)

data2 &lt;- y # Double-sided
peaks2 &lt;- findpeaks(data2, DoubleSided = TRUE)
peaks3 &lt;- findpeaks (data2, DoubleSided = TRUE, MinPeakHeight = 0.5)

op &lt;- par(mfrow=c(1,2))
plot(t, data1, type="l", xlab="", ylab="")
points(t[peaks1$loc], peaks1$pks, col = "red", pch = 1)
plot(t, data2, type = "l", xlab = "", ylab = "")
points(t[peaks2$loc], peaks2$pks, col = "red", pch = 1)
points(t[peaks3$loc], peaks3$pks, col = "red", pch = 4)
legend ("topleft", "0: &gt;2*sd, x: &gt;0.5", bty = "n",
        text.col = "red")
par (op)
title("Finding the peaks of smooth data is not a big deal")

## demo 2
t &lt;- 2 * pi * seq(0, 1, length = 1024)
y &lt;- sin(3.14 * t) + 0.5 * cos(6.09 * t) + 0.1 *
     sin(10.11 * t + 1 / 6) + 0.1 * sin(15.3 * t + 1 / 3)
data &lt;- abs(y + 0.1*rnorm(length(y),1))   # Positive values + noise
peaks1 &lt;- findpeaks(data, MinPeakHeight=1)
dt &lt;- t[2]-t[1]
peaks2 &lt;- findpeaks(data, MinPeakHeight=1, MinPeakDistance=round(0.5/dt))
op &lt;- par(mfrow=c(1,2))
plot(t, data, type="l", xlab="", ylab="")
points (t[peaks1$loc],peaks1$pks,col="red", pch=1)
plot(t, data, type="l", xlab="", ylab="")
points (t[peaks2$loc],peaks2$pks,col="red", pch=1)
par (op)
title(paste("Noisy data may need tuning of the parameters.\n",
            "In the 2nd example, MinPeakDistance is used\n",
            "as a smoother of the peaks"))

</code></pre>

<hr>
<h2 id='fir1'>Window-based FIR filter design</h2><span id='topic+fir1'></span>

<h3>Description</h3>

<p>FIR filter coefficients for a filter with the given order and frequency
cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fir1(
  n,
  w,
  type = c("low", "high", "stop", "pass", "DC-0", "DC-1"),
  window = hamming(n + 1),
  scale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fir1_+3A_n">n</code></td>
<td>
<p>filter order (1 less than the length of the filter).</p>
</td></tr>
<tr><td><code id="fir1_+3A_w">w</code></td>
<td>
<p>band edges, strictly increasing vector in the range c(0, 1), where 1
is the Nyquist frequency. A scalar for highpass or lowpass filters, a
vector pair for bandpass or bandstop, or a vector for an alternating
pass/stop filter.</p>
</td></tr>
<tr><td><code id="fir1_+3A_type">type</code></td>
<td>
<p>character specifying filter type, one of <code>"low"</code> for a
low-pass filter, <code>"high"</code> for a high-pass filter, <code>"stop"</code> for a
stop-band (band-reject) filter, <code>"pass"</code> for a pass-band filter,
<code>"DC-0"</code> for a bandpass as the first band of a multiband filter, or
<code>"DC-1"</code> for a bandstop as the first band of a multiband filter.
Default: <code>"low"</code>.</p>
</td></tr>
<tr><td><code id="fir1_+3A_window">window</code></td>
<td>
<p>smoothing window. The returned filter is the same shape as the
smoothing window. Default: <code>hamming(n + 1)</code>.</p>
</td></tr>
<tr><td><code id="fir1_+3A_scale">scale</code></td>
<td>
<p>whether to normalize or not. Use <code>TRUE</code> (default) or
<code>"scale"</code> to set the magnitude of the center of the first passband to
1, and <code>FALSE</code> or <code>"noscale"</code> to not normalize.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The FIR filter coefficients, a vector of length <code>n + 1</code>, of
class <code>Ma</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,
Conversion to R Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Fir_filter">https://en.wikipedia.org/wiki/Fir_filter</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ma">Ma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+fftfilt">fftfilt</a></code>,
<code><a href="#topic+fir2">fir2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freqz(fir1(40, 0.3))
freqz(fir1(10, c(0.3, 0.5), "stop"))
freqz(fir1(10, c(0.3, 0.5), "pass"))

</code></pre>

<hr>
<h2 id='fir2'>Frequency sampling-based FIR filter design</h2><span id='topic+fir2'></span>

<h3>Description</h3>

<p>Produce a FIR filter with arbitrary frequency response over frequency bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fir2(n, f, m, grid_n = 512, ramp_n = NULL, window = hamming(n + 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fir2_+3A_n">n</code></td>
<td>
<p>filter order (1 less than the length of the filter).</p>
</td></tr>
<tr><td><code id="fir2_+3A_f">f</code></td>
<td>
<p>vector of frequency points in the range from 0 to 1, where 1
corresponds to the Nyquist frequency. The first point of <code>f</code> must be 0
and the last point must be 1. <code>f</code> must be sorted in increasing order.
Duplicate frequency points are allowed and are treated as steps in the
frequency response.</p>
</td></tr>
<tr><td><code id="fir2_+3A_m">m</code></td>
<td>
<p>vector of the same length as <code>f</code> containing the desired
magnitude response at each of the points specified in <code>f</code>.</p>
</td></tr>
<tr><td><code id="fir2_+3A_grid_n">grid_n</code></td>
<td>
<p>length of ideal frequency response function. <code>grid_n</code>
defaults to 512, and should be a power of 2 bigger than <code>n</code>.</p>
</td></tr>
<tr><td><code id="fir2_+3A_ramp_n">ramp_n</code></td>
<td>
<p>transition width for jumps in filter response (defaults to
<code>grid_n / 20</code>). A wider ramp gives wider transitions but has better
stopband characteristics.</p>
</td></tr>
<tr><td><code id="fir2_+3A_window">window</code></td>
<td>
<p>smoothing window. The returned filter is the same shape as the
smoothing window. Default: <code>hamming(n + 1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function linearly interpolates the desired frequency response onto a
dense grid and then uses the inverse Fourier transform and a Hamming window
to obtain the filter coefficients.
</p>


<h3>Value</h3>

<p>The FIR filter coefficients, a vector of length <code>n + 1</code>, of
class <code>Ma</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ma">Ma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+fftfilt">fftfilt</a></code>,
<code><a href="#topic+fir1">fir1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- c(0, 0.3, 0.3, 0.6, 0.6, 1)
m &lt;- c(0, 0, 1, 1/2, 0, 0)
fh &lt;- freqz(fir2(100, f, m))
op &lt;- par(mfrow = c(1, 2))
plot(f, m, type = "b", ylab = "magnitude", xlab = "Frequency")
lines(fh$w / pi, abs(fh$h), col = "blue")
# plot in dB:
plot(f, 20*log10(m+1e-5), type = "b", ylab = "dB", xlab = "Frequency")
lines(fh$w / pi, 20*log10(abs(fh$h)), col = "blue")
par(op)

</code></pre>

<hr>
<h2 id='firls'>Least-squares linear-phase FIR filter design</h2><span id='topic+firls'></span>

<h3>Description</h3>

<p>Produce a linear phase filter such that the integral of the weighted mean
squared error in the specified bands is minimized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firls(n, f, a, w = rep(1L, length(a)/2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="firls_+3A_n">n</code></td>
<td>
<p>filter order (1 less than the length of the filter). Must be even.
If odd, it is incremented by one.</p>
</td></tr>
<tr><td><code id="firls_+3A_f">f</code></td>
<td>
<p>vector of frequency points in the range from 0 to 1, where 1
corresponds to the Nyquist frequency. Each band is specified by two
frequencies, so the vector must have an even length. .</p>
</td></tr>
<tr><td><code id="firls_+3A_a">a</code></td>
<td>
<p>vector of the same length as <code>f</code> containing the desired
amplitude at each of the points specified in <code>f</code>.</p>
</td></tr>
<tr><td><code id="firls_+3A_w">w</code></td>
<td>
<p>weighting function that contains one value for each band that
weights the mean squared error in that band. <code>w</code> must be half the
length of <code>f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The least squares optimization algorithm for computing FIR filter
coefficients is derived in detail in [1].
</p>


<h3>Value</h3>

<p>The FIR filter coefficients, a vector of length <code>n + 1</code>, of
class <code>Ma</code>.
</p>


<h3>Author(s)</h3>

<p>Quentin Spencer, <a href="mailto:qspencer@ieee.org">qspencer@ieee.org</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] I. Selesnick, &quot;Linear-Phase FIR Filter Design by Least
Squares&quot;,
<a href="https://cnx.org/contents/6x7LNQOp@7/Linear-Phase-Fir-Filter-Design-By-Least-Squares">https://cnx.org/contents/6x7LNQOp@7/Linear-Phase-Fir-Filter-Design-By-Least-Squares</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ma">Ma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+fftfilt">fftfilt</a></code>,
<code><a href="#topic+fir1">fir1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freqz(firls(255, c(0, 0.25, 0.3, 1), c(1, 1, 0, 0)))

</code></pre>

<hr>
<h2 id='flattopwin'>Flat top window</h2><span id='topic+flattopwin'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a flat top window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flattopwin(n, method = c("symmetric", "periodic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flattopwin_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="flattopwin_+3A_method">method</code></td>
<td>
<p>Character string. Window sampling method, specified as:
</p>

<dl>
<dt>&quot;symmetric&quot;</dt><dd><p>(Default). Use this option when using windows for filter
design.</p>
</dd>
<dt>&quot;periodic&quot;</dt><dd><p>This option is useful for spectral analysis because it
enables a windowed signal to have the perfect periodic extension implicit
in the discrete Fourier transform. When 'periodic' is specified, the
function computes a window of length <code>n + 1</code> and returns the first
<code>n</code> points.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The Flat Top window is defined by the function:
</p>
<p style="text-align: center;"><code class="reqn">f(w) = 1 - 1.93 cos(2 \pi w) + 1.29 cos(4 \pi w) - 0.388 cos(6 \pi w) +
0.0322 cos(8 \pi w)</code>
</p>

<p>where <code>w = i/(n-1)</code> for <code>i=0:n-1</code> for a symmetric window, or
<code>w = i/n</code> for <code>i=0:n-1</code> for a periodic window. The default is
symmetric. The returned window is normalized to a peak of 1 at w = 0.5.
</p>
<p>Flat top windows have very low passband ripple (&lt; 0.01 dB) and are used
primarily for calibration purposes. Their bandwidth is approximately 2.5
times wider than a Hann window.
</p>


<h3>Value</h3>

<p>Flat top window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ft &lt;- flattopwin(64)
plot (ft, type = "l", xlab = "Samples", ylab =" Amplitude")


</code></pre>

<hr>
<h2 id='fracshift'>Fractional shift</h2><span id='topic+fracshift'></span>

<h3>Description</h3>

<p>Shift a signal by a (possibly fractional) number of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fracshift(x, d, h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fracshift_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector.</p>
</td></tr>
<tr><td><code id="fracshift_+3A_d">d</code></td>
<td>
<p>number of samples to shift <code>x</code> by, specified as a numeric value</p>
</td></tr>
<tr><td><code id="fracshift_+3A_h">h</code></td>
<td>
<p>interpolator impulse response, specified as a numeric vector. If
NULL (default), the interpolator is designed by a Kaiser-windowed sinecard.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the initial index and end index of the sequences of
1’s in the rows of <code>x</code>. The clusters are sought in the rows of the array
<code>x</code>. The function works by finding the indexes of jumps between
consecutive values in the rows of <code>x</code>.
</p>


<h3>Value</h3>

<p>A list of matrices size <code>nr</code>, where <code>nr</code> is the number of
rows in <code>x</code>. Each element of the list contains a matrix with two rows.
The first row is the initial index of a sequence of 1s and the second row
is the end index of that sequence. If <code>nr == 1</code> the output is a matrix
with two rows.
</p>


<h3>Author(s)</h3>

<p>Eric Chassande-Mottin, <a href="mailto:ecm@apc.univ-paris7.fr">ecm@apc.univ-paris7.fr</a>,<br />
Juan Pablo Carbajal, <a href="mailto:carbajal@ifi.uzh.ch">carbajal@ifi.uzh.ch</a>,<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] A. V. Oppenheim, R. W. Schafer and J. R. Buck,
Discrete-time signal processing, Signal processing series,
Prentice-Hall, 1999.<br />
[2] T.I. Laakso, V. Valimaki, M. Karjalainen and U.K. Laine
Splitting the unit delay, IEEE Signal Processing Magazine,
vol. 13, no. 1, pp 30&ndash;59 Jan 1996.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N = 1024
t &lt;- seq(0, 1, length.out = N)
x &lt;- exp(-t^2 / 2 / 0.25^2) * sin(2 * pi * 10 * t)
dt &lt;- 0.25
d  &lt;- dt / (t[2] - t[1])
y &lt;- fracshift(x, d)
plot(t, x, type = "l", xlab = "Time", ylab = "Sigfnal")
lines (t, y, col = "red")
legend("topright", legend = c("original", "shifted"), lty = 1, col = 1:2)

</code></pre>

<hr>
<h2 id='freqs'>Frequency response of analog filters</h2><span id='topic+freqs'></span><span id='topic+freqs.default'></span><span id='topic+freqs.Arma'></span><span id='topic+freqs.Ma'></span><span id='topic+freqs.Sos'></span><span id='topic+freqs.Zpg'></span>

<h3>Description</h3>

<p>Compute the s-plane frequency response of an IIR filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqs(filt, ...)

## Default S3 method:
freqs(filt, a, w, plot = TRUE, ...)

## S3 method for class 'Arma'
freqs(filt, w, ...)

## S3 method for class 'Ma'
freqs(filt, w, ...)

## S3 method for class 'Sos'
freqs(filt, w, ...)

## S3 method for class 'Zpg'
freqs(filt, w, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqs_+3A_filt">filt</code></td>
<td>
<p>for the default case, moving average (MA) polynomial
coefficients, specified as a numeric vector or matrix. In case of a matrix,
then each row corresponds to an output of the system. The number of columns
of <code>b</code> must be less than or equal to the length of <code>a</code>.</p>
</td></tr>
<tr><td><code id="freqs_+3A_...">...</code></td>
<td>
<p>additional parameters (not used)</p>
</td></tr>
<tr><td><code id="freqs_+3A_a">a</code></td>
<td>
<p>autoregressive (AR) polynomial coefficients, specified as a vector.</p>
</td></tr>
<tr><td><code id="freqs_+3A_w">w</code></td>
<td>
<p>angular frequencies, specified as a positive real vector expressed
in rad/second.</p>
</td></tr>
<tr><td><code id="freqs_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), plots the magnitude and phase
responses as a function of angular frequency, otherwise a vector of the
frequency response is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The s-plane frequency response of the IIR filter <code>B(s) / A(s)</code> is
computed as <code>H = polyval(B, 1i * W) / polyval(A, 1i * W)</code>. If called
with no output argument, a plot of magnitude and phase are displayed.
</p>


<h3>Value</h3>

<p>Frequency response, returned as a complex vector.
</p>


<h3>Author(s)</h3>

<p>Julius O. Smith III, <a href="mailto:jos@ccrma.stanford.edu">jos@ccrma.stanford.edu</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- c(1, 2); a &lt;- c(1, 1)
w &lt;- seq(0, 4, length.out = 128)
freqs (b, a, w)

</code></pre>

<hr>
<h2 id='freqs_plot'>Plot frequency response</h2><span id='topic+freqs_plot'></span>

<h3>Description</h3>

<p>Plot the s-plane frequency response of an IIR filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqs_plot(w, h, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqs_plot_+3A_w">w</code></td>
<td>
<p>angular frequencies, specified as a positive real vector expressed
in rad/second.</p>
</td></tr>
<tr><td><code id="freqs_plot_+3A_h">h</code></td>
<td>
<p>Frequency response, specified as a complex vector.</p>
</td></tr>
<tr><td><code id="freqs_plot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot() function</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Julius O. Smith III, <a href="mailto:jos@ccrma.stanford.edu">jos@ccrma.stanford.edu</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- c(1, 2); a &lt;- c(1, 1)
w &lt;- seq(0.01, 4, length.out = 128)
h &lt;- freqs (b, a, w, plot = FALSE)
freqs_plot(w, h)
freqs_plot(w, h, log = "x")

</code></pre>

<hr>
<h2 id='freqz'>Frequency response of digital filter</h2><span id='topic+freqz'></span><span id='topic+freqz.default'></span><span id='topic+freqz.Arma'></span><span id='topic+freqz.Ma'></span><span id='topic+freqz.Sos'></span><span id='topic+freqz.Zpg'></span><span id='topic+print.freqz'></span><span id='topic+summary.freqz'></span><span id='topic+print.summary.freqz'></span><span id='topic+freqz_plot'></span>

<h3>Description</h3>

<p>Compute the z-plane frequency response of an ARMA model or rational IIR
filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqz(filt, ...)

## Default S3 method:
freqz(
  filt,
  a = 1,
  n = 512,
  whole = ifelse((is.numeric(filt) &amp;&amp; is.numeric(a)), FALSE, TRUE),
  fs = 2 * pi,
  ...
)

## S3 method for class 'Arma'
freqz(
  filt,
  n = 512,
  whole = ifelse((is.numeric(filt$b) &amp;&amp; is.numeric(filt$a)), FALSE, TRUE),
  fs = 2 * pi,
  ...
)

## S3 method for class 'Ma'
freqz(
  filt,
  n = 512,
  whole = ifelse(is.numeric(filt), FALSE, TRUE),
  fs = 2 * pi,
  ...
)

## S3 method for class 'Sos'
freqz(filt, n = 512, whole = FALSE, fs = 2 * pi, ...)

## S3 method for class 'Zpg'
freqz(filt, n = 512, whole = FALSE, fs = 2 * pi, ...)

## S3 method for class 'freqz'
print(x, ...)

## S3 method for class 'freqz'
summary(object, ...)

## S3 method for class 'summary.freqz'
print(x, ...)

freqz_plot(w, h, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqz_+3A_filt">filt</code></td>
<td>
<p>for the default case, the moving-average coefficients of an ARMA
model or filter. Generically, <code>filt</code> specifies an arbitrary model or
filter operation.</p>
</td></tr>
<tr><td><code id="freqz_+3A_...">...</code></td>
<td>
<p>for methods of <code>freqz</code>, arguments are passed to the default
method. For <code>freqz_plot</code>, additional arguments are passed through to
plot.</p>
</td></tr>
<tr><td><code id="freqz_+3A_a">a</code></td>
<td>
<p>the autoregressive (recursive) coefficients of an ARMA filter.</p>
</td></tr>
<tr><td><code id="freqz_+3A_n">n</code></td>
<td>
<p>number of points at which to evaluate the frequency response. If
<code>n</code> is a vector with a length greater than 1, then evaluate the
frequency response at these points. For fastest computation, <code>n</code>
should factor into a small number of small primes. Default: 512.</p>
</td></tr>
<tr><td><code id="freqz_+3A_whole">whole</code></td>
<td>
<p>FALSE (the default) to evaluate around the upper half of the
unit circle or TRUE to evaluate around the entire unit circle.</p>
</td></tr>
<tr><td><code id="freqz_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz. If not specified (default = 2 * pi), the
frequencies are in radians.</p>
</td></tr>
<tr><td><code id="freqz_+3A_x">x</code></td>
<td>
<p>object to be printed or plotted.</p>
</td></tr>
<tr><td><code id="freqz_+3A_object">object</code></td>
<td>
<p>object of class <code>"freqz"</code> for <code>summary</code></p>
</td></tr>
<tr><td><code id="freqz_+3A_w">w</code></td>
<td>
<p>vector of frequencies</p>
</td></tr>
<tr><td><code id="freqz_+3A_h">h</code></td>
<td>
<p>complex frequency response <code class="reqn">H(e^{j\omega})</code>, specified as a
vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The frequency response of a digital filter can be interpreted as the transfer
function evaluated at <code class="reqn">z = e^{j\omega}</code>.
</p>
<p>The 'Matlab' and 'Octave' versions of <code>freqz</code> produce magnitude and
phase plots. The <code>freqz</code> version in the 'signal' package produces
separate plots of magnitude in the pass band (max - 3 dB to max) and stop
(total) bands, as well as a phase plot. The current version produces slightly
different plots. The magnitude plots are separate for stop and pass bands,
but the pass band plot has an absolute lower limit of -3 dB instead of max -
3 dB. In addition a <code>summary</code> method was added that prints out the most
important information about the frequency response of the filter.
</p>


<h3>Value</h3>

<p>For <code>freqz</code>, a list of class <code>'freqz'</code> with items:
</p>

<dl>
<dt>h</dt><dd><p>complex array of frequency responses at frequencies <code>f</code>.</p>
</dd>
<dt>w</dt><dd><p>array of frequencies.</p>
</dd>
<dt>u</dt><dd><p>units of (angular) frequency; either rad/s or Hz.</p>
</dd>
</dl>



<h3>Note</h3>

<p>When results of <code>freqz</code> are printed, <code>freqz_plot</code> will be
called to display frequency plots of magnitude and phase. As with lattice
plots, automatic printing does not work inside loops and function calls, so
explicit calls to print or plot are needed there.
</p>


<h3>Author(s)</h3>

<p>John W. Eaton, Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Port to R by Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- c(1, 0, -1)
a &lt;- c(1, 0, 0, 0, 0.25)
freqz(b, a)

hw &lt;- freqz(b, a)
summary(hw)

</code></pre>

<hr>
<h2 id='fwhm'>Full width at half maximum</h2><span id='topic+fwhm'></span>

<h3>Description</h3>

<p>Compute peak full-width at half maximum or at another level of peak maximum
for a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwhm(
  x = seq_len(length(y)),
  y,
  ref = c("max", "zero", "middle", "min", "absolute"),
  level = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fwhm_+3A_x">x</code></td>
<td>
<p>samples at which <code>y</code> is measured, specified as a vector. I.e.,
<code>y</code> is sampled as <code>y[x]</code>. Default: <code>seq_len(length(y))</code>.</p>
</td></tr>
<tr><td><code id="fwhm_+3A_y">y</code></td>
<td>
<p>signal to find the width of. If <code>y</code> is a matrix, widths of all
columns are computed.</p>
</td></tr>
<tr><td><code id="fwhm_+3A_ref">ref</code></td>
<td>
<p>reference. Compute the width with reference to:
</p>

<dl>
<dt><code>"max" | "zero"</code></dt><dd><p><code>max(y)</code></p>
</dd>
<dt><code>"middle" | "min"</code></dt><dd><p><code>min(y) + max(y)</code></p>
</dd>
<dt><code>"absolute"</code></dt><dd><p>an absolute level of <code>y</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fwhm_+3A_level">level</code></td>
<td>
<p>the level at which to compute the width. Default: 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Full width at half maximum, returned as a vector with a length equal
to the number of columns in <code>y</code>, or 1 in case of a vector.
</p>


<h3>Author(s)</h3>

<p>Petr Mikulik.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-pi, pi, 0.001)
y &lt;- cos(x)
w &lt;- fwhm(x, y)
m &lt;- x[which.max(y)]
f &lt;- m - w/2
t &lt;- m + w/2
plot(x, y, type="l",
     panel.first = {
       usr &lt;- par('usr')
       rect(f, usr[3], t, usr[4], col = rgb(0, 1, 0, 0.4), border = NA)
     })
abline(h = max(y) / 2, lty = 2, col = "gray")

</code></pre>

<hr>
<h2 id='gauspuls'>Gaussian-modulated sinusoidal RF pulse</h2><span id='topic+gauspuls'></span>

<h3>Description</h3>

<p>Generate a Gaussian modulated sinusoidal pulse sampled at times <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gauspuls(t, fc = 1000, bw = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gauspuls_+3A_t">t</code></td>
<td>
<p>Vector of time values at which the unit-amplitude Gaussian RF pulse
is calculated.</p>
</td></tr>
<tr><td><code id="gauspuls_+3A_fc">fc</code></td>
<td>
<p>Center frequency of the Gaussian-modulated sinusoidal pulses,
specified as a real positive scalar expressed in Hz. Default: 1000</p>
</td></tr>
<tr><td><code id="gauspuls_+3A_bw">bw</code></td>
<td>
<p>Fractional bandwidth of the Gaussian-modulated sinusoidal pulses,
specified as a real positive scalar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Inphase Gaussian-modulated sinusoidal pulse, returned as a vector of
unit amplitude at the times indicated by the time vector t.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, Mike Miller.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fs &lt;- 11025    # arbitrary sample rate
t &lt;- seq(-10, 10, 1/fs)
yi1 &lt;- gauspuls(t, 0.1, 1)
yi2 &lt;- gauspuls(t, 0.1, 2)
plot(t, yi1, type="l", xlab = "Time", ylab = "Amplitude")
lines(t, yi2, col = "red")

fs &lt;- 11025  # arbitrary sample rate
f0 &lt;- 100    # pulse train sample rate
x &lt;- pulstran (seq(0, 4/f0, 1/fs), seq(0, 4/f0, 1/f0), "gauspuls")
plot (0:(length(x)-1) * 1000/fs, x, type="l",
      xlab = "Time (ms)", ylab = "Amplitude",
      main = "Gaussian pulse train at 10 ms intervals")

</code></pre>

<hr>
<h2 id='gaussian'>Gaussian convolution window</h2><span id='topic+gaussian'></span>

<h3>Description</h3>

<p>Return a Gaussian convolution window of length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian(n, a = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="gaussian_+3A_a">a</code></td>
<td>
<p>Width factor, specified as a positive real scalar. <code>a</code> is
inversely proportional to the width of the window. Default: 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The width of the window is inversely proportional to the parameter <code>a</code>.
Use larger <code>a</code> for a narrower window. Use larger <code>m</code> for longer
tails.
</p>
<p style="text-align: center;"><code class="reqn">w = e^{(-(a*x)^{2}/2 )}</code>
</p>

<p>for <code>x &lt;- seq(-(n - 1) / 2, (n - 1) / 2, by = n)</code>.
</p>
<p>Width a is measured in frequency units (sample rate/num samples). It should
be f when multiplying in the time domain, but 1/f when multiplying in the
frequency domain (for use in convolutions).
</p>


<h3>Value</h3>

<p>Gaussian convolution window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g1 &lt;- gaussian(128, 1)
g2 &lt;- gaussian(128, 0.5)
plot (g1, type = "l", xlab = "Samples", ylab =" Amplitude", ylim = c(0, 1))
lines(g2, col = "red")

</code></pre>

<hr>
<h2 id='gausswin'>Gaussian window</h2><span id='topic+gausswin'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a Gaussian window of length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gausswin(n, a = 2.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gausswin_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="gausswin_+3A_a">a</code></td>
<td>
<p>Width factor, specified as a positive real scalar. <code>a</code> is
inversely proportional to the width of the window. Default: 2.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The width of the window is inversely proportional to the parameter <code>a</code>.
Use larger <code>a</code> for a narrower window. Use larger <code>m</code> for a smoother
curve.
</p>
<p style="text-align: center;"><code class="reqn">w = e^{(-(a*x)^{2}/2 )}</code>
</p>

<p>for <code>x &lt;- seq(-(n - 1) / n, (n - 1) / n, by = n)</code>.
</p>
<p>The exact correspondence with the standard deviation of a Gaussian
probability density function is <code class="reqn">\sigma = (n - 1) / (2a)</code>.
</p>


<h3>Value</h3>

<p>Gaussian convolution window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g1 &lt;- gausswin(64)
g2 &lt;- gausswin(64, 5)
plot (g1, type = "l", xlab = "Samples", ylab =" Amplitude", ylim = c(0, 1))
lines(g2, col = "red")

</code></pre>

<hr>
<h2 id='gmonopuls'>Gaussian monopulse</h2><span id='topic+gmonopuls'></span>

<h3>Description</h3>

<p>Returns samples of the unit-amplitude Gaussian monopulse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmonopuls(t, fc = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmonopuls_+3A_t">t</code></td>
<td>
<p>Vector of time values at which the unit-amplitude Gaussian monopulse
is calculated.</p>
</td></tr>
<tr><td><code id="gmonopuls_+3A_fc">fc</code></td>
<td>
<p>Center frequency of the Gaussian monopulses, specified as a real
positive scalar expressed in Hz. Default: 1000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Samples of the Gaussian monopulse, returned as a vector of unit
amplitude at the times indicated by the time vector <code>t</code>.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- 11025    # arbitrary sample rate
t &lt;- seq(-10, 10, 1/fs)
y1 &lt;- gmonopuls(t, 0.1)
y2 &lt;- gmonopuls(t, 0.2)
plot(t, y1, type="l", xlab = "Time", ylab = "Amplitude")
lines(t, y2, col = "red")
legend("topright", legend = c("fc = 0.1", "fc = 0.2"),
       lty = 1, col = c(1, 2))

</code></pre>

<hr>
<h2 id='grpdelay'>Group delay</h2><span id='topic+grpdelay'></span><span id='topic+print.grpdelay'></span><span id='topic+plot.grpdelay'></span><span id='topic+grpdelay.default'></span><span id='topic+grpdelay.Arma'></span><span id='topic+grpdelay.Ma'></span><span id='topic+grpdelay.Sos'></span><span id='topic+grpdelay.Zpg'></span>

<h3>Description</h3>

<p>Compute the average delay of a filter (group delay).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grpdelay(filt, ...)

## S3 method for class 'grpdelay'
print(x, ...)

## S3 method for class 'grpdelay'
plot(
  x,
  xlab = if (x$HzFlag) "Frequency (Hz)" else "Frequency (rad/sample)",
  ylab = "Group delay (samples)",
  type = "l",
  ...
)

## Default S3 method:
grpdelay(filt, a = 1, n = 512, whole = FALSE, fs = NULL, ...)

## S3 method for class 'Arma'
grpdelay(filt, ...)

## S3 method for class 'Ma'
grpdelay(filt, ...)

## S3 method for class 'Sos'
grpdelay(filt, ...)

## S3 method for class 'Zpg'
grpdelay(filt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grpdelay_+3A_filt">filt</code></td>
<td>
<p>for the default case, the moving-average coefficients of an ARMA
model or filter. Generically, filt specifies an arbitrary model or filter
operation.</p>
</td></tr>
<tr><td><code id="grpdelay_+3A_...">...</code></td>
<td>
<p>for methods of grpdelay, arguments are passed to the default
method. For plot.grpdelay, additional arguments are passed through to plot.</p>
</td></tr>
<tr><td><code id="grpdelay_+3A_x">x</code></td>
<td>
<p>object to be plotted.</p>
</td></tr>
<tr><td><code id="grpdelay_+3A_xlab">xlab</code>, <code id="grpdelay_+3A_ylab">ylab</code>, <code id="grpdelay_+3A_type">type</code></td>
<td>
<p>as in plot, but with more sensible defaults.</p>
</td></tr>
<tr><td><code id="grpdelay_+3A_a">a</code></td>
<td>
<p>the autoregressive (recursive) coefficients of an ARMA filter.</p>
</td></tr>
<tr><td><code id="grpdelay_+3A_n">n</code></td>
<td>
<p>number of points at which to evaluate the frequency response. If
<code>n</code> is a vector with a length greater than 1, then evaluate the
frequency response at these points. For fastest computation, <code>n</code>
should factor into a small number of small primes. Default: 512.</p>
</td></tr>
<tr><td><code id="grpdelay_+3A_whole">whole</code></td>
<td>
<p>FALSE (the default) to evaluate around the upper half of the
unit circle or TRUE to evaluate around the entire unit circle.</p>
</td></tr>
<tr><td><code id="grpdelay_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz. If not specified, the frequencies are in
radians.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the denominator of the computation becomes too small, the group delay is
set to zero. (The group delay approaches infinity when there are poles or
zeros very close to the unit circle in the z plane.)
</p>


<h3>Value</h3>

<p>A list of class <code>grpdelay</code> with items:
</p>

<dl>
<dt>gd</dt><dd><p>the group delay, in units of samples. It can be converted to
seconds by multiplying by the sampling period (or dividing by the sampling
rate fs).</p>
</dd>
<dt>w</dt><dd><p>frequencies at which the group delay was calculated.</p>
</dd>
<dt>ns</dt><dd><p>number of points at which the group delay was calculated.</p>
</dd>
<dt>Hzflag</dt><dd><p>TRUE for frequencies in Hz, FALSE for frequencies in
radians.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Julius O. Smith III, <a href="mailto:jos@ccrma.stanford.edu">jos@ccrma.stanford.edu</a>.<br />
Conversion to R by Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://ccrma.stanford.edu/~jos/filters/Numerical_Computation_Group_Delay.html">https://ccrma.stanford.edu/~jos/filters/Numerical_Computation_Group_Delay.html</a><br />
<a href="https://en.wikipedia.org/wiki/Group_delay">https://en.wikipedia.org/wiki/Group_delay</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two Zeros and Two Poles
b &lt;- poly(c(1 / 0.9 * exp(1i * pi * 0.2), 0.9 * exp(1i * pi * 0.6)))
a &lt;- poly(c(0.9 * exp(-1i * pi * 0.6), 1 / 0.9 * exp(-1i * pi * 0.2)))
gpd &lt;- grpdelay(b, a, 512, whole = TRUE, fs = 1)
print(gpd)
plot(gpd)

</code></pre>

<hr>
<h2 id='hamming'>Hamming window</h2><span id='topic+hamming'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a Hamming window of length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hamming(n, method = c("symmetric", "periodic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hamming_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="hamming_+3A_method">method</code></td>
<td>
<p>Character string. Window sampling method, specified as:
</p>

<dl>
<dt>&quot;symmetric&quot;</dt><dd><p>(Default). Use this option when using windows for filter
design.</p>
</dd>
<dt>&quot;periodic&quot;</dt><dd><p>This option is useful for spectral analysis because it
enables a windowed signal to have the perfect periodic extension implicit
in the discrete Fourier transform. When <code>"periodic"</code> is specified, the
function computes a window of length <code>n + 1</code> and returns the first
<code>n</code> points.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hamming window is a member of the family of cosine sum windows.
</p>


<h3>Value</h3>

<p>Hamming window, returned as a vector. If you specify a one-point
window <code>(n = 1)</code>, the value 1 is returned.
</p>


<h3>Author(s)</h3>

<p>Andreas Weingessel, <a href="mailto:Andreas.Weingessel@ci.tuwien.ac.at">Andreas.Weingessel@ci.tuwien.ac.at</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
h &lt;- hamming(64)
plot (h, type = "l", xlab = "Samples", ylab =" Amplitude")

hs = hamming(64,'symmetric')
hp = hamming(63,'periodic')
plot (hs, type = "l", xlab = "Samples", ylab =" Amplitude")
lines(hp, col="red")

</code></pre>

<hr>
<h2 id='hann'>Hann window</h2><span id='topic+hann'></span><span id='topic+hanning'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a Hann window of length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hann(n, method = c("symmetric", "periodic"))

hanning(n, method = c("symmetric", "periodic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hann_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="hann_+3A_method">method</code></td>
<td>
<p>Character string. Window sampling method, specified as:
</p>

<dl>
<dt>&quot;symmetric&quot;</dt><dd><p>(Default). Use this option when using windows for filter
design.</p>
</dd>
<dt>&quot;periodic&quot;</dt><dd><p>This option is useful for spectral analysis because it
enables a windowed signal to have the perfect periodic extension implicit
in the discrete Fourier transform. When <code>"periodic"</code> is specified, the
function computes a window of length <code>n + 1</code> and returns the first
<code>n</code> points.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hann window is a member of the family of cosine sum windows. It was named
after Julius von Hann, and is sometimes referred to as Hanning, presumably
due to its linguistic and formulaic similarities to Hamming window.
</p>


<h3>Value</h3>

<p>Hann window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Andreas Weingessel, <a href="mailto:Andreas.Weingessel@ci.tuwien.ac.at">Andreas.Weingessel@ci.tuwien.ac.at</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
h &lt;- hann(64)
plot (h, type = "l", xlab = "Samples", ylab =" Amplitude")

hs = hann(64,'symmetric')
hp = hann(63,'periodic')
plot (hs, type = "l", xlab = "Samples", ylab =" Amplitude")
lines(hp, col="red")

</code></pre>

<hr>
<h2 id='hilbert'>Hilbert transform</h2><span id='topic+hilbert'></span>

<h3>Description</h3>

<p>Computes the extension of a real valued signal to an analytic signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert(x, n = ifelse(is.vector(x), length(x), nrow(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbert_+3A_x">x</code></td>
<td>
<p>Input array, specified as a vector or a matrix. In case of a matrix,
the Hilbert transform of all columns is computed.</p>
</td></tr>
<tr><td><code id="hilbert_+3A_n">n</code></td>
<td>
<p>use an n-point FFT to compute the Hilbert transform. The input data
is zero-padded or truncated to length n, as appropriate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns returns a complex helical sequence, sometimes called the
analytic signal, from a real data sequence. The analytic signal has a real
part, which is the original data, and an imaginary part, which contains the
Hilbert transform. The imaginary part is a version of the original real
sequence with a 90 degrees phase shift. Sines are therefore transformed to
cosines, and conversely, cosines are transformed to sines. The
Hilbert-transformed series has the same amplitude and frequency content as
the original sequence. The transform includes phase information that depends
on the phase of the original.
</p>


<h3>Value</h3>

<p>Analytic signal, of length <code>n</code>, returned as a complex vector or
matrix, the real part of which contains the original signal, and the
imaginary part of which contains the Hilbert transform of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Peter L. Soendergaard.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Hilbert_transform">https://en.wikipedia.org/wiki/Hilbert_transform</a>,
<a href="https://en.wikipedia.org/wiki/Analytic_signal">https://en.wikipedia.org/wiki/Analytic_signal</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## notice that the imaginary signal is phase-shifted 90 degrees
t &lt;- seq(0, 10, length = 256)
z &lt;- hilbert(sin(2 * pi * 0.5 * t))
plot(t, Re(z), type = "l", col="blue")
lines (t, Im(z), col = "red")
legend('topright', lty = 1, legend = c("Real", "Imag"),
       col = c("blue", "red"))

## the magnitude of the hilbert transform eliminates the carrier
t &lt;- seq(0, 10, length = 1024)
x &lt;- 5 * cos(0.2 * t) * sin(100 * t)
plot(t, x, type = "l", col = "green")
lines (t, abs(hilbert(x)), col = "blue")
legend('topright', lty = 1, legend = c("x", "|hilbert(x)|"),
        col = c("green", "blue"))

</code></pre>

<hr>
<h2 id='idct'>Inverse Discrete Cosine Transform</h2><span id='topic+idct'></span>

<h3>Description</h3>

<p>Compute the inverse unitary discrete cosine transform of a signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idct(x, n = NROW(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idct_+3A_x">x</code></td>
<td>
<p>input discrete cosine transform, specified as a numeric vector or
matrix. In case of a vector it represents a single signal; in case of a
matrix each column is a signal.</p>
</td></tr>
<tr><td><code id="idct_+3A_n">n</code></td>
<td>
<p>transform length, specified as a positive integer scalar. Default:
<code>NROW(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrete cosine transform (DCT) is closely related to the discrete
Fourier transform. You can often reconstruct a sequence very accurately from
only a few DCT coefficients. This property is useful for applications
requiring data reduction.
</p>


<h3>Value</h3>

<p>Inverse discrete cosine transform, returned as a vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dct">dct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq_len(100) + 50 * cos(seq_len(100) * 2 * pi / 40)
X &lt;- dct(x)

# Find which cosine coefficients are significant (approx.)
# zero the rest
nsig &lt;- which(abs(X) &lt; 1)
N &lt;- length(X) - length(nsig) + 1
X[nsig] &lt;- 0

# Reconstruct the signal and compare it to the original signal.
xx &lt;- idct(X)
plot(x, type = "l")
lines(xx, col = "red")
legend("bottomright", legend = c("Original", paste("Reconstructed, N =", N)),
       lty = 1, col = 1:2)

</code></pre>

<hr>
<h2 id='idct2'>Inverse 2-D Discrete Cosine Transform</h2><span id='topic+idct2'></span>

<h3>Description</h3>

<p>Compute the inverse two-dimensional discrete cosine transform of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idct2(x, m = NROW(x), n = NCOL(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idct2_+3A_x">x</code></td>
<td>
<p>2-D numeric matrix</p>
</td></tr>
<tr><td><code id="idct2_+3A_m">m</code></td>
<td>
<p>Number of rows, specified as a positive integer. <code>dct2</code> pads or
truncates <code>x</code> so that it has <code>m</code> rows. Default: <code>NROW(x)</code>.</p>
</td></tr>
<tr><td><code id="idct2_+3A_n">n</code></td>
<td>
<p>Number of columns, specified as a positive integer. <code>dct2</code> pads
or truncates <code>x</code> so that it has <code>n</code> columns. Default:
<code>NCOL(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrete cosine transform (DCT) is closely related to the discrete
Fourier transform. It is a separable linear transformation; that is, the
two-dimensional transform is equivalent to a one-dimensional DCT performed
along a single dimension followed by a one-dimensional DCT in the other
dimension.
</p>


<h3>Value</h3>

<p><code>m</code>-by-<code>n</code> numeric discrete cosine transformed matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dct2">dct2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(50 * runif(100), 10, 10)
B &lt;- dct2(A)
B[which(B &lt; 1)] &lt;- 0
AA &lt;- idct2(B)

</code></pre>

<hr>
<h2 id='idst'>Inverse Discrete Sine Transform</h2><span id='topic+idst'></span>

<h3>Description</h3>

<p>Compute the inverse discrete sine transform of a signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idst(x, n = NROW(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idst_+3A_x">x</code></td>
<td>
<p>input discrete cosine transform, specified as a numeric vector or
matrix. In case of a vector it represents a single signal; in case of a
matrix each column is a signal.</p>
</td></tr>
<tr><td><code id="idst_+3A_n">n</code></td>
<td>
<p>transform length, specified as a positive integer scalar. Default:
<code>NROW(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrete sine transform (DST) is closely related to the discrete Fourier
transform. but using a purely real matrix. It is equivalent to the imaginary
parts of a DFT of roughly twice the length.
</p>


<h3>Value</h3>

<p>Inverse discrete sine transform, returned as a vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dst">dst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq_len(100) + 50 * cos(seq_len(100) * 2 * pi / 40)
X &lt;- dst(x)
xx &lt;- idst(X)
all.equal(x, xx)

</code></pre>

<hr>
<h2 id='ifft'>Inverse Fast Fourier Transform</h2><span id='topic+ifft'></span><span id='topic+imvfft'></span>

<h3>Description</h3>

<p>Compute the inverse Fast Fourier Transform compatible with
'Matlab' and 'Octave'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifft(x)

imvfft(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifft_+3A_x">x</code></td>
<td>
<p>Real or complex vector, array, or matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>'fft'</code> function in the <code>'stats'</code> package can compute the
inverse FFT by specifying <code>inverse = TRUE</code>. However, that function does
<em>not</em> divide the result by <code>length(x)</code>, nor does it return real
values when appropriate. The present function does both, and is this
compatible with 'Matlab' and 'Octave' (and differs from the <code>'ifft'</code>
function in the <code>'signal'</code> package, which does not return real values).
</p>


<h3>Value</h3>

<p>When <code>x</code> is a vector, the value computed and returned by
<code>ifft</code> is the univariate inverse discrete Fourier transform of the
sequence of values in <code>x</code>. Specifically, <code>y &lt;- ifft(x)</code> is
defined as <code>stats::fft(x, inverse = TRUE) / length(x)</code>. The
<code>stats::fft</code> function called with <code>inverse = TRUE</code> replaces
<code>exp(-2 * pi...)</code> with <code>exp(2 * pi)</code> in the definition of the
discrete Fourier transform (see <code><a href="stats.html#topic+fft">fft</a></code>).
</p>
<p>When <code>x</code> contains an array, <code>ifft</code> computes and returns the
normalized inverse multivariate (spatial) transform. By contrast,
<code>imvfft</code> takes a real or complex matrix as argument, and returns a
similar shaped matrix, but with each column replaced by its normalized
inverse discrete Fourier transform. This is useful for analyzing
vector-valued series.
</p>


<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fft">fft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- ifft(stats::fft(1:5))
res &lt;- ifft(stats::fft(c(1+5i, 2+3i, 3+2i, 4+6i, 5+2i)))
res &lt;- imvfft(stats::mvfft(matrix(1:20, 4, 5)))

</code></pre>

<hr>
<h2 id='ifftshift'>Inverse zero-frequency shift</h2><span id='topic+ifftshift'></span>

<h3>Description</h3>

<p>Rearranges a zero-frequency-shifted Fourier transform back to the original.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifftshift(x, MARGIN = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifftshift_+3A_x">x</code></td>
<td>
<p>input data, specified as a vector or matrix.</p>
</td></tr>
<tr><td><code id="ifftshift_+3A_margin">MARGIN</code></td>
<td>
<p>dimension to operate along, 1 = row, 2 = columns (default).
Specifying <code>MARGIN = c(1, 2)</code> centers along both rows and columns.
Ignored when <code>x</code> is a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Undo the action of the fftshift function. For even length <code>x</code>,
<code>fftshift</code> is its own inverse, but not for odd length input.
</p>


<h3>Value</h3>

<p>back-transformed vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Vincent Cautaerts, <a href="mailto:vincent@comf5.comm.eng.osaka-u.ac.jp">vincent@comf5.comm.eng.osaka-u.ac.jp</a>,<br />
adapted by John W. Eaton.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fftshift">fftshift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Xeven &lt;- 1:6
res &lt;- fftshift(fftshift(Xeven))

Xodd &lt;- 1:7
res &lt;- fftshift(fftshift(Xodd))
res &lt;- ifftshift(fftshift(Xodd))

</code></pre>

<hr>
<h2 id='ifwht'>Fast Walsh-Hadamard Transform</h2><span id='topic+ifwht'></span><span id='topic+fwht'></span>

<h3>Description</h3>

<p>Compute the (inverse) Fast Walsh-Hadamard transform of a signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifwht(x, n = NROW(x), ordering = c("sequency", "hadamard", "dyadic"))

fwht(x, n = NROW(x), ordering = c("sequency", "hadamard", "dyadic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifwht_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal. <code>fwht</code> operates only on signals with length equal to a power
of 2. If the length of <code>x</code> is less than a power of 2, its length is
padded with zeros to the next greater power of two before processing.</p>
</td></tr>
<tr><td><code id="ifwht_+3A_n">n</code></td>
<td>
<p>transform length, specified as a positive integer scalar. Default:
<code>NROW(x)</code>.</p>
</td></tr>
<tr><td><code id="ifwht_+3A_ordering">ordering</code></td>
<td>
<p>order of the Walsh-Hadamard transform coefficients, one of:
</p>

<dl>
<dt>&quot;sequency&quot;</dt><dd><p>(Default) Coefficients in order of increasing sequency
value, where each row has an additional zero crossing.</p>
</dd>
<dt>&quot;hadamard&quot;</dt><dd><p>Coefficients in normal Hadamard order</p>
</dd>
<dt>&quot;dyadic&quot;</dt><dd><p>Coefficients in Gray code order, where a single bit change
occurs from one coefficient to the next</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>(Inverse) Fast Walsh Hadamard transform, returned as a vector or
matrix.
</p>


<h3>Author(s)</h3>

<p>Mike Miller.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Hadamard_transform">https://en.wikipedia.org/wiki/Hadamard_transform</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Fast_Walsh-Hadamard_transform">https://en.wikipedia.org/wiki/Fast_Walsh-Hadamard_transform</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(19, -1, 11, -9, -7, 13, -15, 5)
X &lt;- fwht(x)
all.equal(x, ifwht(X))

</code></pre>

<hr>
<h2 id='iirlp2mb'>IIR lowpass filter to IIR multiband</h2><span id='topic+iirlp2mb'></span><span id='topic+iirlp2mb.Arma'></span><span id='topic+iirlp2mb.Zpg'></span><span id='topic+iirlp2mb.Sos'></span><span id='topic+iirlp2mb.default'></span>

<h3>Description</h3>

<p>Transform an IIR lowpass filter prototype to an IIR multiband filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iirlp2mb(b, ...)

## S3 method for class 'Arma'
iirlp2mb(b, Wo, Wt, type, ...)

## S3 method for class 'Zpg'
iirlp2mb(b, Wo, Wt, type, ...)

## S3 method for class 'Sos'
iirlp2mb(b, Wo, Wt, type, ...)

## Default S3 method:
iirlp2mb(b, a, Wo, Wt, type = c("pass", "stop"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iirlp2mb_+3A_b">b</code></td>
<td>
<p>numerator polynomial of prototype low pass filter</p>
</td></tr>
<tr><td><code id="iirlp2mb_+3A_...">...</code></td>
<td>
<p>additional arguments (not used)</p>
</td></tr>
<tr><td><code id="iirlp2mb_+3A_wo">Wo</code></td>
<td>
<p>(normalized angular frequency)/pi to be transformed</p>
</td></tr>
<tr><td><code id="iirlp2mb_+3A_wt">Wt</code></td>
<td>
<p>vector of (norm. angular frequency)/pi transform targets</p>
</td></tr>
<tr><td><code id="iirlp2mb_+3A_type">type</code></td>
<td>
<p>one of &quot;pass&quot; or &quot;stop&quot;. Specifies to filter to produce: bandpass
(default) or bandstop.</p>
</td></tr>
<tr><td><code id="iirlp2mb_+3A_a">a</code></td>
<td>
<p>denominator polynomial of prototype low pass filter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The utility of a prototype filter comes from the property that all other
filters can be derived from it by applying a scaling factor to the components
of the prototype. The filter design need thus only be carried out once in
full, with other filters being obtained by simply applying a scaling factor.
Especially useful is the ability to transform from one bandform to another.
In this case, the transform is more than a simple scale factor. Bandform here
is meant to indicate the category of passband that the filter possesses. The
usual bandforms are lowpass, highpass, bandpass and bandstop, but others are
possible. In particular, it is possible for a filter to have multiple
passbands. In fact, in some treatments, the bandstop filter is considered to
be a type of multiple passband filter having two passbands. Most commonly,
the prototype filter is expressed as a lowpass filter, but other techniques
are possible[1].
</p>
<p>Filters with multiple passbands may be obtained by applying the general
transformation described in [2].
</p>
<p>Because <code>iirlp2mb</code> is generic, it can be extended to accept other
inputs.
</p>


<h3>Value</h3>

<p>List of class <code><a href="#topic+Arma">Arma</a></code> numerator and denominator
polynomials of the resulting filter.
</p>


<h3>Author(s)</h3>

<p>Alan J. Greenberger, <a href="mailto:alanjg@ptd.net">alanjg@ptd.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] <a href="https://en.wikipedia.org/wiki/Prototype_filter">https://en.wikipedia.org/wiki/Prototype_filter</a><br />
[2] <a href="https://en.wikipedia.org/wiki/Prototype_filter#Lowpass_to_multi-band">https://en.wikipedia.org/wiki/Prototype_filter#Lowpass_to_multi-band</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Design a prototype real IIR lowpass elliptic filter with a gain of about
## –3 dB at 0.5pi rad/sample.
el &lt;- ellip(3, 0.1, 30, 0.409)
## Create a real multiband filter with two passbands.
mb1 &lt;- iirlp2mb(el, 0.5, c(.2, .4, .6, .8), 'pass')
## Create a real multiband filter with two stopbands.
mb2 &lt;- iirlp2mb(el, 0.5, c(.2, .4, .6, .8), 'stop')
## Compare the magnitude responses of the filters.
hfl &lt;- freqz(el)
hf1 &lt;- freqz(mb1)
hf2 &lt;- freqz(mb2)
plot(hfl$w, 20 * log10(abs(hfl$h)), type = "l",
    xlab = "Normalized frequency (* pi rad/sample)",
    ylab = "Magnitude (dB)")
lines(hf1$w, 20 * log10(abs(hf1$h)), col="red")
lines(hf2$w, 20 * log10(abs(hf2$h)), col="blue")
legend('bottomleft',
       legend = c('Prototype', 'Two passbands', 'Two Stopbands'),
       col=c("black", "red", "blue"), lty = 1)

</code></pre>

<hr>
<h2 id='impinvar'>Impulse invariance method for A/D filter conversion</h2><span id='topic+impinvar'></span><span id='topic+impinvar.Arma'></span><span id='topic+impinvar.default'></span>

<h3>Description</h3>

<p>Convert analog filter with coefficients b and a to digital, conserving
impulse response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impinvar(b, ...)

## S3 method for class 'Arma'
impinvar(b, ...)

## Default S3 method:
impinvar(b, a, fs = 1, tol = 1e-04, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impinvar_+3A_b">b</code></td>
<td>
<p>coefficients of numerator polynomial</p>
</td></tr>
<tr><td><code id="impinvar_+3A_...">...</code></td>
<td>
<p>additional arguments (not used)</p>
</td></tr>
<tr><td><code id="impinvar_+3A_a">a</code></td>
<td>
<p>coefficients of denominator polynomial</p>
</td></tr>
<tr><td><code id="impinvar_+3A_fs">fs</code></td>
<td>
<p>sampling frequency (Default: 1 Hz)</p>
</td></tr>
<tr><td><code id="impinvar_+3A_tol">tol</code></td>
<td>
<p>tolerance. Default: 0.0001</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because <code>impinvar</code> is generic, it can also accept input of class
<code><a href="#topic+Arma">Arma</a></code>.
</p>


<h3>Value</h3>

<p>A list of class <code><a href="#topic+Arma">Arma</a></code> containing numerator and
denominator polynomial filter coefficients of the A/D converted filter.
</p>


<h3>Author(s)</h3>

<p>Tony Richardson, <a href="mailto:arichard@stark.cc.oh.us">arichard@stark.cc.oh.us</a>,<br />
Ben Abbott, <a href="mailto:bpabbott@mac.com">bpabbott@mac.com</a>,<br />
adapted by John W. Eaton.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+invimpinvar">invimpinvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- 2
fs &lt;- 10
but &lt;- butter(6, 2 * pi * f, 'low', 's')
zbut &lt;- impinvar(but, fs)
freqz(zbut, n = 1024, fs = fs)

</code></pre>

<hr>
<h2 id='impz'>Impulse response of digital filter</h2><span id='topic+impz'></span><span id='topic+print.impz'></span><span id='topic+impz.Arma'></span><span id='topic+impz.Ma'></span><span id='topic+impz.Sos'></span><span id='topic+impz.Zpg'></span><span id='topic+impz.default'></span>

<h3>Description</h3>

<p>Compute the z-plane impulse response of an ARMA model or rational IIR
filter. A plot of the impulse and step responses is generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impz(filt, ...)

## S3 method for class 'impz'
print(x, ...)

## S3 method for class 'Arma'
impz(filt, ...)

## S3 method for class 'Ma'
impz(filt, ...)

## S3 method for class 'Sos'
impz(filt, ...)

## S3 method for class 'Zpg'
impz(filt, ...)

## Default S3 method:
impz(filt, a = 1, n = NULL, fs = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impz_+3A_filt">filt</code></td>
<td>
<p>for the default case, the moving-average coefficients of an ARMA
model or filter. Generically, <code>filt</code> specifies an arbitrary model or
filter operation.</p>
</td></tr>
<tr><td><code id="impz_+3A_...">...</code></td>
<td>
<p>for methods of <code>freqz</code>, arguments are passed to the default
method. For <code>plot.impz</code>, additional arguments are passed through to
plot.</p>
</td></tr>
<tr><td><code id="impz_+3A_x">x</code></td>
<td>
<p>object to be printed or plotted.</p>
</td></tr>
<tr><td><code id="impz_+3A_a">a</code></td>
<td>
<p>the autoregressive (recursive) coefficients of an ARMA filter.</p>
</td></tr>
<tr><td><code id="impz_+3A_n">n</code></td>
<td>
<p>number of points at which to evaluate the frequency response. If
<code>n</code> is a vector with a length greater than 1, then evaluate the
frequency response at these points. For fastest computation, <code>n</code>
should factor into a small number of small primes. Default: 512.</p>
</td></tr>
<tr><td><code id="impz_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz. If not specified (default = 2 * pi), the
frequencies are in radians.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>impz</code>, a list of class <code>"impz"</code> with items:
</p>

<dl>
<dt>x</dt><dd><p>impulse response signal.</p>
</dd>
<dt>t</dt><dd><p>time.</p>
</dd>
</dl>



<h3>Note</h3>

<p>When results of <code>impz</code> are printed, <code>plot</code> will be called to
display a plot of the impulse response against frequency. As with lattice
plots, automatic printing does not work inside loops and function calls, so
explicit calls to print or plot are needed there.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Tom Short;<br />
adapted by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## elliptic low-pass filter
elp &lt;- ellip(4, 0.5, 20, 0.4)
impz(elp)

xt &lt;- impz(elp)

</code></pre>

<hr>
<h2 id='interp'>Interpolation</h2><span id='topic+interp'></span>

<h3>Description</h3>

<p>Increase sample rate by integer factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp(x, q, n = 4, Wc = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interp_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector.</p>
</td></tr>
<tr><td><code id="interp_+3A_q">q</code></td>
<td>
<p>interpolation factor, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="interp_+3A_n">n</code></td>
<td>
<p>Half the number of input samples used for interpolation, specified
as a positive integer. For best results, use <code>n</code> no larger than 10.
The low-pass interpolation filter has length <code>2 × n × q + 1</code>. Default:
4.</p>
</td></tr>
<tr><td><code id="interp_+3A_wc">Wc</code></td>
<td>
<p>Normalized cutoff frequency of the input signal, specified as a
positive real scalar not greater than 1 that represents a fraction of the
Nyquist frequency. A value of 1 means that the signal occupies the full
Nyquist interval. Default: 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>interpolated signal, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decimate">decimate</a></code>, <code><a href="#topic+resample">resample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a signal
t &lt;- seq(0, 2, 0.01)
x &lt;- chirp(t, 2, .5, 10,'quadratic') + sin(2 * pi * t * 0.4)
w &lt;- seq(1, 121, 4)
plot(t[w] * 1000, x[w], type = "h", xlab = "", ylab = "")
points(t[w] * 1000, x[w])
abline (h = 0)
y &lt;- interp(x[seq(1, length(x), 4)], 4, 4, 1)
lines(t[1:121] * 1000, y[1:121], type = "l", col = "red")
points(t[1:121] * 1000, y[1:121], col = "red", pch = '+')
legend("topleft", legend = c("original", "interpolated"),
  lty = 1, pch = c(1, 3), col = c(1, 2))

</code></pre>

<hr>
<h2 id='invfreq'>Inverse Frequency Response</h2><span id='topic+invfreq'></span><span id='topic+invfreqs'></span><span id='topic+invfreqz'></span>

<h3>Description</h3>

<p>Identify filter parameters from frequency response data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invfreq(
  h,
  w,
  nb,
  na,
  wt = rep(1, length(w)),
  plane = c("z", "s"),
  method = c("ols", "tls", "qr"),
  norm = TRUE
)

invfreqs(
  h,
  w,
  nb,
  na,
  wt = rep(1, length(w)),
  method = c("ols", "tls", "qr"),
  norm = TRUE
)

invfreqz(
  h,
  w,
  nb,
  na,
  wt = rep(1, length(w)),
  method = c("ols", "tls", "qr"),
  norm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invfreq_+3A_h">h</code></td>
<td>
<p>Frequency response, specified as a vector</p>
</td></tr>
<tr><td><code id="invfreq_+3A_w">w</code></td>
<td>
<p>Angular frequencies at which <code>h</code> is computed, specified as a
vector</p>
</td></tr>
<tr><td><code id="invfreq_+3A_nb">nb</code>, <code id="invfreq_+3A_na">na</code></td>
<td>
<p>Desired order of the numerator and denominator polynomials,
specified as positive integers.</p>
</td></tr>
<tr><td><code id="invfreq_+3A_wt">wt</code></td>
<td>
<p>Weighting factors, specified as a vector of the same length as
<code>w</code>. Default: <code>rep(1, length(w))</code></p>
</td></tr>
<tr><td><code id="invfreq_+3A_plane">plane</code></td>
<td>
<p><code>"z"</code> (default) for discrete-time spectra; <code>"s"</code> for
continuous-time spectra</p>
</td></tr>
<tr><td><code id="invfreq_+3A_method">method</code></td>
<td>
<p>minimization method used to solve the normal equations, one of:
</p>

<dl>
<dt>&quot;ols&quot;</dt><dd><p>ordinary least squares (default)</p>
</dd>
<dt>&quot;tls&quot;</dt><dd><p>total least squares</p>
</dd>
<dt>&quot;qr&quot;</dt><dd><p>QR decomposition</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="invfreq_+3A_norm">norm</code></td>
<td>
<p>logical indicating whether frequencies must be normalized to
avoid matrices with rank deficiency. Default: TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a desired (one-sided, complex) spectrum <code>h(w)</code> at equally spaced
angular frequencies <code class="reqn">w = (2 \pi k) / N</code>, k = 0, ... N-1, this function
finds the filter <code>B(z)/A(z)</code> or <code>B(s)/A(s)</code> with <code>nb</code> zeroes
and <code>na</code> poles. Optionally, the fit-errors can be weighted with respect
to frequency according to the weights <code>wt</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>'Arma'</code> with the following list elements:
</p>

<dl>
<dt>b</dt><dd><p>moving average (MA) polynomial coefficients</p>
</dd>
<dt>a</dt><dd><p>autoregressive (AR) polynomial coefficients</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Julius O. Smith III, Rolf Schirmacher, Andrew Fitting, Pascal
Dupuis.<br /> Conversion to R by Geert van Boxtel,
<a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://ccrma.stanford.edu/~jos/filters/FFT_Based_Equation_Error_Method.html">https://ccrma.stanford.edu/~jos/filters/FFT_Based_Equation_Error_Method.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>order &lt;- 6  # order of test filter
fc &lt;- 1/2   # sampling rate / 4
n &lt;- 128    # frequency grid size
ba &lt;- butter(order, fc)
hw &lt;- freqz(ba, n)
BA = invfreq(hw$h, hw$w, order, order)
HW = freqz(BA, n)
plot(hw$w, abs(hw$h), type = "l", xlab = "Frequency (rad/sample)",
  ylab = "Magnitude")
lines(HW$w, abs(HW$h), col = "red")
legend("topright", legend = c("Original", "Measured"), lty  = 1, col = 1:2)
err &lt;- norm(hw$h - HW$h, type = "2")
title(paste('L2 norm of frequency response error =', err))

</code></pre>

<hr>
<h2 id='invimpinvar'>Inverse impulse invariance method</h2><span id='topic+invimpinvar'></span><span id='topic+invimpinvar.Arma'></span><span id='topic+invimpinvar.default'></span>

<h3>Description</h3>

<p>Convert digital filter with coefficients b and a to analog, conserving
impulse response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invimpinvar(b, ...)

## S3 method for class 'Arma'
invimpinvar(b, ...)

## Default S3 method:
invimpinvar(b, a, fs = 1, tol = 1e-04, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invimpinvar_+3A_b">b</code></td>
<td>
<p>coefficients of numerator polynomial</p>
</td></tr>
<tr><td><code id="invimpinvar_+3A_...">...</code></td>
<td>
<p>additional arguments (not used)</p>
</td></tr>
<tr><td><code id="invimpinvar_+3A_a">a</code></td>
<td>
<p>coefficients of denominator polynomial</p>
</td></tr>
<tr><td><code id="invimpinvar_+3A_fs">fs</code></td>
<td>
<p>sampling frequency (Default: 1 Hz)</p>
</td></tr>
<tr><td><code id="invimpinvar_+3A_tol">tol</code></td>
<td>
<p>tolerance. Default: 0.0001</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because <code>invimpinvar</code> is generic, it can also accept input of class
<code><a href="#topic+Arma">Arma</a></code>.
</p>


<h3>Value</h3>

<p>A list of class <code><a href="#topic+Arma">Arma</a></code> containing numerator and
denominator polynomial filter coefficients of the A/D converted filter.
</p>


<h3>Author(s)</h3>

<p>R.G.H. Eschauzier, <a href="mailto:reschauzier@yahoo.com">reschauzier@yahoo.com</a>,<br />
Carne Draug, <a href="mailto:carandraug+dev@gmail.com">carandraug+dev@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>References</h3>

<p>Thomas J. Cavicchi (1996) Impulse invariance and multiple-order
poles. IEEE transactions on signal processing, Vol 40 (9): 2344&ndash;2347.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+impinvar">impinvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- 2
fs &lt;- 10
but &lt;- butter(6, 2 * pi * f, 'low', 's')
zbut &lt;- impinvar(but, fs)
sbut &lt;- invimpinvar(zbut, fs)
all.equal(but, sbut, tolerance = 1e-7)

</code></pre>

<hr>
<h2 id='kaiser'>Kaiser window</h2><span id='topic+kaiser'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a kaiser window of length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kaiser(n, beta = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kaiser_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="kaiser_+3A_beta">beta</code></td>
<td>
<p>Shape factor, specified as a positive real scalar. The parameter
<code>beta</code> affects the side lobe attenuation of the Fourier transform of
the window. Default: 0.5</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kaiser, or Kaiser-Bessel, window is a simple approximation of the DPSS
window using Bessel functions, discovered by James Kaiser.

</p>
<pre>
        besselI(0, Beta * sqrt(1-(2*x/m)^2))
k(x) =  -------------------------------------,  -m/2 &lt;= x &lt;= m/2
        besselO(0, Beta)
</pre>
<p>The variable parameter <code class="reqn">\beta</code> determines the trade-off between main lobe
width and side lobe levels of the spectral leakage pattern. Increasing
<code class="reqn">\beta</code> widens the main lobe and decreases the amplitude of the side
lobes (i.e., increases the attenuation).
</p>


<h3>Value</h3>

<p>Kaiser window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Kurt Hornik, <a href="mailto:Kurt.Hornik@ci.tuwien.ac.at">Kurt.Hornik@ci.tuwien.ac.at</a>,<br /> Paul Kienzle,
<a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br /> Conversion to R by Geert van Boxtel
<a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
k &lt;- kaiser(200, 2.5)
plot (k, type = "l", xlab = "Samples", ylab =" Amplitude")

</code></pre>

<hr>
<h2 id='kaiserord'>Kaiser filter order and cutoff frequency</h2><span id='topic+kaiserord'></span>

<h3>Description</h3>

<p>Return the parameters needed to produce a FIR filter of the desired
specification from a Kaiser window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kaiserord(f, m, dev, fs = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kaiserord_+3A_f">f</code></td>
<td>
<p>frequency bands, given as pairs, with the first half of the first
pair assumed to start at 0 and the last half of the last pair assumed to
end at 1. It is important to separate the band edges, since narrow
transition regions require large order filters.</p>
</td></tr>
<tr><td><code id="kaiserord_+3A_m">m</code></td>
<td>
<p>magnitude within each band. Should be non-zero for pass band and
zero for stop band. All passbands must have the same magnitude, or you will
get the error that pass and stop bands must be strictly alternating.</p>
</td></tr>
<tr><td><code id="kaiserord_+3A_dev">dev</code></td>
<td>
<p>deviation within each band. Since all bands in the resulting
filter have the same deviation, only the minimum deviation is used. In this
version, a single scalar will work just as well.</p>
</td></tr>
<tr><td><code id="kaiserord_+3A_fs">fs</code></td>
<td>
<p>sampling rate. Used to convert the frequency specification into the
c(0, 1) range, where 1 corresponds to the Nyquist frequency, <code>fs / 2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set of specifications in the frequency domain, <code>kaiserord</code>
estimates the minimum FIR filter order that will approximately meet the
specifications. <code>kaiserord</code> converts the given filter specifications
into passband and stopband ripples and converts cutoff frequencies into the
form needed for windowed FIR filter design.
</p>
<p><code>kaiserord</code> uses empirically derived formulas for estimating the orders
of lowpass filters, as well as differentiators and Hilbert transformers.
Estimates for multiband filters (such as band-pass filters) are derived from
the low-pass design formulas.
</p>
<p>The design formulas that underlie the Kaiser window and its application to
FIR filter design are
</p>
<p style="text-align: center;"><code class="reqn">\beta =</code>
</p>

<p style="text-align: center;"><code class="reqn">0.1102(\alpha - 8.7), \alpha &gt; 50</code>
</p>

<p style="text-align: center;"><code class="reqn">0.5842(\alpha -21)^{0.4} + 0.07886(\alpha - 21), 21 \le \alpha \le 50</code>
</p>

<p style="text-align: center;"><code class="reqn">0, \alpha &lt; 21</code>
</p>

<p>where <code class="reqn">\alpha = -20log_{10}(\delta)</code> is the stopband attenuation
expressed in decibels, <code class="reqn">n=(\alpha - 8) / 2.285(\Delta\omega)</code>, where
<code class="reqn">n</code> is the filter order and <code class="reqn">\Delta\omega</code> is the width of the
smallest transition region.
</p>


<h3>Value</h3>

<p>A list of class <code><a href="#topic+FilterSpecs">FilterSpecs</a></code> with the following list
elements:
</p>

<dl>
<dt>n</dt><dd><p>filter order</p>
</dd>
<dt>Wc</dt><dd><p>cutoff frequency</p>
</dd>
<dt>type</dt><dd><p>filter type, one of &quot;low&quot;, &quot;high&quot;, &quot;stop&quot;, &quot;pass&quot;, &quot;DC-0&quot;, or
&quot;DC-1&quot;.</p>
</dd>
<dt>beta</dt><dd><p>shape parameter</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Paul Kienzle.<br />
Conversion to R by Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hamming">hamming</a></code>, <code><a href="#topic+kaiser">kaiser</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- 11025
op &lt;- par(mfrow = c(2, 2), mar = c(3, 3, 1, 1))
for (i in 1:4) {
  if (i == 1) {
    bands &lt;- c(1200, 1500)
    mag &lt;- c(1, 0)
    dev &lt;- c(0.1, 0.1)
  }
  if (i == 2) {
    bands &lt;- c(1000, 1500)
    mag &lt;- c(0, 1)
    dev &lt;- c(0.1, 0.1)
  }
  if (i == 3) {
    bands &lt;- c(1000, 1200, 3000, 3500)
    mag &lt;- c(0, 1, 0)
    dev &lt;- 0.1
  }
  if (i == 4) {
    bands &lt;- 100 * c(10, 13, 15, 20, 30, 33, 35, 40)
    mag &lt;- c(1, 0, 1, 0, 1)
    dev &lt;- 0.05
  }
  kaisprm &lt;- kaiserord(bands, mag, dev, fs)
  d &lt;- max(1, trunc(kaisprm$n / 10))
  if (mag[length(mag)] == 1 &amp;&amp; (d %% 2) == 1) {
     d &lt;- d + 1
  }
  f1 &lt;- freqz(fir1(kaisprm$n, kaisprm$Wc, kaisprm$type,
                   kaiser(kaisprm$n + 1, kaisprm$beta),
                   scale = FALSE),
              fs = fs)
  f2 &lt;- freqz(fir1(kaisprm$n - d, kaisprm$Wc, kaisprm$type,
                   kaiser(kaisprm$n - d + 1, kaisprm$beta),
                   scale = FALSE),
              fs = fs)
  plot(f1$w, abs(f1$h), col = "blue", type = "l",  xlab = "", ylab = "")
  lines(f2$w, abs(f2$h), col = "red")
  legend("right", paste("order", c(kaisprm$n-d, kaisprm$n)),
         col = c("red", "blue"), lty = 1, bty = "n")
  b &lt;- c(0, bands, fs/2)
  for (i in seq(2, length(b), by=2)) {
    hi &lt;- mag[i/2] + dev[1]
    lo &lt;- max(mag[i/2] - dev[1], 0)
    lines(c(b[i-1], b[i], b[i], b[i-1], b[i-1]), c(hi, hi, lo, lo, hi))
  }
}
par(op)

</code></pre>

<hr>
<h2 id='levinson'>Durbin-Levinson Recursion</h2><span id='topic+levinson'></span>

<h3>Description</h3>

<p>Use the Durbin-Levinson algorithm to compute the coefficients of an
autoregressive linear process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levinson(acf, p = NROW(acf))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levinson_+3A_acf">acf</code></td>
<td>
<p>autocorrelation function for lags 0 to <code>p</code>, specified as a
vector or matrix. If r is a matrix, the function finds the coefficients for
each column of <code>acf</code> and returns them in the rows of <code>a</code>.</p>
</td></tr>
<tr><td><code id="levinson_+3A_p">p</code></td>
<td>
<p>model order, specified as a positive integer. Default:
<code>NROW(acf) - 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>levinson</code> uses the Durbin-Levinson algorithm to solve:
</p>
<p style="text-align: center;"><code class="reqn">toeplitz(acf(1:p)) * x = -acf(2:p+1)</code>
</p>
<p> The solution <code>c(1, x)</code> is
the denominator of an all pole filter approximation to the signal <code>x</code>
which generated the autocorrelation function acf.
</p>
<p>From ref [2]: Levinson recursion or Levinson–Durbin recursion is a procedure
in linear algebra to recursively calculate the solution to an equation
involving a Toeplitz matrix. Other methods to process data include Schur
decomposition and Cholesky decomposition. In comparison to these, Levinson
recursion (particularly split Levinson recursion) tends to be faster
computationally, but more sensitive to computational inaccuracies like
round-off errors.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing the following elements:
</p>

<dl>
<dt>a</dt><dd><p>vector or matrix containing <code>(p+1)</code> autoregression
coefficients. If <code>x</code> is a matrix, then each row of a corresponds to
a column of <code>x</code>. <code>a</code> has <code>p + 1</code> columns.</p>
</dd>
<dt>e</dt><dd><p>white noise input variance, returned as a vector. If <code>x</code> is
a matrix, then each element of e corresponds to a column of <code>x</code>.</p>
</dd>
<dt>k</dt><dd><p>Reflection coefficients defining the lattice-filter embodiment
of the model returned as vector or a matrix. If <code>x</code> is a matrix,
then each column of <code>k</code> corresponds to a column of <code>x</code>.
<code>k</code> has <code>p</code> rows.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Peter V. Lanspeary, <a href="mailto:pvl@mecheng.adelaide.edu.au">pvl@mecheng.adelaide.edu.au</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] Steven M. Kay and Stanley Lawrence Marple Jr. (1981).
Spectrum analysis – a modern perspective. Proceedings of the IEEE, Vol 69,
1380-1419.<br />
[2] <a href="https://en.wikipedia.org/wiki/Levinson_recursion">https://en.wikipedia.org/wiki/Levinson_recursion</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Estimate the coefficients of an autoregressive process given by
## x(n) = 0.1x(n-1) - 0.8x(n-2) - 0.27x(n-3) + w(n).
a &lt;- c(1, 0.1, -0.8, -0.27)
v &lt;- 0.4
w &lt;- sqrt(v) * rnorm(15000)
x &lt;- filter(1, a, w)
xc &lt;- xcorr(x, scale = 'biased')
acf &lt;- xc$R[-which(xc$lags &lt; 0)]
lev &lt;- levinson(acf, length(a) - 1)

</code></pre>

<hr>
<h2 id='Ma'>Moving average (MA) model</h2><span id='topic+Ma'></span>

<h3>Description</h3>

<p>Create an MA model representing a filter or system model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ma(b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ma_+3A_b">b</code></td>
<td>
<p>moving average (MA) polynomial coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>Ma</code> with the polynomial coefficients
</p>


<h3>Author(s)</h3>

<p>Tom Short, <a href="mailto:tshort@eprisolutions.com">tshort@eprisolutions.com</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+Arma">Arma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- Ma(b = c(1, 2, 1) / 3)
freqz(f)
zplane(f)

</code></pre>

<hr>
<h2 id='marcumq'>Marcum Q function</h2><span id='topic+marcumq'></span>

<h3>Description</h3>

<p>Compute the generalized Marcum Q function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marcumq(a, b, m = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marcumq_+3A_a">a</code>, <code id="marcumq_+3A_b">b</code></td>
<td>
<p>input arguments, specified as non-negative real numbers.</p>
</td></tr>
<tr><td><code id="marcumq_+3A_m">m</code></td>
<td>
<p>order, specified as a positive integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code for this function was taken from the help file of the <code>cdfkmu</code>
function in the <code>lmomco</code> package, based on a suggestion of Daniel
Wollschlaeger.
</p>


<h3>Value</h3>

<p>Marcum Q function.
</p>


<h3>Author(s)</h3>

<p>William Asquith, <a href="mailto:william.asquith@ttu.edu">william.asquith@ttu.edu</a>.
</p>


<h3>References</h3>

<p><a href="https://cran.r-project.org/package=lmomco">https://cran.r-project.org/package=lmomco</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mq &lt;- marcumq(12.4, 12.5)

</code></pre>

<hr>
<h2 id='medfilt1'>1-D median filtering</h2><span id='topic+medfilt1'></span>

<h3>Description</h3>

<p>Apply a running median of odd span to the input <code>x</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medfilt1(x, n = 3, MARGIN = 2, na.omit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="medfilt1_+3A_x">x</code></td>
<td>
<p>Input signal, specified as a numeric vector, matrix or array.</p>
</td></tr>
<tr><td><code id="medfilt1_+3A_n">n</code></td>
<td>
<p>positive integer width of the median window; must be odd. Default: 3</p>
</td></tr>
<tr><td><code id="medfilt1_+3A_margin">MARGIN</code></td>
<td>
<p>Vector giving the subscripts which the function will be applied
over. E.g., for a matrix 1 indicates rows, 2 indicates columns, c(1, 2)
indicates rows and columns. Where X has named dimnames, it can be a
character vector selecting dimension names. Default: 2 (columns).</p>
</td></tr>
<tr><td><code id="medfilt1_+3A_na.omit">na.omit</code></td>
<td>
<p>logical indicating whether to omit missing values,
or interpolate then using a cubic spline function
(<code><a href="stats.html#topic+splinefun">splinefun</a></code>). Default: FALSE</p>
</td></tr>
<tr><td><code id="medfilt1_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>runmed</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a running median over the input <code>x</code>, using the
<code><a href="stats.html#topic+runmed">runmed</a></code> function. Because of that, it works a little
differently than the 'Matlab' or 'Octave' versions (i.e., it does not produce
exactly the same values).
</p>

<dl>
<dt>missing values</dt><dd><p>The 'Mablab' and 'Octave' functions have a
<code>'nanflag'</code> option that allows to include or remove missing values. If
inclusion is specifies, then the function returns a signal so that the median
of any segment containing NAs is also NA. Because the <code>'runmed'</code> function
does not include an <code>na.omit</code> option, implementing this functionality
would lead to a considerable speed loss. Instead, a <code>na.omit</code> parameter
was implemented that allows either omitting NAs or interpolating them with a
spline function.</p>
</dd>
<dt>endpoint filtering</dt><dd><p>Instead of the <code>'zeropad'</code> and
<code>'truncate'</code> options to the <code>'padding'</code> argument in the 'Matlab'
and 'Octave' functions, the present version uses the standard
<code>endrule</code> parameter of the <code>'runmed'</code> function, with options
<code>keep</code>, <code>constant</code>, or <code>median</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Filtered signal, returned as a numeric vector, matrix, or array, of
the same size as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+runmed">runmed</a></code>, <code><a href="stats.html#topic+splinefun">splinefun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## noise suppression
fs &lt;- 100
t &lt;- seq(0, 1, 1/fs)
x &lt;- sin(2 * pi * t * 3) + 0.25 * sin(2 * pi * t * 40)
plot(t, x, type = "l", xlab = "", ylab = "")
y &lt;- medfilt1(x, 11)
lines (t, y, col = "red")
legend("topright", c("Original", "Filtered"), lty = 1, col = 1:2)

</code></pre>

<hr>
<h2 id='mexihat'>Mexicat Hat</h2><span id='topic+mexihat'></span>

<h3>Description</h3>

<p>Generate a Mexican Hat (Ricker) wavelet sampled on a regular grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mexihat(lb = -5, ub = 5, n = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mexihat_+3A_lb">lb</code>, <code id="mexihat_+3A_ub">ub</code></td>
<td>
<p>Lower and upper bounds of the interval to evaluate the wavelet
on. Default: -5 to 5.</p>
</td></tr>
<tr><td><code id="mexihat_+3A_n">n</code></td>
<td>
<p>Number of points on the grid between <code>lb</code> and <code>ub</code> (length
of the wavelet). Default: 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Mexican Hat or Ricker wavelet is the negative normalized second
derivative of a Gaussian function, i.e., up to scale and normalization, the
second Hermite function. It is a special case of the family of continuous
wavelets (wavelets used in a continuous wavelet transform) known as Hermitian
wavelets. The Ricker wavelet is frequently employed to model seismic data,
and as a broad spectrum source term in computational electrodynamics. It is
usually only referred to as the Mexican hat wavelet in the Americas, due to
taking the shape of a sombrero when used as a 2D image processing kernel. It
is also known as the Marr wavelet (source: Wikipedia)
</p>


<h3>Value</h3>

<p>A list containing 2 variables; <code>x</code>, the grid on which the
complex Mexican Hat wavelet was evaluated, and <code>psi</code> (<code class="reqn">\Psi</code>), the
evaluated wavelet on the grid <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mh &lt;- mexihat(-5, 5, 1000)
plot(mh$x, mh$psi, type="l", main = "Mexican Hat Wavelet",
     xlab = "", ylab = "")

</code></pre>

<hr>
<h2 id='meyeraux'>Meyer wavelet auxiliary function</h2><span id='topic+meyeraux'></span>

<h3>Description</h3>

<p>Compute the Meyer wavelet auxiliary function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meyeraux(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meyeraux_+3A_x">x</code></td>
<td>
<p>Input array, specified as a real scalar, vector, matrix, or
multidimensional array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code <code>y = meyeraux(x)</code> returns values of the auxiliary function used
for Meyer wavelet generation evaluated at the elements of <code>x</code>. The input
<code>x</code> is a vector or matrix of real values. The function is </p>
<p style="text-align: center;"><code class="reqn">y =
35x^{4} - 84x^{5} + 70x^{6} - 20x^{7}.</code>
</p>
 <p><code>x</code> and <code>y</code> have the same
dimensions. The range of <code>meyeraux</code> is the closed interval c(0, 1).
</p>


<h3>Value</h3>

<p>Output array, returned as a real-valued scalar, vector, matrix, or
multidimensional array of the same size as x.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(0, 1, length.out = 100)
y &lt;- meyeraux(x)
plot(x, y, type="l", main = "Meyer wavelet auxiliary function",
     xlab = "", ylab = "")

</code></pre>

<hr>
<h2 id='morlet'>Morlet Wavelet</h2><span id='topic+morlet'></span>

<h3>Description</h3>

<p>Compute the Morlet wavelet on a regular grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morlet(lb = -4, ub = 4, n = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="morlet_+3A_lb">lb</code>, <code id="morlet_+3A_ub">ub</code></td>
<td>
<p>Lower and upper bounds of the interval to evaluate the wavelet
on. Default: -4 to 4.</p>
</td></tr>
<tr><td><code id="morlet_+3A_n">n</code></td>
<td>
<p>Number of points on the grid between <code>lb</code> and <code>ub</code> (length
of the wavelet). Default: 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code <code>m &lt;- morlet(lb, ub, n)</code> returns values of the Morlet wavelet
on an <code>n</code>-point regular grid in the interval <code>c(lb, ub)</code>.
</p>
<p>The Morlet waveform is defined as
</p>
<p style="text-align: center;"><code class="reqn">\psi(x) = e^{-x^{2}/2} cos (5x)</code>
</p>



<h3>Value</h3>

<p>A list containing 2 variables; <code>x</code>, the grid on which the Morlet
wavelet was evaluated, and <code>psi</code> (<code class="reqn">\Psi</code>), the evaluated wavelet
on the grid <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- morlet(-4, 4, 1000)
plot(m$x, m$psi, type="l", main = "Morlet Wavelet", xlab = "", ylab = "")

</code></pre>

<hr>
<h2 id='movingrms'>Moving Root Mean Square</h2><span id='topic+movingrms'></span>

<h3>Description</h3>

<p>Compute the moving root mean square (RMS) of the input signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movingrms(x, width = 0.1, rc = 0.001, fs = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movingrms_+3A_x">x</code></td>
<td>
<p>Input signal, specified as a numeric vector or matrix. In case of a
matrix, the function operates along the columns</p>
</td></tr>
<tr><td><code id="movingrms_+3A_width">width</code></td>
<td>
<p>width of the sigmoid window, in units relative to <code>fs</code>.
Default: 0.1</p>
</td></tr>
<tr><td><code id="movingrms_+3A_rc">rc</code></td>
<td>
<p>Rise time (time constant) of the sigmoid window, in units relative
to <code>fs</code>. Default: 1e-3</p>
</td></tr>
<tr><td><code id="movingrms_+3A_fs">fs</code></td>
<td>
<p>Sampling frequency. Default: 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The signal is convoluted against a sigmoid window of width <code>w</code> and
risetime <code>rc</code>. The units of these parameters are relative to the value
of the sampling frequency given in <code>fs</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> containing 2 variables:
</p>

<dl>
<dt>rmsx</dt><dd><p>Output signal with the same dimensions as <code>x</code></p>
</dd>
<dt>w</dt><dd><p>Window, returned as a vector</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Juan Pablo Carbajal, <a href="mailto:carbajal@ifi.uzh.ch">carbajal@ifi.uzh.ch</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sigmoid_train">sigmoid_train</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>       
N &lt;- 128
fs &lt;- 5
t &lt;- seq(0, 1, length.out = N)
x &lt;- sin(2 * pi * fs * t) + runif(N)
y &lt;- movingrms(x, 5)

</code></pre>

<hr>
<h2 id='mpoles'>Multiplicity of poles</h2><span id='topic+mpoles'></span>

<h3>Description</h3>

<p>Identify unique poles and their associated multiplicity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpoles(p, tol = 0.001, reorder = TRUE, index.return = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpoles_+3A_p">p</code></td>
<td>
<p>vector of poles.</p>
</td></tr>
<tr><td><code id="mpoles_+3A_tol">tol</code></td>
<td>
<p>tolerance. If the relative difference of two poles is less than
<code>tol</code> then they are considered to be multiples. The default value for
<code>tol</code> is 0.001.</p>
</td></tr>
<tr><td><code id="mpoles_+3A_reorder">reorder</code></td>
<td>
<p>logical. If <code>TRUE</code>, (default), the output is ordered from
largest pole to smallest pole.</p>
</td></tr>
<tr><td><code id="mpoles_+3A_index.return">index.return</code></td>
<td>
<p>logical indicating if index vector should be returned as
well. See examples. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>index.return = TRUE</code>, a list consisting of two vectors:
</p>

<dl>
<dt>m</dt><dd><p>vector specifying the multiplicity of the poles</p>
</dd>
<dt>n</dt><dd><p>index</p>
</dd>
</dl>

<p>If <code>index.return = FALSE</code>, only <code>m</code> is returned (as a vector).
</p>


<h3>Author(s)</h3>

<p>Ben Abbott, <a href="mailto:bpabbott@mac.com">bpabbott@mac.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+poly">poly</a></code>, <code><a href="#topic+residue">residue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(2, 3, 1, 1, 2)
ret &lt;- mpoles(p, index = TRUE)

</code></pre>

<hr>
<h2 id='mscohere'>Magnitude-squared coherence</h2><span id='topic+mscohere'></span><span id='topic+cohere'></span>

<h3>Description</h3>

<p>Compute the magnitude-squared coherence estimates of input signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mscohere(
  x,
  window = nextpow2(sqrt(NROW(x))),
  overlap = 0.5,
  nfft = ifelse(isScalar(window), window, length(window)),
  fs = 1,
  detrend = c("long-mean", "short-mean", "long-linear", "short-linear", "none")
)

cohere(
  x,
  window = nextpow2(sqrt(NROW(x))),
  overlap = 0.5,
  nfft = ifelse(isScalar(window), window, length(window)),
  fs = 1,
  detrend = c("long-mean", "short-mean", "long-linear", "short-linear", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mscohere_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="mscohere_+3A_window">window</code></td>
<td>
<p>If <code>window</code> is a vector, each segment has the same length
as <code>window</code> and is multiplied by <code>window</code> before (optional)
zero-padding and calculation of its periodogram. If <code>window</code> is a
scalar, each segment has a length of <code>window</code> and a Hamming window is
used. Default: <code>nextpow2(sqrt(length(x)))</code> (the square root of the
length of <code>x</code> rounded up to the next power of two). The window length
must be larger than 3.</p>
</td></tr>
<tr><td><code id="mscohere_+3A_overlap">overlap</code></td>
<td>
<p>segment overlap, specified as a numeric value expressed as a
multiple of window or segment length. 0 &lt;= overlap &lt; 1. Default: 0.5.</p>
</td></tr>
<tr><td><code id="mscohere_+3A_nfft">nfft</code></td>
<td>
<p>Length of FFT, specified as an integer scalar. The default is the
length of the <code>window</code> vector or has the same value as the scalar
<code>window</code> argument.  If <code>nfft</code> is larger than the segment length,
(seg_len), the data segment is padded <code>nfft - seg_len</code> zeros. The
default is no padding. Nfft values smaller than the length of the data
segment (or window) are ignored. Note that the use of padding to increase
the frequency resolution of the spectral estimate is controversial.</p>
</td></tr>
<tr><td><code id="mscohere_+3A_fs">fs</code></td>
<td>
<p>sampling frequency (Hertz), specified as a positive scalar.
Default: 1.</p>
</td></tr>
<tr><td><code id="mscohere_+3A_detrend">detrend</code></td>
<td>
<p>character string specifying detrending option; one of:
</p>

<dl>
<dt><code>long-mean</code></dt><dd><p>remove the mean from the data before
splitting into segments (default)</p>
</dd>
<dt><code>short-mean</code></dt><dd><p>remove the mean value of each segment</p>
</dd>
<dt><code>long-linear</code></dt><dd><p>remove linear trend from the data before
splitting into segments</p>
</dd>
<dt><code>short-linear</code></dt><dd><p>remove linear trend from each segment</p>
</dd>
<dt><code>none</code></dt><dd><p>no detrending</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mscohere</code> estimates the magnitude-squared coherence function using
Welch’s overlapped averaged periodogram method [1]
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>freq</code></dt><dd><p>vector of frequencies at which the spectral variables
are estimated. If <code>x</code> is numeric, power from negative frequencies is
added to the positive side of the spectrum, but not at zero or Nyquist
(fs/2) frequencies. This keeps power equal in time and spectral domains.
If <code>x</code> is complex, then the whole frequency range is returned.</p>
</dd>
<dt><code>coh</code></dt><dd><p>NULL for univariate series. For multivariate series, a
matrix containing the squared coherence between different series. Column
<code class="reqn">i + (j - 1) * (j - 2)/2 </code> of <code>coh</code> contains the cross-spectral
estimates between columns <code class="reqn">i</code> and <code class="reqn">j</code> of <code class="reqn">x</code>, where <code class="reqn">i &lt;
    j</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The function <code>mscohere</code> (and its deprecated alias <code>cohere</code>)
is a wrapper for the function <code>pwelch</code>, which is more complete and
more flexible.
</p>


<h3>Author(s)</h3>

<p>Peter V. Lanspeary, <a href="mailto:pvl@mecheng.adelaide.edu.au">pvl@mecheng.adelaide.edu.au</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] Welch, P.D. (1967). The use of Fast Fourier Transform for
the estimation of power spectra: A method based on time averaging over
short, modified periodograms. IEEE Transactions on Audio and
Electroacoustics, AU-15 (2): 70–73.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- 1000
f &lt;- 250
t &lt;- seq(0, 1 - 1/fs, 1/fs)
s1 &lt;- sin(2 * pi * f * t) + runif(length(t))
s2 &lt;- sin(2 * pi * f * t - pi / 3) + runif(length(t))
rv &lt;- mscohere(cbind(s1, s2), fs = fs)
plot(rv$freq, rv$coh, type="l", xlab = "Frequency", ylab = "Coherence")

</code></pre>

<hr>
<h2 id='ncauer'>ncauer analog filter design</h2><span id='topic+ncauer'></span>

<h3>Description</h3>

<p>Compute the transfer function coefficients of a Cauer analog filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncauer(Rp, Rs, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncauer_+3A_rp">Rp</code></td>
<td>
<p>dB of passband ripple.</p>
</td></tr>
<tr><td><code id="ncauer_+3A_rs">Rs</code></td>
<td>
<p>dB of stopband ripple.</p>
</td></tr>
<tr><td><code id="ncauer_+3A_n">n</code></td>
<td>
<p>filter order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cauer filters have equal maximum ripple in the passband and the stopband. The
Cauer filter has a faster transition from the passband to the stopband than
any other class of network synthesis filter. The term Cauer filter can be
used interchangeably with elliptical filter, but the general case of
elliptical filters can have unequal ripples in the passband and stopband. An
elliptical filter in the limit of zero ripple in the passband is identical to
a Chebyshev Type 2 filter. An elliptical filter in the limit of zero ripple
in the stopband is identical to a Chebyshev Type 1 filter. An elliptical
filter in the limit of zero ripple in both passbands is identical to a
Butterworth filter. The filter is named after Wilhelm Cauer and the transfer
function is based on elliptic rational functions.Cauer-type filters use
generalized continued fractions.[1]
</p>


<h3>Value</h3>

<p>A list of class Zpg with the following list elements:
</p>

<dl>
<dt>zero</dt><dd><p>complex vector of the zeros of the model</p>
</dd>
<dt>pole</dt><dd><p>complex vector of the poles of the model</p>
</dd>
<dt>gain</dt><dd><p>gain of the model</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Paulo Neis, <a href="mailto:p_neis@yahoo.com.br">p_neis@yahoo.com.br</a>.<br />
Conversion to R Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1]
<a href="https://en.wikipedia.org/wiki/Network_synthesis_filters#Cauer_filter">https://en.wikipedia.org/wiki/Network_synthesis_filters#Cauer_filter</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Zpg">Zpg</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+ellip">ellip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zpg &lt;- ncauer(1, 40, 5)
freqz(zpg)
zplane(zpg)

</code></pre>

<hr>
<h2 id='nuttallwin'>Nuttall-defined minimum 4-term Blackman-Harris window</h2><span id='topic+nuttallwin'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a Blackman-Harris window defined by Nuttall
of length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nuttallwin(n, method = c("symmetric", "periodic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nuttallwin_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="nuttallwin_+3A_method">method</code></td>
<td>
<p>Character string. Window sampling method, specified as:
</p>

<dl>
<dt>&quot;symmetric&quot;</dt><dd><p>(Default). Use this option when using windows for filter
design.</p>
</dd>
<dt>&quot;periodic&quot;</dt><dd><p>This option is useful for spectral analysis because it
enables a windowed signal to have the perfect periodic extension implicit
in the discrete Fourier transform. When <code>periodic</code> is specified, the
function computes a window of length <code>n + 1</code> and returns the first
<code>n</code> points.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The window is minimum in the sense that its maximum sidelobes are minimized.
The coefficients for this window differ from the Blackman-Harris window
coefficients computed with <code>blackmanharris</code> and produce slightly lower
sidelobes.
</p>


<h3>Value</h3>

<p>Nuttall-defined Blackman-Harris window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blackman">blackman</a></code>, <code><a href="#topic+blackmanharris">blackmanharris</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- nuttallwin(64)
plot (n, type = "l", xlab = "Samples", ylab =" Amplitude")

</code></pre>

<hr>
<h2 id='pad'>Pad data</h2><span id='topic+pad'></span><span id='topic+prepad'></span><span id='topic+postpad'></span>

<h3>Description</h3>

<p>Pre- or postpad the data object <code>x</code> with the value <code>c</code> until it is
of length <code>l</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad(x, l, c = 0, MARGIN = 2, direction = c("both", "pre", "post"))

prepad(x, l, c = 0, MARGIN = 2)

postpad(x, l, c = 0, MARGIN = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_+3A_x">x</code></td>
<td>
<p>Vector or matrix to be padded</p>
</td></tr>
<tr><td><code id="pad_+3A_l">l</code></td>
<td>
<p>Length of output data along the padding dimension. If <code>length
(x) &gt; l</code>, elements from the beginning (<code>dimension = "pre"</code>) or the end
(<code>direction = "post"</code>) of <code>x</code> are removed until a vector of
length <code>l</code> is obtained. If <code>direction = "both"</code>, values are
removed from both ends, and in case of an uneven length the smallest number
of elements is removed from the beginning of vector.</p>
</td></tr>
<tr><td><code id="pad_+3A_c">c</code></td>
<td>
<p>Value to be used for the padding (scalar). Must be of the same type
as the elements in <code>x</code>. Default: 0</p>
</td></tr>
<tr><td><code id="pad_+3A_margin">MARGIN</code></td>
<td>
<p>A vector giving the subscripts which the function will be
applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns,
c(1, 2) indicates rows and columns. Where <code>x</code> has named dimnames, it
can be a character vector selecting dimension names.  If <code>MARGIN</code> is
larger than the dimensions of <code>x</code>, the result will have <code>MARGIN</code>
dimensions. Default: 2 (columns).</p>
</td></tr>
<tr><td><code id="pad_+3A_direction">direction</code></td>
<td>
<p>Where to pad the array along each dimension. One of the
following:
</p>

<dl>
<dt>&quot;pre&quot;</dt><dd><p>Before the first element</p>
</dd>
<dt>&quot;post&quot;</dt><dd><p>After the last element</p>
</dd>
<dt>&quot;both&quot;</dt><dd><p>(default) Before the first and after the last element</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Padded data, returned as a vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- 1:24
res &lt;- postpad(v, 30)
res &lt;- postpad(v, 20)
res &lt;- prepad(v, 30)
res &lt;- prepad(v, 20)

m &lt;- matrix(1:24, 4, 6)
res &lt;- postpad(m, 8, 100)
res &lt;- postpad(m, 8, 100, MARGIN = 1)
res &lt;- prepad(m, 8, 100)
res &lt;- prepad(m, 8, 100, MARGIN = 1)

res &lt;- postpad(m, 2)
res &lt;- postpad(m, 2, MARGIN = 1)
res &lt;- prepad(m, 2)
res &lt;- prepad(m, 2, MARGIN = 1)

</code></pre>

<hr>
<h2 id='parzenwin'>Parzen (de la Vallée Poussin) window</h2><span id='topic+parzenwin'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a Parzen window of length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parzenwin(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parzenwin_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parzen windows are piecewise-cubic approximations of Gaussian windows.
</p>


<h3>Value</h3>

<p>Parzen window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- parzenwin(64)
g &lt;- gausswin(64)
plot (p, type = "l", xlab = "Samples", ylab =" Amplitude", ylim = c(0, 1))
lines(g, col = "red")

</code></pre>

<hr>
<h2 id='pburg'>Autoregressive PSD estimate - Burg's method</h2><span id='topic+pburg'></span>

<h3>Description</h3>

<p>Calculate Burg maximum-entropy power spectral density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pburg(
  x,
  p,
  criterion = NULL,
  freq = 256,
  fs = 1,
  range = NULL,
  method = if (length(freq) == 1 &amp;&amp; bitwAnd(freq, freq - 1) == 0) "fft" else "poly"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pburg_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric or complex vector or matrix. In
case of a vector it represents a single signal; in case of a matrix each
column is a signal.</p>
</td></tr>
<tr><td><code id="pburg_+3A_p">p</code></td>
<td>
<p>model order; number of poles in the AR model or limit to the number
of poles if a valid criterion is provided. Must be &lt; length(x) - 2.</p>
</td></tr>
<tr><td><code id="pburg_+3A_criterion">criterion</code></td>
<td>
<p>model-selection criterion. Limits the number of poles so
that spurious poles are not added when the whitened data has no more
information in it. Recognized values are:
</p>

<dl>
<dt>&quot;AKICc&quot;</dt><dd><p>approximate corrected Kullback information criterion
(recommended)</p>
</dd>
<dt>&quot;KIC&quot;</dt><dd><p>Kullback information criterion</p>
</dd>
<dt>&quot;AICc&quot;</dt><dd><p>corrected Akaike information criterion</p>
</dd>
<dt>&quot;AIC&quot;</dt><dd><p>Akaike information criterion</p>
</dd>
<dt>&quot;FPE&quot;</dt><dd><p>final prediction error</p>
</dd>
</dl>

<p>The default is to NOT use a model-selection criterion (NULL)</p>
</td></tr>
<tr><td><code id="pburg_+3A_freq">freq</code></td>
<td>
<p>vector of frequencies at which power spectral density is
calculated, or a scalar indicating the number of uniformly distributed
frequency values at which spectral density is calculated. Default: 256.</p>
</td></tr>
<tr><td><code id="pburg_+3A_fs">fs</code></td>
<td>
<p>sampling frequency (Hz). Default: 1</p>
</td></tr>
<tr><td><code id="pburg_+3A_range">range</code></td>
<td>
<p>character string. one of:
</p>

<dl>
<dt><code>"half"</code> or <code>"onesided"</code></dt><dd><p>frequency range of the spectrum
is from zero up to but not including <code>fs / 2</code>. Power from negative
frequencies is added to the positive side of the spectrum.</p>
</dd>
<dt><code>"whole"</code> or <code>"twosided"</code></dt><dd><p>frequency range of the spectrum
is <code>-fs / 2</code> to <code>fs / 2</code>, with negative frequencies stored in
&quot;wrap around order&quot; after the positive frequencies; e.g. frequencies for a
10-point <code>"twosided"</code> spectrum are 0 0.1 0.2 0.3 0.4 0.5 -0.4 -0.3
-0.2. -0.1.</p>
</dd>
<dt><code>"shift"</code> or <code>"centerdc"</code></dt><dd><p>same as <code>"whole"</code> but with
the first half of the spectrum swapped with second half to put the
zero-frequency value in the middle. If <code>freq</code> is a vector,
<code>"shift"</code> is ignored.</p>
</dd>
</dl>

<p>Default: If model coefficients <code>a</code> are real, the default range is
<code>"half"</code>, otherwise the default range is <code>"whole"</code>.</p>
</td></tr>
<tr><td><code id="pburg_+3A_method">method</code></td>
<td>
<p>method used to calculate the power spectral density, either
<code>"fft"</code> (use the Fast Fourier Transform) or <code>"poly"</code> (calculate
the power spectrum as a polynomial). This argument is ignored if the
<code>freq</code> argument is a vector. The default is <code>"poly"</code> unless the
<code>freq</code> argument is an integer power of 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;ar_psd&quot; , which is a list containing two
elements, <code>freq</code> and <code>psd</code> containing the frequency values and
the estimates of power-spectral density, respectively.
</p>


<h3>Note</h3>

<p>This function is a wrapper for <code>arburg</code> and <code>ar_psd</code>.
</p>


<h3>Author(s)</h3>

<p>Peter V. Lanspeary, <a href="mailto:pvl@mecheng.adelaide.edu.au">pvl@mecheng.adelaide.edu.au</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ar_psd">ar_psd</a></code>, <code><a href="#topic+arburg">arburg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Arma(1, c(1, -2.7607, 3.8106, -2.6535, 0.9238))
y &lt;- filter(A, 0.2 * rnorm(1024))
plot(pb &lt;- pburg(y, 4))

</code></pre>

<hr>
<h2 id='peak2peak'>Maximum-to-minimum difference</h2><span id='topic+peak2peak'></span>

<h3>Description</h3>

<p>Compute the maximum-to-minimum difference of the input data <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peak2peak(x, MARGIN = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peak2peak_+3A_x">x</code></td>
<td>
<p>the data, expected to be a vector, a matrix, an array.</p>
</td></tr>
<tr><td><code id="peak2peak_+3A_margin">MARGIN</code></td>
<td>
<p>a vector giving the subscripts which the function will be
applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns,
c(1, 2) indicates rows and columns. Where <code>x</code> has named dimnames, it
can be a character vector selecting dimension names. Default: 2 (columns)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>x</code> can be a vector, a matrix or an array. If the input is a
vector, a single value is returned representing the maximum-to-minimum
difference of the vector. If the input is a matrix or an array, a vector or
an array of values is returned representing the maximum-to-minimum
differences of the dimensions of <code>x</code> indicated by the <code>MARGIN</code>
argument.
</p>
<p>Support for complex valued input is provided. In this case, the function
<code>peak2peak</code> identifies the maximum and minimum in complex magnitude, and
then subtracts the complex number with the minimum modulus from the complex
number with the maximum modulus.
</p>


<h3>Value</h3>

<p>Vector or array of values containing the maximum-to-minimum
differences of the specified <code>MARGIN</code> of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Georgios Ouzounis, <a href="mailto:ouzounis_georgios@hotmail.com">ouzounis_georgios@hotmail.com</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## numeric vector
x &lt;- c(1:5)
pp &lt;- peak2peak(x)

## numeric matrix
x &lt;- matrix(c(1,2,3, 100, 150, 200, 1000, 1500, 2000), 3, 3)
pp &lt;- peak2peak(x)
pp &lt;- peak2peak(x, 1)

## numeric array
x &lt;- array(c(1, 1.5, 2, 100, 150, 200, 1000, 1500, 2000,
             10000, 15000, 20000), c(2,3,2))
pp &lt;- peak2peak(x, 1)
pp &lt;- peak2peak(x, 2)
pp &lt;- peak2peak(x, 3)

## complex input
x &lt;- c(1+1i, 2+3i, 3+5i, 4+7i, 5+9i)
pp &lt;- peak2peak(x)

</code></pre>

<hr>
<h2 id='peak2rms'>Peak-magnitude-to-RMS ratio</h2><span id='topic+peak2rms'></span>

<h3>Description</h3>

<p>Compute the ratio of the largest absolute value to the root-mean-square (RMS)
value of the object <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peak2rms(x, MARGIN = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peak2rms_+3A_x">x</code></td>
<td>
<p>the data, expected to be a vector, a matrix, an array.</p>
</td></tr>
<tr><td><code id="peak2rms_+3A_margin">MARGIN</code></td>
<td>
<p>a vector giving the subscripts which the function will be
applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns,
c(1, 2) indicates rows and columns. Where <code>x</code> has named dimnames, it
can be a character vector selecting dimension names. Default: 2 (usually
columns)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>x</code> can be a vector, a matrix or an array. If the input is a
vector, a single value is returned representing the peak-magnitude-to-RMS
ratio of the vector. If the input is a matrix or an array, a vector or an
array of values is returned representing the peak-magnitude-to-RMS ratios of
the dimensions of <code>x</code> indicated by the <code>MARGIN</code> argument.
</p>
<p>Support for complex valued input is provided.
</p>


<h3>Value</h3>

<p>Vector or array of values containing the peak-magnitude-to-RMS ratios
of the specified <code>MARGIN</code> of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Weber, <a href="mailto:octave@tech-chat.de">octave@tech-chat.de</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## numeric vector
x &lt;- c(1:5)
p &lt;- peak2rms(x)

## numeric matrix
x &lt;- matrix(c(1,2,3, 100, 150, 200, 1000, 1500, 2000), 3, 3)
p &lt;- peak2rms(x)
p &lt;- peak2rms(x, 1)

## numeric array
x &lt;- array(c(1, 1.5, 2, 100, 150, 200, 1000, 1500, 2000,
           10000, 15000, 20000), c(2,3,2))
p &lt;- peak2rms(x, 1)
p &lt;- peak2rms(x, 2)
p &lt;- peak2rms(x, 3)

## complex input
x &lt;- c(1+1i, 2+3i, 3+5i, 4+7i, 5+9i)
p &lt;- peak2rms(x)

</code></pre>

<hr>
<h2 id='pei_tseng_notch'>Pei-Tseng notch filter</h2><span id='topic+pei_tseng_notch'></span>

<h3>Description</h3>

<p>Compute the transfer function coefficients of an IIR narrow-band notch
filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pei_tseng_notch(w, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pei_tseng_notch_+3A_w">w</code></td>
<td>
<p>vector of critical frequencies of the filter. Must be between 0
and 1 where 1 is the Nyquist frequency.</p>
</td></tr>
<tr><td><code id="pei_tseng_notch_+3A_bw">bw</code></td>
<td>
<p>vector of bandwidths. Bw should be of the same length as <code>w</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The filter construction is based on an all-pass which performs a reversal of
phase at the filter frequencies. Thus, the mean of the phase-distorted and
the original signal has the respective frequencies removed.
</p>


<h3>Value</h3>

<p>List of class <code><a href="#topic+Arma">Arma</a></code> with list elements:
</p>

<dl>
<dt>b</dt><dd><p>moving average (MA) polynomial coefficients</p>
</dd>
<dt>a</dt><dd><p>autoregressive (AR) polynomial coefficients</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexander Klein, <a href="mailto:alexander.klein@math.uni-giessen.de">alexander.klein@math.uni-giessen.de</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>Pei, Soo-Chang, and Tseng, Chien-Cheng &quot;IIR Multiple Notch Filter
Design Based on Allpass Filter&quot;; 1996 IEEE Tencon, doi:
<a href="https://doi.org/10.1109/TENCON.1996.608814">doi:10.1109/TENCON.1996.608814</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+filter">filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 50 Hz notch filter
fs &lt;- 256
nyq &lt;- fs / 2
notch &lt;- pei_tseng_notch(50 / nyq, 2 / nyq)
freqz(notch, fs = fs)

</code></pre>

<hr>
<h2 id='poly'>Polynomial with specified roots</h2><span id='topic+poly'></span>

<h3>Description</h3>

<p>Compute the coefficients of a polynomial when the roots are given, or the
characteristic polynomial of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly_+3A_x">x</code></td>
<td>
<p>Real or complex vector, or square matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a vector is passed as an argument, then <code>poly((x)</code> is a vector of the
coefficients of the polynomial whose roots are the elements of <code>x</code>.
</p>
<p>If an <code class="reqn">N x N</code> square matrix is given, <code>poly((x)</code>
is the row vector of the coefficients of <code>det (z * diag (N) - x)</code>,
which is the characteristic polynomial of <code>x</code>.
</p>


<h3>Value</h3>

<p>A vector of the coefficients of the polynomial in order from highest
to lowest polynomial power.
</p>


<h3>Author(s)</h3>

<p>Kurt Hornik.<br />
Conversion to R by Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="pracma.html#topic+roots">roots</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- poly(c(1, -1))
p &lt;- poly(pracma::roots(1:3))
p &lt;- poly(matrix(1:9, 3, 3))

</code></pre>

<hr>
<h2 id='polyreduce'>Reduce polynomial</h2><span id='topic+polyreduce'></span>

<h3>Description</h3>

<p>Reduce a polynomial coefficient vector to a minimum number of terms by
stripping off any leading zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyreduce(pc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyreduce_+3A_pc">pc</code></td>
<td>
<p>vector of polynomial coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of reduced polynomial coefficients.
</p>


<h3>Author(s)</h3>

<p>Tony Richardson, <a href="mailto:arichard@stark.cc.oh.us">arichard@stark.cc.oh.us</a>,<br />
adapted by John W. Eaton.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- polyreduce(c(0, 0, 1, 2, 3))

</code></pre>

<hr>
<h2 id='polystab'>Stabilize polynomial</h2><span id='topic+polystab'></span>

<h3>Description</h3>

<p>Stabilize the polynomial transfer function by replacing all roots outside the
unit circle with their reflection inside the unit circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polystab(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polystab_+3A_a">a</code></td>
<td>
<p>vector of polynomial coefficients, normally in the z-domain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of stabilized polynomial coefficients.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br /> Conversion to R by
Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unstable &lt;- c(-0.5, 1)
zplane(unstable, 1)
stable &lt;- polystab(unstable)
zplane(stable, 1)

</code></pre>

<hr>
<h2 id='pow2db'>Power - decibel conversion</h2><span id='topic+pow2db'></span><span id='topic+db2pow'></span>

<h3>Description</h3>

<p>Convert power to decibel and decibel to power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow2db(x)

db2pow(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pow2db_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector, matrix, or
multidimensional array. Must be non-negative for numeric <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Converted data, same type and dimensions as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>P. Sudeepam<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- pow2db(c(0, 10, 100))
pow &lt;- db2pow(c(-10, 0, 10))

</code></pre>

<hr>
<h2 id='primitive'>Primitive</h2><span id='topic+primitive'></span>

<h3>Description</h3>

<p>Calculate the indefinitive integral of a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primitive(FUN, t, C = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="primitive_+3A_fun">FUN</code></td>
<td>
<p>the function to calculate the primitive of.</p>
</td></tr>
<tr><td><code id="primitive_+3A_t">t</code></td>
<td>
<p>points at which the function <code>FUN</code> is evaluated, specified as a
vector of ascending values</p>
</td></tr>
<tr><td><code id="primitive_+3A_c">C</code></td>
<td>
<p>constant of integration. Default: 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a fancy way of calculating the cumulative sum.
</p>


<h3>Value</h3>

<p>Vector of integrated function values.
</p>


<h3>Author(s)</h3>

<p>Juan Pablo Carbajal.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cumsum">cumsum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(t) sin(2 * pi * 3 * t)
t &lt;- c(0, sort(runif(100)))
F &lt;- primitive (f, t, 0)
t_true &lt;- seq(0, 1, length.out = 1e3)
F_true &lt;- (1 - cos(2 * pi * 3 * t_true)) / (2 * pi * 3)
plot (t, F, xlab = "", ylab = "")
lines (t_true, F_true, col = "red")
legend("topright", legend = c("Numerical primitive", "True primitive"),
  lty = c(0, 1), pch = c(1, NA), col = 1:2)

</code></pre>

<hr>
<h2 id='pulstran'>Pulse train</h2><span id='topic+pulstran'></span>

<h3>Description</h3>

<p>Generate a train of pulses based on samples of a continuous function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pulstran(
  t,
  d,
  func,
  fs = 1,
  method = c("linear", "nearest", "cubic", "spline"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pulstran_+3A_t">t</code></td>
<td>
<p>Time values at which <code>func</code> is evaluated, specified as a
vector.</p>
</td></tr>
<tr><td><code id="pulstran_+3A_d">d</code></td>
<td>
<p>Offset removed from the values of the array <code>t</code>, specified as a
real vector, matrix, or array. You can apply an optional gain factor to
each delayed evaluation by specifying <code>d</code> as a two-column matrix, with
offset defined in column 1 and associated gain in column 2. If you specify
<code>d</code> as a vector, the values are interpreted as delays only.</p>
</td></tr>
<tr><td><code id="pulstran_+3A_func">func</code></td>
<td>
<p>Continuous function used to generate a pulse train based on its
samples, specified as 'rectpuls', 'gauspuls', 'tripuls', or a function
handle. If you use <code>func</code> as a function handle, you can pass the
function parameters as follows:<br /> <code>y &lt;- pulstran(t, d, 'gauspuls',
10e3, bw = 0.5)</code>.<br /> This creates a pulse train using a 10 kHz Gaussian
pulse with 50% bandwidth. Alternatively, <code>func</code> can be a prototype
function, specified as a vector. The interval of the function <code>0</code> to
<code>(length(p) - 1) / fs</code>, and its samples are identically zero outside
this interval. By default, linear interpolation is used for generating
delays.</p>
</td></tr>
<tr><td><code id="pulstran_+3A_fs">fs</code></td>
<td>
<p>Sample rate in Hz, specified as a real scalar.</p>
</td></tr>
<tr><td><code id="pulstran_+3A_method">method</code></td>
<td>
<p>Interpolation method, specified as one of the following
options:
</p>

<dl>
<dt>&quot;linear&quot; (default)</dt><dd><p>Linear interpolation. The interpolated value at a
query point is based on linear interpolation of the values at neighboring
grid points in each respective dimension. This is the default interpolation
method.</p>
</dd>
<dt>&quot;nearest&quot;</dt><dd><p>Nearest neighbor interpolation. The interpolated value at a
query point is the value at the nearest sample grid point.</p>
</dd>
<dt>&quot;cubic&quot;</dt><dd><p>Shape-preserving piecewise cubic interpolation. The
interpolated value at a query point is based on a shape-preserving
piecewise cubic interpolation of the values at neighboring grid points.</p>
</dd>
<dt>&quot;spline&quot;</dt><dd><p>Spline interpolation using not-a-knot end conditions. The
interpolated value at a query point is based on a cubic interpolation of
the values at neighboring grid points in each respective dimension.</p>
</dd>
</dl>

<p>Interpolation is performed by the function <code>'interp1'</code> function in the
library <code>'pracma'</code>, and any interpolation method accepted by the
function <code>'interp1'</code> can be specified here.</p>
</td></tr>
<tr><td><code id="pulstran_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>func</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate the signal <code>y &lt;- sum(func(t + d, ...))</code> for each <code>d</code>. If
<code>d</code> is a matrix of two columns, the first column is the delay <code>d</code>
and the second column is the amplitude <code>a</code>, and <code>y &lt;- sum(a *
func(t + d))</code> for each <code>d, a</code>. Clearly, <code>func</code> must be a function
which accepts a vector of times. Any extra arguments needed for the function
must be tagged on the end.
</p>
<p>If instead of a function name you supply a pulse shape sampled at frequency
<code>fs</code> (default 1 Hz), an interpolated version of the pulse is added at
each delay <code>d</code>. The interpolation stays within the the time range of the
delayed pulse. The interpolation method defaults to linear, but it can be any
interpolation method accepted by the function <code>interp1</code>
</p>


<h3>Value</h3>

<p>Pulse train generated by the function, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## periodic rectangular pulse
t &lt;- seq(0, 60, 1/1e3)
d &lt;- cbind(seq(0, 60, 2), sin(2 * pi * 0.05 * seq(0, 60, 2)))
y &lt;- pulstran(t, d, 'rectpuls')
plot(t, y, type = "l", xlab = "Time (s)", ylab = "Waveform",
     main = "Periodic rectangular pulse")

## assymetric sawtooth waveform
fs &lt;- 1e3
t &lt;- seq(0, 1, 1/fs)
d &lt;- seq(0, 1, 1/3)
x &lt;- tripuls(t, 0.2, -1)
y &lt;- pulstran(t, d, x, fs)
plot(t, y, type = "l", xlab = "Time (s)", ylab = "Waveform",
     main = "Asymmetric sawtooth waveform")

## Periodic Gaussian waveform
fs &lt;- 1e7
tc &lt;- 0.00025
t &lt;- seq(-tc, tc, 1/fs)
x &lt;- gauspuls(t, 10e3, 0.5)
plot(t, x, type="l", xlab = "Time (s)", ylab = "Waveform",
     main = "Gaussian pulse")
ts &lt;- seq(0, 0.025, 1/50e3)
d &lt;- cbind(seq(0, 0.025, 1/1e3), sin(2 * pi * 0.1 * (0:25)))
y &lt;- pulstran(ts, d, x, fs)
plot(ts, y, type = "l", xlab = "Time (s)", ylab = "Waveform",
     main = "Gaussian pulse train")

# Custom pulse trains
fnx &lt;- function(x, fn) sin(2 * pi * fn * x) * exp(-fn * abs(x))
ffs &lt;- 1000
tp &lt;- seq(0, 1, 1/ffs)
pp &lt;- fnx(tp, 30)
plot(tp, pp, type = "l",xlab = 'Time (s)', ylab = 'Waveform',
     main = "Custom pulse")
fs &lt;- 2e3
t &lt;- seq(0, 1.2, 1/fs)
d &lt;- seq(0, 1, 1/3)
dd &lt;- cbind(d, 4^-d)
z &lt;- pulstran(t, dd, pp, ffs)
plot(t, z, type = "l", xlab = "Time (s)", ylab = "Waveform",
     main = "Custom pulse train")

</code></pre>

<hr>
<h2 id='pwelch'>Welch’s power spectral density estimate</h2><span id='topic+pwelch'></span><span id='topic+plot.pwelch'></span><span id='topic+print.pwelch'></span>

<h3>Description</h3>

<p>Compute power spectral density (PSD) using Welch's method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwelch(
  x,
  window = nextpow2(sqrt(NROW(x))),
  overlap = 0.5,
  nfft = if (isScalar(window)) window else length(window),
  fs = 1,
  detrend = c("long-mean", "short-mean", "long-linear", "short-linear", "none"),
  range = if (is.numeric(x)) "half" else "whole"
)

## S3 method for class 'pwelch'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  plot.type = c("spectrum", "cross-spectrum", "phase", "coherence", "transfer"),
  yscale = c("linear", "log", "dB"),
  ...
)

## S3 method for class 'pwelch'
print(
  x,
  plot.type = c("spectrum", "cross-spectrum", "phase", "coherence", "transfer"),
  yscale = c("linear", "log", "dB"),
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwelch_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_window">window</code></td>
<td>
<p>If <code>window</code> is a vector, each segment has the same length
as <code>window</code> and is multiplied by <code>window</code> before (optional)
zero-padding and calculation of its periodogram. If <code>window</code> is a
scalar, each segment has a length of <code>window</code> and a Hamming window is
used. Default: <code>nextpow2(sqrt(length(x)))</code> (the square root of the
length of <code>x</code> rounded up to the next power of two). The window length
must be larger than 3.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_overlap">overlap</code></td>
<td>
<p>segment overlap, specified as a numeric value expressed as a
multiple of window or segment length. 0 &lt;= overlap &lt; 1. Default: 0.5.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_nfft">nfft</code></td>
<td>
<p>Length of FFT, specified as an integer scalar. The default is the
length of the <code>window</code> vector or has the same value as the scalar
<code>window</code> argument.  If <code>nfft</code> is larger than the segment length,
(seg_len), the data segment is padded <code>nfft - seg_len</code> zeros. The
default is no padding. Nfft values smaller than the length of the data
segment (or window) are ignored. Note that the use of padding to increase
the frequency resolution of the spectral estimate is controversial.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_fs">fs</code></td>
<td>
<p>sampling frequency (Hertz), specified as a positive scalar.
Default: 1.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_detrend">detrend</code></td>
<td>
<p>character string specifying detrending option; one of:
</p>

<dl>
<dt><code>long-mean</code></dt><dd><p>remove the mean from the data before
splitting into segments (default)</p>
</dd>
<dt><code>short-mean</code></dt><dd><p>remove the mean value of each segment</p>
</dd>
<dt><code>long-linear</code></dt><dd><p>remove linear trend from the data before
splitting into segments</p>
</dd>
<dt><code>short-linear</code></dt><dd><p>remove linear trend from each segment</p>
</dd>
<dt><code>none</code></dt><dd><p>no detrending</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pwelch_+3A_range">range</code></td>
<td>
<p>character string. one of:
</p>

<dl>
<dt><code>"half"</code> or <code>"onesided"</code></dt><dd><p>frequency range of the spectrum
is from zero up to but not including <code>fs / 2</code>. Power from negative
frequencies is added to the positive side of the spectrum.</p>
</dd>
<dt><code>"whole"</code> or <code>"twosided"</code></dt><dd><p>frequency range of the spectrum
is <code>-fs / 2</code> to <code>fs / 2</code>, with negative frequencies stored in
&quot;wrap around order&quot; after the positive frequencies; e.g. frequencies for a
10-point <code>"twosided"</code> spectrum are 0 0.1 0.2 0.3 0.4 0.5 -0.4 -0.3
-0.2. -0.1.</p>
</dd>
<dt><code>"shift"</code> or <code>"centerdc"</code></dt><dd><p>same as <code>"whole"</code> but with
the first half of the spectrum swapped with second half to put the
zero-frequency value in the middle.</p>
</dd>
</dl>

<p>Default: If <code>x</code> are real, the default range is <code>"half"</code>,
otherwise the default range is <code>"whole"</code>.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_xlab">xlab</code>, <code id="pwelch_+3A_ylab">ylab</code>, <code id="pwelch_+3A_main">main</code></td>
<td>
<p>labels passed to plotting function. Default: NULL</p>
</td></tr>
<tr><td><code id="pwelch_+3A_plot.type">plot.type</code></td>
<td>
<p>character string specifying which plot to produce; one of
<code>"spectrum"</code>, <code>"cross-spectrum"</code>, <code>"phase"</code>,
<code>"coherence"</code>, <code>"transfer"</code></p>
</td></tr>
<tr><td><code id="pwelch_+3A_yscale">yscale</code></td>
<td>
<p>character string specifying scaling of Y-axis; one of
<code>"linear"</code>, <code>"log"</code>, <code>"dB"</code></p>
</td></tr>
<tr><td><code id="pwelch_+3A_...">...</code></td>
<td>
<p>additional arguments passed to functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Welch method [1] reduces the variance of the periodogram estimate to the
PSD by splitting the signal into (usually) overlapping segments and windowing
each segment, for instance by a Hamming window. The periodogram is then
computed for each segment, and the squared magnitude is computed, which is
then averaged for all segments. See also [2].
</p>
<p>The spectral density is the mean of the modified periodograms, scaled so that
area under the spectrum is the same as the mean square of the data.  This
equivalence is supposed to be exact, but in practice there is a mismatch of
up to 0.5
the data.
</p>
<p>In case of multivariate signals, Cross-spectral density, phase, and coherence
are also returned. The input data can be demeaned or detrended, overall or
for each segment separately.
</p>


<h3>Value</h3>

<p>An object of class <code>"pwelch"</code>, which is a list containing the
following elements:
</p>

<dl>
<dt><code>freq</code></dt><dd><p>vector of frequencies at which the spectral variables
are estimated. If <code>x</code> is numeric, power from negative frequencies is
added to the positive side of the spectrum, but not at zero or Nyquist
(fs/2) frequencies. This keeps power equal in time and spectral domains.
If <code>x</code> is complex, then the whole frequency range is returned.</p>
</dd>
<dt><code>spec</code></dt><dd><p>Vector (for univariate series) or matrix (for
multivariate series) of estimates of the spectral density at frequencies
corresponding to freq.</p>
</dd>
<dt><code>cross</code></dt><dd><p>NULL for univariate series. For multivariateseries, a
matrix containing the cross-spectral density estimates between different
series. Column <code class="reqn">i + (j - 1) * (j - 2)/2 </code> of contains the
cross-spectral estimates between columns <code class="reqn">i</code> and <code class="reqn">j</code> of <code class="reqn">x</code>,
where <code class="reqn">i &lt; j</code>.</p>
</dd>
<dt><code>phase</code></dt><dd><p>NULL for univariate series. For multivariate series,
a matrix containing the cross-spectrum phase between different series.
The format is the same as <code>cross</code>.</p>
</dd>
<dt><code>coh</code></dt><dd><p>NULL for univariate series. For multivariate series, a
matrix containing the squared coherence between different series. The
format is the same as <code>cross</code>.</p>
</dd>
<dt><code>trans</code></dt><dd><p>NULL for univariate series. For multivariate series,
a matrix containing estimates of the transfer function between different
series. The format is the same as <code>cross</code>.</p>
</dd>
<dt><code>x_len</code></dt><dd><p>The length of the input series.</p>
</dd>
<dt><code>seg_len</code></dt><dd><p>The length of each segment making up the averages.</p>
</dd>
<dt><code>psd_len</code></dt><dd><p>The number of frequencies. See <code>freq</code></p>
</dd>
<dt><code>nseries</code></dt><dd><p>The number of series</p>
</dd>
<dt><code>series</code></dt><dd><p>The name of the series</p>
</dd>
<dt><code>snames</code></dt><dd><p>For multivariate input, the names of the individual
series</p>
</dd>
<dt><code>window</code></dt><dd><p>The window used to compute the modified periodogram</p>
</dd>
<dt><code>fs</code></dt><dd><p>The sampling frequency</p>
</dd>
<dt><code>detrend</code></dt><dd><p>Character string specifying detrending option</p>
</dd>
</dl>



<h3>Note</h3>

<p>Unlike the 'Octave' function 'pwelch', the current implementation
does not compute confidence intervals because they can be inaccurate in
case of overlapping segments.
</p>


<h3>Author(s)</h3>

<p>Peter V. Lanspeary <a href="mailto:pvl@mecheng.adelaide.edu.au">pvl@mecheng.adelaide.edu.au</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] Welch, P.D. (1967). The use of Fast Fourier Transform for
the estimation of power spectra: A method based on time averaging over
short, modified periodograms. IEEE Transactions on Audio and
Electroacoustics, AU-15 (2): 70–73.<br />
</p>
<p>[2] <a href="https://en.wikipedia.org/wiki/Welch%27s_method">https://en.wikipedia.org/wiki/Welch%27s_method</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- 256
secs &lt;- 10
freq &lt;- 30
ampl &lt;- 1
t &lt;- seq(0, secs, length.out = fs * secs)

x &lt;- ampl * cos(freq * 2 * pi * t) + runif(length(t))
Pxx &lt;- pwelch(x, fs = fs)              # no plot
pwelch(x, fs = fs)                     # plot

# 90 degrees phase shift with with respect to x
y &lt;- ampl * sin(freq * 2 * pi * t) + runif(length(t))
Pxy &lt;- pwelch(cbind(x, y), fs = fs)
plot(Pxy, yscale = "dB")
plot(Pxy, plot.type = "phase")
# note the phase shift around 30 Hz is pi/2
plot(Pxy, plot.type = "coherence")

# Transfer function estimate example
fs &lt;- 1000                 # Sampling frequency
t &lt;- (0:fs) / fs           # One second worth of samples
A &lt;- c(1, 2)               # Sinusoid amplitudes
f &lt;- c(150, 140)           # Sinusoid frequencies
xn &lt;- A[1] * sin(2 * pi * f[1] * t) +
      A[2] * sin(2 * pi * f[2] * t) +  0.1 * runif(length(t))
h &lt;- Ma(rep(1L, 10) / 10)      # Moving average filter
yn &lt;- filter(h, xn)
atfm &lt;- freqz(h, fs = fs)
etfm &lt;- pwelch(cbind(xn, yn), fs = fs)
op &lt;- par(mfrow = c(2, 1))
xl &lt;- "Frequency (Hz)"; yl &lt;- "Magnitude"
plot(atfm$w, abs(atfm$h), type = "l", main = "Actual", xlab = xl, ylab = yl)
plot(etfm$freq, abs(etfm$trans), type = "l", main = "Estimated",
     xlab = xl, ylab = yl)
par(op)

</code></pre>

<hr>
<h2 id='pyulear'>Autoregressive PSD estimate - Yule-Walker method</h2><span id='topic+pyulear'></span>

<h3>Description</h3>

<p>Calculate Yule-Walker autoregressive power spectral density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pyulear(
  x,
  p,
  freq = 256,
  fs = 1,
  range = NULL,
  method = if (length(freq) == 1 &amp;&amp; bitwAnd(freq, freq - 1) == 0) "fft" else "poly"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pyulear_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric or complex vector or matrix. In
case of a vector it represents a single signal; in case of a matrix each
column is a signal.</p>
</td></tr>
<tr><td><code id="pyulear_+3A_p">p</code></td>
<td>
<p>model order; number of poles in the AR model or limit to the number
of poles if a valid criterion is provided. Must be &lt; length(x) - 2.</p>
</td></tr>
<tr><td><code id="pyulear_+3A_freq">freq</code></td>
<td>
<p>vector of frequencies at which power spectral density is
calculated, or a scalar indicating the number of uniformly distributed
frequency values at which spectral density is calculated. Default: 256.</p>
</td></tr>
<tr><td><code id="pyulear_+3A_fs">fs</code></td>
<td>
<p>sampling frequency (Hz). Default: 1</p>
</td></tr>
<tr><td><code id="pyulear_+3A_range">range</code></td>
<td>
<p>character string. one of:
</p>

<dl>
<dt><code>"half"</code> or <code>"onesided"</code></dt><dd><p>frequency range of the spectrum
is from zero up to but not including <code>fs / 2</code>. Power from negative
frequencies is added to the positive side of the spectrum.</p>
</dd>
<dt><code>"whole"</code> or <code>"twosided"</code></dt><dd><p>frequency range of the spectrum
is <code>-fs / 2</code> to <code>fs / 2</code>, with negative frequencies stored in
&quot;wrap around order&quot; after the positive frequencies; e.g. frequencies for a
10-point <code>'twosided'</code> spectrum are 0 0.1 0.2 0.3 0.4 0.5 -0.4 -0.3
-0.2. -0.1.</p>
</dd>
<dt><code>"shift"</code> or <code>"centerdc"</code></dt><dd><p>same as <code>"whole"</code> but with
the first half of the spectrum swapped with second half to put the
zero-frequency value in the middle. If <code>freq</code> is vector,
<code>"shift"</code> is ignored.</p>
</dd>
</dl>

<p>Default: If model coefficients <code>a</code> are real, the default range is
<code>"half"</code>, otherwise the default range is <code>"whole"</code>.</p>
</td></tr>
<tr><td><code id="pyulear_+3A_method">method</code></td>
<td>
<p>method used to calculate the power spectral density, either
<code>"fft"</code> (use the Fast Fourier Transform) or <code>"poly"</code> (calculate
the power spectrum as a polynomial). This argument is ignored if the
<code>freq</code> argument is a vector. The default is <code>"poly"</code> unless the
<code>freq</code> argument is an integer power of 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;ar_psd&quot; , which is a list containing two
elements, <code>freq</code> and <code>psd</code> containing the frequency values and
the estimates of power-spectral density, respectively.
</p>


<h3>Note</h3>

<p>This function is a wrapper for <code>arburg</code> and <code>ar_psd</code>.
</p>


<h3>Author(s)</h3>

<p>Peter V. Lanspeary, <a href="mailto:pvl@mecheng.adelaide.edu.au">pvl@mecheng.adelaide.edu.au</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ar_psd">ar_psd</a></code>, <code><a href="#topic+arburg">arburg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Arma(1, c(1, -2.7607, 3.8106, -2.6535, 0.9238))
y &lt;- filter(A, 0.2 * rnorm(1024))
py &lt;- pyulear(y, 4)

</code></pre>

<hr>
<h2 id='qp_kaiser'>Kaiser FIR filter design</h2><span id='topic+qp_kaiser'></span>

<h3>Description</h3>

<p>Compute FIR filter for use with a quasi-perfect reconstruction
polyphase-network filter bank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qp_kaiser(nb, at, linear = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qp_kaiser_+3A_nb">nb</code></td>
<td>
<p>number of frequency bands, specified as a scalar</p>
</td></tr>
<tr><td><code id="qp_kaiser_+3A_at">at</code></td>
<td>
<p>attenuation (in dB) in the stop band.</p>
</td></tr>
<tr><td><code id="qp_kaiser_+3A_linear">linear</code></td>
<td>
<p>logical, indicating linear scaling. If FALSE (default), the
Kaiser window is multiplied by the ideal impulse response <code class="reqn">h(n) = a
sinc(an)</code> and converted to its minimum-phase version by means of a Hilbert
transform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The FIR filter coefficients, of class <code>Ma</code>.
</p>


<h3>Author(s)</h3>

<p>André Carezia, <a href="mailto:andre@carezia.eng.br">andre@carezia.eng.br</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ma">Ma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+fftfilt">fftfilt</a></code>,
<code><a href="#topic+fir2">fir2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
freqz(qp_kaiser(1, 20))
freqz(qp_kaiser(1, 40))


</code></pre>

<hr>
<h2 id='rceps'>Real cepstrum</h2><span id='topic+rceps'></span>

<h3>Description</h3>

<p>Return the real cepstrum and minimum-phase reconstruction of a signal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rceps(x, minphase = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rceps_+3A_x">x</code></td>
<td>
<p>input data, specified as a real vector.</p>
</td></tr>
<tr><td><code id="rceps_+3A_minphase">minphase</code></td>
<td>
<p>logical (default: <code>FALSE</code>) indication whether to compute
minimum-phase reconstructed signal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cepstral analysis is a nonlinear signal processing technique that is applied
most commonly in speech and image processing, or as a tool to
investigate periodic structures within frequency spectra, for instance
resulting from echos/reflections in the signal or to the occurrence of
harmonic frequencies (partials, overtones).
</p>
<p>The cepstrum is used in many variants. Most important are the power cepstrum,
the complex cepstrum, and real cepstrum. The function <code>rceps</code> implements
the real cepstrum by computing the inverse of the log-transformed FFT while
discarding phase, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">rceps(x) &lt;- ifft(log(Mag(fft(x))))</code>
</p>

<p>The real cepstrum is related to the power spectrum by the relation <code class="reqn">pceps
= 4 * rceps^2</code>.
</p>
<p>The function <code>rceps()</code> can also return a minimum-phase reconstruction of
the original signal. The concept of minimum phase originates from filtering
theory, and denotes a filter transfer function with all of its poles and
zeroes in the Z-transform domain lie inside the unit circle on the complex
plane. Such a transfer function represents a stable filter.
</p>
<p>A minimum-phase signal is a signal that has its energy concentrated
near the front of the signal (near time 0). Such signals have many
applications, e.g. in seismology and speech analysis.
</p>


<h3>Value</h3>

<p>If <code>minphase</code> equals <code>FALSE</code>, the real cepstrum is returned
as a vector. If <code>minphase</code> equals <code>TRUE</code>, a list is returned
containing two vectors; <code>y</code> containing the real cepstrum, and
<code>ym</code> containing the minimum-phase reconstructed signal
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Mike Miller.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Minimum_phase">https://en.wikipedia.org/wiki/Minimum_phase</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cceps">cceps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a speech signal with a 70 Hz glottal wave
f0 &lt;- 70; fs = 10000           # 100 Hz fundamental, 10 kHz sampling rate
a &lt;- Re(poly(0.985 * exp(1i * pi * c(0.1, -0.1, 0.3, -0.3))))
s &lt;- 0.05 * runif(1024)
s[floor(seq(1, length(s), fs / f0))] &lt;- 1
x &lt;- filter(1, a, s)

## compute real cepstrum and min-phase of x
cep &lt;- rceps(x, TRUE)
hx &lt;- freqz(x, fs = fs)
hxm &lt;- freqz (cep$ym, fs = fs)
len &lt;- 1000 * trunc(min(length(x), length(cep$ym)) / 1000)
time &lt;- 0:(len-1) * 1000 / fs

op &lt;- par(mfcol = c(2, 2))
plot(time, x[1:len], type = "l", ylim = c(-10, 10),
  xlab = "Time (ms)", ylab = "Amplitude",
  main = "Original and reconstructed signals")
lines(time, cep$ym[1:len], col = "red")
legend("topright", legend = c("original", "reconstructed"),
  lty = 1, col = c(1, 2))

plot(time, cep$y[1:len], type = "l",
  xlab = "Quefrency (ms)", ylab = "Amplitude",
  main = "Real cepstrum")

plot (hx$w, log(abs(hx$h)), type = "l",
  xlab = "Frequency (Hz)", ylab = "Magnitude",
  main = "Magnitudes are identical")
lines(hxm$w, log(abs(hxm$h)), col = "red")
legend("topright", legend = c("original", "reconstructed"),
  lty = 1, col = c(1, 2))

phx &lt;- unwrap(Arg(hx$h))
phym &lt;- unwrap(Arg(hxm$h))
range &lt;- c(round(min(phx, phym)), round(max(phx, phym)))
plot (hx$w, phx, type = "l", ylim = range,
  xlab = "Frequency (Hz)", ylab = "Phase",
  main = "Unwrapped phase")
lines(hxm$w, phym, col = "red")
legend("bottomright", legend = c("original", "reconstructed"),
  lty = 1, col = c(1, 2))
par(op)

## confirm the magnitude spectrum is identical in the signal
## and the reconstruction and that there are peaks in the
## cepstrum at 14 ms intervals corresponding to an F0 of 70 Hz.

</code></pre>

<hr>
<h2 id='rectpuls'>Rectangular pulse</h2><span id='topic+rectpuls'></span>

<h3>Description</h3>

<p>Return samples of the unit-amplitude rectangular pulse at the times
indicated by <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectpuls(t, w = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rectpuls_+3A_t">t</code></td>
<td>
<p>Sample times of unit rectangular pulse, specified by a vector.</p>
</td></tr>
<tr><td><code id="rectpuls_+3A_w">w</code></td>
<td>
<p>Rectangle width, specified by a positive number. Default: 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y &lt;- rectpuls(t)</code> returns a continuous, aperiodic, unit-height
rectangular pulse at the sample times indicated in array t, centered about t
= 0.
</p>
<p><code>y &lt;- rectpuls(t, w)</code> generates a rectangular pulse over the interval
from <code>-w/2</code> to  <code>w/2</code>, sampled at times <code>t</code>. This is useful
with the function <code>pulstran</code> for generating a series of pulses.
</p>


<h3>Value</h3>

<p>Rectangular pulse of unit amplitude, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, Mike Miller.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pulstran">pulstran</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fs &lt;- 10e3
t &lt;- seq(-0.1, 0.1, 1/fs)
w &lt;- 20e-3
y &lt;- rectpuls(t, w)
plot(t, y, type="l", xlab = "Time", ylab = "Amplitude")

fs &lt;- 11025  # arbitrary sample rate
f0 &lt;- 100    # pulse train sample rate
w &lt;- 0.3/f0  # pulse width 1/10th the distance between pulses
y &lt;- pulstran (seq(0, 4/f0, 1/fs), seq(0, 4/f0, 1/f0), 'rectpuls', w = w)
plot (seq(0, length(y)-1) * 1000/fs, y, type ="l", xlab = "Time (ms)",
      ylab = "Amplitude",
      main = "Rectangular pulse train of 3 ms pulses at 10 ms intervals")

</code></pre>

<hr>
<h2 id='rectwin'>Rectangular window</h2><span id='topic+rectwin'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a rectangular window of length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectwin(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rectwin_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of the rectwin function with input <code>n</code> can also be created
using the <code>rep</code> function: w &lt;- rep(1L, n)
</p>


<h3>Value</h3>

<p>rectangular window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxcar">boxcar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- rectwin(64)
plot (r, type = "l", xlab = "Samples", ylab =" Amplitude", ylim = c(0, 1))

</code></pre>

<hr>
<h2 id='remez'>Parks-McClellan optimal FIR filter design</h2><span id='topic+remez'></span>

<h3>Description</h3>

<p>Parks-McClellan optimal FIR filter design using the Remez exchange algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remez(
  n,
  f,
  a,
  w = rep(1, length(f)/2),
  ftype = c("bandpass", "differentiator", "hilbert"),
  density = 16
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remez_+3A_n">n</code></td>
<td>
<p>filter order (1 less than the length of the filter).</p>
</td></tr>
<tr><td><code id="remez_+3A_f">f</code></td>
<td>
<p>normalized frequency points, strictly increasing vector in the range
[0, 1], where 1 is the Nyquist frequency. The number of elements in the
vector is always a multiple of 2.</p>
</td></tr>
<tr><td><code id="remez_+3A_a">a</code></td>
<td>
<p>vector of desired amplitudes at the points specified in <code>f</code>.
<code>f</code> and <code>a</code> must be the same length. The length must be an even
number.</p>
</td></tr>
<tr><td><code id="remez_+3A_w">w</code></td>
<td>
<p>vector of weights used to adjust the fit in each frequency band. The
length of <code>w</code> is half the length of <code>f</code> and <code>a</code>, so there is
exactly one weight per band. Default: 1.</p>
</td></tr>
<tr><td><code id="remez_+3A_ftype">ftype</code></td>
<td>
<p>filter type, matched to one of <code>"bandpass"</code> (default),
<code>"differentiatior"</code>, or <code>"hilbert"</code>.</p>
</td></tr>
<tr><td><code id="remez_+3A_density">density</code></td>
<td>
<p>determines how accurately the filter will be constructed. The
minimum value is 16 (default), but higher numbers are slower to compute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The FIR filter coefficients, a vector of length <code>n + 1</code>, of
class <code>Ma</code>
</p>


<h3>Author(s)</h3>

<p>Jake Janovetz, <a href="mailto:janovetz@uiuc.edu">janovetz@uiuc.edu</a>,<br />
Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Kai Habel, <a href="mailto:kahacjde@linux.zrz.tu-berlin.de">kahacjde@linux.zrz.tu-berlin.de</a>.<br />
Conversion to R Tom Short<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Fir_filter">https://en.wikipedia.org/wiki/Fir_filter</a>
</p>
<p>Rabiner, L.R., McClellan, J.H., and Parks, T.W. (1975). FIR
Digital Filter Design Techniques Using Weighted Chebyshev Approximations,
IEEE Proceedings, vol. 63, pp. 595 - 610.<br />
<a href="https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm">https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ma">Ma</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+fftfilt">fftfilt</a></code>,
<code><a href="#topic+fir1">fir1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## low pass filter
f1 &lt;- remez(15, c(0, 0.3, 0.4, 1), c(1, 1, 0, 0))
freqz(f1)

## band pass
f &lt;- c(0, 0.3, 0.4, 0.6, 0.7, 1)
a &lt;- c(0, 0, 1, 1, 0, 0)
b &lt;- remez(17, f, a)
hw &lt;- freqz(b, 512)
plot(f, a, type = "l", xlab = "Radian Frequency (w / pi)",
     ylab = "Magnitude")
lines(hw$w/pi, abs(hw$h), col = "red")
legend("topright", legend = c("Ideal", "Remez"), lty = 1,
       col = c("black", "red"))

</code></pre>

<hr>
<h2 id='resample'>Change sampling rate</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>Resample using a polyphase algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(x, p, q, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="resample_+3A_p">p</code>, <code id="resample_+3A_q">q</code></td>
<td>
<p>resampling factors, specified as positive integers. <code>p / q</code>
is the resampling factor.</p>
</td></tr>
<tr><td><code id="resample_+3A_h">h</code></td>
<td>
<p>Impulse response of the FIR filter specified as a numeric vector or
matrix. If it is a vector, then it represents one FIR filter to may be
applied to multiple signals in <code>x</code>; if it is a matrix, then each
column is a separate FIR impulse response. If not specified, a FIR filter
based on a Kaiser window is designed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>h</code> is not specified, this function will design an optimal FIR filter
using a Kaiser-Bessel window. The filter length and the parameter <code class="reqn">\beta</code>
are computed based on ref [2], Chapter 7, Eq. 7.63 (p. 476), and Eq. 7.62 (p.
474), respectively.
</p>


<h3>Value</h3>

<p>output signal, returned as a vector or matrix. Each column has length
<code>ceiling(((length(x) - 1) * p + length(h)) / q)</code>..
</p>


<h3>Author(s)</h3>

<p>Eric Chassande-Mottin, <a href="mailto:ecm@apc.univ-paris7.fr">ecm@apc.univ-paris7.fr</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] Proakis, J.G., and Manolakis, D.G. (2007).
Digital Signal Processing: Principles, Algorithms, and Applications,
4th ed., Prentice Hall, Chap. 6.<br />
[2] Oppenheim, A.V., Schafer, R.W., and Buck, J.R. (1999).
Discrete-time signal processing, Signal processing series,
Prentice-Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kaiser">kaiser</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lx &lt;- 60
tx &lt;- seq(0, 360, length.out = lx)
x &lt;- sin(2 * pi * tx / 120)

# upsample
p &lt;- 3; q &lt;- 2
ty &lt;- seq(0, 360, length.out = lx * p / q)
y &lt;- resample(x, p, q)

# downsample
p &lt;- 2; q &lt;- 3
tz &lt;- seq(0, 360, length.out = lx * p / q)
z &lt;- resample(x, p, q)

# plot
plot(tx, x, type = "b", col = 1, pch = 1,
 xlab = "", ylab = "")
points(ty, y, col = 2, pch = 2)
points(tz, z, col = 3, pch = 3)
legend("bottomleft", legend = c("original", "upsampled", "downsampled"),
  lty = 1, pch = 1:3, col = 1:3)

</code></pre>

<hr>
<h2 id='residue'>Partial fraction expansion</h2><span id='topic+residue'></span><span id='topic+rresidue'></span>

<h3>Description</h3>

<p>Finds the residues, poles, and direct term of a Partial Fraction Expansion of
the ratio of two polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residue(b, a, tol = 0.001)

rresidue(r, p, k, tol = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residue_+3A_b">b</code></td>
<td>
<p>coefficients of numerator polynomial</p>
</td></tr>
<tr><td><code id="residue_+3A_a">a</code></td>
<td>
<p>coefficients of denominator polynomial</p>
</td></tr>
<tr><td><code id="residue_+3A_tol">tol</code></td>
<td>
<p>tolerance. Default: 0.001</p>
</td></tr>
<tr><td><code id="residue_+3A_r">r</code></td>
<td>
<p>residues of partial fraction expansion</p>
</td></tr>
<tr><td><code id="residue_+3A_p">p</code></td>
<td>
<p>poles of partial fraction expansion</p>
</td></tr>
<tr><td><code id="residue_+3A_k">k</code></td>
<td>
<p>direct term</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call <code>res &lt;- residue(b, a)</code> computes the partial fraction expansion
for the quotient of the polynomials, <code>b</code> and <code>a</code>.
</p>
<p>The call <code>res &lt;- rresidue(r, p, k)</code> performs the inverse operation and
computes the reconstituted quotient of polynomials, b(s) / a(s), from the
partial fraction expansion; represented by the residues, poles, and a direct
polynomial specified by <code>r</code>, <code>p</code> and <code>k</code>, and the pole
multiplicity <code>e</code>.
</p>


<h3>Value</h3>

<p>For <code>residue</code>, a list containing <code>r</code>, <code>p</code> and
<code>k</code>. For <code>rresidue</code>, a list containing <code>b</code> and <code>a</code>.
</p>


<h3>Author(s)</h3>

<p>Tony Richardson, <a href="mailto:arichard@stark.cc.oh.us">arichard@stark.cc.oh.us</a>,<br />
Ben Abbott, <a href="mailto:bpabbott@mac.com">bpabbott@mac.com</a>,<br />
adapted by John W. Eaton.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- c(-4, 8)
a &lt;- c(1, 6, 8)
rpk &lt;- residue(b, a)
ba &lt;- rresidue(rpk$r, rpk$p, rpk$k)

</code></pre>

<hr>
<h2 id='residued'>delayed z-transform partial fraction expansion</h2><span id='topic+residued'></span>

<h3>Description</h3>

<p>Finds the residues, poles, and direct term of a Partial Fraction Expansion of
the ratio of two polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residued(b, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residued_+3A_b">b</code></td>
<td>
<p>coefficients of numerator polynomial</p>
</td></tr>
<tr><td><code id="residued_+3A_a">a</code></td>
<td>
<p>coefficients of denominator polynomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the usual PFE function <code>residuez</code>, the IIR part (poles <code>p</code> and
residues <code>r</code>) is driven in parallel with the FIR part (<code>f</code>). In
this variant, the IIR part is driven by the output of the FIR part. This
structure can be more accurate in signal modeling applications.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> containing
</p>

<dl>
<dt>r</dt><dd><p>vector of filter pole residues of the partial fraction</p>
</dd>
<dt>p</dt><dd><p>vector of partial fraction poles</p>
</dd>
<dt>k</dt><dd><p>vector containing FIR part, if any (empty if <code>length(b) &lt;
 length(a)</code>)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Julius O. Smith III, <a href="mailto:jos@ccrma.stanford.edu">jos@ccrma.stanford.edu</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://ccrma.stanford.edu/~jos/filters/residued.html">https://ccrma.stanford.edu/~jos/filters/residued.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residue">residue</a></code>, <code><a href="#topic+residuez">residuez</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- c(2, 6, 6, 2)
a &lt;- c(1, -2, 1)
resd &lt;- residued(b, a)
resz &lt;- residuez(b, a)

</code></pre>

<hr>
<h2 id='residuez'>Z-transform partial fraction expansion</h2><span id='topic+residuez'></span>

<h3>Description</h3>

<p>Finds the residues, poles, and direct term of a Partial Fraction Expansion of
the ratio of two polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuez(b, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuez_+3A_b">b</code></td>
<td>
<p>coefficients of numerator polynomial</p>
</td></tr>
<tr><td><code id="residuez_+3A_a">a</code></td>
<td>
<p>coefficients of denominator polynomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>residuez</code> converts a discrete time system, expressed as the ratio of
two polynomials, to partial fraction expansion, or residue, form.
</p>


<h3>Value</h3>

<p>A list containing
</p>

<dl>
<dt>r</dt><dd><p>vector of filter pole residues of the partial fraction</p>
</dd>
<dt>p</dt><dd><p>vector of partial fraction poles</p>
</dd>
<dt>k</dt><dd><p>vector containing FIR part, if any (empty if <code>length(b) &lt;
  length(a)</code>)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Julius O. Smith III, <a href="mailto:jos@ccrma.stanford.edu">jos@ccrma.stanford.edu</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residue">residue</a></code>, <code><a href="#topic+residued">residued</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b0 &lt;- 0.05634
b1 &lt;- c(1,  1)
b2 &lt;- c(1, -1.0166, 1)
a1 &lt;- c(1, -0.683)
a2 &lt;- c(1, -1.4461, 0.7957)
b &lt;- b0 * conv(b1, b2)
a &lt;- conv(a1, a2)
res &lt;- residuez(b, a)

</code></pre>

<hr>
<h2 id='rms'>Root-mean-square</h2><span id='topic+rms'></span>

<h3>Description</h3>

<p>Compute the root-mean-square (RMS) of the object <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rms(x, MARGIN = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rms_+3A_x">x</code></td>
<td>
<p>the data, expected to be a vector, a matrix, an array.</p>
</td></tr>
<tr><td><code id="rms_+3A_margin">MARGIN</code></td>
<td>
<p>a vector giving the subscripts which the function will be
applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns,
c(1, 2) indicates rows and columns. Where <code>x</code> has named dimnames, it
can be a character vector selecting dimension names. Default: 2 (columns)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>x</code> can be a vector, a matrix or an array. If the input is a
vector, a single value is returned representing the root-mean-square of the
vector. If the input is a matrix or an array, a vector or an array of values
is returned representing the root-mean-square of the dimensions of <code>x</code>
indicated by the <code>MARGIN</code> argument.
</p>
<p>Support for complex valued input is provided. The sum of squares of complex
numbers is defined by <code>sum(x * Conj(x))</code>
</p>


<h3>Value</h3>

<p>Vector or array of values containing the root-mean-squares of the
specified <code>MARGIN</code> of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Weber, <a href="mailto:octave@tech-chat.de">octave@tech-chat.de</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## numeric vector
x &lt;- c(1:5)
r &lt;- rms(x)

## numeric matrix
x &lt;- matrix(c(1,2,3, 100, 150, 200, 1000, 1500, 2000), 3, 3)
p &lt;- rms(x)
p &lt;- rms(x, 1)

## numeric array
x &lt;- array(c(1, 1.5, 2, 100, 150, 200, 1000, 1500,
           2000, 10000, 15000, 20000), c(2,3,2))
p &lt;- rms(x, 1)
p &lt;- rms(x, 2)
p &lt;- rms(x, 3)

## complex input
x &lt;- c(1+1i, 2+3i, 3+5i, 4+7i, 5+9i)
p &lt;- rms(x)

</code></pre>

<hr>
<h2 id='rssq'>Root-sum-of-squares</h2><span id='topic+rssq'></span>

<h3>Description</h3>

<p>Compute the root-sum-of-squares (SSQ) of the object <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rssq(x, MARGIN = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rssq_+3A_x">x</code></td>
<td>
<p>the data, expected to be a vector, a matrix, an array.</p>
</td></tr>
<tr><td><code id="rssq_+3A_margin">MARGIN</code></td>
<td>
<p>a vector giving the subscripts which the function will be
applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns,
c(1, 2) indicates rows and columns. Where <code>x</code> has named dimnames, it
can be a character vector selecting dimension names. Default: 2 (usually
columns)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>x</code> can be a vector, a matrix or an array. If the input is a
vector, a single value is returned representing the root-sum-of-squares of
the vector. If the input is a matrix or an array, a vector or an array of
values is returned representing the root-sum-of-squares of the dimensions of
<code>x</code> indicated by the <code>MARGIN</code> argument.
</p>
<p>Support for complex valued input is provided. The sum of squares of complex
numbers is defined by <code>sum(x * Conj(x))</code>
</p>


<h3>Value</h3>

<p>Vector or array of values containing the root-sum-of-squares of the
specified <code>MARGIN</code> of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Mike Miller.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## numeric vector
x &lt;- c(1:5)
p &lt;- rssq(x)

## numeric matrix
x &lt;- matrix(c(1,2,3, 100, 150, 200, 1000, 1500, 2000), 3, 3)
p &lt;- rssq(x)
p &lt;- rssq(x, 1)

## numeric array
x &lt;- array(c(1, 1.5, 2, 100, 150, 200, 1000, 1500,
            2000, 10000, 15000, 20000), c(2,3,2))
p &lt;- rssq(x, 1)
p &lt;- rssq(x, 2)
p &lt;- rssq(x, 3)

## complex input
x &lt;- c(1+1i, 2+3i, 3+5i, 4+7i, 5+9i)
p &lt;- rssq(x)

</code></pre>

<hr>
<h2 id='sampled2continuous'>Signal reconstruction</h2><span id='topic+sampled2continuous'></span>

<h3>Description</h3>

<p>Analog signal reconstruction from discrete samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampled2continuous(xn, fs, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampled2continuous_+3A_xn">xn</code></td>
<td>
<p>the sampled input signal, specified as a vector</p>
</td></tr>
<tr><td><code id="sampled2continuous_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz used in collecting <code>x</code>, specified as
a positive scalar value. Default: 1</p>
</td></tr>
<tr><td><code id="sampled2continuous_+3A_t">t</code></td>
<td>
<p>time points at which data is to be reconstructed, specified as a
vector relative to <code>x[0]</code> (not real time).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a discrete signal x[n] sampled with a frequency of <code>fs</code> Hz, this
function reconstruct the original analog signal x(t) at time points <code>t</code>.
The function can be used, for instance, to calculate sampling rate effects on
aliasing.
</p>


<h3>Value</h3>

<p>Reconstructed signal x(t), returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Muthiah Annamalai, <a href="mailto:muthiah.annamalai@uta.edu">muthiah.annamalai@uta.edu</a>.
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 'analog' signal: 3 Hz cosine
t &lt;- seq(0, 1, length.out = 100)
xt &lt;- cos(3 * 2 * pi * t)
plot(t, xt, type = "l", xlab = "", ylab = "", ylim = c(-1, 1.2))

# 'sample' it at 4 Hz to simulate aliasing
fs &lt;- 4
n &lt;- ceiling(length(t) / fs)
xn &lt;- xt[seq(ceiling(n / 2), length(t), n)]
s4 &lt;- sampled2continuous(xn, fs, t)
lines(t, s4, col = "red")

# 'sample' it &gt; 6 Hz to avoid aliasing
fs &lt;- 7
n &lt;- ceiling(length(t) / fs)
xn &lt;- xt[seq(ceiling(n / 2), length(t), n)]
s7 &lt;- sampled2continuous(xn, fs, t)
lines(t, s7, col = "green")
legend("topright", legend = c("original", "aliased", "non-aliased"),
  lty = 1, col = c("black", "red", "green"))


</code></pre>

<hr>
<h2 id='sawtooth'>Sawtooth or triangle wave</h2><span id='topic+sawtooth'></span>

<h3>Description</h3>

<p>Returns samples of the sawtooth function at the times indicated by <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sawtooth(t, width = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sawtooth_+3A_t">t</code></td>
<td>
<p>Sample times of unit sawtooth wave specified by a vector.</p>
</td></tr>
<tr><td><code id="sawtooth_+3A_width">width</code></td>
<td>
<p>Real number between 0 and 1 which specifies the point between 0
and <code class="reqn">2 \pi</code> where the maximum is. The function increases linearly from
-1 to 1 in the interval from 0 to <code class="reqn"> 2 * \pi * width</code>, and decreases
linearly from 1 to -1 in the interval from <code class="reqn">2 * \pi * width</code> to <code class="reqn">2
* \pi</code>. Default: 1 (standard sawtooth).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code <code>y &lt;- sawtooth(t)</code> generates a sawtooth wave with period
<code class="reqn">2\pi</code> for the elements of the time array <code>t</code>. <code>sawtooth()</code> is
similar to the sine function but creates a sawtooth wave with peaks of –1 and
1. The sawtooth wave is defined to be –1 at multiples of <code class="reqn">2\pi</code> and to
increase linearly with time with a slope of <code class="reqn">1/\pi</code> at all other times.
</p>
<p><code>y &lt;- sawtooth(t, width)</code> generates a modified triangle wave with the
maximum location at each period controlled by <code>width</code>. Set <code>width</code>
to 0.5 to generate a standard triangle wave.
</p>


<h3>Value</h3>

<p>Sawtooth wave, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Juan Aguado.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
T &lt;- 10 * (1 / 50)
fs &lt;- 1000
t &lt;- seq(0, T-1/fs, 1/fs)
y &lt;- sawtooth(2 * pi * 50 *t)
plot(t, y, type="l", xlab = "", ylab = "", main = "50 Hz sawtooth wave")

T &lt;- 10 * (1 / 50)
fs &lt;- 1000
t &lt;- seq(0, T-1/fs, 1/fs)
y &lt;- sawtooth(2 * pi * 50 * t, 1/2)
plot(t, y, type="l", xlab = "", ylab = "", main = "50 Hz triangle wave")

</code></pre>

<hr>
<h2 id='schtrig'>Schmitt Trigger</h2><span id='topic+schtrig'></span>

<h3>Description</h3>

<p>Multisignal Schmitt trigger with levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schtrig(x, lvl, st = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schtrig_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="schtrig_+3A_lvl">lvl</code></td>
<td>
<p>threshold levels against which <code>x</code> is compared, specified as
a vector. If this is a scalar, the thresholds are symmetric around 0, i.e.
<code>c(-lvl, lvl)</code>.</p>
</td></tr>
<tr><td><code id="schtrig_+3A_st">st</code></td>
<td>
<p>trigger state, specified as a vector of length <code>ncol(x</code>. The
trigger state is returned in the output list and may be passed again to a
subsequent call to <code>schtrig</code>. Default: NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trigger works compares each column in <code>x</code> to the levels in
<code>lvl</code>, when the value is higher than <code>max(lvl)</code>, the output
<code>v</code> is high (i.e. 1); when the value is below <code>min(lvl)</code> the output
is low (i.e. 0); and when the value is between the two levels the output
retains its value.
</p>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+list">list</a></code> containing the following variables:
</p>

<dl>
<dt>v</dt><dd><p>vector or matrix of 0's and 1's, according to whether <code>x</code> is
above or below <code>lvl</code>, or the value of <code>x</code> if indeterminate</p>
</dd>
<dt>rng</dt><dd><p>ranges in which the output is high, so the indexes
<code>rng[1,i]:rng[2,i]</code> point to the i-th segment of 1s in <code>v</code>. See
<code><a href="#topic+clustersegment">clustersegment</a></code> for a detailed explanation.</p>
</dd>
<dt>st</dt><dd><p>trigger state, returned as a vector with a length of the number
of columns in <code>x</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Juan Pablo Carbajal, <a href="mailto:carbajal@ifi.uzh.ch">carbajal@ifi.uzh.ch</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustersegment">clustersegment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- seq(0, 1, length.out = 100)
x &lt;- sin(2 * pi * 2 * t) + sin(2 * pi * 5 * t) %*% matrix(c(0.8, 0.3), 1, 2)
lvl &lt;- c(0.8, 0.25)
trig  &lt;- schtrig (x, lvl)

op &lt;- par(mfrow = c(2, 1))
plot(t, x[, 1], type = "l", xlab = "", ylab = "")
abline(h = lvl, col = "blue")
lines(t, trig$v[, 1], col = "red", lwd = 2)
plot(t, x[, 2], type = "l", xlab = "", ylab = "")
abline(h = lvl, col = "blue")
lines(t, trig$v[, 2], col = "red", lwd = 2)
par(op)

</code></pre>

<hr>
<h2 id='sftrans'>Transform filter band edges</h2><span id='topic+sftrans'></span><span id='topic+sftrans.Zpg'></span><span id='topic+sftrans.Arma'></span><span id='topic+sftrans.default'></span>

<h3>Description</h3>

<p>Transform band edges of a generic lowpass filter to a filter with different
band edges and to other filter types (high pass, band pass, or band stop).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sftrans(Sz, ...)

## S3 method for class 'Zpg'
sftrans(Sz, w, stop = FALSE, ...)

## S3 method for class 'Arma'
sftrans(Sz, w, stop = FALSE, ...)

## Default S3 method:
sftrans(Sz, Sp, Sg, w, stop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sftrans_+3A_sz">Sz</code></td>
<td>
<p>In the generic case, a model to be transformed. In the default case,
a vector containing the zeros in a pole-zero-gain model.</p>
</td></tr>
<tr><td><code id="sftrans_+3A_...">...</code></td>
<td>
<p>arguments passed to the generic function.</p>
</td></tr>
<tr><td><code id="sftrans_+3A_w">w</code></td>
<td>
<p>critical frequencies of the target filter specified in radians.
<code>w</code> must be a scalar for low-pass and high-pass filters, and <code>w</code>
must be a two-element vector c(low, high) specifying the lower and upper
bands in radians.</p>
</td></tr>
<tr><td><code id="sftrans_+3A_stop">stop</code></td>
<td>
<p>FALSE for a low-pass or band-pass filter, TRUE for a high-pass or
band-stop filter.</p>
</td></tr>
<tr><td><code id="sftrans_+3A_sp">Sp</code></td>
<td>
<p>a vector containing the poles in a pole-zero-gain model.</p>
</td></tr>
<tr><td><code id="sftrans_+3A_sg">Sg</code></td>
<td>
<p>a vector containing the gain in a pole-zero-gain model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a low pass filter represented by poles and zeros in the splane, you can
convert it to a low pass, high pass, band pass or band stop by transforming
each of the poles and zeros individually. The following summarizes the
transformations:

</p>
<pre>

  Transform         Zero at x                  Pole at x
  ----------------  -------------------------  --------------------------
  Low-Pass          zero: Fc x/C               pole: Fc x/C
  S -&gt; C S/Fc       gain: C/Fc                 gain: Fc/C
  ----------------  -------------------------  --------------------------
  High Pass         zero: Fc C/x               pole: Fc C/x
  S -&gt; C Fc/S       pole: 0                    zero: 0
                    gain: -x                   gain: -1/x
  ----------------  -------------------------  --------------------------
  Band Pass         zero: b +- sqrt(b^2-FhFl)  pole: b +- sqrt(b^2-FhFl)
         S^2+FhFl   pole: 0                    zero: 0
  S -&gt; C --------   gain: C/(Fh-Fl)            gain: (Fh-Fl)/C
         S(Fh-Fl)   b=x/C (Fh-Fl)/2            b=x/C (Fh-Fl)/2
  ----------------  -------------------------  --------------------------
  Band Stop         zero: b +- sqrt(b^2-FhFl)  pole: b +- sqrt(b^2-FhFl)
         S(Fh-Fl)   pole: +-sqrt(-FhFl)        zero: +-sqrt(-FhFl)
  S -&gt; C --------   gain: -x                   gain: -1/x
         S^2+FhFl   b=C/x (Fh-Fl)/2            b=C/x (Fh-Fl)/2
  ----------------  -------------------------  --------------------------
  Bilinear          zero: (2+xT)/(2-xT)        pole: (2+xT)/(2-xT)
       2 z-1        pole: -1                   zero: -1
  S -&gt; -----        gain: (2-xT)/T             gain: (2-xT)/T
       T z+1
  ----------------  -------------------------  --------------------------
</pre>
<p>where C is the cutoff frequency of the initial lowpass filter, F_c is the
edge of the target low/high pass filter and [F_l,F_h] are the edges of the
target band pass/stop filter. With abundant tedious algebra, you can derive
the above formulae yourself by substituting the transform for S into
<code class="reqn">H(S)=S-x</code> for a zero at x or <code class="reqn">H(S)=1/(S-x)</code> for a pole at x, and
converting the result into the form:
</p>
<p style="text-align: center;"><code class="reqn">g prod(S-Xi) / prod(S-Xj)</code>
</p>

<p>Please note that a pole and a zero at the same place exactly cancel. This is
significant for High Pass, Band Pass and Band Stop filters which create
numerous extra poles and zeros, most of which cancel. Those which do not
cancel have a fill-in effect, extending the shorter of the sets to have the
same number of as the longer of the sets of poles and zeros (or at least
split the difference in the case of the band pass filter). There may be other
opportunistic cancellations, but it does not check for them.
</p>
<p>Also note that any pole on the unit circle or beyond will result in an
unstable filter. Because of cancellation, this will only happen if the number
of poles is smaller than the number of zeros and the filter is high pass or
band pass. The analytic design methods all yield more poles than zeros, so
this will not be a problem.
</p>


<h3>Value</h3>

<p>For the default case or for sftrans.Zpg, an object of class &quot;Zpg&quot;,
containing the list elements:
</p>

<dl>
<dt>z</dt><dd><p>complex vector of the zeros of the transformed model</p>
</dd>
<dt>p</dt><dd><p>complex vector of the poles of the transformed model</p>
</dd>
<dt>g</dt><dd><p>gain of the transformed model</p>
</dd>
</dl>

<p>For sftrans.Arma, an object of class &quot;Arma&quot;, containing the list elements:
</p>

<dl>
<dt>b</dt><dd><p>moving average (MA) polynomial coefficients</p>
</dd>
<dt>a</dt><dd><p>autoregressive (AR) polynomial coefficients</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>Proakis &amp; Manolakis (1992). <em>Digital Signal Processing</em>. New
York: Macmillan Publishing Company.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 6th order Bessel bandpass
zpg &lt;- besselap(6)
bp &lt;- sftrans(zpg, c(2, 3), stop = TRUE)
freqs(bp, seq(0, 4, length.out = 128))
bp &lt;- sftrans(zpg, c(0.1,0.3), stop = FALSE)
freqs(bp, seq(0, 4, length.out = 128))

</code></pre>

<hr>
<h2 id='sgolay'>Savitzky-Golay filter design</h2><span id='topic+sgolay'></span>

<h3>Description</h3>

<p>Compute the filter coefficients for all Savitzky-Golay FIR smoothing filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgolay(p, n, m = 0, ts = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgolay_+3A_p">p</code></td>
<td>
<p>Polynomial filter order; must be smaller than <code>n</code>.</p>
</td></tr>
<tr><td><code id="sgolay_+3A_n">n</code></td>
<td>
<p>Filter length; must a an odd positive integer.</p>
</td></tr>
<tr><td><code id="sgolay_+3A_m">m</code></td>
<td>
<p>Return the m-th derivative of the filter coefficients. Default: 0</p>
</td></tr>
<tr><td><code id="sgolay_+3A_ts">ts</code></td>
<td>
<p>Scaling factor. Default: 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The early rows of the resulting filter smooth based on future values and
later rows smooth based on past values, with the middle row using half future
and half past.  In particular, you can use row <code>i</code> to estimate
<code>x(k)</code> based on the <code>i-1</code> preceding values and the <code>n-i</code>
following values of <code>x</code> values as <code>y(k) = F[i, ] *
x[(k - i + 1):(k + n -i)]</code>.
</p>
<p>Normally, you would apply the first <code>(n-1)/2</code> rows to the first <code>k</code>
points of the vector, the last <code>k</code> rows to the last <code>k</code> points of
the vector and middle row to the remainder, but for example if you were
running on a real-time system where you wanted to smooth based on the all the
data collected up to the current time, with a lag of five samples, you could
apply just the filter on row <code>n - 5</code> to your window of length <code>n</code>
each time you added a new sample.
</p>


<h3>Value</h3>

<p>An square matrix with dimensions <code>length(n)</code> that is of class
<code>"sgolayFilter"</code>, so it can be used with <code>filter</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Pascal Dupuis, <a href="mailto:Pascal.Dupuis@esat.kuleuven.ac.be">Pascal.Dupuis@esat.kuleuven.ac.be</a>.<br />
Conversion to R Tom Short,<br />
adapted by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sgolayfilt">sgolayfilt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a signal that consists of a 0.2 Hz sinusoid embedded
## in white Gaussian noise and sampled five times a second for 200 seconds.
dt &lt;- 1 / 5 
t &lt;- seq(0, 200 - dt, dt)
x &lt;- 5 * sin(2 * pi * 0.2 * t) + rnorm(length(t))
## Use sgolay to smooth the signal.
## Use 21-sample frames and fourth order polynomials.
p &lt;- 4
n &lt;- 21
sg &lt;- sgolay(p, n)
## Compute the steady-state portion of the signal by convolving it
## with the center row of b.
ycenter &lt;- conv(x, sg[(n + 1)/2, ], 'valid')
## Compute the transients. Use the last rows of b for the startup
## and the first rows of b for the terminal.
ybegin &lt;- sg[seq(nrow(sg), (n + 3) / 2, -1), ] %*% x[seq(n, 1, -1)]
yend &lt;- sg[seq((n - 1)/2, 1, -1), ] %*%
        x[seq(length(x), (length(x) - (n - 1)), -1)]
## Concatenate the transients and the steady-state portion to
## generate the complete smoothed signal.
## Plot the original signal and the Savitzky-Golay estimate.
y = c(ybegin, ycenter, yend)
plot(t, x, type = "l", xlab = "", ylab = "", ylim = c(-8, 10))
lines(t, y, col = 2)
legend("topright", c('Noisy Sinusoid','S-G smoothed sinusoid'),
  lty = 1, col = c(1,2))

</code></pre>

<hr>
<h2 id='shanwavf'>Complex Shannon Wavelet</h2><span id='topic+shanwavf'></span>

<h3>Description</h3>

<p>Compute the Complex Shannon wavelet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shanwavf(lb = -8, ub = 8, n = 1000, fb = 5, fc = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shanwavf_+3A_lb">lb</code>, <code id="shanwavf_+3A_ub">ub</code></td>
<td>
<p>Lower and upper bounds of the interval to evaluate the waveform
on. Default: -8 to 8.</p>
</td></tr>
<tr><td><code id="shanwavf_+3A_n">n</code></td>
<td>
<p>Number of points on the grid between <code>lb</code> and <code>ub</code> (length
of the wavelet). Default: 1000.</p>
</td></tr>
<tr><td><code id="shanwavf_+3A_fb">fb</code></td>
<td>
<p>Time-decay parameter of the wavelet (bandwidth in the frequency
domain). Must be a positive scalar. Default: 5.</p>
</td></tr>
<tr><td><code id="shanwavf_+3A_fc">fc</code></td>
<td>
<p>Center frequency of the wavelet. Must be a positive scalar.
Default: 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The complex Shannon wavelet is defined by a bandwidth parameter <code>fb</code>, a
wavelet center frequency <code>fc</code>, and the expression
</p>
<p style="text-align: center;"><code class="reqn">\psi(x) = (fb^{0.5} * (sinc(fb * x) * e^{2 * 1i * pi * fc * x}))</code>
</p>

<p>on an <code>n</code>-point regular grid in the interval of <code>lb</code> to <code>ub</code>.
</p>


<h3>Value</h3>

<p>A list containing 2 variables; <code>x</code>, the grid on which the
complex Shannon wavelet was evaluated, and <code>psi</code> (<code class="reqn">\Psi</code>), the
evaluated wavelet on the grid <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fb &lt;- 1
fc &lt;- 1.5
lb &lt;- -20
ub &lt;- 20
n &lt;- 1000
sw &lt;- shanwavf(lb, ub, n, fb, fc)
op &lt;- par(mfrow = c(2,1))
plot(sw$x, Re(sw$psi), type="l", main = "Complex Shannon Wavelet",
     xlab = "real part", ylab = "")
plot(sw$x, Im(sw$psi), type="l", xlab = "imaginary part", ylab = "")
par(op)

</code></pre>

<hr>
<h2 id='shiftdata'>Shift data to operate on specified dimension</h2><span id='topic+shiftdata'></span>

<h3>Description</h3>

<p>Shift data in to permute the dimension <code>dimx</code> to the first column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiftdata(x, dimx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shiftdata_+3A_x">x</code></td>
<td>
<p>The data to be shifted. Can be of any type.</p>
</td></tr>
<tr><td><code id="shiftdata_+3A_dimx">dimx</code></td>
<td>
<p>Dimension of <code>x</code> to be shifted to the first column. Named
&quot;dimx&quot; instead of &quot;dim&quot; to avoid confusion with R's dim() function.
Default: NULL (shift the first nonsingleton dimension)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>shiftdata(x, dimx)</code> shifts data <code>x</code> to permute dimension
<code>dimx</code> to the first column using the same permutation as the built-in
<code>filter</code> function. The vector <code>perm</code> in the output list returns the
permutation vector that is used.
</p>
<p>If <code>dimx</code> is missing or empty, then the first nonsingleton dimension is
shifted to the first column, and the number of shifts is returned in
<code>nshifts</code>.
</p>
<p><code>shiftdata</code> is meant to be used in tandem with <code>unshiftdata</code>, which
shifts the data back to its original shape. These functions are useful for
creating functions that work along a certain dimension, like
<code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+sgolayfilt">sgolayfilt</a></code>, and <code><a href="#topic+sosfilt">sosfilt</a></code>.
</p>


<h3>Value</h3>

<p>A list containing 3 variables; <code>x</code>, the shifted data,
<code>perm</code>, the permutation vector, and <code>nshifts</code>, the number of
shifts
</p>


<h3>Author(s)</h3>

<p>Georgios Ouzounis, <a href="mailto:ouzounis_georgios@hotmail.com">ouzounis_georgios@hotmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unshiftdata">unshiftdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create a 3x3 magic square
x &lt;- pracma::magic(3)
## Shift the matrix x to work along the second dimension.
## The permutation vector, perm, and the number of shifts, nshifts,
## are returned along with the shifted matrix.
sd &lt;- shiftdata(x, 2)

## Shift the matrix back to its original shape.
y &lt;- unshiftdata(sd)

## Rearrange Array to Operate on First nonsingleton Dimension
x &lt;- 1:5
sd &lt;- shiftdata(x)
y &lt;- unshiftdata(sd)

</code></pre>

<hr>
<h2 id='sigmoid_train'>Sigmoid Train</h2><span id='topic+sigmoid_train'></span>

<h3>Description</h3>

<p>Evaluate a train of sigmoid functions at <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmoid_train(t, ranges, rc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmoid_train_+3A_t">t</code></td>
<td>
<p>Vector (or coerced to a vector) of time values at which the sigmoids
are calculated.</p>
</td></tr>
<tr><td><code id="sigmoid_train_+3A_ranges">ranges</code></td>
<td>
<p>Matrix or array with 2 columns containing the time values
within <code>t</code> at which each sigmoid is evaluated. The number of sigmoids
is determined by the number of rows in <code>ranges</code>.</p>
</td></tr>
<tr><td><code id="sigmoid_train_+3A_rc">rc</code></td>
<td>
<p>Time constant. Either a scalar or a matrix or array with 2 columns
containing the rising and falling time constants of each sigmoid. If a
matrix or array is passed in <code>rc</code>, its size must equal the size of
<code>ranges</code>. If a single scalar is passed in <code>rc</code>, then all sigmoids
have the same time constant and are symmetrical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number and duration of each sigmoid is determined from ranges. Each row
of <code>ranges</code> represents a real interval, e.g. if sigmoid <code>i</code> starts
at <code>t = 0.1</code> and ends at <code>t = 0.5</code>, then <code>ranges[i, ] = c(0.1,
0.5)</code>. The input <code>rc</code> is an array that defines the rising and falling
time constants of each sigmoid. Its size must equal the size of ranges.
</p>
<p>The individual sigmoids are returned in <code>s</code>. The combined sigmoid train
is returned in the vector <code>y</code> of length equal to <code>t</code>, and such that
<code>y = max(s)</code>.
</p>


<h3>Value</h3>

<p>A list consisting two variables; <code>y</code> the combined sigmoid train
(length identical to <code>t</code>), and <code>s</code>, the individual sigmoids
(number of rows equal to number of rows in <code>ranges</code> and <code>rc</code>.
</p>


<h3>Author(s)</h3>

<p>Juan Pablo Carbajal, <a href="mailto:carbajal@ifi.uzh.ch">carbajal@ifi.uzh.ch</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t &lt;- seq(0, 2, length.out = 500)
ranges &lt;- rbind(c(0.1, 0.4), c(0.6, 0.8), c(1, 2))
rc &lt;- rbind(c(1e-2, 1e-3), c(1e-3, 2e-2), c(2e-2, 1e-2))
st &lt;- sigmoid_train (t, ranges, rc)
plot(t, st$y[1,], type="n", xlab = "Time(s)", ylab = "S(t)",
     main = "Vectorized use of sigmoid train")
for (i in 1:3) rect(ranges[i, 1], 0, ranges[i, 2], 1,
                    border = NA, col="pink")
for (i in 1:3) lines(t, st$y[i,])
# The colored regions show the limits defined in range.

t &lt;- seq(0, 2, length.out = 500)
ranges &lt;- rbind(c(0.1, 0.4), c(0.6, 0.8), c(1, 2))
rc &lt;- rbind(c(1e-2, 1e-3), c(1e-3, 2e-2), c(2e-2, 1e-2))
amp &lt;- c(4, 2, 3)
st &lt;- sigmoid_train (t, ranges, rc)
y &lt;- amp %*% st$y
plot(t, y[1,], type="l", xlab = 'time', ylab = 'signal',
     main = 'Varying amplitude sigmoid train', col="blue")
lines(t, st$s, col = "orange")
legend("topright", legend = c("Sigmoid train", "Components"),
       lty = 1, col = c("blue", "orange"))

</code></pre>

<hr>
<h2 id='signals'>signals</h2><span id='topic+signals'></span>

<h3>Description</h3>

<p>Sample EEG and ECG data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signals
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing 10 seconds of data
electrophysiological data, sampled at 256 Hz with a 24 bit A/D converter,
measured in microVolts. The data frame consists of 2 columns (channels):
</p>

<dl>
<dt>eeg</dt><dd><p>electroencephalogram (EEG) data measured from electrode Pz
according to the 10-20 system, referred to algebraically linked mastoids
(the brain's alpha rhythm is clearly visible).</p>
</dd>
<dt>ecg</dt><dd><p>electrocardiogram (ECG) data, recorded bipolarly with a V6
versus V1 chest lead (this lead maximizes the R wave of the ECG with
respect to the P, Q, S, T and U waves of the cardiac cycle).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(signals)
time &lt;- seq(0, 10, length.out = nrow(signals))
op &lt;- par(mfcol = c(2, 1))
plot(time, signals[, 1], type = "l", xlab = "Time", ylab = "EEG (uV)")
plot(time, signals[, 2], type = "l", xlab = "Time", ylab = "ECG (uV)")
par(op)

</code></pre>

<hr>
<h2 id='sinetone'>Sine tone</h2><span id='topic+sinetone'></span>

<h3>Description</h3>

<p>Generate discrete sine tone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinetone(freq, rate = 8000, sec = 1, ampl = 64)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinetone_+3A_freq">freq</code></td>
<td>
<p>frequency of the tone, specified as a vector of positive numeric
values. The length of <code>freq</code> should equal the length of the
<code>ampl</code> vector; the shorter of the two is recycled to the longer
vector.</p>
</td></tr>
<tr><td><code id="sinetone_+3A_rate">rate</code></td>
<td>
<p>sampling frequency, specified as a positive scalar. Default:
8000.</p>
</td></tr>
<tr><td><code id="sinetone_+3A_sec">sec</code></td>
<td>
<p>length of the generated tone in seconds. Default: 1</p>
</td></tr>
<tr><td><code id="sinetone_+3A_ampl">ampl</code></td>
<td>
<p>amplitude of the tone, specified as a vector of positive numeric
values. The length of <code>ampl</code> should equal the length of the
<code>freq</code> vector; the shorter of the two is recycled to the longer
vector. Default: 64.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sine tone, returned as a vector of length <code>rate * sec</code>, or as a
matrix with <code>rate * sec</code> columns and  <code>max(length(freq),
  length(ampl))</code> columns.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- 1000
sec &lt;- 2
y &lt;- sinetone(10, fs, sec, 1)
plot(seq(0, sec, length.out = sec * fs), y, type = "l", xlab = "", ylab = "")

y &lt;- sinetone(c(10, 15), fs, sec, c(1, 2))
matplot(seq(0, sec, length.out = sec * fs), y, type = "l",
        xlab = "", ylab = "")

</code></pre>

<hr>
<h2 id='sinewave'>Sine wave</h2><span id='topic+sinewave'></span>

<h3>Description</h3>

<p>Generate a discrete sine wave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinewave(m, n = m, d = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinewave_+3A_m">m</code></td>
<td>
<p>desired length of the generated series, specified as a positive
integer.</p>
</td></tr>
<tr><td><code id="sinewave_+3A_n">n</code></td>
<td>
<p>rate, of the generated series, specified as a positive integer.
Default: <code>m</code>.</p>
</td></tr>
<tr><td><code id="sinewave_+3A_d">d</code></td>
<td>
<p>delay, specified as a positive integer. Default: 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sine wave, returned as a vector of length <code>m</code>.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(sinewave(100, 10), type = "l")

</code></pre>

<hr>
<h2 id='Sos'>Second-order sections</h2><span id='topic+Sos'></span><span id='topic+as.Sos'></span><span id='topic+as.Sos.Arma'></span><span id='topic+as.Sos.Ma'></span><span id='topic+as.Sos.Sos'></span><span id='topic+as.Sos.Zpg'></span>

<h3>Description</h3>

<p>Create or convert filter models to second-order sections form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sos(sos, g = 1)

as.Sos(x, ...)

## S3 method for class 'Arma'
as.Sos(x, ...)

## S3 method for class 'Ma'
as.Sos(x, ...)

## S3 method for class 'Sos'
as.Sos(x, ...)

## S3 method for class 'Zpg'
as.Sos(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sos_+3A_sos">sos</code></td>
<td>
<p>second-order sections representation of the model</p>
</td></tr>
<tr><td><code id="Sos_+3A_g">g</code></td>
<td>
<p>overall gain factor</p>
</td></tr>
<tr><td><code id="Sos_+3A_x">x</code></td>
<td>
<p>model to be converted.</p>
</td></tr>
<tr><td><code id="Sos_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.Sos</code> converts from other forms, including <code>Arma</code>, <code>Ma</code>,
and <code>Zpg</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>Sos</code> with the following list elements:
</p>

<dl>
<dt>sos</dt><dd><p>second-order section representation of the model, returned as an
<code>L x 6</code> matrix, one row for each section <code>1:L</code>. Each row
consists of an <code>[B, A]</code>, pair, where <code>B = c(b0, b1, b2)</code>, and
<code>A = c(1, a1, a2)</code>, the filer coefficients for each section. Each
<code>b0</code> entry must be nonzero for each section.</p>
</dd>
<dt>g</dt><dd><p>overall gain factor that scales any one of the <code class="reqn">B_i</code> vectors.
Default: 1</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Arma">Arma</a></code>, <code><a href="#topic+Ma">Ma</a></code>, <code><a href="#topic+Zpg">Zpg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ba &lt;- butter(3, 0.2)
sos &lt;- as.Sos(ba)

</code></pre>

<hr>
<h2 id='sos2tf'>Sos to transfer function</h2><span id='topic+sos2tf'></span>

<h3>Description</h3>

<p>Convert digital filter second-order section data to transfer function form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sos2tf(sos, g = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sos2tf_+3A_sos">sos</code></td>
<td>
<p>Second-order section representation, specified as an nrow-by-6
matrix, whose rows contain the numerator and denominator coefficients of
the second-order sections:<br /> <code>sos &lt;- rbind(cbind(B1, A1), cbind(...),
cbind(Bn, An))</code>, where <code>B1 &lt;- c(b0, b1, b2)</code>, and <code>A1 &lt;- c(a0,
a1, a2)</code> for section 1, etc. The b0 entry must be nonzero for each section.</p>
</td></tr>
<tr><td><code id="sos2tf_+3A_g">g</code></td>
<td>
<p>Overall gain factor that effectively scales the output <code>b</code>
vector (or any one of the input <code>Bi</code> vectors). Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;Arma&quot; with the following list elements:
</p>

<dl>
<dt>b</dt><dd><p>moving average (MA) polynomial coefficients</p>
</dd>
<dt>a</dt><dd><p>autoregressive (AR) polynomial coefficients</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Julius O. Smith III, <a href="mailto:jos@ccrma.stanford.edu">jos@ccrma.stanford.edu</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.Arma">as.Arma</a></code>, <code><a href="#topic+filter">filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sos &lt;- rbind(c(1, 1, 1, 1, 0, -1), c(-2, 3, 1, 1, 10, 1))
ba &lt;- sos2tf(sos)

</code></pre>

<hr>
<h2 id='sos2zp'>Sos to zero-pole-gain</h2><span id='topic+sos2zp'></span>

<h3>Description</h3>

<p>Convert digital filter second-order section data to zero-pole-gain form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sos2zp(sos, g = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sos2zp_+3A_sos">sos</code></td>
<td>
<p>Second-order section representation, specified as an nrow-by-6
matrix, whose rows contain the numerator and denominator coefficients of
the second-order sections:<br /> <code>sos &lt;- rbind(cbind(B1, A1), cbind(...),
cbind(Bn, An))</code>, where <code>B1 &lt;- c(b0, b1, b2)</code>, and <code>A1 &lt;- c(a0,
a1, a2)</code> for section 1, etc. The b0 entry must be nonzero for each section.</p>
</td></tr>
<tr><td><code id="sos2zp_+3A_g">g</code></td>
<td>
<p>Overall gain factor that effectively scales the output <code>b</code>
vector (or any one of the input <code>B_i</code> vectors). Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;Zpg&quot; with the following list elements:
</p>

<dl>
<dt>z</dt><dd><p>complex vector of the zeros of the model (roots of <code>B(z)</code>)</p>
</dd>
<dt>p</dt><dd><p>complex vector of the poles of the model (roots of <code>A(z)</code>)</p>
</dd>
<dt>k</dt><dd><p>overall gain (<code>B(Inf)</code>)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Julius O. Smith III <a href="mailto:jos@ccrma.stanford.edu">jos@ccrma.stanford.edu</a>.<br />
Conversion to R by, Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter">filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sos &lt;- rbind(c(1, 0, 1, 1, 0, -0.81), c(1, 0, 0, 1, 0, 0.49))
zpk &lt;- sos2zp(sos)

</code></pre>

<hr>
<h2 id='sosfilt'>Second-order sections filtering</h2><span id='topic+sosfilt'></span>

<h3>Description</h3>

<p>One-dimensional second-order (biquadratic) sections IIR digital filtering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sosfilt(sos, x, zi = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sosfilt_+3A_sos">sos</code></td>
<td>
<p>Second-order section representation, specified as an nrow-by-6
matrix, whose rows contain the numerator and denominator coefficients of
the second-order sections:<br /> <code>sos &lt;- rbind(cbind(B1, A1), cbind(...),
cbind(Bn, An))</code>, where <code>B1 &lt;- c(b0, b1, b2)</code>, and <code>A1 &lt;- c(a0,
a1, a2)</code> for section 1, etc. The b0 entry must be nonzero for each section.</p>
</td></tr>
<tr><td><code id="sosfilt_+3A_x">x</code></td>
<td>
<p>the input signal to be filtered, specified as a numeric or complex
vector or matrix. If <code>x</code> is a matrix, each column is filtered.</p>
</td></tr>
<tr><td><code id="sosfilt_+3A_zi">zi</code></td>
<td>
<p>If <code>zi</code> is provided, it is taken as the initial state of the
system and the final state is returned as zf. If <code>x</code> is a vector,
<code>zi</code> must be a matrix with <code>nrow(sos)</code> rows and 2 columns. If
<code>x</code> is a matrix, then <code>zi</code> must be a 3-dimensional array of size
<code>(nrow(sos), 2, ncol(x))</code>. Alternatively, <code>zi</code> may be the
character string <code>"zf"</code>, which specifies to return the final state
vector even though the initial state vector is set to all zeros. Default:
NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The filter function is implemented as a series of second-order filters
with direct-form II transposed structure. It is designed to minimize
numerical precision errors for high-order filters [1].
</p>


<h3>Value</h3>

<p>The filtered signal, of the same dimensions as the input signal. In
case the <code>zi</code> input argument was specified, a list with two elements
is returned containing the variables <code>y</code>, which represents the output
signal, and <code>zf</code>, which contains the final state vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>Smith III, J.O. (2012). Introduction to digital filters, with
audio applications (3rd Ed.). W3K Publishing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+filtfilt">filtfilt</a></code>, <code><a href="#topic+Sos">Sos</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- 1000
t &lt;- seq(0, 1, 1/fs)
s &lt;- sin(2* pi * t * 6)
x &lt;- s + rnorm(length(t))
plot(t, x, type = "l", col="light gray")
lines(t, s, col="black")
sosg &lt;- butter(3, 0.02, output = "Sos")
sos &lt;- sosg$sos
sos[1, 1:3] &lt;- sos[1, 1:3] * sosg$g
y &lt;- sosfilt(matrix(sos, ncol=6), x)
lines(t, y, col="red")

## using 'filter' will handle the gain for you
y2 &lt;- filter(sosg, x)
all.equal(y, y2)

## The following example is from Python scipy.signal.sosfilt
## It shows the instability that results from trying to do a
## 13th-order filter in a single stage (the numerical error
## pushes some poles outside of the unit circle)
arma &lt;- ellip(13, 0.009, 80, 0.05, output='Arma')
sos &lt;- ellip(13, 0.009, 80, 0.05, output='Sos')
x &lt;- rep(0, 700); x[1] &lt;- 1
y_arma &lt;- filter(arma, x)
y_sos &lt;- filter(sos, x)
plot(y_arma, type ="l")
lines (y_sos, col = 2)
legend("topleft", legend = c("Arma", "Sos"), lty = 1, col = 1:2)

</code></pre>

<hr>
<h2 id='specgram'>Spectrogram</h2><span id='topic+specgram'></span><span id='topic+plot.specgram'></span><span id='topic+print.specgram'></span>

<h3>Description</h3>

<p>Spectrogram using short-time Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specgram(
  x,
  n = min(256, length(x)),
  fs = 2,
  window = hanning(n),
  overlap = ceiling(n/2)
)

## S3 method for class 'specgram'
plot(
  x,
  col = grDevices::gray(0:512/512),
  xlab = "Time",
  ylab = "Frequency",
  ...
)

## S3 method for class 'specgram'
print(
  x,
  col = grDevices::gray(0:512/512),
  xlab = "Time",
  ylab = "Frequency",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specgram_+3A_x">x</code></td>
<td>
<p>Input signal, specified as a vector.</p>
</td></tr>
<tr><td><code id="specgram_+3A_n">n</code></td>
<td>
<p>Size of the FFT window. Default: 256 (or less if <code>x</code> is
shorter).</p>
</td></tr>
<tr><td><code id="specgram_+3A_fs">fs</code></td>
<td>
<p>Sample rate in Hz. Default: 2</p>
</td></tr>
<tr><td><code id="specgram_+3A_window">window</code></td>
<td>
<p>Either an integer indicating the length of a Hanning window, or
a vector of values representing the shape of the FFT tapering window.
Default: hanning(n)</p>
</td></tr>
<tr><td><code id="specgram_+3A_overlap">overlap</code></td>
<td>
<p>Overlap with previous window. Default: half the window length</p>
</td></tr>
<tr><td><code id="specgram_+3A_col">col</code></td>
<td>
<p>Colormap to use for plotting. Default: <code>grDevices::gray(0:512
/ 512)</code></p>
</td></tr>
<tr><td><code id="specgram_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis of plot. Default: <code>"Time"</code></p>
</td></tr>
<tr><td><code id="specgram_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis of plot. Default: <code>"Frequency"</code></p>
</td></tr>
<tr><td><code id="specgram_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>image</code> plotting function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate a spectrogram for the signal <code>x</code>. The signal is chopped into
overlapping segments of length <code>n</code>, and each segment is windowed and
transformed into the frequency domain using the FFT. The default segment size
is 256. If <code>fs</code> is given, it specifies the sampling rate of the input
signal. The argument <code>window</code> specifies an alternate window to apply
rather than the default of <code>hanning(n)</code>. The argument overlap specifies
the number of samples overlap between successive segments of the input
signal. The default overlap is <code>length (window)/2</code>.
</p>
<p>When results of <code>specgram</code> are printed, a spectrogram will be plotted.
As with <code>lattice</code> plots, automatic printing does not work inside loops
and function calls, so explicit calls to <code>print</code> or <code>plot</code> are
needed there.
</p>
<p>The choice of window defines the time-frequency resolution. In speech for
example, a wide window shows more harmonic detail while a narrow window
averages over the harmonic detail and shows more formant structure. The shape
of the window is not so critical so long as it goes gradually to zero on the
ends.
</p>
<p>Step size (which is window length minus overlap) controls the horizontal
scale of the spectrogram. Decrease it to stretch, or increase it to compress.
Increasing step size will reduce time resolution, but decreasing it will not
improve it much beyond the limits imposed by the window size (you do gain a
little bit, depending on the shape of your window, as the peak of the window
slides over peaks in the signal energy). The range 1-5 msec is good for
speech.
</p>
<p>FFT length controls the vertical scale. Selecting an FFT length greater than
the window length does not add any information to the spectrum, but it is a
good way to interpolate between frequency points which can make for prettier
spectrograms.
</p>
<p>AFTER you have generated the spectral slices, there are a number of decisions
for displaying them. First the phase information is discarded and the energy
normalized:
</p>
<p><code>S &lt;- abs(S); S &lt;- S / max(S)</code>
</p>
<p>Then the dynamic range of the signal is chosen. Since information in speech
is well above the noise floor, it makes sense to eliminate any dynamic range
at the bottom end. This is done by taking the max of the magnitude and some
minimum energy such as minE = -40dB. Similarly, there is not much information
in the very top of the range, so clipping to a maximum energy such as maxE =
-3dB makes sense:
</p>
<p><code>S &lt;- max(S, 10^(minE / 10)); S &lt;- min(S, 10^(maxE / 10))</code>
</p>
<p>The frequency range of the FFT is from 0 to the Nyquist frequency of one half
the sampling rate. If the signal of interest is band limited, you do not need
to display the entire frequency range. In speech for example, most of the
signal is below 4 kHz, so there is no reason to display up to the Nyquist
frequency of 10 kHz for a 20 kHz sampling rate. In this case you will want to
keep only the first 40
More generally, to display the frequency range from minF to maxF, you could
use the following row index:
</p>
<p><code>idx &lt;- (f &gt;= minF &amp; f &lt;= maxF)</code>
</p>
<p>Then there is the choice of colormap. A brightness varying colormap such as
copper or bone gives good shape to the ridges and valleys. A hue varying
colormap such as jet or hsv gives an indication of the steepness of the
slopes. In the field that I am working in (neuroscience / electrophysiology)
rainbow color palettes such as jet are very often used. This is an
unfortunate choice mainly because (a) colors do not have a natural order, and
(b) rainbow palettes are not perceptually linear. It would be better to use a
grayscale palette or the 'cool-to-warm' scheme. The examples show how to do
this in R.
</p>
<p>The final spectrogram is displayed in log energy scale and by convention has
low frequencies on the bottom of the image.
</p>


<h3>Value</h3>

<p>A list of class <code>specgram</code> consisting of the following elements:
</p>

<dl>
<dt>S</dt><dd><p>the complex output of the FFT, one row per slice</p>
</dd>
<dt>f</dt><dd><p>the frequency indices corresponding to the rows of S</p>
</dd>
<dt>t</dt><dd><p>the time indices corresponding to the columns of S</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Tom Short<br />
This conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sp &lt;- specgram(chirp(seq(-2, 15, by = 0.001), 400, 10, 100, 'quadratic'))
specgram(chirp(seq(0, 5, by = 1/8000), 200, 2, 500,
        "logarithmic"), fs = 8000)

# use other color palettes than grayscale
jet &lt;- grDevices::colorRampPalette(
         c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F",
           "yellow", "#FF7F00", "red", "#7F0000"))
plot(specgram(chirp(seq(0, 5, by = 1/8000), 200, 2, 500, "logarithmic"),
         fs = 8000), col = jet(20))
c2w &lt;- grDevices::colorRampPalette(colors = c("red", "white", "blue"))
plot(specgram(chirp(seq(0, 5, by = 1/8000), 200, 2, 500, "logarithmic"),
         fs = 8000), col = c2w(50))

</code></pre>

<hr>
<h2 id='square'>Square wave</h2><span id='topic+square'></span>

<h3>Description</h3>

<p>Generate a square wave of period <code class="reqn">2\pi</code> with limits +1 and -1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>square(t, duty = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="square_+3A_t">t</code></td>
<td>
<p>Time array, specified as a vector.</p>
</td></tr>
<tr><td><code id="square_+3A_duty">duty</code></td>
<td>
<p>Duty cycle, specified as a real scalar from 0 to 100. Default:
50.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y &lt;- square(t)</code> generates a square wave with period <code class="reqn">2\pi</code> for the
elements of the time array <code>t</code>.
<code>square</code> is similar to the sine function but creates a square wave with
values of –1 and 1.
</p>
<p><code>y &lt;- square(t, duty)</code> generates a square wave with specified duty cycle
<code>duty</code>. The duty cycle is the percent of the signal period in which the
square wave is positive.

</p>
<pre>
                     ontime * 100
     duty cycle =  ----------------
                   ontime + offtime
</pre>


<h3>Value</h3>

<p>Square wave, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a vector of 100 equally spaced numbers from 0 to 3pi.
## Generate a square wave with a period of 2pi.
t &lt;- seq(0, 3*pi, length.out = 100)
y &lt;- square(t)
plot(t/pi, y, type="l", xlab = expression(t/pi), ylab = "")
lines (t/pi, sin(t), col = "red")

## Generate a 30 Hz square wave sampled at 1 kHz for 70 ms.
## Specify a duty cycle of 37%.
## Add white Gaussian noise with a variance of 1/100.
t &lt;- seq(0, 0.07, 1/1e3)
y &lt;- square(2 * pi * 30 * t, 37) + rnorm(length(t)) / 10
plot(t, y, type="l", xlab = "", ylab = "")

</code></pre>

<hr>
<h2 id='stft'>Short-Term Fourier Transform</h2><span id='topic+stft'></span>

<h3>Description</h3>

<p>Compute the short-term Fourier transform of a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stft(
  x,
  window = nextpow2(sqrt(NROW(x))),
  overlap = 0.75,
  nfft = ifelse(isScalar(window), window, length(window)),
  fs = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stft_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric or complex vector or matrix. In
case of a vector it represents a single signal; in case of a matrix each
column is a signal.</p>
</td></tr>
<tr><td><code id="stft_+3A_window">window</code></td>
<td>
<p>If <code>window</code> is a vector, each segment has the same length
as <code>window</code> and is multiplied by <code>window</code> before (optional)
zero-padding and calculation of its periodogram. If <code>window</code> is a
scalar, each segment has a length of <code>window</code> and a Hamming window is
used. Default: <code>nextpow2(sqrt(length(x)))</code> (the square root of the
length of <code>x</code> rounded up to the next power of two). The window length
must be larger than 3.</p>
</td></tr>
<tr><td><code id="stft_+3A_overlap">overlap</code></td>
<td>
<p>segment overlap, specified as a numeric value expressed as a
multiple of window or segment length. 0 &lt;= overlap &lt; 1. Default: 0.5.</p>
</td></tr>
<tr><td><code id="stft_+3A_nfft">nfft</code></td>
<td>
<p>Length of FFT, specified as an integer scalar. The default is the
length of the <code>window</code> vector or has the same value as the scalar
<code>window</code> argument.  If <code>nfft</code> is larger than the segment length,
(seg_len), the data segment is padded <code>nfft - seg_len</code> zeros. The
default is no padding. Nfft values smaller than the length of the data
segment (or window) are ignored. Note that the use of padding to increase
the frequency resolution of the spectral estimate is controversial.</p>
</td></tr>
<tr><td><code id="stft_+3A_fs">fs</code></td>
<td>
<p>sampling frequency (Hertz), specified as a positive scalar.
Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>f</code></dt><dd><p>vector of frequencies at which the STFT is estimated.
If <code>x</code> is numeric, power from negative frequencies is added to the
positive side of the spectrum, but not at zero or Nyquist (fs/2)
frequencies. This keeps power equal in time and spectral domains. If
<code>x</code> is complex, then the whole frequency range is returned.</p>
</dd>
<dt><code>t</code></dt><dd><p>vector of time points at which the STFT is estimated.</p>
</dd>
<dt><code>s</code></dt><dd><p>Short-time Fourier transform, returned as a matrix or
a 3-D array. Time increases across the columns of <code>s</code> and frequency
increases down the rows. The third dimension, if present, corresponds to
the input channels.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Andreas Weingessel, <a href="mailto:Andreas.Weingessel@ci.tuwien.ac.at">Andreas.Weingessel@ci.tuwien.ac.at</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- 8000
y &lt;- chirp(seq(0, 5 - 1/fs, by = 1/fs), 200, 2, 500, "logarithmic")
ft &lt;- stft (y, fs = fs)
filled.contour(ft$t, ft$f, t(ft$s), xlab = "Time (s)",
               ylab = "Frequency (Hz)")

</code></pre>

<hr>
<h2 id='tf2sos'>Transfer function to second-order sections form</h2><span id='topic+tf2sos'></span>

<h3>Description</h3>

<p>Convert digital filter transfer function data to second-order section form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf2sos(b, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf2sos_+3A_b">b</code></td>
<td>
<p>moving average (MA) polynomial coefficients</p>
</td></tr>
<tr><td><code id="tf2sos_+3A_a">a</code></td>
<td>
<p>autoregressive (AR) polynomial coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following list elements:
</p>

<dl>
<dt>sos</dt><dd><p>Second-order section representation, specified as an nrow-by-6
matrix, whose rows contain the numerator and denominator coefficients of
the second-order sections:<br /> <code>sos &lt;- rbind(cbind(B1, A1), cbind(...),
  cbind(Bn, An))</code>, where <code>B1 &lt;- c(b0, b1, b2)</code>, and <code>A1 &lt;- c(a0,
  a1, a2)</code> for section 1, etc. The b0 entry must be nonzero for each
section.</p>
</dd>
<dt>g</dt><dd><p>Overall gain factor that effectively scales the output <code>b</code>
vector (or any one of the input <code>Bi</code> vectors).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Julius O. Smith III, <a href="mailto:jos@ccrma.stanford.edu">jos@ccrma.stanford.edu</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+filter">filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- c(1, 0, 0, 0, 0, 1)
a &lt;- c(1, 0, 0, 0, 0, .9)
sosg &lt;- tf2sos (b, a)

</code></pre>

<hr>
<h2 id='tf2zp'>Transfer function to zero-pole-gain form</h2><span id='topic+tf2zp'></span>

<h3>Description</h3>

<p>Convert digital filter transfer function parameters to zero-pole-gain form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf2zp(b, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf2zp_+3A_b">b</code></td>
<td>
<p>moving average (MA) polynomial coefficients, specified as a numeric
vector or matrix. In case of a matrix, then each row corresponds to an
output of the system. The number of columns of <code>b</code> must be less than
or equal to the length of <code>a</code>.</p>
</td></tr>
<tr><td><code id="tf2zp_+3A_a">a</code></td>
<td>
<p>autoregressive (AR) polynomial coefficients, specified as a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class Zpg with the following list elements:
</p>

<dl>
<dt>z</dt><dd><p>complex vector of the zeros of the model (roots of <code>B(z)</code>)</p>
</dd>
<dt>p</dt><dd><p>complex vector of the poles of the model (roots of <code>A(z)</code>)</p>
</dd>
<dt>g</dt><dd><p>overall gain (<code>B(Inf)</code>)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter">filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- c(2, 3)
a &lt;- c(1, 1/sqrt(2), 1/4)
zpk &lt;- tf2zp(b, a)

</code></pre>

<hr>
<h2 id='tfestimate'>Transfer Function Estimate</h2><span id='topic+tfestimate'></span><span id='topic+tfe'></span>

<h3>Description</h3>

<p>Finds a transfer function estimate for signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfestimate(
  x,
  window = nextpow2(sqrt(NROW(x))),
  overlap = 0.5,
  nfft = ifelse(isScalar(window), window, length(window)),
  fs = 1,
  detrend = c("long-mean", "short-mean", "long-linear", "short-linear", "none")
)

tfe(
  x,
  window = nextpow2(sqrt(NROW(x))),
  overlap = 0.5,
  nfft = ifelse(isScalar(window), window, length(window)),
  fs = 1,
  detrend = c("long-mean", "short-mean", "long-linear", "short-linear", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfestimate_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="tfestimate_+3A_window">window</code></td>
<td>
<p>If <code>window</code> is a vector, each segment has the same length
as <code>window</code> and is multiplied by <code>window</code> before (optional)
zero-padding and calculation of its periodogram. If <code>window</code> is a
scalar, each segment has a length of <code>window</code> and a Hamming window is
used. Default: <code>nextpow2(sqrt(length(x)))</code> (the square root of the
length of <code>x</code> rounded up to the next power of two). The window length
must be larger than 3.</p>
</td></tr>
<tr><td><code id="tfestimate_+3A_overlap">overlap</code></td>
<td>
<p>segment overlap, specified as a numeric value expressed as a
multiple of window or segment length. 0 &lt;= overlap &lt; 1. Default: 0.5.</p>
</td></tr>
<tr><td><code id="tfestimate_+3A_nfft">nfft</code></td>
<td>
<p>Length of FFT, specified as an integer scalar. The default is the
length of the <code>window</code> vector or has the same value as the scalar
<code>window</code> argument.  If <code>nfft</code> is larger than the segment length,
(seg_len), the data segment is padded <code>nfft - seg_len</code> zeros. The
default is no padding. Nfft values smaller than the length of the data
segment (or window) are ignored. Note that the use of padding to increase
the frequency resolution of the spectral estimate is controversial.</p>
</td></tr>
<tr><td><code id="tfestimate_+3A_fs">fs</code></td>
<td>
<p>sampling frequency (Hertz), specified as a positive scalar.
Default: 1.</p>
</td></tr>
<tr><td><code id="tfestimate_+3A_detrend">detrend</code></td>
<td>
<p>character string specifying detrending option; one of:
</p>

<dl>
<dt><code>"long-mean"</code></dt><dd><p>remove the mean from the data before
splitting into segments (default)</p>
</dd>
<dt><code>"short-mean"</code></dt><dd><p>remove the mean value of each segment</p>
</dd>
<dt><code>"long-linear"</code></dt><dd><p>remove linear trend from the data before
splitting into segments</p>
</dd>
<dt><code>"short-linear"</code></dt><dd><p>remove linear trend from each segment</p>
</dd>
<dt><code>"none"</code></dt><dd><p>no detrending</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tfestimate</code> uses Welch's averaged periodogram method.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>freq</code></dt><dd><p>vector of frequencies at which the spectral variables
are estimated. If <code>x</code> is numeric, power from negative frequencies is
added to the positive side of the spectrum, but not at zero or Nyquist
(fs/2) frequencies. This keeps power equal in time and spectral domains.
If <code>x</code> is complex, then the whole frequency range is returned.</p>
</dd>
<dt><code>trans</code></dt><dd><p>NULL for univariate series. For multivariate series,
a matrix containing the transfer function estimates between different
series. Column <code class="reqn">i + (j - 1) * (j - 2)/2 </code> of <code>coh</code> contains the
cross-spectral estimates between columns <code class="reqn">i</code> and <code class="reqn">j</code> of <code class="reqn">x</code>,
where <code class="reqn">i &lt; j</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The function <code>tfestimate</code> (and its deprecated alias <code>tfe</code>)
is a wrapper for the function <code>pwelch</code>, which is more complete and
more flexible.
</p>


<h3>Author(s)</h3>

<p>Peter V. Lanspeary, <a href="mailto:pvl@mecheng.adelaide.edu.au">pvl@mecheng.adelaide.edu.au</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pwelch">pwelch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- 1000
f &lt;- 250
t &lt;- seq(0, 1 - 1/fs, 1/fs)
s1 &lt;- sin(2 * pi * f * t) + runif(length(t))
s2 &lt;- sin(2 * pi * f * t - pi / 3) + runif(length(t))
rv &lt;- tfestimate(cbind(s1, s2), fs = fs)
plot(rv$freq, 10*log10(abs(rv$trans)), type="l", xlab = "Frequency",
 ylab = "Tranfer Function Estimate (dB)", main = colnames((rv$trans)))

h &lt;- fir1(30, 0.2, window = rectwin(31))
x &lt;- rnorm(16384)
y &lt;- filter(h, x)
tfe &lt;- tfestimate(cbind(x, y), 1024, fs = 500)
plot(tfe$freq, 10*log10(abs(tfe$trans)), type="l", xlab = "Frequency",
  ylab = "Tranfer Function Estimate (dB)", main = colnames((tfe$trans)))

</code></pre>

<hr>
<h2 id='triang'>Triangular window</h2><span id='topic+triang'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a triangular window of length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triang(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triang_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the Bartlett window, <code>triang</code> does not go to zero at the edges of
the window. For odd <code>n</code>, <code>triang(n)</code> is equal to <code>bartlett(m +
2)</code> except for the zeros at the edges of the window.
</p>


<h3>Value</h3>

<p>triangular window, returned as a vector. If you specify a one-point
window <code>(n = 1)</code>, the value 1 is returned.
</p>


<h3>Author(s)</h3>

<p>Andreas Weingessel, <a href="mailto:Andreas.Weingessel@ci.tuwien.ac.at">Andreas.Weingessel@ci.tuwien.ac.at</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bartlett">bartlett</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t &lt;- triang(64)
plot (t, type = "l", xlab = "Samples", ylab =" Amplitude")

</code></pre>

<hr>
<h2 id='tripuls'>Sampled aperiodic triangle</h2><span id='topic+tripuls'></span>

<h3>Description</h3>

<p>Generate a triangular pulse over the interval <code>-w / 2</code> to <code>w / 2</code>,
sampled at times <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tripuls(t, w = 1, skew = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tripuls_+3A_t">t</code></td>
<td>
<p>Sample times of triangle wave specified by a vector.</p>
</td></tr>
<tr><td><code id="tripuls_+3A_w">w</code></td>
<td>
<p>Width of the triangular pulse to be generated. Default: 1.</p>
</td></tr>
<tr><td><code id="tripuls_+3A_skew">skew</code></td>
<td>
<p>Skew, a value between -1 and 1, indicating the relative placement
of the peak within the width. -1 indicates that the peak should be at
<code>-w / 2</code>, and 1 indicates that the peak should be at <code>w / 2</code>.
Default: 0 (no skew).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y &lt;- tripuls(t)</code> returns a continuous, aperiodic, symmetric,
unity-height triangular pulse at the times indicated in array <code>t</code>,
centered about <code>t = 0</code> and with a default width of 1.
</p>
<p><code>y &lt;- tripuls(t, w)</code> generates a triangular pulse of width <code>w</code>.
</p>
<p><code>y &lt;- tripuls(t, w, skew)</code> generates a triangular pulse with skew
<code>skew</code>, where <code class="reqn">-1 \le skew \le 1</code>. When <code>skew</code> is 0, a
symmetric triangular pulse is generated.
</p>


<h3>Value</h3>

<p>Triangular pulse, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, Mike Miller.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fs &lt;- 10e3
t &lt;- seq(-0.1, 0.1, 1/fs)
w &lt;- 40e-3
y &lt;- tripuls(t, w)
plot(t, y, type="l", xlab = "", ylab = "",
     main = "Symmetric triangular pulse")

## displace into paste and future
tpast &lt;- -45e-3
spast &lt;- -0.45
ypast &lt;- tripuls(t-tpast, w, spast)
tfutr &lt;- 60e-3
sfutr &lt;- 1
yfutr &lt;- tripuls(t-tfutr, w/2, sfutr)
plot (t, y, type = "l", xlab = "", ylab = "", ylim = c(0, 1))
lines(t, ypast, col = "red")
lines(t, yfutr, col = "blue")

</code></pre>

<hr>
<h2 id='tukeywin'>Tukey (tapered cosine) window</h2><span id='topic+tukeywin'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a Tukey window (also known as the
cosine-tapered window) of length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tukeywin(n, r = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tukeywin_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="tukeywin_+3A_r">r</code></td>
<td>
<p>Cosine fraction, specified as a real scalar. The Tukey window is a
rectangular window with the first and last <code>r / 2</code> percent of the
samples equal to parts of a cosine. For example, setting <code>r = 0.5</code>
(default) produces a Tukey window where 1/2 of the entire window length
consists of segments of a phase-shifted cosine with period 2r = 1. If you
specify r &lt;= 0, an n-point rectangular window is returned. If you specify r
&gt;= 1, an n-point von Hann window is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Tukey window, also known as the tapered cosine window, can be regarded as
a cosine lobe that is convolved with a rectangular window.  <code>r</code> defines
the ratio between the constant section and and the cosine section. It has to
be between 0 and 1. The function returns a Hann window for <code>r</code> equal to
1 and a rectangular window for <code>r</code> equal to 0.
</p>


<h3>Value</h3>

<p>Tukey window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Laurent Mazet, <a href="mailto:mazet@crm.mot.com">mazet@crm.mot.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 128
t0 &lt;- tukeywin(n, 0)        # Equivalent to a rectangular window
t25 &lt;- tukeywin(n, 0.25)
t5 &lt;- tukeywin(n)           # default r = 0.5
t75 &lt;- tukeywin(n, 0.75)
t1 &lt;- tukeywin(n, 1)         # Equivalent to a Hann window
plot(t0, type = "l", xlab = "Samples", ylab =" Amplitude", ylim=c(0,1.2))
lines(t25, col = 2)
lines(t5, col = 3)
lines(t75, col = 4)
lines(t1, col = 5)

</code></pre>

<hr>
<h2 id='udecode'>Uniform decoder</h2><span id='topic+udecode'></span>

<h3>Description</h3>

<p>Decode <code class="reqn">2^n</code>-level quantized integer inputs to floating-point outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>udecode(u, n, v = 1, saturate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="udecode_+3A_u">u</code></td>
<td>
<p>Input, a multidimensional array of integer numbers (can be complex).</p>
</td></tr>
<tr><td><code id="udecode_+3A_n">n</code></td>
<td>
<p>Number of levels used in <code class="reqn">2^{n}</code>-level quantization. <code>n</code>
must be between 2 and 32</p>
</td></tr>
<tr><td><code id="udecode_+3A_v">v</code></td>
<td>
<p>Limit on the range of <code>u</code> to the range from <code>-v</code> to
<code>v</code> before saturating them. Default 1.</p>
</td></tr>
<tr><td><code id="udecode_+3A_saturate">saturate</code></td>
<td>
<p>Logical indicating to saturate (TRUE, default) or to wrap
(FALSE) overflows. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y &lt;- udecode(u, n)</code> inverts the operation of <code>uencode</code> and
reconstructs quantized floating-point values from an encoded multidimensional
array of integers <code>u</code>. The input argument <code>n</code> must be an integer
between 2 and 32. The integer <code>n</code> specifies that there are <code class="reqn">2^{n}</code>
quantization levels for the inputs, so that entries in <code>u</code> must be
either:
</p>

<ul>
<li><p> Signed integers in the range <code class="reqn">-2^{n}/2</code> to <code class="reqn">(2^{n}/2) - 1</code>
</p>
</li>
<li><p> Unsigned integers in the range 0 to <code class="reqn">2^{n} - 1</code>
</p>
</li></ul>

<p>Inputs can be real or complex values of any integer data type. Overflows
(entries in u outside of the ranges specified above) are saturated to the
endpoints of the range interval. The output has the same dimensions as the
input <code>u</code>. Its entries have values in the range -1 to 1.
</p>
<p><code>y &lt;- udecode(u, n, v)</code> decodes <code>u</code> such that the output has values
in the range <code>-v</code> to <code>v</code>, where the default value for <code>v</code> is
1.
</p>
<p><code>y &lt;- udecode(u, n, v, saturate)</code> decodes <code>u</code> and treats input
overflows (entries in <code>u</code> outside of the range <code>-v</code> to <code>v</code>
according to <code>saturate</code>, which can be set to one of the following:
</p>

<ul>
<li><p> TRUE (default). Saturate overflows.
</p>

<ul>
<li><p> Entries in signed inputs <code>u</code> whose values are outside of the
range <code class="reqn">-2^{n}/2</code> to <code class="reqn">(2^{n}/2) – 1</code> are assigned the value
determined by the closest endpoint of this interval.
</p>
</li>
<li><p> Entries in unsigned inputs <code>u</code> whose values are outside of
the range 0 to <code class="reqn">2^{n}-1</code> are assigned the value determined by the
closest endpoint of this interval.
</p>
</li></ul>

</li>
<li><p> FALSE Wrap all overflows according to the following:
</p>

<ul>
<li><p> Entries in signed inputs <code>u</code> whose values are outside of the
range <code class="reqn">-2^{n}/2</code> to <code class="reqn">(2^{n}/2) – 1</code> are wrapped back into that
range using modulo <code class="reqn">2^{n}</code> arithmetic (calculated using <code class="reqn">u =
      mod(u+2^{n}/2, 2^{n})-(2^{n}/2))</code>.
</p>
</li>
<li><p> Entries in unsigned inputs <code>u</code> whose values are outside of
the range 0 to <code class="reqn">2^{n}-1</code> are wrapped back into the required range
before decoding using modulo <code class="reqn">2^{n}</code> arithmetic (calculated using
<code class="reqn">u = mod(u,2^{n}))</code>.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>Multidimensional array of the same size as <code>u</code> containing
floating point numbers.
</p>


<h3>Note</h3>

<p>The real and imaginary components of complex inputs are decoded
independently.
</p>


<h3>Author(s)</h3>

<p>Georgios Ouzounis, <a href="mailto:ouzounis_georgios@hotmail.com">ouzounis_georgios@hotmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
u &lt;- c(-1, 1, 2, -5)
ysat &lt;- udecode(u, 3)

# Notice the last entry in u saturates to 1, the default peak input
# magnitude. Change the peak input magnitude to 6.
ysatv &lt;- udecode(u, 3, 6)

# The last input entry still saturates. Wrap the overflows.
ywrap = udecode(u, 3, 6, FALSE)

# Add more quantization levels.
yprec &lt;- udecode(u, 5)

</code></pre>

<hr>
<h2 id='uencode'>Uniform encoder</h2><span id='topic+uencode'></span>

<h3>Description</h3>

<p>Quantize and encode floating-point inputs to integer outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uencode(u, n, v = 1, signed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uencode_+3A_u">u</code></td>
<td>
<p>Input, a multidimensional array of numbers, real or complex, single
or double precision.</p>
</td></tr>
<tr><td><code id="uencode_+3A_n">n</code></td>
<td>
<p>Number of levels used in <code class="reqn">2^{n}</code>-level quantization. <code>n</code>
must be between 2 and 32</p>
</td></tr>
<tr><td><code id="uencode_+3A_v">v</code></td>
<td>
<p>Limit on the range of <code>u</code> to the range from <code>-v</code> to
<code>v</code> before saturating them. Default 1.</p>
</td></tr>
<tr><td><code id="uencode_+3A_signed">signed</code></td>
<td>
<p>Logical indicating signed or unsigned output. See Details.
Default: FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y &lt;- uencode(u, n)</code> quantizes the entries in a multidimensional array
of floating-point numbers <code>u</code> and encodes them as integers using
<code class="reqn">2^{n}</code>-level quantization. <code>n</code> must be an integer between 2 and 32
(inclusive). Inputs can be real or complex, double- or single-precision. The
output <code>y</code> and the input <code>u</code> are arrays of the same size. The
elements of the output <code>y</code> are unsigned integers with magnitudes in the
range 0 to  <code class="reqn">2^{n} - 1</code>. Elements of the input <code>u</code> outside of the
range -1 to 1 are treated as overflows and are saturated.
</p>

<ul>
<li><p> For entries in the input u that are less than -1, the value of the
output of uencode is 0.
</p>
</li>
<li><p> For entries in the input u that are greater than 1, the value of the
output of uencode is <code class="reqn">2^{n}-1</code>.
</p>
</li></ul>

<p><code>y &lt;- uencode(u, n, v)</code> allows the input <code>u</code> to have entries with
floating-point values in the range <code>-v</code> to <code>v</code> before saturating
them (the default value for <code>v</code> is 1). Elements of the input <code>u</code>
outside of the range <code>-v</code> to <code>v</code> are treated as overflows and are
saturated:
</p>

<ul>
<li><p> For input entries less than <code>-v</code>, the value of the output of
uencode is 0.
</p>
</li>
<li><p> For input entries greater than <code>v</code>, the value of the output of
uencode is <code class="reqn">2^{n} - 1</code>.
</p>
</li></ul>

<p><code>y &lt;- uencode(u, n, v, signed)</code> maps entries in a multidimensional array
of floating-point numbers <code>u</code> whose entries have values in the range
<code>-v</code> to <code>v</code> to an integer output <code>y</code>. Input entries outside
this range are saturated. The integer type of the output depends on the
number of quantization levels <code class="reqn">2^{n}</code> and the value of <code>signed</code>,
which can be one of the following:
</p>

<ul>
<li><p> TRUE: Outputs are signed integers with magnitudes in the range
<code class="reqn">-2^{n} / 2</code> to <code class="reqn">(2^{n} / 2) - 1</code>.
</p>
</li>
<li><p> FALSE (default): Outputs are unsigned integers with magnitudes in the
range 0 to <code class="reqn">2^{n} - 1</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Multidimensional array of the same size as <code>u</code> containing signed
or unsigned integers.
</p>


<h3>Author(s)</h3>

<p>Georgios Ouzounis, <a href="mailto:ouzounis_georgios@hotmail.com">ouzounis_georgios@hotmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
u &lt;- seq(-1, 1, 0.01)
y &lt;- uencode(u, 3)
plot(u, y)

</code></pre>

<hr>
<h2 id='ultrwin'>Ultraspherical window</h2><span id='topic+ultrwin'></span>

<h3>Description</h3>

<p>Return the coefficients of an ultraspherical window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ultrwin(n, mu = 3, xmu = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ultrwin_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="ultrwin_+3A_mu">mu</code></td>
<td>
<p>parameter that controls the side-lobe roll-off ratio. Default: 3.</p>
</td></tr>
<tr><td><code id="ultrwin_+3A_xmu">xmu</code></td>
<td>
<p>parameters that provides a trade-off between the ripple ratio and
a width characteristic. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ultraspherical window, returned as a vector.
</p>


<h3>Note</h3>

<p>The Dolph-Chebyshev and Saramaki windows are special cases of the
Ultraspherical window, with mu set to 0 and 1, respectively.
</p>


<h3>Author(s)</h3>

<p>Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] Bergen, S.W.A., and Antoniou, A. Design of Ultraspherical
Window Functions with Prescribed Spectral Characteristics. EURASIP Journal
on Applied Signal Processing 2004:13, 2053–2065.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
w &lt;- ultrwin(101, 3, 1)
plot (w, type = "l", xlab = "Samples", ylab =" Amplitude")
freqz(w)

w2 &lt;- ultrwin(101, 2, 1)
f2 &lt;- freqz(w2)
w3 &lt;- ultrwin(101, 3, 1)
f3 &lt;- freqz(w3)
w4 &lt;- ultrwin(101, 4, 1)
f4 &lt;- freqz(w4)
op &lt;- par(mfrow = c(2, 1))
plot(w2, type = "l", col = "black", xlab = "", ylab = "")
lines(w3, col = "red")
lines(w4, col = "blue")
legend("topright", legend = 2:4, col = c("black", "red", "blue"), lty = 1)
plot (f2$w, 20 * log10(abs(f2$h)), type = "l", col = "black",
      xlab = "", ylab = "", ylim = c(-100, 50))
lines(f3$w, 20 * log10(abs(f3$h)), col = "red")
lines(f4$w, 20 * log10(abs(f4$h)), col = "blue")
legend("topright", legend = 2:4, col = c("black", "red", "blue"), lty = 1)
par(op)
title(main = "Effect of increasing the values of mu (xmu = 1)")

w1 &lt;- ultrwin(101, 2, 1)
f1 &lt;- freqz(w1)
w2 &lt;- ultrwin(101, 2, 1.001)
f2 &lt;- freqz(w2)
w3 &lt;- ultrwin(101, 2, 1.002)
f3 &lt;- freqz(w3)
op &lt;- par(mfrow = c(2, 1))
plot(w1, type = "l", col = "black", xlab = "", ylab = "")
lines(w2, col = "red")
lines(w3, col = "blue")
legend("topright", legend = 2:4, col = c("black", "red", "blue"), lty = 1)
plot (f1$w, 20 * log10(abs(f1$h)), type = "l", col = "black",
      xlab = "", ylab = "", ylim = c(-100, 50))
lines(f2$w, 20 * log10(abs(f2$h)), col = "red")
lines(f3$w, 20 * log10(abs(f3$h)), col = "blue")
legend("topright", legend = c(1, 1.001, 1.002),
       col = c("black", "red", "blue"), lty = 1)
par(op)
title(main = "Effect of increasing the values of xmu (mu = 2)")

</code></pre>

<hr>
<h2 id='unshiftdata'>Inverse of shiftdata</h2><span id='topic+unshiftdata'></span>

<h3>Description</h3>

<p>Reverse what has been done by <code>shiftdata()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unshiftdata(sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unshiftdata_+3A_sd">sd</code></td>
<td>
<p>A list of objects named <code>x</code>, <code>perm</code>, and <code>nshifts</code>,
as returned by <code>shiftdata()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unshiftdata</code> restores the orientation of the data that was shifted with
shiftdata. The permutation vector is given by <code>perm</code>, and <code>nshifts</code>
is the number of shifts that was returned from <code>shiftdata()</code>.
</p>
<p><code>unshiftdata</code> is meant to be used in tandem with <code>shiftdata</code>. These
functions are useful for creating functions that work along a certain
dimension, like filter, goertzel, sgolayfilt, and sosfilt. These functions
are useful for creating functions that work along a certain dimension, like
<code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+sgolayfilt">sgolayfilt</a></code>, and <code><a href="#topic+sosfilt">sosfilt</a></code>.
</p>


<h3>Value</h3>

<p>Array with the same values and dimensions as passed to a previous
call to <code>shiftdata</code>.
</p>


<h3>Author(s)</h3>

<p>Georgios Ouzounis, <a href="mailto:ouzounis_georgios@hotmail.com">ouzounis_georgios@hotmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shiftdata">shiftdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create a 3x3 magic square
x &lt;- pracma::magic(3)
## Shift the matrix x to work along the second dimension.
## The permutation vector, perm, and the number of shifts, nshifts,
## are returned along with the shifted matrix.
sd &lt;- shiftdata(x, 2)

## Shift the matrix back to its original shape.
y &lt;- unshiftdata(sd)

## Rearrange Array to Operate on First Nonsingleton Dimension
x &lt;- 1:5
sd &lt;- shiftdata(x)
y &lt;- unshiftdata(sd)

</code></pre>

<hr>
<h2 id='unwrap'>Unwrap phase angles</h2><span id='topic+unwrap'></span>

<h3>Description</h3>

<p>Unwrap radian phases by adding or subtracting multiples of <code>2 * pi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unwrap(x, tol = pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unwrap_+3A_x">x</code></td>
<td>
<p>Input array, specified as a vector or a matrix. If <code>x</code> is a
matrix, unwrapping along the columns of <code>x</code> is applied.</p>
</td></tr>
<tr><td><code id="unwrap_+3A_tol">tol</code></td>
<td>
<p>Jump threshold to apply phase shift, specified as a scalar. A jump
threshold less than <code class="reqn">pi</code> has the same effect as the threshold
<code class="reqn">pi</code>. Default: </p>
<p style="text-align: center;"><code class="reqn">pi</code>
</p>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Unwrapped phase angle, returned as a vector, matrix, or
multidimensional array.
</p>


<h3>Author(s)</h3>

<p>Bill Lash.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define spiral shape.
t &lt;- seq(0, 6 * pi, length.out = 201)
x &lt;- t / pi * cos(t)
y &lt;- t / pi * sin(t)
plot(x, y, type = "l")
## find phase angle
p = atan2(y, x)
plot(t, p, type="l")
## unwrap it
q = unwrap(p)
plot(t, q, type ="l")

</code></pre>

<hr>
<h2 id='upfirdn'>Upsample, apply FIR filter, downsample</h2><span id='topic+upfirdn'></span>

<h3>Description</h3>

<p>Filter and resample a signal using polyphase interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upfirdn(x, h, p = 1, q = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upfirdn_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="upfirdn_+3A_h">h</code></td>
<td>
<p>Impulse response of the FIR filter specified as a numeric vector or
matrix. If it is a vector, then it represents one FIR filter to may be
applied to multiple signals in <code>x</code>; if it is a matrix, then each
column is a separate FIR impulse response.</p>
</td></tr>
<tr><td><code id="upfirdn_+3A_p">p</code></td>
<td>
<p>Upsampling factor, specified as a positive integer (default: 1).</p>
</td></tr>
<tr><td><code id="upfirdn_+3A_q">q</code></td>
<td>
<p>downsampling factor, specified as a positive integer (default: 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>upfirdn performs a cascade of three operations:
</p>

<ol>
<li><p> Upsample the input data in the matrix <code>x</code> by a factor of the
integer <code>p</code> (inserting zeros)
</p>
</li>
<li><p> FIR filter the upsampled signal data with the impulse response
sequence given in the vector or matrix <code>h</code>
</p>
</li>
<li><p> Downsample the result by a factor of the integer <code>q</code> (throwing
away samples)
</p>
</li></ol>

<p>The FIR filter is usually a lowpass filter, which you must design using
another function such as <code>fir1</code>.
</p>


<h3>Value</h3>

<p>output signal, returned as a vector or matrix. Each column has length
<code>ceiling(((length(x) - 1) * p + length(h)) / q)</code>.
</p>


<h3>Note</h3>

<p>This function uses a polyphase implementation, which is generally
faster than using <code>filter</code> by a factor equal to the downsampling
factor, since it only calculates the needed outputs.
</p>


<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fir1">fir1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1, 1, 1)
h &lt;- c(1, 1)

## FIR filter
y &lt;- upfirdn(x, h)

## FIR filter + upsampling
y &lt;- upfirdn(x, h, 5)

## FIR filter + downsampling
y &lt;- upfirdn(x, h, 1, 2)

## FIR filter + up/downsampling
y &lt;- upfirdn(x, h, 5, 2)

</code></pre>

<hr>
<h2 id='upsample'>Increase sample rate</h2><span id='topic+upsample'></span>

<h3>Description</h3>

<p>Upsample a signal by an integer factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upsample(x, n, phase = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upsample_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="upsample_+3A_n">n</code></td>
<td>
<p>upsampling factor, specified as a positive integer. The signal is
upsampled by inserting <code>n - 1</code> zeros between samples.</p>
</td></tr>
<tr><td><code id="upsample_+3A_phase">phase</code></td>
<td>
<p>offset, specified as a positive integer from <code>0</code> to <code>n
- 1</code>. Default: 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upsampled signal, returned as a vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+downsample">downsample</a></code>, <code><a href="#topic+interp">interp</a></code>,
<code><a href="#topic+decimate">decimate</a></code>, <code><a href="#topic+resample">resample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq_len(4)
u &lt;- upsample(x, 3)
u &lt;- upsample(x, 3, 2)

x &lt;- matrix(seq_len(6), 3, byrow = TRUE)
u &lt;- upsample(x, 3)

</code></pre>

<hr>
<h2 id='upsamplefill'>Upsample and Fill</h2><span id='topic+upsamplefill'></span>

<h3>Description</h3>

<p>Upsample and fill with given values or copies of the vector elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upsamplefill(x, v, copy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upsamplefill_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td></tr>
<tr><td><code id="upsamplefill_+3A_v">v</code></td>
<td>
<p>vector of values to be placed between the elements of <code>x</code>.</p>
</td></tr>
<tr><td><code id="upsamplefill_+3A_copy">copy</code></td>
<td>
<p>logical. If TRUE then <code>v</code> should be a scalar
(<code>length(v) == 1)</code> and each value in <code>x</code> are repeated <code>v</code>
times. If FALSE (default), the values in the vector <code>v</code> are placed
between the elements of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>upsampled vector or matrix
</p>


<h3>Author(s)</h3>

<p>Juan Pablo Carbajal, <a href="mailto:carbajal@ifi.uzh.ch">carbajal@ifi.uzh.ch</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+upsample">upsample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- upsamplefill(diag(2), 2, TRUE)
u &lt;- upsamplefill(diag(2), rep(-1, 3))

</code></pre>

<hr>
<h2 id='wconv'>1-D or 2-D convolution</h2><span id='topic+wconv'></span>

<h3>Description</h3>

<p>Compute the one- or two-dimensional convolution of two vectors or matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wconv(
  type = c("1d", "2d", "row", "column"),
  a,
  b,
  shape = c("full", "same", "valid")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wconv_+3A_type">type</code></td>
<td>
<p>Numeric or character, specifies the type of convolution to
perform:
</p>

<dl>
<dt>&quot;1d&quot;</dt><dd><p>For <code>a</code> and <code>b</code> as (coerced to) vectors,
perform 1-D convolution of <code>a</code> and <code>b</code>;</p>
</dd>
<dt>&quot;2d</dt><dd><p>For <code>a</code> and <code>b</code> as (coerced to)
matrices, perform 2-D convolution of <code>a</code> and <code>b</code>;</p>
</dd>
<dt>&quot;row&quot;</dt><dd><p>For <code>a</code> as (coerced to) a matrix, and <code>b</code>
(coerced to) a vector, perform the 1-D convolution of the rows of <code>a</code>
and <code>b</code>;</p>
</dd>
<dt>&quot;column&quot;</dt><dd><p>For <code>a</code> as (coerced to) a matrix, and <code>b</code>
(coerced to) a vector, perform the 1-D convolution of the colums of
<code>a</code> and <code>b</code>;</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="wconv_+3A_a">a</code>, <code id="wconv_+3A_b">b</code></td>
<td>
<p>Input vectors or matrices, coerced to numeric.</p>
</td></tr>
<tr><td><code id="wconv_+3A_shape">shape</code></td>
<td>
<p>Subsection of convolution, partially matched to:
</p>

<dl>
<dt>&quot;full&quot;</dt><dd><p>Return the full convolution (default)</p>
</dd>
<dt>&quot;same&quot;</dt><dd><p>Return the central part of the convolution with the same size
as A. The central part of the convolution begins at the indices
<code>floor(c(nrow(b), ncol(b)) / 2 + 1)</code></p>
</dd>
<dt>&quot;valid&quot;</dt><dd><p>Return only the parts which do not include zero-padded edges.
The size of the result is <code>max(c(nrow(a), ncol(b)) - c(nrow(b),
  ncol(b)) + 1, 0)</code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Convolution of input matrices, returned as a matrix or a vector.
</p>


<h3>Author(s)</h3>

<p>Lukas Reichlin, <a href="mailto:lukas.reichlin@gmail.com">lukas.reichlin@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conv">conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(1:16, 4, 4)
b &lt;- matrix(1:9, 3,3)
w &lt;- wconv('2', a, b)
w &lt;- wconv('1', a, b, 'same')
w &lt;- wconv('r', a, b)
w &lt;- wconv('r', a, c(0,1), 'same')
w &lt;- wconv('c', a, c(0,1), 'valid')

</code></pre>

<hr>
<h2 id='welchwin'>Welch window</h2><span id='topic+welchwin'></span>

<h3>Description</h3>

<p>Return the filter coefficients of a Welch window of length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>welchwin(n, method = c("symmetric", "periodic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="welchwin_+3A_n">n</code></td>
<td>
<p>Window length, specified as a positive integer.</p>
</td></tr>
<tr><td><code id="welchwin_+3A_method">method</code></td>
<td>
<p>Character string. Window sampling method, specified as:
</p>

<dl>
<dt>&quot;symmetric&quot;</dt><dd><p>(Default). Use this option when using windows for filter
design.</p>
</dd>
<dt>&quot;periodic&quot;</dt><dd><p>This option is useful for spectral analysis because it
enables a windowed signal to have the perfect periodic extension implicit
in the discrete Fourier transform. When 'periodic' is specified, the
function computes a window of length <code>n + 1</code> and returns the first
<code>n</code> points.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The Welch window is a polynomial window consisting of a single parabolic
section:
</p>
<p style="text-align: center;"><code class="reqn">w(k) = 1 - (k / N - 1)^2, n=0,1, ... n-1</code>
</p>
<p>.
The optional argument specifies a &quot;symmetric&quot; window (the default) or a
&quot;periodic&quot; window. A symmetric window has zero at each end and maximum in the
middle, and the length must be an integer greater than 2. The variable
<code>N</code> in the formula above is <code>(n-1)/2</code>. A periodic window wraps
around the cyclic interval <code>0,1, ... m-1</code>, and is intended for use
with the DFT. The length must be an integer greater than 1. The variable
<code>N</code> in the formula above is <code>n/2</code>.
</p>


<h3>Value</h3>

<p>Welch window, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Muthiah Annamalai, <a href="mailto:muthiah.annamalai@uta.edu">muthiah.annamalai@uta.edu</a>,<br />
Mike Gross, <a href="mailto:mike@appl-tech.com">mike@appl-tech.com</a>,<br />
Peter V. Lanspeary, <a href="mailto:pvl@mecheng.adelaide.edu.au">pvl@mecheng.adelaide.edu.au</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
w &lt;- welchwin(64)
plot (w, type = "l", xlab = "Samples", ylab =" Amplitude")

ws = welchwin(64,'symmetric')
wp = welchwin(63,'periodic')
plot (ws, type = "l", xlab = "Samples", ylab =" Amplitude")
lines(wp, col="red")

</code></pre>

<hr>
<h2 id='wkeep'>Keep part of vector or matrix</h2><span id='topic+wkeep'></span>

<h3>Description</h3>

<p>Extract elements from a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkeep(x, l, opt = "centered")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkeep_+3A_x">x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="wkeep_+3A_l">l</code></td>
<td>
<p>either a positive integer value, specifying the length to extract
from the input *vector* <code>x</code>, or a vector of length 2, indicating the
submatrix to extract from the *matrix* <code>x</code>. See the examples.</p>
</td></tr>
<tr><td><code id="wkeep_+3A_opt">opt</code></td>
<td>
<p>One of:
</p>

<dl>
<dt>character string</dt><dd><p>matched against <code>c("centered", "left",
  "right")</code>, indicating the location of the *vector* <code>x</code> to extract</p>
</dd>
<dt>positive integer</dt><dd><p>starting index of the input *vector* <code>x</code></p>
</dd>
<dt>two-element vector</dt><dd><p>starting row and columns from the *matrix*
<code>x</code></p>
</dd>
</dl>

<p>See the examples. Default: &quot;centered&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>extracted vector or matrix
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a vector
x &lt;- 1:10
## Extract a vector of length 6 from the central part of x.
y &lt;- wkeep(x, 6, 'c')

## Extract two vectors of length 6, one from the left part of x, and the
## other from the right part of x.
y &lt;- wkeep(x, 6, 'l')
y &lt;- wkeep(x, 6, 'r')

## Create a 5-by-5 matrix.
x &lt;- matrix(round(runif(25, 0, 25)), 5, 5)

## Extract a 3-by-2 matrix from the center of x
y &lt;- wkeep(x, c(3, 2))

## Extract from x the 2-by-4 submatrix starting at x[3, 1].
y &lt;- wkeep(x, c(2, 4), c(3, 1))

</code></pre>

<hr>
<h2 id='xcorr'>Cross-correlation</h2><span id='topic+xcorr'></span>

<h3>Description</h3>

<p>Estimate the cross-correlation between two sequences or the autocorrelation
of a single sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xcorr(
  x,
  y = NULL,
  maxlag = if (is.matrix(x)) nrow(x) - 1 else max(length(x), length(y)) - 1,
  scale = c("none", "biased", "unbiased", "coeff")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xcorr_+3A_x">x</code></td>
<td>
<p>Input, numeric or complex vector or matrix. Must not be missing.</p>
</td></tr>
<tr><td><code id="xcorr_+3A_y">y</code></td>
<td>
<p>Input, numeric or complex vector data.  If <code>x</code> is a matrix (not
a vector), <code>y</code> must be omitted. <code>y</code> may be omitted if <code>x</code> is
a vector; in this case <code>xcorr</code> estimates the autocorrelation of
<code>x</code>.</p>
</td></tr>
<tr><td><code id="xcorr_+3A_maxlag">maxlag</code></td>
<td>
<p>Integer scalar. Maximum correlation lag. If omitted, the
default value is <code>N-1</code>, where <code>N</code> is the greater of the lengths
of <code>x</code> and <code>y</code> or, if <code>x</code> is a matrix, the number of rows in
<code>x</code>.</p>
</td></tr>
<tr><td><code id="xcorr_+3A_scale">scale</code></td>
<td>
<p>Character string. Specifies the type of scaling applied to the
correlation vector (or matrix). matched to one of:
</p>

<dl>
<dt>&quot;none&quot;</dt><dd><p>return the unscaled correlation, R</p>
</dd>
<dt>&quot;biased&quot;</dt><dd><p>return the biased average, R / N</p>
</dd>
<dt>&quot;unbiased&quot;</dt><dd><p>return the unbiased average, R(k) / (N - |k|)</p>
</dd>
<dt>&quot;coeff&quot;</dt><dd><p>return the correlation coefficient, R / (rms(x) .
rms(y))</p>
</dd></dl>
<p>, where <code>k</code> is the lag, and <code>N</code> is the length of
<code>x</code>

If omitted, the default value is <code>"none"</code>. If <code>y</code> is supplied but
does not have the same length as <code>x</code>, scale must be <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate the cross correlation R_xy(k) of vector arguments <code>x</code> and
<code>y</code> or, if <code>y</code> is omitted, estimate autocorrelation R_xx(k) of
vector <code>x</code>, for a range of lags <code>k</code> specified by the argument
<code>maxlag</code>. If <code>x</code> is a matrix, each column of <code>x</code> is correlated
with itself and every other column.
</p>
<p>The cross-correlation estimate between vectors <code>x</code> and <code>y</code> (of
length <code>N</code>) for lag <code>k</code> is given by

</p>
<pre>
            N
     Rxy = SUM x(i+k) . Conj(y(i))
           i=1
</pre>
<p>where data not provided (for example <code>x[-1], y[N+1]</code>) is zero. Note the
definition of cross-correlation given above. To compute a cross-correlation
consistent with the field of statistics, see xcov.
</p>
<p>The cross-correlation estimate is calculated by a &quot;spectral&quot; method
in which the FFT of the first vector is multiplied element-by-element
with the FFT of second vector.  The computational effort depends on
the length N of the vectors and is independent of the number of lags
requested.  If you only need a few lags, the &quot;direct sum&quot; method may
be faster.
</p>


<h3>Value</h3>

<p>A list containing the following variables:
</p>

<dl>
<dt>R</dt><dd><p>array of correlation estimates</p>
</dd>
<dt>lags</dt><dd><p>vector of correlation lags <code>[-maxlag:maxlag]</code></p>
</dd>
</dl>

<p>The array of correlation estimates has one of the following forms:
</p>

<ol>
<li><p> Cross-correlation estimate if X and Y are vectors.
</p>
</li>
<li><p> Autocorrelation estimate if is a vector and Y is omitted.
</p>
</li>
<li><p> If <code>x</code> is a matrix, <code>R</code> is a matrix containing the
cross-correlation estimate of each column with every other column. Lag
varies with the first index so that <code>R</code> has <code>2 * maxlag + 1</code> rows
and <code class="reqn">P^2</code> columns where <code>P</code> is the number of columns in <code>x</code>.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Asbjorn Sabo, <a href="mailto:asbjorn.sabo@broadpark.no">asbjorn.sabo@broadpark.no</a>,<br />
Peter Lanspeary. <a href="mailto:peter.lanspeary@adelaide.edu.au">peter.lanspeary@adelaide.edu.au</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xcov">xcov</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a vector x and a vector y that is equal to x shifted by 5
## elements to the right. Compute and plot the estimated cross-correlation
## of x and y. The largest spike occurs at the lag value when the elements
## of x and y match exactly (-5).
n &lt;- 0:15
x &lt;- 0.84^n
y &lt;- pracma::circshift(x, 5)
rl &lt;- xcorr(x, y)
plot(rl$lag, rl$R, type="h")

## Compute and plot the estimated autocorrelation of a vector x.
## The largest spike occurs at zero lag, when x matches itself exactly.
n &lt;- 0:15
x &lt;- 0.84^n
rl &lt;- xcorr(x)
plot(rl$lag, rl$R, type="h")

## Compute and plot the normalized cross-correlation of vectors
## x and y with unity peak, and specify a maximum lag of 10.
n &lt;- 0:15
x &lt;- 0.84^n
y &lt;- pracma::circshift(x, 5)
rl &lt;- xcorr(x, y, 10, 'coeff')
plot(rl$lag, rl$R, type="h")

</code></pre>

<hr>
<h2 id='xcorr2'>2-D cross-correlation</h2><span id='topic+xcorr2'></span>

<h3>Description</h3>

<p>Compute the 2D cross-correlation of matrices <code>a</code> and <code>b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xcorr2(a, b = a, scale = c("none", "biased", "unbiased", "coeff"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xcorr2_+3A_a">a</code></td>
<td>
<p>Input matrix, coerced to numeric. Must not be missing.</p>
</td></tr>
<tr><td><code id="xcorr2_+3A_b">b</code></td>
<td>
<p>Input matrix, coerced to numeric. Default: <code>a</code>.</p>
</td></tr>
<tr><td><code id="xcorr2_+3A_scale">scale</code></td>
<td>
<p>Character string. Specifies the type of scaling applied to the
correlation matrix. matched to one of:
</p>

<dl>
<dt>&quot;none&quot;</dt><dd><p>no scaling</p>
</dd>
<dt>&quot;biased&quot;</dt><dd><p>Scales the raw cross-correlation by the maximum number of
elements of <code>a</code> and <code>b</code> involved in the generation of any
element of the output matrix.</p>
</dd>
<dt>&quot;unbiased&quot;</dt><dd><p>Scales the raw correlation by dividing each element in
the cross-correlation matrix by the number of products <code>a</code> and
<code>b</code> used to generate that element. </p>
</dd>
<dt>&quot;coeff&quot;</dt><dd><p>Scales the normalized cross-correlation on the range of [0
1] so that a value of 1 corresponds to a correlation coefficient of 1. </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>b</code> is not specified, computes autocorrelation of <code>a</code>,
i.e., same as <code>xcorr2 (a, a)</code>.
</p>


<h3>Value</h3>

<p>2-D cross-correlation or autocorrelation matrix, returned as a matrix
</p>


<h3>Author(s)</h3>

<p>Dave Cogdell, <a href="mailto:cogdelld@asme.org">cogdelld@asme.org</a>,<br />
Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Carne Draug, <a href="mailto:carandraug+dev@gmail.com">carandraug+dev@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conv2">conv2</a></code>, <code><a href="#topic+xcorr">xcorr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- matrix(c(17, 24,  1,  8, 15,
               23,  5,  7, 14, 16,
                4,  6, 13, 20, 22,
               10, 12, 19, 21,  3,
               11, 18, 25,  2,  9), 5, 5, byrow = TRUE)
m2 &lt;- matrix(c(8, 1, 6,
               3, 5, 7,
               4, 9, 2), 3, 3, byrow = TRUE)
R &lt;- xcorr2(m1, m2)

</code></pre>

<hr>
<h2 id='xcov'>Cross-covariance</h2><span id='topic+xcov'></span>

<h3>Description</h3>

<p>Compute covariance at various lags (= correlation(x-mean(x), y-mean(y))).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xcov(
  x,
  y = NULL,
  maxlag = if (is.matrix(x)) nrow(x) - 1 else max(length(x), length(y)) - 1,
  scale = c("none", "biased", "unbiased", "coeff")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xcov_+3A_x">x</code></td>
<td>
<p>Input, numeric or complex vector or matrix. Must not be missing.</p>
</td></tr>
<tr><td><code id="xcov_+3A_y">y</code></td>
<td>
<p>Input, numeric or complex vector data.  If <code>x</code> is a matrix (not
a vector), <code>y</code> must be omitted. <code>y</code> may be omitted if <code>x</code> is
a vector; in this case <code>xcov</code> estimates the autocovariance of
<code>x</code>.</p>
</td></tr>
<tr><td><code id="xcov_+3A_maxlag">maxlag</code></td>
<td>
<p>Integer scalar. Maximum covariance lag. If omitted, the
default value is <code>N-1</code>, where <code>N</code> is the greater of the lengths
of <code>x</code> and <code>y</code> or, if <code>x</code> is a matrix, the number of rows in
<code>x</code>.</p>
</td></tr>
<tr><td><code id="xcov_+3A_scale">scale</code></td>
<td>
<p>Character string. Specifies the type of scaling applied to the
covariation vector (or matrix). matched to one of:
</p>

<dl>
<dt>&quot;none&quot;</dt><dd><p>return the unscaled covariance, C</p>
</dd>
<dt>&quot;biased&quot;</dt><dd><p>return the biased average, C/N</p>
</dd>
<dt>&quot;unbiased&quot;</dt><dd><p>return the unbiased average, C(k)/(N-|k|)</p>
</dd>
<dt>&quot;coeff&quot;</dt><dd><p>return C/(covariance at lag 0)</p>
</dd></dl>
<p>,
where <code>k</code> is the lag, and <code>N</code> is the length of <code>x</code>

If omitted, the default value is <code>"none"</code>. If <code>y</code> is supplied but
does not have the same length as <code>x</code>, scale must be <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following variables:
</p>

<dl>
<dt>C</dt><dd><p>array of covariance estimates</p>
</dd>
<dt>lags</dt><dd><p>vector of covariance lags <code>[-maxlag:maxlag]</code></p>
</dd>
</dl>

<p>The array of covariance estimates has one of the following forms:
</p>

<ol>
<li><p> Cross-covariance estimate if X and Y are vectors.
</p>
</li>
<li><p> Autocovariance estimate if is a vector and Y is omitted.
</p>
</li>
<li><p> If <code>x</code> is a matrix, <code>C</code> is a matrix containing the
cross-covariance estimates of each column with every other column. Lag
varies with the first index so that <code>C</code> has <code>2 * maxlag + 1</code> rows
and <code class="reqn">P^2</code> columns where <code>P</code> is the number of columns in <code>x</code>.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xcorr">xcorr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 128
fs &lt;- 5
t &lt;- seq(0, 1, length.out = N)
x &lt;- sin(2 * pi * fs * t) + runif(N)
cl &lt;- xcov(x, maxlag = 20, scale = 'coeff')
plot (cl$lags, cl$C, type = "h", xlab = "", ylab = "")
points (cl$lags, cl$C)
abline(h = 0)

</code></pre>

<hr>
<h2 id='zerocrossing'>Zero Crossing</h2><span id='topic+zerocrossing'></span>

<h3>Description</h3>

<p>Estimate zero crossing points of waveform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zerocrossing(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zerocrossing_+3A_x">x</code></td>
<td>
<p>the x-coordinates of points in the function.</p>
</td></tr>
<tr><td><code id="zerocrossing_+3A_y">y</code></td>
<td>
<p>the y-coordinates of points in the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Zero-crossing points
</p>


<h3>Author(s)</h3>

<p>Carlo de Falco, <a href="mailto:carlo.defalco@gmail.com">carlo.defalco@gmail.com</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0, 1, length.out = 100)
y &lt;- runif(100) - 0.5
x0 &lt;- zerocrossing(x, y)
plot(x, y, type ="l", xlab = "", ylab = "")
points(x0, rep(0, length(x0)), col = "red")

</code></pre>

<hr>
<h2 id='zp2sos'>Zero-pole-gain to second-order section format</h2><span id='topic+zp2sos'></span>

<h3>Description</h3>

<p>Convert digital filter zero-pole-gain data to second-order section form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zp2sos(z, p, g = 1, order = c("down", "up"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zp2sos_+3A_z">z</code></td>
<td>
<p>complex vector of the zeros of the model (roots of <code>B(z)</code>)</p>
</td></tr>
<tr><td><code id="zp2sos_+3A_p">p</code></td>
<td>
<p>complex vector of the poles of the model (roots of <code>A(z)</code>)</p>
</td></tr>
<tr><td><code id="zp2sos_+3A_g">g</code></td>
<td>
<p>overall gain (<code>B(Inf)</code>). Default: 1</p>
</td></tr>
<tr><td><code id="zp2sos_+3A_order">order</code></td>
<td>
<p>row order, specified as:
</p>

<dl>
<dt>&quot;up&quot;</dt><dd><p>order the sections so the first row contains the poles farthest
from the unit circle.</p>
</dd>
<dt>&quot;down&quot; (Default)</dt><dd><p>order the sections so the first row of <code>sos</code>
contains the poles closest to the unit circle.</p>
</dd>
</dl>

<p>The ordering influences round-off noise and the probability of overflow.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following list elements:
</p>

<dl>
<dt>sos</dt><dd><p>Second-order section representation, specified as an nrow-by-6
matrix, whose rows contain the numerator and denominator coefficients of
the second-order sections:<br /> <code>sos &lt;- rbind(cbind(B1, A1), cbind(...),
  cbind(Bn, An))</code>, where <code>B1 &lt;- c(b0, b1, b2)</code>, and <code>A1 &lt;- c(a0,
  a1, a2)</code> for section 1, etc. The b0 entry must be nonzero for each
section.</p>
</dd>
<dt>g</dt><dd><p>Overall gain factor that effectively scales the output <code>b</code>
vector (or any one of the input <code>Bi</code> vectors).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Julius O. Smith III, <a href="mailto:jos@ccrma.stanford.edu">jos@ccrma.stanford.edu</a>.<br />
Conversion to R by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.Sos">as.Sos</a></code>, <code><a href="#topic+filter">filter</a></code>, <code><a href="#topic+sosfilt">sosfilt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zpk &lt;- tf2zp (c(1, 0, 0, 0, 0, 1), c(1, 0, 0, 0, 0, .9))
sosg &lt;- zp2sos (zpk$z, zpk$p, zpk$g)

</code></pre>

<hr>
<h2 id='zp2tf'>Zero-pole-gain to transfer function</h2><span id='topic+zp2tf'></span>

<h3>Description</h3>

<p>Convert digital filter zero-pole-gain data to transfer function form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zp2tf(z, p, g = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zp2tf_+3A_z">z</code></td>
<td>
<p>complex vector of the zeros of the model</p>
</td></tr>
<tr><td><code id="zp2tf_+3A_p">p</code></td>
<td>
<p>complex vector of the poles of the model</p>
</td></tr>
<tr><td><code id="zp2tf_+3A_g">g</code></td>
<td>
<p>overall gain. Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;Arma&quot; with the following list elements:
</p>

<dl>
<dt>b</dt><dd><p>moving average (MA) polynomial coefficients</p>
</dd>
<dt>a</dt><dd><p>autoregressive (AR) polynomial coefficients</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.Arma">as.Arma</a></code>, <code><a href="#topic+filter">filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- 1
z &lt;- c(0, 0)
p &lt;- pracma::roots(c(1, 0.01, 1))
ba &lt;- zp2tf(z, p, g)

</code></pre>

<hr>
<h2 id='Zpg'>Zero pole gain model</h2><span id='topic+Zpg'></span><span id='topic+as.Zpg'></span><span id='topic+as.Zpg.Arma'></span><span id='topic+as.Zpg.Ma'></span><span id='topic+as.Zpg.Sos'></span><span id='topic+as.Zpg.Zpg'></span>

<h3>Description</h3>

<p>Create an zero pole gain model of an ARMA filter, or convert other forms to a
Zpg model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zpg(z, p, g)

as.Zpg(x, ...)

## S3 method for class 'Arma'
as.Zpg(x, ...)

## S3 method for class 'Ma'
as.Zpg(x, ...)

## S3 method for class 'Sos'
as.Zpg(x, ...)

## S3 method for class 'Zpg'
as.Zpg(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Zpg_+3A_z">z</code></td>
<td>
<p>complex vector of the zeros of the model.</p>
</td></tr>
<tr><td><code id="Zpg_+3A_p">p</code></td>
<td>
<p>complex vector of the poles of the model.</p>
</td></tr>
<tr><td><code id="Zpg_+3A_g">g</code></td>
<td>
<p>overall gain of the model.</p>
</td></tr>
<tr><td><code id="Zpg_+3A_x">x</code></td>
<td>
<p>model to be converted.</p>
</td></tr>
<tr><td><code id="Zpg_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.Zpg</code> converts from other forms, including <code>Arma</code> and <code>Ma</code>.
</p>


<h3>Value</h3>

<p>A list of class Zpg with the following list elements:
</p>

<dl>
<dt>z</dt><dd><p>complex vector of the zeros of the model</p>
</dd>
<dt>p</dt><dd><p>complex vector of the poles of the model</p>
</dd>
<dt>g</dt><dd><p>gain of the model</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tom Short, <a href="mailto:tshort@eprisolutions.com">tshort@eprisolutions.com</a>,<br />
adapted by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+Arma">Arma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## design notch filter at pi/4 radians = 0.5/4 = 0.125 * fs
w = pi/4
# 2 poles, 2 zeros
# zeroes at r = 1
r &lt;- 1
z1 &lt;- r * exp(1i * w)
z2 &lt;- r * exp(1i * -w)
# poles at r = 0.9
r = 0.9
p1 &lt;- r * exp(1i * w)
p2 &lt;- r * exp(1i * -w)

zpg &lt;- Zpg(c(z1, z2), c(p1, p2), 1)
zplane(zpg)
freqz(zpg)

## Sharper edges: increase distance between zeros and poles
r = 0.8
p1 &lt;- r * exp(1i * w)
p2 &lt;- r * exp(1i * -w)
zpg &lt;- Zpg(c(z1, z2), c(p1, p2), 1)
zplane(zpg)
freqz(zpg)

</code></pre>

<hr>
<h2 id='zplane'>Zero-pole plot</h2><span id='topic+zplane'></span><span id='topic+zplane.Arma'></span><span id='topic+zplane.Ma'></span><span id='topic+zplane.Sos'></span><span id='topic+zplane.Zpg'></span><span id='topic+zplane.default'></span>

<h3>Description</h3>

<p>Plot the poles and zeros of a filter or model on the complex Z-plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zplane(filt, ...)

## S3 method for class 'Arma'
zplane(filt, ...)

## S3 method for class 'Ma'
zplane(filt, ...)

## S3 method for class 'Sos'
zplane(filt, ...)

## S3 method for class 'Zpg'
zplane(filt, ...)

## Default S3 method:
zplane(filt, a, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zplane_+3A_filt">filt</code></td>
<td>
<p>for the default case, the moving-average coefficients of an ARMA
model or filter. Generically, <code>filt</code> specifies an arbitrary model or
filter operation.</p>
</td></tr>
<tr><td><code id="zplane_+3A_...">...</code></td>
<td>
<p>additional arguments are passed through to plot.</p>
</td></tr>
<tr><td><code id="zplane_+3A_a">a</code></td>
<td>
<p>the autoregressive (recursive) coefficients of an ARMA filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Poles are marked with an <code>x</code>, and zeros are marked with an <code>o</code>.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Note</h3>

<p>When results of <code>zplane</code> are printed, <code>plot</code> will be called.
As with lattice plots, automatic printing does not work inside loops and
function calls, so explicit calls to print or plot are needed there.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br />
Stefan van der Walt <a href="mailto:stefan@sun.ac.za">stefan@sun.ac.za</a>,<br />
Mike Miller.<br />
Conversion to R by Tom Short,<br />
adapted by Geert van Boxtel, <a href="mailto:gjmvanboxtel@gmail.com">gjmvanboxtel@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Pole-zero_plot">https://en.wikipedia.org/wiki/Pole-zero_plot</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+freqz">freqz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## elliptic low-pass filter
elp &lt;- ellip(4, 0.5, 20, 0.4)
zplane(elp)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
