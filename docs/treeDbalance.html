<!DOCTYPE html><html><head><title>Help for package treeDbalance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {treeDbalance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all3DImbalIndices'><p>Calculation of integral-based distance- and angle-based 3D imbalance indices</p></a></li>
<li><a href='#combined3DIndex'><p>Calculation of combined 3D imbalance indices</p></a></li>
<li><a href='#example3Dtrees'><p>Examples of rooted 3D trees</p></a></li>
<li><a href='#extendPhylo'><p>Useful extensions to the phylo format</p></a></li>
<li><a href='#imbalProfile'><p>Calculation of 3D imbalance profiles</p></a></li>
<li><a href='#imbalSubdiv_A'><p>Calculation of the centroid angles</p></a></li>
<li><a href='#imbalSubdiv_mu'><p>Calculation of the centroid distances</p></a></li>
<li><a href='#makePhylo3DBalanced'><p>Turn a rooted 3D tree into one of its balanced versions</p></a></li>
<li><a href='#plotPhylo3D'><p>Plot a phylo3D object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Computation of 3D Tree Imbalance</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Mareike Fischer [aut],
  Sophie Kersting [aut, cre],
  Luise Kühn [aut],
  Jule Möller [ctr]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sophie Kersting &lt;sophie_kersting@gmx.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The main goal of the R package 'treeDbalance' is to provide
    functions for the computation of several measurements of 3D node
    imbalance and their respective 3D tree imbalance indices, as well as to
    introduce the new 'phylo3D' format for rooted 3D tree objects.
    Moreover, it encompasses an example dataset of 3D models of 63 beans 
    in 'phylo3D' format. Please note that this R package was developed 
    alongside the project described in the manuscript 'Measuring 3D tree 
    imbalance of plant models using graph-theoretical approaches' by 
    M. Fischer, S. Kersting, and L. Kühn (2023) &lt;<a href="https://doi.org/10.48550/arXiv.2307.14537">doi:10.48550/arXiv.2307.14537</a>&gt;, which 
    provides precise mathematical definitions of the measurements.  
    Furthermore, the package contains several helpful functions, for example, 
    some auxiliary functions for computing the ancestors, descendants, and 
    depths of the nodes, which ensures that the computations can be done in 
    linear time.  
    Most functions of 'treeDbalance' require as input a rooted tree in the 
    'phylo3D' format, an extended 'phylo' format (as introduced in the R package
    'ape' 1.9 in November 2006). Such a 'phylo3D' object must have at least 
    two new attributes next to those required by the 'phylo' format: 
    'node.coord', the coordinates of the nodes, as well as 'edge.weight', 
    the literal weight or volume of the edges.  
    Optional attributes are 'edge.diam', the diameter of the edges, and
    'edge.length', the length of the edges. For visualization purposes one
    can also specify 'edge.type', which ranges from normal cylinder to bud
    to leaf, as well as 'edge.color' to change the color of the edge depiction.  
    This project was supported by the joint research project DIG-IT! 
    funded by the European Social Fund (ESF), reference:
    ESF/14-BM-A55-0017/19, and the Ministry of Education, Science and
    Culture of Mecklenburg-Western Pomerania, Germany, as well as by the
    the project ArtIGROW, which is a part of the WIR!-Alliance 'ArtIFARM – 
    Artificial Intelligence in Farming' funded by the German Federal Ministry 
    of Education and Research (FKZ: 03WIR4805).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rgl</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-20 19:07:11 UTC; Maus</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 14:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='all3DImbalIndices'>Calculation of integral-based distance- and angle-based 3D imbalance indices</h2><span id='topic+all3DImbalIndices'></span><span id='topic+A_Index'></span><span id='topic+alpha_Index'></span><span id='topic+M_Index'></span><span id='topic+mu_Index'></span><span id='topic+imbalInt_e'></span><span id='topic+imbalProfile_e'></span>

<h3>Description</h3>

<p><code>all3DImbalIndices</code> - This serves as a wrapper function to calculate 
a 3D imbalance index value of a 3D tree in phylo3D format according to the 
specified imbalance measurement and weighting scheme.<br />
If problems occur with the estimation of the integrals, try to increase 
the optional parameters  <br /><code>rel.tolerance</code> and <code>max.subdiv</code>.
</p>
<p><code>A_Index</code> - Calculates the 3D imbalance index &quot;weighted integral-based 
centroid angle&quot; of a 3D tree in phylo3D format using either the 
edge weights or the edge lengths as weights.<br />
If problems occur with the estimation of the integrals, try to increase 
the optional parameters  <br /><code>rel.tolerance</code> and <code>max.subdiv</code>.
</p>
<p><code>alpha_Index</code> - Calculates the 3D imbalance index &quot;weighted 
integral-based minimal centroid angle&quot; of a 3D tree in phylo3D format using 
either the edge weights or the edge lengths as weights.<br />
If problems occur with the estimation of the integrals, try to increase 
the optional parameters  <br /><code>rel.tolerance</code> and <code>max.subdiv</code>.
</p>
<p><code>M_Index</code> - Calculates the 3D imbalance index &quot;weighted integral-based 
expanded relative centroid distance&quot; of a 3D tree in phylo3D format using 
either the edge weights or the edge lengths as weights.<br />
If problems occur with the estimation of the integrals, try to increase 
the optional parameters  <br /><code>rel.tolerance</code> and <code>max.subdiv</code>.
</p>
<p><code>mu_Int</code> - Calculates the 3D imbalance index &quot;weighted integral-based 
relative centroid distance&quot; of a 3D tree in phylo3D format using either the 
edge weights or the edge lengths as weights.<br />
If problems occur with the estimation of the integrals, try to increase 
the optional parameters  <br /><code>rel.tolerance</code> and <code>max.subdiv</code>.
</p>
<p><code>imbalInt_e</code> - Calculates the integral of the node imbalance values
over all possible subdividing nodes on an edge.
</p>
<p><code>imbalProfile_e</code> - Calculates the node imbalance values
for a given set of subdivisions of an edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all3DImbalIndices(
  tree,
  imbal_type,
  weight = "edge_weight",
  rel.tolerance = 1e-10,
  max.subdiv = 200L
)

A_Index(tree, weight = "edge_weight", rel.tolerance = 1e-10, max.subdiv = 200L)

alpha_Index(
  tree,
  weight = "edge_weight",
  rel.tolerance = 1e-10,
  max.subdiv = 200L
)

M_Index(tree, weight = "edge_weight", rel.tolerance = 1e-10, max.subdiv = 200L)

mu_Index(
  tree,
  weight = "edge_weight",
  rel.tolerance = 1e-10,
  max.subdiv = 200L
)

imbalInt_e(
  p,
  v,
  centr_v,
  centr_v_weight,
  edge_weight,
  imbal_type,
  rel.tolerance = 1e-08,
  max.subdiv = 200L
)

imbalProfile_e(xs, p, v, centr_v, centr_v_weight, edge_weight, imbal_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all3DImbalIndices_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo3D format (no special node enumeration 
required, except that nodes are numbered from 1 to |V| = the total number of
nodes). There must be at least 2 nodes, i.e., one edge. The attributes 
'node.coord' and 'edge.weight' are strictly required.</p>
</td></tr>
<tr><td><code id="all3DImbalIndices_+3A_imbal_type">imbal_type</code></td>
<td>
<p>Specifies which node imbalance measurement should be used.
Available are:<br />
&quot;A&quot;     - centroid angle<br />
&quot;alpha&quot; - minimal centroid angle<br />
&quot;M&quot;     - expanded relative centroid distance<br />
&quot;mu&quot;    - relative centroid distance</p>
</td></tr>
<tr><td><code id="all3DImbalIndices_+3A_weight">weight</code></td>
<td>
<p>Specifies how the node imbalance values should be weighted.
Available weighting methods are: <br />
&quot;edge_weight&quot; (default) -&gt; Imbalance with regards to the total edge 
weight.<br />
&quot;edge_length&quot; -&gt; Imbalance with regards to the total edge length.</p>
</td></tr>
<tr><td><code id="all3DImbalIndices_+3A_rel.tolerance">rel.tolerance</code></td>
<td>
<p>(Optional) Numeric value which specifies the relative 
tolerance which should be used for estimating the integral using 
stats::integrate. Set to 1e-10 by default (the stats::integrate default 
value is approx 3e-16).</p>
</td></tr>
<tr><td><code id="all3DImbalIndices_+3A_max.subdiv">max.subdiv</code></td>
<td>
<p>(Optional) Integer value which specifies the maximal number 
of interval subdivisions for estimating the integral using stats::integrate. 
Set to 200 by default (stats::integrate default value 100).</p>
</td></tr>
<tr><td><code id="all3DImbalIndices_+3A_p">p</code></td>
<td>
<p>Numeric vector of size 3 (3D coordinates of parent node <code class="reqn">p</code>).</p>
</td></tr>
<tr><td><code id="all3DImbalIndices_+3A_v">v</code></td>
<td>
<p>Numeric vector of size 3 (3D coordinates of node <code class="reqn">v</code>).</p>
</td></tr>
<tr><td><code id="all3DImbalIndices_+3A_centr_v">centr_v</code></td>
<td>
<p>Numeric vector of size 3 (3D coordinates of the centroid of
the pending subtree of node <code class="reqn">v</code>).</p>
</td></tr>
<tr><td><code id="all3DImbalIndices_+3A_centr_v_weight">centr_v_weight</code></td>
<td>
<p>Numeric value &gt;=0 (weight of the pending subtree of 
node <code class="reqn">v</code>).</p>
</td></tr>
<tr><td><code id="all3DImbalIndices_+3A_edge_weight">edge_weight</code></td>
<td>
<p>Numeric value &gt;=0 (weight of the edge <code class="reqn">(p,v)</code>).</p>
</td></tr>
<tr><td><code id="all3DImbalIndices_+3A_xs">xs</code></td>
<td>
<p>Numeric vector with values between 0 (included) and 1 (excluded).
Set of edge subdivisions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>all3DImbalIndices</code> Numeric value indicating the internal 3D
imbalance according to the chosen method.
</p>
<p><code>A_Index</code> Numeric value in the interval 
between 0 (included) and <code class="reqn">\pi</code> (excluded). A value near <code class="reqn">\pi</code> 
indicates a higher degree and near 0 a lower degree of asymmetry.
</p>
<p><code>alpha_Index</code> Numeric value in the interval 
between 0 (included) and <code class="reqn">\pi/2</code> (excluded). A value near <code class="reqn">\pi/2</code> 
indicates a higher degree and near 0 a lower degree of asymmetry.
</p>
<p><code>M_Index</code> Numeric value in the interval 
between 0 (included) and 1 (excluded). A value near 1 indicates a higher 
degree and near 0 a lower degree of asymmetry.
</p>
<p><code>mu_Index</code> Numeric value in the interval between 0 (included) 
and 1 (excluded). A value near 1 indicates a higher degree and near 0 a 
lower degree of asymmetry.
</p>
<p><code>imbalInt_e</code> Numeric value (0 minimal value, higher values
indicate a higher degree of asymmetry).
</p>
<p><code>imbalProfile_e</code> Numeric vector of imbalance values (0 minimal 
value, higher values indicate a higher degree of asymmetry) for the edge
subdivisions indicated by input <code>xs</code>.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- treeDbalance::extendPhylo(treeDbalance::example3Dtrees$bean09)
all3DImbalIndices(tree, imbal_type = "A", weight="edge_length")
A_Index(tree, weight="edge_weight")
alpha_Index(tree)
M_Index(tree, weight="edge_length")
mu_Index(tree, weight="edge_length")
imbalInt_e(p=c(0,0,1),v=c(0,0,0),centr_v=c(0.5,0,0),
    centr_v_weight=1,edge_weight=1,imbal_type="mu")
imbalProfile_e(xs=c(0,0.2,0.4),p=c(1,1,0),v=c(0,0,0),centr_v=c(0.5,0,0),
    centr_v_weight=1,edge_weight=1,imbal_type="A")
</code></pre>

<hr>
<h2 id='combined3DIndex'>Calculation of combined 3D imbalance indices</h2><span id='topic+combined3DIndex'></span>

<h3>Description</h3>

<p><code>combined3DIndex</code> - Calculates either the pure root imbalance value
with regard to a specified vertical axis or the combined 3D imbalance 
index value of a 3D tree in phylo3D format. 
The latter is a weighted mean of the integral-based 3D imbalance index 
value (i.e., <code>A_Index</code>, <code>alpha_Index</code>, <code>M_Index</code>, or 
<code>mu_Index</code> with edge length or edge weight based weighting) as well as 
the root imbalance value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combined3DIndex(
  tree,
  imbal_type,
  weight = "edge_weight",
  root_weight_factor = 1,
  vertical_axis = c(0, 0, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combined3DIndex_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo3D format (no special node enumeration 
required, except that nodes are numbered from 1 to |V| = the total number of
nodes). There must be at least 2 nodes, i.e., one edge. The attributes 
'node.coord' and 'edge.weight' are strictly required.</p>
</td></tr>
<tr><td><code id="combined3DIndex_+3A_imbal_type">imbal_type</code></td>
<td>
<p>Specifies which node imbalance measurement should be used.
Available are:<br />
&quot;A&quot;     - centroid angle<br />
&quot;alpha&quot; - minimal centroid angle<br />
&quot;M&quot;     - expanded relative centroid distance<br />
&quot;mu&quot;    - relative centroid distance</p>
</td></tr>
<tr><td><code id="combined3DIndex_+3A_weight">weight</code></td>
<td>
<p>Specifies how the node imbalance values should be weighted.
Available weighting methods are: <br />
&quot;edge_weight&quot; (default) -&gt; Imbalance with regards to the total edge 
weight.<br />
&quot;edge_length&quot; -&gt; Imbalance with regards to the total edge length.</p>
</td></tr>
<tr><td><code id="combined3DIndex_+3A_root_weight_factor">root_weight_factor</code></td>
<td>
<p>Numeric value &gt;0 (default 1), which specifies the
weight of the root imbalance value in the weighted mean. For example, a 
weight of 1 means that both the imbalance index value of the whole tree as 
well as the root imbalance value contribute equally, i.e., the unweighted 
mean of the two values is returned. For a larger value, the influence of 
the root imbalance value increases.<br />
If the weight is set to infinity (<code>Inf</code>), then the pure root
imbalance value is returned.</p>
</td></tr>
<tr><td><code id="combined3DIndex_+3A_vertical_axis">vertical_axis</code></td>
<td>
<p>Numeric vector of length 3 (default (0,0,1)), which
specifies the given vertical axis for the given tree model. For example,
use the default (0,0,1) for models that grow straight upwards (e.g., trees) 
and (0,0,-1) for models that grow downwards (e.g., roots). The vector (0,0,0)
is not allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>combined3DIndex</code> Numeric value in the interval between 0 
(included) and 1 (excluded). A value near 1 indicates a higher degree and 
near 0 a lower degree of asymmetry.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- treeDbalance::extendPhylo(treeDbalance::example3Dtrees$bean09)
combined3DIndex(tree, imbal_type = "A", weight = "edge_weight", 
                root_weight_factor = 2, vertical_axis = c(0,0,1))
combined3DIndex(tree, imbal_type = "A", root_weight_factor = Inf, 
                vertical_axis = c(0,0,1))
</code></pre>

<hr>
<h2 id='example3Dtrees'>Examples of rooted 3D trees</h2><span id='topic+example3Dtrees'></span>

<h3>Description</h3>

<p>Contains the 3D models of 63 beans in phylo3D format. The single models
can be accessed with their IDs, e.g. &quot;bean09&quot; for the bean with ID 9. 
Note that all IDs from 01 to 66 are available except IDs 8, 29, and 60.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example3Dtrees)
</code></pre>


<h3>Format</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example3Dtrees)
treeDbalance::example3Dtrees$bean09
</code></pre>

<hr>
<h2 id='extendPhylo'>Useful extensions to the phylo format</h2><span id='topic+extendPhylo'></span><span id='topic+getDescs'></span><span id='topic+getChildren'></span><span id='topic+getDescendants'></span><span id='topic+getAncs'></span><span id='topic+getNodeDepths'></span><span id='topic+getNodesAtDepth'></span><span id='topic+getLeaves'></span><span id='topic+getSubtrCentr'></span><span id='topic+getDistFromRoot'></span><span id='topic+getDistFromLeaf'></span><span id='topic+getIncEdgeLens'></span><span id='topic+getIncEdgeWeights'></span>

<h3>Description</h3>

<p><code>extendPhylo</code> - Extends a tree in phylo or phylo3D format, i.e., adds 
or updates several useful attributes of the tree that facilitate various
computations and allow it to be independent of a certain node enumeration.
These are: information on descendants, ancestors, and depths 
as well as on the centroids of all pending subtrees. The latter is 
only computed if the tree is in phylo3D format and as such contains the
attributes 'node.coord' and 'edge.weight'.
</p>
<p><code>getDescs</code> - Creates a matrix with two rows, the second contains 
in the <code class="reqn">i</code>-th entry the index of the first row in which the 
descendants of node <code class="reqn">i</code> start. Use the function <code>getChildren</code> 
to quickly retrieve the direct descendants of each node.
</p>
<p><code>getChildren</code> - Creates a vector containing the direct children of a 
node. If the method indicates that also edges should be returned, this 
function will also return the number (identifier) of the incoming edge of 
each child.
</p>
<p><code>getDescendants</code> - Creates a vector containing all descendants of a 
node.
</p>
<p><code>getAncs</code> - Creates a matrix that contains the parent (direct ancestor) 
of node <code class="reqn">i</code> as well as the corresponding edge number in column <code class="reqn">i</code>.
</p>
<p><code>getNodeDepths</code> - Creates a matrix with three rows:
The first contains the nodes ordered by increasing depth. The second
contains the indices at which the next depth starts in the first row, i.e.,
these first two rows are similar to the output matrix of <code>getDescs</code>.
The last row contains the depth of each node.
</p>
<p><code>getNodesAtDepth</code> - Creates a vector containing the nodes at a certain 
depth.
</p>
<p><code>getLeaves</code> - Creates a logical vector that indicates if the <code class="reqn">i</code>-th
node is a leaf.
</p>
<p><code>getSubtrCentr</code> - Calculates the centroid of each pending subtree. 
Returns a matrix containing the 3D coordinates (3 columns) where row <code class="reqn">i</code>
gives the position of the centroid of <code class="reqn">T_i</code>, the pending subtree rooted
in node <code class="reqn">i</code>.
</p>
<p><code>getDistFromRoot</code> - Creates a vector containing the length of the path 
from the node to the root, i.e., the sum of the corresponding edge lengths.
</p>
<p><code>getDistFromLeaf</code> - Creates a vector containing the length of the path 
from the node to the nearest descendant leaf, i.e., the sum of the 
corresponding edge lengths.
</p>
<p><code>getIncEdgeLens</code> - Returns the length of the incoming edge of every
node as a numeric vector.
</p>
<p><code>getIncEdgeWeights</code> - Returns the weight of the incoming edge of every
node as a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extendPhylo(tree)

getDescs(tree)

getChildren(tree, node, method = "onlyNodes")

getDescendants(tree, node)

getAncs(tree)

getNodeDepths(tree)

getNodesAtDepth(tree, depth)

getLeaves(tree)

getSubtrCentr(tree)

getDistFromRoot(tree)

getDistFromLeaf(tree)

getIncEdgeLens(tree)

getIncEdgeWeights(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extendPhylo_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo3D format (no special node enumeration 
required, except that nodes are numbered from 1 to |V| = the total number of
nodes). There must be at least 2 nodes, i.e., one edge. The attributes 
'node.coord' and 'edge.weight' are strictly required.</p>
</td></tr>
<tr><td><code id="extendPhylo_+3A_node">node</code></td>
<td>
<p>Numeric/integer value representing a node of the tree.</p>
</td></tr>
<tr><td><code id="extendPhylo_+3A_method">method</code></td>
<td>
<p>A string specifying if only descending nodes or also
descending edges should be returned. Can be one of 'onlyNodes' or 
'alsoEdges'.</p>
</td></tr>
<tr><td><code id="extendPhylo_+3A_depth">depth</code></td>
<td>
<p>An integer value representing the depth of interest in the tree.
A depth of 0 indicates the root layer, 1 the layer of its children, and so 
forth.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>extendPhylo</code> Tree in extended phylo(3D) format, 
i.e., phylo(3D) format with further attributes.
</p>
<p><code>getDescs</code> Numeric matrix with 2 rows.
</p>
<p><code>getChildren</code> Depending on the method the function either
returns an integer vector containing the direct descendants of a node
or an integer matrix with two rows, the first containing the direct
descendants and the second the corresponding incoming edges.
</p>
<p><code>getAncs</code> Integer matrix with 2 rows. The first 
row contains the direct ancestor of each node, the second row the incoming
edge of this node, i.e., the edge that leads to its ancestor.
</p>
<p><code>getNodeDepths</code> Numeric matrix with 3 rows.
</p>
<p><code>getNodesAtDepth</code> Integer/numeric vector 
containing all nodes at the desired depth.
</p>
<p><code>getLeaves</code> Creates a logical vector that indicates if the 
<code class="reqn">i</code>-th node is a leaf, TRUE for leaf and FALSE for interior node.
</p>
<p><code>getSubtrCentr</code> Numeric matrix with 2 columns.
</p>
<p><code>getDistFromRoot</code> Integer/numeric vector containing the length 
of the path from each node to the root.
</p>
<p><code>getDistFromLeaf</code> Integer/numeric vector containing the length 
of the path from each node to its nearest descendant leaf.
</p>
<p><code>getIncEdgeLens</code> Numeric vector containing the 
length of the incoming edge of each node, i.e., the length of the
edge from its direct ancestor to the node itself.
</p>
<p><code>getIncEdgeWeights</code> Numeric vector containing the 
weight of the incoming edge of each node, i.e., the weight of the
edge from its direct ancestor to the node itself.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- treeDbalance::example3Dtrees$bean09
ext_tree &lt;- extendPhylo(tree)
getDescs(tree)
getChildren(ext_tree, 3, method="alsoEdges")
getDescendants(ext_tree,3)
getAncs(tree)
getNodeDepths(tree)
getNodesAtDepth(tree,4)
getLeaves(tree)
getSubtrCentr(ext_tree)
getDistFromRoot(ext_tree)
getDistFromLeaf(ext_tree)
getIncEdgeLens(tree)
getIncEdgeWeights(tree)
</code></pre>

<hr>
<h2 id='imbalProfile'>Calculation of 3D imbalance profiles</h2><span id='topic+imbalProfile'></span>

<h3>Description</h3>

<p><code>imbalProfile</code> - Calculates the database for a 3D imbalance profile of  
a 3D tree in phylo3D format for any of the four node imbalance approaches: 
relative centroid distance, expanded relative centroid distance, centroid 
angle, or minimal centroid angle. It is also used as a basis to visualize the 
imbalance in a 3D plot, i.e., functions <code>plotImbalPhylo3D</code> and 
<code>addImbalPhylo3D</code>.<br />
The profile is computed with regards to the z-coordinate (height), path 
length to the root, and path length to the nearest descendant leaf of the 
nodes.<br />
The accuracy can be determined by defining the maximal section length
<code>max.seclen</code>, which means that an edge with length <code class="reqn">l</code> will be
subdivided ceiling(<code class="reqn">l</code>/<code>max.seclen</code>)-1 times into parts of equal 
length and all subdividing nodes will be analyzed for their node imbalance.
For example, an edge <code class="reqn">(p,v)</code> of length 3 with a maximal section length 
of 1 would be subdivided twice and would then be evaluated for three points
in total: for <code class="reqn">v</code> itself and for the two subdivisions at <code class="reqn">1/3</code> and 
<code class="reqn">2/3</code> of the edge length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imbalProfile(tree, imbal_type, max.seclen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imbalProfile_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo3D format (no special node enumeration 
required, except that nodes are numbered from 1 to |V| = the total number of
nodes). There must be at least 2 nodes, i.e., one edge. The attributes 
'node.coord' and 'edge.weight' are strictly required.</p>
</td></tr>
<tr><td><code id="imbalProfile_+3A_imbal_type">imbal_type</code></td>
<td>
<p>Specifies which node imbalance measurement should be 
used. Available are:<br />
&quot;A&quot;     - centroid angle<br />
&quot;alpha&quot; - minimal centroid angle<br />
&quot;M&quot;     - expanded relative centroid distance<br />
&quot;mu&quot;    - relative centroid distance</p>
</td></tr>
<tr><td><code id="imbalProfile_+3A_max.seclen">max.seclen</code></td>
<td>
<p>Numeric value &gt;0 that specifies the maximal section length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>imbalProfile</code> Numeric matrix with five columns. The rows each
represent the values of a single tree node or edge subdivision. The first
column contains the z-coordinate (height), the second the root path length, 
the third the (nearest) descendant leaf path length, and the fourth the 
imbalance value. The fifth column stores the number of the corresponding 
edge.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- treeDbalance::extendPhylo(treeDbalance::example3Dtrees$bean09)
imbalProfile(tree, imbal_type="mu", max.seclen=1)
</code></pre>

<hr>
<h2 id='imbalSubdiv_A'>Calculation of the centroid angles</h2><span id='topic+imbalSubdiv_A'></span><span id='topic+imbalSubdiv_alpha'></span><span id='topic+angle3dVec'></span>

<h3>Description</h3>

<p><code>imbalSubdiv_A</code> - Calculates the node imbalance value &quot;centroid
angle&quot; of a vertex which subdivides the edge <code class="reqn">(p,v)</code> at 
<code class="reqn">v+x \cdot (p-v)</code> with <code class="reqn">x \in [0,1]</code>. For example, 
we can obtain the node imbalance value of <code class="reqn">v</code> if <code class="reqn">x=0</code>, and 
<code class="reqn">x=0.5</code> would indicate a subdividing node exactly in the middle of 
<code class="reqn">v</code> and <code class="reqn">p</code>. <br />
Attention: If <code class="reqn">x=1</code>, this function will not calculate the node imbalance
value of <code class="reqn">p</code> with respect to its incoming edge but with respect to the
edge <code class="reqn">(p,v)</code> itself. This enables us to estimate the 
node imbalance integrals over the entire edge length.
</p>
<p><code>imbalSubdiv_alpha</code> - Calculates the node imbalance value &quot;minimal
centroid angle&quot; of a vertex which subdivides the edge <code class="reqn">(p,v)</code> at 
<code class="reqn">v+x \cdot (p-v)</code> with <code class="reqn">x \in [0,1]</code>. For example, 
we can obtain the node imbalance value of <code class="reqn">v</code> if <code class="reqn">x=0</code>, and 
<code class="reqn">x=0.5</code> would indicate a subdividing node exactly in the middle of 
<code class="reqn">v</code> and <code class="reqn">p</code>. <br />
Attention: If <code class="reqn">x=1</code>, this function will not calculate the node imbalance
value of <code class="reqn">p</code> with respect to its incoming edge but with respect to the
edge <code class="reqn">(p,v)</code> itself. This enables us to estimate the 
node imbalance integrals over the entire edge length.
</p>
<p><code>angle3dVec</code> - Calculates the angle in the interval <code class="reqn">[0,\pi]</code> 
between two 3D vectors <code class="reqn">a</code> and <code class="reqn">b</code>.
Note that the function returns 0 if one entry vector is <code class="reqn">(0,0,0)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imbalSubdiv_A(x, p, v, centr_v, centr_v_weight, edge_weight)

imbalSubdiv_alpha(x, p, v, centr_v, centr_v_weight, edge_weight)

angle3dVec(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imbalSubdiv_A_+3A_x">x</code></td>
<td>
<p>Numeric value <code class="reqn">\in [0,1]</code> which indicates where on the 
edge <code class="reqn">(p,v)</code> the subdivision takes place: 
<code class="reqn">v+x \cdot (p-v)</code>.</p>
</td></tr>
<tr><td><code id="imbalSubdiv_A_+3A_p">p</code></td>
<td>
<p>Numeric vector of size 3 (3D coordinates of parent node <code class="reqn">p</code>).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_A_+3A_v">v</code></td>
<td>
<p>Numeric vector of size 3 (3D coordinates of node <code class="reqn">v</code>).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_A_+3A_centr_v">centr_v</code></td>
<td>
<p>Numeric vector of size 3 (3D coordinates of the centroid of
the pending subtree of node <code class="reqn">v</code>).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_A_+3A_centr_v_weight">centr_v_weight</code></td>
<td>
<p>Numeric value &gt;=0 (weight of the pending subtree of 
node <code class="reqn">v</code>).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_A_+3A_edge_weight">edge_weight</code></td>
<td>
<p>Numeric value &gt;=0 (weight of the edge <code class="reqn">(p,v)</code>).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_A_+3A_a">a</code></td>
<td>
<p>Numeric vector of size 3 (e.g., 3D coordinates).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_A_+3A_b">b</code></td>
<td>
<p>Numeric vector of size 3 (e.g., 3D coordinates).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>imbalSubdiv_A</code> Numeric value <code class="reqn">\in [0,\pi]</code> (higher values
indicate a higher degree of asymmetry).
</p>
<p><code>imbalSubdiv_alpha</code> Numeric value <code class="reqn">\in [0,\pi/2]</code> 
(higher values indicate a higher degree of asymmetry).
</p>
<p><code>angle3dVec</code> Numeric value in <code class="reqn">[0,\pi]</code>.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting, Luise Kühn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imbalSubdiv_A(x=0.5,p=c(1,0,1),v=c(0,0,0),centr_v=c(0.5,0,0),
centr_v_weight=1,edge_weight=1)
imbalSubdiv_alpha(x=0.5,p=c(1,0,1),v=c(0,0,0),centr_v=c(0.5,0,0),
centr_v_weight=1,edge_weight=1)
angle3dVec(a=c(1,0,0),b=c(0,1,0)) # right angle = pi/2 = 1.5707...
</code></pre>

<hr>
<h2 id='imbalSubdiv_mu'>Calculation of the centroid distances</h2><span id='topic+imbalSubdiv_mu'></span><span id='topic+imbalSubdiv_M'></span><span id='topic+dist3dToLine'></span><span id='topic+cross3d_prod'></span>

<h3>Description</h3>

<p><code>imbalSubdiv_mu</code> - Calculates the node imbalance value &quot;relative
centroid distance&quot; of a vertex which subdivides the edge <code class="reqn">(p,v)</code> at 
<code class="reqn">v+x \cdot (p-v)</code> with <code class="reqn">x \in [0,1]</code>. For example, we 
can obtain the node imbalance value of <code class="reqn">v</code> if <code class="reqn">x=0</code>, and 
<code class="reqn">x=0.5</code> would indicate a subdividing node exactly in the middle of 
<code class="reqn">v</code> and <code class="reqn">p</code>. <br />
Attention: If <code class="reqn">x=1</code>, this function will not calculate the node imbalance
value of <code class="reqn">p</code> with respect to its own incoming edge but with respect to 
the edge <code class="reqn">(p,v)</code> itself. This enables us to estimate the 
node imbalance integrals over the entire edge length.
</p>
<p><code>imbalSubdiv_M</code> - Calculates the node imbalance value &quot;expanded
relative centroid distance&quot; of a vertex which subdivides the edge <code class="reqn">(p,v)</code> 
at <code class="reqn">v+x \cdot (p-v)</code> with <code class="reqn">x \in [0,1]</code>. For example, we 
can obtain the node imbalance value of <code class="reqn">v</code> if <code class="reqn">x=0</code>, and <code class="reqn">x=0.5</code> 
would indicate a subdividing node exactly in the middle of <code class="reqn">v</code> and 
<code class="reqn">p</code>. <br />
Attention: If <code class="reqn">x=1</code>, this function will not calculate the node imbalance
value of <code class="reqn">p</code> with respect to its own incoming edge but with respect to 
the edge <code class="reqn">(p,v)</code> itself. This enables us to estimate the 
node imbalance integrals over the entire edge length.
</p>
<p><code>dist3dToLine</code> - Calculates the distance of a <code class="reqn">point</code> 
to the infinite line between two points <code class="reqn">a</code> and <code class="reqn">b</code> in 3D space.
</p>
<p><code>cross3d_prod</code> - Calculates the cross-product of two 3D vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imbalSubdiv_mu(x, p, v, centr_v, centr_v_weight, edge_weight)

imbalSubdiv_M(x, p, v, centr_v, centr_v_weight, edge_weight)

dist3dToLine(point, a, b)

cross3d_prod(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imbalSubdiv_mu_+3A_x">x</code></td>
<td>
<p>Numeric value <code class="reqn">\in [0,1]</code> which indicates where on the 
edge <code class="reqn">(p,v)</code> the subdivision takes place: 
<code class="reqn">v+x \cdot (p-v)</code>.</p>
</td></tr>
<tr><td><code id="imbalSubdiv_mu_+3A_p">p</code></td>
<td>
<p>Numeric vector of size 3 (3D coordinates of parent node <code class="reqn">p</code>).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_mu_+3A_v">v</code></td>
<td>
<p>Numeric vector of size 3 (3D coordinates of node <code class="reqn">v</code>).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_mu_+3A_centr_v">centr_v</code></td>
<td>
<p>Numeric vector of size 3 (3D coordinates of the centroid of
the pending subtree of node <code class="reqn">v</code>).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_mu_+3A_centr_v_weight">centr_v_weight</code></td>
<td>
<p>Numeric value &gt;=0 (weight of the pending subtree of 
node <code class="reqn">v</code>).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_mu_+3A_edge_weight">edge_weight</code></td>
<td>
<p>Numeric value &gt;=0 (weight of the edge <code class="reqn">(p,v)</code>).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_mu_+3A_point">point</code></td>
<td>
<p>Numeric vector of size 3 (e.g. 3D coordinates).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_mu_+3A_a">a</code></td>
<td>
<p>Numeric vector of size 3 (e.g. 3D coordinates).</p>
</td></tr>
<tr><td><code id="imbalSubdiv_mu_+3A_b">b</code></td>
<td>
<p>Numeric vector of size 3 (e.g. 3D coordinates).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>imbalSubdiv_mu</code> Numeric value <code class="reqn">\in [0,1]</code> (higher values
indicate a higher degree of asymmetry).
</p>
<p><code>imbalSubdiv_M</code> Numeric value <code class="reqn">\in [0,2]</code> (higher values
indicate a higher degree of asymmetry).
</p>
<p><code>dist3dToLine</code> Numeric value.
</p>
<p><code>cross3d_prod</code> Numeric vector of size 3.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting, Luise Kühn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imbalSubdiv_mu(x=0.5,p=c(1,0,1),v=c(0,0,0),centr_v=c(0.5,0,0),
centr_v_weight=1,edge_weight=1)
imbalSubdiv_M(x=0.5,p=c(1,0,1),v=c(0,0,0),centr_v=c(0.5,0,0),
centr_v_weight=1,edge_weight=1)
dist3dToLine(point=c(1,1,1),a=c(0,0,0),b=c(1,2,2)) # 0.47140...
cross3d_prod(a=c(1,-1,1),b=c(1,2,2)) # c(-4, -1, 3)
</code></pre>

<hr>
<h2 id='makePhylo3DBalanced'>Turn a rooted 3D tree into one of its balanced versions</h2><span id='topic+makePhylo3DBalanced'></span><span id='topic+rotate3dVec'></span>

<h3>Description</h3>

<p><code>makePhylo3DBalanced</code> - Creates a balanced version of a rooted 3D tree
in phylo3D format. From the leaves of lowest depth to the root, each node
is turned into a balanced node by rotating its pending subtree such that
it is in line with its incoming edge. The edge and subtree lengths and 
weights as well as the angles between the outgoing edges of a single node 
(the sister edges) are left intact. <br />
Note that this function yields only one of many possible balanced 
version of the given rooted 3D tree (most often the minimal tree under the 
aforementioned requirements is not unique).
</p>
<p><code>rotate3dVec</code> - Rotates a vector in 3D space for a given angle and 
rotation axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePhylo3DBalanced(tree)

rotate3dVec(angle, axis, vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePhylo3DBalanced_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo3D format (no special node enumeration 
required, except that nodes are numbered from 1 to |V| = the total number of
nodes). There must be at least 2 nodes, i.e., one edge. The attributes 
'node.coord' and 'edge.weight' are strictly required.</p>
</td></tr>
<tr><td><code id="makePhylo3DBalanced_+3A_angle">angle</code></td>
<td>
<p>Angle for the rotation.</p>
</td></tr>
<tr><td><code id="makePhylo3DBalanced_+3A_axis">axis</code></td>
<td>
<p>Rotation axis.</p>
</td></tr>
<tr><td><code id="makePhylo3DBalanced_+3A_vec">vec</code></td>
<td>
<p>Numeric vector of size 3 (3D coordinates of the
vector that shall be rotated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>makePhylo3DBalanced</code> Tree in phylo3D format which is balanced
with regards to all four node imbalance measurements and their 
corresponding imbalance indices.
</p>
<p><code>rotate3dVec</code> Numeric vector of size 3 (3D coordinates of the
rotated vector).
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting, Luise Kühn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- treeDbalance::extendPhylo(treeDbalance::example3Dtrees$bean22)
tree_bal &lt;- makePhylo3DBalanced(tree)
rotate3dVec(angle = pi/2, axis = c(0,-1,0), vec = c(5,0,0)) # approx. (0,0,5)
round(rotate3dVec(angle = pi/2, axis = c(0,-1,0), vec = c(5,0,0)),15)
</code></pre>

<hr>
<h2 id='plotPhylo3D'>Plot a phylo3D object</h2><span id='topic+plotPhylo3D'></span><span id='topic+addPhylo3D'></span><span id='topic+plotImbalPhylo3D'></span><span id='topic+addImbalPhylo3D'></span>

<h3>Description</h3>

<p><code>plotPhylo3D</code> - Plots a phylo3D object using functions of the 
package 'rgl'.
</p>
<p><code>addPhylo3D</code> - This function plots a phylo3D object without any 
coordinate axis or adds the tree to an existing 
plot (e.g., for plotPhylo3D).
</p>
<p><code>plotImbalPhylo3D</code> - Plots a phylo3D object using functions of the 
package 'rgl'. Moreover, it uses either brightness or a color scale to
indicate the imbalance.<br />
Edge sections are shown darker or red with higher degree of imbalance and
brighter or cyan if they are balanced. 
This function does not use the parameter <code>edge.color</code><br />
Attention: Edges of type 'bud' or 'leaf' will always be depicted as 
balanced, because they should represent leaf edges that are by definition
always balanced.
</p>
<p><code>addImbalPhylo3D</code> - This function plots a phylo3D object without any 
coordinate axis or adds the tree to an existing plot (e.g., for 
<code>plotImbalPhylo3D</code>). Moreover, it uses either brightness or a color 
scale to indicate the imbalance.<br />
Edge sections are shown darker or red with higher degree of imbalance and
brighter or cyan if they are balanced. 
This function does not use the parameter <code>edge.color</code>.<br />
Attention: Edges of type 'bud' or 'leaf' will always be depicted as 
balanced because they should represent leaf edges that are always 
balanced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPhylo3D(tree, show_node_enum = FALSE)

addPhylo3D(tree, offset = c(0, 0, 0), show_node_enum = FALSE)

plotImbalPhylo3D(
  tree,
  imbal_type,
  max.seclen,
  color.imbal = TRUE,
  show.gradient = FALSE
)

addImbalPhylo3D(
  tree,
  offset = c(0, 0, 0),
  imbal_type,
  max.seclen,
  color.imbal = TRUE,
  show.gradient = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPhylo3D_+3A_tree">tree</code></td>
<td>
<p>A rooted tree in phylo3D format (no special node enumeration 
required, except that nodes are numbered from 1 to |V| = the total number of
nodes). There must be at least 2 nodes, i.e., one edge. The attributes 
'node.coord' and 'edge.weight' are strictly required.<br />
Optional: Add attribute 'edge.type' and/or 'edge.color' (character vectors 
e.g., c(&quot;d&quot;,&quot;b&quot;,&quot;l&quot;,&quot;l&quot;) and c(&quot;red&quot;,&quot;blue&quot;, &quot;red&quot;, &quot;gray30&quot;))
to the pylo3D object to plot the edges differently.<br />
The <code class="reqn">i</code>-th entry of 'edge.type' has to contain the type of the 
<code class="reqn">i</code>-th edge. The following types are available: &quot;d&quot;= default cylinder, 
&quot;b&quot; = bud, and &quot;l&quot;=leaf. If 'edge.type' is not given, every edge is by
default visualized as a cylinder.<br />
Similar for the attribute 'edge.color'. If it is not given, every edge is 
depicted as &quot;gray30&quot; by default.<br />
Furthermore, the attribute 'edge.diam' can also be added optionally to
set the edge diameters. Otherwise, the edge diameters will be calculated 
based on the edge lengths and the edge weights (treated as volume).</p>
</td></tr>
<tr><td><code id="plotPhylo3D_+3A_show_node_enum">show_node_enum</code></td>
<td>
<p>A boolean value (default FALSE). If true, each node
of the visualized phylo3D object is marked with its number. This helps to
identify specific nodes and edges.</p>
</td></tr>
<tr><td><code id="plotPhylo3D_+3A_offset">offset</code></td>
<td>
<p>Numeric vector of length 3, contains 3D coordinates by which 
the phylo object should be shifted (default = c(0,0,0), i.e., no shift).</p>
</td></tr>
<tr><td><code id="plotPhylo3D_+3A_imbal_type">imbal_type</code></td>
<td>
<p>Specifies which node imbalance measurement should be used.
Available are:<br />
&quot;A&quot;     - centroid angle<br />
&quot;alpha&quot; - minimal centroid angle<br />
&quot;M&quot;     - expanded relative centroid distance<br />
&quot;mu&quot;    - relative centroid distance</p>
</td></tr>
<tr><td><code id="plotPhylo3D_+3A_max.seclen">max.seclen</code></td>
<td>
<p>Numeric value &gt;0 that specifies the maximal section length.</p>
</td></tr>
<tr><td><code id="plotPhylo3D_+3A_color.imbal">color.imbal</code></td>
<td>
<p>Boolean value (default TRUE). If true, colors are 
used to depict the imbalance. Otherwise, a grayscale image is produced.</p>
</td></tr>
<tr><td><code id="plotPhylo3D_+3A_show.gradient">show.gradient</code></td>
<td>
<p>Boolean value (default FALSE). If true 
the color or grayscale gradient is depicted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plotPhylo3D</code> No return value, called for side effects 
(plotting).
</p>
<p><code>addPhylo3D</code> No return value, called for side effects 
(plotting).
</p>
<p><code>plotImbalPhylo3D</code> No return value, called for side effects 
(plotting).
</p>
<p><code>addImbalPhylo3D</code> No return value, called for side effects 
(plotting).
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- list(edge = matrix(c(1,2, 2,3), byrow = TRUE, ncol = 2),
             tip.label = "", Nnode = 2,
             node.coord = matrix(c(0,0,0, 1,2,2, 3,1,3), byrow = TRUE, 
                                 ncol = 3),
             edge.weight = c(0.5, 0.25), edge.type = c("d","l"))
class(tree) &lt;- "phylo3D"
# Alternatively try: tree &lt;- treeDbalance::example3Dtrees$bean09
plotPhylo3D(tree, show_node_enum = FALSE)
addPhylo3D(tree, offset = c(1,1,0)) 
plotImbalPhylo3D(tree, imbal_type="mu", max.seclen=0.5, color.imbal=TRUE,
    show.gradient=FALSE)
addImbalPhylo3D(tree, imbal_type="mu", offset = c(1,0,0), max.seclen=0.5, 
                color.imbal=FALSE, show.gradient = FALSE) 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
