<!DOCTYPE html><html><head><title>Help for package freqdom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {freqdom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#freqdom-package'><p>Frequency domain basde analysis: dynamic PCA</p></a></li>
<li><a href='#-.freqdom'><p>Frequency-wise difference of freqdom objects</p></a></li>
<li><a href='#-.timedom'><p>Time-wise difference of freqdom objects</p></a></li>
<li><a href='#%*%'><p>Frequency-wise product of freqdom objects</p></a></li>
<li><a href='#+.freqdom'><p>Frequency-wise sum of freqdom objects</p></a></li>
<li><a href='#+.timedom'><p>Time-wise sum of freqdom objects</p></a></li>
<li><a href='#cov.structure'><p>Estimate cross-covariances of two stationary multivariate time series</p></a></li>
<li><a href='#dpca'><p>Compute Dynamic Principal Components and dynamic Karhunen Loeve extepansion</p></a></li>
<li><a href='#dpca.filters'><p>Compute DPCA filter coefficients</p></a></li>
<li><a href='#dpca.KLexpansion'><p>Dynamic KL expansion</p></a></li>
<li><a href='#dpca.scores'><p>Obtain dynamic principal components scores</p></a></li>
<li><a href='#dpca.var'><p>Proportion of variance explained</p></a></li>
<li><a href='#filter.process'><p>Convolute (filter) a multivariate time series using a time-domain filter</p></a></li>
<li><a href='#fourier.inverse'><p>Coefficients of a discrete Fourier transform</p></a></li>
<li><a href='#fourier.transform'><p>Computes the Fourier transformation of a filter given as <code>timedom</code> object</p></a></li>
<li><a href='#freqdom'><p>Create an object corresponding to a frequency domain functional</p></a></li>
<li><a href='#freqdom.eigen'><p>Eigendecompose a frequency domain operator at each frequency</p></a></li>
<li><a href='#freqdom.product'><p>Compute a matrix product of two frequency-domain operators</p></a></li>
<li><a href='#freqdom.transpose'><p>Compute a transpose of a given frequency-domain operator at each frequency</p></a></li>
<li><a href='#is.freqdom'><p>Checks if an object belongs to the class freqdom</p></a></li>
<li><a href='#is.timedom'><p>Checks if an object belongs to the class timedom</p></a></li>
<li><a href='#plus.freqdom'><p>Frequency-wise sum of freqdom objects</p></a></li>
<li><a href='#print.freqdom'><p>Print freqdom object</p></a></li>
<li><a href='#print.timedom'><p>Print timedom object</p></a></li>
<li><a href='#rar'><p>Simulate a multivariate autoregressive time series</p></a></li>
<li><a href='#rev'><p>Invert order of lags or grid parameters of a <code>timedom</code> or <code>freqdom</code> object, respectively</p></a></li>
<li><a href='#rev.timedom'><p>rev Reverts order of lags in an object of class <code>timedom</code></p></a></li>
<li><a href='#rma'><p>Moving average process</p></a></li>
<li><a href='#spectral.density'><p>Compute empirical spectral density</p></a></li>
<li><a href='#summary.freqdom'><p>Print object summary</p></a></li>
<li><a href='#summary.timedom'><p>Print object summary</p></a></li>
<li><a href='#timedom'><p>Defines a linear filter</p></a></li>
<li><a href='#timedom.norms'><p>Compute operator norms of elements of a filter</p></a></li>
<li><a href='#timedom.trunc'><p>Choose lags of an object of class <code>timedom</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Frequency Domain Based Analysis: Dynamic PCA</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Hormann S., Kidzinski L.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kidzinski L. &lt;lukasz.kidzinski@stanford.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of dynamic principal component
    analysis (DPCA), simulation of VAR and VMA processes and frequency domain tools. 
    These frequency domain methods for dimensionality reduction of multivariate time series
    were introduced by David Brillinger in his book Time Series (1974). We follow implementation
    guidelines as described in Hormann, Kidzinski and Hallin (2016),
    Dynamic Functional Principal Component &lt;<a href="https://doi.org/10.1111%2Frssb.12076">doi:10.1111/rssb.12076</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0), mvtnorm, stats, graphics, base, matrixcalc,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fda, MASS, MARSS, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-06 21:40:37 UTC; kidzik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-06 22:03:00 UTC</td>
</tr>
</table>
<hr>
<h2 id='freqdom-package'>Frequency domain basde analysis: dynamic PCA</h2><span id='topic+freqdom-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Implementation of dynamic principle component analysis (DPCA),
simulation of VAR and VMA processes and frequency domain tools.
The package also provides a toolset for developers simplifying
construction of new frequency domain based methods for multivariate signals.
</p>


<h3>Details</h3>

<p><span class="pkg">freqdom</span> package allows you to manipulate time series objects
in both time and frequency domains. We implement dynamic principal component analysis methods,
enabling spectral decomposition of a stationary vector time series into uncorrelated components.
</p>
<p>Dynamic principal component analysis enables estimation of temporal filters which
transform a vector time series into another vector time series with uncorrelated components,
maximizing the long run variance explained.
There are two key differnces between classical PCA and dynamic PCA:
</p>

<ul>
<li><p> Components returned by the dynamic procedure are uncorrelated in time, i.e. for any <code class="reqn">i \neq j</code>
and <code class="reqn">l \in Z</code>, <code class="reqn">Y_i(t)</code> and <code class="reqn">Y_j(t_l)</code> are uncorrelated,
</p>
</li>
<li><p> The mapping maximizes the long run variance, which, in case of stationary vector time series, means
that the process reconstructed from and <code class="reqn">d &gt; 0</code> first dynamic principal components
better approximates your vector time series process than the first <code class="reqn">d</code> classic principal components.
</p>
</li></ul>

<p>For details, please refer to literature below and to help pages of functions <code><a href="#topic+dpca">dpca</a></code>
for estimating the components, <code><a href="#topic+dpca.scores">dpca.scores</a></code> for estimating scores and
<code><a href="#topic+dpca.KLexpansion">dpca.KLexpansion</a></code> for retrieving the signal from components.
</p>
<p>Apart from frequency domain techniques for stationary vector time series,
<span class="pkg">freqdom</span> provides a toolset of operators such as the vector Fourier Transform
(<code><a href="#topic+fourier.transform">fourier.transform</a></code>) or a vector spectral density operator
(<code><a href="#topic+spectral.density">spectral.density</a></code>) as well as simulation of vector time series
models <code><a href="#topic+rar">rar</a></code>, <code><a href="#topic+rma">rma</a></code> generating vector
autoregressive and moving average respectively.
These functions enable developing new techniques based on the Frequency domain analysis.
</p>


<h3>References</h3>

<p>Hormann Siegfried, Kidzinski Lukasz and Hallin Marc.
<em>Dynamic functional principal components.</em> Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 77.2 (2015): 319-348.
</p>
<p>Hormann Siegfried, Kidzinski Lukasz and Kokoszka Piotr.
<em>Estimation in functional lagged regression.</em>
Journal of Time Series Analysis 36.4 (2015): 541-561.
</p>
<p>Hormann Siegfried and Kidzinski Lukasz.
<em>A note on estimation in Hilbertian linear models.</em>
Scandinavian journal of statistics 42.1 (2015): 43-62.
</p>

<hr>
<h2 id='-.freqdom'>Frequency-wise difference of freqdom objects</h2><span id='topic+-.freqdom'></span>

<h3>Description</h3>

<p>Frequency-wise difference of freqdom objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freqdom'
e1 - e2
</code></pre>

<hr>
<h2 id='-.timedom'>Time-wise difference of freqdom objects</h2><span id='topic+-.timedom'></span>

<h3>Description</h3>

<p>Time-wise sum of freqdom objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'timedom'
e1 - e2
</code></pre>

<hr>
<h2 id='+25+2A+25'>Frequency-wise product of freqdom objects</h2><span id='topic++25+2A+25'></span>

<h3>Description</h3>

<p>Frequency-wise product of freqdom objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A %*% B
</code></pre>

<hr>
<h2 id='+2B.freqdom'>Frequency-wise sum of freqdom objects</h2><span id='topic++2B.freqdom'></span>

<h3>Description</h3>

<p>Frequency-wise sum of freqdom objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freqdom'
e1 + e2
</code></pre>

<hr>
<h2 id='+2B.timedom'>Time-wise sum of freqdom objects</h2><span id='topic++2B.timedom'></span>

<h3>Description</h3>

<p>Time-wise sum of freqdom objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'timedom'
e1 + e2
</code></pre>

<hr>
<h2 id='cov.structure'>Estimate cross-covariances of two stationary multivariate time series</h2><span id='topic+cov.structure'></span>

<h3>Description</h3>

<p>This function computes the empirical cross-covariance of two stationary multivariate time series.
If only one time series is provided it determines the empirical autocovariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.structure(X, Y = X, lags = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.structure_+3A_x">X</code></td>
<td>
<p>vector or matrix. If matrix, then each row corresponds to a timepoint of a vector time series.</p>
</td></tr>
<tr><td><code id="cov.structure_+3A_y">Y</code></td>
<td>
<p>vector or matrix. If matrix, then each row corresponds to a timepoint of a vector time series.</p>
</td></tr>
<tr><td><code id="cov.structure_+3A_lags">lags</code></td>
<td>
<p>an integer-valued vector <code class="reqn">(\ell_1,\ldots, \ell_K)</code> containing the lags for which covariances are calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">[X_1,\ldots, X_T]^\prime</code> be a <code class="reqn">T\times d_1</code> matrix and
<code class="reqn">[Y_1,\ldots, Y_T]^\prime</code> be a <code class="reqn">T\times d_2</code> matrix. We stack the vectors and
assume that <code class="reqn">(X_t^\prime,Y_t^\prime)^\prime</code> is a stationary multivariate time series
of dimension <code class="reqn">d_1+d_2</code>. This function determines empirical lagged covariances between
the series <code class="reqn">(X_t)</code> and <code class="reqn">(Y_t)</code>. More precisely it determines
<code class="reqn">\widehat{C}^{XY}(h)</code> for <code class="reqn">h\in</code> lags,
where <code class="reqn">\widehat{C}^{XY}(h)</code> is the empirical version of <code class="reqn">\mathrm{Cov}(X_h,Y_0)</code>.
For a sample of size <code class="reqn">T</code> we set <code class="reqn">\hat\mu^X=\frac{1}{T}\sum_{t=1}^T X_t</code> and <code class="reqn">\hat\mu^Y=\frac{1}{T}\sum_{t=1}^T Y_t</code> and
</p>
<p style="text-align: center;"><code class="reqn">\hat C^{XY}(h) = \frac{1}{T}\sum_{t=1}^{T-h} (X_{t+h} - \hat\mu^X)(Y_{t} - \hat\mu^Y)'</code>
</p>

<p>and for <code class="reqn">h &lt; 0</code>
</p>
<p style="text-align: center;"><code class="reqn">\hat C^{XY}(h) = \frac{1}{T}\sum_{t=|h|+1}^{T} (X_{t+h} - \hat\mu^X)(Y_{t} - \hat\mu^Y)'.</code>
</p>



<h3>Value</h3>

<p>An object of class <code><a href="#topic+timedom">timedom</a></code>. The list contains
</p>

<ul>
<li> <p><code>operators</code> <code class="reqn">\quad</code> an array. Element <code>[,,k]</code> contains the covariance matrix related to lag <code class="reqn">\ell_k</code>.
</p>
</li>
<li> <p><code>lags</code> <code class="reqn">\quad</code> returns the lags vector from the arguments.
</p>
</li></ul>


<hr>
<h2 id='dpca'>Compute Dynamic Principal Components and dynamic Karhunen Loeve extepansion</h2><span id='topic+dpca'></span>

<h3>Description</h3>

<p>Dynamic principal component analysis (DPCA) decomposes multivariate time series into uncorrelated components. Compared
to classical principal components, DPCA decomposition outputs components which are uncorrelated in time, allowing
simpler modeling of the processes and maximizing long run variance of the projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpca(X, q = 30, freq = (-1000:1000/1000) * pi, Ndpc = dim(X)[2])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpca_+3A_x">X</code></td>
<td>
<p>a vector time series given as a <code class="reqn">(T\times d)</code>-matix. Each row corresponds to a timepoint.</p>
</td></tr>
<tr><td><code id="dpca_+3A_q">q</code></td>
<td>
<p>window size for the kernel estimator, i.e. a positive integer.</p>
</td></tr>
<tr><td><code id="dpca_+3A_freq">freq</code></td>
<td>
<p>a vector containing frequencies in <code class="reqn">[-\pi, \pi]</code> on which the spectral density should be evaluated.</p>
</td></tr>
<tr><td><code id="dpca_+3A_ndpc">Ndpc</code></td>
<td>
<p>is the number of principal component filters to compute as in <code><a href="#topic+dpca.filters">dpca.filters</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This convenience function applies the DPCA methodology and returns filters (<code><a href="#topic+dpca.filters">dpca.filters</a></code>), scores
(<code><a href="#topic+dpca.scores">dpca.scores</a></code>), the spectral density (<code><a href="#topic+spectral.density">spectral.density</a></code>), variances (<code><a href="#topic+dpca.var">dpca.var</a></code>) and
Karhunen-Leove expansion (<code><a href="#topic+dpca.KLexpansion">dpca.KLexpansion</a></code>).
</p>
<p>See the example for understanding usage, and help pages for details on individual functions.
</p>


<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li> <p><code>scores</code> <code class="reqn">\quad</code> DPCA scores (<code><a href="#topic+dpca.scores">dpca.scores</a></code>)
</p>
</li>
<li> <p><code>filters</code> <code class="reqn">\quad</code>  DPCA filters (<code><a href="#topic+dpca.filters">dpca.filters</a></code>)
</p>
</li>
<li> <p><code>spec.density</code> <code class="reqn">\quad</code>  spectral density of <code>X</code> (<code><a href="#topic+spectral.density">spectral.density</a></code>)
</p>
</li>
<li> <p><code>var</code> <code class="reqn">\quad</code> amount of variance explained by dynamic principal components (<code><a href="#topic+dpca.var">dpca.var</a></code>)
</p>
</li>
<li> <p><code>Xhat</code> <code class="reqn">\quad</code>  Karhunen-Loeve expansion using <code>Ndpc</code> dynamic principal components (<code><a href="#topic+dpca.KLexpansion">dpca.KLexpansion</a></code>)
</p>
</li></ul>



<h3>References</h3>

<p>Hormann, S., Kidzinski, L., and Hallin, M.
<em>Dynamic functional principal components.</em> Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 77.2 (2015): 319-348.
</p>
<p>Brillinger, D.
<em>Time Series</em> (2001), SIAM, San Francisco.
</p>
<p>Shumway, R., and Stoffer, D.
<em>Time series analysis and its applications: with R examples</em> (2010), Springer Science &amp; Business Media
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = rar(100,3)

# Compute DPCA with only one component
res.dpca = dpca(X, q = 5, Ndpc = 1)

# Compute PCA with only one component
res.pca = prcomp(X, center = TRUE)
res.pca$x[,-1] = 0

# Reconstruct the data
var.dpca = (1 - sum( (res.dpca$Xhat - X)**2 ) / sum(X**2))*100
var.pca = (1 - sum( (res.pca$x %*% t(res.pca$rotation) - X)**2 ) / sum(X**2))*100

cat("Variance explained by DPCA:\t",var.dpca,"%\n")
cat("Variance explained by PCA:\t",var.pca,"%\n")
</code></pre>

<hr>
<h2 id='dpca.filters'>Compute DPCA filter coefficients</h2><span id='topic+dpca.filters'></span>

<h3>Description</h3>

<p>For a given spectral density matrix dynamic principal component filter sequences are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpca.filters(F, Ndpc = dim(F$operators)[1], q = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpca.filters_+3A_f">F</code></td>
<td>
<p><code class="reqn">(d\times d)</code> spectral density matrix, provided as an object of class <code>freqdom</code>.</p>
</td></tr>
<tr><td><code id="dpca.filters_+3A_ndpc">Ndpc</code></td>
<td>
<p>an integer <code class="reqn">\in\{1,\ldots, d\}</code>. It is the number of dynamic principal
components to be computed. By default it is set equal to <code class="reqn">d</code>.</p>
</td></tr>
<tr><td><code id="dpca.filters_+3A_q">q</code></td>
<td>
<p>a non-negative integer. DPCA filter coefficients at lags <code class="reqn">|h|\leq</code> <code>q</code> will be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dynamic principal components are linear filters <code class="reqn">(\phi_{\ell k}\colon k\in \mathbf{Z})</code>,
<code class="reqn">1 \leq \ell \leq d</code>. They are defined as the Fourier coefficients of the dynamic eigenvector
<code class="reqn">\varphi_\ell(\omega)</code> of a spectral density matrix <code class="reqn">\mathcal{F}_\omega</code>:
</p>
<p style="text-align: center;"><code class="reqn">
  \phi_{\ell k}:=\frac{1}{2\pi}\int_{-\pi}^\pi \varphi_\ell(\omega) \exp(-ik\omega) d\omega.
</code>
</p>

<p>The index <code class="reqn">\ell</code> is referring to the <code class="reqn">\ell</code>-th #'largest dynamic eigenvalue. Since the <code class="reqn">\phi_{\ell k}</code> are
real, we have </p>
<p style="text-align: center;"><code class="reqn">
\phi_{\ell k}^\prime=\phi_{\ell k}^*=\frac{1}{2\pi}\int_{-\pi}^\pi \varphi_\ell^* \exp(ik\omega)d\omega.
</code>
</p>

<p>For a given
spectral density (provided as on object of class <code>freqdom</code>) the function
<code>dpca.filters()</code> computes <code class="reqn">(\phi_{\ell k})</code> for <code class="reqn">|k| \leq</code> <code>q</code>  and <code class="reqn">1 \leq \ell \leq</code> <code>Ndpc</code>.
</p>
<p>For more details we refer to Chapter 9 in Brillinger (2001), Chapter 7.8 in Shumway and
Stoffer (2006) and to Hormann et al. (2015).
</p>


<h3>Value</h3>

<p>An object of class <code>timedom</code>.  The list has the following components:
</p>

<ul>
<li> <p><code>operators</code> <code class="reqn">\quad</code> an array. Each matrix in this array has dimension <code>Ndpc</code> <code class="reqn">\times d</code> and is
assigned to a certain lag. For a given lag <code class="reqn">k</code>, the rows of the matrix correpsond to
<code class="reqn">\phi_{\ell k}</code>.
</p>
</li>
<li> <p><code>lags</code> <code class="reqn">\quad</code> a vector with the lags of the filter coefficients.
</p>
</li></ul>



<h3>References</h3>

<p>Hormann, S., Kidzinski, L., and Hallin, M.
<em>Dynamic functional principal components.</em> Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 77.2 (2015): 319-348.
</p>
<p>Brillinger, D.
<em>Time Series</em> (2001), SIAM, San Francisco.
</p>
<p>Shumway, R.H., and Stoffer, D.S.
<em>Time Series Analysis and Its Applications</em> (2006), Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpca.var">dpca.var</a></code>, <code><a href="#topic+dpca.scores">dpca.scores</a></code>, <code><a href="#topic+dpca.KLexpansion">dpca.KLexpansion</a></code>
</p>

<hr>
<h2 id='dpca.KLexpansion'>Dynamic KL expansion</h2><span id='topic+dpca.KLexpansion'></span>

<h3>Description</h3>

<p>Computes the dynamic Karhunen-Loeve expansion of a vector time series up to a given order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpca.KLexpansion(X, dpcs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpca.KLexpansion_+3A_x">X</code></td>
<td>
<p>a vector time series given as a <code class="reqn">(T\times d)</code>-matix. Each row corresponds to a timepoint.</p>
</td></tr>
<tr><td><code id="dpca.KLexpansion_+3A_dpcs">dpcs</code></td>
<td>
<p>an object of class <code>timedom</code>, representing the dpca filters obtained from the sample X. If <code>dpsc = NULL</code>,
then <code>dpcs = dpca.filter(spectral.density(X))</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We obtain the dynamic Karhnunen-Loeve expansion of order <code class="reqn">L</code>, <code class="reqn">1\leq L\leq d</code>. It is defined as
</p>
<p style="text-align: center;"><code class="reqn">
  \sum_{\ell=1}^L\sum_{k\in\mathbf{Z}} Y_{\ell, t+k} \phi_{\ell k},
</code>
</p>

<p>where <code class="reqn">\phi_{\ell k}</code> are the dynamic PC filters as explained in  <code><a href="#topic+dpca.filters">dpca.filters</a></code> and <code class="reqn">Y_{\ell k}</code> are dynamic  scores as explained in <code><a href="#topic+dpca.scores">dpca.scores</a></code>. For the sample version the sum in <code class="reqn">k</code> extends over the range of lags for which the <code class="reqn">\phi_{\ell k}</code> are defined.
</p>
<p>For more details we refer to Chapter 9 in Brillinger (2001), Chapter 7.8 in Shumway and Stoffer (2006)
and to Hormann et al. (2015).
</p>


<h3>Value</h3>

<p>A <code class="reqn">(T\times d)</code>-matix. The <code class="reqn">\ell</code>-th column contains the <code class="reqn">\ell</code>-th data point.
</p>


<h3>References</h3>

<p>Hormann, S., Kidzinski, L., and Hallin, M.
<em>Dynamic functional principal components.</em> Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 77.2 (2015): 319-348.
</p>
<p>Brillinger, D.
<em>Time Series</em> (2001), SIAM, San Francisco.
</p>
<p>Shumway, R.H., and Stoffer, D.S.
<em>Time Series Analysis and Its Applications</em> (2006), Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpca.filters">dpca.filters</a></code>, <code><a href="#topic+filter.process">filter.process</a></code>, <code><a href="#topic+dpca.scores">dpca.scores</a></code>
</p>

<hr>
<h2 id='dpca.scores'>Obtain dynamic principal components scores</h2><span id='topic+dpca.scores'></span>

<h3>Description</h3>

<p>Computes dynamic principal component score vectors of a vector time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpca.scores(X, dpcs = dpca.filters(spectral.density(X)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpca.scores_+3A_x">X</code></td>
<td>
<p>a vector time series given as a <code class="reqn">(T\times d)</code>-matix. Each row corresponds to a timepoint.</p>
</td></tr>
<tr><td><code id="dpca.scores_+3A_dpcs">dpcs</code></td>
<td>
<p>an object of class <code>timedom</code>, representing the dpca filters obtained from the sample X. If <code>dpsc = NULL</code>, then <code>dpcs =
dpca.filter(spectral.density(X))</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">\ell</code>-th dynamic principal components score sequence is defined by
</p>
<p style="text-align: center;"><code class="reqn">
  Y_{\ell t}:=\sum_{k\in\mathbf{Z}}  \phi_{\ell k}^\prime X_{t-k},\quad 1\leq \ell\leq d,
</code>
</p>

<p>where <code class="reqn">\phi_{\ell k}</code> are the dynamic PC filters as explained in  <code><a href="#topic+dpca.filters">dpca.filters</a></code>. For the sample version the sum extends
over the range of lags for which the <code class="reqn">\phi_{\ell k}</code> are defined. The actual operation carried out is <code>filter.process(X, A = dpcs)</code>.
</p>
<p>We for more details we refer to Chapter 9 in Brillinger (2001), Chapter 7.8 in Shumway and Stoffer (2006) and to Hormann et al. (2015).
</p>


<h3>Value</h3>

<p>A <code class="reqn">T\times</code> <code>Ndpc</code>-matix with <code>Ndpc = dim(dpcs$operators)[1]</code>. The <code class="reqn">\ell</code>-th column contains the
<code class="reqn">\ell</code>-th dynamic principal component score sequence.
</p>


<h3>References</h3>

<p>Hormann, S., Kidzinski, L., and Hallin, M.
<em>Dynamic functional principal components.</em> Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 77.2 (2015): 319-348.
</p>
<p>Brillinger, D.
<em>Time Series</em> (2001), SIAM, San Francisco.
</p>
<p>Shumway, R.H., and Stoffer, D.S.
<em>Time Series Analysis and Its Applications</em> (2006), Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpca.filters">dpca.filters</a></code>, <code><a href="#topic+dpca.KLexpansion">dpca.KLexpansion</a></code>, <code><a href="#topic+dpca.var">dpca.var</a></code>
</p>

<hr>
<h2 id='dpca.var'>Proportion of variance explained</h2><span id='topic+dpca.var'></span>

<h3>Description</h3>

<p>Computes the proportion of variance explained by a given dynamic principal component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpca.var(F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpca.var_+3A_f">F</code></td>
<td>
<p><code class="reqn">(d\times d)</code> spectral density matrix, provided as an object of class <code>freqdom</code>. To guarantee accuracy of numerical integration it is important that <code>F</code><code class="reqn">\$</code><code>freq</code> is a dense grid of frequencies in <code class="reqn">[-\pi,\pi]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a spectral density matrix <code class="reqn">\mathcal{F}_\omega</code> and let <code class="reqn">\lambda_\ell(\omega)</code> by the
<code class="reqn">\ell</code>-th dynamic eigenvalue. The proportion of variance described by the <code class="reqn">\ell</code>-th dynamic
principal component is given as
</p>
<p style="text-align: center;"><code class="reqn">v_\ell:=\int_{-\pi}^\pi \lambda_\ell(\omega)d\omega/\int_{-\pi}^\pi \mathrm{tr}(\mathcal{F}_\omega)d\omega.</code>
</p>

<p>This function numerically computes the vectors <code class="reqn">(v_\ell\colon 1\leq \ell\leq d)</code>.
</p>
<p>For more details we refer to Chapter 9 in Brillinger (2001), Chapter 7.8 in Shumway and Stoffer (2006)
and to Hormann et al. (2015).
</p>


<h3>Value</h3>

<p>A <code class="reqn">d</code>-dimensional vector containing the <code class="reqn">v_\ell</code>.
</p>


<h3>References</h3>

<p>Hormann, S., Kidzinski, L., and Hallin, M.
<em>Dynamic functional principal components.</em> Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 77.2 (2015): 319-348.
</p>
<p>Brillinger, D.
<em>Time Series</em> (2001), SIAM, San Francisco.
</p>
<p>Shumway, R.H., and Stoffer, D.S.
<em>Time Series Analysis and Its Applications</em> (2006), Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpca.filters">dpca.filters</a></code>, <code><a href="#topic+dpca.KLexpansion">dpca.KLexpansion</a></code>, <code><a href="#topic+dpca.scores">dpca.scores</a></code>
</p>

<hr>
<h2 id='filter.process'>Convolute (filter) a multivariate time series using a time-domain filter</h2><span id='topic+filter.process'></span><span id='topic++25c+25'></span>

<h3>Description</h3>

<p>This function applies a linear filter to some vector time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.process(X, A)

X %c% A
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.process_+3A_x">X</code></td>
<td>
<p>vector time series given in matrix form. Each row corresponds to a timepoint.</p>
</td></tr>
<tr><td><code id="filter.process_+3A_a">A</code></td>
<td>
<p>an object of class <code><a href="#topic+timedom">timedom</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">[X_1,\ldots, X_T]^\prime</code> be a <code class="reqn">T\times d</code> matrix corresponding to a vector series <code class="reqn">X_1,\ldots,X_T</code>. This time series is transformed to the series <code class="reqn">Y_1,\ldots, Y_T</code>, where
</p>
<p style="text-align: center;"><code class="reqn"> Y_t=\sum_{k=-q}^p A_k X_{t-k},\quad t\in\{p+1,\ldots, T-q\}.</code>
</p>

<p>The index <code class="reqn">k</code> of <code class="reqn">A_k</code> is determined by the lags defined for the time domain object.
When index <code class="reqn">t-k</code> falls outside the domain <code class="reqn">\{1,\ldots, T\}</code> we set <code class="reqn">X_t=\frac{1}{T}\sum_{k=1}^T X_k</code>.
</p>


<h3>Value</h3>

<p>A matrix. Row <code class="reqn">t</code> corresponds to <code class="reqn">Y_t</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>filter.process()</code>: Multivariate convolution (filter) in the time domain
</p>
</li>
<li> <p><code>X %c% A</code>: Convenience operator for <code>filter.process</code> function
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+timedom">timedom</a></code>
</p>

<hr>
<h2 id='fourier.inverse'>Coefficients of a discrete Fourier transform</h2><span id='topic+fourier.inverse'></span>

<h3>Description</h3>

<p>Computes Fourier coefficients of some functional represented by an object of class <code>freqdom</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourier.inverse(F, lags = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourier.inverse_+3A_f">F</code></td>
<td>
<p>an object of class <code><a href="#topic+freqdom">freqdom</a></code> which is corresponding to a function with values in <code class="reqn">\mathbf{C}^{d_1\times d_2}</code>. To guarantee accuracy of inversion it is important that <code>F</code><code class="reqn">\$</code><code>freq</code> is a dense grid of frequencies in <code class="reqn">[-\pi,\pi]</code>.</p>
</td></tr>
<tr><td><code id="fourier.inverse_+3A_lags">lags</code></td>
<td>
<p>lags of the Fourier coefficients to be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a function <code class="reqn">F \colon [-\pi,\pi]\to\mathbf{C}^{d_1\times d_2}</code>. Its <code class="reqn">k</code>-th Fourier
coefficient is given as
</p>
<p style="text-align: center;"><code class="reqn">
  \frac{1}{2\pi}\int_{-\pi}^\pi F(\omega) \exp(ik\omega)d\omega.
</code>
</p>

<p>We represent the function <code class="reqn">F</code> by an object of class <code>freqdom</code> and approximate the integral via
</p>
<p style="text-align: center;"><code class="reqn">
\frac{1}{|F\$freq|}\sum_{\omega\in {F\$freq}} F(\omega) \exp(i k\omega),
</code>
</p>

<p>for <code class="reqn">k\in</code> lags.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+timedom">timedom</a></code>. The list has the following components:
</p>

<ul>
<li> <p><code>operators</code> <code class="reqn">\quad</code> an array. The <code class="reqn">k</code>-th matrix in this array corresponds to the <code class="reqn">k</code>-th Fourier coefficient.
</p>
</li>
<li> <p><code>lags</code> <code class="reqn">\quad</code> the lags of the corresponding Fourier coefficients.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fourier.transform">fourier.transform</a></code>, <code><a href="#topic+freqdom">freqdom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y = rar(100)
grid = c(pi*(1:2000) / 1000 - pi) #a dense grid on -pi, pi
fourier.inverse(spectral.density(Y, q=2, freq=grid))

# compare this to
cov.structure(Y)
</code></pre>

<hr>
<h2 id='fourier.transform'>Computes the Fourier transformation of a filter given as <code>timedom</code> object</h2><span id='topic+fourier.transform'></span>

<h3>Description</h3>

<p>Computes the frequency response function of a linear filter and returns it as a <code><a href="#topic+freqdom">freqdom</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourier.transform(A, freq = pi * -100:100/100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourier.transform_+3A_a">A</code></td>
<td>
<p>an object of class <code>timedom</code>.</p>
</td></tr>
<tr><td><code id="fourier.transform_+3A_freq">freq</code></td>
<td>
<p>a vector of frequencies <code class="reqn">\in [-\pi, \pi]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a filter (a sequence of vectors or matrices) <code class="reqn">(A_k)_{k\in A\$lags}</code>. Then this function computes
</p>
<p style="text-align: center;"><code class="reqn">\sum_{k\in A\$lags} A_k e^{-ik\omega}</code>
</p>

<p>for all frequencies <code class="reqn">\omega</code> listed in the vector <code>freq</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>freqdom</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fourier.inverse">fourier.inverse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We compute the discrete Fourier transform (DFT) of a time series X_1,..., X_T.

X = rar(100)
T=dim(X)[1]
tdX = timedom(X/sqrt(T),lags=1:T)
DFT = fourier.transform(tdX, freq= pi*-1000:1000/1000)
</code></pre>

<hr>
<h2 id='freqdom'>Create an object corresponding to a frequency domain functional</h2><span id='topic+freqdom'></span>

<h3>Description</h3>

<p>Creates an object of class  <code>freqdom</code>. This object corresponds to a functional with domain <code class="reqn">[-\pi,\pi]</code> and some complex vector space as codomain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqdom(F, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqdom_+3A_f">F</code></td>
<td>
<p>a vector, a matrix or an array. For vectors <code class="reqn">F[k], 1\leq k\leq K</code> are complex numbers. For matrices <code class="reqn">F[k,]</code> are complex vectors. For arrays the elements <code class="reqn">F[,,k]</code>, are complex valued <code class="reqn">(d_1\times d_2)</code> matrices (all of same dimension).</p>
</td></tr>
<tr><td><code id="freqdom_+3A_freq">freq</code></td>
<td>
<p>a vector of dimension <code class="reqn">K</code> containing frequencies in <code class="reqn">[-\pi,\pi]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This class is used to describe a frequency domain functional (like a spectral density matrix, a discrete Fourier transform, an impulse response function, etc.)
on selected frequencies. Formally we consider a collection <code class="reqn">[F_1,\ldots,F_K]</code> of complex-valued matrices <code class="reqn">F_k</code>, all of which have the same dimension
<code class="reqn">d_1\times d_2</code>. Moreover, we consider frequencies <code class="reqn">\{\omega_1,\ldots, \omega_K\}\subset[-\pi,\pi]</code>. The object this function creates corresponds
to the mapping <code class="reqn">f: \mathrm{freq}\to \mathbf{C}^{d_1\times d_2}</code>, where <code class="reqn">\omega_k\mapsto F_k</code>.
</p>
<p>Consider, for example, the discrete Fourier transform of a vector time series <code class="reqn">X_1,\ldots, X_T</code>:. It is defined as
</p>
<p style="text-align: center;"><code class="reqn">
  D_T(\omega)=\frac{1}{\sqrt{T}}\sum_{t=1}^T X_t e^{-it\omega},\quad \omega\in[-\pi,\pi].
</code>
</p>

<p>We may choose <code class="reqn">\omega_k=2\pi k/K-\pi</code> and <code class="reqn">F_k=D_T(\omega_k)</code>. Then, the object <code>freqdom</code> creates, is corresponding to the function which associates <code class="reqn">\omega_k</code> and <code class="reqn">D_T(\omega_k)</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+freqdom">freqdom</a></code>. An object of class  <code><a href="#topic+freqdom">freqdom</a></code> is a list containing the following components:
</p>

<ul>
<li> <p><code>operators</code> <code class="reqn">\quad</code> the array <code>F</code> as given in the argument.
</p>
</li>
<li> <p><code>freq</code> <code class="reqn">\quad</code> the vector <code>freq</code> as given in the argument.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fourier.transform">fourier.transform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i = complex(imaginary=1)
OP = array(0, c(2, 2, 3))
OP[,,1] = diag(2) * exp(i)/2
OP[,,2] = diag(2)
OP[,,3] = diag(2) * exp(-i)/2
freq = c(-pi/3, 0, pi/3)
A = freqdom(OP, freq)
</code></pre>

<hr>
<h2 id='freqdom.eigen'>Eigendecompose a frequency domain operator at each frequency</h2><span id='topic+freqdom.eigen'></span>

<h3>Description</h3>

<p>Gives the eigendecomposition of objects of class <code>freqdom</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqdom.eigen(F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqdom.eigen_+3A_f">F</code></td>
<td>
<p>an object of class freqdom. The matrices <code>F\$operator[,,k]</code> are required to be square matrices, say <code class="reqn">d \times d</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes an eigendecomposition for each of the matrices <code>F\$operator[,,k]</code>.
</p>


<h3>Value</h3>

<p>Returns a list. The list is containing the following components:
</p>

<ul>
<li> <p><code>vectors</code> <code class="reqn">\quad</code> an array containing <code class="reqn">d</code> matrices. The <code class="reqn">i</code>-th matrix contains in its <code class="reqn">k</code>-th row the conjugate transpose eigenvector belonging to the <code class="reqn">k</code>-th largest eigenvalue of <code>F\$operator[,,i]</code>.
</p>
</li>
<li> <p><code>values</code> <code class="reqn">\quad</code> matrix containing in <code class="reqn">k</code>-th column the eigenvalues of <code>F\$operator[,,k]</code>.
</p>
</li>
<li> <p><code>freq</code> <code class="reqn">\quad</code> vector of frequencies defining the object <code>F</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+freqdom">freqdom</a></code>
</p>

<hr>
<h2 id='freqdom.product'>Compute a matrix product of two frequency-domain operators</h2><span id='topic+freqdom.product'></span>

<h3>Description</h3>

<p>For given frequency-domain operators <code>F</code> and <code>G</code> (<code><a href="#topic+freqdom">freqdom</a></code>) the function <code>freqdom.kronecker</code> computes their matrix product frequency-wise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqdom.product(F, G)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqdom.product_+3A_f">F</code></td>
<td>
<p>frequency-domain filter of type <code><a href="#topic+freqdom">freqdom</a></code>, i.e. a set of linear operators <code class="reqn">F_\theta \in \mathbf{R}^{p \times q}</code> defined
on a discreet grid defined <code class="reqn">S \subset [-\pi,\pi]</code>.</p>
</td></tr>
<tr><td><code id="freqdom.product_+3A_g">G</code></td>
<td>
<p>frequency-domain filter of type <code><a href="#topic+freqdom">freqdom</a></code>, i.e. a set of linear operators <code class="reqn">G_\theta \in \mathbf{R}^{q \times r}</code> defined
on a discreet grid defined <code class="reqn">S \subset [-\pi,\pi]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">F = \{ F_\theta : \theta \in S \}</code>, <code class="reqn">G = \{ G_\theta : \theta \in S \}</code>,
where <code class="reqn">S</code> is a finite grid of frequencies in <code class="reqn">[-\pi,\pi]</code>, <code class="reqn">F_\theta \in \mathbf{C}^{p \times q}</code>
and <code class="reqn">G_\theta \in \mathbf{C}^{q \times r}</code>.
</p>
<p>We define </p>
<p style="text-align: center;"><code class="reqn">H_\theta = F_\theta G_\theta</code>
</p>
<p> as a matrix product of <code class="reqn">F_\theta</code> and <code class="reqn">G_\theta</code>, i.e. <code class="reqn">H_\theta \in \mathbf{R}^{p\times r}</code>.
Function <code>freqdom.product</code> returns <code class="reqn">H = \{ H_\theta : \theta \in S \}</code>.
</p>


<h3>Value</h3>

<p>Function returns a frequency domain object (<code><a href="#topic+freqdom">freqdom</a></code>) of dimensions <code class="reqn">L \times p \times r</code>, where <code class="reqn">L</code> is the
size of the evaluation grid. The elements correspond to <code class="reqn">F_\theta * G_\theta</code> defined above.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>freqdom.product()</code>: Frequency-wise matrix product of two frequency-domain operators
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>n = 100
X = rar(n)
Y = rar(n)
SX = spectral.density(X)
SY = spectral.density(Y)
R = freqdom.product(SY,SX)
</code></pre>

<hr>
<h2 id='freqdom.transpose'>Compute a transpose of a given frequency-domain operator at each frequency</h2><span id='topic+freqdom.transpose'></span>

<h3>Description</h3>

<p>For a given frequency-domain operator <code>S</code> (<code><a href="#topic+freqdom">freqdom</a></code>) the function <code>freqdom.transpose</code> computes the transpose of <code class="reqn">S_\theta'</code> at
each frequency from the evaluation grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqdom.transpose(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqdom.transpose_+3A_x">x</code></td>
<td>
<p>a frequency-domain filter of type <code><a href="#topic+freqdom">freqdom</a></code>, i.e. a set of linear operators <code class="reqn">S_k \in \mathbf{R}^{p_1 \times p_2}</code>
on some discreet grid defined of <code class="reqn">[-\pi,\pi]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">S = \{ S_\theta : \theta \in G \}</code>, where <code class="reqn">G</code> is some finite grid
of frequencies in <code class="reqn">[-\pi,\pi]</code> and <code class="reqn">S_\theta \in \mathbf{C}^{p \times p}</code>.
At each frequency <code class="reqn">\theta \in G</code> function <code>freqdom.transpose</code> transposes
</p>
<p>Resulting object is defined as
</p>
<p style="text-align: center;"><code class="reqn">S' = \{ S_\theta': \theta \in G \}.</code>
</p>



<h3>Value</h3>

<p>Function returns a frequency domain object (<code><a href="#topic+freqdom">freqdom</a></code>) of dimensions <code class="reqn">L \times p_2 \times p_1</code>, where <code class="reqn">L</code> is the size of the grid.
The elements of the object correspond to <code class="reqn">S_\theta'</code> as defined above.
</p>

<hr>
<h2 id='is.freqdom'>Checks if an object belongs to the class freqdom</h2><span id='topic+is.freqdom'></span>

<h3>Description</h3>

<p>Checks if an object belongs to the class <code><a href="#topic+freqdom">freqdom</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.freqdom(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.freqdom_+3A_x">X</code></td>
<td>
<p>some object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>X</code> is of type <code><a href="#topic+freqdom">freqdom</a></code>, <code>FALSE</code> otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+freqdom">freqdom</a></code>, <code><a href="#topic+timedom">timedom</a></code>, <code><a href="#topic+is.timedom">is.timedom</a></code>
</p>

<hr>
<h2 id='is.timedom'>Checks if an object belongs to the class timedom</h2><span id='topic+is.timedom'></span>

<h3>Description</h3>

<p>Checks if an object belongs to the class <code><a href="#topic+timedom">timedom</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.timedom(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.timedom_+3A_x">X</code></td>
<td>
<p>some object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>X</code> is of type <code><a href="#topic+timedom">timedom</a></code>, <code>FALSE</code> otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+freqdom">freqdom</a></code>, <code><a href="#topic+timedom">timedom</a></code>, <code><a href="#topic+is.freqdom">is.freqdom</a></code>
</p>

<hr>
<h2 id='plus.freqdom'>Frequency-wise sum of freqdom objects</h2><span id='topic+plus.freqdom'></span>

<h3>Description</h3>

<p>Frequency-wise sum of freqdom objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plus.freqdom(e1, e2)
</code></pre>

<hr>
<h2 id='print.freqdom'>Print freqdom object</h2><span id='topic+print.freqdom'></span>

<h3>Description</h3>

<p>Print freqdom object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freqdom'
print(x, ...)
</code></pre>

<hr>
<h2 id='print.timedom'>Print timedom object</h2><span id='topic+print.timedom'></span>

<h3>Description</h3>

<p>Print timedom object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'timedom'
print(x, ...)
</code></pre>

<hr>
<h2 id='rar'>Simulate a multivariate autoregressive time series</h2><span id='topic+rar'></span>

<h3>Description</h3>

<p>Generates a zero mean vector autoregressive process of a given order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rar(
  n,
  d = 2,
  Psi = NULL,
  burnin = 10,
  noise = c("mnormal", "mt"),
  sigma = NULL,
  df = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rar_+3A_n">n</code></td>
<td>
<p>number of observations to generate.</p>
</td></tr>
<tr><td><code id="rar_+3A_d">d</code></td>
<td>
<p>dimension of the time series.</p>
</td></tr>
<tr><td><code id="rar_+3A_psi">Psi</code></td>
<td>
<p>array of <code class="reqn">p \geq 1</code> coefficient matrices. <code>Psi[,,k]</code> is the <code class="reqn">k</code>-th coefficient. If no value is set then we generate a vector autoregressive process of order 1. Then, <code>Psi[,,1]</code> is proportional to <code class="reqn">\exp(-(i+j)\colon 1\leq i, j\leq d)</code> and such that the spectral radius of <code>Psi[,,1]</code> is 1/2.</p>
</td></tr>
<tr><td><code id="rar_+3A_burnin">burnin</code></td>
<td>
<p>an integer <code class="reqn">\geq 0</code>. It specifies a number of initial  observations to be trashed to achieve stationarity.</p>
</td></tr>
<tr><td><code id="rar_+3A_noise">noise</code></td>
<td>
<p><code>mnormal</code> for multivariate normal noise or <code>mt</code> for multivariate student t noise. If not specified <code>mnormal</code> is chosen.</p>
</td></tr>
<tr><td><code id="rar_+3A_sigma">sigma</code></td>
<td>
<p>covariance  or scale matrix of the innovations. By default the identity matrix.</p>
</td></tr>
<tr><td><code id="rar_+3A_df">df</code></td>
<td>
<p>degrees of freedom if <code>noise = "mt"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We simulate a vector autoregressive process
</p>
<p style="text-align: center;"><code class="reqn">
  X_t=\sum_{k=1}^p \Psi_k X_{t-k}+\varepsilon_t,\quad 1\leq t\leq n.
</code>
</p>

<p>The innovation process <code class="reqn">\varepsilon_t</code> is either multivariate normal or multivariate
<code class="reqn">t</code> with a predefined covariance/scale matrix sigma and zero mean. The noise is generated
with the package <code>mvtnorm</code>. For Gaussian noise we use <code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code>. For Student-t noise
we use <code><a href="mvtnorm.html#topic+rmvt">rmvt</a></code>. The parameters sigma and df are imported as arguments, otherwise we use default
settings. To initialise the process we set
<code class="reqn">[X_{1-p},\ldots,X_{0}]=[\varepsilon_{1-p},\ldots,\varepsilon_{0}]</code>. When <code>burnin</code> is set
equal to <code class="reqn">K</code> then, n<code class="reqn">+K</code> observations are generated and the first <code class="reqn">K</code> will be trashed.
</p>


<h3>Value</h3>

<p>A matrix with <code>d</code> columns and <code>n</code> rows. Each row corresponds to one time point.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rma">rma</a></code>
</p>

<hr>
<h2 id='rev'>Invert order of lags or grid parameters of a <code><a href="#topic+timedom">timedom</a></code> or <code><a href="#topic+freqdom">freqdom</a></code> object, respectively</h2><span id='topic+rev'></span><span id='topic+rev.freqdom'></span>

<h3>Description</h3>


<ul>
<li><p> For a given <code>freqdom</code> object <code>x</code>, the function <code>rev</code> reverts the order of the evaluation grid.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freqdom'
rev(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rev_+3A_x">x</code></td>
<td>
<p>an object of class <code>freqdom</code> or <code>timedom</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns object of same class as <code>x</code>.
</p>

<hr>
<h2 id='rev.timedom'>rev Reverts order of lags in an object of class <code><a href="#topic+timedom">timedom</a></code></h2><span id='topic+rev.timedom'></span>

<h3>Description</h3>


<ul>
<li><p> For a given <code>timedom</code> object <code>x</code>, the function <code>rev</code> reverts the order of lags.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'timedom'
rev(x)
</code></pre>

<hr>
<h2 id='rma'>Moving average process</h2><span id='topic+rma'></span>

<h3>Description</h3>

<p>Generates a zero mean vector moving average process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rma(n, d = 2, Psi = NULL, noise = c("mnormal", "mt"), sigma = NULL, df = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rma_+3A_n">n</code></td>
<td>
<p>number of observations to generate.</p>
</td></tr>
<tr><td><code id="rma_+3A_d">d</code></td>
<td>
<p>dimension of the time series.</p>
</td></tr>
<tr><td><code id="rma_+3A_psi">Psi</code></td>
<td>
<p>a <code><a href="#topic+timedom">timedom</a></code> object with operators <code>Psi$operators</code>, where <code>Psi$operators[,,k]</code>
is the operator on thelag <code>lags[k]</code>. If no value is set then we generate a vector moving average process
of order <code class="reqn">1</code>. Then, <code>Psi$lags = c(1)</code> and <code>Psi$operators[,,1]</code> is proportional to <code class="reqn">\exp(-(i+j)\colon 1\leq i, j\leq d)</code> and such
that the spectral radius of <code>Psi[,,1]</code> is <code class="reqn">1/2</code>.</p>
</td></tr>
<tr><td><code id="rma_+3A_noise">noise</code></td>
<td>
<p><code>mnormal</code> for multivariate normal noise or <code>mt</code> for multivariate <code class="reqn">t</code> noise. If not specified <code>mnormal</code> is chosen.</p>
</td></tr>
<tr><td><code id="rma_+3A_sigma">sigma</code></td>
<td>
<p>covariance  or scale matrix of the innovations. If NULL then the identity matrix is used.</p>
</td></tr>
<tr><td><code id="rma_+3A_df">df</code></td>
<td>
<p>degrees of freedom if <code>noise = "mt"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simulates a vector moving average process
</p>
<p style="text-align: center;"><code class="reqn">
  X_t=\varepsilon_t+\sum_{k \in lags} \Psi_k \varepsilon_{t-k},\quad 1\leq t\leq n.
</code>
</p>

<p>The innovation process <code class="reqn">\varepsilon_t</code> is either multivariate normal or multivarite <code class="reqn">t</code> with
a predefined covariance/scale matrix sigma and zero mean. The noise is generated with the
package <code>mvtnorm</code>. For Gaussian noise we use <code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code>. For Student-t noise we use
<code><a href="mvtnorm.html#topic+rmvt">rmvt</a></code>. The parameters <code>sigma</code> and <code>df</code> are imported as arguments, otherwise we use default settings.
</p>


<h3>Value</h3>

<p>A matrix with <code>d</code> columns and <code>n</code> rows. Each row corresponds to one time point.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rar">rar</a></code>
</p>

<hr>
<h2 id='spectral.density'>Compute empirical spectral density</h2><span id='topic+spectral.density'></span>

<h3>Description</h3>

<p>Estimates the spectral density and cross spectral density of vector time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral.density(
  X,
  Y = X,
  freq = (-1000:1000/1000) * pi,
  q = max(1, floor(dim(X)[1]^(1/3))),
  weights = c("Bartlett", "trunc", "Tukey", "Parzen", "Bohman", "Daniell",
    "ParzenCogburnDavis")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral.density_+3A_x">X</code></td>
<td>
<p>a vector or a vector time series given in matrix form. Each row corresponds to a timepoint.</p>
</td></tr>
<tr><td><code id="spectral.density_+3A_y">Y</code></td>
<td>
<p>a vector or vector time series given in matrix form. Each row corresponds to a timepoint.</p>
</td></tr>
<tr><td><code id="spectral.density_+3A_freq">freq</code></td>
<td>
<p>a vector containing frequencies in <code class="reqn">[-\pi, \pi]</code> on which the spectral density should be evaluated.</p>
</td></tr>
<tr><td><code id="spectral.density_+3A_q">q</code></td>
<td>
<p>window size for the kernel estimator, i.e. a positive integer.</p>
</td></tr>
<tr><td><code id="spectral.density_+3A_weights">weights</code></td>
<td>
<p>kernel used in the spectral smoothing. By default the Bartlett kernel is chosen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">[X_1,\ldots, X_T]^\prime</code> be a <code class="reqn">T\times d_1</code> matrix and <code class="reqn">[Y_1,\ldots, Y_T]^\prime</code> be a <code class="reqn">T\times d_2</code> matrix. We stack the vectors and assume that <code class="reqn">(X_t^\prime,Y_t^\prime)^\prime</code> is a stationary multivariate time series of dimension <code class="reqn">d_1+d_2</code>. The cross-spectral density between the two time series <code class="reqn">(X_t)</code> and <code class="reqn">(Y_t)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
  \sum_{h\in\mathbf{Z}} \mathrm{Cov}(X_h,Y_0) e^{-ih\omega}.
</code>
</p>

<p>The function <code>spectral.density</code> determines the empirical cross-spectral density between the two time series <code class="reqn">(X_t)</code> and <code class="reqn">(Y_t)</code>. The estimator is of form
</p>
<p style="text-align: center;"><code class="reqn">
  \widehat{\mathcal{F}}^{XY}(\omega)=\sum_{|h|\leq q} w(|k|/q)\widehat{C}^{XY}(h)e^{-ih\omega},
</code>
</p>

<p>with <code class="reqn">\widehat{C}^{XY}(h)</code> defined in <code>cov.structure</code> Here <code class="reqn">w</code> is a kernel of the specified type and <code class="reqn">q</code> is the window size.  By default the Bartlett kernel <code class="reqn">w(x)=1-|x|</code> is used.
</p>
<p>See, e.g., Chapter 10 and 11 in Brockwell and Davis (1991) for details.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+freqdom">freqdom</a></code>. The list is containing the following components:
</p>

<ul>
<li> <p><code>operators</code> <code class="reqn">\quad</code> an array. The <code class="reqn">k</code>-th matrix in this array corresponds to the spectral density matrix evaluated at the <code class="reqn">k</code>-th frequency listed in <code>freq</code>.
</p>
</li>
<li> <p><code>freq</code> <code class="reqn">\quad</code> returns argument vector <code>freq</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Peter J. Brockwell and Richard A. Davis
<em>Time Series: Theory and Methods</em>
Springer Series in Statistics, 2009
</p>

<hr>
<h2 id='summary.freqdom'>Print object summary</h2><span id='topic+summary.freqdom'></span>

<h3>Description</h3>

<p>Print object summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freqdom'
summary(object, ...)
</code></pre>

<hr>
<h2 id='summary.timedom'>Print object summary</h2><span id='topic+summary.timedom'></span>

<h3>Description</h3>

<p>Print object summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'timedom'
summary(object, ...)
</code></pre>

<hr>
<h2 id='timedom'>Defines a linear filter</h2><span id='topic+timedom'></span>

<h3>Description</h3>

<p>Creates an object of class <code>timedom</code>. This object corresponds to a multivariate linear filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timedom(A, lags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timedom_+3A_a">A</code></td>
<td>
<p>a vector, matrix or array. If array, the elements <code class="reqn">A[,,k], 1\leq k\leq K</code>, are real valued <code class="reqn">(d_1\times d_2)</code> matrices (all of same dimension). If A is a matrix, the <code class="reqn">k</code>-th row is treated as <code class="reqn">A[,,k]</code>. Same for the <code class="reqn">k</code>-th element of a vector. These matrices, vectors or scalars define a linear filter.</p>
</td></tr>
<tr><td><code id="timedom_+3A_lags">lags</code></td>
<td>
<p>a vector of increasing integers. It corresponds to the time lags of the filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This class is used to describe a linear filter, i.e. a sequence of matrices, each of which correspond to a certain lag. Filters can, for example, be used to transform a sequence <code class="reqn">(X_t)</code> into a new sequence <code class="reqn">(Y_t)</code> by defining
</p>
<p style="text-align: center;"><code class="reqn">
 Y_t=\sum_k A_kX_{t-k}.
</code>
</p>

<p>See <code>filter.process()</code>.
Formally we consider a collection <code class="reqn">[A_1,\ldots,A_K]</code> of complex-valued matrices <code class="reqn">A_k</code>, all of which have the same dimension <code class="reqn">d_1\times d_2</code>. Moreover, we consider lags <code class="reqn">\ell_1&lt;\ell_2&lt;\cdots&lt;\ell_K</code>. The object this function creates corresponds to the mapping <code class="reqn">f: \mathrm{lags}\to \mathbf{R}^{d_1\times d_2}</code>, where <code class="reqn">\ell_k\mapsto A_k</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>timedom</code>. An object of class  <code>timedom</code> is a list containing the following components:
</p>

<ul>
<li> <p><code>operators</code> <code class="reqn">\quad</code> returns the array <code>A</code> as given in the argument.
</p>
</li>
<li> <p><code>lags</code> <code class="reqn">\quad</code> returns the vector <code>lags</code> as given in the argument.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+freqdom">freqdom</a></code>, <code><a href="#topic+is.timedom">is.timedom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In this example we apply the difference operator: Delta X_t= X_t-X_{t-1} to a time series
X = rar(20)
OP = array(0,c(2,2,2))
OP[,,1] = diag(2)
OP[,,2] = -diag(2)
A = timedom(OP, lags = c(0,1))
filter.process(X, A)
</code></pre>

<hr>
<h2 id='timedom.norms'>Compute operator norms of elements of a filter</h2><span id='topic+timedom.norms'></span>

<h3>Description</h3>

<p>This function determines the norms of the matrices defining some linear filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timedom.norms(A, type = "2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timedom.norms_+3A_a">A</code></td>
<td>
<p>an object of class <code>timedom</code></p>
</td></tr>
<tr><td><code id="timedom.norms_+3A_type">type</code></td>
<td>
<p>matrix norm to be used as in <code>norm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes <code class="reqn">\|A_h\|</code> for <code class="reqn">h</code> in the set of lags belonging to the object A. When type
is <code>2</code> then <code class="reqn">\|A\|</code> is the spectral radius of <code class="reqn">A</code>. When type is <code>F</code>
then <code class="reqn">\|A\|</code> is the Frobenius norm (or the Hilbert-Schmidt norm, or Schatten 2-norm) of
<code class="reqn">A</code>. Same options as for the function <code>norm</code> as in base package.
</p>


<h3>Value</h3>

<p>A list which contains the following components:
</p>

<ul>
<li> <p><code>lags</code> <code class="reqn">\quad</code> a vector containing the lags of <code>A</code>.
</p>
</li>
<li> <p><code>norms</code> <code class="reqn">\quad</code> a vector containing the norms of the matrices defining <code>A</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>d = 2

A = array(0,c(d,d,2))
A[1,,] = 2 * diag(d:1)/d
A[2,,] = 1.5 * diag(d:1)/d
OP = timedom(A,c(-2,1))
timedom.norms(OP)
</code></pre>

<hr>
<h2 id='timedom.trunc'>Choose lags of an object of class <code>timedom</code></h2><span id='topic+timedom.trunc'></span>

<h3>Description</h3>

<p>This function removes lags from a linear filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timedom.trunc(A, lags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timedom.trunc_+3A_a">A</code></td>
<td>
<p>an object of class <code>timedom</code>.</p>
</td></tr>
<tr><td><code id="timedom.trunc_+3A_lags">lags</code></td>
<td>
<p>a vector which contains a set of lags. These lags must be a subset of the lags defined for timedom object A. Only those lags will be kept, the other lags are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>timedom</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
