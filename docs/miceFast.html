<!DOCTYPE html><html lang="en"><head><title>Help for package miceFast</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {miceFast}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#miceFast-package'>
<p>miceFast package for fast multiple imputations.</p></a></li>
<li><a href='#air_miss'><p>airquality dataset with additional variables</p></a></li>
<li><a href='#compare_imp'><p>Comparing imputations and original data distributions</p></a></li>
<li><a href='#fill_NA'><p><code>fill_NA</code> function for the imputations purpose.</p></a></li>
<li><a href='#fill_NA_N'><p><code>fill_NA_N</code> function for the multiple imputations purpose</p></a></li>
<li><a href='#naive_fill_NA'><p><code>naive_fill_NA</code> function for the simple and automatic imputation</p></a></li>
<li><a href='#neibo'><p>Finding in random manner one of the k closets points in a certain vector for each value in a second vector</p></a></li>
<li><a href='#Rcpp_corrData-class'><p>Class <code>"Rcpp_corrData"</code></p></a></li>
<li><a href='#Rcpp_miceFast-class'><p>Class <code>"Rcpp_miceFast"</code></p></a></li>
<li><a href='#upset_NA'><p>upset plot for NA values</p></a></li>
<li><a href='#VIF'><p><code>VIF</code> function for assessing VIF.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fast Imputations Using 'Rcpp' and 'Armadillo'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.5</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Fast imputations under the object-oriented programming paradigm. 	
  Moreover there are offered a few functions built to work with popular R packages such as 'data.table' or 'dplyr'.
  The biggest improvement in time performance could be achieve for a calculation where a grouping variable have to be used.
  A single evaluation of a quantitative model for the multiple imputations is another major enhancement.
  A new major improvement is one of the fastest predictive mean matching in the R world because of presorting and binary search.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Polkas/miceFast">https://github.com/Polkas/miceFast</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Polkas/miceFast/issues">https://github.com/Polkas/miceFast/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.12.12), data.table</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, pacman, testthat, mice, magrittr, ggplot2,
UpSetR, dplyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RcppModules:</td>
<td>miceFast, corrData</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-03 21:55:19 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Maciej Nasinski [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maciej Nasinski &lt;nasinski.maciej@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-03 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='miceFast-package'>
miceFast package for fast multiple imputations.
</h2><span id='topic+miceFast-package'></span>

<h3>Description</h3>

<p>Fast imputations under the object-oriented programming paradigm.
There was used quantitative models with a closed-form solution. Thus package is based on linear algebra operations.
The biggest improvement in time performance could be achieve for a calculation where a grouping variable have to be used.
A single evaluation of a quantitative model for the multiple imputations is another major enhancement.
Moreover there are offered a few functions built to work with popular R packages such as 'data.table'.
</p>


<h3>Details</h3>

<p>Please read the vignette for additional information
</p>


<h3>Author(s)</h3>

<p>Maciej Nasinski
</p>


<h3>References</h3>

<p><a href="https://github.com/Polkas/miceFast">https://github.com/Polkas/miceFast</a>
</p>

<hr>
<h2 id='air_miss'>airquality dataset with additional variables</h2><span id='topic+air_miss'></span>

<h3>Description</h3>

<p>airquality dataset with additional variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>air_miss
</code></pre>


<h3>Format</h3>

<p>A data frame and data table with 154 observations on 11 variables.
</p>

<dl>
<dt>Ozone</dt><dd><p>	numeric	Ozone (ppb) - Mean ozone in parts per billion from 1300 to 1500 hours at Roosevelt Island</p>
</dd>
<dt>Solar.R</dt><dd><p>	numeric	Solar R (lang) - Solar radiation in Langleys in the frequency band 4000â€“7700 Angstroms from 0800 to 1200 hours at Central Park</p>
</dd>
<dt>Wind</dt><dd><p>	numeric	Wind (mph) - Average wind speed in miles per hour at 0700 and 1000 hours at LaGuardia Airport</p>
</dd>
<dt>Temp</dt><dd><p>	numeric	Temperature (degrees F) - Maximum daily temperature in degrees Fahrenheit at La Guardia Airport.</p>
</dd>
<dt>Day</dt><dd><p>	numeric	Day of month (1&ndash;31)</p>
</dd>
<dt>Intercept</dt><dd><p> numeric a constant</p>
</dd>
<dt>index</dt><dd><p> numeric id</p>
</dd>
<dt>weights</dt><dd><p> numeric positive values weights</p>
</dd>
<dt>groups</dt><dd><p> factor Month (1&ndash;12)</p>
</dd>
<dt>x_character</dt><dd><p> character discrete version of Solar.R (5-levels)</p>
</dd>
<dt>Ozone_chac</dt><dd><p> character discrete version of Ozone (7-levels)</p>
</dd>
<dt>Ozone_f</dt><dd><p> factor discrete version of Ozone (7-levels)</p>
</dd>
<dt>Ozone_high</dt><dd><p>logical Ozone higher than its mean</p>
</dd>
</dl>



<h3>Details</h3>

<p>Daily readings of the following air quality values for May 1, 1973 (a Tuesday) to September 30, 1973.
</p>


<h3>Source</h3>

<p>The data were obtained from the New York State Department of Conservation (ozone data) and the National Weather Service (meteorological data).
</p>


<h3>References</h3>

<p>Chambers, J. M., Cleveland, W. S., Kleiner, B. and Tukey, P. A. (1983) Graphical Methods for Data Analysis. Belmont, CA: Wadsworth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(data.table)
data(airquality)
data &lt;- cbind(as.matrix(airquality[, -5]),
  Intercept = 1, index = 1:nrow(airquality),
  # a numeric vector - positive values
  weights = rnorm(nrow(airquality), 1, 0.01),
  # months as groups
  groups = airquality[, 5]
)

# data.table
air_miss &lt;- data.table(data)
air_miss$groups &lt;- factor(air_miss$groups)

# Distribution of Ozone - close to log-normal
# hist(air_miss$Ozone)

# Additional vars
# Make a character variable to show package capabilities
air_miss$x_character &lt;- as.character(cut(air_miss$Solar.R, seq(0, 350, 70)))
# Discrete version of dependent variable
air_miss$Ozone_chac &lt;- as.character(cut(air_miss$Ozone, seq(0, 160, 20)))
air_miss$Ozone_f &lt;- cut(air_miss$Ozone, seq(0, 160, 20))
air_miss$Ozone_high &lt;- air_miss$Ozone &gt; mean(air_miss$Ozone, na.rm = T)

## End(Not run)

</code></pre>

<hr>
<h2 id='compare_imp'>Comparing imputations and original data distributions</h2><span id='topic+compare_imp'></span>

<h3>Description</h3>

<p>ggplot2 visualization to support which imputation method to choose
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_imp(df, origin, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_imp_+3A_df">df</code></td>
<td>
<p>data.frame with origin variable and the new one with imputations</p>
</td></tr>
<tr><td><code id="compare_imp_+3A_origin">origin</code></td>
<td>
<p>character value - the name of origin variable with values before any imputations</p>
</td></tr>
<tr><td><code id="compare_imp_+3A_target">target</code></td>
<td>
<p>character vector - names of variables with applied imputations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(miceFast)
library(ggplot2)
data(air_miss)
air_miss$Ozone_imp &lt;- fill_NA(
  x = air_miss,
  model = "lm_bayes",
  posit_y = 1,
  posit_x = c(4, 6),
  logreg = TRUE
)
air_miss$Ozone_imp2 &lt;- fill_NA_N(
  x = air_miss,
  model = "pmm",
  posit_y = 1,
  posit_x = c(4, 6),
  logreg = TRUE
)

compare_imp(air_miss, origin = "Ozone", "Ozone_imp")
compare_imp(air_miss, origin = "Ozone", c("Ozone_imp", "Ozone_imp2"))

</code></pre>

<hr>
<h2 id='fill_NA'><code>fill_NA</code> function for the imputations purpose.</h2><span id='topic+fill_NA'></span><span id='topic+fill_NA.data.frame'></span><span id='topic+fill_NA.data.table'></span><span id='topic+fill_NA.matrix'></span>

<h3>Description</h3>

<p>Regular imputations to fill the missing data.
Non missing independent variables are used to approximate a missing observations for a dependent variable.
Quantitative models were built under Rcpp packages and the C++ library Armadillo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_NA(x, model, posit_y, posit_x, w = NULL, logreg = FALSE, ridge = 1e-06)

## S3 method for class 'data.frame'
fill_NA(x, model, posit_y, posit_x, w = NULL, logreg = FALSE, ridge = 1e-06)

## S3 method for class 'data.table'
fill_NA(x, model, posit_y, posit_x, w = NULL, logreg = FALSE, ridge = 1e-06)

## S3 method for class 'matrix'
fill_NA(x, model, posit_y, posit_x, w = NULL, logreg = FALSE, ridge = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_NA_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data.frame/data.table (factor/character/numeric/logical)  - variables</p>
</td></tr>
<tr><td><code id="fill_NA_+3A_model">model</code></td>
<td>
<p>a character - posibble options (&quot;lda&quot;,&quot;lm_pred&quot;,&quot;lm_bayes&quot;,&quot;lm_noise&quot;)</p>
</td></tr>
<tr><td><code id="fill_NA_+3A_posit_y">posit_y</code></td>
<td>
<p>an integer/character - a position/name of dependent variable</p>
</td></tr>
<tr><td><code id="fill_NA_+3A_posit_x">posit_x</code></td>
<td>
<p>an integer/character vector - positions/names of independent variables</p>
</td></tr>
<tr><td><code id="fill_NA_+3A_w">w</code></td>
<td>
<p>a numeric vector - a weighting variable - only positive values, Default:NULL</p>
</td></tr>
<tr><td><code id="fill_NA_+3A_logreg">logreg</code></td>
<td>
<p>a boolean - if dependent variable has log-normal distribution (numeric). If TRUE log-regression is evaluated and then returned exponential of results., Default: FALSE</p>
</td></tr>
<tr><td><code id="fill_NA_+3A_ridge">ridge</code></td>
<td>
<p>a numeric - a value added to diagonal elements of the x'x matrix, Default:1e-5</p>
</td></tr>
</table>


<h3>Value</h3>

<p>load imputations in a numeric/logical/character/factor (similar to the input type) vector format
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fill_NA(data.frame)</code>: S3 method for data.frame
</p>
</li>
<li> <p><code>fill_NA(data.table)</code>: s3 method for data.table
</p>
</li>
<li> <p><code>fill_NA(matrix)</code>: S3 method for matrix
</p>
</li></ul>


<h3>Note</h3>

<p>There is assumed that users add the intercept by their own.
The miceFast module provides the most efficient environment, the second recommended option is to use data.table and the numeric matrix data type.
The lda model is assessed only if there are more than 15 complete observations
and for the lms models if number of independent variables is smaller than number of observations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fill_NA_N">fill_NA_N</a></code>  <code><a href="#topic+VIF">VIF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(miceFast)
library(dplyr)
library(data.table)
### Data
# airquality dataset with additional variables
data(air_miss)
### Intro: dplyr
# IMPUTATIONS
air_miss &lt;- air_miss %&gt;%
  # Imputations with a grouping option (models are separately assessed for each group)
  # taking into account provided weights
  group_by(groups) %&gt;%
  do(mutate(., Solar_R_imp = fill_NA(
    x = .,
    model = "lm_pred",
    posit_y = "Solar.R",
    posit_x = c("Wind", "Temp", "Intercept"),
    w = .[["weights"]]
  ))) %&gt;%
  ungroup() %&gt;%
  # Imputations - discrete variable
  mutate(x_character_imp = fill_NA(
    x = .,
    model = "lda",
    posit_y = "x_character",
    posit_x = c("Wind", "Temp")
  )) %&gt;%
  # logreg was used because almost log-normal distribution of Ozone
  # imputations around mean
  mutate(Ozone_imp1 = fill_NA(
    x = .,
    model = "lm_bayes",
    posit_y = "Ozone",
    posit_x = c("Intercept"),
    logreg = TRUE
  )) %&gt;%
  # imputations using positions - Intercept, Temp
  mutate(Ozone_imp2 = fill_NA(
    x = .,
    model = "lm_bayes",
    posit_y = 1,
    posit_x = c(4, 6),
    logreg = TRUE
  )) %&gt;%
  # multiple imputations (average of x30 imputations)
  # with a factor independent variable, weights and logreg options
  mutate(Ozone_imp3 = fill_NA_N(
    x = .,
    model = "lm_noise",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .[["weights"]],
    logreg = TRUE,
    k = 30
  )) %&gt;%
  mutate(Ozone_imp4 = fill_NA_N(
    x = .,
    model = "lm_bayes",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .[["weights"]],
    logreg = TRUE,
    k = 30
  )) %&gt;%
  group_by(groups) %&gt;%
  do(mutate(., Ozone_imp5 = fill_NA(
    x = .,
    model = "lm_pred",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .[["weights"]],
    logreg = TRUE
  ))) %&gt;%
  do(mutate(., Ozone_imp6 = fill_NA_N(
    x = .,
    model = "pmm",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .[["weights"]],
    logreg = TRUE,
    k = 20
  ))) %&gt;%
  ungroup() %&gt;%
  # Average of a few methods
  mutate(Ozone_imp_mix = rowMeans(select(., starts_with("Ozone_imp")))) %&gt;%
  # Protecting against collinearity or low number of observations - across small groups
  # Be carful when using a grouping option
  # because of lack of protection against collinearity or low number of observations.
  # There could be used a tryCatch(fill_NA(...),error=function(e) return(...))
  group_by(groups) %&gt;%
  do(mutate(., Ozone_chac_imp = tryCatch(
    fill_NA(
      x = .,
      model = "lda",
      posit_y = "Ozone_chac",
      posit_x = c(
        "Intercept",
        "Month",
        "Day",
        "Temp",
        "x_character_imp"
      ),
      w = .[["weights"]]
    ),
    error = function(e) .[["Ozone_chac"]]
  ))) %&gt;%
  ungroup()

# Sample of results
air_miss[which(is.na(air_miss[, 1]))[1:5], ]

### Intro: data.table
# IMPUTATIONS
# Imputations with a grouping option (models are separately assessed for each group)
# taking into account provided weights
data(air_miss)
setDT(air_miss)
air_miss[, Solar_R_imp := fill_NA_N(
  x = .SD,
  model = "lm_bayes",
  posit_y = "Solar.R",
  posit_x = c("Wind", "Temp", "Intercept"),
  w = .SD[["weights"]],
  k = 100
), by = .(groups)] %&gt;%
  # Imputations - discrete variable
  .[, x_character_imp := fill_NA(
    x = .SD,
    model = "lda",
    posit_y = "x_character",
    posit_x = c("Wind", "Temp", "groups")
  )] %&gt;%
  # logreg was used because almost log-normal distribution of Ozone
  # imputations around mean
  .[, Ozone_imp1 := fill_NA(
    x = .SD,
    model = "lm_bayes",
    posit_y = "Ozone",
    posit_x = c("Intercept"),
    logreg = TRUE
  )] %&gt;%
  # imputations using positions - Intercept, Temp
  .[, Ozone_imp2 := fill_NA(
    x = .SD,
    model = "lm_bayes",
    posit_y = 1,
    posit_x = c(4, 6),
    logreg = TRUE
  )] %&gt;%
  # model with a factor independent variable
  # multiple imputations (average of x30 imputations)
  # with a factor independent variable, weights and logreg options
  .[, Ozone_imp3 := fill_NA_N(
    x = .SD,
    model = "lm_noise",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .SD[["weights"]],
    logreg = TRUE,
    k = 30
  )] %&gt;%
  .[, Ozone_imp4 := fill_NA_N(
    x = .SD,
    model = "lm_bayes",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .SD[["weights"]],
    logreg = TRUE,
    k = 30
  )] %&gt;%
  .[, Ozone_imp5 := fill_NA(
    x = .SD,
    model = "lm_pred",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .SD[["weights"]],
    logreg = TRUE
  ), .(groups)] %&gt;%
  .[, Ozone_imp6 := fill_NA_N(
    x = .SD,
    model = "pmm",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .SD[["weights"]],
    logreg = TRUE,
    k = 10
  ), .(groups)] %&gt;%
  # Average of a few methods
  .[, Ozone_imp_mix := apply(.SD, 1, mean), .SDcols = Ozone_imp1:Ozone_imp6] %&gt;%
  # Protecting against collinearity or low number of observations - across small groups
  # Be carful when using a data.table grouping option
  # because of lack of protection against collinearity or low number of observations.
  # There could be used a tryCatch(fill_NA(...),error=function(e) return(...))

  .[, Ozone_chac_imp := tryCatch(
    fill_NA(
      x = .SD,
      model = "lda",
      posit_y = "Ozone_chac",
      posit_x = c(
        "Intercept",
        "Month",
        "Day",
        "Temp",
        "x_character_imp"
      ),
      w = .SD[["weights"]]
    ),
    error = function(e) .SD[["Ozone_chac"]]
  ), .(groups)]

# Sample of results
air_miss[which(is.na(air_miss[, 1]))[1:5], ]

</code></pre>

<hr>
<h2 id='fill_NA_N'><code>fill_NA_N</code> function for the multiple imputations purpose</h2><span id='topic+fill_NA_N'></span><span id='topic+fill_NA_N.data.frame'></span><span id='topic+fill_NA_N.data.table'></span><span id='topic+fill_NA_N.matrix'></span>

<h3>Description</h3>

<p>Multiple imputations to fill the missing data.
Non missing independent variables are used to approximate a missing observations for a dependent variable.
Quantitative models were built under Rcpp packages and the C++ library Armadillo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_NA_N(
  x,
  model,
  posit_y,
  posit_x,
  w = NULL,
  logreg = FALSE,
  k = 10,
  ridge = 1e-06
)

## S3 method for class 'data.frame'
fill_NA_N(
  x,
  model,
  posit_y,
  posit_x,
  w = NULL,
  logreg = FALSE,
  k = 10,
  ridge = 1e-06
)

## S3 method for class 'data.table'
fill_NA_N(
  x,
  model,
  posit_y,
  posit_x,
  w = NULL,
  logreg = FALSE,
  k = 10,
  ridge = 1e-06
)

## S3 method for class 'matrix'
fill_NA_N(
  x,
  model,
  posit_y,
  posit_x,
  w = NULL,
  logreg = FALSE,
  k = 10,
  ridge = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_NA_N_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data.frame/data.table (factor/character/numeric/logical) - variables</p>
</td></tr>
<tr><td><code id="fill_NA_N_+3A_model">model</code></td>
<td>
<p>a character - posibble options (&quot;lm_bayes&quot;,&quot;lm_noise&quot;,&quot;pmm&quot;)</p>
</td></tr>
<tr><td><code id="fill_NA_N_+3A_posit_y">posit_y</code></td>
<td>
<p>an integer/character - a position/name of dependent variable</p>
</td></tr>
<tr><td><code id="fill_NA_N_+3A_posit_x">posit_x</code></td>
<td>
<p>an integer/character vector - positions/names of independent variables</p>
</td></tr>
<tr><td><code id="fill_NA_N_+3A_w">w</code></td>
<td>
<p>a numeric vector - a weighting variable - only positive values, Default: NULL</p>
</td></tr>
<tr><td><code id="fill_NA_N_+3A_logreg">logreg</code></td>
<td>
<p>a boolean - if dependent variable has log-normal distribution (numeric). If TRUE log-regression is evaluated and then returned exponential of results., Default: FALSE</p>
</td></tr>
<tr><td><code id="fill_NA_N_+3A_k">k</code></td>
<td>
<p>an integer - a number of multiple imputations or for pmm a number of closest points from which a one random value is taken, Default:10</p>
</td></tr>
<tr><td><code id="fill_NA_N_+3A_ridge">ridge</code></td>
<td>
<p>a numeric - a value added to diagonal elements of the x'x matrix, Default:1e-5</p>
</td></tr>
</table>


<h3>Value</h3>

<p>load imputations in a numeric/character/factor (similar to the input type) vector format
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fill_NA_N(data.frame)</code>: s3 method for data.frame
</p>
</li>
<li> <p><code>fill_NA_N(data.table)</code>: S3 method for data.table
</p>
</li>
<li> <p><code>fill_NA_N(matrix)</code>: S3 method for matrix
</p>
</li></ul>


<h3>Note</h3>

<p>There is assumed that users add the intercept by their own.
The miceFast module provides the most efficient environment, the second recommended option is to use data.table and the numeric matrix data type.
The lda model is assessed only if there are more than 15 complete observations
and for the lms models if number of variables is smaller than number of observations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fill_NA">fill_NA</a></code> <code><a href="#topic+VIF">VIF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(miceFast)
library(dplyr)
library(data.table)
### Data
# airquality dataset with additional variables
data(air_miss)
### Intro: dplyr
# IMPUTATIONS
air_miss &lt;- air_miss %&gt;%
  # Imputations with a grouping option (models are separately assessed for each group)
  # taking into account provided weights
  group_by(groups) %&gt;%
  do(mutate(., Solar_R_imp = fill_NA(
    x = .,
    model = "lm_pred",
    posit_y = "Solar.R",
    posit_x = c("Wind", "Temp", "Intercept"),
    w = .[["weights"]]
  ))) %&gt;%
  ungroup() %&gt;%
  # Imputations - discrete variable
  mutate(x_character_imp = fill_NA(
    x = .,
    model = "lda",
    posit_y = "x_character",
    posit_x = c("Wind", "Temp")
  )) %&gt;%
  # logreg was used because almost log-normal distribution of Ozone
  # imputations around mean
  mutate(Ozone_imp1 = fill_NA(
    x = .,
    model = "lm_bayes",
    posit_y = "Ozone",
    posit_x = c("Intercept"),
    logreg = TRUE
  )) %&gt;%
  # imputations using positions - Intercept, Temp
  mutate(Ozone_imp2 = fill_NA(
    x = .,
    model = "lm_bayes",
    posit_y = 1,
    posit_x = c(4, 6),
    logreg = TRUE
  )) %&gt;%
  # multiple imputations (average of x30 imputations)
  # with a factor independent variable, weights and logreg options
  mutate(Ozone_imp3 = fill_NA_N(
    x = .,
    model = "lm_noise",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .[["weights"]],
    logreg = TRUE,
    k = 30
  )) %&gt;%
  mutate(Ozone_imp4 = fill_NA_N(
    x = .,
    model = "lm_bayes",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .[["weights"]],
    logreg = TRUE,
    k = 30
  )) %&gt;%
  group_by(groups) %&gt;%
  do(mutate(., Ozone_imp5 = fill_NA(
    x = .,
    model = "lm_pred",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .[["weights"]],
    logreg = TRUE
  ))) %&gt;%
  do(mutate(., Ozone_imp6 = fill_NA_N(
    x = .,
    model = "pmm",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .[["weights"]],
    logreg = TRUE,
    k = 20
  ))) %&gt;%
  ungroup() %&gt;%
  # Average of a few methods
  mutate(Ozone_imp_mix = rowMeans(select(., starts_with("Ozone_imp")))) %&gt;%
  # Protecting against collinearity or low number of observations - across small groups
  # Be carful when using a grouping option
  # because of lack of protection against collinearity or low number of observations.
  # There could be used a tryCatch(fill_NA(...),error=function(e) return(...))
  group_by(groups) %&gt;%
  do(mutate(., Ozone_chac_imp = tryCatch(
    fill_NA(
      x = .,
      model = "lda",
      posit_y = "Ozone_chac",
      posit_x = c(
        "Intercept",
        "Month",
        "Day",
        "Temp",
        "x_character_imp"
      ),
      w = .[["weights"]]
    ),
    error = function(e) .[["Ozone_chac"]]
  ))) %&gt;%
  ungroup()

# Sample of results
air_miss[which(is.na(air_miss[, 1]))[1:5], ]

### Intro: data.table
# IMPUTATIONS
# Imputations with a grouping option (models are separately assessed for each group)
# taking into account provided weights
data(air_miss)
setDT(air_miss)
air_miss[, Solar_R_imp := fill_NA_N(
  x = .SD,
  model = "lm_bayes",
  posit_y = "Solar.R",
  posit_x = c("Wind", "Temp", "Intercept"),
  w = .SD[["weights"]],
  k = 100
), by = .(groups)] %&gt;%
  # Imputations - discrete variable
  .[, x_character_imp := fill_NA(
    x = .SD,
    model = "lda",
    posit_y = "x_character",
    posit_x = c("Wind", "Temp", "groups")
  )] %&gt;%
  # logreg was used because almost log-normal distribution of Ozone
  # imputations around mean
  .[, Ozone_imp1 := fill_NA(
    x = .SD,
    model = "lm_bayes",
    posit_y = "Ozone",
    posit_x = c("Intercept"),
    logreg = TRUE
  )] %&gt;%
  # imputations using positions - Intercept, Temp
  .[, Ozone_imp2 := fill_NA(
    x = .SD,
    model = "lm_bayes",
    posit_y = 1,
    posit_x = c(4, 6),
    logreg = TRUE
  )] %&gt;%
  # model with a factor independent variable
  # multiple imputations (average of x30 imputations)
  # with a factor independent variable, weights and logreg options
  .[, Ozone_imp3 := fill_NA_N(
    x = .SD,
    model = "lm_noise",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .SD[["weights"]],
    logreg = TRUE,
    k = 30
  )] %&gt;%
  .[, Ozone_imp4 := fill_NA_N(
    x = .SD,
    model = "lm_bayes",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .SD[["weights"]],
    logreg = TRUE,
    k = 30
  )] %&gt;%
  .[, Ozone_imp5 := fill_NA(
    x = .SD,
    model = "lm_pred",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .SD[["weights"]],
    logreg = TRUE
  ), .(groups)] %&gt;%
  .[, Ozone_imp6 := fill_NA_N(
    x = .SD,
    model = "pmm",
    posit_y = "Ozone",
    posit_x = c("Intercept", "x_character_imp", "Wind", "Temp"),
    w = .SD[["weights"]],
    logreg = TRUE,
    k = 10
  ), .(groups)] %&gt;%
  # Average of a few methods
  .[, Ozone_imp_mix := apply(.SD, 1, mean), .SDcols = Ozone_imp1:Ozone_imp6] %&gt;%
  # Protecting against collinearity or low number of observations - across small groups
  # Be carful when using a data.table grouping option
  # because of lack of protection against collinearity or low number of observations.
  # There could be used a tryCatch(fill_NA(...),error=function(e) return(...))

  .[, Ozone_chac_imp := tryCatch(
    fill_NA(
      x = .SD,
      model = "lda",
      posit_y = "Ozone_chac",
      posit_x = c(
        "Intercept",
        "Month",
        "Day",
        "Temp",
        "x_character_imp"
      ),
      w = .SD[["weights"]]
    ),
    error = function(e) .SD[["Ozone_chac"]]
  ), .(groups)]

# Sample of results
air_miss[which(is.na(air_miss[, 1]))[1:5], ]

</code></pre>

<hr>
<h2 id='naive_fill_NA'><code>naive_fill_NA</code> function for the simple and automatic imputation</h2><span id='topic+naive_fill_NA'></span><span id='topic+naive_fill_NA.data.frame'></span><span id='topic+naive_fill_NA.data.table'></span><span id='topic+naive_fill_NA.matrix'></span>

<h3>Description</h3>

<p>Automatically fill the missing data with a simple imputation method,
impute with sampling the non missing values.
It is recommended to use this function for each categorical variable separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naive_fill_NA(x)

## S3 method for class 'data.frame'
naive_fill_NA(x)

## S3 method for class 'data.table'
naive_fill_NA(x)

## S3 method for class 'matrix'
naive_fill_NA(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="naive_fill_NA_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data.frame/data.table (factor/character/numeric/logical variables)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object with a similar structure to the input but without missing values.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>naive_fill_NA(data.frame)</code>: S3 method for data.frame
</p>
</li>
<li> <p><code>naive_fill_NA(data.table)</code>: S3 method for data.table
</p>
</li>
<li> <p><code>naive_fill_NA(matrix)</code>: S3 method for matrix
</p>
</li></ul>


<h3>Note</h3>

<p>this is a very simple and fast solution but not recommended,
for more complex solutions please check the vignette.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fill_NA">fill_NA</a></code> <code><a href="#topic+fill_NA_N">fill_NA_N</a></code>  <code><a href="#topic+VIF">VIF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(miceFast)
data(air_miss)
naive_fill_NA(air_miss)
# Could be useful to run it separately for each group level
do.call(rbind, Map(naive_fill_NA, split(air_miss, air_miss$groups)))

## End(Not run)

</code></pre>

<hr>
<h2 id='neibo'>Finding in random manner one of the k closets points in a certain vector for each value in a second vector</h2><span id='topic+neibo'></span>

<h3>Description</h3>

<p>this function using pre-sorting of a y and the binary search the one of the k closest value for each miss is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neibo(y, miss, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neibo_+3A_y">y</code></td>
<td>
<p>numeric vector values to be look up</p>
</td></tr>
<tr><td><code id="neibo_+3A_miss">miss</code></td>
<td>
<p>numeric vector a values to be look for</p>
</td></tr>
<tr><td><code id="neibo_+3A_k">k</code></td>
<td>
<p>integer a number of values which should be taken into account during sampling one of the k closest point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>

<hr>
<h2 id='Rcpp_corrData-class'>Class <code>"Rcpp_corrData"</code></h2><span id='topic+Rcpp_corrData-class'></span><span id='topic+corrData'></span>

<h3>Description</h3>

<p>This C++ class could be used to build a corrData object by invoking <code>new(corrData,...)</code> function.
</p>


<h3>Methods</h3>


<dl>
<dt><code>initialize(...)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>finalize()</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>fill(...)</code>:</dt><dd><p> generating data </p>
</dd>
</dl>



<h3>Note</h3>

<p>This is only frame for building C++ object which could be used to implement certain methods.
Check the vignette for more details of implementing methods.
</p>
<p>Vigniette:
<a href="https://CRAN.R-project.org/package=miceFast">https://CRAN.R-project.org/package=miceFast</a>
</p>


<h3>References</h3>

<p>See the documentation for Rcpp modules for more details of how this class was built.
<code>vignette("Rcpp-modules", package = "Rcpp")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#showClass("Rcpp_corrData")
show(corrData)
</code></pre>

<hr>
<h2 id='Rcpp_miceFast-class'>Class <code>"Rcpp_miceFast"</code></h2><span id='topic+Rcpp_miceFast-class'></span><span id='topic+miceFast'></span>

<h3>Description</h3>

<p>This C++ class could be used to build a miceFast objects by invoking <code>new(miceFast)</code> function.
</p>


<h3>Methods</h3>


<dl>
<dt><code>set_data(...)</code>:</dt><dd><p> providing data by a reference - a numeric matrix</p>
</dd>
<dt><code>set_g(...)</code>:</dt><dd><p> providing a grouping variable by a reference - a numeric vector WITOUT NA values - positive values</p>
</dd>
<dt><code>set_w(...)</code>:</dt><dd><p> providing a weightinh variable by a reference - a numeric vector WITOUT NA values - positive values</p>
</dd>
<dt><code>set_ridge(...)</code>:</dt><dd><p> providing a ridge i.e. the disturbance to diag of XX, default 1e-6</p>
</dd>
<dt><code>get_data(...)</code>:</dt><dd><p> retrieving the data </p>
</dd>
<dt><code>get_w(...)</code>:</dt><dd><p> retrieving the weighting variable </p>
</dd>
<dt><code>get_g(...)</code>:</dt><dd><p> retireiving the grouping variable </p>
</dd>
<dt><code>get_ridge(...)</code>:</dt><dd><p> retireiving the ridge disturbance </p>
</dd>
<dt><code>get_index(...)</code>:</dt><dd><p> getting the index </p>
</dd>
<dt><code>impute(...)</code>:</dt><dd><p> impute data under characterstics from the object like a optional grouping or weighting variable </p>
</dd>
<dt><code>impute_N(...)</code>:</dt><dd><p> multiple imputations - impute data under characterstics from the object like a optional grouping or weighting variable </p>
</dd>
<dt><code>update_var(...)</code>:</dt><dd><p> permanently update the variable at the object and data. Use it only if you are sure about model parameters</p>
</dd>
<dt><code>get_models(...)</code>:</dt><dd><p>  get possible quantitative models for a certain type of dependent variable </p>
</dd>
<dt><code>get_model(...)</code>:</dt><dd><p>  get a recommended quantitative model for a certain type of dependent variable </p>
</dd>
<dt><code>which_updated(...)</code>:</dt><dd><p> which variables at the object was modified by update_var</p>
</dd>
<dt><code>sort_byg(...)</code>:</dt><dd><p> sort data by the grouping variable </p>
</dd>
<dt><code>is_sorted_byg(...)</code>:</dt><dd><p>check if data is sorted by the grouping variable </p>
</dd>
<dt><code>vifs(...)</code>:</dt><dd><p>Variance inflation factors (VIF) - helps to check when the predictor variables are not linearly related</p>
</dd>
<dt><code>initialize(...)</code>:</dt><dd><p> ... </p>
</dd>
<dt><code>finalize()</code>:</dt><dd><p> ... </p>
</dd>
</dl>



<h3>Note</h3>

<p>This is only frame for building C++ object which could be used to implement certain methods.
Check the vignette for more details of implementing these methods.
</p>
<p>Vigniette:
<a href="https://CRAN.R-project.org/package=miceFast">https://CRAN.R-project.org/package=miceFast</a>
</p>


<h3>References</h3>

<p>See the documentation for Rcpp modules for more details of how this class was built.
<code>vignette("Rcpp-modules", package = "Rcpp")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#showClass("Rcpp_miceFast")
show(miceFast)
new(miceFast)
</code></pre>

<hr>
<h2 id='upset_NA'>upset plot for NA values</h2><span id='topic+upset_NA'></span>

<h3>Description</h3>

<p>wrapper around UpSetR::upset for vizualization of NA values
</p>
<p>Visualization of set intersections using novel UpSet matrix design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_NA(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upset_NA_+3A_...">...</code></td>
<td>
<p>all arguments accepted by UpSetR::upset where the first one is expected to be a data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Visualization of set data in the layout described by Lex and Gehlenborg in <a href="https://www.nature.com/articles/nmeth.3033">https://www.nature.com/articles/nmeth.3033</a>.
UpSet also allows for visualization of queries on intersections and elements, along with custom queries queries implemented using
Hadley Wickham's apply function. To further analyze the data contained in the intersections, the user may select additional attribute plots
to be displayed alongside the UpSet plot. The user also has the the ability to pass their own plots into the function to further analyze
data belonging to queries of interest. Most aspects of the UpSet plot are customizable, allowing the user to select the plot that best suits their style.
Depending on how the features are selected, UpSet can display between 25-65 sets and between 40-100 intersections.
</p>


<h3>Note</h3>

<p>Data set must be formatted as described on the original UpSet github page: <a href="https://github.com/VCG/upset/wiki">https://github.com/VCG/upset/wiki</a>.
</p>


<h3>References</h3>

<p>Lex et al. (2014). UpSet: Visualization of Intersecting Sets
IEEE Transactions on Visualization and Computer Graphics (Proceedings of InfoVis 2014), vol 20, pp. 1983-1992, (2014).
</p>
<p>Lex and Gehlenborg (2014). Points of view: Sets and intersections. Nature Methods 11, 779 (2014). <a href="https://www.nature.com/articles/nmeth.3033">https://www.nature.com/articles/nmeth.3033</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(miceFast)
library(UpSetR)
upset_NA(airquality)
upset_NA(air_miss, 6)

</code></pre>

<hr>
<h2 id='VIF'><code>VIF</code> function for assessing VIF.</h2><span id='topic+VIF'></span><span id='topic+VIF.data.frame'></span><span id='topic+VIF.data.table'></span><span id='topic+VIF.matrix'></span>

<h3>Description</h3>

<p>VIF measure how much the variance of the estimated regression coefficients are inflated.
It helps to identify when the predictor variables are linearly related.
You have to decide which variable should be delete.
Usually values higher than 10 (around), mean a collinearity problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VIF(x, posit_y, posit_x, correct = FALSE)

## S3 method for class 'data.frame'
VIF(x, posit_y, posit_x, correct = FALSE)

## S3 method for class 'data.table'
VIF(x, posit_y, posit_x, correct = FALSE)

## S3 method for class 'matrix'
VIF(x, posit_y, posit_x, correct = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VIF_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data.frame/data.table (factor/character/numeric) - variables</p>
</td></tr>
<tr><td><code id="VIF_+3A_posit_y">posit_y</code></td>
<td>
<p>an integer/character - a position/name of dependent variable.
This variable is taken into account only for getting complete cases.</p>
</td></tr>
<tr><td><code id="VIF_+3A_posit_x">posit_x</code></td>
<td>
<p>an integer/character vector - positions/names of independent variables</p>
</td></tr>
<tr><td><code id="VIF_+3A_correct">correct</code></td>
<td>
<p>a boolean - basic or corrected - Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>load a numeric vector with VIF for all variables provided by posit_x
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>VIF(data.frame)</code>: 
</p>
</li>
<li> <p><code>VIF(data.table)</code>: 
</p>
</li>
<li> <p><code>VIF(matrix)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>The corrected VIF is obtained by raising the basic VIF to the power of one divided by two times the degrees of freedom.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fill_NA">fill_NA</a></code> <code><a href="#topic+fill_NA_N">fill_NA_N</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(miceFast)
library(data.table)

airquality2 &lt;- airquality
airquality2$Temp2 &lt;- airquality2$Temp**2
airquality2$Month &lt;- factor(airquality2$Month)
data_DT &lt;- data.table(airquality2)
data_DT[, .(vifs = VIF(
  x = .SD,
  posit_y = "Ozone",
  posit_x = c("Solar.R", "Wind", "Temp", "Month", "Day", "Temp2"),
  correct = FALSE
))][["vifs.V1"]]

data_DT[, .(vifs = VIF(
  x = .SD,
  posit_y = 1,
  posit_x = c(2, 3, 4, 5, 6, 7),
  correct = TRUE
))][["vifs.V1"]]

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
