<!DOCTYPE html><html><head><title>Help for package treats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {treats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#crude.bd.est'><p>Crudely estimates extinction and speciation</p></a></li>
<li><a href='#dispRitreats'><p>dispRity interface for treats objects</p></a></li>
<li><a href='#drop.things'><p>Drop things from a treats object</p></a></li>
<li><a href='#events.conditions'><p>events.conditions</p></a></li>
<li><a href='#events.modifications'><p>Events modifications</p></a></li>
<li><a href='#make.bd.params'><p>Make birth death parameters</p></a></li>
<li><a href='#make.events'><p>make.events</p></a></li>
<li><a href='#make.modifiers'><p>make.modifiers</p></a></li>
<li><a href='#make.traits'><p>make.traits</p></a></li>
<li><a href='#make.treats'><p>Make a treats object</p></a></li>
<li><a href='#map.traits'><p>Maps a trait on a tree</p></a></li>
<li><a href='#modifiers'><p>Modifiers</p></a></li>
<li><a href='#parent.traits'><p>Get parent traits</p></a></li>
<li><a href='#plot.treats'><p>Plot treats objects</p></a></li>
<li><a href='#print.treats'><p>Prints a <code>treats</code> object.</p></a></li>
<li><a href='#trait.process'><p>Trait processes</p></a></li>
<li><a href='#transition.matrix'><p>Makes a transition matrix</p></a></li>
<li><a href='#treats'><p>Diversity and disparity simulator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Trees and Traits Simulations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-24</td>
</tr>
<tr>
<td>Description:</td>
<td>A modular package for simulating phylogenetic trees and species traits jointly. Trees can be simulated using modular birth-death parameters (e.g. changing starting parameters or algorithm rules). Traits can be simulated in any way designed by the user. The growth of the tree and the traits can influence each other through modifiers objects providing rules for affecting each other. Finally, events can be created to modify both the tree and the traits under specific conditions. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), ape, dispRity, stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, MASS, methods, utils, rgl,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TGuillerme/treats">https://github.com/TGuillerme/treats</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-24 10:24:44 UTC; tguillerme</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Guillerme <a href="https://orcid.org/0000-0003-4325-1275"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Guillerme &lt;guillert@tcd.ie&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-24 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='crude.bd.est'>Crudely estimates extinction and speciation</h2><span id='topic+crude.bd.est'></span>

<h3>Description</h3>

<p>Very crudely estimates the extinction and speciaton rate of a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crude.bd.est(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crude.bd.est_+3A_tree">tree</code></td>
<td>
<p>a <code>"phylo"</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the extinction rate as the number of extinction events in the tree divided by the tree age (expressed in tree age units - e.g. million years). The speciation rate is calculated as the number of speciation events divided by the tree age. If the input tree has no <code>$root.time</code> element, the speciation and extinction rate are just the number of speciation and extinction events.
<em>NOTE</em> that this function is a very crude way to estimate rates of extinction and speciation: the rates are calculated from the raw data (not estimated), ignore sampling biases of the data and the variability in rates. For correct model base approaches see for example <code><a href="ape.html#topic+birthdeath">birthdeath</a></code> or <code><a href="ape.html#topic+bd.ext">bd.ext</a></code>.
</p>


<h3>Value</h3>

<p>A <code>"bd.params"</code> object to be fed to <code><a href="#topic+treats">treats</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code> <code><a href="#topic+make.bd.params">make.bd.params</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
## Generating a random tree
my_tree &lt;- rtree(20)
## Calculating the number of speciations and extinctions events
crude.bd.est(my_tree)

## Adding a root time
my_tree$root.time &lt;- 5
## Calculating the number of speciations and extinctions
## per units of time
crude.bd.est(my_tree)

</code></pre>

<hr>
<h2 id='dispRitreats'>dispRity interface for treats objects</h2><span id='topic+dispRitreats'></span>

<h3>Description</h3>

<p>Pass a <code>treats</code> object to the <code>dispRity</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispRitreats(data, ..., scale.trees = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispRitreats_+3A_data">data</code></td>
<td>
<p>an output from <code>treats</code> containing tree and traits data.</p>
</td></tr>
<tr><td><code id="dispRitreats_+3A_...">...</code></td>
<td>
<p>any other arguments to be passed to <code><a href="dispRity.html#topic+dispRity">dispRity</a></code>, <code><a href="dispRity.html#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="dispRity.html#topic+custom.subsets">custom.subsets</a></code>, and <code><a href="dispRity.html#topic+boot.matrix">boot.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="dispRitreats_+3A_scale.trees">scale.trees</code></td>
<td>
<p>logical, whether to scale the tree ages in all simulations (<code>TRUE</code>; default) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies the <code>dispRity</code> package pipeline to the <code>treats</code> output. If multiple simulations are input, the data is scaled for all the simulations.
</p>
<p>The <code>scale.trees</code> option allows the trees to have the same depth and root age. This option is recommended if <code><a href="dispRity.html#topic+chrono.subsets">chrono.subsets</a></code> options are called to make the output results comparable.
</p>
<p>Common optional arguments for the following arguments include the following (refer the the specific function for the arguments details):
</p>

<ul>
<li> <p><code><a href="dispRity.html#topic+custom.subsets">custom.subsets</a></code>: <code>group</code> for the list of elements to be attributed to specific groups;
</p>
</li>
<li> <p><code><a href="dispRity.html#topic+chrono.subsets">chrono.subsets</a></code>: <code>method</code> for selecting the time binning or slicing method; <code>time</code> for the number of time bins/slices or their specific ages; <code>model</code> for the time slicing method; or <code>inc.nodes</code> for whether to include nodes or not in the time subsets;
</p>
</li>
<li> <p><code><a href="dispRity.html#topic+boot.matrix">boot.matrix</a></code>: <code>bootstraps</code> for the number of bootstrap replicates; <code>rarefaction</code> for the number of elements to include in each bootstrap replicate; or <code>boot.type</code> for the bootstrap algorithm;
</p>
</li>
<li> <p><code><a href="dispRity.html#topic+dispRity">dispRity</a></code>: <code>metric</code> for the disparity, dissimilarity or spatial occupancy metric to apply to the data; or <code>dimensions</code> for the number of dimensions to consider.
</p>
</li></ul>



<h3>Value</h3>

<p>Outputs a <code>"dispRity"</code> object that can be plotted, summarised or manipulated with the <code>dispRity</code> package.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code> <code><a href="dispRity.html#topic+dispRity">dispRity</a></code> <code><a href="dispRity.html#topic+chrono.subsets">chrono.subsets</a></code> <code><a href="dispRity.html#topic+custom.subsets">custom.subsets</a></code> <code><a href="dispRity.html#topic+boot.matrix">boot.matrix</a></code> <code><a href="dispRity.html#topic+plot.dispRity">plot.dispRity</a></code> <code><a href="dispRity.html#topic+summary.dispRity">summary.dispRity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a random tree with a 10 dimensional Brownian Motion trait
my_treats &lt;- treats(stop.rule = list("max.taxa" = 20),
                    traits    = make.traits(BM.process, n = 10),
                    bd.params = make.bd.params(speciation = 1))

## Calculating disparity as the sum of variances
disparity &lt;- dispRitreats(my_treats, metric = c(sum, variances))
summary(disparity)

## Calculating disparity as the mean distance from the centroid of
## coordinates 42 (metric = c(mean, centroids), centroid = 42)
## using 100 bootstrap replicates (bootstrap = 100) and 
## chrono.subsets (method = "continuous", model = "acctran", time = 5)
disparity &lt;- dispRitreats(my_treats,
                          metric = c(mean, centroids), centroid = 42,
                          bootstraps = 100,
                          method = "continuous", model = "acctran", time = 5)
plot(disparity)

## Simulate 20 random trees with a 10 dimensional Brownian Motion trait
my_treats &lt;- treats(stop.rule = list("max.taxa" = 20),
                    traits    = make.traits(BM.process, n = 10),
                    bd.params = make.bd.params(speciation = 1))

## Calculating disparity on all these trees as the sum of variance
## on 5 continuous proximity time subsets
disparity &lt;- dispRitreats(my_treats, metric = c(sum, variances),
                          method = "continuous", model = "proximity", time = 5)
plot(disparity)

</code></pre>

<hr>
<h2 id='drop.things'>Drop things from a treats object</h2><span id='topic+drop.things'></span><span id='topic+drop.singles'></span><span id='topic+drop.fossils'></span><span id='topic+drop.livings'></span>

<h3>Description</h3>

<p>Remove fossils or living species or non-bifurcating nodes (singles) from <code>treats</code> objects or <code>phylo</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop.things(treats, what)

drop.fossils(treats)

drop.livings(treats)

drop.singles(treats)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop.things_+3A_treats">treats</code></td>
<td>
<p><code>treats</code> data.</p>
</td></tr>
<tr><td><code id="drop.things_+3A_what">what</code></td>
<td>
<p>what to drop. Can be <code>"fossils"</code>, <code>"livings"</code> or <code>"singles"</code> (non-bifurcating nodes).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>NOTE</em> that dropping living or fossils species DOES NOT drop associated internal nodes and edge lengths. To drop both fossil/living taxa AND internal nodes, you can use for example: <code>drop.things(drop.things(my_data, what = "fossils"), what = "singles")</code>.
</p>


<h3>Value</h3>

<p>This function outputs either a <code>"phylo"</code> object if no traits where generated or a <code>treats</code> object that is a list of at least two elements: <code>$tree</code>, a <code>"phylo"</code> object and <code>$data</code>, a <code>"matrix"</code> of the trait values.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code> <code><a href="#topic+plot.treats">plot.treats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A random tree with fossils and traits and internal nodes every 0.5 times
set.seed(3)
my_data &lt;- treats(stop.rule = list(max.taxa = 20),
                bd.params = list(speciation = 1, extinction = 1/3),
                traits    = make.traits(), save.steps = 0.5)

## A tree with 20 tips and 54 nodes
my_data$tree
## And a dataset with 74 rows
dim(my_data$data)

## Removing the fossil species
drop.things(my_data, what = "fossils")$tree
dim(drop.fossils(my_data)$data)

## Removing the living species
drop.things(my_data, what = "livings")$tree
dim(drop.livings(my_data)$data)

## Removing the internal nodes
drop.things(my_data, what = "singles")$tree
dim(drop.singles(my_data)$data)

## Removing the internal nodes AND the fossils
drop.singles(drop.fossils(my_data))

</code></pre>

<hr>
<h2 id='events.conditions'>events.conditions</h2><span id='topic+events.conditions'></span><span id='topic+events.condition'></span><span id='topic+age.condition'></span><span id='topic+taxa.condition'></span><span id='topic+trait.condition'></span>

<h3>Description</h3>

<p>Inbuilt conditions functions for helping designing events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>events.condition(x, condition, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="events.conditions_+3A_x">x</code></td>
<td>
<p>the variable to reach for satisfying a condition (see details)</p>
</td></tr>
<tr><td><code id="events.conditions_+3A_condition">condition</code></td>
<td>
<p>the logical function for triggering the condition (e.g. '&lt;', '==', '!&gt;', etc...).</p>
</td></tr>
<tr><td><code id="events.conditions_+3A_...">...</code></td>
<td>
<p>any optional argument specific for that condition (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following functions allow to design specific conditions for events:
</p>

<ul>
<li><p><code>age.condition</code>: a conditional function based on the time <code>x</code>. Typically this can be translated into &quot;when time reaches the value x, trigger a condition&quot; (see <code><a href="#topic+make.events">make.events</a></code>). There is no optional argument for the function.
</p>
</li>
<li><p><code>taxa.condition</code>: a conditional function based on the number of taxa <code>x</code>. Typically this can be  translated into &quot;when the number of taxa reaches the value x, trigger a condition&quot; (see <code><a href="#topic+make.events">make.events</a></code>). This function has one optional argument:
</p>

<ul>
<li><p>living, a <code>logical</code> argument whether to consider the number of taxa alive when the condition is checked (default: <code>living = TRUE</code>) or whether to consider all the taxa simulated so far (<code>living = FALSE</code>).
</p>
</li></ul>

</li>
<li><p><code>trait.condition</code>: a conditional function based on the value <code>x</code> of one or more traits. Typically this can be  translated into &quot;when a trait reaches a value x, trigger a condition&quot; (see <code><a href="#topic+make.events">make.events</a></code>). This function has three optional argument:
</p>

<ul>
<li><p>trait, one or more <code>integer</code> or <code>numeric</code> value designating the trait(s) to consider. By default, <code>trait = 1</code>, thus considering only the first trait to trigger the condition.
</p>
</li>
<li><p>what, a <code>function</code> designating what to select from the trait values. By default <code>what = max</code> to select the maximal value of the trait when the condition is triggered (but you can use any function like <code><a href="base.html#topic+min">min</a></code>, <code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+sd">sd</a></code>, etc. or provide your own function).
</p>
</li>
<li><p>absolute, a <code>logical</code> designating to consider absolute trait values (<code>TRUE</code>) or not (default; <code>FALSE</code>).
</p>
</li></ul>

</li></ul>

<p>More details about the <code>events</code> functions is explained in the <code>treats</code> manual: <a href="http://tguillerme.github.io/treats">http://tguillerme.github.io/treats</a>.
</p>


<h3>Value</h3>

<p>This function outputs a <code>"function"</code> to be passed to <code><a href="#topic+make.events">make.events</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code> <code><a href="#topic+make.events">make.events</a></code> <code><a href="#topic+events.modifications">events.modifications</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generating a mass extinction
## 80% mass extinction at time 4
mass_extinction &lt;- make.events(
                      target       = "taxa",
                      condition    = age.condition(4),
                      modification = random.extinction(0.8))

## Set the simulation parameters
stop.rule &lt;- list(max.time = 5)
bd.params &lt;- list(extinction = 0, speciation = 1)

## Run the simulations
set.seed(123)
results &lt;- treats(bd.params = bd.params,
                stop.rule = stop.rule,
                events    = mass_extinction)
## Plot the results
plot(results, show.tip.label = FALSE)
axisPhylo()

## Changing the trait process
## The 95% upper quantile value of a distribution
upper.95 &lt;- function(x) {
    return(quantile(x, prob = 0.95))
} 
## Create an event to change the trait process
change_process &lt;- make.events(
                  target       = "traits",
                  ## condition is triggered if(upper.95(x) &gt; 3)
                  condition    = trait.condition(3, condition = `&gt;`, what = upper.95),
                  modification = traits.update(process = OU.process))

## Set the simulation parameters
bd.params &lt;- list(extinction = 0, speciation = 1)
stop.rule &lt;- list(max.time = 6)
traits    &lt;- make.traits()

## Run the simulations
set.seed(1)
no_change &lt;- treats(bd.params = bd.params,
                  stop.rule = stop.rule,
                  traits    = traits)
set.seed(1)
process_change &lt;- treats(bd.params = bd.params,
                       stop.rule = stop.rule,
                       traits    = traits,
                       events    = change_process)
## Plot the results
oldpar &lt;- par(mfrow = c(1,2))
plot(no_change, ylim = c(-7, 7))
plot(process_change, ylim = c(-7, 7))
par(oldpar)

</code></pre>

<hr>
<h2 id='events.modifications'>Events modifications</h2><span id='topic+events.modifications'></span><span id='topic+events.modification'></span><span id='topic+random.extinction'></span><span id='topic+trait.extinction'></span><span id='topic+bd.params.update'></span><span id='topic+traits.update'></span><span id='topic+modifiers.update'></span><span id='topic+founding.event'></span>

<h3>Description</h3>

<p>Inbuilt modifications functions for helping designing events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>events.modification(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="events.modifications_+3A_x">x</code></td>
<td>
<p>a numerical value to update.</p>
</td></tr>
<tr><td><code id="events.modifications_+3A_...">...</code></td>
<td>
<p>any specific argument for the modification (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following functions allow to design specific modifications for events:
</p>

<ul>
<li><p> modifications for the target <code>"taxa"</code>
</p>

<ul>
<li> <p><code>random.extinction</code>: this function removes (makes extinct) a proportion of living taxa when the event is triggered. The proportion of taxa to remove can be changed with the argument <code>x</code>.
</p>
</li>
<li> <p><code>trait.extinction</code>: this function removes (makes extinct) a number of living taxa based on their trait(s) values when the event is triggered. The trait value is specified with the argument <code>x</code>.This function has one optional argument:
</p>

<ul>
<li><p>condition to specify the condition in relation to that trait value (the default is <code>condition = `&lt;`</code> meaning taxa with a trait value lower that <code>x</code> will go extinct).
</p>
</li>
<li><p>trait to specify which trait will be affected (the default is <code>trait = 1</code>, meaning it will only consider the first trait).
</p>
</li></ul>

</li></ul>

</li>
<li><p> modifications for the target <code>"bd.params"</code>
</p>

<ul>
<li> <p><code>bd.params.update</code>: this function updates a <code>"bd.params"</code> object within the birth death process. It takes any unambiguous named argument to be passed to <code><a href="#topic+make.bd.params">make.bd.params</a></code>. For example, to update the speciation from any current rate to a new rate of 42, you can use <code>bd.params.update(speciation = 42)</code>.
</p>
</li></ul>

</li>
<li><p> modifications for the target <code>"traits"</code> 
</p>

<ul>
<li> <p><code>traits.update</code>: this function updates a <code>"traits"</code> object within the birth death process. It takes any unambiguous named argument to be passed to <code><a href="#topic+make.traits">make.traits</a></code>. For example, to update the trait process from the current one to an OU process, you can use <code>traits.update(process = OU.process)</code>.
</p>
</li></ul>

</li>
<li><p> modifications for the target <code>"modifiers"</code>
</p>

<ul>
<li> <p><code>modifiers.update</code>: this function updates a <code>"modifiers"</code> object within the birth death process. It takes any unambiguous named argument to be passed to <code><a href="#topic+make.modifiers">make.modifiers</a></code>. For example, to update the speciation from the current process to be dependent to trait values, you can use <code>modifiers.update(speciation = speciation.trait)</code>.
</p>
</li></ul>

</li>
<li><p> modifications for the target <code>"founding"</code> 
</p>

<ul>
<li> <p><code>founding.event</code>: this function runs an independent birth-death process when the condition is met. This function takes any of the arguments normally passed to <code><a href="#topic+treats">treats</a></code> (<code>"bd.params"</code>, <code>"traits"</code>, <code>"modifiers"</code> and <code>"events"</code>). The <code>stop.rule</code> and other arguments are handled internally: namely the <code>stop.rule</code> argument is updated to match the time and number of taxa when the founding event is triggered. <em>Note that this can lead to the simulation stopping just before reaching the <code>max.taxa</code> or <code>max.living</code> stop rule</em>.
</p>
</li></ul>

</li></ul>

<p>More details about the <code>events</code> functions is explained in the <code>treats</code> manual: <a href="http://tguillerme.github.io/treats">http://tguillerme.github.io/treats</a>.
</p>


<h3>Value</h3>

<p>This function outputs a <code>"function"</code> to be passed to <code><a href="#topic+make.events">make.events</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code> <code><a href="#topic+make.events">make.events</a></code> <code><a href="#topic+events.conditions">events.conditions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generating a mass extinction
## 80% mass extinction at time 4
mass_extinction &lt;- make.events(
                      target       = "taxa",
                      condition    = age.condition(4),
                      modification = random.extinction(0.8))

## Set the simulation parameters
stop.rule &lt;- list(max.time = 5)
bd.params &lt;- list(extinction = 0, speciation = 1)

## Run the simulations
set.seed(123)
results &lt;- treats(bd.params = bd.params,
                stop.rule = stop.rule,
                events    = mass_extinction)
## Plot the results
plot(results, show.tip.label = FALSE)
axisPhylo()

## Changing the trait process
## The 95% upper quantile value of a distribution
upper.95 &lt;- function(x) {
    return(quantile(x, prob = 0.95))
} 
## Create an event to change the trait process
change_process &lt;- make.events(
                  target       = "traits",
                  ## condition is triggered if(upper.95(x) &gt; 3)
                  condition    = trait.condition(3, condition = `&gt;`, what = upper.95),
                  modification = traits.update(process = OU.process))

## Set the simulation parameters
bd.params &lt;- list(extinction = 0, speciation = 1)
stop.rule &lt;- list(max.time = 6)
traits    &lt;- make.traits()

## Run the simulations
set.seed(1)
no_change &lt;- treats(bd.params = bd.params,
                  stop.rule = stop.rule,
                  traits    = traits)
set.seed(1)
process_change &lt;- treats(bd.params = bd.params,
                       stop.rule = stop.rule,
                       traits    = traits,
                       events    = change_process)
## Plot the results
oldpar &lt;- par(mfrow = c(1,2))
plot(no_change, ylim = c(-7, 7))
plot(process_change, ylim = c(-7, 7))
par(oldpar)


</code></pre>

<hr>
<h2 id='make.bd.params'>Make birth death parameters</h2><span id='topic+make.bd.params'></span>

<h3>Description</h3>

<p>Making bd.params objects for treats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.bd.params(
  speciation = NULL,
  extinction = NULL,
  joint = NULL,
  absolute = NULL,
  speciation.args = NULL,
  extinction.args = NULL,
  test = TRUE,
  update = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.bd.params_+3A_speciation">speciation</code></td>
<td>
<p>The speciation parameter. Can be a single <code>numeric</code> value, a <code>numeric</code> vector or a <code>function</code> (default is <code>1</code>).</p>
</td></tr>
<tr><td><code id="make.bd.params_+3A_extinction">extinction</code></td>
<td>
<p>The extinction parameter. Can be a single <code>numeric</code> value, a <code>numeric</code> vector or a <code>function</code> (default is <code>0</code>).</p>
</td></tr>
<tr><td><code id="make.bd.params_+3A_joint">joint</code></td>
<td>
<p>Logical, whether to estimate both birth and death parameter jointly with speciation &gt; extinction (<code>TRUE</code>) or not (<code>FALSE</code>; default).</p>
</td></tr>
<tr><td><code id="make.bd.params_+3A_absolute">absolute</code></td>
<td>
<p>Logical, whether always return absolute values (<code>TRUE</code>) or not (<code>FALSE</code>; default).</p>
</td></tr>
<tr><td><code id="make.bd.params_+3A_speciation.args">speciation.args</code></td>
<td>
<p>If <code>speciation</code> is a function, any additional arguments to passed to the <code>speciation</code> function.</p>
</td></tr>
<tr><td><code id="make.bd.params_+3A_extinction.args">extinction.args</code></td>
<td>
<p>If <code>speciation</code> is a function, any additional arguments to passed to the <code>speciation</code> function.</p>
</td></tr>
<tr><td><code id="make.bd.params_+3A_test">test</code></td>
<td>
<p>Logical whether to test if the bd.params object will work (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="make.bd.params_+3A_update">update</code></td>
<td>
<p>Optional, another previous <code>"treats"</code> <code>"bd.params"</code> object to update (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code>update</code>, the provided arguments (to <code>make.bd.params</code>) will be the ones updated in the <code>"bd.params"</code> object.
</p>


<h3>Value</h3>

<p>This function outputs a <code>treats</code> object that is a named list of elements handled internally by the <code><a href="#topic+treats">treats</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A default set of birth death parameters
make.bd.params()

## Speciation is randomly picked between 1, 10 and 100
## and extinction is always 2
make.bd.params(speciation = c(1,10,100), extinction = 2)

## Speciation is a normal distribution(with sd = 0.75)
## and extinction is a lognormal distribution always lower than
## speciation (joint). Both are always positive values (absolute)
my_bd_params &lt;- make.bd.params(speciation = rnorm,
                               speciation.args = list(sd = 0.75),
                               extinction = rlnorm,
                               joint = TRUE,
                               absolute = TRUE)
my_bd_params

## Visualising the distributions
plot(my_bd_params)


</code></pre>

<hr>
<h2 id='make.events'>make.events</h2><span id='topic+make.events'></span>

<h3>Description</h3>

<p>Making events objects for treats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.events(
  target,
  condition,
  modification,
  add,
  test = TRUE,
  event.name,
  replications = 0,
  additional.args
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.events_+3A_target">target</code></td>
<td>
<p>What to modify, can be <code>"taxa"</code>, <code>"bd.params"</code>, <code>"traits"</code> or <code>"modifiers"</code> (see details).</p>
</td></tr>
<tr><td><code id="make.events_+3A_condition">condition</code></td>
<td>
<p>A <code>function</code> returning a logical to trigger the event (see details).</p>
</td></tr>
<tr><td><code id="make.events_+3A_modification">modification</code></td>
<td>
<p>A <code>function</code> bringing the modification to the event (see details).</p>
</td></tr>
<tr><td><code id="make.events_+3A_add">add</code></td>
<td>
<p>Another <code>"events"</code> to object to add this event.</p>
</td></tr>
<tr><td><code id="make.events_+3A_test">test</code></td>
<td>
<p>A <code>logical</code>, whether to test if the events object will work (default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="make.events_+3A_event.name">event.name</code></td>
<td>
<p>Optional, a <code>"character"</code> string to name the event.</p>
</td></tr>
<tr><td><code id="make.events_+3A_replications">replications</code></td>
<td>
<p>A numeric or integer value for repeating the event (by default, the event is not repeated: <code>replications = 0</code>).</p>
</td></tr>
<tr><td><code id="make.events_+3A_additional.args">additional.args</code></td>
<td>
<p>Optional, a named <code>list</code> of additional arguments to be used in the event.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>target</code> is a <code>character</code> to designate what will be affected by the event. It can be either <code>"taxa"</code>, <code>"bd.params"</code>, <code>"traits"</code> or <code>"modifiers"</code>. This means that the <code>condition</code> and <code>modification</code> functions will target this specific part of the algorithm.
</p>
<p><code>condition</code> must be a function that returns a <code>logical</code> value and intakes any of the following arguments: <code>bd.params</code>, <code>lineage</code>, <code>traits</code> and <code>time</code>. See <code><a href="#topic+events.conditions">events.conditions</a></code> for examples.
</p>
<p><code>modification</code> must be a function that intakes a first argument named <code>"x"</code> an returns any specific type of class that can be handled internally by treats. For example, if <code>target = "bd.params"</code> the <code>modification</code> function should typically return an updated <code>bd.params</code> object (see <code><a href="#topic+make.bd.params">make.bd.params</a></code>). See <code><a href="#topic+events.modifications">events.modifications</a></code> for examples.
</p>


<h3>Value</h3>

<p>This function outputs a <code>treats</code> object that is a named list of elements handled internally by the <code><a href="#topic+treats">treats</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code> <code><a href="#topic+make.bd.params">make.bd.params</a></code> <code><a href="#topic+make.traits">make.traits</a></code> <code><a href="#topic+make.modifiers">make.modifiers</a></code> <code><a href="#topic+events.conditions">events.conditions</a></code> <code><a href="#topic+events.modifications">events.modifications</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generating a mass extinction
## 80% mass extinction at time 4
mass_extinction &lt;- make.events(
                      target       = "taxa",
                      condition    = age.condition(4),
                      modification = random.extinction(0.8))

## Set the simulation parameters
stop.rule &lt;- list(max.time = 5)
bd.params &lt;- list(extinction = 0, speciation = 1)

## Run the simulations
set.seed(123)
results &lt;- treats(bd.params = bd.params,
                stop.rule = stop.rule,
                events    = mass_extinction)
## Plot the results
plot(results, show.tip.label = FALSE)
axisPhylo()

## Changing the trait process
## The 95% upper quantile value of a distribution
upper.95 &lt;- function(x) {
    return(quantile(x, prob = 0.95))
} 
## Create an event to change the trait process
change_process &lt;- make.events(
                  target       = "traits",
                  ## condition is triggered if(upper.95(x) &gt; 3)
                  condition    = trait.condition(3, condition = `&gt;`, what = upper.95),
                  modification = traits.update(process = OU.process))

## Set the simulation parameters
bd.params &lt;- list(extinction = 0, speciation = 1)
stop.rule &lt;- list(max.time = 6)
traits    &lt;- make.traits()

## Run the simulations
set.seed(1)
no_change &lt;- treats(bd.params = bd.params,
                  stop.rule = stop.rule,
                  traits    = traits)
set.seed(1)
process_change &lt;- treats(bd.params = bd.params,
                       stop.rule = stop.rule,
                       traits    = traits,
                       events    = change_process)
## Plot the results
oldpar &lt;- par(mfrow = c(1,2))
plot(no_change, ylim = c(-7, 7))
plot(process_change, ylim = c(-7, 7))
par(oldpar)

</code></pre>

<hr>
<h2 id='make.modifiers'>make.modifiers</h2><span id='topic+make.modifiers'></span>

<h3>Description</h3>

<p>Making modifiers objects for treats based on an ancestor's (parent) trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.modifiers(
  branch.length = NULL,
  selection = NULL,
  speciation = NULL,
  condition = NULL,
  modify = NULL,
  add = NULL,
  update = NULL,
  test = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.modifiers_+3A_branch.length">branch.length</code></td>
<td>
<p>A function for the waiting time generating branch length (can be left empty for the defeault branch length function; see details).</p>
</td></tr>
<tr><td><code id="make.modifiers_+3A_selection">selection</code></td>
<td>
<p>A function for selecting the lineage(s) affected by speciation (can be left empty for the default selection function; see details).</p>
</td></tr>
<tr><td><code id="make.modifiers_+3A_speciation">speciation</code></td>
<td>
<p>A function for triggering the speciation events (can be left empty for the default speciation function; see details).</p>
</td></tr>
<tr><td><code id="make.modifiers_+3A_condition">condition</code></td>
<td>
<p>A function giving the condition on which to modify the output of <code>branch.length</code> or <code>speciation</code> (see details). If <code>NULL</code> the condition is always met.</p>
</td></tr>
<tr><td><code id="make.modifiers_+3A_modify">modify</code></td>
<td>
<p>A function giving the rule of how to modify the output of <code>branch.length</code> or <code>speciation</code> (see details). If <code>NULL</code> no modification is used.</p>
</td></tr>
<tr><td><code id="make.modifiers_+3A_add">add</code></td>
<td>
<p>Whether to add this modifier to a <code>"treats"</code> <code>"modifier"</code> object.</p>
</td></tr>
<tr><td><code id="make.modifiers_+3A_update">update</code></td>
<td>
<p>Optional, another previous <code>"treats"</code> modifiers object to update (see details).</p>
</td></tr>
<tr><td><code id="make.modifiers_+3A_test">test</code></td>
<td>
<p>Logical whether to test if the modifiers object will work (default is TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>branch.length</code>, <code>selection</code> and <code>speciation</code> must be a functions that intakes the following arguments: <code>bd.params, lineage, trait.values, modify.fun</code>. If left empty, any of these arguments is considered as NULL.
</p>
<p>The default <code>branch.length</code> function is drawing a random number from the exponantial distribution with a rate equal to the current number of taxa multiplied by the speciation and extinction (<code>rexp(1, n_taxa * (speciation + extinction))</code>).
</p>
<p>The default <code>selection</code> function is randomly drawing a single lineage among the ones present at the time of the speciation (<code>sample(n_taxa, 1)</code>).
</p>
<p>The default <code>speciation</code> function is drawing a random number from a uniform distribution (0,1) and starts a speciation event if this random number is lower than the ration of speciation on speciation and extinction (<code>runif(1) &lt; (speciation/(speciation + extinction))</code>). If the random number is greater, the lineage goes extinct.
</p>
<p><code>condition</code> must be a function with unambiguous input (the inputs listed about for <code>branch.length</code> and <code>speciation</code>) and must output a single <code>logical</code> value. 
</p>
<p>For example a conditional on the number of taxa:
</p>
<p><code>condition = function(lineage) return(lineage$n &lt; 1)</code>
</p>
<p>or a conditional on the trait values:
</p>
<p><code>condition = function(trait.values, lineage)</code>
<code>    {</code>
<code>    parent.traits(trait.values, lineage) &lt; mean(trait.values)</code>
<code>    }</code>
</p>
<p><code>modify</code> must be a function with at least one input named <code>x</code> (which will be the branch length or the speciation trigger to value depending on the modifier) and must return a <code>numeric</code> value.
For example a constant modification of the input:
</p>
<p><code>modify = function(x) return(x * 2)</code>
</p>
<p>or a modifier depending on the number of taxa:
</p>
<p><code>modify = function(x, lineage) return(x/lineage$n)</code>
</p>
<p>When using <code>update</code>, the provided arguments (to <code>make.modifiers</code>) will be the ones updated in the <code>"modifiers"</code> object.
If the <code>"modifiers"</code> object contains multiple modifiers (<code>branch.length</code>, <code>selection</code> or <code>speciation</code>), only the called arguments will be updated (e.g. <code>make.modifiers(update = previous_modifiers, speciation = new_speciation)</code> will only update the speciation process).
</p>
<p>More details about the <code>modifiers</code> functions is explained in the <code>treats</code> manual: <a href="http://tguillerme.github.io/treats">http://tguillerme.github.io/treats</a>.
</p>


<h3>Value</h3>

<p>This function outputs a <code>treats</code> object that is a named list of elements handled internally by the <code><a href="#topic+treats">treats</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code> <code><a href="#topic+modifiers">modifiers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## These functions should be fed to the make.modifiers function to create
## modifiers for treats objects. For example, the following sets specifies that
## the branch length should be generated using the branch.length.trait function
## the selection using the selection function and the speciation using the
## speciation.trait function:
my_modifiers &lt;- make.modifiers(branch.length = branch.length.trait,
                               selection     = selection,
                               speciation    = speciation.trait)

## Creating a treats simulation using these modifiers
treats(stop.rule = list(max.taxa = 20),
     traits = make.traits(),
     modifiers = my_modifiers)

</code></pre>

<hr>
<h2 id='make.traits'>make.traits</h2><span id='topic+make.traits'></span>

<h3>Description</h3>

<p>Making traits objects for treats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.traits(
  process = BM.process,
  n = NULL,
  start = NULL,
  process.args = NULL,
  trait.names = NULL,
  add = NULL,
  update = NULL,
  test = TRUE,
  background
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.traits_+3A_process">process</code></td>
<td>
<p>The trait process(es) (default is <code><a href="#topic+BM.process">BM.process</a></code>).</p>
</td></tr>
<tr><td><code id="make.traits_+3A_n">n</code></td>
<td>
<p>Optional, the number of traits per process (default is <code>1</code>).</p>
</td></tr>
<tr><td><code id="make.traits_+3A_start">start</code></td>
<td>
<p>Optional, the starting values for each traits (default is <code>0</code>).</p>
</td></tr>
<tr><td><code id="make.traits_+3A_process.args">process.args</code></td>
<td>
<p>Optional, a named list of optional arguments for the trait process.</p>
</td></tr>
<tr><td><code id="make.traits_+3A_trait.names">trait.names</code></td>
<td>
<p>Optional, the name(s) of the process(s).</p>
</td></tr>
<tr><td><code id="make.traits_+3A_add">add</code></td>
<td>
<p>Optional, another previous <code>"treats"</code> traits object to which to add the trait.</p>
</td></tr>
<tr><td><code id="make.traits_+3A_update">update</code></td>
<td>
<p>Optional, another previous <code>"treats"</code> traits object to update (see details).</p>
</td></tr>
<tr><td><code id="make.traits_+3A_test">test</code></td>
<td>
<p>Logical, whether to test if the traits object will work with <code><a href="#topic+treats">treats</a></code> (<code>TRUE</code> - default).</p>
</td></tr>
<tr><td><code id="make.traits_+3A_background">background</code></td>
<td>
<p>Optional, another <code>"treats"</code> <code>"traits"</code> object to simulate background trait evolution (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code>update</code>, the provided arguments (to <code>make.traits</code>) will be the ones updated in the <code>"traits"</code> object.
If the <code>"traits"</code> object contains multiple processes, you can specify which ones should be affected with the <code>trait.names</code> argument.
Note that you cannot update the <code>traits.names</code> or the number of traits per processes (<code>n</code>) not use the <code>add</code> argument when updating a <code>"traits"</code> object.
</p>
<p>If a <code>background</code> <code>"traits"</code> object is given, this object is then applied to all living edges at the same in the background while the main <code>"traits"</code> is computed. 
</p>
<p>More details about the <code>"treats"</code> <code>"traits"</code> objects is explained in the <code>treats</code> manual: <a href="http://tguillerme.github.io/treats">http://tguillerme.github.io/treats</a>.
</p>


<h3>Value</h3>

<p>This function outputs a <code>treats</code> object that is a named list of elements handled internally by the <code><a href="#topic+treats">treats</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code> <code><a href="#topic+trait.process">trait.process</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A simple Brownian motion trait (default)
make.traits()

## Two independent Brownian motion traits
make.traits(n = 2)

## Two different traits with different process
## (Brownian motion and Ornstein-Uhlenbeck)
make.traits(process = list(BM.process, OU.process))

## A multidimensional Brownian motion trait with correlation
## and different starting points
my_correlations &lt;- matrix(1/3, ncol = 3, nrow = 3)
(my_traits &lt;- make.traits(n = 3, start = c(0, 1, 3),
                          process.args = list(Sigma = my_correlations)))

## Adding a Ornstein-Uhlenbeck trait to the previous trait object
make.traits(process = OU.process, trait.names = "OU_trait",
            add = my_traits)

</code></pre>

<hr>
<h2 id='make.treats'>Make a treats object</h2><span id='topic+make.treats'></span>

<h3>Description</h3>

<p>Combines a tree and some associated data into a treats object (e.g. for plotting)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.treats(tree, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.treats_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree.</p>
</td></tr>
<tr><td><code id="make.treats_+3A_data">data</code></td>
<td>
<p>a dataset of traits, either a <code>matrix</code> with column names or a named <code>vector</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function outputs a <code>treats</code> object that is a list of at least two elements: <code>$tree</code>, a <code>"phylo"</code> object and <code>$data</code>, a <code>"matrix"</code> of the trait values.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code> <code><a href="#topic+plot.treats">plot.treats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a random tree
my_tree &lt;- rtree(5)
## Adding node labels
my_tree$node.label &lt;- letters[1:4]
## Creating a random dataset
my_data &lt;- matrix(rnorm(9),
    dimnames = list(c(my_tree$tip.label, my_tree$node.label)))
## Creating the treats object
my_treats &lt;- make.treats(tree = my_tree, data = my_data)
plot(my_treats)

</code></pre>

<hr>
<h2 id='map.traits'>Maps a trait on a tree</h2><span id='topic+map.traits'></span>

<h3>Description</h3>

<p>Simulates one or more trait specified through a &quot;traits&quot; onto one or multiple trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.traits(traits, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.traits_+3A_traits">traits</code></td>
<td>
<p>A <code>"traits"</code> object (see <code><a href="#topic+make.traits">make.traits</a></code>).</p>
</td></tr>
<tr><td><code id="map.traits_+3A_tree">tree</code></td>
<td>
<p>A <code>"phylo"</code> or <code>"multiPhylo"</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates the trait(s) on the tree using the tree's branch length.
</p>


<h3>Value</h3>

<p>A <code>"treats"</code> object containing the tree and the traits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulating a random tree with branch length
my_tree &lt;- rtree(20)

## Creating three different traits objects:
## A Brownian Motion
bm_process &lt;- make.traits(process = BM.process)
## An Ornstein-Uhlenbeck process
ou_process &lt;- make.traits(process = OU.process)
## No process (just randomly drawing values from a normal distribution)
no_process &lt;- make.traits(process = no.process)

## Mapping the three traits on the phylogeny
bm_traits &lt;- map.traits(bm_process, my_tree)
ou_traits &lt;- map.traits(ou_process, my_tree)
no_traits &lt;- map.traits(no_process, my_tree)

## Plotting the topology and the different traits
oldpar &lt;- par(mfrow = c(2,2))
plot(my_tree, main = "Base topology")
plot(bm_traits, main = "Mapped BM")
plot(ou_traits, main = "Mapped OU")
plot(no_traits, main = "Mapped normal trait")
par(oldpar)

</code></pre>

<hr>
<h2 id='modifiers'>Modifiers</h2><span id='topic+modifiers'></span><span id='topic+branch.length'></span><span id='topic+selection'></span><span id='topic+speciation'></span><span id='topic+branch.length.trait'></span><span id='topic+speciation.trait'></span>

<h3>Description</h3>

<p>Different modifiers for the birth death process implemented in treats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifiers(bd.params = NULL, lineage = NULL, trait.values = NULL,
                     modify.fun = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modifiers_+3A_bd.params">bd.params</code></td>
<td>
<p>A named list of birth death parameters (see details).</p>
</td></tr>
<tr><td><code id="modifiers_+3A_lineage">lineage</code></td>
<td>
<p>A named list containing the lineage data (see details).</p>
</td></tr>
<tr><td><code id="modifiers_+3A_trait.values">trait.values</code></td>
<td>
<p>A matrix containing the trait values (see details).</p>
</td></tr>
<tr><td><code id="modifiers_+3A_modify.fun">modify.fun</code></td>
<td>
<p>A list of internals functions that can modified by <code>events</code> (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bd.params</code> can be either a named list of parameter values (e.g. <code>list("extinction" = 0, "speciation" = 1)</code>) but it is typically handled internally from a <code>"treats"</code> <code>"bd.params"</code> object.
</p>
<p><code>modifiers</code> are functions passed to the birth death process in <code><a href="#topic+treats">treats</a></code> to either generate the branch length (named <code>branch.length</code> and similar) or to decide whether to speciate or go extinct (named <code>speciation</code> and similar).
</p>
<p>For user defined functions, the <code>modifiers</code> <em>must</em> have at least the arguments described above. For safety, we suggest setting these arguments to <code>NULL</code>.
</p>
<p>The pre-build <code>modifiers</code> in the <code>treats</code> package are (so far):
</p>

<ul>
<li> <p><code>branch.length</code> the simple branch length generator that randomly gets a numeric value drawn from the exponential distribution (<code><a href="stats.html#topic+rexp">rexp</a></code>) with a rate equal to the number of taxa (<code>lineage$n * bd.params$speciation + bd.params$extinction</code>).
</p>
</li>
<li> <p><code>branch.length.trait</code> a modification of the <code>branch.length</code> <code>modifier</code> where the resulting branch length is changed by <code>modify.fun$modify</code> if the parent trait(s) meet the condition <code>modify.fun$condition</code>.
</p>
</li>
<li> <p><code>selection</code> a function returning a randomly sampled integer among the number of taxa available.
</p>
</li>
<li> <p><code>speciation</code> a function returning <code>TRUE</code> (speciation) if a random uniform number (<code><a href="stats.html#topic+runif">runif</a></code>) is smaller than the ratio of speciation by speciation and extinction (<code>bd.params$speciation / (bd.params$speciation) + bd.params$extinction</code>). If it's bigger, the function returns <code>FALSE</code> (exinction).
</p>
</li>
<li> <p><code>speciation.trait</code> a modification of the <code>speciation</code> <code>modifier</code> where the random uniform number is changed by <code>modify.fun$modify</code> if the parent trait(s) meet the condition <code>modify.fun$condition</code>.
</p>
</li></ul>

<p>More details about the <code>modifiers</code> functions is explained in the <code>treats</code> manual: <a href="http://tguillerme.github.io/treats">http://tguillerme.github.io/treats</a>.
</p>


<h3>Value</h3>

<p>These functions returns either <code>"numeric"</code> or <code>"logical"</code> values to be passed to <code><a href="#topic+make.modifiers">make.modifiers</a></code> and <code><a href="#topic+treats">treats</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code> <code><a href="#topic+make.modifiers">make.modifiers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## These functions should be fed to the make.modifiers function to create
## modifiers for treats objects. For example, the following sets specifies that
## the branch length should be generated using the branch.length.trait function
## the selection using the selection function and the speciation using the
## speciation.trait function:
my_modifiers &lt;- make.modifiers(branch.length = branch.length.trait,
                               selection     = selection,
                               speciation    = speciation.trait)

## Creating a treats simulation using these modifiers
treats(stop.rule = list(max.taxa = 20),
     traits = make.traits(),
     modifiers = my_modifiers)

</code></pre>

<hr>
<h2 id='parent.traits'>Get parent traits</h2><span id='topic+parent.traits'></span>

<h3>Description</h3>

<p>An internal utility function for <code>modifiers</code>, <code>traits</code> or <code>events</code> to access the value(s) of the parent traits in the <code>treats</code> algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parent.traits(trait.values, lineage, current = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parent.traits_+3A_trait.values">trait.values</code></td>
<td>
<p>The internal table of trait values</p>
</td></tr>
<tr><td><code id="parent.traits_+3A_lineage">lineage</code></td>
<td>
<p>The internal lineage data list</p>
</td></tr>
<tr><td><code id="parent.traits_+3A_current">current</code></td>
<td>
<p>Whether to consider only the current lineage (<code>TRUE</code> - default) or all the living lineages (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to be used internally in <code>treats</code> to help <code>modifiers</code>, <code>traits</code> or <code>events</code> objects to access the parent traits of the lineages simulated through the internal birth death algorithm.
</p>


<h3>Value</h3>

<p>Returns one or more <code>"numeric"</code> values.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code> <code><a href="#topic+make.modifiers">make.modifiers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Speciation event is more likely if lineage's ancestor is further away from the mean trait value
distance.modify &lt;- function(x, trait.values, lineage) {
     ## Distance to the parent's trait
     parent_trait_val &lt;- parent.traits(trait.values, lineage)[1]
     mean_trait_val &lt;- mean(trait.values[, 1])
     distance &lt;- abs(parent_trait_val - mean_trait_val)
     ## Scales x with the distance
     return(x + x * distance)
}

## Make a distance modifier (speciation more likely with distance)
distance.speciation &lt;- make.modifiers(speciation = speciation,
                                      modify = distance.modify)

</code></pre>

<hr>
<h2 id='plot.treats'>Plot treats objects</h2><span id='topic+plot.treats'></span>

<h3>Description</h3>

<p>Plotting treats objects (either a simulated tree and trait(s) or a process for traits objects)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treats'
plot(
  x,
  col,
  ...,
  trait = 1,
  edges = "grey",
  tips.nodes = NULL,
  use.3D = FALSE,
  simulations = 50,
  cent.tend = mean,
  quantiles = c(95, 50),
  legend = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.treats_+3A_x">x</code></td>
<td>
<p><code>treats</code> data.</p>
</td></tr>
<tr><td><code id="plot.treats_+3A_col">col</code></td>
<td>
<p>Optional, a vector of colours that can be named (see details).</p>
</td></tr>
<tr><td><code id="plot.treats_+3A_...">...</code></td>
<td>
<p>Any additional options to be passed to plot functions (from <code>graphics</code> or <code>rgl</code> if <code>use.3D = TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.treats_+3A_trait">trait</code></td>
<td>
<p>which trait to plot (default is <code>1</code>; see details).</p>
</td></tr>
<tr><td><code id="plot.treats_+3A_edges">edges</code></td>
<td>
<p>either a colour name to attribute to the edges or <code>NULL</code> to not display the edges (default is <code>"grey"</code>).</p>
</td></tr>
<tr><td><code id="plot.treats_+3A_tips.nodes">tips.nodes</code></td>
<td>
<p>optional, a colour to circle tips and nodes (only used if <code>use.3D = FALSE</code>). By default <code>tips.nodes = NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.treats_+3A_use.3d">use.3D</code></td>
<td>
<p>logical, whether to use a 3D plot or not (default is <code>FALSE</code>; see details).</p>
</td></tr>
<tr><td><code id="plot.treats_+3A_simulations">simulations</code></td>
<td>
<p>if the input is a <code>treats</code> <code>traits</code> or <code>bd.params</code> object, how many replicates to run (default is <code>50</code>).</p>
</td></tr>
<tr><td><code id="plot.treats_+3A_cent.tend">cent.tend</code></td>
<td>
<p>if the input is a <code>treats</code> <code>traits</code>, which central tendency to plot (default is <code>mean</code>).</p>
</td></tr>
<tr><td><code id="plot.treats_+3A_quantiles">quantiles</code></td>
<td>
<p>if the input is a <code>treats</code> <code>traits</code>, which quantiles to plot (default are <code>c(95, 50))</code>).</p>
</td></tr>
<tr><td><code id="plot.treats_+3A_legend">legend</code></td>
<td>
<p>logical, whether to display the legend in 2D plots (<code>TRUE</code>) or not (<code>FALSE</code>; default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>col</code> option can be either:
</p>

<ul>
<li><p> a <code>vector</code> of colours to be applied to <code>"treats"</code> <code>"traits"</code> objects (for respectively the median, 50
</p>
</li>
<li><p> a <code>vector</code> of colours to be applied to <code>"treats"</code> objects for the colours of different elements of the plot. This vector cycles through different elements of the the tree depending on the length of the vector: if one colour is given, it is applied to all elements; if two colours are given, the first one is applied to the nodes and the second to the tips; if three colours are given, they are applied to the nodes, fossils and living elements respectively. If more colours are given, they are applied in a gradient way to all elements depending on their age (see the <code>function</code> usage below). Note that you can always name the vector elements for avoiding ambiguities: e.g. <code>col = c("nodes" = "orange", "fossils" = "lightblue", "livings" = "blue")</code> (the default - you can use the name <code>"tips"</code> to designate both livings and fossils).
</p>
</li>
<li><p> a <code>function</code> from which to sample the colours to match the time gradient for each element.
</p>
</li></ul>

<p>The <code>trait</code> option can intake from 1 to 3 traits (if <code>use.3D = TRUE</code>). If two traits are given (e.g. <code>c(1, 2)</code>), the default plots a correlation plot between both traits (same for 3 traits if <code>use.3D = TRUE</code>).
</p>
<p>The <code>use.3D</code> option uses the <code>rgl</code> library to create a 3D plot. The plot displays either a time on the Z axis with two traits on the X and Y axis (if two traits are requested via <code>trait</code>) or three traits on the X Y and Z (if three traits a requested via <code>trait</code>).
</p>


<h3>Value</h3>

<p>No return value, plot <code>x</code>'s content.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Specifying a trait process
my_trait &lt;- make.traits()
## Plotting a trait process
plot(my_trait, main = "A Brownian Motion")

## Simulating a tree with ten taxa
my_tree &lt;- treats(stop.rule = list(max.taxa = 10))
## Plotting a simple birth death tree (using ape::plot.phylo)
plot(my_tree, main = "A pure birth tree")

## Simulating a tree with traits
my_data &lt;- treats(stop.rule = list(max.taxa = 10),
                traits    = my_trait)
## Plotting the tree and traits
plot(my_data)

## Specifying a 3D trait process
my_3D_trait &lt;- make.traits(n = 3)
## Simulating a birth death tree with that trait
my_data &lt;- treats(bd.params = list(extinction = 0.2),
                stop.rule = list(max.living = 50),
                traits    = my_3D_trait)

## Plotting the second trait and the tree (default)
## The colours are purple for nodes and blue for tips
## with a black circle for highlighting the tips
plot(my_data, trait = 2, col = c("purple", "blue"),
     edges = "pink", tips.nodes = "black")

## Plotting the first and third trait correlation
## The colours are a heat map based on the elements age
plot(my_data, trait = c(1,3), col = terrain.colors,
     edges = "grey", tips.nodes = "black")

## Plotting the first and third trait correlation in 3D
plot(my_data, trait = c(1,3), col = rainbow,
     edges = "grey", tips.nodes = "black", use.3D = TRUE)
#rglwidget() # to display the plot with non-default OpenRGL

## Plotting all traits in 3D (without branch lengths)
plot(my_data, trait = c(1:3), col = heat.colors,
     edges = NULL, tips.nodes = "black", use.3D = TRUE)
#rglwidget() # to display the plot with non-default OpenRGL

</code></pre>

<hr>
<h2 id='print.treats'>Prints a <code>treats</code> object.</h2><span id='topic+print.treats'></span>

<h3>Description</h3>

<p>Summarises the content of a <code>treats</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treats'
print(x, all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.treats_+3A_x">x</code></td>
<td>
<p>A <code>treats</code> object.</p>
</td></tr>
<tr><td><code id="print.treats_+3A_all">all</code></td>
<td>
<p><code>logical</code>; whether to display the entire object (<code>TRUE</code>) or just summarise its contents (<code>FALSE</code> - default).</p>
</td></tr>
<tr><td><code id="print.treats_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>print</code> or to <code>print.treats</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, summarises <code>x</code>'s content.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A treats birth-death parameters object
make.bd.params()
## A treats traits object
make.traits()
## A treats modifiers object
make.modifiers()
## A treats object
treats(stop.rule = list(max.taxa = 10), traits = make.traits())

</code></pre>

<hr>
<h2 id='trait.process'>Trait processes</h2><span id='topic+trait.process'></span><span id='topic+BM.process'></span><span id='topic+OU.process'></span><span id='topic+no.process'></span><span id='topic+multi.peak.process'></span><span id='topic+repulsion.process'></span><span id='topic+discrete.process'></span>

<h3>Description</h3>

<p>Different trait processes implemented in treats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trait.process(x0, edge.length, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trait.process_+3A_x0">x0</code></td>
<td>
<p>The previous state. This can be a single value (unidimensional process) or more (multidimensional processes).</p>
</td></tr>
<tr><td><code id="trait.process_+3A_edge.length">edge.length</code></td>
<td>
<p>The branch length (default must be 1). This is always a single value.</p>
</td></tr>
<tr><td><code id="trait.process_+3A_...">...</code></td>
<td>
<p>Any optional argument for the specific process (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The different trait processes implemented in treats are:
</p>

<ul>
<li><p>BM.process A Brownian motion process (uni or multidimensional). This function is based on <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code>.
This process can take following optional arguments:
</p>

<ul>
<li> <p><code>Sigma</code> a positive-definite symmetric matrix specifying the covariance matrix of the variables (default is <code>diag(length(x0))</code>).
</p>
</li>
<li> <p><code>...</code> any named additional argument to be passed to <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code>.
</p>
</li></ul>

</li>
<li><p>discrete.process
This process can take following optional arguments:
</p>

<ul>
<li> <p><code>transitions</code> a positive-definite squared transition matrix. If left missing, a 2 states equal rates matrix is used.
</p>
</li></ul>

<p>Note that for this process, 0 corresponds to state 1, 1 corresponds to state 2, etc... The current version of this process does not allow other discrete traits notation (but future versions will!).
</p>
</li>
<li><p>OU.process A Ornstein-Uhlenbeck process (uni or multidimensional). This function is based on <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code>.
This process can take following optional arguments:
</p>

<ul>
<li> <p><code>Sigma</code> the traits variance/covariance (default is <code>diag(length(x0))</code>).
</p>
</li>
<li> <p><code>alpha</code> the alpha parameter (default = is <code>1</code>).
</p>
</li>
<li> <p><code>optimum</code> the theta parameter (default = is <code>0</code>).
</p>
</li>
<li> <p><code>...</code> any named additional argument to be passed to <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code>.
</p>
</li></ul>

</li>
<li><p>no.process An non-process unidimensional function. This function generates a trait value not depending on the branch length nor the previous state
This process can take following optional arguments:
</p>

<ul>
<li> <p><code>fun</code> a random number function (default is <code><a href="stats.html#topic+rnorm">rnorm</a></code>).
</p>
</li>
<li> <p><code>...</code> any named additional argument to be passed to <code>fun</code>.
</p>
</li></ul>

</li>
<li><p>multi.peak.process A Ornstein-Uhlenbeck process (uni or multidimensional) with multiple optimal values. This function is based on <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code>.
This process can take following optional arguments:
</p>

<ul>
<li> <p><code>Sigma</code> the traits variance/covariance (default is <code>diag(length(x0))</code>).
</p>
</li>
<li> <p><code>alpha</code> the alpha parameter (default = is <code>1</code>).
</p>
</li>
<li> <p><code>peaks</code> the multiple optimal values to be attracted to (default = is <code>0</code>). This can be a <code>numeric</code> vector to be applied to all the values of <code>x0</code> or a <code>list</code> of the same length as <code>x0</code> for different multiple optimums for each <code>x0</code>.
</p>
</li>
<li> <p><code>...</code> any named additional argument to be passed to <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code>.
</p>
</li></ul>

</li>
<li><p>repulsion.process An unidimensional Brownian Motion process that generates a trait value not overlapping with the other living taxa ancestral values. This function is based on <code><a href="stats.html#topic+rnorm">rnorm</a></code>.
This process can take following optional arguments:
</p>

<ul>
<li> <p><code>sd</code> the normal distribution standard deviation.
</p>
</li>
<li> <p><code>repulsion</code> the minimal distance requested between trait values.
</p>
</li>
<li> <p><code>max.try</code> the maximum number of values to draw (if the repulsion value is to hard to achieve).
</p>
</li>
<li> <p><code>trait.values</code> LEAVE AS <code>NULL</code> (it designates the trait value table from the birth death process and is handled internally by <code><a href="#topic+treats">treats</a></code>).
</p>
</li>
<li> <p><code>lineage</code> LEAVE AS <code>NULL</code> (it designates the lineage object from the birth death process and is handled internally by <code><a href="#topic+treats">treats</a></code>).
</p>
</li>
<li> <p><code>trait</code> LEAVE AS <code>NULL</code> (it which trait to use and is analysed an is handled internally by <code><a href="#topic+treats">treats</a></code>).
</p>
</li></ul>

</li></ul>

<p>More details about the <code>trait.process</code> functions is explained in the <code>treats</code> manual: <a href="http://tguillerme.github.io/treats">http://tguillerme.github.io/treats</a>.
</p>


<h3>Value</h3>

<p>Returns one or more <code>"numeric"</code> value(s).
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treats">treats</a></code> <code><a href="#topic+make.traits">make.traits</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOTE: You can visualise most process by making them
## into a "treats" "traits" object using make.traits():

## The Brownian motion process
BM.process(x0 = 0)
plot(make.traits(process = BM.process))
## A covariance matrix between 3 traits
varcovar_matrix &lt;- matrix(c(1/3,1/3,1/3,1/3,2/3,0,1/3,0,2/3), ncol = 3)
BM.process(x0 = c(0,0,0), Sigma = varcovar_matrix)

## The Ornstein-Uhlenbeck process
OU.process(x0 = 0)
plot(make.traits(process = OU.process))

## No process
no.process()
plot(make.traits(process = no.process))

## Multi peaks with peaks at the values 1, 5 and 10
multi.peak.process(peaks = c(1, 5, 10))
plot(make.traits(multi.peak.process, process.args = list(peaks = c(1, 5, 10))))

## Repulsion process
repulsion.process(x0 = 0, repulsion = 1)
plot(make.traits(repulsion.process, process.args = list(repulsion = 5)))

## Discrete trait process
## Generating a stepwise transition matrix for 3 states (with an overal random transition rate)
stepwise_matrix &lt;- transition.matrix(type = "stepwise", states = 3)
## Generatin and plotting the the trait
plot(make.traits(discrete.process, process.args = list(transitions = stepwise_matrix)))

</code></pre>

<hr>
<h2 id='transition.matrix'>Makes a transition matrix</h2><span id='topic+transition.matrix'></span>

<h3>Description</h3>

<p>Utility function for generating discrete characters evolution transition matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition.matrix(type, states, rates = runif, self = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transition.matrix_+3A_type">type</code></td>
<td>
<p>the type of transition matrix, either &quot;equal rates&quot;, &quot;stepwise&quot;, &quot;symmetric&quot;, or  &quot;all rates different&quot;. See details.</p>
</td></tr>
<tr><td><code id="transition.matrix_+3A_states">states</code></td>
<td>
<p>the number of states.</p>
</td></tr>
<tr><td><code id="transition.matrix_+3A_rates">rates</code></td>
<td>
<p>either a fixed value for a rate to attribute to each possible transitions or a <code>function</code> to generate the rates (default is <code><a href="stats.html#topic+runif">runif</a></code>). See details.</p>
</td></tr>
<tr><td><code id="transition.matrix_+3A_self">self</code></td>
<td>
<p>logical, whether to allow reverting states (i.e. transition rates from state A to the same state A; <code>TRUE</code>; default) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="transition.matrix_+3A_...">...</code></td>
<td>
<p>if <code>rates</code> is a function, any optional arguments to be passed to it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following transition rate matrices are currently implemented:
</p>

<ul>
<li><p> &quot;equal rates&quot; where all transitions are equal (including no transition if <code>self = TRUE</code>).
</p>
</li>
<li><p> &quot;stepwise&quot; transitions are allowed only in a step wise way (e.g. state 1 to 2 and 2 to 3 are allowed but not 1 to 3).
</p>
</li>
<li><p> &quot;symmetric&quot; where transitions between states are all different but not directional (e.g. the change of state 1 to 2 is equal to 2 to 1). If <code>self = TRUE</code>, the non transitions (e.g. from state 1 to 1) are equal.
</p>
</li>
<li><p> &quot;all rates different&quot; where all transitions are different. Note that if rates is a give value (rather than a function), then all rates are actually equal.
</p>
</li></ul>

<p>If <code>rates</code> is a function that generates negative values or a negative value, the output transition matrix always returns absolute values.
</p>


<h3>Value</h3>

<p>Returns a squared <code>"matrix"</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.traits">make.traits</a></code> <code><a href="#topic+discrete.process">discrete.process</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A two states equal rates matrix with a rate of 1
## and no stationary rates (no probability of staying in the same state)
transition.matrix(type = "equal rates", states = 2, rates = 1, self = FALSE)

## Two different 6 states stepwise matrix with a random absolute normal rate
transition.matrix(type = "stepwise", states = 6, rates = rnorm)
transition.matrix(type = "stepwise", states = 6, rates = rnorm)

</code></pre>

<hr>
<h2 id='treats'>Diversity and disparity simulator</h2><span id='topic+treats'></span>

<h3>Description</h3>

<p>Simulating phylogenetic trees and traits. See full manual here: https://github.com/TGuillerme/treats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treats(
  stop.rule,
  bd.params,
  traits = NULL,
  modifiers = NULL,
  events = NULL,
  save.steps = NULL,
  null.error = FALSE,
  replicates,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treats_+3A_stop.rule">stop.rule</code></td>
<td>
<p>The rules on when to stop the simulation (see details).</p>
</td></tr>
<tr><td><code id="treats_+3A_bd.params">bd.params</code></td>
<td>
<p>A <code>"bd.params"</code> object or a named list of parameters for the birth-death process (see details or <code><a href="#topic+make.bd.params">make.bd.params</a></code>).</p>
</td></tr>
<tr><td><code id="treats_+3A_traits">traits</code></td>
<td>
<p>A <code>"traits"</code> object (see <code><a href="#topic+make.traits">make.traits</a></code>).</p>
</td></tr>
<tr><td><code id="treats_+3A_modifiers">modifiers</code></td>
<td>
<p>A <code>"modifiers"</code> object (see <code><a href="#topic+make.modifiers">make.modifiers</a></code>).</p>
</td></tr>
<tr><td><code id="treats_+3A_events">events</code></td>
<td>
<p>A <code>"events"</code> object (see <code><a href="#topic+make.events">make.events</a></code>).</p>
</td></tr>
<tr><td><code id="treats_+3A_save.steps">save.steps</code></td>
<td>
<p>Optional, <code>"numeric"</code> value to save the simulations at specific internal points (this can slow down the algorithm significantly for large trees).</p>
</td></tr>
<tr><td><code id="treats_+3A_null.error">null.error</code></td>
<td>
<p>Logical, whether to return an error when the birth-death parameters fails to build a tree (<code>FALSE</code>; default and highly recommended) or whether to return <code>NULL</code> (<code>TRUE</code>). Can also be set to an integer value for the numbers of trials (see details).</p>
</td></tr>
<tr><td><code id="treats_+3A_replicates">replicates</code></td>
<td>
<p>Optional, the number of replicates for the simulation.</p>
</td></tr>
<tr><td><code id="treats_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to be verbose (<code>TRUE</code>; default) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stop.rule</code>: The rule(s) for when to stop the simulation. When multiple rules are given, the simulation stops when any rule is broken. The allowed rules are:
</p>

<ul>
<li> <p><code>max.taxa</code>   The maximum number of taxa (including extinct ones).
</p>
</li>
<li> <p><code>max.living</code> The maximum number of living taxa (i.e. non extinct).
</p>
</li>
<li> <p><code>max.time</code>   The maximum amount of phylogenetic (in arbitrary units).
</p>
</li></ul>

<p><code>bd.params</code>: This can be either a <code>"treats"</code> <code>"bd.params"</code> object (see <code><a href="#topic+make.bd.params">make.bd.params</a></code>) or a list of named parameters. The allowed parameters are:
</p>

<ul>
<li> <p><code>speciation</code> The speciation parameter value.
</p>
</li>
<li> <p><code>extinction</code> The extinction parameter value.
</p>
</li></ul>

<p>By default, this parameter is set to <code>bd.params = list(speciation = 1)</code>
</p>
<p>If <code>null.error</code> is set to a numeric value, the function will run multiple times until a correct tree is generated. Using this option can greatly increase computational time!
</p>


<h3>Value</h3>

<p>This function outputs either a <code>"phylo"</code> object if no traits where generated or a <code>treats</code> object that is a list of at least two elements: <code>$tree</code>, a <code>"phylo"</code> object and <code>$data</code>, a <code>"matrix"</code> of the trait values.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.treats">plot.treats</a></code> <code><a href="#topic+make.traits">make.traits</a></code> <code><a href="#topic+make.modifiers">make.modifiers</a></code> <code><a href="#topic+make.events">make.events</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Setting pure birth tree (no extinction) parameters
my_bd_params &lt;- list(speciation = 1)
## Setting a stopping rule: stop when reaching 10 taxa.
my_stop_rule &lt;- list(max.taxa = 10) 

## Run a birth tree without traits
a_tree &lt;- treats(bd.params = my_bd_params,
               stop.rule = my_stop_rule)
## Plot the results
plot(a_tree)

## Add an extinction parameter
my_bd_params$extinction &lt;- 1/3

## Add a simple trait simulation (default Brownian motion)
my_trait &lt;- make.traits()

## Run a birth-death tree with traits simulation
treats(bd.params = my_bd_params,
     stop.rule = my_stop_rule,
     traits    = my_trait)

## Simulating a tree using modifiers
## Making a modifier to make speciation trait dependent
my_modifiers &lt;- make.modifiers(branch.length = branch.length.trait,
                               selection     = selection,
                               speciation    = speciation.trait)

## Simulating the tree
treats(stop.rule = list(max.taxa = 20),
     traits = make.traits(),
     modifiers = my_modifiers)

## Run a birth death tree with an event
## 80% mass extinction at time 4
mass_extinction &lt;- make.events(
                      target       = "taxa",
                      condition    = age.condition(4),
                      modification = random.extinction(0.8))

## Set the simulation parameters
stop.rule &lt;- list(max.time = 5)
bd.params &lt;- list(extinction = 0, speciation = 1)

## Run the simulations
set.seed(123)
results &lt;- treats(bd.params = bd.params,
                stop.rule = stop.rule,
                events    = mass_extinction)
## Plot the results
plot(results, show.tip.label = FALSE)
axisPhylo()


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
