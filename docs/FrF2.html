<!DOCTYPE html><html><head><title>Help for package FrF2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FrF2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FrF2-package'>
<p>Fractional Factorial designs with 2-level factors</p></a></li>
<li><a href='#add.center'>
<p>Function to add center points to a 2-level fractional factorial</p></a></li>
<li><a href='#aliases'><p> Alias structure for fractional factorial 2-level designs</p></a></li>
<li><a href='#block'><p> Statistical and algorithmic aspects of blocking in FrF2</p></a></li>
<li><a href='#blockpick'><p> Function to show potential block assignments</p></a></li>
<li><a href='#BsProb.design'><p> Bayesian posterior probabilities from Box and Meyer method</p></a></li>
<li><a href='#CatalogueAccessors'><p> Catalogue file and accessor functions</p></a></li>
<li><a href='#CIG'><p> Clear interactions graph from catlg entry</p></a></li>
<li><a href='#compromise'><p> Function to support estimability requests for compromise designs</p></a></li>
<li><a href='#cubePlot'><p> Cube plot for three-factor-effects</p></a></li>
<li><a href='#DanielPlot'><p> Normal or Half-Normal Effects Plots</p></a></li>
<li><a href='#estimable.2fis'><p> Statistical and algorithmic aspects of requesting 2-factor interactions to be estimable in FrF2</p></a></li>
<li><a href='#fold.design'>
<p>Function to create a foldover for 2-level fractional factorials</p></a></li>
<li><a href='#FrF2'><p> Function to provide regular Fractional Factorial 2-level designs</p></a></li>
<li><a href='#FrF2Large'><p> Function to provide large (at least 8192 runs) regular Fractional Factorial designs</p>
that are not necessarily optimal, especially large resolution V designs.</a></li>
<li><a href='#godolphin'><p> Functions in support of Godolphin's approach for blocking designs</p></a></li>
<li><a href='#IAPlot'><p> Main Effects and Interaction Plots</p></a></li>
<li><a href='#makecatlg'><p> Function for creating a class catlg catalogue from a vector of generators</p></a></li>
<li><a href='#pb'><p> Function to generate non-regular fractional factorial screening designs</p></a></li>
<li><a href='#splitplot'><p> Statistical and algorithmic aspects of split-plot designs in FrF2</p></a></li>
<li><a href='#StructurePickers'><p> Functions to find split-plot or left-adjusted designs</p></a></li>
<li><a href='#utilities.blocksplitplot.aliases.shortrep'><p> Utility functions for short representation of block and splitplot generators</p></a></li>
<li><a href='#utilitiesCat'><p> ~~ Internal utility functions and a user-visible constant for working with regular fractional factorials ~~</p></a></li>
<li><a href='#utilitiesPB'><p> ~~ Internal utility functions ~~</p></a></li>
<li><a href='#utilitiesV'><p> ~~ Internal utility functions for generating regular fractional factorials ~~</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fractional Factorial Designs with 2-Level Factors</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3-3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.13.0), DoE.base(&ge; 0.25)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sfsmisc(&ge; 1.0-26), utils, scatterplot3d, igraph(&ge; 0.7),
methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>FrF2.catlg128, BsMD, DoE.wrapper</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Ulrike Groemping</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ulrike Groemping &lt;ulrike.groemping@bht-berlin.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Regular and non-regular Fractional Factorial 2-level designs 
        can be created. Furthermore, analysis tools for Fractional
        Factorial designs with 2-level factors are offered (main
        effects and interaction plots for all factors simultaneously,
        cube plot for looking at the simultaneous effects of three
        factors, full or half normal plot, alias structure in a more
        readable format than with the built-in function alias). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://prof.bht-berlin.de/groemping/DoE/">https://prof.bht-berlin.de/groemping/DoE/</a>,
<a href="https://prof.bht-berlin.de/groemping/">https://prof.bht-berlin.de/groemping/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-11 22:30:15 UTC; groemping</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-20 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='FrF2-package'>
Fractional Factorial designs with 2-level factors
</h2><span id='topic+FrF2-package'></span>

<h3>Description</h3>

<p>creates regular and non-regular Fractional Factorial 2-level designs. 
Furthermore, analysis tools for Fractional Factorial designs with 2-level factors 
are offered (main effects and interaction plots for all factors simultaneously, 
cube plot for looking at the simultaneous effects of three factors, full or half normal plot, 
alias structure in a more readable format than with the built-in function alias). 
</p>
<p>The package works together with packages DoE.base and DoE.wrapper.
</p>


<h3>Details</h3>

<p>The package is still subject to development; most key functionality is now included. 
Please contact me, if you have suggestions.
</p>
<p>This package designs and analyses Fractional Factorial experiments with 2-level factors. 
Regular (function <code><a href="#topic+FrF2">FrF2</a></code>) and non-regular (function <code><a href="#topic+pb">pb</a></code>) 2-level fractional factorial 
designs can be generated. For regular fractional factorials, function <code><a href="#topic+FrF2">FrF2</a></code> 
permits the specification of effects of interest, whose estimation is requested clear of aliasing 
with other effects. The function can furthermore generate regular fractional factorials 
as blocked or split-plot designs, and hard-to-change 
factors can be specified in order to keep the number of level changes low.
Regular resolution V designs larger than those obtainable from function <code>FrF2</code> 
can be created by function <code><a href="#topic+FrF2Large">FrF2Large</a></code> (these are not guaranteed to be optimal). 
Analysis facilities work for completely aliased designs only, 
i.e. e.g. not for analysing Plackett-Burman designs with interactions. 
</p>
<p>Functions <code>fac.design</code>, <code>fractionate</code> or <code>oa.design</code> from 
Chambers and Hastie (1993) have been used as role models e.g. for 
the option <code>factor.names</code> or for outputting a data frame with attributes. 
However, S compatibility has not been considered in devising this package. The original 
above-mentioned functions are not available in <code>R</code>; similar 
functions have been implemented in package <span class="pkg"><a href="DoE.base.html#topic+DoE.base-package">DoE.base</a></span> 
together with other general functionality for experimental designs.
</p>
<p>In terms of analysis, package <code>FrF2</code> works on linear models and enables convenient main effects and 
interaction plots (functions <code>MEPlot</code> and <code>IAPlot</code>) similar to those 
offered by Minitab software for all factors simultaneously, even though especially the 
interactions are often aliased, i.e. the model is typically singular. 
For the (less frequent) case of suspected three-factor-interactions, function 
<code>cubePlot</code> displays a cube with corners labeled with the (modeled) 
means of three factors simultaneously.
Furthermore, the function <code>DanielPlot</code> from package <span class="pkg">BsMD</span> has been 
modified to automatically label effects significant according to the 
Lenth-criterion, to automatically distinguish between whole-plot and 
split-plot effects for split-plot designs, and to provide more usage comfort 
to the analyst.<br />
Finally, the function <code>aliases</code> determines the alias structure of a 
Fractional Factorial 2-level design in a format more suitable for human readers 
than the output from the built-in function <code>alias</code>. 
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>
<p>Maintainer: Ulrike Groemping &lt;ulrike.groemping@bht-berlin.de&gt;
</p>


<h3>References</h3>

<p>Box G. E. P, Hunter, W. C. and Hunter, J. S. (2005) 
<em>Statistics for Experimenters, 2nd edition</em>.
New York: Wiley.
</p>
<p>Chambers, J.M. and Hastie, T.J. (1993). <em>Statistical Models in S</em>, 
Chapman and Hall, London.
</p>
<p>Chen, J., Sun, D.X. and Wu, C.F.J. (1993) 
A catalogue of 2-level and 3-level orthogonal arrays. 
<em>International Statistical Review</em> <b>61</b>, 131-145.
</p>
<p>Daniel, C. (1959) 
Use of Half Normal Plots in Interpreting Two Level Experiments.
<em>Technometrics</em>, <b>1</b>, 311-340.
</p>
<p>Groemping, U. (2014). R Package FrF2 for Creating and Analyzing Fractional 
Factorial 2-Level Designs. <em>Journal of Statistical Software</em>, <b>56</b>, 
Issue 1, 1-56. <a href="https://www.jstatsoft.org/v56/i01/">https://www.jstatsoft.org/v56/i01/</a>.
</p>
<p>Hedayat, A.S., Sloane, N.J.A. and Stufken, J. (1999) 
<em>Orthogonal Arrays: Theory and Applications</em>, Springer, New York. 
</p>
<p>Lenth, R.V. (1989) Quick and easy analysis of unreplicated factorials.
<em>Technometrics</em>, <b>31</b>, 469-473.
</p>
<p>Mee, R. (2009). <em>A Comprehensive Guide to Factorial Two-Level Experimentation</em>. 
New York: Springer.
</p>
<p>Montgomery, D.C. (2001). Design and Analysis of Experiments (5th ed.). Wiley, New York.
</p>
<p>Plackett, R.L.; Burman, J.P. (1946) The design of optimum multifactorial 
experiments. <em>Biometrika</em> <b>33</b>, 305-325.
</p>
<p>Ryan, K.J. and Bulutoglu, D.A. (2010). Minimum Aberration Fractional Factorial Designs With Large N.
<em>Technometrics</em> <b>52</b>, 250-255.
</p>
<p>Sanchez, S.M. and Sanchez, P.J. (2005). Very Large Fractional Factorial 
and Central Composite Designs. 
<em>ACM Transactions on Modeling and Computer Simulation</em> 
<b>15</b>, 362-377.
</p>


<h3>See Also</h3>

<p>The key design generating functions: <code><a href="#topic+FrF2">FrF2</a></code>, <code><a href="#topic+pb">pb</a></code>, <code><a href="#topic+FrF2Large">FrF2Large</a></code><br />
S3 class <code><a href="DoE.base.html#topic+class-design">design</a></code><br /> 
Related packages: 
<code><a href="DoE.base.html#topic+DoE.base-package">DoE.base</a></code>, 
<code><a href="DoE.wrapper.html#topic+DoE.wrapper-package">DoE.wrapper</a></code>, 
<code><a href="BsMD.html#topic+BsMD-package">BsMD</a></code>;<br /> 
Graphical analysis functions: <code><a href="#topic+MEPlot">MEPlot</a></code>, <code><a href="#topic+IAPlot">IAPlot</a></code>, <code><a href="#topic+cubePlot">cubePlot</a></code>, 
<code><a href="#topic+DanielPlot">DanielPlot</a></code><br />
Analysis of alias structure for linear models of <code>FrF2</code> designs: <code><a href="#topic+aliases">aliases</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ### for examples on design generation, cf. functions pb and FrF2
  
    ### Injection Molding Experiment. Box et al. 1978.
    ## data(BM93.e3.data, package="BsMD")  #from BsMD
    ## iMdat &lt;- BM93.e3.data[1:16,2:10]  #only original experiment
    ## re-create here
    y=c(14, 16.8, 15, 15.4, 27.6, 24, 27.4, 22.6, 
     22.3, 17.1, 21.5, 17.5, 15.9, 21.9, 16.7, 20.3)
    iMdat &lt;- FrF2(8,7,randomize=FALSE)
    iMdat &lt;- desnum(iMdat)
    iMdat &lt;- rbind(cbind(iMdat,H=1),cbind(-iMdat,H=-1))
    iMdat &lt;- cbind(as.data.frame(iMdat), y=y)

    # make data more user-friendly
    colnames(iMdat) &lt;- c("MoldTemp","Moisture","HoldPress","CavityThick","BoostPress",
             "CycleTime","GateSize","ScrewSpeed", "y")
    # linear model with all main effects and 2-factor interactions
    iM.lm &lt;- lm(y ~ (.)^2, data = iMdat)
    # determine aliases
    aliases(iM.lm)
    # coded version
    aliases(iM.lm, code=TRUE)
    # normal plot of effects, default is autolabel with alpha=0.05
    DanielPlot(iM.lm)  
    DanielPlot(iM.lm,code=TRUE)
    DanielPlot(iM.lm,code=TRUE,alpha=0.5)
    # half normal plot of effects
    DanielPlot(iM.lm,code=TRUE,alpha=0.5,half=TRUE)
    # main effects plots
    MEPlot(iM.lm, las=1)
    # interaction plots
    IAPlot(iM.lm, las=1)
    # interaction plots with attention drawn to aliases
    aus &lt;- IAPlot(iM.lm, show.alias=TRUE)
    # alias groups corresponding to interaction plots
    aliases(iM.lm)$aliases[9:15]
    # returned object
    aus
    # cube plot of three factors
    # (not very useful for this model, for demonstration only)
      ## per default, modeled means are shown
      ## this does not make a difference here, since the main effect of 
      ## ScrewSpeed is confounded with the MoldTemp:HoldPress:BoostPress
      ## interaction, so that the three-factor-interaction is indirectly included 
      ## in the modeled means
      cubePlot(iM.lm, "MoldTemp", "HoldPress", "BoostPress")
      ## modeled means without a three-factor interaction
      cubePlot(lm(y ~ (MoldTemp+HoldPress+BoostPress)^2, data = iMdat), 
         "MoldTemp", "HoldPress", "BoostPress")
      ## modeled=FALSE reverts to showing the apparent three-factor interaction
      cubePlot(lm(y ~ (MoldTemp+HoldPress+BoostPress)^2, data = iMdat), 
         "MoldTemp", "HoldPress", "BoostPress", modeled=FALSE)
      ## cubePlot also works on raw data
      cubePlot(iMdat$y, iMdat$MoldTemp, iMdat$HoldPress, iMdat$BoostPress)
    ## plotting functions also work directly on designs, 
    ## if these have been generated from functions FrF2 or pb:
      plan &lt;- FrF2(16, 7)
      plan &lt;- add.response(plan, rnorm(16))
      MEPlot(plan)
      IAPlot(plan)
      DanielPlot(plan)
      
</code></pre>

<hr>
<h2 id='add.center'>
Function to add center points to a 2-level fractional factorial
</h2><span id='topic+add.center'></span>

<h3>Description</h3>

<p>This function adds center points to a 2-level fractional factorial design. 
All factors must be quantitative!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.center(design, ncenter, distribute=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.center_+3A_design">design</code></td>
<td>

<p>a data frame of class design that contains a 2-level fractional factorial 
(regular or non-regular); 
<code>design</code> must neither be a split-plot nor a long version parameter design.<br />
For function <code>add.center</code>, the design must not contain center points yet, 
while it has to contain center points for function <code>iscube</code>.
</p>
<p>For function <code>add.center</code>, blocked and replicated (or repeated measurement) designs 
must be in the original run order (column run.no in run.order attribute 
in ascending order), as the algorithm relies on the related runs being grouped as 
expected. An error is thrown, if this condition is violated.
</p>
</td></tr>
<tr><td><code id="add.center_+3A_ncenter">ncenter</code></td>
<td>

<p>the number of center points to be added to each block
</p>
</td></tr>
<tr><td><code id="add.center_+3A_distribute">distribute</code></td>
<td>

<p>the number of positions over which to distribute the center points within each block; 
note that the center points are not randomized but placed evenly throughout the 
(hopefully randomdomized) design (but see also the details section);<br />
if distribute is NULL, center points are all added at the end for non-randomized designs 
and are distributed as evenly as possible to beginning, middle and end of the experiment 
for randomized designs. 
</p>
<p><code>distribute</code> must neither be larger than <code>ncenter</code> nor than 
the number of runs of the design plus one. 
</p>
</td></tr>
<tr><td><code id="add.center_+3A_...">...</code></td>
<td>

<p>currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>add.center</code> adds center points to 2-level fractional factorial 
designs. Instead of using this function directly, center points should usually 
be added directly with calls to functions <code><a href="#topic+FrF2">FrF2</a></code> or <code><a href="#topic+pb">pb</a></code>. 
These make use of function <code>add.center</code> for this purpose.
</p>
<p>Center points are added to designs for three main reasons: 
they provide a repeated benchmark run that can alert the experimenter to unplanned changes in experimental conditions, 
they provide an independent estimate of experimental error, and finally they provide a possibility for 
checking whether a first order model is sufficient. Especially for the first purpose, 
package FrF2 follows the recommendation in Montgomery (2001, p.275). To distinguish them from the center points, 
the original fractional factorial runs are called &ldquo;cube points&rdquo;. 
</p>
<p>Addition of center points does not affect estimates for main effects and interactions. 
The difference between the averages of cube points and center points gives an indication whether 
quadratic terms might be needed in the model.
</p>
<p>For blocked designs and properly replicated designs, 
<code>ncenter</code> center points are added to <em>each</em> (replication) block. 
In case of repeated measurements, center points are also measured repeatedly.
</p>
<p>Center points are distributed as evenly as possible over the <code>distribute</code> selected 
positions throughout each block. <code>distribute=1</code> always adds all center points at the end of 
each block. If <code>distribute &gt; 1</code>, (each block of) the design starts and ends 
with a (group of) center point(s), 
and the <code>distribute</code> positions for placing center points are as evenly 
placed throughout (each block of) the design as possible. <br />
If <code>ncenter</code> is not a multiple of <code>distribute</code>, 
some center point groups have one more center point than others. If <code>ncenter%%distribute</code> 
is one or two only, the beginning and (for two) the end of (each block of) the design have one more center point, 
otherwise the <code>ncenter%%distribute</code> extra center points are randomized over the center point positions.
</p>
<p>Function <code><a href="DoE.base.html#topic+iscube">iscube</a></code> from package <span class="pkg">DoE.base</span> 
provides a logical vector that is TRUE for cube points 
and FALSE for center points, which allows to use of simple functions 
for &ldquo;clean&rdquo; 2-level fractional factorials like <code>MEPlot</code>. 
</p>


<h3>Value</h3>

<p>A data frame of class design with <code>ncenter</code> center point runs per block 
(or per replication block) added to the <code>design</code> 
(and its <code>desnum</code> and <code>run.order</code> attributes). 
The run.no.in.std.order column of run.order is &ldquo;0&rdquo; for the center points.
</p>
<p>Existing response values for cube runs are preserved, and response values for the 
new center point runs are NA. Note, however, that center points should be added 
BEFORE running the experiment in order to benefit from all their useful properties; 
this should best be done within functions <code><a href="#topic+pb">pb</a></code> or <code><a href="#topic+FrF2">FrF2</a></code>.
</p>
<p>The design is identifiable as a design with center points by the 
suffix <code>.center</code> to the <code>type</code> element of attribute <code>design.info</code>,
and the elements <code>ncube</code> and <code>ncenter</code> are added 
(with the updated <code>nruns</code> being their sum). The element <code>coding</code> is 
also added to the <code>design.info</code>, in order to support steepest ascent/descent 
analysis from the center point.
</p>


<h3>Note</h3>

<p>This function is still somewhat experimental.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>Montgomery, D.C. (2001). <em>Design and Analysis of Experiments (5th ed.)</em>. Wiley, New York.
</p>


<h3>See Also</h3>

<p>See also as <code><a href="#topic+pb">pb</a></code>, <code><a href="#topic+FrF2">FrF2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## purely technical example 
  plan &lt;- FrF2(8,5, factor.names=c("one","two","three","four","five"))
  add.center(plan, 6)
  add.center(plan, 6, distribute=1)
  add.center(plan, 6, distribute=6)
  add.center(plan, 6, distribute=4)
  
  ## very artificial analysis example
    plan &lt;- FrF2(8,4, factor.names=list(one=c(0,10),two=c(1,3),three=c(25,32),four=c(3.7,4.8)))
  ## add some response data
    y &lt;- c(2+desnum(plan)%*%c(2,3,0,0) +
       1.5*apply(desnum(plan)[,c(1,2)],1,"prod") + rnorm(8))
       ## the "c()" makes y into a vector rather than a 1-column matrix
    plan &lt;- add.response(plan, y)
  ## analysing this design provides an impression
    MEPlot(lm(y~(.)^2, plan))
    IAPlot(lm(y~(.)^2, plan))
    DanielPlot(lm(y~(.)^2,plan), half=TRUE, alpha=0.2)
  ## tentative conclusion: factors one and two do something
  ## wonder whether the model with one and two and their interaction is sufficient
  ## look at center points (!!! SHOULD HAVE BEEN INCLUDED FROM THE START,
  ##      but maybe better now than not at all)
  ## use distribute=1, because all center points are run at the end
    planc &lt;- add.center(plan, 6, distribute=1)
      ## conduct additional runs for the center points
        y &lt;- c(y, c(2+desnum(planc)[!iscube(planc),1:4]%*%c(2,3,0,0) +
             1.5*apply(desnum(planc)[!iscube(planc),][,c(1,2)],1,"prod") + rnorm(6)))
  ## add to the design
    planc &lt;- add.response(planc, y, replace=TRUE)
  ## sanity check: repeat previous analyses for comparison, with the help of function iscube()
    MEPlot(lm(y~(.)^2, planc, subset=iscube(planc)))
    IAPlot(lm(y~(.)^2, planc, subset=iscube(planc)))
    DanielPlot(lm(y~(.)^2, planc, subset=iscube(planc)), half=TRUE, alpha=0.2)
  ## quick check whether there a quadratic effect is needed: is the cube indicator significant ?
    summary(lm(y~(.)^2+iscube(planc), planc))
        ## (in this unrealistic example, the quadratic effect is dominating everything else;
        ## with an effect that strong in practice, it is likely that
        ## one would either have expected a strong non-linearity before conducting the experiment, 
        ## OR that the effect is not real but the result of some stupid mistake
  ## alternatively, the check can be calculated per hand (cf. e.g. Montgomery, Chapter 11):
    (mean(planc$y[iscube(planc)])-mean(planc$y[!iscube(planc)]))^2*8*6/(8+6)/var(y[!iscube(planc)])
    ## must be compared to the F-quantile with 1 degree of freedom
    ## is the square of the t-value for the cube indicator in the linear model
   </code></pre>

<hr>
<h2 id='aliases'> Alias structure for fractional factorial 2-level designs </h2><span id='topic+aliases'></span><span id='topic+aliasprint'></span><span id='topic+print.aliases'></span>

<h3>Description</h3>

<p>Functions to examine the alias structure of a 
fractional factorial 2-level design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aliases(fit, code = FALSE, condense=FALSE)
aliasprint(design, ...)
## S3 method for class 'aliases'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aliases_+3A_fit">fit</code></td>
<td>
<p> a linear model object with only 2-level factors as explanatory variables;
the function will return an error, if the model contains partially
aliased effects (like interactions in a Plackett-Burman design 
for most cases) </p>
</td></tr>
<tr><td><code id="aliases_+3A_code">code</code></td>
<td>
<p> if TRUE, requests that aliasing is given in code letters (A, B, C 
etc.) instead of (potentially lengthy) variable names; 
in this case, a legend is included in the output object.</p>
</td></tr>
<tr><td><code id="aliases_+3A_condense">condense</code></td>
<td>
<p> if TRUE, reformats the alias information to 
be comparable to the version calculated by internal function alias3fi;
does not work with models with higher than 3-way interactions;
for up to 3-way interactions, the output may be more easily readible</p>
</td></tr>
<tr><td><code id="aliases_+3A_design">design</code></td>
<td>
<p> a data frame of class <code>design</code> that should contain a fractional 
factorial 2-level design; the function does not print anything if 
the design is of different nature</p>
</td></tr>
<tr><td><code id="aliases_+3A_x">x</code></td>
<td>
<p>   an object of class <code>aliases</code> that should be the output from 
function <code>aliases</code> </p>
</td></tr>
<tr><td><code id="aliases_+3A_...">...</code></td>
<td>
<p>further arguments to function <code><a href="base.html#topic+print.default">print.default</a></code>;<br />
the <code>quote</code> argument cannot be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>aliasprint</code> returns NULL and is called for its side effects only.
</p>
<p>Per default, Function <code>aliases</code> returns a list with two elements:
</p>
<table>
<tr><td><code>legend</code></td>
<td>
<p>links the codes to variable names, if <code>code=TRUE</code>.</p>
</td></tr>
<tr><td><code>aliases</code></td>
<td>
<p>is a list of vectors of aliased effects.</p>
</td></tr>
</table>
<p>If option <code>condense</code> is TRUE, the function returns a list with elements legend, 
main, fi2 and fi3; this may be preferrable for looking at the alias structure of larger designs. 
</p>
<p>The output object of function <code>aliases</code> has class <code>aliases</code>, 
which is used for customized printing with the <code>print</code> method.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Box G. E. P, Hunter, W. C. and Hunter, J. S. (2005) 
<em>Statistics for Experimenters, 2nd edition</em>.
New York: Wiley.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+FrF2-package">FrF2-package</a></code> for information on the package, 
<code><a href="stats.html#topic+alias">alias</a></code> for the built-in R-function, 
<code><a href="#topic+IAPlot">IAPlot</a></code> for effects plots </p>


<h3>Examples</h3>

<pre><code class='language-R'>    ### Injection Molding Experiment. Box et al. 1978.
    ## data(BM93.e3.data, package="BsMD")  #from BsMD
    ## iMdat &lt;- BM93.e3.data[1:16,2:10]  #only original experiment
    ## re-create here
    y=c(14, 16.8, 15, 15.4, 27.6, 24, 27.4, 22.6, 
     22.3, 17.1, 21.5, 17.5, 15.9, 21.9, 16.7, 20.3)
    iMdat &lt;- FrF2(8,7,randomize=FALSE)
    iMdat &lt;- desnum(iMdat)
    iMdat &lt;- rbind(cbind(iMdat,H=1),cbind(-iMdat,H=-1))
    iMdat &lt;- cbind(as.data.frame(iMdat), y=y)

    # make data more user-friendly
    colnames(iMdat) &lt;- c("MoldTemp","Moisture","HoldPress","CavityThick",
             "BoostPress","CycleTime","GateSize","ScrewSpeed","y")
    # determine aliases with all 2-factor-interactions
    aliases(lm(y ~ (.)^2, data = iMdat))
    # coded version
    aliases(lm(y ~ (.)^2, data = iMdat), code=TRUE)
    # determine aliases with all 3-factor-interactions
    aliases(lm(y ~ (.)^3, data = iMdat), code=TRUE)
    # show condensed form
    aliases(lm(y ~ (.)^3, data = iMdat), code=TRUE, condense=TRUE)
    # determine aliases for unaliased model
    aliases(lm(y ~ ., data = iMdat))
</code></pre>

<hr>
<h2 id='block'> Statistical and algorithmic aspects of blocking in FrF2 </h2><span id='topic+block'></span>

<h3>Description</h3>

<p>This help page documents the statistical and algorithmic details of blocking in FrF2 
</p>


<h3>Details</h3>

<p>Blocking is done with the purpose to balance the design with respect to a factor 
that is known or strongly suspected to have an influence but is not in itself of interest, 
and it is usually assumed that block factors do not interact with experimental factors. 
Examples are batches of material that are not large enough to accomodate the complete 
experiment so that e.g. half the experiment is done on the first batch and the other half 
on the second batch (two blocks). The block factor should be orthogonal to the experimental 
factors, at least to their main effects. Per default, it is also requested that the block 
factor is orthogonal to the 2-factor interactions. This can be changed by the user, if no 
such design can be found.
</p>
<p>Blocking is currently implemented for regular fractional factorial designs only.<br />
There are two principal ways to handle blocked designs, manual definition 
(i.e. the user specifies exactly which columns are to be used for which purpose) and automatic 
definition. Each situation has its specifics. These are detailed below. For users with 
not so much mathematical/statistical background, it will often be best to use the automatic way, 
specifying the treatment factors of interest via <code>nfactors</code> or <code>factor.names</code> 
and a single number for <code>blocks</code> or <code>WPs</code>. 
Users with more mathematical background may want to use the manual definitions, perhaps 
in conjunction with published catalogues of good block designs, or 
after inspecting possibilities with functions <code><a href="#topic+blockpick">blockpick</a></code>, <code><a href="#topic+blockpick.big">blockpick.big</a></code> (default before version 2 for large settings) or <code><a href="#topic+colpick">colpick</a></code> (default since version 2 for large settings or settings with estimability requirements).
</p>

<dl>
<dt>Manual definition of blocked designs for regular fractional factorials</dt><dd>
<p>The user can start from a design with a number of factors and manually specify which factors or 
interactions are to be used as block generators. If this route is chosen, <code>blocks</code> 
can be a vector of factor names or factor letters, or of the same form as generators, except that 
not only base factors but all factors can be used and single factors are permitted 
(which would lead to resolution II designs if used in generators). For example, <br />
<code>block = Letters[c(2,4,5)]</code> <br />
or <br />
<code>block = list(2,4,5)</code> <br />
specify that the 2nd, 4th and 5th factor are to be used as block generators, while <br />
<code>block = c("Day","Shift")</code><br />
indicates that the named factors &ldquo;Day&rdquo; and &ldquo;Shift&rdquo; specified in <code>factor.names</code> 
are to be treated as blocking factors). In this case, the number of blocks is calculated, 
and a new factor with the default name &ldquo;Blocks&rdquo; (in general the name chosen in 
option <code>block.name</code>) is generated, which would for example contain as levels 
the Day/Shift combinations. It is also possible to choose interaction effects rather than factors themselves 
as block generators, e.g. <br />
<code>block = c("ABCD","EFGH") </code> <br />
or<br />
<code>block = list(c(1,2,3,4),c(5,6,7,8)) </code>. <br />
Finally, it is also possible to specify choice of blocks using a vector of Yates column numbers, 
in order to be able to use catalogued blocking structures of this form, e.g. from Sitter, Chen and Feder 
(1997).<br />
The block main effects are defined by the <code>k.block</code> specified effect 
and all interactions between them. The specified block effects are required to be independent from each other, 
which implies that they generate <code>2^k.block</code> blocks. <br />
CAUTION: If the user manually generates a blocked design, it is his/her responsibility to ensure a 
good choice of design (e.g. by using a catalogued design from Bisgaard 1994, 
Sun, Wu and Chen 1997, Sitter, Chen and Feder (1997), or Cheng and Wu 2002).
Since version 2 of package <span class="pkg">FrF2</span>, manual blocking is also checked for confounding 
of the block factor with main effects or two-factor interactions; 
this implies that some earlier code will now require the additional specification 
of argument <code>alias.block.2fis=TRUE</code> in order to avoid errors.
</p>
</dd>
<dt>Automatic definition of blocked designs for regular fractional factorials</dt><dd>
<p>If the user only specifies the number of blocks required for the experiment, function <code><a href="#topic+FrF2">FrF2</a></code> 
automatically generates the blocks. For full factorial designs, function <code><a href="#topic+FrF2">FrF2</a></code> uses function <code><a href="#topic+colpick">colpick</a></code> 
with subsequent <code><a href="#topic+blockgencreate">blockgencreate</a></code>, except where the Sun, Wu and Chen (1997) catalogue of blocked designs 
contains suitable block generators for a design without estimability requirements 
(implemented in function <code><a href="#topic+blockpick">blockpick</a></code>, which also calls <code>colpick</code>, if that 
catalogue does not offer a solution). 
Otherwise, depending on the situation, 
function <code><a href="#topic+FrF2">FrF2</a></code> uses function <code><a href="#topic+blockpick">blockpick</a></code> or function <code><a href="#topic+colpick">colpick</a></code> 
with subsequent <code><a href="#topic+blockgencreate">blockgencreate</a></code>; 
function <code><a href="#topic+blockpick">blockpick</a></code> treats smaller problems (<code>choose(nruns-1-nfactors,k.block) &lt; 100000</code>) 
without estimability requirements and with <code>force.godolphin=FALSE</code> (the latter is per default set to TRUE 
whenever <code>alias.block.2fis=TRUE</code>), 
other problems are treated by function <code><a href="#topic+colpick">colpick</a></code>.
</p>
<p>Use of the earlier default function <code><a href="#topic+blockpick.big">blockpick.big</a></code> for large cases or the earlier behavior for full factorial designs 
can be requested with the argument 
<code>block.old=TRUE</code>; this should only be done for reproducing earlier results, as the new methodology is definitely superior. 
</p>
<p>The search for an appropriate blocked design starts with the overall best unblocked design 
(in terms of aberration or MaxC2, if requested). 
If this best design does not yield an adequate blocking possibility, the search continues with 
the next best design and so forth (exception: with an estimability requirement, only a single design, prefiltered for the estimability requirement, is subjected to the blocking algorithm). <br />
For the smaller problems, function <code><a href="#topic+blockpick">blockpick</a></code> 
looks for <code>k.block</code> independent subsets among the eligible columns of the design. 
(The eligible columns are all columns of the Yates matrix that are neither occupied 
by treatment main effects nor by 2fis among treatments (if <code>alias.block.2fis=FALSE</code>, 
which is the default), or all columns of the Yates matrix that are not occupied by treatment main effects 
(if <code>alias.block.2fis=TRUE</code>). Note that no effort is made to avoid aliasing with 2-factor interactions, 
if <code>alias.block.2fis=TRUE</code> is chosen. 
</p>
<p>For the larger problems, or blocking in combination with requiring some 2fis to be clear of aliasing, 
or per default for blocking with permitting 2fis to be aliased with blocks, 
function <code><a href="#topic+colpick">colpick</a></code> creates a <code class="reqn">q \times n</code> <b>X</b> matrix for creating 
blocks of size <code class="reqn">2^q</code> based on the approach described by Godolphin (2021); 
function <code>blockgencreate</code> creates block generators from this matrix. 
This approach can be used in combination with argument <code>estimable</code>, 
as long as <code>clear=TRUE</code>. The implementation of this approach is described in Groemping (2021).
The argument <code>force.godolphin</code> of function <code><a href="#topic+FrF2">FrF2</a></code> can enforce the Godolphin approach instead 
of the default approach for small blocked designs without <code>alias.block.2fis=TRUE</code>, 
and the Godolphin approach can be switched off for <code>alias.block.2fis=TRUE</code> applications by explicitly requesting 
<code>force.godolphin=FALSE</code>. Note that the Godolphin approach solely focuses on clear 2fis 
of the blocked design and does not attempt to avoid confounding of the block factor with non-clear 2fis; it may 
thus confound 2fis with the block factor even if this were avoidable, maintaining the same number of clear 2fis.
</p>
<p>For the larger problems, in versions before 2.0, which can be activated in current versions with <code>block.old=TRUE</code>,
function <code><a href="#topic+blockpick.big">blockpick.big</a></code> permutes the k~base factors of candidate designs with <code>nfactors + k.block</code> factors 
in search of a design the first <code>k.block</code>~factors of which can be used for block construction. Any 
specification of design (via options <code>design</code> or <code>generators</code>) is ignored. Note that function 
<code><a href="#topic+blockpick.big">blockpick.big</a></code> is not guaranteed to find an existing blocked design.
</p>
<p>Sun, Wu and Chen (1997) provided a catalogue of blocked designs 
with a few quality criteria, and they stated that there is no single best design, but that the choice 
depends on the situation. <code>FrF2</code> always comes up with one specific solution design. 
Comparisons to the catalogued designs in Sun, Wu and Chen (1997) have shown that 
the designs found in <code>FrF2</code> are often but not always isomorphic to the catalogued ones. 
Differences do occur, especially if the base designs are resolution III, or if <code><a href="#topic+blockpick.big">blockpick.big</a></code> 
has to be used. Expert users who want to be certain to use a &ldquo;best&rdquo; blocked design should manually 
implement a specific catalogued design or inspect several solutions from functions <code><a href="#topic+blockpick">blockpick</a></code> or <code><a href="#topic+colpick">colpick</a></code> (or, if desparate, <code><a href="#topic+blockpick.big">blockpick.big</a></code>). 
</p>
</dd>
</dl>

<p>Please contact me with any suggestions for improvements.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Bisgaard, S. (1994a). Blocking generators for small <code class="reqn">2^{k-p}</code> designs. 
<em>J. Quality Technology</em> <b>26</b>, 288-294.
</p>
<p>Chen, J., Sun, D.X. and Wu, C.F.J. (1993) 
A catalogue of 2-level and 3-level orthogonal arrays. 
<em>International Statistical Review</em> <b>61</b>, 131-145. 
</p>
<p>Cheng, C.-S. and Tsai, P.-W. (2009). 
Optimal two-level regular fractional factorial block and split-plot designs. 
<em>Biometrika</em> <b>96</b>, 83-93.
</p>
<p>Cheng, S.W. and Wu, C.F.J. (2002). 
Choice of optimal blocking schemes in 2-level and 3-level designs. 
<em>Technometrics</em> <b>44</b>, 269-277. 
</p>
<p>Godolphin, J. (2021). Construction of Blocked Factorial Designs to Estimate 
Main Effects and Selected Two-Factor Interactions. <em>J. Royal Statistical Society</em> <b>B 83</b>, 5-29. 
doi: <a href="https://doi.org/10.1111/rssb.12397">10.1111/rssb.12397</a>.
</p>
<p>Groemping, U. (2019). An algorithm for blocking regular fractional 
factorial 2-level designs with clear two-factor interactions. 
<em>Reports in Mathematics, Physics and Chemistry</em>, <a href="http://www1.bht-berlin.de/FB_II/reports/Report-2019-003.pdf">Report 3/2019</a>, 
Department II, Beuth University of Applied Sciences Berlin.
</p>
<p>Sitter, R.R., Chen, J. and Feder, M. (1997). 
Fractional Resolution and Minimum Aberration in Blocked 2n-k Designs.
<em>Technometrics</em> <b>39</b>, 382&ndash;390.
</p>
<p>Sun, D.X., Wu, C.F.J. and Chen, Y.Y. (1997). 
Optimal blocking schemes for <code class="reqn">2^p</code> and <code class="reqn">2^{n-p}</code> designs. <em>Technometrics</em> <b>39</b>, 
298-307. 
</p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+FrF2">FrF2</a></code> for regular fractional factorials, 
<code><a href="#topic+catlg">catlg</a></code> for the Chen, Sun, Wu catalogue of designs 
and some accessor functions, 
and <code><a href="#topic+splitplot">splitplot</a></code> for the statistical aspects of split-plot designs.</p>


<h3>Examples</h3>

<pre><code class='language-R'>########## automatic blocked designs ###################
## from a full factorial ##
FrF2(8,3,blocks=2)
## with replication
run.order(FrF2(8,3,blocks=2,wbreps=2))
run.order(FrF2(8,3,blocks=2,wbreps=2,repeat.only=TRUE))
run.order(FrF2(8,3,blocks=2,bbreps=2))
run.order(FrF2(8,3,blocks=2,bbreps=2,wbreps=2))

## automatic blocked design with fractions
FrF2(16,7,blocks=4,alias.block.2fis=TRUE)
## isomorphic non-catalogued design as basis
FrF2(16,gen=c(7,11,14),blocks=4,alias.block.2fis=TRUE)
## FrF2 uses blockpick.big and ignores the generator
FrF2(64,gen=c(7,11,14),blocks=16,alias.block.2fis=TRUE)

########## manual blocked design ####################
### example that shows why order of blocks is not randomized
### can of course be randomized by user, if appropriate
FrF2(32,9,blocks=c("Day","Shift"),alias.block.2fis=TRUE, 
    factor.names=list(Day=c("Wednesday","Thursday"), Shift=c("Morning","Afternoon"),
        F1="",F2="",F3="",F4="",F5="",F6="",F7=""), default.levels=c("current","new"))

########## blocked design with estimable 2fis ####################
### all interactions of last two factors to be estimable clearly
### in 64 run design with blocks of size 4
### not possible with catalogue entry 9-3.1
FrF2(design="9-3.2", blocks=16, alias.block.2fis=TRUE, 
    factor.names = list(C1="",C2="",C3="",C4="",C5="",C6="",C7="",
    N1=c("low","high"),N2=c("low","high")), 
    default.levels = c("current","new"),
    estimable=compromise(9, 8:9)$requirement)

</code></pre>

<hr>
<h2 id='blockpick'> Function to show potential block assignments </h2><span id='topic+blockpick'></span><span id='topic+blockpick.big'></span>

<h3>Description</h3>

<p>Functions to investigate potential assignments of blocks 
and show alias information of resulting designs, meant for expert users
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockpick(k, gen, k.block, design = NULL, show = 10, 
                       alias.block.2fis = FALSE, select.catlg = catlg)
blockpick.big(k, gen, k.block, design = NULL, show = 10, 
                       alias.block.2fis = FALSE, select.catlg = catlg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockpick_+3A_k">k</code></td>
<td>
<p> the number of base factors (designs have <code>2^k</code> runs) </p>
</td></tr>
<tr><td><code id="blockpick_+3A_gen">gen</code></td>
<td>
<p> vector of generating columns from Yates matrix; 
for a full factorial, choose <code>gen = 0</code> or 
<code>gen=numeric(0)</code> for 
no generating columns; but note that there is always just the one 
and only catalogued design returned for a full factorial.<br />
For function <code>blockpick</code>, <code>gen</code> refers to the generators 
of the base design only, and block columns are automatically added by 
<code>blockpick</code>.<br />
For function <code>blockpick.big</code>, <code>gen</code> refers to the generators 
for treatment factors and block generators. In fact, <code>blockpick.big</code> 
will always use the first <code>k.block</code> (base) factors for block generation. 
Hence, for example for generating a design in 64 runs and 7 factors with 
32 blocks, <code>gen</code> must have 6 entries in order to accomodate the 
7 treatment factors together with the 5 block generators.
</p>
</td></tr>
<tr><td><code id="blockpick_+3A_k.block">k.block</code></td>
<td>
<p> number of base factors needed for constructing blocks; 
there will be <code>2^k.block</code> blocks in the design </p>
</td></tr>
<tr><td><code id="blockpick_+3A_design">design</code></td>
<td>
<p> design name (character string) of a specific design from the 
catalogue given in select.catlg </p>
</td></tr>
<tr><td><code id="blockpick_+3A_show">show</code></td>
<td>
<p> numeric integer indicating how many results are to be shown;
the search for possible allocations stops, once <code>show</code> variants 
have been found. Note that the best designs may not be found early in 
the process, especially if a large number of eligible columns is available 
and many blocks are needed (e.g. 
full factorial in 64 runs with 16 blocks). In such cases, increasing <code>show</code> may 
lead to finding a better design (but may also increase calculation 
time from long to unbearable).</p>
</td></tr>
<tr><td><code id="blockpick_+3A_alias.block.2fis">alias.block.2fis</code></td>
<td>
<p> logical, indicates whether 2fis may be aliased with blocks </p>
</td></tr>
<tr><td><code id="blockpick_+3A_select.catlg">select.catlg</code></td>
<td>
<p> design catalogue of class <code>catlg</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>blockpick</code> is used per default by function <code><a href="#topic+FrF2">FrF2</a></code> 
for problems with <code>choose(nruns-1-nfactors,k.block) &lt; 100000</code> and without 
estimability requirements. <code>blockpick</code> will find a design, if it exists. 
However, it may take a long time and/or much storage space in problems with 
large numbers of runs and blocks.
</p>
<p>In <span class="pkg">FrF2</span> versions before 2.0, function <code>blockpick.big</code> was used for 
large use cases; this can still be requested using argument <code>block.old=TRUE</code>. 
Since FrF2 version 2, the <code><a href="#topic+godolphin">Godolphin (2021) based approach</a></code> 
is used instead, both for 
large cases and for cases where blocking is combined with estimability requirements 
(<code>clear=TRUE</code> only); the big advantage is the ability of combining blocking with 
estimability requirements, and a substantial speed gain if small blocks are needed. 
</p>
<p>All approaches investigate the potential assignment of blocks such that 
main effects of treatment factors are not aliased with block main effects. 
It is left to the user whether or not 2fis amoong treatment effects may be 
aliased with block main effects (option <code>alias.block.2fis</code>). (For the Godolphin 
approach to work, one will usually need to set <code>alias.block.2fis</code> to TRUE.)
</p>
<p>Following Sun, Wu and Chen (1997), there is no single best block assignment. 
<code>blockpick</code> uses their catalogue for full factorials (implemented up to 256 runs). 
For fractional factorials, it develops designs according to a 
principle similar to that underlying the Sun Wu Chen catalogue that works also in 
uncatalogued situations. 
</p>
<p>Function <code>blockpick.big</code> uses a strategy similar to <code><a href="#topic+splitpick">splitpick</a></code> 
and <code><a href="#topic+leftadjust">leftadjust</a></code>
and often finds a solution quickly where <code>blockpick</code> does not work with the 
given ressources. However, it is not guaranteed to find existing solutions 
or a best solution. 
</p>


<h3>Value</h3>

<p>The function <code>blockpick</code> outputs a list of entries with information on at most <code>show</code> suitable 
assignments. It ends with an error, if no suitable solution can be found.
</p>
<table>
<tr><td><code>gen</code></td>
<td>
<p>generator column numbers of the base design (w.r.t. the Yates matrix)</p>
</td></tr>
<tr><td><code>basics</code></td>
<td>
<p>named vector with number of runs (<code>nruns</code>), number of blocks (<code>nblocks</code>), 
number of treatment factors (<code>ntreat</code>) and resolution of base design (<code>res.base</code>);
the vector is numeric or character, depending on whether resolution is known exactly or 
as &ldquo;5+&rdquo; only</p>
</td></tr>
<tr><td><code>blockcols</code></td>
<td>
<p>matrix with at most show rows; each row contains the <code>k.block</code> 
column numbers (w.r.t. the Yates matrix) of the block generators
for the current assignment (the <code>2^k.block-1</code> columns for block main 
effects can be obtained from these).</p>
</td></tr>
<tr><td><code>alias.2fis.block</code></td>
<td>
<p>list of character vectors, which contain the 2fis 
aliased with block main effects for the respective rows of <code>blockcols</code></p>
</td></tr>
<tr><td><code>nblock.2fis</code></td>
<td>
<p>vector with number of 2fis aliased with block main effects 
for the respective rows of <code>blockcols</code></p>
</td></tr>
<tr><td><code>nclear.2fis</code></td>
<td>
<p>vector with number of 2fis clear (of aliasing with block main effects 
and treatment main effects or 2fis) 
for the respective rows of <code>blockcols</code></p>
</td></tr>
<tr><td><code>clear.2fis</code></td>
<td>
<p>list of character vectors, which contain the 2fis that are 
counted in <code>nclear.2fis</code> 
for the respective rows of <code>blockcols</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Chen, J., Sun, D.X. and Wu, C.F.J. (1993) 
A catalogue of 2-level and 3-level orthogonal arrays. 
<em>International Statistical Review</em> <b>61</b>, 131-145. 
</p>
<p>Sun, D.X., Wu, C.F.J. and Chen, Y.Y. (1997). 
Optimal blocking schemes for <code class="reqn">2^n</code> and <code class="reqn">2^{n-p}</code> designs. <em>Technometrics</em> <b>39</b>, 
298-307. 
</p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+FrF2">FrF2</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>## look at possibilities for running a 32 run design with 6 factors in 8 blocks
## running this without alias.block.2fis=TRUE throws an error: not possible
## Not run: blockpick(k=5,design="6-1.1",k.block=3)
## the 8th to 10th design have more clear 2fis than the earlier ones
blockpick(k=5,design="6-1.1",k.block=3,alias.block.2fis=TRUE)
## function FrF2 can be used to manually accomodate this 
des32.6fac.8blocks.MaxC2 &lt;- FrF2(32,6,blocks=c(3,12,21),alias.block.2fis=TRUE)
summary(des32.6fac.8blocks.MaxC2)
## automatic block generation leads to more aliased 2fis
summary(FrF2(32,6,blocks=8,alias.block.2fis=TRUE))

## look at possibilities for blocking design 7-3.1 from Chen, Sun, Wu catalogue
blockpick(4,design="7-3.1",k.block=2,alias.block.2fis=TRUE)

## big design
## running this throws an error on many machines because of too little memory
## Not run: blockpick(6,design="7-1.2",k.block=5,alias.block.2fis=TRUE)
## for obtaining a design for this scenario with blockpick.big, 
## the number of factors must be increased to 7+k.block=12
## designs 12-6.1 and 12-6.2 dont do it, 12-6.3 does
bpb &lt;- blockpick.big(6,design="12-6.3",k.block=5,alias.block.2fis=TRUE)
bpb
## based on the result of blockpick.big, a blocked design can be obtained as follows:
## (not run for saving check time on CRAN)
## Not run: 
des64.7fac.32blocks &lt;- FrF2(64,gen=bpb$gen[1,], blocks = as.list(1:5), 
   alias.block.2fis=TRUE)
str(des64.7fac.32blocks)
## if the seven factors are to be named A,...,G:
des64.7fac.32blocks &lt;- FrF2(64,gen=bpb$gen[1,], blocks = as.list(1:5), 
   alias.block.2fis=TRUE, factor.names=c(paste("b",1:5,sep=""),Letters[1:7]))
str(des64.7fac.32blocks)

## End(Not run)
</code></pre>

<hr>
<h2 id='BsProb.design'> Bayesian posterior probabilities from Box and Meyer method </h2><span id='topic+BsProb.design'></span>

<h3>Description</h3>

<p>The function calculates Bayesian posterior probabilities according 
to Box and Meyer (1993) for screening experiments with 2-level factors.
The function is modified from function BsProb in packge <span class="pkg">BsMD</span>
with the purpose of providing usage comfort for 
class design objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BsProb.design(design, mFac = NULL, response=NULL, select=NULL, mInt = 2, p = 0.25, g = 2,
    ng = 1, nMod = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BsProb.design_+3A_design">design</code></td>
<td>
<p>an experimental design of class <code><a href="DoE.base.html#topic+class-design">design</a></code> 
with the <code>type</code> element of the <code>design.info</code> attribute 
containing &ldquo;FrF2&rdquo; or &ldquo;pb&rdquo; and at least one response variable</p>
</td></tr>
<tr><td><code id="BsProb.design_+3A_response">response</code></td>
<td>
<p> NULL or a character string that specifies response variable to be used, 
must be an element of <code>response.names(obj)</code>; 
if NULL, the first response from <code>response.names(obj)</code> is used</p>
</td></tr>
<tr><td><code id="BsProb.design_+3A_mfac">mFac</code></td>
<td>
<p>integer. Maximum number of factors included in the models.
The default is the number of factors in the design.</p>
</td></tr>
<tr><td><code id="BsProb.design_+3A_select">select</code></td>
<td>
<p> vector with position numbers of the factors to be included; <br />
default: all factors. </p>
</td></tr>
<tr><td><code id="BsProb.design_+3A_mint">mInt</code></td>
<td>
<p>integer &lt;= 3. Maximum order of interactions considered in the models.
This can strongly impact the result.</p>
</td></tr>
<tr><td><code id="BsProb.design_+3A_p">p</code></td>
<td>
<p>numeric. Prior probability assigned to active factors.
This can strongly impact the result.</p>
</td></tr>
<tr><td><code id="BsProb.design_+3A_g">g</code></td>
<td>
<p>numeric vector. Variance inflation factor(s) gamma associated to active and interaction factors;
see &quot;Details&quot; section</p>
</td></tr>
<tr><td><code id="BsProb.design_+3A_ng">ng</code></td>
<td>
<p>integer &lt;=20. Number of different variance inflation factors (g) used in calculations.</p>
</td></tr>
<tr><td><code id="BsProb.design_+3A_nmod">nMod</code></td>
<td>
<p>integer &lt;=100. Number of models to keep with the highest posterior probability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Factor and model posterior probabilities are computed by the Box and Meyer (1993) Bayesian procedure. 
The design factors - or a selection of these given by column numbers in <code>select</code> - 
are considered together with the specified response or the first response of the design. 
The function has been adapted from function <code><a href="BsMD.html#topic+BsProb">BsProb</a></code> in package <span class="pkg">BsMD</span>, 
and a vignette in that package (<a href="../../BsMD/doc/BsMD.pdf">../../BsMD/doc/BsMD.pdf</a>) explains 
details of the usage regarding the parameters.
</p>
<p>If <code>g</code>, the variance inflation factor (VIF) gamma, is a vector of length 1, 
the same VIF is used for factor main effects and interactions. 
If the length of <code>g</code> is 2 and <code>ng</code> is 1, <code>g[1]</code> 
is used for factor main effects and <code>g[2]</code> for the interaction effects. 
If <code>ng</code> greater than 1, then <code>ng</code> values of VIFs between <code>g[1]</code> and 
<code>g[2]</code> are used for calculations with the same gamma value for main effects 
and interactions. The function calls the FORTRAN subroutine <code>bm</code> and captures 
summary results. The complete output of the FORTRAN code is save in the <code>BsPrint.out</code> 
file in the working directory. The output is a list of class <code>BsProb</code> 
for which print, plot and summary methods are available from package <span class="pkg">BsMD</span>.
</p>


<h3>Value</h3>

<p>cf. documentation of function <code><a href="BsMD.html#topic+BsProb">BsProb</a></code>
</p>


<h3>Note</h3>

<p>This method relies on the availability of package <span class="pkg">BsMD</span>.
</p>


<h3>Author(s)</h3>

<p>Daniel Meyer, ported to R by Ernesto Barrios, port adapted to designs by Ulrike Groemping.</p>


<h3>References</h3>

<p>Barrios, E. (2013). Using the BsMD Package for Bayesian Screening and Model
Discrimination. Vignette. <a href="../../BsMD/doc/BsMD.pdf">../../BsMD/doc/BsMD.pdf</a>.
</p>
<p>Box, G. E. P and R. D. Meyer (1986). An Analysis for Unreplicated Fractional 
Factorials. <em>Technometrics</em> <b>28</b>, 11-18.
</p>
<p>Box, G. E. P and R. D. Meyer (1993). 
Finding the Active Factors in Fractionated Screening Experiments. 
<em>Journal of Quality Technology</em> <b>25</b>, 94-105. </p>


<h3>See Also</h3>

<p><code><a href="BsMD.html#topic+plot.BsProb">plot.BsProb</a></code>, <code><a href="BsMD.html#topic+print.BsProb">print.BsProb</a></code>, 
<code><a href="BsMD.html#topic+summary.BsProb">summary.BsProb</a></code>, <code><a href="BsMD.html#topic+BsMD">BsMD</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   ### there are several success stories and recommendations for this method
   ### in the simulated example here (not fabricated, 
   ###         it was the first one that came to my mind), 
   ### the method goes wrong, at least when using mInt=2 (the default, because 
   ###         Daniel plots work quite well for pure main effects models):
   ### active factors are A to E (perhaps too many for the method to work),
   ### the method identifies F, J, and L with highest probability 
   ### (but is quite undecided)
   plan &lt;- pb(12)
   dn &lt;- desnum(plan)
   set.seed(8655)
   y &lt;- dn%*%c(2,2,2,2,3,0,0,0,0,0,0) + dn[,1]*dn[,3]*2 - dn[,5]*dn[,4] + rnorm(12)/10
   plan.r &lt;- add.response(plan, response=y)
   if (requireNamespace("BsMD", quiet=TRUE)){
   plot(bpmInt2 &lt;- BsProb.design(plan.r), code=FALSE)
   plot(bpmInt1 &lt;- BsProb.design(plan.r, mInt=1), code=FALSE) ## much better!
   summary(bpmInt2)
   summary(bpmInt1)
   }
   ### For comparison: A Daniel plot does not show any significant effects according 
   ### to Lenths method, but makes the right effects stick out
   DanielPlot(plan.r, half=TRUE, alpha=1)
</code></pre>

<hr>
<h2 id='CatalogueAccessors'> Catalogue file and accessor functions </h2><span id='topic++5B.catlg'></span><span id='topic+print.catlg'></span><span id='topic+res'></span><span id='topic+nruns'></span><span id='topic+nfac'></span><span id='topic+WLP'></span><span id='topic+nclear.2fis'></span><span id='topic+clear.2fis'></span><span id='topic+dominating'></span><span id='topic+res.catlg'></span><span id='topic+nruns.catlg'></span><span id='topic+nfac.catlg'></span><span id='topic+WLP.catlg'></span><span id='topic+nclear.2fis.catlg'></span><span id='topic+clear.2fis.catlg'></span><span id='topic+all.2fis.clear.catlg'></span><span id='topic+dominating.catlg'></span><span id='topic+res.character'></span><span id='topic+nruns.character'></span><span id='topic+nfac.character'></span><span id='topic+WLP.character'></span><span id='topic+nclear.2fis.character'></span><span id='topic+clear.2fis.character'></span><span id='topic+all.2fis.clear.character'></span><span id='topic+dominating.character'></span><span id='topic+catlg'></span><span id='topic+block.catlg'></span>

<h3>Description</h3>

<p>Functions to select elements or extract information from design catalogues of class catlg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>res(catlg)
## S3 method for class 'catlg'
res(catlg)
## S3 method for class 'character'
res(catlg)
nruns(catlg)
## S3 method for class 'catlg'
nruns(catlg)
## S3 method for class 'character'
nruns(catlg)
nfac(catlg)
## S3 method for class 'catlg'
nfac(catlg)
## S3 method for class 'character'
nfac(catlg)
WLP(catlg)
## S3 method for class 'catlg'
WLP(catlg)
## S3 method for class 'character'
WLP(catlg)
nclear.2fis(catlg)
## S3 method for class 'catlg'
nclear.2fis(catlg)
## S3 method for class 'character'
nclear.2fis(catlg)
clear.2fis(catlg)
## S3 method for class 'catlg'
clear.2fis(catlg)
## S3 method for class 'character'
clear.2fis(catlg)
all.2fis.clear.catlg(catlg)
dominating(catlg)
## S3 method for class 'catlg'
dominating(catlg)
## S3 method for class 'character'
dominating(catlg)
catlg
## S3 method for class 'catlg'
catlg[i]
## S3 method for class 'catlg'
print(x, name="all", nruns="all", nfactors="all", 
                        res.min=3, MaxC2=FALSE, show=10, 
                        gen.letters=FALSE, show.alias=FALSE, ...)
block.catlg
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CatalogueAccessors_+3A_catlg">catlg</code></td>
<td>
<p> Catalogue of designs of class <code>catlg</code> (cf. details section), or character vector with name(s) of <code>catlg</code> element(s) in case of accessor functions</p>
</td></tr>
<tr><td><code id="CatalogueAccessors_+3A_i">i</code></td>
<td>
<p> vector of index positions or logical vector that can be used for indexing a <code>catlg</code> object </p>
</td></tr>
<tr><td><code id="CatalogueAccessors_+3A_x">x</code></td>
<td>
<p> an object of class <code>catlg</code> </p>
</td></tr>
<tr><td><code id="CatalogueAccessors_+3A_name">name</code></td>
<td>
<p> character vector of entry names from <code>x</code>; default &ldquo;all&rdquo; means: no selection made </p>
</td></tr>
<tr><td><code id="CatalogueAccessors_+3A_nruns">nruns</code></td>
<td>
<p> numeric integer (vector), giving the run size(s) for entries of <code>x</code> to be shown; 
default &ldquo;all&rdquo; means: no selection made  </p>
</td></tr>
<tr><td><code id="CatalogueAccessors_+3A_nfactors">nfactors</code></td>
<td>
<p> numeric integer (vector), giving the factor number(s) for entries of <code>x</code> to be shown; 
default &ldquo;all&rdquo; means: no selection made </p>
</td></tr>
<tr><td><code id="CatalogueAccessors_+3A_res.min">res.min</code></td>
<td>
<p> numeric integer giving the minimum resolution for entries of <code>x</code> to be shown </p>
</td></tr>
<tr><td><code id="CatalogueAccessors_+3A_maxc2">MaxC2</code></td>
<td>
<p> logical indicating whether designs are ordered by minimum aberration (default, <code>MaxC2=FALSE</code>) 
or by maximum number of clear 2fis (<code>MaxC2=TRUE</code>)</p>
</td></tr>
<tr><td><code id="CatalogueAccessors_+3A_show">show</code></td>
<td>
<p> integer number indicating maximum number of designs to be shown; default is 10 </p>
</td></tr>
<tr><td><code id="CatalogueAccessors_+3A_gen.letters">gen.letters</code></td>
<td>
<p> logical indicating whether the generators should be shown as 
column numbers (default, <code>gen.letters=FALSE</code>) or as generators with 
factor letters (e.g. E=ABCD, <code>gen.letters=TRUE</code>)</p>
</td></tr>
<tr><td><code id="CatalogueAccessors_+3A_show.alias">show.alias</code></td>
<td>
<p> logical indicating whether the alias structure (up to 2fis) is to be printed </p>
</td></tr>
<tr><td><code id="CatalogueAccessors_+3A_...">...</code></td>
<td>
<p> further arguments to function <code>print</code> </p>
</td></tr>
<tr><td><code id="CatalogueAccessors_+3A_block.catlg">block.catlg</code></td>
<td>
<p> data frame with block generators for full factorial designs up to 256~runs, 
taken from Sun, Wu and Chen (1997)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>catlg</code> is a named list of design entries. 
Each design entry is again a list with the following items:
</p>

<dl>
<dt>res</dt><dd><p>resolution, numeric, i.e. 3 denotes resolution III and so forth </p>
</dd>
<dt>nfac</dt><dd><p>number of factors</p>
</dd> 
<dt>nruns</dt><dd><p>number of runs</p>
</dd> 
<dt>gen</dt><dd><p>column numbers of additional factors in Yates order</p>
</dd> 
<dt>WLP</dt><dd><p>word length pattern (starting with words of length 1, 
i.e. the first two entries are 0 for all designs in <code>catlg</code>)</p>
</dd> 
<dt>nclear.2fis</dt><dd><p>number of clear 2-factor interactions (i.e. free of aliasing with main effects or other 2-factor interactions)</p>
</dd> 
<dt>clear.2fis</dt><dd><p>2x<code>nclear.2fis</code> matrix of clear 2-factor interactions 
(clear to be understood in the above sense); this matrix represents 
each designs clear interaction graph, which can be used in automated searches for 
designs that can accomodate (i.e. clearly) a certain requirement set 
of 2-factor interactions; cf. also <code><a href="#topic+estimable.2fis">estimable.2fis</a></code> </p>
</dd> 
<dt>all.2fis.clear</dt><dd><p>vector of factors with all 2-factor interactions clear in the above sense</p>
</dd>
<dt>dominating</dt><dd><p>logical that indicates whether the current design adds a 
CIG structure that has not been seen for a design with less aberration 
(cf. Wu, Mee and Tang 2012 p.196 for dominating designs);
TRUE, if so; FALSE, if current CIG is isomorphic to previous one or 
has no edges (IMPORTANT: the dominance assessment refers to the current 
catalogue; for designs with more than 64 runs, it is possible that 
a design marked dominating in catalogue <code>catlg</code> is not dominating 
when considering ALL non-isomorphic designs). <br />
This element is helpful in omitting non-promising 
designs from a search for a clear design.<br />
This element may be missing. In that case, all catalogue entries 
are assumed dominating. </p>
</dd>
</dl>

<p>Reference to factors in components <code>clear.2fis</code> and <code>all.2fis.clear</code> 
is via their position number (element of (1:nfac)). 
</p>
<p>The <code>print</code> function for class <code>catlg</code> gives a concise overview of selected designs in any design catalogue of class <code>catlg</code>. 
It is possible to restrict attention to designs with certain run sizes, numbers of factors, and/or to request a minimum resolutions. 
Designs are ordered in decreasing quality, where the default is aberration order, but number of clear 2fis can be requested alternatively. 
The best 10 designs are displayed per default; this number can be changed by the <code>show</code> option. 
Options <code>gen.letters</code> and <code>show.alias</code> influence the style and amount of printed output.
</p>
<p>The catalogue <code>catlg</code>, which is included with package <code>FrF2</code>, 
is of class <code>catlg</code> and is a living object, since it has to be updated with 
recent research results for larger designs. In particular, new MA designs may be found, 
or it may be proven that previous &ldquo;good&rdquo; designs are in fact of minimum aberration.
</p>
<p>Currently, the catalogue contains
</p>

<ul>
<li><p> the Chen, Sun and Wu (1993) 2-level designs 
(complete list of 2-level fractional factorials from 4 to 32~runs, 
complete list of resolution IV 2-level fractional factorials with 64~runs). 
Note that the Chen Sun Wu paper only shows a selection of the 64~run designs, the 
complete catalogue has been obtained from Don Sun and is numbered according to 
minimum aberration (lower number = better design); numbering in the paper is 
not everywhere in line with this numbering. 
</p>
</li>
<li><p> minimum aberration (MA) resolution III designs for 33 to 63 factors in 
64 runs. The first few of these have been obtained from Appendix G of 
Mee 2009, the designs for 38 and more factors have been constructed by combining 
a duplicated minimum aberration design in 32 runs and the required number of factors 
with columns 32 to 63 of the Yates matrix for 64 run designs. Using complementary 
design theory (cf. e.g. Chapter 6.2.2 in Mee 2009), it can be shown that the resulting 
designs are minimum aberration (because they are complementary to basically the same 
designs as the designs in 32 runs on which they are based). The author is grateful 
to Robert Mee for pointing this out.
</p>
</li>
<li><p> the MA designs in 128 runs:
</p>

<ul>
<li><p> for up to 24 factors obtained from Xu (2009),
</p>
</li>
<li><p> for 25 to 64 factors taken from Block and Mee (2005, with corrigendum 2006),
</p>
</li>
<li><p> for 65 to 127 factors (resolution III): up to 69 factors coming from Appendix G 
in Mee, whereas the designs for 70 or more factors have been  
constructed according to the same principle mentioned for the 64 run designs.</p>
</li></ul>

</li>
<li><p> various further &ldquo;good&rdquo; resolution IV designs in 128 runs obtained by evaluating 
designs from the complete catalogue by Xu (2009, catalogue on his website) 
w.r.t. aberration and number of clear 2fis (including also all designs that yield 
minimum aberration clear compromise designs according to Groemping 2010); all designs 
with resolution at least IV for up to 11 factors have been added with version 2.2.
</p>
</li>
<li><p> the MA even designs in 128 runs, in support of blocking according to the 
Godolphin approach have been added with version 2.2.
</p>
<p>Note that additional non-isomorphic resolution IV designs in 128 runs are 
available in package (<span class="pkg">FrF2.catlg128</span>); since the catalogues are quite large, 
they are not forced upon users of this package who do not need them. 
Since version 1.1 of that package, the catalogues are not complete but contain 
high resolution fractions and even/odd fractions only (status: version 1.2-x); 
re-inclusion of at least selected even fractions is intended, because these 
may yield improved support of blocking in connection with estimable 2fis.
</p>
</li>
<li><p> the best (MA) resolution IV or higher designs in <br />
256 runs for up to 36 factors (resolution V up to 17 factors),<br /> 
512 runs for up to 29 factors (resolution V for up to 23 factors).<br /> 
These have been taken from Xu (2009) with additions by Ryan and Bulutoglu 
(2010). 
</p>
</li>
<li><p> Further &ldquo;good&rdquo; resolution IV designs with up to 80 factors in 
256 runs and up to 160 factors in 512 runs have also been implemented from Xu (2009).
</p>
</li>
<li><p> the best (MA) resolution V or higher design for each number of factors or 
a &ldquo;good&rdquo; such design (if it is not known which one is best) in <br />
1024 runs (up to 33 factors, MA up to 28 factors, resolution VI up to 24 factors), <br />
2048 runs (up to 47 factors, MA up to 32 factors, resolution VI up to 34 factors),<br />
and 4096 runs (up to 65 factors, MA up to 26 factors, resolution VI up to 48 factors).<br /> 
</p>
<p>Most of the large designs in <code>catlg</code> have been taken from Xu (2009), 
where complete catalogues of some scenarios are provided 
(cf. also his website) as well as &ldquo;good&rdquo; (not necessarily MA) designs for a larger 
set of situations. Some of the good designs by Xu (2009) have later been shown 
to be MA by Ryan and Bulutoglu (2010), who also found some additional larger MA designs, 
which are also included in <code>catlg</code>. Non-MA designs that 
were already available before Bulutoglu (2010) are still in the catalogue with their old name.
(Note that designs that are not MA and cannot be placed in the ranking do not 
have a running number in the design name; for example, the MA 2048 runs 
design in 28 factors is named 28-17.1, the older previous design 
that was not MA is named 28-17 (without &ldquo;.1&rdquo; or another placement, 
because the designs position in the ranking of all designs is not known.)) 
</p>
</li></ul>

<p>There are also some non-regular 2-level fractional factorial designs of resolution V 
which may be interesting, as it is possible to increase the number of factors for which 
resolution V is possible (cf. Mee 2009, Chapter 8). 
These are part of package <span class="pkg">DoE.base</span>, which is automatically 
loaded with this package. With versions higher than 0.9-14 of that package, 
the following arrays are available: <br />
<code>L128.2.15.8.1</code>, which allows 4 additional factors and blocking into up to 8 blocks<br />
<code>L256.2.19</code>, which allows just 2 additonal factors<br />
<code>L2048.2.63</code>, which allows 16 additional factors.
These non-regular arrays should be fine for most purposes; the difference to the arrays generated 
by function <code>FrF2</code> lies in the fact that there is partial aliasing, e.g. between 3-factor interactions 
and 2-factor interactions. This means that an affected 3-factor interaction is 
partially aliased with several different 
2-factor interactions rather than being aliased either fully or not at all.
</p>


<h3>Value</h3>

<p><code>[</code> selects a subset of designs based on <code>i</code>, which is again a list of class <code>catlg</code>, even if a single element is selected.
<code>res</code>, <code>nruns</code>, <code>nfac</code>, <code>nclear.2fis</code> 
and <code>dominating</code> return a named vector, 
the <code>print</code> method does not return anything (i.e. it returns <code>NULL</code>), and 
the remaining functions return a list.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Block, R. and Mee, R. (2005) Resolution IV Designs with 128 Runs <em>Journal of Quality Technology</em> <b>37</b>, 282-293.
</p>
<p>Block, R. and Mee, R. (2006) Corrigenda <em>Journal of Quality Technology</em> <b>38</b>, 196.
</p>
<p>Chen, J., Sun, D.X. and Wu, C.F.J. (1993) A catalogue of 2-level and 3-level orthogonal arrays. <em>Int. Statistical Review</em> <b>61</b>, 131-145.
</p>
<p>Groemping, U. (2012). Creating clear designs: a graph-based algorithm and a 
catalog of clear compromise plans. <em>IIE Transactions</em> <b>44</b>, 988-1001. 
doi: <a href="https://doi.org/10.1080/0740817X.2012.654848">10.1080/0740817X.2012.654848</a>. Early preprint at 
<a href="http://www1.bht-berlin.de/FB_II/reports/Report-2010-005.pdf">http://www1.bht-berlin.de/FB_II/reports/Report-2010-005.pdf</a>.
</p>
<p>Mee, R. (2009). <em>A Comprehensive Guide to Factorial Two-Level Experimentation</em>. 
New York: Springer.
</p>
<p>Ryan, K.J. and Bulutoglu, D.A. (2010). Minimum Aberration Fractional Factorial Designs With Large N.
<em>Technometrics</em> <b>52</b>, 250-255.
</p>
<p>Sun, D.X., Wu, C.F.J. and Chen, Y.Y. (1997). 
Optimal blocking schemes for <code class="reqn">2^p</code> and <code class="reqn">2^{n-p}</code> designs. <em>Technometrics</em> <b>39</b>, 
298-307. 
</p>
<p>Wu, H., Mee, R. and Tang, B. (2012). Fractional Factorial Designs With Admissible 
Sets of Clear Two-Factor Interactions. <em>Technometrics</em> <b>54</b>, 191-197.
</p>
<p>Xu, H. (2009) Algorithmic Construction of Efficient Fractional Factorial Designs 
With Large Run Sizes. <em>Technometrics</em> <b>51</b>, 262-277.
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+FrF2">FrF2</a></code>, <code><a href="DoE.base.html#topic+oa.design">oa.design</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>c8 &lt;- catlg[nruns(catlg)==8]
nclear.2fis(c8)
clear.2fis(c8)
all.2fis.clear.catlg(c8)

## inspecting a specific catalogue element
clear.2fis("9-4.2")

## usage of print function for inspecting catalogued designs
## the first 10 resolution V+ designs in catalogue catlg
print(catlg, res.min=5)
## the 10 resolution V+ designs in catalogue catlg with the most factors
## (for more than one possible value of nfactors, MaxC2 does usually not make sense)
print(catlg, res.min=5, MaxC2=TRUE)

## designs with 12 factors in 64 runs (minimum resolution IV because 
## no resolution III designs of this size are in the catalogue)
## best 10 aberration designs
print(catlg, nfactors=12, nruns=64)
## best 10 clear 2fi designs
print(catlg, nfactors=12, nruns=64, MaxC2=TRUE)
## show alias structure
print(catlg, nfactors=12, nruns=64, MaxC2=TRUE, show.alias=TRUE)
## show best 20 designs
print(catlg, nfactors=12, nruns=64, MaxC2=TRUE, show=20)

## use vector-valued nruns 
print(catlg, nfactors=7, nruns=c(16,32))
## all designs (as show=100 is larger than available number of designs)
##    with 7 or 8 factors in 16 runs
print(catlg, nfactors=c(7,8), nruns=16, show=100)

## the irregular resolution V arrays from package DoE.base (from version 0.9-17)
## designs can be created from them using function oa.design
## Not run: 
## not run in case older version of DoE.base does not have these
length3(L128.2.15.8.1)
length4(L128.2.15.8.1)  ## aliasing of 2fis with block factor
length4(L128.2.15.8.1[,-16])

length3(L256.2.19)
length4(L256.2.19)

##length3(L2048.2.63) 
##length4(L2048.2.63) do not work resource wise
## but the array is also resolution V (but irregular)

## End(Not run)
</code></pre>

<hr>
<h2 id='CIG'> Clear interactions graph from catlg entry </h2><span id='topic+CIGstatic'></span><span id='topic+CIG'></span><span id='topic+gen2CIG'></span>

<h3>Description</h3>

<p>Function CIG creates a clear interactions graph (CIG) 
from a catlg design (design name must be given). 
Function CIGstatic allows to create a static graph from a dynamically-adjusted 
one. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIG(design, select.catlg = catlg, nfac = NULL, static = FALSE, 
   layout = layout.auto, label = "num", plot = TRUE, ...)
CIGstatic(graph, id, label = "num", xlim = c(-1,1), ylim = c(1,-1), ...)
gen2CIG(nruns, gen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CIG_+3A_design">design</code></td>
<td>
<p>a character string that identifies a design in the catalogue specified 
by option <code>select.catlg</code>, <br />
OR a class <code>catlg</code> object with a single entry, <br />
OR a formula with all main effects and the requested clear 2-factor 
interactions, <br />
OR a character vector of length more than one with two-letter combinations of 
the clear 2-factor interactions,<br />
OR a numeric two-row matrix with factor numbers of the clear 2-factor 
interactions,<br />
OR a character two-row matrix with factor names of the clear 2-factor 
interactions.<br />
The first two are for graphing design CIGs, the other ones for requirement 
set CIGs.</p>
</td></tr>
<tr><td><code id="CIG_+3A_select.catlg">select.catlg</code></td>
<td>
<p>name of catalogue (not in quotes); 
only relevant, if <code>design</code> is a character string</p>
</td></tr>
<tr><td><code id="CIG_+3A_nfac">nfac</code></td>
<td>
<p>number of factors; this is not needed for a class <code>catlg</code> object, 
or if the graph is supposed to show only factors that are involved 
in at least one interaction</p>
</td></tr>
<tr><td><code id="CIG_+3A_static">static</code></td>
<td>
<p>logical. If <code>TRUE</code>, a static graphic is produced, 
otherwise an interactive graphic is created that can be modified 
by moving aroung nodes; only relevant for <code>plot=TRUE</code></p>
</td></tr>
<tr><td><code id="CIG_+3A_layout">layout</code></td>
<td>
<p>ignored for <code>static=FALSE</code>;<br />
possible values are two-column matrices with number of rows 
equal to the number of vertices of the graph, or layout parameters for 
function <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code> as described in 
<code><a href="igraph.html#topic+plot.common">plot.common</a></code> 
and <code><a href="igraph.html#topic+layout">layout</a></code>;<br />
default: <code>layout.auto</code> (changed with version 1.6, was <code>layout.circle</code> 
before</p>
</td></tr>
<tr><td><code id="CIG_+3A_label">label</code></td>
<td>
<p>in effect for <code>catlg</code> object only (character design name or 
class <code>catlg</code> object);<br />
a character string that decides for numeric labels or 
character labels; any string other than the default will invoke the 
factor letters as labels</p>
</td></tr>
<tr><td><code id="CIG_+3A_plot">plot</code></td>
<td>
<p>a logical that decides whether a plot is requested (default: <code>TRUE</code>);<br />
plotting can be suppressed, if graph creation is desired for calculating 
graph characteristics with functions from package <code>igraph</code> 
(e.g. <code><a href="igraph.html#topic+cliques">clique.number</a></code>,
<code><a href="igraph.html#topic+cliques">largest.cliques</a></code>, 
<code><a href="igraph.html#topic+independent.vertex.sets">independence.number</a></code>,
<code><a href="igraph.html#topic+degree">degree</a></code>) </p>
</td></tr>
<tr><td><code id="CIG_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to function <code><a href="igraph.html#topic+tkplot">tkplot</a></code>, 
or graphical parameters to be passed to <code>plot</code>.</p>
</td></tr>
<tr><td><code id="CIG_+3A_graph">graph</code></td>
<td>
<p>a graph object from package <code>igraph</code>, or a list whose first 
element is such a graph object (like the output from function <code>CIG</code>)</p>
</td></tr>
<tr><td><code id="CIG_+3A_id">id</code></td>
<td>
<p>identification number of the interactive graph to be reproduced in 
static form; this number can be found in the header line of the graphics window</p>
</td></tr>
<tr><td><code id="CIG_+3A_xlim">xlim</code></td>
<td>
<p>horizontal axis limits</p>
</td></tr>
<tr><td><code id="CIG_+3A_ylim">ylim</code></td>
<td>
<p>vertical axis limits (per default reversed in order to exactly 
reproduce the interactive graph) </p>
</td></tr>
<tr><td><code id="CIG_+3A_nruns">nruns</code></td>
<td>
<p>number of runs of the design to be graphed </p>
</td></tr>
<tr><td><code id="CIG_+3A_gen">gen</code></td>
<td>
<p>generator (vector of Yates matrix column numbers) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The design depicted in <code>CIG</code> has to be the name (character string) of a 
regular fractional factorial 2-level design present in <code>select.catlg</code>. 
</p>
<p>Clear 2fis are depicted as edges in the graph. In the interactive graph, 
users can change the layout manually or with the menus. For example, 
the Reingold-Tilford layout can be chosen, with a root vertex specified; 
this sometimes helps in identifying groups 
of vertices that are not connected with each other. 
</p>
<p>Previous versions of package <code>igraph</code> used to internally number the 
vertices from 0 to number of vertices -1, not from 1 to number of vertices. 
This has been changed 
in June 2012 (FrF2 adapted to this change with version 1.5).
</p>
<p>Function <code>CIGstatic</code> serves the purpose to statically create the current 
interactively modified graph; 
the usual annotation possibilities for plots are available.
</p>
<p>Function <code>gen2CIG</code> returns a graph object that can be plotted or otherwise 
investigated with graph-related 
functionality.
</p>


<h3>Value</h3>

<p>For <code>plot=FALSE</code> or <code>plot=TRUE</code> with <code>static=TRUE</code>, 
function <code>CIG</code> visibly (<code>plot=FALSE</code>) or invisibly (<code>plot=TRUE</code>) 
returns a graph from package <code>igraph</code>.<br />
For <code>plot=TRUE</code> with <code>static=FALSE</code>, 
the function returns a list with the first element <code>graph</code> 
the element <code>coords</code> with the coordinates of that graph. <br />
Function <code>CIGstatic</code> works on the list produced by function <code>CIG</code> 
by plotting the graph statically using the positioning from the 
current interactive picture. 
</p>
<p>Function <code>gen2CIG</code> returns a clear interactions graph that can e.g. be 
plotted with functions <code>plot</code> (<code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>) or 
<code><a href="igraph.html#topic+tkplot">tkplot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping</p>


<h3>References</h3>

<p>Groemping, U. (2012). Creating clear designs: a graph-based algorithm and a 
catalog of clear compromise plans. <em>IIE Transactions</em> <b>44</b>, 988-1001. 
doi: <a href="https://doi.org/10.1080/0740817X.2012.654848">10.1080/0740817X.2012.654848</a>. Early preprint at 
<a href="http://www1.bht-berlin.de/FB_II/reports/Report-2010-005.pdf">http://www1.bht-berlin.de/FB_II/reports/Report-2010-005.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>, <code><a href="igraph.html#topic+tkplot">tkplot</a></code>,
<code><a href="igraph.html#topic+plot.common">plot.common</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ex.CIG &lt;- CIG("9-4.2", vertex.color="white", vertex.label.color="darkred")
## play around with the dynamic graph until it looks right
## look up its id number in the title bar of the graph window and use it for id
par(xpd=TRUE)
CIGstatic(ex.CIG, id=1)

## End(Not run)

graph1 &lt;- CIG("9-4.2", plot=FALSE)   ### create graph object from design name
### calculate graph properties
require(igraph)
degree(graph1)
clique.number(graph1)
independence.number(graph1)
largest.cliques(graph1)

graph2 &lt;- gen2CIG(32, c(7,11,14,29))   ### create graph object from generator columns
### check isomorphism to graph1
graph.isomorphic(graph1, graph2)

## Not run: 
## use a CIG for manual design search
## requirement set: 
estim &lt;- compromise(9, 8:9)$requirement ## all interactions of factors 8 and 9 (H, J)
## graph the requirement set CIG
CIG(estim, vertex.color="white", vertex.label.color="darkred")
## a human can easily see that columns 1, 8 and 9 are worth a try for factors P, Q and R
CIG("9-4.1", vertex.color="white", vertex.label.color="darkred")
    ## obviously, 9-4.1 cannot accommodate the requirement set
CIG("9-4.2", vertex.color="white", vertex.label.color="darkred")
    ## 9-4.2 can, by assigning factors H and J to columns 5 and 9
## function FrF2 automatically does such matchings

## End(Not run)
</code></pre>

<hr>
<h2 id='compromise'> Function to support estimability requests for compromise designs </h2><span id='topic+compromise'></span>

<h3>Description</h3>

<p>Addelman (1962) and Ke and Wu (2005) discuss compromise plans of different types. 
Their creation is supported by the function compromise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    compromise(nfactors, G1, class=3, msg=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compromise_+3A_nfactors">nfactors</code></td>
<td>
<p> overall number of factors</p>
</td></tr>
<tr><td><code id="compromise_+3A_g1">G1</code></td>
<td>
<p> vector with indices of factors in group G1 (cf. details)</p>
</td></tr>
<tr><td><code id="compromise_+3A_class">class</code></td>
<td>
<p> class of compromise designs that is to be generated; 1, 2, 3, or 4, cf. details below </p>
</td></tr>
<tr><td><code id="compromise_+3A_msg">msg</code></td>
<td>
<p> logical stating whether the <code>minnruns.clear</code> element of the result
should be reported in a message</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For compromise plans, the factors are decomposed into a group G1 and a group G2. 
The different classes of compromise plans require estimability of different subsets 
of 2fis in addition to main effects:<br /><br />
Class 1: all 2fis within group G1 are estimable<br />
Class 2: all 2fis within group G1 are estimable, 
as well as all 2fis within group G2<br />
Class 3: all 2fis within group G1 are estimable, 
as well as all 2fis between groups G1 and G2<br />
Class 4: all 2fis between groups G1 and G2 are estimable<br />
</p>
<p>The function returns a list of four components (cf. section &ldquo;Value&rdquo;). 
They can be used as input for the function <code><a href="#topic+FrF2">FrF2</a></code>, if compromise 
plans are to be created. Both distinct designs (Addelman 1962) and clear designs 
(Ke, Tang and Wu 2005) can be constructed, 
depending on the settings of option <code>clear</code> in function 
<code><a href="#topic+FrF2">FrF2</a></code>. More explanations on specifying estimability requirements 
for 2fis in general are provided under <code><a href="#topic+estimable.2fis">estimable.2fis</a></code>.
</p>


<h3>Value</h3>

<p>Value is a list of the four components <code>perms.full</code>, <code>requirement</code>, 
<code>class</code>, and <code>minnrun.clear</code>. The last two components are purely imformative, 
while the first two provide input parameters for function <code><a href="#topic+FrF2">FrF2</a></code>.<br />
<code>requirement</code> can be used for specifying the required 2fis in the <code>estimable</code> option, 
both with <code>clear=FALSE</code> and <code>clear=TRUE</code>. 
For <code>clear=FALSE</code>, <code>perms.full</code> can be used in the <code>perms</code> option 
for speeding up the search into a hopefully realistic time frame.<br /> 
<code>minnrun.clear</code> indicates the minimum number of runs needed for a clear design.
</p>
<p>Note that the catalogue <code><a href="#topic+catlg">catlg</a></code> contains all designs needed for 
accomodating existing clear compromise designs in up to 128 runs (even minimum aberration
among all existing clear compromise designs; for a catalogue of these, cf. Gr\&quot;omping 2010).
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Addelman, S. (1962). Symmetrical and asymmetrical fractional factorial plans. 
<em>Technometrics</em> <b>4</b>, 47-58.
</p>
<p>Groemping, U. (2012). Creating clear designs: a graph-based algorithm and a 
catalog of clear compromise plans. <em>IIE Transactions</em> <b>44</b>, 988-1001. 
doi: <a href="https://doi.org/10.1080/0740817X.2012.654848">10.1080/0740817X.2012.654848</a>. Early preprint at 
<a href="http://www1.bht-berlin.de/FB_II/reports/Report-2010-005.pdf">http://www1.bht-berlin.de/FB_II/reports/Report-2010-005.pdf</a>.
</p>
<p>Ke, W., Tang, B. and Wu, H. (2005). Compromise plans with clear two-factor interactions. 
<em>Statistica Sinica</em> <b>15</b>, 709-715.
</p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+FrF2">FrF2</a></code> for creation of regular fractional factorial designs 
as well as <code><a href="#topic+estimable.2fis">estimable.2fis</a></code> 
for statistical and algorithmic information on estimability of 2-factor interactions</p>


<h3>Examples</h3>

<pre><code class='language-R'>## seven factors two of which are in group G1
C1 &lt;- compromise(7, c(2,4), class=1)
C1$perms.full  ## the same for all classes
C1$requirement
C2 &lt;- compromise(7, c(2,4), class=2)
C2$requirement
C3 &lt;- compromise(7, c(2,4), class=3)
C3$requirement
C4 &lt;- compromise(7, c(2,4), class=4)
C4$requirement

## Not run: 
########## usage of estimable ###########################
  ## design with with BD clear in 16 runs
  FrF2(16,7,estimable = C1$requirement)
  ## design with BD estimable on a distinct column in 16 runs (any design will do,
  ##    if resolution IV!!!
  FrF2(16,7,estimable = C1$requirement, clear=FALSE, perms=C1$perms.full)
  ## all four classes, mostly clear, for 32 runs
  FrF2(32,7,estimable = C1$requirement)
  FrF2(32,7,estimable = C2$requirement)   ## requires resolution V
         ## as clear class 2 compromise designs do not exist due to Ke et al. 2005
  FrF2(32,7,estimable = C2$requirement, clear=FALSE, perms=C2$perms.full)
  FrF2(32,7,estimable = C3$requirement)
  FrF2(32,7,estimable = C4$requirement)
  ## two additional factors H and J that do not show up in the requirement set
  FrF2(32,9,estimable = C3$requirement)
  ## two additional factors H and J that do not show up in the requirement set
  FrF2(32,9,estimable = C3$requirement, clear=FALSE)
  ## note that this is not possible for distinct designs in case perms is needed,
  ## because perms must have nfactors columns

## End(Not run)
</code></pre>

<hr>
<h2 id='cubePlot'> Cube plot for three-factor-effects </h2><span id='topic+cubePlot'></span><span id='topic+cubedraw'></span><span id='topic+cubecorners'></span><span id='topic+cubelabel'></span><span id='topic+myscatterplot3d'></span>

<h3>Description</h3>

<p>A cube plot for the combined effect of three factors is produced (function cubePlot). 
Functions cubedraw, cubecorners, cubelabel and myscatterplot3d are not intended for users. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubePlot(obj, eff1, eff2, eff3, main=paste("Cube plot for",respnam),
    cex.title=1.5,cex.lab=par("cex.lab"), cex.ax=par("cex.axis"),  
    cex.clab=1.2, size=0.3, round=NULL,
    abbrev=4,y.margin.add=-0.2, modeled=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubePlot_+3A_obj">obj</code></td>
<td>
<p> a vector of response values to be analyzed
</p>
<p>OR
</p>
<p>a linear model object with 2-level factors or numerical 
2-level variables (CAUTION: numerical x-variable have to be 
coded as -1 and +1 only!); 
the structure must be such that effects are either fully 
aliased or orthogonal, like in a fractional factorial 2-level 
design</p>
</td></tr>
<tr><td><code id="cubePlot_+3A_eff1">eff1</code></td>
<td>
<p> cf. <code>eff3</code> </p>
</td></tr>
<tr><td><code id="cubePlot_+3A_eff2">eff2</code></td>
<td>
<p> cf. <code>eff3</code> </p>
</td></tr>
<tr><td><code id="cubePlot_+3A_eff3">eff3</code></td>
<td>
<p> effects to be included in the cube plot (x-, y-, z-direction),
EITHER vectors of equal length (two-level factors or numerical 
with the two values -1 and 1)
OR variable names of main effects within the <code>obj</code> linear
model object (character strings) </p>
</td></tr>
<tr><td><code id="cubePlot_+3A_main">main</code></td>
<td>
<p> title for the plot, <code>respnam</code> is the name of the 
response variable as determined from the call </p>
</td></tr>
<tr><td><code id="cubePlot_+3A_cex.title">cex.title</code></td>
<td>
<p>multiplier for size of overall title 
(<code>cex.main</code> is multiplied with this factor) </p>
</td></tr> 
<tr><td><code id="cubePlot_+3A_cex.ax">cex.ax</code></td>
<td>
<p> size of axis tick marks, defaults to <code>cex.axis</code>-parameter </p>
</td></tr>
<tr><td><code id="cubePlot_+3A_cex.lab">cex.lab</code></td>
<td>
<p> size of axis labels </p>
</td></tr>
<tr><td><code id="cubePlot_+3A_cex.clab">cex.clab</code></td>
<td>
<p> size of corner labels </p>
</td></tr>
<tr><td><code id="cubePlot_+3A_size">size</code></td>
<td>
<p> size of cube corners </p>
</td></tr>
<tr><td><code id="cubePlot_+3A_round">round</code></td>
<td>
<p> optional rounding of corner labels (digits argument for function 
<code>round</code>, e.g. round=0 for integers, round=-1 for multiples
of 10, round=1 for 1 decimal place</p>
</td></tr>
<tr><td><code id="cubePlot_+3A_abbrev">abbrev</code></td>
<td>
<p> number of characters shown for factor levels </p>
</td></tr>
<tr><td><code id="cubePlot_+3A_y.margin.add">y.margin.add</code></td>
<td>
<p> adjustment parameter for placement of y-axis labeling </p>
</td></tr>
<tr><td><code id="cubePlot_+3A_modeled">modeled</code></td>
<td>
<p> TRUE (default: show modeled means; FALSE: show averages 
</p>
<p>NOTE: Even when showing modeled means, there also appears to 
be a three-factor-interaction, if the model contains an effect
that is aliased with this interaction!</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cubePlot</code> produces a cube plot of the modeled means or averages of 
all combinations for three factors. The other functions are internal
and are called by cubePlot.
<code>myscatterplot3d</code> is a modified version of scatterplot3d, 
made more suitable for this situation.
</p>


<h3>Value</h3>

<p><code>cubePlot</code> is used for its side effects only. 
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Box G. E. P, Hunter, W. C. and Hunter, J. S. (2005)
<em>Statistics for Experimenters, 2nd edition</em>.
New York: Wiley.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+FrF2-package">FrF2-package</a></code> for examples </p>

<hr>
<h2 id='DanielPlot'> Normal or Half-Normal Effects Plots </h2><span id='topic+DanielPlot'></span><span id='topic+DanielPlot.design'></span><span id='topic+DanielPlot.default'></span>

<h3>Description</h3>

<p>The function is modified from the same-name function in packge <span class="pkg">BsMD</span>
with the purpose of providing more usage comfort (correct effect sizes 
in case of factors, automatic annotation, 
automatic labelling of the most significant factors only).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DanielPlot(fit, ...)
## S3 method for class 'design'
DanielPlot(fit, ..., response = NULL)
## Default S3 method:
DanielPlot(fit, code = FALSE, autolab = TRUE, alpha = 0.05, faclab = NULL, 
       block = FALSE, datax = TRUE, half = FALSE, pch = "*", 
       cex.fac = par("cex.lab"), cex.lab = par("cex.lab"), 
       cex.pch = par("cex"), cex.legend = par("cex.lab"), 
       main = NULL, subtitle=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DanielPlot_+3A_fit">fit</code></td>
<td>
<p>an experimental design of class <code><a href="DoE.base.html#topic+class-design">design</a></code> 
with the <code>type</code> element of the <code>design.info</code> attribute 
containing &ldquo;FrF2&rdquo; or &ldquo;pb&rdquo;<br />
OR<br />
object of class <code>lm</code>. Fitted model from <code>lm</code> or <code>aov</code>.</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the default function, 
or graphical parameters to be passed to <code>plot</code>;
note that one should not use <code>pch</code> for split-plot designs.</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_response">response</code></td>
<td>
<p> NULL or a character string that specifies response variable to be used, 
must be an element of <code>response.names(obj)</code>; 
if NULL, the first response from <code>response.names(obj)</code> is used</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_code">code</code></td>
<td>
<p>logical. If <code>TRUE</code> labels &ldquo;A&rdquo;,&ldquo;B&rdquo;, etc. are used 
instead of the names of the coefficients (factors). A legend linking 
codes to names is provided.</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_autolab">autolab</code></td>
<td>
<p> If TRUE, only the significant factors according to the Lenth method
(significance level given by <code>alpha</code>) are labelled. </p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_alpha">alpha</code></td>
<td>
<p> significanc level for the Lenth method </p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_faclab">faclab</code></td>
<td>
<p>NULL or list. 
If <code>NULL</code>, point labels are automatically determined according to the 
setting of <code>code</code> (i.e. A,B,C etc. for <code>code=TRUE</code>, natural effect 
names otherwise) and <code>autolab</code> (i.e. all effects are labelled if <code>autolab=FALSE</code>,
only significant effects are labelled if <code>autolab=TRUE</code>).  
Otherwise, <code>faclab</code> can be used for manual labelling of certain effects 
and should be a list with <code>idx</code> (integer vector referring to 
position of effects to be labelled) and <code>lab</code> (character vector of labels)
components. 
</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_block">block</code></td>
<td>
<p>logical. If <code>TRUE</code>, the first factor is labelled as &ldquo;BK&rdquo; (block).</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_datax">datax</code></td>
<td>
<p>logical. If <code>TRUE</code>, the x-axis is used for the factor effects the
the y-axis for the normal scores. The opposite otherwise.</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_half">half</code></td>
<td>
<p>logical. If <code>TRUE</code>, half-normal plot of effects is display.</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_pch">pch</code></td>
<td>
<p>numeric or character. Points character.</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_cex.fac">cex.fac</code></td>
<td>
<p>numeric. Factor label character size.</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_cex.lab">cex.lab</code></td>
<td>
<p>numeric. Labels character size.</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_cex.pch">cex.pch</code></td>
<td>
<p>numeric. Points character size.</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>numeric. Legend size in case of codes.</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_main">main</code></td>
<td>
<p>NULL or character. Title of plot. If NULL, automatic title is generated.</p>
</td></tr>
<tr><td><code id="DanielPlot_+3A_subtitle">subtitle</code></td>
<td>
<p>NULL or character. Sub title of plot. Should not be used for split-plot designs, 
because automatic subtitle is generated for these.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The design underlying <code>fit</code> 
has to be a (regular or non-regular) fractional factorial 2-level design. 
Effects (except for the intercept) are displayed in a normal or half-normal 
plot with the effects in the x-axis by default. 
</p>
<p>If <code>fit</code> is a design with at least one response variable 
rather than a linear model fit, 
the <code>lm</code>-method for class <code>design</code> is applied to it with 
degree high enough that at least one effect is assigned to each column of the Yates matrix, 
and the default method for <code>DanielPlot</code> is afterwards applied to the 
resulting linear model.
</p>
<p>For split-plot designs, whole plot effects are shown as different plotting 
characters, because they are potentially subject to larger variability, 
and one should not be too impressed, if they look impressively large, 
as this may well be indication of plot-to-plot variability rather than a 
true effect.
</p>


<h3>Value</h3>

<p>The function invisibly returns a data frame with columns: <code>x</code>, <code>y</code>,
<code>no</code>, <code>effect</code>, <code>coded</code> (if coded plot was requested) 
and <code>pchs</code>, for the coordinates, the position numbers, 
the effect names, the coded effect names, and the plotting characters 
for plotted points.
</p>
<p>The plotting characters are particularly useful for split-plot designs and can be used 
for subsequent separate plotting of whole-plot and split-plot effects, if necessary.
</p>


<h3>Note</h3>

<p>If you load package <span class="pkg">BsMD</span> after package <span class="pkg">FrF2</span>, 
a mere call to function <code>DanielPlot</code> will use the function from package <span class="pkg">BsMD</span> 
rather than the one from package <span class="pkg">FrF2</span>. You can explicitly request 
usage of the <span class="pkg">FrF2</span> function by <code>FrF2::DanielPlot</code>. </p>


<h3>Author(s)</h3>

<p>Ernesto Barrios, modified by Ulrike Groemping.</p>


<h3>References</h3>

<p>Box G. E. P, Hunter, W. C. and Hunter, J. S. (2005)
<em>Statistics for Experimenters, 2nd edition</em>.
New York: Wiley.
</p>
<p>Daniel, C. (1959) 
Use of Half Normal Plots in Interpreting Two Level Experiments.
<em>Technometrics</em> <b>1</b>, 311&ndash;340.
</p>
<p>Daniel, C. (1976) 
<em>Application of Statistics to Industrial Experimentation.</em>
New York: Wiley.
</p>
<p>Lenth, R.V. (1989) Quick and easy analysis of unreplicated factorials.
<em>Technometrics</em> <b>31</b>, 469&ndash;473.
</p>
<p>Lenth, R.V. (2006) Lenth s Method for the Analysis of Unreplicated Experiments.
To appear in <em>Encyclopedia of Statistics in Quality and Reliability</em>, Wiley, New York.
Downloadable at <a href="http://www.wiley.com/legacy/wileychi/eqr/docs/sample_1.pdf">http://www.wiley.com/legacy/wileychi/eqr/docs/sample_1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqnorm">qqnorm</a></code>, <code><a href="DoE.base.html#topic+halfnormal">halfnormal</a></code>, 
<code><a href="BsMD.html#topic+LenthPlot">LenthPlot</a></code>, <code>BsMD-package</code> </p>

<hr>
<h2 id='estimable.2fis'> Statistical and algorithmic aspects of requesting 2-factor interactions to be estimable in FrF2 </h2><span id='topic+estimable.2fis'></span>

<h3>Description</h3>

<p>This help page documents the statistical and algorithmic details of requesting 2-factor interactions to be estimable in FrF2 
</p>


<h3>Details</h3>

<p>The option <code>estimable</code> allows to specify 2-factor interactions (2fis) that 
have to be estimable in the model. Whenever a resolution V or higher design is available, 
this option is unnecessary, because all 2fis are estimable in the sense that they are 
not aliased with any main effect or any other 2fi. If resolution V or higher is not affordable, 
the option <code>estimable</code> can ensure that certain 2fis can nevertheless be estimated. 
</p>
<p>Per default, it is assumed that a resolution IV design is required, 
as it is normally not reasonable to allow main effects to be 
aliased with other 2-factor interactions in this situation. There are two types of 
estimability that are distinguished by the setting of option <code>clear</code> in 
function <code><a href="#topic+FrF2">FrF2</a></code> (cf. Groemping 2010).
</p>
<p>Let us first consider designs of at least resolution IV. 
With option <code>clear=TRUE</code>, <code>FrF2</code> searches for 
a model for which all main effects and all 2fis given in <code>estimable</code> are 
clear of aliasing with any other 2fis. This is a weaker requirement than resolution V, 
because 2fis outside those specified in <code>estimable</code> may be aliased with 
each other. But it is much stronger than what is done in case of <code>clear=FALSE</code>: 
For the latter, <code>FrF2</code> searches for a design that has a distinct column in 
the model matrix for each main effect and each interaction requested 
in <code>estimable</code>. 
</p>
<p>Users can explicitly permit that resolution III designs are included in the 
search of designs for which the specified 2fis are estimable (by the <code>res3=TRUE</code> option). 
In case of <code>clear=TRUE</code>, this leads to the somewhat 
strange situation that main effects can be aliased with 2fis from outside 
<code>estimable</code> while 2fis from inside <code>estimable</code> are not aliased with 
any main effects or 2fis. 
</p>
<p>With <code>clear=TRUE</code>, the algorithm compares the requirement set to 
catalogued sets of clear 2fis by a graph isomorphism algorithm from R-package 
<span class="pkg">igraph</span>. For details of this algorithm, 
cf. Groemping (2012). With the catalogue <code><a href="#topic+catlg">catlg</a></code> available in this package, 
the best (minimum aberration) existing clear designs are guaranteed to be found 
for up to 64 runs and have a good chance to be found for 128 runs. For 128 runs, 
it is possible to load an additional large catalogue (package <span class="pkg"><a href="FrF2.catlg128.html#topic+FrF2.catlg128">FrF2.catlg128</a></span>) 
in order to also guarantee that the best clear design is found. For 256 and 512 runs, 
only one or two resolution IV designs of each size are catalogued so that 
option <code>estimable</code> can try to influence allocation of factors to columns, 
but may fail although an appropriate clear design would exist outside the catalogued 
designs.<br />
The search for a clear design 
is often fast. If it isn't, option <code>sort</code> 
of function <code><a href="#topic+FrF2">FrF2</a></code> can help. For the occasional situation where 
this doesn't help either, a manual search may help, see <code><a href="#topic+CIG">CIG</a></code> 
for an example of how to proceed.<br />
Since version 2 of package <span class="pkg">FrF2</span>, requesting 2fis to be clear is compatible 
with blocking a design. The algorithm behind that functionality is based on 
Godolphin (2021) and is described in Groemping (2021). 
The default implementation strives for a guartanteed and best possible result. 
Arguments <code>firsthit</code> and <code>useV</code> to function <code><a href="#topic+FrF2">FrF2</a></code> 
can be used for trying to obtain a possibly not best result (<code>firsthit</code>) 
faster or to use a (sometimes) faster algorithm that is not guaranteed 
to deliver a result even though it might exist for resolution IV situations 
(<code>useV=FALSE</code>). 
</p>
<p>With <code>clear=FALSE</code>, the algorithm loops through the eligible designs from 
<code>catlg.select</code> from good to worse (in terms of MA) and, for each design, loops 
through all eligible permutations of the experiment factors from <code>perms</code>. 
If <code>perms</code> is omitted, the permutations are looped through in lexicographic 
order starting from 1:nfac or <code>perm.start</code>. Especially in this case, 
run times of the search algorithm can be very long. 
The <code>max.time</code> option allows to limit this run time. 
If the time limit is reached, the final situation (catalogued design and 
current permutation of experiment factors) is printed so that the user can 
decide to proceed later with this starting point (indicated by <code>catlg.select</code> 
for the catalogued design(s) to be used and <code>perm.start</code> for the current 
permutation of experiment factors). 
</p>
<p>With <code>clear=TRUE</code>, the algorithm loops through the eligible designs from 
<code>catlg.select</code> from good to worse (in terms of MA) and, for each design, 
uses a subgraph isomorphism check from package <code>igraph</code>. There are two such 
algorithms, VF2 (the default, Cordella et al. 2001) and LAD (introduced with 
version 1.7 of package <span class="pkg">FrF2</span>, Solnon 2010), 
which can be chosen with the  <code>method</code> option. 
Run times of the subgraph isomorphism search are often fast, 
but can also be very very slow in unlucky situations. 
Where the VF2 algorithm is particularly slow, the LAD algorithm is often fast 
(see Groemping 2014b). 
Especially for the VF2 algorithm, run times may strongly depend on the ordering 
of factors, which can be influenced by the option <code>sort</code>.
As the slowness of the process is intrinsic to the subgraph isomorphism 
search problem (which is NP-complete), a <code>max.time</code> option analogous to 
the <code>clear=FALSE</code> situation would be of very limited use only and is 
therefore not available. Instead, it is possible to have a look at the 
number of the design that was in the process of being searched when the 
process was interrupted (with the command <code>FrF2.currentlychecked()</code>).
</p>
<p>Note that - according to the structure of the catalogued designs and the lexicographic 
order of checking permutations - the initial order of the factors has a strong influence 
on the run time for larger or unlucky problems. For example, consider 
an experiment in 32~runs and 11~factors, for six of which the pairwise interactions are to be estimable 
(Example 1 in Wu and Chen 1992). <code>estimable</code> for this model can be specified as <br />
<code>formula("~(F+G+H+J+K+L)^2")</code> <br />
OR <br />
<code>formula("~(A+B+C+D+E+F)^2")</code>.<br />
The former runs a lot faster than the latter (I have not yet seen the latter finish 
the first catalogued design, if <code>perms</code> is not specified). 
The reason is that the latter needs more permutations of the experiment factors than 
the former, since the factors with high positions 
change place faster and more often than those with low positions. 
</p>
<p>For this particular design, it is very advisable to constrain the 
permutations of the experiment factors to the different subset selections of six factors 
from eleven, since permutations within the sets do not change the possibility of accomodating 
a design. The required permutations for the second version of this example 
can be obtained e.g. by the following code: 
</p>
<p><code>perms.6 &lt;- combn(11,6)</code><br />
<code>perms.full &lt;- matrix(NA,ncol(perms.6),11)</code><br />
<code>for (i in 1:ncol(perms.6))</code><br />
<code>perms.full[i,] &lt;- c(perms.6[,i],setdiff(1:11,perms.6[,i]))</code><br />
</p>
<p>Handing perms.full to the procedure using the <code>perms</code> option makes the second version of the 
requested interaction terms fast as well, since up to almost 40 Mio permutations of experiment 
factors are reduced to at most 462. Thus, whenever possible, 
one should try to limit the permutations necessary in case of <code>clear=FALSE</code>.
</p>
<p>In order to support relatively comfortable creation of distinct designs of some frequently-used types 
of required interaction patterns, the function <code><a href="#topic+compromise">compromise</a></code> has been 
divised: it supports creation of the so-called compromise plans of classes 1 to 4 (cf. 
e.g. Addelman 1962; Ke, Tang and Wu 2005; Groemping 2012). 
The list it returns also contains a component <code>perms.full</code> that can be used as input 
for the <code>perms</code> option.
</p>
<p>Please contact me with any suggestions for improvements.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Addelman, S. (1962). Symmetrical and asymmetrical fractional factorial plans. 
<em>Technometrics</em> <b>4</b>, 47-58.
</p>
<p>Chen, J., Sun, D.X. and Wu, C.F.J. (1993). A catalogue of 2-level and 3-level 
orthogonal arrays. 
<em>International Statistical Review</em> <b>61</b>, 131-145. 
</p>
<p>Cordella, L.P., Foggia, P., Sansone, C. and Vento, M. (2001). 
An improved algorithm for matching large graphs. <em>Proc. of the 3rd 
IAPR TC-15 Workshop on Graphbased Representations in Pattern Recognition</em>,
149&ndash;159.
</p>
<p>Godolphin, J. (2021). Construction of Blocked Factorial Designs to Estimate 
Main Effects and Selected Two-Factor Interactions. <em>J. Royal Statistical Society</em> <b>B 83</b>, 5-29. 
doi: <a href="https://doi.org/10.1111/rssb.12397">10.1111/rssb.12397</a>.
</p>
<p>Groemping, U. (2010). &ldquo;Clear&rdquo; and &ldquo;Distinct&rdquo;: two approaches for regular 
fractional factorial designs with estimability requirements. 
<em>Reports in Mathematics, Physics and Chemistry</em>, report 02/2010, 
Department II, Beuth University of Applied Sciences Berlin.
<a href="http://www1.bht-berlin.de/FB_II/reports/Report-2010-002.pdf">http://www1.bht-berlin.de/FB_II/reports/Report-2010-002.pdf</a>.
</p>
<p>Groemping, U. (2012). Creating clear designs: a graph-based algorithm and a 
catalogue of clear compromise plans. <em>IIE Transactions</em> <b>44</b>, 988&ndash;1001. 
Early preprint available at <a href="http://www1.bht-berlin.de/FB_II/reports/Report-2010-005.pdf">http://www1.bht-berlin.de/FB_II/reports/Report-2010-005.pdf</a>.
</p>
<p>Groemping, U. (2014a). R Package FrF2 for Creating and Analyzing Fractional 
Factorial 2-Level Designs. <em>Journal of Statistical Software</em>, <b>56</b>, 
Issue 1, 1-56. <a href="https://www.jstatsoft.org/v56/i01/">https://www.jstatsoft.org/v56/i01/</a>.
</p>
<p>Groemping, U. (2014b). A Note on Dominating Fractional Factorial 
Two-Level Designs With Clear Two-Factor Interactions. <em>Technometrics</em> 
<b>56</b>, 42&ndash;45.
</p>
<p>Groemping, U. (2021). An algorithm for blocking regular fractional factorial 
2-level designs with clear two-factor interactions. <em>Computational Statistics and Data Analysis</em> 
<b>153</b>, 1-18. doi: <a href="https://doi.org/10.1016/j.csda.2020.107059">10.1016/j.csda.2020.107059</a>. Preprint at 
<a href="http://www1.bht-berlin.de/FB_II/reports/Report-2019-003.pdf">Report 3/2019</a>.
</p>
<p>Ke, W., Tang, B. and Wu, H. (2005). Compromise plans with clear two-factor interactions. 
<em>Statistica Sinica</em> <b>15</b>, 709-715.
</p>
<p>Solnon, C. (2010). AllDifferent-based Filtering for Subgraph Isomorphism.
<em>Artificial Intelligence</em> <b>174</b>, 850&ndash;864.
</p>
<p>Wu, C.F.J. and Chen, Y. (1992) 
A graph-aided method for planning two-level experiments when certain interactions 
are important. 
<em>Technometrics</em> <b>34</b>, 162-175. 
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+FrF2">FrF2</a></code> for regular fractional factorials, 
<code><a href="#topic+catlg">catlg</a></code> for the Chen, Sun, Wu (1993) and larger catalogues of designs 
and some accessor functions, and function <code><a href="#topic+compromise">compromise</a></code> for a convenience 
function to handle estimability requests for compromise plans</p>


<h3>Examples</h3>

<pre><code class='language-R'>########## usage of estimable ###########################
  ## design with all 2fis of factor A estimable on distinct columns in 16 runs
  FrF2(16, nfactors=6, estimable = rbind(rep(1,5),2:6), clear=FALSE)
  FrF2(16, nfactors=6, estimable = c("AB","AC","AD","AE","AF"), clear=FALSE)
  FrF2(16, nfactors=6, estimable = formula("~A+B+C+D+E+F+A:(B+C+D+E+F)"), 
       clear=FALSE)
            ## formula would also accept self-defined factor names
            ## from factor.names instead of letters A, B, C, ...
            
  ## estimable does not need any other input
  FrF2(estimable=formula("~(A+B+C)^2+D+E"))

  ## estimable with factor names 
  ## resolution three must be permitted, as FrF2 first determines that 8 runs 
  ##     would be sufficient degrees of freedom to estimate all effects 
  ##     and then tries to accomodate the 2fis from the model clear of aliasing in 8 runs
  FrF2(estimable=formula("~one+two+three+four+two:three+two:four"), 
       factor.names=c("one","two","three","four"), res3=TRUE)
  ## clear=FALSE allows to allocate all effects on distinct columns in the 
  ##     8 run MA resolution IV design
  FrF2(estimable=formula("~one+two+three+four+two:three+two:four"), 
       factor.names=c("one","two","three","four"), clear=FALSE)

  ## 7 factors instead of 6, but no requirements for factor G
  FrF2(16, nfactors=7, estimable = formula("~A+B+C+D+E+F+A:(B+C+D+E+F)"), 
       clear=FALSE)
  ## larger design for handling this with all required effects clear
  FrF2(32, nfactors=7, estimable = formula("~A+B+C+D+E+F+A:(B+C+D+E+F)"), 
       clear=TRUE)
  ## 16 run design for handling this with required 2fis clear, but main effects aliased
  ## (does not usually make sense)
  FrF2(16, nfactors=7, estimable = formula("~A+B+C+D+E+F+A:(B+C+D+E+F)"), 
       clear=TRUE, res3=TRUE)

## example for necessity of perms for the clear=FALSE case
## based on Wu and Chen Example 1
  ## Not run: 
  ## runs per default about max.time=60 seconds, before throwing error with 
  ##        interim results
  ## results could be used in select.catlg and perm.start for restarting with 
  ##       calculation of further possibilities
  FrF2(32, nfactors=11, estimable = formula("~(A+B+C+D+E+F)^2"), clear=FALSE)
  ## would run for a long long time (I have not yet been patient enough)
  FrF2(32, nfactors=11, estimable = formula("~(A+B+C+D+E+F)^2"), clear=FALSE, 
       max.time=Inf)
  
## End(Not run)
  ## can be easily done with perms, 
  ## as only different subsets of six factors are non-isomorphic
  perms.6 &lt;- combn(11,6)
  perms.full &lt;- matrix(NA,ncol(perms.6),11)
  for (i in 1:ncol(perms.6))
     perms.full[i,] &lt;- c(perms.6[,i],setdiff(1:11,perms.6[,i]))
  ## function compromise will calculate the necessary perms entries automatically
  compromise(11,1:6)$perms.full
  FrF2(32, nfactors=11, estimable = formula("~(A+B+C+D+E+F)^2"), clear=FALSE, 
      perms = perms.full )
</code></pre>

<hr>
<h2 id='fold.design'>
Function to create a foldover for 2-level fractional factorials
</h2><span id='topic+fold.design'></span>

<h3>Description</h3>

<p>This function creates a foldover design for a 2-level fractional 
factorial. The purpose is to dealias (some) effects. 
Per default, all factors are folded upon, which makes the resulting 
design at least resolution IV. Different foldover versions can be requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fold.design(design, columns = "full", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fold.design_+3A_design">design</code></td>
<td>

<p>a data frame of class design that contains a 2-level fractional factorial; 
currently, <code>design</code> must neither be blocked nor a long version parameter design
</p>
</td></tr>
<tr><td><code id="fold.design_+3A_columns">columns</code></td>
<td>

<p>indicates which columns to fold on; the default &ldquo;full&rdquo; folds on all columns, 
i.e. swaps levels for all columns. <br />  
A specific fold on certain columns can be requested giving a character vector 
of factor names or a numeric vector of factor positions.<br />
See the details section for some statistical comments.
</p>
</td></tr>
<tr><td><code id="fold.design_+3A_...">...</code></td>
<td>

<p>currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Foldover is a method to dealias effects in relatively small 
2-level fractional factorial designs. The folded design has twice the number 
of runs from the original design, and an additional column &ldquo;fold&rdquo; that 
distinguishes the original runs from the mirror runs. This column should be used 
in analyses, since it captures a block effect on time (often the mirror runs 
are conducted substantially later than the original experiment).
</p>
<p>Like most other software, this function conducts a full foldover per default, 
i.e. the mirror portion reverses the levels of all factors. In terms of the 
convenient -1/1 notation for factor levels, this can be written as 
a multiplication with &ldquo;-1&rdquo; for the mirror portion of all factors. 
Thus, all confounding relations involving 
an odd number of factors (e.g. A=BC) are resolved, because the odd side of the 
equation involves a minus for the mirror runs, and the even side does not 
(since the minuses cancel each other). (These 
confounding relations are replaced by even ones 
for which the odd side of the equation is multiplied with minus the new mirror factor <code>fold</code>.) 
</p>
<p>There are many situations, for which the default full foldover is 
not the best possible foldover fraction, cf. e.g. Li and Mee (2002). 
It is therefore possible to choose an arbitrary foldover fraction. For example, 
folding on one particular factor alone dealiases all confounding relations 
for that factor, folding on two particular factors dealiases all confounding relations 
of these two with others but not of these two together with others and so on.
</p>
<p>Folding Plackett-Burman designs also removes the (partial) aliasing with 2-factor 
interactions for all main effects that are mirrored.
</p>


<h3>Value</h3>

<p>A data frame of class design with twice as many rows as <code>design</code> and 
the additional factor <code>fold</code> (added as the last factor for folded <code>pb</code> 
designs, as the first factor for splitplot designs, 
and as the last <em>base</em> factor for other folded regular fractional 
factorial designs).
</p>
<p>Existing response values are of course preserved, and response values for the 
new mirror runs are NA.
</p>
<p>The type in attribute <code>design.info</code> is suffixed with &ldquo;.folded&rdquo;, and 
<code>nruns</code> (and, if applicable, <code>nWPs</code>) is doubled, 
<code>nfactors</code> (and, if applicable, <code>nfac.WP</code>) 
is increased by one (for the factor fold, which 
is a block factor and can also be treated as such, but will currently be treated as a fixed 
(whole plot) factor by any automated analysis routine). The creator element receives a list entry for the fold columns.<br />
For regular fractional factorials (design type starting with <code>FrF2</code>), the generator element is adjusted 
(the generators for all generated fold factors now involve the folding factor), and an existing 
catlg.entry element is replaced by a new generators element. The <code>aliased</code> element is 
adapted to the new alias structure. Note that the fold factor enters as a new base factor and therefore 
is added to the factor matrix after the first log2(nruns) factors. This implies that all factor 
letters previously used for the generated factors are changed - for avoiding confusion it is always recommended to 
work with factor names that are meaningful in a subject-matter sense.
</p>
<p>Furthermore, for the regular fractional factorial designs, 
the column run.no.in.std.order in attribute <code>run.order</code> for the mirror portion of the design is 
populated such that the base factors remain in the conventional order when ordered by 
run.no.in.std.order (regardless whether or not they are included in the fold; 
it is always possible to reorder runs such that the original base factors 
together with the folding factor form the new base in standard order).
</p>


<h3>Note</h3>

<p>This function is still somewhat experimental.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>Li, H. and Mee, R. (2002). Better foldover fractions for resolution III 2^(k-p) designs. 
<em>Technometrics</em> <b>44</b>, 278&ndash;283. 
New York: Springer.
</p>
<p>Mee, R. (2009). <em>A Comprehensive Guide to Factorial Two-Level Experimentation</em>. 
New York: Springer.
</p>
<p>Montgomery, D.C. (2001). <em>Design and Analysis of Experiments (5th ed.)</em>. Wiley, New York.
</p>


<h3>See Also</h3>

<p>See also as <code><a href="#topic+pb">pb</a></code>, <code><a href="#topic+FrF2">FrF2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## create resolution III design
  plan &lt;- FrF2(8,5, factor.names=c("one","two","three","four","five"))
  ## add some resonse data
  y &lt;- c(2+desnum(plan)%*%c(2,3,0,0,0) +
     1.5*apply(desnum(plan)[,c(1,2)],1,"prod") + rnorm(8))
     ## the "c()" makes y into a vector rather than a 1-column matrix
  plan &lt;- add.response(plan, y)
  DanielPlot(lm(y~(.)^2,plan), alpha=0.2, half=TRUE)
  ## alias information
  design.info(plan)
  ## full foldover for dealiasing all main effects
  plan &lt;- fold.design(plan)
  design.info(plan)
  ## further data, shifted by -2
  y &lt;- c(y, desnum(plan)[9:16,1:5]%*%c(2,3,0,0,0) +
     1.5*apply(desnum(plan)[9:16,c(1,2)],1,"prod") + rnorm(8))
  plan &lt;- add.response(plan, y, replace=TRUE)
  linmod &lt;- lm(y~(.)^2,plan)
  DanielPlot(linmod, alpha=0.2, half=TRUE)
  MEPlot(linmod)
  IAPlot(linmod)
  
  ## fold on factor a only (also removes main effect aliasing here)
  plan &lt;- FrF2(8,5, factor.names=c("one","two","three","four","five"))
  aliasprint(plan)
  plan &lt;- fold.design(plan, columns=1)
  aliasprint(plan)
  
  ## fold a Plackett-Burman design with 11 factors
  plan &lt;- pb(12)
  fold.design(plan)
   </code></pre>

<hr>
<h2 id='FrF2'> Function to provide regular Fractional Factorial 2-level designs </h2><span id='topic+FrF2'></span><span id='topic+FrF2.currentlychecked'></span>

<h3>Description</h3>

<p>Regular fractional factorial 2-level designs are provided. 
Apart from obtaining the usual minimum aberration designs in a fixed number of runs, it is possible to 
request highest number of free 2-factor interactions instead of minimum aberration or to 
request the smallest design that fulfills certain requirements (e.g. resolution V with 8 factors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FrF2(nruns = NULL, nfactors = NULL, factor.names = if (!is.null(nfactors)) {
        if (nfactors &lt;= 50) Letters[1:nfactors] else 
                             paste("F", 1:nfactors, sep = "")} else NULL, 
        default.levels = c(-1, 1), ncenter=0, center.distribute=NULL, 
        generators = NULL, design = NULL, 
        resolution = NULL, select.catlg=catlg, 
        estimable = NULL, clear = TRUE, method="VF2", sort="natural", 
        ignore.dom = !isTRUE(all.equal(blocks,1)), 
        useV = TRUE, firsthit=FALSE, res3 = FALSE, max.time = 60, 
        perm.start=NULL, perms = NULL, 
        MaxC2 = FALSE, replications = 1, repeat.only = FALSE, 
        randomize = TRUE, seed = NULL, alias.info = 2, 
        blocks = 1, block.name = "Blocks", block.old=FALSE, 
        force.godolphin=alias.block.2fis,
        bbreps=replications, wbreps=1, 
        alias.block.2fis = FALSE, 
        hard = NULL, check.hard=10, WPs=1,nfac.WP=0,
        WPfacs=NULL, check.WPs = 10, ...)
FrF2.currentlychecked()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FrF2_+3A_nruns">nruns</code></td>
<td>
<p> Number of runs, must be a power of 2 (4 to 4096), if given. 
</p>
<p>The number of runs can also be omitted. In that case, 
if <code>resolution</code> is specified, the function looks for the smallest 
design of the requested resolution that accomodates <code>nfactors</code> factors. 
If the smallest possible design is a full factorial or not catalogued, 
the function stops with an error.
</p>
<p>If <code>generators</code> is specified, <code>nruns</code> is required.
</p>
<p>If estimable is specified and <code>nruns</code> omitted, 
<code>nruns</code> becomes the size of the smallest design that 
MIGHT accomodate the effects requested in <code>estimable</code>. 
If this run size turns out to be too low, an error is thrown. 
In that case, explicitly choose <code>nruns</code> as twice the run size 
given in the error message and retry. </p>
</td></tr>
<tr><td><code id="FrF2_+3A_nfactors">nfactors</code></td>
<td>
<p> is the number of 2-level factors to be investigated. 
It can be omitted, if it is obvious from <code>factor.names</code>, 
a specific catalogued design given in <code>design</code>, 
<code>nruns</code> together with <code>generators</code>, or 
<code>estimable</code>. 
</p>
<p>If <code>estimable</code> is used for determining 
the number of factors, it is assumed that the largest main effect position number 
occurring in <code>estimable</code> coincides with <code>nfactors</code>. 
</p>
<p>For blocked designs, block generator columns are not included in 
<code>nfactors</code>, except if 
the user explicitly specifies 2-level block generation factors as 
part of the fractional factorial design (e.g. a factor shift with levels 
morning and afternoon). 
</p>
<p>For automatically-generated split-plot designs (cf. details section), 
<code>nfactors</code> simply is the number of all factors (whole plot and split plot together). 
If <code>nfac.WP &lt; log2(WPs)</code>, the algorithm will add (an) artificial plot generation factor(s). 
<br />
For manually-specified split-plot designs (through options <code>generators</code> or 
<code>design</code> together with <code>WPfacs</code>), the user must specify at least <code>log2(WPs)</code> 
split plot factors, i.e. <code>nfac.WP &gt;= log2(WPs)</code> is required (and must, if necessary, 
be achieved by adding <code>log2(WPs) - nfac.WP</code> extra independent generator columns 
for the whole plot structure, which have to be counted in <code>nfac.WP</code> and <code>nfactors</code>).</p>
</td></tr>
<tr><td><code id="FrF2_+3A_factor.names">factor.names</code></td>
<td>
<p> a character vector of <code>nfactors</code> factor names 
or a list with <code>nfactors</code> elements;<br /> 
if the list is named, list names represent factor names, otherwise default factor names are used;<br /> 
the elements of the list are <br />
EITHER vectors of length 2 with factor levels for the respective factor<br />
OR empty strings. 
For each factor with an empty string in factor.names, the levels given in 
<code>default.levels</code> are used;<br />
Default factor names are the first elements of the character vector <code><a href="DoE.base.html#topic+utilities">Letters</a></code>, 
or the factors position numbers preceded by capital F in case of more than 50 factors. </p>
</td></tr>
<tr><td><code id="FrF2_+3A_default.levels">default.levels</code></td>
<td>
<p> default levels (vector of length 2) for all factors for 
which no specific levels are given </p>
</td></tr>
<tr><td><code id="FrF2_+3A_ncenter">ncenter</code></td>
<td>
<p> number of center points per block; <code>ncenter &gt; 0</code> 
is permitted, if all factors are quantitative and the design is not a split-plot design </p>
</td></tr>
<tr><td><code id="FrF2_+3A_center.distribute">center.distribute</code></td>
<td>
<p> the number of positions over which the center points 
are to be distributed for each block; if NULL (default), center points are 
distributed over end, beginning, and middle (in that order, if there are fewer than three center points) 
for randomized designs, and appended to the end for non-randomized designs. 
for more detail, see function <code><a href="#topic+add.center">add.center</a></code>, which does the work.
</p>
</td></tr>
<tr><td><code id="FrF2_+3A_generators">generators</code></td>
<td>
<p> There are <code>log2(nruns)</code> base factors the full factorial 
of which spans the design (e.g. 3 for 8 runs). 
The generators specify how the remaining factors 
are to be allocated to interactions of these.
</p>
<p><code>generators</code> can be 
</p>
<p>a list of vectors with position numbers of base factors (e.g. c(1,3,4) 
stands for the interaction between first, third and fourth base factor) 
</p>
<p>a vector of character representations of these interactions, 
e.g. &ldquo;ACD&rdquo; stands for the same interaction as above
</p>
<p>a vector of columns numbers in Yates order (e.g. 13 stands for ACD). 
Note that the columns 1, 2, 4, 8, etc., i.e. all powers of 2, are reserved 
for the base factors and cannot be used for assigning additional factors, 
because the design would become a resolution II design. For looking up 
which column number stands for which interaction, type e.g. 
<code>names(Yates)[1:15]</code> for a 16 run design.
</p>
<p>In all cases, preceding the respective entry with a minus sign 
(e.g. -c(1,3,4), &ldquo;-ACD&rdquo;, -13) implies that the levels 
of the respective column are reversed.<br />
WARNING: Minus signs do not cause an error, but neither have an effect in case 
of automatic assignment of split-plot designs or hard-to-change columns.
</p>
</td></tr>
<tr><td><code id="FrF2_+3A_design">design</code></td>
<td>
<p> is a character string specifying the name of a design listed 
in the catalogue specified as <code>select.catlg</code>, which is usually 
the catalogue <code><a href="#topic+catlg">catlg</a></code>
</p>
</td></tr>
<tr><td><code id="FrF2_+3A_resolution">resolution</code></td>
<td>
<p> is the arabic numeral for the requested resolution of the design. 
<code>FrF2</code> looks for a design with at least this resolution. 
Option <code>resolution</code> does not work, if <code>estimable</code>, <code>blocks</code> 
or <code>WPs</code> are specified, and neither if <code>nruns</code> is given.<br />
A design with resolution III (resolution=3) confounds main effects 
with 2-factor interactions, a design with resolution IV confounds main 
effects with three-factor interactions or 2-factor interactions with each other, 
and designs with resolution V or higher are usually regarded as very strong, 
because all 2-factor interactions are unconfounded with each other and 
with main effects.</p>
</td></tr>
<tr><td><code id="FrF2_+3A_select.catlg">select.catlg</code></td>
<td>
<p> specifies a catalogue of class <code>catlg</code> from 
which an adequate design is selected and adapted. <br />
The specified catalogue is used for design construction, 
unless <code>generators</code> explicitly constructs a 
non-catalogued design. The default <code><a href="#topic+catlg">catlg</a></code> is adequate for most 
applications. 
</p>
<p>If a specific different catalogue of designs is available, 
this can be specified here. <br />
Specification of a smaller subset of designs is useful, if <code>estimable</code> 
has been given and <code>clear=FALSE</code>, for restricting the search 
to promising designs.
</p>
<p><a href="FrF2.catlg128.html#topic+Catalogues">Names of catalogues from package</a> <span class="pkg">FrF2.catlg128</span> 
can be given here without prior loading of that package; loading of the package 
and the selected catalogue will then happen automatically, provided the 
package is installed (for version &gt;=1.2 of package <span class="pkg">FrF2.catlg128</span>; 
for earlier versions, the suitable catalogue has to be manually loaded 
using the <code>data()</code> command).
</p>
</td></tr>                
<tr><td><code id="FrF2_+3A_estimable">estimable</code></td>
<td>
<p> indicates the 2-factor interactions (2fis) that are to be estimable in 
the design. Consult the specific help file (<code><a href="#topic+estimable.2fis">estimable.2fis</a></code>) 
for details of two different approaches of requesting estimability, 
as indicated by the status of the <code>clear</code> option. <code>estimable</code> cannot be 
specified together with <code>splitplot</code>, <code>generators</code> or <code>design</code>.
</p>
<p><code>estimable</code> can be<br /> 
a numeric matrix with two rows, each column of which indicates one interaction,
e.g. column 1 3 for interaction of the first with the third factor<br />
OR<br />
a character vector containing strings of length 2 with capital letters from <code>Letters</code> 
(cf. package <span class="pkg">DoE.base</span>)
for the first 25 factors and small letters for the last 25 (e.g. <code>c("AB","BE")</code> <br />
OR<br />
a formula that contains an adequate model formula, e.g. <br />
<code>formula("~A+B+C+D+E+(F+G+H+J+K+L)^2")</code> <br />
for a model with (at least) eleven factors. <br />
The names of the factors used in the formula can be the same letters usable in 
the character vector (cf. above, A the first factor, B the second etc.), 
or they can correspond to the factor names from 
<code>factor.names</code>. 
</p>
</td></tr>
<tr><td><code id="FrF2_+3A_clear">clear</code></td>
<td>
<p> logical, indicating how estimable is to be used. See <code><a href="#topic+estimable.2fis">estimable.2fis</a></code>. </p>
</td></tr>
<tr><td><code id="FrF2_+3A_method">method</code></td>
<td>
<p> character string indicating which subgraph isomorphism search routine 
of package <span class="pkg">igraph</span> is used (<code>graph.subisomorphic.vf2</code> or 
<code>graph.subisomorphic.lad</code>). 
The default <code>"VF2"</code> uses VF2 algorithm by Cordella et al. (2001), 
which was the only available algorithm before version 1.7 of package FrF2. 
The alternative <code>"LAD"</code> uses the LAD algorithm by Solnon (2010), which was 
reported to be substantially faster than VF2 especially for some notoriously 
difficult VF2 cases (see Gr?mping 2014b).         
This option is relevant for <code>estimable</code> with <code>clear=TRUE</code> only.<br />
NOTE: The resulting design may be different for different settings of this option!</p>
</td></tr>
<tr><td><code id="FrF2_+3A_sort">sort</code></td>
<td>
<p> character string indicating how the estimability requirement and the 
candidate design clear 2fis are handed to 
the subgraph isomorphism search routine of package <span class="pkg">igraph</span>. 
The default <code>"natural"</code> leaves them in unchanged order (like in 
<span class="pkg">FrF2</span> versions up to 1.6). <code>sort="high"</code> and <code>sort="low"</code> sort 
both requirement set and candidate design graph according to vertex degrees (high 
first or low first). 
</p>
<p>This option is relevant for <code>estimable</code> with <code>clear=TRUE</code> only.<br />
It has been added, because pre-sorting of vertices sometimes speeds up the 
search by several orders of magnitude especially for the <code>VF2</code> method.<br />
NOTE: The resulting design may be different for different settings of this option!</p>
</td></tr>
<tr><td><code id="FrF2_+3A_ignore.dom">ignore.dom</code></td>
<td>
<p> logical, default FALSE for unblocked designs, TRUE for blocked designs; 
if TRUE, <code>estimable</code> ignores 
the dominating attribute of the catalogue entries; can be useful for 
searching a blocked design with estimable 2fis from a reduced catalogue</p>
</td></tr>
<tr><td><code id="FrF2_+3A_usev">useV</code></td>
<td>
<p> NULL or logical; relevant for designs with <code>blocks</code> and <code>estimable</code> only; 
if TRUE, function <code>link{colpick}</code> is used (default), otherwise function <code>link{colpickIV}</code>; 
if set to NULL, <code>colpick</code> is used for fractions with resolution at least V and function 
<code>link{colpickIV}</code> for resolution IV fractions;<br />
<code>useV=FALSE</code> does the subgraph isomorphism check once only, 
at the expense of missing out opportunities; it may be worth trying <code>useV=NULL</code> 
or <code>useV=FALSE</code> for resolution IV situations, 
for which the search takes very long with the default</p>
</td></tr>
<tr><td><code id="FrF2_+3A_firsthit">firsthit</code></td>
<td>
<p> logical; relevant for designs with <code>blocks</code> and <code>estimable</code> only; 
if FALSE, the function tries to find a design with as many as possible clear 2fis, 
otherwise the function stops at the first possible blocking; in case of resource problems, 
setting <code>firsthit</code> to TRUE may be helpful</p>
</td></tr>
<tr><td><code id="FrF2_+3A_res3">res3</code></td>
<td>
<p> logical; if TRUE, <code>estimable</code> includes resolution III designs 
into the search for adequate designs; otherwise resolution IV and higher designs 
are included only. </p>
</td></tr>
<tr><td><code id="FrF2_+3A_max.time">max.time</code></td>
<td>
<p> maximum time for design search as requested by <code>estimable</code>, 
in seconds (default 60); introduced for <code>clear=FALSE</code> situations because
the search can take a long time in complicated or unlucky situations;
set max.time to Inf if you want to force a search over an extended period of 
time; however, be aware that it may still take longer than feasible 
(cf. also <code><a href="#topic+estimable.2fis">estimable.2fis</a></code>)</p>
</td></tr>
<tr><td><code id="FrF2_+3A_perm.start">perm.start</code></td>
<td>
<p> used with <code>estimable</code> specified, and <code>clear=FALSE</code>.<br />
Provides a start permutation for permuting experiment factors (numeric vector). 
This is useful for the case that a previous search was not (yet) successful 
because of a time limit, since the algorithm notifies the user about the 
permutation at which it had to stop.</p>
</td></tr>
<tr><td><code id="FrF2_+3A_perms">perms</code></td>
<td>
<p> used with <code>estimable</code> specified, and <code>clear=FALSE</code>.<br />
Provides the matrix of permutations of experiment factors to be tried; each 
row is a permutation. For example, for an 11-factor design with the 
first six factors and their 2fis 
estimable, it is only relevant, which of the eleven factors are to be allocated 
to the first six experiment factors, and these as well as the other five factors can be 
in arbitrary order. This reduces the number of required permutations from 
about 40 Mio to 462. 
It is recommended to use <code>perms</code> whenever possible, if <code>clear=FALSE</code>, 
since this dramatically improves performance of the algorithm.
</p>
<p>It is planned to automatically generate perms for certain structures like 
compromise designs in the (not so near) future.</p>
</td></tr>
<tr><td><code id="FrF2_+3A_maxc2">MaxC2</code></td>
<td>
<p> is a logical and defaults to FALSE. If TRUE, 
maximizing the number of clear 2-factor interactions takes precedence 
over minimizing aberration. Resolution is always considered first. 
<code>MaxC2</code> is ignored when using the <code>estimable</code> option.
<code>MaxC2=TRUE</code> is not a recommended choice. </p>
</td></tr>
<tr><td><code id="FrF2_+3A_replications">replications</code></td>
<td>
<p> positive integer number. Default 1 (i.e. each row just once). 
If larger, each design run is executed replication times. 
If <code>repeat.only</code>, repeated measurements 
are carried out directly in sequence, i.e. no true replication takes place, 
and all the repeat runs are conducted together. It is likely that the error 
variation generated by such a procedure will be too small, so that average values 
should be analyzed for an unreplicated design. 
</p>
<p>Otherwise (default), the full experiment is first carried out once, then 
for the second replication and so forth. In case of randomization, 
each such blocks is randomized separately. In this case, replication variance is 
more likely suitable for usage as error variance 
(unless e.g. the same parts are used for replication runs although build 
variation is important).</p>
</td></tr>
<tr><td><code id="FrF2_+3A_repeat.only">repeat.only</code></td>
<td>
<p> logical, relevant only if replications &gt; 1. If TRUE, 
replications of each run are grouped together 
(repeated measurement rather than true replication). The default is 
<code>repeat.only=FALSE</code>, i.e. the complete experiment 
is conducted in <code>replications</code> blocks, and each run occurs in each block.  </p>
</td></tr>
<tr><td><code id="FrF2_+3A_randomize">randomize</code></td>
<td>
<p> logical. If TRUE, the design is randomized. This is the default. 
In case of replications, the nature of randomization depends on the setting of 
option <code>repeat.only</code>.</p>
</td></tr>
<tr><td><code id="FrF2_+3A_seed">seed</code></td>
<td>
<p> optional seed for the randomization process <br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>FrF2</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="DoE.base.html#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
<tr><td><code id="FrF2_+3A_alias.info">alias.info</code></td>
<td>
<p> can be 2 or 3, gives the order of interaction effects for which 
alias information is to be included in the <code>aliased</code> component of the 
<code>design.info</code> element of the output object. </p>
</td></tr>
<tr><td><code id="FrF2_+3A_blocks">blocks</code></td>
<td>
<p> is EITHER <br /> 
the number of blocks into which the experiment is subdivided <br />
OR a character vector of names of independent factors that are used as block constructors <br />
OR a vector of Yates column numbers
OR a list of generators similar to list entries for <code>generators</code>. <br />
In the latter case, 
the differences to <code>generators</code> are <br /> 
</p>

<ul>
<li><p> that numbers/letters refer to the factors of the experiment and not to 
column numbers of the Yates matrix 
</p>
</li>
<li><p> that numbers/letters can refer to *all* <code>nfactors</code> factors rather than the log2(nruns) base factors only, 
</p>
</li>
<li><p> that one single number is always interpreted as the number of blocks rather than a column reference, 
</p>
</li>
<li><p> that individual numbers are allowed in a list (i.e. individual factors specified in the experiment can be used as block factors) and
</p>
</li>
<li><p> that no negative signs are allowed. </p>
</li></ul>

<p>If <code>blocks</code> is a single number, it must be a power of 2. 
A blocked design can have at most <code>nruns-blocks-1</code> treatment 
factors, but should usually have fewer than that. <br />
</p>
<p>If the experiment is randomized, randomization happens within blocks. 
In case of many blocks, units should also be randomized to blocks wherever possible! <br />
</p>
<p>For the statistical and algorithmic background of blocked designs, see <code><a href="#topic+block">block</a></code>.
</p>
</td></tr>
<tr><td><code id="FrF2_+3A_block.name">block.name</code></td>
<td>
<p> name of the block factor, default &ldquo;Blocks&rdquo;</p>
</td></tr>
<tr><td><code id="FrF2_+3A_block.old">block.old</code></td>
<td>
<p>logical; if TRUE, blocking behavior of FrF2 version 1.7.2 is activated</p>
</td></tr>
<tr><td><code id="FrF2_+3A_force.godolphin">force.godolphin</code></td>
<td>
<p>logical; if TRUE, blocking is forced to be done with the 
Godolphin method (using function <code>colpick</code>, see <code><a href="#topic+block">block</a></code>), 
even if the default would have been to use function <code>blockpick</code>. <br />
The Godolphin method was introduced with package version 2.0, and since package version 2.3, the default for <code>alias.block.2fis=TRUE</code> is to force the use of the Godolphin method.</p>
</td></tr>
<tr><td><code id="FrF2_+3A_bbreps">bbreps</code></td>
<td>
<p> between block replications; these are always taken as genuine replications, 
not repeat runs; default: equal to <code>replications</code>;
CAUTION: you should not modify <code>bbreps</code> if you do not work with blocks, 
because the program code uses it instead of <code>replications</code> in some places </p>
</td></tr>
<tr><td><code id="FrF2_+3A_wbreps">wbreps</code></td>
<td>
<p> within block replications; whether or not these are taken as genuine replications 
depends on the setting of <code>repeat.only</code></p>
</td></tr>
<tr><td><code id="FrF2_+3A_alias.block.2fis">alias.block.2fis</code></td>
<td>
<p> logical indicating whether blocks may be aliased 
with 2fis (default: <code>FALSE</code>); <br />
it will often be necessary to modify this option, because there is otherwise no solution.</p>
</td></tr>
<tr><td><code id="FrF2_+3A_hard">hard</code></td>
<td>
<p> gives the number of hard to change factors. These must be the 
first factors in <code>factor.names</code>. Implementation is via a non-randomized split-plot 
design with as few as possible whole plots (number of possible whole plots is 
determined via left-adjustment) and as few as possible non-hard factors 
within the whole plot structure (by applying split-plot after left-adjustment).<br />
Observations within whole plots are randomized, whole plots themselves are not 
randomized (contrary to split plot designs).<br />
From the statistical point of view, randomisation of whole plots is strongly 
preferrable (cf. <code><a href="#topic+splitplot">splitplot</a></code> for a brief discussion of the difference).
If this appears feasible, you may want to explicitly handle the situation 
by treating the hard to change factors as whole-plot factors via <code>WPs</code> and <code>nfac.WP</code>.
</p>
</td></tr>
<tr><td><code id="FrF2_+3A_check.hard">check.hard</code></td>
<td>
<p> is the number of candidate designs from the catalogue specified 
in <code>select.catlg</code> that are checked for making hard-to-change factors 
change as little as possible.<br />
The default is 10 - if too many changes are needed, a larger choice might 
help find a design with fewer level changes (but will also take longer run time
and will find a worse design in terms of resolution / aberration). <br />
If you want to use the best design and do not want to compromise the confounding 
structure for ease-of-change reasons, set check.hard to 1.</p>
</td></tr>  
<tr><td><code id="FrF2_+3A_wps">WPs</code></td>
<td>
<p> is the number of whole plots and must be a power of 2.<br />
If <code>WPs &gt; 1</code>, at least one of <code>nfac.WP</code> or <code>WPfacs</code> must be given.<br />
If <code>WPs = 1</code>, all settings for split-plot related options are ignored.<br />
</p>
<p>For statistical and algorithmic information on treatment of split-plot designs 
see the separate help file <code><a href="#topic+splitplot">splitplot</a></code>.
</p>
</td></tr>
<tr><td><code id="FrF2_+3A_nfac.wp">nfac.WP</code></td>
<td>
<p> is the number of whole plot factors and must be smaller than <code>WPs</code>.
</p>
<p>The <code>nfac.WP</code> whole plot factors are counted within <code>nfactors</code>. 
Per default, the first <code>nfac.WP</code> factors are the whole plot factors.
</p>
<p>If a design is provided and whole plot factors are manually provided 
(design or generators option together with <code>WPfacs</code>), 
<code>nfac.WP</code> can be omitted (i.e. remains 0). If given, it must coincide with 
the length of <code>WPfacs</code>.
</p>
<p>If <code>nfac.WP</code> is given without <code>WPfacs</code>only, <code>generators</code> must not be given.
</p>
<p>If <code>nfac.WP</code> is omitted (i.e. remains 0) and <code>WPs</code> &gt; 1, an error is thrown, 
because the situation is a block rather than a split-plot situation 
(and either it was forgotten to specify 
the number of whole plot factors, or blocks should be specified).
</p>
</td></tr>
<tr><td><code id="FrF2_+3A_wpfacs">WPfacs</code></td>
<td>
<p> is per default NULL. In this case, the first <code>nfac.WP</code> factors are 
considered whole plot factors (and are, if necessary, automatically supplemented by 
additional whole plot constructor factors). <br />
If <code>WPfacs</code> is given, it must specify at least <code>log2(WPs)</code> whole plot factors. 
A custom design must be specified 
with options <code>design</code> or <code>generators</code>, and the requested factors in 
<code>WPfacs</code> must indeed create a split-plot structure with <code>WPs</code> whole plots. 
If the number of whole plots created by the whole plot factors differs from 
<code>WPs</code> or factors other than the specified factors from <code>WPfacs</code> would 
in fact become whole plot factors as well, an error is thrown.
</p>
<p><code>WPfacs</code> can be any of<br /> 
a vector or list of factor position numbers<br />
OR<br />
a character vector of factor position letters from <code>Letters</code><br />
OR<br />
a character vector with entries &ldquo;F&rdquo; followed by factor position number<br />
OR<br />
a character vector of factor names (this takes precedence over factor letters, 
i.e. if the factor names were B, A, C, D, and E, factor letter entries in the <code>nfac.WP</code> 
are interpreted as factor names, not position letters).<br />
It is not possible to specify additional whole plot generators 
from interaction effects manually through <code>WPfacs</code>. 
Rather, all whole plot factors - even artificial ones needed only to increase the number 
of plots - need to be included in the design factors. </p>
</td></tr>
<tr><td><code id="FrF2_+3A_check.wps">check.WPs</code></td>
<td>
<p> is the number of potential split-plot designs that are 
compared by function <code>splitpick</code> w.r.t. resolution of the whole plot
portion of the design. This option is effective, if <code>nfac.WP&gt;k.WP</code> 
(i.e. bad resolution possible) and nfac.WP not larger than half 
the number of plots (i.e. resolution better than III is possible). 
The default is 10 - if not satisfied with the structure of the whole plot 
factors, a larger choice might help find a better design (but also take 
longer run time). </p>
</td></tr>
<tr><td><code id="FrF2_+3A_...">...</code></td>
<td>
<p> currently not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Per default, the function picks the best design from the 
default design catalogue <code><a href="#topic+catlg">catlg</a></code> (a list object of class <code>catlg</code>). 
</p>
<p>Alternatively, the user can explicitly specify a design through accessing 
a specific catalogued design using the <code>design</code> option or specifying non-catalogued 
generators via the <code>generators</code> option.
</p>
<p>Apart from generation of simple fractional factorial designs based on catalogued 
or non-catalogued generators, function <code>FrF2</code> allows specification of blocked designs 
and split-plot designs, as well as specification of a set of 2fis that are required to be estimable. 
The implementation of these possibilities is explained in the separate help files <code><a href="#topic+block">block</a></code>, 
<code><a href="#topic+splitplot">splitplot</a></code> and <code><a href="#topic+estimable.2fis">estimable.2fis</a></code>. If you consider to use 
option <code>hard</code>, it may also be worth while to look at the <code><a href="#topic+splitplot">splitplot</a></code> 
help file.
</p>
<p>Function <code>FrF2</code> is still under development, although most features are 
now included, and the principle structure of inputs and outputs should not change 
much any more. Please contact me with any suggestions for improvements.
</p>
<p>Function <code>FrF2.currentlychecked</code> is meant as a diagnostic tool, 
when searching for designs with option <code>estimable</code>
and <code>clear=TRUE</code>. If the search takes very long, it can be interrupted 
(CAUTION: in some igraph versions, interrupting the search may crash R). 
After a successful interruption, and <code>FrF2.currentlychecked()</code> 
returns a character string with the name of the design that was checked at the 
time of interruption. 
</p>


<h3>Value</h3>

<p>Function <code>FrF2</code> returns a data frame of S3 class <code><a href="DoE.base.html#topic+class-design">design</a></code> 
that has attached attributes that can be accessed 
by functions <code><a href="DoE.base.html#topic+class-design-methods">desnum</a></code>, 
<code><a href="DoE.base.html#topic+class-design-methods">run.order</a></code> and 
<code><a href="DoE.base.html#topic+class-design-methods">design.info</a></code>. 
</p>
<p>The data frame itself contains the design with levels coded as requested. 
If no center points have been requested, the design columns are factors with 
contrasts <code>-1</code> and <code>+1</code> (cf. also <code><a href="DoE.base.html#topic+contr.FrF2">contr.FrF2</a></code>); in case 
of center points, the design columns are numeric.
</p>
<p>The following attributes are attached to it: 
</p>
<table>
<tr><td><code>desnum</code></td>
<td>
<p>Design matrix in -1/1 coding</p>
</td></tr>
<tr><td><code>run.order</code></td>
<td>
<p>a three column data frame;<br /> 
the first column (<code>run.no.in.std.order</code>)
contains the run number in standard order, possibly including a block number 
and in that case also a number for the original position within the block,<br /> 
the second column (<code>run.no</code>) contains the actual run number as randomized, <br />
the third column contains (<code>run.no.std.rp</code>) contains the content 
of the first column accumulated with a replication identifier, if applicable.<br />
A few remarks on the run number in standard order are needed here: <br />
In blocked and split plot designs, the run number in standard 
order refers to a row ordering with the first base factor changing <em>slowest</em>, 
different from the usual order with the first base factor changing <em>fastest</em>. 
Also note that the run number in standard order may not refer to 
the base columns one would naturally expect for designs created with blocking,  
estimable 2fis or split plot designs; the elements <code>map</code> and/or  
<code>orig.fac.order</code> of the attribute <code>design.info</code> help identify 
which base factors drive the run number in standard order.
(In case of option <code>hard=TRUE</code>, the remark on split plot designs applies, 
and the numbering refers to the special slow change matrix from 
Cheng et al. 1998.)<br />
Before version 2 of package FrF2, blocking for large situations was internally 
done with function <code>blockpick.big</code>. This behavior can be reproduced 
using the argument <code>block.old=TRUE</code>; if blocking for a large design is 
not successful otherwise, <code>block.old=TRUE</code> might be worth a try. 
For blocked designs created internally with 
function <code>blockpick.big</code>, 
the run number in standard order is not easily related to the final 
design.</p>
</td></tr>
<tr><td><code>design.info</code></td>
<td>
<p>list with the entries 
</p>

<dl>
<dt>type</dt><dd><p> character string &ldquo;full factorial&rdquo;, &ldquo;FrF2&rdquo;, 
&ldquo;FrF2.estimable&rdquo;, &ldquo;FrF2.generators&rdquo;, &ldquo;FrF2.blocked&rdquo; 
or &ldquo;FrF2.splitplot&rdquo; depending on the 
type of design</p>
</dd>
<dt>nruns</dt><dd><p> number of runs (replications are not counted) </p>
</dd>
<dt>nfactors</dt><dd><p> number of factors; since version 0.97, 
this is also true for designs of type <code>FrF2.blocked</code> 
(<code>nfactors</code> is now equal to <code>ntreat</code>) and for designs of type 
<code>FrF2.splitplot</code>, where <code>nfactors</code> is now the sum of <code>nfac.WP</code> and <code>nfac.SP</code>.</p>
</dd>
<dt>ntreat</dt><dd><p> for designs of type <code>FrF2.blocked</code> only; <br />
number of treatment factors </p>
</dd>
<dt>nfac.WP</dt><dd><p> for designs of type <code>FrF2.splitplot</code> only; <br />
number of whole plot factors (including extra factors that may have been 
added for whole plot construction); these are the first factors in the 
design data frame </p>
</dd>
<dt>nfac.SP</dt><dd><p> for designs of type <code>FrF2.splitplot</code> only; <br />
number of split-plot factors </p>
</dd>
<dt>nlevels</dt><dd><p>for designs of type <code>full factorial</code> only; <br />
vector with number of levels for each factor 
(of course, all the <code>nfactors</code> entries are &ldquo;2&rdquo; for <code>FrF2</code>)</p>
</dd>
<dt>factor.names </dt><dd><p> list named with (treatment) factor names and containing as 
entries vectors of length two each with coded factor levels </p>
</dd>
<dt>FrF2.version </dt><dd><p> version number of package FrF2, 
supporting correct usage of <code>FrF2</code>-specific functionality in 
functions <code>summary</code> and <code>generators</code> 
methods for class <code>design</code></p>
</dd>
<dt>nblocks</dt><dd><p>for designs of type <code>FrF2.blocked</code> only; <br />
number of blocks</p>
</dd>
<dt>block.gen</dt><dd><p>vector of columns of the Yates matrix for generating 
block factors in case of automatic block generation <br /> 
OR list of (vectors of) factor numbers in case the <code>blocks</code> 
argument specifies certain factor combinations for blocking; ; <br />
for designs of type <code>FrF2.blocked</code> only</p>
</dd>
<dt>blocksize</dt><dd><p>for designs of type <code>FrF2.blocked</code> only; <br />
size of each block (without consideration of <code>wbreps</code>)</p>
</dd>
<dt>nWPs</dt><dd><p>for designs of type <code>FrF2.splitplot</code> only; <br />
number of whole plots</p>
</dd>
<dt>plotsize</dt><dd><p>for designs of type <code>FrF2.splitplot</code> only; <br />
size of each plot (without consideration of repeat.only replications if applicable)</p>
</dd>
<dt>orig.fac.order </dt><dd><p>designs of type <code>FrF2.splitplot</code> only; <br />
factor order of the design before reshuffling of factors in order 
to accomodate the split plot request; 
the run number in standard order can only be interpreted together 
with this information</p>
</dd>
<dt>catlg.entry </dt><dd><p> for designs of type <code>FrF2</code> only; <br />
list with one element, which is the entry of <code>catlg</code> 
on which the design is based</p>
</dd>
<dt>generators </dt><dd><p> for designs of type <code>FrF2.generators</code> only; <br />
character vector of generators in the form D=ABC etc.</p>
</dd>
<dt>base.design </dt><dd><p> for designs of type <code>FrF2.blocked</code> or <code>FrF2.splitplot</code> only; <br />
gives a character string that contains the name of the base design 
in the catalogue or the column numbers of generating columns in Yates matrix; 
in case of automatic block generation, the exclusion or inclusion of <code>k.block</code> 
in the number of design factors / generators 
indicates whether the design was generated using function 
<code><a href="#topic+blockpick">blockpick</a></code> or <code><a href="#topic+blockpick.big">blockpick.big</a></code>.</p>
</dd>
<dt>aliased.with.blocks</dt><dd><p> for designs of type <code>FrF2.blocked</code> only; <br />
treatment effects that are aliased with block main effects,
up to 2fis or 3fis, depending on the choice of <code>alias.info</code></p>
</dd>
<dt>aliased </dt><dd><p> alias structure of main effects, 2fis and possibly 3fis,
depending on the choice of <code>alias.info</code>; 
For non-blocked and non-split-plot designs, <code>aliased</code> is 
itself a list of the two or three components main, fi2, and optionally fi3, given 
in terms of factor letters from <code>Letters</code> (up to 50~factors) 
or <code>F1</code>, <code>F2</code>, and so forth (more than 50~factors). 
For blocked and split-plot designs, <code>aliased</code> is a single list 
with an entry for each column of the Yates matrix that accomodates 
aliased low-order effects, and entries are in terms of factor names.)</p>
</dd>
<dt>replication </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>repeat.only </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>bbreps</dt><dd><p>for designs of type <code>FrF2.blocked</code> only; 
number of between block replications</p>
</dd>
<dt>wbreps</dt><dd><p>for designs of type <code>FrF2.blocked</code> only; 
number of within block replications;<br />
<code>repeat.only</code> indicates whether these are replications or repetitions only</p>
</dd>
<dt>map </dt><dd><p> the mapping relation between factors in the base design and 
experimental factors, after using option <code>estimable</code> and for split-plot designs</p>
</dd>
<dt>clear </dt><dd><p> option setting in call to <code>FrF2</code>, in case of <code>estimable</code> </p>
</dd>
<dt>res3</dt><dd><p> option setting in call to <code>FrF2</code>, in case of <code>estimable</code> </p>
</dd>
<dt>randomize </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>seed </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>creator </dt><dd><p> call to function FrF2 
(or stored menu settings, if the function has been called via the R commander plugin 
<span class="pkg">RcmdrPlugin.DoE</span>) </p>
</dd>
<dt>ncube </dt><dd><p> number of cube points per block, in case center points have been requested </p>
</dd>
<dt>ncenter </dt><dd><p> number of center points per block, in case center points have been requested </p>
</dd>
</dl>

</td></tr>
</table>


<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For reproducing a randomized design that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Bingham, D.R., Schoen, E.D. and Sitter, R.R. (2004). 
Designing Fractional Factorial Split-Plot Experiments with Few Whole-Plot Factors. 
<em>Applied Statistics</em> <b>53</b>, 325-339.
</p>
<p>Bingham, D. and Sitter, R.R. (2003). Fractional Factorial Split-Plot Designs
for Robust Parameter Experiments. <em>Technometrics</em> <b>45</b>, 80-89.
</p>
<p>Bisgaard, S. (1994a). Blocking generators for small <code class="reqn">2^{k-p}</code> designs. 
<em>J. Quality Technology</em> <b>26</b>, 288-294.
</p>
<p>Chen, J., Sun, D.X. and Wu, C.F.J. (1993) 
A catalogue of 2-level and 3-level orthogonal arrays. 
<em>International Statistical Review</em> <b>61</b>, 131-145. 
</p>
<p>Cheng, C.-S., Martin, R.J., and Tang, B. (1998). 
Two-level factorial designs with extreme numbers of level changes. <em>Annals of Statistics</em> 
<b>26</b>, 1522-1539.
</p>
<p>Cheng, C.-S. and Tsai, P.-W. (2009). 
Optimal two-level regular fractional factorial block and split-plot designs. 
<em>Biometrika</em> <b>96</b>, 83-93.
</p>
<p>Cheng, S.W. and Wu, C.F.J. (2002). 
Choice of optimal blocking schemes in 2-level and 3-level designs. 
<em>Technometrics</em> <b>44</b>, 269-277. 
</p>
<p>Cordella, L.P., Foggia, P., Sansone, C. and Vento, M. (2001). 
An improved algorithm for matching large graphs. <em>Proc. of the 3rd 
IAPR TC-15 Workshop on Graphbased Representations in Pattern Recognition</em>,
149&ndash;159.
</p>
<p>Godolphin, J. (2021). Construction of Blocked Factorial Designs to Estimate 
Main Effects and Selected Two-Factor Interactions. <em>J. Royal Statistical Society</em> <b>B 83</b>, 5-29. 
doi: <a href="https://doi.org/10.1111/rssb.12397">10.1111/rssb.12397</a>.
</p>
<p>Groemping, U. (2012). Creating clear designs: a graph-based algorithm and a 
catalogue of clear compromise plans. <em>IIE Transactions</em> <b>44</b>, 988&ndash;1001.
Early preprint available at <a href="http://www1.bht-berlin.de/FB_II/reports/Report-2010-005.pdf">http://www1.bht-berlin.de/FB_II/reports/Report-2010-005.pdf</a>. 
</p>
<p>Groemping, U. (2014a). R Package FrF2 for Creating and Analyzing Fractional 
Factorial 2-Level Designs. <em>Journal of Statistical Software</em>, <b>56</b>, 
Issue 1, 1-56. <a href="https://www.jstatsoft.org/v56/i01/">https://www.jstatsoft.org/v56/i01/</a>.
</p>
<p>Groemping, U. (2014b). A Note on Dominating Fractional Factorial 
Two-Level Designs With Clear Two-Factor Interactions. <em>Technometrics</em> 
<b>56</b>, 42&ndash;45.
</p>
<p>Groemping, U. (2021). An algorithm for blocking regular fractional factorial 
2-level designs with clear two-factor interactions. <em>Computational Statistics and Data Analysis</em> 
<b>153</b>, 1-18. doi: <a href="https://doi.org/10.1016/j.csda.2020.107059">10.1016/j.csda.2020.107059</a>. Preprint at 
<a href="http://www1.bht-berlin.de/FB_II/reports/Report-2019-003.pdf">Report 3/2019</a>.
</p>
<p>Huang, P., Chen, D. and Voelkel, J.O. (1998). Minimum-Aberration Two-Level Split-Plot Designs. 
<em>Technometrics</em> <b>40</b>, 314-326. 
</p>
<p>Mee, R. (2009). <em>A Comprehensive Guide to Factorial Two-Level Experimentation</em>. 
New York: Springer.
</p>
<p>Solnon, C. (2010). AllDifferent-based Filtering for Subgraph Isomorphism.
<em>Artificial Intelligence</em> <b>174</b>, 850&ndash;864.
</p>
<p>Sun, D.X., Wu, C.F.J. and Chen, Y.Y. (1997). 
Optimal blocking schemes for <code class="reqn">2^n</code> and <code class="reqn">2^{n-p}</code> designs. <em>Technometrics</em> <b>39</b>, 
298-307. 
</p>
<p>Wu, C.F.J. and Chen, Y. (1992) 
A graph-aided method for planning two-level experiments when certain interactions 
are important. 
<em>Technometrics</em> <b>34</b>, 162-175. 
</p>


<h3>See Also</h3>

<p> See also <br />
<code><a href="#topic+FrF2Large">FrF2Large</a></code> for regular fractional factorial designs 
with more than 4096 runs (these are not supported by a design catalogue, except for 
a few resolution V designs which have not been checked for any optimality among the resolution V designs), <br />
<code><a href="#topic+pb">pb</a></code> for non-regular fractional factorials according 
to Plackett-Burman, <br />
<code><a href="#topic+catlg">catlg</a></code> for the underlying design catalogue and some accessor functions,<br />
and <code><a href="#topic+block">block</a></code>, <code><a href="#topic+splitplot">splitplot</a></code> or <code><a href="#topic+estimable.2fis">estimable.2fis</a></code> 
for statistical and algorithmic information on the respective topic.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## maximum resolution minimum aberration design with 4 factors in 8 runs
FrF2(8,4)
## the design with changed default level codes
FrF2(8,4, default.level=c("current","new"))
## the design with number of factors specified via factor names 
      ## (standard level codes)
FrF2(8,factor.names=list(temp="",press="",material="",state=""))
## the design with changed factor names and factor-specific level codes
FrF2(8,4, factor.names=list(temp=c("min","max"),press=c("low","normal"),
     material=c("current","new"),state=c("new","aged")))
## a full factorial
FrF2(8,3, factor.names=list(temp=c("min","max"),press=c("low","normal"),
     material=c("current","new")))
## a replicated full factorial (implicit by low number of factors)
FrF2(16,3, factor.names=list(temp=c("min","max"),press=c("low","normal"),
     material=c("current","new")))
## three ways for custom specification of the same design
FrF2(8, generators = "ABC")
FrF2(8, generators = 7)
FrF2(8, generators = list(c(1,2,3)))
## more than one generator
FrF2(8, generators = c("ABC","BC"))
FrF2(8, generators = c(7,6))
FrF2(8, generators = list(c(1,2,3),c(2,3)))
## alias structure for three generators that differ only by sign
design.info(FrF2(16,generators=c(7,13,15),randomize=FALSE))$aliased
design.info(FrF2(16,generators=c(7,-13,15),randomize=FALSE))$aliased
design.info(FrF2(16,generators=c(-7,-13,-15),randomize=FALSE))$aliased
## finding smallest design with resolution 5 in 7 factors
FrF2(nfactors=7, resolution=5)
## same design, but with 12 center points in 6 positions
FrF2(nfactors=7, resolution=5, ncenter=12, center.distribute=6)


## maximum resolution minimum aberration design with 9 factors in 32 runs
## show design information instead of design itself
design.info(FrF2(32,9))
## maximum number of free 2-factor interactions instead of minimum aberration
## show design information instead of design itself
design.info(FrF2(32,9,MaxC2=TRUE))

## usage of replication
## shows run order instead of design itself
run.order(FrF2(8,4,replication=2,randomize=FALSE))
run.order(FrF2(8,4,replication=2,repeat.only=TRUE,randomize=FALSE))
run.order(FrF2(8,4,replication=2))
run.order(FrF2(8,4,replication=2,repeat.only=TRUE))


## Not run: 
## examples below do work, but are repeated in the 
## respective method's separate help file and are therefore prevented 
## from running twice

########## automatic blocked designs ###################
## from a full factorial ##
FrF2(8,3,blocks=2)
## with replication
run.order(FrF2(8,3,blocks=2,wbreps=2))
run.order(FrF2(8,3,blocks=2,wbreps=2,repeat.only=TRUE))
run.order(FrF2(8,3,blocks=2,bbreps=2))
run.order(FrF2(8,3,blocks=2,bbreps=2,wbreps=2))

## automatic blocked design with fractions
FrF2(16,7,blocks=4,alias.block.2fis=TRUE,factor.names=c("MotorSpeed", 
      "FeedMode","FeedSizing","MaterialType","Gain","ScreenAngle","ScreenVibLevel"))
## isomorphic non-catalogued design as basis, using Godolphin approach
FrF2(16,gen=c(7,11,14),blocks=4,alias.block.2fis=TRUE)
## isomorphic non-catalogued design as basis, not using Godolphin approach
## (different design of comparable quality in this case)
FrF2(16,gen=c(7,11,14),blocks=4,alias.block.2fis=TRUE, force.godolphin=FALSE)
## FrF2 uses blockpick.big and ignores the generator
FrF2(64,gen=c(7,11,14),blocks=16,alias.block.2fis=TRUE, block.old=TRUE)
## FrF2 uses Godolphin approach, regardless of force.godolphin argument
##      because the setting is large
FrF2(64,gen=c(7,11,14),blocks=16,alias.block.2fis=TRUE)

########## manual blocked design ####################
### example that shows why order of blocks is not randomized
### can of course be randomized by user, if appropriate
FrF2(32,9,blocks=c("Day","Shift"),alias.block.2fis=TRUE, 
    factor.names=list(Day=c("Wednesday","Thursday"), Shift=c("Morning","Afternoon"),
        F1="",F2="",F3="",F4="",F5="",F6="",F7=""), default.levels=c("current","new"))

########## blocked design with estimable 2fis ####################
### all interactions of last two factors to be estimable clearly
### in 64 run design with blocks of size 4
### not possible with catalogue entry 9-3.1
FrF2(64, 6, blocks=16, factor.names=Letters[15:20], 
                 estimable=compromise(6,3)$requirement,
                 alias.block.2fis=TRUE, randomize=FALSE)
FrF2(design="9-3.2", blocks=16, alias.block.2fis=TRUE, 
    factor.names = list(C1="",C2="",C3="",C4="",C5="",C6="",C7="",
    N1=c("low","high"),N2=c("low","high")), 
    default.levels = c("current","new"),
    estimable=compromise(9, 8:9)$requirement)
FrF2(256, 13, blocks=64, alias.block.2fis=TRUE, 
    factor.names = list(C1="",C2="",C3="",C4="",C5="",C6="",C7="",C8="",
    N1=c("low","high")), 
    default.levels = c("current","new"),
    estimable=compromise(13, 1)$requirement)

########## hard to change factors ####################
## example from Bingham and Sitter Technometrics 19999
## MotorSpeed, FeedMode,FeedSizing,MaterialType are hard to change
BS.ex &lt;- FrF2(16,7,hard=4,
     factor.names=c("MotorSpeed", "FeedMode","FeedSizing","MaterialType",
                  "Gain","ScreenAngle","ScreenVibLevel"), 
     default.levels=c("-","+"),randomize=FALSE)
design.info(BS.ex)
BS.ex
## NOTE: the design has 8 whole plots.
## If randomize=FALSE is used like here, the first hard-to-change factors 
## do not always change between whole plots. 
## A conscious and honest decision is required whether this is 
##    acceptable for the situation at hand!
## randomize=TRUE would cause more changes in the first four factors.

########## automatic generation for split plot ##########
## 3 control factors, 5 noise factors, control factors are whole plot factors
## 8 plots desired in a total of 32 runs
## Bingham Sitter 2003
BS.ex2a &lt;- FrF2(32, 8, WPs=8, nfac.WP=3, 
      factor.names=c(paste("C",1:3,sep=""), paste("N",1:5,sep="")),randomize=TRUE)

## manual generation of this same design
BS.ex2m &lt;- FrF2(32, 8, generators=c("ABD","ACD","BCDE"),WPs=8, WPfacs=c("C1","C2","C3"), nfac.WP=3, 
      factor.names=c(paste("C",1:3,sep=""),paste("N",1:5,sep="")),randomize=TRUE)

## design with few whole plot factors
## 2 whole plot factors, 7 split plot factors
## 8 whole plots, i.e. one extra WP factor needed
BSS.cheese.exa &lt;- FrF2(32, 9, WPs=8, nfac.WP=2, 
      factor.names=c("A","B","p","q","r","s","t","u","v"))
design.info(BSS.cheese.exa)
## manual generation of the design used by Bingham, Schoen and Sitter
## note that the generators include a generator for the 10th spplitting factor
    ## s= ABq, t = Apq, u = ABpr and v = Aqr, splitting factor rho=Apqr
BSS.cheese.exm &lt;- FrF2(32, gen=list(c(1,2,4),c(1,3,4),c(1,2,3,5),c(1,4,5),c(1,3,4,5)), 
      WPs=8, nfac.WP=3, WPfacs=c(1,2,10),
      factor.names=c("A","B","p","q","r","s","t","u","v","rho"))
design.info(BSS.cheese.exm)

########## usage of estimable ###########################
  ## design with all 2fis of factor A estimable on distinct columns in 16 runs
  FrF2(16, nfactors=6, estimable = rbind(rep(1,5),2:6), clear=FALSE)
  FrF2(16, nfactors=6, estimable = c("AB","AC","AD","AE","AF"), clear=FALSE)
  FrF2(16, nfactors=6, estimable = formula("~A+B+C+D+E+F+A:(B+C+D+E+F)"), 
       clear=FALSE)
            ## formula would also accept self-defined factor names
            ## from factor.names instead of letters A, B, C, ...
            
  ## estimable does not need any other input
  FrF2(estimable=formula("~(A+B+C)^2+D+E"))

  ## estimable with factor names 
  ## resolution three must be permitted, as FrF2 first determines that 8 runs 
  ##     would be sufficient degrees of freedom to estimate all effects 
  ##     and then tries to accomodate the 2fis from the model clear of aliasing in 8 runs
  FrF2(estimable=formula("~one+two+three+four+two:three+two:four"), 
       factor.names=c("one","two","three","four"), res3=TRUE)
  ## clear=FALSE allows to allocate all effects on distinct columns in the 
  ##     8 run MA resolution IV design
  FrF2(estimable=formula("~one+two+three+four+two:three+two:four"), 
       factor.names=c("one","two","three","four"), clear=FALSE)

  ## 7 factors instead of 6, but no requirements for factor G
  FrF2(16, nfactors=7, estimable = formula("~A+B+C+D+E+F+A:(B+C+D+E+F)"), 
       clear=FALSE)
  ## larger design for handling this with all required effects clear
  FrF2(32, nfactors=7, estimable = formula("~A+B+C+D+E+F+A:(B+C+D+E+F)"), 
       clear=TRUE)
  ## 16 run design for handling this with required 2fis clear, but main effects aliased
  ## (does not usually make sense)
  FrF2(16, nfactors=7, estimable = formula("~A+B+C+D+E+F+A:(B+C+D+E+F)"), 
       clear=TRUE, res3=TRUE)

## End(Not run)
## example for the sort option added with version 1.6-1
## and for usage of a catalogue from package FrF2.catlg128 (simplified with version 1.6-5)
  ## Not run: 
  estim &lt;- compromise(17,15:17)$requirement  ## all interactions of factors 15 to 17 (P,Q,R)
  ## VF2 algorithm without pre-sorting of vertices
  ### CAUTION: in some igraph versions, the following may crash R ###
  FrF2(128, 17, estimable=estim, select.catlg=catlg128.17) 
                        ## very slow, interrupt with ESC key after a short while
                        ## !!! save all important work before, in case R crashes
  FrF2.currentlychecked()   ## displays the design that was currently checked 
                            ## should be 17-10.2407, if the interrupt was successful
  ## VF2 algorithm with pre-sorting of vertices
  FrF2(128, 17, estimable=estim, sort="high", select.catlg=catlg128.17)  ## very fast
  FrF2(128, 17, estimable=estim, sort="low", select.catlg=catlg128.17)  ## very fast
  ## LAD algorithm
  FrF2(128, 17, estimable=estim, method="LAD", select.catlg=catlg128.17)  ## very fast
  ## guaranteed to be MA clear design 
  ## only works, if package FrF2.catlg128 is installed
  
## End(Not run)

## example for necessity of perms, and uses of select.catlg and perm.start
## based on Wu and Chen Example 1
  ## Not run: 
  ## runs per default about max.time=60 seconds, before throwing error with 
  ##        interim results
  ## results could be used in select.catlg and perm.start for restarting with 
  ##       calculation of further possibilities
  FrF2(32, nfactors=11, estimable = formula("~(A+B+C+D+E+F)^2"), clear=FALSE)
  ## would run for a long long time (I have not yet been patient enough)
  FrF2(32, nfactors=11, estimable = formula("~(A+B+C+D+E+F)^2"), clear=FALSE, 
       max.time=Inf)
  ## can be easily done with perms, 
  ## as only different subsets of six factors are non-isomorphic
  perms.6 &lt;- combn(11,6)
  perms.full &lt;- matrix(NA,ncol(perms.6),11)
  for (i in 1:ncol(perms.6))
     perms.full[i,] &lt;- c(perms.6[,i],setdiff(1:11,perms.6[,i]))
  FrF2(32, nfactors=11, estimable = formula("~(A+B+C+D+E+F)^2"), clear=FALSE, 
      perms = perms.full )
  
## End(Not run)
</code></pre>

<hr>
<h2 id='FrF2Large'> Function to provide large (at least 8192 runs) regular Fractional Factorial designs 
that are not necessarily optimal, especially large resolution V designs.</h2><span id='topic+FrF2Large'></span><span id='topic+nrunsV'></span>

<h3>Description</h3>

<p>Large regular fractional factorial 2-level designs in 8192 or more runs are provided: 
Resolution V designs in 8096 to 32768 runs with up to 120 factors according to the suggestion by Sanchez and Sanchez 2005 
are automatically created (these are not necessarily optimal). Furthermore, manual generation 
of large regular fractional factorial designs via specification of generators is possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FrF2Large(nruns, nfactors = NULL, factor.names = if (!is.null(nfactors)){ 
    if (nfactors &lt;= 50) 
        Letters[1:nfactors]
    else paste("F", 1:nfactors, sep = "")
    } else NULL, 
    default.levels = c(-1, 1), ncenter = 0, center.distribute = NULL, 
    generators = NULL, 
    replications = 1, repeat.only = FALSE, 
    randomize = TRUE, seed = NULL, alias.info = 2, ...) 
nrunsV(nfactors)    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FrF2Large_+3A_nruns">nruns</code></td>
<td>
<p> Number of runs, must be a power of 2 (8192 to 32768). 
</p>
<p>The number of runs must match the number of factors. Function <code>nrunsV</code> 
can be used for determining the number of runs needed for a resolution V design, 
and for advice on the function to be used.<br />
For more detail on specification of the number of runs, see the Details section.
</p>
</td></tr>
<tr><td><code id="FrF2Large_+3A_nfactors">nfactors</code></td>
<td>
<p> is the number of 2-level factors to be investigated. 
It can be omitted, if it is obvious from options <code>factor.names</code> or 
<code>generators</code>.<br /> 
The number of factors must match the length of <code>generators</code>.
</p>
</td></tr>
<tr><td><code id="FrF2Large_+3A_factor.names">factor.names</code></td>
<td>
<p> a character vector of <code>nfactors</code> factor names 
or a list with <code>nfactors</code> elements;<br /> 
if the list is named, list names represent factor names, otherwise default factor names are used;<br /> 
the elements of the list are <br />
EITHER vectors of length 2 with factor levels for the respective factor<br />
OR empty strings. 
For each factor with an empty string in factor.names, the levels given in 
<code>default.levels</code> are used;<br />
Default factor names are the first elements of the character vector <code><a href="DoE.base.html#topic+utilities">Letters</a></code>, 
or the factors position numbers preceded by capital F in case of more than 50 factors. </p>
</td></tr>
<tr><td><code id="FrF2Large_+3A_default.levels">default.levels</code></td>
<td>
<p> default levels (vector of length 2) for all factors for 
which no specific levels are given </p>
</td></tr>
<tr><td><code id="FrF2Large_+3A_ncenter">ncenter</code></td>
<td>
<p> number of center points per block; <code>ncenter &gt; 0</code> 
is permitted, if all factors are quantitative and the design is not a split-plot design </p>
</td></tr>
<tr><td><code id="FrF2Large_+3A_center.distribute">center.distribute</code></td>
<td>
<p> the number of positions over which the center points 
are to be distributed for each block; if NULL (default), center points are 
distributed over end, beginning, and middle (in that order, if there are fewer than three center points) 
for randomized designs, and appended to the end for non-randomized designs. 
for more detail, see function <code><a href="#topic+add.center">add.center</a></code>, which does the work.
</p>
</td></tr>
<tr><td><code id="FrF2Large_+3A_generators">generators</code></td>
<td>
<p> There are <code>log2(nruns)</code> base factors the full factorial 
of which spans the design (e.g. 10 for 1024 runs). 
The generators specify how the remaining factors 
are to be allocated to interactions of these. <br />
WARNING: Of course, with manual 
specification of generators, the structure of the design is in the users 
responsibility; the function only prevents confounding of two main effects with each 
other.
</p>
<p><code>generators</code> can be 
</p>
<p>a list of vectors with position numbers of base factors (e.g. c(1,3,4) 
stands for the interaction between first, third and fourth base factor) 
</p>
<p>a vector of character representations of these interactions, 
e.g. &ldquo;ACD&rdquo; stands for the same interaction as above
</p>
<p>a vector of columns numbers in Yates order (e.g. 13 stands for ACD). 
Note that the columns 1, 2, 4, 8, etc., i.e. all powers of 2, are reserved 
for the base factors and cannot be used for assigning additional factors, 
because the design would become a resolution II design. For looking up 
which column number stands for which interaction, type e.g. 
<code>names(Yates)[1:15]</code> for a 16 run design.
</p>
<p>WARNING: Contrary to function <code><a href="#topic+FrF2">FrF2</a></code>, it is not possible to 
precede generator entries with a minus sign for reversing column levels; 
instead, the levels must be swapped.
</p>
</td></tr>
<tr><td><code id="FrF2Large_+3A_replications">replications</code></td>
<td>
<p> positive integer number. Default 1 (i.e. each row just once). 
If larger, each design run is executed replication times. 
If <code>repeat.only</code>, repeated measurements 
are carried out directly in sequence, i.e. no true replication takes place, 
and all the repeat runs are conducted together. It is likely that the error 
variation generated by such a procedure will be too small, so that average values 
should be analyzed for an unreplicated design. 
</p>
<p>Otherwise (default), the full experiment is first carried out once, then 
for the second replication and so forth. In case of randomization, 
each such blocks is randomized separately. In this case, replication variance is 
more likely suitable for usage as error variance 
(unless e.g. the same parts are used for replication runs although build 
variation is important).</p>
</td></tr>
<tr><td><code id="FrF2Large_+3A_repeat.only">repeat.only</code></td>
<td>
<p> logical, relevant only if replications &gt; 1. If TRUE, 
replications of each run are grouped together 
(repeated measurement rather than true replication). The default is 
<code>repeat.only=FALSE</code>, i.e. the complete experiment 
is conducted in <code>replications</code> blocks, and each run occurs in each block.  </p>
</td></tr>
<tr><td><code id="FrF2Large_+3A_randomize">randomize</code></td>
<td>
<p> logical. If TRUE, the design is randomized. This is the default. 
In case of replications, the nature of randomization depends on the setting of 
option <code>repeat.only</code>.</p>
</td></tr>
<tr><td><code id="FrF2Large_+3A_seed">seed</code></td>
<td>
<p> optional seed for the randomization process <br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>FrF2Large</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="DoE.base.html#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
<tr><td><code id="FrF2Large_+3A_alias.info">alias.info</code></td>
<td>
<p> can be 2 or 3, gives the order of interaction effects for which 
alias information is to be included in the <code>aliased</code> component of the 
<code>design.info</code> element of the output object. </p>
</td></tr>
<tr><td><code id="FrF2Large_+3A_...">...</code></td>
<td>
<p> currently not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If generators are not explicitly specified, function <code>FrF2Large</code> creates a 
resolution V design according to the 
rules by Sanchez and Sanchez (2005) for the specified number of factors in 
the specified number of runs. The Sanchez and Sanchez article offers designs with <br />
at least 1024 runs for 25 to 29 factors (1024 up to 33 factors with <code><a href="#topic+FrF2">FrF2</a></code>),<br />
at least 2048 runs for 30 to 38 factors (2048 up to 47 factors with <code><a href="#topic+FrF2">FrF2</a></code>),<br />
at least 4096 runs for 39 to 52 factors (4096 up to 65 factors with <code><a href="#topic+FrF2">FrF2</a></code>),<br />
at least 8192 runs for 53 to 69 factors (up to 65 factors in half the run size with <code><a href="#topic+FrF2">FrF2</a></code>),<br />
at least 16384 runs for 70 to 92 factors, (<br />
at least 32768 runs for 93 to 120 factors.<br />
For designs with up to 4096 runs, function <code><a href="#topic+FrF2">FrF2</a></code> 
creates better automatic designs. 
Therefore, function <code>FrF2Large</code> is restricted to usage for larger designs. 
</p>
<p>Users can explicitly specify a design through specifying 
generators via the <code>generators</code> option. For up to 4096 runs, this is also possible 
with function <code><a href="#topic+FrF2">FrF2</a></code>, even with more flexibility. Therefore, manual design generation 
with function <code>FrF2Large</code> is also restricted to designs of at least 8192 runs.
</p>
<p>Manual generation of large designs with the option <code>generators</code> is limited by 
computer memory only. <code>nruns</code> must be at least large enough to accomodate the 
rightmost generator column; for example, if generators contains an element <code>ABEP</code>, 
<code>P</code> is the 15th base factor (15th letter in <code><a href="DoE.base.html#topic+Letters">Letters</a></code>), 
i.e. <code>nruns</code> must be at least <code>2^15</code>=32768;
if the largest generator column number in Yates column notation is 4201, 
<code>nruns</code> must be at least <code>2^ceiling(log2(4201))</code>=8192. 
</p>


<h3>Value</h3>

<p>Function <code>nrunsV</code> invisibly returns the number of runs requested and 
prints a message with the number of runs and the appropriate function.
</p>
<p>Function <code>FrF2Large</code> returns a data frame of S3 class 
<code><a href="DoE.base.html#topic+class-design">design</a></code> 
and has attached attributes that can be accessed 
by functions <code><a href="DoE.base.html#topic+class-design-methods">desnum</a></code>, 
<code><a href="DoE.base.html#topic+class-design-methods">run.order</a></code> and 
<code><a href="DoE.base.html#topic+class-design-methods">design.info</a></code>. 
</p>
<p>The data frame itself contains the design with levels coded as requested. 
If no center points have been requested, the design columns are factors with 
contrasts <code>-1</code> and <code>+1</code> (cf. also <code><a href="DoE.base.html#topic+contr.FrF2">contr.FrF2</a></code>); in case 
of center points, the design columns are numeric.
</p>
<p>The following attributes are attached to it: 
</p>
<table>
<tr><td><code>desnum</code></td>
<td>
<p>Design matrix in -1/1 coding</p>
</td></tr>
<tr><td><code>run.order</code></td>
<td>
<p>three column data frame, first column contains the run number in 
standard order, second column the run number as randomized, third column the 
run number with replication number as postfix;
useful for switching back and forth between actual and standard run 
number</p>
</td></tr>
<tr><td><code>design.info</code></td>
<td>
<p>list with the entries 
</p>

<dl>
<dt>type</dt><dd><p> character string &ldquo;FrF2.large&rdquo;</p>
</dd>
<dt>nruns</dt><dd><p> number of runs (replications are not counted) </p>
</dd>
<dt>nfactors</dt><dd><p> number of factors</p>
</dd>
<dt>factor.names </dt><dd><p> list named with (treatment) factor names and containing as 
entries vectors of length two each with coded factor levels </p>
</dd>
<dt>generators </dt><dd><p> for designs of type <code>FrF2.generators</code> only; <br />
character vector of generators in the form D=ABC etc.</p>
</dd>
<dt>aliased </dt><dd><p> alias structure of main effects, 2fis and possibly 3fis,
depending on the choice of <code>alias.info</code>; 
For non-blocked and non-split-plot designs, <code>aliased</code> is 
itself a list of the two or three components main, fi2, and optionally fi3, given 
in terms of factor letters from <code>Letters</code> (up to 50~factors) 
or <code>F1</code>, <code>F2</code>, and so forth (more than 50~factors). 
For blocked and split-plot designs, <code>aliased</code> is a single list 
with an entry for each column of the Yates matrix that accomodates 
aliased low-order effects, and entries are in terms of factor names.)</p>
</dd>
<dt>replications </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>repeat.only </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>randomize </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>seed </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>creator </dt><dd><p> call to function FrF2Large; 
(in future, may also contain stored menu settings from R commander plugin 
<span class="pkg">RcmdrPlugin.DoE</span>, once the function has been implemented in that package) 
</p>
</dd>
<dt>FrF2.version </dt><dd><p> version number of package FrF2, 
supporting correct usage of <code>FrF2</code>-specific functionality in 
functions <code>summary</code> and <code>generators</code> 
methods for class <code>design</code></p>
</dd>
<dt>ncube </dt><dd><p> number of cube points per block, in case center points have been requested </p>
</dd>
<dt>ncenter </dt><dd><p> number of center points per block, in case center points have been requested </p>
</dd>
</dl>

</td></tr>
</table>


<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that might be relevant for the randomization 
of very large designs). 
For reproducing a randomized design that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Mee, R. (2009). <em>A Comprehensive Guide to Factorial Two-Level Experimentation</em>. 
New York: Springer.
</p>
<p>Sanchez, S.M. and Sanchez, P.J. (2005). Very Large Fractional Factorial 
and Central Composite Designs. 
<em>ACM Transactions on Modeling and Computer Simulation</em> 
<b>15</b>, 362-377.
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+FrF2">FrF2</a></code> for smaller regular fractional factorials and 
<code><a href="DoE.base.html#topic+oacat">oacat</a></code> for two non-regular resolution V fractional factorials (reported e.g. by 
Mee 2009) for up to 19 factors in 256 runs or up to 63 factors in 2048 runs </p>


<h3>Examples</h3>

<pre><code class='language-R'>## numbers of runs needed for resolution V designs in different numbers of factors 
nrunsV(8)
nrunsV(18)
needed &lt;- nrunsV(27)
needed
nrunsV(65)
nrunsV(71)

## Not run: 
plan &lt;- FrF2Large(nrunsV(75),75)
summary(plan)

## End(Not run)
</code></pre>

<hr>
<h2 id='godolphin'> Functions in support of Godolphin's approach for blocking designs </h2><span id='topic+colpick'></span><span id='topic+FF_from_X'></span><span id='topic+X_from_parts'></span><span id='topic+X_from_profile'></span><span id='topic+clear2fis_from_profile'></span><span id='topic+blockgencreate'></span><span id='topic+phimax'></span><span id='topic+Xcalc'></span><span id='topic+blockgengroup'></span><span id='topic+colpickIV'></span>

<h3>Description</h3>

<p>Function colpick handles the creation of X matrices for blocking, 
function FF_from_X blocks a full factorial, function X_from_profile creates 
an X matrix from a profile, 
function phimax calculations the maximum number of clear 2fis from Godolphin's approach.
Further helper functions support the use of the method. 
The functions are meant for expert users only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colpick(design, q, all = FALSE, select.catlg = catlg, 
      estimable = NULL, method = "VF2", sort = "natural",
      res3 = FALSE, all0 = FALSE, quiet = FALSE, 
      firsthit = is.numeric(design))
FF_from_X(X, randomize = TRUE, seed = NULL, alias.info=2)
X_from_profile(n, q, profile = NULL)
clear2fis_from_profile(n, q, profile = NULL)
X_from_parts(n, q, parts)
phimax(n, q, profile = NULL)
blockgencreate(X, p = 0)
Xcalc(XI, gen)
blockgengroup(X, p = 0, num = FALSE)
colpickIV(design, q, all = FALSE, select.catlg = catlg, 
      estimable = NULL, method = "VF2", sort = "natural",
      res3 = FALSE, all0 = FALSE, quiet = FALSE, 
      firsthit = is.numeric(design))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="godolphin_+3A_design">design</code></td>
<td>
<p>a character string that identifies a design in the cataloge specified 
by option <code>select.catlg</code>, <br />
OR a class <code>catlg</code> object with a single entry (of longer, only the first one is used), <br />
OR an integer number of factors for which a full factorial is assumed.</p>
</td></tr>
<tr><td><code id="godolphin_+3A_q">q</code></td>
<td>
<p>the requested block size is <code class="reqn">2^q</code></p>
</td></tr>
<tr><td><code id="godolphin_+3A_all">all</code></td>
<td>
<p>if TRUE (default FALSE), all possible <b>X</b> matrices are returned; 
otherwise, <code>colpick</code> returns the first successful one (if <code>estimable</code> 
is not NULL) or the best one (otherwise)</p>
</td></tr>
<tr><td><code id="godolphin_+3A_select.catlg">select.catlg</code></td>
<td>
<p>name of catalogue (not in quotes); 
only relevant, if <code>design</code> is a character string</p>
</td></tr>
<tr><td><code id="godolphin_+3A_estimable">estimable</code></td>
<td>
<p>a specification of 2fis to be kept clear in the blocked design, 
either as a character vector of pairs of factor letters (using the first 
elements of 'Letters') or as a two-row matrix of pairs of factor numbers occurring 
in 2fis)</p>
</td></tr>
<tr><td><code id="godolphin_+3A_method">method</code></td>
<td>
<p>character string identifying a subgraph isomorphism method
(VF2 or LAD), see <code><a href="#topic+FrF2">FrF2</a></code></p>
</td></tr>
<tr><td><code id="godolphin_+3A_sort">sort</code></td>
<td>
<p>character string specifying a presort strategy for subgraph 
isomorphism search, see <code><a href="#topic+FrF2">FrF2</a></code></p>
</td></tr>
<tr><td><code id="godolphin_+3A_res3">res3</code></td>
<td>
<p>relevant only if <code>estimable</code> is not NULL;<br />
per default (<code>res3=FALSE</code>), <code>design</code> will yield no result, 
if it has resolution III only; 
set <code>res3</code> to TRUE for allowing a <code>design</code> of resolution III 
(almost never useful)</p>
</td></tr>
<tr><td><code id="godolphin_+3A_all0">all0</code></td>
<td>
<p>per default (<code>all0=FALSE</code>), <b>X</b> matrices are requested to be 
free of all-zero columns. Set <code>all0</code> to TRUE for permitting aliasing 
between blocks and factor main effects, i.e. for finding a suitable split-plot
constructor. </p>
</td></tr>
<tr><td><code id="godolphin_+3A_quiet">quiet</code></td>
<td>
<p>if TRUE, the message about failure is suppressed (for using the function 
inside other functions, like <code>FrF2</code>) </p>
</td></tr>
<tr><td><code id="godolphin_+3A_firsthit">firsthit</code></td>
<td>
<p>if TRUE, the function does not attempt to optimize the 
number of clear 2fis but accepts the first acceptable blocking
(relevant for non-null <code>estimable</code> only); <br />
per default, optimizing is suppressed for full factorials only (where it 
is not very reasonable to use function <code>colpick</code> instead of simply
hand-crafting an <b>X</b> matrix; function <code>FrF2</code> sets it to FALSE 
for creation of full factorials with estimability requirements); <br />
for large applications with estimability requirements, 
specifying <code>firsthit</code> as TRUE may allow to inspect more candidates 
and to then possibly deepdive some of them</p>
</td></tr>
<tr><td><code id="godolphin_+3A_x">X</code></td>
<td>
<p>a <code class="reqn">q \times n</code> <b>X</b> matrix 
with only 0/1 elements for block construction </p>
</td></tr>
<tr><td><code id="godolphin_+3A_randomize">randomize</code></td>
<td>
<p> logical. If TRUE, the design is randomized. This is the default.
Randomization is implemented using function 
<code><a href="DoE.base.html#topic+rerandomize.design">rerandomize.design</a></code> of package <span class="pkg">DoE.base</span> 
as the last step in design creation.
</p>
</td></tr>
<tr><td><code id="godolphin_+3A_seed">seed</code></td>
<td>
<p> optional seed for the randomization process <br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>FrF2</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="DoE.base.html#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
<tr><td><code id="godolphin_+3A_alias.info">alias.info</code></td>
<td>
<p>degree of effects aliased with blocks to be included in the 
<code>design.info</code> attribute</p>
</td></tr>
<tr><td><code id="godolphin_+3A_profile">profile</code></td>
<td>
<p>profile to use for calculation 
(NULL or integer vector of up to <code class="reqn">2^q-1</code> elements that sum to <code class="reqn">n</code>); 
if NULL, the maximally balanced profile is used (which yields the overall maximum
number of clear 2fis when blocking a full factorial)</p>
</td></tr>
<tr><td><code id="godolphin_+3A_parts">parts</code></td>
<td>
<p>list that provides factor partitions; list entries 
must either be all integers from 1 to <code>n</code> or the elements
of <code>Letters[1:n]</code></p>
</td></tr>
<tr><td><code id="godolphin_+3A_n">n</code></td>
<td>
<p>number of factors</p>
</td></tr>
<tr><td><code id="godolphin_+3A_p">p</code></td>
<td>
<p>the number of generated factors (among the n factors); 
<code class="reqn">2^{n-p}</code> is the number of runs in the experiment)</p>
</td></tr>
<tr><td><code id="godolphin_+3A_xi">XI</code></td>
<td>
<p>a <code class="reqn">q \times k</code> <b>X</b>_I matrix 
with only 0/1 elements, 
to be extended into a <code class="reqn">q \times n</code> <b>X</b> matrix for 
block construction, given the generators in <code>gen</code> (<code class="reqn">k=n-p</code>)</p>
</td></tr>
<tr><td><code id="godolphin_+3A_gen">gen</code></td>
<td>
<p>generators for extending <code>XI</code>: <code>gen</code> can be<br /> 
a class <code>catlg</code> object (e.g. <code>catlg["7-2.1"]</code> or 
<code>catlg[nruns(catlg)==32 &amp; nfac(catlg)==7])</code>; each <code>nfac</code> 
entry must be the sum of <code class="reqn">k</code> and the length of the <code>gen</code> element)<br />
a vector of Yates column numbers (e.g. <code>c(7, 27)</code>)<br />
a vector of defining contrasts (e.g. <code>c("ABC","ABDE")</code>)
a list of vectors of base column numbers</p>
</td></tr>
<tr><td><code id="godolphin_+3A_num">num</code></td>
<td>
<p>if TRUE (default FALSE), Yates column numbers are returned 
instead of their character representations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are the functions for the Godolphin (2021) approach to blocking; 
most of them are user-visible. 
This approach and its implementation are described in Groemping (2021). 
Direct use of this functions is intended for expert use only.
</p>
<p>Function <code>colpick</code> is
the main workhorse function for blocking larger situations 
in function <code><a href="#topic+FrF2">FrF2</a></code> 
(since version 2 of the package, it replaces the earlier approach 
with function <code><a href="#topic+blockpick.big">blockpick.big</a></code>); it makes use of function 
<code>blockgencreate</code>, and of the internal function <code>blockgengroup</code>.
</p>
<p>Function <code>FF_from_X</code> creates a class <code>design</code> object. 
Design size is limited by computer memory and run time. 
The function can use an <b>X</b> matrix that was produced by function 
<code>colpick</code>; but note that it is quite easy to hand-craft 
an <b>X</b> matrix for a full factorial, even with estimability requirements.
The light-weight function does not have arguments for customization; it can 
be post-processed, however, e.g. using function 
<code><a href="DoE.base.html#topic+factor.names+3C-">factor.names&lt;-</a></code>.
</p>
<p>Function <code>X_from_profile</code> creates an X matrix that corresponds to 
the specified profile.
</p>
<p>Function <code>phimax</code> returns the maximum number of 2fis that can 
be kept clear when blocking a full factorial design in <code class="reqn">n</code> factors into 
blocks of size <code class="reqn">2^q</code>, given the specified profile.
</p>
<p>Function <code>blockgencreate</code> creates block generators from an <b>X</b> matrix 
for blocking a design in <code class="reqn">2^{n-p}=2^k</code> runs into blocks of size <code class="reqn">2^q</code>, 
where <code class="reqn">n</code> and <code class="reqn">q</code> are derived from <code>X</code> as the number of columns and rows, 
respectively. The generators are returned as a character vector that consists of 
strings of base factor letters.
</p>
<p>Function <code>Xcalc</code> extends a <code class="reqn">q\times k</code> 
matrix <b>X</b>_I by <code class="reqn">p=n-k</code> columns 
(<b>X</b>_II in Godolphin notatation) based 
on the generators provided in <code>gen</code>.
</p>
<p>Function <code>blockgengroup</code> is internal only, 
as are functions <code>colpickIV</code> and <code>clear2fis_from_profile</code>.
</p>


<h3>Value</h3>

<p>Function <code>colpick</code> returns a list of at least two elements: <br />
if <code>all</code> is FALSE, the list consists of the matrix <code>X</code>, 
the character vector 
<code>clear.2fis</code> and possibly the integer vector <code>map</code>, <br />
otherwise of list-valued elements <code>X_matrices</code>, <code>clearlist</code> and 
<code>profiles</code> and <code>maplist</code>.
</p>
<p>Function <code>FF_from_X</code> returns a class design object of type <code>FrF2.blocked</code>.
</p>
<p>Function <code>phimax</code> returns a real number.
</p>
<p>Function <code>blockgencreate</code> returns a character vector of generators
in terms of <code>Letters</code> combinations of the first $n-p$ factors.
</p>
<p>Function <code>Xcalc</code> returns a <code class="reqn">q\times n</code> 
matrix (in case of a single generator) or a list of such matrices 
(if <code>gen</code> is a class <code>catlg</code> object with more than one element).
</p>
<p>The internal function <code>blockgengroup</code> returns a character vector of all effects 
(denoted as base column letter combinations) aliased with the block main effect, 
or corresponding Yates column numbers.
</p>
<p>The internal function <code>colpickIV</code> returns almost the same type of results as <code>colpick</code>. 
The difference: <br />
if <code>all</code> is TRUE, there is an integer vector <code>map</code> instead of the 
<code>maplist</code> element, because the <code>map</code> does not depend on the choice of X-matrix 
(separate subgraph isomorphism checking is skipped with this function).
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping</p>


<h3>References</h3>

<p>Groemping, U. (2012). Creating clear designs: a graph-based algorithm and a 
catalogue of clear compromise plans. <em>IIE Transactions</em> <b>44</b>, 988&ndash;1001. 
Early preprint available at <a href="http://www1.bht-berlin.de/FB_II/reports/Report-2010-005.pdf">http://www1.bht-berlin.de/FB_II/reports/Report-2010-005.pdf</a>.
</p>
<p>Godolphin, J. (2021). Construction of Blocked Factorial Designs to Estimate 
Main Effects and Selected Two-Factor Interactions. <em>J. Royal Statistical Society</em> <b>B 83</b>, 5-29. 
doi: <a href="https://doi.org/10.1111/rssb.12397">10.1111/rssb.12397</a>.
</p>
<p>Groemping, U. (2021). An algorithm for blocking regular fractional factorial 
2-level designs with clear two-factor interactions. <em>Computational Statistics and Data Analysis</em> 
<b>153</b>, 1-18. doi: <a href="https://doi.org/10.1016/j.csda.2020.107059">10.1016/j.csda.2020.107059</a>. Preprint at 
<a href="http://www1.bht-berlin.de/FB_II/reports/Report-2019-003.pdf">Report 3/2019</a>.
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>, <code><a href="igraph.html#topic+tkplot">tkplot</a></code>,
<code><a href="igraph.html#topic+plot.common">plot.common</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>phimax(7, 2)  ## 16 2fis can be clear, if 128 run full factorial is blocked 
              ## into 32 blocks of size 2^2=4

## X matrices for blocking full factorials
## do not care about which factors have which role
X_from_profile(7, 2, c(3,2,2))
   # X_from_profile(7, 2, c(2,2,3)) returns same matrix
## ensure specific partition, i.e. specific requirement CIG to be accommodated
X &lt;- X_from_parts(7, 2, parts=list(c("A","D","F"), c("B","G"), c("C","E")))

## blocked full factorial
summary(FF_from_X(X))

## using colpick
## estimable in standard letters
requ &lt;- c("BA", "BC", "BD", "BE", "BF", "BG", "BH", "BJ")
## estimability requirement in factor names
fn &lt;- Letters[15:23] ## P to X
requfn &lt;- requ
requfn &lt;- sapply(1:8, function(obj) gsub(Letters[obj], fn[obj], requfn[obj]))

## obtain X matrix for accommodating estimability requirement in 9-4.2
(aus &lt;- colpick("9-4.2", 2, estimable=requ))
## obtain the same matrix manually with Xcalc
XI &lt;- aus$X[,1:5]
## obtain the same matrix manually with Xcalc
all(Xcalc(XI, catlg["9-4.2"])==aus$X)
## inspect X matrices generated from XI
Xcalc(XI, catlg[nruns(catlg)==32 &amp; nfac(catlg)==9 &amp; res(catlg)&gt;=4])

## factor permutation needed
aus$map
## calculate block generators
blockgencreate(aus$X, p=4)
## automatic creation from the design 9-4.2 uses these block generators
summary(FrF2(32, 9, blocks=8, estimable=requ, factor.names=fn, 
    alias.block.2fis = TRUE, select.catlg = catlg["9-4.2"]), 
    brief=TRUE)
## can also be reproduced manually (internal function invperm does the permuting)
summary(FrF2(design="9-4.2", blocks=blockgencreate(aus$X, p=4), 
    factor.names=fn[FrF2:::invperm(aus$map)], 
    alias.block.2fis = TRUE), 
    brief=TRUE)
</code></pre>

<hr>
<h2 id='IAPlot'> Main Effects and Interaction Plots </h2><span id='topic+MEPlot'></span><span id='topic+MEPlot.design'></span><span id='topic+MEPlot.default'></span><span id='topic+IAPlot'></span><span id='topic+IAPlot.design'></span><span id='topic+IAPlot.default'></span><span id='topic+intfind'></span><span id='topic+check'></span><span id='topic+remodel'></span>

<h3>Description</h3>

<p>Main effects plots and interaction plots are produced. The other documented 
functions are not intended for users. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEPlot(obj, ...)
## S3 method for class 'design'
MEPlot(obj, ..., response = NULL)
## Default S3 method:
MEPlot(obj, main = paste("Main effects plot for", respnam), 
    pch = 15, cex.xax = par("cex.axis"), cex.yax = cex.xax, mgp.ylab = 4, 
    cex.title = 1.5, cex.main = par("cex.main"), 
    lwd = par("lwd"), las=par("las"), abbrev = 3, select = NULL, ...)

IAPlot(obj, ...)
## S3 method for class 'design'
IAPlot(obj, ..., response = NULL)
## Default S3 method:
IAPlot(obj, main = paste("Interaction plot matrix for", respnam), 
    pch = c(15, 17), cex.lab = par("cex.lab"), cex = par("cex"), 
    cex.xax = par("cex.axis"), cex.yax = cex.xax, cex.title = 1.5, 
    lwd = par("lwd"), las=par("las"), abbrev = 4, select = NULL, show.alias = FALSE, ...)
         
intfind(i, j, mat)

check(obj)

remodel(obj)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IAPlot_+3A_obj">obj</code></td>
<td>
<p> an experimental design of class <code><a href="DoE.base.html#topic+class-design">design</a></code> 
with the <code>type</code> element of the <code>design.info</code> attribute 
containing &ldquo;FrF2&rdquo; or &ldquo;pb&rdquo;<br />
OR<br />
a linear model object with 2-level factors or numerical 
2-level variables; <br />
the structure must be such that effects are either fully 
aliased or orthogonal, like in a regular fractional factorial 2-level 
design;<br />
note that <code>IAPlot</code> currently requires the response in <code>obj</code> to be 
a pre-defined variable and not a calculated quantity</p>
</td></tr>
<tr><td><code id="IAPlot_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to the default function; <br />
... in the default method are not used, they have been added because of 
formal requirements only </p>
</td></tr>
<tr><td><code id="IAPlot_+3A_response">response</code></td>
<td>
<p> character string that specifies response variable to be used, 
must be an element of <code>response.names(obj)</code>; 
if NULL, the first response from <code>response.names(obj)</code> is used</p>
</td></tr>
<tr><td><code id="IAPlot_+3A_main">main</code></td>
<td>
<p> overall title for the plot assembly </p>
</td></tr>
<tr><td><code id="IAPlot_+3A_pch">pch</code></td>
<td>
<p> Plot symbol number <code>MEPlot</code>, 
or vector of two plot symbol numbers for the lower 
and higher level of the trace factor <code>iap</code></p>
</td></tr>
<tr><td><code id="IAPlot_+3A_cex.xax">cex.xax</code></td>
<td>
<p> size of x-axis annotation, defaults to <code>cex.axis</code>-parameter </p>
</td></tr>
<tr><td><code id="IAPlot_+3A_cex.yax">cex.yax</code></td>
<td>
<p> size of y-axis annotation, defaults to cex.xax </p>
</td></tr>
<tr><td><code id="IAPlot_+3A_mgp.ylab">mgp.ylab</code></td>
<td>
<p>horizontal placement of label of vertical axis in <code>MEPlot</code></p>
</td></tr>
<tr><td><code id="IAPlot_+3A_cex.title">cex.title</code></td>
<td>
<p>multiplier for size of overall title 
(cex.main is multiplied with this factor) </p>
</td></tr> 
<tr><td><code id="IAPlot_+3A_cex.main">cex.main</code></td>
<td>
<p> size of individual plot titles in <code>MEPlot</code> </p>
</td></tr> 
<tr><td><code id="IAPlot_+3A_cex.lab">cex.lab</code></td>
<td>
<p> Size of variable names in diagonal panels of interaction plots
produced by <code>IAPlot</code>.</p>
</td></tr>
<tr><td><code id="IAPlot_+3A_cex">cex</code></td>
<td>
<p> size of plot symbols in interaction plots </p>
</td></tr>
<tr><td><code id="IAPlot_+3A_lwd">lwd</code></td>
<td>
<p> line width for plot lines and axes </p>
</td></tr>
<tr><td><code id="IAPlot_+3A_las">las</code></td>
<td>
<p> orientation for tick mark labels (<code>las=1</code> is recommended) </p>
</td></tr>
<tr><td><code id="IAPlot_+3A_abbrev">abbrev</code></td>
<td>
<p> number of characters shown for factor levels </p>
</td></tr>
<tr><td><code id="IAPlot_+3A_select">select</code></td>
<td>
<p> vector with position numbers of the main effects to be displayed; <br />
default: all main effects; the default implies the full interaction plot matrix 
for <code>IAPlot</code>.<br />
For <code>IAPlot</code>, the full interaction plot matrix for the selected 
factors is displayed. Of course, at least two factors must be selected. 
Furthermore, the linear model <code>obj</code> must at least contain one 
interaction term among the selected variables. 
For interactions that do not occur in the linear model, not plot is shown.
An interaction plot matrix of data means can be obtained by 
specifying the model with all possible 2-factor interactions (e.g. formula 
<code>y~(.)^2</code> for a regular 2-level fractional factorial, for which 
<code>y</code> is the only response and all other variables are 2-level factors).
</p>
</td></tr>
<tr><td><code id="IAPlot_+3A_show.alias">show.alias</code></td>
<td>
<p> if TRUE, the interaction plot shows the number 
of the list entry from aliases(obj) (cf. <code><a href="#topic+aliases">aliases</a></code>) in order to support immediate 
diagnosis of which depicted interaction may be due to other 
than the shown effect because of aliasing;<br />
CAUTION: if the <code>select</code> option is used, 
the model is reduced to the selected factors, i.e. aliases with 
unselected factors are not shown!</p>
</td></tr>
<tr><td><code id="IAPlot_+3A_i">i</code></td>
<td>
<p>integer, for internal use only</p>
</td></tr>
<tr><td><code id="IAPlot_+3A_j">j</code></td>
<td>
<p>integer, for internal use only</p>
</td></tr>
<tr><td><code id="IAPlot_+3A_mat">mat</code></td>
<td>
<p>matrix, for internal use only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For functions <code>MEPlot</code> or <code>IAPlot</code>, 
if <code>obj</code> is a design with at least one response variable 
rather than a linear model fit, 
the <code>lm</code>-method for class <code>design</code> is applied to it with the 
required degree (1 or 2), 
and the default method for the respective function is afterwards applied to the 
resulting linear model.<br /> 
If the design contains a block factor, the plot functions show non-block effects only. 
</p>

<dl>
<dt>MEPlot</dt><dd><p>produces plots of all treatment main effects in the model, 
or selected ones if <code>select</code> is specified</p>
</dd>
<dt>IAPlot</dt><dd><p>produces plots of all treatment interaction effects in the model,
or selected ones if <code>select</code> is specified</p>
</dd>
<dt>intfind</dt><dd><p>is an internal function not directly useful for users</p>
</dd>
<dt>check</dt><dd><p>is an internal function for checking whether the model complies 
with assumptions (fractional factorial of 2-level factors 
with full or no aliasing, not partial aliasing; 
this implies that Plackett-Burman designs with partial aliasing 
of 2-factor interactions give an OK (=TRUE) in <code>check</code> for 
pure main effects models only.)</p>
</dd>
<dt>remodel</dt><dd><p>is an internal function that redoes factor values into -1 and 1 
coding, regardless of the contrasts that have been used for the 
original factors;
numerical data are transformed by subtracting the mean and dividing 
by half the range (max-min), which also transforms them to -1 and 1 
coding in the 2-level case (and leads to an error otherwise)</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>MEPlot</code> and <code>IAPlot</code> invisibly return the plotted effects (two-row 
matrix or four-row matrix, respectively). If <code>show.alias=TRUE</code>, 
the matrix returned by IAPlot has as the attribute <code>aliasgroups</code>,
which contains all alias groups (list element number corresponds to 
number in the graphics tableau).
</p>
<p>The internal function <code>check</code> is used within other functions for checking 
whether the model is a fractional factorial with 2-level factors and 
no partial aliasing, as requested for the package to work.  
It is applied to remodeled objects only and returns a logical.  
If the returned value is FALSE, the calling function fails. 
</p>
<p>The internal function <code>intfind</code> returns an integer (length 1 or 0). 
It is not useful for users.
</p>
<p>The internal function <code>remodel</code> is applied to a linear model object and 
returns a list of two components:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>is the redone model with x-variables recoded to numeric 
-1 and 1 notation and aov objects made into &ldquo;pure&rdquo; lm objects</p>
</td></tr>
<tr><td><code>labs</code></td>
<td>
<p>is a list preserving the level information from original factors
(levels are minus and plus for numerical variables)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Box G. E. P, Hunter, W. C. and Hunter, J. S. (2005)
<em>Statistics for Experimenters, 2nd edition</em>.
New York: Wiley.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+FrF2-package">FrF2-package</a></code> for examples </p>

<hr>
<h2 id='makecatlg'> Function for creating a class catlg catalogue from a vector of generators </h2><span id='topic+makecatlg'></span>

<h3>Description</h3>

<p>creates a class catlg catalogue with a single element for use in functions 
colpick or FrF2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makecatlg(k, gen) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makecatlg_+3A_k">k</code></td>
<td>
<p> number of base factors spanning a full factorial with the desired number of runs </p>
</td></tr>
<tr><td><code id="makecatlg_+3A_gen">gen</code></td>
<td>
<p> generators as a numeric vector of Yates column numbers </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If generators are available in a different format, they must be transformed to Yates column numbers. 
</p>
<p>For a character vector <code>genc</code> with elements like <code>ABC</code>, <code>ADE</code>, etc., 
a code for obtaining Yates columns with order preserved is
<code>sapply(1:length(genc), function(obj) which(names(Yates)==genc[obj]))</code> 
(a solution with <code>which</code> applied to the entire vector at once does not preserve the order).
</p>
<p>Yet different formats like <code>123</code>, <code>145</code>, etc., can e.g. 
be preprocessed by picking the suitable elements from <code><a href="DoE.base.html#topic+Letters">Letters</a></code>, e.g. 
<code>paste(Letters[as.numeric(unlist(strsplit("123","")))],collapse="")</code>.
</p>


<h3>Value</h3>

<p>The function returns a list of class <code>catlg</code> with a single element.
</p>


<h3>Note</h3>

<p> This package is still under development, but does already provide useful and well-tested results.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+FrF2">FrF2</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Xu's fraction 13-5.2
genXu &lt;- c(127, 143, 179, 85, 150)
catXu &lt;- makecatlg(k=8, genXu)
colpick(catXu, q=2) ## Godolphin blocking into blocks of size 4 yields 56 clear 2fis
FrF2(256, 13, blocks=64, alias.block.2fis=TRUE, select.catlg=catXu)
</code></pre>

<hr>
<h2 id='pb'> Function to generate non-regular fractional factorial screening designs </h2><span id='topic+pb'></span><span id='topic+pb.list'></span>

<h3>Description</h3>

<p>The function generates Plackett-Burman designs and in some cases other screening 
designs in run numbers that are a multiple of 4. These designs are particularly suitable for screening a 
large number of factors, since interactions are not fully aliased with one main effect each 
but partially aliased. (The design in 8 runs is an exception from this rule.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pb(nruns, nfactors = nruns - 1, factor.names = if (nfactors &lt;= 50) 
     Letters[1:nfactors] else paste("F", 1:nfactors, sep = ""), 
     default.levels = c(-1, 1), ncenter=0, center.distribute=NULL, 
     boxtyssedal = TRUE, n12.taguchi = FALSE, 
     replications = 1, repeat.only = FALSE, 
     randomize = TRUE, seed = NULL, oldver = FALSE, ...)

pb.list
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pb_+3A_nruns">nruns</code></td>
<td>
<p> number of runs, must be a multiple of 4 </p>
</td></tr>
<tr><td><code id="pb_+3A_nfactors">nfactors</code></td>
<td>
<p> number of factors, default is nruns - 1, 
and it is recommended to retain this default.<br /> 
It is possible to specify factor names for fewer factors, 
and the remaining columns will be named <code>e1</code>, <code>e2</code>, ... 
They are useful for representing error in effects plots 
(so-called dummy factors). </p>
</td></tr>
<tr><td><code id="pb_+3A_factor.names">factor.names</code></td>
<td>
<p> a character vector of factor names (length up to nfactors) 
or a list with <code>nfactors</code> elements;<br /> 
if the list is named, list names represent factor names, otherwise default factor names are used;<br /> 
the elements of the list are <br />
EITHER vectors of length 2 with factor levels for the respective factor<br />
OR empty strings. 
For each factor with an empty string in factor.names, the levels given in 
<code>default.levels</code> are used;<br />
Default factor names are the first elements of the character vector <code><a href="DoE.base.html#topic+utilities">Letters</a></code>, 
or the factors position numbers preceded by capital F in case of more than 50 factors. </p>
</td></tr>
<tr><td><code id="pb_+3A_default.levels">default.levels</code></td>
<td>
<p> default levels (vector of length 2) for all factors for which no specific levels are given </p>
</td></tr>
<tr><td><code id="pb_+3A_ncenter">ncenter</code></td>
<td>
<p> number of center points; <code>ncenter &gt; 0</code> 
is permitted, if all factors are quantitative </p>
</td></tr>
<tr><td><code id="pb_+3A_center.distribute">center.distribute</code></td>
<td>
<p> the number of positions over which the center points 
are to be distributed ; if NULL (default), center points are 
distributed over end, beginning, and middle (in that order, if there are fewer than three center points) 
for randomized designs, and appended to the end for non-randomized designs. 
for more detail, see function <code><a href="#topic+add.center">add.center</a></code>, which does the work.
</p>
</td></tr>
<tr><td><code id="pb_+3A_boxtyssedal">boxtyssedal</code></td>
<td>
<p> logical, relevant only for nruns=16. 
If FALSE, the geometric (=standard) 16 run plan is used. 
If TRUE, the proposal by Box and Tyssedal is used instead, which has the advantage (for screening) of aliasing each interaction with several main effects, like the other Plackett-Burman designs. </p>
</td></tr>
<tr><td><code id="pb_+3A_n12.taguchi">n12.taguchi</code></td>
<td>
<p> logical, relevant only for nruns=12. If TRUE, the 12 run design is given in Taguchi order. </p>
</td></tr>
<tr><td><code id="pb_+3A_replications">replications</code></td>
<td>
<p> positive integer number. Default 1 (i.e. each row just once). 
If larger, each design run is executed replication times. 
If <code>repeat.only</code>, repeated measurements 
are carried out directly in sequence, i.e. no true replication takes place, 
and all the repeat runs are conducted together. It is likely that the error 
variation generated by such a procedure will be too small, so that average values 
should be analyzed for an unreplicated design. 
</p>
<p>Otherwise (default), the full experiment is first carried out once, then 
for the second replication and so forth. In case of randomization, 
each such blocks is randomized separately. In this case, replication variance is 
more likely suitable for usage as error variance 
(unless e.g. the same parts are used for replication runs although build 
variation is important). </p>
</td></tr>
<tr><td><code id="pb_+3A_repeat.only">repeat.only</code></td>
<td>
<p> logical, relevant only if replications &gt; 1. If TRUE, 
replications of each run are grouped together 
(repeated measurement rather than true replication). The default is 
<code>repeat.only=FALSE</code>, i.e. the complete experiment 
is conducted in <code>replications</code> blocks, and each run occurs in each block. </p>
</td></tr>
<tr><td><code id="pb_+3A_randomize">randomize</code></td>
<td>
<p> logical. If TRUE, the design is randomized. This is the default. </p>
</td></tr>
<tr><td><code id="pb_+3A_seed">seed</code></td>
<td>
<p> optional seed for the randomization process <br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>pb</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="DoE.base.html#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
<tr><td><code id="pb_+3A_oldver">oldver</code></td>
<td>
<p> logical. If <code>TRUE</code>, the column ordering from 
package versions 1.0-5 to 1.2.10 is used. This affects designs in 
40, 52, 56, 64, 76, 92, 96 and 100 runs. 
Usually, option <code>oldver</code> should not be set to is useful for reproducing an 
old design, or for making a design in 40, 56, 64, 88 or 96 runs with 
exactly half the number of factors resolution IV.
</p>
</td></tr>
<tr><td><code id="pb_+3A_...">...</code></td>
<td>
<p> currently not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pb</code> stands for Plackett-Burman. Plackett-Burman designs (Plackett and Burman 1946) are generally 
used for screening many variables in relatively few runs, when interest is in 
main effects only, at least initially. Different from the regular 
fractional factorial designs created by function <code><a href="#topic+FrF2">FrF2</a></code>, they 
do not perfectly confound interaction terms with main effects but distribute 
interaction effects over several main effects. The designs with number of runs 
a power of 2 are an exception to this rule: they are just the resolution III 
regular fractional factorial designs and are as such not very suitable for 
screening because of a high risk of very biased estimates for the main effects 
of the factors. Where possible, these are therefore replaced by different designs (cf. below).
</p>
<p>For most run numbers, function <code>pb</code> uses Plackett-Burman designs, 
and simply fills columns from left to right. 
The generating rows for these designs can be found in the list <code>pb.list</code> 
(a 0 entry indicates that the design is constructed by a different method, e.g. doubling).
</p>
<p>For 12 runs, the isomorphic design by Taguchi can be requested. 
For 16 runs, the default is to use the designs suggested by Box and Tyssedal (2001), 
which up to 14 factors do not suffer from perfect aliasing. 
For 32 runs, a cyclic design with generating row given in Samset and Tyssedal (1999) is used. 
For 64 runs, the 32 run design is doubled.
For 92 runs, a design is constructed according to the Williamson construction with matrices A, B, C and D from Hedayat and Stufken (1999), p. 160. 
</p>
<p>Designs up to 100~runs are covered. 
</p>
<p>Usage of the 8 run design for more than 4 factors is discouraged, 
as it completely aliases main effects with individual two-factor interactions. 
It is recommended to use at least the 12 run design instead for screening more than 4 factors. 
</p>


<h3>Value</h3>

<p>Value is a data frame of S3 class <code><a href="DoE.base.html#topic+class-design">design</a></code> 
and has attached attributes that can be accessed 
by functions <code><a href="DoE.base.html#topic+class-design-methods">desnum</a></code>, 
<code><a href="DoE.base.html#topic+class-design-methods">run.order</a></code> and 
<code><a href="DoE.base.html#topic+class-design-methods">design.info</a></code>. 
</p>
<p>The data frame itself contains the design with levels coded as requested. 
If no center points have been requested, the design columns are factors with 
contrasts <code>-1</code> and <code>+1</code> (cf. also <code><a href="DoE.base.html#topic+contr.FrF2">contr.FrF2</a></code>); in case 
of center points, the design columns are numeric.
</p>
<p>The following attributes are attached to it:
</p>
<table>
<tr><td><code>desnum</code></td>
<td>
<p>Design matrix in -1/1 coding</p>
</td></tr>
<tr><td><code>run.order</code></td>
<td>
<p>three column data frame, first column contains the run number in 
standard order, second column the run number as randomized, third column the 
run number with replication number as postfix;
useful for switching back and forth between actual and standard run 
number</p>
</td></tr>
<tr><td><code>design.info</code></td>
<td>
<p>list with entries   
</p>

<dl>
<dt>type </dt><dd><p> character string &ldquo;pb&rdquo;, except for 8~runs with up to 
4~factors, for which a type &ldquo;FrF2&rdquo; design is output</p>
</dd>
<dt>nruns </dt><dd><p> number of runs (replications are not counted) </p>
</dd>
<dt>nfactors </dt><dd><p> number of factors</p>
</dd>
<dt>factor.names </dt><dd><p> list named with (treatment) factor names and containing as 
entries vectors of length two each with coded factor levels </p>
</dd>
<dt>ndummies </dt><dd><p> number of dummy factors for error </p>
</dd>
<dt>replication </dt><dd><p> option setting in call to <code>pb</code> </p>
</dd>
<dt>repeat.only </dt><dd><p> option setting in call to <code>pb</code> </p>
</dd>
<dt>randomize </dt><dd><p> option setting in call to <code>pb</code> </p>
</dd>
<dt>seed </dt><dd><p> option setting in call to <code>pb</code> </p>
</dd>
<dt>creator </dt><dd><p> call to function pb 
(or stored menu settings, if the function has been called via the R commander plugin 
<span class="pkg">RcmdrPlugin.DoE</span>) </p>
</dd>
</dl>

</td></tr>
</table>


<h3>Warning</h3>

<p>With version 1.0-5 of package <span class="pkg">FrF2</span>, 
design generation for the designs based on doubling has changed (internal function 
<code>double.des</code>). This affected designs for 40,56,64,88,96 runs. 
With version 1.3 of package <span class="pkg">FrF2</span>, this and further behaviors (52, 76) has changed 
again, in the interest of improving generalized resolution of desigs produced by function <code>pb</code>. 
</p>
<p>For the affected run sizes, package versions from 1.0-5 onwards 
cannot exactly reproduce pb designs that have been created with a version before 
1.0-5. Package versions from 1.3 onwards reproduce the behavior of versions 1.0-5 to 1.2-10 
through option <code>oldver</code>.</p>


<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For reproducing a randomized design that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Box, G.E.P. and Tyssedal, J. (2001) Sixteen Run Designs of High Projectivity for Factor Screening. 
<em>Communications in Statistics - Simulation and Computation</em> <b>30</b>, 217-228. 
</p>
<p>Hedayat, A.S., Sloane, N.J.A. and Stufken, J. (1999) <em>Orthogonal Arrays: Theory and Applications</em>, Springer, New York. 
</p>
<p>Groemping, U. (2014). R Package FrF2 for Creating and Analyzing Fractional 
Factorial 2-Level Designs. <em>Journal of Statistical Software</em>, <b>56</b>, 
Issue 1, 1-56. <a href="https://www.jstatsoft.org/v56/i01/">https://www.jstatsoft.org/v56/i01/</a>.
</p>
<p>Mee, R. (2009). <em>A Comprehensive Guide to Factorial Two-Level Experimentation</em>. 
New York: Springer.
</p>
<p>Plackett, R.L.; Burman, J.P. (1946) The design of optimum multifactorial experiments. <em>Biometrika</em> <b>33</b>, 305-325.
</p>
<p>Samset, O.; Tyssedal, J. (1999) Two-level designs with good projection properties. <em>Technical Report 12, 
Department of Mathematical Sciences, The Norwegian University of Science and Technology, Norway</em>.  
</p>
<p>Williamson, J. (1946) Determinants whose elements are 0 and 1. <em>American Mathematical Monthly</em> <b>53</b>, 427-434.
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+FrF2">FrF2</a></code> for regular fractional factorial designs, 
<code><a href="DoE.base.html#topic+generalized.word.length">generalized.word.length</a></code> for functions <code><a href="DoE.base.html#topic+length3">length3</a></code> 
and <code><a href="DoE.base.html#topic+length4">length4</a></code> used in examples</p>


<h3>Examples</h3>

<pre><code class='language-R'>   pb(12,randomize=FALSE)
   pb(12,randomize=FALSE,n12.taguchi=TRUE)
   pb(20,seed=29869)
   pb(16,factor.names=list(A="",B="",C="",D=c("min","max"),
          E="",F="",G="",H="",J=c("new","old")))
   pb(8,default.levels=c("current","new"))
   test &lt;- pb(40) ## design created by doubling the 20 run design
   pb(12, ncenter=6) ## 6 center points with default placement
   
   ## Not run: 
   ## note: designs in 40, 56, 64, 88, and 96 runs are resolution IV,
   ## if the number of factors is up to nruns/2 - 1, e.g.:
   plan1 &lt;- pb(40, 19)
   length3(plan1)  ## 0 generalized words of length 3
   length4(plan1)  ## 228 generalized words of length 4
   ## they can be made resolution IV by oldver=TRUE for 
   ## nfactors=nruns/2, e.g.:
   plan2 &lt;- pb(40, 20)
   plan3 &lt;- pb(40, 20, oldver=TRUE)
   length3(plan2)  ## 9 generalized words of length 3
   length3(plan3)  ## 0 generalized words of length 3
   length4(plan3)  ## 285 generalized words of length 4
   
   ## note: designs in 52, 76, and 100 runs are almost resolution IV,
   ## if the number of factors is up to nruns/2 - 1, e.g.:
   plan4 &lt;- pb(52, 25)
   GR(plan4)       ## generalized resolution 3.92
   
   ## note: versions &gt;1.3 avoid complete and heavy aliasing of triples of factors 
   ## for up to nruns-2 factors for 40, 52, 56, 64, 76, 88, 92 and 96 runs
   ## (the same for 100 runs, which were not implemented before version 1.3)
   plan5 &lt;- pb(40, 38)
   plan6 &lt;- pb(40, 38, oldver=TRUE)
   GR(plan5)       ## generalized resolution 3.4
   GR(plan6)       ## generalized resolution 3
   plan7 &lt;- pb(52, 50)
   plan8 &lt;- pb(52, 50, oldver=TRUE)
   GR(plan7)       ## generalized resolution 3.62
   GR(plan8)       ## generalized resolution 3.15
   
## End(Not run)
   </code></pre>

<hr>
<h2 id='splitplot'> Statistical and algorithmic aspects of split-plot designs in FrF2 </h2><span id='topic+splitplot'></span>

<h3>Description</h3>

<p>This help page documents the statistical and algorithmic details of split-plot designs in FrF2
</p>


<h3>Details</h3>

<p>A split-plot design is similar to a <code><a href="#topic+block">block</a></code>ed design, with the difference that 
there are also factors of interest that can be only changed on block level (so-called whole 
plot factors). The blocks are called &ldquo;plots&rdquo; in the context of split-plot designs. 
The factors that can (and should!) be varied within a plot are called split-plot factors. 
Note that the experiment provides more information on split-plot factors than on whole-plot factors.
</p>
<p><em>Warning:</em> In terms of analysis, split-plot designs would have to be treated by advanced random effects models, 
but often are not. At the very least, the user must be aware that all whole-plot effects (i.e. effects 
on columns that only change between plots) are (likely to be) more variable than split-plot effects so that 
e.g. it does not necessarily mean anything if they stick out in a normal or half-normal effects plot. 
</p>
<p>Designs for hard-to-change factors are also treated by the split-plot approach in function <code>FrF2</code>, 
although they are not quite split-plot designs: The are non-randomized split-plot designs arranged in an order 
such that the first whole-plot factors have as few as possible changes. This gives very poor information on 
these first whole-plot factors (which in the extreme are only changed once or twice), 
if there is variability involved with setting the factor levels. <br />
If hard-to-change factors can be implemented as true whole-plot factors with randomization, this is by far preferrable from a statistical 
point of view (but may nevertheless be rejected from a feasibility point of view, as the necessary changes may seem unaffordable). 
</p>
<p>For design generation, there are two principal ways to handle split-plot designs, manual definition 
(i.e. the user specifies exactly which columns are to be used for which purpose) and automatic 
definition. Each situation has its specifics. These are detailed below. For users with 
not so much mathematical/statistical background, it will often be best to use the automatic way, 
specifying the treatement factors of interest via <code>nfactors</code> or <code>factor.names</code> 
and a single number for <code>WPs</code>. 
Users with more mathematical background may want to use the manual definitions, perhaps 
in conjunction with published catalogues of good split-plot designs, or 
after inspecting possibilities with function <code><a href="#topic+splitpick">splitpick</a></code>.
</p>

<dl>
<dt>Manual definition of split-plot designs</dt><dd>
<p>The user can specify a design with the <code>design</code> or the <code>generators</code> option 
and specify manually with the <code>WPfacs</code> option, which factors are whole plot factors 
(i.e. factors that do not change within a plot). 
The other factors become split-plot factors (i.e. factors that do change within a plot). 
If the user chooses this route, <code>WPfacs</code> must be character vectors of factor names, factor letters, 
factor numbers preceded by capital F, or a vector or list of factor position numbers (NOT: Yates column numbers). 
Caution: It is the users responsibility to ensure a 
good choice of split-plot design (e.g. by using a catalogued design from Huang, Chen and Voelkel 1998, 
Bingham and Sitter 2003, or Bingham Schoen and Sitter 2004).
In case of a user-mistake such that the resulting design is not a split-plot design with 
the alleged number of whole plots, an error is thrown.
</p>
</dd>
<dt>Automatic definition of split-plot designs</dt><dd>
<p>As mentioned above, split-plot designs differ from block designs by the fact that the block main 
effects are purely nuisance parameters which are assumed (based on prior knowledge) 
to be relevant but are not of interest, while the plots are structured by 
<code>nfac.WP</code> whole plot factors, which are of interest. 
The user has to decide on a number of whole plots (<code>WPs</code>) as well as 
the number of whole plot factors <code>nfac.WP</code>. 
If <code>log2(WPs) &lt;= nfac.WP &lt;= WPs-1</code>, it is obviously in principle possible to accomodate the 
desired number of whole plot factors in the desired number of whole plots. If <code>nfac.WP &gt; WPs/2</code>, 
the base design for the split-plot structure has to be of resolution III. Sometimes, 
subject matter considerations limit whole plot sizes, and there are only few interesting 
whole plot factors, i.e. <code>nfac.WP &lt; log2(WPs)</code>. 
In this case, it is of course nevertheless necessary to 
have a total of <code>log2(WPs)</code> whole plot <em>construction</em> factors; 
the missing <code>log2(WPs) - nfac.WP</code> factors are added 
to the design (names starting with <code>WP</code>), and <code>nfactors</code> is increased accordingly. 
</p>
<p>In all cases, the first <code>nfac.WPs</code> user-specified factors are treated as whole plot factors, the 
remaining factors as split-plot factors. 
</p>
<p>From there, function <code><a href="#topic+FrF2">FrF2</a></code> proceeds like in the blocked situation by starting 
with the best design and working its way down to worse designs, if the best design cannot 
accomodate the desired split-plot structure. For each design, function <code><a href="#topic+FrF2">FrF2</a></code> 
calls function <code><a href="#topic+splitpick">splitpick</a></code>, which permutes base factors until 
the requested whole plot / split-plot structure is achieved, or until impossibility for 
this design with these base factors has been ascertained. In the latter case, function <code>FrF2</code> 
proceeds to the next best design and so forth. 
</p>
<p>If several competing split-plot designs based on the same base design are found, 
the best possible resolution among the first <code>check.WPs</code> such designs is chosen. 
No further criteria are automatically implemented, and no more than <code>check.WPs</code> 
designs are checked. If not satisfied with the structure of the whole plot portion of the experiment, 
increasing <code>check.WPs</code> vs. the default 10 may help. 
Expert users may want to inspect possibilities, 
using function <code><a href="#topic+splitpick">splitpick</a></code> directly.
</p>
<p>Note that the algorithm does not necessarily find an existing split-plot design. 
It has been checked out which catalogued designs it can find: designs for all catalogued situations 
from Bingham and Sitter (2003) have been found, as well as for most catalogued situations 
from Huang, Chen and Voelkel (1998). Occasionally, a better design than catalogued has been found, e.g. 
for 4 whole plot and 10 split plot factors in 32 runs with 16 whole plots, the design found by the algorithm 
is resolution IV, while Huang, Chen and Voelkel propose a resolution III design. 
The algorithm has the largest difficulties with extreme designs in the sense that a large number of 
whole plots with a small number of whole plot factors are to be accomodated; thus it does not find designs for 
the more extreme situations in Bingham, Schoen and Sitter (2004).
</p>
</dd>
</dl>
 
<p>Please contact me with any suggestions for improvements.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Bingham, D.R., Schoen, E.D. and Sitter, R.R. (2004). 
Designing Fractional Factorial Split-Plot Experiments with Few Whole-Plot Factors. 
<em>Applied Statistics</em> <b>53</b>, 325-339.
</p>
<p>Bingham, D. and Sitter, R.R. (2003). Fractional Factorial Split-Plot Designs
for Robust Parameter Experiments. <em>Technometrics</em> <b>45</b>, 80-89.
</p>
<p>Chen, J., Sun, D.X. and Wu, C.F.J. (1993) 
A catalogue of 2-level and 3-level orthogonal arrays. 
<em>International Statistical Review</em> <b>61</b>, 131-145. 
</p>
<p>Cheng, C.-S. and Tsai, P.-W. (2009). 
Optimal two-level regular fractional factorial block and split-plot designs. 
<em>Biometrika</em> <b>96</b>, 83-93.
</p>
<p>Huang, P., Chen, D. and Voelkel, J.O. (1998). Minimum-Aberration Two-Level Split-Plot Designs. 
<em>Technometrics</em> <b>40</b>, 314-326. 
</p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+FrF2">FrF2</a></code> for regular fractional factorials, 
<code><a href="#topic+catlg">catlg</a></code> for the Chen, Sun, Wu catalogue of designs 
and some accessor functions, 
and <code><a href="#topic+block">block</a></code> for the statistical aspects of blocked designs.</p>


<h3>Examples</h3>

<pre><code class='language-R'>########## hard to change factors ####################
## example from Bingham and Sitter Technometrics 19999
## MotorSpeed, FeedMode,FeedSizing,MaterialType are hard to change
BS.ex &lt;- FrF2(16,7,hard=4,
     factor.names=c("MotorSpeed", "FeedMode","FeedSizing","MaterialType",
                  "Gain","ScreenAngle","ScreenVibLevel"), 
     default.levels=c("-","+"))
design.info(BS.ex)
BS.ex
## NOTE: the design has 8 whole plots.
## The first hard-to-change factors have very few changes only 
## between whole plots. 
## A conscious and honest decision is required whether it is 
##    acceptable for the situation at hand not to reset them!
## A proper split-plot design with resetting all whole plot factors 
## for each whole plot would be strongly preferred from a 
## statistical point of view. 

########## automatic generation for split plot ##########
## 3 control factors, 5 noise factors, control factors are whole plot factors
## 8 plots desired in a total of 32 runs
## Bingham Sitter 2003
BS.ex2a &lt;- FrF2(32, 8, WPs=8, nfac.WP=3, 
      factor.names=c(paste("C",1:3,sep=""), paste("N",1:5,sep="")),randomize=TRUE)

## manual generation of this same design
BS.ex2m &lt;- FrF2(32, 8, generators=c("ABD","ACD","BCDE"),WPs=8, WPfacs=c("C1","C2","C3"), nfac.WP=3, 
      factor.names=c(paste("C",1:3,sep=""),paste("N",1:5,sep="")),randomize=TRUE)

## design with few whole plot factors
## 2 whole plot factors, 7 split plot factors
## 8 whole plots, i.e. one extra WP factor needed
BSS.cheese.exa &lt;- FrF2(32, 9, WPs=8, nfac.WP=2, 
      factor.names=c("A","B","p","q","r","s","t","u","v"))
design.info(BSS.cheese.exa)
## manual generation of the design used by Bingham, Schoen and Sitter
## note that the generators include a generator for the 10th spplitting factor
    ## s= ABq, t = Apq, u = ABpr and v = Aqr, splitting factor rho=Apqr
BSS.cheese.exm &lt;- FrF2(32, gen=list(c(1,2,4),c(1,3,4),c(1,2,3,5),c(1,4,5),c(1,3,4,5)), 
      WPs=8, nfac.WP=3, WPfacs=c(1,2,10),
      factor.names=c("A","B","p","q","r","s","t","u","v","rho"))
design.info(BSS.cheese.exm)
</code></pre>

<hr>
<h2 id='StructurePickers'> Functions to find split-plot or left-adjusted designs </h2><span id='topic+splitpick'></span><span id='topic+leftadjust'></span>

<h3>Description</h3>

<p>Functions to restructure a fractional factorial by permuting the base factors 
such that the leftmost base factors have a suitable alias structure for the 
problem at hand; meant for expert users
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitpick(k, gen, k.WP, nfac.WP, show=10)
leftadjust(k, gen, early=NULL, show=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StructurePickers_+3A_k">k</code></td>
<td>
<p> the number of base factors (designs have <code>2^k</code> runs) </p>
</td></tr>
<tr><td><code id="StructurePickers_+3A_gen">gen</code></td>
<td>
<p> vector of generating columns from Yates matrix </p>
</td></tr>
<tr><td><code id="StructurePickers_+3A_k.wp">k.WP</code></td>
<td>
<p> integer number of base factors used for whole plot generation; 
there will be <code>2^k.WP</code> plots in the design</p>
</td></tr>
<tr><td><code id="StructurePickers_+3A_nfac.wp">nfac.WP</code></td>
<td>
<p> integer number of whole plot factors, must not be smaller than <code>k.WP</code>;
the other <code>k + length(gen)</code> factors are split-plot factors, i.e. 
they change within plots </p>
</td></tr>
<tr><td><code id="StructurePickers_+3A_show">show</code></td>
<td>
<p> numeric integer indicating how many results are to be shown;
for function <code>splitpick</code>, this number also determines how many designs 
are investigated;
the other two functions investigate all designs and show the best results only </p>
</td></tr>
<tr><td><code id="StructurePickers_+3A_early">early</code></td>
<td>
<p> number that indicates how many &ldquo;leftmost&rdquo; factors are 
needed in the design; used by <code>FrF2</code> for accomodating hard-to-change 
factors </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions exploit the fact that a factorial design can be arranged such 
that the <code>2^k.WP-1</code> leftmost columns have exactly <code>2^k.WP</code> 
different patterns. They can thus accomodate whole plot effects if <code>2^k.WP</code> 
plots are available; also, with a specially rearranged version of the Yates matrix, 
the leftmost columns can have particularly few or particularly many level changes, 
cf. e.g. Cheng, Martin and Tang 1998.
</p>
<p>By permuting the <code>k</code> base factors , the functions try to find <code>2^k.WP</code> 
ones that accomodate the current needs, if taken as the first base factors. They are 
used by function <code>FrF2</code>, if a user requests an automatically-generated 
split-plot design or a design with some factors declared hard-to-change.
</p>
<p>There may be a possibility to better accomodate the experimenters needs within 
a given design by trying different sets of base factors. This is not done 
in these functions. Also, custom user needs may be better fulfilled, if an expert 
user directly uses one of these functions for inspecting the possibilities, rather 
than relying on the automatic selection routine in function <code>FrF2</code>. 
</p>


<h3>Value</h3>

<p>Both functions output a list of entries with information on at most <code>show</code> suitable 
permutations. <code>splitpick</code> ends with an error, if no suitable 
solution can be found.
</p>
<table>
<tr><td><code>orig</code></td>
<td>
<p>original generator column numbers</p>
</td></tr>
<tr><td><code>basics</code></td>
<td>
<p>named vector with the following entries: <br />
for function <code>splitpick</code>, 
entries are the number of runs, the number of plots, the
number of whole plot factors and the number of split-plot factors <br />
for function <code>leftadjust</code>, 
entries are the number of runs, the number of factors, 
and - if <code>early</code> is not NULL - the entry for <code>early</code> </p>
</td></tr>
<tr><td><code>perms</code></td>
<td>
<p>matrix with rows containing permutations of base factors</p>
</td></tr>
<tr><td><code>res.WP</code></td>
<td>
<p>for <code>splitpick</code> only; <br /> 
vector of resolutions for the respective rows of perms</p>
</td></tr>
<tr><td><code>maxpos</code></td>
<td>
<p>for <code>leftadjust</code> only; <br /> 
vector of maximum positions for the <code>early</code> leftmost factors for the respective rows of perms</p>
</td></tr>
<tr><td><code>k.early</code></td>
<td>
<p>for <code>leftadjust</code> only; <br /> 
vector of numbers of base factors needed for spanning the <code>early</code> leftmost factors for the respective rows of perms</p>
</td></tr>
<tr><td><code>gen</code></td>
<td>
<p>matrix the rows of which contain the generator columns 
for the respective rows of perms</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Cheng, C.-S., Martin, R.J., and Tang, B. (1998). 
Two-level factorial designs with extreme numbers of level changes. <em>Annals of Statistics</em> 
<b>26</b>, 1522-1539.
</p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+FrF2">FrF2</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>## leftadjusting MA design from table 6.22 in BHH2, 9 factors, 32 runs
## NOTE: nevertheless not as well left-adjusted as the isomorphic design 9-4.1 from catlg
leftadjust(5,c(30,29,27,23))
## with option early=4 (i.e. 4 columns as early as possible are requested)
leftadjust(5,c(30,29,27,23),early=4)
leftadjust(5,catlg$'9-4.1'$gen,early=4)

## look for a split plot design in 32 runs with 7 factors, 
##       3 of which are whole plot factors, 
##       and 8 plots
splitpick(5,catlg$'7-2.1'$gen,nfac.WP=3,k.WP=3)
</code></pre>

<hr>
<h2 id='utilities.blocksplitplot.aliases.shortrep'> Utility functions for short representation of block and splitplot generators </h2><span id='topic+recalc.alias.block'></span><span id='topic+recalc.alias.block.new'></span><span id='topic+struc.aliased'></span><span id='topic+struc.aliased.new'></span><span id='topic+blockfull'></span>

<h3>Description</h3>

<p>Utility functions for short representation of block and splitplot generators, 
not intended for direct use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recalc.alias.block(dia, leg)
recalc.alias.block.new(dia, leg)
struc.aliased(struc, nk, order)
struc.aliased.new(struc, nk, order) 
blockfull(block.gen, k, des.gen = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilities.blocksplitplot.aliases.shortrep_+3A_dia">dia</code></td>
<td>
<p> a list of alias information from function aliases </p>
</td></tr>
<tr><td><code id="utilities.blocksplitplot.aliases.shortrep_+3A_leg">leg</code></td>
<td>
<p> a character vector of legend entries shaped as <code>A=name1</code> or <code>F1=name1</code>, 
depending on whether there are up to 50 factors or more</p>
</td></tr>
<tr><td><code id="utilities.blocksplitplot.aliases.shortrep_+3A_struc">struc</code></td>
<td>
<p> an output from function <code>recalc.alias.block</code> </p>
</td></tr>
<tr><td><code id="utilities.blocksplitplot.aliases.shortrep_+3A_nk">nk</code></td>
<td>
<p> number of factors (&lt;=50: Letters; &gt;50: F1, F2, ...) </p>
</td></tr>
<tr><td><code id="utilities.blocksplitplot.aliases.shortrep_+3A_order">order</code></td>
<td>
<p> 2 or 3 (aliasing order) </p>
</td></tr>
<tr><td><code id="utilities.blocksplitplot.aliases.shortrep_+3A_block.gen">block.gen</code></td>
<td>
<p> generators for <code>k.block</code> independent block columns;<br />
a list of vectors of design column numbers<br />
or a numeric vector of Yates column numbers<br />
or a vector of character strings like &quot;ABD&quot;, &quot;CF&quot; etc </p>
</td></tr>
<tr><td><code id="utilities.blocksplitplot.aliases.shortrep_+3A_k">k</code></td>
<td>
<p> number of base factors (i.e. design has <code class="reqn">2^k</code> runs) </p>
</td></tr>
<tr><td><code id="utilities.blocksplitplot.aliases.shortrep_+3A_des.gen">des.gen</code></td>
<td>
<p> generating columns for the design as Yates column numbers 
(including base columns)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions are not intended for direct use. 
</p>


<h3>Value</h3>

<p>The functions are not intended for direct use. 
Function <code>recalc.alias.block</code> outputs a character vector of alias relations, 
function <code>struc.aliased</code> structures these into a list with main effects, 
2fis and 3fis (the latter for <code>order=3</code> only). The functions with suffix <code>new</code> do the same thing for package version 2 in case of blocked designs (split plot functionality still uses the old ones).
</p>
<p><code>blockfull</code> supports reporting about aliasing with blocks.
</p>
<p>These functions are used by function <code>FrF2</code>.
</p>


<h3>Note</h3>

<p> This package is still under development regarding some of its aspects; 
especially internal functions cannot be relied upon to remain stable.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+FrF2-package">FrF2-package</a></code> </p>

<hr>
<h2 id='utilitiesCat'> ~~ Internal utility functions and a user-visible constant for working with regular fractional factorials ~~ </h2><span id='topic+slowfast'></span><span id='topic+mult.gen'></span><span id='topic+mult.gen.a'></span><span id='topic+words.all'></span><span id='topic+alias3fi'></span><span id='topic+gen.check'></span><span id='topic+estimable.check'></span><span id='topic+mapcalc'></span><span id='topic+mapcalc.distinct'></span><span id='topic+mapcalc.block'></span><span id='topic+map2design'></span><span id='topic+gen2clear.2fis'></span><span id='topic+formula2matrix'></span><span id='topic+char2num'></span><span id='topic+check.subisomorphic.special'></span><span id='topic+check.subisomorphic.matrix'></span><span id='topic+getNext'></span><span id='topic+estimable'></span><span id='topic+Yates'></span>

<h3>Description</h3>

<p>~~ Internal functions, mainly for deriving words, alias structures and so forth from catalogue information for regular 2-level fractional factorials. 
They need not be accessed for normal use of the package - some of them may be made user-usable for future versions of the package. 
</p>
<p>The constant Yates is user-visible, as it can be useful for expert users. ~~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slowfast(k) 
mult.gen(liste) 
mult.gen.a(string.vec,sep="")
words.all(k, gen, design = NULL, max.length=7, select.catlg = catlg)
alias3fi(k, gen, order = 3)
gen.check(k, gen)
estimable.check(estimable, nfac, factor.names)
estimable(estimable, nfac, nruns, clear=FALSE, res3=FALSE, max.time=60, 
            select.catlg=catlg, perm.start=1:nfac, perms=NULL, order = 3, 
            method="VF2", sort="natural", ignore.dom=FALSE)
mapcalc(estimable, nfac, nruns, res3=FALSE, select.catlg=catlg, 
            method="VF2", sort="natural", ignore.dom=FALSE)
mapcalc.block(estimable, nfac, clearcur, 
            method="VF2", sort="natural")
mapcalc.distinct(estimable, nfac, nruns, res3=FALSE, max.time=60, 
        select.catlg=catlg, perm.start=1:nfac, perms=NULL)
map2design(map, select.catlg=catlg)
gen2clear.2fis(k, gen)
formula2matrix(formula)
char2num(char)
check.subisomorphic.special(estimable, nfac, hilf2, hilf3=NULL, 
    res3=FALSE, max.time=60, 
    perm.start=1:nfac, begin_time=Sys.time(), name=NA)
check.subisomorphic.matrix(estimable, nfac, hilf2, hilf3=NULL, 
    res3=FALSE, max.time=60, 
    begin_time=Sys.time(), name=NA, perms=perms)
getNext(perm)
Yates
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilitiesCat_+3A_k">k</code></td>
<td>
<p> number of base factors spanning a full factorial with the desired number of runs (i.e. <code>log2(nruns)</code>) </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_liste">liste</code></td>
<td>
<p> list of words in terms of vectors of factor numbers to be combined into one new word </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_string.vec">string.vec</code></td>
<td>
<p> vector of words in terms of factor letter combinations (e.g. &ldquo;ABC&rdquo;) to be combined into one new word </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_sep">sep</code></td>
<td>
<p> character by which interaction terms are separated or concatenated; default is empty, i.e. ABC are separated into A, B and C; 
for more than 50~factors, a colon is needed so that F1:F2:F127 can be separated into F1, F2 and F127, for example.</p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_gen">gen</code></td>
<td>
<p> generators in any admissible format (<code>gen.check</code> transforms any admissible format to the default needed for calculations)) </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_design">design</code></td>
<td>
<p> character string that contains a name of a design from <code>select.catlg</code>, like in <code><a href="#topic+FrF2">FrF2</a></code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_max.length">max.length</code></td>
<td>
<p> the maximum word length to be calculated for the words list; in large design, choosing this to be 4 or 5 may substantially speed things up! </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_select.catlg">select.catlg</code></td>
<td>
<p> catalogue of fractional factorial 2-level designs of class <code>catlg</code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_order">order</code></td>
<td>
<p> 2 or 3, order of interactions to be shown </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_estimable">estimable</code></td>
<td>
<p> like in <code><a href="#topic+FrF2">FrF2</a></code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_nfac">nfac</code></td>
<td>
<p> number of factors, like <code>nfactors</code> in <code><a href="#topic+FrF2">FrF2</a></code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_factor.names">factor.names</code></td>
<td>
<p> a named list with <code>nfac</code> elements, 
for which the names represent factor names </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_nruns">nruns</code></td>
<td>
<p> like in <code><a href="#topic+FrF2">FrF2</a></code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_clear">clear</code></td>
<td>
<p> like in <code><a href="#topic+FrF2">FrF2</a></code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_res3">res3</code></td>
<td>
<p> like in <code><a href="#topic+FrF2">FrF2</a></code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_max.time">max.time</code></td>
<td>
<p> like in <code><a href="#topic+FrF2">FrF2</a></code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_perm.start">perm.start</code></td>
<td>
<p> like in <code><a href="#topic+FrF2">FrF2</a></code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_perms">perms</code></td>
<td>
<p> like in <code><a href="#topic+FrF2">FrF2</a></code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_method">method</code></td>
<td>
<p> like in <code><a href="#topic+FrF2">FrF2</a></code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_sort">sort</code></td>
<td>
<p> like in <code><a href="#topic+FrF2">FrF2</a></code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_ignore.dom">ignore.dom</code></td>
<td>
<p>per default (<code>ignore.dom=FALSE</code>), 
non-dominating elements of <code>select.catlg</code> will be removed before searching; 
set <code>ignore.dom</code> to TRUE to change that (needed for combination of blocking 
with estimable requirement)</p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_clearcur">clearcur</code></td>
<td>
<p>is the set of clear 2fis after removing aliases with the block factor</p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_map">map</code></td>
<td>
<p> map of experiment factors to design factors, used in <code>estimable</code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_formula">formula</code></td>
<td>
<p> formula to be translated into matrix for <code>estimable</code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_char">char</code></td>
<td>
<p> character vector to be translated into matrix for <code>estimable</code> </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_hilf2">hilf2</code></td>
<td>
<p> list of length four words </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_hilf3">hilf3</code></td>
<td>
<p> list of length three words, if there are any </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_begin_time">begin_time</code></td>
<td>
<p> timing option used for controlling overall run time, calculated </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_name">name</code></td>
<td>
<p> name of design in catalogue, used in case of max.time end for 
information where the stop occurred </p>
</td></tr>
<tr><td><code id="utilitiesCat_+3A_perm">perm</code></td>
<td>
<p> current permutation, of which <code>getNext</code> determines the 
next permutation in lexicographic order </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Yates</code> is a user-visible constant that is useful in design construction: 
</p>
<p><code>Yates</code> is a list of design column generators in Yates order (for 4096 runs), e.g. <code>Yates[1:8]</code> is identical to 
</p>
<p><code>list(1,2,c(1,2),3,c(1,3),c(2,3),c(1,2,3))</code>.
</p>


<h3>Value</h3>

<p><code>mult.gen</code> and <code>mult.gen.a</code> determine a new word as the product of the argument words (numeric vector or character string respectively), 
<code>words.all</code> calculates a word list object with word length pattern, the word list itself and a max.length entry, 
<code>alias3fi</code> calculates an alias pattern based on the structure of the design (less demanding than the word list approach.
</p>
<p><code>gen.check</code> produces a list of vectors with integers from 1 to k for denoting the generators, 
which may have come as a vector of factor letter combinations or a vector of column numbers in Yates order,
<code>estimable.check</code> determines a list including elements <code>estimable</code>, 
a 2-row-matrix indicating estimable 2fis from the permissible inputs, and <code>nfac</code>, 
the number of factors from input parameter <code>estimable</code>, 
function <code>estimable</code> calculates the appropriate design if certain effects have been requested to be estimable, and 
all subsequent functions are auxiliary functions to function <code>estimable</code>.
</p>
<p><code>Yates</code> is a user-visible constant (cf. details section). 
</p>


<h3>Note</h3>

<p> This package is still under development, but does already provide useful and well-tested results.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Hedayat, A.S., Sloane, N.J.A. and Stufken, J. (1999) <em>Orthogonal Arrays: Theory and Applications</em>, Springer, New York. 
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+FrF2">FrF2</a></code> </p>

<hr>
<h2 id='utilitiesPB'> ~~ Internal utility functions ~~ </h2><span id='topic+williamson'></span><span id='topic+double.des'></span><span id='topic+circ.mat'></span><span id='topic+normalize.col.first'></span><span id='topic+normalize.row.last'></span><span id='topic+des.recode'></span><span id='topic+taguchi'></span><span id='topic+boxtyssedal'></span>

<h3>Description</h3>

<p>Internal functions, mainly for calculation of Plackett-Burman and other non-regular screening designs. 
They need not be accessed for normal use of the package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ.mat(gen) 
double.des(des)
normalize.col.first(mat)
normalize.row.last(mat)
williamson(A,B,C,D)
taguchi(nruns)
boxtyssedal(nruns,k)
des.recode(var, recodes, as.factor.result, char)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilitiesPB_+3A_gen">gen</code></td>
<td>
<p> ~~Generating vector for circular design matrix (used in Plackett-Burman construction)</p>
</td></tr>
<tr><td><code id="utilitiesPB_+3A_des">des</code></td>
<td>
<p> ~~numeric design matrix (elements -1 / +1 ) to be doubled</p>
</td></tr>
<tr><td><code id="utilitiesPB_+3A_mat">mat</code></td>
<td>
<p> ~~numeric design matrix (elements -1 / +1 ) to be normalized </p>
</td></tr>
<tr><td><code id="utilitiesPB_+3A_a">A</code></td>
<td>
<p> ~~numeric square matrix (elements -1 / +1 ) to be combined with <code>B</code>, <code>C</code>, and <code>D</code> by Williamson construction. 
Although the function combines any square matrices of identical dimension, 
the matrices must observe a special structure to in order to yield a useful design matrix. </p>
</td></tr>
<tr><td><code id="utilitiesPB_+3A_b">B</code></td>
<td>
<p> ~~numeric square matrix (elements -1 / +1 ) with same dimensions as <code>A</code> </p>
</td></tr>
<tr><td><code id="utilitiesPB_+3A_c">C</code></td>
<td>
<p> ~~numeric square matrix (elements -1 / +1 ) with same dimensions as <code>A</code> </p>
</td></tr>
<tr><td><code id="utilitiesPB_+3A_d">D</code></td>
<td>
<p> ~~numeric square matrix (elements -1 / +1 ) with same dimensions as <code>A</code> </p>
</td></tr>
<tr><td><code id="utilitiesPB_+3A_nruns">nruns</code></td>
<td>
<p> number of runs; currently has to be 12 for <code>taguchi</code> and 16 for <code>boxtyssedal</code>. </p>
</td></tr>
<tr><td><code id="utilitiesPB_+3A_k">k</code></td>
<td>
<p> number of factors; for up to 12 factors, a different design is picked. For 15 factors, a warning against perfect aliasing (of the last columnn) is issued. </p>
</td></tr>
<tr><td><code id="utilitiesPB_+3A_var">var</code></td>
<td>
<p> variable </p>
</td></tr>
<tr><td><code id="utilitiesPB_+3A_recodes">recodes</code></td>
<td>
<p> character string specifying recodes, so far only used in the principal form &ldquo;-1=level[1];1=level[2]&rdquo; </p>
</td></tr>
<tr><td><code id="utilitiesPB_+3A_as.factor.result">as.factor.result</code></td>
<td>
<p> logical that specifies whether or not results are to be coerced to factor. 
The default is that factors are coerced to factor, while numeric variables with numeric recodes are kept numeric.</p>
</td></tr>
<tr><td><code id="utilitiesPB_+3A_char">char</code></td>
<td>
<p> logical: should replacement be treated as character string (TRUE) or evaluated? default is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>des.recode</code> has been adapted to the needs of this package from function <code>recode</code> of package <code>car</code>.
</p>


<h3>Value</h3>

<p>All functions return except <code>des.recode</code> return a numeric matrix, <code>circ.mat</code> a square matrix of dimension <code>length(gen)</code>, 
<code>double.des</code> a matrix with <code>2*nrow(des)</code> rows and <code>2*ncol(des)+1</code> columns (full foldover),
the <code>normalize...</code> functions a matrix of the same dimenensions as <code>mat</code>, 
and <code>williamson</code> a square matrix of dimension <code>4*nrow(A)</code>.
<code>taguchi</code> returns the Plackett-Burman array in 12 runs in Taguchi order (it is isomorphic to the standard version), and <code>boxtyssedal</code> returns the suitable version of the 16 run Hadamard matrix described by Box and Tyssedal, which is more appropriate for screening than the standard 16 run factorial.
</p>
<p><code>des.recode</code> returns a numeric vector or factor, depending on the type of var and the setting of <code>as.factor.result</code>. 
This function is identical to the function in package <span class="pkg"><a href="DoE.base.html#topic+DoE.base-package">DoE.base</a></span> and will eventually be deleted in package <span class="pkg">FrF2</span>.
</p>


<h3>Note</h3>

<p> This package is currently under intensive development. Substantial changes are to be expected in the near future.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Box, G.E.P. and Tyssedal, J. (2001) Sixteen Run Designs of High Projectivity for Factor Screening. 
<em>Communications in Statistics - Simulation and Computation</em> <b>30</b>, 217-228. 
</p>
<p>Hedayat, A.S., Sloane, N.J.A. and Stufken, J. (1999) <em>Orthogonal Arrays: Theory and Applications</em>, Springer, New York. 
</p>
<p>Plackett, R.L.; Burman, J.P. (1946) The design of optimum multifactorial experiments. <em>Biometrika</em> <b>33</b>, 305-325.
</p>
<p>Williamson, J. (1946) Determinants whose elements are 0 and 1. <em>American Mathematical Monthly</em> <b>53</b>, 427-434.
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+pb">pb</a></code> </p>

<hr>
<h2 id='utilitiesV'> ~~ Internal utility functions for generating regular fractional factorials ~~ </h2><span id='topic+revdigits'></span><span id='topic+indexcalc'></span><span id='topic+gencalc'></span><span id='topic+YatesFly'></span>

<h3>Description</h3>

<p>~~ Internal functions, mainly for generating designs without relying on a catalogue of designs ~~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revdigits(obj, ndigits = 1 + floor(log2(max(obj))))

indexcalc(obj, k = 1 + floor(log2(max(obj))))

gencalc(gen)

YatesFly(walshindex, k=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilitiesV_+3A_obj">obj</code></td>
<td>
<p> non-negative integer (vector) with Yates matrix column numbers 
(called Walsh indices by Sanchez and Sanchez 2005) </p>
</td></tr>
<tr><td><code id="utilitiesV_+3A_ndigits">ndigits</code></td>
<td>
<p> number of binary digits; default is the necessary number for the largest element of <code>obj</code> </p>
</td></tr>
<tr><td><code id="utilitiesV_+3A_k">k</code></td>
<td>
<p> number of base factors; default is the minimum necessary number for the maximum of <code>obj</code> </p>
</td></tr>
<tr><td><code id="utilitiesV_+3A_gen">gen</code></td>
<td>
<p> generators in any admissible format (<code>gen.check</code> transforms any admissible format to the default needed for calculations)) </p>
</td></tr>
<tr><td><code id="utilitiesV_+3A_walshindex">walshindex</code></td>
<td>
<p> non-negative integer (vector) with Yates matrix column numbers 
(called Walsh indices by Sanchez and Sanchez 2005; <br />
must contain the base column numbers 1, 2, 4, 8 and so forth for the desired dimension;
if this rule is violated, the first non-base column(s) are omitted in favor of supplementing 
the set of base columns)  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These internal functions are used for generating regular 2-level fractional factorials. 
The Sanchez and Sanchez (2005) way of providing large resolution V designs 
is supported, as well as manual design generation of large designs with 
functions <code><a href="#topic+FrF2">FrF2</a></code> and <code><a href="#topic+FrF2Large">FrF2Large</a></code>.
</p>


<h3>Value</h3>

<p><code>revdigits</code> creates a matrix with 0-1 entries in an order appropriate for 
creating character generators from Yates matrix column numbers,<br /> 
<code>indexcalc</code> calculates a named list of vectors of base column numbers, 
named by the corresponding character generator, <br />
<code>gencalc</code> calculates Yates column numbers from arbitrary types of generator 
representations (except for negative numbers),<br />
<code>YatesFly</code> produces an experimental plan from a vector of Yates column numbers 
which have to include the base column numbers (contrary to the 
<code>generators</code> option in <code>FrF2</code> or <code>FrF2Large</code>
</p>


<h3>Note</h3>

<p> This package is still under development, but does already provide useful and well-tested results.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Sanchez, S.M. and Sanchez, P.J. (2005). Very Large Fractional Factorial 
and Central Composite Designs. 
<em>ACM Transactions on Modeling and Computer Simulation</em> 
<b>15</b>, 362-377.
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+FrF2Large">FrF2Large</a></code> </p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
