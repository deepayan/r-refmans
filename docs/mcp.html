<!DOCTYPE html><html><head><title>Help for package mcp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mcp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mcp-package'><p>mcp: Regression with Multiple Change Points</p></a></li>
<li><a href='#bernoulli'><p>Bernoulli family for mcp</p></a></li>
<li><a href='#check_terms_in_data'><p>Checks if all terms are in the data</p></a></li>
<li><a href='#criterion'><p>Compute information criteria for model comparison</p></a></li>
<li><a href='#cumpaste'><p>Cumulative pasting of character columns</p></a></li>
<li><a href='#demo_fit'><p>Example <code>mcpfit</code> for examples</p></a></li>
<li><a href='#exponential'><p>Exponential family for mcp</p></a></li>
<li><a href='#fitted.mcpfit'><p>Expected Values from the Posterior Predictive Distribution</p></a></li>
<li><a href='#format_code'><p>Format code with one or multiple terms</p></a></li>
<li><a href='#geom_cp_density'><p>Density geom for <code>plot.mcpfit()</code></p></a></li>
<li><a href='#geom_quantiles'><p>Return a geom_line representing the quantiles</p></a></li>
<li><a href='#get_all_formulas'><p>Call <code>get_formula_str</code> for multiple ytypes and paste strings</p></a></li>
<li><a href='#get_ar_code'><p>Gets code for ARMA terms, resulting in a &quot;resid_&quot;</p></a></li>
<li><a href='#get_arma_order'><p>Extracts the order from ARMA parameter name(s)</p></a></li>
<li><a href='#get_density'><p>Compute the density at a specific point.</p></a></li>
<li><a href='#get_eval_at'><p>Get a list of x-coordinates to evaluate fit$simulate at</p></a></li>
<li><a href='#get_formula_str'><p>Build an R formula (as string) given a segment table (ST)</p></a></li>
<li><a href='#get_jags_data'><p>Adds helper variables for use in <code>run_jags</code></p></a></li>
<li><a href='#get_jagscode'><p>Make JAGS code for Multiple Change Point model</p></a></li>
<li><a href='#get_ppc_plot'><p>pp_check for loo statistics</p></a></li>
<li><a href='#get_prior'><p>Get priors for all parameters in a segment table.</p></a></li>
<li><a href='#get_prior_str'><p>Get JAGS code for a prior</p></a></li>
<li><a href='#get_quantiles'><p>Expand samples with quantiles</p></a></li>
<li><a href='#get_segment_table'><p>Build a table describing a list of segments</p></a></li>
<li><a href='#get_simulate'><p>Turn formula_str into a proper R function</p></a></li>
<li><a href='#get_summary'><p>Internal function for summary.mcpfit, fixef.mcpfit, and ranef.mcpfit</p></a></li>
<li><a href='#get_term_content'><p>Get formula inside a wrapper</p></a></li>
<li><a href='#hypothesis'><p>Test hypotheses on mcp objects.</p></a></li>
<li><a href='#ilogit'><p>Inverse logit function</p></a></li>
<li><a href='#is.mcpfit'><p>Checks if argument is an <code>mcpfit</code> object</p></a></li>
<li><a href='#logit'><p>Logit function</p></a></li>
<li><a href='#mcmclist_samples'><p>Internal function to get samples.</p></a></li>
<li><a href='#mcp'><p>Fit Multiple Linear Segments And Their Change Points</p></a></li>
<li><a href='#mcp_example'><p>Get example models and data</p></a></li>
<li><a href='#mcpfamily'><p>Add A family object to store link functions between R and JAGS.</p></a></li>
<li><a href='#mcpfit-class'><p>Class <code>mcpfit</code> of models fitted with the <span class="pkg">mcp</span> package</p></a></li>
<li><a href='#negbinomial'><p>Negative binomial for mcp</p></a></li>
<li><a href='#phi'><p>Inverse probit function</p></a></li>
<li><a href='#plot_pars'><p>Plot individual parameters</p></a></li>
<li><a href='#plot.mcpfit'><p>Plot full fits</p></a></li>
<li><a href='#pp_check'><p>Posterior Predictive Checks For Mcpfit Objects</p></a></li>
<li><a href='#pp_eval'><p>Fits and predictions from samples and newdata</p></a></li>
<li><a href='#predict.mcpfit'><p>Samples from the Posterior Predictive Distribution</p></a></li>
<li><a href='#print.mcplist'><p>Print mcplist</p></a></li>
<li><a href='#print.mcptext'><p>Nice printing texts</p></a></li>
<li><a href='#probit'><p>Probit function</p></a></li>
<li><a href='#recover_levels'><p>Recover the levels of varying effects in mcmc.list</p></a></li>
<li><a href='#remove_terms'><p>Remove varying or population terms from a formula</p></a></li>
<li><a href='#residuals.mcpfit'><p>Compute Residuals From Mcpfit Objects</p></a></li>
<li><a href='#run_jags'><p>Run parallel MCMC sampling using JAGS.</p></a></li>
<li><a href='#sd_to_prec'><p>Transform a prior from SD to precision.</p></a></li>
<li><a href='#summary.mcpfit'><p>Summarise mcpfit objects</p></a></li>
<li><a href='#tidy_samples'><p>Get tidy samples with or without varying effects</p></a></li>
<li><a href='#tidy_to_matrix'><p>Convert from tidy to matrix</p></a></li>
<li><a href='#to_formula'><p>Takes any formula-like input and returns a formula</p></a></li>
<li><a href='#unpack_arma'><p>Unpack arma order and formula</p></a></li>
<li><a href='#unpack_cp'><p>Takes a cp formula (as a string) and returns its properties</p></a></li>
<li><a href='#unpack_int'><p>Get the intercept of a formula</p></a></li>
<li><a href='#unpack_rhs'><p>Unpack right-hand side</p></a></li>
<li><a href='#unpack_slope'><p>Unpack the slope of a formula</p></a></li>
<li><a href='#unpack_slope_term'><p>Unpacks a single term</p></a></li>
<li><a href='#unpack_tildes'><p>Takes a formula and returns a string representation of y, cp, and rhs</p></a></li>
<li><a href='#unpack_varying'><p>Get relevant info about varying parameters</p></a></li>
<li><a href='#unpack_varying_term'><p>Unpack varying effects</p></a></li>
<li><a href='#unpack_y'><p>Unpacks y variable name</p></a></li>
<li><a href='#with_loo'><p>Add loo if not already present</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Regression with Multiple Change Points</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-14</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lindeloev.github.io/mcp/">https://lindeloev.github.io/mcp/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lindeloev/mcp/issues">https://github.com/lindeloev/mcp/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Flexible and informed regression with Multiple Change Points. 'mcp' can infer change points in means, variances, autocorrelation structure, and any combination of these, as well as the parameters of the segments in between. All parameters are estimated with uncertainty and prediction intervals are supported - also near the change points. 'mcp' supports hypothesis testing via Savage-Dickey density ratio, posterior contrasts, and cross-validation. 'mcp' is described in Lindeløv (submitted) &lt;<a href="https://doi.org/10.31219%2Fosf.io%2Ffzqxv">doi:10.31219/osf.io/fzqxv</a>&gt; and generalizes the approach described in Carlin, Gelfand, &amp; Smith (1992) &lt;<a href="https://doi.org/10.2307%2F2347570">doi:10.2307/2347570</a>&gt; and Stephens (1994) &lt;<a href="https://doi.org/10.2307%2F2986119">doi:10.2307/2986119</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, future (&ge; 1.16), future.apply (&ge; 1.4), rjags (&ge;
4.9), coda (&ge; 0.19.3), loo (&ge; 2.1.0), bayesplot (&ge; 1.7.0),
tidybayes (&ge; 3.0.0), dplyr (&ge; 1.1.1), magrittr (&ge; 1.5),
tidyr (&ge; 1.0.0), tidyselect (&ge; 0.2.5), tibble (&ge; 2.1.3),
stringr (&ge; 1.4.0), ggplot2 (&ge; 3.2.1), patchwork (&ge; 1.0.0),
stats, rlang (&ge; 0.4.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>hexbin, testthat (&ge; 3.1.0), purrr (&ge; 0.3.4), knitr,
rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-17 19:39:34 UTC; jonas</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonas Kristoffer Lindeløv
    <a href="https://orcid.org/0000-0003-4565-0595"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonas Kristoffer Lindeløv &lt;jonas@lindeloev.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-17 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mcp-package'>mcp: Regression with Multiple Change Points</h2><span id='topic+mcp-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Flexible and informed regression with Multiple Change Points. 'mcp' can infer change points in means, variances, autocorrelation structure, and any combination of these, as well as the parameters of the segments in between. All parameters are estimated with uncertainty and prediction intervals are supported - also near the change points. 'mcp' supports hypothesis testing via Savage-Dickey density ratio, posterior contrasts, and cross-validation. 'mcp' is described in Lindeløv (submitted) <a href="https://doi.org/10.31219/osf.io/fzqxv">doi:10.31219/osf.io/fzqxv</a> and generalizes the approach described in Carlin, Gelfand, &amp; Smith (1992) <a href="https://doi.org/10.2307/2347570">doi:10.2307/2347570</a> and Stephens (1994) <a href="https://doi.org/10.2307/2986119">doi:10.2307/2986119</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a> (<a href="https://orcid.org/0000-0003-4565-0595">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://lindeloev.github.io/mcp/">https://lindeloev.github.io/mcp/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/lindeloev/mcp/issues">https://github.com/lindeloev/mcp/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bernoulli'>Bernoulli family for mcp</h2><span id='topic+bernoulli'></span>

<h3>Description</h3>

<p>Bernoulli family for mcp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernoulli(link = "logit")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bernoulli_+3A_link">link</code></td>
<td>
<p>Link function.</p>
</td></tr>
</table>

<hr>
<h2 id='check_terms_in_data'>Checks if all terms are in the data</h2><span id='topic+check_terms_in_data'></span>

<h3>Description</h3>

<p>Checks if all terms are in the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_terms_in_data(form, data, i, n_terms = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_terms_in_data_+3A_form">form</code></td>
<td>
<p>Formula or character (tilde will be prefixed if it isn't already)</p>
</td></tr>
<tr><td><code id="check_terms_in_data_+3A_data">data</code></td>
<td>
<p>A data.frame or tibble</p>
</td></tr>
<tr><td><code id="check_terms_in_data_+3A_i">i</code></td>
<td>
<p>The segment number (integer)</p>
</td></tr>
<tr><td><code id="check_terms_in_data_+3A_n_terms">n_terms</code></td>
<td>
<p>Int &gt;= 1. Number of expected terms. Will raise error if it doesn't match.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='criterion'>Compute information criteria for model comparison</h2><span id='topic+criterion'></span><span id='topic+loo.mcpfit'></span><span id='topic+loo'></span><span id='topic+LOO'></span><span id='topic+waic.mcpfit'></span><span id='topic+waic'></span><span id='topic+WAIC'></span>

<h3>Description</h3>

<p>Takes an <code><a href="#topic+mcpfit">mcpfit</a></code> as input and computes information criteria using loo or
WAIC. Compare models using <code><a href="loo.html#topic+loo_compare">loo_compare</a></code> and <code><a href="loo.html#topic+loo_model_weights">loo_model_weights</a></code>.
more in <code><a href="loo.html#topic+loo">loo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criterion(fit, criterion = "loo", ...)

## S3 method for class 'mcpfit'
loo(x, ...)

## S3 method for class 'mcpfit'
waic(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="criterion_+3A_fit">fit</code></td>
<td>
<p>An <code><a href="#topic+mcpfit">mcpfit</a></code> object.</p>
</td></tr>
<tr><td><code id="criterion_+3A_criterion">criterion</code></td>
<td>
<p>One of <code>"loo"</code> (calls <code><a href="loo.html#topic+loo">loo</a></code>) or <code>"waic"</code> (calls <code><a href="loo.html#topic+waic">waic</a></code>).</p>
</td></tr>
<tr><td><code id="criterion_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="criterion_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+mcpfit">mcpfit</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>loo</code> or <code>psis_loo</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>loo(mcpfit)</code>: Computes loo on mcpfit objects
</p>
</li>
<li> <p><code>waic(mcpfit)</code>: Computes WAIC on mcpfit objects
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+criterion">criterion</a></code>
</p>
<p><code><a href="#topic+criterion">criterion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define two models and sample them
# options(mc.cores = 3)  # Speed up sampling
ex = mcp_example("intercepts")  # Get some simulated data.
model1 = list(y ~ 1 + x, ~ 1)
model2 = list(y ~ 1 + x)  # Without a change point
fit1 = mcp(model1, ex$data)
fit2 = mcp(model2, ex$data)

# Compute LOO for each and compare (works for waic(fit) too)
fit1$loo = loo(fit1)
fit2$loo = loo(fit2)
loo::loo_compare(fit1$loo, fit2$loo)


</code></pre>

<hr>
<h2 id='cumpaste'>Cumulative pasting of character columns</h2><span id='topic+cumpaste'></span>

<h3>Description</h3>

<p>Cumulative pasting of character columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumpaste(x, .sep = " ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumpaste_+3A_x">x</code></td>
<td>
<p>A column</p>
</td></tr>
<tr><td><code id="cumpaste_+3A_.sep">.sep</code></td>
<td>
<p>A character to append between pastes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a> but Inspired by
https://stackoverflow.com/questions/24862046/cumulatively-paste-concatenate-values-grouped-by-another-variable
</p>

<hr>
<h2 id='demo_fit'>Example <code>mcpfit</code> for examples</h2><span id='topic+demo_fit'></span>

<h3>Description</h3>

<p>This was generated using <code>mcp_examples("demo", sample = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo_fit
</code></pre>


<h3>Format</h3>

<p>An <code><a href="#topic+mcpfit">mcpfit</a></code> object.
</p>

<hr>
<h2 id='exponential'>Exponential family for mcp</h2><span id='topic+exponential'></span>

<h3>Description</h3>

<p>Exponential family for mcp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential(link = "identity")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_+3A_link">link</code></td>
<td>
<p>Link function (Character).</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.mcpfit'>Expected Values from the Posterior Predictive Distribution</h2><span id='topic+fitted.mcpfit'></span><span id='topic+fitted'></span>

<h3>Description</h3>

<p>Expected Values from the Posterior Predictive Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcpfit'
fitted(
  object,
  newdata = NULL,
  summary = TRUE,
  probs = TRUE,
  rate = TRUE,
  prior = FALSE,
  which_y = "ct",
  varying = TRUE,
  arma = TRUE,
  nsamples = NULL,
  samples_format = "tidy",
  scale = "response",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.mcpfit_+3A_object">object</code></td>
<td>
<p>An <code>mcpfit</code> object.</p>
</td></tr>
<tr><td><code id="fitted.mcpfit_+3A_newdata">newdata</code></td>
<td>
<p>A <code>tibble</code> or a <code>data.frame</code> containing predictors in the model. If <code>NULL</code> (default),
the original data is used.</p>
</td></tr>
<tr><td><code id="fitted.mcpfit_+3A_summary">summary</code></td>
<td>
<p>Summarise at each x-value</p>
</td></tr>
<tr><td><code id="fitted.mcpfit_+3A_probs">probs</code></td>
<td>
<p>Vector of quantiles. Only in effect when <code>summary == TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted.mcpfit_+3A_rate">rate</code></td>
<td>
<p>Boolean. For binomial models, plot on raw data (<code>rate = FALSE</code>) or
response divided by number of trials (<code>rate = TRUE</code>). If FALSE, linear
interpolation on trial number is used to infer trials at a particular x.</p>
</td></tr>
<tr><td><code id="fitted.mcpfit_+3A_prior">prior</code></td>
<td>
<p>TRUE/FALSE. Plot using prior samples? Useful for <code>mcp(..., sample = "both")</code></p>
</td></tr>
<tr><td><code id="fitted.mcpfit_+3A_which_y">which_y</code></td>
<td>
<p>What to plot on the y-axis. One of
</p>

<ul>
<li> <p><code>"ct"</code>: The central tendency which is often the mean after applying the
link function.
</p>
</li>
<li> <p><code>"sigma"</code>: The variance
</p>
</li>
<li> <p><code>"ar1"</code>, <code>"ar2"</code>, etc. depending on which order of the autoregressive
effects you want to plot.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fitted.mcpfit_+3A_varying">varying</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>TRUE</code> All varying effects (<code>fit$pars$varying</code>).
</p>
</li>
<li> <p><code>FALSE</code> No varying effects (<code>c()</code>).
</p>
</li>
<li><p> Character vector: Only include specified varying parameters - see <code>fit$pars$varying</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fitted.mcpfit_+3A_arma">arma</code></td>
<td>
<p>Whether to include autoregressive effects.
</p>

<ul>
<li> <p><code>TRUE</code> Compute autoregressive residuals. Requires the response variable in <code>newdata</code>.
</p>
</li>
<li> <p><code>FALSE</code> Disregard the autoregressive effects. For <code>family = gaussian()</code>, <code>predict()</code> just use <code>sigma</code> for residuals.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fitted.mcpfit_+3A_nsamples">nsamples</code></td>
<td>
<p>Integer or <code>NULL</code>. Number of samples to return/summarise.
If there are varying effects, this is the number of samples from each varying group.
<code>NULL</code> means &quot;all&quot;. Ignored if both are <code>FALSE</code>. More samples trade speed for accuracy.</p>
</td></tr>
<tr><td><code id="fitted.mcpfit_+3A_samples_format">samples_format</code></td>
<td>
<p>One of &quot;tidy&quot; or &quot;matrix&quot;. Controls the output format when <code>summary == FALSE</code>.
See more under &quot;value&quot;</p>
</td></tr>
<tr><td><code id="fitted.mcpfit_+3A_scale">scale</code></td>
<td>
<p>One of
</p>

<ul>
<li><p> &quot;response&quot;: return on the observed scale, i.e., after applying the inverse link function.
</p>
</li>
<li><p> &quot;linear&quot;: return on the parameter scale (where the linear trends are modelled).
</p>
</li></ul>
</td></tr>
<tr><td><code id="fitted.mcpfit_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> If <code>summary = TRUE</code>: A <code>tibble</code> with the posterior mean for each row in <code>newdata</code>,
If <code>newdata</code> is <code>NULL</code>, the data in <code>fit$data</code> is used.
</p>
</li>
<li><p> If <code>summary = FALSE</code> and <code>samples_format = "tidy"</code>: A <code>tidybayes</code> <code>tibble</code> with all the posterior
samples (<code>Ns</code>) evaluated at each row in <code>newdata</code> (<code>Nn</code>), i.e., with <code style="white-space: pre;">&#8288;Ns x Nn&#8288;</code> rows. If there are
varying effects, the returned data is expanded with the relevant levels for each row.
</p>
<p>The return columns are:
</p>

<ul>
<li><p> Predictors from <code>newdata</code>.
</p>
</li>
<li><p> Sample descriptors: &quot;.chain&quot;, &quot;.iter&quot;, &quot;.draw&quot; (see the <code>tidybayes</code> package for more), and &quot;data_row&quot; (<code>newdata</code> rownumber)
</p>
</li>
<li><p> Sample values: one column for each parameter in the model.
</p>
</li>
<li><p> The estimate. Either &quot;predict&quot; or &quot;fitted&quot;, i.e., the name of the <code>type</code> argument.
</p>
</li></ul>

</li>
<li><p> If <code>summary = FALSE</code> and <code>samples_format = "matrix"</code>: An <code>N_draws</code> X <code>nrows(newdata)</code> matrix with fitted/predicted
values (depending on <code>type</code>). This format is used by <code>brms</code> and it's useful as <code>yrep</code> in
<code style="white-space: pre;">&#8288;bayesplot::ppc_*&#8288;</code> functions.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp_eval">pp_eval</a></code> <code><a href="#topic+predict.mcpfit">predict.mcpfit</a></code> <code><a href="#topic+residuals.mcpfit">residuals.mcpfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fitted(demo_fit)
fitted(demo_fit, probs = c(0.1, 0.5, 0.9))  # With median and 80% credible interval.
fitted(demo_fit, summary = FALSE)  # Samples instead of summary.
fitted(demo_fit,
       newdata = data.frame(time = c(-5, 20, 300)),  # New data
       probs = c(0.025, 0.5, 0.975))


</code></pre>

<hr>
<h2 id='format_code'>Format code with one or multiple terms</h2><span id='topic+format_code'></span>

<h3>Description</h3>

<p>Take a value like &quot;a + b&quot; and
(1) replace it with NA if na_col == NA.
(2) Change to &quot;(a + b)&quot; if there is a &quot;+&quot;
(3) Return itself otherwise, e.g., &quot;a&quot; &ndash;&gt; &quot;a&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_code(col, na_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_code_+3A_col">col</code></td>
<td>
<p>A column</p>
</td></tr>
<tr><td><code id="format_code_+3A_na_col">na_col</code></td>
<td>
<p>If this column is NA, return NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='geom_cp_density'>Density geom for <code>plot.mcpfit()</code></h2><span id='topic+geom_cp_density'></span>

<h3>Description</h3>

<p>Density geom for <code>plot.mcpfit()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_cp_density(fit, facet_by, limits_y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_cp_density_+3A_fit">fit</code></td>
<td>
<p>An <code>mcpfit</code> object</p>
</td></tr>
<tr><td><code id="geom_cp_density_+3A_facet_by">facet_by</code></td>
<td>
<p><code>NULL</code> or a a string, like <code style="white-space: pre;">&#8288;plot.mcpfit(..., facet_by = "id").&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2::stat_density</code> geom representing the change point densities.
</p>

<hr>
<h2 id='geom_quantiles'>Return a geom_line representing the quantiles</h2><span id='topic+geom_quantiles'></span>

<h3>Description</h3>

<p>Called by <code>plot.mcpfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_quantiles(samples, quantiles, xvar, yvar, facet_by, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_quantiles_+3A_samples">samples</code></td>
<td>
<p>A tidybayes tibble</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_quantiles">quantiles</code></td>
<td>
<p>Vector of quantiles (0.0 to 1.0)</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_xvar">xvar</code></td>
<td>
<p>An rlang::sym() with the name of the x-col in <code>samples</code></p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_yvar">yvar</code></td>
<td>
<p>An rlang::sym() with the name of the response col in <code>samples</code></p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_facet_by">facet_by</code></td>
<td>
<p>String. Name of a varying group.</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_...">...</code></td>
<td>
<p>Arguments passed to geom_line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2::geom_line</code> object.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='get_all_formulas'>Call <code>get_formula_str</code> for multiple ytypes and paste strings</h2><span id='topic+get_all_formulas'></span>

<h3>Description</h3>

<p>Currently used to differentiate between the JAGS model (use all) and the
fit$simulate model (do not include arma).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_formulas(ST, prior, par_x, ytypes = c("ct", "sigma", "arma"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_formulas_+3A_st">ST</code></td>
<td>
<p>Tibble. Returned by <code>get_segment_table</code>.</p>
</td></tr>
<tr><td><code id="get_all_formulas_+3A_prior">prior</code></td>
<td>
<p>Named list. Names are parameter names (<code>cp_i</code>, <code>int_i</code>, <code>xvar_i</code>,
'sigma&ldquo;) and the values are either
</p>

<ul>
<li><p> A JAGS distribution (e.g., <code>int_1 = "dnorm(0, 1) T(0,)"</code>) indicating a
conventional prior distribution. Uninformative priors based on data
properties are used where priors are not specified. This ensures good
parameter estimations, but it is a questionable for hypothesis testing.
<code>mcp</code> uses SD (not precision) for dnorm, dt, dlogis, etc. See
details. Change points are forced to be ordered through the priors using
truncation, except for uniform priors where the lower bound should be
greater than the previous change point, <code>dunif(cp_1, MAXX)</code>.
</p>
</li>
<li><p> A numerical value (e.g., <code>int_1 = -2.1</code>) indicating a fixed value.
</p>
</li>
<li><p> A model parameter name (e.g., <code>int_2 = "int_1"</code>), indicating that this parameter is shared -
typically between segments. If two varying effects are shared this way,
they will need to have the same grouping variable.
</p>
</li>
<li><p> A scaled Dirichlet prior is supported for change points if they are all set to
<code style="white-space: pre;">&#8288;cp_i = "dirichlet(N)&#8288;</code> where <code>N</code> is the alpha for this change point and
<code>N = 1</code> is most often used. This prior is less informative about the
location of the change points than the default uniform prior, but it
samples less efficiently, so you will often need to set <code>iter</code> higher.
It is recommended for hypothesis testing and for the estimation of more
than 5 change points. <a href="https://lindeloev.github.io/mcp/articles/priors.html">Read more</a>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_all_formulas_+3A_par_x">par_x</code></td>
<td>
<p>String (default: NULL). Only relevant if no segments contains
slope (no hint at what x is). Set this, e.g., par_x = &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="get_all_formulas_+3A_ytypes">ytypes</code></td>
<td>
<p>A character vector of ytypes to including in model building</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with JAGS code.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='get_ar_code'>Gets code for ARMA terms, resulting in a &quot;resid_&quot;</h2><span id='topic+get_ar_code'></span>

<h3>Description</h3>

<p>Developer note: Ensuring that this can be used in both simulate() and JAGS
got quite messy with a lot of if-statements. It works but some refactoring
may be good in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ar_code(ar_order, family, is_R, xvar, yvar = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ar_code_+3A_ar_order">ar_order</code></td>
<td>
<p>Positive integer. The order of ARMA</p>
</td></tr>
<tr><td><code id="get_ar_code_+3A_family">family</code></td>
<td>
<p>An mcpfamily object</p>
</td></tr>
<tr><td><code id="get_ar_code_+3A_is_r">is_R</code></td>
<td>
<p>Bool. Is this R code (TRUE) or JAGS code (FALSE)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String with JAGS code for AR.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='get_arma_order'>Extracts the order from ARMA parameter name(s)</h2><span id='topic+get_arma_order'></span>

<h3>Description</h3>

<p>If several names are provided (vector), it returns the maximum. If <code>pars_arma</code>
is an empty string, it returns <code>0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_arma_order(pars_arma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_arma_order_+3A_pars_arma">pars_arma</code></td>
<td>
<p>Character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>

<hr>
<h2 id='get_density'>Compute the density at a specific point.</h2><span id='topic+get_density'></span>

<h3>Description</h3>

<p>Used in <a href="#topic+hypothesis">hypothesis</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_density(samples, LHS, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_density_+3A_samples">samples</code></td>
<td>
<p>An mcmc.list</p>
</td></tr>
<tr><td><code id="get_density_+3A_lhs">LHS</code></td>
<td>
<p>Expression to compute posterior</p>
</td></tr>
<tr><td><code id="get_density_+3A_value">value</code></td>
<td>
<p>What value to evaluate the density at</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='get_eval_at'>Get a list of x-coordinates to evaluate fit$simulate at</h2><span id='topic+get_eval_at'></span>

<h3>Description</h3>

<p>Solves two problems: if setting the number of points too high, the
function becomes slow. If setting it too low, the posterior at large intercept-
changes at change points look discrete, because they are evaluated at very
few x in that interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eval_at(fit, facet_by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eval_at_+3A_fit">fit</code></td>
<td>
<p>An mcpfit object.</p>
</td></tr>
<tr><td><code id="get_eval_at_+3A_facet_by">facet_by</code></td>
<td>
<p>String. Name of a varying group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes a vector of x-values with large spacing in general,
but finer resolution at change points.
</p>


<h3>Value</h3>

<p>A vector of x-values to evaluate at.
</p>

<hr>
<h2 id='get_formula_str'>Build an R formula (as string) given a segment table (ST)</h2><span id='topic+get_formula_str'></span>

<h3>Description</h3>

<p>You will need to replace PAR_X for whatever your x-axis observation column
is called. In JAGS typically <code>x[i_]</code>. In R just <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_formula_str(ST, par_x, ytype = "ct", init = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_formula_str_+3A_st">ST</code></td>
<td>
<p>Tibble. Returned by <code>get_segment_table</code>.</p>
</td></tr>
<tr><td><code id="get_formula_str_+3A_par_x">par_x</code></td>
<td>
<p>String (default: NULL). Only relevant if no segments contains
slope (no hint at what x is). Set this, e.g., par_x = &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="get_formula_str_+3A_ytype">ytype</code></td>
<td>
<p>One of &quot;ct&quot; (central tendency), &quot;sigma&quot;, &quot;ar1&quot; (or another order), or &quot;ma1&quot; (or another order)</p>
</td></tr>
<tr><td><code id="get_formula_str_+3A_init">init</code></td>
<td>
<p>TRUE/FALSE. Set to TRUE for the first call. Adds segment-relative
X-codings and verbose commenting of one formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with JAGS code.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='get_jags_data'>Adds helper variables for use in <code>run_jags</code></h2><span id='topic+get_jags_data'></span>

<h3>Description</h3>

<p>Returns the relevant data columns as a list and add elements with unique
varying group levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_jags_data(data, ST, jags_code, sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_jags_data_+3A_data">data</code></td>
<td>
<p>A tibble</p>
</td></tr>
<tr><td><code id="get_jags_data_+3A_st">ST</code></td>
<td>
<p>A segment table (tibble), returned by <code>get_segment_table</code>.</p>
</td></tr>
<tr><td><code id="get_jags_data_+3A_jags_code">jags_code</code></td>
<td>
<p>A string. JAGS model, usually returned by <code>make_jagscode()</code>.</p>
</td></tr>
<tr><td><code id="get_jags_data_+3A_sample">sample</code></td>
<td>
<p>One of
</p>

<ul>
<li> <p><code>"post"</code>: Sample the posterior.
</p>
</li>
<li> <p><code>"prior"</code>: Sample only the prior. Plots, summaries, etc. will
use the prior. This is useful for prior predictive checks.
</p>
</li>
<li> <p><code>"both"</code>: Sample both prior and posterior. Plots, summaries, etc.
will default to using the posterior. The prior only has effect when doing
Savage-Dickey density ratios in <code><a href="#topic+hypothesis">hypothesis</a></code>.
</p>
</li>
<li> <p><code>"none"</code> or <code>FALSE</code>: Do not sample. Returns an mcpfit
object without sample. This is useful if you only want to check
prior strings (fit$prior), the JAGS model (fit$jags_code), etc.
</p>
</li></ul>
</td></tr>
</table>

<hr>
<h2 id='get_jagscode'>Make JAGS code for Multiple Change Point model</h2><span id='topic+get_jagscode'></span>

<h3>Description</h3>

<p>Make JAGS code for Multiple Change Point model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_jagscode(prior, ST, formula_str, arma_order, family, sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_jagscode_+3A_prior">prior</code></td>
<td>
<p>Named list. Names are parameter names (<code>cp_i</code>, <code>int_i</code>, <code>xvar_i</code>,
'sigma&ldquo;) and the values are either
</p>

<ul>
<li><p> A JAGS distribution (e.g., <code>int_1 = "dnorm(0, 1) T(0,)"</code>) indicating a
conventional prior distribution. Uninformative priors based on data
properties are used where priors are not specified. This ensures good
parameter estimations, but it is a questionable for hypothesis testing.
<code>mcp</code> uses SD (not precision) for dnorm, dt, dlogis, etc. See
details. Change points are forced to be ordered through the priors using
truncation, except for uniform priors where the lower bound should be
greater than the previous change point, <code>dunif(cp_1, MAXX)</code>.
</p>
</li>
<li><p> A numerical value (e.g., <code>int_1 = -2.1</code>) indicating a fixed value.
</p>
</li>
<li><p> A model parameter name (e.g., <code>int_2 = "int_1"</code>), indicating that this parameter is shared -
typically between segments. If two varying effects are shared this way,
they will need to have the same grouping variable.
</p>
</li>
<li><p> A scaled Dirichlet prior is supported for change points if they are all set to
<code style="white-space: pre;">&#8288;cp_i = "dirichlet(N)&#8288;</code> where <code>N</code> is the alpha for this change point and
<code>N = 1</code> is most often used. This prior is less informative about the
location of the change points than the default uniform prior, but it
samples less efficiently, so you will often need to set <code>iter</code> higher.
It is recommended for hypothesis testing and for the estimation of more
than 5 change points. <a href="https://lindeloev.github.io/mcp/articles/priors.html">Read more</a>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_jagscode_+3A_st">ST</code></td>
<td>
<p>Segment table. Returned by <code>get_segment_table()</code>.</p>
</td></tr>
<tr><td><code id="get_jagscode_+3A_formula_str">formula_str</code></td>
<td>
<p>String. The formula string returned by <code>build_formula_str</code>.</p>
</td></tr>
<tr><td><code id="get_jagscode_+3A_arma_order">arma_order</code></td>
<td>
<p>Positive integer. The autoregressive order.</p>
</td></tr>
<tr><td><code id="get_jagscode_+3A_family">family</code></td>
<td>
<p>One of <code>gaussian()</code>, <code>binomial()</code>, <code>bernoulli()</code>, or <code>poission()</code>.
Only default link functions are currently supported.</p>
</td></tr>
<tr><td><code id="get_jagscode_+3A_sample">sample</code></td>
<td>
<p>One of
</p>

<ul>
<li> <p><code>"post"</code>: Sample the posterior.
</p>
</li>
<li> <p><code>"prior"</code>: Sample only the prior. Plots, summaries, etc. will
use the prior. This is useful for prior predictive checks.
</p>
</li>
<li> <p><code>"both"</code>: Sample both prior and posterior. Plots, summaries, etc.
will default to using the posterior. The prior only has effect when doing
Savage-Dickey density ratios in <code><a href="#topic+hypothesis">hypothesis</a></code>.
</p>
</li>
<li> <p><code>"none"</code> or <code>FALSE</code>: Do not sample. Returns an mcpfit
object without sample. This is useful if you only want to check
prior strings (fit$prior), the JAGS model (fit$jags_code), etc.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>String. A JAGS model.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='get_ppc_plot'>pp_check for loo statistics</h2><span id='topic+get_ppc_plot'></span><span id='topic+get_loo_plot_call'></span>

<h3>Description</h3>

<p>pp_check for loo statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ppc_plot(fit, type, y, yrep, nsamples, draws = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ppc_plot_+3A_type">type</code></td>
<td>
<p>One of <code>bayesplot::available_ppc("grouped", invert = TRUE) %&gt;% stringr::str_remove("ppc_")</code></p>
</td></tr>
<tr><td><code id="get_ppc_plot_+3A_y">y</code></td>
<td>
<p>Response vector</p>
</td></tr>
<tr><td><code id="get_ppc_plot_+3A_yrep">yrep</code></td>
<td>
<p>S X N matrix of predicted responses</p>
</td></tr>
<tr><td><code id="get_ppc_plot_+3A_nsamples">nsamples</code></td>
<td>
<p>Number of draws. Note that you may want to use all data for summary geoms.
e.g., <code>pp_check(fit, type = "ribbon", nsamples = NULL)</code>.</p>
</td></tr>
<tr><td><code id="get_ppc_plot_+3A_draws">draws</code></td>
<td>
<p>(required for loo-type plots) Indices of draws to use.</p>
</td></tr>
<tr><td><code id="get_ppc_plot_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>bayesplot::ppc_type(y, yrep, ...)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object returned by <code style="white-space: pre;">&#8288;tidybayes::ppc_*(y, yrep, ...)&#8288;</code>.
</p>
<p>A string
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='get_prior'>Get priors for all parameters in a segment table.</h2><span id='topic+get_prior'></span>

<h3>Description</h3>

<p>Starts by finding all default priors. Then replace them with user priors.
User priors for change points are truncated appropriately using
'truncate_prior_cp&ldquo;, if not done manually by the user already.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_prior(ST, family, prior = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_prior_+3A_st">ST</code></td>
<td>
<p>Tibble. A segment table returned by <code>get_segment_table</code>.</p>
</td></tr>
<tr><td><code id="get_prior_+3A_family">family</code></td>
<td>
<p>One of <code>gaussian()</code>, <code>binomial()</code>, <code>bernoulli()</code>, or <code>poission()</code>.
Only default link functions are currently supported.</p>
</td></tr>
<tr><td><code id="get_prior_+3A_prior">prior</code></td>
<td>
<p>A list of user-defined priors. Will overwrite the relevant
default priors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of strings. The names correspond to the parameter names
and the strings are the JAGS code for the prior (before converting SD to
precision).
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='get_prior_str'>Get JAGS code for a prior</h2><span id='topic+get_prior_str'></span>

<h3>Description</h3>

<p>Get JAGS code for a prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_prior_str(prior, i, varying_group = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_prior_str_+3A_prior">prior</code></td>
<td>
<p>Named list. Names are parameter names (<code>cp_i</code>, <code>int_i</code>, <code>xvar_i</code>,
'sigma&ldquo;) and the values are either
</p>

<ul>
<li><p> A JAGS distribution (e.g., <code>int_1 = "dnorm(0, 1) T(0,)"</code>) indicating a
conventional prior distribution. Uninformative priors based on data
properties are used where priors are not specified. This ensures good
parameter estimations, but it is a questionable for hypothesis testing.
<code>mcp</code> uses SD (not precision) for dnorm, dt, dlogis, etc. See
details. Change points are forced to be ordered through the priors using
truncation, except for uniform priors where the lower bound should be
greater than the previous change point, <code>dunif(cp_1, MAXX)</code>.
</p>
</li>
<li><p> A numerical value (e.g., <code>int_1 = -2.1</code>) indicating a fixed value.
</p>
</li>
<li><p> A model parameter name (e.g., <code>int_2 = "int_1"</code>), indicating that this parameter is shared -
typically between segments. If two varying effects are shared this way,
they will need to have the same grouping variable.
</p>
</li>
<li><p> A scaled Dirichlet prior is supported for change points if they are all set to
<code style="white-space: pre;">&#8288;cp_i = "dirichlet(N)&#8288;</code> where <code>N</code> is the alpha for this change point and
<code>N = 1</code> is most often used. This prior is less informative about the
location of the change points than the default uniform prior, but it
samples less efficiently, so you will often need to set <code>iter</code> higher.
It is recommended for hypothesis testing and for the estimation of more
than 5 change points. <a href="https://lindeloev.github.io/mcp/articles/priors.html">Read more</a>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_prior_str_+3A_i">i</code></td>
<td>
<p>The index in <code>prior</code> to get code for</p>
</td></tr>
<tr><td><code id="get_prior_str_+3A_varying_group">varying_group</code></td>
<td>
<p>String or NULL. Null indicates a population-
level prior. String indicates a varying-effects prior (one for each group
level).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='get_quantiles'>Expand samples with quantiles</h2><span id='topic+get_quantiles'></span>

<h3>Description</h3>

<p>TO DO: implement using <code>fitted()</code> and <code>predict()</code> but avoid double-computing the samples? E.g.:
<code style="white-space: pre;">&#8288;get_quantiles2 = function(fit, quantiles, facet_by = NULL) {&#8288;</code>
<code style="white-space: pre;">&#8288;fitted(fit, probs = c(0.1, 0.5, 0.9), newdata = data.frame(x = c(11, 50, 100))) %&gt;%&#8288;</code>
<code style="white-space: pre;">&#8288;tidyr::pivot_longer(tidyselect::starts_with("Q")) %&gt;%&#8288;</code>
<code>dplyr::mutate(quantile = stringr::str_remove(name, "Q") %&gt;% as.numeric() / 100)</code>
<code style="white-space: pre;">&#8288;}&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_quantiles(samples, quantiles, xvar, yvar, facet_by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_quantiles_+3A_samples">samples</code></td>
<td>
<p>A tidybayes tibble</p>
</td></tr>
<tr><td><code id="get_quantiles_+3A_quantiles">quantiles</code></td>
<td>
<p>Vector of quantiles (0.0 to 1.0)</p>
</td></tr>
<tr><td><code id="get_quantiles_+3A_xvar">xvar</code></td>
<td>
<p>An rlang::sym() with the name of the x-col in <code>samples</code></p>
</td></tr>
<tr><td><code id="get_quantiles_+3A_yvar">yvar</code></td>
<td>
<p>An rlang::sym() with the name of the response col in <code>samples</code></p>
</td></tr>
<tr><td><code id="get_quantiles_+3A_facet_by">facet_by</code></td>
<td>
<p>String. Name of a varying group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidybayes long format tibble with the column &quot;quantile&quot;
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='get_segment_table'>Build a table describing a list of segments</h2><span id='topic+get_segment_table'></span>

<h3>Description</h3>

<p>Used internally for most mcp functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_segment_table(model, data = NULL, family = gaussian(), par_x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_segment_table_+3A_model">model</code></td>
<td>
<p>A list of formulas - one for each segment. The first formula
has the format <code>response ~ predictors</code> while the following formulas
have the format <code>response ~ changepoint ~ predictors</code>. The response
and change points can be omitted (<code>changepoint ~ predictors</code> assumes same
response. <code>~ predictors</code> assumes an intercept-only change point). The
following can be modeled:
</p>

<ul>
<li> <p><em>Regular formulas:</em> e.g., <code>~ 1 + x</code>). <a href="https://lindeloev.github.io/mcp/articles/formulas.html">Read more</a>.
</p>
</li>
<li> <p><em>Extended formulas:</em>, e.g., <code>~ I(x^2) + exp(x) + sin(x)</code>. <a href="https://lindeloev.github.io/mcp/articles/formulas.html">Read more</a>.
</p>
</li>
<li> <p><em>Variance:</em> e.g., <code>~sigma(1)</code> for a simple variance change or
<code>~sigma(rel(1) + I(x^2))</code>) for more advanced variance structures. <a href="https://lindeloev.github.io/mcp/articles/variance.html">Read more</a>
</p>
</li>
<li> <p><em>Autoregression:</em> e.g., <code>~ar(1)</code> for a simple onset/change in AR(1) or
<code style="white-space: pre;">&#8288;ar(2, 0 + x&#8288;</code>) for an AR(2) increasing by <code>x</code>. <a href="https://lindeloev.github.io/mcp/articles/arma.html">Read more</a>
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_segment_table_+3A_data">data</code></td>
<td>
<p>Data.frame or tibble in long format.</p>
</td></tr>
<tr><td><code id="get_segment_table_+3A_family">family</code></td>
<td>
<p>One of <code>gaussian()</code>, <code>binomial()</code>, <code>bernoulli()</code>, or <code>poission()</code>.
Only default link functions are currently supported.</p>
</td></tr>
<tr><td><code id="get_segment_table_+3A_par_x">par_x</code></td>
<td>
<p>String (default: NULL). Only relevant if no segments contains
slope (no hint at what x is). Set this, e.g., par_x = &quot;time&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with one row describing each segment and the corresponding code.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model = list(
  y ~ 1 + x,
  1 + (1|id) ~ 1
)
get_segment_table(model)
</code></pre>

<hr>
<h2 id='get_simulate'>Turn formula_str into a proper R function</h2><span id='topic+get_simulate'></span>

<h3>Description</h3>

<p>Turn formula_str into a proper R function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_simulate(formula_str, pars, nsegments, family)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_simulate_+3A_formula_str">formula_str</code></td>
<td>
<p>string. Returned by <code>get_formula</code>.</p>
</td></tr>
<tr><td><code id="get_simulate_+3A_pars">pars</code></td>
<td>
<p>List of user-provided parameters, in the format of fit$pars.</p>
</td></tr>
<tr><td><code id="get_simulate_+3A_nsegments">nsegments</code></td>
<td>
<p>Positive integer. Number of segments, typically <code>nrow(ST)</code>.</p>
</td></tr>
<tr><td><code id="get_simulate_+3A_family">family</code></td>
<td>
<p>One of <code>gaussian()</code>, <code>binomial()</code>, <code>bernoulli()</code>, or <code>poission()</code>.
Only default link functions are currently supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with R code for the fit$simulate() function corresponding to the model.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='get_summary'>Internal function for summary.mcpfit, fixef.mcpfit, and ranef.mcpfit</h2><span id='topic+get_summary'></span><span id='topic+get_summary.mcpfit'></span>

<h3>Description</h3>

<p>Internal function for summary.mcpfit, fixef.mcpfit, and ranef.mcpfit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_summary(fit, width, varying = FALSE, prior = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_summary_+3A_fit">fit</code></td>
<td>
<p>An <code><a href="#topic+mcpfit">mcpfit</a></code>' object.</p>
</td></tr>
<tr><td><code id="get_summary_+3A_width">width</code></td>
<td>
<p>Float. The width of the highest posterior density interval
(between 0 and 1).</p>
</td></tr>
<tr><td><code id="get_summary_+3A_varying">varying</code></td>
<td>
<p>Boolean. Get results for varying (TRUE) or population (FALSE)?</p>
</td></tr>
<tr><td><code id="get_summary_+3A_prior">prior</code></td>
<td>
<p>TRUE/FALSE. Summarise prior instead of posterior?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with summaries for each model parameter.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='get_term_content'>Get formula inside a wrapper</h2><span id='topic+get_term_content'></span>

<h3>Description</h3>

<p>Get formula inside a wrapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_term_content(term)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_term_content_+3A_term">term</code></td>
<td>
<p>E.g., &quot;ct(1 + x)&quot;, &quot;sigma(0 + rel(x) + I(x^2))&quot;, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>char formula with the content inside the brackets.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='hypothesis'>Test hypotheses on mcp objects.</h2><span id='topic+hypothesis'></span><span id='topic+hypothesis.mcpfit'></span>

<h3>Description</h3>

<p>Returns posterior probabilities and Bayes Factors for flexible hypotheses involving
model parameters. The documentation for the argument <code>hypotheses</code> below
shows examples of how to specify hypotheses, and <a href="https://lindeloev.github.io/mcp/articles/comparison.html">read worked examples on the mcp website</a>.
For directional hypotheses, <code style="white-space: pre;">&#8288;hypothesis`` executes the hypothesis string in a &#8288;</code>tidybayes&ldquo; environment and summerises the proportion of samples where
the expression evaluates to TRUE. For equals-hypothesis, a Savage-Dickey
ratio is computed. Savage-Dickey requires a prior too, so remember
<code>mcp(..., sample = "both")</code>. This function is heavily inspired by the
'hypothesis' function from the 'brms' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypothesis(fit, hypotheses, width = 0.95, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypothesis_+3A_fit">fit</code></td>
<td>
<p>An <code><a href="#topic+mcpfit">mcpfit</a></code> object.</p>
</td></tr>
<tr><td><code id="hypothesis_+3A_hypotheses">hypotheses</code></td>
<td>
<p>String representation of a logical test involving model parameters.
Takes R code that evaluates to TRUE or FALSE in a vectorized way.
</p>
<p>Directional hypotheses are specified using &lt;, &gt;, &lt;=, or &gt;=. <code>hypothesis</code>
returns the posterior probability and odds in favor of the stated hypothesis.
The odds can be interpreted as a Bayes Factor. For example:
</p>

<ul>
<li> <p><code>"cp_1 &gt; 30"</code>:  the first change point is above 30.
</p>
</li>
<li> <p><code>"int_1 &gt; int_2"</code>: the intercept is greater in segment 1 than 2.
</p>
</li>
<li> <p><code>"x_2 - x_1 &lt;= 3"</code>: the difference between slope 1 and 2 is less
than or equal to 3.
</p>
</li>
<li> <p><code>"int_1 &gt; -2 &amp; int_1 &lt; 2"</code>: int_1 is between -2 and 2 (an interval hypothesis). This can be useful as a Region Of Practical Equivalence test (ROPE).
</p>
</li>
<li> <p><code>"cp_1^2 &lt; 30 | (log(x_1) + log(x_2)) &gt; 5"</code>: be creative.
</p>
</li>
<li> <p><code>"`cp_1_id[1]` &gt; `cp_1_id[2]`"</code>: id1 is greater than id2, as estimated
through the varying-by-&quot;id&quot; change point in segment 1. Note that <code>``</code>
required for varying effects.
</p>
</li></ul>

<p>Hypotheses can also test equality using the equal sign (=). This runs a
Savage-Dickey test, i.e., the proportion by which the probability density
has increased from the prior to the posterior at a given value. Therefore,
it requires <code>mcp(sample = "both")</code>. There are two requirements:
First, there can only be one equal sign, so don't use and (&amp;) or or (|).
Second, the point to test has to be on the right, and the variables on the left.
</p>

<ul>
<li> <p><code>"cp_1 = 30"</code>: is the first change point at 30? Or to be more precise:
by what factor has the credence in cp_1 = 30 risen/fallen when
conditioning on the data, relative to the prior credence?
</p>
</li>
<li> <p><code>"int_1 + int_2 = 0"</code>: Is the sum of two intercepts zero?
</p>
</li>
<li> <p><code>"`cp_1_id[John]`/`cp_1_id[Erin]` = 2"</code>: is the varying change
point for John (which is relative to 'cp_1&ldquo;) double that of Erin?
</p>
</li></ul>
</td></tr>
<tr><td><code id="hypothesis_+3A_width">width</code></td>
<td>
<p>Float. The width of the highest posterior density interval
(between 0 and 1).</p>
</td></tr>
<tr><td><code id="hypothesis_+3A_digits">digits</code></td>
<td>
<p>a non-null value for digits specifies the minimum number of
significant digits to be printed in values. The default, NULL, uses
getOption(&quot;digits&quot;). (For the interpretation for complex numbers see signif.)
Non-integer values will be rounded down, and only values greater than or
equal to 1 and no greater than 22 are accepted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with a row per hypothesis and the following columns:
</p>

<ul>
<li> <p><code>hypothesis</code> is the hypothesis; often re-arranged to test against zero.
</p>
</li>
<li> <p><code>mean</code> is the posterior mean of the left-hand side of the hypothesis.
</p>
</li>
<li> <p><code>lower</code> is the lower bound of the (two-sided) highest-density interval of width <code>width</code>.
</p>
</li>
<li> <p><code>upper</code> is the upper bound of ditto.
</p>
</li>
<li> <p><code>p</code> Posterior probability.
For &quot;=&quot; (Savage-Dickey), it is the BF converted to p.
For directional hypotheses, it is the proportion of samples that returns TRUE.
</p>
</li>
<li> <p><code>BF</code> Bayes Factor in favor  of the hypothesis.
For &quot;=&quot; it is the Savage-Dickey density ratio.
For directional hypotheses, it is p converted to odds.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='ilogit'>Inverse logit function</h2><span id='topic+ilogit'></span>

<h3>Description</h3>

<p>Inverse logit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ilogit(eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ilogit_+3A_eta">eta</code></td>
<td>
<p>A vector of logits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with same length as <code>eta</code>
</p>

<hr>
<h2 id='is.mcpfit'>Checks if argument is an <code>mcpfit</code> object</h2><span id='topic+is.mcpfit'></span>

<h3>Description</h3>

<p>Checks if argument is an <code>mcpfit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mcpfit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mcpfit_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='logit'>Logit function</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Logit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_mu">mu</code></td>
<td>
<p>A vector of probabilities (0.0 to 1.0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with same length as <code>mu</code>
</p>

<hr>
<h2 id='mcmclist_samples'>Internal function to get samples.</h2><span id='topic+mcmclist_samples'></span><span id='topic+mcmclist_samples.mcpfit'></span>

<h3>Description</h3>

<p>Returns posterior samples, if available. If not, then prior samples. If not,
then throw an informative error. This is useful for summary and plotting, that
works on both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmclist_samples(fit, prior = FALSE, message = TRUE, error = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmclist_samples_+3A_fit">fit</code></td>
<td>
<p>An <code><a href="#topic+mcpfit">mcpfit</a></code> object</p>
</td></tr>
<tr><td><code id="mcmclist_samples_+3A_prior">prior</code></td>
<td>
<p>TRUE/FALSE. Summarise prior instead of posterior?</p>
</td></tr>
<tr><td><code id="mcmclist_samples_+3A_message">message</code></td>
<td>
<p>TRUE: gives a message if returning prior samples. FALSE = no message</p>
</td></tr>
<tr><td><code id="mcmclist_samples_+3A_error">error</code></td>
<td>
<p>TRUE: err if there are no samples. FALSE: return NULL</p>
</td></tr>
</table>

<hr>
<h2 id='mcp'>Fit Multiple Linear Segments And Their Change Points</h2><span id='topic+mcp'></span>

<h3>Description</h3>

<p>Given a model (a list of segment formulas), <code>mcp</code> infers the posterior
distributions of the parameters of each segment as well as the change points
between segments. <a href="https://lindeloev.github.io/mcp/">See more details and worked examples on the mcp website</a>.
All segments must regress on the same x-variable. Change
points are forced to be ordered using truncation of the priors. You can run
<code>fit = mcp(model, sample=FALSE)</code> to avoid sampling and the need for
data if you just want to get the priors (<code>fit$prior</code>), the JAGS code
<code>fit$jags_code</code>, or the R function to simulate data (<code>fit$simulate</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcp(
  model,
  data = NULL,
  prior = list(),
  family = gaussian(),
  par_x = NULL,
  sample = "post",
  cores = 1,
  chains = 3,
  iter = 3000,
  adapt = 1500,
  inits = NULL,
  jags_code = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcp_+3A_model">model</code></td>
<td>
<p>A list of formulas - one for each segment. The first formula
has the format <code>response ~ predictors</code> while the following formulas
have the format <code>response ~ changepoint ~ predictors</code>. The response
and change points can be omitted (<code>changepoint ~ predictors</code> assumes same
response. <code>~ predictors</code> assumes an intercept-only change point). The
following can be modeled:
</p>

<ul>
<li> <p><em>Regular formulas:</em> e.g., <code>~ 1 + x</code>). <a href="https://lindeloev.github.io/mcp/articles/formulas.html">Read more</a>.
</p>
</li>
<li> <p><em>Extended formulas:</em>, e.g., <code>~ I(x^2) + exp(x) + sin(x)</code>. <a href="https://lindeloev.github.io/mcp/articles/formulas.html">Read more</a>.
</p>
</li>
<li> <p><em>Variance:</em> e.g., <code>~sigma(1)</code> for a simple variance change or
<code>~sigma(rel(1) + I(x^2))</code>) for more advanced variance structures. <a href="https://lindeloev.github.io/mcp/articles/variance.html">Read more</a>
</p>
</li>
<li> <p><em>Autoregression:</em> e.g., <code>~ar(1)</code> for a simple onset/change in AR(1) or
<code style="white-space: pre;">&#8288;ar(2, 0 + x&#8288;</code>) for an AR(2) increasing by <code>x</code>. <a href="https://lindeloev.github.io/mcp/articles/arma.html">Read more</a>
</p>
</li></ul>
</td></tr>
<tr><td><code id="mcp_+3A_data">data</code></td>
<td>
<p>Data.frame or tibble in long format.</p>
</td></tr>
<tr><td><code id="mcp_+3A_prior">prior</code></td>
<td>
<p>Named list. Names are parameter names (<code>cp_i</code>, <code>int_i</code>, <code>xvar_i</code>,
'sigma&ldquo;) and the values are either
</p>

<ul>
<li><p> A JAGS distribution (e.g., <code>int_1 = "dnorm(0, 1) T(0,)"</code>) indicating a
conventional prior distribution. Uninformative priors based on data
properties are used where priors are not specified. This ensures good
parameter estimations, but it is a questionable for hypothesis testing.
<code>mcp</code> uses SD (not precision) for dnorm, dt, dlogis, etc. See
details. Change points are forced to be ordered through the priors using
truncation, except for uniform priors where the lower bound should be
greater than the previous change point, <code>dunif(cp_1, MAXX)</code>.
</p>
</li>
<li><p> A numerical value (e.g., <code>int_1 = -2.1</code>) indicating a fixed value.
</p>
</li>
<li><p> A model parameter name (e.g., <code>int_2 = "int_1"</code>), indicating that this parameter is shared -
typically between segments. If two varying effects are shared this way,
they will need to have the same grouping variable.
</p>
</li>
<li><p> A scaled Dirichlet prior is supported for change points if they are all set to
<code style="white-space: pre;">&#8288;cp_i = "dirichlet(N)&#8288;</code> where <code>N</code> is the alpha for this change point and
<code>N = 1</code> is most often used. This prior is less informative about the
location of the change points than the default uniform prior, but it
samples less efficiently, so you will often need to set <code>iter</code> higher.
It is recommended for hypothesis testing and for the estimation of more
than 5 change points. <a href="https://lindeloev.github.io/mcp/articles/priors.html">Read more</a>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mcp_+3A_family">family</code></td>
<td>
<p>One of <code>gaussian()</code>, <code>binomial()</code>, <code>bernoulli()</code>, or <code>poission()</code>.
Only default link functions are currently supported.</p>
</td></tr>
<tr><td><code id="mcp_+3A_par_x">par_x</code></td>
<td>
<p>String (default: NULL). Only relevant if no segments contains
slope (no hint at what x is). Set this, e.g., par_x = &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="mcp_+3A_sample">sample</code></td>
<td>
<p>One of
</p>

<ul>
<li> <p><code>"post"</code>: Sample the posterior.
</p>
</li>
<li> <p><code>"prior"</code>: Sample only the prior. Plots, summaries, etc. will
use the prior. This is useful for prior predictive checks.
</p>
</li>
<li> <p><code>"both"</code>: Sample both prior and posterior. Plots, summaries, etc.
will default to using the posterior. The prior only has effect when doing
Savage-Dickey density ratios in <code><a href="#topic+hypothesis">hypothesis</a></code>.
</p>
</li>
<li> <p><code>"none"</code> or <code>FALSE</code>: Do not sample. Returns an mcpfit
object without sample. This is useful if you only want to check
prior strings (fit$prior), the JAGS model (fit$jags_code), etc.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mcp_+3A_cores">cores</code></td>
<td>
<p>Positive integer or &quot;all&quot;. Number of cores.
</p>

<ul>
<li> <p><code>1</code>: serial sampling. <code>options(mc.cores = 3)</code> will dominate <code>cores = 1</code>
but not larger values of <code>cores</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;&gt;1&#8288;</code>: parallel sampling on this number of cores. Ideally set <code>chains</code>
to the same value. Note: <code>cores &gt; 1</code> takes a few extra seconds the first
time it's called but subsequent calls will start sampling immediately.
</p>
</li>
<li> <p><code>"all"</code>: use all cores but one and sets <code>chains</code> to the same value. This is
a convenient way to maximally use your computer's power.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mcp_+3A_chains">chains</code></td>
<td>
<p>Positive integer. Number of chains to run.</p>
</td></tr>
<tr><td><code id="mcp_+3A_iter">iter</code></td>
<td>
<p>Positive integer. Number of post-warmup draws from each chain.
The total number of draws is <code>iter * chains</code>.</p>
</td></tr>
<tr><td><code id="mcp_+3A_adapt">adapt</code></td>
<td>
<p>Positive integer. Also sometimes called &quot;burnin&quot;, this is the
number of samples used to reach convergence. Set lower for greater speed.
Set higher if the chains haven't converged yet or look at <a href="https://lindeloev.github.io/mcp/articles/tips.html">tips, tricks, and debugging</a>.</p>
</td></tr>
<tr><td><code id="mcp_+3A_inits">inits</code></td>
<td>
<p>A list if initial values for the parameters. This can be useful
if a model fails to converge. Read more in <code><a href="rjags.html#topic+jags.model">jags.model</a></code>.
Defaults to <code>NULL</code>, i.e., no inits.</p>
</td></tr>
<tr><td><code id="mcp_+3A_jags_code">jags_code</code></td>
<td>
<p>String. Pass JAGS code to <code>mcp</code> to use directly. This is useful if
you want to tweak the code in <code>fit$jags_code</code> and run it within the <code>mcp</code>
framework.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notes on priors:
</p>

<ul>
<li><p> Order restriction is automatically applied to cp_\* parameters using
truncation (e.g., <code>T(cp_1, )</code>) so that they are in the correct order on the
x-axis UNLESS you do it yourself. The one exception is for dunif
distributions where you have to do it as above.
</p>
</li>
<li><p> In addition to the model parameters, <code>MINX</code> (minimum x-value), <code>MAXX</code>
(maximum x-value), <code>SDX</code> (etc...), <code>MINY</code>, <code>MAXY</code>, and <code>SDY</code>
are also available when you set priors. They are used to set uninformative
default priors.
</p>
</li>
<li><p> Use SD when you specify priors for dt, dlogis, etc. JAGS uses precision
but <code>mcp</code> converts to precision under the hood via the sd_to_prec()
function. So you will see SDs in <code>fit$prior</code> but precision ($1/SD^2)
in <code>fit$jags_code</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An <code><a href="#topic+mcpfit">mcpfit</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_segment_table">get_segment_table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the segments using formulas. A change point is estimated between each formula.
model = list(
  response ~ 1,  # Plateau in the first segment (int_1)
  ~ 0 + time,    # Joined slope (time_2) at cp_1
  ~ 1 + time     # Disjoined slope (int_3, time_3) at cp_2
)

# Fit it and sample the prior too.
# options(mc.cores = 3)  # Uncomment to speed up sampling
ex = mcp_example("demo")  # Simulated data example
demo_fit = mcp(model, data = ex$data, sample = "both")

# See parameter estimates
summary(demo_fit)

# Visual inspection of the results
plot(demo_fit)  # Visualization of model fit/predictions
plot_pars(demo_fit)  # Parameter distributions
pp_check(demo_fit)  # Prior/Posterior predictive checks

# Test a hypothesis
hypothesis(demo_fit, "cp_1 &gt; 10")

# Make predictions
fitted(demo_fit)
predict(demo_fit)
predict(demo_fit, newdata = data.frame(time = c(55.545, 80, 132)))

# Compare to a one-intercept-only model (no change points) with default prior
model_null = list(response ~ 1)
fit_null = mcp(model_null, data = ex$data, par_x = "time")  # fit another model here
demo_fit$loo = loo(demo_fit)
fit_null$loo = loo(fit_null)
loo::loo_compare(demo_fit$loo, fit_null$loo)

# Inspect the prior. Useful for prior predictive checks.
summary(demo_fit, prior = TRUE)
plot(demo_fit, prior = TRUE)

# Show all priors. Default priors are added where you don't provide any
print(demo_fit$prior)

# Set priors and re-run
prior = list(
  int_1 = 15,
  time_2 = "dt(0, 2, 1) T(0, )",  # t-dist slope. Truncated to positive.
  cp_2 = "dunif(cp_1, 80)",    # change point to segment 2 &gt; cp_1 and &lt; 80.
  int_3 = "int_1"           # Shared intercept between segment 1 and 3
)

fit3 = mcp(model, data = ex$data, prior = prior)

# Show the JAGS model
demo_fit$jags_code


</code></pre>

<hr>
<h2 id='mcp_example'>Get example models and data</h2><span id='topic+mcp_example'></span>

<h3>Description</h3>

<p>Get example models and data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcp_example(name, sample = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcp_example_+3A_name">name</code></td>
<td>
<p>Name of the example. One of:
</p>

<ul>
<li> <p><code>"demo"</code>: Two change points between intercepts and joined/disjoined slopes.
</p>
</li>
<li> <p><code>"ar"</code>: One change point in autoregressive residuals.
</p>
</li>
<li> <p><code>"binomial"</code>: Binomial with two change points. Much like <code>"demo"</code> on a logit scale.
</p>
</li>
<li> <p><code>"intercepts"</code>: An intercept-only change point.
</p>
</li>
<li> <p><code>rel_prior</code>: Relative parameterization and informative priors.
</p>
</li>
<li> <p><code>"quadratic"</code>: A change point to a quadratic segment.
</p>
</li>
<li> <p><code>"trigonometric"</code>: Trigonometric/seasonal data and model.
</p>
</li>
<li> <p><code>"varying"</code>: Varying / hierarchical change points.
</p>
</li>
<li> <p><code>"variance"</code>: A change in variance, including a variance slope.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mcp_example_+3A_sample">sample</code></td>
<td>
<p>TRUE (run <code>fit = mcp(model, data, ...)</code>) or FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with
</p>

<ul>
<li> <p><code>model</code>: A list of formulas
</p>
</li>
<li> <p><code>data</code>: The simulated data
</p>
</li>
<li> <p><code>simulated</code>: The parameters used for simulating the data.
</p>
</li>
<li> <p><code>fit</code>: an <code>mcpfit</code> if <code>sample = TRUE</code>,
</p>
</li>
<li> <p><code>call</code>: the code to run the above.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex = mcp_example("demo")
plot(ex$data)  # Plot data
print(ex$simulated)  # See true parameters used to simulate
print(ex$call)  # See how the data was simulated

# Fit the model. Either...
fit = mcp(ex$model, ex$data)
plot(fit)

ex_with_fit = mcp_example("demo", sample = TRUE)
plot(ex_with_fit$fit)

</code></pre>

<hr>
<h2 id='mcpfamily'>Add A family object to store link functions between R and JAGS.</h2><span id='topic+mcpfamily'></span>

<h3>Description</h3>

<p>This will make more sense once more link functions / families are added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcpfamily(family)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcpfamily_+3A_family">family</code></td>
<td>
<p>A family object, e.g., <code>binomial(link = "identity")</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='mcpfit-class'>Class <code>mcpfit</code> of models fitted with the <span class="pkg">mcp</span> package</h2><span id='topic+mcpfit-class'></span><span id='topic+mcpfit'></span>

<h3>Description</h3>

<p>Models fitted with the <code><a href="#topic+mcp">mcp</a></code> function are represented as
an <code>mcpfit</code> object which contains the user input (model, data, family),
derived model characteristics (prior, parameter names, and jags code), and
the fit (prior and/or posterior mcmc samples).
</p>


<h3>Details</h3>

<p>See <code>methods(class = "mcpfit")</code> for an overview of available methods.
</p>
<p>User-provided information (see <code><a href="#topic+mcp">mcp</a></code> for more details):
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>A list of formulas, making up the model.
Provided by user. See <code><a href="#topic+mcp">mcp</a></code> for more details.</p>
</dd>
<dt><code>data</code></dt><dd><p>A data frame.
Provided by user. See <code><a href="#topic+mcp">mcp</a></code> for more details.</p>
</dd>
<dt><code>family</code></dt><dd><p>An <code>mcpfamily</code> object.
Provided by user. See <code><a href="#topic+mcp">mcp</a></code> for more details.</p>
</dd>
<dt><code>prior</code></dt><dd><p>A named list.
Provided by user. See <code><a href="#topic+mcp">mcp</a></code> for more details.</p>
</dd>
<dt><code>mcmc_post</code></dt><dd><p>An <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object with posterior samples.</p>
</dd>
<dt><code>mcmc_prior</code></dt><dd><p>An <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object with prior samples.</p>
</dd>
<dt><code>mcmc_loglik</code></dt><dd><p>An <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object with samples of log-likelihood.</p>
</dd>
<dt><code>pars</code></dt><dd><p>A list of character vectors of model parameter names.</p>
</dd>
<dt><code>jags_code</code></dt><dd><p>A string with jags code. Use <code>cat(fit$jags_code)</code> to show it.</p>
</dd>
<dt><code>simulate</code></dt><dd><p>A method to simulate and predict data.</p>
</dd>
<dt><code>.other</code></dt><dd><p>Information that is used internally by mcp.</p>
</dd>
</dl>

<hr>
<h2 id='negbinomial'>Negative binomial for mcp</h2><span id='topic+negbinomial'></span>

<h3>Description</h3>

<p>Parameterized as <code>mu</code> (mean; poisson lambda) and <code>size</code> (a shape parameter),
so you can do <code>rnbinom(10, mu = 10, size = 1)</code>. Read more in the doc for <code>rnbinom</code>,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negbinomial(link = "log")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negbinomial_+3A_link">link</code></td>
<td>
<p>Link function (Character).</p>
</td></tr>
</table>

<hr>
<h2 id='phi'>Inverse probit function</h2><span id='topic+phi'></span>

<h3>Description</h3>

<p>Inverse probit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi(eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phi_+3A_eta">eta</code></td>
<td>
<p>A vector of probits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with same length as <code>mu</code>
</p>

<hr>
<h2 id='plot_pars'>Plot individual parameters</h2><span id='topic+plot_pars'></span>

<h3>Description</h3>

<p>Plot many types of plots of parameter estimates. See examples for typical use
cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pars(
  fit,
  pars = "population",
  regex_pars = character(0),
  type = "combo",
  ncol = 1,
  prior = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pars_+3A_fit">fit</code></td>
<td>
<p>An <code><a href="#topic+mcpfit">mcpfit</a></code> object.</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_pars">pars</code></td>
<td>
<p>Character vector. One of:
</p>

<ul>
<li><p> Vector of parameter names.
</p>
</li>
<li> <p><code>"population"</code> plots all population parameters.
</p>
</li>
<li> <p><code>"varying"</code> plots all varying effects. To plot a particular varying
effect, use <code>regex_pars = "^name"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_pars_+3A_regex_pars">regex_pars</code></td>
<td>
<p>Vector of regular expressions. This will typically just be
the beginning of the parameter name(s), i.e., &quot;^cp_&quot; plots all change
points, &quot;^my_varying&quot; plots all levels of a particular varying effect, and
&quot;^cp_|^my_varying&quot; plots both.</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_type">type</code></td>
<td>
<p>String or vector of strings. Calls <code style="white-space: pre;">&#8288;bayesplot::mcmc_&gt;&gt;type&lt;&lt;()&#8288;</code>.
Common calls are &quot;combo&quot;, &quot;trace&quot;, and &quot;dens_overlay&quot;. Current options include
'acf', 'acf_bar', 'areas', 'areas_ridges', 'combo', 'dens', 'dens_chains',
'dens_overlay', 'hist', 'intervals', 'rank_hist', 'rank_overlay', 'trace',
'trace_highlight', and 'violin&quot;.</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns in plot. This is useful when you have many
parameters and only one plot <code>type</code>.</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_prior">prior</code></td>
<td>
<p>TRUE/FALSE. Plot using prior samples? Useful for <code>mcp(..., sample = "both")</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For other <code>type</code>, it calls <code>bayesplot::mcmc_type()</code>. Use these
directly on <code>fit$mcmc_post</code> or <code>fit$mcmc_prior</code> if you want finer
control of plotting, e.g., <code>bayesplot::mcmc_dens(fit$mcmc_post)</code>. There
are also a number of useful plots in the <span class="pkg">coda</span> package, i.e.,
<code>coda::gelman.plot(fit$mcmc_post)</code> and <code>coda::crosscorr.plot(fit$mcmc_post)</code>
</p>
<p>In any case, if you see a few erratic lines or parameter estimates, this is
a sign that you may want to increase argument 'adapt' and 'iter' in <code><a href="#topic+mcp">mcp</a></code>.
</p>


<h3>Value</h3>

<p>A <span class="pkg">ggplot2</span> object.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Typical usage. demo_fit is an mcpfit object.
plot_pars(demo_fit)

## Not run: 
# More options
plot_pars(demo_fit, regex_pars = "^cp_")  # Plot only change points
plot_pars(demo_fit, pars = c("int_3", "time_3"))  # Plot these parameters
plot_pars(demo_fit, type = c("trace", "violin"))  # Combine plots
# Some plots only take pairs. hex is good to assess identifiability
plot_pars(demo_fit, type = "hex", pars = c("cp_1", "time_2"))

# Visualize the priors:
plot_pars(demo_fit, prior = TRUE)

# Useful for varying effects:
# plot_pars(my_fit, pars = "varying", ncol = 3)  # plot all varying effects
# plot_pars(my_fit, regex_pars = "my_varying", ncol = 3)  # plot all levels of a particular varying

# Customize multi-column ggplots using "*" instead of "+" (patchwork)
library(ggplot2)
plot_pars(demo_fit, type = c("trace", "dens_overlay")) * theme_bw(10)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.mcpfit'>Plot full fits</h2><span id='topic+plot.mcpfit'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p>Plot prior or posterior model draws on top of data. Use <code>plot_pars</code> to
plot individual parameter estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcpfit'
plot(
  x,
  facet_by = NULL,
  lines = 25,
  geom_data = "point",
  cp_dens = TRUE,
  q_fit = FALSE,
  q_predict = FALSE,
  rate = TRUE,
  prior = FALSE,
  which_y = "ct",
  arma = TRUE,
  nsamples = 2000,
  scale = "response",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mcpfit_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+mcpfit">mcpfit</a></code> object</p>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_facet_by">facet_by</code></td>
<td>
<p>String. Name of a varying group.</p>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_lines">lines</code></td>
<td>
<p>Positive integer or <code>FALSE</code>. Number of lines (posterior
draws). FALSE or <code>lines = 0</code> plots no lines. Note that lines always plot
fitted values - not predicted. For prediction intervals, see the <code>q_predict</code> argument.</p>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_geom_data">geom_data</code></td>
<td>
<p>String. One of &quot;point&quot;, &quot;line&quot; (good for time-series),
or FALSE (don not plot).</p>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_cp_dens">cp_dens</code></td>
<td>
<p>TRUE/FALSE. Plot posterior densities of the change point(s)?
Currently does not respect <code>facet_by</code>. This will be added in the future.</p>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_q_fit">q_fit</code></td>
<td>
<p>Whether to plot quantiles of the posterior (fitted value).
</p>

<ul>
<li> <p><code>TRUE</code> Add 2.5% and 97.5% quantiles. Corresponds to
<code>q_fit = c(0.025, 0.975)</code>.
</p>
</li>
<li> <p><code>FALSE</code> No quantiles
</p>
</li>
<li><p> A vector of quantiles. For example, <code>quantiles = 0.5</code>
plots the median and <code>quantiles = c(0.2, 0.8)</code> plots the 20% and 80%
quantiles.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_q_predict">q_predict</code></td>
<td>
<p>Same as <code>q_fit</code>, but for the prediction interval.</p>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_rate">rate</code></td>
<td>
<p>Boolean. For binomial models, plot on raw data (<code>rate = FALSE</code>) or
response divided by number of trials (<code>rate = TRUE</code>). If FALSE, linear
interpolation on trial number is used to infer trials at a particular x.</p>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_prior">prior</code></td>
<td>
<p>TRUE/FALSE. Plot using prior samples? Useful for <code>mcp(..., sample = "both")</code></p>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_which_y">which_y</code></td>
<td>
<p>What to plot on the y-axis. One of
</p>

<ul>
<li> <p><code>"ct"</code>: The central tendency which is often the mean after applying the
link function.
</p>
</li>
<li> <p><code>"sigma"</code>: The variance
</p>
</li>
<li> <p><code>"ar1"</code>, <code>"ar2"</code>, etc. depending on which order of the autoregressive
effects you want to plot.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_arma">arma</code></td>
<td>
<p>Whether to include autoregressive effects.
</p>

<ul>
<li> <p><code>TRUE</code> Compute autoregressive residuals. Requires the response variable in <code>newdata</code>.
</p>
</li>
<li> <p><code>FALSE</code> Disregard the autoregressive effects. For <code>family = gaussian()</code>, <code>predict()</code> just use <code>sigma</code> for residuals.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_nsamples">nsamples</code></td>
<td>
<p>Integer or <code>NULL</code>. Number of samples to return/summarise.
If there are varying effects, this is the number of samples from each varying group.
<code>NULL</code> means &quot;all&quot;. Ignored if both are <code>FALSE</code>. More samples trade speed for accuracy.</p>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_scale">scale</code></td>
<td>
<p>One of
</p>

<ul>
<li><p> &quot;response&quot;: return on the observed scale, i.e., after applying the inverse link function.
</p>
</li>
<li><p> &quot;linear&quot;: return on the parameter scale (where the linear trends are modelled).
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.mcpfit_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot()</code> uses <code>fit$simulate()</code> on posterior samples. These represent the
(joint) posterior distribution.
</p>


<h3>Value</h3>

<p>A <span class="pkg">ggplot2</span> object.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Typical usage. demo_fit is an mcpfit object.
plot(demo_fit)

plot(demo_fit, prior = TRUE)  # The prior

plot(demo_fit, lines = 0, q_fit = TRUE)  # 95% HDI without lines
plot(demo_fit, q_predict = c(0.1, 0.9))  # 80% prediction interval
plot(demo_fit, which_y = "sigma", lines = 100)  # The variance parameter on y

# Show a panel for each varying effect
# plot(fit, facet_by = "my_column")

# Customize plots using regular ggplot2
library(ggplot2)
plot(demo_fit) + theme_bw(15) + ggtitle("Great plot!")


</code></pre>

<hr>
<h2 id='pp_check'>Posterior Predictive Checks For Mcpfit Objects</h2><span id='topic+pp_check'></span><span id='topic+pp_check.mcpfit'></span>

<h3>Description</h3>

<p>Plot posterior (default) or prior (<code>prior = TRUE</code>) predictive checks. This is convenience wrapper
around the <code style="white-space: pre;">&#8288;bayesplot::ppc_*()&#8288;</code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_check(
  object,
  type = "dens_overlay",
  facet_by = NULL,
  newdata = NULL,
  prior = FALSE,
  varying = TRUE,
  arma = TRUE,
  nsamples = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_check_+3A_object">object</code></td>
<td>
<p>An <code>mcpfit</code> object.</p>
</td></tr>
<tr><td><code id="pp_check_+3A_type">type</code></td>
<td>
<p>One of <code>bayesplot::available_ppc("grouped", invert = TRUE) %&gt;% stringr::str_remove("ppc_")</code></p>
</td></tr>
<tr><td><code id="pp_check_+3A_facet_by">facet_by</code></td>
<td>
<p>Name of a column in data modeled as varying effect(s).</p>
</td></tr>
<tr><td><code id="pp_check_+3A_newdata">newdata</code></td>
<td>
<p>A <code>tibble</code> or a <code>data.frame</code> containing predictors in the model. If <code>NULL</code> (default),
the original data is used.</p>
</td></tr>
<tr><td><code id="pp_check_+3A_prior">prior</code></td>
<td>
<p>TRUE/FALSE. Plot using prior samples? Useful for <code>mcp(..., sample = "both")</code></p>
</td></tr>
<tr><td><code id="pp_check_+3A_varying">varying</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>TRUE</code> All varying effects (<code>fit$pars$varying</code>).
</p>
</li>
<li> <p><code>FALSE</code> No varying effects (<code>c()</code>).
</p>
</li>
<li><p> Character vector: Only include specified varying parameters - see <code>fit$pars$varying</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pp_check_+3A_arma">arma</code></td>
<td>
<p>Whether to include autoregressive effects.
</p>

<ul>
<li> <p><code>TRUE</code> Compute autoregressive residuals. Requires the response variable in <code>newdata</code>.
</p>
</li>
<li> <p><code>FALSE</code> Disregard the autoregressive effects. For <code>family = gaussian()</code>, <code>predict()</code> just use <code>sigma</code> for residuals.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pp_check_+3A_nsamples">nsamples</code></td>
<td>
<p>Number of draws. Note that you may want to use all data for summary geoms.
e.g., <code>pp_check(fit, type = "ribbon", nsamples = NULL)</code>.</p>
</td></tr>
<tr><td><code id="pp_check_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>bayesplot::ppc_type(y, yrep, ...)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object for single plots. Enriched by <code>patchwork</code> for faceted plots.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.mcpfit">plot.mcpfit</a></code> <code><a href="#topic+pp_eval">pp_eval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pp_check(demo_fit)
pp_check(demo_fit, type = "ecdf_overlay")
#pp_check(some_varying_fit, type = "loo_intervals", facet_by = "id")


</code></pre>

<hr>
<h2 id='pp_eval'>Fits and predictions from samples and newdata</h2><span id='topic+pp_eval'></span><span id='topic+pp_eval.mcpfit'></span>

<h3>Description</h3>

<p>Fits and predictions from samples and newdata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_eval(
  object,
  newdata = NULL,
  summary = TRUE,
  type = "fitted",
  probs = TRUE,
  rate = TRUE,
  prior = FALSE,
  which_y = "ct",
  varying = TRUE,
  arma = TRUE,
  nsamples = NULL,
  samples_format = "tidy",
  scale = "response",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_eval_+3A_object">object</code></td>
<td>
<p>An <code>mcpfit</code> object.</p>
</td></tr>
<tr><td><code id="pp_eval_+3A_newdata">newdata</code></td>
<td>
<p>A <code>tibble</code> or a <code>data.frame</code> containing predictors in the model. If <code>NULL</code> (default),
the original data is used.</p>
</td></tr>
<tr><td><code id="pp_eval_+3A_summary">summary</code></td>
<td>
<p>Summarise at each x-value</p>
</td></tr>
<tr><td><code id="pp_eval_+3A_type">type</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> &quot;fitted&quot;: return fitted values. See also <code>fitted()</code>
</p>
</li>
<li><p> &quot;predict&quot;: return predicted values, using random dispersion around the central tendency
(e.g., <code>y_predict = rnorm(N, y_fitted, sigma_fitted)</code> for <code>family = gaussian()</code>).
See also <code>predict()</code>.
</p>
</li>
<li><p> &quot;residuals&quot;: same as &quot;predict&quot; but the observed y-values are subtracted. See also <code>residuals()</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="pp_eval_+3A_probs">probs</code></td>
<td>
<p>Vector of quantiles. Only in effect when <code>summary == TRUE</code>.</p>
</td></tr>
<tr><td><code id="pp_eval_+3A_rate">rate</code></td>
<td>
<p>Boolean. For binomial models, plot on raw data (<code>rate = FALSE</code>) or
response divided by number of trials (<code>rate = TRUE</code>). If FALSE, linear
interpolation on trial number is used to infer trials at a particular x.</p>
</td></tr>
<tr><td><code id="pp_eval_+3A_prior">prior</code></td>
<td>
<p>TRUE/FALSE. Plot using prior samples? Useful for <code>mcp(..., sample = "both")</code></p>
</td></tr>
<tr><td><code id="pp_eval_+3A_which_y">which_y</code></td>
<td>
<p>What to plot on the y-axis. One of
</p>

<ul>
<li> <p><code>"ct"</code>: The central tendency which is often the mean after applying the
link function.
</p>
</li>
<li> <p><code>"sigma"</code>: The variance
</p>
</li>
<li> <p><code>"ar1"</code>, <code>"ar2"</code>, etc. depending on which order of the autoregressive
effects you want to plot.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pp_eval_+3A_varying">varying</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>TRUE</code> All varying effects (<code>fit$pars$varying</code>).
</p>
</li>
<li> <p><code>FALSE</code> No varying effects (<code>c()</code>).
</p>
</li>
<li><p> Character vector: Only include specified varying parameters - see <code>fit$pars$varying</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pp_eval_+3A_arma">arma</code></td>
<td>
<p>Whether to include autoregressive effects.
</p>

<ul>
<li> <p><code>TRUE</code> Compute autoregressive residuals. Requires the response variable in <code>newdata</code>.
</p>
</li>
<li> <p><code>FALSE</code> Disregard the autoregressive effects. For <code>family = gaussian()</code>, <code>predict()</code> just use <code>sigma</code> for residuals.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pp_eval_+3A_nsamples">nsamples</code></td>
<td>
<p>Integer or <code>NULL</code>. Number of samples to return/summarise.
If there are varying effects, this is the number of samples from each varying group.
<code>NULL</code> means &quot;all&quot;. Ignored if both are <code>FALSE</code>. More samples trade speed for accuracy.</p>
</td></tr>
<tr><td><code id="pp_eval_+3A_samples_format">samples_format</code></td>
<td>
<p>One of &quot;tidy&quot; or &quot;matrix&quot;. Controls the output format when <code>summary == FALSE</code>.
See more under &quot;value&quot;</p>
</td></tr>
<tr><td><code id="pp_eval_+3A_scale">scale</code></td>
<td>
<p>One of
</p>

<ul>
<li><p> &quot;response&quot;: return on the observed scale, i.e., after applying the inverse link function.
</p>
</li>
<li><p> &quot;linear&quot;: return on the parameter scale (where the linear trends are modelled).
</p>
</li></ul>
</td></tr>
<tr><td><code id="pp_eval_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> If <code>summary = TRUE</code>: A <code>tibble</code> with the posterior mean for each row in <code>newdata</code>,
If <code>newdata</code> is <code>NULL</code>, the data in <code>fit$data</code> is used.
</p>
</li>
<li><p> If <code>summary = FALSE</code> and <code>samples_format = "tidy"</code>: A <code>tidybayes</code> <code>tibble</code> with all the posterior
samples (<code>Ns</code>) evaluated at each row in <code>newdata</code> (<code>Nn</code>), i.e., with <code style="white-space: pre;">&#8288;Ns x Nn&#8288;</code> rows. If there are
varying effects, the returned data is expanded with the relevant levels for each row.
</p>
<p>The return columns are:
</p>

<ul>
<li><p> Predictors from <code>newdata</code>.
</p>
</li>
<li><p> Sample descriptors: &quot;.chain&quot;, &quot;.iter&quot;, &quot;.draw&quot; (see the <code>tidybayes</code> package for more), and &quot;data_row&quot; (<code>newdata</code> rownumber)
</p>
</li>
<li><p> Sample values: one column for each parameter in the model.
</p>
</li>
<li><p> The estimate. Either &quot;predict&quot; or &quot;fitted&quot;, i.e., the name of the <code>type</code> argument.
</p>
</li></ul>

</li>
<li><p> If <code>summary = FALSE</code> and <code>samples_format = "matrix"</code>: An <code>N_draws</code> X <code>nrows(newdata)</code> matrix with fitted/predicted
values (depending on <code>type</code>). This format is used by <code>brms</code> and it's useful as <code>yrep</code> in
<code style="white-space: pre;">&#8288;bayesplot::ppc_*&#8288;</code> functions.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.mcpfit">fitted.mcpfit</a></code> <code><a href="#topic+predict.mcpfit">predict.mcpfit</a></code> <code><a href="#topic+residuals.mcpfit">residuals.mcpfit</a></code>
</p>

<hr>
<h2 id='predict.mcpfit'>Samples from the Posterior Predictive Distribution</h2><span id='topic+predict.mcpfit'></span><span id='topic+predict'></span>

<h3>Description</h3>

<p>Samples from the Posterior Predictive Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcpfit'
predict(
  object,
  newdata = NULL,
  summary = TRUE,
  probs = TRUE,
  rate = TRUE,
  prior = FALSE,
  which_y = "ct",
  varying = TRUE,
  arma = TRUE,
  nsamples = NULL,
  samples_format = "tidy",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mcpfit_+3A_object">object</code></td>
<td>
<p>An <code>mcpfit</code> object.</p>
</td></tr>
<tr><td><code id="predict.mcpfit_+3A_newdata">newdata</code></td>
<td>
<p>A <code>tibble</code> or a <code>data.frame</code> containing predictors in the model. If <code>NULL</code> (default),
the original data is used.</p>
</td></tr>
<tr><td><code id="predict.mcpfit_+3A_summary">summary</code></td>
<td>
<p>Summarise at each x-value</p>
</td></tr>
<tr><td><code id="predict.mcpfit_+3A_probs">probs</code></td>
<td>
<p>Vector of quantiles. Only in effect when <code>summary == TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.mcpfit_+3A_rate">rate</code></td>
<td>
<p>Boolean. For binomial models, plot on raw data (<code>rate = FALSE</code>) or
response divided by number of trials (<code>rate = TRUE</code>). If FALSE, linear
interpolation on trial number is used to infer trials at a particular x.</p>
</td></tr>
<tr><td><code id="predict.mcpfit_+3A_prior">prior</code></td>
<td>
<p>TRUE/FALSE. Plot using prior samples? Useful for <code>mcp(..., sample = "both")</code></p>
</td></tr>
<tr><td><code id="predict.mcpfit_+3A_which_y">which_y</code></td>
<td>
<p>What to plot on the y-axis. One of
</p>

<ul>
<li> <p><code>"ct"</code>: The central tendency which is often the mean after applying the
link function.
</p>
</li>
<li> <p><code>"sigma"</code>: The variance
</p>
</li>
<li> <p><code>"ar1"</code>, <code>"ar2"</code>, etc. depending on which order of the autoregressive
effects you want to plot.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.mcpfit_+3A_varying">varying</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>TRUE</code> All varying effects (<code>fit$pars$varying</code>).
</p>
</li>
<li> <p><code>FALSE</code> No varying effects (<code>c()</code>).
</p>
</li>
<li><p> Character vector: Only include specified varying parameters - see <code>fit$pars$varying</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.mcpfit_+3A_arma">arma</code></td>
<td>
<p>Whether to include autoregressive effects.
</p>

<ul>
<li> <p><code>TRUE</code> Compute autoregressive residuals. Requires the response variable in <code>newdata</code>.
</p>
</li>
<li> <p><code>FALSE</code> Disregard the autoregressive effects. For <code>family = gaussian()</code>, <code>predict()</code> just use <code>sigma</code> for residuals.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.mcpfit_+3A_nsamples">nsamples</code></td>
<td>
<p>Integer or <code>NULL</code>. Number of samples to return/summarise.
If there are varying effects, this is the number of samples from each varying group.
<code>NULL</code> means &quot;all&quot;. Ignored if both are <code>FALSE</code>. More samples trade speed for accuracy.</p>
</td></tr>
<tr><td><code id="predict.mcpfit_+3A_samples_format">samples_format</code></td>
<td>
<p>One of &quot;tidy&quot; or &quot;matrix&quot;. Controls the output format when <code>summary == FALSE</code>.
See more under &quot;value&quot;</p>
</td></tr>
<tr><td><code id="predict.mcpfit_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> If <code>summary = TRUE</code>: A <code>tibble</code> with the posterior mean for each row in <code>newdata</code>,
If <code>newdata</code> is <code>NULL</code>, the data in <code>fit$data</code> is used.
</p>
</li>
<li><p> If <code>summary = FALSE</code> and <code>samples_format = "tidy"</code>: A <code>tidybayes</code> <code>tibble</code> with all the posterior
samples (<code>Ns</code>) evaluated at each row in <code>newdata</code> (<code>Nn</code>), i.e., with <code style="white-space: pre;">&#8288;Ns x Nn&#8288;</code> rows. If there are
varying effects, the returned data is expanded with the relevant levels for each row.
</p>
<p>The return columns are:
</p>

<ul>
<li><p> Predictors from <code>newdata</code>.
</p>
</li>
<li><p> Sample descriptors: &quot;.chain&quot;, &quot;.iter&quot;, &quot;.draw&quot; (see the <code>tidybayes</code> package for more), and &quot;data_row&quot; (<code>newdata</code> rownumber)
</p>
</li>
<li><p> Sample values: one column for each parameter in the model.
</p>
</li>
<li><p> The estimate. Either &quot;predict&quot; or &quot;fitted&quot;, i.e., the name of the <code>type</code> argument.
</p>
</li></ul>

</li>
<li><p> If <code>summary = FALSE</code> and <code>samples_format = "matrix"</code>: An <code>N_draws</code> X <code>nrows(newdata)</code> matrix with fitted/predicted
values (depending on <code>type</code>). This format is used by <code>brms</code> and it's useful as <code>yrep</code> in
<code style="white-space: pre;">&#8288;bayesplot::ppc_*&#8288;</code> functions.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp_eval">pp_eval</a></code> <code><a href="#topic+fitted.mcpfit">fitted.mcpfit</a></code> <code><a href="#topic+residuals.mcpfit">residuals.mcpfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
predict(demo_fit)  # Evaluate at each demo_fit$data
predict(demo_fit, probs = c(0.1, 0.5, 0.9))  # With median and 80% credible interval.
predict(demo_fit, summary = FALSE)  # Samples instead of summary.
predict(
  demo_fit,
  newdata = data.frame(time = c(-5, 20, 300)),  # Evaluate
  probs = c(0.025, 0.5, 0.975)
)


</code></pre>

<hr>
<h2 id='print.mcplist'>Print mcplist</h2><span id='topic+print.mcplist'></span>

<h3>Description</h3>

<p>Shows a list in a more condensed format using <code>str(list)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcplist'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mcplist_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+mcpfit">mcpfit</a></code> object.</p>
</td></tr>
<tr><td><code id="print.mcplist_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='print.mcptext'>Nice printing texts</h2><span id='topic+print.mcptext'></span>

<h3>Description</h3>

<p>Useful for <code>print(fit$jags_code)</code>, <code>print(mcp_demo$call)</code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcptext'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mcptext_+3A_x">x</code></td>
<td>
<p>Character, often with newlines.</p>
</td></tr>
<tr><td><code id="print.mcptext_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mytext = "line1 = 2\n line2 = 'horse'"
class(mytext) = "mcptext"
print(mytext)
</code></pre>

<hr>
<h2 id='probit'>Probit function</h2><span id='topic+probit'></span>

<h3>Description</h3>

<p>Probit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probit(mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probit_+3A_mu">mu</code></td>
<td>
<p>A vector of probabilities (0.0 to 1.0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with same length as <code>mu</code>
</p>

<hr>
<h2 id='recover_levels'>Recover the levels of varying effects in mcmc.list</h2><span id='topic+recover_levels'></span>

<h3>Description</h3>

<p>Jags uses 1, 2, 3, ..., etc. for indexing of varying effects.
This function adds back the original levels, whether numeric or string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recover_levels(samples, data, mcmc_col, data_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recover_levels_+3A_samples">samples</code></td>
<td>
<p>An mcmc.list with varying columns starting in <code>mcmc_col</code>.</p>
</td></tr>
<tr><td><code id="recover_levels_+3A_data">data</code></td>
<td>
<p>A tibble or data.frame with the cols in <code>data_col</code>.</p>
</td></tr>
<tr><td><code id="recover_levels_+3A_mcmc_col">mcmc_col</code></td>
<td>
<p>A vector of strings.</p>
</td></tr>
<tr><td><code id="recover_levels_+3A_data_col">data_col</code></td>
<td>
<p>A vector of strings. Has to be same length as <code>mcmc_col</code>.'</p>
</td></tr>
</table>

<hr>
<h2 id='remove_terms'>Remove varying or population terms from a formula</h2><span id='topic+remove_terms'></span>

<h3>Description</h3>

<p>WARNING: removes response side from the formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_terms(form, remove)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_terms_+3A_form">form</code></td>
<td>
<p>A formula</p>
</td></tr>
<tr><td><code id="remove_terms_+3A_remove">remove</code></td>
<td>
<p>Either &quot;varying&quot; or &quot;population&quot;. These are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='residuals.mcpfit'>Compute Residuals From Mcpfit Objects</h2><span id='topic+residuals.mcpfit'></span><span id='topic+residuals'></span><span id='topic+resid'></span><span id='topic+resid.mcpfit'></span>

<h3>Description</h3>

<p>Equivalent to  <code>fitted(fit, ...) - fit$data[, fit$data$yvar]</code> (or <code>fitted(fit, ...) - newdata[, fit$data$yvar]</code>),
but with fixed arguments for <code>fitted</code>: <code style="white-space: pre;">&#8288;rate = FALSE, which_y = 'ct', samples_format = 'tidy'&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcpfit'
residuals(
  object,
  newdata = NULL,
  summary = TRUE,
  probs = TRUE,
  prior = FALSE,
  varying = TRUE,
  arma = TRUE,
  nsamples = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.mcpfit_+3A_object">object</code></td>
<td>
<p>An <code>mcpfit</code> object.</p>
</td></tr>
<tr><td><code id="residuals.mcpfit_+3A_newdata">newdata</code></td>
<td>
<p>A <code>tibble</code> or a <code>data.frame</code> containing predictors in the model. If <code>NULL</code> (default),
the original data is used.</p>
</td></tr>
<tr><td><code id="residuals.mcpfit_+3A_summary">summary</code></td>
<td>
<p>Summarise at each x-value</p>
</td></tr>
<tr><td><code id="residuals.mcpfit_+3A_probs">probs</code></td>
<td>
<p>Vector of quantiles. Only in effect when <code>summary == TRUE</code>.</p>
</td></tr>
<tr><td><code id="residuals.mcpfit_+3A_prior">prior</code></td>
<td>
<p>TRUE/FALSE. Plot using prior samples? Useful for <code>mcp(..., sample = "both")</code></p>
</td></tr>
<tr><td><code id="residuals.mcpfit_+3A_varying">varying</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>TRUE</code> All varying effects (<code>fit$pars$varying</code>).
</p>
</li>
<li> <p><code>FALSE</code> No varying effects (<code>c()</code>).
</p>
</li>
<li><p> Character vector: Only include specified varying parameters - see <code>fit$pars$varying</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="residuals.mcpfit_+3A_arma">arma</code></td>
<td>
<p>Whether to include autoregressive effects.
</p>

<ul>
<li> <p><code>TRUE</code> Compute autoregressive residuals. Requires the response variable in <code>newdata</code>.
</p>
</li>
<li> <p><code>FALSE</code> Disregard the autoregressive effects. For <code>family = gaussian()</code>, <code>predict()</code> just use <code>sigma</code> for residuals.
</p>
</li></ul>
</td></tr>
<tr><td><code id="residuals.mcpfit_+3A_nsamples">nsamples</code></td>
<td>
<p>Integer or <code>NULL</code>. Number of samples to return/summarise.
If there are varying effects, this is the number of samples from each varying group.
<code>NULL</code> means &quot;all&quot;. Ignored if both are <code>FALSE</code>. More samples trade speed for accuracy.</p>
</td></tr>
<tr><td><code id="residuals.mcpfit_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp_eval">pp_eval</a></code> <code><a href="#topic+fitted.mcpfit">fitted.mcpfit</a></code> <code><a href="#topic+predict.mcpfit">predict.mcpfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
residuals(demo_fit)
residuals(demo_fit, probs = c(0.1, 0.5, 0.9))  # With median and 80% credible interval.
residuals(demo_fit, summary = FALSE)  # Samples instead of summary.


</code></pre>

<hr>
<h2 id='run_jags'>Run parallel MCMC sampling using JAGS.</h2><span id='topic+run_jags'></span>

<h3>Description</h3>

<p>Run parallel MCMC sampling using JAGS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_jags(
  data,
  jags_code,
  pars,
  ST,
  cores,
  sample,
  n.chains,
  n.iter,
  n.adapt,
  inits
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_jags_+3A_data">data</code></td>
<td>
<p>Data.frame or tibble in long format.</p>
</td></tr>
<tr><td><code id="run_jags_+3A_jags_code">jags_code</code></td>
<td>
<p>A string. JAGS model, usually returned by <code>make_jagscode()</code>.</p>
</td></tr>
<tr><td><code id="run_jags_+3A_pars">pars</code></td>
<td>
<p>Character vector of parameters to save/monitor.</p>
</td></tr>
<tr><td><code id="run_jags_+3A_st">ST</code></td>
<td>
<p>A segment table (tibble), returned by <code>get_segment_table</code>.
Only really used when the model contains varying effects.</p>
</td></tr>
<tr><td><code id="run_jags_+3A_cores">cores</code></td>
<td>
<p>Positive integer or &quot;all&quot;. Number of cores.
</p>

<ul>
<li> <p><code>1</code>: serial sampling. <code>options(mc.cores = 3)</code> will dominate <code>cores = 1</code>
but not larger values of <code>cores</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;&gt;1&#8288;</code>: parallel sampling on this number of cores. Ideally set <code>chains</code>
to the same value. Note: <code>cores &gt; 1</code> takes a few extra seconds the first
time it's called but subsequent calls will start sampling immediately.
</p>
</li>
<li> <p><code>"all"</code>: use all cores but one and sets <code>chains</code> to the same value. This is
a convenient way to maximally use your computer's power.
</p>
</li></ul>
</td></tr>
<tr><td><code id="run_jags_+3A_sample">sample</code></td>
<td>
<p>One of
</p>

<ul>
<li> <p><code>"post"</code>: Sample the posterior.
</p>
</li>
<li> <p><code>"prior"</code>: Sample only the prior. Plots, summaries, etc. will
use the prior. This is useful for prior predictive checks.
</p>
</li>
<li> <p><code>"both"</code>: Sample both prior and posterior. Plots, summaries, etc.
will default to using the posterior. The prior only has effect when doing
Savage-Dickey density ratios in <code><a href="#topic+hypothesis">hypothesis</a></code>.
</p>
</li>
<li> <p><code>"none"</code> or <code>FALSE</code>: Do not sample. Returns an mcpfit
object without sample. This is useful if you only want to check
prior strings (fit$prior), the JAGS model (fit$jags_code), etc.
</p>
</li></ul>
</td></tr>
<tr><td><code id="run_jags_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of parallel chains for the model</p>
</td></tr>
<tr><td><code id="run_jags_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations to monitor</p>
</td></tr>
<tr><td><code id="run_jags_+3A_n.adapt">n.adapt</code></td>
<td>
<p>the number of iterations for adaptation. See 
<code><a href="rjags.html#topic+adapt">adapt</a></code> for details. If <code>n.adapt = 0</code> then no 
adaptation takes place.</p>
</td></tr>
<tr><td><code id="run_jags_+3A_inits">inits</code></td>
<td>
<p>A list if initial values for the parameters. This can be useful
if a model fails to converge. Read more in <code><a href="rjags.html#topic+jags.model">jags.model</a></code>.
Defaults to <code>NULL</code>, i.e., no inits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'mcmc.list&ldquo;
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='sd_to_prec'>Transform a prior from SD to precision.</h2><span id='topic+sd_to_prec'></span>

<h3>Description</h3>

<p>JAGS uses precision rather than SD. This function converts
<code>dnorm(4.2, 1.3)</code> into <code>dnorm(4.2, 1/1.3^2)</code>. It allows users to specify
priors using SD and then it's transformed for the JAGS code. It works for the
following distributions: dnorm|dt|dcauchy|ddexp|dlogis|dlnorm. In all of
these,
tau/sd is the second parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_to_prec(prior_str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_to_prec_+3A_prior_str">prior_str</code></td>
<td>
<p>String. A JAGS prior. Can be truncated, e.g.
<code style="white-space: pre;">&#8288;dt(3, 2, 1) T(my_var, )&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='summary.mcpfit'>Summarise mcpfit objects</h2><span id='topic+summary.mcpfit'></span><span id='topic+summary'></span><span id='topic+fixef'></span><span id='topic+fixef.mcpfit'></span><span id='topic+fixed.effects'></span><span id='topic+ranef'></span><span id='topic+ranef.mcpfit'></span><span id='topic+random.effects'></span><span id='topic+print.mcpfit'></span><span id='topic+print'></span>

<h3>Description</h3>

<p>Summarise parameter estimates and model diagnostics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcpfit'
summary(object, width = 0.95, digits = 2, prior = FALSE, ...)

fixef(object, width = 0.95, prior = FALSE, ...)

ranef(object, width = 0.95, prior = FALSE, ...)

## S3 method for class 'mcpfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mcpfit_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+mcpfit">mcpfit</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.mcpfit_+3A_width">width</code></td>
<td>
<p>Float. The width of the highest posterior density interval
(between 0 and 1).</p>
</td></tr>
<tr><td><code id="summary.mcpfit_+3A_digits">digits</code></td>
<td>
<p>a non-null value for digits specifies the minimum number of
significant digits to be printed in values. The default, NULL, uses
getOption(&quot;digits&quot;). (For the interpretation for complex numbers see signif.)
Non-integer values will be rounded down, and only values greater than or
equal to 1 and no greater than 22 are accepted.</p>
</td></tr>
<tr><td><code id="summary.mcpfit_+3A_prior">prior</code></td>
<td>
<p>TRUE/FALSE. Summarise prior instead of posterior?</p>
</td></tr>
<tr><td><code id="summary.mcpfit_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="summary.mcpfit_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+mcpfit">mcpfit</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with parameter estimates and MCMC diagnostics.
OBS: The change point distributions are often not unimodal and symmetric so
the intervals can be deceiving Plot them using <code>plot_pars(fit)</code>.
</p>

<ul>
<li> <p><code>mean</code> is the posterior mean
</p>
</li>
<li> <p><code>lower</code> is the lower quantile of the highest-density interval (HDI) given in <code>width</code>.
</p>
</li>
<li> <p><code>upper</code> is the upper quantile.
</p>
</li>
<li> <p><code>Rhat</code> is the Gelman-Rubin convergence diagnostic which is often taken to
be acceptable if &lt; 1.1. It is computed using <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code>.
</p>
</li>
<li> <p><code>n.eff</code> is the effective sample size computed using <code><a href="coda.html#topic+effectiveSize">effectiveSize</a></code>.
Low effective sample sizes are also obvious as poor mixing in trace plots
(see <code>plot_pars(fit)</code>). Read how to deal with such problems <a href="https://lindeloev.github.io/mcp/articles/tips.html">here</a>
</p>
</li>
<li> <p><code>ts_err</code> is the time-series error, taking autoregressive correlation
into account. It is computed using <code><a href="coda.html#topic+spectrum0.ar">spectrum0.ar</a></code>.
</p>
</li></ul>

<p>For simulated data, the summary contains two additional columns so that it
is easy to inspect whether the model can recover the parameters. Run
simulation and summary multiple times to get a sense of the robustness.
</p>

<ul>
<li> <p><code>sim</code> is the value used to generate the data.
</p>
</li>
<li> <p><code>match</code> is <code>"OK"</code> if <code>sim</code> is contained in the HDI interval (<code>lower</code> to
<code>upper</code>).
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>fixef()</code>: Get population-level (&quot;fixed&quot;) effects of an <code><a href="#topic+mcpfit">mcpfit</a></code> object.
</p>
</li>
<li> <p><code>ranef()</code>: Get varying (&quot;random&quot;) effects of an <code><a href="#topic+mcpfit">mcpfit</a></code> object.
</p>
</li>
<li> <p><code>print(mcpfit)</code>: Print the posterior summary of an <code><a href="#topic+mcpfit">mcpfit</a></code> object.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Typical usage
summary(demo_fit)
summary(demo_fit, width = 0.8, digits = 4)  # Set HDI width

# Get the results as a data frame
results = summary(demo_fit)

# Varying (random) effects
# ranef(my_fit)

# Summarise prior
summary(demo_fit, prior = TRUE)

</code></pre>

<hr>
<h2 id='tidy_samples'>Get tidy samples with or without varying effects</h2><span id='topic+tidy_samples'></span><span id='topic+tidy_samples.mcpfit'></span>

<h3>Description</h3>

<p>Returns in a format useful for <code>fit$simulate()</code> with population parameters in wide format
and varying effects in long format (the number of rows will be <code>nsamples * n_levels_in_varying</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_samples(
  fit,
  population = TRUE,
  varying = TRUE,
  absolute = FALSE,
  prior = FALSE,
  nsamples = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_samples_+3A_fit">fit</code></td>
<td>
<p>An <code><a href="#topic+mcpfit">mcpfit</a></code> object</p>
</td></tr>
<tr><td><code id="tidy_samples_+3A_population">population</code></td>
<td>

<ul>
<li> <p><code>TRUE</code> All population effects. Same as <code>fit$pars$population</code>.
</p>

<ul>
<li> <p><code>FALSE</code> No population effects. Same as <code>c()</code>.
</p>
</li>
<li><p> Character vector: Only include specified population parameters - see <code>fit$pars$population</code>.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="tidy_samples_+3A_varying">varying</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>TRUE</code> All varying effects (<code>fit$pars$varying</code>).
</p>
</li>
<li> <p><code>FALSE</code> No varying effects (<code>c()</code>).
</p>
</li>
<li><p> Character vector: Only include specified varying parameters - see <code>fit$pars$varying</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tidy_samples_+3A_absolute">absolute</code></td>
<td>

<ul>
<li> <p><code>TRUE</code> Returns the absolute location of all varying change points.
</p>

<ul>
<li> <p><code>FALSE</code> Just returns the varying effects.
</p>
</li>
<li><p> Character vector: Only do absolute transform for these varying parameters - see <code>fit$pars$varying</code>.
</p>
</li></ul>

<p>OBS: This currently only applies to varying change points. It is not implemented for <code>rel()</code> regressors yet.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tidy_samples_+3A_prior">prior</code></td>
<td>
<p>TRUE/FALSE. Summarise prior instead of posterior?</p>
</td></tr>
<tr><td><code id="tidy_samples_+3A_nsamples">nsamples</code></td>
<td>
<p>Integer or <code>NULL</code>. Number of samples to return/summarise.
If there are varying effects, this is the number of samples from each varying group.
<code>NULL</code> means &quot;all&quot;. Ignored if both are <code>FALSE</code>. More samples trade speed for accuracy.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tibble</code> of posterior draws in <code>tidybayes</code> format.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='tidy_to_matrix'>Convert from tidy to matrix</h2><span id='topic+tidy_to_matrix'></span>

<h3>Description</h3>

<p>Converts from the output of <code>tidy_samples()</code> or <code>pp_eval(fit, samples_format = "tidy")</code>
to an <code>N_draws</code> X <code>nrows(newdata)</code> matrix with fitted/predicted values. This format is
used y <code>brms</code> and it's useful as <code>yrep</code> in <code style="white-space: pre;">&#8288;bayesplot::ppc_*&#8288;</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_to_matrix(samples, returnvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_to_matrix_+3A_samples">samples</code></td>
<td>
<p>Samples in tidy format</p>
</td></tr>
<tr><td><code id="tidy_to_matrix_+3A_returnvar">returnvar</code></td>
<td>
<p>An <code>rlang::sym()</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An  <code>N_draws</code> X <code>nrows(newdata)</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='to_formula'>Takes any formula-like input and returns a formula</h2><span id='topic+to_formula'></span>

<h3>Description</h3>

<p>Takes any formula-like input and returns a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_formula(form)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_formula_+3A_form">form</code></td>
<td>
<p>Formula or character (with or without initial tilde/&quot;~&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='unpack_arma'>Unpack arma order and formula</h2><span id='topic+unpack_arma'></span>

<h3>Description</h3>

<p>Unpack arma order and formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_arma(form_str_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_arma_+3A_form_str_in">form_str_in</code></td>
<td>
<p>A character. These are allowed: &quot;ar(number)&quot; or &quot;ar(number, formula)&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with $order and $form_str (e.g., &quot;ar(formula)&quot;). The formula is ar(1) or ma(1) if no formula is given
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='unpack_cp'>Takes a cp formula (as a string) and returns its properties</h2><span id='topic+unpack_cp'></span>

<h3>Description</h3>

<p>Takes a cp formula (as a string) and returns its properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_cp(form_cp, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_cp_+3A_form_cp">form_cp</code></td>
<td>
<p>Segment formula as string.</p>
</td></tr>
<tr><td><code id="unpack_cp_+3A_i">i</code></td>
<td>
<p>The segment number (integer)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-row tibble with columns:
</p>

<ul>
<li> <p><code>cp_int</code>: bool. Whether there is an intercept change in the change point.
</p>
</li>
<li> <p><code>cp_in_rel</code>: bool. Is this intercept change relative?
</p>
</li>
<li> <p><code>cp_ran_int</code>: bool or NA. Is there a random intercept on the change point?
</p>
</li>
<li> <p><code>cp_group_col</code>: char or NA. Which column in data define the random intercept?
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='unpack_int'>Get the intercept of a formula</h2><span id='topic+unpack_int'></span>

<h3>Description</h3>

<p>Get the intercept of a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_int(form, i, ttype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_int_+3A_form">form</code></td>
<td>
<p>A formula</p>
</td></tr>
<tr><td><code id="unpack_int_+3A_i">i</code></td>
<td>
<p>Segment number (integer)</p>
</td></tr>
<tr><td><code id="unpack_int_+3A_ttype">ttype</code></td>
<td>
<p>The term type. One of &quot;ct&quot; (central tendency), &quot;sigma&quot; (variance),
or &quot;ar&quot; (autoregressive)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-row tibble describing the intercept.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='unpack_rhs'>Unpack right-hand side</h2><span id='topic+unpack_rhs'></span>

<h3>Description</h3>

<p>This is a pretty big function. It includes unpacking sigma(), ar(), etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_rhs(form_rhs, i, family, data, last_segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_rhs_+3A_form_rhs">form_rhs</code></td>
<td>
<p>A character representation of a formula</p>
</td></tr>
<tr><td><code id="unpack_rhs_+3A_i">i</code></td>
<td>
<p>The segment number (integer)</p>
</td></tr>
<tr><td><code id="unpack_rhs_+3A_family">family</code></td>
<td>
<p>An mcpfamily object returned by <code>mcpfamily()</code>.</p>
</td></tr>
<tr><td><code id="unpack_rhs_+3A_data">data</code></td>
<td>
<p>A data.frame or tibble</p>
</td></tr>
<tr><td><code id="unpack_rhs_+3A_last_segment">last_segment</code></td>
<td>
<p>The last row in the segment table, made in <code>get_segment_table()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-row tibble with three columns for each of <code>ct</code>. <code>sigma</code>, <code>ar</code>, and <code>ma</code>:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;_int&#8288;</code>: NA or a one-row tibble describing the intercept.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_slope&#8288;</code>: NA or a tibble with a row for each slope term.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_code&#8288;</code>: NA or a char with the JAGS/R code to implement the slope.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='unpack_slope'>Unpack the slope of a formula</h2><span id='topic+unpack_slope'></span>

<h3>Description</h3>

<p>Makes A list of terms and applies unpack_slope_term() to each of them. Then builds the code for this segment's slope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_slope(form, i, ttype, last_slope)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_slope_+3A_form">form</code></td>
<td>
<p>A formula</p>
</td></tr>
<tr><td><code id="unpack_slope_+3A_i">i</code></td>
<td>
<p>Segment number (integer)</p>
</td></tr>
<tr><td><code id="unpack_slope_+3A_ttype">ttype</code></td>
<td>
<p>The term type. One of &quot;ct&quot; (central tendency), &quot;sigma&quot; (variance),
or &quot;ar&quot; (autoregressive)</p>
</td></tr>
<tr><td><code id="unpack_slope_+3A_last_slope">last_slope</code></td>
<td>
<p>The element in the slope column for this ttype in the previous
segment. I.e., probably what this function returned last time it was called!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;one-row&quot; list with code (char) and a tibble of slopes.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='unpack_slope_term'>Unpacks a single term</h2><span id='topic+unpack_slope_term'></span>

<h3>Description</h3>

<p>Returns a row for <code>unpack_slope()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_slope_term(term, i, last_slope, ttype = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_slope_term_+3A_term">term</code></td>
<td>
<p>A character, e.g., &quot;x&quot;, &quot;I(x^2)&quot;, or &quot;log(x)&quot;.</p>
</td></tr>
<tr><td><code id="unpack_slope_term_+3A_i">i</code></td>
<td>
<p>Segment number (integer)</p>
</td></tr>
<tr><td><code id="unpack_slope_term_+3A_last_slope">last_slope</code></td>
<td>
<p>The element in the slope column for this ttype in the previous
segment. I.e., probably what this function returned last time it was called!</p>
</td></tr>
<tr><td><code id="unpack_slope_term_+3A_ttype">ttype</code></td>
<td>
<p>The term type. One of &quot;ct&quot; (central tendency), &quot;sigma&quot; (variance),
or &quot;ar&quot; (autoregressive)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;one-row&quot; list describing a slope term.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='unpack_tildes'>Takes a formula and returns a string representation of y, cp, and rhs</h2><span id='topic+unpack_tildes'></span>

<h3>Description</h3>

<p>Takes a formula and returns a string representation of y, cp, and rhs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_tildes(segment, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_tildes_+3A_segment">segment</code></td>
<td>
<p>A formula</p>
</td></tr>
<tr><td><code id="unpack_tildes_+3A_i">i</code></td>
<td>
<p>The segment number (integer)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-row tibble with columns:
</p>

<ul>
<li> <p><code>form</code>: String. The full formula for this segment.
</p>
</li>
<li> <p><code>form_y</code>: String. The expression for y (without tilde)
</p>
</li>
<li> <p><code>form_cp</code>: String. The formula for the change point
</p>
</li>
<li> <p><code>form_rhs</code>: String. The formula for the right-hand side
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='unpack_varying'>Get relevant info about varying parameters</h2><span id='topic+unpack_varying'></span><span id='topic+unpack_varying.mcpfit'></span>

<h3>Description</h3>

<p>Returns parameters, data columns, and implicated segments given parameter name(s) or column(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_varying(fit, pars = NULL, cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_varying_+3A_pars">pars</code></td>
<td>
<p><code>NULL</code>/<code>FALSE</code> for nothing. <code>TRUE</code> for all. A vector of varying parameter names for specifics.</p>
</td></tr>
<tr><td><code id="unpack_varying_+3A_cols">cols</code></td>
<td>
<p><code>NULL</code>/<code>FALSE</code> for nothing. <code>TRUE</code> for all. A vector of varying column names for specifics. Usually provided via &quot;facet_by&quot; argument in other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a list with
</p>


<h3>Value</h3>

<p>A list. See details.
</p>


<h3>Slots</h3>


<dl>
<dt><code>pars</code></dt><dd><p>Character vector of parameter names. <code>NULL</code> if empty.</p>
</dd>
<dt><code>cols</code></dt><dd><p>Character vector of data column names. <code>NULL</code> if empty.</p>
</dd>
<dt><code>indices</code></dt><dd><p>Logical vector of segments in the segment table that contains the varying effect</p>
</dd>
</dl>

<hr>
<h2 id='unpack_varying_term'>Unpack varying effects</h2><span id='topic+unpack_varying_term'></span>

<h3>Description</h3>

<p>Unpack varying effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_varying_term(term, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_varying_term_+3A_term">term</code></td>
<td>
<p>A character, e.g., &quot;x&quot;, &quot;I(x^2)&quot;, or &quot;log(x)&quot;.</p>
</td></tr>
<tr><td><code id="unpack_varying_term_+3A_i">i</code></td>
<td>
<p>Segment number (integer)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;one-row&quot; list describing a varying intercept.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='unpack_y'>Unpacks y variable name</h2><span id='topic+unpack_y'></span>

<h3>Description</h3>

<p>Unpacks y variable name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_y(form_y, i, family)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_y_+3A_form_y">form_y</code></td>
<td>
<p>Character representation of formula</p>
</td></tr>
<tr><td><code id="unpack_y_+3A_i">i</code></td>
<td>
<p>The segment number (integer)</p>
</td></tr>
<tr><td><code id="unpack_y_+3A_family">family</code></td>
<td>
<p>An mcpfamily object returned by <code>mcpfamily()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-row tibble with the columns
</p>

<ul>
<li> <p><code>y</code>: string. The y variable name.
</p>
</li>
<li> <p><code>trials</code>: string. The trials variable name.
</p>
</li>
<li> <p><code>weights</code>: string. The weights variable name.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

<hr>
<h2 id='with_loo'>Add loo if not already present</h2><span id='topic+with_loo'></span>

<h3>Description</h3>

<p>Add loo if not already present
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_loo(fit, save_psis = FALSE, info = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_loo_+3A_fit">fit</code></td>
<td>
<p>An mcpfit object</p>
</td></tr>
<tr><td><code id="with_loo_+3A_save_psis">save_psis</code></td>
<td>
<p>Logical. See documentation of loo::loo</p>
</td></tr>
<tr><td><code id="with_loo_+3A_info">info</code></td>
<td>
<p>Optional message if adding loo</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An mcpfit object with loo.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindeløv <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
