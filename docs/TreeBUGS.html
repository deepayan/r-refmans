<!DOCTYPE html><html><head><title>Help for package TreeBUGS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TreeBUGS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TreeBUGS-package'><p>TreeBUGS: Hierarchical Multinomial Processing Tree Modeling</p></a></li>
<li><a href='#arnold2013'><p>Data of a Source-Monitoring Experiment</p></a></li>
<li><a href='#BayesFactorMPT'><p>Bayes Factors for Simple (Nonhierarchical) MPT Models</p></a></li>
<li><a href='#BayesFactorSlope'><p>Bayes Factor for Slope Parameters in Latent-Trait MPT</p></a></li>
<li><a href='#betaMPT'><p>Fit a Hierarchical Beta-MPT Model</p></a></li>
<li><a href='#betaMPTcpp'><p>C++ Sampler for Hierarchical Beta-MPT Model</p></a></li>
<li><a href='#betweenSubjectMPT'><p>Between-Subject Comparison of Parameters</p></a></li>
<li><a href='#correlationPosterior'><p>Posterior Distribution for Correlations</p></a></li>
<li><a href='#extendMPT'><p>Extend MCMC Sampling for MPT Model</p></a></li>
<li><a href='#genBetaMPT'><p>Generate Data for Beta MPT Models</p></a></li>
<li><a href='#genMPT'><p>Generate MPT Frequencies</p></a></li>
<li><a href='#genTraitMPT'><p>Generate Data for Latent-Trait MPT Models</p></a></li>
<li><a href='#getGroupMeans'><p>Get Mean Parameters per Group</p></a></li>
<li><a href='#getParam'><p>Get Parameter Posterior Statistics</p></a></li>
<li><a href='#getSamples'><p>Get Posterior Samples from Fitted MPT Model</p></a></li>
<li><a href='#marginalMPT'><p>Marginal Likelihood for Simple MPT</p></a></li>
<li><a href='#plot.betaMPT'><p>Plot Convergence for Hierarchical MPT Models</p></a></li>
<li><a href='#plotDistribution'><p>Plot Distribution of Individual Estimates</p></a></li>
<li><a href='#plotFit'><p>Plot Posterior Predictive Mean Frequencies</p></a></li>
<li><a href='#plotFreq'><p>Plot Raw Frequencies</p></a></li>
<li><a href='#plotParam'><p>Plot Parameter Estimates</p></a></li>
<li><a href='#plotPrior'><p>Plot Prior Distributions</p></a></li>
<li><a href='#plotPriorPost'><p>Plot Prior vs. Posterior Distribution</p></a></li>
<li><a href='#posteriorPredictive'><p>Get Posterior Predictive Samples</p></a></li>
<li><a href='#PPP'><p>Compute Posterior Predictive P-Values</p></a></li>
<li><a href='#priorPredictive'><p>Prior Predictive Samples</p></a></li>
<li><a href='#probitInverse'><p>Probit-Inverse of Group-Level Normal Distribution</p></a></li>
<li><a href='#readEQN'><p>Read multiTree files</p></a></li>
<li><a href='#simpleMPT'><p>C++ Sampler for Standard (Nonhierarchical) MPT Models</p></a></li>
<li><a href='#summarizeMCMC'><p>MCMC Summary</p></a></li>
<li><a href='#summarizeMPT'><p>Summarize JAGS Output for Hierarchical MPT Models</p></a></li>
<li><a href='#testHetChi'><p>Chi-Square Test of Heterogeneity</p></a></li>
<li><a href='#testHetPerm'><p>Permutation Test of Heterogeneity</p></a></li>
<li><a href='#traitMPT'><p>Fit a Hierarchical Latent-Trait MPT Model</p></a></li>
<li><a href='#transformedParameters'><p>Get Transformed Parameters</p></a></li>
<li><a href='#WAIC'><p>WAIC: Widely Applicable Information Criterion</p></a></li>
<li><a href='#withinSubjectEQN'><p>Generate EQN Files for Within-Subject Designs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-21</td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical Multinomial Processing Tree Modeling</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel W. Heck &lt;daniel.heck@uni-marburg.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.6), runjags, stats, graphics, utils, grDevices,
coda, parallel, rjags, MASS, hypergeo, logspline</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, R.rsp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>JAGS (https://mcmc-jags.sourceforge.io/)</td>
</tr>
<tr>
<td>Description:</td>
<td>User-friendly analysis of hierarchical multinomial processing tree (MPT) 
    models that are often used in cognitive psychology. Implements the latent-trait 
    MPT approach (Klauer, 2010) &lt;<a href="https://doi.org/10.1007%2Fs11336-009-9141-0">doi:10.1007/s11336-009-9141-0</a>&gt; and the beta-MPT 
    approach (Smith &amp; Batchelder, 2010) &lt;<a href="https://doi.org/10.1016%2Fj.jmp.2009.06.007">doi:10.1016/j.jmp.2009.06.007</a>&gt; to model 
    heterogeneity of participants. MPT models are conveniently specified by an
    .eqn-file as used by other MPT software and data are provided by a .csv-file 
    or directly in R. Models are either fitted by calling JAGS or by an MPT-tailored 
    Gibbs sampler in C++ (only for nonhierarchical and beta MPT models). Provides 
    tests of heterogeneity and MPT-tailored summaries and plotting functions.
    A detailed documentation is available in Heck, Arnold, &amp; Arnold (2018) 
    &lt;<a href="https://doi.org/10.3758%2Fs13428-017-0869-7">doi:10.3758/s13428-017-0869-7</a>&gt; and a tutorial on MPT modeling can be found 
    in Schmidt, Erdfelder, &amp; Heck (2022) &lt;<a href="https://doi.org/10.31234%2Fosf.io%2Fgh8md">doi:10.31234/osf.io/gh8md</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/danheck/TreeBUGS">https://github.com/danheck/TreeBUGS</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-21 15:13:41 UTC; daniel</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel W. Heck <a href="https://orcid.org/0000-0002-6302-9252"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Nina R. Arnold [aut, dtc],
  Denis Arnold [aut],
  Alexander Ly [ctb],
  Marius Barth <a href="https://orcid.org/0000-0002-3421-6665"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-21 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='TreeBUGS-package'>TreeBUGS: Hierarchical Multinomial Processing Tree Modeling</h2><span id='topic+TreeBUGS'></span><span id='topic+TreeBUGS-package'></span>

<h3>Description</h3>


<p><img src="../help/figures/TreeBUGS.png" width='120' alt='logo' style='float: right' />

</p>
<p>Uses standard MPT files in the .eqn-format (Moshagen, 2010) to fit
hierarchical Bayesian MPT models. Note that the software JAGS is required
(<a href="https://mcmc-jags.sourceforge.io/">https://mcmc-jags.sourceforge.io/</a>). 
</p>
<p>The core functions either fit a Beta-MPT model (<code><a href="#topic+betaMPT">betaMPT</a></code>; Smith
&amp; Batchelder, 2010) or a latent-trait MPT model (<code><a href="#topic+traitMPT">traitMPT</a></code>;
Klauer, 2010). A fitted model can be inspected using convenient summary and
plot functions tailored to hierarchical MPT models.
</p>
<p>Detailed explanations and examples can be found in the package vignette,
accessible via <code>vignette("TreeBUGS")</code>
</p>


<h3>Citation</h3>

<p>If you use TreeBUGS, please cite the software as follows:
</p>
<p>Heck, D. W., Arnold, N. R., &amp; Arnold, D. (2018).
TreeBUGS: An R package for hierarchical multinomial-processing-tree modeling.
<em>Behavior Research Methods, 50</em>, 264–284.
<a href="https://doi.org/10.3758/s13428-017-0869-7">doi:10.3758/s13428-017-0869-7</a>
</p>


<h3>Tutorial</h3>

<p>For a tutorial on MPT modeling (including hierarchical modeling in TreeBUGS), see:
</p>
<p>Schmidt, O., Erdfelder, E., &amp; Heck, D. W. (2022).
Tutorial on multinomial processing tree modeling:
How to develop, test, and extend MPT models.
<a href="https://psyarxiv.com/gh8md/">https://psyarxiv.com/gh8md/</a>
</p>


<h3>Author(s)</h3>

<p>Daniel W. Heck, Denis Arnold, &amp; Nina Arnold
</p>


<h3>References</h3>

<p>Klauer, K. C. (2010). Hierarchical multinomial processing tree models:
A latent-trait approach.
<em>Psychometrika, 75</em>, 70-98.
<a href="https://doi.org/10.1007/s11336-009-9141-0">doi:10.1007/s11336-009-9141-0</a>
</p>
<p>Matzke, D., Dolan, C. V., Batchelder, W. H., &amp; Wagenmakers, E.-J. (2015).
Bayesian estimation of multinomial processing tree models with heterogeneity
in participants and items.
<em>Psychometrika, 80</em>, 205-235.
<a href="https://doi.org/10.1007/s11336-013-9374-9">doi:10.1007/s11336-013-9374-9</a>
</p>
<p>Moshagen, M. (2010).
multiTree: A computer program for the analysis of multinomial processing
tree models.
<em>Behavior Research Methods, 42</em>, 42-54.
<a href="https://doi.org/10.3758/BRM.42.1.42">doi:10.3758/BRM.42.1.42</a>
</p>
<p>Smith, J. B., &amp; Batchelder, W. H. (2008).
Assessing individual differences in categorical data.
<em>Psychonomic Bulletin &amp; Review, 15</em>, 713-731.
<a href="https://doi.org/10.3758/PBR.15.4.713">doi:10.3758/PBR.15.4.713</a>
</p>
<p>Smith, J. B., &amp; Batchelder, W. H. (2010).
Beta-MPT: Multinomial processing tree models for addressing
individual differences.
<em>Journal of Mathematical Psychology, 54</em>, 167-183.
<a href="https://doi.org/10.1016/j.jmp.2009.06.007">doi:10.1016/j.jmp.2009.06.007</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/danheck/TreeBUGS">https://github.com/danheck/TreeBUGS</a>
</p>
</li></ul>


<hr>
<h2 id='arnold2013'>Data of a Source-Monitoring Experiment</h2><span id='topic+arnold2013'></span>

<h3>Description</h3>

<p>Dataset of a source-monitoring experiment by Arnold, Bayen, Kuhlmann, and
Vaterrodt (2013) using a 2 (Source; within) x 3 (Expectancy; within) x 2
(Time of Schema Activation; between) mixed factorial design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arnold2013
</code></pre>


<h3>Format</h3>

<p>A data frame 13 variables:
</p>

<dl>
<dt><code>subject</code></dt><dd><p>Participant code</p>
</dd>
<dt><code>age</code></dt><dd><p>Age in years</p>
</dd>
<dt><code>group</code></dt><dd><p> Between-subject factor &quot;Time of Schema Activation&quot;:
Retrieval vs. encoding condition</p>
</dd>
<dt><code>pc</code></dt><dd><p>perceived contingency</p>
</dd>
<dt><code>EE</code></dt><dd><p>Frequency of &quot;Source E&quot; responses to items from source &quot;E&quot;</p>
</dd>
<dt><code>EU</code></dt><dd><p>Frequency of &quot;Source U&quot; responses to items from source &quot;E&quot;</p>
</dd>
<dt><code>EN</code></dt><dd><p>Frequency of &quot;New&quot; responses to items from source &quot;E&quot;</p>
</dd>
<dt><code>UE</code></dt><dd><p>Frequency of &quot;Source E&quot; responses to items from source &quot;E&quot;</p>
</dd>
<dt><code>UU</code></dt><dd><p>Frequency of &quot;Source U&quot; responses to items from source &quot;E&quot;</p>
</dd>
<dt><code>UN</code></dt><dd><p>Frequency of &quot;New&quot; responses to items from source &quot;E&quot;</p>
</dd>
<dt><code>NE</code></dt><dd><p>Frequency of &quot;Source E&quot; responses to new items</p>
</dd>
<dt><code>NU</code></dt><dd><p>Frequency of &quot;Source U&quot; responses to new items</p>
</dd>
<dt><code>NN</code></dt><dd><p>Frequency of &quot;New&quot; responses to new items</p>
</dd>
</dl>



<h3>Details</h3>

<p>Eighty-four participants had to learn statements that were either
presented by a doctor or a lawyer (Source) and were either typical for
doctors, typical for lawyers, or neutral (Expectancy). These two types of
statements were completely crossed in a balanced way, resulting in a true
contingency of zero between Source and Expectancy. Whereas the profession
schemata were activated at the time of encoding for half of the participants
(encoding condition), the other half were told about the profession of the
sources just before the test (retrieval condition). After the test,
participants were asked to judge the contingency between item type and source
(perceived contingency pc).
</p>


<h3>References</h3>

<p>Arnold, N. R., Bayen, U. J., Kuhlmann, B. G., &amp; Vaterrodt, B.
(2013). Hierarchical modeling of contingency-based source monitoring: A
test of the probability-matching account. Psychonomic Bulletin &amp; Review,
20, 326-333.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(arnold2013)

## Not run: 
# fit hierarchical MPT model for encoding condition:
EQNfile &lt;- system.file("MPTmodels/2htsm.eqn", package = "TreeBUGS")
d.encoding &lt;- subset(arnold2013, group == "encoding", select = -(1:4))
fit &lt;- betaMPTcpp(EQNfile, d.encoding,
  n.thin = 5,
  restrictions = list("D1=D2=D3", "d1=d2", "a=g")
)
# convergence
plot(fit, parameter = "mean", type = "default")
summary(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='BayesFactorMPT'>Bayes Factors for Simple (Nonhierarchical) MPT Models</h2><span id='topic+BayesFactorMPT'></span>

<h3>Description</h3>

<p>Computes Bayes factors for simple (fixed-effects, nonhierarchical) MPT models
with beta distributions as priors on the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesFactorMPT(
  models,
  dataset = 1,
  resample,
  batches = 5,
  scale = 1,
  store = FALSE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesFactorMPT_+3A_models">models</code></td>
<td>
<p>list of models fitted with <code><a href="#topic+simpleMPT">simpleMPT</a></code>, e.g.,
<code>list(mod1, mod2)</code></p>
</td></tr>
<tr><td><code id="BayesFactorMPT_+3A_dataset">dataset</code></td>
<td>
<p>for which data set should Bayes factors be computed?</p>
</td></tr>
<tr><td><code id="BayesFactorMPT_+3A_resample">resample</code></td>
<td>
<p>how many of the posterior samples of the MPT parameters
should be resampled per model</p>
</td></tr>
<tr><td><code id="BayesFactorMPT_+3A_batches">batches</code></td>
<td>
<p>number of batches. Used to compute a standard error of the
estimate.</p>
</td></tr>
<tr><td><code id="BayesFactorMPT_+3A_scale">scale</code></td>
<td>
<p>how much should posterior-beta approximations be downscaled to
get fatter importance-sampling density</p>
</td></tr>
<tr><td><code id="BayesFactorMPT_+3A_store">store</code></td>
<td>
<p>whether to save parameter samples</p>
</td></tr>
<tr><td><code id="BayesFactorMPT_+3A_cores">cores</code></td>
<td>
<p>number of CPUs used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, this is only implemented for a single data set!
</p>
<p>Uses a Rao-Blackwellized version of the product-space method (Carlin &amp; Chib,
1995) as proposed by Barker and Link (2013). First, posterior distributions
of the MPT parameters are approximated by independent beta distributions.
Second, for one a selected model, parameters are sampled from these proposal
distributions. Third, the conditional probabilities to switch to a different
model are computed and stored. Finally, the eigenvector with eigenvalue one
of the matrix of switching probabilities provides an estimate of the
posterior model probabilities.
</p>


<h3>References</h3>

<p>Barker, R. J., &amp; Link, W. A. (2013). Bayesian multimodel
inference by RJMCMC: A Gibbs sampling approach. The American Statistician,
67(3), 150-156.
</p>
<p>Carlin, B. P., &amp; Chib, S. (1995). Bayesian model choice via Markov chain
Monte Carlo methods. Journal of the Royal Statistical Society. Series B
(Methodological), 57(3), 473-484.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marginalMPT">marginalMPT</a></code>
</p>

<hr>
<h2 id='BayesFactorSlope'>Bayes Factor for Slope Parameters in Latent-Trait MPT</h2><span id='topic+BayesFactorSlope'></span>

<h3>Description</h3>

<p>Uses the Savage-Dickey method to compute the Bayes factor that the slope
parameter of a continuous covariate in <code><a href="#topic+traitMPT">traitMPT</a></code> is zero vs.
positive/negative/unequal to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesFactorSlope(
  fittedModel,
  parameter,
  direction = "!=",
  approx = "normal",
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesFactorSlope_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>a fitted latent-trait model fitted with
<code><a href="#topic+traitMPT">traitMPT</a></code> with predictor variables that have been defined via
<code>predStructure</code>.</p>
</td></tr>
<tr><td><code id="BayesFactorSlope_+3A_parameter">parameter</code></td>
<td>
<p>name of the slope parameter (e.g.,
<code>"slope_d_covariate"</code>).</p>
</td></tr>
<tr><td><code id="BayesFactorSlope_+3A_direction">direction</code></td>
<td>
<p>alternative hypothesis: whether slope is smaller or larger
than zero (<code>"&lt;"</code> or <code>"&gt;"</code>) or unequal to zero (<code>"!="</code>).</p>
</td></tr>
<tr><td><code id="BayesFactorSlope_+3A_approx">approx</code></td>
<td>
<p>how to approximate the posterior density of the slope parameter
at zero: <code>approx="normal"</code> uses a normal approximation to all samples
and <code>approx="logspline"</code> uses a nonparametric density estimate of the
package <a href="logspline.html#topic+logspline">logspline</a>. Usually, both methods provide similar
results.</p>
</td></tr>
<tr><td><code id="BayesFactorSlope_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code>, the prior and posterior densities and the ratio
at slope=0 are plotted.</p>
</td></tr>
<tr><td><code id="BayesFactorSlope_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="logspline.html#topic+logspline">logspline</a></code>,
which is used to approximate the density of the posterior distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayes factor is computed with the Savage-Dickey method, which is
defined as the ratio of the density of the posterior and the density of the
prior evaluated at <code>slope=0</code> (Heck, 2019). Note that this method cannot
be used with default JZS priors (<code>IVprec="dgamma(.5,.5)"</code>) if more than
one predictor is added for an MPT parameter. As a remedy, a g-prior (normal
distribution) can be used on the slopes by setting the hyperprior parameter
<code class="reqn">g</code> to a fixed constant when fitting the model: <code>traitMPT(...,
IVprec = 1)</code> (see Heck, 2019).
</p>


<h3>References</h3>

<p>Heck, D. W. (2019). A caveat on the Savage-Dickey density ratio:
The case of computing Bayes factors for regression parameters. <em>British
Journal of Mathematical and Statistical Psychology, 72</em>, 316–333.
<a href="https://doi.org/10.1111/bmsp.12150">doi:10.1111/bmsp.12150</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# latent-trait MPT model for the encoding condition (see ?arnold2013):
EQNfile &lt;- system.file("MPTmodels/2htsm.eqn", package = "TreeBUGS")
d.enc &lt;- subset(arnold2013, group == "encoding")

fit &lt;- traitMPT(EQNfile,
  data = d.enc[, -(1:4)], n.thin = 5,
  restrictions = list("D1=D2=D3", "d1=d2", "a=g"),
  covData = d.enc[, c("age", "pc")],
  predStructure = list("D1 ; age")
)
plot(fit, parameter = "slope", type = "default")
summary(fit)

BayesFactorSlope(fit, "slope_D1_age", direction = "&lt;")

## End(Not run)
</code></pre>

<hr>
<h2 id='betaMPT'>Fit a Hierarchical Beta-MPT Model</h2><span id='topic+betaMPT'></span>

<h3>Description</h3>

<p>Fits a Beta-MPT model (Smith &amp; Batchelder, 2010) based on a standard MPT
model file (.eqn) and individual data table (.csv).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaMPT(
  eqnfile,
  data,
  restrictions,
  covData,
  transformedParameters,
  corProbit = FALSE,
  alpha = "dgamma(1, 0.1)T(1,)",
  beta = "dgamma(1, 0.1)T(1,)",
  n.iter = 20000,
  n.adapt = 2000,
  n.burnin = 2000,
  n.thin = 5,
  n.chains = 3,
  dic = FALSE,
  ppp = 0,
  monitorIndividual = TRUE,
  modelfilename,
  parEstFile,
  posteriorFile,
  autojags = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betaMPT_+3A_eqnfile">eqnfile</code></td>
<td>
<p>The (relative or full) path to the file that specifies the MPT
model (standard .eqn syntax). Note that category labels must start with a
letter (different to multiTree) and match the column names of <code>data</code>.
Alternatively, the EQN-equations can be provided within R as a character
value (cf. <code><a href="#topic+readEQN">readEQN</a></code>). Note that the first line of an .eqn-file
is reserved for comments and always ignored.</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_data">data</code></td>
<td>
<p>The (relative or full) path to the .csv file with the data (comma
separated; category labels in first row). Alternatively: a data frame or
matrix (rows=individuals, columns = individual category frequencies,
category labels as column names)</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_restrictions">restrictions</code></td>
<td>
<p>Specifies which parameters should be (a) constant (e.g.,
<code>"a=b=.5"</code>) or (b) constrained to be identical (e.g., <code>"Do=Dn"</code>)
or (c) treated as fixed effects (i.e., identical for all participants;
<code>"a=b=FE"</code>). Either given as the path to a text file with restrictions
per row or as a list of restrictions, e.g., <code>list("D1=D2","g=0.5")</code>.
Note that numbers in .eqn-equations (e.g., <code>d*(1-g)*.50</code>) are directly
interpreted as equality constraints.</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_covdata">covData</code></td>
<td>
<p>Data that contains covariates, for which correlations with
individual MPT parameters will be sampled. Either the path to a .csv file
(comma-separated: rows=individuals in the same order as <code>data</code>; first
row must contain covariate labels). Alternatively: a data frame or matrix
(rows=individuals, columns = variables; covariate labels as column names).
Note that in <code>betaMPT</code>, correlations are computed for discrete
variables that are coded numerically (in <code>traitMPT</code>, this can be
suppressed by using <code>predType="f"</code>)</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_transformedparameters">transformedParameters</code></td>
<td>
<p>list with parameter transformations that should
be computed based on the posterior samples of the group-level means (e.g.,
for testing parameter differences: <code>list("diffD=Do-Dn")</code>), or path to
a text file containing one transformation per line. Transformations of
individual-level parameters can also be performed after fitting a model
using <code><a href="#topic+transformedParameters">transformedParameters</a></code>.</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_corprobit">corProbit</code></td>
<td>
<p>whether to use probit-transformed MPT parameters to compute
correlations (probit-values of <code>+Inf</code> are truncated to
<code>max(5,max(probit))</code>; similarly for <code>-Inf</code>). Default for
beta-MPT: MPT parameters are used on the probability scale [0,1].</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_alpha">alpha</code></td>
<td>
<p>Hyperprior for the shape parameters <code class="reqn">\alpha</code> of the
group-level beta distributions (in JAGS syntax). Default: Truncated gamma
distributions for <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> with shape 1 and rate 0.1
and truncated to be larger than 1 (see <a href="#topic+plotPrior">plotPrior</a>). A named vector
can be used to specify separate hyperpriors for each MPT parameter (if
unnamed, the order of parameters is determined by the default order as
shown by <code><a href="#topic+readEQN">readEQN</a></code> with <code>paramOrder = TRUE</code>). Originally,
Smith and Batchelder (2008) used the &quot;WinBUGS-zeros-trick&quot; (available in
TreeBUGS if <code>alpha="zero"</code> or <code>beta="zero"</code>), which approximates
uniform priors on the group-level mean and SD (but often results
convergence issues).</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_beta">beta</code></td>
<td>
<p>Hyperprior for <code class="reqn">\beta</code> of group-level distributions, see
<code>alpha</code>.</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of iterations per chain (including burnin samples). See
<code><a href="runjags.html#topic+run.jags">run.jags</a></code> for details.</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_n.adapt">n.adapt</code></td>
<td>
<p>number of adaption samples to adjust MCMC sampler in JAGS. The
sampler will be more efficient if it is tuned well. However, MCMC sampling
will still give correct results even if the warning appears: &quot;Adaptation
incomplete.&quot; (this just means that sampling efficiency could be better).</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_n.burnin">n.burnin</code></td>
<td>
<p>Number of samples for burnin (samples will not be stored and
removed from n.iter)</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_n.thin">n.thin</code></td>
<td>
<p>Thinning rate.</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_n.chains">n.chains</code></td>
<td>
<p>number of MCMC chains (sampled in parallel).</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_dic">dic</code></td>
<td>
<p>whether to compute DIC using
<code><a href="runjags.html#topic+extract.runjags">extract.runjags</a></code>, which requires additional sampling.
Can also be computed and added after fitting the model by
<code>fittedModel$summary$dic &lt;- runjags::extract(fittedModel$runjags,
"dic")</code>. As an alternative information criterion, <code><a href="#topic+WAIC">WAIC</a></code> can be
computed for fitted models.</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_ppp">ppp</code></td>
<td>
<p>number of samples to compute  posterior predictive p-value (see
<code><a href="#topic+posteriorPredictive">posteriorPredictive</a></code>)</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_monitorindividual">monitorIndividual</code></td>
<td>
<p>whether to store MCMC samples of the MPT
parameters <code>theta</code> at the individual level (i.e., the random effects).
If <code>FALSE</code>, it is not possible to perform posterior-predictive checks.</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_modelfilename">modelfilename</code></td>
<td>
<p>name of the generated JAGS model file. Default is to
write this information to the tempdir as required by CRAN standards.</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_parestfile">parEstFile</code></td>
<td>
<p>Name of the file to with the estimates should be stored
(e.g., &quot;parEstFile.txt&quot;)</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_posteriorfile">posteriorFile</code></td>
<td>
<p>path to RData-file where to save the model including
MCMC posterior samples (an object named <code>fittedModel</code>; e.g.,
<code>posteriorFile="mcmc.RData"</code>)</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_autojags">autojags</code></td>
<td>
<p>JAGS first fits the MPT model as usual and then draws MCMC
samples repeatedly until convergence. For this, the function
<code>autoextend.jags</code> is used with the arguments provided in
<code>autojags</code> (this can be an empty list, in which case the defaults are
used). Possible arguments for <code>autoextend.jags</code> are:
<code>list(startburnin = 1000, startsample = 5000, adapt = 2000,
max.time="30m")</code> (the last of these arguments restricts sampling  to 30
minutes, see  <a href="runjags.html#topic+autoextend.jags">autoextend.jags</a>).</p>
</td></tr>
<tr><td><code id="betaMPT_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the JAGS sampling function
(i.e., to <code><a href="runjags.html#topic+run.jags">run.jags</a></code>. Note that reproducible results
are obtained by setting a random seed before fitting a model (i.e.,
<code>set.seed(12345)</code> ).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, in the Beta-MPT model, correlations of individual MPT
parameters with covariates are sampled. Hence, the covariates do not affect
the estimation of the actual Beta-MPT parameters. Therefore, the correlation
of covariates with the individual MPT parameters can equivalently be
performed after fitting the model using the sampled posterior parameter
values stored in <code>betaMPT$mcmc</code>
</p>


<h3>Value</h3>

<p>a list of the class <code>betaMPT</code> with the objects:
</p>

<ul>
<li> <p><code>summary</code>: MPT tailored summary. Use <code>summary(fittedModel)</code>
</p>
</li>
<li> <p><code>mptInfo</code>: info about MPT model (eqn and data file etc.)
</p>
</li>
<li> <p><code>runjags</code>: the object returned from the MCMC sampler.
Note that the object <code>fittedModel$runjags</code> is an
<a href="runjags.html#topic+runjags">runjags</a> object, whereas
<code>fittedModel$runjags$mcmc</code> is a <code>mcmc.list</code>
as used by the coda package (<a href="coda.html#topic+mcmc">mcmc</a>)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel W. Heck, Nina R. Arnold, Denis Arnold
</p>


<h3>References</h3>

<p>Heck, D. W., Arnold, N. R., &amp; Arnold, D. (2018). TreeBUGS: An R
package for hierarchical multinomial-processing-tree modeling. <em>Behavior
Research Methods, 50</em>, 264–284. <a href="https://doi.org/10.3758/s13428-017-0869-7">doi:10.3758/s13428-017-0869-7</a>
</p>
<p>Smith, J. B., &amp; Batchelder, W. H. (2010). Beta-MPT: Multinomial processing
tree models for addressing individual differences. <em>Journal of
Mathematical Psychology, 54</em>, 167-183. <a href="https://doi.org/10.1016/j.jmp.2009.06.007">doi:10.1016/j.jmp.2009.06.007</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# fit beta-MPT model for encoding condition (see ?arnold2013):
EQNfile &lt;- system.file("MPTmodels/2htsm.eqn", package = "TreeBUGS")
d.encoding &lt;- subset(arnold2013, group == "encoding", select = -(1:4))
fit &lt;- betaMPT(EQNfile, d.encoding,
  n.thin = 5,
  restrictions = list("D1=D2=D3", "d1=d2", "a=g")
)
# convergence
plot(fit, parameter = "mean", type = "default")
summary(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='betaMPTcpp'>C++ Sampler for Hierarchical Beta-MPT Model</h2><span id='topic+betaMPTcpp'></span>

<h3>Description</h3>

<p>Fast Gibbs sampler in C++ that is tailored to the beta-MPT model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaMPTcpp(
  eqnfile,
  data,
  restrictions,
  covData,
  corProbit = FALSE,
  n.iter = 20000,
  n.burnin = 2000,
  n.thin = 5,
  n.chains = 3,
  ppp = 0,
  shape = 1,
  rate = 0.1,
  parEstFile,
  posteriorFile,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betaMPTcpp_+3A_eqnfile">eqnfile</code></td>
<td>
<p>The (relative or full) path to the file that specifies the MPT
model (standard .eqn syntax). Note that category labels must start with a
letter (different to multiTree) and match the column names of <code>data</code>.
Alternatively, the EQN-equations can be provided within R as a character
value (cf. <code><a href="#topic+readEQN">readEQN</a></code>). Note that the first line of an .eqn-file
is reserved for comments and always ignored.</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_data">data</code></td>
<td>
<p>The (relative or full) path to the .csv file with the data (comma
separated; category labels in first row). Alternatively: a data frame or
matrix (rows=individuals, columns = individual category frequencies,
category labels as column names)</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_restrictions">restrictions</code></td>
<td>
<p>Specifies which parameters should be (a) constant (e.g.,
<code>"a=b=.5"</code>) or (b) constrained to be identical (e.g., <code>"Do=Dn"</code>)
or (c) treated as fixed effects (i.e., identical for all participants;
<code>"a=b=FE"</code>). Either given as the path to a text file with restrictions
per row or as a list of restrictions, e.g., <code>list("D1=D2","g=0.5")</code>.
Note that numbers in .eqn-equations (e.g., <code>d*(1-g)*.50</code>) are directly
interpreted as equality constraints.</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_covdata">covData</code></td>
<td>
<p>Data that contains covariates, for which correlations with
individual MPT parameters will be sampled. Either the path to a .csv file
(comma-separated: rows=individuals in the same order as <code>data</code>; first
row must contain covariate labels). Alternatively: a data frame or matrix
(rows=individuals, columns = variables; covariate labels as column names).
Note that in <code>betaMPT</code>, correlations are computed for discrete
variables that are coded numerically (in <code>traitMPT</code>, this can be
suppressed by using <code>predType="f"</code>)</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_corprobit">corProbit</code></td>
<td>
<p>whether to use probit-transformed MPT parameters to compute
correlations (probit-values of <code>+Inf</code> are truncated to
<code>max(5,max(probit))</code>; similarly for <code>-Inf</code>). Default for
beta-MPT: MPT parameters are used on the probability scale [0,1].</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of iterations per chain (including burnin samples). See
<code><a href="runjags.html#topic+run.jags">run.jags</a></code> for details.</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_n.burnin">n.burnin</code></td>
<td>
<p>Number of samples for burnin (samples will not be stored and
removed from n.iter)</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_n.thin">n.thin</code></td>
<td>
<p>Thinning rate.</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_n.chains">n.chains</code></td>
<td>
<p>number of MCMC chains (sampled in parallel).</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_ppp">ppp</code></td>
<td>
<p>number of samples to compute  posterior predictive p-value (see
<code><a href="#topic+posteriorPredictive">posteriorPredictive</a></code>)</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_shape">shape</code></td>
<td>
<p>shape parameter(s) of Gamma-hyperdistribution for the
hierarchical beta-parameters <code class="reqn">\alpha_s</code> and <code class="reqn">\beta_s</code> (can be a
named vector to provide different hyperpriors for each parameter)</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_rate">rate</code></td>
<td>
<p>rate parameter(s) of Gamma-hyperdistribution</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_parestfile">parEstFile</code></td>
<td>
<p>Name of the file to with the estimates should be stored
(e.g., &quot;parEstFile.txt&quot;)</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_posteriorfile">posteriorFile</code></td>
<td>
<p>path to RData-file where to save the model including
MCMC posterior samples (an object named <code>fittedModel</code>; e.g.,
<code>posteriorFile="mcmc.RData"</code>)</p>
</td></tr>
<tr><td><code id="betaMPTcpp_+3A_cores">cores</code></td>
<td>
<p>number of CPUs to be used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Heck
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# fit beta-MPT model for encoding condition (see ?arnold2013):
EQNfile &lt;- system.file("MPTmodels/2htsm.eqn", package = "TreeBUGS")
d.encoding &lt;- subset(arnold2013, group == "encoding", select = -(1:4))
fit &lt;- betaMPTcpp(EQNfile, d.encoding,
  n.thin = 5,
  restrictions = list("D1=D2=D3", "d1=d2", "a=g")
)
# convergence
plot(fit, parameter = "mean", type = "default")
summary(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='betweenSubjectMPT'>Between-Subject Comparison of Parameters</h2><span id='topic+betweenSubjectMPT'></span>

<h3>Description</h3>

<p>Computes differencesor other statistics of MPT parameters for two
hierarchical MPT models fitted separately to between-subjects data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betweenSubjectMPT(
  model1,
  model2,
  par1,
  par2 = par1,
  stat = c("x-y", "x&lt;y"),
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betweenSubjectMPT_+3A_model1">model1</code></td>
<td>
<p>fitted hierarchical MPT model for first between-subjects
condition</p>
</td></tr>
<tr><td><code id="betweenSubjectMPT_+3A_model2">model2</code></td>
<td>
<p>fitted hierarchical MPT model for second between-subjects
condition</p>
</td></tr>
<tr><td><code id="betweenSubjectMPT_+3A_par1">par1</code></td>
<td>
<p>label of parameter from first model for which statistic should be
computed</p>
</td></tr>
<tr><td><code id="betweenSubjectMPT_+3A_par2">par2</code></td>
<td>
<p>label of parameter from second model. Default: The same parameter
as in the first model</p>
</td></tr>
<tr><td><code id="betweenSubjectMPT_+3A_stat">stat</code></td>
<td>
<p>one or more functions of the parameters using <code>"x"</code> and
<code>"y"</code> as placeholders for the parameters from the first and second
model, respectively. Default: Compute (A) the difference between parameters
and (B) a Bayesian p-value (by counting how often x&lt;y).</p>
</td></tr>
<tr><td><code id="betweenSubjectMPT_+3A_plot">plot</code></td>
<td>
<p>whether to plot the convergence of the difference in parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the class <code>betweenMPT</code> with the values:
</p>

<ul>
<li> <p><code>summary</code>: Summary for parameter difference
</p>
</li>
<li> <p><code>mptInfo1</code>, <code>mptInfo2</code>: info about MPT models (eqn and data file etc.)
</p>
</li>
<li> <p><code>mcmc</code>: the MCMC samples of the differences in parameters
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Heck
</p>

<hr>
<h2 id='correlationPosterior'>Posterior Distribution for Correlations</h2><span id='topic+correlationPosterior'></span>

<h3>Description</h3>

<p>Adjusts the posterior distribution of correlations for the sampling error of
a population correlation according to the sample size (i.e., the number of
participants; Ly, Marsman, &amp; Wagenmakers, 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlationPosterior(
  fittedModel,
  r,
  N,
  kappa = 1,
  ci = 0.95,
  M = 1000,
  precision = 0.005,
  maxiter = 10000,
  plot = TRUE,
  nCPU = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlationPosterior_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>a fitted <a href="#topic+betaMPT">betaMPT</a> or <a href="#topic+traitMPT">traitMPT</a> model with
covariates (added during fitting by the argument <code>covData</code>)</p>
</td></tr>
<tr><td><code id="correlationPosterior_+3A_r">r</code></td>
<td>
<p>optional: a vector of posterior correlations (instead of
<code>fittedModel</code>)</p>
</td></tr>
<tr><td><code id="correlationPosterior_+3A_n">N</code></td>
<td>
<p>only if <code>r</code> is used: the number of participants the correlation
is based on</p>
</td></tr>
<tr><td><code id="correlationPosterior_+3A_kappa">kappa</code></td>
<td>
<p>parameter for the prior of the correlation, that is, a scaled
beta distribution: Beta(1/kappa, 1/kappa). The default <code>kappa=1</code>
defines a uniform distribution on [-1,1], whereas <code>kappa&lt;1</code> defines a
unimodal prior centered around zero.</p>
</td></tr>
<tr><td><code id="correlationPosterior_+3A_ci">ci</code></td>
<td>
<p>credibility interval</p>
</td></tr>
<tr><td><code id="correlationPosterior_+3A_m">M</code></td>
<td>
<p>number of subsamples from the fitted model</p>
</td></tr>
<tr><td><code id="correlationPosterior_+3A_precision">precision</code></td>
<td>
<p>precision on the interval [-1,1] to approximate the
posterior density</p>
</td></tr>
<tr><td><code id="correlationPosterior_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations in
<code><a href="hypergeo.html#topic+genhypergeo">genhypergeo</a></code>. Higher values might be necessary to
increase numerical stability for large correlations (r&gt;.95).</p>
</td></tr>
<tr><td><code id="correlationPosterior_+3A_plot">plot</code></td>
<td>
<p>whether to plot (a) the unadjusted posterior correlations (gray
histogram) and (b) the corrected posterior (black line with red credibility
intervals)</p>
</td></tr>
<tr><td><code id="correlationPosterior_+3A_ncpu">nCPU</code></td>
<td>
<p>number of CPUs used for parallel computation of posterior
distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function (1) uses all posterior samples of a correlation to (2)
derive the posterior of the correlation corrected for sampling error and (3)
averages these densities across the posterior samples. Thereby, the method
accounts for estimation uncertainty of the MPT model (due to the use of the
posterior samples) and also for sampling error of the population correlation
due to sample size (cf. Ly, Boehm, Heathcote, Turner, Forstmann, Marsman, &amp;
Matzke, 2016).
</p>


<h3>Author(s)</h3>

<p>Daniel W. Heck, Alexander Ly
</p>


<h3>References</h3>

<p>Ly, A., Marsman, M., &amp; Wagenmakers, E.-J. (2018). Analytic
posteriors for Pearson’s correlation coefficient. <em>Statistica
Neerlandica, 72</em>, 4–13. <a href="https://doi.org/10.1111/stan.12111">doi:10.1111/stan.12111</a>
</p>
<p>Ly, A., Boehm, U., Heathcote, A., Turner, B. M. , Forstmann, B., Marsman,
M., and Matzke, D. (2017). A flexible and efficient hierarchical Bayesian
approach to the exploration of individual differences in
cognitive-model-based neuroscience. <a href="https://osf.io/evsyv/">https://osf.io/evsyv/</a>.
<a href="https://doi.org/10.1002/9781119159193">doi:10.1002/9781119159193</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test effect of number of participants:
set.seed(123)
cors &lt;- rbeta(50, 100, 70)
correlationPosterior(r = cors, N = 10, nCPU = 1)
correlationPosterior(r = cors, N = 100, nCPU = 1)

</code></pre>

<hr>
<h2 id='extendMPT'>Extend MCMC Sampling for MPT Model</h2><span id='topic+extendMPT'></span>

<h3>Description</h3>

<p>Adds more MCMC samples to the fitted MPT model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extendMPT(fittedModel, n.iter = 10000, n.adapt = 1000, n.burnin = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extendMPT_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>a fitted <code><a href="#topic+traitMPT">traitMPT</a></code> or <code><a href="#topic+betaMPT">betaMPT</a></code></p>
</td></tr>
<tr><td><code id="extendMPT_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of iterations per chain (including burnin samples). See
<code><a href="runjags.html#topic+run.jags">run.jags</a></code> for details.</p>
</td></tr>
<tr><td><code id="extendMPT_+3A_n.adapt">n.adapt</code></td>
<td>
<p>number of adaption samples to adjust MCMC sampler in JAGS. The
sampler will be more efficient if it is tuned well. However, MCMC sampling
will still give correct results even if the warning appears: &quot;Adaptation
incomplete.&quot; (this just means that sampling efficiency could be better).</p>
</td></tr>
<tr><td><code id="extendMPT_+3A_n.burnin">n.burnin</code></td>
<td>
<p>Number of samples for burnin (samples will not be stored and
removed from n.iter)</p>
</td></tr>
<tr><td><code id="extendMPT_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>extend.jags</code> (see arguments
listed in: <a href="runjags.html#topic+run.jags">run.jags</a>).
</p>
<p>When drawing more samples, JAGS requires an additional adaptation phase, in
which the MCMC sampling procedure is adjusted. Note that the MCMC sampling
will still give correct results even if the warning appears: &quot;Adaptation
incomplete.&quot; (this just means that sampling efficiency is not optimal).</p>
</td></tr>
</table>

<hr>
<h2 id='genBetaMPT'>Generate Data for Beta MPT Models</h2><span id='topic+genBetaMPT'></span>

<h3>Description</h3>

<p>Generating a data file with known parameter structure using the Beta-MPT.
Useful for simulations and robustness checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genBetaMPT(
  N,
  numItems,
  eqnfile,
  restrictions,
  mean = NULL,
  sd = NULL,
  alpha = NULL,
  beta = NULL,
  warning = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genBetaMPT_+3A_n">N</code></td>
<td>
<p>number of participants</p>
</td></tr>
<tr><td><code id="genBetaMPT_+3A_numitems">numItems</code></td>
<td>
<p>number of responses per tree (a named vector with tree
labels)</p>
</td></tr>
<tr><td><code id="genBetaMPT_+3A_eqnfile">eqnfile</code></td>
<td>
<p>The (relative or full) path to the file that specifies the MPT
model (standard .eqn syntax). Note that category labels must start with a
letter (different to multiTree) and match the column names of <code>data</code>.
Alternatively, the EQN-equations can be provided within R as a character
value (cf. <code><a href="#topic+readEQN">readEQN</a></code>). Note that the first line of an .eqn-file
is reserved for comments and always ignored.</p>
</td></tr>
<tr><td><code id="genBetaMPT_+3A_restrictions">restrictions</code></td>
<td>
<p>Specifies which parameters should be (a) constant (e.g.,
<code>"a=b=.5"</code>) or (b) constrained to be identical (e.g., <code>"Do=Dn"</code>)
or (c) treated as fixed effects (i.e., identical for all participants;
<code>"a=b=FE"</code>). Either given as the path to a text file with restrictions
per row or as a list of restrictions, e.g., <code>list("D1=D2","g=0.5")</code>.
Note that numbers in .eqn-equations (e.g., <code>d*(1-g)*.50</code>) are directly
interpreted as equality constraints.</p>
</td></tr>
<tr><td><code id="genBetaMPT_+3A_mean">mean</code></td>
<td>
<p>Named vector of true group means of individual MPT parameters. If
the vector is not named, the internal order of parameters is used (can be
obtained using <code><a href="#topic+readEQN">readEQN</a></code>).</p>
</td></tr>
<tr><td><code id="genBetaMPT_+3A_sd">sd</code></td>
<td>
<p>named vector of group standard deviations of individual MPT
parameters.</p>
</td></tr>
<tr><td><code id="genBetaMPT_+3A_alpha">alpha</code></td>
<td>
<p>Alternative specification of the group-level distribution using
the shape parameters of the beta distribution (see <a href="stats.html#topic+dbeta">dbeta</a>).</p>
</td></tr>
<tr><td><code id="genBetaMPT_+3A_beta">beta</code></td>
<td>
<p>see <code>alpha</code></p>
</td></tr>
<tr><td><code id="genBetaMPT_+3A_warning">warning</code></td>
<td>
<p>whether to show warning in case the naming of data-generating
parameters are unnamed or do not match</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data are generated in a two-step procedure. First, person parameters
are sampled from the specified beta distributions for each paramter (either
based on mean/sd or based on alpha/beta). In a second step, response
frequencies are sampled for each person using <code><a href="#topic+genMPT">genMPT</a></code>.
</p>


<h3>Value</h3>

<p>a list including the generated frequencies (<code>data</code>) and the
true, underlying parameters (<code>parameters</code>) on the group and individual
level.
</p>


<h3>References</h3>

<p>Smith, J. B., &amp; Batchelder, W. H. (2010). Beta-MPT: Multinomial
processing tree models for addressing individual differences. Journal of
Mathematical Psychology, 54, 167-183.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genMPT">genMPT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: Standard Two-High-Threshold Model (2HTM)
EQNfile &lt;- system.file("MPTmodels/2htm.eqn", package = "TreeBUGS")
genDat &lt;- genBetaMPT(
  N = 100,
  numItems = c(Target = 250, Lure = 250),
  eqnfile = EQNfile,
  mean = c(Do = .7, Dn = .5, g = .5),
  sd = c(Do = .1, Dn = .1, g = .05)
)
head(genDat$data, 3)
plotFreq(genDat$data, eqn = EQNfile)
</code></pre>

<hr>
<h2 id='genMPT'>Generate MPT Frequencies</h2><span id='topic+genMPT'></span>

<h3>Description</h3>

<p>Uses a matrix of individual MPT parameters to generate MPT frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genMPT(theta, numItems, eqnfile, restrictions, warning = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genMPT_+3A_theta">theta</code></td>
<td>
<p>matrix of MPT parameters (rows: individuals; columns:
parameters). Parameters are assigned by column names of the matrix. all of
the parameters in the model file need to be included.</p>
</td></tr>
<tr><td><code id="genMPT_+3A_numitems">numItems</code></td>
<td>
<p>number of responses per tree (a named vector with tree
labels)</p>
</td></tr>
<tr><td><code id="genMPT_+3A_eqnfile">eqnfile</code></td>
<td>
<p>The (relative or full) path to the file that specifies the MPT
model (standard .eqn syntax). Note that category labels must start with a
letter (different to multiTree) and match the column names of <code>data</code>.
Alternatively, the EQN-equations can be provided within R as a character
value (cf. <code><a href="#topic+readEQN">readEQN</a></code>). Note that the first line of an .eqn-file
is reserved for comments and always ignored.</p>
</td></tr>
<tr><td><code id="genMPT_+3A_restrictions">restrictions</code></td>
<td>
<p>Specifies which parameters should be (a) constant (e.g.,
<code>"a=b=.5"</code>) or (b) constrained to be identical (e.g., <code>"Do=Dn"</code>)
or (c) treated as fixed effects (i.e., identical for all participants;
<code>"a=b=FE"</code>). Either given as the path to a text file with restrictions
per row or as a list of restrictions, e.g., <code>list("D1=D2","g=0.5")</code>.
Note that numbers in .eqn-equations (e.g., <code>d*(1-g)*.50</code>) are directly
interpreted as equality constraints.</p>
</td></tr>
<tr><td><code id="genMPT_+3A_warning">warning</code></td>
<td>
<p>whether to show warning in case the naming of data-generating
parameters are unnamed or do not match</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+genTraitMPT">genTraitMPT</a></code> and <code><a href="#topic+genBetaMPT">genBetaMPT</a></code> to generate
data for latent normal/beta hierarchical distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: Standard Two-High-Threshold Model (2HTM)
EQNfile &lt;- system.file("MPTmodels/2htm.eqn", package = "TreeBUGS")
theta &lt;- matrix(
  c(
    .8, .4, .5,
    .6, .3, .4
  ),
  nrow = 2, byrow = TRUE,
  dimnames = list(NULL, c("Do", "Dn", "g"))
)
genDat &lt;- genMPT(
  theta, c(Target = 250, Lure = 250),
  EQNfile
)
genDat
</code></pre>

<hr>
<h2 id='genTraitMPT'>Generate Data for Latent-Trait MPT Models</h2><span id='topic+genTraitMPT'></span>

<h3>Description</h3>

<p>Generating a data set with known parameter structure using the Trait-MPT.
Useful for simulations and robustness checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genTraitMPT(
  N,
  numItems,
  eqnfile,
  restrictions,
  mean,
  mu,
  sigma,
  rho,
  warning = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genTraitMPT_+3A_n">N</code></td>
<td>
<p>number of participants</p>
</td></tr>
<tr><td><code id="genTraitMPT_+3A_numitems">numItems</code></td>
<td>
<p>number of responses per tree (a named vector with tree
labels)</p>
</td></tr>
<tr><td><code id="genTraitMPT_+3A_eqnfile">eqnfile</code></td>
<td>
<p>The (relative or full) path to the file that specifies the MPT
model (standard .eqn syntax). Note that category labels must start with a
letter (different to multiTree) and match the column names of <code>data</code>.
Alternatively, the EQN-equations can be provided within R as a character
value (cf. <code><a href="#topic+readEQN">readEQN</a></code>). Note that the first line of an .eqn-file
is reserved for comments and always ignored.</p>
</td></tr>
<tr><td><code id="genTraitMPT_+3A_restrictions">restrictions</code></td>
<td>
<p>Specifies which parameters should be (a) constant (e.g.,
<code>"a=b=.5"</code>) or (b) constrained to be identical (e.g., <code>"Do=Dn"</code>)
or (c) treated as fixed effects (i.e., identical for all participants;
<code>"a=b=FE"</code>). Either given as the path to a text file with restrictions
per row or as a list of restrictions, e.g., <code>list("D1=D2","g=0.5")</code>.
Note that numbers in .eqn-equations (e.g., <code>d*(1-g)*.50</code>) are directly
interpreted as equality constraints.</p>
</td></tr>
<tr><td><code id="genTraitMPT_+3A_mean">mean</code></td>
<td>
<p>named vector of data-generating group means of the individual MPT
parameters on the probability scale. If the vector is not named, the
internal order of parameters is used (can be obtained using
<code><a href="#topic+readEQN">readEQN</a></code>).</p>
</td></tr>
<tr><td><code id="genTraitMPT_+3A_mu">mu</code></td>
<td>
<p>an alternative way to define the group-level means on the
latent-probit scale (i.e., <code>mu = qnorm(mean)</code> or equivalently,
<code>mean = pnorm(mu)</code>).</p>
</td></tr>
<tr><td><code id="genTraitMPT_+3A_sigma">sigma</code></td>
<td>
<p>(named) vector of group standard deviations of individual MPT
parameters on the latent probit scale. Default is zero (no person
heterogeneity).</p>
</td></tr>
<tr><td><code id="genTraitMPT_+3A_rho">rho</code></td>
<td>
<p>(named) correlation matrix for individual MPT parameters on the
latent probit scale. Must be symmetric and positive definite (e.g., no
correlations of 1 or -1 allowed). Default: a diagonal matrix (i.e., zero
correlations).</p>
</td></tr>
<tr><td><code id="genTraitMPT_+3A_warning">warning</code></td>
<td>
<p>whether to show warning in case the naming of data-generating
parameters are unnamed or do not match</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions implements a two-step sampling procedure. First, the
person parameters on the latent probit-scale are sampled from the
multivariate normal distribution (based on the mean <code>mu = qnorm(mean)</code>,
the standard deviations <code>sigma</code>, and the correlation matrix <code>rho</code>).
These person parameters are then transformed to the probability scale using
the probit-link. In a last step, observed frequencies are sampled for each
person using the MPT equations.
</p>
<p>Note that the user can generate more complex structures for the latent person
parameters, and then supply these person parameters to the function
<code><a href="#topic+genMPT">genMPT</a></code>.
</p>


<h3>Value</h3>

<p>a list including the generated frequencies per person (<code>data</code>)
and the sampled individual parameters (<code>parameters</code>) on the probit and
probability scale (<code>thetaLatent</code> and <code>theta</code>, respectively).
</p>


<h3>References</h3>

<p>Klauer, K. C. (2010). Hierarchical multinomial processing tree
models: A latent-trait approach. Psychometrika, 75, 70-98.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genMPT">genMPT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: Standard Two-High-Threshold Model (2HTM)
EQNfile &lt;- system.file("MPTmodels/2htm.eqn", package = "TreeBUGS")
rho &lt;- matrix(c(
  1, .8, .2,
  .8, 1, .1,
  .2, .1, 1
), nrow = 3)
colnames(rho) &lt;- rownames(rho) &lt;- c("Do", "Dn", "g")
genDat &lt;- genTraitMPT(
  N = 100,
  numItems = c(Target = 250, Lure = 250),
  eqnfile = EQNfile,
  mean = c(Do = .7, Dn = .7, g = .5),
  sigma = c(Do = .3, Dn = .3, g = .15),
  rho = rho
)
head(genDat$data, 3)
plotFreq(genDat$data, eqn = EQNfile)
</code></pre>

<hr>
<h2 id='getGroupMeans'>Get Mean Parameters per Group</h2><span id='topic+getGroupMeans'></span>

<h3>Description</h3>

<p>For hierarchical latent-trait MPT models with discrete predictor variables as
fitted with <code>traitMPT(..., predStructure = list("f"))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGroupMeans(
  traitMPT,
  factor = "all",
  probit = FALSE,
  file = NULL,
  mcmc = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGroupMeans_+3A_traitmpt">traitMPT</code></td>
<td>
<p>a fitted <code><a href="#topic+traitMPT">traitMPT</a></code> model</p>
</td></tr>
<tr><td><code id="getGroupMeans_+3A_factor">factor</code></td>
<td>
<p>whether to get group estimates for all combinations of factor
levels (default) or only for specific factors (requires the names of the
covariates in covData)</p>
</td></tr>
<tr><td><code id="getGroupMeans_+3A_probit">probit</code></td>
<td>
<p>whether to use probit scale or probability scale</p>
</td></tr>
<tr><td><code id="getGroupMeans_+3A_file">file</code></td>
<td>
<p>filename to export results in .csv format (e.g.,
<code>file="fit_group.csv"</code>)</p>
</td></tr>
<tr><td><code id="getGroupMeans_+3A_mcmc">mcmc</code></td>
<td>
<p>if <code>TRUE</code>, the raw MCMC samples for the group means are
returned as an <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object. This allows pairwise
tests of group means (see <code><a href="#topic+transformedParameters">transformedParameters</a></code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Heck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getParam">getParam</a></code> for parameter estimates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# save group means (probability scale):
getGroupMeans(traitMPT, file = "groups.csv")

## End(Not run)
</code></pre>

<hr>
<h2 id='getParam'>Get Parameter Posterior Statistics</h2><span id='topic+getParam'></span>

<h3>Description</h3>

<p>Returns posterior statistics (e.g., mean, median) for the parameters of a
hierarchical MPT model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParam(fittedModel, parameter = "mean", stat = "mean", file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParam_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>a fitted latent-trait MPT model (see
<code><a href="#topic+traitMPT">traitMPT</a></code>) or beta MPT model (see <code><a href="#topic+betaMPT">betaMPT</a></code>)</p>
</td></tr>
<tr><td><code id="getParam_+3A_parameter">parameter</code></td>
<td>
<p>which parameter(s) of the (hierarchical) MPT model should be
returned? (see details in <code><a href="#topic+getParam">getParam</a></code>).</p>
</td></tr>
<tr><td><code id="getParam_+3A_stat">stat</code></td>
<td>
<p>whether to get the posterior <code>"mean"</code>, <code>"median"</code>,
<code>"sd"</code>, or <code>"summary"</code> (includes mean, SD, and 95% credibility
interval)</p>
</td></tr>
<tr><td><code id="getParam_+3A_file">file</code></td>
<td>
<p>filename to export results in .csv format (e.g.,
<code>file="est_param.csv"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenient way to get the information stored in
<code>fittedModel$mcmc.summ</code>.
</p>
<p>The latent-trait MPT includes the following parameters:
</p>

<ul>
<li> <p><code>"mean"</code> (group means on probability scale)
</p>
</li>
<li> <p><code>"mu"</code> (group means on probit scale)
</p>
</li>
<li> <p><code>"sigma"</code> (SD on probit scale)
</p>
</li>
<li> <p><code>"rho"</code> (correlations on probit scale)
</p>
</li>
<li> <p><code>"theta"</code> (individual MPT parameters)
</p>
</li></ul>

<p>The beta MPT includes the following parameters:
</p>

<ul>
<li> <p><code>"mean"</code> (group means on probability scale)
</p>
</li>
<li> <p><code>"sd"</code> (SD on probability scale)
</p>
</li>
<li> <p><code>"alph"</code>,<code>"bet"</code> (group parameters of beta distribution)
</p>
</li>
<li> <p><code>"theta"</code> (individual MPT parameters)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Heck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getGroupMeans">getGroupMeans</a></code> mean group estimates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# mean estimates per person:
getParam(fittedModel, parameter = "theta")

# save summary of individual estimates:
getParam(fittedModel,
  parameter = "theta",
  stat = "summary", file = "ind_summ.csv"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='getSamples'>Get Posterior Samples from Fitted MPT Model</h2><span id='topic+getSamples'></span>

<h3>Description</h3>

<p>Extracts MCMC posterior samples as an <code>coda::mcmc.list</code> and relabels the
MCMC variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSamples(
  fittedModel,
  parameter = "mean",
  select = "all",
  names = "par_label"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSamples_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>a fitted latent-trait MPT model (see
<code><a href="#topic+traitMPT">traitMPT</a></code>) or beta MPT model (see <code><a href="#topic+betaMPT">betaMPT</a></code>)</p>
</td></tr>
<tr><td><code id="getSamples_+3A_parameter">parameter</code></td>
<td>
<p>which parameter(s) of the (hierarchical) MPT model should be
returned? (see details in <code><a href="#topic+getParam">getParam</a></code>).</p>
</td></tr>
<tr><td><code id="getSamples_+3A_select">select</code></td>
<td>
<p>character vector of parameters to be plotted (e.g., <code>select = c("d", "g")</code>. Can be used to plot subsets of parameters and change the order of parameters.</p>
</td></tr>
<tr><td><code id="getSamples_+3A_names">names</code></td>
<td>
<p>whether and how to rename the variables in the MCMC output:
<code>par</code> (internal parameter labels such as <code>mu[1]</code>), <code>label</code>
(MPT label from EQN file such as <code>"d"</code>), or <code>par_name</code>
(concatenation of both such as <code>"mu[1]_d"</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getSamples(fittedModel, "mu", select = c("d", "g"))

## End(Not run)
</code></pre>

<hr>
<h2 id='marginalMPT'>Marginal Likelihood for Simple MPT</h2><span id='topic+marginalMPT'></span>

<h3>Description</h3>

<p>Computes the marginal likelihood for simple (fixed-effects, nonhierarchical)
MPT models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalMPT(
  eqnfile,
  data,
  restrictions,
  alpha = 1,
  beta = 1,
  dataset = 1,
  method = "importance",
  posterior = 500,
  mix = 0.05,
  scale = 0.9,
  samples = 10000,
  batches = 10,
  show = TRUE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalMPT_+3A_eqnfile">eqnfile</code></td>
<td>
<p>The (relative or full) path to the file that specifies the MPT
model (standard .eqn syntax). Note that category labels must start with a
letter (different to multiTree) and match the column names of <code>data</code>.
Alternatively, the EQN-equations can be provided within R as a character
value (cf. <code><a href="#topic+readEQN">readEQN</a></code>). Note that the first line of an .eqn-file
is reserved for comments and always ignored.</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_data">data</code></td>
<td>
<p>The (relative or full) path to the .csv file with the data (comma
separated; category labels in first row). Alternatively: a data frame or
matrix (rows=individuals, columns = individual category frequencies,
category labels as column names)</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_restrictions">restrictions</code></td>
<td>
<p>Specifies which parameters should be (a) constant (e.g.,
<code>"a=b=.5"</code>) or (b) constrained to be identical (e.g., <code>"Do=Dn"</code>)
or (c) treated as fixed effects (i.e., identical for all participants;
<code>"a=b=FE"</code>). Either given as the path to a text file with restrictions
per row or as a list of restrictions, e.g., <code>list("D1=D2","g=0.5")</code>.
Note that numbers in .eqn-equations (e.g., <code>d*(1-g)*.50</code>) are directly
interpreted as equality constraints.</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_alpha">alpha</code></td>
<td>
<p>first shape parameter(s) for the beta prior-distribution of the
MPT parameters <code class="reqn">\theta_s</code> (can be a named vector to use a different
prior for each MPT parameter)</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_beta">beta</code></td>
<td>
<p>second shape parameter(s)</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_dataset">dataset</code></td>
<td>
<p>for which data set should Bayes factors be computed?</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_method">method</code></td>
<td>
<p>either <code>"importance"</code> (importance sampling using a mixture
of uniform and beta-aproximation of the posterior) or <code>"prior"</code> (brute
force Monte Carlo sampling from prior)</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_posterior">posterior</code></td>
<td>
<p>number of posterior samples used to approximate
importance-sampling densities (i.e., beta distributions)</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_mix">mix</code></td>
<td>
<p>mixture proportion of the uniform distribution for the
importance-sampling density</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_scale">scale</code></td>
<td>
<p>how much should posterior-beta approximations be downscaled to
get fatter importance-sampling density</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_samples">samples</code></td>
<td>
<p>total number of samples from parameter space</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_batches">batches</code></td>
<td>
<p>number of batches. Used to compute a standard error of the
estimate.</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_show">show</code></td>
<td>
<p>whether to show progress</p>
</td></tr>
<tr><td><code id="marginalMPT_+3A_cores">cores</code></td>
<td>
<p>number of CPUs used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, this is only implemented for a single data set!
</p>
<p>If <code>method = "prior"</code>, a brute-force Monte Carlo method is used and
parameters are directly sampled from the prior.Then, the likelihood is
evaluated for these samples and averaged (fast, but inefficient).
</p>
<p>Alternatively, an importance sampler is used if <code>method = "importance"</code>,
and the posterior distributions of the MPT parameters are approximated by
independent beta distributions. Then each parameter <code class="reqn">s</code> is sampled from
the importance density:
</p>
<p><code class="reqn">mix*U(0,1) + (1-mix)*Beta(scale*a_s, scale*b_s)</code>
</p>


<h3>References</h3>

<p>Vandekerckhove, J. S., Matzke, D., &amp; Wagenmakers, E. (2015).
Model comparison and the principle of parsimony. In Oxford Handbook of
Computational and Mathematical Psychology (pp. 300-319). New York, NY:
Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BayesFactorMPT">BayesFactorMPT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2-High-Threshold Model
eqn &lt;- "## 2HTM ##
   Target  Hit  d
   Target  Hit  (1-d)*g
   Target  Miss (1-d)*(1-g)
   Lure    FA   (1-d)*g
   Lure    CR   (1-d)*(1-g)
   Lure    CR   d"
data &lt;- c(
  Hit = 46, Miss = 14,
  FA = 14, CR = 46
)

# weakly informative prior for guessing
aa &lt;- c(d = 1, g = 2)
bb &lt;- c(d = 1, g = 2)
curve(dbeta(x, aa["g"], bb["g"]))

# compute marginal likelihood
htm &lt;- marginalMPT(eqn, data,
  alpha = aa, beta = bb,
  posterior = 200, samples = 1000
)
# second model: g=.50
htm.g50 &lt;- marginalMPT(eqn, data, list("g=.5"),
  alpha = aa, beta = bb,
  posterior = 200, samples = 1000
)

# Bayes factor
# (per batch to get estimation error)
bf &lt;- htm.g50$p.per.batch / htm$p.per.batch
mean(bf) # BF
sd(bf) / sqrt(length(bf)) # standard error of BF estimate

</code></pre>

<hr>
<h2 id='plot.betaMPT'>Plot Convergence for Hierarchical MPT Models</h2><span id='topic+plot.betaMPT'></span><span id='topic+plot.simpleMPT'></span><span id='topic+plot.traitMPT'></span>

<h3>Description</h3>

<p>Plot Convergence for Hierarchical MPT Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betaMPT'
plot(x, parameter = "mean", type = "default", ...)

## S3 method for class 'simpleMPT'
plot(x, type = "default", ...)

## S3 method for class 'traitMPT'
plot(x, parameter = "mean", type = "default", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.betaMPT_+3A_x">x</code></td>
<td>
<p>fitted hierarchical MPT model (<code><a href="#topic+traitMPT">traitMPT</a></code>, <code><a href="#topic+betaMPT">betaMPT</a></code>)</p>
</td></tr>
<tr><td><code id="plot.betaMPT_+3A_parameter">parameter</code></td>
<td>
<p>which parameter to plot (e.g., <code>"theta"</code>,
<code>"mean"</code>, <code>"rho"</code>, <code>"slope"</code>).
Parameters are matched partially, in order to plot all entries of vector
valued parameters (see <code><a href="#topic+getParam">getParam</a></code> to get a list of parameters).
Moreover, parameter labels can be used, e.g., <code>"theta[D]"</code> or <code>"rho[D,g]"</code></p>
</td></tr>
<tr><td><code id="plot.betaMPT_+3A_type">type</code></td>
<td>
<p>type of convergence plot. Can be one of <code>"default"</code>
(trace+density), <code>"acf"</code> (auto-correlation function),
<code>"trace"</code>, <code>"autocorr"</code>, <code>"crosscorr"</code>,<code>"density"</code>,
<code>"gelman"</code>. See plotting functions in the <code>coda</code> package
(<code><a href="coda.html#topic+plot.mcmc.list">plot.mcmc.list</a></code>,
<code><a href="coda.html#topic+acfplot">acfplot</a></code>,
<code><a href="coda.html#topic+traceplot">traceplot</a></code>,
<code><a href="coda.html#topic+autocorr.plot">autocorr.plot</a></code>,
<code><a href="coda.html#topic+crosscorr.plot">crosscorr.plot</a></code>,
<code><a href="coda.html#topic+densplot">densplot</a></code>,
<code><a href="coda.html#topic+gelman.plot">gelman.plot</a></code>
).</p>
</td></tr>
<tr><td><code id="plot.betaMPT_+3A_...">...</code></td>
<td>
<p>further arguments passed to the plotting functions in coda</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>plot(betaMPT)</code>: Plot convergence for beta MPT
</p>
</li>
<li> <p><code>plot(simpleMPT)</code>: Plot convergence for nonhierarchical MPT model
</p>
</li>
<li> <p><code>plot(traitMPT)</code>: Plot convergence for latent-trait MPT
</p>
</li></ul>

<hr>
<h2 id='plotDistribution'>Plot Distribution of Individual Estimates</h2><span id='topic+plotDistribution'></span>

<h3>Description</h3>

<p>Plots histograms of the posterior-means of individual MPT parameters against
the group-level distribution given by the posterior-mean of the hierarchical
parameters (e.g., the beta distribution in case of the beta-MPT)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDistribution(fittedModel, scale = "probability", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDistribution_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>fitted latent-trait or beta MPT model
(<code><a href="#topic+traitMPT">traitMPT</a></code>, <code><a href="#topic+betaMPT">betaMPT</a></code>)</p>
</td></tr>
<tr><td><code id="plotDistribution_+3A_scale">scale</code></td>
<td>
<p>only for latent-trait MPT: should estimates be plotted on the
<code>"latent"</code> or the <code>"probability"</code> scale (i.e., as MPT
parameters). Can be abbreviated by <code>"l"</code>  and <code>"p"</code>.</p>
</td></tr>
<tr><td><code id="plotDistribution_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+hist">hist</a></code> (e.g.,
<code>breaks=50</code> to get a more fine-grained histogram)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the latent-trait MPT, differences due to continuous predictors
or discrete factors are currently not considered in the group-level
predictions (red density). Under such a model, individual estimates are not
predicted to be normally distributed on the latent scale as shown in the
plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.traitMPT">plot.traitMPT</a></code>
</p>

<hr>
<h2 id='plotFit'>Plot Posterior Predictive Mean Frequencies</h2><span id='topic+plotFit'></span>

<h3>Description</h3>

<p>Plots observed means/covariances of individual frequencies against the
means/covariances sampled from the posterior distribution (posterior
predictive distribution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFit(fittedModel, M = 1000, stat = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFit_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>fitted latent-trait or beta MPT model (<code><a href="#topic+traitMPT">traitMPT</a></code>, <code><a href="#topic+betaMPT">betaMPT</a></code>)</p>
</td></tr>
<tr><td><code id="plotFit_+3A_m">M</code></td>
<td>
<p>number of posterior predictive samples. As a maximum, the number of posterior samples in <code>fittedModel</code> is used.</p>
</td></tr>
<tr><td><code id="plotFit_+3A_stat">stat</code></td>
<td>
<p>whether to plot mean frequencies (<code>"mean"</code>) or covariances
of individual frequencies (<code>"cov"</code>)</p>
</td></tr>
<tr><td><code id="plotFit_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+boxplot">boxplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If posterior predictive p-values were computed when fitting the
model (e.g., by adding the argument <code>traitMPT(...,ppp=1000)</code> ), the
stored posterior samples are re-used for plotting. Note that the last
category in each MPT tree is dropped, because one category per multinomial
distribution is fixed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# add posterior predictive samples to fitted model (optional step)
fittedModel$postpred$freq.pred &lt;-
  posteriorPredictive(fittedModel, M = 1000)

# plot model fit
plotFit(fittedModel, stat = "mean")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotFreq'>Plot Raw Frequencies</h2><span id='topic+plotFreq'></span>

<h3>Description</h3>

<p>Plot observed individual and mean frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFreq(x, freq = TRUE, select = "all", boxplot = TRUE, eqnfile, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFreq_+3A_x">x</code></td>
<td>
<p>either a fitted hierarchical MPT model (see <code><a href="#topic+traitMPT">traitMPT</a></code>,
<code><a href="#topic+betaMPT">betaMPT</a></code>); or a matrix/data frame of response frequencies (can
be provided as a path to a .csv-file with individual frequencies).</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_freq">freq</code></td>
<td>
<p>whether to plot absolute frequencies or relative frequencies
(which sum up to one within each tree; only if <code>x</code> is a hierarchical
model or if <code>eqnfile</code> is provided)</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_select">select</code></td>
<td>
<p>a numeric vector with participant indices to select which raw
frequencies to plot (default: <code>"all"</code>)</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_boxplot">boxplot</code></td>
<td>
<p>if <code>FALSE</code>, lines and points are drawn instead of
boxplots</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_eqnfile">eqnfile</code></td>
<td>
<p>optional: EQN description of an MPT model, that is, either the
path to an EQN file or as a character string (only used if <code>x</code> refers
to a matrix/data frame or .csv-file)</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>boxplot</code> and <code>plot</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># get frequency data and EQN file
freq &lt;- subset(arnold2013, group == "encoding", select = -(1:4))
eqn &lt;- system.file("MPTmodels/2htsm.eqn", package = "TreeBUGS")
plotFreq(freq, eqnfile = eqn)
plotFreq(freq, freq = FALSE, eqnfile = eqn)
</code></pre>

<hr>
<h2 id='plotParam'>Plot Parameter Estimates</h2><span id='topic+plotParam'></span>

<h3>Description</h3>

<p>Plot parameter estimates for hierarchical MPT models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotParam(
  x,
  includeIndividual = TRUE,
  addLines = FALSE,
  estimate = "mean",
  select = "all",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotParam_+3A_x">x</code></td>
<td>
<p>a fitted Beta or latent-trait MPT model</p>
</td></tr>
<tr><td><code id="plotParam_+3A_includeindividual">includeIndividual</code></td>
<td>
<p>whether to plot individual estimates</p>
</td></tr>
<tr><td><code id="plotParam_+3A_addlines">addLines</code></td>
<td>
<p>whether to connect individual parameter estimates by lines</p>
</td></tr>
<tr><td><code id="plotParam_+3A_estimate">estimate</code></td>
<td>
<p>type of point estimates for group-level and individual parameters
(either <code>"mean"</code> or <code>"median"</code>)</p>
</td></tr>
<tr><td><code id="plotParam_+3A_select">select</code></td>
<td>
<p>character vector of parameters to be plotted (e.g., <code>select = c("d", "g")</code>. Can be used to plot subsets of parameters and change the order of parameters.</p>
</td></tr>
<tr><td><code id="plotParam_+3A_...">...</code></td>
<td>
<p>further arguments passed to the standard <code><a href="graphics.html#topic+plot">plot</a></code> function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Heck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betaMPT">betaMPT</a></code>, <code><a href="#topic+traitMPT">traitMPT</a></code>, <code><a href="#topic+plotDistribution">plotDistribution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plotParam(fit,
  addLines = TRUE,
  estimate = "median",
  select = c("d1", "d2")
)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotPrior'>Plot Prior Distributions</h2><span id='topic+plotPrior'></span>

<h3>Description</h3>

<p>Plots prior distributions for group means, standard deviation, and
correlations of MPT parameters across participants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPrior(prior, probitInverse = "mean", M = 5000, nCPU = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPrior_+3A_prior">prior</code></td>
<td>
<p>a named list defining the priors. For the <a href="#topic+traitMPT">traitMPT</a>, the
default is <code>list(mu = "dnorm(0,1)", xi="dunif(0,10)", V=diag(S),
df=S+1)</code>, where S is the number of free parameters. For the <a href="#topic+betaMPT">betaMPT</a>,
the default is <code>list(alpha ="dgamma(1,.1)", beta = "dgamma(1,.1)")</code>.
Note that the normal distribution <code>"dnorm(mu,prec)"</code> is parameterized
as in JAGS by the mean and precision (= 1/variance).</p>
</td></tr>
<tr><td><code id="plotPrior_+3A_probitinverse">probitInverse</code></td>
<td>
<p>which latent-probit parameters (for
<code><a href="#topic+traitMPT">traitMPT</a></code> model) to transform to probability scale. Either
<code>"none"</code>, <code>"mean"</code> (simple transformation <code class="reqn">\Phi(\mu)</code>), or
<code>"mean_sd"</code> (see <code><a href="#topic+probitInverse">probitInverse</a></code>)</p>
</td></tr>
<tr><td><code id="plotPrior_+3A_m">M</code></td>
<td>
<p>number of random samples to approximate priors of group-level
parameters</p>
</td></tr>
<tr><td><code id="plotPrior_+3A_ncpu">nCPU</code></td>
<td>
<p>number of CPUs used for parallel sampling. For large models and
many participants, this may require a lot of memory.</p>
</td></tr>
<tr><td><code id="plotPrior_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples from a set of hyperpriors (either for
hierarchical traitMPT or betaMPT structure) to approximate the implied
prior distributions on the parameters of interest (group-level mean, SD,
and correlations of MPT parameters). Note that the normal distribution
<code>"dnorm(mu,prec)"</code> is parameterized as in JAGS by the mean and
precision (= 1/variance).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+priorPredictive">priorPredictive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# default priors for traitMPT:
plotPrior(list(
  mu = "dnorm(0, 1)",
  xi = "dunif(0, 10)",
  V = diag(2),
  df = 2 + 1
), M = 4000)

# default priors for betaMPT:
plotPrior(list(
  alpha = "dgamma(1, 0.1)",
  beta = "dgamma(1, 0.1)"
), M = 4000)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotPriorPost'>Plot Prior vs. Posterior Distribution</h2><span id='topic+plotPriorPost'></span>

<h3>Description</h3>

<p>Allows to judge how much the data informed the parameter posterior
distributions compared to the prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPriorPost(
  fittedModel,
  probitInverse = "mean",
  M = 2e+05,
  ci = 0.95,
  nCPU = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPriorPost_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>fitted latent-trait or beta MPT model (<code><a href="#topic+traitMPT">traitMPT</a></code>, <code><a href="#topic+betaMPT">betaMPT</a></code>)</p>
</td></tr>
<tr><td><code id="plotPriorPost_+3A_probitinverse">probitInverse</code></td>
<td>
<p>which latent-probit parameters (for
<code><a href="#topic+traitMPT">traitMPT</a></code> model) to transform to probability scale. Either
<code>"none"</code>, <code>"mean"</code> (simple transformation <code class="reqn">\Phi(\mu)</code>), or
<code>"mean_sd"</code> (see <code><a href="#topic+probitInverse">probitInverse</a></code>)</p>
</td></tr>
<tr><td><code id="plotPriorPost_+3A_m">M</code></td>
<td>
<p>number of random samples to approximate prior distributions</p>
</td></tr>
<tr><td><code id="plotPriorPost_+3A_ci">ci</code></td>
<td>
<p>credibility interval indicated by vertical red lines</p>
</td></tr>
<tr><td><code id="plotPriorPost_+3A_ncpu">nCPU</code></td>
<td>
<p>number of CPUs used for parallel sampling. For large models and
many participants, this may require a lot of memory.</p>
</td></tr>
<tr><td><code id="plotPriorPost_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+boxplot">boxplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prior distributions are shown as blue, dashed lines, whereas
posterior distributions are shown as solid, black lines.
</p>

<hr>
<h2 id='posteriorPredictive'>Get Posterior Predictive Samples</h2><span id='topic+posteriorPredictive'></span>

<h3>Description</h3>

<p>Draw predicted frequencies based on posterior distribution of (a) individual estimates (default) or (b) for a new participant (if <code>numItems</code> is provided; does not consider continuous or discrete predictors in traitMPT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriorPredictive(
  fittedModel,
  M = 100,
  numItems = NULL,
  expected = FALSE,
  nCPU = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriorPredictive_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>fitted latent-trait or beta MPT model (<code><a href="#topic+traitMPT">traitMPT</a></code>, <code><a href="#topic+betaMPT">betaMPT</a></code>)</p>
</td></tr>
<tr><td><code id="posteriorPredictive_+3A_m">M</code></td>
<td>
<p>number of posterior predictive samples. As a maximum, the number of posterior samples in <code>fittedModel</code> is used.</p>
</td></tr>
<tr><td><code id="posteriorPredictive_+3A_numitems">numItems</code></td>
<td>
<p>optional: a vector with the number of items per MPT tree to sample predicted data for a new participant (first, a participant vector <code class="reqn">\theta</code> is sampled from the hierarchical posterior; second, frequencies are generated).</p>
</td></tr>
<tr><td><code id="posteriorPredictive_+3A_expected">expected</code></td>
<td>
<p>if <code>TRUE</code>, the expected frequencies per person are returned (without additional sampling from a multinomial distribution)</p>
</td></tr>
<tr><td><code id="posteriorPredictive_+3A_ncpu">nCPU</code></td>
<td>
<p>number of CPUs used for parallel sampling. For large models and many participants, this requires considerable computer-memory resources (as a remedy, use <code>nCPU=1</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>by default, a list of <code>M</code> posterior-predictive samples (i.e., matrices) with individual frequencies (rows=participants, columns=MPT categories). For <code>M=1</code>, a single matrix is returned. If <code>numItems</code> is provided, a matrix with samples for a new participant is returned (rows=samples)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# add posterior predictive samples to fitted model
#     (facilitates plotting using ?plotFit)
fittedModel$postpred$freq.pred &lt;-
  posteriorPredictive(fittedModel, M = 1000)

## End(Not run)
</code></pre>

<hr>
<h2 id='PPP'>Compute Posterior Predictive P-Values</h2><span id='topic+PPP'></span>

<h3>Description</h3>

<p>Computes posterior predictive p-values to test model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPP(fittedModel, M = 1000, nCPU = 4, T2 = TRUE, type = "X2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPP_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>fitted latent-trait or beta MPT model (<code><a href="#topic+traitMPT">traitMPT</a></code>, <code><a href="#topic+betaMPT">betaMPT</a></code>)</p>
</td></tr>
<tr><td><code id="PPP_+3A_m">M</code></td>
<td>
<p>number of posterior predictive samples. As a maximum, the number of posterior samples in <code>fittedModel</code> is used.</p>
</td></tr>
<tr><td><code id="PPP_+3A_ncpu">nCPU</code></td>
<td>
<p>number of CPUs used for parallel sampling. For large models and many participants, this requires considerable computer-memory resources (as a remedy, use <code>nCPU=1</code>).</p>
</td></tr>
<tr><td><code id="PPP_+3A_t2">T2</code></td>
<td>
<p>whether to compute T2 statistic to check coveriance structure (can
take a lot of time). If some participants do not have responses for some
trees, (co)variances are computed by pairwise deletion of the corresponding
persons.</p>
</td></tr>
<tr><td><code id="PPP_+3A_type">type</code></td>
<td>
<p>whether the T1 statistic of expected means is computed using
Person's <code>"X2"</code> or the likelihood-ratio statistic <code>"G2"</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Heck
</p>


<h3>References</h3>

<p>Klauer, K. C. (2010). Hierarchical multinomial processing tree
models: A latent-trait approach. Psychometrika, 75, 70-98.
</p>

<hr>
<h2 id='priorPredictive'>Prior Predictive Samples</h2><span id='topic+priorPredictive'></span>

<h3>Description</h3>

<p>Samples full data sets (i.e., individual response frequencies) or group-level
MPT parameters based on prior distribution for group-level parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priorPredictive(
  prior,
  eqnfile,
  restrictions,
  numItems,
  level = "data",
  N = 1,
  M = 100,
  nCPU = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priorPredictive_+3A_prior">prior</code></td>
<td>
<p>a named list defining the priors. For the <a href="#topic+traitMPT">traitMPT</a>, the
default is <code>list(mu = "dnorm(0,1)", xi="dunif(0,10)", V=diag(S),
df=S+1)</code>, where S is the number of free parameters. For the <a href="#topic+betaMPT">betaMPT</a>,
the default is <code>list(alpha ="dgamma(1,.1)", beta = "dgamma(1,.1)")</code>.
Note that the normal distribution <code>"dnorm(mu,prec)"</code> is parameterized
as in JAGS by the mean and precision (= 1/variance).</p>
</td></tr>
<tr><td><code id="priorPredictive_+3A_eqnfile">eqnfile</code></td>
<td>
<p>The (relative or full) path to the file that specifies the MPT
model (standard .eqn syntax). Note that category labels must start with a
letter (different to multiTree) and match the column names of <code>data</code>.
Alternatively, the EQN-equations can be provided within R as a character
value (cf. <code><a href="#topic+readEQN">readEQN</a></code>). Note that the first line of an .eqn-file
is reserved for comments and always ignored.</p>
</td></tr>
<tr><td><code id="priorPredictive_+3A_restrictions">restrictions</code></td>
<td>
<p>Specifies which parameters should be (a) constant (e.g.,
<code>"a=b=.5"</code>) or (b) constrained to be identical (e.g., <code>"Do=Dn"</code>)
or (c) treated as fixed effects (i.e., identical for all participants;
<code>"a=b=FE"</code>). Either given as the path to a text file with restrictions
per row or as a list of restrictions, e.g., <code>list("D1=D2","g=0.5")</code>.
Note that numbers in .eqn-equations (e.g., <code>d*(1-g)*.50</code>) are directly
interpreted as equality constraints.</p>
</td></tr>
<tr><td><code id="priorPredictive_+3A_numitems">numItems</code></td>
<td>
<p>vector with the number of items per MPT tree (either named or
assigned to alphabetically ordered tree labels)</p>
</td></tr>
<tr><td><code id="priorPredictive_+3A_level">level</code></td>
<td>
<p>either <code>"data"</code> (returns individual frequencies) or
<code>"parameter"</code> (returns group-level MPT parameters; <code>M</code> and
<code>numItems</code> are ignored)</p>
</td></tr>
<tr><td><code id="priorPredictive_+3A_n">N</code></td>
<td>
<p>number of participants per replication</p>
</td></tr>
<tr><td><code id="priorPredictive_+3A_m">M</code></td>
<td>
<p>number of prior predictive samples (i.e., data sets with <code>N</code>
participants).</p>
</td></tr>
<tr><td><code id="priorPredictive_+3A_ncpu">nCPU</code></td>
<td>
<p>number of CPUs used for parallel sampling. For large models and
many participants, this may require a lot of memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code>M</code> matrices with individual frequencies
(rows=participants, columns=MPT categories). A single matrix is returned if
<code>M=1</code> or <code>level="parameter"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eqnfile &lt;- system.file("MPTmodels/2htm.eqn",
  package = "TreeBUGS"
)
### beta-MPT:
prior &lt;- list(
  alpha = "dgamma(1,.1)",
  beta = "dgamma(1,.1)"
)

### prior-predictive frequencies:
priorPredictive(prior, eqnfile,
  restrictions = list("g=.5", "Do=Dn"),
  numItems = c(50, 50), N = 10, M = 1, nCPU = 1
)

### prior samples of group-level parameters:
priorPredictive(prior, eqnfile,
  level = "parameter",
  restrictions = list("g=.5", "Do=Dn"),
  M = 5, nCPU = 1
)

### latent-trait MPT
priorPredictive(
  prior = list(
    mu = "dnorm(0,1)", xi = "dunif(0,10)",
    df = 3, V = diag(2)
  ),
  eqnfile, restrictions = list("g=.5"),
  numItems = c(50, 50), N = 10, M = 1, nCPU = 1
)

</code></pre>

<hr>
<h2 id='probitInverse'>Probit-Inverse of Group-Level Normal Distribution</h2><span id='topic+probitInverse'></span>

<h3>Description</h3>

<p>Transform latent group-level normal distribution (latent-trait MPT) into mean
and SD on probability scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probitInverse(mu, sigma, fittedModel = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probitInverse_+3A_mu">mu</code></td>
<td>
<p>latent-probit mean of normal distribution</p>
</td></tr>
<tr><td><code id="probitInverse_+3A_sigma">sigma</code></td>
<td>
<p>latent-probit SD of normal distribution</p>
</td></tr>
<tr><td><code id="probitInverse_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>optional: fitted <a href="#topic+traitMPT">traitMPT</a> model. If provided, the
bivariate inverse-probit transform is applied to all MCMC samples (and
<code>mu</code> and <code>sigma</code> are ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>implied mean and SD on probability scale
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### compare bivariate vs. univariate transformation
probitInverse(mu = 0.8, sigma = c(0.25, 0.5, 0.75, 1))
pnorm(0.8)

# full distribution
prob &lt;- pnorm(rnorm(10000, mean = 0.8, sd = 0.7))
hist(prob, 80, col = "gray", xlim = 0:1)

## Not run: 
# transformation for fitted model
mean_sd &lt;- probitInverse(fittedModel = fit)
summarizeMCMC(mean_sd)

## End(Not run)
</code></pre>

<hr>
<h2 id='readEQN'>Read multiTree files</h2><span id='topic+readEQN'></span>

<h3>Description</h3>

<p>Function to import MPT models from standard .eqn model files as used, for
instance, by multiTree (Moshagen, 2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readEQN(file, restrictions = NULL, paramOrder = FALSE, parse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readEQN_+3A_file">file</code></td>
<td>
<p>The (full path to the) file that specifies the MPT model
(standard .eqn syntax). Note that category labels must start with a letter
(different to multiTree) and match the column names of <code>data</code>.
Alternatively, the EQN-equations can be provided within R as a character
value (see examples). Note that the first line of an .eqn-file is reserved
for comments and always ignored.</p>
</td></tr>
<tr><td><code id="readEQN_+3A_restrictions">restrictions</code></td>
<td>
<p>Specifies which parameters should be (a) constant (e.g.,
<code>"a=b=.5"</code>) or (b) constrained to be identical (e.g., <code>"Do=Dn"</code>)
or (c) treated as fixed effects (i.e., identical for all participants;
<code>"a=b=FE"</code>). Either given as the path to a text file with restrictions
per row or as a list of restrictions, e.g., <code>list("D1=D2","g=0.5")</code>.
Note that numbers in .eqn-equations (e.g., <code>d*(1-g)*.50</code>) are directly
interpreted as equality constraints.</p>
</td></tr>
<tr><td><code id="readEQN_+3A_paramorder">paramOrder</code></td>
<td>
<p>if TRUE, the order of MPT parameters as interally used is
printed.</p>
</td></tr>
<tr><td><code id="readEQN_+3A_parse">parse</code></td>
<td>
<p>whether to return a parsed MPT model description in terms of the
matrices <code class="reqn">a</code> and <code class="reqn">b</code> (the powers of the <code class="reqn">\theta</code> and
<code class="reqn">(1-\theta)</code>, respectively, and the vector of constants <code class="reqn">c</code>. Each
branch probability is then given as <code class="reqn">c_{i}  \prod_{s}
\theta^{a_{i,s}}(1-\theta)^{b_{i,s}})</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file format should adhere to the standard .eqn-syntax (note that
the first line is skipped and can be used for comments). In each line, a
separate branch of the MPT model is specified using the tree label,
category label, and the model equations in full form (multiplication sign
'*' required; not abbreviations such as 'a^2' allowed).
</p>
<p>As an example, the standard two-high threshold model (2HTM) is defined as
follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>Target </code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>Hit</code>             </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>Do</code>           </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>Target</code>  </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>Hit</code>             </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>(1-Do)*g</code>     </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>Target</code>  </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>Miss</code>            </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>(1-Do)*(1-g)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>Lure</code>    </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>FalseAlarm</code>      </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>(1-Dn)*g</code>     </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>Lure</code>    </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>CorrectReject</code>   </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>(1-Dn)*(1-g)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>Lure</code>    </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>CorrectReject  </code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>Dn</code>
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Daniel Heck, Denis Arnold, Nina Arnold
</p>


<h3>References</h3>

<p>Moshagen, M. (2010). multiTree: A computer program for the
analysis of multinomial processing tree models. Behavior Research Methods,
42, 42-54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: Standard Two-High-Threshold Model (2HTM)
EQNfile &lt;- system.file("MPTmodels/2htm.eqn",
  package = "TreeBUGS"
)
readEQN(file = EQNfile, paramOrder = TRUE)

# with equality constraint:
readEQN(
  file = EQNfile, restrictions = list("Dn = Do", "g = 0.5"),
  paramOrder = TRUE
)

# define MPT model directly within R
model &lt;-
  "2-High Threshold Model (2HTM)
  old hit d
  old hit (1-d)*g
  old miss (1-d)*(1-g)
  new fa (1-d)*g
  new cr (1-d)*(1-g)
  new cr d"
readEQN(model, paramOrder = TRUE)
</code></pre>

<hr>
<h2 id='simpleMPT'>C++ Sampler for Standard (Nonhierarchical) MPT Models</h2><span id='topic+simpleMPT'></span>

<h3>Description</h3>

<p>Fast Gibbs sampler in C++ that is tailored to the standard fixed-effects MPT
model (i.e., fixed-effects, non-hierarchical MPT). Assumes independent
parameters per person if a matrix of frequencies per person is supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleMPT(
  eqnfile,
  data,
  restrictions,
  n.iter = 2000,
  n.burnin = 500,
  n.thin = 3,
  n.chains = 3,
  ppp = 0,
  alpha = 1,
  beta = 1,
  parEstFile,
  posteriorFile,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpleMPT_+3A_eqnfile">eqnfile</code></td>
<td>
<p>The (relative or full) path to the file that specifies the MPT
model (standard .eqn syntax). Note that category labels must start with a
letter (different to multiTree) and match the column names of <code>data</code>.
Alternatively, the EQN-equations can be provided within R as a character
value (cf. <code><a href="#topic+readEQN">readEQN</a></code>). Note that the first line of an .eqn-file
is reserved for comments and always ignored.</p>
</td></tr>
<tr><td><code id="simpleMPT_+3A_data">data</code></td>
<td>
<p>The (relative or full) path to the .csv file with the data (comma
separated; category labels in first row). Alternatively: a data frame or
matrix (rows=individuals, columns = individual category frequencies,
category labels as column names)</p>
</td></tr>
<tr><td><code id="simpleMPT_+3A_restrictions">restrictions</code></td>
<td>
<p>Specifies which parameters should be (a) constant (e.g.,
<code>"a=b=.5"</code>) or (b) constrained to be identical (e.g., <code>"Do=Dn"</code>)
or (c) treated as fixed effects (i.e., identical for all participants;
<code>"a=b=FE"</code>). Either given as the path to a text file with restrictions
per row or as a list of restrictions, e.g., <code>list("D1=D2","g=0.5")</code>.
Note that numbers in .eqn-equations (e.g., <code>d*(1-g)*.50</code>) are directly
interpreted as equality constraints.</p>
</td></tr>
<tr><td><code id="simpleMPT_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of iterations per chain (including burnin samples). See
<code><a href="runjags.html#topic+run.jags">run.jags</a></code> for details.</p>
</td></tr>
<tr><td><code id="simpleMPT_+3A_n.burnin">n.burnin</code></td>
<td>
<p>Number of samples for burnin (samples will not be stored and
removed from n.iter)</p>
</td></tr>
<tr><td><code id="simpleMPT_+3A_n.thin">n.thin</code></td>
<td>
<p>Thinning rate.</p>
</td></tr>
<tr><td><code id="simpleMPT_+3A_n.chains">n.chains</code></td>
<td>
<p>number of MCMC chains (sampled in parallel).</p>
</td></tr>
<tr><td><code id="simpleMPT_+3A_ppp">ppp</code></td>
<td>
<p>number of samples to compute  posterior predictive p-value (see
<code><a href="#topic+posteriorPredictive">posteriorPredictive</a></code>)</p>
</td></tr>
<tr><td><code id="simpleMPT_+3A_alpha">alpha</code></td>
<td>
<p>first shape parameter(s) for the beta prior-distribution of the
MPT parameters <code class="reqn">\theta_s</code> (can be a named vector to use a different
prior for each MPT parameter)</p>
</td></tr>
<tr><td><code id="simpleMPT_+3A_beta">beta</code></td>
<td>
<p>second shape parameter(s)</p>
</td></tr>
<tr><td><code id="simpleMPT_+3A_parestfile">parEstFile</code></td>
<td>
<p>Name of the file to with the estimates should be stored
(e.g., &quot;parEstFile.txt&quot;)</p>
</td></tr>
<tr><td><code id="simpleMPT_+3A_posteriorfile">posteriorFile</code></td>
<td>
<p>path to RData-file where to save the model including
MCMC posterior samples (an object named <code>fittedModel</code>; e.g.,
<code>posteriorFile="mcmc.RData"</code>)</p>
</td></tr>
<tr><td><code id="simpleMPT_+3A_cores">cores</code></td>
<td>
<p>number of CPUs to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beta distributions with fixed shape parameters <code class="reqn">\alpha</code> and
<code class="reqn">\beta</code> are used. The default <code class="reqn">\alpha=1</code> and <code class="reqn">\beta=1</code> assumes
uniform priors for all MPT parameters.
</p>


<h3>Author(s)</h3>

<p>Daniel Heck
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# fit nonhierarchical MPT model for aggregated data (see ?arnold2013):
EQNfile &lt;- system.file("MPTmodels/2htsm.eqn", package = "TreeBUGS")
d.encoding &lt;- subset(arnold2013, group == "encoding", select = -(1:4))
fit &lt;- simpleMPT(EQNfile, colSums(d.encoding),
  restrictions = list("D1=D2=D3", "d1=d2", "a=g")
)
# convergence
plot(fit)
summary(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='summarizeMCMC'>MCMC Summary</h2><span id='topic+summarizeMCMC'></span>

<h3>Description</h3>

<p>TreeBUGS-specific MCMC summary for <code>mcmc.list</code>-objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeMCMC(mcmc, batchSize = 50, probs = c(0.025, 0.5, 0.975))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarizeMCMC_+3A_mcmc">mcmc</code></td>
<td>
<p>a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object</p>
</td></tr>
<tr><td><code id="summarizeMCMC_+3A_batchsize">batchSize</code></td>
<td>
<p>size of batches of parameters used to reduce memory load
when computing posterior summary statistics (including Rhat and effective
sample size).</p>
</td></tr>
<tr><td><code id="summarizeMCMC_+3A_probs">probs</code></td>
<td>
<p>quantile probabilities used to compute credibility intervals</p>
</td></tr>
</table>

<hr>
<h2 id='summarizeMPT'>Summarize JAGS Output for Hierarchical MPT Models</h2><span id='topic+summarizeMPT'></span>

<h3>Description</h3>

<p>Provide clean and readable summary statistics tailored to MPT models based on
the JAGS output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeMPT(mcmc, mptInfo, probs = c(0.025, 0.5, 0.975), summ = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarizeMPT_+3A_mcmc">mcmc</code></td>
<td>
<p>the actual mcmc.list output of the sampler of a fitted MPT model
(accesible via <code>fittedModel$runjags$mcmc</code>)</p>
</td></tr>
<tr><td><code id="summarizeMPT_+3A_mptinfo">mptInfo</code></td>
<td>
<p>the internally stored information about the fitted MPT model
(accesible via <code>fittedModel$mptInfo</code>)</p>
</td></tr>
<tr><td><code id="summarizeMPT_+3A_probs">probs</code></td>
<td>
<p>quantile probabilities used to compute credibility intervals</p>
</td></tr>
<tr><td><code id="summarizeMPT_+3A_summ">summ</code></td>
<td>
<p>optional argument for internal use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MPT-specific summary is computed directly after fitting a model.
However, this function might be used manually after removing MCMC samples
(e.g., extending the burnin period).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Remove additional burnin samples and recompute MPT summary
## Not run: 
# start later or thin (see ?window)
mcmc.subsamp &lt;- window(fittedModel$runjags$mcmc, start = 3001, thin = 2)
new.mpt.summary &lt;- summarizeMPT(mcmc.subsamp, fittedModel$mptInfo)
new.mpt.summary

## End(Not run)
</code></pre>

<hr>
<h2 id='testHetChi'>Chi-Square Test of Heterogeneity</h2><span id='topic+testHetChi'></span>

<h3>Description</h3>

<p>Tests whether whether participants (items) are homogeneous under the
assumption of item (participant) homogeneity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testHetChi(freq, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testHetChi_+3A_freq">freq</code></td>
<td>
<p>matrix with observed frequencies (rows: persons/items; columns:
categories). Can also be the path to a .csv file with frequencies
(comma-separated; first line defines category labels)</p>
</td></tr>
<tr><td><code id="testHetChi_+3A_tree">tree</code></td>
<td>
<p>a vector defining which columns of x belong to separate
multinomial distributions (i.e., MPT trees). For instance, if <code>x</code> has
five categories from two MPT trees: <code>tree=c(1,1,2,2,2)</code> or
<code>tree=c("t1","t1","t2","t2","t2")</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an item/person has zero frequencies on all categories in an MPT
tree, these zeros are neglected when computing mean frequencies per column.
As an example, consider a simple recognition test with a fixed assignments of
words to the learn/test list. In such an experiment, all learned words will
result in hits or misses (i.e., the MPT tree of old items), whereas new words
are always false alarms/correct rejections and thus belong to the MPT tree of
new items (this is not necessarily the case if words are assigned randomly).
</p>
<p>Note that the test assumes independence of observations and item homogeneity
when testing participant heterogeneity. The latter assumption can be dropped
when using a permutation test (<code><a href="#topic+testHetPerm">testHetPerm</a></code>).
</p>


<h3>Author(s)</h3>

<p>Daniel W. Heck
</p>


<h3>References</h3>

<p>Smith, J. B., &amp; Batchelder, W. H. (2008). Assessing individual
differences in categorical data. Psychonomic Bulletin &amp; Review, 15,
713-731. <a href="https://doi.org/10.3758/PBR.15.4.713">doi:10.3758/PBR.15.4.713</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testHetPerm">testHetPerm</a></code>, <code><a href="#topic+plotFreq">plotFreq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some made up frequencies:
freq &lt;- matrix(
  c(
    13, 16, 11, 13,
    15, 21, 18, 13,
    21, 14, 16, 17,
    19, 20, 21, 18
  ),
  ncol = 4, byrow = TRUE
)
# for a product-binomial distribution:
# (categories 1 and 2 and categories 3 and 4 are binomials)
testHetChi(freq, tree = c(1, 1, 2, 2))
# =&gt; no significant deviation from homogeneity (low power!)
</code></pre>

<hr>
<h2 id='testHetPerm'>Permutation Test of Heterogeneity</h2><span id='topic+testHetPerm'></span>

<h3>Description</h3>

<p>Tests whether whether participants (items) are homogeneous without assuming
item (participant) homogeneity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testHetPerm(data, tree, source = "person", rep = 1000, nCPU = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testHetPerm_+3A_data">data</code></td>
<td>
<p>matrix or data frame with three columns: person code/index, item
label, response category. Can also be the path to a .csv file with
frequencies (comma-separated; first line defines category labels)</p>
</td></tr>
<tr><td><code id="testHetPerm_+3A_tree">tree</code></td>
<td>
<p>a list that defines which categories belong to the same
multinomial distribution (i.e., the the same MPT tree). For instance:
<code>tree = list(tree.old = c("hit","cr"), tree.new = c("fa","miss"))</code>.
Category labels must match the values of the third column of <code>data</code></p>
</td></tr>
<tr><td><code id="testHetPerm_+3A_source">source</code></td>
<td>
<p>whether to test for <code>"person"</code> or <code>"item"</code>
homogeneity</p>
</td></tr>
<tr><td><code id="testHetPerm_+3A_rep">rep</code></td>
<td>
<p>number of permutations to be sampled</p>
</td></tr>
<tr><td><code id="testHetPerm_+3A_ncpu">nCPU</code></td>
<td>
<p>number of CPUs used for parallel Monte Carlo sampling of
permutations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an item/person has zero frequencies on all categories in an MPT
tree, these zeros are neglected when computing mean frequencies per column.
As an example, consider a simple recognition test with a fixed assignments of
words to the learn/test list. In such an experiment, all learned words will
result in hits or misses (i.e., the MPT tree of old items), whereas new words
are always false alarms/correct rejections and thus belong to the MPT tree of
new items (this is not necessarily the case if words are assigned randomly).
</p>
<p>Note that the test does still assume independence of observations. However,
it does not require item homogeneity when testing participant heterogeneity
(in contrast to the chi-square test: <code><a href="#topic+testHetChi">testHetChi</a></code>).
</p>


<h3>Author(s)</h3>

<p>Daniel W. Heck
</p>


<h3>References</h3>

<p>Smith, J. B., &amp; Batchelder, W. H. (2008). Assessing individual
differences in categorical data. Psychonomic Bulletin &amp; Review, 15,
713-731. <a href="https://doi.org/10.3758/PBR.15.4.713">doi:10.3758/PBR.15.4.713</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testHetChi">testHetChi</a></code>, <code><a href="#topic+plotFreq">plotFreq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate homogeneous data
# (N=15 participants, M=30 items)
data &lt;- data.frame(
  id = rep(1:15, each = 30),
  item = rep(1:30, 15)
)
data$cat &lt;- sample(c("h", "cr", "m", "fa"), 15 * 30,
  replace = TRUE,
  prob = c(.7, .3, .4, .6)
)
head(data)
tree &lt;- list(
  old = c("h", "m"),
  new = c("fa", "cr")
)

# test participant homogeneity:
tmp &lt;- testHetPerm(data, tree, rep = 200, nCPU = 1)
tmp[2:3]
</code></pre>

<hr>
<h2 id='traitMPT'>Fit a Hierarchical Latent-Trait MPT Model</h2><span id='topic+traitMPT'></span>

<h3>Description</h3>

<p>Fits a latent-trait MPT model (Klauer, 2010) based on a standard MPT model
file (.eqn) and individual data table (.csv).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traitMPT(
  eqnfile,
  data,
  restrictions,
  covData,
  predStructure,
  predType,
  transformedParameters,
  corProbit = TRUE,
  mu = "dnorm(0,1)",
  xi = "dunif(0,10)",
  V,
  df,
  IVprec = "dgamma(.5,.5)",
  n.iter = 20000,
  n.adapt = 2000,
  n.burnin = 2000,
  n.thin = 5,
  n.chains = 3,
  dic = FALSE,
  ppp = 0,
  monitorIndividual = TRUE,
  modelfilename,
  parEstFile,
  posteriorFile,
  autojags = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traitMPT_+3A_eqnfile">eqnfile</code></td>
<td>
<p>The (relative or full) path to the file that specifies the MPT
model (standard .eqn syntax). Note that category labels must start with a
letter (different to multiTree) and match the column names of <code>data</code>.
Alternatively, the EQN-equations can be provided within R as a character
value (cf. <code><a href="#topic+readEQN">readEQN</a></code>). Note that the first line of an .eqn-file
is reserved for comments and always ignored.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_data">data</code></td>
<td>
<p>The (relative or full) path to the .csv file with the data (comma
separated; category labels in first row). Alternatively: a data frame or
matrix (rows=individuals, columns = individual category frequencies,
category labels as column names)</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_restrictions">restrictions</code></td>
<td>
<p>Specifies which parameters should be (a) constant (e.g.,
<code>"a=b=.5"</code>) or (b) constrained to be identical (e.g., <code>"Do=Dn"</code>)
or (c) treated as fixed effects (i.e., identical for all participants;
<code>"a=b=FE"</code>). Either given as the path to a text file with restrictions
per row or as a list of restrictions, e.g., <code>list("D1=D2","g=0.5")</code>.
Note that numbers in .eqn-equations (e.g., <code>d*(1-g)*.50</code>) are directly
interpreted as equality constraints.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_covdata">covData</code></td>
<td>
<p>Data that contains covariates, for which correlations with
individual MPT parameters will be sampled. Either the path to a .csv file
(comma-separated: rows=individuals in the same order as <code>data</code>; first
row must contain covariate labels). Alternatively: a data frame or matrix
(rows=individuals, columns = variables; covariate labels as column names).
Note that in <code>betaMPT</code>, correlations are computed for discrete
variables that are coded numerically (in <code>traitMPT</code>, this can be
suppressed by using <code>predType="f"</code>)</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_predstructure">predStructure</code></td>
<td>
<p>Defines which variables in <code>covData</code> are included
as predictors for which MPT parameters. Either the path to the file that
specifies the assignment of MPT parameters to covariates (that is, each row
assigns one or more MPT parameters to one or more covariates, separated by
a semicolon, e.g., <code>Do g; age extraversion</code>). Can also be provided as
a list, e.g., <code>list("Do Dn ; age", "g ; extraversion"</code>). Note that no
correlations of MPT parameters and predictors are computed. However, for
continuous covariates, the standardized slope parameters
<code>slope_std_parameter_predictor</code> can be interpreted as a correlation if
a single predictor is included for the corresponding MPT parameter (see
Jobst et al., 2020).</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_predtype">predType</code></td>
<td>
<p>a character vector specifying the type of continuous or
discrete predictors in each column of <code>covData</code>: <code>"c"</code> =
continuous covariate (which are centered to have a mean of zero);
<code>"f"</code> = discrete predictor, fixed effect (default for character/factor
variables); <code>"r"</code> = discrete predictor, random effect.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_transformedparameters">transformedParameters</code></td>
<td>
<p>list with parameter transformations that should
be computed based on the posterior samples of the group-level means (e.g.,
for testing parameter differences: <code>list("diffD=Do-Dn")</code>), or path to
a text file containing one transformation per line. Transformations of
individual-level parameters can also be performed after fitting a model
using <code><a href="#topic+transformedParameters">transformedParameters</a></code>.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_corprobit">corProbit</code></td>
<td>
<p>whether to use probit-transformed MPT parameters to compute
correlations (probit-values of <code>+Inf</code> are truncated to
<code>max(5,max(probit))</code>; similarly for <code>-Inf</code>). Default for
beta-MPT: MPT parameters are used on the probability scale [0,1].</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_mu">mu</code></td>
<td>
<p>hyperprior for group means of probit-transformed parameters in JAGS
syntax. Default is a standard normal distribution, which implies a uniform
distribution on the MPT probability parameters. A named vector can be used
to specify separate hyperpriors for each MPT parameter (the order of
parameters is determined by the names of the vector or by the default order
as shown in <code><a href="#topic+readEQN">readEQN</a></code> with <code>paramOrder = TRUE</code>).</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_xi">xi</code></td>
<td>
<p>hyperprior for scaling parameters of the group-level parameter
variances. Default is a uniform distribution on the interval [0,10].
Similarly as for <code>mu</code>, a vector of different priors can be used. Less
informative priors can be used (e.g., <code>"dunif(0,100)")</code>) but might
result in reduced stability.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_v">V</code></td>
<td>
<p>S x S matrix used as a hyperprior for the inverse-Wishart
hyperprior parameters with as many rows and columns as there are core MPT
parameters. Default is a diagonal matrix.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_df">df</code></td>
<td>
<p>degrees of freedom for the inverse-Wishart hyperprior for the
individual parameters. Minimum is S+1, where S gives the number of core MPT
parameters.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_ivprec">IVprec</code></td>
<td>
<p>hyperprior on the precision parameter <code class="reqn">g</code> (= the inverse of
the variance) of the standardized slope parameters of continuous
covariates. The default <code>IVprec=dgamma(.5,.5)</code> defines a mixture of
<code class="reqn">g</code>-priors (also known as JZS or Cauchy prior) with the scale parameter
<code class="reqn">s=1</code>. Different scale parameters <code class="reqn">s</code> can be set via:
<code>IVprec=dgamma(.5,.5*s^2)</code>. A numeric constant <code>IVprec=1</code> implies
a <code class="reqn">g</code>-prior (a normal distribution). For ease of interpretation,
TreeBUGS reports both unstandardized and standardized regression
coefficients. See details below.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of iterations per chain (including burnin samples). See
<code><a href="runjags.html#topic+run.jags">run.jags</a></code> for details.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_n.adapt">n.adapt</code></td>
<td>
<p>number of adaption samples to adjust MCMC sampler in JAGS. The
sampler will be more efficient if it is tuned well. However, MCMC sampling
will still give correct results even if the warning appears: &quot;Adaptation
incomplete.&quot; (this just means that sampling efficiency could be better).</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_n.burnin">n.burnin</code></td>
<td>
<p>Number of samples for burnin (samples will not be stored and
removed from n.iter)</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_n.thin">n.thin</code></td>
<td>
<p>Thinning rate.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_n.chains">n.chains</code></td>
<td>
<p>number of MCMC chains (sampled in parallel).</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_dic">dic</code></td>
<td>
<p>whether to compute DIC using
<code><a href="runjags.html#topic+extract.runjags">extract.runjags</a></code>, which requires additional sampling.
Can also be computed and added after fitting the model by
<code>fittedModel$summary$dic &lt;- runjags::extract(fittedModel$runjags,
"dic")</code>. As an alternative information criterion, <code><a href="#topic+WAIC">WAIC</a></code> can be
computed for fitted models.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_ppp">ppp</code></td>
<td>
<p>number of samples to compute  posterior predictive p-value (see
<code><a href="#topic+posteriorPredictive">posteriorPredictive</a></code>)</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_monitorindividual">monitorIndividual</code></td>
<td>
<p>whether to store MCMC samples of the MPT
parameters <code>theta</code> at the individual level (i.e., the random effects).
If <code>FALSE</code>, it is not possible to perform posterior-predictive checks.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_modelfilename">modelfilename</code></td>
<td>
<p>name of the generated JAGS model file. Default is to
write this information to the tempdir as required by CRAN standards.</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_parestfile">parEstFile</code></td>
<td>
<p>Name of the file to with the estimates should be stored
(e.g., &quot;parEstFile.txt&quot;)</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_posteriorfile">posteriorFile</code></td>
<td>
<p>path to RData-file where to save the model including
MCMC posterior samples (an object named <code>fittedModel</code>; e.g.,
<code>posteriorFile="mcmc.RData"</code>)</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_autojags">autojags</code></td>
<td>
<p>JAGS first fits the MPT model as usual and then draws MCMC
samples repeatedly until convergence. For this, the function
<code>autoextend.jags</code> is used with the arguments provided in
<code>autojags</code> (this can be an empty list, in which case the defaults are
used). Possible arguments for <code>autoextend.jags</code> are:
<code>list(startburnin = 1000, startsample = 5000, adapt = 2000,
max.time="30m")</code> (the last of these arguments restricts sampling  to 30
minutes, see  <a href="runjags.html#topic+autoextend.jags">autoextend.jags</a>).</p>
</td></tr>
<tr><td><code id="traitMPT_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the JAGS sampling function
(i.e., to <code><a href="runjags.html#topic+run.jags">run.jags</a></code>. Note that reproducible results
are obtained by setting a random seed before fitting a model (i.e.,
<code>set.seed(12345)</code> ).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the class <code>traitMPT</code> with the objects:
</p>

<ul>
<li> <p><code>summary</code>: MPT tailored summary. Use <code>summary(fittedModel)</code>
</p>
</li>
<li> <p><code>mptInfo</code>: info about MPT model (eqn and data file etc.)
</p>
</li>
<li> <p><code>mcmc</code>: the object returned from the MCMC sampler.
Note that the object <code>fittedModel$mcmc</code> is an
<a href="runjags.html#topic+runjags">runjags</a> object, whereas
<code>fittedModel$mcmc$mcmc</code> is an <code>mcmc.list</code> as used by
the coda package (<a href="coda.html#topic+mcmc">mcmc</a>)
</p>
</li></ul>



<h3>Regression Extensions</h3>

<p>Continuous and discrete predictors are added
on the latent-probit scale via: </p>
<p style="text-align: center;"><code class="reqn">\theta = \Phi(\mu + X \beta +\delta
  ),</code>
</p>
<p> where <code class="reqn">X</code> is a design matrix includes centered continuous
covariates and recoded factor variables (using the orthogonal contrast
coding scheme by Rouder et al., 2012). Note that both centering and
recoding is done internally. TreeBUGS reports unstandardized regression
coefficients <code class="reqn">\beta</code> that correspond to the scale/SD of the predictor
variables. Hence, slope estimates will be very small if the covariate has a
large variance. TreeBUGS also reports standardized slope parameters
(labeled with <code>std</code>) which are standardized both with respect to the
variance of the predictor variables and the variance in the individual MPT
parameters. If a single predictor variable is included, the standardized
slope can be interpreted as a correlation coefficient (Jobst et al., 2020).
</p>
<p>For continuous predictor variables, the default prior <code>IVprec =
  "dgamma(.5,.5)"</code> implies a Cauchy prior on the <code class="reqn">\beta</code> parameters
(standardized with respect to the variance of the predictor variables).
This prior is similar to the Jeffreys-Zellner-Siow (JZS) prior with scale
parameter <code class="reqn">s=1</code> (for details, see: Rouder et. al, 2012; Rouder &amp; Morey,
2012). In contrast to the JZS prior for standard linear regression by
Rouder &amp; Morey (2012), TreeBUGS implements a latent-probit regression where
the prior on the coefficients <code class="reqn">\beta</code> is only standardized/scaled with
respect to the continuous predictor variables but not with respect to the
residual variance (since this is not a parameter in probit regression). If
small effects are expected, smaller scale values <code class="reqn">s</code> can be used by
changing the default to <code>IVprec = 'dgamma(.5, .5*s^2)'</code> (by plugging
in a specific number for <code>s</code>). To use a standard-normal instead of a
Cauchy prior distribution, use <code>IVprec = 'dcat(1)'</code>. Bayes factors for
slope parameters of continuous predictors can be computed with the function
<a href="#topic+BayesFactorSlope">BayesFactorSlope</a>.
</p>


<h3>Uncorrelated Latent-Trait Values</h3>

<p>The standard latent-trait MPT
model assumes a multivariate normal distribution of the latent-trait
values, where the covariance matrix follows a scaled-inverse Wishart
distribution. As an alternative, the parameters can be assumed to be
independent (this is equivalent to a diagonal covariance matrix). If the
assumption of uncorrelated parameters is justified, such a simplified model
has less parameters and is more parsimonious, which in turn might result in
more robust estimation and more precise parameter estimates.
</p>
<p>This alternative method can be fitted in TreeBUGS (but not all of the
features of TreeBUGS might be compatible with this alternative model
structure). To fit the model, the scale matrix <code>V</code> is set to <code>NA</code>
(V is only relevant for the multivariate Wishart prior) and the prior on
<code>xi</code> is changed: <code>traitMPT(..., V=NA, xi="dnorm(0,1)")</code>. The
model assumes that the latent-trait values <code class="reqn">\delta_i</code>
(=random-intercepts) are decomposed by the scaling parameter <code class="reqn">\xi</code> and
the raw deviation <code class="reqn">\epsilon_i</code> (cf. Gelman, 2006): </p>
<p style="text-align: center;"><code class="reqn">\delta_i = \xi
  \cdot \epsilon_i</code>
</p>
 <p style="text-align: center;"><code class="reqn">\epsilon_i \sim Normal(0,\sigma^2)</code>
</p>
 <p style="text-align: center;"><code class="reqn">\sigma^2
  \sim Inverse-\chi^2(df)</code>
</p>
<p> Note that the default prior for <code class="reqn">\xi</code> should
be changed to <code>xi="dnorm(0,1)"</code>, which results in a half-Cauchy prior
(Gelman, 2006).
</p>


<h3>Author(s)</h3>

<p>Daniel W. Heck, Denis Arnold, Nina R. Arnold
</p>


<h3>References</h3>

<p>Heck, D. W., Arnold, N. R., &amp; Arnold, D. (2018). TreeBUGS: An R
package for hierarchical multinomial-processing-tree modeling. <em>Behavior
Research Methods, 50</em>, 264–284. <a href="https://doi.org/10.3758/s13428-017-0869-7">doi:10.3758/s13428-017-0869-7</a>
</p>
<p>Gelman, A. (2006). Prior distributions for variance parameters in
hierarchical models (comment on article by Browne and Draper). <em>Bayesian
Analysis, 1</em>, 515-534.
</p>
<p>Jobst, L. J., Heck, D. W., &amp; Moshagen, M. (2020). A comparison of correlation
and regression approaches for multinomial processing tree models.
<em>Journal of Mathematical Psychology, 98</em>, 102400.
<a href="https://doi.org/10.1016/j.jmp.2020.102400">doi:10.1016/j.jmp.2020.102400</a>
</p>
<p>Klauer, K. C. (2010). Hierarchical multinomial processing tree models: A
latent-trait approach. <em>Psychometrika, 75</em>, 70-98.
<a href="https://doi.org/10.1007/s11336-009-9141-0">doi:10.1007/s11336-009-9141-0</a>
</p>
<p>Matzke, D., Dolan, C. V., Batchelder, W. H., &amp; Wagenmakers, E.-J. (2015).
Bayesian estimation of multinomial processing tree models with heterogeneity
in participants and items. <em>Psychometrika, 80</em>, 205-235.
<a href="https://doi.org/10.1007/s11336-013-9374-9">doi:10.1007/s11336-013-9374-9</a>
</p>
<p>Rouder, J. N., Morey, R. D., Speckman, P. L., &amp; Province, J. M. (2012).
Default Bayes factors for ANOVA designs. <em>Journal of Mathematical
Psychology, 56</em>, 356-374. <a href="https://doi.org/10.1016/j.jmp.2012.08.001">doi:10.1016/j.jmp.2012.08.001</a>
</p>
<p>Rouder, J. N., &amp; Morey, R. D. (2012). Default Bayes Factors for Model
Selection in Regression. <em>Multivariate Behavioral Research, 47</em>,
877-903. <a href="https://doi.org/10.1080/00273171.2012.734737">doi:10.1080/00273171.2012.734737</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# fit beta-MPT model for encoding condition (see ?arnold2013):
EQNfile &lt;- system.file("MPTmodels/2htsm.eqn", package = "TreeBUGS")
d.encoding &lt;- subset(arnold2013, group == "encoding", select = -(1:4))
fit &lt;- traitMPT(EQNfile, d.encoding,
  n.thin = 5,
  restrictions = list("D1=D2=D3", "d1=d2", "a=g")
)
# convergence
plot(fit, parameter = "mean", type = "default")
summary(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='transformedParameters'>Get Transformed Parameters</h2><span id='topic+transformedParameters'></span>

<h3>Description</h3>

<p>Computes transformations of MPT parameters based on the MCMC posterior
samples (e.g., differences of parameters).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformedParameters(
  fittedModel,
  transformedParameters,
  level = "group",
  nCPU = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformedParameters_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>either a fitted latent-trait or beta MPT model
(<code><a href="#topic+traitMPT">traitMPT</a></code>, <code><a href="#topic+betaMPT">betaMPT</a></code>) or an
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>.</p>
</td></tr>
<tr><td><code id="transformedParameters_+3A_transformedparameters">transformedParameters</code></td>
<td>
<p>list with parameter transformations that should
be computed based on the posterior samples (e.g., for testing parameter
differences: <code>list("diffD=Do-Dn")</code>).</p>
</td></tr>
<tr><td><code id="transformedParameters_+3A_level">level</code></td>
<td>
<p>whether to compute transformations of <code>"group"</code> or
<code>"individual"</code> estimates</p>
</td></tr>
<tr><td><code id="transformedParameters_+3A_ncpu">nCPU</code></td>
<td>
<p>number of CPU cores across which the MCMC chains are distributed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <a href="coda.html#topic+mcmc.list">mcmc.list</a> of posterior samples for the transformed
parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tt &lt;- transformedParameters(fittedModel,
  list("diff = a-b", "p = a&gt;b"),
  level = "individual"
)
summary(tt)

## End(Not run)
</code></pre>

<hr>
<h2 id='WAIC'>WAIC: Widely Applicable Information Criterion</h2><span id='topic+WAIC'></span><span id='topic+print.waic'></span><span id='topic+print.waic_difference'></span><span id='topic+-.waic'></span>

<h3>Description</h3>

<p>Implementation of the WAIC for model comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WAIC(
  fittedModel,
  n.adapt = 1000,
  n.chains = 3,
  n.iter = 10000,
  n.thin = 1,
  summarize = FALSE
)

## S3 method for class 'waic'
print(x, ...)

## S3 method for class 'waic_difference'
print(x, ...)

## S3 method for class 'waic'
e1 - e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WAIC_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>fitted latent-trait or beta MPT model (<code><a href="#topic+traitMPT">traitMPT</a></code>, <code><a href="#topic+betaMPT">betaMPT</a></code>)</p>
</td></tr>
<tr><td><code id="WAIC_+3A_n.adapt">n.adapt</code></td>
<td>
<p>number of adaptation samples.</p>
</td></tr>
<tr><td><code id="WAIC_+3A_n.chains">n.chains</code></td>
<td>
<p>number of chains (no parallel computation).</p>
</td></tr>
<tr><td><code id="WAIC_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations after burnin.</p>
</td></tr>
<tr><td><code id="WAIC_+3A_n.thin">n.thin</code></td>
<td>
<p>Thinning rate.</p>
</td></tr>
<tr><td><code id="WAIC_+3A_summarize">summarize</code></td>
<td>
<p>deprecated argument only available for backwards compatibility</p>
</td></tr>
<tr><td><code id="WAIC_+3A_x">x</code></td>
<td>
<p>An object of class <code>waic</code> or <code>waic_difference</code> to be printed.</p>
</td></tr>
<tr><td><code id="WAIC_+3A_...">...</code></td>
<td>
<p>Further arguments that may be passed to print methods.</p>
</td></tr>
<tr><td><code id="WAIC_+3A_e1">e1</code>, <code id="WAIC_+3A_e2">e2</code></td>
<td>
<p>Two objects of class <code>waic</code> to be compared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WAIC provides an approximation of predictive accuracy with respect
to out-of-sample deviance. The uncertainty of the WAIC for the given number
of observed nodes (i.e., number of free categories times the number of
participants) is quantified by the standard error of WAIC <code>"se_waic"</code>
(cf. Vehtari et al., 2017). In contrast, to assess whether the approximation
uncertainty due to MCMC sampling (not sample size) is sufficiently low, it is
a good idea to fit each model twice and compute WAIC again to assess the
stability of the WAIC values.
</p>
<p>For more details, see Vehtari et al. (2017) and the following discussion
about the JAGS implementation (which is currently an experimental feature of
JAGS 4.3.0):
</p>
<p><a href="https://sourceforge.net/p/mcmc-jags/discussion/610036/thread/8211df61/">https://sourceforge.net/p/mcmc-jags/discussion/610036/thread/8211df61/</a>
</p>


<h3>Value</h3>

<p>Function <code>WAIC()</code> returns an object of class <code>waic</code>, which is basically
a list containing three vectors <code>p_waic</code>, <code>deviance</code>, and <code>waic</code>, with
separate values for each observed node
(i.e., for all combinations of persons and free categories).
</p>
<p>For these objects, a <code>print()</code> method exists, which
also calculates the standard error of the estimate of WAIC.
</p>
<p>For backwards compatibility, if <code>WAIC()</code> is called with <code>summarize = TRUE</code>,
a vector with values <code>p_waic</code>, <code>deviance</code>, <code>waic</code>, and <code>se_waic</code> is returned.
</p>
<p>WAIC values from two models can be compared by using the <code>-</code> operator;
the result is an object of class <code>waic_difference</code>.
</p>


<h3>References</h3>

<p>Vehtari, A., Gelman, A., &amp; Gabry, J. (2017). Practical Bayesian
model evaluation using leave-one-out cross-validation and WAIC. Statistics
and Computing, 27(5), 1413–1432. doi:10.1007/s11222-016-9696-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#### WAIC for a latent-trait MPT model:
fit &lt;- traitMPT(...)
WAIC(fit)


#### pairwise comparison of two models:

# (1) compute WAIC per model
waic1 &lt;- WAIC(fit1)
waic2 &lt;- WAIC(fit2)

# (2) WAIC difference
waic1 - waic2

## End(Not run)


</code></pre>

<hr>
<h2 id='withinSubjectEQN'>Generate EQN Files for Within-Subject Designs</h2><span id='topic+withinSubjectEQN'></span>

<h3>Description</h3>

<p>Replicates an MPT model multiple times with different tree, category, and
parameter labels for within-subject factorial designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>withinSubjectEQN(eqnfile, labels, constant, save)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="withinSubjectEQN_+3A_eqnfile">eqnfile</code></td>
<td>
<p>The (relative or full) path to the file that specifies the MPT
model (standard .eqn syntax). Note that category labels must start with a
letter (different to multiTree) and match the column names of <code>data</code>.
Alternatively, the EQN-equations can be provided within R as a character
value (cf. <code><a href="#topic+readEQN">readEQN</a></code>). Note that the first line of an .eqn-file
is reserved for comments and always ignored.</p>
</td></tr>
<tr><td><code id="withinSubjectEQN_+3A_labels">labels</code></td>
<td>
<p>a character vector defining the labels that are added to the
parameters in each within-subject condition</p>
</td></tr>
<tr><td><code id="withinSubjectEQN_+3A_constant">constant</code></td>
<td>
<p>optional: a character vector defining which parameters are
constrained to be constant across within-conditions</p>
</td></tr>
<tr><td><code id="withinSubjectEQN_+3A_save">save</code></td>
<td>
<p>optional: path to an EQN output file. By default, the model is
return as a string character</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example: Standard Two-High-Threshold Model (2HTM)
EQNfile &lt;- system.file("MPTmodels/2htm.eqn",
  package = "TreeBUGS"
)
withinSubjectEQN(EQNfile, c("high", "low"), constant = c("g"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
