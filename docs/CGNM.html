<!DOCTYPE html><html><head><title>Help for package CGNM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CGNM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acceptedApproximateMinimizers'><p>acceptedApproximateMinimizers</p></a></li>
<li><a href='#acceptedIndices'><p>acceptedIndices</p></a></li>
<li><a href='#acceptedIndices_binary'><p>acceptedIndices_binary</p></a></li>
<li><a href='#acceptedMaxSSR'><p>acceptedMaxSSR</p></a></li>
<li><a href='#bestApproximateMinimizers'><p>bestApproximateMinimizers</p></a></li>
<li><a href='#Cluster_Gauss_Newton_Bootstrap_method'><p>Cluster_Gauss_Newton_Bootstrap_method</p></a></li>
<li><a href='#Cluster_Gauss_Newton_method'><p>Cluster_Gauss_Newton_method</p></a></li>
<li><a href='#plot_2DprofileLikelihood'><p>plot_2DprofileLikelihood</p></a></li>
<li><a href='#plot_goodnessOfFit'><p>plot_goodnessOfFit</p></a></li>
<li><a href='#plot_paraDistribution_byHistogram'><p>plot_paraDistribution_byHistogram</p></a></li>
<li><a href='#plot_paraDistribution_byViolinPlots'><p>plot_paraDistribution_byViolinPlots</p></a></li>
<li><a href='#plot_parameterValue_scatterPlots'><p>plot_parameterValue_scatterPlots</p></a></li>
<li><a href='#plot_profileLikelihood'><p>plot_profileLikelihood</p></a></li>
<li><a href='#plot_Rank_SSR'><p>plot_Rank_SSR</p></a></li>
<li><a href='#plot_simulationMatrixWithCI'><p>plot_simulationMatrixWithCI</p></a></li>
<li><a href='#plot_simulationWithCI'><p>plot_simulationWithCI</p></a></li>
<li><a href='#plot_SSR_parameterValue'><p>plot_SSR_parameterValue</p></a></li>
<li><a href='#plot_SSRsurface'><p>plot_SSRsurface</p></a></li>
<li><a href='#suggestInitialLowerRange'><p>suggestInitialLowerRange</p></a></li>
<li><a href='#suggestInitialUpperRange'><p>suggestInitialUpperRange</p></a></li>
<li><a href='#table_parameterSummary'><p>table_parameterSummary</p></a></li>
<li><a href='#table_profileLikelihoodConfidenceInterval'><p>table_profileLikelihoodConfidenceInterval</p></a></li>
<li><a href='#topIndices'><p>topIndices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cluster Gauss-Newton Method</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.7</td>
</tr>
<tr>
<td>Author:</td>
<td>Yasunori Aoki</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yasunori Aoki &lt;yaoki@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Find multiple solutions of a nonlinear least squares problem.  Cluster Gauss-Newton method does not assume uniqueness of the solution of the nonlinear least squares problem and compute multiple minimizers. Please cite the following paper when this software is used in your research: Aoki et al. (2020) &lt;<a href="https://doi.org/10.1007%2Fs11081-020-09571-2">doi:10.1007/s11081-020-09571-2</a>&gt;. Cluster Gauss–Newton method. Optimization and Engineering, 1-31.  Please cite the following paper when profile likelihood plot is drawn with this software and used in your research: Aoki and Sugiyama (2024) &lt;<a href="https://doi.org/10.1002%2Fpsp4.13055">doi:10.1002/psp4.13055</a>&gt;. Cluster Gauss-Newton method for a quick approximation of profile likelihood: With application to physiologically-based pharmacokinetic models. CPT Pharmacometrics Syst Pharmacol.13(1):54-67. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ggplot2, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-18 11:49:19 UTC; yaoki</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-18 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acceptedApproximateMinimizers'>acceptedApproximateMinimizers</h2><span id='topic+acceptedApproximateMinimizers'></span>

<h3>Description</h3>

<p>CGNM find multiple sets of minimizers of the nonlinear least squares (nls) problem by solving nls from various initial iterates.  Although CGNM is shown to be robust compared to other conventional multi-start algorithms, not all initial iterates minimizes successfully.  By assuming sum of squares residual (SSR) follows the chai-square distribution we first reject the approximated minimiser who SSR is statistically significantly worse than the minimum SSR found by the CGNM.  Then use elbow-method (a heuristic often used in mathematical optimisation to balance the quality and the quantity of the solution found) to find the &quot;acceptable&quot; maximum SSR. This function outputs the acceptable approximate minimizers of the nonlinear least squares problem found by the CGNM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acceptedApproximateMinimizers(
  CGNM_result,
  cutoff_pvalue = 0.05,
  numParametersIncluded = NA,
  useAcceptedApproximateMinimizers = TRUE,
  algorithm = 2,
  ParameterNames = NA,
  ReparameterizationDef = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acceptedApproximateMinimizers_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="acceptedApproximateMinimizers_+3A_cutoff_pvalue">cutoff_pvalue</code></td>
<td>
<p>(default: 0.05) <em>A number</em> defines the rejection p-value for the first stage of acceptable computational result screening.</p>
</td></tr>
<tr><td><code id="acceptedApproximateMinimizers_+3A_numparametersincluded">numParametersIncluded</code></td>
<td>
<p>(default: NA) <em>A natural number</em> defines the number of parameter sets to be included in the assessment of the acceptable parameters.  If set NA then use all the parameters found by the CGNM.</p>
</td></tr>
<tr><td><code id="acceptedApproximateMinimizers_+3A_useacceptedapproximateminimizers">useAcceptedApproximateMinimizers</code></td>
<td>
<p>(default: TRUE) <em>TRUE or FALSE</em> If true then use chai-square and elbow method to choose maximum accepted SSR.  If false returns the parameters upto numParametersIncluded-th smallest SSR (or if numParametersIncluded=NA then use all the parameters found by the CGNM).</p>
</td></tr>
<tr><td><code id="acceptedApproximateMinimizers_+3A_algorithm">algorithm</code></td>
<td>
<p>(default: 2) <em>1 or 2</em> specify the algorithm used for obtain accepted approximate minimizers. (Algorithm 1 uses elbow method, Algorithm 2 uses Grubbs' Test for Outliers.)</p>
</td></tr>
<tr><td><code id="acceptedApproximateMinimizers_+3A_parameternames">ParameterNames</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply so that these names are used when making the plot. (Note if it set as NA or vector of incorrect length then the parameters are named as theta1, theta2, ... or as in ReparameterizationDef)</p>
</td></tr>
<tr><td><code id="acceptedApproximateMinimizers_+3A_reparameterizationdef">ReparameterizationDef</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply definition of reparameterization where each string follows R syntax</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A dataframe</em> that each row stores the accepted approximate minimizers found by CGNM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

acceptedApproximateMinimizers(CGNM_result)
</code></pre>

<hr>
<h2 id='acceptedIndices'>acceptedIndices</h2><span id='topic+acceptedIndices'></span>

<h3>Description</h3>

<p>CGNM find multiple sets of minimizers of the nonlinear least squares (nls) problem by solving nls from various initial iterates.  Although CGNM is shown to be robust compared to other conventional multi-start algorithms, not all initial iterates minimizes successfully.  By assuming sum of squares residual (SSR) follows the chai-square distribution we first reject the approximated minimiser who SSR is statistically significantly worse than the minimum SSR found by the CGNM.  Then use elbow-method (a heuristic often used in mathematical optimisation to balance the quality and the quantity of the solution found) to find the &quot;acceptable&quot; maximum SSR. This function outputs the indices of acceptable approximate minimizers of the nonlinear least squares problem found by the CGNM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acceptedIndices(
  CGNM_result,
  cutoff_pvalue = 0.05,
  numParametersIncluded = NA,
  useAcceptedApproximateMinimizers = TRUE,
  algorithm = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acceptedIndices_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="acceptedIndices_+3A_cutoff_pvalue">cutoff_pvalue</code></td>
<td>
<p>(default: 0.05) <em>A number</em> defines the rejection p-value for the first stage of acceptable computational result screening.</p>
</td></tr>
<tr><td><code id="acceptedIndices_+3A_numparametersincluded">numParametersIncluded</code></td>
<td>
<p>(default: NA) <em>A natural number</em> defines the number of parameter sets to be included in the assessment of the acceptable parameters.  If set NA then use all the parameters found by the CGNM.</p>
</td></tr>
<tr><td><code id="acceptedIndices_+3A_useacceptedapproximateminimizers">useAcceptedApproximateMinimizers</code></td>
<td>
<p>(default: TRUE) <em>TRUE or FALSE</em> If true then use chai-square and elbow method to choose maximum accepted SSR.  If false returns the parameters upto numParametersIncluded-th smallest SSR (or if numParametersIncluded=NA then use all the parameters found by the CGNM).</p>
</td></tr>
<tr><td><code id="acceptedIndices_+3A_algorithm">algorithm</code></td>
<td>
<p>(default: 2) <em>1 or 2</em> specify the algorithm used for obtain accepted approximate minimizers. (Algorithm 1 uses elbow method, Algorithm 2 uses Grubbs' Test for Outliers.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A vector of natural number</em> that contains the indices of accepted approximate minimizers found by CGNM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

acceptedIndices(CGNM_result)
</code></pre>

<hr>
<h2 id='acceptedIndices_binary'>acceptedIndices_binary</h2><span id='topic+acceptedIndices_binary'></span>

<h3>Description</h3>

<p>CGNM find multiple sets of minimizers of the nonlinear least squares (nls) problem by solving nls from various initial iterates.  Although CGNM is shown to be robust compared to other conventional multi-start algorithms, not all initial iterates minimizes successfully.  By assuming sum of squares residual (SSR) follows the chai-square distribution we first reject the approximated minimiser who SSR is statistically significantly worse than the minimum SSR found by the CGNM.  Then use elbow-method (a heuristic often used in mathematical optimisation to balance the quality and the quantity of the solution found) to find the &quot;acceptable&quot; maximum SSR. This function outputs the indices of acceptable approximate minimizers of the nonlinear least squares problem found by the CGNM. (note that acceptedIndices(CGNM_result) is equal to seq(1,length(acceptedIndices_binary(CGNM_result)))[acceptedIndices_binary(CGNM_result)])
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acceptedIndices_binary(
  CGNM_result,
  cutoff_pvalue = 0.05,
  numParametersIncluded = NA,
  useAcceptedApproximateMinimizers = TRUE,
  algorithm = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acceptedIndices_binary_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="acceptedIndices_binary_+3A_cutoff_pvalue">cutoff_pvalue</code></td>
<td>
<p>(default: 0.05) <em>A number</em> defines the rejection p-value for the first stage of acceptable computational result screening.</p>
</td></tr>
<tr><td><code id="acceptedIndices_binary_+3A_numparametersincluded">numParametersIncluded</code></td>
<td>
<p>(default: NA) <em>A natural number</em> defines the number of parameter sets to be included in the assessment of the acceptable parameters.  If set NA then use all the parameters found by the CGNM.</p>
</td></tr>
<tr><td><code id="acceptedIndices_binary_+3A_useacceptedapproximateminimizers">useAcceptedApproximateMinimizers</code></td>
<td>
<p>(default: TRUE) <em>TRUE or FALSE</em> If true then use chai-square and elbow method to choose maximum accepted SSR.  If false returns the indicies upto numParametersIncluded-th smallest SSR (or if numParametersIncluded=NA then use all the parameters found by the CGNM).</p>
</td></tr>
<tr><td><code id="acceptedIndices_binary_+3A_algorithm">algorithm</code></td>
<td>
<p>(default: 2) <em>1 or 2</em> specify the algorithm used for obtain accepted approximate minimizers. (Algorithm 1 uses elbow method, Algorithm 2 uses Grubbs' Test for Outliers.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A vector of TRUE and FALSE</em> that indicate if the each of the approximate minimizer found by CGNM is acceptable or not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

acceptedIndices_binary(CGNM_result)
</code></pre>

<hr>
<h2 id='acceptedMaxSSR'>acceptedMaxSSR</h2><span id='topic+acceptedMaxSSR'></span>

<h3>Description</h3>

<p>CGNM find multiple sets of minimizers of the nonlinear least squares (nls) problem by solving nls from various initial iterates.  Although CGNM is shown to be robust compared to other conventional multi-start algorithms, not all initial iterates minimizes successfully.  By assuming sum of squares residual (SSR) follows the chai-square distribution we first reject the approximated minimiser who SSR is statistically significantly worse than the minimum SSR found by the CGNM.  Then use elbow-method (a heuristic often used in mathematical optimisation to balance the quality and the quantity of the solution found) to find the &quot;acceptable&quot; maximum SSR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acceptedMaxSSR(
  CGNM_result,
  cutoff_pvalue = 0.05,
  numParametersIncluded = NA,
  useAcceptedApproximateMinimizers = TRUE,
  algorithm = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acceptedMaxSSR_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="acceptedMaxSSR_+3A_cutoff_pvalue">cutoff_pvalue</code></td>
<td>
<p>(default: 0.05) <em>A number</em> defines the rejection p-value for the first stage of acceptable computational result screening.</p>
</td></tr>
<tr><td><code id="acceptedMaxSSR_+3A_numparametersincluded">numParametersIncluded</code></td>
<td>
<p>(default: NA) <em>A natural number</em> defines the number of parameter sets to be included in the assessment of the acceptable parameters.  If set NA then use all the parameters found by the CGNM.</p>
</td></tr>
<tr><td><code id="acceptedMaxSSR_+3A_useacceptedapproximateminimizers">useAcceptedApproximateMinimizers</code></td>
<td>
<p>(default: TRUE) <em>TRUE or FALSE</em> If true then use chai-square and elbow method to choose maximum accepted SSR.  If false returnsnumParametersIncluded-th smallest SSR (or if numParametersIncluded=NA then returns the largest SSR).</p>
</td></tr>
<tr><td><code id="acceptedMaxSSR_+3A_algorithm">algorithm</code></td>
<td>
<p>(default: 2) <em>1 or 2</em> specify the algorithm used for obtain accepted approximate minimizers. (Algorithm 1 uses elbow method, Algorithm 2 uses Grubbs' Test for Outliers.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A positive real number</em> that is the maximum sum of squares residual (SSR) the algorithm has selected to accept.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

acceptedMaxSSR(CGNM_result)
</code></pre>

<hr>
<h2 id='bestApproximateMinimizers'>bestApproximateMinimizers</h2><span id='topic+bestApproximateMinimizers'></span>

<h3>Description</h3>

<p>Returns the approximate minimizers with minimum SSR found by CGNM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestApproximateMinimizers(
  CGNM_result,
  numParameterSet = 1,
  ParameterNames = NA,
  ReparameterizationDef = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestApproximateMinimizers_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="bestApproximateMinimizers_+3A_numparameterset">numParameterSet</code></td>
<td>
<p>(default 1) <em>A natural number</em> number of parameter sets to output (chosen from the smallest SSR to numParameterSet-th smallest SSR) .</p>
</td></tr>
<tr><td><code id="bestApproximateMinimizers_+3A_parameternames">ParameterNames</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply so that these names are used when making the plot. (Note if it set as NA or vector of incorrect length then the parameters are named as theta1, theta2, ... or as in ReparameterizationDef)</p>
</td></tr>
<tr><td><code id="bestApproximateMinimizers_+3A_reparameterizationdef">ReparameterizationDef</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply definition of reparameterization where each string follows R syntax</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A vector</em> a vector of accepted approximate minimizers with minimum SSR found by CGNM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

bestApproximateMinimizers(CGNM_result,10)
</code></pre>

<hr>
<h2 id='Cluster_Gauss_Newton_Bootstrap_method'>Cluster_Gauss_Newton_Bootstrap_method</h2><span id='topic+Cluster_Gauss_Newton_Bootstrap_method'></span>

<h3>Description</h3>

<p>Conduct residual resampling bootstrap analyses using CGNM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cluster_Gauss_Newton_Bootstrap_method(
  CGNM_result,
  nonlinearFunction,
  ...,
  num_bootstrapSample = 200,
  indicesToUseAsInitialIterates = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cluster_Gauss_Newton_Bootstrap_method_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_Bootstrap_method_+3A_nonlinearfunction">nonlinearFunction</code></td>
<td>
<p>(required input) <em>A function with input of a vector x of real number of length n and output a vector y of real number of length m.</em> In the context of model fitting the nonlinearFunction is <strong>the model</strong>.  Given the CGNM does not assume the uniqueness of the minimizer, m can be less than n.  Also CGNM does not assume any particular form of the nonlinear function and also does not require the function to be continuously differentiable (see Appendix D of our publication for an example when this function is discontinuous).</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_Bootstrap_method_+3A_...">...</code></td>
<td>
<p>Further arguments to be supplied to nonlinearFunction</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_Bootstrap_method_+3A_num_bootstrapsample">num_bootstrapSample</code></td>
<td>
<p>(default: 200) <em>A positive integer</em> number of bootstrap samples to generate.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_Bootstrap_method_+3A_indicestouseasinitialiterates">indicesToUseAsInitialIterates</code></td>
<td>
<p>(default: NA) <em>A vector of integers</em> indices to use for initial iterate of the bootstrap analyses.  For CGNM bootstrap, we use the parameters found by CGNM as the initial iterates, here you can manually spccify which of the approximate minimizers that was found by CGNM (where the CGNM computation result is given as CGNM_result file) to use as initial iterates.  (if NA, use indices chosen by the acceptedIndices() function with default setting).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of a matrix X, Y,residual_history, initialX, bootstrapX, bootstrapY as well as a list runSetting.
</p>
<ol>
<li><p> X, Y, residual_history, initialX: identical to what was given as CGNM_result.
</p>
</li>
<li><p> X: <em>a num_bootstrapSample by n matrix</em> which stores the the X values that was sampled using residual resampling bootstrap analyses (In terms of model fitting this is the parameter combinations with variabilities that represent <strong>parameter estimation uncertainties</strong>.).
</p>
</li>
<li><p> Y: <em>a num_bootstrapSample by m matrix</em> which stores the nonlinearFunction evaluated at the corresponding bootstrap analyses results in matrix bootstrapX above. In the context of model fitting each row corresponds to <strong>the model simulations</strong>.
</p>
</li>
<li><p> runSetting: identical to what is given as CGNM_result but in addition including num_bootstrapSample and indicesToUseAsInitialIterates.</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>##lip-flop kinetics (an example known to have two distinct solutions)

model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation, num_iteration = 10, num_minimizersToFind = 100,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
lowerBound=rep(0,3), ParameterNames=c("Ka","V1","CL_2"), saveLog = FALSE)

CGNM_bootstrap=Cluster_Gauss_Newton_Bootstrap_method(CGNM_result,
     nonlinearFunction=model_analytic_function, num_bootstrapSample=100)

plot_paraDistribution_byHistogram(CGNM_bootstrap)

</code></pre>

<hr>
<h2 id='Cluster_Gauss_Newton_method'>Cluster_Gauss_Newton_method</h2><span id='topic+Cluster_Gauss_Newton_method'></span>

<h3>Description</h3>

<p>Find multiple minimisers of the nonlinear least squares problem.
</p>
<p style="text-align: center;"><code class="reqn">argmin_x ||f(x)-y*||</code>
</p>

<p>where
</p>
<ol>
<li><p> f: nonlinear function (e.g., mathematical model)
</p>
</li>
<li><p> y*: target vector (e.g., observed data to fit the mathematical model)
</p>
</li>
<li><p> x: variable of the nonlinear function that we aim to find the values that minimize (minimizers) the differences between the nonlinear function and target vector (e.g., model parameter)
</p>
</li></ol>

<p>Parameter estimation problems of mathematical models can often be formulated as nonlinear least squares problems.  In this context f can be thought at a model, x is the parameter, and y* is the observation.
CGNM iteratively estimates the minimizer of the nonlinear least squares problem from various initial estimates hence finds multiple minimizers.
Full detail of the algorithm and comparison with conventional method is available in the following publication, also please cite this publication when this algorithm is used in your research: Aoki et al. (2020) &lt;doi.org/10.1007/s11081-020-09571-2&gt;. Cluster Gauss–Newton method. Optimization and Engineering, 1-31.  As illustrated in this paper, CGNM is faster and more robust compared to repeatedly applying the conventional optimization/nonlinear least squares algorithm from various initial estimates. In addition, CGNM can realize this speed assuming the nonlinear function to be a black-box function (e.g. does not use things like adjoint equation of a system of ODE as the function does not have to be based on a system of ODEs.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cluster_Gauss_Newton_method(
  nonlinearFunction,
  ...,
  targetVector,
  initial_lowerRange,
  initial_upperRange,
  lowerBound = NA,
  upperBound = NA,
  ParameterNames = NA,
  stayIn_initialRange = FALSE,
  num_minimizersToFind = 250,
  num_iteration = 25,
  saveLog = TRUE,
  runName = "",
  textMemo = "",
  algorithmParameter_initialLambda = 1,
  algorithmParameter_gamma = 2,
  algorithmVersion = 3,
  initialIterateMatrix = NA,
  targetMatrix = NA,
  keepInitialDistribution = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_nonlinearfunction">nonlinearFunction</code></td>
<td>
<p>(required input) <em>A function with input of a vector x of real number of length n and output a vector y of real number of length m.</em> In the context of model fitting the nonlinearFunction is <strong>the model</strong>.  Given the CGNM does not assume the uniqueness of the minimizer, m can be less than n.  Also CGNM does not assume any particular form of the nonlinear function and also does not require the function to be continuously differentiable (see Appendix D of our publication for an example when this function is discontinuous). Also this function can be matrix to matrix equation.  This can be used for parallerization, see vignettes for examples.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_...">...</code></td>
<td>
<p>Further arguments to be supplied to nonlinearFunction</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_targetvector">targetVector</code></td>
<td>
<p>(required input) <em>A vector of real number of length m</em> where we minimize the Euclidean distance between the nonlinearFuncition and targetVector.  In the context of curve fitting targetVector can be though as <strong>the observational data</strong>.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_initial_lowerrange">initial_lowerRange</code></td>
<td>
<p>(required input) <em>A vector of real number of length n</em> where each element represents  <strong>the lower range of the initial iterate</strong>. Similarly to regular Gauss-Newton method, CGNM iteratively reduce the residual to find minimizers.  Essential differences is that CGNM start from the initial RANGE and not an initial point.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_initial_upperrange">initial_upperRange</code></td>
<td>
<p>(required input) <em>A vector of real number of length n</em> where each element represents  <strong>the upper range of the initial iterate</strong>.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_lowerbound">lowerBound</code></td>
<td>
<p>(default: NA) <em>A vector of real number or NA of length n</em> where each element represents  <strong>the lower bound of the parameter search</strong>.  If no lower bound set that element NA. Note that CGNM is an unconstraint optimization method so the final minimizer can be anywhere.  In the parameter estimation problem, there often is a constraints to the parameters (e.g., parameters cannot be negative). So when the upper or lower bound is set using this option, parameter transformation is conducted internally (e.g., if either the upper or lower bound is given parameters are log transformed, if the upper and lower bounds are given logit transform is used.)</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_upperbound">upperBound</code></td>
<td>
<p>(default: NA) <em>A vector of real number or NA of length n</em> where each element represents  <strong>the upper bound of the parameter search</strong>.  If no upper bound set that element NA.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_parameternames">ParameterNames</code></td>
<td>
<p>(default: NA) <em>A vector of string</em> of length n User can specify names of the parameters that will be used for the plots.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_stayin_initialrange">stayIn_initialRange</code></td>
<td>
<p>(default: FALSE) <em>TRUE or FALSE</em> if set TRUE, the parameter search will conducted strictly within the range specified by initial_lowerRange and initial_upperRange.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_num_minimizerstofind">num_minimizersToFind</code></td>
<td>
<p>(default: 250) <em>A positive integer</em> defining number of approximate minimizers CGNM will find. We usually <strong>use 250 when testing the model and 1000 for the final analysis</strong>.  The computational cost increase proportionally to this number; however, larger number algorithm becomes more stable and increase the chance of finding more better minimizers. See Appendix C of our paper for detail.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_num_iteration">num_iteration</code></td>
<td>
<p>(default: 25)  <em>A positive integer</em> defining maximum number of iterations. We usually <strong>set 25 while model building and 100 for final analysis</strong>.  Given each point terminates the computation when the convergence criterion is met the computation cost does not grow proportionally to the number of iterations (hence safe to increase this without significant increase in the computational cost).</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_savelog">saveLog</code></td>
<td>
<p>(default: TRUE) <em>TRUE or FALSE</em> indicating either or not to save computation result from each iteration in CGNM_log folder. It requires disk write access right in the current working directory. <strong>Recommended to set TRUE if the computation is expected to take long time</strong> as user can retrieve intrim computation result even if the computation is terminated prematurely (or even during the computation).</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_runname">runName</code></td>
<td>
<p>(default: &quot;&quot;) <em>string</em> that user can ue to identify the CGNM runs. The run history will be saved in the folder name CGNM_log_&lt;runName&gt;.  If this is set to &quot;TIME&quot; then runName is automatically set by the run start time.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_textmemo">textMemo</code></td>
<td>
<p>(default: &quot;&quot;) <em>string</em> that user can write an arbitrary text (without influencing computation). This text is stored with the computation result so that can be used for example to describe model so that the user can recognize the computation result.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_algorithmparameter_initiallambda">algorithmParameter_initialLambda</code></td>
<td>
<p>(default: 1) <em>A positive number</em> for initial value for the regularization coefficient lambda see Appendix B of of our paper for detail.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_algorithmparameter_gamma">algorithmParameter_gamma</code></td>
<td>
<p>(default: 2) <em>A positive number</em> a positive scalar value for adjusting the strength of the weighting for the linear approximation see Appendix A of our paper for detail.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_algorithmversion">algorithmVersion</code></td>
<td>
<p>(default: 3.0) <em>A positive number</em> user can choose different version of CGNM algorithm currently 1.0 and 3.0 are available.  If number chosen other than 1.0 or 3.0 it will choose 1.0.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_initialiteratematrix">initialIterateMatrix</code></td>
<td>
<p>(default: NA) <em>A matrix</em> with dimension num_minimizersToFind x n.  User can provide initial iterate as a matrix  This input is used when the user wishes not to generate initial iterate randomly from the initial range.  The user is responsible for ensuring all function evaluation at each initial iterate does not produce NaN.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_targetmatrix">targetMatrix</code></td>
<td>
<p>(default: NA) <em>A matrix</em> with dimension num_minimizersToFind x m  User can define multiple target vectors in the matrix form.  This input is mainly used when running bootstrap method and not intended to be used for other purposes.</p>
</td></tr>
<tr><td><code id="Cluster_Gauss_Newton_method_+3A_keepinitialdistribution">keepInitialDistribution</code></td>
<td>
<p>(default: NA) <em>A vector of TRUE or FALSE</em> of length n User can specify if the initial distribution of one of the input variable (e.g. parameter) to be kept as the initial iterate throughout CGNM iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of a matrix X, Y,residual_history and initialX, as well as a list runSetting
</p>
<ol>
<li><p> X: <em>a num_minimizersToFind by n matrix</em> which stores the approximate minimizers of the nonlinear least squares in each row. In the context of model fitting they are <strong>the estimated parameter sets</strong>.
</p>
</li>
<li><p> Y: <em>a num_minimizersToFind by m matrix</em> which stores the nonlinearFunction evaluated at the corresponding approximate minimizers in matrix X above. In the context of model fitting each row corresponds to <strong>the model simulations</strong>.
</p>
</li>
<li><p> residual_history: <em>a num_iteration by num_minimizersToFind matrix</em> storing sum of squares residual for all iterations.
</p>
</li>
<li><p> initialX: <em>a num_minimizersToFind by n matrix</em> which stores the set of initial iterates.
</p>
</li>
<li><p> runSetting: a list containing all the input variables to Cluster_Gauss_Newton_method (i.e., nonlinearFunction, targetVector, initial_lowerRange, initial_upperRange ,algorithmParameter_initialLambda, algorithmParameter_gamma, num_minimizersToFind, num_iteration, saveLog, runName, textMemo).</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>##lip-flop kinetics (an example known to have two distinct solutions)

model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation, num_iteration = 10, num_minimizersToFind = 100,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
saveLog = FALSE)

acceptedApproximateMinimizers(CGNM_result)

## Not run: 
library(RxODE)

model_text="
d/dt(X_1)=-ka*X_1
d/dt(C_2)=(ka*X_1-CL_2*C_2)/V1"

model=RxODE(model_text)
#define nonlinearFunction
model_function=function(x){

observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)

theta &lt;- c(ka=x[1],V1=x[2],CL_2=x[3])
ev &lt;- eventTable()
ev$add.dosing(dose = 1000, start.time =0)
ev$add.sampling(observation_time)
odeSol=model$solve(theta, ev)
log10(odeSol[,"C_2"])

}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(nonlinearFunction=model_function,
targetVector = observation, saveLog = FALSE,
initial_lowerRange = c(0.1,0.1,0.1),initial_upperRange =  c(10,10,10))
## End(Not run)

</code></pre>

<hr>
<h2 id='plot_2DprofileLikelihood'>plot_2DprofileLikelihood</h2><span id='topic+plot_2DprofileLikelihood'></span>

<h3>Description</h3>

<p>Make likelihood related values v.s. parameterValues plot using the function evaluations used during CGNM computation. Note plot_SSRsurface can only be used when log is saved by setting saveLog=TRUE option when running Cluster_Gauss_Newton_method().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_2DprofileLikelihood(
  logLocation,
  index_x = NA,
  index_y = NA,
  plotType = 2,
  plotMax = NA,
  ParameterNames = NA,
  ReparameterizationDef = NA,
  numBins = NA,
  showInitialRange = TRUE,
  alpha = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_2DprofileLikelihood_+3A_loglocation">logLocation</code></td>
<td>
<p>(required input) <em>A string or a list of strings</em> of folder directory where CGNM computation log files exist.</p>
</td></tr>
<tr><td><code id="plot_2DprofileLikelihood_+3A_index_x">index_x</code></td>
<td>
<p>(default: NA) <em>A vector of strings or numbers</em> List parameter names or indices used for the surface plot. (if NA all parameters are used)</p>
</td></tr>
<tr><td><code id="plot_2DprofileLikelihood_+3A_index_y">index_y</code></td>
<td>
<p>(default: NA) <em>A vector of strings or numbers</em> List parameter names or indices used for the surface plot. (if NA all parameters are used)</p>
</td></tr>
<tr><td><code id="plot_2DprofileLikelihood_+3A_plottype">plotType</code></td>
<td>
<p>(default: 2) <em>A number 0,1,2,3, or 4</em> 0: number of model evaluations done, 1: (1-alpha) where alpha is the significance level, this plot is recommended for the ease of visualization as it ranges from 0 to 1. 2: -2log likelihood. 3: SSR. 4: all points within 1-alpha confidence region</p>
</td></tr>
<tr><td><code id="plot_2DprofileLikelihood_+3A_plotmax">plotMax</code></td>
<td>
<p>(default: NA) <em>A number</em> the maximum value that will be plotted on surface plot. (If NA all values are included in the plot, note SSR or likelihood can range many orders of magnitudes fo may want to restrict when plotting them)</p>
</td></tr>
<tr><td><code id="plot_2DprofileLikelihood_+3A_parameternames">ParameterNames</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply so that these names are used when making the plot. (Note if it set as NA or vector of incorrect length then the parameters are named as theta1, theta2, ... or as in ReparameterizationDef)</p>
</td></tr>
<tr><td><code id="plot_2DprofileLikelihood_+3A_reparameterizationdef">ReparameterizationDef</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply definition of reparameterization where each string follows R syntax</p>
</td></tr>
<tr><td><code id="plot_2DprofileLikelihood_+3A_numbins">numBins</code></td>
<td>
<p>(default: NA) <em>A positive integer</em> 2D profile likelihood surface is plotted by finding the minimum SSR given two of the parameters are fixed and then repeat this for various values.  numBins specifies the number of different parameter values to fix for each parameter. (if set NA the number of bins are set as num_minimizersToFind/10)</p>
</td></tr>
<tr><td><code id="plot_2DprofileLikelihood_+3A_showinitialrange">showInitialRange</code></td>
<td>
<p>(default: TRUE) <em>TRUE or FALSE</em> if TRUE then the initial range appears in the plot.</p>
</td></tr>
<tr><td><code id="plot_2DprofileLikelihood_+3A_alpha">alpha</code></td>
<td>
<p>(default: 0.25) <em>a number between 0 and 1</em> level of significance (all the points outside of this significance level will not be plotted when plot tyoe 1,2 or 4 are chosen).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> including the violin plot, interquartile range and median, minimum and maximum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=10^x[1]
 V1=10^x[2]
 CL_2=10^x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(-1,-1,-1), initial_upperRange =  c(1,1,1),
num_iter = 10, num_minimizersToFind = 500, saveLog=TRUE)

## the minimum example
plot_2DprofileLikelihood("CGNM_log")

## we can draw profilelikelihood also including bootstrap result
CGNM_result=Cluster_Gauss_Newton_Bootstrap_method(CGNM_result,
                      nonlinearFunction = model_analytic_function)

## example with various options
plot_2DprofileLikelihood(c("CGNM_log","CGNM_log_bootstrap"),
 showInitialRange = TRUE,index_x = c("ka","V1"))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='plot_goodnessOfFit'>plot_goodnessOfFit</h2><span id='topic+plot_goodnessOfFit'></span>

<h3>Description</h3>

<p>Make goodness of fit plots to assess the model-fit and bias in residual distribution. The linear model is fit to the residual and plotted using geom_smooth(method=lm) in ggplot.<br /><br />
Explanation of the terminologies in terms of PBPK model fitting to the time-course drug concentration measurements:
<br /> &quot;independent variable&quot; is time
<br /> &quot;dependent variable&quot; is the concentration.
<br /> &quot;Residual&quot; is the difference between the measured concentration and the model simulation with the parameter fond by the CGNM.
<br /> &quot;m&quot; is number of observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_goodnessOfFit(
  CGNM_result,
  plotType = 1,
  plotRank = c(1),
  independentVariableVector = NA,
  dependentVariableTypeVector = NA,
  absResidual = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_goodnessOfFit_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="plot_goodnessOfFit_+3A_plottype">plotType</code></td>
<td>
<p>(default: 1) <em>1,2 or 3</em><br /> specify the kind of goodness of fit plot to create</p>
</td></tr>
<tr><td><code id="plot_goodnessOfFit_+3A_plotrank">plotRank</code></td>
<td>
<p>(default: c(1)) <em>a vector of integers</em><br /> Specify which rank of the parameter to use for the goodness of fit plots. (e.g., if one wishes to use rank 1 to 100 then set it to be seq(1,100), or if one wish to use 88th rank parameters then set this as 88.)</p>
</td></tr>
<tr><td><code id="plot_goodnessOfFit_+3A_independentvariablevector">independentVariableVector</code></td>
<td>
<p>(default: NA) <em>a vector of numerics of length m</em> <br /> set independent variables that target values are associated with (e.g., time of the drug concentration measurement one is fitting PBPK model to) <br />(when this variable is set to NA, seq(1,m) will be used as independent variable when appropriate).</p>
</td></tr>
<tr><td><code id="plot_goodnessOfFit_+3A_dependentvariabletypevector">dependentVariableTypeVector</code></td>
<td>
<p>(default: NA) <em>a vector of text of length m</em> <br /> when this variable is set (i.e., not NA) then the goodness of fit analyses is done for each variable type.  For example, if we are fitting the PBPK model to data with multiple dose arms, one can see the goodness of fit for each dose arm by specifying which dose group the observations are from.</p>
</td></tr>
<tr><td><code id="plot_goodnessOfFit_+3A_absresidual">absResidual</code></td>
<td>
<p>(default: FALSE)  <em>TRUE or FALSE</em> If TRUE plot absolute values of the residual.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> of the goodness of fit plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=10^x[1]
 V1=10^x[2]
 CL_2=10^x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = rep(0.01,3), initial_upperRange =  rep(100,3),
lowerBound=rep(0,3), ParameterNames = c("Ka","V1","CL"),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

plot_goodnessOfFit(CGNM_result)
plot_goodnessOfFit(CGNM_result,
     independentVariableVector=c(0.1,0.2,0.4,0.6,1,2,3,6,12))
</code></pre>

<hr>
<h2 id='plot_paraDistribution_byHistogram'>plot_paraDistribution_byHistogram</h2><span id='topic+plot_paraDistribution_byHistogram'></span>

<h3>Description</h3>

<p>Make histograms to visualize the initial distribution and distribition of the accepted approximate minimizers found by the CGNM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_paraDistribution_byHistogram(
  CGNM_result,
  indicesToInclude = NA,
  ParameterNames = NA,
  ReparameterizationDef = NA,
  bins = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_paraDistribution_byHistogram_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="plot_paraDistribution_byHistogram_+3A_indicestoinclude">indicesToInclude</code></td>
<td>
<p>(default: NA) <em>A vector of integers</em> indices to include in the plot (if NA, use indices chosen by the acceptedIndices() function with default setting).</p>
</td></tr>
<tr><td><code id="plot_paraDistribution_byHistogram_+3A_parameternames">ParameterNames</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply so that these names are used when making the plot. (Note if it set as NA or vector of incorrect length then the parameters are named as theta1, theta2, ... or as in ReparameterizationDef)</p>
</td></tr>
<tr><td><code id="plot_paraDistribution_byHistogram_+3A_reparameterizationdef">ReparameterizationDef</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply definition of reparameterization where each string follows R syntax</p>
</td></tr>
<tr><td><code id="plot_paraDistribution_byHistogram_+3A_bins">bins</code></td>
<td>
<p>(default: 30) <em>A natural number</em> Number of bins used for plotting histogram.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> including the violin plot, interquartile range and median, minimum and maximum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))



CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = rep(0.01,3), initial_upperRange =  rep(100,3),
lowerBound=rep(0,3), ParameterNames = c("Ka","V1","CL"),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

plot_paraDistribution_byHistogram(CGNM_result)
plot_paraDistribution_byHistogram(CGNM_result,
     ReparameterizationDef=c("log10(Ka)","log10(V1)","log10(CL)"))

</code></pre>

<hr>
<h2 id='plot_paraDistribution_byViolinPlots'>plot_paraDistribution_byViolinPlots</h2><span id='topic+plot_paraDistribution_byViolinPlots'></span>

<h3>Description</h3>

<p>Make violin plot to compare the initial distribution and distribition of the accepted approximate minimizers found by the CGNM. Bars in the violin plots indicates the interquartile range. The solid line connects the interquartile ranges of the initial distribution and the distribution of the accepted approximate minimizer at the final iterate.  The blacklines connets the minimums and maximums of the initial distribution and the distribution of the accepted approximate minimizer at the final iterate. The black dots indicate the median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_paraDistribution_byViolinPlots(
  CGNM_result,
  indicesToInclude = NA,
  ParameterNames = NA,
  ReparameterizationDef = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_paraDistribution_byViolinPlots_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="plot_paraDistribution_byViolinPlots_+3A_indicestoinclude">indicesToInclude</code></td>
<td>
<p>(default: NA) <em>A vector of integers</em> indices to include in the plot (if NA, use indices chosen by the acceptedIndices() function with default setting).</p>
</td></tr>
<tr><td><code id="plot_paraDistribution_byViolinPlots_+3A_parameternames">ParameterNames</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply so that these names are used when making the plot. (Note if it set as NA or vector of incorrect length then the parameters are named as theta1, theta2, ... or as in ReparameterizationDef)</p>
</td></tr>
<tr><td><code id="plot_paraDistribution_byViolinPlots_+3A_reparameterizationdef">ReparameterizationDef</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply definition of reparameterization where each string follows R syntax</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> including the violin plot, interquartile range and median, minimum and maximum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))



CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = rep(0.01,3), initial_upperRange =  rep(100,3),
lowerBound=rep(0,3), ParameterNames = c("Ka","V1","CL"),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

plot_paraDistribution_byViolinPlots(CGNM_result)
plot_paraDistribution_byViolinPlots(CGNM_result,
     ReparameterizationDef=c("log10(Ka)","log10(V1)","log10(CL)"))


</code></pre>

<hr>
<h2 id='plot_parameterValue_scatterPlots'>plot_parameterValue_scatterPlots</h2><span id='topic+plot_parameterValue_scatterPlots'></span>

<h3>Description</h3>

<p>Make scatter plots of the accepted approximate minimizers found by the CGNM. Bars in the violin plots indicates the interquartile range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_parameterValue_scatterPlots(CGNM_result, indicesToInclude = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_parameterValue_scatterPlots_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="plot_parameterValue_scatterPlots_+3A_indicestoinclude">indicesToInclude</code></td>
<td>
<p>(default: NA) <em>A vector of integers</em> indices to include in the plot (if NA, use indices chosen by the acceptedIndices() function with default setting).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> including the violin plot, interquartile range and median, minimum and maximum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

plot_parameterValue_scatterPlots(CGNM_result)
</code></pre>

<hr>
<h2 id='plot_profileLikelihood'>plot_profileLikelihood</h2><span id='topic+plot_profileLikelihood'></span>

<h3>Description</h3>

<p>Draw profile likelihood surface using the function evaluations conducted during CGNM computation. Note plot_SSRsurface can only be used when log is saved by setting saveLog=TRUE option when running Cluster_Gauss_Newton_method().  The grey horizontal line is the threshold for 95
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_profileLikelihood(
  logLocation,
  alpha = 0.25,
  numBins = NA,
  ParameterNames = NA,
  ReparameterizationDef = NA,
  showInitialRange = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_profileLikelihood_+3A_loglocation">logLocation</code></td>
<td>
<p>(required input) <em>A string</em> of folder directory where CGNM computation log files exist.</p>
</td></tr>
<tr><td><code id="plot_profileLikelihood_+3A_alpha">alpha</code></td>
<td>
<p>(default: 0.25) <em>a number between 0 and 1</em> level of significance (used to draw horizontal line on the profile likelihood).</p>
</td></tr>
<tr><td><code id="plot_profileLikelihood_+3A_numbins">numBins</code></td>
<td>
<p>(default: NA) <em>A positive integer</em> SSR surface is plotted by finding the minimum SSR given one of the parameters is fixed and then repeat this for various values.  numBins specifies the number of different parameter values to fix for each parameter. (if set NA the number of bins are set as num_minimizersToFind/10)</p>
</td></tr>
<tr><td><code id="plot_profileLikelihood_+3A_parameternames">ParameterNames</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply so that these names are used when making the plot. (Note if it set as NA or vector of incorrect length then the parameters are named as theta1, theta2, ... or as in ReparameterizationDef)</p>
</td></tr>
<tr><td><code id="plot_profileLikelihood_+3A_reparameterizationdef">ReparameterizationDef</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply definition of reparameterization where each string follows R syntax</p>
</td></tr>
<tr><td><code id="plot_profileLikelihood_+3A_showinitialrange">showInitialRange</code></td>
<td>
<p>(default: TRUE) <em>TRUE or FALSE</em> if TRUE then the initial range appears in the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> including the violin plot, interquartile range and median, minimum and maximum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog=TRUE)

plot_profileLikelihood("CGNM_log")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_Rank_SSR'>plot_Rank_SSR</h2><span id='topic+plot_Rank_SSR'></span>

<h3>Description</h3>

<p>Make SSR v.s. rank plot. This plot is often used to visualize the maximum accepted SSR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_Rank_SSR(CGNM_result, indicesToInclude = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_Rank_SSR_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="plot_Rank_SSR_+3A_indicestoinclude">indicesToInclude</code></td>
<td>
<p>(default: NA) <em>A vector of integers</em> indices to include in the plot (if NA, use indices chosen by the acceptedIndices() function with default setting).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> of SSR v.s. rank.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

plot_Rank_SSR(CGNM_result)
</code></pre>

<hr>
<h2 id='plot_simulationMatrixWithCI'>plot_simulationMatrixWithCI</h2><span id='topic+plot_simulationMatrixWithCI'></span>

<h3>Description</h3>

<p>Plot simulation that are provided to plot confidence interval (or more like a confidence region).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_simulationMatrixWithCI(
  simulationMatrix,
  independentVariableVector = NA,
  dependentVariableTypeVector = NA,
  confidenceLevels = c(0.25, 0.75),
  observationVector = NA,
  observationIndpendentVariableVector = NA,
  observationDependentVariableTypeVector = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_simulationMatrixWithCI_+3A_simulationmatrix">simulationMatrix</code></td>
<td>
<p>(required input) <em>A matrix of numbers</em> where each row contains the simulated values that will be plotted.</p>
</td></tr>
<tr><td><code id="plot_simulationMatrixWithCI_+3A_independentvariablevector">independentVariableVector</code></td>
<td>
<p>(default: NA) <em>A vector of numbers</em> that represents the independent variables of each points of the simulation (e.g., observation time) where used for the values of x-axis when plotting. If set at NA then sequence of 1,2,3,... will be used.</p>
</td></tr>
<tr><td><code id="plot_simulationMatrixWithCI_+3A_dependentvariabletypevector">dependentVariableTypeVector</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> specify the kind of variable the simulation values are. (i.e., if it simulate both PK and PD then indicate which simulation value is PK and which is PD).</p>
</td></tr>
<tr><td><code id="plot_simulationMatrixWithCI_+3A_confidencelevels">confidenceLevels</code></td>
<td>
<p>(default: c(25,75)) <em>A vector of two numbers between 0 and 1</em> set the confidence interval that will be used for the plot.  Default is inter-quartile range.</p>
</td></tr>
<tr><td><code id="plot_simulationMatrixWithCI_+3A_observationvector">observationVector</code></td>
<td>
<p>(default: NA) <em>A vector of numbers</em> used when wishing to overlay the plot of observations to the simulation.</p>
</td></tr>
<tr><td><code id="plot_simulationMatrixWithCI_+3A_observationindpendentvariablevector">observationIndpendentVariableVector</code></td>
<td>
<p>(default: NA) <em>A vector of numbers</em> used when wishing to overlay the plot of observations to the simulation.</p>
</td></tr>
<tr><td><code id="plot_simulationMatrixWithCI_+3A_observationdependentvariabletypevector">observationDependentVariableTypeVector</code></td>
<td>
<p>(default: NA) <em>A vector of numbers</em> used when wishing to overlay the plot of observations to the simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> including the violin plot, interquartile range and median, minimum and maximum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 (Cp)
}

observation=(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation, num_iteration = 10, num_minimizersToFind = 100,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
lowerBound=rep(0,3), ParameterNames=c("Ka","V1","CL_2"), saveLog = FALSE)

CGNM_bootstrap=Cluster_Gauss_Newton_Bootstrap_method(CGNM_result,
     nonlinearFunction=model_analytic_function, num_bootstrapSample=100)


plot_simulationMatrixWithCI(CGNM_result$bootstrapY,
independentVariableVector=observation_time, observationVector=observation)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_simulationWithCI'>plot_simulationWithCI</h2><span id='topic+plot_simulationWithCI'></span>

<h3>Description</h3>

<p>Plot model simulation where the various parameter combinations are provided and conduct simulations and then the confidence interval (or more like a confidence region) is plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_simulationWithCI(
  simulationFunction,
  parameter_matrix,
  independentVariableVector = NA,
  dependentVariableTypeVector = NA,
  confidenceLevels = c(0.25, 0.75),
  observationVector = NA,
  observationIndpendentVariableVector = NA,
  observationDependentVariableTypeVector = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_simulationWithCI_+3A_simulationfunction">simulationFunction</code></td>
<td>
<p>(required input) <em>A function</em> that maps the parameter vector to the simulation.</p>
</td></tr>
<tr><td><code id="plot_simulationWithCI_+3A_parameter_matrix">parameter_matrix</code></td>
<td>
<p>(required input) <em>A matrix of numbers</em> where each row contains the parameter combination that will be used for the simulations.</p>
</td></tr>
<tr><td><code id="plot_simulationWithCI_+3A_independentvariablevector">independentVariableVector</code></td>
<td>
<p>(default: NA) <em>A vector of numbers</em> that represents the independent variables of each points of the simulation (e.g., observation time) where used for the values of x-axis when plotting. If set at NA then sequence of 1,2,3,... will be used.</p>
</td></tr>
<tr><td><code id="plot_simulationWithCI_+3A_dependentvariabletypevector">dependentVariableTypeVector</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> specify the kind of variable the simulationFunction simulate out. (i.e., if it simulate both PK and PD then indicate which simulation output is PK and which is PD).</p>
</td></tr>
<tr><td><code id="plot_simulationWithCI_+3A_confidencelevels">confidenceLevels</code></td>
<td>
<p>(default: c(25,75)) <em>A vector of two numbers between 0 and 1</em> set the confidence interval that will be used for the plot.  Default is inter-quartile range.</p>
</td></tr>
<tr><td><code id="plot_simulationWithCI_+3A_observationvector">observationVector</code></td>
<td>
<p>(default: NA) <em>A vector of numbers</em> used when wishing to overlay the plot of observations to the simulation.</p>
</td></tr>
<tr><td><code id="plot_simulationWithCI_+3A_observationindpendentvariablevector">observationIndpendentVariableVector</code></td>
<td>
<p>(default: NA) <em>A vector of numbers</em> used when wishing to overlay the plot of observations to the simulation.</p>
</td></tr>
<tr><td><code id="plot_simulationWithCI_+3A_observationdependentvariabletypevector">observationDependentVariableTypeVector</code></td>
<td>
<p>(default: NA) <em>A vector of numbers</em> used when wishing to overlay the plot of observations to the simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> including the violin plot, interquartile range and median, minimum and maximum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 (Cp)
}

observation=(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation, num_iteration = 10, num_minimizersToFind = 100,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
lowerBound=rep(0,3), ParameterNames=c("Ka","V1","CL_2"), saveLog = FALSE)

CGNM_bootstrap=Cluster_Gauss_Newton_Bootstrap_method(CGNM_result,
     nonlinearFunction=model_analytic_function, num_bootstrapSample=100)

plot_simulationWithCI(model_analytic_function, as.matrix(CGNM_result$bootstrapTheta),
independentVariableVector=observation_time, observationVector=observation)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_SSR_parameterValue'>plot_SSR_parameterValue</h2><span id='topic+plot_SSR_parameterValue'></span>

<h3>Description</h3>

<p>Make SSR v.s. parameterValue plot of the accepted approximate minimizers found by the CGNM. Bars in the violin plots indicates the interquartile range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_SSR_parameterValue(
  CGNM_result,
  indicesToInclude = NA,
  ParameterNames = NA,
  ReparameterizationDef = NA,
  showInitialRange = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_SSR_parameterValue_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="plot_SSR_parameterValue_+3A_indicestoinclude">indicesToInclude</code></td>
<td>
<p>(default: NA) <em>A vector of integers</em> indices to include in the plot (if NA, use indices chosen by the acceptedIndices() function with default setting).</p>
</td></tr>
<tr><td><code id="plot_SSR_parameterValue_+3A_parameternames">ParameterNames</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply so that these names are used when making the plot. (Note if it set as NA or vector of incorrect length then the parameters are named as theta1, theta2, ... or as in ReparameterizationDef)</p>
</td></tr>
<tr><td><code id="plot_SSR_parameterValue_+3A_reparameterizationdef">ReparameterizationDef</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply definition of reparameterization where each string follows R syntax</p>
</td></tr>
<tr><td><code id="plot_SSR_parameterValue_+3A_showinitialrange">showInitialRange</code></td>
<td>
<p>(default: TRUE) <em>TRUE or FALSE</em> if TRUE then the initial range appears in the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> including the violin plot, interquartile range and median, minimum and maximum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

plot_SSR_parameterValue(CGNM_result)
</code></pre>

<hr>
<h2 id='plot_SSRsurface'>plot_SSRsurface</h2><span id='topic+plot_SSRsurface'></span>

<h3>Description</h3>

<p>Make minimum SSR v.s. parameterValue plot using the function evaluations used during CGNM computation. Note plot_SSRsurface can only be used when log is saved by setting saveLog=TRUE option when running Cluster_Gauss_Newton_method().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_SSRsurface(
  logLocation,
  alpha = 0.25,
  profile_likelihood = FALSE,
  numBins = NA,
  maxSSR = NA,
  ParameterNames = NA,
  ReparameterizationDef = NA,
  showInitialRange = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_SSRsurface_+3A_loglocation">logLocation</code></td>
<td>
<p>(required input) <em>A string or a list of strings</em> of folder directory where CGNM computation log files exist.</p>
</td></tr>
<tr><td><code id="plot_SSRsurface_+3A_alpha">alpha</code></td>
<td>
<p>(default: 0.25) <em>a number between 0 and 1</em> level of significance (used to draw horizontal line on the profile likelihood).</p>
</td></tr>
<tr><td><code id="plot_SSRsurface_+3A_profile_likelihood">profile_likelihood</code></td>
<td>
<p>(default: FALSE) <em>TRUE or FALSE</em> If set TRUE plot profile likelihood (assuming normal distribution of residual) instead of SSR surface.</p>
</td></tr>
<tr><td><code id="plot_SSRsurface_+3A_numbins">numBins</code></td>
<td>
<p>(default: NA) <em>A positive integer</em> SSR surface is plotted by finding the minimum SSR given one of the parameters is fixed and then repeat this for various values.  numBins specifies the number of different parameter values to fix for each parameter. (if set NA the number of bins are set as num_minimizersToFind/10)</p>
</td></tr>
<tr><td><code id="plot_SSRsurface_+3A_maxssr">maxSSR</code></td>
<td>
<p>(default: NA) <em>A positive number</em> the maximum SSR that will be plotted on SSR surface plot.  This option is used to zoom into the SSR surface near the minimum SSR.</p>
</td></tr>
<tr><td><code id="plot_SSRsurface_+3A_parameternames">ParameterNames</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply so that these names are used when making the plot. (Note if it set as NA or vector of incorrect length then the parameters are named as theta1, theta2, ... or as in ReparameterizationDef)</p>
</td></tr>
<tr><td><code id="plot_SSRsurface_+3A_reparameterizationdef">ReparameterizationDef</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply definition of reparameterization where each string follows R syntax</p>
</td></tr>
<tr><td><code id="plot_SSRsurface_+3A_showinitialrange">showInitialRange</code></td>
<td>
<p>(default: FALSE) <em>TRUE or FALSE</em> if TRUE then the initial range appears in the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> including the violin plot, interquartile range and median, minimum and maximum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog=TRUE)

plot_SSRsurface("CGNM_log") + scale_y_continuous(trans='log10')

## End(Not run)
</code></pre>

<hr>
<h2 id='suggestInitialLowerRange'>suggestInitialLowerRange</h2><span id='topic+suggestInitialLowerRange'></span>

<h3>Description</h3>

<p>Suggest initial lower range based on the profile likelihood. The user can re-run CGNM with this suggested initial range so that to improve the convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suggestInitialLowerRange(logLocation, alpha = 0.25, numBins = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suggestInitialLowerRange_+3A_loglocation">logLocation</code></td>
<td>
<p>(required input) <em>A string or a list of strings</em> of folder directory where CGNM computation log files exist.</p>
</td></tr>
<tr><td><code id="suggestInitialLowerRange_+3A_alpha">alpha</code></td>
<td>
<p>(default: 0.25) <em>a number between 0 and 1</em> level of significance used to derive the confidence interval.</p>
</td></tr>
<tr><td><code id="suggestInitialLowerRange_+3A_numbins">numBins</code></td>
<td>
<p>(default: NA) <em>A positive integer</em> SSR surface is plotted by finding the minimum SSR given one of the parameters is fixed and then repeat this for various values.  numBins specifies the number of different parameter values to fix for each parameter. (if set NA the number of bins are set as num_minimizersToFind/10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A numerical vector</em> of suggested initial lower range based on profile likelihood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog=TRUE)

suggestInitialLowerRange("CGNM_log")

## End(Not run)
</code></pre>

<hr>
<h2 id='suggestInitialUpperRange'>suggestInitialUpperRange</h2><span id='topic+suggestInitialUpperRange'></span>

<h3>Description</h3>

<p>Suggest initial upper range based on the profile likelihood. The user can re-run CGNM with this suggested initial range so that to improve the convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suggestInitialUpperRange(logLocation, alpha = 0.25, numBins = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suggestInitialUpperRange_+3A_loglocation">logLocation</code></td>
<td>
<p>(required input) <em>A string or a list of strings</em> of folder directory where CGNM computation log files exist.</p>
</td></tr>
<tr><td><code id="suggestInitialUpperRange_+3A_alpha">alpha</code></td>
<td>
<p>(default: 0.25) <em>a number between 0 and 1</em> level of significance used to derive the confidence interval.</p>
</td></tr>
<tr><td><code id="suggestInitialUpperRange_+3A_numbins">numBins</code></td>
<td>
<p>(default: NA) <em>A positive integer</em> SSR surface is plotted by finding the minimum SSR given one of the parameters is fixed and then repeat this for various values.  numBins specifies the number of different parameter values to fix for each parameter. (if set NA the number of bins are set as num_minimizersToFind/10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A numerical vector</em> of suggested initial upper range based on profile likelihood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog=TRUE)

suggestInitialLowerRange("CGNM_log")

## End(Not run)
</code></pre>

<hr>
<h2 id='table_parameterSummary'>table_parameterSummary</h2><span id='topic+table_parameterSummary'></span>

<h3>Description</h3>

<p>Make summary table of the approximate local minimizers found by CGNM.  If bootstrap analysis result is available, relative standard error (RSE: standard deviation/mean) will also be included in the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_parameterSummary(
  CGNM_result,
  indicesToInclude = NA,
  ParameterNames = NA,
  ReparameterizationDef = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_parameterSummary_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="table_parameterSummary_+3A_indicestoinclude">indicesToInclude</code></td>
<td>
<p>(default: NA) <em>A vector of integers</em> indices to include in the plot (if NA, use indices chosen by the acceptedIndices() function with default setting).</p>
</td></tr>
<tr><td><code id="table_parameterSummary_+3A_parameternames">ParameterNames</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply so that these names are used when making the plot. (Note if it set as NA or vector of incorrect length then the parameters are named as theta1, theta2, ... or as in ReparameterizationDef)</p>
</td></tr>
<tr><td><code id="table_parameterSummary_+3A_reparameterizationdef">ReparameterizationDef</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply definition of reparameterization where each string follows R syntax.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> including the violin plot, interquartile range and median, minimum and maximum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))



CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = rep(0.01,3), initial_upperRange =  rep(100,3),
lowerBound=rep(0,3), ParameterNames = c("Ka","V1","CL"),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

table_parameterSummary(CGNM_result)
table_parameterSummary(CGNM_result,
     ReparameterizationDef=c("log10(Ka)","log10(V1)","log10(CL)"))

</code></pre>

<hr>
<h2 id='table_profileLikelihoodConfidenceInterval'>table_profileLikelihoodConfidenceInterval</h2><span id='topic+table_profileLikelihoodConfidenceInterval'></span>

<h3>Description</h3>

<p>Make table of confidence intervals that are approximated from the profile likelihood. First inspect profile likelihood plot and make sure the plot is smooth and has good enough resolution and the initial range is appropriate. Do not report this table without checking the profile likelihood plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_profileLikelihoodConfidenceInterval(
  logLocation,
  alpha = 0.25,
  numBins = NA,
  ParameterNames = NA,
  ReparameterizationDef = NA,
  pretty = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_profileLikelihoodConfidenceInterval_+3A_loglocation">logLocation</code></td>
<td>
<p>(required input) <em>A string or a list of strings</em> of folder directory where CGNM computation log files exist.</p>
</td></tr>
<tr><td><code id="table_profileLikelihoodConfidenceInterval_+3A_alpha">alpha</code></td>
<td>
<p>(default: 0.25) <em>a number between 0 and 1</em> level of significance used to derive the confidence interval.</p>
</td></tr>
<tr><td><code id="table_profileLikelihoodConfidenceInterval_+3A_numbins">numBins</code></td>
<td>
<p>(default: NA) <em>A positive integer</em> SSR surface is plotted by finding the minimum SSR given one of the parameters is fixed and then repeat this for various values.  numBins specifies the number of different parameter values to fix for each parameter. (if set NA the number of bins are set as num_minimizersToFind/10)</p>
</td></tr>
<tr><td><code id="table_profileLikelihoodConfidenceInterval_+3A_parameternames">ParameterNames</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply so that these names are used when making the plot. (Note if it set as NA or vector of incorrect length then the parameters are named as theta1, theta2, ... or as in ReparameterizationDef)</p>
</td></tr>
<tr><td><code id="table_profileLikelihoodConfidenceInterval_+3A_reparameterizationdef">ReparameterizationDef</code></td>
<td>
<p>(default: NA) <em>A vector of strings</em> the user can supply definition of reparameterization where each string follows R syntax</p>
</td></tr>
<tr><td><code id="table_profileLikelihoodConfidenceInterval_+3A_pretty">pretty</code></td>
<td>
<p>(default: FALSE) <em>TRUE or FALSE</em> if true then the publication ready table will be an output</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A ggplot object</em> including the violin plot, interquartile range and median, minimum and maximum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog=TRUE)

table_profileLikelihoodConfidenceInterval("CGNM_log")

## End(Not run)
</code></pre>

<hr>
<h2 id='topIndices'>topIndices</h2><span id='topic+topIndices'></span>

<h3>Description</h3>

<p>CGNM find multiple sets of minimizers of the nonlinear least squares (nls) problem by solving nls from various initial iterates.  Although CGNM is shown to be robust compared to other conventional multi-start algorithms, not all initial iterates minimizes successfully.  One can visually inspect rank v.s. SSR plot and manually choose number of best fit acceptable parameters.  By using this function &quot;topIndices&quot;, we can obtain the indices of the &quot;numTopIndices&quot; best fit parameter combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topIndices(CGNM_result, numTopIndices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topIndices_+3A_cgnm_result">CGNM_result</code></td>
<td>
<p>(required input) <em>A list</em> stores the computational result from Cluster_Gauss_Newton_method() function in CGNM package.</p>
</td></tr>
<tr><td><code id="topIndices_+3A_numtopindices">numTopIndices</code></td>
<td>
<p>(required input) <em>An integer</em> .</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>A vector of natural number</em> that contains the indices of accepted approximate minimizers found by CGNM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model_analytic_function=function(x){

 observation_time=c(0.1,0.2,0.4,0.6,1,2,3,6,12)
 Dose=1000
 F=1

 ka=x[1]
 V1=x[2]
 CL_2=x[3]
 t=observation_time

 Cp=ka*F*Dose/(V1*(ka-CL_2/V1))*(exp(-CL_2/V1*t)-exp(-ka*t))

 log10(Cp)
}

observation=log10(c(4.91, 8.65, 12.4, 18.7, 24.3, 24.5, 18.4, 4.66, 0.238))

CGNM_result=Cluster_Gauss_Newton_method(
nonlinearFunction=model_analytic_function,
targetVector = observation,
initial_lowerRange = c(0.1,0.1,0.1), initial_upperRange =  c(10,10,10),
num_iter = 10, num_minimizersToFind = 100, saveLog = FALSE)

topInd=topIndices(CGNM_result, 10)

## This gives top 10 approximate minimizers
CGNM_result$X[topInd,]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
