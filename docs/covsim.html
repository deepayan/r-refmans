<!DOCTYPE html><html lang="en"><head><title>Help for package covsim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {covsim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rIG'><p>Simulation of non-normal data</p></a></li>
<li><a href='#rPLSIM'><p>Simulation of non-normal data</p></a></li>
<li><a href='#vita'><p>Calibrate a regular vine</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>VITA, IG and PLSIM Simulation for Given Covariance and Marginals</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Random sampling from distributions with user-specified population covariance matrix. Marginal information may be fully
        specified, for which the package implements the VITA (VIne-To-Anything) algorithm
        Grønneberg and Foldnes (2017) &lt;<a href="https://doi.org/10.1007%2Fs11336-017-9569-6">doi:10.1007/s11336-017-9569-6</a>&gt;.  See also Grønneberg, Foldnes and Marcoulides (2022) &lt;<a href="https://doi.org/10.18637%2Fjss.v102.i03">doi:10.18637/jss.v102.i03</a>&gt;.
        Alternatively, marginal skewness and kurtosis may be specified, for which the package
        implements the IG (independent generator) and PLSIM (piecewise linear) algorithms, see Foldnes and Olsson (2016) &lt;<a href="https://doi.org/10.1080%2F00273171.2015.1133274">doi:10.1080/00273171.2015.1133274</a>&gt; and
        Foldnes and Grønneberg (2021) &lt;<a href="https://doi.org/10.1080%2F10705511.2021.1949323">doi:10.1080/10705511.2021.1949323</a>&gt;, respectively.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rvinecopulib (&ge; 0.5.1.1.0), lavaan (&ge; 0.6-5), nleqslv,
PearsonDS, MASS, stats, tmvtnorm, Matrix</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, R.rsp, GGally, psych, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-31 07:02:14 UTC; njaalfoldnes</td>
</tr>
<tr>
<td>Author:</td>
<td>Njaal Foldnes [aut, cre],
  Steffen Grønneberg [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Njaal Foldnes &lt;njal.foldnes@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-31 07:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rIG'>Simulation of non-normal data</h2><span id='topic+rIG'></span>

<h3>Description</h3>

<p>Using the IG method to simulate non-normal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rIG(N, sigma.target, skewness, excesskurtosis, reps = 1, typeA = "triang")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rIG_+3A_n">N</code></td>
<td>
<p>Number of observations to simulate.</p>
</td></tr>
<tr><td><code id="rIG_+3A_sigma.target">sigma.target</code></td>
<td>
<p>Target population covariance matrix</p>
</td></tr>
<tr><td><code id="rIG_+3A_skewness">skewness</code></td>
<td>
<p>Target skewness</p>
</td></tr>
<tr><td><code id="rIG_+3A_excesskurtosis">excesskurtosis</code></td>
<td>
<p>Target excess kurtosis</p>
</td></tr>
<tr><td><code id="rIG_+3A_reps">reps</code></td>
<td>
<p>Number of simulated samples</p>
</td></tr>
<tr><td><code id="rIG_+3A_typea">typeA</code></td>
<td>
<p>Symmetrical or triangular (default) A matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of simulated samples
</p>


<h3>Author(s)</h3>

<p>Njål Foldnes  (<a href="mailto:njal.foldnes@gmail.com">njal.foldnes@gmail.com</a>)
</p>


<h3>References</h3>

<p>Foldnes, N. and Olson, U. H. (2016). A simple simulation technique for nonnormal data with prespecified skewness,
kurtosis, and covariance matrix. Multivariate behavioral research, 51(2-3), 207-219
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
model &lt;- '
 # measurement model
   ind60 =~ x1 + x2 + x3
   dem60 =~ y1 + y2 + y3 + y4
   dem65 =~ y5 + y6 + y7 + y8
 # regressions
   dem60 ~ ind60
   dem65 ~ ind60 + dem60
 # residual correlations
   y1 ~~ y5
   y2 ~~ y4 + y6
   y3 ~~ y7
   y4 ~~ y8
   y6 ~~ y8'
fit  &lt;- lavaan::sem(model, data=lavaan::PoliticalDemocracy)
population.sigma &lt;- lavaan::lavInspect(fit, "sigma.hat")
population.skew  &lt;- c(0, 0, 0, 0, 1, 1, 1, 1, 2,2,2 )
population.excesskurt &lt;- c( 1 , 1, 1, 1, 3, 3, 3, 3, 15, 15, 15)
my.samples &lt;- rIG(N=10^3, sigma=population.sigma,
        skewness=population.skew,
        excesskurt=population.excesskurt,
        reps=5)
</code></pre>

<hr>
<h2 id='rPLSIM'>Simulation of non-normal data</h2><span id='topic+rPLSIM'></span>

<h3>Description</h3>

<p>Using the piecewise linear PLSIM method to simulate non-normal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rPLSIM(
  N,
  sigma.target,
  skewness,
  excesskurtosis,
  reps = 1,
  numsegments = 4,
  gammalist = NULL,
  monot = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rPLSIM_+3A_n">N</code></td>
<td>
<p>Number of observations to simulate.</p>
</td></tr>
<tr><td><code id="rPLSIM_+3A_sigma.target">sigma.target</code></td>
<td>
<p>Target population covariance matrix</p>
</td></tr>
<tr><td><code id="rPLSIM_+3A_skewness">skewness</code></td>
<td>
<p>Target skewness</p>
</td></tr>
<tr><td><code id="rPLSIM_+3A_excesskurtosis">excesskurtosis</code></td>
<td>
<p>Target excess kurtosis</p>
</td></tr>
<tr><td><code id="rPLSIM_+3A_reps">reps</code></td>
<td>
<p>Number of simulated samples</p>
</td></tr>
<tr><td><code id="rPLSIM_+3A_numsegments">numsegments</code></td>
<td>
<p>The number of line segments in each marginal</p>
</td></tr>
<tr><td><code id="rPLSIM_+3A_gammalist">gammalist</code></td>
<td>
<p>A list of breakpoints in each margin</p>
</td></tr>
<tr><td><code id="rPLSIM_+3A_monot">monot</code></td>
<td>
<p>True if piecewise linear functions are forced to be monotonous. The copula will then be normal.</p>
</td></tr>
<tr><td><code id="rPLSIM_+3A_verbose">verbose</code></td>
<td>
<p>If true, progress details of the procedure are printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements. First element: the list of simulated samples. Second element: The fitted piecewise linear functions and the intermediate correlations matrix.
</p>


<h3>Author(s)</h3>

<p>Njål Foldnes  (<a href="mailto:njal.foldnes@gmail.com">njal.foldnes@gmail.com</a>)
</p>


<h3>References</h3>

<p>Foldnes, N. and Grønneberg S. (2021). Non-normal data simulation using piecewise linear transforms.Under review.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
sigma.target  &lt;- cov(MASS::mvrnorm(5, rep(0,3), diag(3)))
res  &lt;- covsim::rPLSIM(10^5, sigma.target, skewness=rep(1,3), excesskurtosis=rep(4,3))
my.sample  &lt;- res[[1]][[1]]
</code></pre>

<hr>
<h2 id='vita'>Calibrate a regular vine</h2><span id='topic+vita'></span>

<h3>Description</h3>

<p><code>vita</code> implements the VITA (VIne-To-Anything) algorithm.
Covariance matrix and margins are specified, and <code>vita</code> calibrates the
pair-copulas in each node of the tree to match the target covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vita(
  margins,
  sigma.target,
  vc = NULL,
  family_set = c("clayton", "gauss", "joe", "gumbel", "frank"),
  Nmax = 10^6,
  numrootpoints = 10,
  conflevel = 0.995,
  numpoints = 4,
  verbose = TRUE,
  cores = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vita_+3A_margins">margins</code></td>
<td>
<p>A list where each element corresponds to a margin. Each
margin element is a list containing the distribution family (&quot;distr&quot;) and
additional parameters. Must be a distribution available in the stats package.</p>
</td></tr>
<tr><td><code id="vita_+3A_sigma.target">sigma.target</code></td>
<td>
<p>The target covariance matrix that is to be matched. The diagonal
elements must contain the variances of marginal distributions.</p>
</td></tr>
<tr><td><code id="vita_+3A_vc">vc</code></td>
<td>
<p>A vine dist object as specified by the rvinecopulib package. This object
specifies the  vine that is to be calibrated. If not provided, a D-vine is assumed.</p>
</td></tr>
<tr><td><code id="vita_+3A_family_set">family_set</code></td>
<td>
<p>A vector of one-parameter pair-copula families that is to
be calibrated at each node in the vine. Possible entries are &quot;gauss&quot;, &quot;clayton&quot;, &quot;joe&quot;, &quot;gumbel&quot; and &quot;frank&quot;.
Calibration of pair-copula families is attempted in the order provided.</p>
</td></tr>
<tr><td><code id="vita_+3A_nmax">Nmax</code></td>
<td>
<p>The sample size used for calibration. Reduce for faster calibration,
at the cost of precision.</p>
</td></tr>
<tr><td><code id="vita_+3A_numrootpoints">numrootpoints</code></td>
<td>
<p>The number of estimated roots at the initial calibration stage, which
determines a search interval where Nmax samples are drawn</p>
</td></tr>
<tr><td><code id="vita_+3A_conflevel">conflevel</code></td>
<td>
<p>Confidence level for determining search interval</p>
</td></tr>
<tr><td><code id="vita_+3A_numpoints">numpoints</code></td>
<td>
<p>The number of samples drawn with size Nmax, to determine the root within search interval
To increase precision increase this number. To calibrate faster (but less precisely), may be reduced to a number no lower than 2</p>
</td></tr>
<tr><td><code id="vita_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, outputs details of calibration of each bicopula</p>
</td></tr>
<tr><td><code id="vita_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use. If larger than 1, computations are done in parallel. May be determined with parallel:detectCores()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a feasible solution was found, a vine to be used for simulation
</p>


<h3>References</h3>

<p>Grønneberg, S., Foldnes, N., &amp; Marcoulides, K. M. (2021). covsim: An r package for simulating non-normal data for structural equation models using copulas. Journal of Statistical Software. doi:10.18637/jss.v102.i03
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)# define a target covariance. 3 dimensions.
sigma.target &lt;- cov(MASS::mvrnorm(10, mu=rep(0,3), Sigma=diag(1, 3)))

#normal margins that match the covariances:
marginsnorm &lt;- lapply(X=sqrt(diag(sigma.target)),function(X) list(distr="norm", sd=X) )

#calibrate with a default D-vine, with rather low precision (default Nmax is 10^6)
# if cores=1 is removed, all cores are used, with a speed gain
calibrated.vine &lt;- vita(marginsnorm, sigma.target =sigma.target, Nmax=10^5, cores=1)
#check
#round(cov(rvinecopulib::rvine(10^5, calibrated.vine))-sigma.target, 3)

#margins are normal but dependence structure is not
#pairs(rvinecopulib::rvine(500, calibrated.vine))



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
