<!DOCTYPE html><html lang="en"><head><title>Help for package galah</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {galah}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#galah'><p>Biodiversity Data from the GBIF Node Network</p></a></li>
<li><a href='#apply_profile'><p>Apply a data quality profile</p></a></li>
<li><a href='#arrange.data_request'><p>Order rows using column values</p></a></li>
<li><a href='#atlas_'><p>Retrieve a database query</p></a></li>
<li><a href='#atlas_citation'><p>Generate a citation for occurrence data</p></a></li>
<li><a href='#collapse.data_request'><p>Generate a query</p></a></li>
<li><a href='#collect_media'><p>Collect media files</p></a></li>
<li><a href='#collect.data_request'><p>Retrieve a database query</p></a></li>
<li><a href='#compute.data_request'><p>Compute a query</p></a></li>
<li><a href='#count.data_request'><p>Count the observations in each group</p></a></li>
<li><a href='#filter.data_request'><p>Keep rows that match a condition</p></a></li>
<li><a href='#galah_call'><p>Start building a query</p></a></li>
<li><a href='#galah_config'><p>Get or set configuration options that control galah behaviour</p></a></li>
<li><a href='#geolocate'><p>Narrow a query to within a specified area</p></a></li>
<li><a href='#group_by.data_request'><p>Group by one or more variables</p></a></li>
<li><a href='#identify.data_request'><p>Narrow a query by passing taxonomic identifiers</p></a></li>
<li><a href='#print_galah_objects'><p>Print galah objects</p></a></li>
<li><a href='#read_zip'><p>Read downloaded data from a zip file</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#search_all'><p>Search for record information</p></a></li>
<li><a href='#select.data_request'><p>Keep or drop columns using their names</p></a></li>
<li><a href='#show_all'><p>Show valid record information</p></a></li>
<li><a href='#show_values'><p>Show or search for values within a specified field</p></a></li>
<li><a href='#slice_head.data_request'><p>Subset rows using their positions</p></a></li>
<li><a href='#taxonomic_searches'><p>Look up taxon information</p></a></li>
<li><a href='#tidyverse_functions'><p>Non-generic tidyverse functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Biodiversity Data from the GBIF Node Network</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>The Global Biodiversity Information Facility 
    ('GBIF', <a href="https://www.gbif.org">https://www.gbif.org</a>) sources data from an international network
    of data providers, known as 'nodes'. Several of these nodes - the "living 
    atlases" (<a href="https://living-atlases.gbif.org">https://living-atlases.gbif.org</a>) - maintain their own web 
    services using software originally developed by the Atlas of Living 
    Australia ('ALA', <a href="https://www.ala.org.au">https://www.ala.org.au</a>). 'galah' enables the R community 
    to directly access data and resources hosted by 'GBIF' and its partner nodes.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, crayon, dplyr, glue (&ge; 1.3.2), httr2, jsonlite (&ge;
0.9.8), lifecycle (&ge; 1.0.0), potions (&ge; 0.2.0), purrr, readr,
rlang, sf, stringr, tibble, tidyr, tidyselect, utils, xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, gt, kableExtra, knitr, magrittr, pkgdown, reactable,
rmarkdown, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL-2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://galah.ala.org.au/R/">https://galah.ala.org.au/R/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AtlasOfLivingAustralia/galah-R/issues">https://github.com/AtlasOfLivingAustralia/galah-R/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Westgate &lt;martin.westgate@csiro.au&gt;</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-07 03:25:18 UTC; wes186</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Westgate [aut, cre],
  Dax Kellie [aut],
  Matilda Stevenson [aut],
  Peggy Newman [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-07 04:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='galah'>Biodiversity Data from the GBIF Node Network</h2><span id='topic+galah-package'></span><span id='topic+galah'></span>

<h3>Description</h3>

<p>The Global Biodiversity Information Facility (GBIF; <a href="https://www.gbif.org">https://www.gbif.org</a>)
provides tools to enable users to find, access, combine and visualise
biodiversity data. <code>galah</code> enables the R community to directly access data and
resources hosted by GBIF and several of it's subsidiary organisations, known
as 'nodes'.
</p>
<p>The basic unit of data stored by these infrastructures is
an <strong>occurrence</strong> record, which is an observation of a biological entity at
a specific time and place. However, <code>galah</code> also facilitates access to
taxonomic information, or associated media such images or sounds,
all while restricting their queries to particular taxa or locations. Users
can specify which columns are returned by a query, or restrict their results
to observations that meet particular quality-control criteria.
</p>
<p>For those outside Australia, 'galah' is the common name of
<em>Eolophus roseicapilla</em>, a widely-distributed Australian bird species.
</p>


<h3>Functions</h3>

<p><strong>Getting Started</strong>
</p>

<ul>
<li> <p><code><a href="#topic+galah_call">galah_call()</a></code>/<code><a href="#topic+request_data">request_()</a></code> Start to build a query
</p>
</li>
<li> <p><code><a href="#topic+galah_config">galah_config()</a></code> Set package configuration options
</p>
</li>
<li> <p><code><a href="#topic+show_all">show_all()</a></code> &amp; <code><a href="#topic+search_all">search_all()</a></code> Data for generating filter queries
</p>
</li>
<li> <p><code><a href="#topic+show_values">show_values()</a></code> &amp; <code><a href="#topic+search_values">search_values()</a></code> Show or search for values <em>within</em>
<code>fields</code>, <code>profiles</code>, <code>lists</code>, <code>collections</code>, <code>datasets</code> or <code>providers</code>
</p>
</li></ul>

<p><strong>Amend a query</strong>
</p>

<ul>
<li> <p><code><a href="#topic+apply_profile">apply_profile()</a></code>/<code><a href="#topic+galah_apply_profile">galah_apply_profile()</a></code> Restrict to data that pass predefined checks (ALA only)
</p>
</li>
<li> <p><code><a href="#topic+arrange.data_request">arrange()</a></code> Arrange rows of a query on the server side
</p>
</li>
<li> <p><code><a href="#topic+count.data_request">count()</a></code> Request counts of the specified data type
</p>
</li>
<li> <p><code><a href="#topic+desc">desc()</a></code> Arrange counts in descending order (when combined with <code><a href="#topic+arrange.data_request">arrange()</a></code>)
</p>
</li>
<li> <p><code><a href="#topic+filter.data_request">filter()</a></code>/<code><a href="#topic+galah_filter">galah_filter()</a></code> Filter records
</p>
</li>
<li> <p><code><a href="#topic+geolocate">geolocate()</a></code>/<code><a href="#topic+galah_geolocate">galah_geolocate()</a></code> Spatial filtering of a query
</p>
</li>
<li> <p><code><a href="#topic+group_by.data_request">group_by()</a></code>/<code><a href="#topic+galah_group_by">galah_group_by()</a></code> Group counts by one or more fields
</p>
</li>
<li> <p><code><a href="#topic+identify.data_request">identify()</a></code>/<code><a href="#topic+galah_identify">galah_identify()</a></code> Search for taxonomic identifiers (see also <code><a href="#topic+taxonomic_searches">taxonomic_searches</a></code>)
</p>
</li>
<li> <p><code><a href="#topic+select.data_request">select()</a></code>/<code><a href="#topic+galah_select">galah_select()</a></code> Fields to report information for
</p>
</li>
<li> <p><code><a href="#topic+slice_head.data_request">slice_head()</a></code> Choose the first n rows of a download
</p>
</li>
<li> <p><code><a href="#topic+unnest">unnest()</a></code> Expand metadata for <code>fields</code>, <code>lists</code>, <code>profiles</code> or <code>taxa</code>
</p>
</li></ul>

<p><strong>Execute a query via API</strong>
</p>

<ul>
<li> <p><code><a href="#topic+collapse.data_request">collapse()</a></code> Convert a <code>data_request</code> into a <code>query</code>
</p>
</li>
<li> <p><code><a href="#topic+compute.data_request">compute()</a></code> Compute a query
</p>
</li>
<li> <p><code><a href="#topic+collect.data_request">collect()</a></code>/<code><a href="#topic+atlas_">atlas_()</a></code>/<code><a href="#topic+collect_media">collect_media()</a></code> Retrieve a database query
</p>
</li></ul>

<p><strong>Miscellaneous functions</strong>
</p>

<ul>
<li> <p><code><a href="#topic+atlas_citation">atlas_citation()</a></code> Get a citation for a dataset
</p>
</li>
<li> <p><code><a href="#topic+read_zip">read_zip()</a></code> To read data from an earlier download
</p>
</li>
<li> <p><code><a href="#topic+print.data_request">print()</a></code> Print functions for galah objects
</p>
</li></ul>



<h3>Terminology</h3>

<p>To get the most value from <code>galah</code>, it is helpful to understand some
terminology. Each occurrence record contains taxonomic
information, and usually some information about the observation itself, such
as its location. In addition to this record-specific information, the living
atlases append contextual information to each record, particularly data from
spatial <strong>layers</strong> reflecting climate gradients or political boundaries. They
also run a number of quality checks against each record, resulting in
<strong>assertions</strong> attached to the record. Each piece of information
associated with a given occurrence record is stored in a <strong>field</strong>,
which corresponds to a <strong>column</strong> when imported to an
<code style="white-space: pre;">&#8288;R data.frame&#8288;</code>. See <code>show_all(fields)</code> to view valid fields,
layers and assertions, or conduct a search using <code>search_all(fields)</code>.
</p>
<p>Data fields are important because they provide a means to <strong>filter</strong>
occurrence records;  i.e. to return only the information that you need, and
no more. Consequently, much of the architecture of <code>galah</code> has been
designed to make filtering as simple as possible. The easiest way to do this
is to start a pipe with <code>galah_call()</code> and follow it with the relevant
<code>dplyr</code> function; starting with <code>filter()</code>, but also including <code>select()</code>,
<code>group_by()</code> or others. Functions without a relevant <code>dplyr</code> synonym include
<code><a href="#topic+galah_identify">galah_identify()</a></code>/<code>identify()</code> for choosing a taxon, or <code><a href="#topic+galah_geolocate">galah_geolocate()</a></code>/
<code>st_crop()</code> for choosing a specific location. By combining different filters,
it is possible to build complex queries to return only the most valuable
information for a given problem.
</p>
<p>A notable extension of the filtering approach is to remove records with low
'quality'. All living atlases perform quality control checks on all records
that they store. These checks are used to generate new fields, that can then
be used to filter out records that are unsuitable for particular applications.
However, there are many possible data quality checks, and it is not always
clear which are most appropriate in a given instance. Therefore, <code>galah</code>
supports data quality <strong>profiles</strong>, which can be passed to
<code><a href="#topic+galah_apply_profile">galah_apply_profile()</a></code> to quickly remove undesirable records. A full list of
data quality profiles is returned by <code>show_all(profiles)</code>. Note this service
is currently only available for the Australian atlas (ALA).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin Westgate <a href="mailto:martin.westgate@csiro.au">martin.westgate@csiro.au</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Dax Kellie <a href="mailto:dax.kellie@csiro.au">dax.kellie@csiro.au</a>
</p>
</li>
<li><p> Matilda Stevenson
</p>
</li>
<li><p> Peggy Newman <a href="mailto:peggy.newman@csiro.au">peggy.newman@csiro.au</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://galah.ala.org.au/R/">https://galah.ala.org.au/R/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/AtlasOfLivingAustralia/galah-R/issues">https://github.com/AtlasOfLivingAustralia/galah-R/issues</a>
</p>
</li></ul>


<hr>
<h2 id='apply_profile'>Apply a data quality profile</h2><span id='topic+apply_profile'></span><span id='topic+galah_apply_profile'></span>

<h3>Description</h3>

<p>A 'profile' is a group of filters that are pre-applied by the ALA. Using a
data profile allows a query to be filtered quickly to the most relevant or
quality-assured data that is fit-for-purpose. For example, the &quot;ALA&quot; profile
is designed to exclude lower quality records, whereas other profiles apply
filters specific to species distribution modelling (e.g. CDSM).
</p>
<p>Note that only one profile can be loaded at a time; if multiple profiles are
given, the first valid profile is used.
</p>
<p>For more bespoke editing of filters within a profile, use
<code><a href="#topic+filter.data_request">filter.data_request()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_profile(.data, ...)

galah_apply_profile(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_profile_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>data_request</code></p>
</td></tr>
<tr><td><code id="apply_profile_+3A_...">...</code></td>
<td>
<p>a profile name. Should be a <code>string</code> - the name or abbreviation
of a data quality profile to apply to the query. Valid values can be seen
using <code>show_all(profiles)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code>data_request</code> with a completed <code>data_profile</code> slot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+show_all">show_all()</a></code> and <code><a href="#topic+search_all">search_all()</a></code> to look up available data profiles.
<code><a href="#topic+filter.data_request">filter.data_request()</a></code> can be used for more bespoke editing of individual data
profile filters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Apply a data quality profile to a query
galah_call() |&gt; 
  identify("reptilia") |&gt;
  filter(year == 2021) |&gt;
  apply_profile(ALA) |&gt;
  atlas_counts()

## End(Not run)
</code></pre>

<hr>
<h2 id='arrange.data_request'>Order rows using column values</h2><span id='topic+arrange.data_request'></span><span id='topic+arrange.metadata_request'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>arrange.data_request()</code> arranges rows of a query on the server side, meaning
that the query is constructed in such a way that information will be arranged
when the query is processed. This only has an effect when used in combination
with <code><a href="#topic+count.data_request">count()</a></code> and
<code><a href="#topic+group_by.data_request">group_by()</a></code>. The benefit of using
<code>arrange()</code> within a <code>galah_call()</code> pipe is that it is sometimes beneficial
to choose a non-default order for data to be delivered in, particularly if
<code><a href="#topic+slice_head.data_request">slice_head()</a></code> is also called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_request'
arrange(.data, ...)

## S3 method for class 'metadata_request'
arrange(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange.data_request_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>data_request</code></p>
</td></tr>
<tr><td><code id="arrange.data_request_+3A_...">...</code></td>
<td>
<p>A variable to arrange the resulting tibble by. Should be one of
the variables also listed in <code><a href="#topic+group_by.data_request">group_by()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An amended <code>data_request</code> with a completed <code>arrange</code> slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Arrange grouped counts by ascending year
galah_call() |&gt;
  identify("Crinia") |&gt;
  filter(year &gt;= 2020) |&gt;
  group_by(year) |&gt;
  arrange(year) |&gt;
  count() |&gt;
  collect()
  
# Arrange grouped counts by ascending record count
galah_call() |&gt;
  identify("Crinia") |&gt;
  filter(year &gt;= 2020) |&gt;
  group_by(year) |&gt;
  arrange(count) |&gt;
  count() |&gt;
  collect()

# Arrange grouped counts by descending year
galah_call() |&gt;
  identify("Crinia") |&gt;
  filter(year &gt;= 2020) |&gt;
  group_by(year) |&gt;
  arrange(desc(year)) |&gt;
  count() |&gt;
  collect()

## End(Not run)
</code></pre>

<hr>
<h2 id='atlas_'>Retrieve a database query</h2><span id='topic+atlas_'></span><span id='topic+atlas_occurrences'></span><span id='topic+atlas_counts'></span><span id='topic+atlas_species'></span><span id='topic+atlas_media'></span><span id='topic+atlas_taxonomy'></span>

<h3>Description</h3>

<p>An alternative to using <code><a href="#topic+collect.data_request">collect()</a></code> at the
end of a query pipe is to call a function with the <code>atlas_</code> prefix. These
solutions are basically synonymous, but <code>atlas_</code> functions differ in two ways:
</p>

<ul>
<li><p> They have the ability to accept <code>filter</code>, <code>select</code> etc as arguments,
rather than within a pipe; but <strong>only</strong> when using the <code>galah_</code> forms of
those functions (e.g. <code><a href="#topic+galah_filter">galah_filter()</a></code>).
</p>
</li>
<li> <p><code>atlas_</code> functions do not require you to specify the <code>method</code> or <code>type</code>
arguments to <code><a href="#topic+galah_call">galah_call()</a></code>, as they are more specific in what data are
being requested.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>atlas_occurrences(
  request = NULL,
  identify = NULL,
  filter = NULL,
  geolocate = NULL,
  data_profile = NULL,
  select = NULL,
  mint_doi = FALSE,
  doi = NULL,
  file = NULL
)

atlas_counts(
  request = NULL,
  identify = NULL,
  filter = NULL,
  geolocate = NULL,
  data_profile = NULL,
  group_by = NULL,
  limit = NULL,
  type = c("occurrences", "species")
)

atlas_species(
  request = NULL,
  identify = NULL,
  filter = NULL,
  geolocate = NULL,
  data_profile = NULL
)

atlas_media(
  request = NULL,
  identify = NULL,
  filter = NULL,
  select = NULL,
  geolocate = NULL,
  data_profile = NULL
)

atlas_taxonomy(
  request = NULL,
  identify = NULL,
  filter = NULL,
  constrain_ids = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="atlas__+3A_request">request</code></td>
<td>
<p>optional <code>data_request</code> object: generated by a call to
<code><a href="#topic+galah_call">galah_call()</a></code>.</p>
</td></tr>
<tr><td><code id="atlas__+3A_identify">identify</code></td>
<td>
<p><code>tibble</code>: generated by a call to <code><a href="#topic+galah_identify">galah_identify()</a></code>.</p>
</td></tr>
<tr><td><code id="atlas__+3A_filter">filter</code></td>
<td>
<p><code>tibble</code>: generated by a call to <code><a href="#topic+galah_filter">galah_filter()</a></code></p>
</td></tr>
<tr><td><code id="atlas__+3A_geolocate">geolocate</code></td>
<td>
<p><code>string</code>: generated by a call to <code><a href="#topic+galah_geolocate">galah_geolocate()</a></code></p>
</td></tr>
<tr><td><code id="atlas__+3A_data_profile">data_profile</code></td>
<td>
<p><code>string</code>: generated by a call to <code><a href="#topic+galah_apply_profile">galah_apply_profile()</a></code></p>
</td></tr>
<tr><td><code id="atlas__+3A_select">select</code></td>
<td>
<p><code>tibble</code>: generated by a call to <code><a href="#topic+galah_select">galah_select()</a></code></p>
</td></tr>
<tr><td><code id="atlas__+3A_mint_doi">mint_doi</code></td>
<td>
<p><code>logical</code>: by default no DOI will be generated. Set to
<code>TRUE</code> if you intend to use the data in a publication or similar.</p>
</td></tr>
<tr><td><code id="atlas__+3A_doi">doi</code></td>
<td>
<p><code>string</code>: (Optional) DOI to download. If provided overrides
all other arguments. Only available for the ALA.</p>
</td></tr>
<tr><td><code id="atlas__+3A_file">file</code></td>
<td>
<p><code>string</code>: (Optional) file name. If not given, will be set to
<code>data</code> with date and time added. The file path (directory) is always given by
<code>galah_config()$package$directory</code>.</p>
</td></tr>
<tr><td><code id="atlas__+3A_group_by">group_by</code></td>
<td>
<p><code>tibble</code>: generated by a call to <code><a href="#topic+galah_group_by">galah_group_by()</a></code>.</p>
</td></tr>
<tr><td><code id="atlas__+3A_limit">limit</code></td>
<td>
<p><code>numeric</code>: maximum number of categories to return, defaulting to 100.
If limit is NULL, all results are returned. For some categories this will
take a while.</p>
</td></tr>
<tr><td><code id="atlas__+3A_type">type</code></td>
<td>
<p><code>string</code>: one of <code>"occurrences"</code> or <code>"species"</code>.
Defaults to <code>"occurrences"</code>, which returns the number of records
that match the selected criteria; alternatively returns the number of
species. Formerly accepted arguments (<code>"records"</code> or <code>"species"</code>) are
deprecated but remain functional.</p>
</td></tr>
<tr><td><code id="atlas__+3A_constrain_ids">constrain_ids</code></td>
<td>
<p><code>string</code>: Optional string to limit which <code>taxon_concept_id</code>'s
are returned. This is useful for restricting taxonomy to particular
authoritative sources. Default is <code>"biodiversity.org.au"</code> for Australia,
which is the infix common to National Species List IDs; use
<code>NULL</code> to suppress source filtering. Regular expressions are supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that unless care is taken, some queries can be particularly large.
While most cases this will simply take a long time to process, if the number
of requested records is &gt;50 million, the call will not return any data. Users
can test whether this threshold will be reached by first calling
<code><a href="#topic+atlas_counts">atlas_counts()</a></code> using the same arguments that they intend to pass to
<code>atlas_occurrences()</code>. It may also be beneficial when requesting a large
number of records to show a progress bar by setting <code>verbose = TRUE</code> in
<code><a href="#topic+galah_config">galah_config()</a></code>, or to use <code>compute()</code> to run the call before collecting
it later with <code>collect()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>tbl_df</code> and <code>data.frame</code> (aka a tibble). For
<code>atlas_occurrences()</code> and <code>atlas_species()</code>, this will have columns specified
by <code><a href="#topic+select.data_request">select()</a></code>. For <code>atlas_counts()</code>,
it will have columns specified by
<code><a href="#topic+group_by.data_request">group_by()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Best practice is to first calculate the number of records
galah_call() |&gt;
  filter(year == 2015) |&gt;
  atlas_counts()

# Download occurrence records for a specific taxon
galah_config(email = "your_email_here") # login required for downloads
galah_call() |&gt;
  identify("Reptilia") |&gt;
  atlas_occurrences()

# Download occurrence records in a year range
galah_call() |&gt;
  identify("Litoria") |&gt;
  filter(year &gt;= 2010 &amp; year &lt;= 2020) |&gt;
  atlas_occurrences()
  
# Download occurrences records in a WKT-specified area
polygon &lt;- "POLYGON((146.24960 -34.05930,
                     146.37045 -34.05930,
                     146.37045 -34.152549,
                     146.24960 -34.15254,
                     146.24960 -34.05930))"
galah_call() |&gt; 
  identify("Reptilia") |&gt;
  filter(year &gt;= 2010, year &lt;= 2020) |&gt;
  st_crop(polygon) |&gt;
  atlas_occurrences()
  
# Get a list of species within genus "Heleioporus"
# (every row is a species with associated taxonomic data)
galah_call() |&gt;
  identify("Heleioporus") |&gt;
  atlas_species()

# Download Regent Honeyeater records with multimedia attached
# Note this returns one row per multimedia file, NOT one per occurrence
galah_call() |&gt;
  identify("Regent Honeyeater") |&gt;
  filter(year == 2011) |&gt;
  atlas_media()

# Get a taxonomic tree of *Chordata* down to the class level
galah_call() |&gt; 
  identify("chordata") |&gt;
  filter(rank == class) |&gt;
  atlas_taxonomy()

## End(Not run)
</code></pre>

<hr>
<h2 id='atlas_citation'>Generate a citation for occurrence data</h2><span id='topic+atlas_citation'></span>

<h3>Description</h3>

<p>If a <code>tibble</code> containing occurrences was generated using galah (either via
<code><a href="#topic+collect.data_request">collect()</a></code> or <code><a href="#topic+atlas_occurrences">atlas_occurrences()</a></code>), it
will usually contain associated metadata stored in <code>attributes()</code> that can be
used to build a citation for that dataset. This function simply extracts that
information, formats it, then both invisibly returns the formatted citation
and prints it to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atlas_citation(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="atlas_citation_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> generated by <code><a href="#topic+atlas_occurrences">atlas_occurrences()</a></code> or similar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a string containing the citation for that dataset.
Primarily called for the side-effect of printing this string to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- galah_call() |&gt;
    identify("Heleioporus") |&gt;
    filter(year == 2022) |&gt;
    collect()
atlas_citation(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='collapse.data_request'>Generate a query</h2><span id='topic+collapse.data_request'></span><span id='topic+collapse.metadata_request'></span><span id='topic+collapse.files_request'></span>

<h3>Description</h3>

<p><code>collapse()</code> constructs a valid query so it can be
inspected before being sent. It typically occurs at the end of a pipe,
traditionally begun with <code>galah_call()</code>, that is used to define a query.
As of version 2.0, objects of class <code>data_request</code> (created using
<code>request_data()</code>), <code>metadata_request</code> (from <code>request_metadata()</code>) or
<code>files_request</code> (from <code>request_files()</code>) are all supported by <code>collapse()</code>.
Any of these objects can be created using <code>galah_call()</code> via the <code>method</code>
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_request'
collapse(x, ..., mint_doi, .expand = FALSE)

## S3 method for class 'metadata_request'
collapse(x, .expand = FALSE, ...)

## S3 method for class 'files_request'
collapse(x, thumbnail = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse.data_request_+3A_x">x</code></td>
<td>
<p>An object of class <code>data_request</code>, <code>metadata_request</code> or
<code>files_request</code></p>
</td></tr>
<tr><td><code id="collapse.data_request_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="collapse.data_request_+3A_mint_doi">mint_doi</code></td>
<td>
<p>Logical: should a DOI be minted for this download? Only
applies to <code>type = "occurrences"</code> when atlas chosen is &quot;ALA&quot;.</p>
</td></tr>
<tr><td><code id="collapse.data_request_+3A_.expand">.expand</code></td>
<td>
<p>Logical: should the <code>query_set</code> be returned? This object
shows all the requisite data needed to process the supplied query. Defaults
to <code>FALSE</code>; if <code>TRUE</code> will append the <code>query_set</code> to an extra slot in the
<code>query</code> object.</p>
</td></tr>
<tr><td><code id="collapse.data_request_+3A_thumbnail">thumbnail</code></td>
<td>
<p>Logical: should thumbnail-size images be returned? Defaults
to <code>FALSE</code>, indicating full-size images are required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>query</code>, which is a list-like object containing at
least the slots <code>type</code> and <code>url</code>.
</p>

<hr>
<h2 id='collect_media'>Collect media files</h2><span id='topic+collect_media'></span>

<h3>Description</h3>

<p>This function downloads full-sized or thumbnail images and media files using
information from <code>atlas_media</code> to a local directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_media(df, thumbnail = FALSE, path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collect_media_+3A_df">df</code></td>
<td>
<p><code>tibble</code>: returned by <code>atlas_media()</code> or a pipe starting with
<code>request_data(type = "media")</code>.</p>
</td></tr>
<tr><td><code id="collect_media_+3A_thumbnail">thumbnail</code></td>
<td>
<p><code>logical</code>: If <code>TRUE</code> will download small thumbnail-sized
images, rather than full size images (default).</p>
</td></tr>
<tr><td><code id="collect_media_+3A_path">path</code></td>
<td>
<p><code>string</code>:
<a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Use <code style="white-space: pre;">&#8288;galah_config(directory = "path-to-directory)"&#8288;</code> instead. Supply a path
to a local folder/directory where downloaded media will be saved to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a <code>tibble</code> listing the number of files downloaded,
grouped by their HTML status codes. Primarily called for the side effect of
downloading available image &amp; media files to a user local directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Use `atlas_media()` to return a `tibble` of records that contain media
x &lt;- galah_call() |&gt; 
  identify("perameles") |&gt;
  filter(year == 2015) |&gt;
  atlas_media()

# To download media files, add `collect_media()` to the end of a query 
galah_config(directory = "media_files")
collect_media(x)

#' # post version 2.0, it is possible to run all steps in sequence
# first, get occurrences, making sure to include media fields:
occurrences_df &lt;- request_data() |&gt;
  identify("Regent Honeyeater") |&gt;
  filter(!is.na(images), year == 2011) |&gt;
  select(group = "media") |&gt;
  collect()
 
# second, get media metadata
media_info &lt;- request_metadata() |&gt;
  filter(media == occurrences_df) |&gt;
  collect()
  
# the two steps above + `right_join()` are synonmous with `atlas_media()`
# third, get images
request_files() |&gt;
  filter(media == media_df) |&gt;
  collect(thumbnail = TRUE)
# step three is synonymous with `collect_media()`

## End(Not run)
</code></pre>

<hr>
<h2 id='collect.data_request'>Retrieve a database query</h2><span id='topic+collect.data_request'></span><span id='topic+collect.metadata_request'></span><span id='topic+collect.files_request'></span><span id='topic+collect.query'></span><span id='topic+collect.computed_query'></span>

<h3>Description</h3>

<p><code>collect()</code> attempts to retrieve the result of a query from the
selected API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_request'
collect(x, ..., wait = TRUE, file = NULL)

## S3 method for class 'metadata_request'
collect(x, ...)

## S3 method for class 'files_request'
collect(x, ...)

## S3 method for class 'query'
collect(x, ..., wait = TRUE, file = NULL)

## S3 method for class 'computed_query'
collect(x, ..., wait = TRUE, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collect.data_request_+3A_x">x</code></td>
<td>
<p>An object of class <code>data_request</code>, <code>metadata_request</code> or
<code>files_request</code> (from <code>galah_call()</code>); or an object of class <code>query_set</code> or
<code>query</code> (from <code>collapse()</code> or <code>compute()</code>)</p>
</td></tr>
<tr><td><code id="collect.data_request_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="collect.data_request_+3A_wait">wait</code></td>
<td>
<p>logical; should <code>galah</code> wait for a response? Defaults to FALSE.
Only applies for <code>type = "occurrences"</code> or <code>"species"</code>.</p>
</td></tr>
<tr><td><code id="collect.data_request_+3A_file">file</code></td>
<td>
<p>(Optional) file name. If not given, will be set to <code>data</code> with
date and time added. The file path (directory) is always given by
<code>galah_config()$package$directory</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In most cases, <code>collect()</code> returns a <code>tibble</code> containing requested
data. Where the requested data are not yet ready (i.e. for occurrences when
<code>wait</code> is set to <code>FALSE</code>), this function returns an object of class <code>query</code>
that can be used to recheck the download at a later time.
</p>

<hr>
<h2 id='compute.data_request'>Compute a query</h2><span id='topic+compute.data_request'></span><span id='topic+compute.metadata_request'></span><span id='topic+compute.files_request'></span><span id='topic+compute.query'></span>

<h3>Description</h3>

<p><code>compute()</code> is useful for several purposes. It's original
purpose is to send a request for data, which can then be processed by the
server and retrieved at a later time (via <code>collect()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_request'
compute(x, ...)

## S3 method for class 'metadata_request'
compute(x, ...)

## S3 method for class 'files_request'
compute(x, ...)

## S3 method for class 'query'
compute(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute.data_request_+3A_x">x</code></td>
<td>
<p>An object of class <code>data_request</code>, <code>metadata_request</code> or
<code>files_request</code> (i.e. constructed using a pipe) or <code>query</code>
(i.e. constructed by <code>collapse()</code>)</p>
</td></tr>
<tr><td><code id="compute.data_request_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>computed_query</code>, which is identical to class
<code>query</code> except for occurrence data, where it also contains information on the
status of the request.
</p>

<hr>
<h2 id='count.data_request'>Count the observations in each group</h2><span id='topic+count.data_request'></span>

<h3>Description</h3>

<p><code>count()</code> lets you quickly count the unique values of one or more variables.
It is evaluated lazily.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_request'
count(x, ..., wt, sort, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count.data_request_+3A_x">x</code></td>
<td>
<p>An object of class <code>data_request</code>, created using <code><a href="#topic+galah_call">galah_call()</a></code></p>
</td></tr>
<tr><td><code id="count.data_request_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="count.data_request_+3A_wt">wt</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="count.data_request_+3A_sort">sort</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="count.data_request_+3A_name">name</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>

<hr>
<h2 id='filter.data_request'>Keep rows that match a condition</h2><span id='topic+filter.data_request'></span><span id='topic+filter.metadata_request'></span><span id='topic+filter.files_request'></span><span id='topic+galah_filter'></span>

<h3>Description</h3>

<p>The <code>filter()</code> function is used to subset a data, retaining all rows that
satisfy your conditions. To be retained, the row must produce a value of
<code>TRUE</code> for all conditions. Unlike 'local' filters that act on a <code>tibble</code>,
the galah implementations work by amending a query which is then enacted
by <code>collect()</code> or one of the <code>atlas_</code> family of functions (such as
<code>atlas_counts()</code> or <code>atlas_occurrences()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_request'
filter(.data, ...)

## S3 method for class 'metadata_request'
filter(.data, ...)

## S3 method for class 'files_request'
filter(.data, ...)

galah_filter(..., profile = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter.data_request_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>data_request</code>, <code>metadata_request</code>
or <code>files_request</code>, created using <code><a href="#topic+galah_call">galah_call()</a></code> or related functions.</p>
</td></tr>
<tr><td><code id="filter.data_request_+3A_...">...</code></td>
<td>
<p>Expressions that return a logical value, and are defined in terms
of the variables in the selected atlas (and checked using <code>show_all(fields)</code>.
If multiple expressions are included, they are combined with the &amp; operator.
Only rows for which all conditions evaluate to <code>TRUE</code> are kept.</p>
</td></tr>
<tr><td><code id="filter.data_request_+3A_profile">profile</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Use <code>galah_apply_profile</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Syntax</em>
</p>
<p><code>filter.data_request()</code> and <code>galah_filter()</code> uses non-standard evaluation
(NSE), and are designed to be as compatible as possible with
<code>dplyr::filter()</code> syntax. Permissible examples include:
</p>

<ul>
<li> <p><code>==</code> (e.g. <code>year = 2020</code>) but not <code>=</code> (for consistency with <code>dplyr</code>)
</p>
</li>
<li> <p><code>!=</code>, e.g. <code>year != 2020</code>)
</p>
</li>
<li> <p><code>&gt;</code> or <code>&gt;=</code> (e.g. <code>year &gt;= 2020</code>)
</p>
</li>
<li> <p><code>&lt;</code> or <code>&lt;=</code> (e.g. <code>year &lt;= 2020</code>)
</p>
</li>
<li> <p><code>OR</code> statements (e.g. <code>year == 2018 | year == 2020</code>)
</p>
</li>
<li> <p><code>AND</code> statements (e.g. <code>year &gt;= 2000 &amp; year &lt;= 2020</code>)
</p>
</li></ul>

<p>Some general tips:
</p>

<ul>
<li><p> Separating statements with a comma is equivalent to an <code>AND</code> statement;
Ergo <code>filter(year &gt;= 2010 &amp; year &lt; 2020)</code> is the same as
<code style="white-space: pre;">&#8288;_filter(year &gt;= 2010, year &lt; 2020)&#8288;</code>.
</p>
</li>
<li><p> All statements must include the field name; so
<code>filter(year == 2010 | year == 2021)</code> works, as does
<code>filter(year == c(2010, 2021))</code>, but <code>filter(year == 2010 | 2021)</code>
fails.
</p>
</li>
<li><p> It is possible to use an object to specify required values, e.g.
<code style="white-space: pre;">&#8288;year_value &lt;- 2010; filter(year &gt; year_value)&#8288;</code>.
</p>
</li>
<li> <p><code>solr</code> supports range queries on text as well as numbers; so
<code>filter(cl22 &gt;= "Tasmania")</code> is valid.
</p>
</li>
<li><p> It is possible to filter by 'assertions', which are statements about data
validity, such as <code style="white-space: pre;">&#8288;filter(assertions != c("INVALID_SCIENTIFIC_NAME", "COORDINATE_INVALID")&#8288;</code>.
Valid assertions can be found using <code>show_all(assertions)</code>.
</p>
</li></ul>

<p><em>Exceptions</em>
</p>
<p>When querying occurrences, species, or their respective counts (i.e. all of
the above examples), field names are checked internally against
<code>show_all(fields)</code>. There are some cases where bespoke field names are
required, as follows.
</p>
<p>When requesting a data download from a DOI, the field <code>doi</code> is valid, i.e.:
</p>
<pre>galah_call() |&gt; 
  filter(doi = "a-long-doi-string") |&gt; 
  collect()</pre>
<p>For taxonomic metadata, the <code>taxa</code> field is valid:
</p>
<pre>request_metadata() |&gt; 
  filter(taxa == "Chordata") |&gt; 
  unnest()</pre>
<p>For building taxonomic trees, the <code>rank</code> field is valid:
</p>
<pre>request_data() |&gt;
  identify("Chordata") |&gt;
  filter(rank == "class") |&gt;
  atlas_taxonomy()</pre>
<p>Media queries are more involved, but break two rules: they accept the <code>media</code>
field, and they accept a tibble on the rhs of the equation. For example,
users wishing to break down media queries into their respective API calls
should begin with an occurrence query:
</p>
<pre>occurrences &lt;- galah_call() |&gt; 
   identify("Litoria peronii) |&gt; 
   select(group = c("basic", "media") |&gt; 
   collect()</pre>
<p>They can then use the <code>media</code> field to request media metadata:
</p>
<pre>media_metadata &lt;- galah_call("metadata") |&gt;
  filter(media == occurrences) |&gt;
  collect()</pre>
<p>And finally, the metadata tibble can be used to request files:
</p>
<pre>galah_call("files") |&gt;
  filter(media == media_metadata) |&gt;
  collect()</pre>


<h3>Value</h3>

<p>A tibble containing filter values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select.data_request">select()</a></code>,
<code><a href="#topic+group_by.data_request">group_by()</a></code> and <code><a href="#topic+geolocate">geolocate()</a></code> for
other ways to amend the information returned by <code><a href="#topic+atlas_">atlas_()</a></code> functions. Use
<code>search_all(fields)</code> to find fields that you can filter by, and
<code><a href="#topic+show_values">show_values()</a></code> to find what values of those filters are available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
galah_call() |&gt;
  filter(year &gt;= 2019,
         basisOfRecord == "HumanObservation") |&gt;
  count() |&gt;
  collect()

## End(Not run)
</code></pre>

<hr>
<h2 id='galah_call'>Start building a query</h2><span id='topic+galah_call'></span><span id='topic+request_data'></span><span id='topic+request_metadata'></span><span id='topic+request_files'></span>

<h3>Description</h3>

<p>To download data from the selected atlas, one must construct a query. This
query tells the atlas API what data to download and return, as well as how it
should be filtered. Using <code>galah_call()</code> allows you to build a piped query to
download data, in the same way that you would wrangle data with <code>dplyr</code> and
the <code>tidyverse</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>galah_call(method = c("data", "metadata", "files"), type, ...)

request_data(
  type = c("occurrences", "occurrences-count", "occurrences-doi", "species",
    "species-count"),
  ...
)

request_metadata(
  type = c("fields", "apis", "assertions", "atlases", "collections", "datasets",
    "licences", "lists", "media", "profiles", "providers", "ranks", "reasons", "taxa",
    "identifiers")
)

request_files(type = "media")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="galah_call_+3A_method">method</code></td>
<td>
<p>string: what <code>request</code> function should be called. Should be one
of <code>"data"</code> (default), <code>"metadata"</code> or <code>"files"</code></p>
</td></tr>
<tr><td><code id="galah_call_+3A_type">type</code></td>
<td>
<p>string: what form of data should be returned? Acceptable values
are specified by the corresponding <code>request</code> function</p>
</td></tr>
<tr><td><code id="galah_call_+3A_...">...</code></td>
<td>
<p>Zero or more arguments passed to
<code><a href="#topic+collapse.data_request">collapse()</a></code> to alter a query. Currently
only <code>mint.doi</code> (for occurrences) and <code>thumbnail</code> (for media downloads) are
supported. Both are logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In practice, <code>galah_call()</code> is a wrapper to a group of underlying
<code>request_</code> functions, selected using the <code>method</code> argument.
Each of these functions can begin a piped query and end with <code>collapse()</code>,
<code>compute()</code> or <code>collect()</code>, or optionally one of the <code>atlas_</code> family of
functions. For more details see the object-oriented programming vignette:
<code>vignette("object_oriented_programming", package = "galah")</code>
</p>
<p>Accepted values of the <code>type</code> argument are set by the underlying <code>request_</code>
functions. While all accepted types can be set directly, some are affected
by later functions. The most common example is that adding
<code><a href="#topic+count.data_request">count()</a></code> to a pipe updates <code>type</code>,
converting <code>type = "occurrences"</code> to <code>type = "occurrences-count"</code> (and ditto
for <code>type = "species"</code>).
</p>
<p>The underlying <code>request_</code> functions are useful because they allow <code>galah</code>
to separate different types of requests to perform better. For example,
<code>filter.data_request</code> translates filters in R to <code>solr</code>, whereas
<code>filter.metadata_request</code> searches using a search term.
</p>


<h3>Value</h3>

<p>Each sub-function returns a different object class: <code>request_data()</code>
returns <code>data_request</code>. <code>request_metadata</code> returns <code>metadata_request</code>,
<code>request_files()</code> returns <code>files_request</code>. These objects are list-like and
contain the following slots:
</p>

<ul>
<li> <p><code>filter</code>: edit by piping <code><a href="#topic+filter.data_request">filter()</a></code> or <code><a href="#topic+galah_filter">galah_filter()</a></code>.
</p>
</li>
<li> <p><code>select</code>: edit by piping <code><a href="#topic+filter.data_request">select</a></code> or <code><a href="#topic+galah_select">galah_select()</a></code>.
</p>
</li>
<li> <p><code>group_by</code>: edit by piping <code><a href="#topic+group_by.data_request">group_by()</a></code> or <code><a href="#topic+galah_group_by">galah_group_by()</a></code>.
</p>
</li>
<li> <p><code>identify</code>: edit by piping <code><a href="#topic+identify.data_request">identify()</a></code> or <code><a href="#topic+galah_identify">galah_identify()</a></code>.
</p>
</li>
<li> <p><code>geolocate</code>: edit by piping <code><a href="#topic+st_crop.data_request">st_crop()</a></code>,
<code><a href="#topic+galah_geolocate">galah_geolocate()</a></code>, <code><a href="#topic+galah_polygon">galah_polygon()</a></code> or <code><a href="#topic+galah_bbox">galah_bbox()</a></code>.
</p>
</li>
<li> <p><code>limit</code>: edit by piping <code><a href="#topic+slice_head.data_request">slice_head()</a></code>.
</p>
</li>
<li> <p><code>doi</code>: edit by piping <code><a href="#topic+filter.data_request">filter(doi == &quot;my-doi-here&quot;)</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+collapse.data_request">collapse.data_request()</a></code>, <code><a href="#topic+compute.data_request">compute.data_request()</a></code>, <code><a href="#topic+collect.data_request">collect.data_request()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
# Begin your query with `galah_call()`, then pipe using `%&gt;%` or `|&gt;`

# Get number of records of *Aves* from 2001 to 2004 by year
galah_call() |&gt;
  identify("Aves") |&gt;
  filter(year &gt; 2000 &amp; year &lt; 2005) |&gt;
  group_by(year) |&gt;
  atlas_counts()
  
# Get information for all species in *Cacatuidae* family
galah_call() |&gt;
  identify("Cacatuidae") |&gt;
  atlas_species()
  
# Download records of genus *Eolophus* from 2001 to 2004
galah_config(email = "your-email@email.com")

galah_call() |&gt;
  identify("Eolophus") |&gt;
  filter(year &gt; 2000 &amp; year &lt; 2005) |&gt;
  atlas_occurrences() # synonymous with `collect()`


# galah_call() is a wrapper to various `request_` functions.
# These can be called directly for greater specificity.

# Get number of records of *Aves* from 2001 to 2004 by year
request_data() |&gt;
  identify("Aves") |&gt;
  filter(year &gt; 2000 &amp; year &lt; 2005) |&gt;
  group_by(year) |&gt;
  count() |&gt;
  collect()

# Get information for all species in *Cacatuidae* family
request_data(type = "species") |&gt;
  identify("Cacatuidae") |&gt;
  collect()
  
# Get metadata information about supported atlases in galah
request_metadata(type = "atlases") |&gt;
  collect()


## End(Not run)
</code></pre>

<hr>
<h2 id='galah_config'>Get or set configuration options that control galah behaviour</h2><span id='topic+galah_config'></span>

<h3>Description</h3>

<p>The <code>galah</code> package supports large data downloads, and also
interfaces with the ALA which requires that users of some services
provide a registered email address and reason for downloading data. The
<code>galah_config</code> function provides a way to manage these issues as simply
as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>galah_config(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="galah_config_+3A_...">...</code></td>
<td>
<p>Options can be defined using the form <code>name = "value"</code>.
Valid arguments are:
</p>

<ul>
<li> <p><code>api-key</code> string: A registered API key (currently unused).
</p>
</li>
<li> <p><code>atlas</code> string: Living Atlas to point to, Australia by default. Can be
an organisation name, acronym, or region (see <code><a href="#topic+show_all_atlases">show_all_atlases()</a></code> for
admissible values)
</p>
</li>
<li> <p><code>directory</code> string: the directory to use for the cache.
By default this is a temporary directory, which means that results will
only be cached
within an R session and cleared automatically when the user exits R.
The user may wish to set this to a non-temporary directory for
caching across sessions. The directory must exist on the file system.
</p>
</li>
<li> <p><code>download_reason_id</code> numeric or string: the &quot;download reason&quot; required.
by some ALA services, either as a numeric ID (currently 0&ndash;13)
or a string (see <code>show_all(reasons)</code> for a list of valid ID codes and
names). By default this is NA. Some ALA services require a valid
download_reason_id code, either specified here or directly to the
associated R function.
</p>
</li>
<li> <p><code>email</code> string: An email address that has been registered with the chosen
atlas. For the ALA, you can register at
<a href="https://auth.ala.org.au/userdetails/registration/createAccount">this address</a>.
</p>
</li>
<li> <p><code>password</code> string: A registered password (GBIF only)
</p>
</li>
<li> <p><code>run_checks</code> logical: should <code>galah</code> run checks for filters
and columns. If making lots of requests sequentially, checks can slow down
the process and lead to HTTP 500 errors, so should be turned off. Defaults
to TRUE.
</p>
</li>
<li> <p><code>send_email</code> logical: should you receive an email for each query to
<code><a href="#topic+atlas_occurrences">atlas_occurrences()</a></code>? Defaults to <code>FALSE</code>; but can be
useful in some instances, for example for tracking DOIs assigned to
specific downloads for later citation.
</p>
</li>
<li> <p><code>username</code> string: A registered username (GBIF only)
</p>
</li>
<li> <p><code>verbose</code> logical: should <code>galah</code> give verbose such as progress bars?
Defaults to FALSE.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>galah_config()</code>, a <code>list</code> of all options.
When <code>galah_config(...)</code> is called with arguments, nothing is returned
but the configuration is set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To download occurrence records, enter your email in `galah_config()`. 
# This email should be registered with the atlas in question. 
galah_config(email = "your-email@email.com")
 
# Turn on caching in your session
galah_config(caching = TRUE)
 
# Some ALA services require that you add a reason for downloading data. 
# Add your selected reason using the option `download_reason_id`
galah_config(download_reason_id = 0)

# To look up all valid reasons to enter, use `show_all(reasons)`
show_all(reasons)

# Make debugging in your session easier by setting `verbose = TRUE`
galah_config(verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='geolocate'>Narrow a query to within a specified area</h2><span id='topic+geolocate'></span><span id='topic+galah_geolocate'></span><span id='topic+galah_polygon'></span><span id='topic+galah_bbox'></span><span id='topic+galah_radius'></span><span id='topic+st_crop.data_request'></span>

<h3>Description</h3>

<p>Restrict results to those from a specified area.
Areas can be specified as either polygons or bounding boxes, depending on
<code>type</code>. Alternatively, users can call the underlying functions directly via
<code>galah_polygon()</code>, <code>galah_bbox()</code> or <code>galah_radius()</code>. It is possible to use
<code>sf</code> syntax by calling <code>st_crop()</code>, which is synonymous with
<code>galah_polygon()</code>.
</p>
<p><strong>Use a polygon</strong>
If calling <code>galah_geolocate()</code>, the default <code>type</code> is <code>"polygon"</code>, which
narrows queries to within an area supplied as a <code>POLYGON</code> or <code>MULTIPOLYGON</code>.
Polygons must be
specified as either an <code>sf</code> object, a 'well-known text' (WKT) string, or a
shapefile. Shapefiles must be simple to be accepted by the ALA.
</p>
<p><strong>Use a bounding box</strong>
Alternatively, set <code>type = "bbox"</code> to narrow queries to within a bounding
box. Bounding boxes can be extracted from a supplied <code>sf</code> object or
a shapefile. A bounding box can also be supplied as a <code>bbox</code> object
(via <code>sf::st_bbox()</code>) or a <code>tibble</code>/<code>data.frame</code>.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
<strong>Use a point radius</strong>
Alternatively, set <code>type = "radius"</code> to narrow queries to within a circular
area around a specific point location. Point coordinates can be supplied as
latitude/longitude coordinate numbers or as an <code>sf</code> object (<code>sfc_POINT</code>).
Area is supplied as a <code>radius</code> in kilometres. Default radius is 10 km.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geolocate(..., type = c("polygon", "bbox", "radius"))

galah_geolocate(..., type = c("polygon", "bbox", "radius"))

galah_polygon(...)

galah_bbox(...)

galah_radius(...)

## S3 method for class 'data_request'
st_crop(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geolocate_+3A_...">...</code></td>
<td>
<p>For <code>st_crop</code>, additional arguments (currently ignored). Otherwise
a single <code>sf</code> object, WKT string or shapefile. Bounding boxes can
be supplied as a <code>tibble</code>/<code>data.frame</code> or a <code>bbox</code></p>
</td></tr>
<tr><td><code id="geolocate_+3A_type">type</code></td>
<td>
<p><code>string</code>: one of <code>c("polygon", "bbox")</code>. Defaults to
<code>"polygon"</code>. If <code>type = "polygon"</code>, a multipolygon will be built via
<code><a href="#topic+galah_polygon">galah_polygon()</a></code>. If <code>type = "bbox"</code>, a multipolygon will be built via
<code><a href="#topic+galah_bbox">galah_bbox()</a></code>. The multipolygon is used to narrow a query to the ALA.</p>
</td></tr>
<tr><td><code id="geolocate_+3A_x">x</code></td>
<td>
<p>An object of class <code>data_request</code>, created using <code><a href="#topic+galah_call">galah_call()</a></code></p>
</td></tr>
<tr><td><code id="geolocate_+3A_y">y</code></td>
<td>
<p>A valid Well-Known Text string (wkt), a <code>POLYGON</code> or a <code>MULTIPOLYGON</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type = "polygon"</code>, WKT strings longer than 10000 characters and
<code>sf</code> objects with more than 500 vertices will not be
accepted by the ALA. Some polygons  may need to be simplified.
If <code>type = "bbox"</code>, sf objects and shapefiles will be converted to a bounding
box to query the ALA.
If <code style="white-space: pre;">&#8288;type = "radius&#8288;</code>, <code>sfc_POINT</code> objects will be converted to lon/lat
coordinate numbers to query the ALA. Default radius is 10 km.
</p>


<h3>Value</h3>

<p>If <code>type = "polygon"</code> or <code>type = "bbox"</code>,
length-1 string (class <code>character</code>) containing a multipolygon WKT
string representing the area provided.
If <code>type = "radius"</code>,
<code>list</code> of <code>lat</code>, <code>long</code> and <code>radius</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Search for records within a polygon using a shapefile
location &lt;- sf::st_read("path/to/shapefile.shp")
galah_call() |&gt;
  identify("vulpes") |&gt;
  geolocate(location) |&gt;
  count() |&gt;
  collect()
  
# Search for records within the bounding box of a shapefile
location &lt;- sf::st_read("path/to/shapefile.shp")
galah_call() |&gt;
  identify("vulpes") |&gt;
  geolocate(location, type = "bbox") |&gt;
  count() |&gt;
  collect()

# Search for records within a polygon using an `sf` object
location &lt;- "POLYGON((142.3 -29.0,142.7 -29.1,142.7 -29.4,142.3 -29.0))" |&gt;
 sf::st_as_sfc()
galah_call() |&gt;
  identify("reptilia") |&gt;
  galah_polygon(location) |&gt;
  count() |&gt;
  collect()
  
# Search for records using a Well-known Text string (WKT)
wkt &lt;- "POLYGON((142.3 -29.0,142.7 -29.1,142.7 -29.4,142.3 -29.0))"
galah_call() |&gt;
  identify("vulpes") |&gt;
  st_crop(wkt) |&gt;
  count() |&gt;
  collect()

# Search for records within the bounding box extracted from an `sf` object
location &lt;- "POLYGON((142.3 -29.0,142.7 -29.1,142.7 -29.4,142.3 -29.0))" |&gt;
  sf::st_as_sfc()
galah_call() |&gt;
  identify("vulpes") |&gt;
  galah_geolocate(location, type = "bbox") |&gt;
  count() |&gt;
  collect()

# Search for records using a bounding box of coordinates
b_box &lt;- sf::st_bbox(c(xmin = 143, xmax = 148, ymin = -29, ymax = -28), 
                     crs = sf::st_crs("WGS84"))
galah_call() |&gt;
  identify("reptilia") |&gt;
  galah_geolocate(b_box, type = "bbox") |&gt;
  count() |&gt;
  collect()

# Search for records using a bounding box in a `tibble` or `data.frame`
b_box &lt;- tibble::tibble(xmin = 148, ymin = -29, xmax = 143, ymax = -21)
galah_call() |&gt;
  identify("vulpes") |&gt;
  galah_geolocate(b_box, type = "bbox") |&gt;
  count() |&gt;
  collect()

# Search for records within a radius around a point's coordinates
galah_call() |&gt;
  identify("manorina melanocephala") |&gt;
  galah_geolocate(lat = -33.7,
                  lon = 151.3,
                  radius = 5,
                  type = "radius") |&gt;
  count() |&gt;
  collect()

# Search for records with a radius around an `sf_POINT` object
point &lt;- sf::st_sfc(sf::st_point(c(-33.66741, 151.3174)), crs = 4326)
galah_call() |&gt;
  identify("manorina melanocephala") |&gt;
  galah_geolocate(point,
                  radius = 5,
                  type = "radius") |&gt;
  count() |&gt;
  collect()

## End(Not run)
</code></pre>

<hr>
<h2 id='group_by.data_request'>Group by one or more variables</h2><span id='topic+group_by.data_request'></span><span id='topic+galah_group_by'></span>

<h3>Description</h3>

<p>Most data operations are done on groups defined by variables. <code>group_by()</code>
takes a field name (unquoted) and performs a grouping operation. The default
behaviour is to use it in combination with
<code><a href="#topic+count.data_request">count()</a></code> to give information on number
of occurrences per level of that field. Alternatively, you can use it
without count to get a download of occurrences grouped by that variable. This
is particularly useful when used with a taxonomic <code>ID</code> field (<code>speciesID</code>,
<code>genusID</code> etc.) as it allows further information to be appended to the result.
This is how <code><a href="#topic+atlas_species">atlas_species()</a></code> works, for example. See
<code><a href="#topic+select.data_request">select()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_request'
group_by(.data, ...)

galah_group_by(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_by.data_request_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>data_request</code></p>
</td></tr>
<tr><td><code id="group_by.data_request_+3A_...">...</code></td>
<td>
<p>Zero or more individual column names to include</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If any arguments are provided, returns a <code>data.frame</code> with
columns <code>name</code> and <code>type</code>, as per <code><a href="#topic+select.data_request">select.data_request()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# default usage is for grouping counts
galah_call() |&gt; 
  group_by(basisOfRecord) |&gt;
  counts() |&gt;
  collect()

# Alternatively, we can use this with an occurrence search  
galah_call() |&gt;
  filter(year == 2024,
         genus = "Crinia") |&gt;
  group_by(speciesID) |&gt;
 collect()
# note that this example is equivalent to `atlas_species()`; 
# but using `group_by()` is more flexible.

## End(Not run)
</code></pre>

<hr>
<h2 id='identify.data_request'>Narrow a query by passing taxonomic identifiers</h2><span id='topic+identify.data_request'></span><span id='topic+identify.metadata_request'></span><span id='topic+galah_identify'></span>

<h3>Description</h3>

<p>When conducting a search or creating a data query, it is common to identify
a known taxon or group of taxa to narrow down the records or results returned.
<code>identify()</code> is used to identify taxa you want returned in a search or
a data query. Users to pass scientific names or taxonomic identifiers
with pipes to provide data only for the biological group of interest.
</p>
<p>It is good to use <code><a href="#topic+search_taxa">search_taxa()</a></code> and <code><a href="#topic+search_identifiers">search_identifiers()</a></code>
first to check that the taxa you provide to <code>galah_identify()</code> return the
correct results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_request'
identify(x, ...)

## S3 method for class 'metadata_request'
identify(x, ...)

galah_identify(..., search = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify.data_request_+3A_x">x</code></td>
<td>
<p>An object of class <code>metadata_request</code>, created using <code><a href="#topic+request_metadata">request_metadata()</a></code></p>
</td></tr>
<tr><td><code id="identify.data_request_+3A_...">...</code></td>
<td>
<p>One or more scientific names.</p>
</td></tr>
<tr><td><code id="identify.data_request_+3A_search">search</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
<code>galah_identify()</code> now always does a search to verify search terms; ergo
this argument is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing identified taxa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.data_request">filter()</a></code> or <code><a href="#topic+geolocate">geolocate()</a></code> for
other ways to filter a query. You can also use <code><a href="#topic+search_taxa">search_taxa()</a></code> to check that
supplied names are being matched correctly on the server-side; see
<a href="#topic+taxonomic_searches">taxonomic_searches</a> for a detailed overview.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Use `galah_identify()` to narrow your queries
galah_call() |&gt; 
  identify("Eolophus") |&gt;
  count() |&gt;
  collect()

# If you know a valid taxon identifier, use `filter()` instead.
id &lt;- "https://biodiversity.org.au/afd/taxa/009169a9-a916-40ee-866c-669ae0a21c5c"
galah_call() |&gt; 
  filter(lsid == id)  |&gt;
  count() |&gt;
  collect()

## End(Not run)
</code></pre>

<hr>
<h2 id='print_galah_objects'>Print galah objects</h2><span id='topic+print_galah_objects'></span><span id='topic+print.data_request'></span><span id='topic+print.files_request'></span><span id='topic+print.metadata_request'></span><span id='topic+print.query'></span><span id='topic+print.computed_query'></span><span id='topic+print.query_set'></span><span id='topic+print.galah_config'></span>

<h3>Description</h3>

<p>As of version 2.0, <code>galah</code> supports several bespoke object types. Classes
<code>data_request</code>, <code>metadata_request</code> and <code>files_request</code> are for starting pipes
to download different types of information. These objects are parsed using
<code>collapse()</code> into a <code>query</code> object, which contains one or more URLs necessary
to return the requested information. This object is then passed to
<code>compute()</code> and/or <code>collect()</code>. Finally, <code>galah_config()</code> creates an object
of class <code>galah_config</code> which (unsurprisingly) stores configuration
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_request'
print(x, ...)

## S3 method for class 'files_request'
print(x, ...)

## S3 method for class 'metadata_request'
print(x, ...)

## S3 method for class 'query'
print(x, ...)

## S3 method for class 'computed_query'
print(x, ...)

## S3 method for class 'query_set'
print(x, ...)

## S3 method for class 'galah_config'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_galah_objects_+3A_x">x</code></td>
<td>
<p>an object of the appropriate <code>class</code></p>
</td></tr>
<tr><td><code id="print_galah_objects_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print does not return an object; instead it prints a description
of the object to the console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The most common way to start a pipe is with `galah_call()`
# later functions update the `data_request` object
galah_call() |&gt; # same as calling `request_data()`
  filter(year &gt;= 2020) |&gt;
  group_by(year) |&gt;
  count()

# Metadata requests are formatted in a similar way
request_metadata() |&gt;
  filter(field == basisOfRecord) |&gt;
  unnest()

# Queries are converted into a `query_set` by `collapse()`
x &lt;- galah_call() |&gt; # same as calling `request_data()`
  filter(year &gt;= 2020) |&gt;
  count() |&gt;
  collapse()
print(x)
  
# Each `query_set` contains one or more `query` objects
x[[3]]

## End(Not run)
</code></pre>

<hr>
<h2 id='read_zip'>Read downloaded data from a zip file</h2><span id='topic+read_zip'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Living atlases supply data downloads as zip files. This function reads these
data efficiently, i.e. without unzipping them first, using the <code>readr</code>
package. Although this function has been part of galah for some time, it was
previously internal to <code><a href="#topic+atlas_occurrences">atlas_occurrences()</a></code>. It has been exported now to
support easy re-importing of downloaded files, without the need to re-run
a query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_zip(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_zip_+3A_file">file</code></td>
<td>
<p>(character) A file name. Must be a length-1 character ending in
<code>.zip</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set a working directory
galah_config(directory = "data-raw",
             email = "an-email-address@email.com")

# download some data
galah_call() |&gt;
  identify("Heleioporus") |&gt;
  filter(year == 2022) |&gt;
  collect(file = "burrowing_frog_data.zip")
  
# load data from file
x &lt;- read_zip("./data-raw/burrowing_frog_data.zip")

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+arrange'></span><span id='topic+collect'></span><span id='topic+compute'></span><span id='topic+collapse'></span><span id='topic+identify'></span><span id='topic+filter'></span><span id='topic+select'></span><span id='topic+group_by'></span><span id='topic+slice_head'></span><span id='topic+count'></span><span id='topic+st_crop'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="dplyr.html#topic+compute">collapse</a></code>, <code><a href="dplyr.html#topic+compute">collect</a></code>, <code><a href="dplyr.html#topic+compute">compute</a></code>, <code><a href="dplyr.html#topic+count">count</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code>, <code><a href="dplyr.html#topic+select">select</a></code>, <code><a href="dplyr.html#topic+slice">slice_head</a></code></p>
</dd>
<dt>graphics</dt><dd><p><code><a href="graphics.html#topic+identify">identify</a></code></p>
</dd>
<dt>sf</dt><dd><p><code><a href="sf.html#topic+st_crop">st_crop</a></code></p>
</dd>
</dl>

<hr>
<h2 id='search_all'>Search for record information</h2><span id='topic+search_all'></span><span id='topic+search_atlases'></span><span id='topic+search_reasons'></span><span id='topic+search_ranks'></span><span id='topic+search_fields'></span><span id='topic+search_assertions'></span><span id='topic+search_profiles'></span><span id='topic+search_providers'></span><span id='topic+search_collections'></span><span id='topic+search_datasets'></span><span id='topic+search_licences'></span><span id='topic+search_apis'></span><span id='topic+search_identifiers'></span><span id='topic+search_lists'></span><span id='topic+search_taxa'></span>

<h3>Description</h3>

<p>The living atlases store a huge amount of information, above and beyond the
occurrence records that are their main output. In <code>galah</code>, one way that
users can investigate this information is by searching for a specific option
or category for the type of information they are interested in.
Functions prefixed with <code>search_</code> do this, displaying any matches to a
search term within the valid options for the information specified by the
suffix.
</p>
<p><strong>For more information about taxonomic searches using <code>search_taxa()</code>, see <code>?taxonomic_searches</code></strong>.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
<code>search_all()</code> is a helper function that can do searches for multiple
types of information, acting as a wrapper around many <code>search_</code> sub-functions.
See <code>Details</code> (below) for accepted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_all(type, query)

search_assertions(query)

search_apis(query)

search_atlases(query)

search_collections(query)

search_datasets(query)

search_fields(query)

search_identifiers(...)

search_licences(query)

search_lists(query)

search_profiles(query)

search_providers(query)

search_ranks(query)

search_reasons(query)

search_taxa(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_all_+3A_type">type</code></td>
<td>
<p>A string to specify what type of parameters should be searched.</p>
</td></tr>
<tr><td><code id="search_all_+3A_query">query</code></td>
<td>
<p>A string specifying a search term. Searches are not
case-sensitive.</p>
</td></tr>
<tr><td><code id="search_all_+3A_...">...</code></td>
<td>
<p>A set of strings or a tibble to be queried; see
Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are five categories of information, each with their own
specific sub-functions to look-up each type of information.
The available types of information for <code>search_all()</code> are:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Category</strong> </td><td style="text-align: left;"> <strong>Type</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Sub-functions</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   configuration </td><td style="text-align: left;"> <code>atlases</code> </td><td style="text-align: left;"> Search for what atlases are available </td><td style="text-align: left;"> <code>search_atlases()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>apis</code> </td><td style="text-align: left;"> Search for what APIs &amp; functions are available for each atlas </td><td style="text-align: left;"> <code>search_apis()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>reasons</code> </td><td style="text-align: left;"> Search for what values are acceptable as 'download reasons' for a specified atlas </td><td style="text-align: left;"> <code>search_reasons()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   taxonomy </td><td style="text-align: left;"> <code>taxa</code> </td><td style="text-align: left;"> Search for one or more taxonomic names </td><td style="text-align: left;"> <code>search_taxa()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>identifiers</code> </td><td style="text-align: left;"> Take a universal identifier and return taxonomic information </td><td style="text-align: left;"> <code>search_identifiers()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>ranks</code> </td><td style="text-align: left;"> Search for valid taxonomic ranks (e.g. Kingdom, Class, Order, etc.) </td><td style="text-align: left;"> <code>search_ranks()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   filters </td><td style="text-align: left;"> <code>fields</code> </td><td style="text-align: left;"> Search for fields that are stored in an atlas </td><td style="text-align: left;"> <code>search_fields()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>assertions</code> </td><td style="text-align: left;"> Search for results of data quality checks run by each atlas </td><td style="text-align: left;"> <code>search_assertions()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>licenses</code> </td><td style="text-align: left;"> Search for copyright licences applied to media </td><td style="text-align: left;"> <code>search_licenses()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   group filters </td><td style="text-align: left;"> <code>profiles</code> </td><td style="text-align: left;"> Search for what data profiles are available </td><td style="text-align: left;"> <code>search_profiles()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>lists</code> </td><td style="text-align: left;"> Search for what species lists are available </td><td style="text-align: left;"> <code>search_lists()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   data providers </td><td style="text-align: left;"> <code>providers</code> </td><td style="text-align: left;"> Search for which institutions have provided data </td><td style="text-align: left;"> <code>search_providers()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>collections</code> </td><td style="text-align: left;"> Search for the specific collections within those institutions </td><td style="text-align: left;"> <code>search_collections()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>datasets</code> </td><td style="text-align: left;"> Search for the data groupings within those collections </td><td style="text-align: left;"> <code>search_datasets()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>An object of class <code>tbl_df</code> and <code>data.frame</code> (aka a tibble)
containing all data that match the search query.
</p>


<h3>See Also</h3>

<p>Use the <code><a href="#topic+show_all">show_all()</a></code> function and <code>show_all_()</code> sub-functions to
show available options of information. These functions are used to pass valid
arguments to <code><a href="#topic+filter.data_request">filter()</a></code>,
<code><a href="#topic+select.data_request">select()</a></code>, and related functions.
Taxonomic queries are somewhat more involved; see <a href="#topic+taxonomic_searches">taxonomic_searches</a> for
details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Search for fields that include the word "date"
search_all(fields, "date")

# Search for fields that include the word "marine"
search_all(fields, "marine")

# Search using a single taxonomic term
# (see `?search_taxa()` for more information)
search_all(taxa, "Reptilia") # equivalent

# Look up a unique taxon identifier
# (see `?search_identifiers()` for more information)
search_all(identifiers, 
           "https://id.biodiversity.org.au/node/apni/2914510")

# Search for species lists that match "endangered"
search_all(lists, "endangered") # equivalent

# Search for a valid taxonomic rank, "subphylum"
search_all(ranks, "subphylum")

# An alternative is to download the data and then `filter` it. This is 
# largely synonymous, and allows greater control over which fields are searched.
request_metadata(type = "fields") |&gt;
 collect() |&gt;
 dplyr::filter(grepl("date", id))

## End(Not run)
</code></pre>

<hr>
<h2 id='select.data_request'>Keep or drop columns using their names</h2><span id='topic+select.data_request'></span><span id='topic+galah_select'></span>

<h3>Description</h3>

<p>Select (and optionally rename) variables in a data frame, using
a concise mini-language that makes it easy to refer to variables based on
their name. Note that unlike calling <code>select()</code> on a local tibble, this
implementation is only evaluated at the
<code><a href="#topic+collapse.data_request">collapse()</a></code> stage, meaning any errors
or messages will be triggered at the end of the pipe.
</p>
<p><code>select()</code> supports <code>dplyr</code> <strong>selection helpers</strong>, including:
</p>

<ul>
<li> <p><code><a href="dplyr.html#topic+everything">everything</a></code>: Matches all variables.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+last_col">last_col</a></code>: Select last variable, possibly with an
offset.
</p>
</li></ul>

<p>Other helpers select variables by matching patterns in their names:
</p>

<ul>
<li> <p><code><a href="dplyr.html#topic+starts_with">starts_with</a></code>: Starts with a prefix.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+ends_with">ends_with</a></code>: Ends with a suffix.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+contains">contains</a></code>: Contains a literal string.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+matches">matches</a></code>: Matches a regular expression.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+num_range">num_range</a></code>: Matches a numerical range like x01,
x02, x03.
</p>
</li></ul>

<p>Or from variables stored in a character vector:
</p>

<ul>
<li> <p><code><a href="dplyr.html#topic+all_of">all_of</a></code>: Matches variable names in a character
vector. All names must be present, otherwise an out-of-bounds error is
thrown.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+any_of">any_of</a></code>: Same as <code>all_of()</code>, except that no error
is thrown for names that don't exist.
</p>
</li></ul>

<p>Or using a predicate function:
</p>

<ul>
<li> <p><code><a href="dplyr.html#topic+where">where</a></code>: Applies a function to all variables and selects those for which the function returns <code>TRUE</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_request'
select(.data, ..., group)

galah_select(..., group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select.data_request_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>data_request</code>, created using <code><a href="#topic+galah_call">galah_call()</a></code>.</p>
</td></tr>
<tr><td><code id="select.data_request_+3A_...">...</code></td>
<td>
<p>Zero or more individual column names to include.</p>
</td></tr>
<tr><td><code id="select.data_request_+3A_group">group</code></td>
<td>
<p><code>string</code>: (optional) name of one or more column groups to
include. Valid options are <code>"basic"</code>, <code>"event"</code> <code>"taxonomy"</code>, <code>"media"</code> and
<code>"assertions"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GBIF nodes store content in hundreds of different fields, and users often
require thousands or millions of records at a time. To reduce time taken to
download data, and limit complexity of the resulting <code>tibble</code>, it is sensible
to restrict the fields returned by occurrence queries. The full list of
available fields can be viewed with <code>show_all(fields)</code>. Note that <code>select()</code>
and <code>galah_select()</code> are supported for all atlases that allow downloads, with
the exception of GBIF, for which all columns are returned.
</p>
<p>Calling the argument <code>group = "basic"</code> returns the following columns:
</p>

<ul>
<li> <p><code>decimalLatitude</code>
</p>
</li>
<li> <p><code>decimalLongitude</code>
</p>
</li>
<li> <p><code>eventDate</code>
</p>
</li>
<li> <p><code>scientificName</code>
</p>
</li>
<li> <p><code>taxonConceptID</code>
</p>
</li>
<li> <p><code>recordID</code>
</p>
</li>
<li> <p><code>dataResourceName</code>
</p>
</li>
<li> <p><code>occurrenceStatus</code>
</p>
</li></ul>

<p>Using <code>group = "event"</code> returns the following columns:
</p>

<ul>
<li> <p><code>eventRemarks</code>
</p>
</li>
<li> <p><code>eventTime</code>
</p>
</li>
<li> <p><code>eventID</code>
</p>
</li>
<li> <p><code>eventDate</code>
</p>
</li>
<li> <p><code>samplingEffort</code>
</p>
</li>
<li> <p><code>samplingProtocol</code>
</p>
</li></ul>

<p>Using <code>group = "media"</code> returns the following columns:
</p>

<ul>
<li> <p><code>multimedia</code>
</p>
</li>
<li> <p><code>multimediaLicence</code>
</p>
</li>
<li> <p><code>images</code>
</p>
</li>
<li> <p><code>videos</code>
</p>
</li>
<li> <p><code>sounds</code>
</p>
</li></ul>

<p>Using <code>group = "taxonomy"</code> returns higher taxonomic information for a given
query. It is the only <code>group</code> that is accepted by <code>atlas_species()</code> as well
as <code>atlas_occurrences()</code>.
</p>
<p>Using <code>group = "assertions"</code> returns all quality assertion-related
columns. The list of assertions is shown by <code>show_all_assertions()</code>.
</p>
<p>For <code>atlas_occurrences()</code>, arguments passed to <code>...</code> should be valid field
names, which you can check using <code>show_all(fields)</code>. For <code>atlas_species()</code>,
it should be one or more of:
</p>

<ul>
<li> <p><code>counts</code> to include counts of occurrences per species.
</p>
</li>
<li> <p><code>synonyms</code> to include any synonymous names.
</p>
</li>
<li> <p><code>lists</code> to include authoritative lists that each species is included on.
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble
specifying the name and type of each column to include in the
call to <code>atlas_counts()</code> or <code>atlas_occurrences()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.data_request">filter()</a></code>,
<code><a href="#topic+st_crop.data_request">st_crop()</a></code> and
<code><a href="#topic+identify.data_request">identify()</a></code> for other ways to restrict
the information returned; <code>show_all(fields)</code> to list available fields.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Download occurrence records of *Perameles*, 
# Only return scientificName and eventDate columns
galah_config(email = "your-email@email.com")
galah_call() |&gt;
  identify("perameles")|&gt;
  select(scientificName, eventDate) |&gt;
  collect()

# Only return the "basic" group of columns and the basisOfRecord column
galah_call() |&gt;
  identify("perameles") |&gt;
  select(basisOfRecord, group = "basic") |&gt;
  collect()
  
# When used in a pipe, `galah_select()` and `select()` are synonymous.
# Hence the previous example can be rewritten as:
galah_call() |&gt;
  galah_identify("perameles") |&gt;
  galah_select(basisOfRecord, group = "basic") |&gt;
  collect()

## End(Not run)
</code></pre>

<hr>
<h2 id='show_all'>Show valid record information</h2><span id='topic+show_all'></span><span id='topic+show_all_apis'></span><span id='topic+show_all_assertions'></span><span id='topic+show_all_atlases'></span><span id='topic+show_all_collections'></span><span id='topic+show_all_datasets'></span><span id='topic+show_all_fields'></span><span id='topic+show_all_licences'></span><span id='topic+show_all_lists'></span><span id='topic+show_all_profiles'></span><span id='topic+show_all_providers'></span><span id='topic+show_all_ranks'></span><span id='topic+show_all_reasons'></span>

<h3>Description</h3>

<p>The living atlases store a huge amount of information, above and beyond the
occurrence records that are their main output. In <code>galah</code>, one way that
users can investigate this information is by showing all the available
options or categories for the type of information they are interested in.
Functions prefixed with <code>show_all_</code> do this, displaying all valid options
for the information specified by the suffix.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
<code>show_all()</code> is a helper function that can display multiple types of
information from <code>show_all_</code> sub-functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_all(..., limit = NULL)

show_all_apis(limit = NULL)

show_all_assertions(limit = NULL)

show_all_atlases(limit = NULL)

show_all_collections(limit = NULL)

show_all_datasets(limit = NULL)

show_all_fields(limit = NULL)

show_all_licences(limit = NULL)

show_all_lists(limit = NULL)

show_all_profiles(limit = NULL)

show_all_providers(limit = NULL)

show_all_ranks(limit = NULL)

show_all_reasons(limit = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_all_+3A_...">...</code></td>
<td>
<p>String showing what type of information is to be requested. See
<code>Details</code> (below) for accepted values.</p>
</td></tr>
<tr><td><code id="show_all_+3A_limit">limit</code></td>
<td>
<p>Optional number of values to return. Defaults to NULL, i.e. all records</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are five categories of information, each with their own
specific sub-functions to look-up each type of information.
The available types of information for <code>show_all_</code> are:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Category</strong> </td><td style="text-align: left;"> <strong>Type</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Sub-functions</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Configuration </td><td style="text-align: left;"> <code>atlases</code> </td><td style="text-align: left;"> Show what atlases are available </td><td style="text-align: left;"> <code>show_all_atlases()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>apis</code> </td><td style="text-align: left;"> Show what APIs &amp; functions are available for each atlas </td><td style="text-align: left;"> <code>show_all_apis()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>reasons</code> </td><td style="text-align: left;"> Show what values are acceptable as 'download reasons' for a specified atlas </td><td style="text-align: left;"> <code>show_all_reasons()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Data providers </td><td style="text-align: left;"> <code>providers</code> </td><td style="text-align: left;"> Show which institutions have provided data </td><td style="text-align: left;"> <code>show_all_providers()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>collections</code> </td><td style="text-align: left;"> Show the specific collections within those institutions </td><td style="text-align: left;"> <code>show_all_collections()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>datasets</code> </td><td style="text-align: left;"> Shows all the data groupings within those collections </td><td style="text-align: left;"> <code>show_all_datasets()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Filters </td><td style="text-align: left;"> <code>assertions</code> </td><td style="text-align: left;"> Show results of data quality checks run by each atlas </td><td style="text-align: left;"> <code>show_all_assertions()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>fields</code> </td><td style="text-align: left;"> Show fields that are stored in an atlas </td><td style="text-align: left;"> <code>show_all_fields()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>licenses</code> </td><td style="text-align: left;"> Show what copyright licenses are applied to media </td><td style="text-align: left;"> <code>show_all_licenses()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>profiles</code> </td><td style="text-align: left;"> Show what data profiles are available </td><td style="text-align: left;"> <code>show_all_profiles()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Taxonomy </td><td style="text-align: left;"> <code>lists</code> </td><td style="text-align: left;"> Show what species lists are available </td><td style="text-align: left;"> <code>show_all_lists()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>ranks</code> </td><td style="text-align: left;"> Show valid taxonomic ranks (e.g. Kingdom, Class, Order, etc.) </td><td style="text-align: left;"> <code>show_all_ranks()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>An object of class <code>tbl_df</code> and <code>data.frame</code> (aka a tibble)
containing all data of interest.
</p>


<h3>References</h3>


<ul>
<li><p> Darwin Core terms <a href="https://dwc.tdwg.org/terms/">https://dwc.tdwg.org/terms/</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Use the <code><a href="#topic+search_all">search_all()</a></code> function and <code>search_()</code> sub-functions to
search for information. These functions are used to pass valid arguments to
<code><a href="#topic+filter.data_request">filter()</a></code>,
<code><a href="#topic+select.data_request">select()</a></code>, and related functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See all supported atlases
show_all(atlases)

# Show a list of all available data quality profiles
show_all(profiles)

# Show a listing of all accepted reasons for downloading occurrence data
show_all(reasons)

# Show a listing of all taxonomic ranks
show_all(ranks)

# `show_all()` is synonymous with `request_metadata() |&gt; collect()`
request_metadata(type = "fields") |&gt;
  collect()

## End(Not run)
</code></pre>

<hr>
<h2 id='show_values'>Show or search for values within a specified field</h2><span id='topic+show_values'></span><span id='topic+search_values'></span>

<h3>Description</h3>

<p>Users may wish to see the specific values <em>within</em> a chosen field, profile
or list to narrow queries or understand more about the information of
interest. <code>show_values()</code> provides users with these values. <code>search_values()</code>
allows users for search for specific values within a specified field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_values(df)

search_values(df, query)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_values_+3A_df">df</code></td>
<td>
<p>A search result from <code><a href="#topic+search_fields">search_fields()</a></code>, <code><a href="#topic+search_profiles">search_profiles()</a></code> or
<code><a href="#topic+search_lists">search_lists()</a></code>.</p>
</td></tr>
<tr><td><code id="show_values_+3A_query">query</code></td>
<td>
<p>A string specifying a search term. Not case sensitive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each <strong>Field</strong> contains categorical or numeric values.
For example:
</p>

<ul>
<li><p> The <code>field</code> &quot;year&quot; contains values 2021, 2020, 2019, etc.
</p>
</li>
<li><p> The <code>field</code> &quot;stateProvince&quot; contains values New South Wales, Victoria, Queensland, etc.
These are used to narrow queries with
<code><a href="#topic+filter.data_request">filter()</a></code> or <code><a href="#topic+galah_filter">galah_filter()</a></code>.
</p>
</li></ul>

<p>Each <strong>Profile</strong> consists of many individual quality filters.
For example, the &quot;ALA&quot; profile consists of values:
</p>

<ul>
<li><p> Exclude all records where spatial validity is FALSE
</p>
</li>
<li><p> Exclude all records with a latitude value of zero
</p>
</li>
<li><p> Exclude all records with a longitude value of zero
</p>
</li></ul>

<p>Each <strong>List</strong> contains a list of species, usually by taxonomic name.
For example, the Endangered Plant species list contains values:
</p>

<ul>
<li><p> Acacia curranii (Curly-bark Wattle)
</p>
</li>
<li><p> Brachyscome papillosa (Mossgiel Daisy)
</p>
</li>
<li><p> Solanum karsense (Menindee Nightshade)
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tibble</code> of values for a specified field, profile or list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Show values in field 'cl22'
search_fields("cl22") |&gt; 
  show_values()

# This is synonymous with `request_metadata() |&gt; unnest()`.
# For example, the previous example can be run using:
request_metadata() |&gt;
  filter(field == "cl22") |&gt;
  unnest() |&gt;
  collect() 

# Search for any values in field 'cl22' that match 'tas'
search_fields("cl22") |&gt; 
  search_values("tas")

# See items within species list "dr19257"
search_lists("dr19257") |&gt; 
  show_values()

## End(Not run)
</code></pre>

<hr>
<h2 id='slice_head.data_request'>Subset rows using their positions</h2><span id='topic+slice_head.data_request'></span><span id='topic+slice_head.metadata_request'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>slice()</code> lets you index rows by their (integer) locations. For objects of
classes <code>data_request</code> or <code>metadata_request</code>, only <code>slice_head()</code> is
currently implemented, and selects the first <code>n</code> rows.
</p>
<p>If <code>.data</code> has been grouped using
<code><a href="#topic+group_by.data_request">group_by()</a></code>, the operation will be
performed on each group, so that (e.g.) <code>slice_head(df, n = 5)</code> will select
the first five rows in each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_request'
slice_head(.data, ..., n, prop, by = NULL)

## S3 method for class 'metadata_request'
slice_head(.data, ..., n, prop, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_head.data_request_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>data_request</code>, created using <code><a href="#topic+galah_call">galah_call()</a></code></p>
</td></tr>
<tr><td><code id="slice_head.data_request_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="slice_head.data_request_+3A_n">n</code></td>
<td>
<p>The number of rows to be returned. If data are grouped
<code><a href="#topic+group_by.data_request">group_by()</a></code>, this operation will be
performed on each group.</p>
</td></tr>
<tr><td><code id="slice_head.data_request_+3A_prop">prop</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="slice_head.data_request_+3A_by">by</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An amended <code>data_request</code> with a completed <code>slice</code> slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Limit number of rows returned to 3.
# In this case, our query returns the top 3 years with most records.
galah_call() |&gt;
  identify("perameles") |&gt;
  filter(year &gt; 2010) |&gt;
  group_by(year) |&gt;
  count() |&gt;
  slice_head(n = 3) |&gt;
  collect()

## End(Not run)
</code></pre>

<hr>
<h2 id='taxonomic_searches'>Look up taxon information</h2><span id='topic+taxonomic_searches'></span>

<h3>Description</h3>

<p><code>search_taxa()</code> allows users to look up taxonomic names, and ensure they are
being matched correctly, before downloading data from the specified
organisation.
</p>
<p>By default, names are supplied as strings; but users can also specify
taxonomic levels in a search using a <code>data.frame</code> or <code>tibble</code>. This is useful
when the taxonomic <em>level</em> of the name in question needs to be specified,
in addition to it's identity. For example, a common method is to use the
<code>scientificName</code> column to list a Latinized binomial, but it is also possible
to list these separately under <code>genus</code> and <code>specificEpithet</code> (respectively).
A more common use-case is to distinguish between homonyms by listing higher
taxonomic units, by supplying columns like <code>kingdom</code>, <code>phylum</code> or <code>class</code>.
</p>
<p><code>search_identifiers()</code> allows users to look up matching taxonomic names using
their unique <code>taxonConceptID</code>. In the ALA, all records are associated with
an identifier that uniquely identifies the taxon to which that record belongs.
Once those identifiers are known, this function allows you to use them to
look up further information on the taxon in question. Effectively this is the
inverse function to <code><a href="#topic+search_taxa">search_taxa()</a></code>, which takes names and provides
identifiers.
</p>
<p>Note that when taxonomic look-up is required within a pipe, the equivalent
to <code>search_taxa()</code> is <code><a href="#topic+identify.data_request">identify()</a></code> (or
<code><a href="#topic+galah_identify">galah_identify()</a></code>). The equivalent to <code>search_identifiers()</code> is to use
<code><a href="#topic+filter.data_request">filter()</a></code> to filter by <code>taxonConceptId</code>.
</p>


<h3>Details</h3>

<p><code>search_taxa()</code> returns the taxonomic match of a supplied text string, along
with the following information:
</p>

<ul>
<li> <p><code>search_term</code>: The search term used by the user. When multiple search
terms are provided in a tibble, these are displayed in this column,
concatenated using <code style="white-space: pre;">&#8288;_&#8288;</code>.
</p>
</li>
<li> <p><code>scientific_name</code>: The taxonomic name matched to the provided search
term, to the lowest identified taxonomic rank.
</p>
</li>
<li> <p><code>taxon_concept_id</code>: The unique taxonomic identifier.
</p>
</li>
<li> <p><code>rank</code>: The taxonomic rank of the returned result.
</p>
</li>
<li> <p><code>match_type</code>: (ALA only) The method of name matching used by the name
matching service. More information can be found on the
<a href="https://github.com/AtlasOfLivingAustralia/ala-name-matching?tab=readme-ov-file#understanding-the-name-matching-algorithm">name matching github repository</a>.
</p>
</li>
<li> <p><code>issues</code>: Any errors returned by the name matching service
(e.g. homonym, indeterminate species match). More information can be found
on the <a href="https://github.com/AtlasOfLivingAustralia/ala-name-matching?tab=readme-ov-file#error-types">name matching github repository</a>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;taxonomic names&#8288;</code> (e.g. <code>kingdom</code>, <code>phylum</code>, <code>class</code>, <code>order</code>,
<code>family</code>, <code>genus</code>)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+search_all">search_all()</a></code> for how to get names if taxonomic identifiers
are already known. <code><a href="#topic+filter.data_request">filter()</a></code>,
<code><a href="#topic+select.data_request">select()</a></code>,
<code><a href="#topic+identify.data_request">identify()</a></code> and <code><a href="#topic+geolocate">geolocate()</a></code> for ways
to restrict the information returned by <code><a href="#topic+atlas_">atlas_()</a></code> functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Search using a single string. 
# Note that `search_taxa()` is not case sensitive
search_taxa("Reptilia")

# Search using multiple strings. 
# `search_taxa()` will return one row per taxon
search_taxa("reptilia", "mammalia")

# Search using more detailed strings with authorship information
search_taxa("Acanthocladium F.Muell")

# Specify taxonomic levels in a tibble using "specificEpithet"
search_taxa(tibble::tibble(
  class = "aves", 
  family = "pardalotidae", 
  genus = "pardalotus", 
  specificEpithet = "punctatus"))

# Specify taxonomic levels in a tibble using "scientificName"                    
search_taxa(tibble::tibble(
  family = c("pardalotidae", "maluridae"), 
  scientificName = c("Pardalotus striatus striatus", "malurus cyaneus")))

# Look up a unique taxon identifier
search_identifiers(query = "https://id.biodiversity.org.au/node/apni/2914510")

## End(Not run)
</code></pre>

<hr>
<h2 id='tidyverse_functions'>Non-generic tidyverse functions</h2><span id='topic+tidyverse_functions'></span><span id='topic+desc'></span><span id='topic+unnest'></span>

<h3>Description</h3>

<p>Several useful functions from tidyverse packages are <code>generic</code>, meaning
that we can define class-specific versions of those functions and implement
them in galah; examples include <code>filter()</code>, <code>select()</code> and <code>group_by()</code>.
However, there are also functions that are only defined within tidyverse
packages and are not generic. In a few cases we have re-implemented these
functions in galah. This has the consequence of supporting consistent
syntax with tidyverse, at the cost of potentially introducing conflicts.
This can be avoided by using the <code>::</code> operator where required (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc(...)

unnest(.query)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidyverse_functions_+3A_...">...</code></td>
<td>
<p>column to order by</p>
</td></tr>
<tr><td><code id="tidyverse_functions_+3A_.query">.query</code></td>
<td>
<p>An object of class <code>metadata_request</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following functions are included:
</p>

<ul>
<li> <p><code>desc()</code> (<code>dplyr</code>): Use within <code>arrange()</code> to specify arrangement should be descending
</p>
</li>
<li> <p><code>unnest()</code> (<code>tidyr</code>): Use to 'drill down' into nested information on <code>fields</code>, <code>lists</code>, <code>profiles</code>, or <code>taxa</code>
</p>
</li></ul>

<p>These galah versions all use lazy evaluation.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>galah::desc()</code> returns a <code>tibble</code> used by <code>arrange.data_request()</code> to arrange rows of a query.
</p>
</li>
<li> <p><code>galah::unnest()</code> returns an object of class <code>metadata_request</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+arrange.data_request">arrange()</a></code>, <code><a href="#topic+galah_call">galah_call()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Arrange grouped record counts by descending year
galah_call() |&gt;
  identify("perameles") |&gt;
  filter(year &gt; 2019) |&gt;
  count() |&gt;
  arrange(galah::desc(year)) |&gt;
  collect()

# Return values of field `basisOfRecord`
request_metadata() |&gt; 
  galah::unnest() |&gt; 
  filter(field == basisOfRecord) |&gt; 
  collect()
  
# Using `galah::unnest()` in this way is equivalent to:
show_all(fields, "basisOfRecord") |&gt; 
  show_values()

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
