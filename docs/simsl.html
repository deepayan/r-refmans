<!DOCTYPE html><html><head><title>Help for package simsl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simsl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chicago'><p>Air pollution dataset</p></a></li>
<li><a href='#der.link'><p>A subfunction used in estimation</p></a></li>
<li><a href='#fit.simsl'><p>Single-index models with a surface-link (workhorse function)</p></a></li>
<li><a href='#pred.simsl'><p>SIMSL prediction function</p></a></li>
<li><a href='#simsl'><p>Single-index models with a surface-link (main function)</p></a></li>
<li><a href='#warfarin'><p>Warfarin dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Single-Index Models with a Surface-Link</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Hyung Park, Eva Petkova, Thaddeus Tarpey, R. Todd Ogden</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hyung Park &lt;parkh15@nyu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of a single-index regression for optimizing individualized dose rules from an observational study. To model interaction effects between baseline covariates and a treatment variable defined on a continuum, we employ two-dimensional penalized spline regression on an index-treatment domain, where the index is defined as a linear combination of the covariates (a single-index). An unspecified main effect for the covariates is allowed, which can also be modeled through a parametric model. A unique contribution of this work is in the parsimonious single-index parametrization specifically defined for the interaction effect term. We refer to Park, Petkova, Tarpey, and Ogden (2020) &lt;<a href="https://doi.org/10.1111%2Fbiom.13320">doi:10.1111/biom.13320</a>&gt; (for the case of a discrete treatment) and Park, Petkova, Tarpey, and Ogden (2021) "A single-index model with a surface-link for optimizing individualized dose rules" &lt;<a href="https://arxiv.org/abs/2006.00267v2">arXiv:2006.00267v2</a>&gt; for detail of the method. The model can take a member of the exponential family as a response variable and can also take an ordinal categorical response. The main function of this package is simsl(). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>mgcv, stats</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-09 18:21:19 UTC; parkh15</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-12 14:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='chicago'>Air pollution dataset</h2><span id='topic+chicago'></span>

<h3>Description</h3>

<p>Daily air pollution and death rate data for Chicago
</p>


<h3>Format</h3>

<p>A data frame with 7 columns and 5114 rows; each row refers to one day; the columns correspond to:
</p>

<dl>
<dt>death</dt><dd><p> total deaths (per day).</p>
</dd>
<dt>pm10median</dt><dd><p> median particles in 2.5-10 per cubic m</p>
</dd>
<dt>pm25median</dt><dd><p> median particles &lt; 2.5 mg per cubic m (more dangerous).</p>
</dd>
<dt>o3median</dt><dd><p> Ozone in parts per billion</p>
</dd>
<dt>so2median</dt><dd><p> Median Sulpher dioxide measurement</p>
</dd>
<dt>time</dt><dd><p> time in days</p>
</dd>
<dt>tmpd</dt><dd><p> temperature in fahrenheit</p>
</dd>
</dl>


<h3>Details</h3>

<p>The data are from Peng and Welty (2004) and are available from R (R Core Team, 2019) package <code>gamair</code> (Wood, 2019).
</p>
<p>The daily death in the city of Chicago is recorded over a number of years (about 14 years). Each observation is a time series of daily mortality counts, indicating the number of deaths that occurred on each day.
</p>


<h3>Source</h3>

<p>The <code>chicago</code> dataset is available from package <code>gamair</code> (Wood, 2019).
</p>


<h3>References</h3>

<p>Peng, R.D. and Welty, L.J. (2004) The NMMAPSdata package. R News 4(2)
</p>
<p>Wood, S.N. (2017) Generalized Additive Models: An Introduction with R
</p>
<p>Wood, S.N. (2019) gamair: Data for ’GAMs: An introduction with R’. R package version 1.0.2
</p>

<hr>
<h2 id='der.link'>A subfunction used in estimation</h2><span id='topic+der.link'></span>

<h3>Description</h3>

<p>This function computes the 1st derivative of the surface-link function with respect to the argument associated with the pure interaction effect term of the smooth, using finite difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>der.link(g.fit, eps = 10^(-4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="der.link_+3A_g.fit">g.fit</code></td>
<td>
<p>a <code>mgcv::gam</code> object</p>
</td></tr>
<tr><td><code id="der.link_+3A_eps">eps</code></td>
<td>
<p>a small finite difference used in numerical differentiation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>fit.simsl</code>, <code>simsl</code>
</p>

<hr>
<h2 id='fit.simsl'>Single-index models with a surface-link (workhorse function)</h2><span id='topic+fit.simsl'></span>

<h3>Description</h3>

<p><code>fit.simsl</code> is the workhorse function for Single-index models with a surface-link (SIMSL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.simsl(y, A, X, Xm = NULL, family = "gaussian", R = NULL,
  bs = c("ps", "ps"), k = c(8, 8), m = list(NA, NA), sp = NULL,
  knots = NULL, sep.A.effect = FALSE, mc = c(TRUE, FALSE),
  method = "GCV.Cp", beta.ini = NULL, ind.to.be.positive = NULL,
  random.effect = FALSE, z = NULL, gamma = 1, pen.order = 0,
  lambda = 0, max.iter = 10, eps.iter = 0.01, trace.iter = TRUE,
  center.X = TRUE, scale.X = TRUE, uncons.final.fit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.simsl_+3A_y">y</code></td>
<td>
<p>a n-by-1 vector of treatment outcomes; y is a member of the exponential family; any distribution supported by <code>mgcv::gam</code>; y can also be an ordinal categorial response with <code>R</code> categories taking a value from 1 to <code>R</code>.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_a">A</code></td>
<td>
<p>a n-by-1 vector of treatment variable; each element is assumed to take a value on a continuum.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_x">X</code></td>
<td>
<p>a n-by-p matrix of baseline covarates.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_xm">Xm</code></td>
<td>
<p>a n-by-q design matrix associated with an X main effect model; the defult is <code>NULL</code> and it is taken as a vector of zeros</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_family">family</code></td>
<td>
<p>specifies the distribution of y; e.g., &quot;gaussian&quot;, &quot;binomial&quot;, &quot;poisson&quot;; can be any family supported by <code>mgcv::gam</code>; can also be &quot;ordinal&quot;, for an ordinal categorical response y.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_r">R</code></td>
<td>
<p>the number of response categories for the case of family = &quot;ordinal&quot;.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_bs">bs</code></td>
<td>
<p>basis type for the treatment (A) and single-index domains, respectively; the defult is &quot;ps&quot; (p-splines); any basis supported by <code>mgcv::gam</code> can be used, e.g., &quot;cr&quot; (cubic regression splines); see <code>mgcv::s</code> for detail.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_k">k</code></td>
<td>
<p>basis dimension for the treatment (A) and single-index domains, respectively.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_m">m</code></td>
<td>
<p>a length 2 list (e.g., m=list(c(2,3), c(2,2))), for the treatment (A) and single-index domains, respectively, where each element specifies the order of basis and penalty (note, for bs=&quot;ps&quot;, c(2,3) means a 2nd order P-spline basis (cubic spline) and a 3rd order difference penalty; the default &quot;NA&quot; sets c(2,2) for each domain); see <code>mgcv::s</code> for details.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_sp">sp</code></td>
<td>
<p>a vector of smoothing parameters;  Smoothing parameters must be supplied in the order that the smooth terms appear in the model formula (i.e., A, and then the single-index); negative elements indicate that the parameter should be estimated, and hence a mixture of fixed and estimated parameters is possible; see <code>mgcv::gam</code> for detail.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_knots">knots</code></td>
<td>
<p>a list containing user-specified knot values to be used for basis construction, for the treatment (A) and single-index domains, respectively.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_sep.a.effect">sep.A.effect</code></td>
<td>
<p>If <code>TRUE</code>, the g term of SIMSL is further decomposed into: the A main effect + the A-by-X interaction effect; the default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_mc">mc</code></td>
<td>
<p>a length 2 vector indicating which marginals (i.e., A and the single-index, respectively) should have centering (i.e., the sum-to-zero) constraints applied; the default is <code>mc = c(TRUE, FALSE)</code> (see <code>mgcv::te</code> for detail of the constraint), which is sufficient for the so-called &quot;orthogonality&quot; constraint of the SIMSL.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_method">method</code></td>
<td>
<p>the smoothing parameter estimation method; &quot;GCV.Cp&quot; to use GCV for unknown scale parameter and Mallows' Cp/UBRE/AIC for known scale; any method supported by <code>mgcv::gam</code> can be used.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_beta.ini">beta.ini</code></td>
<td>
<p>an initial value for <code>beta.coef</code>; a p-by-1 vector; the defult is <code>NULL</code>, in which case a linear model estimate is used.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_ind.to.be.positive">ind.to.be.positive</code></td>
<td>
<p>for identifiability of the solution <code>beta.coef</code>, the user can restrict the jth (e.g., j=1) component of <code>beta.coef</code> to be positive; by default, we match the &quot;overall&quot; sign of <code>beta.coef</code> with that of the linear estimate (i.e., the initial estimate), by restricting the inner product between the two to be positive.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_random.effect">random.effect</code></td>
<td>
<p>if <code>TRUE</code>, as part of the main effects, the user can incorporate z-specific random intercepts.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_z">z</code></td>
<td>
<p>a factor that specifies the random intercepts when <code>random.effect = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_gamma">gamma</code></td>
<td>
<p>increase this beyond 1 to produce smoother models. <code>gamma</code> multiplies the effective degrees of freedom in the GCV or UBRE/AIC (see <code>mgcv::gam</code> for detail); the default is 1.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_pen.order">pen.order</code></td>
<td>
<p>0 indicates the ridge penalty; 1 indicates the 1st difference penalty; 2 indicates the 2nd difference penalty, used in a penalized least squares (LS) estimation of <code>beta.coef</code>.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_lambda">lambda</code></td>
<td>
<p>a regularization parameter associated with the penalized LS for <code>beta.coef</code> update.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_max.iter">max.iter</code></td>
<td>
<p>an integer specifying the maximum number of iterations for <code>beta.coef</code> update.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_eps.iter">eps.iter</code></td>
<td>
<p>a value specifying the convergence criterion of algorithm.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_trace.iter">trace.iter</code></td>
<td>
<p>if <code>TRUE</code>, trace the estimation process and print the differences in <code>beta.coef</code>.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_center.x">center.X</code></td>
<td>
<p>if <code>TRUE</code>, center X to have zero mean.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_scale.x">scale.X</code></td>
<td>
<p>if <code>TRUE</code>, scale X to have unit variance.</p>
</td></tr>
<tr><td><code id="fit.simsl_+3A_uncons.final.fit">uncons.final.fit</code></td>
<td>
<p>if <code>TRUE</code>, once the convergence in the estimates of <code>beta.coef</code> is reached, include the main effect associated with the fitted single-index (beta.coef'X) to the final surface-link estimate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates a linear combination (a single-index) of covariates X, and captures a nonlinear interactive structure between the single-index and the treatment defined on a continuum via a smooth surface-link on the index-treatment domain.
</p>
<p>SIMSL captures the effect of covariates via a single-index and their interaction with the treatment via a 2-dimensional smooth link function.
Interaction effects are determined by shapes of the link function.
The model allows comparing different individual treatment levels and constructing individual treatment rules,
as functions of a biomarker signature (single-index), efficiently utilizing information on patient’s characteristics.
The resulting <code>simsl</code> object can be used to estimate an optimal dose rule for a new patient with pretreatment clinical information.
</p>


<h3>Value</h3>

<p>a list of information of the fitted SIMSL including
</p>
<table>
<tr><td><code>beta.coef</code></td>
<td>
<p> the estimated single-index coefficients.</p>
</td></tr> <tr><td><code>g.fit</code></td>
<td>
<p>a <code>mgcv:gam</code> object containing information about the estimated 2-dimensional link function as well as the X main effect model.</p>
</td></tr> <tr><td><code>beta.ini</code></td>
<td>
<p>the initial value used in the estimation of <code>beta.coef</code></p>
</td></tr> <tr><td><code>beta.path</code></td>
<td>
<p>solution path of <code>beta.coef</code> over the iterations</p>
</td></tr> <tr><td><code>d.beta</code></td>
<td>
<p>records the change in <code>beta.coef</code> over the solution path, <code>beta.path</code></p>
</td></tr> <tr><td><code>X.scale</code></td>
<td>
<p>sd of pretreatment covariates X</p>
</td></tr> <tr><td><code>X.center</code></td>
<td>
<p>mean of pretreatment covariates X</p>
</td></tr> <tr><td><code>A.range</code></td>
<td>
<p>range of the observed treatment variable A</p>
</td></tr> <tr><td><code>p</code></td>
<td>
<p>number of baseline covariates X</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>number of subjects</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Park, Petkova, Tarpey, Ogden
</p>


<h3>See Also</h3>

<p><code>pred.simsl</code>,  <code>fit.simsl</code>
</p>

<hr>
<h2 id='pred.simsl'>SIMSL prediction function</h2><span id='topic+pred.simsl'></span>

<h3>Description</h3>

<p>This function makes predictions from an estimated SIMSL, given a (new) set of covariates.
The function returns a set of predicted outcomes given the treatment values in a dense grid of treatment levels for each individual, and a recommended treatment level (assuming a larger value of the outcome is better).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.simsl(simsl.obj, newX = NULL, newA = NULL, newXm = NULL,
  single.index = NULL, L = 50, type = "link", maximize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.simsl_+3A_simsl.obj">simsl.obj</code></td>
<td>
<p>a <code>simsl</code> object</p>
</td></tr>
<tr><td><code id="pred.simsl_+3A_newx">newX</code></td>
<td>
<p>a (n-by-p) matrix of new values for the covariates X at which predictions are to be made.</p>
</td></tr>
<tr><td><code id="pred.simsl_+3A_newa">newA</code></td>
<td>
<p>a (n-by-L) matrix of new values for the treatment A at which predictions are to be made.</p>
</td></tr>
<tr><td><code id="pred.simsl_+3A_newxm">newXm</code></td>
<td>
<p>a (n-by-q) matrix of new values for the covariates associated with the fitted main effect Xm at which predictions are to be made.</p>
</td></tr>
<tr><td><code id="pred.simsl_+3A_single.index">single.index</code></td>
<td>
<p>a length n vector specifying new values for the single-index at which predictions are to be made; the default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pred.simsl_+3A_l">L</code></td>
<td>
<p>when <code>newA=NULL</code>, a value specifying the length of the grid of A at which predictions are to be made.</p>
</td></tr>
<tr><td><code id="pred.simsl_+3A_type">type</code></td>
<td>
<p>the type of prediction required; the default &quot;response&quot; is on the scale of the response variable; the alternative &quot;link&quot; is on the scale of the linear predictors.</p>
</td></tr>
<tr><td><code id="pred.simsl_+3A_maximize">maximize</code></td>
<td>
<p>the default is <code>TRUE</code>, assuming a larger value of the outcome is better; if <code>FALSE</code>, a smaller value is assumed to be prefered.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>pred.new</code></td>
<td>
<p>a (n-by-L) matrix of predicted values; each column represents a treatment dose.</p>
</td></tr>
<tr><td><code>trt.rule</code></td>
<td>
<p>a (n-by-1) vector of suggested treatment assignments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Park, Petkova, Tarpey, Ogden
</p>


<h3>See Also</h3>

<p><code>simsl</code>,<code>fit.simsl</code>
</p>

<hr>
<h2 id='simsl'>Single-index models with a surface-link (main function)</h2><span id='topic+simsl'></span>

<h3>Description</h3>

<p><code>simsl</code> is the wrapper function for fitting a single-index model with a surface-link (SIMSL).
The function estimates a linear combination (a single-index) of baseline covariates X, and models a nonlinear interactive structure between the single-index and a treatment variable defined on a continuum, by estimating a smooth link function on the index-treatment domain. The resulting <code>simsl</code> object can be used to estimate an optimal dose rule for a new patient with baseline clinical information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsl(y, A, X, Xm = NULL, family = "gaussian", R = NULL,
  bs = c("ps", "ps"), k = c(8, 8), m = list(NA, NA), sp = NULL,
  knots = NULL, sep.A.effect = FALSE, mc = c(TRUE, FALSE),
  method = "GCV.Cp", beta.ini = NULL, ind.to.be.positive = NULL,
  random.effect = FALSE, z = NULL, gamma = 1, pen.order = 0,
  lambda = 0, max.iter = 10, eps.iter = 0.01, trace.iter = TRUE,
  center.X = TRUE, scale.X = TRUE, uncons.final.fit = TRUE,
  bootstrap = FALSE, nboot = 200, boot.conf = 0.95, seed = 1357)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simsl_+3A_y">y</code></td>
<td>
<p>a n-by-1 vector of treatment outcomes; y is a member of the exponential family; any distribution supported by <code>mgcv::gam</code>; y can also be an ordinal categorial response with <code>R</code> categories taking a value from 1 to <code>R</code>.</p>
</td></tr>
<tr><td><code id="simsl_+3A_a">A</code></td>
<td>
<p>a n-by-1 vector of treatment variable; each element is assumed to take a value on a continuum.</p>
</td></tr>
<tr><td><code id="simsl_+3A_x">X</code></td>
<td>
<p>a n-by-p matrix of baseline covarates.</p>
</td></tr>
<tr><td><code id="simsl_+3A_xm">Xm</code></td>
<td>
<p>a n-by-q design matrix associated with an X main effect model; the defult is <code>NULL</code> and it is taken as a vector of zeros</p>
</td></tr>
<tr><td><code id="simsl_+3A_family">family</code></td>
<td>
<p>specifies the distribution of y; e.g., &quot;gaussian&quot;, &quot;binomial&quot;, &quot;poisson&quot;; can be any family supported by <code>mgcv::gam</code>; can also be &quot;ordinal&quot;, for an ordinal categorical response y.</p>
</td></tr>
<tr><td><code id="simsl_+3A_r">R</code></td>
<td>
<p>the number of response categories for the case of family = &quot;ordinal&quot;.</p>
</td></tr>
<tr><td><code id="simsl_+3A_bs">bs</code></td>
<td>
<p>basis type for the treatment (A) and single-index domains, respectively; the defult is &quot;ps&quot; (p-splines); any basis supported by <code>mgcv::gam</code> can be used, e.g., &quot;cr&quot; (cubic regression splines); see <code>mgcv::s</code> for detail.</p>
</td></tr>
<tr><td><code id="simsl_+3A_k">k</code></td>
<td>
<p>basis dimension for the treatment (A) and single-index domains, respectively.</p>
</td></tr>
<tr><td><code id="simsl_+3A_m">m</code></td>
<td>
<p>a length 2 list (e.g., m=list(c(2,3), c(2,2))), for the treatment (A) and single-index domains, respectively, where each element specifies the order of basis and penalty (note, for bs=&quot;ps&quot;, c(2,3) means a 2nd order P-spline basis (cubic spline) and a 3rd order difference penalty; the default &quot;NA&quot; sets c(2,2) for each domain); see <code>mgcv::s</code> for details.</p>
</td></tr>
<tr><td><code id="simsl_+3A_sp">sp</code></td>
<td>
<p>a vector of smoothing parameters;  Smoothing parameters must be supplied in the order that the smooth terms appear in the model formula (i.e., A, and then the single-index); negative elements indicate that the parameter should be estimated, and hence a mixture of fixed and estimated parameters is possible; see <code>mgcv::gam</code> for detail.</p>
</td></tr>
<tr><td><code id="simsl_+3A_knots">knots</code></td>
<td>
<p>a list containing user-specified knot values to be used for basis construction, for the treatment (A) and single-index domains, respectively.</p>
</td></tr>
<tr><td><code id="simsl_+3A_sep.a.effect">sep.A.effect</code></td>
<td>
<p>If <code>TRUE</code>, the g term of SIMSL is further decomposed into: the A main effect + the A-by-X interaction effect; the default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simsl_+3A_mc">mc</code></td>
<td>
<p>a length 2 vector indicating which marginals (i.e., A and the single-index, respectively) should have centering (i.e., the sum-to-zero) constraints applied; the default is <code>mc = c(TRUE, FALSE)</code> (see <code>mgcv::te</code> for detail of the constraint), which is sufficient for the so-called &quot;orthogonality&quot; constraint of the SIMSL.</p>
</td></tr>
<tr><td><code id="simsl_+3A_method">method</code></td>
<td>
<p>the smoothing parameter estimation method; &quot;GCV.Cp&quot; to use GCV for unknown scale parameter and Mallows' Cp/UBRE/AIC for known scale; any method supported by <code>mgcv::gam</code> can be used.</p>
</td></tr>
<tr><td><code id="simsl_+3A_beta.ini">beta.ini</code></td>
<td>
<p>an initial value for <code>beta.coef</code>; a p-by-1 vector; the defult is <code>NULL</code>, in which case a linear model estimate is used.</p>
</td></tr>
<tr><td><code id="simsl_+3A_ind.to.be.positive">ind.to.be.positive</code></td>
<td>
<p>for identifiability of the solution <code>beta.coef</code>, the user can restrict the jth (e.g., j=1) component of <code>beta.coef</code> to be positive; by default, we match the &quot;overall&quot; sign of <code>beta.coef</code> with that of the linear estimate (i.e., the initial estimate), by restricting the inner product between the two to be positive.</p>
</td></tr>
<tr><td><code id="simsl_+3A_random.effect">random.effect</code></td>
<td>
<p>if <code>TRUE</code>, as part of the main effects, the user can incorporate z-specific random intercepts.</p>
</td></tr>
<tr><td><code id="simsl_+3A_z">z</code></td>
<td>
<p>a factor that specifies the random intercepts when <code>random.effect = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simsl_+3A_gamma">gamma</code></td>
<td>
<p>increase this beyond 1 to produce smoother models. <code>gamma</code> multiplies the effective degrees of freedom in the GCV or UBRE/AIC (see <code>mgcv::gam</code> for detail); the default is 1.</p>
</td></tr>
<tr><td><code id="simsl_+3A_pen.order">pen.order</code></td>
<td>
<p>0 indicates the ridge penalty; 1 indicates the 1st difference penalty; 2 indicates the 2nd difference penalty, used in a penalized least squares (LS) estimation of <code>beta.coef</code>.</p>
</td></tr>
<tr><td><code id="simsl_+3A_lambda">lambda</code></td>
<td>
<p>a regularization parameter associated with the penalized LS for <code>beta.coef</code> update.</p>
</td></tr>
<tr><td><code id="simsl_+3A_max.iter">max.iter</code></td>
<td>
<p>an integer specifying the maximum number of iterations for <code>beta.coef</code> update.</p>
</td></tr>
<tr><td><code id="simsl_+3A_eps.iter">eps.iter</code></td>
<td>
<p>a value specifying the convergence criterion of algorithm.</p>
</td></tr>
<tr><td><code id="simsl_+3A_trace.iter">trace.iter</code></td>
<td>
<p>if <code>TRUE</code>, trace the estimation process and print the differences in <code>beta.coef</code>.</p>
</td></tr>
<tr><td><code id="simsl_+3A_center.x">center.X</code></td>
<td>
<p>if <code>TRUE</code>, center X to have zero mean.</p>
</td></tr>
<tr><td><code id="simsl_+3A_scale.x">scale.X</code></td>
<td>
<p>if <code>TRUE</code>, scale X to have unit variance.</p>
</td></tr>
<tr><td><code id="simsl_+3A_uncons.final.fit">uncons.final.fit</code></td>
<td>
<p>if <code>TRUE</code>, once the convergence in the estimates of <code>beta.coef</code> is reached, include the main effect associated with the fitted single-index (beta.coef'X) to the final surface-link estimate.</p>
</td></tr>
<tr><td><code id="simsl_+3A_bootstrap">bootstrap</code></td>
<td>
<p>if <code>TRUE</code>, compute bootstrap confidence intervals for the single-index coefficients, <code>beta.coef</code>; the default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simsl_+3A_nboot">nboot</code></td>
<td>
<p>when <code>bootstrap=TRUE</code>, a value specifying the number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="simsl_+3A_boot.conf">boot.conf</code></td>
<td>
<p>a value specifying the confidence level of the bootstrap confidence intervals; the defult is <code>boot.conf = 0.95</code>.</p>
</td></tr>
<tr><td><code id="simsl_+3A_seed">seed</code></td>
<td>
<p>when  <code>bootstrap=TRUE</code>, randomization seed used in bootstrap resampling.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SIMSL captures the effect of covariates via a single-index and their interaction with the treatment via a 2-dimensional smooth link function.
Interaction effects are determined by shapes of the link surface.
The SIMSL allows comparing different individual treatment levels and constructing individual treatment rules,
as functions of a biomarker signature (single-index), efficiently utilizing information on patient’s characteristics.
The resulting <code>simsl</code> object can be used to estimate an optimal dose rule for a new patient with baseline clinical information.
</p>


<h3>Value</h3>

<p>a list of information of the fitted SIMSL including
</p>
<table>
<tr><td><code>beta.coef</code></td>
<td>
<p> the estimated single-index coefficients.</p>
</td></tr> <tr><td><code>g.fit</code></td>
<td>
<p>a <code>mgcv:gam</code> object containing information about the estimated 2-dimensional link function.</p>
</td></tr> <tr><td><code>beta.ini</code></td>
<td>
<p>the initial value used in the estimation of <code>beta.coef</code></p>
</td></tr> <tr><td><code>beta.path</code></td>
<td>
<p>solution path of <code>beta.coef</code> over the iterations</p>
</td></tr> <tr><td><code>d.beta</code></td>
<td>
<p>records the change in <code>beta.coef</code> over the solution path, <code>beta.path</code></p>
</td></tr> <tr><td><code>X.scale</code></td>
<td>
<p>sd of pretreatment covariates X</p>
</td></tr> <tr><td><code>X.center</code></td>
<td>
<p>mean of pretreatment covariates X</p>
</td></tr> <tr><td><code>A.range</code></td>
<td>
<p>range of the observed treatment variable A</p>
</td></tr> <tr><td><code>p</code></td>
<td>
<p>number of baseline covariates X</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>number of subjects</p>
</td></tr> <tr><td><code>boot.ci</code></td>
<td>
<p><code>boot.conf</code>-level bootstrap CIs (LB, UB) associated with <code>beta.coef</code></p>
</td></tr> <tr><td><code>boot.mat</code></td>
<td>
<p>a (nboot x p) matrix of bootstrap estimates of  <code>beta.coef</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Park, Petkova, Tarpey, Ogden
</p>


<h3>See Also</h3>

<p><code>pred.simsl</code>,  <code>fit.simsl</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
n.test &lt;- 500


## simulation 1
# generate training data
p &lt;- 30
n &lt;- 200
X &lt;- matrix(runif(n*p,-1,1),ncol=p)
A &lt;- runif(n,0,2)
D_opt &lt;- 1 + 0.5*X[,2] + 0.5*X[,1]
mean.fn &lt;- function(X, D_opt, A){ 8 + 4*X[,1] - 2*X[,2] - 2*X[,3] - 25*((D_opt-A)^2) }
mu &lt;-   mean.fn(X, D_opt, A)
y &lt;- rnorm(length(mu),mu,1)
# fit SIMSL
simsl.obj &lt;- simsl(y=y, A=A, X=X)

# generate testing data
X.test &lt;- matrix(runif(n.test*p,-1,1),ncol=p)
A.test &lt;- runif(n.test,0,2)
f_opt.test &lt;- 1 + 0.5*X.test[,2] + 0.5*X.test[,1]
pred &lt;- pred.simsl(simsl.obj, newX= X.test)  # make prediction based on the estimated SIMSL
value &lt;- mean(8 + 4*X.test[,1] - 2*X.test[,2] - 2*X.test[,3] - 25*((f_opt.test- pred$trt.rule)^2))
value  # "value" of the estimated treatment rule; the "oracle" value is 8.


## simulation 2
p &lt;- 10
n &lt;- 400
# generate training data
X &lt;- matrix(runif(n*p,-1,1),ncol=p)
A &lt;- runif(n,0,2)
f_opt &lt;- I(X[,1] &gt; -0.5)*I(X[,1] &lt; 0.5)*0.6 + 1.2*I(X[,1] &gt; 0.5) +
 1.2*I(X[,1] &lt; -0.5) + X[,4]^2 + 0.5*log(abs(X[,7])+1) - 0.6
mu &lt;-   8 + 4*cos(2*pi*X[,2]) - 2*X[,4] - 8*X[,5]^3 - 15*abs(f_opt-A)
y  &lt;- rnorm(length(mu),mu,1)
Xq &lt;- cbind(X, X^2)  # include a quadratic term
# fit SIMSL
simsl.obj &lt;- simsl(y=y, A=A, X=Xq)

# generate testing data
X.test &lt;- matrix(runif(n.test*p,-1,1),ncol=p)
A.test &lt;- runif(n.test,0,2)
f_opt.test &lt;- I(X.test[,1] &gt; -0.5)*I(X.test[,1] &lt; 0.5)*0.6 + 1.2*I(X.test[,1] &gt; 0.5) +
 1.2*I(X.test[,1] &lt; -0.5) + X.test[,4]^2 + 0.5*log(abs(X.test[,7])+1) - 0.6
Xq.test &lt;- cbind(X.test, X.test^2)
pred &lt;- pred.simsl(simsl.obj, newX= Xq.test)  # make prediction based on the estimated SIMSL
value &lt;- mean(8 + 4*cos(2*pi*X.test[,2]) - 2*X.test[,4] - 8*X.test[,5]^3 -
              15*abs(f_opt.test-pred$trt.rule))
value  # "value" of the estimated treatment rule; the "oracle" value is 8.



 ### air pollution data application
 data(chicago); head(chicago)
 chicago &lt;- chicago[,-3][complete.cases(chicago[,-3]), ]
 chicago &lt;- chicago[-c(2856:2859), ]  # get rid of the gross outliers in y
 chicago &lt;- chicago[-which.max(chicago$pm10median), ]  # get rid of the gross outliers in x

 # create lagged variables
 lagard &lt;- function(x,n.lag=5) {
   n &lt;- length(x); X &lt;- matrix(NA,n,n.lag)
   for (i in 1:n.lag) X[i:n,i] &lt;- x[i:n-i+1]
   X
 }
 chicago$pm10 &lt;- lagard(chicago$pm10median)
 chicago &lt;- chicago[complete.cases(chicago), ]
 # create season varaible
 chicago$time.day &lt;- round(chicago$time %%  365)

 # fit SIMSL for modeling the season-by-pm10 interactions on their effects on outcomes
 simsl.obj &lt;- simsl(y=chicago$death, A=chicago$time.day, X=chicago[,7], bs=c("cc","ps"),
                    ind.to.be.positive = 1, family="poisson", method = "REML",
                    bootstrap =FALSE) # bootstrap = TRUE
 simsl.obj$beta.coef  # the estimated single-index coefficients
 summary(simsl.obj$g.fit)
 #round(simsl.obj$boot.ci,3)
 mgcv::vis.gam(simsl.obj$g.fit, view=c("A","single.index"), theta=-135, phi = 30,
               color="heat", se=2,ylab = "single-index", zlab = " ",
               main=expression(paste("Interaction surface g")))



 ### Warfarin data application
 data(warfarin)
 X &lt;- warfarin$X
 A &lt;- warfarin$A
 y &lt;- -abs(warfarin$INR - 2.5)  # the target INR is 2.5
 X[,1:3] &lt;- scale(X[,1:3]) # standardize continuous variables

 # Estimate the main effect, using an additive model
 mu.fit &lt;- mgcv::gam(y-mean(y)  ~ X[, 4:13] +
                       s(X[,1], k=5, bs="ps")+
                       s(X[,2], k=5, bs="ps") +
                       s(X[,3], k=5, bs="ps"), method="REML")
 summary(mu.fit)
 mu.hat &lt;- predict(mu.fit)
 # fit SIMSL
 simsl.obj &lt;- simsl(y, A, X, Xm= mu.hat, scale.X = FALSE, center.X=FALSE, method="REML",
                    bootstrap = FALSE) # bootstrap = TRUE
 simsl.obj$beta.coef
 #round(simsl.obj$boot.ci,3)
 mgcv::vis.gam(simsl.obj$g.fit, view=c("A","single.index"), theta=52, phi = 18,
               color="heat", se=2, ylab = "single-index", zlab = "Y",
               main=expression(paste("Interaction surface g")))


</code></pre>

<hr>
<h2 id='warfarin'>Warfarin dataset</h2><span id='topic+warfarin'></span>

<h3>Description</h3>

<p>The dataset provided by International Warfarin Pharmacogenetics Consortium et al. (2009). Warfarin is an anticoagulant agent widely used as a medicine to treat blood clots and prevent forming new harmful blood clots.
</p>


<h3>Format</h3>

<p>A list containing <code>INR</code>, <code>A</code>, <code>X</code>:
</p>

<dl>
<dt>INR</dt><dd><p>a vector of treatment outcomes of the study (INR; International Normalized Ratio)</p>
</dd>
<dt>A</dt><dd><p>a vector of therapeutic warfarin dosages</p>
</dd>
<dt>X</dt><dd><p>a data frame consist of 13 patient characteristics</p>
</dd>
</dl>


<h3>Details</h3>

<p>The dataset onsists of 1780 subjects (after removing patients with missing data and data cleaning), including information on patient covariates (X), final therapeutic warfarin dosages (A), and patient outcomes (INR, International Normalized Ratio).
</p>
<p>There are 13 covariates in the dataset: weight (X1), height (X2), age (X3), use of the cytochrome P450 enzyme inducers (X4; the enzyme inducers considered in this analysis includes phenytoin, carbamazepine, and rifampin), use of amiodarone (X5), gender (X6; 1 for male, 0 for female), African or black race (X7), Asian race (X8), the VKORC1 A/G genotype (X9), the VKORC1 A/A genotype (X10), the CYP2C9 1/2 genotype (X11), the CYP2C9 1/3 genotype (X12), and the other CYP2C9 genotypes (except the CYP2C9 1/1 genotype which is taken as the baseline genotype) (X13).
</p>
<p>The details of these covariate information are given in International Warfarin Pharmacogenetics Consortium et al. (2009).
</p>


<h3>Source</h3>

<p>The data can be downloaded from https://www.pharmgkb.org/downloads/.
</p>


<h3>References</h3>

<p>International Warfarin Pharmacogenetics Consortium, Klein, T., Altman, R., Eriksson, N., Gage, B., Kimmel, S., Lee, M., Limdi, N., Page, D., Roden, D., Wagner, M., Caldwell, M., and Johnson, J. (2009). Estimation of the warfarin dose with clinical and pharmacogenetic data. The New England Journal of Medicine 360:753–674
</p>
<p>Chen, G., Zeng, D., and Kosorok, M. R. (2016). Personalized dose finding using outcome wieghted learning. Journal of the American Medical Association 111:1509–1547.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
