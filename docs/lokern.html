<!DOCTYPE html><html><head><title>Help for package lokern</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lokern}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#glkerns'><p>Kernel Regression Smoothing with Adaptive Plug-in Bandwidth</p></a></li>
<li><a href='#KernS-methods'><p>Methods for (&quot;KernS&quot; classed) Results of lokerns() and glkerns()</p></a></li>
<li><a href='#lokerns'><p>Kernel Regression Smoothing with Local Plug-in Bandwidth</p></a></li>
<li><a href='#varNPreg'><p>Nonparametric Variance Estimator</p></a></li>
<li><a href='#xSim'><p>Simulated Linear plus Exponential Peak</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1-11</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Kernel Regression Smoothing with Local or Global Plug-in
Bandwidth</td>
</tr>
<tr>
<td>Author:</td>
<td>Eva Herrmann &lt;eherrmann@mathematik.tu-darmstadt.de&gt; (F77 &amp; S original);
	Packaged for R and enhanced by Martin Maechler</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, utils, sfsmisc (&ge; 1.0-12)</td>
</tr>
<tr>
<td>Description:</td>
<td>Kernel regression smoothing with adaptive local or global plug-in
	     bandwidth selection.</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://curves-etc.r-forge.r-project.org/">https://curves-etc.r-forge.r-project.org/</a>,
<a href="https://r-forge.r-project.org/R/?group_id=846">https://r-forge.r-project.org/R/?group_id=846</a>,
<a href="https://r-forge.r-project.org/scm/viewvc.php/pkg/lokern/?root=curves-etc">https://r-forge.r-project.org/scm/viewvc.php/pkg/lokern/?root=curves-etc</a>,
svn://svn.r-forge.r-project.org/svnroot/curves-etc/pkg/lokern</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://r-forge.r-project.org/R/?group_id=846">https://r-forge.r-project.org/R/?group_id=846</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-18 10:11:57 UTC; maechler</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-18 10:52:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='glkerns'>Kernel Regression Smoothing with Adaptive Plug-in Bandwidth</h2><span id='topic+glkerns'></span><span id='topic+glkerns.default'></span><span id='topic+glkerns.formula'></span>

<h3>Description</h3>

<p>Nonparametric estimation of regression functions and their derivatives
with kernel regression estimators and automatically adapted
(<b>gl</b>obal) plug-in bandwidth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glkerns(x, ...)

## Default S3 method:
glkerns(x, y=NULL, deriv = 0, n.out = 300, x.out=NULL, x.inOut = TRUE,
        korder= deriv + 2, hetero=FALSE, is.rand=TRUE,
        inputb = is.numeric(bandwidth) &amp;&amp; all(bandwidth &gt; 0),
        m1 = 400, xl=NULL, xu=NULL,
        s=NULL, sig=NULL, bandwidth=NULL, trace.lev = 0, ...)

## S3 method for class 'formula'
glkerns(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glkerns_+3A_x">x</code></td>
<td>
<p>vector of design points, not necessarily ordered.</p>
</td></tr>
<tr><td><code id="glkerns_+3A_y">y</code></td>
<td>
<p>vector of observations of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="glkerns_+3A_deriv">deriv</code></td>
<td>
<p>order of derivative of the regression function to be
estimated.  Only deriv=0,1,2 are allowed for automatic smoothing,
whereas deriv=0,1,2,3,4 is possible when smoothing with a global input
bandwidth.  The default value is deriv=0.</p>
</td></tr>
<tr><td><code id="glkerns_+3A_n.out">n.out</code></td>
<td>
<p>number of output design points where the function has to
be estimated; default is <code>n.out=300</code>.</p>
</td></tr>
<tr><td><code id="glkerns_+3A_x.out">x.out</code></td>
<td>
<p>vector of output design points where the function has to
be estimated.  The default is an equidistant grid of n.out points
from min(x) to max(x).</p>
</td></tr>
<tr><td><code id="glkerns_+3A_x.inout">x.inOut</code></td>
<td>
<p>logical or character string indicating if <code>x.out</code>
should contain the input <code>x</code> values.
Note that this argument did not exist, equivalently to being
<code>FALSE</code>, up to <span class="pkg">lokern</span> version <code>1.0-9</code>.
</p>
<p>In order for <code><a href="stats.html#topic+residuals">residuals</a>()</code> or <code><a href="stats.html#topic+fitted">fitted</a>()</code>
methods to be applicable, it must be <code>TRUE</code> or a character
string specifying one of the <code>methods</code>s of
<code><a href="sfsmisc.html#topic+seqXtend">seqXtend</a></code> (package <a href="https://CRAN.R-project.org/package=sfsmisc"><span class="pkg">sfsmisc</span></a>). The default,
<code>TRUE</code> corresponds to method <code>"aim"</code>.
</p>
</td></tr>
<tr><td><code id="glkerns_+3A_korder">korder</code></td>
<td>

<p>nonnegative integer giving the kernel order <code class="reqn">k</code>; it defaults to
<code>korder = deriv+2</code> or <code class="reqn">k = \nu + 2</code> where <code class="reqn">k - \nu</code>
must be even.  The maximal possible values are for automatic
smoothing, <code class="reqn">k \le 4</code>, whereas for smoothing with input
bandwidth, <code class="reqn">k \le 6</code>.
</p>
</td></tr>
<tr><td><code id="glkerns_+3A_hetero">hetero</code></td>
<td>
<p>logical: if TRUE, heteroscedastic error variables are
assumed for variance estimation, if FALSE the variance estimation is
optimized for homoscedasticity.  Default value is hetero=FALSE.
</p>
</td></tr>
<tr><td><code id="glkerns_+3A_is.rand">is.rand</code></td>
<td>

<p>logical: if <code>TRUE</code> (default), random x are assumed and the
s-array of the convolution estimator is computed as smoothed
quantile estimators in order to adapt this variability.  If FALSE,
the s-array is choosen as mid-point sequences as the classical
Gasser-Mueller estimator, this will be better for equidistant and
fixed design.
</p>
</td></tr>
<tr><td><code id="glkerns_+3A_inputb">inputb</code></td>
<td>

<p>logical: if true, a local input bandwidth array is used; if
<code>FALSE</code> (by default when <code>bandwidth</code> is not specified), a
data-adaptive local plug-in bandwidths array is calculated and used.
</p>
</td></tr>
<tr><td><code id="glkerns_+3A_m1">m1</code></td>
<td>

<p>integer, the number of grid points for integral approximation when
estimating the plug-in bandwidth. The default, 400, may be increased
if a very large number of observations are available.
</p>
</td></tr>
<tr><td><code id="glkerns_+3A_xl">xl</code>, <code id="glkerns_+3A_xu">xu</code></td>
<td>

<p>numeric (scalars), the lower and upper bounds for integral
approximation and variance estimation when estimating the plug-in
bandwidth. By default (when <code>xl</code> and <code>xu</code> are not specified),
the 87% middle part of <code class="reqn">[xmin,xmax]</code> is used.
</p>
</td></tr>
<tr><td><code id="glkerns_+3A_s">s</code></td>
<td>

<p>s-array of the convolution kernel estimator. If it is not given by input
it is calculated as midpoint-sequence of the ordered design points for
<code>is.rand=FALSE</code> or as quantiles estimators of the design density
for <code>is.rand=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="glkerns_+3A_sig">sig</code></td>
<td>
<p>variance of the error variables.  If it is not given by
input or if <code>hetero=TRUE</code> it is calculated by a
nonparametric variance estimator.</p>
</td></tr>
<tr><td><code id="glkerns_+3A_bandwidth">bandwidth</code></td>
<td>

<p><em>global</em> bandwidth for kernel regression estimation.  If it is
not given by input or if <code>inputb=FALSE</code> a data-adaptive global
plug-in bandwidth is used instead.</p>
</td></tr>
<tr><td><code id="glkerns_+3A_trace.lev">trace.lev</code></td>
<td>
<p>integer indicating how much the internal (Fortran
level) computations should be &ldquo;traced&rdquo;, i.e., be reported.
The default, <code>0</code>, does not print anything.</p>
</td></tr>
<tr><td><code id="glkerns_+3A_formula">formula</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> of the form <code>y ~ pred</code>,
specifying the response variable <code>y</code> and predictor variable
<code>pred</code> which must be in <code>data</code>.</p>
</td></tr>
<tr><td><code id="glkerns_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="glkerns_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="glkerns_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to
<code>getOption("na.action")</code>.</p>
</td></tr>
<tr><td><code id="glkerns_+3A_...">...</code></td>
<td>
<p>for the <code>formula</code> method: Optional arguments all
passed to <code>glkerns.default()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls an efficient and fast algorithm for automatically
adaptive nonparametric regression estimation with a kernel method.
</p>
<p>Roughly spoken, the method performs a local averaging of the
observations when estimating the regression function. Analogously, one
can estimate derivatives of small order of the regression function.
Crucial for the kernel regression estimation used here is the choice
of a global bandwidth. Too small bandwidths will lead to a wiggly
curve, too large ones will smooth away important details.  The
function glkerns calculates an estimator of the regression function or
derivatives of the regression function with an automatically chosen
global plugin bandwidth. It is also possible to use global bandwidths
which are specified by the user.
</p>
<p>Main ideas of the plugin method are to estimate the optimal bandwidths
by estimating the asymptotically optimal mean integrated squared error
optimal bandwidths. Therefore, one has to estimate the variance for
homoscedastic error variables and a functional of a smooth variance
function for heteroscedastic error variables, respectively. Also, one
has to estimate an integral functional of the squared <code class="reqn">k</code>-th derivative
of the regression function (<code class="reqn">k=\code{korder}</code>) for the global bandwidth.
</p>
<p>Here, a further kernel estimator for this derivative is used with a
bandwidth which is adapted iteratively to the regression function.  A
convolution form of the kernel estimator for the regression function
and its derivatives is used. Thereby one can adapt the s-array for
random design. Using this estimator leads to an asymptotically minimax
efficient estimator for fixed and random design.  Polynomial kernels
and boundary kernels are used with a fast and stable updating
algorithm for kernel regression estimation.  More details can be found
in the references and previously at
Biostats, University of Zurich under &lsquo;<span class="file">software/kernel.html</span>&rsquo;, but no longer.





</p>


<h3>Value</h3>

<p>an object of class(es) <code>c("glkerns", "KernS")</code>, which is
a list including used parameters and estimator, containing among others
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>vector of ordered design points.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector of observations ordered with respect to x.</p>
</td></tr>
<tr><td><code>bandwidth</code></td>
<td>
<p>bandwidth which was used for kernel regression estimation.</p>
</td></tr>
<tr><td><code>x.out</code></td>
<td>
<p>vector of ordered output design points.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>vector of estimated regression function or its derivative
(at <code>x.out</code>).</p>
</td></tr>
<tr><td><code>sig</code></td>
<td>
<p>variance estimation which was used for calculating the
plug-in bandwidth</p>
</td></tr>
<tr><td><code>deriv</code></td>
<td>
<p>derivative of the regression function which was estimated.</p>
</td></tr>
<tr><td><code>korder</code></td>
<td>
<p>order of the kernel function which was used.</p>
</td></tr>
<tr><td><code>xl</code></td>
<td>
<p>lower bound for integral approximation and variance estimation.</p>
</td></tr>
<tr><td><code>xu</code></td>
<td>
<p>upper bound for integral approximation and variance estimation.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>vector of midpoint values used for the convolution kernel
regression estimator.</p>
</td></tr>
</table>


<h3>Author(s)</h3>


<p>- Eva Herrmann, TU Darmstadt(1995-1997): principal code (origianl Fortran and S+),
see the references.
<br />
- Martin Maechler, 2001 ff: translated to R, created the package, refactored
&lsquo;<span class="file">src/</span>&rsquo;, added class, methods (predict, plot ..), arguments, docu,
tweaks, help, examples, etc.
<br />
- The <code>formula</code> method was added in 2014 after proposals by Andri Signorell.
</p>


<h3>References</h3>

<p>- global plug-in bandwidth estimator:<br />
Theo Gasser, Alois Kneip &amp; Walter Koehler (1991)
A flexible and fast method for automatic smoothing.
<em>Journal of the American Statistical Association</em> <b>86</b>, 643&ndash;652.
<a href="https://doi.org/10.2307/2290393">doi:10.2307/2290393</a> 
</p>
<p>Muller, H.-G. (1984)
Smooth optimum kernel estimators of densities, regression curves and modes.
<em>The Annals of Statistics</em> <b>12</b>, 766&ndash;774.
</p>
<p>- variance estimation:<br />
Theo Gasser, Lothar Sroka &amp; Christine Jennen-Steinmetz (1986)
Residual Variance and Residual Pattern in Nonlinear Regression.
<em>Biometrika</em> <b>73</b>, 625&ndash;633. <a href="https://doi.org/10.2307/2336527">doi:10.2307/2336527</a>
</p>
<p>- adapting heteroscedasticity:<br />
E. Herrmann (1997)
Local bandwidth choice in kernel regression estimation.
<em>Journal of Graphical and Computational Statistics</em> <b>6</b>, 35&ndash;54.
</p>
<p>- fast algorithm for kernel regression estimator:<br />
T. Gasser &amp; A. Kneip (1989)
discussion of Buja, A., Hastie, T. and Tibshirani, R.: Linear smoothers
and additive models, <em>The Annals of Statistics</em> <b>17</b>, 532&ndash;535.
</p>
<p>B. Seifert, M. Brockmann, J. Engel &amp; T. Gasser (1994)
Fast algorithms for nonparametric curve estimation.
<em>J. Computational and Graphical Statistics</em> <b>3</b>, 192&ndash;213.
</p>
<p>- on the special kernel estimator for random design point:<br />
E. Herrmann (1996)
<em>On the convolution type kernel regression estimator</em>;
Preprint 1833, FB Mathematik, Technische Universitaet Darmstadt;
currently available from
<a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.32.6383">https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.32.6383</a>


</p>


<h3>See Also</h3>

<p><code><a href="#topic+lokerns">lokerns</a></code> for <b>lo</b>cal bandwidth computation.
<code><a href="#topic+plot.KernS">plot.KernS</a></code> documents all the <code><a href="utils.html#topic+methods">methods</a></code> for <code>"KernS"</code>
classed objects.
</p>
<p>The <code><a href="utils.html#topic+demo">demo</a></code> for computing derivatives, <code>demo("glk-derivs")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(xSim)## linear plus an exponential peak, see help(xSim)
n &lt;- length(xSim)
tt &lt;- ((1:n) - 1/2)/n # equidistant x ==&gt; is.rand = FALSE
gk &lt;- glkerns(tt, xSim, is.rand = FALSE)
gk # print method
plot(gk) # nice plot() method
if(require("sfsmisc")) {
  TA.plot(gk)
} else { plot(residuals(gk) ~ fitted(gk)); abline(h = 0, lty=2) }
qqnorm(residuals(gk), ylab = "residuals(gk)")

cat("glkerns() bandwidth:",format(gk$bandwidth, dig=10),"\n")
## local bandwidth: fit is very similar :
(lk &lt;- lokerns(tt, xSim, is.rand = FALSE))
nobs(lk)

cols &lt;- c(gl="PaleGreen", lo="Firebrick")
plot(lk$x.out, lk$bandwidth, axes = FALSE, xlab="", ylab="",
     ylim=c(0,max(lk$bandwidth)), type="h", col = "gray90")
axis(4); mtext("bandwidth(s)", side=4)
lines(lk$x.out, lk$bandwidth, col = cols["lo"], lty = 3)
abline(     h = gk$bandwidth, col = cols["gl"], lty = 4)
par(new=TRUE)
plot(tt, xSim, main = "global and local bandwidth kernel regression")
lines(gk$x.out, gk$est, col = cols["gl"], lwd = 1.5)
lines(lk$x.out, lk$est, col = cols["lo"])
# the red curve (local bw) is very slightly better
legend(0.7,4.4, c("global bw","local bw"), col = cols, lwd=1)

## This should look
op &lt;- par(mfrow = c(3,1), mar = .1 + c(4,4,2,1), oma = c(0,0,3,0),
          mgp = c(1.5, 0.6,0))
plot(gk, main = expression(paste("Data &amp; ", hat(f))))
## calling extra plot() method
gk1 &lt;- glkerns(tt, xSim, deriv = 1, is.rand = FALSE)
plot(gk1$x.out, gk1$est, col = "green", lwd = 1.5, type = "l",
     main = expression(widehat(paste(f,"'"))))
abline(h=0, col="gray", lty = 3)
gk2 &lt;- glkerns(tt, xSim, deriv = 2, is.rand = FALSE)
plot(gk2$x.out, gk2$est, col = "orange", lwd = 1.5, type = "l",
     main = expression(widehat(paste(f,"''"))))
abline(h=0, col="gray", lty = 3)
mtext("Example from www.unizh.ch/biostat/..../kernf77.html",side=3,
      outer = TRUE, cex = 1, font = par("font.main"))

par(op)
data(cars)
plot(dist ~ speed, data = cars,
     main = "Global Plug-In Bandwidth")
## these two are equivalent
m1glk &lt;- glkerns(dist ~ speed, data = cars)
m.glk &lt;- glkerns(cars$ speed, cars$ dist)
lines(m.glk, col=2) # using the lines() method
mtext(paste("bandwidth = ", format(m.glk$bandwidth, dig = 4)))
ii &lt;- names(m1glk) != "call"
stopifnot(all.equal(m1glk[ii], m.glk[ii], tol = 1e-15))
</code></pre>

<hr>
<h2 id='KernS-methods'>Methods for (&quot;KernS&quot; classed) Results of lokerns() and glkerns()</h2><span id='topic+fitted.KernS'></span><span id='topic+lines.KernS'></span><span id='topic+plot.KernS'></span><span id='topic+predict.KernS'></span><span id='topic+print.KernS'></span><span id='topic+residuals.KernS'></span>

<h3>Description</h3>

<p>Methods for results of <code><a href="#topic+glkerns">glkerns</a>()</code> and
<code><a href="#topic+lokerns">lokerns</a>()</code> which are of (S3) class <code>"KernS"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KernS'
fitted(object, ...)
## S3 method for class 'KernS'
plot(x, type = "l", lwd = 2.5, col = 3, ...)
## S3 method for class 'KernS'
predict(object, x, deriv = object[["deriv"]],
        korder = deriv+2, trace.lev = 0, ...)
## S3 method for class 'KernS'
print(x, digits = getOption("digits"), ...)
## S3 method for class 'KernS'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KernS-methods_+3A_x">x</code>, <code id="KernS-methods_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object, of S3 class <code>"KernS"</code>, typically
result either from <code><a href="#topic+glkerns">glkerns</a>()</code> or <code><a href="#topic+lokerns">lokerns</a>()</code>.</p>
</td></tr>
<tr><td><code id="KernS-methods_+3A_type">type</code>, <code id="KernS-methods_+3A_lwd">lwd</code>, <code id="KernS-methods_+3A_col">col</code></td>
<td>
<p>arguments for <code>plot()</code> <em>only</em> for the
case when <code>x$deriv</code> is <em>not</em> 0.</p>
</td></tr>
<tr><td><code id="KernS-methods_+3A_deriv">deriv</code></td>
<td>
<p>integer, <code class="reqn">\ge 0</code>, specifiying order of
derivative that should be predicted.</p>
</td></tr>
<tr><td><code id="KernS-methods_+3A_korder">korder</code></td>
<td>
<p>nonnegative integer giving the kernel order; see
<code><a href="#topic+lokerns">lokerns</a></code> or <code><a href="#topic+glkerns">glkerns</a></code>.</p>
</td></tr>
<tr><td><code id="KernS-methods_+3A_digits">digits</code></td>
<td>
<p>number of significant digits, see <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
<tr><td><code id="KernS-methods_+3A_trace.lev">trace.lev</code></td>
<td>
<p>integer; level of tracing of Fortran level
computations; see <code><a href="#topic+lokerns">lokerns</a></code>.</p>
</td></tr>
<tr><td><code id="KernS-methods_+3A_...">...</code></td>
<td>
<p>potentially further arguments passed to and from
methods.  For the <code>plot(*, deriv=0)</code> method, these are passed to
<code><a href="sfsmisc.html#topic+plotDS">plotDS</a></code> from package <a href="https://CRAN.R-project.org/package=sfsmisc"><span class="pkg">sfsmisc</span></a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>fitted()</code> and <code>residuals()</code> rely on
<code>x.inOut</code> having been true or <code>x.out</code> having contained the
data <code>x</code>, in the <code><a href="#topic+lokerns">lokerns</a></code> or <code><a href="#topic+glkerns">glkerns</a></code>
call.
</p>
<p>The <code>plot()</code> method calls <code><a href="sfsmisc.html#topic+plotDS">plotDS</a></code> from
package <a href="https://CRAN.R-project.org/package=sfsmisc"><span class="pkg">sfsmisc</span></a>.
</p>
<p><code>predict(object, x, deriv)</code> when either some <code>x</code> are not in
<code>x.out</code> or <code>deriv</code> is not 0, basically recalls the original
<code><a href="#topic+lokerns">lokerns</a></code> or <code><a href="#topic+glkerns">glkerns</a></code> function (keeping the
bandwidths for <code>lokerns</code>).
</p>


<h3>Value</h3>

<p>(differing, depending on the generic function)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glkerns">glkerns</a></code>, <code><a href="#topic+lokerns">lokerns</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## "interesting" artificial data:
set.seed(47)
x &lt;- sort(round(10*runif(250),2))
fn &lt;- function(x) 5 - x/2 + 3*exp(-(x-5)^2)
y &lt;- fn(x) + rnorm(x)/4
plot(x,y)
## Tracing the phases in the Fortran code: trace=1 gives some, trace=3 gives *much*
lof &lt;- lokerns(x,y, trace=2) 
plot(lof)
plot(lof, cex = 1/4)# maybe preferable
plot(fn, 0, 10, add=TRUE, col=adjustcolor("gray40",1/2), lwd=2, lty=2)
## Simpler, using the lines() method:
plot(x,y); lines(lof, lwd=2, col=2)

qqnorm(residuals(lof)) # hmm... overfitting?
stopifnot(all.equal(y, fitted(lof) + residuals(lof), tolerance = 1e-15),
          predict(lof)$y == fitted(lof))
lof$iter # negative ?
tt &lt;- seq(0, 10, by=1/32)
## again with 'tracing' [not for the average user]
p0 &lt;- predict(lof, x=tt,          trace=1)
p1 &lt;- predict(lof, x=tt, deriv=1, trace=1)
p2 &lt;- predict(lof, x=tt, deriv=2)
plot(p2, type="l"); abline(h=0, lty=3) # not satisfactory, but lokerns(*,deriv=2) is
lof2 &lt;- lokerns(x,y, deriv=2)
plot(lof2, ylim = c(-12,4), main=
   "lokerns(*, deriv=2) -- much more smooth than predict(*,deriv=2)")
mtext("as lokerns(*, deriv=2) chooses larger bandwidths[] !")
lines(predict(lof2, x=tt), col=adjustcolor("tomato", 1/3), lwd=5)
lines(p2, col="gray50"); abline(h=0, lty=3)
## add 2nd derivative of underlying fn():
f2 &lt;- fn; body(f2) &lt;- D(D(body(fn), "x"),"x")
lines(tt, f2(tt), col="blue")
</code></pre>

<hr>
<h2 id='lokerns'>Kernel Regression Smoothing with Local Plug-in Bandwidth</h2><span id='topic+lokerns'></span><span id='topic+lokerns.default'></span><span id='topic+lokerns.formula'></span>

<h3>Description</h3>

<p>Nonparametric estimation of regression functions and their derivatives
with kernel regression estimators and automatically adapted <b>local</b>
plug-in bandwidth function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lokerns(x, ...)

## Default S3 method:
lokerns(x, y=NULL, deriv = 0, n.out=300, x.out=NULL, x.inOut = TRUE,
        korder = deriv + 2, hetero=FALSE, is.rand=TRUE,
        inputb = is.numeric(bandwidth) &amp;&amp; all(bandwidth &gt; 0),
        m1 = 400, xl=NULL, xu=NULL,
        s=NULL, sig=NULL, bandwidth=NULL, trace.lev = 0, ...)

## S3 method for class 'formula'
lokerns(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lokerns_+3A_x">x</code></td>
<td>
<p>vector of design points, not necessarily ordered.</p>
</td></tr>
<tr><td><code id="lokerns_+3A_y">y</code></td>
<td>
<p>vector of observations of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="lokerns_+3A_deriv">deriv</code></td>
<td>
<p>order of derivative of the regression function to be
estimated.  Only deriv=0,1,2 are allowed for automatic smoothing,
whereas deriv=0,1,2,3,4  is possible when smoothing with an input
bandwidth array. The default value is deriv=0.</p>
</td></tr>
<tr><td><code id="lokerns_+3A_n.out">n.out</code></td>
<td>
<p>number of output design points where the function has to
be estimated; default is <code>n.out=300</code>.</p>
</td></tr>
<tr><td><code id="lokerns_+3A_x.out">x.out</code></td>
<td>
<p>vector of output design points where the function has to
be estimated.  The default is an equidistant grid of n.out points
from min(x) to max(x).</p>
</td></tr>
<tr><td><code id="lokerns_+3A_x.inout">x.inOut</code></td>
<td>
<p>logical or character string indicating if <code>x.out</code>
should contain the input <code>x</code> values.
Note that this argument did not exist, equivalently to being
<code>FALSE</code>, up to <span class="pkg">lokern</span> version <code>1.0-9</code>.
</p>
<p>In order for <code><a href="stats.html#topic+residuals">residuals</a>()</code> or <code><a href="stats.html#topic+fitted">fitted</a>()</code>
methods to be applicable, it must be <code>TRUE</code> or a character
string specifying one of the <code>methods</code>s of
<code><a href="sfsmisc.html#topic+seqXtend">seqXtend</a></code> (package <a href="https://CRAN.R-project.org/package=sfsmisc"><span class="pkg">sfsmisc</span></a>). The default,
<code>TRUE</code> corresponds to method <code>"aim"</code>.
</p>
</td></tr>
<tr><td><code id="lokerns_+3A_korder">korder</code></td>
<td>

<p>nonnegative integer giving the kernel order <code class="reqn">k</code>; it defaults to
<code>korder = deriv+2</code> or <code class="reqn">k = \nu + 2</code> where <code class="reqn">k - \nu</code>
must be even.  The maximal possible values are for automatic
smoothing, <code class="reqn">k \le 4</code>, whereas for smoothing with input
bandwidth array, <code class="reqn">k \le 6</code>.
</p>
</td></tr>
<tr><td><code id="lokerns_+3A_hetero">hetero</code></td>
<td>

<p>logical: if TRUE, heteroscedastic error variables are assumed for
variance estimation, if FALSE the variance estimation is optimized for
homoscedasticity. Default value is hetero=FALSE.
</p>
</td></tr>
<tr><td><code id="lokerns_+3A_is.rand">is.rand</code></td>
<td>

<p>logical: if <code>TRUE</code> (default), random x are assumed and the
s-array of the convolution estimator is computed as smoothed
quantile estimators in order to adapt this variability.  If FALSE,
the s-array is choosen as mid-point sequences as the classical
Gasser-Mueller estimator, this will be better for equidistant and
fixed design.
</p>
</td></tr>
<tr><td><code id="lokerns_+3A_inputb">inputb</code></td>
<td>

<p>logical: if true, a local input bandwidth array is used; if
<code>FALSE</code> (by default when <code>bandwidth</code> is not specified), a
data-adaptive local plug-in bandwidths array is calculated and used.
</p>
</td></tr>
<tr><td><code id="lokerns_+3A_m1">m1</code></td>
<td>

<p>integer, the number of grid points for integral approximation when
estimating the plug-in bandwidth. The default, 400, may be increased
if a very large number of observations are available.
</p>
</td></tr>
<tr><td><code id="lokerns_+3A_xl">xl</code>, <code id="lokerns_+3A_xu">xu</code></td>
<td>

<p>numeric (scalars), the lower and upper bounds for integral
approximation and variance estimation when estimating the plug-in
bandwidth. By default (when <code>xl</code> and <code>xu</code> are not specified),
the 87% middle part of <code class="reqn">[xmin,xmax]</code> is used.
</p>
</td></tr>
<tr><td><code id="lokerns_+3A_s">s</code></td>
<td>

<p>s-array of the convolution kernel estimator. If it is not given by input
it is calculated as midpoint-sequence of the ordered design points for
<code>is.rand=FALSE</code> or as quantiles estimators of the design density
for <code>is.rand=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="lokerns_+3A_sig">sig</code></td>
<td>
<p>variance of the error variables.  If it is not given by
input or if <code>hetero=TRUE</code> it is calculated by a
nonparametric variance estimator.</p>
</td></tr>
<tr><td><code id="lokerns_+3A_bandwidth">bandwidth</code></td>
<td>

<p><em>local</em> bandwidth array for kernel regression estimation.  If it is
not given by input or if <code>inputb=FALSE</code> a data-adaptive local
plug-in bandwidth array is used instead.
</p>
</td></tr>
<tr><td><code id="lokerns_+3A_trace.lev">trace.lev</code></td>
<td>
<p>integer indicating how much the internal (Fortran
level) computations should be &ldquo;traced&rdquo;, i.e., be reported.
The default, <code>0</code>, does not print anything.</p>
</td></tr>
<tr><td><code id="lokerns_+3A_formula">formula</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> of the form <code>y ~ pred</code>,
specifying the response variable <code>y</code> and predictor variable
<code>pred</code> which must be in <code>data</code>.</p>
</td></tr>
<tr><td><code id="lokerns_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="lokerns_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="lokerns_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to
<code>getOption("na.action")</code>.</p>
</td></tr>
<tr><td><code id="lokerns_+3A_...">...</code></td>
<td>
<p>for the <code>formula</code> method: Optional arguments all
passed to <code>lokerns.default()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls an efficient and fast algorithm for automatically
adaptive nonparametric regression estimation with a kernel method.
</p>
<p>Roughly spoken, the method performs a local averaging of the
observations when estimating the regression function. Analogously, one
can estimate derivatives of small order of the regression function.
Crucial for the kernel regression estimation used here is the choice
the local bandwidth array. Too small bandwidths will lead to a wiggly
curve, too large ones will smooth away important details.  The
function lokerns calculates an estimator of the regression function or
derivatives of the regression function with an automatically chosen
local plugin bandwidth function. It is also possible to use a local
bandwidth array which are specified by the user.
</p>
<p>Main ideas of the plugin method are to estimate the optimal bandwidths
by estimating the asymptotically optimal mean squared error optimal
bandwidths. Therefore, one has to estimate the variance for
homoscedastic error variables and a functional of a smooth variance
function for heteroscedastic error variables, respectively. Also, one
has to estimate an integral functional of the squared <code class="reqn">k</code>-th derivative
of the regression function (<code class="reqn">k=\code{korder}</code>) for the global
bandwidth and the squared <code class="reqn">k</code>-th derivative itself for the local
bandwidths.
</p>
<p>Some more details are in <code><a href="#topic+glkerns">glkerns</a></code>.
</p>


<h3>Value</h3>

<p>an object of class(es) <code>c("lokerns", "KernS")</code>, which is
a list including used parameters and estimator, containing among others
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>vector of ordered design points.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector of observations ordered with respect to x.</p>
</td></tr>
<tr><td><code>bandwidth</code></td>
<td>
<p>local bandwidth array which was used for kernel
regression estimation.</p>
</td></tr>
<tr><td><code>x.out</code></td>
<td>
<p>vector of ordered output design points.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>vector of estimated regression function or its derivative
(at <code>x.out</code>).</p>
</td></tr>
<tr><td><code>sig</code></td>
<td>
<p>variance estimation which was used for calculating the
plug-in bandwidths if hetero=TRUE (default) and either inputb=FALSE
(default) or is.rand=TRUE (default).</p>
</td></tr>
<tr><td><code>deriv</code></td>
<td>
<p>derivative of the regression function which was estimated.</p>
</td></tr>
<tr><td><code>korder</code></td>
<td>
<p>order of the kernel function which was used.</p>
</td></tr>
<tr><td><code>xl</code></td>
<td>
<p>lower bound for integral approximation and variance estimation.</p>
</td></tr>
<tr><td><code>xu</code></td>
<td>
<p>upper bound for integral approximation and variance estimation.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>vector of midpoint values used for the convolution kernel
regression estimator.</p>
</td></tr>
</table>


<h3>References</h3>

<p>All the references in <code><a href="#topic+glkerns">glkerns</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glkerns">glkerns</a></code> for <b>gl</b>obal bandwidth computation.
<code><a href="#topic+plot.KernS">plot.KernS</a></code> documents all the methods for <code>"KernS"</code>
classed objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cars)
lofit &lt;- lokerns(dist ~ speed, data=cars)
lofit # print() method

if(require("sfsmisc")) {
  TA.plot(lofit)
} else { plot(residuals(lofit) ~ fitted(lofit)); abline(h = 0, lty=2) }
qqnorm(residuals(lofit), ylab = "residuals(lofit)")

## nice simple plot of data + smooth
plot(lofit)

(sb &lt;- summary(lofit$bandwidth))
op &lt;- par(fg = "gray90", tcl = -0.2, mgp = c(3,.5,0))
plot(lofit$band, ylim=c(0,3*sb["Max."]), type="h",#col="gray90",
     ann = FALSE, axes = FALSE)

boxplot(lofit$bandwidth, add = TRUE, at = 304, boxwex = 8,
        col = "gray90",border="gray", pars = list(axes = FALSE))
axis(4, at = c(0,pretty(sb)), col.axis = "gray")
par(op)
par(new=TRUE)
plot(dist ~ speed, data = cars,
     main = "Local Plug-In Bandwidth Vector")
lines(lofit, col=4, lwd=2)
mtext(paste("bandwidth in [",
            paste(format(sb[c(1,6)], dig = 3),collapse=","),
            "];  Median b.w.=",formatC(sb["Median"])))

## using user-specified bandwidth array
myBW &lt;- round(2*lofit$bandwidth, 2)
(lofB &lt;- lokerns(dist ~ speed, data=cars, bandwidth = myBW)) # failed (for a while)
## can use deriv=3 (and 4) here:
lofB3 &lt;- lokerns(dist ~ speed, data=cars, bandwidth = myBW, deriv=3)
plot(lofB)
lines(lofB3, col=3)
stopifnot(inherits(lofB3, "KernS"), identical(lofB3$korder, 5L))
</code></pre>

<hr>
<h2 id='varNPreg'>Nonparametric Variance Estimator</h2><span id='topic+varNPreg'></span><span id='topic+varest'></span>

<h3>Description</h3>

<p>Estimates the error variance <code class="reqn">\sigma^2</code> nonparametrically in the model
</p>
<p style="text-align: center;"><code class="reqn">Y_i = m(x_i) + E_i,</code>
</p>
<p> where
<code class="reqn">E_i \sim (0,\sigma^2)</code>, i.i.d.
</p>
<p>Computes leave-one-out residuals (local linear approximation followed by
reweighting) and their variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varNPreg(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varNPreg_+3A_x">x</code></td>
<td>
<p>abscissae values, ordered increasingly.</p>
</td></tr>
<tr><td><code id="varNPreg_+3A_y">y</code></td>
<td>
<p>observations at <code>y[i]</code> at <code>x[i]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>numeric; residuals at <code>x[]</code> of length <code>n</code>.</p>
</td></tr>
<tr><td><code>snr</code></td>
<td>
<p>explained variance of the true curve, i.e., an <code class="reqn">R^2</code>,
defined as <code class="reqn">1 - \hat{\sigma^2}/ \hat{\sigma_0^2}</code>, where
<code class="reqn">\hat{\sigma^2} = </code><code>sigma2</code>, and
<code class="reqn">\hat{\sigma_0^2} := var(Y) = E[Y^2] - (E[Y])^2</code>,
see the example below.</p>
</td></tr> 
<tr><td><code>sigma2</code></td>
<td>
<p>estimation of residual variance, <code class="reqn">\hat{\sigma^2}</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is an <span class="rlang"><b>R</b></span> interface to the <code>resest</code> Fortran subroutine, used
in <code><a href="#topic+lokerns">lokerns</a></code> and <code><a href="#topic+glkerns">glkerns</a></code>, see the latter's help
page for references and context.
</p>
<p>Earlier version of the <span class="pkg">lokern</span> package accidentally contained
<code>varest()</code> which has been an identical copy of <code>varNPreg()</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+lokerns">lokerns</a></code>, <code><a href="#topic+glkerns">glkerns</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
x &lt;- sort(runif(n))
y &lt;- sin(pi*x) + rnorm(n)/10
str(ve &lt;- varNPreg(x,y))

plot(x, y)
## "fitted" = y - residuals:
lines(x, y - ve$res, col=adjustcolor(2, 1/2), lwd=3)
segments(x,y,x,y-ve$res, col=3:4, lty=2:3, lwd=1:2)

## sigma2 :=  1/n  sum_i res_i^2  :
          with(ve,         c(sigma2, sum(res^2)/n))
stopifnot(with(ve, all.equal(sigma2, sum(res^2)/n)))

## show how 'snr' is computed, given 'sigma2'  { in ../src/auxkerns.f }
dx2 &lt;- diff(x, 2) # (x[i+1] - x[i-1]) i= 2..{n-1}
dx.n &lt;- c(x[2]-x[1], dx2, x[n]-x[n-1])
SY  &lt;- sum(dx.n * y)
SY2 &lt;- sum(dx.n * y^2)
rx &lt;- 2*(x[n]-x[1]) # 'dn'
(sigm2.0 &lt;- SY2/rx - (SY/rx)^2)
(R2 &lt;- 1 - ve$sigma2 / sigm2.0)
stopifnot(all.equal(ve$snr, R2))
</code></pre>

<hr>
<h2 id='xSim'>Simulated Linear plus Exponential Peak</h2><span id='topic+xSim'></span>

<h3>Description</h3>

<p>This is simulated data, a linear plus an exponential peak.
In similar form, data like this appears in the smoothing literature
since at least the eighties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(xSim)</code></pre>


<h3>Format</h3>

<p>A vector of 75 numbers between -3.1323 and 4.4505, all rounded to 4
digits after the decimal.
</p>


<h3>Source</h3>

<p><a href="https://www.biostat.uzh.ch/en/research/software/kernel.html">https://www.biostat.uzh.ch/en/research/software/kernel.html</a>
</p>


<h3>See Also</h3>

<p>The example in <code><a href="#topic+glkerns">glkerns</a></code> replicates the
computations and plots from the source given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(xSim)
plot(xSim, main = "`xSim' - N=75 simulated linear + peak")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
