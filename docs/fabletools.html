<!DOCTYPE html><html><head><title>Help for package fabletools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fabletools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accuracy.mdl_df'><p>Evaluate accuracy of a forecast or model</p></a></li>
<li><a href='#agg_vec'><p>Create an aggregation vector</p></a></li>
<li><a href='#aggregate_index'><p>Expand a dataset to include temporal aggregates</p></a></li>
<li><a href='#aggregate_key'><p>Expand a dataset to include other levels of aggregation</p></a></li>
<li><a href='#aggregation-vctrs'><p>Internal vctrs methods</p></a></li>
<li><a href='#as_dable'><p>Coerce to a dable object</p></a></li>
<li><a href='#as_fable'><p>Coerce to a fable object</p></a></li>
<li><a href='#as_mable'><p>Coerce a dataset to a mable</p></a></li>
<li><a href='#augment.mdl_df'><p>Augment a mable</p></a></li>
<li><a href='#autoplot.dcmp_ts'><p>Decomposition plots</p></a></li>
<li><a href='#autoplot.fbl_ts'><p>Plot a set of forecasts</p></a></li>
<li><a href='#autoplot.tbl_ts'><p>Plot time series from a tsibble</p></a></li>
<li><a href='#bias_adjust'><p>Bias adjust back-transformation functions</p></a></li>
<li><a href='#bottom_up'><p>Bottom up forecast reconciliation</p></a></li>
<li><a href='#box_cox'><p>Box Cox Transformation</p></a></li>
<li><a href='#combination_ensemble'><p>Ensemble combination</p></a></li>
<li><a href='#combination_model'><p>Combination modelling</p></a></li>
<li><a href='#combination_weighted'><p>Weighted combination</p></a></li>
<li><a href='#common_periods'><p>Extract frequencies for common seasonal periods</p></a></li>
<li><a href='#common_xregs'><p>Common exogenous regressors</p></a></li>
<li><a href='#components.mdl_df'><p>Extract components from a fitted model</p></a></li>
<li><a href='#construct_fc'><p>Construct a new set of forecasts</p></a></li>
<li><a href='#dable'><p>Create a dable object</p></a></li>
<li><a href='#dable-vctrs'><p>Internal vctrs methods</p></a></li>
<li><a href='#decomposition_model'><p>Decomposition modelling</p></a></li>
<li><a href='#distribution_var'><p>Return distribution variable</p></a></li>
<li><a href='#estimate'><p>Estimate a model</p></a></li>
<li><a href='#fable'><p>Create a fable object</p></a></li>
<li><a href='#fable-vctrs'><p>Internal vctrs methods</p></a></li>
<li><a href='#fabletools-package'><p>fabletools: Core Tools for Packages in the 'fable' Framework</p></a></li>
<li><a href='#feature_set'><p>Create a feature set from tags</p></a></li>
<li><a href='#features'><p>Extract features from a dataset</p></a></li>
<li><a href='#features_by_pkg'><p>Features by package</p></a></li>
<li><a href='#features_by_tag'><p>Features by tag</p></a></li>
<li><a href='#fitted.mdl_df'><p>Extract fitted values from models</p></a></li>
<li><a href='#forecast.mdl_df'><p>Produce forecasts</p></a></li>
<li><a href='#generate.mdl_df'><p>Generate responses from a mable</p></a></li>
<li><a href='#glance.mdl_df'><p>Glance a mable</p></a></li>
<li><a href='#hypothesize.mdl_df'><p>Run a hypothesis test from a mable</p></a></li>
<li><a href='#interpolate.mdl_df'><p>Interpolate missing values</p></a></li>
<li><a href='#is_aggregated'><p>Is the element an aggregation of smaller data</p></a></li>
<li><a href='#is_dable'><p>Is the object a dable</p></a></li>
<li><a href='#is_fable'><p>Is the object a fable</p></a></li>
<li><a href='#is_mable'><p>Is the object a mable</p></a></li>
<li><a href='#is_model'><p>Is the object a model</p></a></li>
<li><a href='#MAAPE'><p>Mean Arctangent Absolute Percentage Error</p></a></li>
<li><a href='#mable'><p>Create a new mable</p></a></li>
<li><a href='#mable_vars'><p>Return model column variables</p></a></li>
<li><a href='#mable-vctrs'><p>Internal vctrs methods</p></a></li>
<li><a href='#MDA'><p>Directional accuracy measures</p></a></li>
<li><a href='#ME'><p>Point estimate accuracy measures</p></a></li>
<li><a href='#middle_out'><p>Middle out forecast reconciliation</p></a></li>
<li><a href='#min_trace'><p>Minimum trace forecast reconciliation</p></a></li>
<li><a href='#model'><p>Estimate models</p></a></li>
<li><a href='#model_lhs'><p>Extract the left hand side of a model</p></a></li>
<li><a href='#model_rhs'><p>Extract the right hand side of a model</p></a></li>
<li><a href='#model_sum'><p>Provide a succinct summary of a model</p></a></li>
<li><a href='#new_model_class'><p>Create a new class of models</p></a></li>
<li><a href='#new_specials'><p>Create evaluation environment for specials</p></a></li>
<li><a href='#new_transformation'><p>Create a new modelling transformation</p></a></li>
<li><a href='#null_model'><p>NULL model</p></a></li>
<li><a href='#outliers'><p>Identify outliers</p></a></li>
<li><a href='#parse_model'><p>Parse the model specification for specials</p></a></li>
<li><a href='#parse_model_lhs'><p>Parse the RHS of the model formula for transformations</p></a></li>
<li><a href='#parse_model_rhs'><p>Parse the RHS of the model formula for specials</p></a></li>
<li><a href='#percentile_score'><p>Distribution accuracy measures</p></a></li>
<li><a href='#reconcile'><p>Forecast reconciliation</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#refit.mdl_df'><p>Refit a mable to a new dataset</p></a></li>
<li><a href='#register_feature'><p>Register a feature function</p></a></li>
<li><a href='#report'><p>Report information about an object</p></a></li>
<li><a href='#residuals.mdl_df'><p>Extract residuals values from models</p></a></li>
<li><a href='#response'><p>Extract the response variable from a model</p></a></li>
<li><a href='#response_vars'><p>Return response variables</p></a></li>
<li><a href='#scenarios'><p>A set of future scenarios for forecasting</p></a></li>
<li><a href='#skill_score'><p>Forecast skill score measure</p></a></li>
<li><a href='#special_xreg'><p>Helper special for producing a model matrix of exogenous regressors</p></a></li>
<li><a href='#stream'><p>Extend a fitted model with new data</p></a></li>
<li><a href='#tidy.mdl_df'><p>Extract model coefficients from a mable</p></a></li>
<li><a href='#top_down'><p>Top down forecast reconciliation</p></a></li>
<li><a href='#traverse'><p>Recursively traverse an object</p></a></li>
<li><a href='#unpack_hilo'><p>Unpack a hilo column</p></a></li>
<li><a href='#validate_formula'><p>Validate the user provided model</p></a></li>
<li><a href='#winkler_score'><p>Interval estimate accuracy measures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Core Tools for Packages in the 'fable' Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools, helpers and data structures for
    developing models and time series functions for 'fable' and extension
    packages. These tools support a consistent and tidy interface for time
    series modelling and analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fabletools.tidyverts.org/">https://fabletools.tidyverts.org/</a>,
<a href="https://github.com/tidyverts/fabletools">https://github.com/tidyverts/fabletools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverts/fabletools/issues">https://github.com/tidyverts/fabletools/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tsibble (&ge; 0.9.0), tibble (&ge; 1.4.1), ggplot2 (&ge; 3.0.0),
tidyselect, rlang (&ge; 0.4.5), stats, dplyr (&ge; 1.0.0), tidyr
(&ge; 1.1.0), generics, R6, utils, vctrs (&ge; 0.2.2),
distributional (&ge; 0.3.0.9000), progressr, lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, crayon, fable (&ge; 0.2.0), future, future.apply, knitr,
pillar (&ge; 1.0.1), feasts (&ge; 0.1.2), rmarkdown, spelling,
testthat, tsibbledata (&ge; 0.2.0), lubridate, Matrix</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-11 22:19:46 UTC; mitchell</td>
</tr>
<tr>
<td>Author:</td>
<td>Mitchell O'Hara-Wild <a href="https://orcid.org/0000-0001-6729-7695"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Rob Hyndman [aut],
  Earo Wang <a href="https://orcid.org/0000-0001-6448-5260"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Di Cook [ctb],
  George Athanasopoulos [ctb],
  David Holt [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mitchell O'Hara-Wild &lt;mail@mitchelloharawild.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-11 22:40:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; ; 2024-01-02 08:00:00 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='accuracy.mdl_df'>Evaluate accuracy of a forecast or model</h2><span id='topic+accuracy.mdl_df'></span><span id='topic+accuracy.mdl_ts'></span><span id='topic+accuracy.fbl_ts'></span>

<h3>Description</h3>

<p>Summarise the performance of the model using accuracy measures. Accuracy
measures can be computed directly from models as the one-step-ahead fitted
residuals are available. When evaluating accuracy on forecasts, you will
need to provide a complete dataset that includes the future data and data
used to train the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
accuracy(object, measures = point_accuracy_measures, ...)

## S3 method for class 'mdl_ts'
accuracy(object, measures = point_accuracy_measures, ...)

## S3 method for class 'fbl_ts'
accuracy(object, data, measures = point_accuracy_measures, ..., by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy.mdl_df_+3A_object">object</code></td>
<td>
<p>A model or forecast object</p>
</td></tr>
<tr><td><code id="accuracy.mdl_df_+3A_measures">measures</code></td>
<td>
<p>A list of accuracy measure functions to compute (such as <code><a href="fabletools.html#topic+point_accuracy_measures">point_accuracy_measures</a></code>, <code><a href="fabletools.html#topic+interval_accuracy_measures">interval_accuracy_measures</a></code>, or <code><a href="fabletools.html#topic+distribution_accuracy_measures">distribution_accuracy_measures</a></code>)</p>
</td></tr>
<tr><td><code id="accuracy.mdl_df_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to measures that use it.</p>
</td></tr>
<tr><td><code id="accuracy.mdl_df_+3A_data">data</code></td>
<td>
<p>A dataset containing the complete model dataset (both training and test data). The training portion of the data will be used in the computation of some accuracy measures, and the test data is used to compute the forecast errors.</p>
</td></tr>
<tr><td><code id="accuracy.mdl_df_+3A_by">by</code></td>
<td>
<p>Variables over which the accuracy is computed (useful for computing across forecast horizons in cross-validation). If <code>by</code> is <code>NULL</code>, groups will be chosen automatically from the key structure.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://otexts.com/fpp3/accuracy.html">Evaluating forecast accuracy</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(tsibble)
library(tsibbledata)
library(dplyr)

fit &lt;- aus_production %&gt;%
  filter(Quarter &lt; yearquarter("2006 Q1")) %&gt;% 
  model(ets = ETS(log(Beer) ~ error("M") + trend("Ad") + season("A")))

# In-sample training accuracy does not require extra data provided.
accuracy(fit)

# Out-of-sample forecast accuracy requires the future values to compare with.
# All available future data will be used, and a warning will be given if some
# data for the forecast window is unavailable.
fc &lt;- fit %&gt;% 
  forecast(h = "5 years")
fc %&gt;% 
  accuracy(aus_production)
  
# It is also possible to compute interval and distributional measures of
# accuracy for models and forecasts which give forecast distributions.
fc %&gt;% 
  accuracy(
    aus_production,
    measures = list(interval_accuracy_measures, distribution_accuracy_measures)
  )

</code></pre>

<hr>
<h2 id='agg_vec'>Create an aggregation vector</h2><span id='topic+agg_vec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt='[Maturing]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg_vec(x = character(), aggregated = logical(vec_size(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agg_vec_+3A_x">x</code></td>
<td>
<p>The vector of values.</p>
</td></tr>
<tr><td><code id="agg_vec_+3A_aggregated">aggregated</code></td>
<td>
<p>A logical vector to identify which values are <code style="white-space: pre;">&#8288;&lt;aggregated&gt;&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An aggregation vector extends usual vectors by adding <code style="white-space: pre;">&#8288;&lt;aggregated&gt;&#8288;</code> values.
These vectors are typically produced via the <code><a href="fabletools.html#topic+aggregate_key">aggregate_key()</a></code> function,
however it can be useful to create them manually to produce more complicated
hierarchies (such as unbalanced hierarchies).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>agg_vec(
  x = c(NA, "A", "B"),
  aggregated = c(TRUE, FALSE, FALSE)
)

</code></pre>

<hr>
<h2 id='aggregate_index'>Expand a dataset to include temporal aggregates</h2><span id='topic+aggregate_index'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_index(.data, .window, ..., .offset = "end", .bin_size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_index_+3A_.data">.data</code></td>
<td>
<p>A tsibble.</p>
</td></tr>
<tr><td><code id="aggregate_index_+3A_.window">.window</code></td>
<td>
<p>Temporal aggregations to include. The default (NULL) will
automatically identify appropriate temporal aggregations. This can be
specified in several ways (see details).</p>
</td></tr>
<tr><td><code id="aggregate_index_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs of
summary functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returning values with size 0 or &gt;1 was
deprecated as of 1.1.0. Please use <code><a href="dplyr.html#topic+reframe">reframe()</a></code> for this instead.</p>
</td></tr>
<tr><td><code id="aggregate_index_+3A_.offset">.offset</code></td>
<td>
<p>Offset the temporal aggregation windows to align with the start
or end of the data. If FALSE, no offset will be applied (giving common
breakpoints for temporal bins.)</p>
</td></tr>
<tr><td><code id="aggregate_index_+3A_.bin_size">.bin_size</code></td>
<td>
<p>Temporary. Define the number of observations in each temporal bucket</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This feature is very experimental. It currently allows for temporal
aggregation of daily data as a proof of concept.
</p>
<p>The aggregation <code>.window</code> can be specified in several ways:
</p>

<ul>
<li><p> A character string, containing one of &quot;day&quot;, &quot;week&quot;, &quot;month&quot;, &quot;quarter&quot; or
&quot;year&quot;. This can optionally be preceded by a (positive or negative) integer
and a space, or followed by &quot;s&quot;.
</p>
</li>
<li><p> A number, taken to be in days.
</p>
</li>
<li><p> A <code><a href="base.html#topic+difftime">difftime</a></code> object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(tsibble)
pedestrian %&gt;%
  # Currently only supports daily data
  index_by(Date) %&gt;% 
  dplyr::summarise(Count = sum(Count)) %&gt;% 
  # Compute weekly aggregates
  fabletools:::aggregate_index("1 week", Count = sum(Count))
</code></pre>

<hr>
<h2 id='aggregate_key'>Expand a dataset to include other levels of aggregation</h2><span id='topic+aggregate_key'></span>

<h3>Description</h3>

<p>Uses the structural specification given in <code>.spec</code> to aggregate a time
series. A grouped structure is specified using <code>grp1 * grp2</code>, and a nested
structure is specified via <code>parent / child</code>. Aggregating the key structure is
commonly used with forecast reconciliation to produce coherent forecasts over
some hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_key(.data, .spec, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_key_+3A_.data">.data</code></td>
<td>
<p>A tsibble.</p>
</td></tr>
<tr><td><code id="aggregate_key_+3A_.spec">.spec</code></td>
<td>
<p>The specification of aggregation structure.</p>
</td></tr>
<tr><td><code id="aggregate_key_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs of
summary functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returning values with size 0 or &gt;1 was
deprecated as of 1.1.0. Please use <code><a href="dplyr.html#topic+reframe">reframe()</a></code> for this instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is experimental, and is subject to change in the future.
</p>
<p>The way in which the measured variables are aggregated is specified in a
similar way to how <code style="white-space: pre;">&#8288;[dplyr::summarise()]&#8288;</code> is used.
</p>


<h3>See Also</h3>

<p><code><a href="fabletools.html#topic+reconcile">reconcile()</a></code>, <code><a href="fabletools.html#topic+is_aggregated">is_aggregated()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsibble)
tourism %&gt;% 
  aggregate_key(Purpose * (State / Region), Trips = sum(Trips))

</code></pre>

<hr>
<h2 id='aggregation-vctrs'>Internal vctrs methods</h2><span id='topic+aggregation-vctrs'></span><span id='topic+vec_ptype2.agg_vec'></span><span id='topic+vec_ptype2.agg_vec.agg_vec'></span><span id='topic+vec_ptype2.agg_vec.default'></span><span id='topic+vec_ptype2.agg_vec.character'></span><span id='topic+vec_ptype2.character.agg_vec'></span><span id='topic+vec_ptype_abbr.agg_vec'></span><span id='topic+vec_cast.agg_vec'></span><span id='topic+vec_cast.agg_vec.agg_vec'></span><span id='topic+vec_cast.agg_vec.default'></span><span id='topic+vec_cast.character.agg_vec'></span><span id='topic+vec_proxy_compare.agg_vec'></span>

<h3>Description</h3>

<p>These methods are the extensions that allow aggregation vectors to work with
vctrs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'agg_vec'
vec_ptype2(x, y, ...)

## S3 method for class 'agg_vec.agg_vec'
vec_ptype2(x, y, ...)

## S3 method for class 'agg_vec.default'
vec_ptype2(x, y, ...)

## S3 method for class 'agg_vec.character'
vec_ptype2(x, y, ...)

## S3 method for class 'character.agg_vec'
vec_ptype2(x, y, ...)

## S3 method for class 'agg_vec'
vec_ptype_abbr(x, ...)

## S3 method for class 'agg_vec'
vec_cast(x, to, ...)

## S3 method for class 'agg_vec.agg_vec'
vec_cast(x, to, ...)

## S3 method for class 'agg_vec.default'
vec_cast(x, to, ...)

## S3 method for class 'character.agg_vec'
vec_cast(x, to, ...)

## S3 method for class 'agg_vec'
vec_proxy_compare(x, ...)
</code></pre>

<hr>
<h2 id='as_dable'>Coerce to a dable object</h2><span id='topic+as_dable'></span><span id='topic+as_dable.tbl_df'></span><span id='topic+as_dable.tbl_ts'></span>

<h3>Description</h3>

<p>Coerce to a dable object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_dable(x, ...)

## S3 method for class 'tbl_df'
as_dable(x, response, method = NULL, seasons = list(), aliases = list(), ...)

## S3 method for class 'tbl_ts'
as_dable(x, response, method = NULL, seasons = list(), aliases = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_dable_+3A_x">x</code></td>
<td>
<p>Object to be coerced to a dable (<code>dcmp_ts</code>)</p>
</td></tr>
<tr><td><code id="as_dable_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="as_dable_+3A_response">response</code></td>
<td>
<p>The character vector of response variable(s).</p>
</td></tr>
<tr><td><code id="as_dable_+3A_method">method</code></td>
<td>
<p>The name of the decomposition method.</p>
</td></tr>
<tr><td><code id="as_dable_+3A_seasons">seasons</code></td>
<td>
<p>A named list describing the structure of seasonal components
(such as <code>period</code>, and <code>base</code>).</p>
</td></tr>
<tr><td><code id="as_dable_+3A_aliases">aliases</code></td>
<td>
<p>A named list of calls describing common aliases computed from
components.</p>
</td></tr>
</table>

<hr>
<h2 id='as_fable'>Coerce to a fable object</h2><span id='topic+as_fable'></span><span id='topic+as_fable.tbl_ts'></span><span id='topic+as_fable.grouped_ts'></span><span id='topic+as_fable.tbl_df'></span><span id='topic+as_fable.fbl_ts'></span><span id='topic+as_fable.grouped_df'></span><span id='topic+as_fable.forecast'></span>

<h3>Description</h3>

<p>Coerce to a fable object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_fable(x, ...)

## S3 method for class 'tbl_ts'
as_fable(x, response, distribution, ...)

## S3 method for class 'grouped_ts'
as_fable(x, response, distribution, ...)

## S3 method for class 'tbl_df'
as_fable(x, response, distribution, ...)

## S3 method for class 'fbl_ts'
as_fable(x, response, distribution, ...)

## S3 method for class 'grouped_df'
as_fable(x, response, distribution, ...)

## S3 method for class 'forecast'
as_fable(x, ..., point_forecast = list(.mean = mean))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_fable_+3A_x">x</code></td>
<td>
<p>Object to be coerced to a fable (<code>fbl_ts</code>)</p>
</td></tr>
<tr><td><code id="as_fable_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="as_fable_+3A_response">response</code></td>
<td>
<p>The character vector of response variable(s).</p>
</td></tr>
<tr><td><code id="as_fable_+3A_distribution">distribution</code></td>
<td>
<p>The name of the distribution column (can be provided
using a bare expression).</p>
</td></tr>
<tr><td><code id="as_fable_+3A_point_forecast">point_forecast</code></td>
<td>
<p>The point forecast measure(s) which should be returned
in the resulting fable. Specified as a named list of functions which accept
a distribution and return a vector. To compute forecast medians, you can use
<code>list(.median = median)</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='as_mable'>Coerce a dataset to a mable</h2><span id='topic+as_mable'></span><span id='topic+as_mable.data.frame'></span>

<h3>Description</h3>

<p>Coerce a dataset to a mable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_mable(x, ...)

## S3 method for class 'data.frame'
as_mable(x, key = NULL, model = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_mable_+3A_x">x</code></td>
<td>
<p>A dataset containing a list model column.</p>
</td></tr>
<tr><td><code id="as_mable_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="as_mable_+3A_key">key</code></td>
<td>
<p>Structural variable(s) that identify each model.</p>
</td></tr>
<tr><td><code id="as_mable_+3A_model">model</code></td>
<td>
<p>Identifiers for the columns containing model(s).</p>
</td></tr>
</table>

<hr>
<h2 id='augment.mdl_df'>Augment a mable</h2><span id='topic+augment.mdl_df'></span><span id='topic+augment.mdl_ts'></span>

<h3>Description</h3>

<p>Uses a fitted model to augment the response variable with fitted values and
residuals. Response residuals (back-transformed) are stored in the <code>.resid</code>
column, while innovation residuals (transformed) are stored in the <code>.innov</code>
column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
augment(x, ...)

## S3 method for class 'mdl_ts'
augment(x, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.mdl_df_+3A_x">x</code></td>
<td>
<p>A mable.</p>
</td></tr>
<tr><td><code id="augment.mdl_df_+3A_...">...</code></td>
<td>
<p>Arguments for model methods.</p>
</td></tr>
<tr><td><code id="augment.mdl_df_+3A_type">type</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(tsibbledata)

# Forecasting with an ETS(M,Ad,A) model to Australian beer production
aus_production %&gt;%
  model(ets = ETS(log(Beer) ~ error("M") + trend("Ad") + season("A"))) %&gt;% 
  augment()

</code></pre>

<hr>
<h2 id='autoplot.dcmp_ts'>Decomposition plots</h2><span id='topic+autoplot.dcmp_ts'></span>

<h3>Description</h3>

<p>Produces a faceted plot of the components used to build the response
variable of the dable. Useful for visualising how the components contribute
in a decomposition or model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcmp_ts'
autoplot(object, .vars = NULL, scale_bars = TRUE, level = c(80, 95), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.dcmp_ts_+3A_object">object</code></td>
<td>
<p>A dable.</p>
</td></tr>
<tr><td><code id="autoplot.dcmp_ts_+3A_.vars">.vars</code></td>
<td>
<p>The column of the dable used to plot. By default, this will be the response variable of the decomposition.</p>
</td></tr>
<tr><td><code id="autoplot.dcmp_ts_+3A_scale_bars">scale_bars</code></td>
<td>
<p>If <code>TRUE</code>, each facet will include a scale bar which represents the same units across each facet.</p>
</td></tr>
<tr><td><code id="autoplot.dcmp_ts_+3A_level">level</code></td>
<td>
<p>If the decomposition contains distributions, which levels should be used to display intervals?</p>
</td></tr>
<tr><td><code id="autoplot.dcmp_ts_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>, which can be used to specify fixed aesthetics such as <code>colour = "red"</code> or <code>linewidth = 3</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(feasts)
library(tsibbledata)
aus_production %&gt;% 
  model(STL(Beer)) %&gt;%
  components() %&gt;%  
  autoplot()

</code></pre>

<hr>
<h2 id='autoplot.fbl_ts'>Plot a set of forecasts</h2><span id='topic+autoplot.fbl_ts'></span><span id='topic+autolayer.fbl_ts'></span>

<h3>Description</h3>

<p>Produces a forecast plot from a fable. As the original data is not included
in the fable object, it will need to be specified via the <code>data</code> argument.
The <code>data</code> argument can be used to specify a shorter period of data, which is
useful to focus on the more recent observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fbl_ts'
autoplot(object, data = NULL, level = c(80, 95), show_gap = TRUE, ...)

## S3 method for class 'fbl_ts'
autolayer(
  object,
  data = NULL,
  level = c(80, 95),
  point_forecast = list(mean = mean),
  show_gap = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.fbl_ts_+3A_object">object</code></td>
<td>
<p>A fable.</p>
</td></tr>
<tr><td><code id="autoplot.fbl_ts_+3A_data">data</code></td>
<td>
<p>A tsibble with the same key structure as the fable.</p>
</td></tr>
<tr><td><code id="autoplot.fbl_ts_+3A_level">level</code></td>
<td>
<p>The confidence level(s) for the plotted intervals.</p>
</td></tr>
<tr><td><code id="autoplot.fbl_ts_+3A_show_gap">show_gap</code></td>
<td>
<p>Setting this to <code>FALSE</code> will connect the most recent value in <code>data</code> with the forecasts.</p>
</td></tr>
<tr><td><code id="autoplot.fbl_ts_+3A_...">...</code></td>
<td>
<p>Further arguments passed used to specify fixed aesthetics for the forecasts such as <code>colour = "red"</code> or <code>linewidth = 3</code>.</p>
</td></tr>
<tr><td><code id="autoplot.fbl_ts_+3A_point_forecast">point_forecast</code></td>
<td>
<p>The point forecast measure to be displayed in the plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(tsibbledata)

fc &lt;- aus_production %&gt;%
  model(ets = ETS(log(Beer) ~ error("M") + trend("Ad") + season("A"))) %&gt;% 
  forecast(h = "3 years") 

fc %&gt;% 
  autoplot(aus_production)


aus_production %&gt;% 
  autoplot(Beer) + 
  autolayer(fc)

</code></pre>

<hr>
<h2 id='autoplot.tbl_ts'>Plot time series from a tsibble</h2><span id='topic+autoplot.tbl_ts'></span><span id='topic+autolayer.tbl_ts'></span>

<h3>Description</h3>

<p>Produces a time series plot of one or more variables from a tsibble. If the
tsibble contains a multiple keys, separate time series will be identified by
colour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_ts'
autoplot(object, .vars = NULL, ...)

## S3 method for class 'tbl_ts'
autolayer(object, .vars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.tbl_ts_+3A_object">object</code></td>
<td>
<p>A tsibble.</p>
</td></tr>
<tr><td><code id="autoplot.tbl_ts_+3A_.vars">.vars</code></td>
<td>
<p>A bare expression containing data you wish to plot. Multiple variables can be plotted using <code><a href="ggplot2.html#topic+vars">ggplot2::vars()</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.tbl_ts_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>, which can be used to specify fixed aesthetics such as <code>colour = "red"</code> or <code>linewidth = 3</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(tsibbledata)
library(tsibble)

tsibbledata::gafa_stock %&gt;%
 autoplot(vars(Close, log(Close)))

</code></pre>

<hr>
<h2 id='bias_adjust'>Bias adjust back-transformation functions</h2><span id='topic+bias_adjust'></span>

<h3>Description</h3>

<p>To produce forecast means (instead of forecast medians) it is necessary to adjust the back-transformation function relative to the forecast variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bias_adjust(bt, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bias_adjust_+3A_bt">bt</code></td>
<td>
<p>The back-transformation function</p>
</td></tr>
<tr><td><code id="bias_adjust_+3A_sd">sd</code></td>
<td>
<p>The forecast standard deviation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details about bias adjustment can be found in the transformations vignette: read the vignette:
<code>vignette("transformations", package = "fable")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
adj_fn &lt;- bias_adjust(function(x) exp(x), 1:10)
y &lt;- rnorm(10)
exp(y)
adj_fn(y)

</code></pre>

<hr>
<h2 id='bottom_up'>Bottom up forecast reconciliation</h2><span id='topic+bottom_up'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bottom_up(models)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bottom_up_+3A_models">models</code></td>
<td>
<p>A column of models in a mable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reconciles a hierarchy using the bottom up reconciliation method. The
response variable of the hierarchy must be aggregated using sums. The
forecasted time points must match for all series in the hierarchy.
</p>


<h3>See Also</h3>

<p><code><a href="fabletools.html#topic+reconcile">reconcile()</a></code>, <code><a href="fabletools.html#topic+aggregate_key">aggregate_key()</a></code>
</p>

<hr>
<h2 id='box_cox'>Box Cox Transformation</h2><span id='topic+box_cox'></span><span id='topic+inv_box_cox'></span>

<h3>Description</h3>

<p><code>box_cox()</code> returns a transformation of the input variable using a Box-Cox
transformation. <code>inv_box_cox()</code> reverses the transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box_cox(x, lambda)

inv_box_cox(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="box_cox_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="box_cox_+3A_lambda">lambda</code></td>
<td>
<p>a numeric value for the transformation parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Box-Cox transformation is given by </p>
<p style="text-align: center;"><code class="reqn">f_\lambda(x) =\frac{x^\lambda -
1}{\lambda}</code>
</p>
<p> if <code class="reqn">\lambda\ne0</code>. For <code class="reqn">\lambda=0</code>,
</p>
<p style="text-align: center;"><code class="reqn">f_0(x)=\log(x)</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>a transformed numeric vector of the same length as x.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman &amp; Mitchell O'Hara-Wild
</p>


<h3>References</h3>

<p>Box, G. E. P. and Cox, D. R. (1964) An analysis of
transformations. <em>JRSS B</em> <b>26</b> 211&ndash;246.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsibble)
library(dplyr)
airmiles %&gt;% 
  as_tsibble() %&gt;% 
  mutate(box_cox = box_cox(value, lambda = 0.3))

</code></pre>

<hr>
<h2 id='combination_ensemble'>Ensemble combination</h2><span id='topic+combination_ensemble'></span>

<h3>Description</h3>

<p>Ensemble combination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combination_ensemble(..., weights = c("equal", "inv_var"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combination_ensemble_+3A_...">...</code></td>
<td>
<p>Estimated models used in the ensemble.</p>
</td></tr>
<tr><td><code id="combination_ensemble_+3A_weights">weights</code></td>
<td>
<p>The method used to weight each model in the ensemble.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="fabletools.html#topic+combination_weighted">combination_weighted()</a></code>
</p>

<hr>
<h2 id='combination_model'>Combination modelling</h2><span id='topic+combination_model'></span>

<h3>Description</h3>

<p>Combines multiple model definitions (passed via <code>...</code>) to produce a model
combination definition using some combination function (<code>cmbn_fn</code>). Currently
distributional forecasts are only supported for models producing normally
distributed forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combination_model(..., cmbn_fn = combination_ensemble, cmbn_args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combination_model_+3A_...">...</code></td>
<td>
<p>Model definitions used in the combination.</p>
</td></tr>
<tr><td><code id="combination_model_+3A_cmbn_fn">cmbn_fn</code></td>
<td>
<p>A function used to produce the combination.</p>
</td></tr>
<tr><td><code id="combination_model_+3A_cmbn_args">cmbn_args</code></td>
<td>
<p>Additional arguments passed to <code>cmbn_fn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A combination model can also be produced using mathematical operations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(tsibble)
library(tsibbledata)

# cmbn1 and cmbn2 are equivalent and equally weighted.
aus_production %&gt;%
  model(
    cmbn1 = combination_model(SNAIVE(Beer), TSLM(Beer ~ trend() + season())),
    cmbn2 = (SNAIVE(Beer) + TSLM(Beer ~ trend() + season()))/2
  )

# An inverse variance weighted ensemble.
aus_production %&gt;%
  model(
    cmbn1 = combination_model(
      SNAIVE(Beer), TSLM(Beer ~ trend() + season()), 
      cmbn_args = list(weights = "inv_var")
    )
  )

</code></pre>

<hr>
<h2 id='combination_weighted'>Weighted combination</h2><span id='topic+combination_weighted'></span>

<h3>Description</h3>

<p>Weighted combination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combination_weighted(..., weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combination_weighted_+3A_...">...</code></td>
<td>
<p>Estimated models used in the ensemble.</p>
</td></tr>
<tr><td><code id="combination_weighted_+3A_weights">weights</code></td>
<td>
<p>The numeric weights applied to each model in <code>...</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="fabletools.html#topic+combination_ensemble">combination_ensemble()</a></code>
</p>

<hr>
<h2 id='common_periods'>Extract frequencies for common seasonal periods</h2><span id='topic+common_periods'></span><span id='topic+common_periods.default'></span><span id='topic+common_periods.tbl_ts'></span><span id='topic+common_periods.interval'></span><span id='topic+get_frequencies'></span><span id='topic+get_frequencies.numeric'></span><span id='topic+get_frequencies.NULL'></span><span id='topic+get_frequencies.character'></span><span id='topic+get_frequencies.Period'></span>

<h3>Description</h3>

<p>Extract frequencies for common seasonal periods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common_periods(x)

## Default S3 method:
common_periods(x)

## S3 method for class 'tbl_ts'
common_periods(x)

## S3 method for class 'interval'
common_periods(x)

get_frequencies(period, ...)

## S3 method for class 'numeric'
get_frequencies(period, ...)

## S3 method for class ''NULL''
get_frequencies(period, data, ..., .auto = c("smallest", "largest", "all"))

## S3 method for class 'character'
get_frequencies(period, data, ...)

## S3 method for class 'Period'
get_frequencies(period, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="common_periods_+3A_x">x</code></td>
<td>
<p>An object containing temporal data (such as a <code>tsibble</code>, <code>interval</code>, <code>datetime</code> and others.)</p>
</td></tr>
<tr><td><code id="common_periods_+3A_period">period</code></td>
<td>
<p>Specification of the time-series period</p>
</td></tr>
<tr><td><code id="common_periods_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed on to methods</p>
</td></tr>
<tr><td><code id="common_periods_+3A_data">data</code></td>
<td>
<p>A tsibble</p>
</td></tr>
<tr><td><code id="common_periods_+3A_.auto">.auto</code></td>
<td>
<p>The method used to automatically select the appropriate seasonal
periods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of frequencies appropriate for the provided data.
</p>


<h3>References</h3>

<p><a href="https://robjhyndman.com/hyndsight/seasonal-periods/">https://robjhyndman.com/hyndsight/seasonal-periods/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>common_periods(tsibble::pedestrian)

</code></pre>

<hr>
<h2 id='common_xregs'>Common exogenous regressors</h2><span id='topic+common_xregs'></span>

<h3>Description</h3>

<p>These special functions provide interfaces to more complicated functions within
the model formulae interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common_xregs
</code></pre>


<h3>Specials</h3>



<h4>trend</h4>

<p>The <code>trend</code> special includes common linear trend regressors in the model. It also supports piecewise linear trend via the <code>knots</code> argument.
</p>
<pre>
trend(knots = NULL, origin = NULL)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>knots</code>    </td><td style="text-align: left;"> A vector of times (same class as the data's time index) identifying the position of knots for a piecewise linear trend.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>origin</code>   </td><td style="text-align: left;"> An optional time value to act as the starting time for the trend.
</td>
</tr>

</table>




<h4>season</h4>

<p>The <code>season</code> special includes seasonal dummy variables in the model.
</p>
<pre>
season(period = NULL)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>period</code>   </td><td style="text-align: left;"> The periodic nature of the seasonality. This can be either a number indicating the number of observations in each seasonal period, or text to indicate the duration of the seasonal window (for example, annual seasonality would be "1 year").
</td>
</tr>

</table>




<h4>fourier</h4>

<p>The <code>fourier</code> special includes seasonal fourier terms in the model. The maximum order of the fourier terms must be specified using <code>K</code>.
</p>
<pre>
fourier(period = NULL, K, origin = NULL)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>period</code>   </td><td style="text-align: left;"> The periodic nature of the seasonality. This can be either a number indicating the number of observations in each seasonal period, or text to indicate the duration of the seasonal window (for example, annual seasonality would be "1 year"). </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>K</code>        </td><td style="text-align: left;"> The maximum order of the fourier terms.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>origin</code>   </td><td style="text-align: left;"> An optional time value to act as the starting time for the fourier series.
</td>
</tr>

</table>



<hr>
<h2 id='components.mdl_df'>Extract components from a fitted model</h2><span id='topic+components.mdl_df'></span><span id='topic+components.mdl_ts'></span>

<h3>Description</h3>

<p>Allows you to extract elements of interest from the model which can be
useful in understanding how they contribute towards the overall fitted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
components(object, ...)

## S3 method for class 'mdl_ts'
components(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="components.mdl_df_+3A_object">object</code></td>
<td>
<p>A mable.</p>
</td></tr>
<tr><td><code id="components.mdl_df_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A dable will be returned, which will allow you to easily plot the components
and see the way in which components are combined to give forecasts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(tsibbledata)

# Forecasting with an ETS(M,Ad,A) model to Australian beer production
aus_production %&gt;%
  model(ets = ETS(log(Beer) ~ error("M") + trend("Ad") + season("A"))) %&gt;% 
  components() %&gt;% 
  autoplot()

</code></pre>

<hr>
<h2 id='construct_fc'>Construct a new set of forecasts</h2><span id='topic+construct_fc'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function is deprecated. <code>forecast()</code> methods for a model should return
a vector of distributions using the distributional package.
</p>
<p>Backtransformations are automatically handled, and so no transformations should be specified here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_fc(point, sd, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_fc_+3A_point">point</code></td>
<td>
<p>The transformed point forecasts</p>
</td></tr>
<tr><td><code id="construct_fc_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the transformed forecasts</p>
</td></tr>
<tr><td><code id="construct_fc_+3A_dist">dist</code></td>
<td>
<p>The forecast distribution (typically produced using <code>new_fcdist</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='dable'>Create a dable object</h2><span id='topic+dable'></span>

<h3>Description</h3>

<p>A dable (decomposition table) data class (<code>dcmp_ts</code>) which is a tsibble-like
data structure for representing decompositions. This data class is useful for
representing decompositions, as its print method describes how its columns
can be combined to produce the original data, and has a more appropriate
<code>autoplot()</code> method for displaying decompositions. Beyond this, a dable
(<code>dcmp_ts</code>) behaves very similarly to a tsibble (<code>tbl_ts</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dable(..., response, method = NULL, seasons = list(), aliases = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dable_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="tsibble.html#topic+tsibble">tsibble::tsibble()</a></code>.</p>
</td></tr>
<tr><td><code id="dable_+3A_response">response</code></td>
<td>
<p>The name of the response variable column.</p>
</td></tr>
<tr><td><code id="dable_+3A_method">method</code></td>
<td>
<p>The name of the decomposition method.</p>
</td></tr>
<tr><td><code id="dable_+3A_seasons">seasons</code></td>
<td>
<p>A named list describing the structure of seasonal components
(such as <code>period</code>, and <code>base</code>).</p>
</td></tr>
<tr><td><code id="dable_+3A_aliases">aliases</code></td>
<td>
<p>A named list of calls describing common aliases computed from
components.</p>
</td></tr>
</table>

<hr>
<h2 id='dable-vctrs'>Internal vctrs methods</h2><span id='topic+dable-vctrs'></span><span id='topic+vec_ptype2.dcmp_ts'></span><span id='topic+vec_cast.dcmp_ts'></span>

<h3>Description</h3>

<p>These methods are the extensions that allow dable objects to
work with vctrs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcmp_ts'
vec_ptype2(x, y, ...)

## S3 method for class 'dcmp_ts'
vec_cast(x, to, ...)
</code></pre>

<hr>
<h2 id='decomposition_model'>Decomposition modelling</h2><span id='topic+decomposition_model'></span>

<h3>Description</h3>

<p>This function allows you to specify a decomposition combination model using
any additive decomposition. It works by first decomposing the data using the
decomposition method provided to <code>dcmp_fn</code> with the given formula. Secondary
models are used to fit each of the components from the resulting
decomposition. These models are specified after the decomposition formula.
All non-seasonal decomposition components must be specified, and any
unspecified seasonal components will be forecasted using seasonal naive.
These component models will be combined according to the decomposition
method, giving a combination model for the response of the decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposition_model(dcmp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomposition_model_+3A_dcmp">dcmp</code></td>
<td>
<p>A model definition which supports extracting decomposed <code><a href="fabletools.html#topic+components">components()</a></code>.</p>
</td></tr>
<tr><td><code id="decomposition_model_+3A_...">...</code></td>
<td>
<p>Model definitions used to model the components</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://otexts.com/fpp3/forecasting-decomposition.html"><em>Forecasting: Principles and Practice</em> - Forecasting Decomposition</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(feasts)
library(tsibble)
library(dplyr)

vic_food &lt;- tsibbledata::aus_retail %&gt;% 
  filter(State == "Victoria", Industry == "Food retailing")
  
# Identify an appropriate decomposition
vic_food %&gt;% 
  model(STL(log(Turnover) ~ season(window = Inf))) %&gt;% 
  components() %&gt;% 
  autoplot()
  
# Use an ARIMA model to seasonally adjusted data, and SNAIVE to season_year
# Any model can be used, and seasonal components will default to use SNAIVE.
my_dcmp_spec &lt;- decomposition_model(
  STL(log(Turnover) ~ season(window = Inf)),
  ETS(season_adjust ~ season("N")), SNAIVE(season_year)
)

vic_food %&gt;%
  model(my_dcmp_spec) %&gt;% 
  forecast(h="5 years") %&gt;% 
  autoplot(vic_food)

</code></pre>

<hr>
<h2 id='distribution_var'>Return distribution variable</h2><span id='topic+distribution_var'></span>

<h3>Description</h3>

<p><code>distribution_var()</code> returns a character vector of the distribution variable
in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distribution_var(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribution_var_+3A_x">x</code></td>
<td>
<p>A dataset containing a distribution variable (such as a fable).</p>
</td></tr>
</table>

<hr>
<h2 id='estimate'>Estimate a model</h2><span id='topic+estimate'></span><span id='topic+estimate.tbl_ts'></span>

<h3>Description</h3>

<p>Estimate a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(.data, ...)

## S3 method for class 'tbl_ts'
estimate(.data, .model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_+3A_.data">.data</code></td>
<td>
<p>A data structure suitable for the models (such as a <code>tsibble</code>).</p>
</td></tr>
<tr><td><code id="estimate_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="estimate_+3A_.model">.model</code></td>
<td>
<p>Definition for the model to be used.</p>
</td></tr>
</table>

<hr>
<h2 id='fable'>Create a fable object</h2><span id='topic+fable'></span>

<h3>Description</h3>

<p>A fable (forecast table) data class (<code>fbl_ts</code>) which is a tsibble-like data
structure for representing forecasts. In extension to the key and index from
the tsibble (<code>tbl_ts</code>) class, a fable (<code>fbl_ts</code>) must also contain a single
distribution column that uses values from the distributional package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fable(..., response, distribution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fable_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="tsibble.html#topic+tsibble">tsibble::tsibble()</a></code>.</p>
</td></tr>
<tr><td><code id="fable_+3A_response">response</code></td>
<td>
<p>The character vector of response variable(s).</p>
</td></tr>
<tr><td><code id="fable_+3A_distribution">distribution</code></td>
<td>
<p>The name of the distribution column (can be provided
using a bare expression).</p>
</td></tr>
</table>

<hr>
<h2 id='fable-vctrs'>Internal vctrs methods</h2><span id='topic+fable-vctrs'></span><span id='topic+vec_ptype2.fbl_ts'></span><span id='topic+vec_cast.fbl_ts'></span>

<h3>Description</h3>

<p>These methods are the extensions that allow fable objects to
work with vctrs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fbl_ts'
vec_ptype2(x, y, ...)

## S3 method for class 'fbl_ts'
vec_cast(x, to, ...)
</code></pre>

<hr>
<h2 id='fabletools-package'>fabletools: Core Tools for Packages in the 'fable' Framework</h2><span id='topic+fabletools'></span><span id='topic+fabletools-package'></span>

<h3>Description</h3>

<p>Provides tools, helpers and data structures for developing models and time series functions for 'fable' and extension packages. These tools support a consistent and tidy interface for time series modelling and analysis.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mitchell O'Hara-Wild <a href="mailto:mail@mitchelloharawild.com">mail@mitchelloharawild.com</a> (<a href="https://orcid.org/0000-0001-6729-7695">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Rob Hyndman
</p>
</li>
<li><p> Earo Wang (<a href="https://orcid.org/0000-0001-6448-5260">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Di Cook [contributor]
</p>
</li>
<li><p> George Athanasopoulos [contributor]
</p>
</li>
<li><p> David Holt [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://fabletools.tidyverts.org/">https://fabletools.tidyverts.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverts/fabletools">https://github.com/tidyverts/fabletools</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverts/fabletools/issues">https://github.com/tidyverts/fabletools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='feature_set'>Create a feature set from tags</h2><span id='topic+feature_set'></span>

<h3>Description</h3>

<p>Construct a feature set from features available in currently loaded packages.
Lists of available features can be found in the following pages:
</p>

<ul>
<li> <p><a href="fabletools.html#topic+features_by_pkg">Features by package</a>
</p>
</li>
<li> <p><a href="fabletools.html#topic+features_by_tag">Features by tag</a>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>feature_set(pkgs = NULL, tags = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feature_set_+3A_pkgs">pkgs</code></td>
<td>
<p>The package(s) from which to search for features. If <code>NULL</code>,
all registered features from currently loaded packages will be searched.</p>
</td></tr>
<tr><td><code id="feature_set_+3A_tags">tags</code></td>
<td>
<p>Tags used to identify similar groups of features. If <code>NULL</code>,
all tags will be included.</p>
</td></tr>
</table>


<h3>Registering features</h3>

<p>Features can be registered for use with the <code>feature_set()</code> function using
<code><a href="fabletools.html#topic+register_feature">register_feature()</a></code>. This function allows you to register a feature along
with the tags associated with it. If the features are being registered from
within a package, this feature registration should happen at load time using
<code style="white-space: pre;">&#8288;[.onLoad()]&#8288;</code>.
</p>

<hr>
<h2 id='features'>Extract features from a dataset</h2><span id='topic+features'></span><span id='topic+features_at'></span><span id='topic+features_all'></span><span id='topic+features_if'></span>

<h3>Description</h3>

<p>Create scalar valued summary features for a dataset from feature functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>features(.tbl, .var, features, ...)

features_at(.tbl, .vars, features, ...)

features_all(.tbl, features, ...)

features_if(.tbl, .predicate, features, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="features_+3A_.tbl">.tbl</code></td>
<td>
<p>A dataset</p>
</td></tr>
<tr><td><code id="features_+3A_.var">.var</code>, <code id="features_+3A_.vars">.vars</code></td>
<td>
<p>The variable(s) to compute features on</p>
</td></tr>
<tr><td><code id="features_+3A_features">features</code></td>
<td>
<p>A list of functions (or lambda expressions) for the features to compute. <code><a href="fabletools.html#topic+feature_set">feature_set()</a></code> is a useful helper for building sets of features.</p>
</td></tr>
<tr><td><code id="features_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to each feature. These arguments will only be passed to features which use it in their formal arguments (<code><a href="base.html#topic+formals">base::formals()</a></code>), and not via their <code>...</code>. While passing <code>na.rm = TRUE</code> to <code><a href="stats.html#topic+cor">stats::var()</a></code> will work, it will not for <code><a href="base.html#topic+mean">base::mean()</a></code> as its formals are <code>x</code> and <code>...</code>. To more precisely pass inputs to each function, you should use lambdas in the list of features (<code>~ mean(., na.rm = TRUE)</code>).</p>
</td></tr>
<tr><td><code id="features_+3A_.predicate">.predicate</code></td>
<td>
<p>A predicate function (or lambda expression) to be applied to the columns or a logical vector. The variables for which .predicate is or returns TRUE are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lists of available features can be found in the following pages:
</p>

<ul>
<li> <p><a href="fabletools.html#topic+features_by_pkg">Features by package</a>
</p>
</li>
<li> <p><a href="fabletools.html#topic+features_by_tag">Features by tag</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="fabletools.html#topic+feature_set">feature_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Provide a set of functions as a named list to features.
library(tsibble)
tourism %&gt;% 
  features(Trips, features = list(mean = mean, sd = sd))

# Search and use useful features with `feature_set()`. 


library(feasts)

tourism %&gt;% 
  features(Trips, features = feature_set(tags = "autocorrelation"))

# Best practice is to use anonymous functions for additional arguments
tourism %&gt;% 
  features(Trips, list(~ quantile(., probs=seq(0,1,by=0.2))))


</code></pre>

<hr>
<h2 id='features_by_pkg'>Features by package</h2><span id='topic+features_by_pkg'></span>

<h3>Description</h3>

<p>This documentation lists all available in currently loaded packages. This is
a useful reference for making a <code><a href="fabletools.html#topic+feature_set">feature_set()</a></code> from particular package(s).
</p>


<h3>Details</h3>

<p>No features found in currently loaded packages.
</p>


<h3>See Also</h3>

<p><a href="fabletools.html#topic+features_by_tag">features_by_tag</a>
</p>

<hr>
<h2 id='features_by_tag'>Features by tag</h2><span id='topic+features_by_tag'></span>

<h3>Description</h3>

<p>This documentation lists all available in currently loaded packages. This is
a useful reference for making a <code><a href="fabletools.html#topic+feature_set">feature_set()</a></code> from particular tag(s).
</p>


<h3>Details</h3>

<p>No features found in currently loaded packages.
</p>


<h3>See Also</h3>

<p><a href="fabletools.html#topic+features_by_pkg">features_by_pkg</a>
</p>

<hr>
<h2 id='fitted.mdl_df'>Extract fitted values from models</h2><span id='topic+fitted.mdl_df'></span><span id='topic+hfitted'></span><span id='topic+fitted.mdl_ts'></span>

<h3>Description</h3>

<p>Extracts the fitted values from each of the models in a mable. A tsibble will
be returned containing these fitted values. Fitted values will be
automatically back-transformed if a transformation was specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
fitted(object, ...)

## S3 method for class 'mdl_ts'
fitted(object, h = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.mdl_df_+3A_object">object</code></td>
<td>
<p>A mable or time series model.</p>
</td></tr>
<tr><td><code id="fitted.mdl_df_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the model method for <code>fitted()</code></p>
</td></tr>
<tr><td><code id="fitted.mdl_df_+3A_h">h</code></td>
<td>
<p>The number of steps ahead that these fitted values are computed from.</p>
</td></tr>
</table>

<hr>
<h2 id='forecast.mdl_df'>Produce forecasts</h2><span id='topic+forecast.mdl_df'></span><span id='topic+forecast.mdl_ts'></span>

<h3>Description</h3>

<p>The forecast function allows you to produce future predictions of a time series
from fitted models. If the response variable has been transformed in the
model formula, the transformation will be automatically back-transformed
(and bias adjusted if <code>bias_adjust</code> is <code>TRUE</code>). More details about
transformations in the fable framework can be found in
<code>vignette("transformations", package = "fable")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
forecast(
  object,
  new_data = NULL,
  h = NULL,
  point_forecast = list(.mean = mean),
  ...
)

## S3 method for class 'mdl_ts'
forecast(
  object,
  new_data = NULL,
  h = NULL,
  bias_adjust = NULL,
  simulate = FALSE,
  bootstrap = FALSE,
  times = 5000,
  point_forecast = list(.mean = mean),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.mdl_df_+3A_object">object</code></td>
<td>
<p>The time series model used to produce the forecasts</p>
</td></tr>
<tr><td><code id="forecast.mdl_df_+3A_new_data">new_data</code></td>
<td>
<p>A <code>tsibble</code> containing future information used to forecast.</p>
</td></tr>
<tr><td><code id="forecast.mdl_df_+3A_h">h</code></td>
<td>
<p>The forecast horison (can be used instead of <code>new_data</code> for regular
time series with no exogenous regressors).</p>
</td></tr>
<tr><td><code id="forecast.mdl_df_+3A_point_forecast">point_forecast</code></td>
<td>
<p>The point forecast measure(s) which should be returned
in the resulting fable. Specified as a named list of functions which accept
a distribution and return a vector. To compute forecast medians, you can use
<code>list(.median = median)</code>.</p>
</td></tr>
<tr><td><code id="forecast.mdl_df_+3A_...">...</code></td>
<td>
<p>Additional arguments for forecast model methods.</p>
</td></tr>
<tr><td><code id="forecast.mdl_df_+3A_bias_adjust">bias_adjust</code></td>
<td>
<p>Deprecated. Please use <code>point_forecast</code> to specify the
desired point forecast method.</p>
</td></tr>
<tr><td><code id="forecast.mdl_df_+3A_simulate">simulate</code></td>
<td>
<p>Should forecasts be based on simulated future paths instead
of analytical results.</p>
</td></tr>
<tr><td><code id="forecast.mdl_df_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Should innovations from simulated forecasts be bootstrapped
from the model's fitted residuals. This allows the forecast distribution to
have a different underlying shape which could better represent the nature
of your data.</p>
</td></tr>
<tr><td><code id="forecast.mdl_df_+3A_times">times</code></td>
<td>
<p>The number of future paths for simulations if <code>simulate = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The forecasts returned contain both point forecasts and their distribution.
A specific forecast interval can be extracted from the distribution using the
<code><a href="distributional.html#topic+hilo">hilo()</a></code> function, and multiple intervals can be obtained using <code><a href="fabletools.html#topic+report">report()</a></code>.
These intervals are stored in a single column using the <code>hilo</code> class, to
extract the numerical upper and lower bounds you can use <code><a href="fabletools.html#topic+unpack_hilo">unpack_hilo()</a></code>.
</p>


<h3>Value</h3>

<p>A fable containing the following columns:
</p>

<ul>
<li> <p><code>.model</code>: The name of the model used to obtain the forecast. Taken from
the column names of models in the provided mable.
</p>
</li>
<li><p> The forecast distribution. The name of this column will be the same as the
dependent variable in the model(s). If multiple dependent variables exist,
it will be named <code>.distribution</code>.
</p>
</li>
<li><p> Point forecasts computed from the distribution using the functions in the
<code>point_forecast</code> argument.
</p>
</li>
<li><p> All columns in <code>new_data</code>, excluding those whose names conflict with the
above.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(tsibble)
library(tsibbledata)
library(dplyr)
library(tidyr)

# Forecasting with an ETS(M,Ad,A) model to Australian beer production
beer_fc &lt;- aus_production %&gt;%
  model(ets = ETS(log(Beer) ~ error("M") + trend("Ad") + season("A"))) %&gt;% 
  forecast(h = "3 years")

# Compute 80% and 95% forecast intervals
beer_fc %&gt;% 
  hilo(level = c(80, 95))

beer_fc %&gt;% 
  autoplot(aus_production)

# Forecasting with a seasonal naive and linear model to the monthly 
# "Food retailing" turnover for each Australian state/territory.
library(dplyr)
aus_retail %&gt;% 
  filter(Industry == "Food retailing") %&gt;% 
  model(
    snaive = SNAIVE(Turnover),
    ets = TSLM(log(Turnover) ~ trend() + season()),
  ) %&gt;% 
  forecast(h = "2 years 6 months") %&gt;% 
  autoplot(filter(aus_retail, Month &gt;= yearmonth("2000 Jan")), level = 90)
  
# Forecast GDP with a dynamic regression model on log(GDP) using population and
# an automatically chosen ARIMA error structure. Assume that population is fixed
# in the future.
aus_economy &lt;- global_economy %&gt;% 
  filter(Country == "Australia")
fit &lt;- aus_economy %&gt;% 
  model(lm = ARIMA(log(GDP) ~ Population))

future_aus &lt;- new_data(aus_economy, n = 10) %&gt;% 
  mutate(Population = last(aus_economy$Population))

fit %&gt;% 
  forecast(new_data = future_aus) %&gt;% 
  autoplot(aus_economy)

</code></pre>

<hr>
<h2 id='generate.mdl_df'>Generate responses from a mable</h2><span id='topic+generate.mdl_df'></span><span id='topic+generate.mdl_ts'></span>

<h3>Description</h3>

<p>Use a model's fitted distribution to simulate additional data with similar
behaviour to the response. This is a tidy implementation of
<code style="white-space: pre;">&#8288;\link[stats]{simulate}&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
generate(x, new_data = NULL, h = NULL, times = 1, seed = NULL, ...)

## S3 method for class 'mdl_ts'
generate(
  x,
  new_data = NULL,
  h = NULL,
  times = 1,
  seed = NULL,
  bootstrap = FALSE,
  bootstrap_block_size = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.mdl_df_+3A_x">x</code></td>
<td>
<p>A mable.</p>
</td></tr>
<tr><td><code id="generate.mdl_df_+3A_new_data">new_data</code></td>
<td>
<p>The data to be generated (time index and exogenous regressors)</p>
</td></tr>
<tr><td><code id="generate.mdl_df_+3A_h">h</code></td>
<td>
<p>The simulation horizon (can be used instead of <code>new_data</code> for regular
time series with no exogenous regressors).</p>
</td></tr>
<tr><td><code id="generate.mdl_df_+3A_times">times</code></td>
<td>
<p>The number of replications.</p>
</td></tr>
<tr><td><code id="generate.mdl_df_+3A_seed">seed</code></td>
<td>
<p>The seed for the random generation from distributions.</p>
</td></tr>
<tr><td><code id="generate.mdl_df_+3A_...">...</code></td>
<td>
<p>Additional arguments for individual simulation methods.</p>
</td></tr>
<tr><td><code id="generate.mdl_df_+3A_bootstrap">bootstrap</code></td>
<td>
<p>If TRUE, then forecast distributions are computed using simulation with resampled errors.</p>
</td></tr>
<tr><td><code id="generate.mdl_df_+3A_bootstrap_block_size">bootstrap_block_size</code></td>
<td>
<p>The bootstrap block size specifies the number of contiguous residuals to be taken in each bootstrap sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Innovations are sampled by the model's assumed error distribution.
If <code>bootstrap</code> is <code>TRUE</code>, innovations will be sampled from the model's
residuals. If <code>new_data</code> contains the <code>.innov</code> column, those values will be
treated as innovations for the simulated paths..
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(dplyr)
UKLungDeaths &lt;- as_tsibble(cbind(mdeaths, fdeaths), pivot_longer = FALSE)
UKLungDeaths %&gt;% 
  model(lm = TSLM(mdeaths ~ fourier("year", K = 4) + fdeaths)) %&gt;% 
  generate(UKLungDeaths, times = 5)

</code></pre>

<hr>
<h2 id='glance.mdl_df'>Glance a mable</h2><span id='topic+glance.mdl_df'></span><span id='topic+glance.mdl_ts'></span>

<h3>Description</h3>

<p>Uses the models within a mable to produce a one row summary of their fits.
This typically contains information about the residual variance,
information criterion, and other relevant summary statistics. Each model
will be represented with a row of output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
glance(x, ...)

## S3 method for class 'mdl_ts'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.mdl_df_+3A_x">x</code></td>
<td>
<p>A mable.</p>
</td></tr>
<tr><td><code id="glance.mdl_df_+3A_...">...</code></td>
<td>
<p>Arguments for model methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(tsibbledata)

olympic_running %&gt;%
  model(lm = TSLM(log(Time) ~ trend())) %&gt;% 
  glance()

</code></pre>

<hr>
<h2 id='hypothesize.mdl_df'>Run a hypothesis test from a mable</h2><span id='topic+hypothesize.mdl_df'></span><span id='topic+hypothesize.mdl_ts'></span>

<h3>Description</h3>

<p>This function will return the results of a hypothesis test for each model in
the mable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
hypothesize(x, ...)

## S3 method for class 'mdl_ts'
hypothesize(x, tests = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypothesize.mdl_df_+3A_x">x</code></td>
<td>
<p>A mable.</p>
</td></tr>
<tr><td><code id="hypothesize.mdl_df_+3A_...">...</code></td>
<td>
<p>Arguments for model methods.</p>
</td></tr>
<tr><td><code id="hypothesize.mdl_df_+3A_tests">tests</code></td>
<td>
<p>a list of test functions to perform on the model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(tsibbledata)

olympic_running %&gt;%
  model(lm = TSLM(log(Time) ~ trend())) %&gt;% 
  hypothesize()

</code></pre>

<hr>
<h2 id='interpolate.mdl_df'>Interpolate missing values</h2><span id='topic+interpolate.mdl_df'></span><span id='topic+interpolate.mdl_ts'></span>

<h3>Description</h3>

<p>Uses a fitted model to interpolate missing values from a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
interpolate(object, new_data, ...)

## S3 method for class 'mdl_ts'
interpolate(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate.mdl_df_+3A_object">object</code></td>
<td>
<p>A mable containing a single model column.</p>
</td></tr>
<tr><td><code id="interpolate.mdl_df_+3A_new_data">new_data</code></td>
<td>
<p>A dataset with the same structure as the data used to fit the model.</p>
</td></tr>
<tr><td><code id="interpolate.mdl_df_+3A_...">...</code></td>
<td>
<p>Other arguments passed to interpolate methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(tsibbledata)

# The fastest running times for the olympics are missing for years during 
# world wars as the olympics were not held.
olympic_running

olympic_running %&gt;% 
  model(TSLM(Time ~ trend())) %&gt;% 
  interpolate(olympic_running)

</code></pre>

<hr>
<h2 id='is_aggregated'>Is the element an aggregation of smaller data</h2><span id='topic+is_aggregated'></span>

<h3>Description</h3>

<p>Is the element an aggregation of smaller data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_aggregated(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_aggregated_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="fabletools.html#topic+aggregate_key">aggregate_key</a></code>
</p>

<hr>
<h2 id='is_dable'>Is the object a dable</h2><span id='topic+is_dable'></span>

<h3>Description</h3>

<p>Is the object a dable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_dable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_dable_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>

<hr>
<h2 id='is_fable'>Is the object a fable</h2><span id='topic+is_fable'></span>

<h3>Description</h3>

<p>Is the object a fable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_fable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_fable_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>

<hr>
<h2 id='is_mable'>Is the object a mable</h2><span id='topic+is_mable'></span>

<h3>Description</h3>

<p>Is the object a mable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_mable_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>

<hr>
<h2 id='is_model'>Is the object a model</h2><span id='topic+is_model'></span>

<h3>Description</h3>

<p>Is the object a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_model(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_model_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>

<hr>
<h2 id='MAAPE'>Mean Arctangent Absolute Percentage Error</h2><span id='topic+MAAPE'></span>

<h3>Description</h3>

<p>Mean Arctangent Absolute Percentage Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAAPE(.resid, .actual, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAAPE_+3A_.resid">.resid</code></td>
<td>
<p>A vector of residuals from either the training (model accuracy)
or test (forecast accuracy) data.</p>
</td></tr>
<tr><td><code id="MAAPE_+3A_.actual">.actual</code></td>
<td>
<p>A vector of responses matching the fitted values
(for forecast accuracy, <code>new_data</code> must be provided).</p>
</td></tr>
<tr><td><code id="MAAPE_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove the missing values before calculating the accuracy measure</p>
</td></tr>
<tr><td><code id="MAAPE_+3A_...">...</code></td>
<td>
<p>Additional arguments for each measure.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kim, Sungil and Heeyoung Kim (2016) &quot;A new metric of absolute percentage error
for intermittent demand forecasts&quot;. <em>International Journal of Forecasting</em>,
<b>32</b>(3), 669-679.
</p>

<hr>
<h2 id='mable'>Create a new mable</h2><span id='topic+mable'></span>

<h3>Description</h3>

<p>A mable (model table) data class (<code>mdl_df</code>) is a tibble-like data structure
for applying multiple models to a dataset. Each row of the mable refers to a
different time series from the data (identified by the key columns). A mable
must contain at least one column of time series models (<code>mdl_ts</code>), where the
list column itself (<code>lst_mdl</code>) describes how these models are related.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable(..., key = NULL, model = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt;
A set of name-value pairs. These arguments are
processed with <code><a href="rlang.html#topic+defusing-advanced">rlang::quos()</a></code> and support unquote via <code><a href="rlang.html#topic++21+21">!!</a></code> and
unquote-splice via <code><a href="rlang.html#topic++21+21+21">!!!</a></code>. Use <code style="white-space: pre;">&#8288;:=&#8288;</code> to create columns that start with a dot.
</p>
<p>Arguments are evaluated sequentially.
You can refer to previously created elements directly or using the <a href="dplyr.html#topic+.data">.data</a>
pronoun.
To refer explicitly to objects in the calling environment, use <code><a href="rlang.html#topic++21+21">!!</a></code> or
<a href="igraph.html#topic+.env">.env</a>, e.g. <code>!!.data</code> or <code>.env$.data</code> for the special case of an object
named <code>.data</code>.</p>
</td></tr>
<tr><td><code id="mable_+3A_key">key</code></td>
<td>
<p>Structural variable(s) that identify each model.</p>
</td></tr>
<tr><td><code id="mable_+3A_model">model</code></td>
<td>
<p>Identifiers for the columns containing model(s).</p>
</td></tr>
</table>

<hr>
<h2 id='mable_vars'>Return model column variables</h2><span id='topic+mable_vars'></span>

<h3>Description</h3>

<p><code>mable_vars()</code> returns a character vector of the model variables in the
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable_vars(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable_vars_+3A_x">x</code></td>
<td>
<p>A dataset containing models (such as a mable).</p>
</td></tr>
</table>

<hr>
<h2 id='mable-vctrs'>Internal vctrs methods</h2><span id='topic+mable-vctrs'></span><span id='topic+vec_ptype2.mdl_df'></span><span id='topic+vec_cast.mdl_df'></span>

<h3>Description</h3>

<p>These methods are the extensions that allow mable objects to
work with vctrs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
vec_ptype2(x, y, ...)

## S3 method for class 'mdl_df'
vec_cast(x, to, ...)
</code></pre>

<hr>
<h2 id='MDA'>Directional accuracy measures</h2><span id='topic+MDA'></span><span id='topic+MDV'></span><span id='topic+MDPV'></span><span id='topic+directional_accuracy_measures'></span>

<h3>Description</h3>

<p>A collection of accuracy measures based on the accuracy of the prediction's
direction (say, increasing or decreasing).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDA(.resid, .actual, na.rm = TRUE, reward = 1, penalty = 0, ...)

MDV(.resid, .actual, na.rm = TRUE, ...)

MDPV(.resid, .actual, na.rm = TRUE, ...)

directional_accuracy_measures
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MDA_+3A_.resid">.resid</code></td>
<td>
<p>A vector of residuals from either the training (model accuracy)
or test (forecast accuracy) data.</p>
</td></tr>
<tr><td><code id="MDA_+3A_.actual">.actual</code></td>
<td>
<p>A vector of responses matching the fitted values
(for forecast accuracy, <code>new_data</code> must be provided).</p>
</td></tr>
<tr><td><code id="MDA_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove the missing values before calculating the accuracy measure</p>
</td></tr>
<tr><td><code id="MDA_+3A_reward">reward</code>, <code id="MDA_+3A_penalty">penalty</code></td>
<td>
<p>The weights given to correct and incorrect predicted
directions.</p>
</td></tr>
<tr><td><code id="MDA_+3A_...">...</code></td>
<td>
<p>Additional arguments for each measure.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>


<h3>Details</h3>

<p><code>MDA()</code>: Mean Directional Accuracy
<code>MDV()</code>: Mean Directional Value
<code>MDPV()</code>: Mean Directional Percentage Value
</p>


<h3>References</h3>

<p>Blaskowitz and H. Herwartz (2011) &quot;On economic evaluation of directional forecasts&quot;. <em>International Journal of Forecasting</em>,
<b>27</b>(4), 1058-1065.
</p>

<hr>
<h2 id='ME'>Point estimate accuracy measures</h2><span id='topic+ME'></span><span id='topic+MSE'></span><span id='topic+RMSE'></span><span id='topic+MAE'></span><span id='topic+MPE'></span><span id='topic+MAPE'></span><span id='topic+MASE'></span><span id='topic+RMSSE'></span><span id='topic+ACF1'></span><span id='topic+point_accuracy_measures'></span>

<h3>Description</h3>

<p>Point estimate accuracy measures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ME(.resid, na.rm = TRUE, ...)

MSE(.resid, na.rm = TRUE, ...)

RMSE(.resid, na.rm = TRUE, ...)

MAE(.resid, na.rm = TRUE, ...)

MPE(.resid, .actual, na.rm = TRUE, ...)

MAPE(.resid, .actual, na.rm = TRUE, ...)

MASE(
  .resid,
  .train,
  demean = FALSE,
  na.rm = TRUE,
  .period,
  d = .period == 1,
  D = .period &gt; 1,
  ...
)

RMSSE(
  .resid,
  .train,
  demean = FALSE,
  na.rm = TRUE,
  .period,
  d = .period == 1,
  D = .period &gt; 1,
  ...
)

ACF1(.resid, na.action = stats::na.pass, demean = TRUE, ...)

point_accuracy_measures
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ME_+3A_.resid">.resid</code></td>
<td>
<p>A vector of residuals from either the training (model accuracy)
or test (forecast accuracy) data.</p>
</td></tr>
<tr><td><code id="ME_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove the missing values before calculating the accuracy measure</p>
</td></tr>
<tr><td><code id="ME_+3A_...">...</code></td>
<td>
<p>Additional arguments for each measure.</p>
</td></tr>
<tr><td><code id="ME_+3A_.actual">.actual</code></td>
<td>
<p>A vector of responses matching the fitted values
(for forecast accuracy, <code>new_data</code> must be provided).</p>
</td></tr>
<tr><td><code id="ME_+3A_.train">.train</code></td>
<td>
<p>A vector of responses used to train the model
(for forecast accuracy, the <code>orig_data</code> must be provided).</p>
</td></tr>
<tr><td><code id="ME_+3A_demean">demean</code></td>
<td>
<p>Should the response be demeaned (MASE)</p>
</td></tr>
<tr><td><code id="ME_+3A_.period">.period</code></td>
<td>
<p>The seasonal period of the data (defaulting to 'smallest' seasonal period).
from a model, or forecasted values from the forecast.</p>
</td></tr>
<tr><td><code id="ME_+3A_d">d</code></td>
<td>
<p>Should the response model include a first difference?</p>
</td></tr>
<tr><td><code id="ME_+3A_d">D</code></td>
<td>
<p>Should the response model include a seasonal difference?</p>
</td></tr>
<tr><td><code id="ME_+3A_na.action">na.action</code></td>
<td>
<p>Function to handle missing values.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 8.
</p>

<hr>
<h2 id='middle_out'>Middle out forecast reconciliation</h2><span id='topic+middle_out'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>middle_out(models, split = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="middle_out_+3A_models">models</code></td>
<td>
<p>A column of models in a mable.</p>
</td></tr>
<tr><td><code id="middle_out_+3A_split">split</code></td>
<td>
<p>The middle level of the hierarchy from which the bottom-up and
top-down approaches are used above and below respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reconciles a hierarchy using the middle out reconciliation method. The
response variable of the hierarchy must be aggregated using sums. The
forecasted time points must match for all series in the hierarchy.
</p>


<h3>See Also</h3>

<p><code><a href="fabletools.html#topic+reconcile">reconcile()</a></code>, <code><a href="fabletools.html#topic+aggregate_key">aggregate_key()</a></code>
<a href="https://otexts.com/fpp3/single-level.html#middle-out-approach"><em>Forecasting: Principles and Practice</em> - Middle-out approach</a>
</p>

<hr>
<h2 id='min_trace'>Minimum trace forecast reconciliation</h2><span id='topic+min_trace'></span>

<h3>Description</h3>

<p>Reconciles a hierarchy using the minimum trace combination method. The
response variable of the hierarchy must be aggregated using sums. The
forecasted time points must match for all series in the hierarchy (caution:
this is not yet tested for beyond the series length).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_trace(
  models,
  method = c("wls_var", "ols", "wls_struct", "mint_cov", "mint_shrink"),
  sparse = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_trace_+3A_models">models</code></td>
<td>
<p>A column of models in a mable.</p>
</td></tr>
<tr><td><code id="min_trace_+3A_method">method</code></td>
<td>
<p>The reconciliation method to use.</p>
</td></tr>
<tr><td><code id="min_trace_+3A_sparse">sparse</code></td>
<td>
<p>If TRUE, the reconciliation will be computed using sparse
matrix algebra? By default, sparse matrices will be used if the MatrixM
package is installed.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wickramasuriya, S. L., Athanasopoulos, G., &amp; Hyndman, R. J. (2019). Optimal forecast reconciliation for hierarchical and grouped time series through trace minimization. Journal of the American Statistical Association, 1-45. https://doi.org/10.1080/01621459.2018.1448825
</p>


<h3>See Also</h3>

<p><code><a href="fabletools.html#topic+reconcile">reconcile()</a></code>, <code><a href="fabletools.html#topic+aggregate_key">aggregate_key()</a></code>
</p>

<hr>
<h2 id='model'>Estimate models</h2><span id='topic+model'></span><span id='topic+model.tbl_ts'></span>

<h3>Description</h3>

<p>Trains specified model definition(s) to a dataset. This function will
estimate the a set of model definitions (passed via <code>...</code>) to each series
within <code>.data</code> (as identified by the key structure). The result will be a
mable (a model table), which neatly stores the estimated models in a tabular
structure. Rows of the data identify different series within the data, and
each model column contains all models from that model definition. Each cell
in the mable identifies a single model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model(.data, ...)

## S3 method for class 'tbl_ts'
model(.data, ..., .safely = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_+3A_.data">.data</code></td>
<td>
<p>A data structure suitable for the models (such as a <code>tsibble</code>)</p>
</td></tr>
<tr><td><code id="model_+3A_...">...</code></td>
<td>
<p>Definitions for the models to be used. All models must share the
same response variable.</p>
</td></tr>
<tr><td><code id="model_+3A_.safely">.safely</code></td>
<td>
<p>If a model encounters an error, rather than aborting the process a <a href="fabletools.html#topic+null_model">NULL model</a> will be returned instead. This allows for an error to occur when computing many models, without losing the results of the successful models.</p>
</td></tr>
</table>


<h3>Parallel</h3>

<p>It is possible to estimate models in parallel using the
<a href="https://cran.r-project.org/package=future">future</a> package. By specifying a
<code><a href="future.html#topic+plan">future::plan()</a></code> before estimating the models, they will be computed
according to that plan.
</p>


<h3>Progress</h3>

<p>Progress on model estimation can be obtained by wrapping the code with
<code>progressr::with_progress()</code>. Further customisation on how progress is
reported can be controlled using the <code>progressr</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(tsibbledata)

# Training an ETS(M,Ad,A) model to Australian beer production
aus_production %&gt;%
  model(ets = ETS(log(Beer) ~ error("M") + trend("Ad") + season("A")))

# Training a seasonal naive and ETS(A,A,A) model to the monthly 
# "Food retailing" turnover for selected Australian states.
library(dplyr)
progressr::with_progress(
aus_retail %&gt;% 
  filter(
    Industry == "Food retailing",
    State %in% c("Victoria", "New South Wales", "Queensland")
  ) %&gt;% 
  model(
    snaive = SNAIVE(Turnover),
    ets = ETS(log(Turnover) ~ error("A") + trend("A") + season("A")),
  )
)

</code></pre>

<hr>
<h2 id='model_lhs'>Extract the left hand side of a model</h2><span id='topic+model_lhs'></span>

<h3>Description</h3>

<p>Extract the left hand side of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_lhs(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_lhs_+3A_model">model</code></td>
<td>
<p>A formula</p>
</td></tr>
</table>

<hr>
<h2 id='model_rhs'>Extract the right hand side of a model</h2><span id='topic+model_rhs'></span>

<h3>Description</h3>

<p>Extract the right hand side of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_rhs(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_rhs_+3A_model">model</code></td>
<td>
<p>A formula</p>
</td></tr>
</table>

<hr>
<h2 id='model_sum'>Provide a succinct summary of a model</h2><span id='topic+model_sum'></span>

<h3>Description</h3>

<p>Similarly to pillar's type_sum and obj_sum, model_sum is used to provide brief model summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_sum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_sum_+3A_x">x</code></td>
<td>
<p>The model to summarise</p>
</td></tr>
</table>

<hr>
<h2 id='new_model_class'>Create a new class of models</h2><span id='topic+new_model_class'></span><span id='topic+new_model_definition'></span>

<h3>Description</h3>

<p>Suitable for extension packages to create new models for fable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_model_class(
  model = "Unknown model",
  train = function(.data, formula, specials, ...)
    abort("This model has not defined a training method."),
  specials = new_specials(),
  check = function(.data) {
 },
  prepare = function(...) {
 },
  ...,
  .env = caller_env(),
  .inherit = model_definition
)

new_model_definition(.class, formula, ..., .env = caller_env(n = 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_model_class_+3A_model">model</code></td>
<td>
<p>The name of the model</p>
</td></tr>
<tr><td><code id="new_model_class_+3A_train">train</code></td>
<td>
<p>A function that trains the model to a dataset. <code>.data</code> is a tsibble
containing the data's index and response variables only. <code>formula</code> is the
user's provided formula. <code>specials</code> is the evaluated specials used in the formula.</p>
</td></tr>
<tr><td><code id="new_model_class_+3A_specials">specials</code></td>
<td>
<p>Special functions produced using <code><a href="fabletools.html#topic+new_specials">new_specials()</a></code></p>
</td></tr>
<tr><td><code id="new_model_class_+3A_check">check</code></td>
<td>
<p>A function that is used to check the data for suitability with
the model. This can be used to check for missing values (both implicit and
explicit), regularity of observations, ordered time index, and univariate
responses.</p>
</td></tr>
<tr><td><code id="new_model_class_+3A_prepare">prepare</code></td>
<td>
<p>This allows you to modify the model class according to user
inputs. <code>...</code> is the arguments passed to <code>new_model_definition</code>, allowing
you to perform different checks or training procedures according to different
user inputs.</p>
</td></tr>
<tr><td><code id="new_model_class_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="R6.html#topic+R6Class">R6::R6Class()</a></code>. This can be useful to set up
additional elements used in the other functions. For example, to use
<code>common_xregs</code>, an <code>origin</code> element in the model is used to store
the origin for <code>trend()</code> and <code>fourier()</code> specials. To use these specials, you
must add an <code>origin</code> element to the object (say with <code>origin = NULL</code>).</p>
</td></tr>
<tr><td><code id="new_model_class_+3A_.env">.env</code></td>
<td>
<p>The environment from which functions should inherit from.</p>
</td></tr>
<tr><td><code id="new_model_class_+3A_.inherit">.inherit</code></td>
<td>
<p>A model class to inherit from.</p>
</td></tr>
<tr><td><code id="new_model_class_+3A_.class">.class</code></td>
<td>
<p>A model class (typically created with <code><a href="fabletools.html#topic+new_model_class">new_model_class()</a></code>).</p>
</td></tr>
<tr><td><code id="new_model_class_+3A_formula">formula</code></td>
<td>
<p>The user's model formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a new R6 model definition. An understanding of R6 is
not required, however could be useful to provide more sophisticated model
interfaces. All functions have access to <code>self</code>, allowing the functions for
training the model and evaluating specials to access the model class itself.
This can be useful to obtain elements set in the %TODO
</p>

<hr>
<h2 id='new_specials'>Create evaluation environment for specials</h2><span id='topic+new_specials'></span>

<h3>Description</h3>

<p>Allows extension packages to make use of the formula parsing of specials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_specials(..., .required_specials = NULL, .xreg_specials = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_specials_+3A_...">...</code></td>
<td>
<p>A named set of functions which used to parse formula inputs</p>
</td></tr>
<tr><td><code id="new_specials_+3A_.required_specials">.required_specials</code></td>
<td>
<p>The names of specials which must be provided (and if not, are included with no inputs).</p>
</td></tr>
<tr><td><code id="new_specials_+3A_.xreg_specials">.xreg_specials</code></td>
<td>
<p>The names of specials which will be only used as inputs to other specials (most commonly <code>xreg</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='new_transformation'>Create a new modelling transformation</h2><span id='topic+new_transformation'></span><span id='topic+invert_transformation'></span>

<h3>Description</h3>

<p>Produces a new transformation for fable modelling functions which will be used to transform, back-transform, and adjust forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_transformation(transformation, inverse)

invert_transformation(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_transformation_+3A_transformation">transformation</code></td>
<td>
<p>A function which transforms the data</p>
</td></tr>
<tr><td><code id="new_transformation_+3A_inverse">inverse</code></td>
<td>
<p>A function which is the inverse of a transformation</p>
</td></tr>
<tr><td><code id="new_transformation_+3A_x">x</code></td>
<td>
<p>A transformation (such as one created with <code>new_transformation</code>).</p>
</td></tr>
<tr><td><code id="new_transformation_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details about transformations, read the vignette:
<code>vignette("transformations", package = "fable")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
scaled_logit &lt;- function(x, lower=0, upper=1){
  log((x-lower)/(upper-x))
}
inv_scaled_logit &lt;- function(x, lower=0, upper=1){
  (upper-lower)*exp(x)/(1+exp(x)) + lower
}
my_scaled_logit &lt;- new_transformation(scaled_logit, inv_scaled_logit)

t_vals &lt;- my_scaled_logit(1:10, 0, 100)
t_vals

</code></pre>

<hr>
<h2 id='null_model'>NULL model</h2><span id='topic+null_model'></span><span id='topic+is_null_model'></span>

<h3>Description</h3>

<p>Create a NULL model definition. This model produces NA forecasts and does not
require any estimation of the data. It is generally used as a placeholder for
models which have encountered an error (see <code>.safely</code> in <code><a href="fabletools.html#topic+model">model()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_model(formula, ...)

is_null_model(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_model_+3A_formula">formula</code></td>
<td>
<p>Model specification (response variable)</p>
</td></tr>
<tr><td><code id="null_model_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="null_model_+3A_x">x</code></td>
<td>
<p>The object to be tested.</p>
</td></tr>
</table>

<hr>
<h2 id='outliers'>Identify outliers</h2><span id='topic+outliers'></span><span id='topic+outliers.mdl_df'></span><span id='topic+outliers.mdl_ts'></span>

<h3>Description</h3>

<p>Return a table of outlying observations using a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outliers(object, ...)

## S3 method for class 'mdl_df'
outliers(object, ...)

## S3 method for class 'mdl_ts'
outliers(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outliers_+3A_object">object</code></td>
<td>
<p>An object which can identify outliers.</p>
</td></tr>
<tr><td><code id="outliers_+3A_...">...</code></td>
<td>
<p>Arguments for further methods.</p>
</td></tr>
</table>

<hr>
<h2 id='parse_model'>Parse the model specification for specials</h2><span id='topic+parse_model'></span>

<h3>Description</h3>

<p>Using a list of defined special functions, the user's formula specification and data
is parsed to extract important modelling components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_model(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_model_+3A_model">model</code></td>
<td>
<p>A model definition</p>
</td></tr>
</table>

<hr>
<h2 id='parse_model_lhs'>Parse the RHS of the model formula for transformations</h2><span id='topic+parse_model_lhs'></span>

<h3>Description</h3>

<p>Parse the RHS of the model formula for transformations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_model_lhs(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_model_lhs_+3A_model">model</code></td>
<td>
<p>A model definition</p>
</td></tr>
</table>

<hr>
<h2 id='parse_model_rhs'>Parse the RHS of the model formula for specials</h2><span id='topic+parse_model_rhs'></span>

<h3>Description</h3>

<p>Parse the RHS of the model formula for specials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_model_rhs(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_model_rhs_+3A_model">model</code></td>
<td>
<p>A model definition</p>
</td></tr>
</table>

<hr>
<h2 id='percentile_score'>Distribution accuracy measures</h2><span id='topic+percentile_score'></span><span id='topic+quantile_score'></span><span id='topic+CRPS'></span><span id='topic+distribution_accuracy_measures'></span>

<h3>Description</h3>

<p>These accuracy measures can be used to evaluate how accurately a forecast
distribution predicts a given actual value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percentile_score(.dist, .actual, na.rm = TRUE, ...)

quantile_score(
  .dist,
  .actual,
  probs = c(0.05, 0.25, 0.5, 0.75, 0.95),
  na.rm = TRUE,
  ...
)

CRPS(.dist, .actual, n_quantiles = 1000, na.rm = TRUE, ...)

distribution_accuracy_measures
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percentile_score_+3A_.dist">.dist</code></td>
<td>
<p>The distribution of fitted values from the model, or forecasted values from the forecast.</p>
</td></tr>
<tr><td><code id="percentile_score_+3A_.actual">.actual</code></td>
<td>
<p>A vector of responses matching the fitted values
(for forecast accuracy, <code>new_data</code> must be provided).</p>
</td></tr>
<tr><td><code id="percentile_score_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove the missing values before calculating the accuracy measure</p>
</td></tr>
<tr><td><code id="percentile_score_+3A_...">...</code></td>
<td>
<p>Additional arguments for each measure.</p>
</td></tr>
<tr><td><code id="percentile_score_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities at which the metric is evaluated.</p>
</td></tr>
<tr><td><code id="percentile_score_+3A_n_quantiles">n_quantiles</code></td>
<td>
<p>The number of quantiles to use in approximating CRPS when an exact solution is not available.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Quantile/percentile score (pinball loss)</h3>

<p>A quantile (or percentile) score evaluates how accurately a set of quantiles
(or percentiles) from the distribution match the given actual value. This
score uses a pinball loss function, and can be calculated via the average of
the score function given below:
</p>
<p>The score function <code class="reqn">s_p(q_p,y)</code> is given by <code class="reqn">(1-p)(q_p-y)</code> if
<code class="reqn">y &lt; q_p</code>, and <code class="reqn">p(y-q_p)</code> if <code class="reqn">y \ge q_p</code>. Where <code class="reqn">p</code> is the
quantile probability, <code class="reqn">q_p = F^{-1}(p)</code> is the quantile with probability
<code class="reqn">p</code>, and <code class="reqn">y</code> is the actual value.
</p>
<p>The resulting accuracy measure will average this score over all predicted
points at all desired quantiles (defined via the <code>probs</code> argument).
</p>
<p>The percentile score is uses the same method with <code>probs</code> set to all
percentiles <code>probs = seq(0.01, 0.99, 0.01)</code>.
</p>


<h3>Continuous ranked probability score (CRPS)</h3>

<p>The continuous ranked probability score (CRPS) is the continuous analogue of
the pinball loss quantile score defined above. Its value is twice the
integral of the quantile score over all possible quantiles:
</p>
<p style="text-align: center;"><code class="reqn">
  CRPS(F,y) = 2 \int_0^1 s_p(q_p,y) dp
</code>
</p>

<p>It can be computed directly from the distribution via:
</p>
<p style="text-align: center;"><code class="reqn">
  CRPS(F,y) = \int_{-\infty}^\infty (F(x) - 1{y\leq x})^2 dx
</code>
</p>

<p>For some forecast distribution <code class="reqn">F</code> and actual value <code class="reqn">y</code>.
</p>
<p>Calculating the CRPS accuracy measure is computationally difficult for many
distributions, however it can be computed quickly and exactly for Normal and
emperical (sample) distributions. For other distributions the CRPS is
approximated using the quantile score of many quantiles (using the number of
quantiles specified in the <code>n_quantiles</code> argument).
</p>

<hr>
<h2 id='reconcile'>Forecast reconciliation</h2><span id='topic+reconcile'></span><span id='topic+reconcile.mdl_df'></span>

<h3>Description</h3>

<p>This function allows you to specify the method used to reconcile forecasts
in accordance with its key structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconcile(.data, ...)

## S3 method for class 'mdl_df'
reconcile(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconcile_+3A_.data">.data</code></td>
<td>
<p>A mable.</p>
</td></tr>
<tr><td><code id="reconcile_+3A_...">...</code></td>
<td>
<p>Reconciliation methods applied to model columns within <code>.data</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
lung_deaths_agg &lt;- as_tsibble(cbind(mdeaths, fdeaths)) %&gt;%
  aggregate_key(key, value = sum(value))

lung_deaths_agg %&gt;%
  model(lm = TSLM(value ~ trend() + season())) %&gt;%
  reconcile(lm = min_trace(lm)) %&gt;% 
  forecast()

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+as_tsibble'></span><span id='topic+vars'></span><span id='topic+autoplot'></span><span id='topic+autolayer'></span><span id='topic+accuracy'></span><span id='topic+equation'></span><span id='topic+interpolate'></span><span id='topic+components'></span><span id='topic+augment'></span><span id='topic+glance'></span><span id='topic+tidy'></span><span id='topic+hypothesize'></span><span id='topic+generate'></span><span id='topic+refit'></span><span id='topic+forecast'></span><span id='topic+hilo'></span><span id='topic+guide_level'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>distributional</dt><dd><p><code><a href="distributional.html#topic+guide_level">guide_level</a></code>, <code><a href="distributional.html#topic+hilo">hilo</a></code></p>
</dd>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code>, <code><a href="dplyr.html#topic+vars">vars</a></code></p>
</dd>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+accuracy">accuracy</a></code>, <code><a href="generics.html#topic+augment">augment</a></code>, <code><a href="generics.html#topic+components">components</a></code>, <code><a href="generics.html#topic+equation">equation</a></code>, <code><a href="generics.html#topic+forecast">forecast</a></code>, <code><a href="generics.html#topic+generate">generate</a></code>, <code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+hypothesize">hypothesize</a></code>, <code><a href="generics.html#topic+interpolate">interpolate</a></code>, <code><a href="generics.html#topic+refit">refit</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+autolayer">autolayer</a></code>, <code><a href="ggplot2.html#topic+autoplot">autoplot</a></code></p>
</dd>
<dt>tsibble</dt><dd><p><code><a href="tsibble.html#topic+as-tsibble">as_tsibble</a></code></p>
</dd>
</dl>

<hr>
<h2 id='refit.mdl_df'>Refit a mable to a new dataset</h2><span id='topic+refit.mdl_df'></span><span id='topic+refit.mdl_ts'></span>

<h3>Description</h3>

<p>Applies a fitted model to a new dataset. For most methods this can be done
with or without re-estimation of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
refit(object, new_data, ...)

## S3 method for class 'mdl_ts'
refit(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refit.mdl_df_+3A_object">object</code></td>
<td>
<p>A mable.</p>
</td></tr>
<tr><td><code id="refit.mdl_df_+3A_new_data">new_data</code></td>
<td>
<p>A tsibble dataset used to refit the model.</p>
</td></tr>
<tr><td><code id="refit.mdl_df_+3A_...">...</code></td>
<td>
<p>Additional optional arguments for refit methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)

fit &lt;- as_tsibble(mdeaths) %&gt;% 
  model(ETS(value ~ error("M") + trend("A") + season("A")))
fit %&gt;% report()

fit %&gt;% 
  refit(as_tsibble(fdeaths)) %&gt;% 
  report(reinitialise = TRUE)

</code></pre>

<hr>
<h2 id='register_feature'>Register a feature function</h2><span id='topic+register_feature'></span>

<h3>Description</h3>

<p>Allows users to find and use features from your package using <code><a href="fabletools.html#topic+feature_set">feature_set()</a></code>.
If the features are being registered from within a package, this feature
registration should happen at load time using <code style="white-space: pre;">&#8288;[.onLoad()]&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_feature(fn, tags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_feature_+3A_fn">fn</code></td>
<td>
<p>The feature function</p>
</td></tr>
<tr><td><code id="register_feature_+3A_tags">tags</code></td>
<td>
<p>Identifying tags</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
tukey_five &lt;- function(x){
  setNames(fivenum(x), c("min", "hinge_lwr", "med", "hinge_upr", "max"))
}

register_feature(tukey_five, tags = c("boxplot", "simple"))


## End(Not run)

</code></pre>

<hr>
<h2 id='report'>Report information about an object</h2><span id='topic+report'></span>

<h3>Description</h3>

<p>Displays the object in a suitable format for reporting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report_+3A_object">object</code></td>
<td>
<p>The object to report</p>
</td></tr>
<tr><td><code id="report_+3A_...">...</code></td>
<td>
<p>Additional options for the reporting function</p>
</td></tr>
</table>

<hr>
<h2 id='residuals.mdl_df'>Extract residuals values from models</h2><span id='topic+residuals.mdl_df'></span><span id='topic+residuals.mdl_ts'></span>

<h3>Description</h3>

<p>Extracts the residuals from each of the models in a mable. A tsibble will
be returned containing these residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
residuals(object, ...)

## S3 method for class 'mdl_ts'
residuals(object, type = "innovation", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.mdl_df_+3A_object">object</code></td>
<td>
<p>A mable or time series model.</p>
</td></tr>
<tr><td><code id="residuals.mdl_df_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the model method for <code>residuals()</code></p>
</td></tr>
<tr><td><code id="residuals.mdl_df_+3A_type">type</code></td>
<td>
<p>The type of residuals to compute. If <code>type="response"</code>, residuals on the back-transformed data will be computed.</p>
</td></tr>
</table>

<hr>
<h2 id='response'>Extract the response variable from a model</h2><span id='topic+response'></span>

<h3>Description</h3>

<p>Returns a tsibble containing only the response variable used in the fitting
of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_+3A_object">object</code></td>
<td>
<p>The object containing response data</p>
</td></tr>
<tr><td><code id="response_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to other methods</p>
</td></tr>
</table>

<hr>
<h2 id='response_vars'>Return response variables</h2><span id='topic+response_vars'></span>

<h3>Description</h3>

<p><code>response_vars()</code> returns a character vector of the response variables in the
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response_vars(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_vars_+3A_x">x</code></td>
<td>
<p>A dataset containing a response variable (such as a mable, fable, or dable).</p>
</td></tr>
</table>

<hr>
<h2 id='scenarios'>A set of future scenarios for forecasting</h2><span id='topic+scenarios'></span>

<h3>Description</h3>

<p>A set of future scenarios for forecasting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scenarios(..., names_to = ".scenario")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scenarios_+3A_...">...</code></td>
<td>
<p>Input data for each scenario</p>
</td></tr>
<tr><td><code id="scenarios_+3A_names_to">names_to</code></td>
<td>
<p>The column name used to identify each scenario</p>
</td></tr>
</table>

<hr>
<h2 id='skill_score'>Forecast skill score measure</h2><span id='topic+skill_score'></span>

<h3>Description</h3>

<p>This function converts other error metrics such as <code>MSE</code> into a skill score.
The reference or benchmark forecasting method is the Naive method for
non-seasonal data, and the seasonal naive method for seasonal data.
When used within <code><a href="fabletools.html#topic+accuracy.fbl_ts">accuracy.fbl_ts</a></code>, it is important that the data
contains both the training and test data, as the training data is used to
compute the benchmark forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skill_score(measure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skill_score_+3A_measure">measure</code></td>
<td>
<p>The accuracy measure to use in computing the skill score.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
skill_score(MSE)


library(fable)
library(tsibble)

lung_deaths &lt;- as_tsibble(cbind(mdeaths, fdeaths))
lung_deaths %&gt;% 
  dplyr::filter(index &lt; yearmonth("1979 Jan")) %&gt;%
  model(
    ets = ETS(value ~ error("M") + trend("A") + season("A")),
    lm = TSLM(value ~ trend() + season())
  ) %&gt;%
  forecast(h = "1 year") %&gt;%
  accuracy(lung_deaths, measures = list(skill = skill_score(MSE)))

</code></pre>

<hr>
<h2 id='special_xreg'>Helper special for producing a model matrix of exogenous regressors</h2><span id='topic+special_xreg'></span>

<h3>Description</h3>

<p>Helper special for producing a model matrix of exogenous regressors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>special_xreg(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="special_xreg_+3A_...">...</code></td>
<td>
<p>Arguments for <code>fable_xreg_matrix</code> (see Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the <code>fable_xreg_matrix</code> helper supports a single argument named
<code>default_intercept</code>. If this argument is TRUE (passed via <code>...</code> above), then
the intercept will be returned in the matrix if not specified (much like the
behaviour of <code>lm()</code>). If FALSE, then the intercept will only be included if
explicitly requested via <code>1</code> in the formula.
</p>

<hr>
<h2 id='stream'>Extend a fitted model with new data</h2><span id='topic+stream'></span><span id='topic+stream.mdl_df'></span>

<h3>Description</h3>

<p>Extend the length of data used to fit a model and update the parameters to
suit this new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stream(object, ...)

## S3 method for class 'mdl_df'
stream(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stream_+3A_object">object</code></td>
<td>
<p>An object (such as a model) which can be extended with additional data.</p>
</td></tr>
<tr><td><code id="stream_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to stream methods.</p>
</td></tr>
<tr><td><code id="stream_+3A_new_data">new_data</code></td>
<td>
<p>A dataset of the same structure as was used to fit the model.</p>
</td></tr>
</table>

<hr>
<h2 id='tidy.mdl_df'>Extract model coefficients from a mable</h2><span id='topic+tidy.mdl_df'></span><span id='topic+coef.mdl_df'></span><span id='topic+tidy.mdl_ts'></span><span id='topic+coef.mdl_ts'></span>

<h3>Description</h3>

<p>This function will obtain the coefficients (and associated statistics) for
each model in the mable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_df'
tidy(x, ...)

## S3 method for class 'mdl_df'
coef(object, ...)

## S3 method for class 'mdl_ts'
tidy(x, ...)

## S3 method for class 'mdl_ts'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.mdl_df_+3A_x">x</code>, <code id="tidy.mdl_df_+3A_object">object</code></td>
<td>
<p>A mable.</p>
</td></tr>
<tr><td><code id="tidy.mdl_df_+3A_...">...</code></td>
<td>
<p>Arguments for model methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fable)
library(tsibbledata)

olympic_running %&gt;%
  model(lm = TSLM(log(Time) ~ trend())) %&gt;% 
  tidy()

</code></pre>

<hr>
<h2 id='top_down'>Top down forecast reconciliation</h2><span id='topic+top_down'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top_down(
  models,
  method = c("forecast_proportions", "average_proportions", "proportion_averages")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top_down_+3A_models">models</code></td>
<td>
<p>A column of models in a mable.</p>
</td></tr>
<tr><td><code id="top_down_+3A_method">method</code></td>
<td>
<p>The reconciliation method to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reconciles a hierarchy using the top down reconciliation method. The
response variable of the hierarchy must be aggregated using sums. The
forecasted time points must match for all series in the hierarchy.
</p>


<h3>See Also</h3>

<p><code><a href="fabletools.html#topic+reconcile">reconcile()</a></code>, <code><a href="fabletools.html#topic+aggregate_key">aggregate_key()</a></code>
</p>

<hr>
<h2 id='traverse'>Recursively traverse an object</h2><span id='topic+traverse'></span>

<h3>Description</h3>

<p>Recursively traverse an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traverse(
  x,
  .f = list,
  .g = identity,
  .h = identity,
  base = function(.x) is_syntactic_literal(.x) || is_symbol(.x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traverse_+3A_x">x</code></td>
<td>
<p>The object to traverse</p>
</td></tr>
<tr><td><code id="traverse_+3A_.f">.f</code></td>
<td>
<p>A function for combining the recursed components</p>
</td></tr>
<tr><td><code id="traverse_+3A_.g">.g</code></td>
<td>
<p>A function applied to the object before recursion</p>
</td></tr>
<tr><td><code id="traverse_+3A_.h">.h</code></td>
<td>
<p>A function applied to the base case</p>
</td></tr>
<tr><td><code id="traverse_+3A_base">base</code></td>
<td>
<p>The base case for the recursion</p>
</td></tr>
</table>

<hr>
<h2 id='unpack_hilo'>Unpack a hilo column</h2><span id='topic+unpack_hilo'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>This function is superceded. It is recommended that you use the functionality
from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package to extract elements from a <code style="white-space: pre;">&#8288;&lt;hilo&gt;&#8288;</code> object. For example, you can access
the lower bound with <code style="white-space: pre;">&#8288;&lt;hilo&gt;$lower&#8288;</code>.
</p>
<p>Allows a hilo column to be unpacked into its component columns: &quot;lower&quot;,
&quot;upper&quot;, and &quot;level&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_hilo(data, cols, names_sep = "_", names_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_hilo_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unpack_hilo_+3A_cols">cols</code></td>
<td>
<p>Name of hilo columns to unpack.</p>
</td></tr>
<tr><td><code id="unpack_hilo_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the names will be left
as is. In <code>pack()</code>, inner names will come from the former outer names;
in <code>unpack()</code>, the new outer names will come from the inner names.
</p>
<p>If a string, the inner and outer names will be used together. In
<code>unpack()</code>, the names of the new outer columns will be formed by pasting
together the outer and the inner column names, separated by <code>names_sep</code>. In
<code>pack()</code>, the new inner names will have the outer names + <code>names_sep</code>
automatically stripped. This makes <code>names_sep</code> roughly symmetric between
packing and unpacking.</p>
</td></tr>
<tr><td><code id="unpack_hilo_+3A_names_repair">names_repair</code></td>
<td>
<p>Used to check that output data frame has valid
names. Must be one of the following options:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;"minimal&#8288;</code>&quot;: no name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"unique&#8288;</code>&quot;: make sure names are unique and not empty,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"check_unique&#8288;</code>&quot;: (the default), no name repair, but check they are unique,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"universal&#8288;</code>&quot;: make the names unique and syntactic
</p>
</li>
<li><p> a function: apply custom name repair.
</p>
</li>
<li> <p><a href="tidyr.html#topic+tidyr_legacy">tidyr_legacy</a>: use the name repair from tidyr 0.8.
</p>
</li>
<li><p> a formula: a purrr-style anonymous function (see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>)
</p>
</li></ul>

<p>See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for more details on these terms and the
strategies used to enforce them.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+pack">tidyr::unpack()</a></code>
</p>

<hr>
<h2 id='validate_formula'>Validate the user provided model</h2><span id='topic+validate_formula'></span>

<h3>Description</h3>

<p>Appropriately format the user's model for evaluation. Typically ran as one of the first steps
in a model function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_formula(model, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_formula_+3A_model">model</code></td>
<td>
<p>A quosure for the user's model specification</p>
</td></tr>
<tr><td><code id="validate_formula_+3A_data">data</code></td>
<td>
<p>A dataset used for automatic response selection</p>
</td></tr>
</table>

<hr>
<h2 id='winkler_score'>Interval estimate accuracy measures</h2><span id='topic+winkler_score'></span><span id='topic+pinball_loss'></span><span id='topic+scaled_pinball_loss'></span><span id='topic+interval_accuracy_measures'></span>

<h3>Description</h3>

<p>Interval estimate accuracy measures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winkler_score(.dist, .actual, level = 95, na.rm = TRUE, ...)

pinball_loss(.dist, .actual, level = 95, na.rm = TRUE, ...)

scaled_pinball_loss(
  .dist,
  .actual,
  .train,
  level = 95,
  na.rm = TRUE,
  demean = FALSE,
  .period,
  d = .period == 1,
  D = .period &gt; 1,
  ...
)

interval_accuracy_measures
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="winkler_score_+3A_.dist">.dist</code></td>
<td>
<p>The distribution of fitted values from the model, or forecasted values from the forecast.</p>
</td></tr>
<tr><td><code id="winkler_score_+3A_.actual">.actual</code></td>
<td>
<p>A vector of responses matching the fitted values
(for forecast accuracy, <code>new_data</code> must be provided).</p>
</td></tr>
<tr><td><code id="winkler_score_+3A_level">level</code></td>
<td>
<p>The level of the forecast interval.</p>
</td></tr>
<tr><td><code id="winkler_score_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove the missing values before calculating the accuracy measure</p>
</td></tr>
<tr><td><code id="winkler_score_+3A_...">...</code></td>
<td>
<p>Additional arguments for each measure.</p>
</td></tr>
<tr><td><code id="winkler_score_+3A_.train">.train</code></td>
<td>
<p>A vector of responses used to train the model
(for forecast accuracy, the <code>orig_data</code> must be provided).</p>
</td></tr>
<tr><td><code id="winkler_score_+3A_demean">demean</code></td>
<td>
<p>Should the response be demeaned (MASE)</p>
</td></tr>
<tr><td><code id="winkler_score_+3A_.period">.period</code></td>
<td>
<p>The seasonal period of the data (defaulting to 'smallest' seasonal period).
from a model, or forecasted values from the forecast.</p>
</td></tr>
<tr><td><code id="winkler_score_+3A_d">d</code></td>
<td>
<p>Should the response model include a first difference?</p>
</td></tr>
<tr><td><code id="winkler_score_+3A_d">D</code></td>
<td>
<p>Should the response model include a seasonal difference?</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
