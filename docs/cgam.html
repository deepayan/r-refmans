<!DOCTYPE html><html><head><title>Help for package cgam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cgam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#best.fit'><p>Extract the Best Fit Returned by the ShapeSelect Routine</p></a></li>
<li><a href='#cgam'><p>Constrained Generalized Additive Model Fitting</p></a></li>
<li><a href='#cgamm'><p>Constrained Generalized Additive Mixed-Effects Model Fitting</p></a></li>
<li><a href='#COforest'>
<p>Colorado Forest Data Set</p></a></li>
<li><a href='#conc'><p>Specify a Concave Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#conv'><p>Specify a Convex Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#cubic'><p>A Data Set for Cgam</p></a></li>
<li><a href='#decr'><p>Specify a Decreasing Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#decr.conc'><p>Specify a Decreasing and Concave Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#decr.conv'><p>Specify a Decreasing and Convex Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#in.or.out'><p>To Include a Non-Parametrically Modelled Predictor in a SHAPESELECT Formula</p></a></li>
<li><a href='#incr'><p>Specify an Increasing Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#incr.conc'><p>Specify an Increasing and Concave Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#incr.conv'><p>Specify an Increasing and Convex Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#mental'><p>Alachua County Study of Mental Impairment</p></a></li>
<li><a href='#Ord'><p>Specify an Ordered Categorical Family in a CGAM Formula</p></a></li>
<li><a href='#plasma'><p>A Data Set for Cgam</p></a></li>
<li><a href='#plotpersp'><p>Create a 3D Plot for a CGAM Object</p></a></li>
<li><a href='#predict.cgam'><p>Predict Method for CGAM Fits</p></a></li>
<li><a href='#s'><p>Specify a Smooth Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.conc'><p>Specify a Smooth and Concave Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.conc.conc'><p>Specify a Doubly-Concave Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.conv'><p>Specify a Smooth and Convex Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.conv.conv'><p>Specify a Doubly-convex Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.decr'><p>Specify a Smooth and Decreasing Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.decr.conc'><p>Specify a Smooth, Decreasing and Concave Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.decr.conv'><p>Specify a Smooth, Decreasing and Convex Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.decr.decr'><p>Specify a Doubly-Decreasing Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.decr.incr'><p>Specify a Decreasing-Increasing Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.incr'><p>Specify a Smooth and Increasing Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.incr.conc'><p>Specify a Smooth, Increasing and Concave Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.incr.conv'><p>Specify an Smooth, Increasing and Convex Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.incr.decr'><p>Specify an Increasing-Decreasing Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#s.incr.incr'><p>Specify a Doubly-Increasing Shape-Restriction in a CGAM Formula</p></a></li>
<li><a href='#shapes'><p>To Include a Non-Parametrically Modelled Predictor in a SHAPESELECT Formula</p></a></li>
<li><a href='#ShapeSelect'><p>Variable and Shape Selection via Genetic Algorithm</p></a></li>
<li><a href='#tree'><p>Specify a Tree-Ordering in a CGAM Formula</p></a></li>
<li><a href='#umbrella'><p>Specify an Umbrella-Ordering in a CGAM Formula</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Constrained Generalized Additive Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.21</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-09</td>
</tr>
<tr>
<td>Description:</td>
<td>A constrained generalized additive model is fitted by the cgam routine. Given a set of predictors, each of which may have a shape or order restrictions, the maximum likelihood estimator for the constrained generalized additive model is found using an iteratively re-weighted cone projection algorithm. The ShapeSelect routine chooses a subset of predictor variables and describes the component relationships with the response. For each predictor, the user needs only specify a set of possible shape or order restrictions. A model selection method chooses the shapes and orderings of the relationships as well as the variables. The cone information criterion (CIC) is used to select the best combination of variables and shapes. A genetic algorithm may be used when the set of possible models is large. In addition, the cgam routine implements a two-dimensional isotonic regression using warped-plane splines without additivity assumptions.  It can also fit a convex or concave regression surface with triangle splines without additivity assumptions. See Liao X, Meyer MC (2019)&lt;<a href="https://doi.org/10.18637%2Fjss.v089.i05">doi:10.18637/jss.v089.i05</a>&gt; for more details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>coneproj(&ge; 1.12), svDialogs (&ge; 0.9-57), statmod (&ge; 1.4.36),
lme4 (&ge; 1.1-13), Matrix (&ge; 1.2-8), R(&ge; 3.0.2)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Suggests:</td>
<td>stats, MASS, graphics, grDevices, utils, SemiPar</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-09 22:58:43 UTC; xliao</td>
</tr>
<tr>
<td>Author:</td>
<td>Mary Meyer [aut],
  Xiyue Liao <a href="https://orcid.org/0000-0002-4508-9219"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiyue Liao &lt;xliao@sdsu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-10 16:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='best.fit'>Extract the Best Fit Returned by the ShapeSelect Routine</h2><span id='topic+best.fit'></span>

<h3>Description</h3>

<p>The is a subroutine which only works for the ShapeSelect routine. It returns an object of the cgam class given the variables and their shapes chosen by the ShapeSelect routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.fit(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best.fit_+3A_x">x</code></td>
<td>
<p>x is an object of the ShapeSelect class.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>object</code></td>
<td>
<p>The best fit returned by the ShapeSelect routine, which is an object of the cgam class.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xiyue Liao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cgam">cgam</a></code>, <code><a href="#topic+ShapeSelect">ShapeSelect</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  library(MASS)
  data(Rubber)

  # do a variable and shape selection with four possible shapes
  # increasing, decreasing, convex and concave 
  ans &lt;- ShapeSelect(loss ~ shapes(hard, set = c("incr", "decr", "conv", "conc"))
  + shapes(tens, set = c("incr", "decr", "conv", "conc")), data = Rubber, genetic = TRUE)

  # check the best fit, which is an object of the cgam class
  bf &lt;- best.fit(ans)
  class(bf)
  plotpersp(bf)

## End(Not run)
</code></pre>

<hr>
<h2 id='cgam'>Constrained Generalized Additive Model Fitting</h2><span id='topic+cgam'></span>

<h3>Description</h3>

<p>The partial linear generalized additive model is fitted using the method of maximum likelihood, where shape or order restrictions can be imposed on the non-parametrically modelled predictors with optional smoothing, and no restrictions are imposed on the optional parametrically modelled covariate. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgam(formula, cic = FALSE, nsim = 100, family = gaussian, cpar = 1.5, 
	data = NULL, weights = NULL, sc_x = FALSE, sc_y = FALSE, pnt = TRUE, 
	pen = 0, var.est = NULL, gcv = FALSE, pvf = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cgam_+3A_formula">formula</code></td>
<td>

<p>A formula object which gives a symbolic description of the model to be fitted. It has the form &quot;response ~ predictor&quot;. The response is a vector of length <code class="reqn">n</code>. The specification of the model can be one of the three exponential families: gaussian, binomial and poisson. The systematic component <code class="reqn">\eta</code> is <code class="reqn">E(y)</code>, the log odds of <code class="reqn">y = 1</code>, and the logarithm of <code class="reqn">E(y)</code> respectively. A predictor can be a non-parametrically modelled variable with or without a shape or order restriction, or a parametrically modelled unconstrained covariate. In terms of a non-parametrically modelled predictor, the user is supposed to indicate the relationship between the systematic component <code class="reqn">\eta</code> and a predictor <code class="reqn">x</code> in the following way:
</p>
<p>Assume that <code class="reqn">\eta</code> is the systematic component and <code class="reqn">x</code> is a predictor: 
</p>

<ul>
<li><p>incr(x): <code class="reqn">\eta</code> is increasing in <code class="reqn">x</code>. See <code><a href="#topic+incr">incr</a></code> for more details.
</p>
</li>
<li><p>s.incr(x): <code class="reqn">\eta</code> is smoothly increasing in <code class="reqn">x</code>. See <code><a href="#topic+s.incr">s.incr</a></code> for more details.
</p>
</li>
<li><p>decr(x): <code class="reqn">\eta</code> is decreasing in <code class="reqn">x</code>.  See <code><a href="#topic+decr">decr</a></code> for more details.
</p>
</li>
<li><p>s.decr(x): <code class="reqn">\eta</code> is smoothly decreasing in <code class="reqn">x</code>.  See <code><a href="#topic+s.decr">s.decr</a></code> for more details.
</p>
</li>
<li><p>conc(x): <code class="reqn">\eta</code> is concave in <code class="reqn">x</code>.  See <code><a href="#topic+conc">conc</a></code> for more details.
</p>
</li>
<li><p>s.conc(x): <code class="reqn">\eta</code> is smoothly concave in <code class="reqn">x</code>.  See <code><a href="#topic+s.conc">s.conc</a></code> for more details.
</p>
</li>
<li><p>conv(x): <code class="reqn">\eta</code> is convex in <code class="reqn">x</code>.  See <code><a href="#topic+conv">conv</a></code> for more details.
</p>
</li>
<li><p>s.conv(x): <code class="reqn">\eta</code> is smoothly convex in <code class="reqn">x</code>.  See <code><a href="#topic+s.conv">s.conv</a></code> for more details.
</p>
</li>
<li><p>incr.conc(x): <code class="reqn">\eta</code> is increasing and concave in <code class="reqn">x</code>.  See <code><a href="#topic+incr.conc">incr.conc</a></code> for more details.
</p>
</li>
<li><p>s.incr.conc(x): <code class="reqn">\eta</code> is smoothly increasing and concave in <code class="reqn">x</code>. See <code><a href="#topic+s.incr.conc">s.incr.conc</a></code> for more details.
</p>
</li>
<li><p>decr.conc(x): <code class="reqn">\eta</code> is decreasing and concave in <code class="reqn">x</code>. See <code><a href="#topic+decr.conc">decr.conc</a></code> for more details.
</p>
</li>
<li><p>s.decr.conc(x): <code class="reqn">\eta</code> is smoothly decreasing and concave in <code class="reqn">x</code>. See <code><a href="#topic+s.decr.conc">s.decr.conc</a></code> for more details.
</p>
</li>
<li><p>incr.conv(x): <code class="reqn">\eta</code> is increasing and convex in <code class="reqn">x</code>. See <code><a href="#topic+incr.conv">incr.conv</a></code> for more details.
</p>
</li>
<li><p>s.incr.conv(x): <code class="reqn">\eta</code> is smoothly increasing and convex in <code class="reqn">x</code>. See <code><a href="#topic+s.incr.conv">s.incr.conv</a></code> for more details.
</p>
</li>
<li><p>decr.conv(x): <code class="reqn">\eta</code> is decreasing and convex in <code class="reqn">x</code>. See <code><a href="#topic+decr.conv">decr.conv</a></code> for more details.
</p>
</li>
<li><p>s.decr.conv(x): <code class="reqn">\eta</code> is smoothly decreasing and convex in <code class="reqn">x</code>. See <code><a href="#topic+s.decr.conv">s.decr.conv</a></code> for more details.
</p>
</li>
<li><p>s(x): <code class="reqn">\eta</code> is smooth in <code class="reqn">x</code>. See <code><a href="#topic+s">s</a></code> for more details.
</p>
</li>
<li><p>tree(x): <code class="reqn">\eta</code> has a tree-ordering in <code class="reqn">x</code>. See <code><a href="#topic+tree">tree</a></code> for more details.
</p>
</li>
<li><p>umbrella(x): <code class="reqn">\eta</code> has an umbrella-ordering in <code class="reqn">x</code>. See <code><a href="#topic+umbrella">umbrella</a></code> for more details.
</p>
</li></ul>

</td></tr>
<tr><td><code id="cgam_+3A_cic">cic</code></td>
<td>
<p>Logical flag indicating if or not simulations are used to get the cic value. 
The default is cic = FALSE
</p>
</td></tr>
<tr><td><code id="cgam_+3A_nsim">nsim</code></td>
<td>

<p>The number of simulations used to get the cic parameter. The default is nsim = 100. 
</p>
</td></tr>
<tr><td><code id="cgam_+3A_family">family</code></td>
<td>

<p>A parameter indicating the error distribution and link function to be used in the model. It can be a character string naming a family function or the result of a call to a family function. This is borrowed from the glm routine in the stats package. There are four families used in csvy: Gaussian, binomial, poisson, and Gamma.  Note that if family = Ord is specified, a proportional odds regression model with shape constraints is fitted. This is under development. 
</p>
</td></tr>
<tr><td><code id="cgam_+3A_cpar">cpar</code></td>
<td>
<p>A multiplier to estimate the model variance, which is defined as <code class="reqn">\sigma^2 = SSR / (n - cpar * edf)</code>. SSR is the sum of squared residuals for the full model and edf is the effective degrees of freedom. The default is cpar = 1.2. The user-defined value must be between 1 and 2. See Meyer, M. C. and M. Woodroofe (2000) for more details.</p>
</td></tr>
<tr><td><code id="cgam_+3A_data">data</code></td>
<td>

<p>An optional data frame, list or environment containing the variables in the model. The default is data = NULL.
</p>
</td></tr>
<tr><td><code id="cgam_+3A_weights">weights</code></td>
<td>

<p>An optional non-negative vector of &quot;replicate weights&quot; which has the same length as the response vector. If weights are not given, all weights are taken to equal 1. The default is weights = NULL.
</p>
</td></tr>
<tr><td><code id="cgam_+3A_sc_x">sc_x</code></td>
<td>
<p>Logical flag indicating if or not continuous predictors are normalized. The default is sc_x = FALSE.</p>
</td></tr>
<tr><td><code id="cgam_+3A_sc_y">sc_y</code></td>
<td>
<p>Logical flag indicating if or not the response variable is normalized. The default is sc_y = FALSE.</p>
</td></tr>
<tr><td><code id="cgam_+3A_pen">pen</code></td>
<td>
<p>User-defined penalty parameter. It must be non-negative. It will only be used in a warped-plane spline fit or a triangle spline fit. The default is pen = 0.</p>
</td></tr>
<tr><td><code id="cgam_+3A_pnt">pnt</code></td>
<td>
<p>Logical flag indicating if or not penalized constrained regression splines are used. It will only be used in a warped-plane spline fit or a triangle spline fit. The default is pnt = TRUE.</p>
</td></tr>
<tr><td><code id="cgam_+3A_var.est">var.est</code></td>
<td>
<p>To do a monotonic variance function estimation, the user can set var.est = s.incr(x) or var.est = s.decr(x). See <code><a href="#topic+s.incr">s.incr</a></code> and <code><a href="#topic+s.decr">s.decr</a></code> for more details. The default is var.est = NULL.</p>
</td></tr>
<tr><td><code id="cgam_+3A_gcv">gcv</code></td>
<td>
<p>Logical flag indicating if or not gcv is used to choose a penalty term in warped-plane surface fit. The default is gcv = FALSE.</p>
</td></tr>
<tr><td><code id="cgam_+3A_pvf">pvf</code></td>
<td>
<p>Logical flag indicating if or not simulations are used to find the p-value of the test of linear vs double monotone in warped plane surface fit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider generalized partial linear models with independent observations from an exponential family of the form <code class="reqn">p(y_i;\theta,\tau) = exp[\{y_i\theta_i - b(\theta_i)\}\tau - c(y_i, \tau)], i = 1,\ldots,n</code>, where the specifications of the functions <code class="reqn">b</code> and <code class="reqn">c</code> determine the sub-family of models. The mean vector <code class="reqn">\mu = E(y)</code> has values <code class="reqn">\mu_i = b'(\theta_i)</code>, and is related to a design matrix of predictor variables through a monotonically increasing link function <code class="reqn">g(\mu_i) = \eta_i, i = 1,\ldots,n</code>, where <code class="reqn">\eta</code> is the systematic component and describes the relationship with the predictors. The relationship between <code class="reqn">\eta</code> and <code class="reqn">\theta</code> is determined by the link function <code class="reqn">b</code>.
</p>
<p>For the additive model, the systematic component is specified for each observation by <code class="reqn">\eta_i = f_1(x_{1i}) + \ldots + f_L(x_{Li}) + z_i'\beta</code>, where the functions <code class="reqn">f_l</code> describe the relationships of the non-parametrically modelled predictors <code class="reqn">x_l</code>, <code class="reqn">\beta</code> is a parameter vector, and <code class="reqn">z_i</code> contains the values of variables to be modelled parametrically. The non-parametric components are modelled with shape or order assumptions with optional smoothing, and the solution is obtained through an iteratively re-weighted cone projection, with no back-fitting of individual components.
</p>
<p>Suppose that <code class="reqn">\eta</code> is a <code class="reqn">n</code> by <code class="reqn">1</code> vector. The matrix form of the systematic component and the predictor is <code class="reqn">\eta = \phi_1 + \ldots + \phi_L + Z\beta</code>, where <code class="reqn">\phi_l</code> is the individual component for the <code class="reqn">l</code>th non-parametrically modelled predictor, <code class="reqn">l = 1, \ldots, L</code>, and <code class="reqn">Z</code> is an <code class="reqn">n</code> by <code class="reqn">p</code> design matrix for the parametrically modelled covariate. 
</p>
<p>To model the component <code class="reqn">\phi_l</code>, smooth regression splines or non-smooth ordinal basis functions can be used. The constraints for the component <code class="reqn">\phi_l</code> are in <code class="reqn">C_l</code>. In the first case, <code class="reqn">C_l</code> = <code class="reqn">\{\phi_l \in R^n: \phi_l = v_l+B_l\beta_l</code>, where <code class="reqn">\beta_l \ge 0</code> and <code class="reqn">v_l\in V_l \}</code>, where <code class="reqn">B_l</code> has regression splines as columns and <code class="reqn">V_l</code> is the linear space contained in <code class="reqn">C_l</code>, and in the second case, <code class="reqn">C_l</code> = <code class="reqn">\{\phi \in R^n: A_l\phi \ge 0</code> and <code class="reqn">B_l\phi = 0\}</code>, for inequality constraint matrix <code class="reqn">A_l</code> and equality constraint matrix <code class="reqn">B_l</code>. 
</p>
<p>The set <code class="reqn">C_l</code> is a convex cone and the set <code class="reqn">C = C_1 + \ldots + C_p + Z</code> is also a convex cone with a finite set of edges, where the edges are the generators of <code class="reqn">C</code>, and <code class="reqn">Z</code> is the column space of the design matrix <code class="reqn">Z</code> for the parametrically modelled covariate. 
</p>
<p>An iteratively re-weighted cone projection algorithm is used to fit the generalized regression model over the cone <code class="reqn">C</code>. 
</p>
<p>See references cited in this section and the official manual (<a href="https://cran.r-project.org/package=coneproj">https://cran.r-project.org/package=coneproj</a>) for the R package coneproj for more details.
</p>


<h3>Value</h3>


<table>
<tr><td><code>etahat</code></td>
<td>
<p>The fitted systematic component <code class="reqn">\eta</code>.</p>
</td></tr>
<tr><td><code>muhat</code></td>
<td>
<p>The fitted mean value, obtained by transforming the systematic component <code class="reqn">\eta</code> by the inverse of the link function.</p>
</td></tr>
<tr><td><code>vcoefs</code></td>
<td>
<p>The estimated coefficients for the basis spanning the null space of the constraint set.</p>
</td></tr>
<tr><td><code>xcoefs</code></td>
<td>
<p>The estimated coefficients for the edges corresponding to the smooth predictors with no shape constraint and shape-restricted predictors.</p>
</td></tr>
<tr><td><code>zcoefs</code></td>
<td>
<p>The estimated coefficients for the parametrically modelled covariate, i.e., the estimation for the vector <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>ucoefs</code></td>
<td>
<p>The estimated coefficients for the edges corresponding to the predictors with an umbrella-ordering constraint.</p>
</td></tr>
<tr><td><code>tcoefs</code></td>
<td>
<p>The estimated coefficients for the edges corresponding to the predictors with a tree-ordering constraint.</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>The estimated coefficients for the basis spanning the null space of the constraint set and edges corresponding to the shape-restricted and order-restricted predictors.</p>
</td></tr>
<tr><td><code>cic</code></td>
<td>
<p>The cone information criterion proposed in Meyer(2013a). It uses the &quot;null expected degrees of freedom&quot; as a measure of the complexity of the model. See Meyer(2013a) for further details of cic.</p>
</td></tr>
<tr><td><code>d0</code></td>
<td>
<p>The dimension of the linear space contained in the cone generated by all constraint conditions.</p>
</td></tr>
<tr><td><code>edf0</code></td>
<td>
<p>The estimated &quot;null expected degrees of freedom&quot;. It is a measure of the complexity of the model. See Meyer (2013a) and Meyer (2013b) for further details.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>The constrained effective degrees of freedom.</p>
</td></tr>
<tr><td><code>etacomps</code></td>
<td>
<p>The fitted systematic component value for non-parametrically modelled predictors. It is a matrix of which each row is the fitted systematic component value for a non-parametrically modelled predictor. If there are more than one such predictors, the order of the rows is the same as the order that the user defines such predictors in the formula argument of cgam.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The response variable.</p>
</td></tr>
<tr><td><code>xmat_add</code></td>
<td>
<p>A matrix whose columns represent the shape-restricted predictors and smooth predictors with no shape constraint.</p>
</td></tr>
<tr><td><code>zmat</code></td>
<td>
<p>A matrix whose columns represent the basis for the parametrically modelled covariate. The user can choose to include a constant vector in it or not. It must have full column rank.</p>
</td></tr>
<tr><td><code>ztb</code></td>
<td>
<p>A list keeping track of the order of the parametrically modelled covariate.</p>
</td></tr>
<tr><td><code>tr</code></td>
<td>
<p>A matrix whose columns represent the predictors with a tree-ordering constraint.</p>
</td></tr>
<tr><td><code>umb</code></td>
<td>
<p>A matrix whose columns represent  the predictors with an umbrella-ordering constraint.</p>
</td></tr>
<tr><td><code>tree.delta</code></td>
<td>
<p>A matrix whose rows are the edges corresponding to the predictors with a tree-ordering constraint.</p>
</td></tr>
<tr><td><code>umbrella.delta</code></td>
<td>
<p>A matrix whose rows are the edges corresponding to the predictors with an umbrella-ordering constraint.</p>
</td></tr>
<tr><td><code>bigmat</code></td>
<td>
<p>A matrix whose rows are the basis spanning the null space of the constraint set and the edges corresponding to the shape-restricted and order-restricted predictors.</p>
</td></tr>
<tr><td><code>shapes</code></td>
<td>
<p>A vector including the shape and partial-ordering constraints in a cgam fit.</p>
</td></tr>
<tr><td><code>shapesx</code></td>
<td>
<p>A vector including the shape constraints in a cgam fit.</p>
</td></tr>
<tr><td><code>prior.w</code></td>
<td>
<p>User-defined weights.</p>
</td></tr>
<tr><td><code>wt</code></td>
<td>
<p>The weights in the final iteration of the iteratively re-weighted cone projections.</p>
</td></tr>
<tr><td><code>wt.iter</code></td>
<td>
<p>Logical flag indicating if or not iteratively re-weighted cone projections may be used. If the response is gaussian, then wt.iter = FALSE; if the response is binomial or poisson, then wt.iter = TRUE.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The family parameter defined in a cgam formula.</p>
</td></tr>
<tr><td><code>SSE0</code></td>
<td>
<p>The sum of squared residuals for the linear part.</p>
</td></tr>
<tr><td><code>SSE1</code></td>
<td>
<p>The sum of squared residuals for the full model.</p>
</td></tr>
<tr><td><code>pvals.beta</code></td>
<td>
<p>The approximate p-values for the estimation of the vector <code class="reqn">\beta</code>. A t-distribution is used as the approximate distribution.</p>
</td></tr>
<tr><td><code>se.beta</code></td>
<td>
<p>The standard errors for the estimation of the vector <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>null_df</code></td>
<td>
<p>The degree of freedom for the null model of a cgam fit, i.e., the model only containing a constant vector.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The degree of freedom for the null space of a cgam fit.</p>
</td></tr>
<tr><td><code>resid_df_obs</code></td>
<td>
<p>The observed degree of freedom for the residuals of a cgam fit.</p>
</td></tr>
<tr><td><code>null_deviance</code></td>
<td>
<p>The deviance for the null model of a cgam fit, i.e., the model only containing a constant vector.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The residual deviance of a cgam fit.</p>
</td></tr>
<tr><td><code>tms</code></td>
<td>
<p>The terms objects extracted by the generic function <em>terms</em> from a cgam fit.</p>
</td></tr>
<tr><td><code>capm</code></td>
<td>
<p>The number of edges corresponding to the shape-restricted predictors.</p>
</td></tr>
<tr><td><code>capms</code></td>
<td>
<p>The number of edges corresponding to the smooth predictors with no shape constraint.</p>
</td></tr>
<tr><td><code>capk</code></td>
<td>
<p>The number of non-constant columns of zmat.</p>
</td></tr>
<tr><td><code>capt</code></td>
<td>
<p>The number of edges corresponding to the tree-ordering predictors.</p>
</td></tr>
<tr><td><code>capu</code></td>
<td>
<p>The number of edges corresponding to the umbrella-ordering predictors.</p>
</td></tr>
<tr><td><code>xid1</code></td>
<td>
<p>A vector keeping track of the beginning position of the set of edges in bigmat for each shape-restricted predictor and smooth predictor with no shape constraint in xmat.</p>
</td></tr>
<tr><td><code>xid2</code></td>
<td>
<p>A vector keeping track of the end position of the set of edges in bigmat for each shape-restricted predictor and smooth predictor with no shape constraint in xmat.</p>
</td></tr>
<tr><td><code>tid1</code></td>
<td>
<p>A vector keeping track of the beginning position of the set of edges in bigmat for each tree-ordering factor in tr.</p>
</td></tr>
<tr><td><code>tid2</code></td>
<td>
<p>A vector keeping track of the end position of the set of edges in bigmat for each tree-ordering factor in tr.</p>
</td></tr>
<tr><td><code>uid1</code></td>
<td>
<p>A vector keeping track of the beginning position of the set of edges in bigmat for each umbrella-ordering factor in umb.</p>
</td></tr>
<tr><td><code>uid2</code></td>
<td>
<p>A vector keeping track of the end position of the set of edges in bigmat for each umbrella-ordering factor in umb.</p>
</td></tr>
<tr><td><code>zid</code></td>
<td>
<p>A vector keeping track of the positions of the parametrically modelled covariate.</p>
</td></tr>
<tr><td><code>vals</code></td>
<td>
<p>A vector storing the levels of each variable used as a factor.</p>
</td></tr>
<tr><td><code>zid1</code></td>
<td>
<p>A vector keeping track of the beginning position of the levels of each variable used as a factor.</p>
</td></tr>
<tr><td><code>zid2</code></td>
<td>
<p>A vector keeping track of the end position of the levels of each variable used as a factor.</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>
<p>The number of simulations used to get the cic parameter.</p>
</td></tr>
<tr><td><code>xnms</code></td>
<td>
<p>A vector storing the names of the shape-restricted predictors and the smooth predictors with no shape constraint in xmat.</p>
</td></tr>
<tr><td><code>ynm</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code>znms</code></td>
<td>
<p>A vector storing the names of the parametrically modelled covariate.</p>
</td></tr>
<tr><td><code>is_param</code></td>
<td>
<p>A logical scalar showing if or not a variable is a parametrically modelled covariate, which could be a linear term or a factor.</p>
</td></tr>
<tr><td><code>is_fac</code></td>
<td>
<p>A logical scalar showing if or not a variable is a factor.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>A list storing the knots used for each shape-restricted predictor and smooth predictor with no shape constraint. For a smooth,  constrained and a smooth, unconstrainted predictor, <em>knots</em> is a vector of more than <code class="reqn">1</code> elements, and for a shape-restricted predictor without smoothing, <em>knots</em> = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code>numknots</code></td>
<td>
<p>A vector storing the number of knots for each shape-restricted predictor and smooth predictor with no shape constraint. For a smooth, constrained and a smooth, unconstrainted predictor, <em>numknots</em> &gt; <code class="reqn">1</code>, and for a shape-restricted predictor without smoothing, <em>numknots</em> = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code>sps</code></td>
<td>
<p>A character vector storing the <em>space</em> parameter to create knots for each shape-restricted predictor.</p>
</td></tr>
<tr><td><code>ms</code></td>
<td>
<p>The centering terms used to make edges for shape-restricted predictors.</p>
</td></tr>
<tr><td><code>cpar</code></td>
<td>
<p>The cpar argument in the cgam formula</p>
</td></tr>
<tr><td><code>vh</code></td>
<td>
<p>The estimated monotonic variance function.</p>
</td></tr>
<tr><td><code>kts.var</code></td>
<td>
<p>The knots used in monotonic variance function estimation.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao </p>


<h3>References</h3>

<p>Liao, X. and Meyer, M. C. (2019) cgam: An R Package for the Constrained Generalized Additive Model.
<em>Journal of Statistical Software <b>89(5)</b></em>, 1&ndash;24. 
</p>
<p>Meyer, M. C. (2018) A Framework for Estimation and Inference in Generalized Additive Models with Shape and Order Restrictions.
<em>Statistical Science <b>33(4)</b></em>, 595&ndash;614. 
</p>
<p>Meyer, M. C. (2013a) Semi-parametric additive constrained regression. 
<em>Journal of Nonparametric Statistics <b>25(3)</b></em>, 715.
</p>
<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.  
</p>
<p>Meyer, M. C. and M. Woodroofe (2000) On the degrees of freedom in shape-restricted regression. <em>Annals of Statistics <b>28</b></em>, 1083&ndash;1104.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013&ndash;1033.
</p>
<p>Mammen, E. and K. Yu (2007) Additive isotonic regression. <em>IMS Lecture  Notes-Monograph Series Asymptotics: Particles, Process, and Inverse Problems <b>55</b></em>, 179&ndash;195.
</p>
<p>Huang, J. (2002) A note on estimating a partly linear model under monotonicity constraints. <em>Journal of Statistical Planning and Inference <b>107</b></em>, 343&ndash;351.
</p>
<p>Cheng, G.(2009) Semiparametric additive isotonic regression. <em>Journal of Statistical Planning and Inference <b>139</b></em>, 1980&ndash;1991.
</p>
<p>Bacchetti, P. (1989) Additive isotonic models. <em>Journal of the American Statistical Association <b>84(405)</b></em>, 289&ndash;294.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1.
  data(cubic)
  # extract x
  x &lt;- cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x with no restriction with lm()
  fit.lm &lt;- lm(y ~ x + I(x^2) + I(x^3))

  # regress y on x under the restriction: "increasing and convex"
  fit.cgam &lt;- cgam(y ~ incr.conv(x))

  # make a plot to compare the two fits
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, fit.cgam$muhat, col = 2, lty = 2)
  lines(x, fitted(fit.lm), col = 1, lty = 1)
  legend("topleft", bty = "n", c("constrained cgam fit", "unconstrained lm fit"), 
  lty = c(2, 1), col = c(2, 1))

# Example 2.
## Not run: 
  library(gam)
  data(kyphosis)
  
  # regress Kyphosis on Age, Number, and Start under the restrictions:
  # "concave", "increasing and concave", and "decreasing and concave" 
  fit &lt;- cgam(Kyphosis ~ conc(Age) + incr.conc(Number) + decr.conc(Start), 
  family = binomial(), data = kyphosis) 

## End(Not run)

# Example 3.
  library(MASS)
  data(Rubber)
  
  # regress loss on hard and tens under the restrictions:
  # "decreasing" and "decreasing"
  fit.cgam &lt;- cgam(loss ~ decr(hard) + decr(tens), data = Rubber)
  # "smooth and decreasing" and "smooth and decreasing"
  fit.cgam.s &lt;- cgam(loss ~ s.decr(hard) + s.decr(tens), data = Rubber)
  summary(fit.cgam.s)
  anova(fit.cgam.s)
  
  # make a 3D plot based on fit.cgam and fit.cgam.s
  plotpersp(fit.cgam, th = 120, main = "3D Plot of a Cgam Fit")
  plotpersp(fit.cgam.s, tens, hard, data = Rubber, th = 120, main = "3D Plot of a Smooth Cgam Fit")

# Example 4. monotonic variance estimation
  n &lt;- 400
  x &lt;- runif(n)
  sig &lt;- .1 + exp(15*x-8)/(1+exp(15*x-8))
  e &lt;- rnorm(n)
  mu &lt;- 10*x^2
  y &lt;- mu + sig*e

  fit &lt;- cgam(y ~ s.incr.conv(x), var.est = s.incr(x))
  est.var &lt;- fit$vh
  muhat &lt;- fit$muhat

  par(mfrow = c(1, 2))
  plot(x, y)
  points(sort(x), muhat[order(x)], type = "l", lwd = 2, col = 2)
  lines(sort(x), (mu)[order(x)], col = 4)

  plot(sort(x), est.var[order(x)], col=2, lwd=2, type="l", 
  lty=2, ylab="Variance", ylim=c(0, max(c(est.var, sig^2))))
  points(sort(x), (sig^2)[order(x)], col=1, lwd=2, type="l")

# Example 5. monotonic variance estimation with the lidar data set in SemiPar
  library(SemiPar)
  data(lidar)

  fit &lt;- cgam(logratio ~ s.decr(range), var.est=s.incr(range), data=lidar)
  muhat &lt;- fit$muhat
  est.var &lt;- fit$vh
  
  logratio &lt;- lidar$logratio
  range &lt;- lidar$range
  pfit &lt;- predict(fit, newData=data.frame(range=range), interval="confidence", level=0.95)
  upp &lt;- pfit$upper
  low &lt;- pfit$lower
  
  par(mfrow = c(1, 2))
  plot(range, logratio)
  points(sort(range), muhat[order(range)], type = "l", lwd = 2, col = 2)
  lines(sort(range), upp[order(range)], type = "l", lwd = 2, col = 4)
  lines(sort(range), low[order(range)], type = "l", lwd = 2, col = 4)
  title("Smoothly Decreasing Fit with a Point-Wise Confidence Interval", cex.main=0.5)
  
  plot(range, est.var, col=2, lwd=2, type="l",lty=2, ylab="variance")
  title("Smoothly Increasing Variance", cex.main=0.5)
</code></pre>

<hr>
<h2 id='cgamm'>Constrained Generalized Additive Mixed-Effects Model Fitting</h2><span id='topic+cgamm'></span>

<h3>Description</h3>

<p>This routine is an addition to the main routine cgam in this package. A random-intercept component is included in a cgam model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgamm(formula, nsim = 0, family = gaussian(), cpar = 1.2, data = NULL, weights = NULL,
sc_x = FALSE, sc_y = FALSE, bisect = TRUE, reml = TRUE, nAGQ = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cgamm_+3A_formula">formula</code></td>
<td>
<p>A formula object which gives a symbolic description of the model to be fitted. It has the form &quot;response ~ predictor + (1|id)&quot;, where id is the label for a group effect. For now, only gaussian responses are considered and this routine only includes a random-intercept effect. See <code><a href="#topic+cgam">cgam</a></code> for more details.</p>
</td></tr>
<tr><td><code id="cgamm_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations used to get the cic parameter. The default is nsim = 0.</p>
</td></tr>
<tr><td><code id="cgamm_+3A_family">family</code></td>
<td>
<p>A parameter indicating the error distribution and link function to be used in the model. For now, the options are family = gaussian() and family = binomial().</p>
</td></tr>
<tr><td><code id="cgamm_+3A_cpar">cpar</code></td>
<td>
<p>A multiplier to estimate the model variance, which is defined as <code class="reqn">\sigma^2 = SSR / (n - cpar * edf)</code>. SSR is the sum of squared residuals for the full model and edf is the effective degrees of freedom. The default is cpar = 1.2. The user-defined value must be between 1 and 2. See Meyer, M. C. and M. Woodroofe (2000) for more details.</p>
</td></tr>
<tr><td><code id="cgamm_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment containing the variables in the model. The default is data = NULL.</p>
</td></tr>
<tr><td><code id="cgamm_+3A_weights">weights</code></td>
<td>
<p>An optional non-negative vector of &quot;replicate weights&quot; which has the same length as the response vector. If weights are not given, all weights are taken to equal 1. The default is weights = NULL.</p>
</td></tr>
<tr><td><code id="cgamm_+3A_sc_x">sc_x</code></td>
<td>
<p>Logical flag indicating if or not continuous predictors are normalized. The default is sc_x = FALSE.</p>
</td></tr>
<tr><td><code id="cgamm_+3A_sc_y">sc_y</code></td>
<td>
<p>Logical flag indicating if or not the response variable is normalized. The default is sc_y = FALSE.</p>
</td></tr>
<tr><td><code id="cgamm_+3A_bisect">bisect</code></td>
<td>
<p>If bisect = TRUE, a 95 percent confidence interval will be found for the variance ratio parameter by a bisection method.</p>
</td></tr>
<tr><td><code id="cgamm_+3A_reml">reml</code></td>
<td>
<p>If reml = TRUE, restricted maximum likelihood (REML) method will be used to find estimates instead of maximum likelihood estimation (MLE).</p>
</td></tr>
<tr><td><code id="cgamm_+3A_nagq">nAGQ</code></td>
<td>
<p>Integer scalar - the number of points per axis for evaluating the adaptive Gauss-Hermite approximation to the log-likelihood. Defaults to 1, corresponding to the Laplace approximation. Values greater than 1 produce greater accuracy in the evaluation of the log-likelihood at the expense of speed.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>muhat</code></td>
<td>
<p>The fitted fixed-effect term.</p>
</td></tr>
<tr><td><code>ahat</code></td>
<td>
<p>A vector of estimated random-effect terms.</p>
</td></tr>
<tr><td><code>sig2hat</code></td>
<td>
<p>Estimate of the variance (<code class="reqn">\sigma^2</code>) of between-cluster error terms.</p>
</td></tr>
<tr><td><code>siga2hat</code></td>
<td>
<p>Estimate of the variance (<code class="reqn">\sigma_a^2</code>) of within-cluster error terms.</p>
</td></tr>
<tr><td><code>thhat</code></td>
<td>
<p>Estimate of the ratio (<code class="reqn">\theta</code>) of two variances.</p>
</td></tr>
<tr><td><code>pv.siga2</code></td>
<td>
<p><code class="reqn">p</code>-value of the test <code class="reqn">H_0: \sigma_a^2=0</code></p>
</td></tr>
<tr><td><code>ci.siga2</code></td>
<td>
<p>95 percent confidence interval for the variance of within-cluster error terms.</p>
</td></tr>
<tr><td><code>ci.th</code></td>
<td>
<p>95 percent confidence interval for ratio of two variances.</p>
</td></tr>
<tr><td><code>ci.rho</code></td>
<td>
<p>95 percent confidence interval for intraclass correlation coefficient.</p>
</td></tr>
<tr><td><code>ci.sig2</code></td>
<td>
<p>95 percent confidence interval for the variance of between-cluster error terms.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xiyue Liao</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 (family = gaussian).

# simulate a balanced data set with 30 clusters
# each cluster has 30 data points
	n &lt;- 30
	m &lt;- 30

# the standard deviation of between cluster error terms is 1
# the standard deviation of within cluster error terms is 2
	sige &lt;- 1
	siga &lt;- 2

# generate a continuous predictor
	x &lt;- 1:(m*n)
	for(i in 1:m) {
		x[(n*(i-1)+1):(n*i)] &lt;- round(runif(n), 3)
	}
# generate a group factor
	group &lt;- trunc(0:((m*n)-1)/n)+1

# generate the fixed-effect term
	mu &lt;- 10*exp(10*x-5)/(1+exp(10*x-5))

# generate the random-intercept term asscosiated with each group
	avals &lt;- rnorm(m, 0, siga)

# generate the response
	y &lt;- 1:(m*n)
	for(i in 1:m){
		y[group == i] &lt;- mu[group == i] + avals[i] + rnorm(n, 0, sige)
	}

# use REML method to fit the model
	ans &lt;- cgamm(y ~ s.incr(x) + (1|group), reml=TRUE)
	summary(ans)
	anova(ans)

	muhat &lt;- ans$muhat
	plot(x, y, col = group, cex = .6)
	lines(sort(x), mu[order(x)], lwd = 2)
	lines(sort(x), muhat[order(x)], col = 2, lty = 2, lwd = 2)
	legend("topleft", bty = "n", c("true fixed-effect term", "cgamm fit"),
	col = c(1, 2), lty = c(1, 2), lwd = c(2, 2))

# Example 2 (family = binomial).
# simulate a balanced data set with 20 clusters
# each cluster has 20 data points

  n &lt;- 20
  m &lt;- 20#
  N &lt;- n*m

  # siga is the sd for the random intercept
  siga &lt;- 1

# generate a group factor
  group &lt;- trunc(0:((m*n)-1)/n)+1
  group &lt;- factor(group)

# generate the random-intercept term asscosiated with each group
  avals &lt;- rnorm(m,0,siga)

# generate the fixed-effect mean term: mu, systematic term: eta and the response: y
  x &lt;- runif(m*n)
  mu &lt;- 1:(m*n)
  y &lt;- 1:(m*n)

  eta &lt;- 2 * (1 + tanh(7 * (x - .8))) - 2
  eta0 &lt;- eta
  for(i in 1:m){eta[group == i] &lt;- eta[group == i] + avals[i]}
  for(i in 1:m){mu[group == i] &lt;- 1 - 1 / (1 + exp(eta[group == i]))}
  for(i in 1:m){y[group == i] &lt;- rbinom(n, size = 1, prob = mu[group == i])}
  dat &lt;- data.frame(x = x, y = y, group = group)
  ansc &lt;- cgamm(y ~ s.incr.conv(x) + (1|group),
  family = binomial(link = "logit"), reml = FALSE, data = dat)
  summary(ansc)
  anova(ansc)
</code></pre>

<hr>
<h2 id='COforest'>
Colorado Forest Data Set
</h2><span id='topic+COforest'></span>

<h3>Description</h3>

<p>This data set contains 9167 records of different species of live trees for 345 sampled forested plots measured in 2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("COforest")</code></pre>


<h3>Format</h3>

<p>A data frame with 9167 observations on the following 19 variables.
</p>

<dl>
<dt><code>PLT_CN</code></dt><dd><p>Unique identifier of plot</p>
</dd>
<dt><code>STATECD</code></dt><dd><p>State code using Bureau of Census Federal Information Processing Standards (FIPS)</p>
</dd>
<dt><code>COUNTYCD</code></dt><dd><p>County code (FIPS)</p>
</dd>
<dt><code>ELEV_PUBLIC</code></dt><dd><p>Elevation (ft) extracted spatially using LON_PUBLIC/LAT_PUBLIC</p>
</dd>
<dt><code>LON_PUBLIC</code></dt><dd><p>Fuzzed longitude in decimal degrees using NAD83 datum</p>
</dd>
<dt><code>LAT_PUBLIC</code></dt><dd><p>Fuzzed latitude in decimal degrees using NAD83 datum</p>
</dd>
<dt><code>ASPECT</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SLOPE</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SUBP</code></dt><dd><p>Subplot number</p>
</dd>
<dt><code>TREE</code></dt><dd><p>Tree number within subplot</p>
</dd>
<dt><code>STATUSCD</code></dt><dd><p>Tree status (0:no status; 1:live tree; 2:dead tree; 3:removed)</p>
</dd>
<dt><code>SPCD</code></dt><dd><p>Species code</p>
</dd>
<dt><code>DIA</code></dt><dd><p>Current diameter (in)</p>
</dd>
<dt><code>HT</code></dt><dd><p>Total height (ft): estimated when broken or missing</p>
</dd>
<dt><code>ACTUALHT</code></dt><dd><p>Actual height (ft): measured standing or down</p>
</dd>
<dt><code>HTCD</code></dt><dd><p>Height method code (1:measured; 2:actual measured-length estimated; 3:actual and length estimated; 4:modeled</p>
</dd>
<dt><code>TREECLCD</code></dt><dd><p>Tree class code (2:growing-stock; 3:rough cull; 4:rotten cull)</p>
</dd>
<dt><code>CR</code></dt><dd><p>Compacted crown ratio (percentage)</p>
</dd>
<dt><code>CCLCD</code></dt><dd><p>Crown class (1:open grown; 2:domimant; 3:co-dominant; 4:intermediate; 5:overtopped)</p>
</dd>
</dl>



<h3>Source</h3>

<p>It is provided by Forest Inventory Analysis (FIA) National Program.
</p>


<h3>References</h3>

<p>X. Liao and M. Meyer (2019). Estimation and Inference in Mixed-Effect Regression Models using Shape Constraints, with Application to Tree Height Estimation. (<em>to appear in Journal of the Royal Statistical Society. Series C: Applied Statistics</em>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  library(dplyr)
  library(tidyr)
  data(COforest)

  #re-grouping classes of CCLCD:
  #combine dominant (2) and co-dominant (3)
  #combine intermediate (4) and overtopped (5)
  COforest = COforest 
    mutate(CCLCD = replace(CCLCD, CCLCD == 5, 4))

  #make a list of species, each element is a small data frame for one species
  species = COforest 

  #get the subset for quaking aspen, which is the 4th element in the species list
  sub = species$data[[4]]
  #for quaking aspen, there are only two crown classes: dominant/co-dominant
  #and intermediate/overtopped
  table(sub$CCLCD)
  #   3    4
  #1400  217
  #for quaking aspen, there are only two tree clases: growing-stock and rough cull
  table(sub$TREECLCD)
  #2    3
  #1591   26

  #fit the model
  ansc = cgamm(log(HT)~s.incr.conc(DIA)+factor(CCLCD)+factor(TREECLCD)
  +(1|PLT_CN), reml=TRUE, data=sub)

  #check which classes are significant
  summary(ansc)

  #fixed-effect 95
  newData = data.frame(DIA=sub$DIA,CCLCD=sub$CCLCD,TREECLCD=sub$TREECLCD)
  pfit = predict(ansc, newData,interval='confidence')
  lower = pfit$lower
  upper = pfit$upper
  #we need to use exp(muhat) later in the plot
  muhat = pfit$fit

  #get x and y
  x = sub$DIA
  y = sub$HT

  #get TREECLCD and CCLCD
  z1 = sub$TREECLCD
  z2 = sub$CCLCD

  #plot fixed-effect confidence intervals
  plot(x, y, xlab='DIA (m)', ylab='HT (m)', ylim=c(min(y),max(exp(upper))+10),type='n')
  lines(sort(x[z2==3&amp;z1==2]), (exp(pfit$fit)[z2==3&amp;z1==2])[order(x[z2==3&amp;z1==2])],
  col='slategrey', lty=1, lwd=2)
  lines(sort(x[z2==3&amp;z1==2]), (exp(pfit$lower)[z2==3&amp;z1==2])[order(x[z2==3&amp;z1==2])],
  col='slategrey', lty=1, lwd=2)
  lines(sort(x[z2==3&amp;z1==2]), (exp(pfit$upper)[z2==3&amp;z1==2])[order(x[z2==3&amp;z1==2])],
  col='slategrey', lty=1, lwd=2)

  lines(sort(x[z2==4&amp;z1==2]), (exp(pfit$fit)[z2==4&amp;z1==2])[order(x[z2==4&amp;z1==2])],
  col="blueviolet", lty=2, lwd=2)
  lines(sort(x[z2==4&amp;z1==2]), (exp(pfit$lower)[z2==4&amp;z1==2])[order(x[z2==4&amp;z1==2])],
  col="blueviolet", lty=2, lwd=2)
  lines(sort(x[Cz2==4&amp;z1==2]), (exp(pfit$upper)[Cz2==4&amp;z1==2])[order(x[Cz2==4&amp;z1==2])],
  col="blueviolet", lty=2, lwd=2)

  lines(sort(x[Cz2==3&amp;z1==3]), (exp(pfit$fit)[Cz2==3&amp;z1==3])[order(x[Cz2==3&amp;z1==3])],
  col=3, lty=3, lwd=2)
  lines(sort(x[Cz2==3&amp;z1==3]), (exp(pfit$lower)[Cz2==3&amp;z1==3])[order(x[Cz2==3&amp;z1==3])],
  col=3, lty=3, lwd=2)
  lines(sort(x[Cz2==3&amp;z1==3]), (exp(pfit$upper)[Cz2==3&amp;z1==3])[order(x[Cz2==3&amp;z1==3])],
  col=3, lty=3, lwd=2)

  lines(sort(x[Cz2==4&amp;z1==3]), (exp(pfit$fit)[Cz2==4&amp;z1==3])[order(x[Cz2==4&amp;z1==3])],
  col=2, lty=4, lwd=2)
  lines(sort(x[Cz2==4&amp;z1==3]), (exp(pfit$lower)[Cz2==4&amp;z1==3])[order(x[Cz2==4&amp;z1==3])],
  col=2, lty=4, lwd=2)
  lines(sort(x[Cz2==4&amp;z1==3]), (exp(pfit$upper)[Cz2==4&amp;z1==3])[order(x[Cz2==4&amp;z1==3])],
  col=2, lty=4, lwd=2)
  legend('bottomright', bty='n', cex=.9,c('dominant/co-dominant and growing stock',
  'intermediate/overtopped and growing stock','dominant/co-dominant and rough cull',
  'intermediate/overtopped and rough cull'), col=c('slategrey',"blueviolet",3,2),
  lty=c(1,2,3,4),lwd=c(2,2,2,2), pch=c(24,23,22,21))
  title('Quaking Aspen fits with 95

## End(Not run)


</code></pre>

<hr>
<h2 id='conc'>Specify a Concave Shape-Restriction in a CGAM Formula</h2><span id='topic+conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is concave in a predictor in a formula argument to cgam. This is the unsmoothed version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>conc(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conc_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="conc_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="conc_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="conc_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;conc&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;conc&quot;; the shape attribute is 4(&quot;concave&quot;), and according to the value of the vector itself and its shape attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the systematic component <code class="reqn">\eta</code> and &quot;x&quot; to be concave,  will be made. The cone edges are a set of basis employed in the hinge algorithm.  
</p>
<p>Note that &quot;conc&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 4(&quot;concave&quot;); numknots: the numknots argument in &quot;conc&quot;; knots: the knots argument in &quot;conc&quot;; space: the space argument in &quot;conc&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conv">conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # generate y
  x &lt;- seq(-1, 2, by = 0.1)
  n &lt;- length(x)
  y &lt;- - x^2 + rnorm(n, .3)  

  # regress y on x under the shape-restriction: "concave"
  ans &lt;- cgam(y ~ conc(x))

  # make a plot
  plot(x, y)
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "concave fit", col = 2, lty = 1)
</code></pre>

<hr>
<h2 id='conv'>Specify a Convex Shape-Restriction in a CGAM Formula</h2><span id='topic+conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is convex in a predictor in a formula argument to cgam. This is the unsmoothed version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="conv_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="conv_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="conv_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;conv&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space. 
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;conv&quot;; the shape attribute is 3(&quot;convex&quot;), and according to the value of the vector itself and its shape attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the systematic component <code class="reqn">\eta</code> and &quot;x&quot; to be convex,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;conv&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 3(&quot;convex&quot;); numknots: the numknots argument in &quot;conv&quot;; knots: the knots argument in &quot;conv&quot;
; space: the space argument in &quot;conv&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conc">conc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # generate y
  x &lt;- seq(-1, 2, by = 0.1)
  n &lt;- length(x)
  y &lt;- x^2 + rnorm(n, .3)  

  # regress y on x under the shape-restriction: "convex"
  ans &lt;- cgam(y ~ conv(x))

  # make a plot
  plot(x, y)
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "convex fit", col = 2, lty = 1)
</code></pre>

<hr>
<h2 id='cubic'>A Data Set for Cgam</h2><span id='topic+cubic'></span>

<h3>Description</h3>

<p>This data set is used for several examples in the cgam package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cubic)</code></pre>


<h3>Format</h3>

<p>A data frame with 50 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>The predictor vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>The response vector.</p>
</dd>  </dl>
  

<h3>Source</h3>

<p>STAT640 HW 14 given by Dr. Meyer.  </p>

<hr>
<h2 id='decr'>Specify a Decreasing Shape-Restriction in a CGAM Formula</h2><span id='topic+decr'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is decreasing in a predictor in a formula argument to cgam. This is the unsmoothed version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>decr(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decr_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="decr_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="decr_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="decr_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;decr&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space. 
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;decr&quot;; the shape attribute is 2(&quot;decreasing&quot;), and according to the value of the vector itself and its shape attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the systematic component <code class="reqn">\eta</code> and &quot;x&quot; to be decreasing, will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;decr&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 2(&quot;decreasing&quot;); numknots: the numknots argument in &quot;decr&quot;; knots: the knots argument in &quot;decr&quot;; space: the space argument in &quot;decr&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decr.conc">decr.conc</a></code>, <code><a href="#topic+decr.conv">decr.conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- - cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x with the shape restriction: "decreasing"
  ans &lt;- cgam(y ~ decr(x))

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, ans$muhat, col = 2)
  legend("bottomright", bty = "n", "decreasing fit", col = 2, lty = 1)

</code></pre>

<hr>
<h2 id='decr.conc'>Specify a Decreasing and Concave Shape-Restriction in a CGAM Formula</h2><span id='topic+decr.conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is decreasing and concave in a predictor in a formula argument to cgam. This is the unsmoothed version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>decr.conc(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decr.conc_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="decr.conc_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="decr.conc_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="decr.conc_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;decr.conc&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space. 
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;decr.conc&quot;; the shape attribute is 8(&quot;decreasing and concave&quot;), and according to the value of the vector itself and its shape attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the systematic component <code class="reqn">\eta</code> and &quot;x&quot; to be decreasing and concave, will be made. The cone edges are a set of basis employed in the hinge algorithm.
</p>
<p>Note that &quot;decr.conc&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 8(&quot;decreasing and concave&quot;); numknots: the numknots argument in &quot;decr.conc&quot;; knots: the knots argument in &quot;decr.conc&quot;; space: the space argument in &quot;decr.conc&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decr.conv">decr.conv</a></code>, <code><a href="#topic+decr">decr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;-  cubic$x

  # extract y
  y &lt;- - cubic$y

  # regress y on x with the shape restriction: "decreasing" and "concave"
  ans &lt;- cgam(y ~ decr.conc(x))

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "decreasing and concave fit", col = 2, lty = 1)

</code></pre>

<hr>
<h2 id='decr.conv'>Specify a Decreasing and Convex Shape-Restriction in a CGAM Formula</h2><span id='topic+decr.conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is decreasing and convex in a predictor in a formula argument to cgam. This is the unsmoothed version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>decr.conv(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decr.conv_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="decr.conv_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="decr.conv_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="decr.conv_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;decr.conv&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space. 
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;decr.conv&quot;; the shape attribute is 6(&quot;decreasing and convex&quot;), and according to the value of the vector itself and its shape attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the systematic component <code class="reqn">\eta</code> and &quot;x&quot; to be decreasing and convex,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;decr.conv&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 6(&quot;decreasing and convex&quot;); numknots: the numknots argument in &quot;decr.conv&quot;; knots: the knots argument in &quot;decr.conv&quot;; space: the space argument in &quot;decr.conv&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decr.conc">decr.conc</a></code>, <code><a href="#topic+decr">decr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- - cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x with the shape restriction: "decreasing" and "convex"
  ans &lt;- cgam(y ~ decr.conv(x))

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, ans$muhat, col = 2)
  legend("bottomright", bty = "n", "decreasing and convex fit", col = 2, lty = 1)

</code></pre>

<hr>
<h2 id='in.or.out'>To Include a Non-Parametrically Modelled Predictor in a SHAPESELECT Formula</h2><span id='topic+in.or.out'></span>

<h3>Description</h3>

<p>A symbolic routine to indicate that a predictor is included as a non-parametrically modeled predictor in a formula argument to ShapeSelect.</p>


<h3>Usage</h3>

<pre><code class='language-R'>in.or.out(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in.or.out_+3A_z">z</code></td>
<td>
<p>A non-parametrically modelled predictor which has the same length as the response vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To include a categorical predictor, in.or.out(factor(z)) is used, and to include a linear predictor z, in.or.out(z) is used. If in.or.out is not used, the user can include z in a model by adding z or factor(z) in a ShapeSelect formula.
</p>


<h3>Value</h3>

<p>The vector z with three attributes, i.e., nm: the name of z; shape: 1 or 0 (in or out of the model); type: &quot;fac&quot; or &quot;lin&quot;, i.e., z is modelled as a categorical predictor or a linear predictor.</p>


<h3>Author(s)</h3>

<p>Xiyue Liao</p>


<h3>See Also</h3>

<p><code><a href="#topic+shapes">shapes</a></code>, <code><a href="#topic+ShapeSelect">ShapeSelect</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  n &lt;- 100
  # x is a continuous predictor 
  x &lt;- runif(n)
  
  # generate z and to include it as a categorical predictor
  z &lt;- rep(0:1, 50)

  # y is generated as correlated to both x and z
  # the relationship between y and x is smoothly increasing-convex
  y &lt;- x^2 + 2 * I(z == 1) + rnorm(n, sd = 1)

  # call ShapeSelect to find the best model by the genetic algorithm
  # factor(z) may be in or out of the model  
  fit &lt;- ShapeSelect(y ~ shapes(x) + in.or.out(factor(z)), genetic = TRUE)

  # factor(z) isn't chosen and is included in the model
  fit &lt;- ShapeSelect(y ~ shapes(x) + factor(z), genetic = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='incr'>Specify an Increasing Shape-Restriction in a CGAM Formula</h2><span id='topic+incr'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is increasing in a predictor in a formula argument to cgam. This is the unsmoothed version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>incr(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incr_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="incr_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="incr_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="incr_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;incr&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space. 
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;incr&quot;; the shape attribute is 1(&quot;increasing&quot;), and according to the value of the vector itself and its attributes, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the systematic component <code class="reqn">\eta</code> and &quot;x&quot; to be increasing,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;incr&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 1(&quot;increasing&quot;); numknots: the numknots argument in &quot;incr&quot;; knots: the knots argument in &quot;incr&quot;; space: the space argument in &quot;incr&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incr.conc">incr.conc</a></code>, <code><a href="#topic+incr.conv">incr.conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x with the shape restriction: "increasing"
  ans &lt;- cgam(y ~ incr(x))

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "increasing fit", col = 2, lty = 1)
</code></pre>

<hr>
<h2 id='incr.conc'>Specify an Increasing and Concave Shape-Restriction in a CGAM Formula</h2><span id='topic+incr.conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is increasing and concave in a predictor in a formula argument to cgam. This is the unsmoothed version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>incr.conc(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incr.conc_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="incr.conc_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr> 
<tr><td><code id="incr.conc_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="incr.conc_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;incr.conc&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space. 
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;incr.conc&quot;; the shape attribute is 7(&quot;increasing and concave&quot;), and according to the value of the vector itself and its attributes, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the systematic component <code class="reqn">\eta</code> and &quot;x&quot; to be increasing and concave,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;incr.conc&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 7(&quot;increasing and concave&quot;); numknots: the numknots argument in &quot;incr.conc&quot;; knots: the knots argument in &quot;incr.conc&quot;; space: the space argument in &quot;incr.conc&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incr.conv">incr.conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- - cubic$x

  # extract y
  y &lt;- - cubic$y

  # regress y on x with the shape restriction: "increasing" and "concave"
  ans &lt;- cgam(y ~ incr.conc(x))

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "increasing and concave fit", col = 2, lty = 1)

</code></pre>

<hr>
<h2 id='incr.conv'>Specify an Increasing and Convex Shape-Restriction in a CGAM Formula</h2><span id='topic+incr.conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is increasing and convex in a predictor in a formula argument to cgam. This is the unsmoothed version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>incr.conv(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incr.conv_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="incr.conv_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="incr.conv_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="incr.conv_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;incr.conv&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space. 
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;incr.conv&quot;; the shape attribute is 5(&quot;increasing and convex&quot;), and according to the value of the vector itself and its attributes, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the systematic component <code class="reqn">\eta</code> and &quot;x&quot; to be increasing and convex,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;incr.conv&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 5(&quot;increasing and convex&quot;); numknots: the numknots argument in &quot;incr.conv&quot;; knots: the knots argument in &quot;incr.conv&quot;; space: the space argument in &quot;incr.conv&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incr.conc">incr.conc</a></code>, <code><a href="#topic+incr">incr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x with the shape restriction: "increasing" and "convex"
  ans &lt;- cgam(y ~ incr.conv(x))

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "increasing and convex fit", col = 2, lty = 1)

</code></pre>

<hr>
<h2 id='mental'>Alachua County Study of Mental Impairment</h2><span id='topic+mental'></span>

<h3>Description</h3>

<p>The date set is from a study of mental health for a random sample of 40 adult residents of Alachua County, Florida. Mental impairment is an ordinal response with 4 categories: well, mild symptom formation, moderate symptom formation, and impaired, which are recorded as 1, 2, 3, and 4. Life event index is a composite measure of the number and severity of important life events that occurred with the past three years, e.g., birth of a child, new job, divorce, or death of a family member. It is an integer from 0 to 9. Another covariate is socio-economic status and it is measured as binary: high = 1, low = 0.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mental)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>mental</code></dt><dd><p>Mental impairment. It is an ordinal response with <code class="reqn">4</code> categories recorded as <code class="reqn">1</code>, <code class="reqn">2</code>, <code class="reqn">3</code>, and  <code class="reqn">4</code>.</p>
</dd>
<dt><code>ses</code></dt><dd><p>Socio-economic status measured as binary: high = <code class="reqn">1</code>, low = <code class="reqn">0</code>.  
</p>
</dd>
<dt><code>life</code></dt><dd><p>Life event index. It is an integer from <code class="reqn">0</code> to <code class="reqn">9</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Agresti, A. (2010) Analysis of Ordinal Categorical Data, <em>2nd ed. Hoboken, NJ: Wiley</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ord">Ord</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# proportional odds model example 
	data(mental)
	
	# model the relationship between the latent variable and life event index as increasing
	# socio-economic status is included as a binary covariate 
	fit.incr &lt;- cgam(mental ~ incr(life) + ses, data = mental, family = Ord)

	# check the estimated probabilities P(mental = k), k = 1, 2, 3, 4
	probs.incr &lt;- fitted(fit.incr)
	head(probs.incr)
</code></pre>

<hr>
<h2 id='Ord'>Specify an Ordered Categorical Family in a CGAM Formula</h2><span id='topic+Ord'></span>

<h3>Description</h3>

<p>This is a subroutine to specify an ordered catergorical family in a cgam formula. It set things up to a routine called cgam.polr. This is learned from the polr routine in the MASS package, which fits a logistic or probit regression model to an ordered categorical response. Currently only the logistic regression model is allowed. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ord(link = "identity")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ord_+3A_link">link</code></td>
<td>
<p>The link function. Users don't need specify this term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the polr section in the official manual of the MASS package (<a href="https://cran.r-project.org/package=MASS">https://cran.r-project.org/package=MASS</a>) for details. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>muhat</code></td>
<td>
<p>The estimated expected value of a latent variable.</p>
</td></tr>
<tr><td><code>zeta</code></td>
<td>
<p>Estimated cut-points defining the intervals of a latent 
variable such that the latent variable is between two adjacent cut-points is equivalent to that the ordered categorical response is in a category.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xiyue Liao
</p>


<h3>References</h3>

<p>Agresti, A. (2002) <em>Categorical Data</em>. Second edition. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mental">mental</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	# Example 1. 
	# generate the predictor and the latenet variable
	n &lt;- 500
	set.seed(123)
	x &lt;- runif(n, 0, 1)
	yst &lt;- 5*x^2 + rlogis(n)
	
	# generate observed ordered response, which has levels 1, 2, 3. 
	cts &lt;- quantile(yst, probs = seq(0, 1, length = 4)) 
	yord &lt;- cut(yst, breaks = cts, include.lowest = TRUE, labels = c(1:3), Ord = TRUE)
	y &lt;- as.numeric(levels(yord))[yord] 

	# regress y on x under the shape-restriction: the latent variable is "increasing-convex"
	# w.r.t x
	ans &lt;- cgam(y ~ s.incr.conv(x), family = Ord)
	
	# check the estimated cut-points
	ans$zeta
	
	# check the estimated expected value of the latent variable
	head(ans$muhat)
	
	# check the estimated probabilities P(y = k), k = 1, 2, 3
	head(fitted(ans))
	
	# check the estimated latent variable
	plot(x, yst, cex = 1, type = "n", ylab = "latent variable")
	cols &lt;- topo.colors(3)
	for (i in 1:3) {
		points(x[y == i], yst[y == i], col = cols[i], pch = i, cex = 0.7)
	}
	for (i in 1:2) {
		abline(h = (ans$zeta)[i], lty = 4, lwd = 1)
	}
	lines(sort(x), (5*x^2)[order(x)], lwd = 2)
	lines(sort(x), (ans$muhat)[order(x)], col = 2, lty = 2, lwd = 2)
	legend("topleft", bty = "n", col = c(1, 2), lty = c(1, 2), 
	c("true latent variable", "increasing-convex fit"), lwd = c(1, 1))

## End(Not run)	
## Not run: 
	# Example 2. mental impairment data set 
	# mental impairment is an ordinal response with 4 categories recorded as 1, 2, 3, and 4
	# two covariates are life event index and socio-economic status (high = 1, low = 0)
	data(mental)
	table(mental$mental)
	
	# model the relationship between the latent variable and life event index as increasing
	# socio-economic status is included as a binary covariate 
	fit.incr &lt;- cgam(mental ~ incr(life) + ses, data = mental, family = Ord)

	# check the estimated probabilities P(mental = k), k = 1, 2, 3, 4
	probs.incr &lt;- fitted(fit.incr)
	head(probs.incr)

## End(Not run)

</code></pre>

<hr>
<h2 id='plasma'>A Data Set for Cgam</h2><span id='topic+plasma'></span>

<h3>Description</h3>

<p>This data set is used for the routine plotpersp. It contains 314 observations of blood plasma, beta carotene measurements along with several covariates. High levels of blood plasma and beta carotene are believed to be protective against cancer, and it is of interest to determine the relationships with covariates. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(plasma)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>logplasma</code></dt><dd><p>A numeric vector of the logarithm of plasma levels.</p>
</dd>
<dt><code>betacaro</code></dt><dd><p>A numeric vector of dietary beta carotene consumed mcg per day.</p>
</dd>
<dt><code>bmi</code></dt><dd><p>A numeric vector of BMI values.</p>
</dd>
<dt><code>cholest</code></dt><dd><p>A numeric vector of cholesterol consumed mg per day.</p>
</dd>
<dt><code>dietfat</code></dt><dd><p>A numeric vector of the logarithm of grams of diet fat consumed per day.</p>
</dd>
<dt><code>fiber</code></dt><dd><p>A numeric vector of grams of fiber consumed per day.</p>
</dd>
<dt><code>retinol</code></dt><dd><p>A numeric vector of retinol consumed per day.</p>
</dd>
<dt><code>smoke</code></dt><dd><p>A numeric vector of smoking status (1=Never, 2=Former, 3=Current Smoker).</p>
</dd>
<dt><code>vituse</code></dt><dd><p>A numeric vector of vitamin use (1=Yes, fairly often, 2=Yes, not often, 3=No).</p>
</dd>
</dl>



<h3>References</h3>

<p>Nierenberg, D.,Stukel, T.,Baron, J.,Dain, B.,and Greenberg, E. (1989) Determinants of plasma levels of beta-carotene and retinol. <em>American Journal of Epidemiology <b>130</b></em>, 511&ndash;521.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(plasma)</code></pre>

<hr>
<h2 id='plotpersp'>Create a 3D Plot for a CGAM Object</h2><span id='topic+plotpersp'></span>

<h3>Description</h3>

<p>Given an object of the cgam class, which has at least two non-parametrically modelled predictors, this routine will make a 3D plot of the fit with a set of two non-parametrically modelled predictors in the formula being the x and y labs. If there are more than two non-parametrically modelled predictors, any other such predictor will be evaluated at the largest value which is smaller than or equal to its median value.
</p>
<p>If there is any categorical covariate and if the user specifies the argument categ to be a character representing a categorical covariate in the formula, then a 3D plot with multiple parallel surfaces, which represent the levels of a categorical covariate in an ascending order, will be created; otherwise, a 3D plot with only one surface will be created. Each level of a categorical covariate will be evaluated at its mode.
</p>
<p>This routine is extended to make a 3D plot for an object fitted by warped-plane splines or triangle splines. Note that two non-parametrically modelled predictors specified in this routine must both be modelled as addtive components, or a pair of predictors forming an isotonic or convex surface without additivity assumption.
</p>
<p>This routine is an extension of the generic R graphics routine persp. See the documentation below for more details. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  plotpersp(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotpersp_+3A_object">object</code></td>
<td>
<p>An object of the cgam class with at least two non-parametrically modelled predictors.</p>
</td></tr>
<tr><td><code id="plotpersp_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to the S3 method for the cgam class:
</p>

<ul>
<li><p>x1A non-parametrically modelled predictor in a cgam fit. If the user omits x1 and x2, then the first two non-parametric predictors in a cgam formula will be used.
</p>
</li>
<li><p>x2A non-parametrically modelled predictor in a cgam fit. If the user omits x1 and x2, then the first two non-parametric predictors in a cgam formula will be used.
</p>
</li>
<li><p>x1nm: Character name of x1.
</p>
</li>
<li><p>x2nm: Character name of x2.
</p>
</li>
<li><p>data: The data frame based on which the user get a cgam fit.
</p>
</li>
<li><p>surface: The type of the surface of a 3D plot. For a cgam fit, if surface == &quot;mu&quot;, then the surface of the estimated mean value of the fit will be plotted; if surface == &quot;eta&quot;, then the surface of the estimated systematic component value of the fit will be plotted. The default is surface = &quot;mu&quot;; for a warped-plane spline fit, if surface == &quot;C&quot;, then the surface of the constrained estimated mean value of the fit will be plotted, while if surface == &quot;U&quot;, then the surface of the unconstrained estimated mean value of the fit will be plotted. The default is surface = &quot;C&quot;.
</p>
</li>
<li><p>categ: Optional categorical covariate(s) in a cgam fit. If there is any categorical covariate and if the user specifies the argument categ to be a character representing a categorical covariate in the formula, then a 3D plot with multiple parallel surfaces, which represent the levels of a categorical covariate in an ascending order, will be created; otherwise, a 3D plot with only one surface will be created. Each level of a categorical covariate will be evaluated at its mode. The default is categ = NULL.
</p>
</li>
<li><p>col: The color(s) of a 3D plot created by plotpersp. If col == NULL, &quot;white&quot; will be used when there is only one surface in the plot, and a sequence of colors will be used in a fixed order when there are multiple parallel surfaces in the plot. For example, when there are two surfaces, the lower surface will be in the color &quot;peachpuff&quot;, and the higher surface will be in the color &quot;lightblue&quot;. The default is col =  NULL.
</p>
</li>
<li><p>random: A logical scalar. If random == TRUE, color(s) for a 3D plot will be randomly chosen from ten colors, namely, &quot;peachpuff&quot;, &quot;lightblue&quot;, &quot;limegreen&quot;, &quot;grey&quot;, &quot;wheat&quot;, &quot;yellowgreen&quot;, &quot;seagreen1&quot;, &quot;palegreen&quot;, &quot;azure&quot;, &quot;whitesmoke&quot;; otherwise, &quot;white&quot; will be used when there is only one surface in the plot, and a sequence of colors will be used in a fixed order when there are multiple parallel surfaces in the plot.
</p>
</li>
<li><p>ngrid: This is a positive integer specifying how dense the <code class="reqn">x</code> grid and the <code class="reqn">y</code> grid will be. The default is ngrid = <code class="reqn">12</code>. Note that this argument is only used for a cgam fit.
</p>
</li>
<li><p>xlim: The xlim argument inherited from the persp routine.
</p>
</li>
<li><p>ylim: The ylim argument inherited from the persp routine.
</p>
</li>
<li><p>zlim: The zlim argument inherited from the persp routine.
</p>
</li>
<li><p>xlab: The xlab argument inherited from the persp routine.
</p>
</li>
<li><p>ylab: The ylab argument inherited from the persp routine.
</p>
</li>
<li><p>zlab: The zlab argument inherited from the persp routine.
</p>
</li>
<li><p>main: The main argument inherited from the persp routine.
</p>
</li>
<li><p>th: The theta argument inherited from the persp routine.
</p>
</li>
<li><p>ltheta: The ltheta argument inherited from the persp routine.
</p>
</li>
<li><p>main: The main argument inherited from the persp routine.
</p>
</li>
<li><p>ticktype: The ticktype argument inherited from the persp routine.

</p>
</li></ul>

</td></tr>
</table>


<h3>Value</h3>

<p>The routine plotpersp returns a 3D plot of an object of the cgam class. The <code class="reqn">x</code> lab and <code class="reqn">y</code> lab represent a set of non-parametrically modelled predictors used in a cgam formula, and the <code class="reqn">z</code> lab represents the estimated mean value or the estimated systematic component value.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1.
  data(FEV)

  # extract the variables
  y &lt;- FEV$FEV
  age &lt;- FEV$age
  height &lt;- FEV$height
  sex &lt;- FEV$sex
  smoke &lt;- FEV$smoke

  fit &lt;- cgam(y ~ incr(age) + incr(height) + factor(sex) + factor(smoke), nsim = 0)
  fit.s &lt;- cgam(y ~ s.incr(age) + s.incr(height) + factor(sex) + factor(smoke), nsim = 0)

  plotpersp(fit, age, height, ngrid = 10, main = "Cgam Increasing Fit", 
  sub = "Categorical Variable: Sex", categ = "factor(sex)")
  plotpersp(fit.s, age, height, ngrid = 10, main = "Cgam Smooth Increasing Fit", 
  sub = "Categorical Variable: Smoke", categ = "factor(smoke)")

# Example 2.
  data(plasma)

  # extract the variables
  y &lt;- plasma$logplasma
  bmi &lt;- plasma$bmi
  logdietfat &lt;- plasma$logdietfat
  cholest &lt;- plasma$cholest
  fiber &lt;- plasma$fiber
  betacaro &lt;- plasma$betacaro
  retinol &lt;- plasma$retinol
  smoke &lt;- plasma$smoke
  vituse &lt;- plasma$vituse

  fit &lt;- cgam(y ~  s.decr(bmi) + s.decr(logdietfat) + s.decr(cholest) + s.incr(fiber) 
+ s.incr(betacaro) + s.incr(retinol) + factor(smoke) + factor(vituse)) 

  plotpersp(fit, bmi, logdietfat, ngrid = 15, th = 120, ylab = "log(dietfat)", 
zlab = "est mean of log(plasma)", main = "Cgam Fit with the Plasma Data Set", 
sub = "Categorical Variable: Vitamin Use", categ = "factor(vituse)")

# Example 3.
  data(plasma)
  addl &lt;- 1:314*0 + 1 
  addl[runif(314) &lt; .3] &lt;- 2
  addl[runif(314) &gt; .8] &lt;- 4
  addl[runif(314) &gt; .8] &lt;- 3

  ans &lt;- cgam(logplasma ~ s.incr(betacaro, 5) + s.decr(bmi) + s.decr(logdietfat) 
+ as.factor(addl), data = plasma)
  plotpersp(ans, betacaro, logdietfat, th = 240, random = TRUE, 
categ = "as.factor(addl)", data = plasma)

# Example 4.
## Not run: 
  n &lt;- 100
  set.seed(123)
  x1 &lt;- sort(runif(n))
  x2 &lt;- sort(runif(n))
  y &lt;- 4 * (x1 - x2) + rnorm(n, sd = .5)

  # regress y on x1 and x2 under the shape-restriction: "decreasing-increasing"
  # with a penalty term = .1
  ans &lt;- cgam(y ~ s.decr.incr(x1, x2), pen = .1)

# plot the constrained surface
  plotpersp(ans)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='predict.cgam'>Predict Method for CGAM Fits</h2><span id='topic+predict.cgam'></span>

<h3>Description</h3>

<p>Predicted values based on a cgam object</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgam'
predict(object, newData, interval = c("none", "confidence", "prediction"), 
type = c("response", "link"), level = 0.95, n.mix = 500,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cgam_+3A_object">object</code></td>
<td>
<p>A cgam object.</p>
</td></tr>
<tr><td><code id="predict.cgam_+3A_newdata">newData</code></td>
<td>
<p>A data frame in which to look for variables with which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.cgam_+3A_interval">interval</code></td>
<td>
<p>Type of interval calculation. A prediction interval is only implemented for Gaussian response for now.</p>
</td></tr>
<tr><td><code id="predict.cgam_+3A_type">type</code></td>
<td>
<p>If the response is Gaussian, type = &quot;response&quot; gives the predicted mean; if the response is binomial, type = &quot;response&quot; gives the predicted probabilities, and type = &quot;link&quot; gives the predicted systematic component.</p>
</td></tr>
<tr><td><code id="predict.cgam_+3A_level">level</code></td>
<td>
<p>Tolerance/confidence level.</p>
</td></tr>
<tr><td><code id="predict.cgam_+3A_n.mix">n.mix</code></td>
<td>
<p>Number of simulations to get the mixture distribution. The default is n.mix = 500.</p>
</td></tr>
<tr><td><code id="predict.cgam_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the routine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constrained spline estimators can be characterized by projections onto a polyhedral convex cone. Point-wise confidence intervals for constrained splines are constructed by estimating the probabilities that the projection lands on each of the faces of the cone, and using a mixture of covariance matrices to estimate the standard error of the function estimator at any design point. 
</p>
<p>Note that currently predict.cgam only works when all components in a cgam formula are additive.
</p>
<p>See references cited in this section for more details.	
</p>


<h3>Value</h3>

<table>
<tr><td><code>fit</code></td>
<td>
<p>A vector of predictions.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>A vector of lower bound if interval is set to be &quot;confidence&quot;.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>A vector of upper bound if interval is set to be &quot;confidence&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2017) Constrained partial linear regression splines. <em>Statistical Sinica in press</em>.
</p>
<p>Meyer, M. C. (2017) Confidence intervals for regression functions using constrained
splines with application to estimation of tree height
</p>
<p>Meyer, M. C. (2012) Constrained penalized splines. <em>Canadian Journal of Statistics <b>40(1)</b></em>, 190&ndash;206.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013&ndash;1033.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1.
	# generate data
	n &lt;- 100
	set.seed(123)
	x &lt;- runif(n)
	y &lt;- 4*x^3 + rnorm(n)

	# regress y on x under the shape-restriction: "increasing-convex"
	fit &lt;- cgam(y ~ s.incr.conv(x))
	
	# make a data frame 
	x0 &lt;- seq(min(x), max(x), by = 0.05)
	new.Data &lt;- data.frame(x = x0)

	# predict values in new.Data based on the cgam fit without a confidence interval
	pfit &lt;- predict(fit, new.Data)
	
	# or 
	pfit &lt;- predict(fit, new.Data, interval = "none")
	
	# make a plot to check the prediction
	plot(x, y, main = "Predict Method for CGAM")
	lines(sort(x), (fitted(fit)[order(x)]))
	points(x0, pfit$fit, col = 2, pch = 20)

	# predict values in new.Data based on the cgam fit with a 95 percent confidence interval
	pfit &lt;- predict(fit, new.Data, interval = "confidence", level = 0.95)

	# make a plot to check the prediction
	plot(x, y, main = "Pointwise Confidence Bands (Gaussian Response)")
	lines(sort(x), (fitted(fit)[order(x)]))
	lines(sort(x0), (pfit$lower)[order(x0)], col = 2, lty = 2)
	lines(sort(x0), (pfit$upper)[order(x0)], col = 2, lty = 2)
	points(x0, pfit$fit, col = 2, pch = 20)

# Example 2. binomial response
	n &lt;- 200
	x &lt;- seq(0, 1, length = n)

	eta &lt;- 4*x - 2
	mu &lt;- exp(eta)/(1+exp(eta))
	set.seed(123)
	y &lt;- 1:n*0
	y[runif(n)&lt;mu] = 1
        
	fit &lt;- cgam(y ~ s.incr.conv(x), family = binomial)
	muhat &lt;- fitted(fit)
	
    # predict values in new.Data based on the cgam fit with a 95 percent confidence interval
    xinterp &lt;- seq(min(x), max(x), by = 0.05)
    new.Data &lt;- data.frame(x = xinterp)
	pfit &lt;- predict(fit, new.Data, interval = "confidence", level = 0.95)
	pmu &lt;- pfit$fit
	lwr &lt;- pfit$lower
	upp &lt;- pfit$upper
	
	# make a plot to check the prediction	
	plot(x, y, type = "n", ylim = c(0, 1), 
	main = "Pointwise Confidence Bands (Binomial Response)")
	rug(x[y == 0])
    rug(x[y == 1], side = 3)   
	lines(x, mu)
	lines(x, muhat, col = 5, lty = 2)
       
	points(xinterp, pmu, pch = 20)
	lines(xinterp, upp, col = 5)
	points(xinterp, upp, pch = 20)
	lines(xinterp, lwr, col = 5)
	points(xinterp, lwr, pch = 20)
</code></pre>

<hr>
<h2 id='s'>Specify a Smooth Shape-Restriction in a CGAM Formula</h2><span id='topic+s'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is smooth in a predictor in a formula argument to cgam. This is the smooth version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s(x, numknots = 0, knots = 0, space = "Q")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to constrain <code class="reqn">x</code>. It will not be used if the user specifies the <em>knots</em> argument. The default is numknots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s_+3A_knots">knots</code></td>
<td>
<p>The knots used to constrain <code class="reqn">x</code>. User-defined knots will be used when given. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used if the user specifies the <em>knots</em> argument. If space == &quot;E&quot;, then equally spaced knots will be created; if space == &quot;Q&quot;, then a vector of equal <code class="reqn">x</code> quantiles will be created based on <code class="reqn">x</code> with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> <code class="reqn">&gt; 0</code>. Otherwise it is of the order <code class="reqn">n^{1/7}</code>. The default is space = &quot;Q&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s&quot;; the shape attribute is 17(&quot;smooth&quot;). According to the value of the vector itself and its shape, numknots, knots and space attributes, the cone edges will be made by C-spline basis functions in Meyer (2008). The cone edges are a set of basis employed in the hinge algorithm.
</p>
<p>Note that &quot;s&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 17(&quot;smooth&quot;); numknots: the numknots argument in &quot;s&quot;; knots: the knots argument in &quot;s&quot;;
space: the space argument in &quot;s&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013&ndash;1033.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s.incr">s.incr</a></code>, <code><a href="#topic+s.decr">s.decr</a></code>,  <code><a href="#topic+s.conc">s.conc</a></code>,   <code><a href="#topic+s.conv">s.conv</a></code>,   <code><a href="#topic+s.incr.conc">s.incr.conc</a></code>,  <code><a href="#topic+s.incr.conv">s.incr.conv</a></code>,   <code><a href="#topic+s.decr.conc">s.decr.conc</a></code>,  <code><a href="#topic+s.decr.conv">s.decr.conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # generate y
  x &lt;- seq(-1, 2, by = 0.1)
  n &lt;- length(x)
  y &lt;- - x^2 + rnorm(n, .3)

  # regress y on x under the shape-restriction: "smooth"
  ans &lt;- cgam(y ~ s(x))
  knots &lt;- ans$knots[[1]]

  # make a plot
  plot(x, y)
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "smooth fit", col = 2, lty = 1)
  legend(1.6, 1.8, bty = "o", "knots", pch = "X")
  points(knots, 1:length(knots)*0+min(y), pch = "X")
</code></pre>

<hr>
<h2 id='s.conc'>Specify a Smooth and Concave Shape-Restriction in a CGAM Formula</h2><span id='topic+s.conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is smooth and concave in a predictor in a formula argument to cgam. This is the smooth version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.conc(x, numknots = 0, knots = 0, space = "Q")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.conc_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.conc_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to constrain <code class="reqn">x</code>. It will not be used if the user specifies the <em>knots</em> argument. The default is numknots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.conc_+3A_knots">knots</code></td>
<td>
<p>The knots used to constrain <code class="reqn">x</code>. User-defined knots will be used when given. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.conc_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used if the user specifies the <em>knots</em> argument. If space == &quot;E&quot;, then equally spaced knots will be created; if space == &quot;Q&quot;, then a vector of equal <code class="reqn">x</code> quantiles will be created based on <code class="reqn">x</code> with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> <code class="reqn">&gt; 0</code>. Otherwise it is of the order <code class="reqn">n^{1/7}</code>. The default is space = &quot;Q&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.conc&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.conc&quot;; the shape attribute is 12(&quot;smooth and concave&quot;). According to the value of the vector itself and its shape, numknots, knots and space attributes, the cone edges will be made by C-spline basis functions in Meyer (2008). The cone edges are a set of basis employed in the hinge algorithm.
</p>
<p>Note that &quot;s.conc&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 12(&quot;smooth and concave&quot;); numknots: the numknots argument in &quot;s.conc&quot;; knots: the knots argument in &quot;s.conc&quot;; space: the space argument in &quot;s.conc&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013&ndash;1033.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conc">conc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # generate y
  x &lt;- seq(-1, 2, by = 0.1)
  n &lt;- length(x)
  y &lt;- - x^2 + rnorm(n, .3)

  # regress y on x under the shape-restriction: "smooth and concave"
  ans &lt;- cgam(y ~ s.conc(x))
  knots &lt;- ans$knots[[1]]

  # make a plot
  plot(x, y)
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "smooth and concave fit", col = 2, lty = 1)
  legend(1.6, 1.8, bty = "o", "knots", pch = "X")
  points(knots, 1:length(knots)*0+min(y), pch = "X")
</code></pre>

<hr>
<h2 id='s.conc.conc'>Specify a Doubly-Concave Shape-Restriction in a CGAM Formula</h2><span id='topic+s.conc.conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that a surface is concave in two predictors in a formula argument to cgam.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.conc.conc(x1, x2, numknots = c(0, 0), knots = list(k1 = 0, k2 = 0), space = c("E", "E"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.conc.conc_+3A_x1">x1</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.conc.conc_+3A_x2">x2</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.conc.conc_+3A_numknots">numknots</code></td>
<td>
<p>A vector of the number of knots used to constrain <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. It will not be used if the user specifies the <em>knots</em> argument and each predictor is within the range of its knots. The default is numknots = c(0, 0).</p>
</td></tr>
<tr><td><code id="s.conc.conc_+3A_knots">knots</code></td>
<td>
<p>A list of two vectors of knots used to constrain <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. User-defined knots will be used if each predictor is within the range of its knots. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = list(k1 = 0, k2 = 0).</p>
</td></tr>
<tr><td><code id="s.conc.conc_+3A_space">space</code></td>
<td>
<p>A vector of the character specifying the method to create knots for <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. It will not be used if the user specifies the <em>knots</em> argument. If &quot;E&quot; is used, then equally spaced knots will be created; if &quot;Q&quot; is used, then a vector of equal quantiles will be created with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> is a positive integer <code class="reqn">&gt; 4</code>. Otherwise it is of the order <code class="reqn">n^{1/3}</code>. The default is space = c(&quot;E&quot;, &quot;E&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.conc.conc&quot; returns the vectors &quot;x1&quot; and &quot;x2&quot;, and imposes on each vector six attributes: name, shape, numknots, knots, space and cvs.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.conc.conc&quot;; the shape attribute is &quot;tri_cvs&quot;(doubly-concave); the cvs values for both vectors are FALSE. According to the value of the vector itself and its shape, numknots, knots, space and cvs attributes, the cone edges will be made by triangle spline basis functions in Meyer (2017). The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;s.conc.conc&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called trispl.fit
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vectors <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. Each of them has six attributes, i.e., name: names of <code class="reqn">x_1</code> and <code class="reqn">x_2</code>; shape: &quot;tri_cvs&quot;(doubly-concave); numknots: the numknots argument in &quot;s.conc.conc&quot;; knots: the knots argument in &quot;s.conc.conc&quot;; space: the space argument in &quot;s.conc.conc&quot;; cvs: two logical values indicating the monotonicity of the isotonically-constrained surface with respect to <code class="reqn">x_1</code> and <code class="reqn">x_2</code>, which are both FALSE.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2017) Estimation and inference for regression surfaces using shape-constrained splines.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s.conv.conv">s.conv.conv</a></code>, <code><a href="#topic+cgam">cgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# generate data
	n &lt;- 200
	set.seed(123)
	x1 &lt;- runif(n); x2 &lt;- runif(n)
	y &lt;- -(x1 - 1)^2 - (x2 - 3)^2 + rnorm(n)
   
    # regress y on x1 and x2 under the shape-restriction: "doubly-concave" 
    ans &lt;- cgam(y ~ s.conc.conc(x1, x2), nsim = 0)
    # make a 3D plot of the constrained surface
    plotpersp(ans)
</code></pre>

<hr>
<h2 id='s.conv'>Specify a Smooth and Convex Shape-Restriction in a CGAM Formula</h2><span id='topic+s.conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is smooth and convex in a predictor in a formula argument to cgam. This is the smooth version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.conv(x, numknots = 0, knots = 0, space = "Q")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.conv_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.conv_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to constrain <code class="reqn">x</code>. It will not be used if the user specifies the <em>knots</em> argument. The default is numknots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.conv_+3A_knots">knots</code></td>
<td>
<p>The knots used to constrain <code class="reqn">x</code>. User-defined knots will be used when given. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.conv_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used if the user specifies the <em>knots</em> argument. If space == &quot;E&quot;, then equally spaced knots will be created; if space == &quot;Q&quot;, then a vector of equal <code class="reqn">x</code> quantiles will be created based on <code class="reqn">x</code> with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> <code class="reqn">&gt; 0</code>. Otherwise it is of the order <code class="reqn">n^{1/7}</code>. The default is space = &quot;Q&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.conv&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.conv&quot;; the shape attribute is 11(&quot;smooth and convex&quot;). According to the value of the vector itself and its shape, numknots, knots and space attributes, the cone edges will be made by C-spline basis functions in Meyer (2008). The cone edges are a set of basis employed in the hinge algorithm.
</p>
<p>Note that &quot;s.conv&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 11(&quot;smooth and convex&quot;); numknots: the numknots argument in &quot;s.conv&quot;; knots: the knots argument in &quot;s.conv&quot;; space: the space argument in &quot;s.conv&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013&ndash;1033.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conv">conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # generate y
  x &lt;- seq(-1, 2, by = 0.1)
  n &lt;- length(x)
  y &lt;- x^2 + rnorm(n, .3)

  # regress y on x under the shape-restriction: "smooth and convex"
  ans &lt;- cgam(y ~ s.conv(x))
  knots &lt;- ans$knots[[1]]

  # make a plot
  plot(x, y)
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "smooth and convex fit", col = 2, lty = 1)
  legend(1.6, -1, bty = "o", "knots", pch = "X")
  points(knots, 1:length(knots)*0+min(y), pch = "X")
</code></pre>

<hr>
<h2 id='s.conv.conv'>Specify a Doubly-convex Shape-Restriction in a CGAM Formula</h2><span id='topic+s.conv.conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that a surface is convex in two predictors in a formula argument to cgam.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.conv.conv(x1, x2, numknots = c(0, 0), knots = list(k1 = 0, k2 = 0), space = c("E", "E"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.conv.conv_+3A_x1">x1</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.conv.conv_+3A_x2">x2</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.conv.conv_+3A_numknots">numknots</code></td>
<td>
<p>A vector of the number of knots used to constrain <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. It will not be used if the user specifies the <em>knots</em> argument and each predictor is within the range of its knots. The default is numknots = c(0, 0).</p>
</td></tr>
<tr><td><code id="s.conv.conv_+3A_knots">knots</code></td>
<td>
<p>A list of two vectors of knots used to constrain <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. User-defined knots will be used if each predictor is within the range of its knots. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = list(k1 = 0, k2 = 0).</p>
</td></tr>
<tr><td><code id="s.conv.conv_+3A_space">space</code></td>
<td>
<p>A vector of the character specifying the method to create knots for <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. It will not be used if the user specifies the <em>knots</em> argument. If &quot;E&quot; is used, then equally spaced knots will be created; if &quot;Q&quot; is used, then a vector of equal quantiles will be created with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> is a positive integer <code class="reqn">&gt; 4</code>. Otherwise it is of the order <code class="reqn">n^{1/3}</code>. The default is space = c(&quot;E&quot;, &quot;E&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.conv.conv&quot; returns the vectors &quot;x1&quot; and &quot;x2&quot;, and imposes on each vector six attributes: name, shape, numknots, knots, space and cvs.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.conv.conv&quot;; the shape attribute is &quot;tri_cvs&quot;(doubly-convex); the cvs values for both vectors are TRUE. According to the value of the vector itself and its shape, numknots, knots, space and cvs attributes, the cone edges will be made by triangle spline basis functions in Meyer (2017). The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;s.conv.conv&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called trispl.fit
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vectors <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. Each of them has six attributes, i.e., name: names of <code class="reqn">x_1</code> and <code class="reqn">x_2</code>; shape: &quot;tri_cvs&quot;(doubly-convex); numknots: the numknots argument in &quot;s.conv.conv&quot;; knots: the knots argument in &quot;s.conv.conv&quot;; space: the space argument in &quot;s.conv.conv&quot;; cvs: two logical values indicating the monotonicity of the isotonically-constrained surface with respect to <code class="reqn">x_1</code> and <code class="reqn">x_2</code>, which are both TRUE.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2017) Estimation and inference for regression surfaces using shape-constrained splines.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s.conv.conv">s.conv.conv</a></code>, <code><a href="#topic+cgam">cgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# generate data
	n &lt;- 200
	set.seed(123)
	x1 &lt;- runif(n); x2 &lt;- runif(n)
	y &lt;- (x1 - 1)^2 + (x2 - 3)^2 + rnorm(n)
    
    # regress y on x1 and x2 under the shape-restriction: "doubly-convex" 
    ans &lt;- cgam(y ~ s.conv.conv(x1, x2), nsim = 0)
    # make a 3D plot of the constrained surface
    plotpersp(ans)
</code></pre>

<hr>
<h2 id='s.decr'>Specify a Smooth and Decreasing Shape-Restriction in a CGAM Formula</h2><span id='topic+s.decr'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is smooth and decreasing in a predictor in a formula argument to cgam. This is the smooth version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.decr(x, numknots = 0, knots = 0, var.knots = 0, space = "Q", db.exp = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.decr_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.decr_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to constrain <code class="reqn">x</code>. It will not be used if the user specifies the <em>knots</em> argument. The default is numknots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.decr_+3A_knots">knots</code></td>
<td>
<p>The knots used to constrain <code class="reqn">x</code>. User-defined knots will be used when given. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.decr_+3A_var.knots">var.knots</code></td>
<td>
<p>The knots used in variance function estimation. User-defined knots will be used when given. The default is var.knots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.decr_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used if the user specifies the <em>knots</em> argument. If space == &quot;E&quot;, then equally spaced knots will be created; if space == &quot;Q&quot;, then a vector of equal <code class="reqn">x</code> quantiles will be created based on <code class="reqn">x</code> with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> <code class="reqn">&gt; 0</code>. Otherwise it is of the order <code class="reqn">n^{1/7}</code>. The default is space = &quot;Q&quot;.</p>
</td></tr>
<tr><td><code id="s.decr_+3A_db.exp">db.exp</code></td>
<td>
<p>The parameter will be used in variance function estimation. If db.exp = TRUE, then the errors are assumed to follow a normal distribution; otherwise, the errors are assumed to follow a double-exponential distribution. The default is db.exp = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.decr&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots, space, var.knots and db.exp.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.decr&quot;; the shape attribute is 10(&quot;smooth and decreasing&quot;). According to the value of the vector itself and its shape, numknots, knots and space attributes, the cone edges will be made by I-spline basis functions in Meyer (2008). The cone edges are a set of basis employed in the hinge algorithm.
</p>
<p>Note that &quot;s.decr&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>var.knots and db.exp will be used for monotonic variance function estimation.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e, name: the name of x; shape: 10(&quot;smooth and decreasing&quot;); numknots: the numknots argument in &quot;s.decr&quot;; knots: the knots argument in &quot;s.decr&quot;; space: the space argument in &quot;s.decr&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013&ndash;1033.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decr">decr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- - cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x under the shape-restriction: "smooth and decreasing"
  ans &lt;- cgam(y ~ s.decr(x))
  knots &lt;- ans$knots[[1]]

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "smooth and decreasing fit", col = 2, lty = 1)
  legend(-.3, 8, bty = "o", "knots", pch = "X")
  points(knots, 1:length(knots)*0+min(y), pch = "X")
</code></pre>

<hr>
<h2 id='s.decr.conc'>Specify a Smooth, Decreasing and Concave Shape-Restriction in a CGAM Formula</h2><span id='topic+s.decr.conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is smooth, decreasing and concave in a predictor in a formula argument to cgam. This is the smooth version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.decr.conc(x, numknots = 0, knots = 0, space = "Q")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.decr.conc_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.decr.conc_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to constrain <code class="reqn">x</code>. It will not be used if the user specifies the <em>knots</em> argument. The default is numknots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.decr.conc_+3A_knots">knots</code></td>
<td>
<p>The knots used to constrain <code class="reqn">x</code>. User defined knots will be used when given. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.decr.conc_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used if the user specifies the <em>knots</em> argument. If space == &quot;E&quot;, then equally spaced knots will be created; if space == &quot;Q&quot;, then a vector of equal <code class="reqn">x</code> quantiles will be created based on <code class="reqn">x</code> with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> <code class="reqn">&gt; 0</code>. Otherwise it is of the order <code class="reqn">n^{1/7}</code>. The default is space = &quot;Q&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.decr.conc&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.decr.conc&quot;; the shape attribute is 16(&quot;smooth, decreasing and concave&quot;). According to the value of the vector itself and its shape, numknots, knots and space attributes, the cone edges will be made by C-spline basis functions in Meyer (2008). The cone edges are a set of basis employed in the hinge algorithm.
</p>
<p>Note that &quot;s.decr.conc&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 16(&quot;smooth, decreasing and concave&quot;); numknots: the numknots argument in &quot;s.decr.conc&quot;; knots: the knots argument in &quot;s.decr.conc&quot;; space: the space argument in &quot;s.decr.conc&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013&ndash;1033.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decr.conv">decr.conv</a></code>, <code><a href="#topic+decr">decr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;-  cubic$x

  # extract y
  y &lt;- - cubic$y

  # regress y on x under the shape-restriction: "smooth, decreasing and concave"
  ans &lt;- cgam(y ~ s.decr.conc(x))
  knots &lt;- ans$knots[[1]]

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "smooth, decreasing and concave fit", col = 2, lty = 1)
  legend(1.7, 4, bty = "o", "knots", pch = "X")
  points(knots, 1:length(knots)*0+min(y), pch = "X")
</code></pre>

<hr>
<h2 id='s.decr.conv'>Specify a Smooth, Decreasing and Convex Shape-Restriction in a CGAM Formula</h2><span id='topic+s.decr.conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is smooth, decreasing and convex in a predictor in a formula argument to cgam. This is the smooth version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.decr.conv(x, numknots = 0, knots = 0, space = "Q")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.decr.conv_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.decr.conv_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to constrain <code class="reqn">x</code>. It will not be used if the user specifies the <em>knots</em> argument. The default is numknots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.decr.conv_+3A_knots">knots</code></td>
<td>
<p>The knots used to constrain <code class="reqn">x</code>. User-defined knots will be used when given. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.decr.conv_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used if the user specifies the <em>knots</em> argument. If space == &quot;E&quot;, then equally spaced knots will be created; if space == &quot;Q&quot;, then a vector of equal <code class="reqn">x</code> quantiles will be created based on <code class="reqn">x</code> with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> <code class="reqn">&gt; 0</code>. Otherwise it is of the order <code class="reqn">n^{1/7}</code>. The default is space = &quot;Q&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.decr.conv&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.decr.conv&quot;; the shape attribute is 15(&quot;smooth, decreasing and convex&quot;). According to the value of the vector itself and its shape, numknots, knots and space attributes, the cone edges will be made by C-spline basis functions in Meyer (2008). The cone edges are a set of basis employed in the hinge algorithm.
</p>
<p>Note that &quot;s.decr.conv&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 15(&quot;smooth, decreasing and convex&quot;); numknots: the numknots argument in &quot;s.decr.conv&quot;; knots: the knots argument in &quot;s.decr.conv&quot;; space: the space argument in &quot;s.decr.conv&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013&ndash;1033.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decr.conv">decr.conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- - cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x under the shape-restriction: "smooth, decreasing and convex"
  ans &lt;- cgam(y ~ s.decr.conv(x))
  knots &lt;- ans$knots[[1]]

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "smooth, decreasing and convex fit", col = 2, lty = 1)
  legend(-.3, 9.2, bty = "o", "knots", pch = "X")
  points(knots, 1:length(knots)*0+min(y), pch = "X")
</code></pre>

<hr>
<h2 id='s.decr.decr'>Specify a Doubly-Decreasing Shape-Restriction in a CGAM Formula</h2><span id='topic+s.decr.decr'></span>

<h3>Description</h3>

<p>A symbolic routine to define that a surface is decreasing in two predictors in a formula argument to cgam.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.decr.decr(x1, x2, numknots = c(0, 0), knots = list(k1 = 0, k2 = 0), space = c("E", "E"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.decr.decr_+3A_x1">x1</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.decr.decr_+3A_x2">x2</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.decr.decr_+3A_numknots">numknots</code></td>
<td>
<p>A vector of the number of knots used to constrain <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. It will not be used if the user specifies the <em>knots</em> argument and each predictor is within the range of its knots. The default is numknots = c(0, 0).</p>
</td></tr>
<tr><td><code id="s.decr.decr_+3A_knots">knots</code></td>
<td>
<p>A list of two vectors of knots used to constrain <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. User-defined knots will be used if each predictor is within the range of its knots. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = list(k1 = 0, k2 = 0).</p>
</td></tr>
<tr><td><code id="s.decr.decr_+3A_space">space</code></td>
<td>
<p>A vector of the character specifying the method to create knots for <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. It will not be used if the user specifies the <em>knots</em> argument. If &quot;E&quot; is used, then equally spaced knots will be created; if &quot;Q&quot; is used, then a vector of equal quantiles will be created with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> is a positive integer <code class="reqn">&gt; 4</code>. Otherwise it is of the order <code class="reqn">n^{1/6}</code>. The default is space = c(&quot;E&quot;, &quot;E&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.decr.decr&quot; returns the vectors &quot;x1&quot; and &quot;x2&quot;, and imposes on each vector six attributes: name, shape, numknots, knots, space and decreasing.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.decr.decr&quot;; the shape attribute is &quot;wps_dd&quot;(doubly-decreasing); the decreasing values for both vectors are TRUE. According to the value of the vector itself and its shape, numknots, knots, space and decreasing attributes, the cone edges will be made by warped-plane spline basis functions in Meyer (2016). The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;s.decr.decr&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta_wps.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vectors <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. Each of them has six attributes, i.e., name: names of <code class="reqn">x_1</code> and <code class="reqn">x_2</code>; shape: &quot;wps_dd&quot;(doubly-decreasing); numknots: the numknots argument in &quot;s.decr.decr&quot;; knots: the knots argument in &quot;s.decr.decr&quot;; space: the space argument in &quot;s.decr.decr&quot;; decreasing: two logical values indicating the monotonicity of the isotonically-constrained surface with respect to <code class="reqn">x_1</code> and <code class="reqn">x_2</code>, which are both TRUE.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2017) Estimation and inference for regression surfaces using shape-constrained splines.</p>


<h3>See Also</h3>

<p><code><a href="#topic+s.incr.incr">s.incr.incr</a></code>, <code><a href="#topic+s.decr.incr">s.decr.incr</a></code>, <code><a href="#topic+s.incr.decr">s.incr.decr</a></code>, <code><a href="#topic+cgam">cgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # generate data
  n &lt;- 100
  set.seed(123)
  x1 &lt;- runif(n)
  x2 &lt;- runif(n)
  y &lt;- -4 * (x1 + x2 - x1 * x2) + rnorm(n, sd = .2)

  # regress y on x1 and x2 under the shape-restriction: "doubly-decreasing" 
  # using the penalized estimator
  ans &lt;- cgam(y ~ s.decr.decr(x1, x2), pnt = TRUE)

  # make a 3D plot of the constrained surface
  plotpersp(ans)	

## End(Not run)
</code></pre>

<hr>
<h2 id='s.decr.incr'>Specify a Decreasing-Increasing Shape-Restriction in a CGAM Formula</h2><span id='topic+s.decr.incr'></span>

<h3>Description</h3>

<p>A symbolic routine to define that a surface is decreasing in one predictor and increasing in another in a formula argument to cgam.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.decr.incr(x1, x2, numknots = c(0, 0), knots = list(k1 = 0, k2 = 0), space = c("E", "E"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.decr.incr_+3A_x1">x1</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.decr.incr_+3A_x2">x2</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.decr.incr_+3A_numknots">numknots</code></td>
<td>
<p>A vector of the number of knots used to constrain <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. It will not be used if the user specifies the <em>knots</em> argument and each predictor is within the range of its knots. The default is numknots = c(0, 0).</p>
</td></tr>
<tr><td><code id="s.decr.incr_+3A_knots">knots</code></td>
<td>
<p>A list of two vectors of knots used to constrain <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. User-defined knots will be used if each predictor is within the range of its knots. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = list(k1 = 0, k2 = 0).</p>
</td></tr>
<tr><td><code id="s.decr.incr_+3A_space">space</code></td>
<td>
<p>A vector of the character specifying the method to create knots for <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. It will not be used if the user specifies the <em>knots</em> argument. If &quot;E&quot; is used, then equally spaced knots will be created; if &quot;Q&quot; is used, then a vector of equal quantiles will be created with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> is a positive integer <code class="reqn">&gt; 4</code>. Otherwise it is of the order <code class="reqn">n^{1/6}</code>. The default is space = c(&quot;E&quot;, &quot;E&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.decr.incr&quot; returns the vectors &quot;x1&quot; and &quot;x2&quot;, and imposes on each vector six attributes: name, shape, numknots, knots, space and decreasing.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.decr.incr&quot;; the shape attribute is &quot;wps_di&quot;(decreasing-increasing); the decreasing values for &quot;x1&quot; and &quot;x2&quot; are TRUE and FALSE. According to the value of the vector itself and its shape, numknots, knots, space and decreasing attributes, the cone edges will be made by warped-plane spline basis functions in Meyer (2016). The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;s.decr.incr&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta_wps.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vectors <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. Each of them has six attributes, i.e., name: names of <code class="reqn">x_1</code> and <code class="reqn">x_2</code>; shape: &quot;wps_di&quot;(decreasing-increasing); numknots: the numknots argument in &quot;s.decr.incr&quot;; knots: the knots argument in &quot;s.decr.incr&quot;; space: the space argument in &quot;s.decr.incr&quot;; decreasing: two logical values indicating the monotonicity of the isotonically-constrained surface with respect to <code class="reqn">x_1</code> and <code class="reqn">x_2</code>, which are TRUE and FALSE.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2017) Estimation and inference for regression surfaces using shape-constrained splines.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s.incr.incr">s.incr.incr</a></code>, <code><a href="#topic+s.incr.decr">s.incr.decr</a></code>, <code><a href="#topic+s.decr.decr">s.decr.decr</a></code>, <code><a href="#topic+cgam">cgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # generate data
  n &lt;- 100
  set.seed(123)
  x1 &lt;- runif(n)
  x2 &lt;- runif(n)
  y &lt;- 4 * (x2 - x1) - x1 * x2 + rnorm(n, sd = .2)

  # regress y on x1 and x2 under the shape-restriction: "decreasing-increasing"
  # using the penalized estimator
  ans &lt;- cgam(y ~ s.decr.incr(x1, x2), pnt = TRUE)

  # make a 3D plot of the constrained surface
  plotpersp(ans)

## End(Not run)
</code></pre>

<hr>
<h2 id='s.incr'>Specify a Smooth and Increasing Shape-Restriction in a CGAM Formula</h2><span id='topic+s.incr'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is smooth and increasing in a predictor in a formula argument to cgam. This is the smooth version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.incr(x, numknots = 0, knots = 0, var.knots = 0, space = "Q", db.exp = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.incr_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.incr_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to constrain <code class="reqn">x</code>. It will not be used if the user specifies the <em>knots</em> argument. The default is numknots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.incr_+3A_knots">knots</code></td>
<td>
<p>The knots used to constrain <code class="reqn">x</code>. User-defined knots will be used when given. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.incr_+3A_var.knots">var.knots</code></td>
<td>
<p>The knots used in variance function estimation. User-defined knots will be used when given. The default is var.knots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.incr_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used if the user specifies the <em>knots</em> argument. If space == &quot;E&quot;, then equally spaced knots will be created; if space == &quot;Q&quot;, then a vector of equal <code class="reqn">x</code> quantiles will be created based on <code class="reqn">x</code> with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> <code class="reqn">&gt; 0</code>. Otherwise it is of the order <code class="reqn">n^{1/7}</code>. The default is space = &quot;Q&quot;.</p>
</td></tr>
<tr><td><code id="s.incr_+3A_db.exp">db.exp</code></td>
<td>
<p>The parameter will be used in variance function estimation. If db.exp = TRUE, then the errors are assumed to follow a normal distribution; otherwise, the errors are assumed to follow a double-exponential distribution. The default is db.exp = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.incr&quot; returns the vector &quot;x&quot; and imposes on it seven attributes: name, shape, numknots, knots, space, var.knots and db.exp.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.incr&quot;; the shape attribute is 9(&quot;smooth and increasing&quot;). According to the value of the vector itself and its shape, numknots, knots and space attributes, the cone edges will be made by I-spline basis functions in Meyer (2008). The cone edges are a set of basis employed in the hinge algorithm.
</p>
<p>Note that &quot;s.incr&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>var.knots and db.exp will be used for monotonic variance function estimation.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 9(&quot;smooth and increasing&quot;); numknots: the numknots argument in &quot;s.incr&quot;; knots: the knots argument in &quot;s.incr&quot;; space: the space argument in &quot;s.incr&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013&ndash;1033.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incr">incr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x with the shape restriction: "smooth and increasing"
  ans &lt;- cgam(y ~ s.incr(x))
  knots &lt;- ans$knots[[1]]

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "smooth and increasing fit", col = 2, lty = 1)
  legend(1.7, 9.2, bty = "o", "knots", pch = "X")
  points(knots, 1:length(knots)*0+min(y), pch = "X")
</code></pre>

<hr>
<h2 id='s.incr.conc'>Specify a Smooth, Increasing and Concave Shape-Restriction in a CGAM Formula</h2><span id='topic+s.incr.conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is smooth, increasing and concave in a predictor in a formula argument to cgam. This is the smooth version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.incr.conc(x, numknots = 0, knots = 0, space = "Q")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.incr.conc_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.incr.conc_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to constrain <code class="reqn">x</code>. It will not be used if the user specifies the <em>knots</em> argument. The default is numknots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.incr.conc_+3A_knots">knots</code></td>
<td>
<p>The knots used to constrain <code class="reqn">x</code>. User-defined knots will be used when given. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.incr.conc_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used if the user specifies the <em>knots</em> argument. If space == &quot;E&quot;, then equally spaced knots will be created; if space == &quot;Q&quot;, then a vector of equal <code class="reqn">x</code> quantiles will be created based on <code class="reqn">x</code> with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> <code class="reqn">&gt; 0</code>. Otherwise it is of the order <code class="reqn">n^{1/7}</code>. The default is space = &quot;Q&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.incr.conc&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.incr.conc&quot;; the shape attribute is 14(&quot;smooth, increasing and concave&quot;). According to the value of the vector itself and its shape, numknots, knots and space attributes, the cone edges will be made by C-spline basis functions in Meyer (2008). The cone edges are a set of basis employed in the hinge algorithm.
</p>
<p>Note that &quot;s.incr.conc&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 14(&quot;smooth, increasing and concave&quot;); numknots: the numknots argument in &quot;s.incr.conc&quot;; knots: the knots argument in &quot;s.incr.conc&quot;; space: the space argument in &quot;s.incr.conc&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013&ndash;1033.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incr.conv">incr.conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- - cubic$x

  # extract y
  y &lt;- - cubic$y

  # regress y on x with the shape restriction: "smooth, increasing and concave"
  ans &lt;- cgam(y ~ s.incr.conc(x))
  knots &lt;- ans$knots[[1]]

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "smooth, increasing and concave fit", col = 2, lty = 1)
  legend(-.3, 4, bty = "o", "knots", pch = "X")
  points(knots, 1:length(knots)*0+min(y), pch = "X")
</code></pre>

<hr>
<h2 id='s.incr.conv'>Specify an Smooth, Increasing and Convex Shape-Restriction in a CGAM Formula</h2><span id='topic+s.incr.conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is smooth, increasing and convex in a predictor in a formula argument to cgam. This is the smooth version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.incr.conv(x, numknots = 0, knots = 0, space = "Q")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.incr.conv_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.incr.conv_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to constrain <code class="reqn">x</code>. It will not be used if the user specifies the <em>knots</em> argument. The default is numknots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.incr.conv_+3A_knots">knots</code></td>
<td>
<p>The knots used to constrain <code class="reqn">x</code>. User-defined knots will be used when given. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="s.incr.conv_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used if the user specifies the <em>knots</em> argument. If space == &quot;E&quot;, then equally spaced knots will be created; if space == &quot;Q&quot;, then a vector of equal <code class="reqn">x</code> quantiles will be created based on <code class="reqn">x</code> with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> <code class="reqn">&gt; 0</code>. Otherwise it is of the order <code class="reqn">n^{1/7}</code>. The default is space = &quot;Q&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.incr.conv&quot; returns the vector &quot;x&quot; and imposes on it five attributes: name, shape, numknots, knots and space.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.incr.conv&quot;; the shape attribute is 13(&quot;smooth, increasing and convex&quot;). According to the value of the vector itself and its shape, numknots, knots and space attributes, the cone edges will be made by C-spline basis functions in Meyer (2008). The cone edges are a set of basis employed in the hinge algorithm.
</p>
<p>Note that &quot;s.incr.conv&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in cgam.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 13(&quot;smooth, increasing and convex&quot;); numknots: the numknots argument in &quot;s.incr.conv&quot;; knots: the knots argument in &quot;s.incr.conv&quot;; space: the space argument in &quot;s.incr.conv&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013&ndash;1033.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incr.conv">incr.conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x with the shape restriction: "smooth, increasing and convex"
  ans &lt;- cgam(y ~ s.incr.conv(x))
  knots &lt;- ans$knots[[1]]

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, ans$muhat, col = 2)
  legend("topleft", bty = "n", "smooth, increasing and convex fit", col = 2, lty = 1)
  legend(1.7, 9.2, bty = "o", "knots", pch = "X")
  points(knots, 1:length(knots)*0+min(y), pch = "X")
</code></pre>

<hr>
<h2 id='s.incr.decr'>Specify an Increasing-Decreasing Shape-Restriction in a CGAM Formula</h2><span id='topic+s.incr.decr'></span>

<h3>Description</h3>

<p>A symbolic routine to define that a surface is decreasing in one predictor and increasing in another in a formula argument to cgam.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.incr.decr(x1, x2, numknots = c(0, 0), knots = list(k1 = 0, k2 = 0), space = c("E", "E"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.incr.decr_+3A_x1">x1</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.incr.decr_+3A_x2">x2</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.incr.decr_+3A_numknots">numknots</code></td>
<td>
<p>A vector of the number of knots used to constrain <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. It will not be used if the user specifies the <em>knots</em> argument and each predictor is within the range of its knots. The default is numknots = c(0, 0).</p>
</td></tr>
<tr><td><code id="s.incr.decr_+3A_knots">knots</code></td>
<td>
<p>A list of two vectors of knots used to constrain <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. User-defined knots will be used if each predictor is within the range of its knots. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = list(k1 = 0, k2 = 0).</p>
</td></tr>
<tr><td><code id="s.incr.decr_+3A_space">space</code></td>
<td>
<p>A vector of the character specifying the method to create knots for <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. It will not be used if the user specifies the <em>knots</em> argument. If &quot;E&quot; is used, then equally spaced knots will be created; if &quot;Q&quot; is used, then a vector of equal quantiles will be created with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> is a positive integer <code class="reqn">&gt; 4</code>. Otherwise it is of the order <code class="reqn">n^{1/6}</code>. The default is space = c(&quot;E&quot;, &quot;E&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.incr.decr&quot; returns the vectors &quot;x1&quot; and &quot;x2&quot;, and imposes on each vector six attributes: name, shape, numknots, knots, space and decreasing.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.incr.decr&quot;; the shape attribute is &quot;wps_id&quot;(increasing-decreasing); the decreasing values for &quot;x1&quot; and &quot;x2&quot; are TRUE and FALSE. According to the value of the vector itself and its shape, numknots, knots, space and decreasing attributes, the cone edges will be made by warped-plane spline basis functions in Meyer (2016). The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;s.incr.decr&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta_wps.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vectors <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. Each of them has six attributes, i.e., name: names of <code class="reqn">x_1</code> and <code class="reqn">x_2</code>; shape: &quot;wps_id&quot;(increasing-decreasing); numknots: the numknots argument in &quot;s.incr.decr&quot;; knots: the knots argument in &quot;s.incr.decr&quot;; space: the space argument in &quot;s.incr.decr&quot;; decreasing: two logical values indicating the monotonicity of the isotonically-constrained surface with respect to <code class="reqn">x_1</code> and <code class="reqn">x_2</code>, which are FALSE and TRUE.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2017) Estimation and inference for regression surfaces using shape-constrained splines.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s.incr.incr">s.incr.incr</a></code>, <code><a href="#topic+s.decr.decr">s.decr.decr</a></code>, <code><a href="#topic+s.decr.incr">s.decr.incr</a></code>, <code><a href="#topic+cgam">cgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # generate data
  n &lt;- 100
  set.seed(123)
  x1 &lt;- runif(n)
  x2 &lt;- runif(n)
  y &lt;- 4 * (x1 - x2) - x1 * x2 + rnorm(n, sd = .2)

  # regress y on x1 and x2 under the shape-restriction: "increasing-decreasing"
  # using the penalized estimator
  ans &lt;- cgam(y ~ s.incr.decr(x1, x2), pnt = TRUE)

  # make a 3D plot of the constrained surface
  plotpersp(ans)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='s.incr.incr'>Specify a Doubly-Increasing Shape-Restriction in a CGAM Formula</h2><span id='topic+s.incr.incr'></span>

<h3>Description</h3>

<p>A symbolic routine to define that a surface is increasing in two predictors in a formula argument to cgam.</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.incr.incr(x1, x2, numknots = c(0, 0), knots = list(k1 = 0, k2 = 0), space = c("E", "E"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.incr.incr_+3A_x1">x1</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.incr.incr_+3A_x2">x2</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="s.incr.incr_+3A_numknots">numknots</code></td>
<td>
<p>A vector of the number of knots used to constrain <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. It will not be used if the user specifies the <em>knots</em> argument and each predictor is within the range of its knots. The default is numknots = c(0, 0).</p>
</td></tr>
<tr><td><code id="s.incr.incr_+3A_knots">knots</code></td>
<td>
<p>A list of two vectors of knots used to constrain <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. User-defined knots will be used if each predictor is within the range of its knots. Otherwise, <em>numknots</em> and <em>space</em> will be used to create knots. The default is knots = list(k1 = 0, k2 = 0).</p>
</td></tr>
<tr><td><code id="s.incr.incr_+3A_space">space</code></td>
<td>
<p>A vector of the character specifying the method to create knots for <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. It will not be used if the user specifies the <em>knots</em> argument. If &quot;E&quot; is used, then equally spaced knots will be created; if &quot;Q&quot; is used, then a vector of equal quantiles will be created with duplicate elements removed. The number of knots is <em>numknots</em> when <em>numknots</em> is a positive integer <code class="reqn">&gt; 4</code>. Otherwise it is of the order <code class="reqn">n^{1/6}</code>. The default is space = c(&quot;E&quot;, &quot;E&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;s.incr.incr&quot; returns the vectors &quot;x1&quot; and &quot;x2&quot;, and imposes on each vector six attributes: name, shape, numknots, knots, space and decreasing.
</p>
<p>The name attribute is used in the subroutine plotpersp; the numknots, knots and space attributes are the same as the numknots, knots and space arguments in &quot;s.incr.incr&quot;; the shape attribute is &quot;wps_ii&quot;(doubly-increasing); the decreasing values for both vectors are FALSE. According to the value of the vector itself and its shape, numknots, knots, space and decreasing attributes, the cone edges will be made by warped-plane spline basis functions in Meyer (2016). The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;s.incr.incr&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta_wps.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vectors <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. Each of them has six attributes, i.e., name: names of <code class="reqn">x_1</code> and <code class="reqn">x_2</code>; shape: &quot;wps_ii&quot;(doubly-increasing); numknots: the numknots argument in &quot;s.incr.incr&quot;; knots: the knots argument in &quot;s.incr.incr&quot;; space: the space argument in &quot;s.incr.incr&quot;; decreasing: two logical values indicating the monotonicity of the isotonically-constrained surface with respect to <code class="reqn">x_1</code> and <code class="reqn">x_2</code>, which are both FALSE.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2017) Estimation and inference for regression surfaces using shape-constrained splines.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s.decr.decr">s.decr.decr</a></code>, <code><a href="#topic+s.decr.incr">s.decr.incr</a></code>, <code><a href="#topic+cgam">cgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # generate data
  n &lt;- 100
  set.seed(123)
  x1 &lt;- runif(n)
  x2 &lt;- runif(n)
  y &lt;- 4 * (x1 + x2 - x1 * x2) + rnorm(n, sd = .2)

  # regress y on x1 and x2 under the shape-restriction: "doubly-increasing" 
  # using the penalized estimator
  ans &lt;- cgam(y ~ s.incr.incr(x1, x2), pnt = TRUE)

  # make a 3D plot of the constrained surface
  plotpersp(ans)

## End(Not run)
</code></pre>

<hr>
<h2 id='shapes'>To Include a Non-Parametrically Modelled Predictor in a SHAPESELECT Formula</h2><span id='topic+shapes'></span>

<h3>Description</h3>

<p>A symbolic routine to indicate that a predictor is included as a non-parametrically modelled predictor in a formula argument to ShapeSelect.</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapes(x, set = "s.9")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shapes_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="shapes_+3A_set">set</code></td>
<td>
<p>A character or a numeric vector indicating all possible shapes defined for x. For example, we are not only interested in modeling the relationship between the growth of an organism (dependent variable <code class="reqn">y</code>) and time (independent variable <code class="reqn">x</code>), but we are also interested in the shape of the growth curve. Suppose we know <em>a priori</em> that the shape could be flat, increasing, increasing concave, or increasing convex, and we further know that the curve is smooth, we can write y ~ shapes(x, set = c(&quot;flat&quot;, &quot;s.incr&quot;, &quot;s.incr.conc&quot;, &quot;s.incr.conv&quot;)) in a formula to impose the four possible shape constraints on the growth curve and model it with splines. 
</p>
<p>To be more specific, the user can choose to specify this argument as following
</p>

<ul>
<li><p>1. It could be written as &quot;s.5&quot;, &quot;s.9&quot;, &quot;ord.5&quot;, &quot;ord.9&quot;, and &quot;tree&quot;, where &quot;s.5&quot; (&quot;ord.5&quot;) means that the relationship between the response and a predictor <code class="reqn">x</code> is modelled with regression splines (ordinal regression basis functions) with five possible shapes, i.e., flat, increasing, decreasing, convex, and concave; &quot;s.9&quot; (&quot;ord.9&quot;) includes four more possible shapes, which are the combination of monotonicity and convexity; &quot;tree&quot; specifies that <code class="reqn">x</code> is included as an ordinal predictor with three possibilities: no effect, tree-ordering, and unordered effect.
</p>
</li>
<li><p>2. Or the user can choose any subset of the possible shapes, i.e., flat, increasing, decreasing, convex, concave, and combination of monotonicity and convexity. The symbols are  &quot;flat&quot;, &quot;incr&quot;, &quot;decr&quot;, &quot;conv&quot;, &quot;conc&quot;, &quot;incr.conv&quot;, &quot;decr.conv&quot;, &quot;incr.conc&quot;, and &quot;decr.conc&quot;. To specify a spline-based regression, the user needs write something like &quot;s.incr&quot;, &quot;s.decr&quot;, etc.
</p>
</li>
<li><p>3. It can also be a subset of integers between 0 and 16, where 0 is the flat shape, 1 ~ 8 indicate increasing, decreasing, convex, concave, increasing-convex, decreasing-convex, increasing-concave, and decreasing-concave, while 9 ~ 16 indicate the same shapes with a smooth assumption.
</p>
</li></ul>

</td></tr>
</table>
<p>The default is set = &quot;s.9&quot;.
</p>


<h3>Value</h3>

<p>The vector x with three attributes, i.e., nm: the name of x; shape: a numeric vector ranging from 0 to 16 to indicate possible shapes imposed on the relationship between the response and x; type: &quot;nparam&quot;, i.e., x is non-parametrically modelled.</p>


<h3>Author(s)</h3>

<p>Xiyue Liao</p>


<h3>See Also</h3>

<p><code><a href="#topic+in.or.out">in.or.out</a></code>, <code><a href="#topic+ShapeSelect">ShapeSelect</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example 1.
  n &lt;- 100 
   
  # generate predictors, x is non-parametrically modelled 
  # and z is parametrically modelled
  x &lt;- runif(n)
  z &lt;- rep(0:1, 50)
  
  # E(y) is generated as correlated to both x and z
  # the relationship between E(y) and x is smoothly increasing-convex
  y &lt;- x^2 + 2 * I(z == 1) + rnorm(n, sd = 1)

  # call ShapeSelect to find the best model by the genetic algorithm
  fit &lt;- ShapeSelect(y ~ shapes(x) + in.or.out(factor(z)), genetic = TRUE)

# Example 2.
  n &lt;- 100
  z &lt;- rep(c("A","B"), n / 2)
  x &lt;- runif(n)

  # y0 is generated as correlated to z with a tree-ordering in it
  # y0 is smoothly increasing-convex in x
  y0 &lt;- x^2 + I(z == "B") * 1.5
  y &lt;- y0 + rnorm(n, 1)

  fit &lt;- ShapeSelect(y ~ s.incr(x) + shapes(z, set = "tree"), genetic = FALSE)
  
  # check the best fit in terms of z
  fit$top

## End(Not run)
</code></pre>

<hr>
<h2 id='ShapeSelect'>Variable and Shape Selection via Genetic Algorithm</h2><span id='topic+ShapeSelect'></span>

<h3>Description</h3>

<p>The partial linear generalized additive model is considered, where the goal is to choose a subset of predictor variables and describe the component relationships with the response, in the case where there is very little <em>a priori</em> information. For each predictor, the user need only specify a set of possible shape or order restrictions. A model selection method chooses the shapes and orderings of the relationships as well as the variables.  For each possible combination of shapes and orders for the predictors, the maximum likelihood estimator for the constrained generalized additive model is found using iteratively re-weighted cone projections.  The cone information criterion is used to select the best combination of variables and shapes.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShapeSelect(formula, family = gaussian, cpar = 2, data = NULL, weights = NULL, 
npop = 200, per.mutate = 0.05, genetic = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShapeSelect_+3A_formula">formula</code></td>
<td>

<p>A formula object which includes a set of predictors to be selected. It has the form &quot;response ~ predictor&quot;. The response is a vector of length <code class="reqn">n</code>. The specification of the model can be one of the three exponential families: gaussian, binomial and poisson. The systematic component <code class="reqn">\eta</code> is <code class="reqn">E(y)</code>, the log odds of <code class="reqn">y = 1</code>, and the logarithm of <code class="reqn">E(y)</code> respectively. The user is supposed to define at least one predictor in the formula, which could be a non-parametrically modelled variable or a parametrically modelled covariate (categorical or linear). Assume that <code class="reqn">\eta</code> is the systematic component and <code class="reqn">x</code> is a predictor, two symbolic routines <code><a href="#topic+shapes">shapes</a></code> and <code><a href="#topic+in.or.out">in.or.out</a></code> are used to include <code class="reqn">x</code> in the formula. 
</p>

<ul>
<li><p>shapes(x): <code class="reqn">x</code> is included as a non-parametrically modelled predictor in the formula. See <code><a href="#topic+shapes">shapes</a></code> for more details.
</p>
</li>
<li><p>in.or.out(x): <code class="reqn">x</code> is included as a categorical or linear predictor in the formula. See <code><a href="#topic+in.or.out">in.or.out</a></code> for more details.
</p>
</li></ul>

</td></tr>
<tr><td><code id="ShapeSelect_+3A_family">family</code></td>
<td>
<p>A parameter indicating the error distribution and link function to be used in the model. It can be a character string naming a family function or the result of a call to a family function. This is borrowed from the glm routine in the stats package. There are three families used in ShapeSelect: gaussian, binomial and poisson.</p>
</td></tr>
<tr><td><code id="ShapeSelect_+3A_cpar">cpar</code></td>
<td>
<p>A multiplier to estimate the model variance, which is defined as <code class="reqn">\sigma^2 = SSR / (n - d_0 - cpar * edf)</code>. SSR is the sum of squared residuals for the full model, <code class="reqn">d_0</code> is the dimension of the linear space in the cone, and edf is the effective degrees of freedom. The default is cpar = 2. See Meyer, M. C. and M. Woodroofe (2000) for more details.</p>
</td></tr>
<tr><td><code id="ShapeSelect_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment containing the variables in the model. The default is data = NULL.</p>
</td></tr>
<tr><td><code id="ShapeSelect_+3A_weights">weights</code></td>
<td>
<p>An optional non-negative vector of &quot;replicate weights&quot; which has the same length as the response vector. If weights are not given, all weights are taken to equal 1. The default is weights = NULL.</p>
</td></tr>
<tr><td><code id="ShapeSelect_+3A_npop">npop</code></td>
<td>
<p>The population size used for the genetic algorithm. The default is npop = 200.</p>
</td></tr>
<tr><td><code id="ShapeSelect_+3A_per.mutate">per.mutate</code></td>
<td>
<p>The percentage of mutation used for the genetic algorithm. The default is per.mutate = 0.05</p>
</td></tr>
<tr><td><code id="ShapeSelect_+3A_genetic">genetic</code></td>
<td>
<p>A logical scalar showing if or not the genetic algorithm is defined by the user to select the best model. The default is genetic = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that when the argument genetic is set to be FALSE, the routine will check to see if using the genetic algorithm is better than going through all models to find the best fit. The primary concern is running time. An interactive dialogue window may pop out to ask the user if they prefer to the genetic algorithm when it may take too long to do a brutal search, and if there are too many possible models to go through, like more than one million, the routine will implement the genetic algorithm anyway.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<table>
<tr><td><code>top</code></td>
<td>
<p>The best model of the final population, which shows the variables chosen along with their best shapes.</p>
</td></tr>
<tr><td><code>pop</code></td>
<td>
<p>The final population ordered by its fitness values. It is a data frame, and each row of this data frame shows the shapes chosen for predictors in an individual model. Besides, the fitness value for each individual model is included in the last column of the data frame. For example, we have two continuous predictors <code class="reqn">x_1</code>, <code class="reqn">x_2</code>, and a categorical predictor <code class="reqn">z</code>, then a row of this data frame may look like: &quot;flat&quot;, &quot;s.incr&quot;, &quot;in&quot;, <code class="reqn">-12.3806</code>, which means that <code class="reqn">x_1</code> is not chosen, <code class="reqn">x_2</code> is chosen with the shape constraint to be smoothly increasing, <code class="reqn">z</code> is included in the model, and the fitness value for the model is <code class="reqn">-12.3806</code>.</p>
</td></tr>
<tr><td><code>fitness</code></td>
<td>
<p>The sorted fitness values for the final population.</p>
</td></tr>
<tr><td><code>tm</code></td>
<td>
<p>Total cpu running time.</p>
</td></tr>
<tr><td><code>xnms</code></td>
<td>
<p>A vector storing the name of the nonparametrically-modelled predictor in a ShapeSelect formula.</p>
</td></tr>
<tr><td><code>znms</code></td>
<td>
<p>A vector storing the name of the parametrically-modelled predictor in a ShapeSelect formula, which is a categorical predictor or a linear term.</p>
</td></tr>
<tr><td><code>trnms</code></td>
<td>
<p>A vector storing the name of the treatment predictor in a ShapeSelect formula, which has three possible levels: no effect, tree ordering, unordered.</p>
</td></tr>
<tr><td><code>zfacs</code></td>
<td>
<p>A logical vector keeping track of if the parametrically-modelled predictor in a ShapeSelect formula is a categorical predictor or a linear term.</p>
</td></tr>
<tr><td><code>mxf</code></td>
<td>
<p>A vector keeping track of the largest fitness value in each generation.</p>
</td></tr>
<tr><td><code>mnf</code></td>
<td>
<p>A vector keeping track of the mean fitness value in each generation.</p>
</td></tr>
<tr><td><code>GA</code></td>
<td>
<p>A logical scalar showing if or not the genetic algorithm is actually implemented to select the best model.</p>
</td></tr>
<tr><td><code>best.fit</code></td>
<td>
<p>The best model fitted by the cgam routine, given the best variables with their shape constraints chosen by the ShapeSelect routine.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao</p>


<h3>References</h3>

<p>Meyer, M. C. (2013a) Semi-parametric additive constrained regression. <em>Journal of Nonparametric Statistics <b>25(3)</b></em>, 715
</p>
<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.  
</p>
<p>Meyer, M. C. and M. Woodroofe (2000) On the degrees of freedom in shape-restricted regression. <em>Annals of Statistics <b>28</b></em>, 1083&ndash;1104.
</p>
<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. <em>Annals of Applied Statistics <b>2(3)</b></em>, 1013&ndash;1033.
</p>
<p>Meyer, M. C. and Liao, X. (2016) Variable and shape selection for the generalized additive model. <em>under preparation</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cgam">cgam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example 1.
  library(MASS)
  data(Rubber)

  # ShapeSelect can be used to go through all models to find the best model
  fit &lt;- ShapeSelect(loss ~ shapes(hard, set = "s.9") + shapes(tens, set = "s.9"),
  data = Rubber, genetic = FALSE)
 
  # the user can also choose to find the best model by the genetic algorithm
  # given any total number of possible models
  fit &lt;- ShapeSelect(loss ~ shapes(hard, set = "s.9") + shapes(tens, set = "s.9"),
  data = Rubber, genetic = TRUE)

  # check the best model
  fit$top

  # check the running time
  fit$tm

# Example 2.
  # simulate a data set such that the mean is smoothly increasing-convex in x1 and x2
  n &lt;- 100
  x1 &lt;- runif(n)
  x2 &lt;- runif(n)
  y0 &lt;-  x1^2 + x2 + x2^3

  z &lt;- rep(0:1, 50)
  for (i in 1:n) {
    if (z[i] == 1) 
      y0[i] = y0[i] * 1.5
  }

  # add some random errors and call the routine
  y &lt;- y0 + rnorm(n)

  # include factor(z) in the formula and determine if factor(z) should be in the model 
  fit &lt;- ShapeSelect(y ~ shapes(x1, set = "s.9") + shapes(x2, set = "s.9") + in.or.out(factor(z)))
  
  # use the genetic algorithm
  fit &lt;- ShapeSelect(y ~ shapes(x1, set = "s.9") + shapes(x2, set = "s.9") + in.or.out(factor(z)),
   npop = 300, per.mutate=0.02)

  # include z as a linear term in the formula and determine if z should be in the model 
  fit &lt;- ShapeSelect(y ~ shapes(x1, set = "s.9") + shapes(x2, set = "s.9") + in.or.out(z))

  # include z as a linear term in the model 
  fit &lt;- ShapeSelect(y ~ shapes(x1, set = "s.9") + shapes(x2, set = "s.9") + z)

  # include factor(z) in the model 
  fit &lt;- ShapeSelect(y ~ shapes(x1, set = "s.9") + shapes(x2, set = "s.9") + factor(z))

  # check the best model
  bf &lt;- fit$best.fit 
 
  # make a 3D plot of the best fit
  plotpersp(bf, categ = "z")

## End(Not run)
</code></pre>

<hr>
<h2 id='tree'>Specify a Tree-Ordering in a CGAM Formula</h2><span id='topic+tree'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> has a tree-ordering in a predictor in a formula argument to cgam.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree(x, pl = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_+3A_x">x</code></td>
<td>
<p>A numeric vector which has the same length as the response vector. Note that the placebo level of x must be 0.</p>
</td></tr>
<tr><td><code id="tree_+3A_pl">pl</code></td>
<td>
<p>The placebo level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;tree&quot; returns the vector &quot;x&quot; and imposes on it two attributes: name and shape. 
</p>
<p>The name attribute is used in the subroutine plotpersp; the shape attribute is &quot;tree&quot;, and according to the value of the vector itself and its shape attribute, the cone edges of the cone generated by the constraint matrix, which constrains that <code class="reqn">\eta</code> has a tree-ordering in &quot;x&quot;  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;tree&quot; does not make the corresponding cone edges itself. It sets things up to a sub-routine called tree.fun in cgam which will make the cone edges. A tree-ordering is a partial ordering: For a categorical variable <code class="reqn">x</code>, if there are treatment levels <code class="reqn">x_1,\ldots,x_k</code>, where <code class="reqn">x_1</code> is a placebo, we compare <code class="reqn">x_i, i = 2,\ldots,k</code> with <code class="reqn">x_1</code>, and not have any other comparable pairs.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with two attributes, i.e., name: the name of x; shape: &quot;tree&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+umbrella">umbrella</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # generate y
  set.seed(123)
  n &lt;- 100 
  x &lt;- rep(0:4, each = 20)
  z &lt;- rep(c("a", "b"), 50)
  y &lt;- x + I(z == "a") + rnorm(n, 1)
  xu &lt;- unique(x)

  # regress y on x under the tree-ordering restriction
  fit.tree &lt;- cgam(y ~ tree(x) + factor(z)) 

  # make a plot
  plot(x, y, cex = .7)
  mua = unique(fit.tree$muhat)[unique(z) == "a"]
  points(xu, unique(fit.tree$muhat)[unique(z) == "a"], pch = '+', col = 4, cex = 3)
  legend(0,7.5, bty = "n", "tree-ordering fit: z = 'a'", col = 4, pch = '+', cex = 1.3)
  mub = unique(fit.tree$muhat)[unique(z) == "b"] 
  points(xu, unique(fit.tree$muhat)[unique(z) == "b"], pch = '+', col = 2, cex = 3)
  legend(0,8.5, bty = "n", "tree-ordering fit: z = 'b'", col = 2, pch = '+', cex = 1.3)
</code></pre>

<hr>
<h2 id='umbrella'>Specify an Umbrella-Ordering in a CGAM Formula</h2><span id='topic+umbrella'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> has an umbrella-ordering in a predictor in a formula argument to cgam.</p>


<h3>Usage</h3>

<pre><code class='language-R'>umbrella(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="umbrella_+3A_x">x</code></td>
<td>
<p>A numeric vector which has the same length as the response vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;umbrella&quot; returns the vector &quot;x&quot; and imposes on it two attributes: name and shape.
</p>
<p>The name attribute is used in the subroutine plotpersp; the shape attribute is &quot;umbrella&quot;, and to the value of the vector itself and its shape attribute, the cone edges of the cone generated by the constraint matrix, which constrains that <code class="reqn">\eta</code> has an umbrella-ordering in &quot;x&quot;  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;umbrella&quot; does not make the corresponding cone edges itself. It sets things up to a sub-routine called umbrella.fun in cgam which will make the cone edges. An umbrella-ordering is a partial ordering: Suppose we have a <code class="reqn">x_0</code> that is known to be a &quot;mode&quot; so that for <code class="reqn">x, y &gt;= x_0</code>, we have a binary relation between <code class="reqn">x</code> and <code class="reqn">y</code> if <code class="reqn">x &lt;= y</code> and for <code class="reqn">x, y &lt;= x_0</code> we have the opposite binary relation if <code class="reqn">x &lt;= y</code>, but if <code class="reqn">x &lt; x_0</code> and <code class="reqn">y &gt; x_0</code>, there is no such binary relation.  
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with two attributes, i.e., name: the name of x; shape: &quot;umbrella&quot;.</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree">tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # generate y
  set.seed(123)
  n &lt;- 20
  x &lt;- seq(-2, 2, length = n)
  y &lt;- - x^2 + rnorm(n)

  # regress y on x under the umbrella-ordering restriction
  fit &lt;- cgam(y ~ umbrella(x)) 

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, ylab = "y")
  lines(x, fit$muhat, col = 2)
  legend("topleft", bty = "n", "umbrella-ordering fit", col = 2, lty = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
