<!DOCTYPE html><html><head><title>Help for package fido</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fido}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alr'><p>Compute the ALR of a matrix</p></a></li>
<li><a href='#alr_array'><p>Compute the ALR of an array</p></a></li>
<li><a href='#alrInv'><p>Compute the inverse ALR of a matrix</p></a></li>
<li><a href='#alrInv_array'><p>Compute the ALR of an array</p></a></li>
<li><a href='#as.list'><p>Generic method to convert to list</p></a></li>
<li><a href='#as.list.orthusfit'><p>Convert object of class orthusfit to a list</p></a></li>
<li><a href='#as.list.pibblefit'><p>Convert object of class pibblefit to a list</p></a></li>
<li><a href='#as.orthusfit'><p>convert list to orthusfit</p></a></li>
<li><a href='#as.pibblefit'><p>convert list to pibblefit</p></a></li>
<li><a href='#basset_fit'><p>Interface to fit basset models</p></a></li>
<li><a href='#check_dims'><p>Check vector/matrix/data.frame for expected dimensions or throw error</p></a></li>
<li><a href='#clr_array'><p>Compute the CLR of an array</p></a></li>
<li><a href='#coef'><p>Return regression coefficients of pibblefit or orthusfit object</p></a></li>
<li><a href='#coef.orthusfit'><p>Return regression coefficients of orthus object</p></a></li>
<li><a href='#coef.pibblefit'><p>Return regression coefficients of pibblefit object</p></a></li>
<li><a href='#conjugateLinearModel'><p>Solve Bayesian Multivariate Conjugate Linear Model</p></a></li>
<li><a href='#convert_orthus_covariance'><p>Convert orthus covariance matricies between representations</p></a></li>
<li><a href='#create_default_ilr_base'><p>Create a default ILR base</p></a></li>
<li><a href='#fido_package'><p>fido: Fitting and Analysis of Multinomial Logistic Normal  Models</p></a></li>
<li><a href='#fido_transforms'><p>Transform Fit fido Parameters to other representations</p></a></li>
<li><a href='#gather_array'><p>Gather Multidimensional Array to Tidy Tibble</p></a></li>
<li><a href='#kernels'><p>Multivariate RBF Kernel</p></a></li>
<li><a href='#lambda_to_iqlr'><p>Transform Lambda into IQLR (Inter-Quantile Log-Ratio)</p></a></li>
<li><a href='#lmvgamma'><p>Log of Multivarate Gamma Function - Gamma_p(a)</p></a></li>
<li><a href='#lmvgamma_deriv'><p>Derivative of Log of Multivariate Gamma Function - Gamma_p(a)</p></a></li>
<li><a href='#loglikMaltipooCollapsed'><p>Calculations for the Collapsed Maltipoo Model</p></a></li>
<li><a href='#loglikPibbleCollapsed'><p>Calculations for the Collapsed Pibble Model</p></a></li>
<li><a href='#mallard'><p>Data from Silverman et al. (2018) Microbiome</p></a></li>
<li><a href='#mallard_family'><p>Data from Silverman et al. (2018) Microbiome</p></a></li>
<li><a href='#maltipoo_fit'><p>Interface to fit maltipoo models</p></a></li>
<li><a href='#maltipoofit'><p>Create maltipoofit object</p></a></li>
<li><a href='#metadata'><p>Data from Silverman et al. (2019) bioRxiv</p></a></li>
<li><a href='#miniclo'><p>Closure operator</p></a></li>
<li><a href='#miniclo_array'><p>Closure Operation applied to array on margin</p></a></li>
<li><a href='#mongrel-deprecated'><p>mongrel</p></a></li>
<li><a href='#name'><p>Generic method for applying names to an object</p></a></li>
<li><a href='#name.orthusfit'><p>S3 for orthusfit apply names to orthusfit object</p></a></li>
<li><a href='#name.pibblefit'><p>S3 for pibblefit apply names to pibblefit object</p></a></li>
<li><a href='#names_covariates.pibblefit'><p>Generic method for getting and setting dimension names of fit object</p></a></li>
<li><a href='#ncategories.pibblefit'><p>Generic method for accessing model fit dimensions</p></a></li>
<li><a href='#optimMaltipooCollapsed'><p>Function to Optimize the Collapsed Maltipoo Model</p></a></li>
<li><a href='#optimPibbleCollapsed'><p>Function to Optimize the Collapsed Pibble Model</p></a></li>
<li><a href='#orthus_fit'><p>Interface to fit orthus models</p></a></li>
<li><a href='#orthus_lr_transforms'><p>Log-Ratio transforms for orthus objects</p></a></li>
<li><a href='#orthus_sim'><p>Simulate simple orthus dataset and priors (for testing)</p></a></li>
<li><a href='#orthus_tidy_samples'><p>Convert orthus samples of Eta Lambda and Sigma to tidy format</p></a></li>
<li><a href='#orthusfit'><p>Create orthusfit object</p></a></li>
<li><a href='#pcrbias_mock'><p>Data from Silverman et al. (2019) bioRxiv</p></a></li>
<li><a href='#pibble_fit'><p>Interface to fit pibble models</p></a></li>
<li><a href='#pibble_sim'><p>Simulate simple pibble dataset and priors (for testing)</p></a></li>
<li><a href='#pibble_tidy_samples'><p>Convert pibble samples of Eta Lambda and Sigma to tidy format</p></a></li>
<li><a href='#pibblefit'><p>Create pibblefit object</p></a></li>
<li><a href='#plot.pibblefit'><p>Plot Summaries of Posterior Distribution of pibblefit Parameters</p></a></li>
<li><a href='#ppc'><p>Generic method for visualizing posterior predictive checks</p></a></li>
<li><a href='#ppc_summary.pibblefit'><p>Generic Method to Plot Posterior Predictive Summaries</p></a></li>
<li><a href='#ppc.pibblefit'><p>Visualization of Posterior Predictive Check of fit model</p></a></li>
<li><a href='#predict'><p>Predict response from new data</p></a></li>
<li><a href='#predict.bassetfit'><p>Predict using basset</p></a></li>
<li><a href='#predict.pibblefit'><p>Predict response from new data</p></a></li>
<li><a href='#print'><p>Print dimensions and coordinate system information for an orthusfit or pibblefit object.</p></a></li>
<li><a href='#print.orthusfit'><p>Print dimensions and coordinate system information for orthusfit object.</p></a></li>
<li><a href='#print.pibblefit'><p>Print dimensions and coordinate system information for pibblefit object.</p></a></li>
<li><a href='#random_pibble_init'><p>Provide random initialization for pibble model</p></a></li>
<li><a href='#refit'><p>Generic method for fitting model from passed model fit object</p></a></li>
<li><a href='#req'><p>Generic method for ensuring object contains required elements</p></a></li>
<li><a href='#req.maltipoofit'><p>require elements to be non-null in pibblefit or throw error</p></a></li>
<li><a href='#req.orthusfit'><p>require elements to be non-null in orthusfit or throw error</p></a></li>
<li><a href='#req.pibblefit'><p>require elements to be non-null in pibblefit or throw error</p></a></li>
<li><a href='#sample_prior'><p>Generic method for sampling from prior distribution of object</p></a></li>
<li><a href='#sample_prior.pibblefit'><p>Sample from the prior distribution of pibblefit object</p></a></li>
<li><a href='#store_coord'><p>Holds information on coordinates system to later be reapplied</p></a></li>
<li><a href='#summarise_posterior'><p>Shortcut for summarize variable with quantiles and mean</p></a></li>
<li><a href='#summary'><p>Summarise pibblefit or orthusfit object and print posterior quantiles</p></a></li>
<li><a href='#summary.orthusfit'><p>Summarise orthusfit object and print posterior quantiles</p></a></li>
<li><a href='#summary.pibblefit'><p>Summarise pibblefit object and print posterior quantiles</p></a></li>
<li><a href='#uncollapsePibble'><p>Uncollapse output from optimPibbleCollapsed to full pibble Model</p></a></li>
<li><a href='#verify'><p>Generic method for verifying new objects</p></a></li>
<li><a href='#verify.bassetfit'><p>Simple verification of passed bassetfit object</p></a></li>
<li><a href='#verify.maltipoofit'><p>Simple verification of passed multipoo object</p></a></li>
<li><a href='#verify.orthusfit'><p>Simple verification of passed orthusfit object</p></a></li>
<li><a href='#verify.pibblefit'><p>Simple verification of passed pibblefit object</p></a></li>
<li><a href='#Y'><p>Data from Silverman et al. (2019) bioRxiv</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Multinomial Logistic Normal Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-22</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michelle Nixon
&lt;pistner@psu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for fitting and inspection of Bayesian Multinomial Logistic Normal Models using MAP estimation 
 and Laplace Approximation as developed in Silverman et. Al. (2022) <a href="https://www.jmlr.org/papers/v23/19-882.html">https://www.jmlr.org/papers/v23/19-882.html</a>. Key functionality is implemented in C++ for 
 scalability. 'fido' replaces the previous package 'stray'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jsilve24.github.io/fido/">https://jsilve24.github.io/fido/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.17), dplyr, ggplot2, purrr, tidybayes, rlang,
tidyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, RcppNumerical, RcppZiggurat, BH</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://michellepistner.github.io/fidoRepo">https://michellepistner.github.io/fidoRepo</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown, ape, numDeriv,
MCMCpack, MicrobeDS, phyloseq</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jsilve24/fido/issues">https://github.com/jsilve24/fido/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-23 14:57:06 UTC; map5672</td>
</tr>
<tr>
<td>Author:</td>
<td>Justin Silverman [aut],
  Kim Roche [ctb],
  Michelle Nixon [ctb, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-24 12:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='alr'>Compute the ALR of a matrix</h2><span id='topic+alr'></span>

<h3>Description</h3>

<p>Compute the ALR of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alr(x, d = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alr_+3A_x">x</code></td>
<td>
<p>A matrix where the rows are the samples</p>
</td></tr>
<tr><td><code id="alr_+3A_d">d</code></td>
<td>
<p>Index of column used as a reference. Defaults to last column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='alr_array'>Compute the ALR of an array</h2><span id='topic+alr_array'></span>

<h3>Description</h3>

<p>Compute the ALR of an array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alr_array(x, d = dim(x)[parts], parts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alr_array_+3A_x">x</code></td>
<td>
<p>multidimensional array in simplex</p>
</td></tr>
<tr><td><code id="alr_array_+3A_d">d</code></td>
<td>
<p>Index of column used as a reference. Defaults to last column</p>
</td></tr>
<tr><td><code id="alr_array_+3A_parts">parts</code></td>
<td>
<p>index of dimension of 'x' that represents parts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array
</p>

<hr>
<h2 id='alrInv'>Compute the inverse ALR of a matrix</h2><span id='topic+alrInv'></span>

<h3>Description</h3>

<p>Compute the inverse ALR of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alrInv(y, d = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alrInv_+3A_y">y</code></td>
<td>
<p>An ALR transformed matrix</p>
</td></tr>
<tr><td><code id="alrInv_+3A_d">d</code></td>
<td>
<p>Index of column used as a reference. Defaults to last column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='alrInv_array'>Compute the ALR of an array</h2><span id='topic+alrInv_array'></span>

<h3>Description</h3>

<p>Compute the ALR of an array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alrInv_array(y, d = dim(y)[coords] + 1, coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alrInv_array_+3A_y">y</code></td>
<td>
<p>multidimensional ALR transformed array</p>
</td></tr>
<tr><td><code id="alrInv_array_+3A_d">d</code></td>
<td>
<p>Index of column used as a reference. Defaults to last column</p>
</td></tr>
<tr><td><code id="alrInv_array_+3A_coords">coords</code></td>
<td>
<p>index of dimension of 'x' that represents coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array
</p>

<hr>
<h2 id='as.list'>Generic method to convert to list</h2><span id='topic+as.list'></span>

<h3>Description</h3>

<p>Generic method to convert to list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list_+3A_x">x</code></td>
<td>
<p>An object of class pibblefit or orthusfit</p>
</td></tr>
<tr><td><code id="as.list_+3A_...">...</code></td>
<td>
<p>Other objects to pass</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object
</p>

<hr>
<h2 id='as.list.orthusfit'>Convert object of class orthusfit to a list</h2><span id='topic+as.list.orthusfit'></span>

<h3>Description</h3>

<p>Convert object of class orthusfit to a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orthusfit'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.orthusfit_+3A_x">x</code></td>
<td>
<p>an object of class orthusfit</p>
</td></tr>
<tr><td><code id="as.list.orthusfit_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the converted orthusfit object
</p>

<hr>
<h2 id='as.list.pibblefit'>Convert object of class pibblefit to a list</h2><span id='topic+as.list.pibblefit'></span>

<h3>Description</h3>

<p>Convert object of class pibblefit to a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.pibblefit_+3A_x">x</code></td>
<td>
<p>an object of class pibblefit</p>
</td></tr>
<tr><td><code id="as.list.pibblefit_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list from the converted pibblefit object.
</p>

<hr>
<h2 id='as.orthusfit'>convert list to orthusfit</h2><span id='topic+as.orthusfit'></span>

<h3>Description</h3>

<p>convert list to orthusfit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.orthusfit(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.orthusfit_+3A_object">object</code></td>
<td>
<p>list object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An orthusfit object
</p>

<hr>
<h2 id='as.pibblefit'>convert list to pibblefit</h2><span id='topic+as.pibblefit'></span>

<h3>Description</h3>

<p>convert list to pibblefit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.pibblefit(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.pibblefit_+3A_object">object</code></td>
<td>
<p>list object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pibblefit object
</p>

<hr>
<h2 id='basset_fit'>Interface to fit basset models</h2><span id='topic+basset_fit'></span><span id='topic+basset'></span><span id='topic+refit.bassetfit'></span>

<h3>Description</h3>

<p>Basset (A Lazy Learner) - non-linear regression models in fido
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basset(
  Y = NULL,
  X,
  upsilon = NULL,
  Theta = NULL,
  Gamma = NULL,
  Xi = NULL,
  init = NULL,
  pars = c("Eta", "Lambda", "Sigma"),
  ...
)

## S3 method for class 'bassetfit'
refit(m, pars = c("Eta", "Lambda", "Sigma"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basset_fit_+3A_y">Y</code></td>
<td>
<p>D x N matrix of counts (if NULL uses priors only)</p>
</td></tr>
<tr><td><code id="basset_fit_+3A_x">X</code></td>
<td>
<p>Q x N matrix of covariates (cannot be NULL)</p>
</td></tr>
<tr><td><code id="basset_fit_+3A_upsilon">upsilon</code></td>
<td>
<p>dof for inverse wishart prior (numeric must be &gt; D)
(default: D+3)</p>
</td></tr>
<tr><td><code id="basset_fit_+3A_theta">Theta</code></td>
<td>
<p>A function from dimensions dim(X) -&gt; (D-1)xN (prior mean of gaussian process)</p>
</td></tr>
<tr><td><code id="basset_fit_+3A_gamma">Gamma</code></td>
<td>
<p>A function from dimension dim(X) -&gt; NxN (kernel matrix of gaussian process)</p>
</td></tr>
<tr><td><code id="basset_fit_+3A_xi">Xi</code></td>
<td>
<p>(D-1)x(D-1) prior covariance matrix
(default: ALR transform of diag(1)*(upsilon-D)/2 - this is
essentially iid on &quot;base scale&quot; using Aitchison terminology)</p>
</td></tr>
<tr><td><code id="basset_fit_+3A_init">init</code></td>
<td>
<p>(D-1) x Q initialization for Eta for optimization</p>
</td></tr>
<tr><td><code id="basset_fit_+3A_pars">pars</code></td>
<td>
<p>character vector of posterior parameters to return</p>
</td></tr>
<tr><td><code id="basset_fit_+3A_...">...</code></td>
<td>
<p>other arguments passed to <a href="#topic+pibble">pibble</a> (which is used internally to
fit the basset model)</p>
</td></tr>
<tr><td><code id="basset_fit_+3A_m">m</code></td>
<td>
<p>object of class bassetfit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the full model is given by:
</p>
<p style="text-align: center;"><code class="reqn">Y_j \sim Multinomial(Pi_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Pi_j = Phi^{-1}(Eta_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Eta \sim MN_{D-1 x N}(Lambda, Sigma, I_N)</code>
</p>

<p style="text-align: center;"><code class="reqn">Lambda \sim GP_{D-1 x Q}(Theta(X), Sigma, Gamma(X))</code>
</p>

<p style="text-align: center;"><code class="reqn">Sigma \sim InvWish(upsilon, Xi)</code>
</p>

<p>Where Gamma(X) is short hand for the Gram matrix of the Kernel function.
</p>
<p>Default behavior is to use MAP estimate for uncollaping the LTP
model if laplace approximation is not preformed.
</p>


<h3>Value</h3>

<p>an object of class bassetfit
</p>

<hr>
<h2 id='check_dims'>Check vector/matrix/data.frame for expected dimensions or throw error</h2><span id='topic+check_dims'></span>

<h3>Description</h3>

<p>Check vector/matrix/data.frame for expected dimensions or throw error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dims(x, d, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_dims_+3A_x">x</code></td>
<td>
<p>object to check</p>
</td></tr>
<tr><td><code id="check_dims_+3A_d">d</code></td>
<td>
<p>expected dimensions</p>
</td></tr>
<tr><td><code id="check_dims_+3A_par">par</code></td>
<td>
<p>character name of x (for error message)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing if no error, otherwise throws error
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- c(1,3,4)
check_dims(y, 3, "y")
</code></pre>

<hr>
<h2 id='clr_array'>Compute the CLR of an array</h2><span id='topic+clr_array'></span>

<h3>Description</h3>

<p>Compute the CLR of an array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clr_array(x, parts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clr_array_+3A_x">x</code></td>
<td>
<p>multidimensional array in index</p>
</td></tr>
<tr><td><code id="clr_array_+3A_parts">parts</code></td>
<td>
<p>index of dimension of 'x' that represents parts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array
</p>

<hr>
<h2 id='coef'>Return regression coefficients of pibblefit or orthusfit object</h2><span id='topic+coef'></span>

<h3>Description</h3>

<p>Return regression coefficients of pibblefit or orthusfit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>an object of class pibblefit or orthusfit</p>
</td></tr>
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>other options passed to coef.pibblefit  or coef.orthusfit (see details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of dimension (D-1) x Q x iter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim()
fit &lt;- pibble(sim$Y, sim$X)
coef(fit)

</code></pre>

<hr>
<h2 id='coef.orthusfit'>Return regression coefficients of orthus object</h2><span id='topic+coef.orthusfit'></span>

<h3>Description</h3>

<p>Orthus: Returned as array of dimension (D-1+P) x Q x iter (if in ALR or ILR) 
otherwise (D+P) x Q x iter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orthusfit'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.orthusfit_+3A_object">object</code></td>
<td>
<p>an object of class orthusfit</p>
</td></tr>
<tr><td><code id="coef.orthusfit_+3A_...">...</code></td>
<td>
<p>other options passed to coef.orthusfit (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Other arguments:
</p>

<ul>
<li><p> use_names if column and row names were passed for Y and X in 
call to <code><a href="#topic+pibble">pibble</a></code>, should these names be applied to output 
array. 
</p>
</li></ul>



<h3>Value</h3>

<p>Array of dimension (D-1) x Q x iter
</p>

<hr>
<h2 id='coef.pibblefit'>Return regression coefficients of pibblefit object</h2><span id='topic+coef.pibblefit'></span>

<h3>Description</h3>

<p>Pibble: Returned as array of dimension (D-1) x Q x iter (if in ALR or ILR) otherwise
DxQxiter (if in proportions or clr).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.pibblefit_+3A_object">object</code></td>
<td>
<p>an object of class pibblefit</p>
</td></tr>
<tr><td><code id="coef.pibblefit_+3A_...">...</code></td>
<td>
<p>other options passed to coef.pibblefit (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Other arguments:
</p>

<ul>
<li><p> 'use_names' if column and row names were passed for Y and X in 
call to <code><a href="#topic+pibble">pibble</a></code>, should these names be applied to output 
array. 
</p>
</li></ul>



<h3>Value</h3>

<p>Array of dimension (D-1) x Q x iter
</p>

<hr>
<h2 id='conjugateLinearModel'>Solve Bayesian Multivariate Conjugate Linear Model</h2><span id='topic+conjugateLinearModel'></span>

<h3>Description</h3>

<p>See details for model.  Notation: <code>N</code> is number of samples,
<code>D</code> is the dimension of the response, <code>Q</code> is number
of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conjugateLinearModel(Y, X, Theta, Gamma, Xi, upsilon, n_samples = 2000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conjugateLinearModel_+3A_y">Y</code></td>
<td>
<p>matrix of dimension D x N</p>
</td></tr>
<tr><td><code id="conjugateLinearModel_+3A_x">X</code></td>
<td>
<p>matrix of covariates of dimension Q x N</p>
</td></tr>
<tr><td><code id="conjugateLinearModel_+3A_theta">Theta</code></td>
<td>
<p>matrix of prior mean of dimension D x Q</p>
</td></tr>
<tr><td><code id="conjugateLinearModel_+3A_gamma">Gamma</code></td>
<td>
<p>covariance matrix of dimension Q x Q</p>
</td></tr>
<tr><td><code id="conjugateLinearModel_+3A_xi">Xi</code></td>
<td>
<p>covariance matrix of dimension D x D</p>
</td></tr>
<tr><td><code id="conjugateLinearModel_+3A_upsilon">upsilon</code></td>
<td>
<p>scalar (must be &gt; D-1) degrees of freedom for InvWishart prior</p>
</td></tr>
<tr><td><code id="conjugateLinearModel_+3A_n_samples">n_samples</code></td>
<td>
<p>number of samples to draw (default: 2000)</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">Y ~ MN_{D-1 x N}(Lambda*X, Sigma, I_N)</code>
</p>

<p style="text-align: center;"><code class="reqn">Lambda ~ MN_{D-1 x Q}(Theta, Sigma, Gamma)</code>
</p>

<p style="text-align: center;"><code class="reqn">Sigma ~ InvWish(upsilon, Xi)</code>
</p>

<p>This function provides a means of sampling from the posterior distribution of
<code>Lambda</code> and <code>Sigma</code>.
</p>


<h3>Value</h3>

<p>List with components
</p>

<ol>
<li><p> Lambda Array of dimension (D-1) x Q x n_samples (posterior samples)
</p>
</li>
<li><p> Sigma Array of dimension (D-1) x (D-1) x n_samples (posterior samples)
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim()
eta.hat &lt;- t(alr(t(sim$Y+0.65)))
fit &lt;- conjugateLinearModel(eta.hat, sim$X, sim$Theta, sim$Gamma, 
                            sim$Xi, sim$upsilon, n_samples=2000)
</code></pre>

<hr>
<h2 id='convert_orthus_covariance'>Convert orthus covariance matricies between representations</h2><span id='topic+convert_orthus_covariance'></span><span id='topic+oilrvar2ilrvar'></span><span id='topic+oilrvar2clrvar'></span><span id='topic+oclrvar2ilrvar'></span><span id='topic+oalrvar2clrvar'></span><span id='topic+oclrvar2alrvar'></span><span id='topic+oalrvar2alrvar'></span><span id='topic+oalrvar2ilrvar'></span><span id='topic+oilrvar2alrvar'></span>

<h3>Description</h3>

<p>Convert orthus covariance matricies between representations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oilrvar2ilrvar(Sigma, s, V1, V2)

oilrvar2clrvar(Sigma, s, V)

oclrvar2ilrvar(Sigma, s, V)

oalrvar2clrvar(Sigma, s, d1)

oclrvar2alrvar(Sigma, s, d2)

oalrvar2alrvar(Sigma, s, d1, d2)

oalrvar2ilrvar(Sigma, s, d1, V2)

oilrvar2alrvar(Sigma, s, V1, d2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_orthus_covariance_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix arrat in specified transformed space 
(dim(Sigma)[3]=iter)</p>
</td></tr>
<tr><td><code id="convert_orthus_covariance_+3A_s">s</code></td>
<td>
<p>first s rows and colums of Sigma are transformed</p>
</td></tr>
<tr><td><code id="convert_orthus_covariance_+3A_v1">V1</code></td>
<td>
<p>ILR contrast matrix of basis Sigma is already in</p>
</td></tr>
<tr><td><code id="convert_orthus_covariance_+3A_v2">V2</code></td>
<td>
<p>ILR contrast matrix of basis Sigma is desired in</p>
</td></tr>
<tr><td><code id="convert_orthus_covariance_+3A_v">V</code></td>
<td>
<p>ILR contrast matrix (i.e., transformation matrix of ILR)</p>
</td></tr>
<tr><td><code id="convert_orthus_covariance_+3A_d1">d1</code></td>
<td>
<p>alr reference element Sigma is already expressed with respec to</p>
</td></tr>
<tr><td><code id="convert_orthus_covariance_+3A_d2">d2</code></td>
<td>
<p>alr reference element Sigma is to be expressed with respect to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='create_default_ilr_base'>Create a default ILR base</h2><span id='topic+create_default_ilr_base'></span>

<h3>Description</h3>

<p>Create a default ILR base
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_default_ilr_base(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_default_ilr_base_+3A_d">D</code></td>
<td>
<p>the number of parts (e.g., number of columns in untransformed data)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>

<hr>
<h2 id='fido_package'>fido: Fitting and Analysis of Multinomial Logistic Normal  Models</h2><span id='topic+fido_package'></span>

<h3>Description</h3>

<p>Provides methods for fitting and inspection of Bayesian Multinomial 
Logistic Normal Models using MAP estimation 
(with the ADAM optimizer) and Laplace Approximation. Key functionality is 
implemented in C++ for scalability.
</p>

<hr>
<h2 id='fido_transforms'>Transform Fit fido Parameters to other representations</h2><span id='topic+fido_transforms'></span><span id='topic+to_proportions'></span><span id='topic+to_alr'></span><span id='topic+to_ilr'></span><span id='topic+to_clr'></span><span id='topic+to_proportions.pibblefit'></span><span id='topic+to_proportions.orthusfit'></span><span id='topic+to_alr.pibblefit'></span><span id='topic+to_alr.orthusfit'></span><span id='topic+to_ilr.pibblefit'></span><span id='topic+to_ilr.orthusfit'></span><span id='topic+to_clr.pibblefit'></span><span id='topic+to_clr.orthusfit'></span>

<h3>Description</h3>

<p>These are a collection of convenience functions for transforming
fido fit objects to a number of different representations including
ILR bases, CLR coordinates, ALR coordinates, and proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_proportions(m)

to_alr(m, d)

to_ilr(m, V = NULL)

to_clr(m)

## S3 method for class 'pibblefit'
to_proportions(m)

## S3 method for class 'orthusfit'
to_proportions(m)

## S3 method for class 'pibblefit'
to_alr(m, d)

## S3 method for class 'orthusfit'
to_alr(m, d)

## S3 method for class 'pibblefit'
to_ilr(m, V = NULL)

## S3 method for class 'orthusfit'
to_ilr(m, V = NULL)

## S3 method for class 'pibblefit'
to_clr(m)

## S3 method for class 'orthusfit'
to_clr(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fido_transforms_+3A_m">m</code></td>
<td>
<p>object of class pibblefit or orthusfit (e.g., output of <code><a href="#topic+pibble">pibble</a></code>
or <code><a href="#topic+orthus">orthus</a></code>)</p>
</td></tr>
<tr><td><code id="fido_transforms_+3A_d">d</code></td>
<td>
<p>(integer) multinomial category to take as new alr reference</p>
</td></tr>
<tr><td><code id="fido_transforms_+3A_v">V</code></td>
<td>
<p>(matrix) contrast matrix for ILR basis to transform into to (defaults to 
<code>create_default_ilr_base(D)</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For orthus, transforms only appleid to log-ratio parameters
</p>
<p>Note: that there is a degeneracy of representations for a covariance 
matrix represented in terms of proportions. As such the function 
<code>to_proportions</code> does not attempt to transform parameters Sigma
or prior Xi and instead just removes them from the pibblefit object returned.
</p>


<h3>Value</h3>

<p>object
</p>

<hr>
<h2 id='gather_array'>Gather Multidimensional Array to Tidy Tibble</h2><span id='topic+gather_array'></span>

<h3>Description</h3>

<p>Gather Multidimensional Array to Tidy Tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_array(a, value, ..., .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_array_+3A_a">a</code></td>
<td>
<p>multidimensional array</p>
</td></tr>
<tr><td><code id="gather_array_+3A_value">value</code></td>
<td>
<p>unquoted name of column with values (defaults to &quot;var&quot;)</p>
</td></tr>
<tr><td><code id="gather_array_+3A_...">...</code></td>
<td>
<p>unquoted dimension names (defaults to &quot;dim_1&quot;, &quot;dim_2&quot;, etc...)</p>
</td></tr>
<tr><td><code id="gather_array_+3A_.id">.id</code></td>
<td>
<p>if specified, name for column created with name of a captured</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p>spread_array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- array(1:100, dim =c(10, 5, 2))
gather_array(a, sequence, A, B, C)
</code></pre>

<hr>
<h2 id='kernels'>Multivariate RBF Kernel</h2><span id='topic+kernels'></span><span id='topic+SE'></span><span id='topic+LINEAR'></span>

<h3>Description</h3>

<p>Designed to be partially specified. (see examples)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SE(X, sigma = 1, rho = median(as.matrix(dist(t(X)))), jitter = 1e-10)

LINEAR(X, sigma = 1, c = rep(0, nrow(X)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernels_+3A_x">X</code></td>
<td>
<p>covariate (dimension Q x N; i.e., covariates x samples)</p>
</td></tr>
<tr><td><code id="kernels_+3A_sigma">sigma</code></td>
<td>
<p>scalar parameter</p>
</td></tr>
<tr><td><code id="kernels_+3A_rho">rho</code></td>
<td>
<p>scalar bandwidth parameter</p>
</td></tr>
<tr><td><code id="kernels_+3A_jitter">jitter</code></td>
<td>
<p>small scalar to add to off-diagonal of gram matrix 
(for numerical underflow issues)</p>
</td></tr>
<tr><td><code id="kernels_+3A_c">c</code></td>
<td>
<p>vector parameter defining intercept for linear kernel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gram matrix G is given by 
</p>
<p>SE (squared exponential):
</p>
<p style="text-align: center;"><code class="reqn">G = \sigma^2 * exp(-[(X-c)'(X-c)]/(s*\rho^2))</code>
</p>

<p>LINEAR:
</p>
<p style="text-align: center;"><code class="reqn">G = \sigma^2*(X-c)'(X-c)</code>
</p>



<h3>Value</h3>

<p>Gram Matrix (N x N) (e.g., the Kernel evaluated at 
each pair of points)
</p>

<hr>
<h2 id='lambda_to_iqlr'>Transform Lambda into IQLR (Inter-Quantile Log-Ratio)</h2><span id='topic+lambda_to_iqlr'></span>

<h3>Description</h3>

<p>Takes idea from Wu et al. (citation below) and calculates IQLR for 
Lambda, potentially useful if you believe there is an invariant group of 
categories (e.g., taxa / genes) that are not changing (in absolute abundance) 
between samples. IQLR is defined as 
</p>
<p style="text-align: center;"><code class="reqn">IQLR_x = log(x_i/g(IQVF))</code>
</p>

<p>for i in 1,...,D. 
IQVF are the CLR coordinates whose variance is within the inter-quantile range
(defined by <code>probs</code> argument to this function). 
A different IQVF is fit for each posteior sample as the IQVFs are calculted
based on posterior estimates for Lambda. The variance of a CLR coordinate
is defined as the norm of each row of Lambda[,focus.cov] (i.e., 
the covariation in Eta, explained by those covariates). This definition of 
variance allows uses to exclude variation from technical / trivial sources
in calculation of IQVF/IQLR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_to_iqlr(m, focus.cov = NULL, probs = c(0.25, 0.75))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_to_iqlr_+3A_m">m</code></td>
<td>
<p>object of class pibblefit (e.g., output of <code><a href="#topic+pibble">pibble</a></code>)</p>
</td></tr>
<tr><td><code id="lambda_to_iqlr_+3A_focus.cov">focus.cov</code></td>
<td>
<p>vector of integers or characters specifying columns (covariates)
of Lambda to include in calculating IQLR (if NULL, default, then uses all covariates)</p>
</td></tr>
<tr><td><code id="lambda_to_iqlr_+3A_probs">probs</code></td>
<td>
<p>bounds for categories (i.e., features / genes / taxa) to include in 
calculation of iqlr (smaller bounds means more stringent inclusion criteria)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Primarily intended for doing differential expression analysis under 
assumption that only small group of categories (e.g., taxa / genes) are changing
</p>


<h3>Value</h3>

<p>array of dimension (D, Q, iter) where D is number of taxa, Q is number
of covariates, and iter is number of posterior samples.
</p>


<h3>References</h3>

<p>Jia R. Wu, Jean M. Macklaim, Briana L. Genge, Gregory B. Gloor (2017)
Finding the center: corrections for asymmetry in high-throughput sequencing
datasets. arxiv:1704.01841v1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim &lt;- pibble_sim()
fit &lt;- pibble(sim$Y, sim$X)
# Use first two covariates to define iqlr, just show first 5 samples
lambda_to_iqlr(fit, 1:2)[,,1:5] 


</code></pre>

<hr>
<h2 id='lmvgamma'>Log of Multivarate Gamma Function - Gamma_p(a)</h2><span id='topic+lmvgamma'></span>

<h3>Description</h3>

<p>Log of Multivarate Gamma Function - Gamma_p(a)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmvgamma(a, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmvgamma_+3A_a">a</code></td>
<td>
<p>defined by Gamma_p(a)</p>
</td></tr>
<tr><td><code id="lmvgamma_+3A_p">p</code></td>
<td>
<p>defined by Gamma_p(a)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/Multivariate_gamma_function
</p>

<hr>
<h2 id='lmvgamma_deriv'>Derivative of Log of Multivariate Gamma Function - Gamma_p(a)</h2><span id='topic+lmvgamma_deriv'></span>

<h3>Description</h3>

<p>Derivative of Log of Multivariate Gamma Function - Gamma_p(a)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmvgamma_deriv(a, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmvgamma_deriv_+3A_a">a</code></td>
<td>
<p>defined by Gamma_p(a)</p>
</td></tr>
<tr><td><code id="lmvgamma_deriv_+3A_p">p</code></td>
<td>
<p>defined by Gamma_p(a)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/Multivariate_gamma_function
</p>

<hr>
<h2 id='loglikMaltipooCollapsed'>Calculations for the Collapsed Maltipoo Model</h2><span id='topic+loglikMaltipooCollapsed'></span><span id='topic+gradMaltipooCollapsed'></span><span id='topic+hessMaltipooCollapsed'></span>

<h3>Description</h3>

<p>Functions providing access to the Log Likelihood, Gradient, and Hessian
of the collapsed maltipoo model. Note: These are convenience functions
but are not as optimized as direct coding of the MaltipooCollapsed
C++ class due to a lack of Memoization. By contrast function optimMaltipooCollapsed
is much more optimized and massively cuts down on repeated calculations.
A more efficient Rcpp module based implementation of these functions
may following if the future. For model details see <code><a href="#topic+optimMaltipooCollapsed">optimMaltipooCollapsed</a></code>
documentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikMaltipooCollapsed(Y, upsilon, Theta, X, KInv, U, eta, ell, sylv = FALSE)

gradMaltipooCollapsed(Y, upsilon, Theta, X, KInv, U, eta, ell, sylv = FALSE)

hessMaltipooCollapsed(Y, upsilon, Theta, X, KInv, U, eta, ell, sylv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikMaltipooCollapsed_+3A_y">Y</code></td>
<td>
<p>D x N matrix of counts</p>
</td></tr>
<tr><td><code id="loglikMaltipooCollapsed_+3A_upsilon">upsilon</code></td>
<td>
<p>(must be &gt; D)</p>
</td></tr>
<tr><td><code id="loglikMaltipooCollapsed_+3A_theta">Theta</code></td>
<td>
<p>D-1 x Q matrix the prior mean for regression coefficients</p>
</td></tr>
<tr><td><code id="loglikMaltipooCollapsed_+3A_x">X</code></td>
<td>
<p>Q x N matrix of covariates</p>
</td></tr>
<tr><td><code id="loglikMaltipooCollapsed_+3A_kinv">KInv</code></td>
<td>
<p>D-1 x D-1 symmetric positive-definite matrix</p>
</td></tr>
<tr><td><code id="loglikMaltipooCollapsed_+3A_u">U</code></td>
<td>
<p>a PQxQ matrix of stacked variance components</p>
</td></tr>
<tr><td><code id="loglikMaltipooCollapsed_+3A_eta">eta</code></td>
<td>
<p>matrix (D-1)xN of parameter values at which to calculate quantities</p>
</td></tr>
<tr><td><code id="loglikMaltipooCollapsed_+3A_ell">ell</code></td>
<td>
<p>P-vector of scale factors for each variance component (aka VCScale)</p>
</td></tr>
<tr><td><code id="loglikMaltipooCollapsed_+3A_sylv">sylv</code></td>
<td>
<p>(default:false) if true and if N &lt; D-1 will use sylvester determinant
identity to speed computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see below
</p>

<ul>
<li><p> loglikMaltipooCollapsed - double
</p>
</li>
<li><p> gradMaltipooCollapsed - vector
</p>
</li>
<li><p> hessMaltipooCollapsed- matrix
</p>
</li></ul>


<hr>
<h2 id='loglikPibbleCollapsed'>Calculations for the Collapsed Pibble Model</h2><span id='topic+loglikPibbleCollapsed'></span><span id='topic+gradPibbleCollapsed'></span><span id='topic+hessPibbleCollapsed'></span>

<h3>Description</h3>

<p>Functions providing access to the Log Likelihood, Gradient, and Hessian
of the collapsed pibble model. Note: These are convenience functions
but are not as optimized as direct coding of the PibbleCollapsed
C++ class due to a lack of Memoization. By contrast function optimPibbleCollapsed
is much more optimized and massively cuts down on repeated calculations.
A more efficient Rcpp module based implementation of these functions
may following if the future. For model details see <code><a href="#topic+optimPibbleCollapsed">optimPibbleCollapsed</a></code>
documentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikPibbleCollapsed(Y, upsilon, ThetaX, KInv, AInv, eta, sylv = FALSE)

gradPibbleCollapsed(Y, upsilon, ThetaX, KInv, AInv, eta, sylv = FALSE)

hessPibbleCollapsed(Y, upsilon, ThetaX, KInv, AInv, eta, sylv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikPibbleCollapsed_+3A_y">Y</code></td>
<td>
<p>D x N matrix of counts</p>
</td></tr>
<tr><td><code id="loglikPibbleCollapsed_+3A_upsilon">upsilon</code></td>
<td>
<p>(must be &gt; D)</p>
</td></tr>
<tr><td><code id="loglikPibbleCollapsed_+3A_thetax">ThetaX</code></td>
<td>
<p>D-1 x N matrix formed by Theta*X (Theta is Prior mean
for regression coefficients)</p>
</td></tr>
<tr><td><code id="loglikPibbleCollapsed_+3A_kinv">KInv</code></td>
<td>
<p>Inverse of K for LTP (for Pibble defined as KInv = solve(Xi))</p>
</td></tr>
<tr><td><code id="loglikPibbleCollapsed_+3A_ainv">AInv</code></td>
<td>
<p>Inverse of A for LTP (for Pibble defined as
AInv = solve(diag(N)+ X'GammaX) )</p>
</td></tr>
<tr><td><code id="loglikPibbleCollapsed_+3A_eta">eta</code></td>
<td>
<p>matrix (D-1)xN of parameter values at which to calculate quantities</p>
</td></tr>
<tr><td><code id="loglikPibbleCollapsed_+3A_sylv">sylv</code></td>
<td>
<p>(default:false) if true and if N &lt; D-1 will use sylvester determinant
identity to speed computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see below
</p>

<ul>
<li><p> loglikPibbleCollapsed - double
</p>
</li>
<li><p> gradPibbleCollapsed - vector
</p>
</li>
<li><p> hessPibbleCollapsed- matrix
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- 10
Q &lt;- 2
N &lt;- 30

# Simulate Data
Sigma &lt;- diag(sample(1:8, D-1, replace=TRUE))
Sigma[2, 3] &lt;- Sigma[3,2] &lt;- -1
Gamma &lt;- diag(sqrt(rnorm(Q)^2))
Theta &lt;- matrix(0, D-1, Q)
Phi &lt;-  Theta + t(chol(Sigma))%*%matrix(rnorm(Q*(D-1)), nrow=D-1)%*%chol(Gamma)
X &lt;- matrix(rnorm(N*(Q-1)), Q-1, N)
X &lt;- rbind(1, X)
Eta &lt;- Phi%*%X + t(chol(Sigma))%*%matrix(rnorm(N*(D-1)), nrow=D-1)
Pi &lt;- t(alrInv(t(Eta)))
Y &lt;- matrix(0, D, N)
for (i in 1:N) Y[,i] &lt;- rmultinom(1, sample(5000:10000), prob = Pi[,i])

# Priors
upsilon &lt;- D+10
Xi &lt;- Sigma*(upsilon-D)

# Precompute
KInv &lt;- solve(Xi)
AInv &lt;- solve(diag(N)+ t(X)%*%Gamma%*%X)
ThetaX &lt;- Theta%*%X


loglikPibbleCollapsed(Y, upsilon, ThetaX, KInv, AInv, Eta)
gradPibbleCollapsed(Y, upsilon, ThetaX, KInv, AInv, Eta)[1:5]
hessPibbleCollapsed(Y, upsilon, ThetaX, KInv, AInv, Eta)[1:5,1:5]
</code></pre>

<hr>
<h2 id='mallard'>Data from Silverman et al. (2018) Microbiome</h2><span id='topic+mallard'></span>

<h3>Description</h3>

<p>High Resolution (hourly and daily) sampling of 4 in vitro artificial gut models
with many technical replicates to identify technical variation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mallard)
</code></pre>


<h3>Format</h3>

<p>A list containing &quot;otu_table&quot;, &quot;sample_data&quot;, &quot;tax_table&quot;, and &quot;refseq&quot;.
</p>


<h3>Details</h3>

<p>This data is at the sequence variant level. Data at the family level
processed as in Silverman et al. 2018 is given in <code><a href="#topic+mallard_family">mallard_family</a></code>
</p>


<h3>References</h3>

<p>Silverman et al. &quot;Dynamic linear models guide design and 
analysis of microbiota studies within artificial human guts&quot;. 
Microbiome 2018 6:202
</p>

<hr>
<h2 id='mallard_family'>Data from Silverman et al. (2018) Microbiome</h2><span id='topic+mallard_family'></span>

<h3>Description</h3>

<p>High Resolution (hourly and daily) sampling of 4 in vitro artificial gut models
with many technical replicates to identify technical variation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mallard_family)
</code></pre>


<h3>Format</h3>

<p>A list containing &quot;otu_table&quot;, &quot;sample_data&quot;, &quot;tax_table&quot;, and &quot;refseq&quot;.
</p>


<h3>Details</h3>

<p>This data is at the family level and processed as in Silverman et al. 2018. Data at the sequence
variant level without preprocessing is given in <code><a href="#topic+mallard">mallard</a></code>
</p>


<h3>References</h3>

<p>Silverman et al. &quot;Dynamic linear models guide design and 
analysis of microbiota studies within artificial human guts&quot;. 
Microbiome 2018 6:202
</p>

<hr>
<h2 id='maltipoo_fit'>Interface to fit maltipoo models</h2><span id='topic+maltipoo_fit'></span><span id='topic+maltipoo'></span>

<h3>Description</h3>

<p>This function is largely a more user friendly wrapper around 
<code><a href="#topic+optimMaltipooCollapsed">optimMaltipooCollapsed</a></code> and 
<code><a href="#topic+uncollapsePibble">uncollapsePibble</a></code>. 
See details for model specification. 
Notation: <code>N</code> is number of samples,
<code>D</code> is number of multinomial categories, <code>Q</code> is number
of covariates, <code>P</code> is the number of variance components 
<code>iter</code> is the number of samples of <code>eta</code> (e.g.,
the parameter <code>n_samples</code> in the function 
<code><a href="#topic+optimPibbleCollapsed">optimPibbleCollapsed</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maltipoo(
  Y = NULL,
  X = NULL,
  upsilon = NULL,
  Theta = NULL,
  U = NULL,
  Xi = NULL,
  init = NULL,
  ellinit = NULL,
  pars = c("Eta", "Lambda", "Sigma"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maltipoo_fit_+3A_y">Y</code></td>
<td>
<p>D x N matrix of counts (if NULL uses priors only)</p>
</td></tr>
<tr><td><code id="maltipoo_fit_+3A_x">X</code></td>
<td>
<p>Q x N matrix of covariates (design matrix) (if NULL uses priors only, must
be present to sample Eta)</p>
</td></tr>
<tr><td><code id="maltipoo_fit_+3A_upsilon">upsilon</code></td>
<td>
<p>dof for inverse wishart prior (numeric must be &gt; D)
(default: D+3)</p>
</td></tr>
<tr><td><code id="maltipoo_fit_+3A_theta">Theta</code></td>
<td>
<p>(D-1) x Q matrix of prior mean for regression parameters
(default: matrix(0, D-1, Q))</p>
</td></tr>
<tr><td><code id="maltipoo_fit_+3A_u">U</code></td>
<td>
<p>a PQ x Q matrix of stacked variance components (each of dimension Q x Q)</p>
</td></tr>
<tr><td><code id="maltipoo_fit_+3A_xi">Xi</code></td>
<td>
<p>(D-1)x(D-1) prior covariance matrix
(default: ALR transform of diag(1)*(upsilon-D)/2 - this is
essentially iid on &quot;base scale&quot; using Aitchison terminology)</p>
</td></tr>
<tr><td><code id="maltipoo_fit_+3A_init">init</code></td>
<td>
<p>(D-1) x Q initialization for Eta for optimization</p>
</td></tr>
<tr><td><code id="maltipoo_fit_+3A_ellinit">ellinit</code></td>
<td>
<p>P vector initialization values for ell for optimization</p>
</td></tr>
<tr><td><code id="maltipoo_fit_+3A_pars">pars</code></td>
<td>
<p>character vector of posterior parameters to return</p>
</td></tr>
<tr><td><code id="maltipoo_fit_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+optimPibbleCollapsed">optimPibbleCollapsed</a></code> and
<code><a href="#topic+uncollapsePibble">uncollapsePibble</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>the full model is given by:
</p>
<p style="text-align: center;"><code class="reqn">Y_j \sim Multinomial(Pi_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Pi_j = Phi^{-1}(Eta_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Eta \sim MN_{D-1 x N}(Lambda*X, Sigma, I_N)</code>
</p>

<p style="text-align: center;"><code class="reqn">Lambda \sim MN_{D-1 x Q}(Theta, Sigma, Gamma)</code>
</p>

<p style="text-align: center;"><code class="reqn">Gamma = e^{ell_1} U_1 + ... + e^{ell_P} U_P</code>
</p>

<p style="text-align: center;"><code class="reqn">Sigma \sim InvWish(upsilon, Xi)</code>
</p>

<p>Where A = (I_N + X * Gamma * X')^-1, K^-1 = Xi is a (D-1)x(D-1) 
covariance matrix, U_1 is a Q x Q covariance matrix (a variance component), 
e^ell_i is a scale for that variance component and Phi^-1 is 
ALRInv_D transform. 
</p>
<p>Default behavior is to use MAP estimate for uncollaping collapsed maltipoo 
model if laplace approximation is not preformed. 
</p>
<p>Parameters ell are treated as fixed and estimated by MAP estimation.
</p>


<h3>Value</h3>

<p>an object of class maltipoofit
</p>

<hr>
<h2 id='maltipoofit'>Create maltipoofit object</h2><span id='topic+maltipoofit'></span>

<h3>Description</h3>

<p>Create maltipoofit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maltipoofit(
  D,
  N,
  Q,
  P,
  coord_system,
  iter = NULL,
  alr_base = NULL,
  ilr_base = NULL,
  Eta = NULL,
  Lambda = NULL,
  Sigma = NULL,
  Sigma_default = NULL,
  Y = NULL,
  X = NULL,
  upsilon = NULL,
  Theta = NULL,
  Xi = NULL,
  Xi_default = NULL,
  Gamma = NULL,
  init = NULL,
  ellinit = NULL,
  names_categories = NULL,
  names_samples = NULL,
  names_covariates = NULL,
  VCScale = NULL,
  U = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maltipoofit_+3A_d">D</code></td>
<td>
<p>number of multinomial categories</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_n">N</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_q">Q</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_p">P</code></td>
<td>
<p>number of variance components</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_coord_system">coord_system</code></td>
<td>
<p>coordinate system objects are represented in (options 
include &quot;alr&quot;, &quot;clr&quot;, &quot;ilr&quot;, and &quot;proportions&quot;)</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_iter">iter</code></td>
<td>
<p>number of posterior samples</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_alr_base">alr_base</code></td>
<td>
<p>integer category used as reference 
(required if coord_system==&quot;alr&quot;)</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_ilr_base">ilr_base</code></td>
<td>
<p>(D x D-1) contrast matrix (required if coord_system==&quot;ilr&quot;)</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_eta">Eta</code></td>
<td>
<p>Array of samples of Eta</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_lambda">Lambda</code></td>
<td>
<p>Array of samples of Lambda</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_sigma">Sigma</code></td>
<td>
<p>Array of samples of Sigma (null if coord_system==&quot;proportions&quot;)</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_sigma_default">Sigma_default</code></td>
<td>
<p>Array of samples of Sigma in alr base D, used if 
coord_system==&quot;proportions&quot;</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_y">Y</code></td>
<td>
<p>DxN matrix of observed counts</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_x">X</code></td>
<td>
<p>QxN design matrix</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_upsilon">upsilon</code></td>
<td>
<p>scalar prior dof of inverse wishart prior</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_theta">Theta</code></td>
<td>
<p>prior mean of Lambda</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_xi">Xi</code></td>
<td>
<p>Matrix of prior covariance for inverse wishart 
(null if coord_system==&quot;proportions&quot;)</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_xi_default">Xi_default</code></td>
<td>
<p>Matrix of prior covariance for inverse wishart in alr 
base D (used if coord_system==&quot;proportions&quot;)</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_gamma">Gamma</code></td>
<td>
<p>QxQ covariance matrix prior for Lambda</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_init">init</code></td>
<td>
<p>matrix initial guess for Lambda used for optimization</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_ellinit">ellinit</code></td>
<td>
<p>P vector initialization values for ell for optimization</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_names_categories">names_categories</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_names_samples">names_samples</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_names_covariates">names_covariates</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_vcscale">VCScale</code></td>
<td>
<p>scale factors (delta) for variance components</p>
</td></tr>
<tr><td><code id="maltipoofit_+3A_u">U</code></td>
<td>
<p>a PQ x Q matrix of stacked variance components (each of dimension Q x Q)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class maltipoofit
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maltipoo">maltipoo</a></code>
</p>

<hr>
<h2 id='metadata'>Data from Silverman et al. (2019) bioRxiv</h2><span id='topic+metadata'></span>

<h3>Description</h3>

<p>Mock communities and calibration samples created for measuring and validating model
of PCR bias. This data has been preprocessed as in the original manuscript.
</p>


<h3>Format</h3>

<p>a data.frame metadata associated with the counts matrix 'Y'
</p>


<h3>References</h3>

<p>Justin D. Silverman, Rachael J. Bloom, Sharon Jiang, Heather K. Durand, Sayan Mukherjee, 
Lawrence A. David. (2019) Measuring and Mitigating PCR Bias in Microbiome Data. 
bioRxiv 604025; doi: https://doi.org/10.1101/604025
</p>

<hr>
<h2 id='miniclo'>Closure operator</h2><span id='topic+miniclo'></span>

<h3>Description</h3>

<p>Closure operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miniclo(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miniclo_+3A_x">x</code></td>
<td>
<p>vector or matrix (rows are samples, parts are columns) of data in simplex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x with row entries divided by sum of row (converts vectors to row matricies)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(30), 10, 3)
x &lt;- miniclo(x)
</code></pre>

<hr>
<h2 id='miniclo_array'>Closure Operation applied to array on margin</h2><span id='topic+miniclo_array'></span>

<h3>Description</h3>

<p>Array version of <code><a href="#topic+miniclo">miniclo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miniclo_array(x, parts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miniclo_array_+3A_x">x</code></td>
<td>
<p>multidimensional array</p>
</td></tr>
<tr><td><code id="miniclo_array_+3A_parts">parts</code></td>
<td>
<p>index of dimension of <code>x</code> that represents parts (e.g., compositional variables)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(1:100, dim=c(10, 5, 2))
miniclo_array(x, parts=2)
</code></pre>

<hr>
<h2 id='mongrel-deprecated'>mongrel</h2><span id='topic+mongrel-deprecated'></span><span id='topic+mongrel'></span>

<h3>Description</h3>

<p>This function is deprecated, please use <code>pibble</code> 
instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mongrel(
  Y = NULL,
  X = NULL,
  upsilon = NULL,
  Theta = NULL,
  Gamma = NULL,
  Xi = NULL,
  init = NULL,
  pars = c("Eta", "Lambda", "Sigma"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mongrel-deprecated_+3A_y">Y</code></td>
<td>
<p>D x N matrix of counts (if NULL uses priors only)</p>
</td></tr>
<tr><td><code id="mongrel-deprecated_+3A_x">X</code></td>
<td>
<p>Q x N matrix of covariates (design matrix) (if NULL uses priors only, must
be present to sample Eta)</p>
</td></tr>
<tr><td><code id="mongrel-deprecated_+3A_upsilon">upsilon</code></td>
<td>
<p>dof for inverse wishart prior (numeric must be &gt; D)
(default: D+3)</p>
</td></tr>
<tr><td><code id="mongrel-deprecated_+3A_theta">Theta</code></td>
<td>
<p>(D-1) x Q matrix of prior mean for regression parameters
(default: matrix(0, D-1, Q))</p>
</td></tr>
<tr><td><code id="mongrel-deprecated_+3A_gamma">Gamma</code></td>
<td>
<p>QxQ prior covariance matrix
(default: diag(Q))</p>
</td></tr>
<tr><td><code id="mongrel-deprecated_+3A_xi">Xi</code></td>
<td>
<p>(D-1)x(D-1) prior covariance matrix
(default: ALR transform of diag(1)*(upsilon-D)/2 - this is
essentially iid on &quot;base scale&quot; using Aitchison terminology)</p>
</td></tr>
<tr><td><code id="mongrel-deprecated_+3A_init">init</code></td>
<td>
<p>(D-1) x Q initialization for Eta for optimization</p>
</td></tr>
<tr><td><code id="mongrel-deprecated_+3A_pars">pars</code></td>
<td>
<p>character vector of posterior parameters to return</p>
</td></tr>
<tr><td><code id="mongrel-deprecated_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+optimPibbleCollapsed">optimPibbleCollapsed</a></code> and
<code><a href="#topic+uncollapsePibble">uncollapsePibble</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class pibblefit
</p>

<hr>
<h2 id='name'>Generic method for applying names to an object</h2><span id='topic+name'></span>

<h3>Description</h3>

<p>Intended to be called internally by package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name_+3A_m">m</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="name_+3A_...">...</code></td>
<td>
<p>other arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of same class but with names applied to dimensions
</p>

<hr>
<h2 id='name.orthusfit'>S3 for orthusfit apply names to orthusfit object</h2><span id='topic+name.orthusfit'></span>

<h3>Description</h3>

<p>To avoid confusion, assigned default names to multinomial categories (c1 etc...) 
and zdimensions (z1 etc...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orthusfit'
name(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name.orthusfit_+3A_m">m</code></td>
<td>
<p>object of class orthusfit</p>
</td></tr>
<tr><td><code id="name.orthusfit_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class orthusfit
</p>

<hr>
<h2 id='name.pibblefit'>S3 for pibblefit apply names to pibblefit object</h2><span id='topic+name.pibblefit'></span>

<h3>Description</h3>

<p>S3 for pibblefit apply names to pibblefit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
name(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name.pibblefit_+3A_m">m</code></td>
<td>
<p>object of class pibblefit</p>
</td></tr>
<tr><td><code id="name.pibblefit_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class pibblefit
</p>

<hr>
<h2 id='names_covariates.pibblefit'>Generic method for getting and setting dimension names of fit object</h2><span id='topic+names_covariates.pibblefit'></span><span id='topic+names_samples.pibblefit'></span><span id='topic+names_categories.pibblefit'></span><span id='topic+names_coords.pibblefit'></span><span id='topic+names_covariates+3C-.pibblefit'></span><span id='topic+names_samples+3C-.pibblefit'></span><span id='topic+names_categories+3C-.pibblefit'></span><span id='topic+name_dims'></span><span id='topic+names_covariates'></span><span id='topic+names_samples'></span><span id='topic+names_categories'></span><span id='topic+names_coords'></span><span id='topic+names_covariates+3C-'></span><span id='topic+names_samples+3C-'></span><span id='topic+names_categories+3C-'></span>

<h3>Description</h3>

<p>Generic method for getting and setting dimension names of fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
names_covariates(m)

## S3 method for class 'pibblefit'
names_samples(m)

## S3 method for class 'pibblefit'
names_categories(m)

## S3 method for class 'pibblefit'
names_coords(m)

## S3 replacement method for class 'pibblefit'
names_covariates(m) &lt;- value

## S3 replacement method for class 'pibblefit'
names_samples(m) &lt;- value

## S3 replacement method for class 'pibblefit'
names_categories(m) &lt;- value

names_covariates(m)

names_samples(m)

names_categories(m)

names_coords(m)

names_covariates(m) &lt;- value

names_samples(m) &lt;- value

names_categories(m) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names_covariates.pibblefit_+3A_m">m</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="names_covariates.pibblefit_+3A_value">value</code></td>
<td>
<p>character vector (or NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>names_coords</code> is different than <code>names_categories</code>. 
<code>names_categories</code> provides access to the basic names of each multinomial 
category. In contrast, <code>names_coords</code> provides access to the 
names of the coordinates in which an object is represented. These coordinate
names are based on the category names. For example, category names may be, 
(OTU1, ..., OTUD) where as coordinate names could be (log(OTU1/OTUD), etc...)
if object is in default coordinate system.
</p>


<h3>Value</h3>

<p>A vector of names
</p>

<hr>
<h2 id='ncategories.pibblefit'>Generic method for accessing model fit dimensions</h2><span id='topic+ncategories.pibblefit'></span><span id='topic+nsamples.pibblefit'></span><span id='topic+ncovariates.pibblefit'></span><span id='topic+niter.pibblefit'></span><span id='topic+ncategories.orthusfit'></span><span id='topic+nsamples.orthusfit'></span><span id='topic+ncovariates.orthusfit'></span><span id='topic+niter.orthusfit'></span><span id='topic+access_dims'></span><span id='topic+ncategories'></span><span id='topic+nsamples'></span><span id='topic+ncovariates'></span><span id='topic+niter'></span>

<h3>Description</h3>

<p>Generic method for accessing model fit dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
ncategories(m)

## S3 method for class 'pibblefit'
nsamples(m)

## S3 method for class 'pibblefit'
ncovariates(m)

## S3 method for class 'pibblefit'
niter(m)

## S3 method for class 'orthusfit'
ncategories(m)

## S3 method for class 'orthusfit'
nsamples(m)

## S3 method for class 'orthusfit'
ncovariates(m)

## S3 method for class 'orthusfit'
niter(m)

ncategories(m)

nsamples(m)

ncovariates(m)

niter(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncategories.pibblefit_+3A_m">m</code></td>
<td>
<p>An object of class pibblefit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An alternative approach to accessing these dimensions is to 
access them directly from the pibblefit object using list indexing. 
* <code>ncategories</code> is equivalent to <code>m$D</code>
* <code>nsamples</code> is equivalent to <code>m$N</code>
* <code>ncovariates</code> is equivalent to <code>m$Q</code>
</p>


<h3>Value</h3>

<p>integer
</p>

<hr>
<h2 id='optimMaltipooCollapsed'>Function to Optimize the Collapsed Maltipoo Model</h2><span id='topic+optimMaltipooCollapsed'></span>

<h3>Description</h3>

<p>See details for model. Should likely be followed by function
<code><a href="#topic+uncollapsePibble">uncollapsePibble</a></code>. Notation: <code>N</code> is number of samples,
<code>D</code> is number of multinomial categories, and <code>Q</code> is number
of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimMaltipooCollapsed(
  Y,
  upsilon,
  Theta,
  X,
  KInv,
  U,
  init,
  ellinit,
  n_samples = 2000L,
  calcGradHess = TRUE,
  b1 = 0.9,
  b2 = 0.99,
  step_size = 0.003,
  epsilon = 1e-06,
  eps_f = 1e-10,
  eps_g = 1e-04,
  max_iter = 10000L,
  verbose = FALSE,
  verbose_rate = 10L,
  decomp_method = "cholesky",
  eigvalthresh = 0,
  jitter = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimMaltipooCollapsed_+3A_y">Y</code></td>
<td>
<p>D x N matrix of counts</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_upsilon">upsilon</code></td>
<td>
<p>(must be &gt; D)</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_theta">Theta</code></td>
<td>
<p>D-1 x Q matrix the prior mean for regression coefficients</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_x">X</code></td>
<td>
<p>Q x N matrix of covariates</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_kinv">KInv</code></td>
<td>
<p>D-1 x D-1 symmetric positive-definite matrix</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_u">U</code></td>
<td>
<p>a PQxQ matrix of stacked variance components</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_init">init</code></td>
<td>
<p>D-1 x N matrix of initial guess for eta used for optimization</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_ellinit">ellinit</code></td>
<td>
<p>P vector of initial guess for ell used for optimization</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_n_samples">n_samples</code></td>
<td>
<p>number of samples for Laplace Approximation (=0 very fast
as no inversion or decomposition of Hessian is required)</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_calcgradhess">calcGradHess</code></td>
<td>
<p>if n_samples=0 should Gradient and Hessian
still be calculated using closed form solutions?</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_b1">b1</code></td>
<td>
<p>(ADAM) 1st moment decay parameter (recommend 0.9) &quot;aka momentum&quot;</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_b2">b2</code></td>
<td>
<p>(ADAM) 2nd moment decay parameter (recommend 0.99 or 0.999)</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_step_size">step_size</code></td>
<td>
<p>(ADAM) step size for descent (recommend 0.001-0.003)</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_epsilon">epsilon</code></td>
<td>
<p>(ADAM) parameter to avoid divide by zero</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_eps_f">eps_f</code></td>
<td>
<p>(ADAM) normalized function improvement stopping criteria</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_eps_g">eps_g</code></td>
<td>
<p>(ADAM) normalized gradient magnitude stopping criteria</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_max_iter">max_iter</code></td>
<td>
<p>(ADAM) maximum number of iterations before stopping</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_verbose">verbose</code></td>
<td>
<p>(ADAM) if true will print stats for stopping criteria and
iteration number</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_verbose_rate">verbose_rate</code></td>
<td>
<p>(ADAM) rate to print verbose stats to screen</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_decomp_method">decomp_method</code></td>
<td>
<p>decomposition of hessian for Laplace approximation
'eigen' (more stable-slightly, slower) or 'cholesky' (less stable, faster, default)</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_eigvalthresh">eigvalthresh</code></td>
<td>
<p>threshold for negative eigenvalues in
decomposition of negative inverse hessian (should be &lt;=0)</p>
</td></tr>
<tr><td><code id="optimMaltipooCollapsed_+3A_jitter">jitter</code></td>
<td>
<p>(default: 0) if &gt;0 then adds that factor to diagonal of Hessian
before decomposition (to improve matrix conditioning)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notation: Let Z_j denote the J-th row of a matrix Z.
Model:
</p>
<p style="text-align: center;"><code class="reqn">Y_j \sim Multinomial(Pi_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Pi_j = Phi^{-1}(Eta_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Eta \sim T_{D-1, N}(upsilon, Theta\\*X, K, A)</code>
</p>

<p>Where A = (I_N + e^ell_1\*X\*U_1\*X' + ... + e^ell_P\*X\*U_P\*X' ),
K is a D-1xD-1 covariance and Phi is ALRInv_D transform.
</p>
<p>Gradient and Hessian calculations are fast as they are computed using closed
form solutions. That said, the Hessian matrix can be quite large
[N\<em>(D-1) x N\</em>(D-1)] and storage may be an issue.
</p>
<p>Note: Warnings about large negative eigenvalues can either signal
that the optimizer did not reach an optima or (more commonly in my experience)
that the prior / degrees of freedom for the covariance (given by parameters
<code>upsilon</code> and <code>KInv</code>) were too specific and at odds with the observed data.
If you get this warning try the following.
</p>

<ol>
<li><p> Try restarting the optimization using a different initial guess for eta
</p>
</li>
<li><p> Try decreasing (or even increasing)<code>step_size</code> (by increments of 0.001 or 0.002)
and increasing <code>max_iter</code> parameters in optimizer. Also can try
increasing <code>b1</code> to 0.99 and decreasing <code>eps_f</code> by a few orders
of magnitude
</p>
</li>
<li><p> Try relaxing prior assumptions regarding covariance matrix. (e.g., may want
to consider decreasing parameter <code>upsilon</code> closer to a minimum value of
D)
</p>
</li>
<li><p> Try adding small amount of jitter (e.g., set <code>jitter=1e-5</code>) to address
potential floating point errors.
</p>
</li></ol>



<h3>Value</h3>

<p>List containing (all with respect to found optima)
</p>

<ol>
<li><p> LogLik - Log Likelihood of collapsed model (up to proportionality constant)
</p>
</li>
<li><p> Gradient - (if <code>calcGradHess</code>=true)
</p>
</li>
<li><p> Hessian - (if <code>calcGradHess</code>=true) of the POSITIVE log posterior
</p>
</li>
<li><p> Pars - Parameter value of eta
</p>
</li>
<li><p> Samples - (D-1) x N x n_samples array containing posterior samples of eta
based on Laplace approximation (if n_samples&gt;0)
</p>
</li>
<li><p> VCScale - value of e^ell_i at optima
</p>
</li>
<li><p> logInvNegHessDet - the log determinant of the covariacne of the Laplace
approximation, useful for calculating marginal likelihood
</p>
</li></ol>



<h3>References</h3>

<p>S. Ruder (2016) <em>An overview of gradient descent
optimization algorithms</em>. arXiv 1609.04747
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncollapsePibble">uncollapsePibble</a></code>
</p>

<hr>
<h2 id='optimPibbleCollapsed'>Function to Optimize the Collapsed Pibble Model</h2><span id='topic+optimPibbleCollapsed'></span>

<h3>Description</h3>

<p>See details for model. Should likely be followed by function
<code><a href="#topic+uncollapsePibble">uncollapsePibble</a></code>. Notation: <code>N</code> is number of samples,
<code>D</code> is number of multinomial categories, and <code>Q</code> is number
of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimPibbleCollapsed(
  Y,
  upsilon,
  ThetaX,
  KInv,
  AInv,
  init,
  n_samples = 2000L,
  calcGradHess = TRUE,
  b1 = 0.9,
  b2 = 0.99,
  step_size = 0.003,
  epsilon = 1e-06,
  eps_f = 1e-10,
  eps_g = 1e-04,
  max_iter = 10000L,
  verbose = FALSE,
  verbose_rate = 10L,
  decomp_method = "cholesky",
  optim_method = "adam",
  eigvalthresh = 0,
  jitter = 0,
  multDirichletBoot = -1,
  useSylv = TRUE,
  ncores = -1L,
  seed = -1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimPibbleCollapsed_+3A_y">Y</code></td>
<td>
<p>D x N matrix of counts</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_upsilon">upsilon</code></td>
<td>
<p>(must be &gt; D)</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_thetax">ThetaX</code></td>
<td>
<p>D-1 x N matrix formed by Theta*X (Theta is Prior mean
for regression coefficients)</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_kinv">KInv</code></td>
<td>
<p>D-1 x D-1 precision matrix (inverse of Xi)</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_ainv">AInv</code></td>
<td>
<p>N x N precision matrix given by (I_N + X'<em>Gamma</em>X)^-1</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_init">init</code></td>
<td>
<p>D-1 x N matrix of initial guess for eta used for optimization</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_n_samples">n_samples</code></td>
<td>
<p>number of samples for Laplace Approximation (=0 very fast
as no inversion or decomposition of Hessian is required)</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_calcgradhess">calcGradHess</code></td>
<td>
<p>if n_samples=0 should Gradient and Hessian
still be calculated using closed form solutions?</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_b1">b1</code></td>
<td>
<p>(ADAM) 1st moment decay parameter (recommend 0.9) &quot;aka momentum&quot;</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_b2">b2</code></td>
<td>
<p>(ADAM) 2nd moment decay parameter (recommend 0.99 or 0.999)</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_step_size">step_size</code></td>
<td>
<p>(ADAM) step size for descent (recommend 0.001-0.003)</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_epsilon">epsilon</code></td>
<td>
<p>(ADAM) parameter to avoid divide by zero</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_eps_f">eps_f</code></td>
<td>
<p>(ADAM) normalized function improvement stopping criteria</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_eps_g">eps_g</code></td>
<td>
<p>(ADAM) normalized gradient magnitude stopping criteria</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_max_iter">max_iter</code></td>
<td>
<p>(ADAM) maximum number of iterations before stopping</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_verbose">verbose</code></td>
<td>
<p>(ADAM) if true will print stats for stopping criteria and
iteration number</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_verbose_rate">verbose_rate</code></td>
<td>
<p>(ADAM) rate to print verbose stats to screen</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_decomp_method">decomp_method</code></td>
<td>
<p>decomposition of hessian for Laplace approximation
'eigen' (more stable-slightly, slower) or 'cholesky' (less stable, faster, default)</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_optim_method">optim_method</code></td>
<td>
<p>(default:&quot;adam&quot;) or &quot;lbfgs&quot;</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_eigvalthresh">eigvalthresh</code></td>
<td>
<p>threshold for negative eigenvalues in
decomposition of negative inverse hessian (should be &lt;=0)</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_jitter">jitter</code></td>
<td>
<p>(default: 0) if &gt;=0 then adds that factor to diagonal of Hessian
before decomposition (to improve matrix conditioning)</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_multdirichletboot">multDirichletBoot</code></td>
<td>
<p>if &gt;0 (overrides laplace approximation) and samples
eta efficiently at MAP estimate from pseudo Multinomial-Dirichlet posterior.</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_usesylv">useSylv</code></td>
<td>
<p>(default: true) if N&lt;D-1 uses Sylvester Determinant Identity
to speed up calculation of log-likelihood and gradients.</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_ncores">ncores</code></td>
<td>
<p>(default:-1) number of cores to use, if ncores==-1 then
uses default from OpenMP typically to use all available cores.</p>
</td></tr>
<tr><td><code id="optimPibbleCollapsed_+3A_seed">seed</code></td>
<td>
<p>(random seed for Laplace approximation &ndash; integer)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notation: Let Z_j denote the J-th row of a matrix Z.
Model:
</p>
<p style="text-align: center;"><code class="reqn">Y_j \sim Multinomial(Pi_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Pi_j = Phi^{-1}(Eta_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Eta \sim T_{D-1, N}(upsilon, Theta*X, K, A)</code>
</p>

<p>Where A = I_N + X * Gamma * X', K is a (D-1)x(D-1) covariance
matrix, Gamma is a Q x Q covariance matrix, and Phi^-1 is ALRInv_D
transform.
</p>
<p>Gradient and Hessian calculations are fast as they are computed using closed
form solutions. That said, the Hessian matrix can be quite large
[N*(D-1) x N*(D-1)] and storage may be an issue.
</p>
<p>Note: Warnings about large negative eigenvalues can either signal
that the optimizer did not reach an optima or (more commonly in my experience)
that the prior / degrees of freedom for the covariance (given by parameters
<code>upsilon</code> and <code>KInv</code>) were too specific and at odds with the observed data.
If you get this warning try the following.
</p>

<ol>
<li><p> Try restarting the optimization using a different initial guess for eta
</p>
</li>
<li><p> Try decreasing (or even increasing )<code>step_size</code> (by increments of 0.001 or 0.002)
and increasing <code>max_iter</code> parameters in optimizer. Also can try
increasing <code>b1</code> to 0.99 and decreasing <code>eps_f</code> by a few orders
of magnitude
</p>
</li>
<li><p> Try relaxing prior assumptions regarding covariance matrix. (e.g., may want
to consider decreasing parameter <code>upsilon</code> closer to a minimum value of
D)
</p>
</li>
<li><p> Try adding small amount of jitter (e.g., set <code>jitter=1e-5</code>) to address
potential floating point errors.
</p>
</li></ol>



<h3>Value</h3>

<p>List containing (all with respect to found optima)
</p>

<ol>
<li><p> LogLik - Log Likelihood of collapsed model (up to proportionality constant)
</p>
</li>
<li><p> Gradient - (if <code>calcGradHess</code>=true)
</p>
</li>
<li><p> Hessian - (if <code>calcGradHess</code>=true) of the POSITIVE LOG POSTERIOR
</p>
</li>
<li><p> Pars - Parameter value of eta at optima
</p>
</li>
<li><p> Samples - (D-1) x N x n_samples array containing posterior samples of eta
based on Laplace approximation (if n_samples&gt;0)
</p>
</li>
<li><p> Timer - Vector of Execution Times
</p>
</li>
<li><p> logInvNegHessDet - the log determinant of the covariacne of the Laplace
approximation, useful for calculating marginal likelihood
</p>
</li></ol>



<h3>References</h3>

<p>S. Ruder (2016) <em>An overview of gradient descent
optimization algorithms</em>. arXiv 1609.04747
</p>
<p>JD Silverman K Roche, ZC Holmes, LA David, S Mukherjee.
<em>Bayesian Multinomial Logistic Normal Models through Marginally Latent Matrix-T Processes</em>.
2019, arXiv e-prints, arXiv:1903.11695
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncollapsePibble">uncollapsePibble</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim()

# Fit model for eta
fit &lt;- optimPibbleCollapsed(sim$Y, sim$upsilon, sim$Theta%*%sim$X, sim$KInv, 
                             sim$AInv, random_pibble_init(sim$Y))  
</code></pre>

<hr>
<h2 id='orthus_fit'>Interface to fit orthus models</h2><span id='topic+orthus_fit'></span><span id='topic+orthus'></span>

<h3>Description</h3>

<p>This function is largely a more user friendly wrapper around
<code><a href="#topic+optimPibbleCollapsed">optimPibbleCollapsed</a></code> and
<code><a href="#topic+uncollapsePibble">uncollapsePibble</a></code> for fitting orthus models.
See details for model specification.
Notation: <code>N</code> is number of samples, <code>P</code> is the number of dimensions
of observations in the second dataset,
<code>D</code> is number of multinomial categories, <code>Q</code> is number
of covariates, <code>iter</code> is the number of samples of <code>eta</code> (e.g.,
the parameter <code>n_samples</code> in the function
<code><a href="#topic+optimPibbleCollapsed">optimPibbleCollapsed</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthus(
  Y = NULL,
  Z = NULL,
  X = NULL,
  upsilon = NULL,
  Theta = NULL,
  Gamma = NULL,
  Xi = NULL,
  init = NULL,
  pars = c("Eta", "Lambda", "Sigma"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthus_fit_+3A_y">Y</code></td>
<td>
<p>D x N matrix of counts (if NULL uses priors only)</p>
</td></tr>
<tr><td><code id="orthus_fit_+3A_z">Z</code></td>
<td>
<p>P x N matrix of counts (if NULL uses priors only - must be present/absent
if Y is present/absent)</p>
</td></tr>
<tr><td><code id="orthus_fit_+3A_x">X</code></td>
<td>
<p>Q x N matrix of covariates (design matrix) (if NULL uses priors only, must
be present to sample Eta)</p>
</td></tr>
<tr><td><code id="orthus_fit_+3A_upsilon">upsilon</code></td>
<td>
<p>dof for inverse wishart prior (numeric must be &gt; D)
(default: D+3)</p>
</td></tr>
<tr><td><code id="orthus_fit_+3A_theta">Theta</code></td>
<td>
<p>(D-1+P) x Q matrix of prior mean for regression parameters
(default: matrix(0, D-1+P, Q))</p>
</td></tr>
<tr><td><code id="orthus_fit_+3A_gamma">Gamma</code></td>
<td>
<p>QxQ prior covariance matrix
(default: diag(Q))</p>
</td></tr>
<tr><td><code id="orthus_fit_+3A_xi">Xi</code></td>
<td>
<p>(D-1+P)x(D-1+P) prior covariance matrix
(default: ALR transform of diag(1)*(upsilon-D)/2 - this is
essentially iid on &quot;base scale&quot; using Aitchison terminology)</p>
</td></tr>
<tr><td><code id="orthus_fit_+3A_init">init</code></td>
<td>
<p>(D-1) x Q initialization for Eta for optimization</p>
</td></tr>
<tr><td><code id="orthus_fit_+3A_pars">pars</code></td>
<td>
<p>character vector of posterior parameters to return</p>
</td></tr>
<tr><td><code id="orthus_fit_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+optimPibbleCollapsed">optimPibbleCollapsed</a></code> and
<code><a href="#topic+uncollapsePibble">uncollapsePibble</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>the full model is given by:
</p>
<p style="text-align: center;"><code class="reqn">Y_j \sim Multinomial(Pi_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Pi_j = Phi^{-1}(Eta_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">cbind(Eta, Z) \sim MN_{D-1+P x N}(Lambda*X, Sigma, I_N)</code>
</p>

<p style="text-align: center;"><code class="reqn">Lambda \sim MN_{D-1+P x Q}(Theta, Sigma, Gamma)</code>
</p>

<p style="text-align: center;"><code class="reqn">Sigma \sim InvWish(upsilon, Xi)</code>
</p>

<p>Where Gamma is a Q x Q covariance matrix, and Phi^-1 is
ALRInv_D transform.
That is, the orthus model models the latent multinomial log-ratios (Eta) and
the observations of the second dataset jointly as a linear model. This allows
Sigma to also describe the covariation between the two datasets.
</p>
<p>Default behavior is to use MAP estimate for uncollaping the LTP
model if laplace approximation is not preformed.
</p>


<h3>Value</h3>

<p>an object of class pibblefit
</p>


<h3>References</h3>

<p>JD Silverman K Roche, ZC Holmes, LA David, S Mukherjee. 
Bayesian Multinomial Logistic Normal Models through Marginally Latent Matrix-T Processes. 
2019, arXiv e-prints, arXiv:1903.11695
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fido_transforms">fido_transforms</a></code> provide convenience methods for
transforming the representation of pibblefit objects (e.g., conversion to
proportions, alr, clr, or ilr coordinates.)
</p>
<p><code><a href="#topic+access_dims">access_dims</a></code> provides convenience methods for accessing
dimensions of pibblefit object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- orthus_sim()
fit &lt;- orthus(sim$Y, sim$Z, sim$X)
</code></pre>

<hr>
<h2 id='orthus_lr_transforms'>Log-Ratio transforms for orthus objects</h2><span id='topic+orthus_lr_transforms'></span><span id='topic+oglr'></span><span id='topic+oglrInv'></span><span id='topic+oalr'></span><span id='topic+oalrInv'></span><span id='topic+oilr'></span><span id='topic+oilrInv'></span><span id='topic+oclr'></span><span id='topic+oclrInv'></span>

<h3>Description</h3>

<p>Log-Ratio transforms for orthus objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oglr(x, s, V)

oglrInv(x, s, V)

oalr(x, s, d = NULL)

oalrInv(y, s, d = NULL)

oilr(x, s, V = NULL)

oilrInv(y, s, V = NULL)

oclr(x, s)

oclrInv(x, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthus_lr_transforms_+3A_x">x</code></td>
<td>
<p>orthus data array (e.g., first s rows are multinomial parameters or log-ratios)</p>
</td></tr>
<tr><td><code id="orthus_lr_transforms_+3A_s">s</code></td>
<td>
<p>first s rows of x are transformed</p>
</td></tr>
<tr><td><code id="orthus_lr_transforms_+3A_v">V</code></td>
<td>
<p>transformation matrix (defines transform)</p>
</td></tr>
<tr><td><code id="orthus_lr_transforms_+3A_d">d</code></td>
<td>
<p>for ALR, which component (integer position) to take as reference
(default is ncol(x)) for alrInv corresponds to column position in untransformed
matrix.</p>
</td></tr>
<tr><td><code id="orthus_lr_transforms_+3A_y">y</code></td>
<td>
<p>orthus data array (e.g., first s rows are multinomial parameters or log-ratios)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>

<hr>
<h2 id='orthus_sim'>Simulate simple orthus dataset and priors (for testing)</h2><span id='topic+orthus_sim'></span>

<h3>Description</h3>

<p>Simulate simple orthus dataset and priors (for testing)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthus_sim(
  D = 10,
  P = 10,
  N = 30,
  Q = 2,
  use_names = TRUE,
  true_priors = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthus_sim_+3A_d">D</code></td>
<td>
<p>number of multinomial categories</p>
</td></tr>
<tr><td><code id="orthus_sim_+3A_p">P</code></td>
<td>
<p>number of dimensions of second dataset Z</p>
</td></tr>
<tr><td><code id="orthus_sim_+3A_n">N</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="orthus_sim_+3A_q">Q</code></td>
<td>
<p>number of covariates (first one is an intercept, must be &gt; 1)</p>
</td></tr>
<tr><td><code id="orthus_sim_+3A_use_names">use_names</code></td>
<td>
<p>should samples, covariates, and categories be named</p>
</td></tr>
<tr><td><code id="orthus_sim_+3A_true_priors">true_priors</code></td>
<td>
<p>should Xi and upsilon be chosen to have mean at true 
simulated value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- orthus_sim()
</code></pre>

<hr>
<h2 id='orthus_tidy_samples'>Convert orthus samples of Eta Lambda and Sigma to tidy format</h2><span id='topic+orthus_tidy_samples'></span>

<h3>Description</h3>

<p>Combines them all into a single tibble, see example for formatting and 
column headers. Primarily designed to be used by 
<code><a href="#topic+summary.orthusfit">summary.orthusfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthus_tidy_samples(m, use_names = FALSE, as_factor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthus_tidy_samples_+3A_m">m</code></td>
<td>
<p>an object of class orthusfit</p>
</td></tr>
<tr><td><code id="orthus_tidy_samples_+3A_use_names">use_names</code></td>
<td>
<p>should dimension indices be replaced by
dimension names if provided in data used to fit pibble model.</p>
</td></tr>
<tr><td><code id="orthus_tidy_samples_+3A_as_factor">as_factor</code></td>
<td>
<p>if use_names should names be returned as factor?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- orthus_sim()
fit &lt;- orthus(sim$Y, sim$Z, sim$X)
fit_tidy &lt;- orthus_tidy_samples(fit, use_names=TRUE)
head(fit_tidy)
</code></pre>

<hr>
<h2 id='orthusfit'>Create orthusfit object</h2><span id='topic+orthusfit'></span>

<h3>Description</h3>

<p>Create orthusfit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthusfit(
  D,
  N,
  Q,
  P,
  coord_system,
  iter = NULL,
  alr_base = NULL,
  ilr_base = NULL,
  Eta = NULL,
  Lambda = NULL,
  Sigma = NULL,
  Sigma_default = NULL,
  Z = NULL,
  Y = NULL,
  X = NULL,
  upsilon = NULL,
  Theta = NULL,
  Xi = NULL,
  Xi_default = NULL,
  Gamma = NULL,
  init = NULL,
  names_categories = NULL,
  names_samples = NULL,
  names_Zdimensions = NULL,
  names_covariates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthusfit_+3A_d">D</code></td>
<td>
<p>number of multinomial categories</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_n">N</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_q">Q</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_p">P</code></td>
<td>
<p>Dimension of second dataset (e.g., nrows(Z) )</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_coord_system">coord_system</code></td>
<td>
<p>coordinate system objects are represented in (options 
include &quot;alr&quot;, &quot;clr&quot;, &quot;ilr&quot;, and &quot;proportions&quot;)</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_iter">iter</code></td>
<td>
<p>number of posterior samples</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_alr_base">alr_base</code></td>
<td>
<p>integer category used as reference 
(required if coord_system==&quot;alr&quot;)</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_ilr_base">ilr_base</code></td>
<td>
<p>(D x D-1) contrast matrix (required if coord_system==&quot;ilr&quot;)</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_eta">Eta</code></td>
<td>
<p>Array of samples of Eta</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_lambda">Lambda</code></td>
<td>
<p>Array of samples of Lambda</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_sigma">Sigma</code></td>
<td>
<p>Array of samples of Sigma (null if coord_system==&quot;proportions&quot;)</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_sigma_default">Sigma_default</code></td>
<td>
<p>Array of samples of Sigma in alr base D, used if 
coord_system==&quot;proportions&quot;</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_z">Z</code></td>
<td>
<p>PxN matrix of real valued observations</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_y">Y</code></td>
<td>
<p>DxN matrix of observed counts</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_x">X</code></td>
<td>
<p>QxN design matrix</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_upsilon">upsilon</code></td>
<td>
<p>scalar prior dof of inverse wishart prior</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_theta">Theta</code></td>
<td>
<p>prior mean of Lambda</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_xi">Xi</code></td>
<td>
<p>Matrix of prior covariance for inverse wishart 
(null if coord_system==&quot;proportions&quot;)</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_xi_default">Xi_default</code></td>
<td>
<p>Matrix of prior covariance for inverse wishart in alr 
base D (used if coord_system==&quot;proportions&quot;)</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_gamma">Gamma</code></td>
<td>
<p>QxQ covariance matrix prior for Lambda</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_init">init</code></td>
<td>
<p>matrix initial guess for Lambda used for optimization</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_names_categories">names_categories</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_names_samples">names_samples</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_names_zdimensions">names_Zdimensions</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="orthusfit_+3A_names_covariates">names_covariates</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class orthusfit
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pibble">pibble</a></code>
</p>

<hr>
<h2 id='pcrbias_mock'>Data from Silverman et al. (2019) bioRxiv</h2><span id='topic+pcrbias_mock'></span>

<h3>Description</h3>

<p>Mock communities and calibration samples created for measuring and validating model
of PCR bias. This data has been preprocessed as in the original manuscript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pcrbias_mock)
</code></pre>


<h3>Format</h3>

<p>an matrix Y (counts for each community member) and a data.frame metadata
</p>


<h3>References</h3>

<p>Justin D. Silverman, Rachael J. Bloom, Sharon Jiang, Heather K. Durand, Sayan Mukherjee, 
Lawrence A. David. (2019) Measuring and Mitigating PCR Bias in Microbiome Data. 
bioRxiv 604025; doi: https://doi.org/10.1101/604025
</p>

<hr>
<h2 id='pibble_fit'>Interface to fit pibble models</h2><span id='topic+pibble_fit'></span><span id='topic+pibble'></span><span id='topic+refit.pibblefit'></span>

<h3>Description</h3>

<p>This function is largely a more user friendly wrapper around
<code><a href="#topic+optimPibbleCollapsed">optimPibbleCollapsed</a></code> and
<code><a href="#topic+uncollapsePibble">uncollapsePibble</a></code>.
See details for model specification.
Notation: <code>N</code> is number of samples,
<code>D</code> is number of multinomial categories, <code>Q</code> is number
of covariates, <code>iter</code> is the number of samples of <code>eta</code> (e.g.,
the parameter <code>n_samples</code> in the function
<code><a href="#topic+optimPibbleCollapsed">optimPibbleCollapsed</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pibble(
  Y = NULL,
  X = NULL,
  upsilon = NULL,
  Theta = NULL,
  Gamma = NULL,
  Xi = NULL,
  init = NULL,
  pars = c("Eta", "Lambda", "Sigma"),
  ...
)

## S3 method for class 'pibblefit'
refit(m, pars = c("Eta", "Lambda", "Sigma"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pibble_fit_+3A_y">Y</code></td>
<td>
<p>D x N matrix of counts (if NULL uses priors only)</p>
</td></tr>
<tr><td><code id="pibble_fit_+3A_x">X</code></td>
<td>
<p>Q x N matrix of covariates (design matrix) (if NULL uses priors only, must
be present to sample Eta)</p>
</td></tr>
<tr><td><code id="pibble_fit_+3A_upsilon">upsilon</code></td>
<td>
<p>dof for inverse wishart prior (numeric must be &gt; D)
(default: D+3)</p>
</td></tr>
<tr><td><code id="pibble_fit_+3A_theta">Theta</code></td>
<td>
<p>(D-1) x Q matrix of prior mean for regression parameters
(default: matrix(0, D-1, Q))</p>
</td></tr>
<tr><td><code id="pibble_fit_+3A_gamma">Gamma</code></td>
<td>
<p>QxQ prior covariance matrix
(default: diag(Q))</p>
</td></tr>
<tr><td><code id="pibble_fit_+3A_xi">Xi</code></td>
<td>
<p>(D-1)x(D-1) prior covariance matrix
(default: ALR transform of diag(1)*(upsilon-D)/2 - this is
essentially iid on &quot;base scale&quot; using Aitchison terminology)</p>
</td></tr>
<tr><td><code id="pibble_fit_+3A_init">init</code></td>
<td>
<p>(D-1) x Q initialization for Eta for optimization</p>
</td></tr>
<tr><td><code id="pibble_fit_+3A_pars">pars</code></td>
<td>
<p>character vector of posterior parameters to return</p>
</td></tr>
<tr><td><code id="pibble_fit_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+optimPibbleCollapsed">optimPibbleCollapsed</a></code> and
<code><a href="#topic+uncollapsePibble">uncollapsePibble</a></code></p>
</td></tr>
<tr><td><code id="pibble_fit_+3A_m">m</code></td>
<td>
<p>object of class pibblefit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the full model is given by:
</p>
<p style="text-align: center;"><code class="reqn">Y_j \sim Multinomial(Pi_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Pi_j = Phi^{-1}(Eta_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Eta \sim MN_{D-1 x N}(Lambda*X, Sigma, I_N)</code>
</p>

<p style="text-align: center;"><code class="reqn">Lambda \sim MN_{D-1 x Q}(Theta, Sigma, Gamma)</code>
</p>

<p style="text-align: center;"><code class="reqn">Sigma \sim InvWish(upsilon, Xi)</code>
</p>

<p>Where Gamma is a Q x Q covariance matrix, and Phi^-1 is
ALRInv_D transform.
</p>
<p>Default behavior is to use MAP estimate for uncollaping the LTP
model if laplace approximation is not preformed.
</p>


<h3>Value</h3>

<p>an object of class pibblefit
</p>


<h3>References</h3>

<p>JD Silverman K Roche, ZC Holmes, LA David, S Mukherjee. 
Bayesian Multinomial Logistic Normal Models through Marginally Latent Matrix-T Processes. 
2019, arXiv e-prints, arXiv:1903.11695
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fido_transforms">fido_transforms</a></code> provide convenience methods for
transforming the representation of pibblefit objects (e.g., conversion to
proportions, alr, clr, or ilr coordinates.)
</p>
<p><code><a href="#topic+access_dims">access_dims</a></code> provides convenience methods for accessing
dimensions of pibblefit object
</p>
<p>Generic functions including <code><a href="#topic+summary.pibblefit">summary</a></code>,
<code><a href="#topic+print.pibblefit">print</a></code>,
<code><a href="#topic+coef.pibblefit">coef</a></code>,
<code><a href="#topic+as.list.pibblefit">as.list</a></code>,
<code><a href="#topic+predict.pibblefit">predict</a></code>,
<code><a href="#topic+name.pibblefit">name</a></code>, and
<code><a href="#topic+sample_prior.pibblefit">sample_prior</a></code>
<code><a href="#topic+name_dims">name_dims</a></code>
</p>
<p>Plotting functions provided by <code><a href="#topic+plot.pibblefit">plot</a></code>
and <code><a href="#topic+ppc.pibblefit">ppc</a></code> (posterior predictive checks)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim()
fit &lt;- pibble(sim$Y, sim$X)
</code></pre>

<hr>
<h2 id='pibble_sim'>Simulate simple pibble dataset and priors (for testing)</h2><span id='topic+pibble_sim'></span>

<h3>Description</h3>

<p>Simulate simple pibble dataset and priors (for testing)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pibble_sim(D = 10, N = 30, Q = 2, use_names = TRUE, true_priors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pibble_sim_+3A_d">D</code></td>
<td>
<p>number of multinomial categories</p>
</td></tr>
<tr><td><code id="pibble_sim_+3A_n">N</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="pibble_sim_+3A_q">Q</code></td>
<td>
<p>number of covariates (first one is an intercept, must be &gt; 1)</p>
</td></tr>
<tr><td><code id="pibble_sim_+3A_use_names">use_names</code></td>
<td>
<p>should samples, covariates, and categories be named</p>
</td></tr>
<tr><td><code id="pibble_sim_+3A_true_priors">true_priors</code></td>
<td>
<p>should Xi and upsilon be chosen to have mean at true 
simulated value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim()
</code></pre>

<hr>
<h2 id='pibble_tidy_samples'>Convert pibble samples of Eta Lambda and Sigma to tidy format</h2><span id='topic+pibble_tidy_samples'></span>

<h3>Description</h3>

<p>Combines them all into a single tibble, see example for formatting and 
column headers. Primarily designed to be used by 
<code><a href="#topic+summary.pibblefit">summary.pibblefit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pibble_tidy_samples(m, use_names = FALSE, as_factor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pibble_tidy_samples_+3A_m">m</code></td>
<td>
<p>an object of class pibblefit</p>
</td></tr>
<tr><td><code id="pibble_tidy_samples_+3A_use_names">use_names</code></td>
<td>
<p>should dimension indices be replaced by
dimension names if provided in data used to fit pibble model.</p>
</td></tr>
<tr><td><code id="pibble_tidy_samples_+3A_as_factor">as_factor</code></td>
<td>
<p>if use_names should names be returned as factor?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim()
fit &lt;- pibble(sim$Y, sim$X)
fit_tidy &lt;- pibble_tidy_samples(fit, use_names=TRUE)
head(fit_tidy)
</code></pre>

<hr>
<h2 id='pibblefit'>Create pibblefit object</h2><span id='topic+pibblefit'></span>

<h3>Description</h3>

<p>Create pibblefit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pibblefit(
  D,
  N,
  Q,
  coord_system,
  iter = NULL,
  alr_base = NULL,
  ilr_base = NULL,
  Eta = NULL,
  Lambda = NULL,
  Sigma = NULL,
  Sigma_default = NULL,
  Y = NULL,
  X = NULL,
  upsilon = NULL,
  Theta = NULL,
  Xi = NULL,
  Xi_default = NULL,
  Gamma = NULL,
  init = NULL,
  names_categories = NULL,
  names_samples = NULL,
  names_covariates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pibblefit_+3A_d">D</code></td>
<td>
<p>number of multinomial categories</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_n">N</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_q">Q</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_coord_system">coord_system</code></td>
<td>
<p>coordinate system objects are represented in (options 
include &quot;alr&quot;, &quot;clr&quot;, &quot;ilr&quot;, and &quot;proportions&quot;)</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_iter">iter</code></td>
<td>
<p>number of posterior samples</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_alr_base">alr_base</code></td>
<td>
<p>integer category used as reference 
(required if coord_system==&quot;alr&quot;)</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_ilr_base">ilr_base</code></td>
<td>
<p>(D x D-1) contrast matrix (required if coord_system==&quot;ilr&quot;)</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_eta">Eta</code></td>
<td>
<p>Array of samples of Eta</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_lambda">Lambda</code></td>
<td>
<p>Array of samples of Lambda</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_sigma">Sigma</code></td>
<td>
<p>Array of samples of Sigma (null if coord_system==&quot;proportions&quot;)</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_sigma_default">Sigma_default</code></td>
<td>
<p>Array of samples of Sigma in alr base D, used if 
coord_system==&quot;proportions&quot;</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_y">Y</code></td>
<td>
<p>DxN matrix of observed counts</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_x">X</code></td>
<td>
<p>QxN design matrix</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_upsilon">upsilon</code></td>
<td>
<p>scalar prior dof of inverse wishart prior</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_theta">Theta</code></td>
<td>
<p>prior mean of Lambda</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_xi">Xi</code></td>
<td>
<p>Matrix of prior covariance for inverse wishart 
(null if coord_system==&quot;proportions&quot;)</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_xi_default">Xi_default</code></td>
<td>
<p>Matrix of prior covariance for inverse wishart in alr 
base D (used if coord_system==&quot;proportions&quot;)</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_gamma">Gamma</code></td>
<td>
<p>QxQ covariance matrix prior for Lambda</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_init">init</code></td>
<td>
<p>matrix initial guess for Lambda used for optimization</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_names_categories">names_categories</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_names_samples">names_samples</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="pibblefit_+3A_names_covariates">names_covariates</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class pibblefit
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pibble">pibble</a></code>
</p>

<hr>
<h2 id='plot.pibblefit'>Plot Summaries of Posterior Distribution of pibblefit Parameters</h2><span id='topic+plot.pibblefit'></span>

<h3>Description</h3>

<p>Plot Summaries of Posterior Distribution of pibblefit Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pibblefit_+3A_x">x</code></td>
<td>
<p>an object of class pibblefit</p>
</td></tr>
<tr><td><code id="plot.pibblefit_+3A_...">...</code></td>
<td>
<p>other arguments passed to plot.pibblefit (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Other arguments:
</p>

<ul>
<li><p> 'par' parameter to plot (options: Lambda, Eta, and Sigma) 
(default=&quot;Lambda&quot;)
</p>
</li>
<li><p> 'focus.cov' vector of covariates to include in plot (plots all if NULL)
</p>
</li>
<li><p> 'focus.coord' vector of coordinates to include in plot (plots all if NULL)
</p>
</li>
<li><p> 'focus.sample' vector of samples to include in plot (plots all if NULL)
</p>
</li>
<li><p> 'use_names' if TRUE, uses dimension names found in data as plot labels
rather than using dimension integer indices. 
</p>
</li></ul>



<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim(N=10, D=4, Q=3)
fit &lt;- pibble(sim$Y, sim$X)
plot(fit, par="Lambda")
plot(fit, par="Sigma")
</code></pre>

<hr>
<h2 id='ppc'>Generic method for visualizing posterior predictive checks</h2><span id='topic+ppc'></span>

<h3>Description</h3>

<p>Generic method for visualizing posterior predictive checks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppc(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppc_+3A_m">m</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="ppc_+3A_...">...</code></td>
<td>
<p>other arguments passed that control visualization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot
</p>

<hr>
<h2 id='ppc_summary.pibblefit'>Generic Method to Plot Posterior Predictive Summaries</h2><span id='topic+ppc_summary.pibblefit'></span><span id='topic+ppc_summary'></span>

<h3>Description</h3>

<p>Generic Method to Plot Posterior Predictive Summaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
ppc_summary(m, from_scratch = FALSE, ...)

ppc_summary(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppc_summary.pibblefit_+3A_m">m</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="ppc_summary.pibblefit_+3A_from_scratch">from_scratch</code></td>
<td>
<p>should predictions of Y come from fitted Eta or from 
predictions of Eta from posterior of Lambda? (default: false)</p>
</td></tr>
<tr><td><code id="ppc_summary.pibblefit_+3A_...">...</code></td>
<td>
<p>other arguments to pass</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>

<hr>
<h2 id='ppc.pibblefit'>Visualization of Posterior Predictive Check of fit model</h2><span id='topic+ppc.pibblefit'></span>

<h3>Description</h3>

<p>Visualization of Posterior Predictive Check of fit model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
ppc(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppc.pibblefit_+3A_m">m</code></td>
<td>
<p>an object of class pibblefit</p>
</td></tr>
<tr><td><code id="ppc.pibblefit_+3A_...">...</code></td>
<td>
<p>other options passed to ppc (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ppc.pibblefit accepts the following additional arguments:
</p>

<ul>
<li><p> &quot;type&quot; type of plot (options &quot;lines&quot;,  &quot;points&quot;, &quot;bounds&quot;)
</p>
</li>
<li><p> &quot;iter&quot; number of samples from posterior predictive distribution to plot
(currently must be &lt;= m$iter) if type==&quot;lines&quot; default is 50, if type==&quot;ribbon&quot;
default is to use all available iterations. 
</p>
</li>
<li><p> &quot;from_scratch&quot; should predictions of Y come from fitted Eta or from 
predictions of Eta from posterior of Lambda? (default: false)
</p>
</li></ul>



<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim()
fit &lt;- pibble(sim$Y, sim$X)
ppc(fit)

</code></pre>

<hr>
<h2 id='predict'>Predict response from new data</h2><span id='topic+predict'></span>

<h3>Description</h3>

<p>Predict response from new data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>An object of class pibblefit</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>Other objects to be passed to the 'predict' function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(if summary==FALSE) array D x N x iter; (if summary==TRUE) 
tibble with calculated posterior summaries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim()
fit &lt;- pibble(sim$Y, sim$X)
predict(fit)[,,1:2] # just show 2 samples
</code></pre>

<hr>
<h2 id='predict.bassetfit'>Predict using basset</h2><span id='topic+predict.bassetfit'></span>

<h3>Description</h3>

<p>Predict using basset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bassetfit'
predict(
  object,
  newdata,
  response = "Lambda",
  size = NULL,
  use_names = TRUE,
  summary = FALSE,
  iter = NULL,
  from_scratch = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bassetfit_+3A_object">object</code></td>
<td>
<p>An object of class pibblefit</p>
</td></tr>
<tr><td><code id="predict.bassetfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional matrix for which to evaluate prediction.</p>
</td></tr>
<tr><td><code id="predict.bassetfit_+3A_response">response</code></td>
<td>
<p>Options = &quot;Lambda&quot;:Mean of regression, &quot;Eta&quot;, &quot;Y&quot;: counts</p>
</td></tr>
<tr><td><code id="predict.bassetfit_+3A_size">size</code></td>
<td>
<p>the number of counts per sample if response=&quot;Y&quot; (as vector or matrix), 
default if newdata=NULL and response=&quot;Y&quot; is to use colsums of m$Y. Otherwise
uses median colsums of object$Y as default. If passed as a matrix should have dimensions
ncol(newdata) x iter.</p>
</td></tr>
<tr><td><code id="predict.bassetfit_+3A_use_names">use_names</code></td>
<td>
<p>if TRUE apply names to output</p>
</td></tr>
<tr><td><code id="predict.bassetfit_+3A_summary">summary</code></td>
<td>
<p>if TRUE, posterior summary of predictions are returned rather
than samples</p>
</td></tr>
<tr><td><code id="predict.bassetfit_+3A_iter">iter</code></td>
<td>
<p>number of iterations to return if NULL uses object$iter</p>
</td></tr>
<tr><td><code id="predict.bassetfit_+3A_from_scratch">from_scratch</code></td>
<td>
<p>should predictions of Y come from fitted Eta or from 
predictions of Eta from posterior of Lambda? (default: false)</p>
</td></tr>
<tr><td><code id="predict.bassetfit_+3A_...">...</code></td>
<td>
<p>other arguments passed to summarise_posterior</p>
</td></tr>
</table>


<h3>Details</h3>

<p>currently only implemented for pibblefit objects in coord_system &quot;default&quot;
&quot;alr&quot;, or &quot;ilr&quot;.
</p>


<h3>Value</h3>

<p>(if summary==FALSE) array D x N x iter; (if summary==TRUE) 
tibble with calculated posterior summaries
</p>

<hr>
<h2 id='predict.pibblefit'>Predict response from new data</h2><span id='topic+predict.pibblefit'></span>

<h3>Description</h3>

<p>Predict response from new data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
predict(
  object,
  newdata = NULL,
  response = "LambdaX",
  size = NULL,
  use_names = TRUE,
  summary = FALSE,
  iter = NULL,
  from_scratch = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.pibblefit_+3A_object">object</code></td>
<td>
<p>An object of class pibblefit</p>
</td></tr>
<tr><td><code id="predict.pibblefit_+3A_newdata">newdata</code></td>
<td>
<p>An optional matrix for which to evaluate predictions. If NULL
(default), the original data of the model is used.</p>
</td></tr>
<tr><td><code id="predict.pibblefit_+3A_response">response</code></td>
<td>
<p>Options = &quot;LambdaX&quot;:Mean of regression, &quot;Eta&quot;, &quot;Y&quot;: counts</p>
</td></tr>
<tr><td><code id="predict.pibblefit_+3A_size">size</code></td>
<td>
<p>the number of counts per sample if response=&quot;Y&quot; (as vector or matrix), 
default if newdata=NULL and response=&quot;Y&quot; is to use colsums of m$Y. Otherwise
uses median colsums of m$Y as default. If passed as a matrix should have dimensions
ncol(newdata) x iter.</p>
</td></tr>
<tr><td><code id="predict.pibblefit_+3A_use_names">use_names</code></td>
<td>
<p>if TRUE apply names to output</p>
</td></tr>
<tr><td><code id="predict.pibblefit_+3A_summary">summary</code></td>
<td>
<p>if TRUE, posterior summary of predictions are returned rather
than samples</p>
</td></tr>
<tr><td><code id="predict.pibblefit_+3A_iter">iter</code></td>
<td>
<p>number of iterations to return if NULL uses object$iter</p>
</td></tr>
<tr><td><code id="predict.pibblefit_+3A_from_scratch">from_scratch</code></td>
<td>
<p>should predictions of Y come from fitted Eta or from 
predictions of Eta from posterior of Lambda? (default: false)</p>
</td></tr>
<tr><td><code id="predict.pibblefit_+3A_...">...</code></td>
<td>
<p>other arguments passed to summarise_posterior</p>
</td></tr>
</table>


<h3>Details</h3>

<p>currently only implemented for pibblefit objects in coord_system &quot;default&quot;
&quot;alr&quot;, or &quot;ilr&quot;.
</p>


<h3>Value</h3>

<p>(if summary==FALSE) array D x N x iter; (if summary==TRUE) 
tibble with calculated posterior summaries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim()
fit &lt;- pibble(sim$Y, sim$X)
predict(fit)[,,1:2] # just show 2 samples
</code></pre>

<hr>
<h2 id='print'>Print dimensions and coordinate system information for an orthusfit or pibblefit object.</h2><span id='topic+print'></span>

<h3>Description</h3>

<p>Print dimensions and coordinate system information for an orthusfit or pibblefit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>an object of class pibblefit or orthusfit</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>other arguments to pass to summary function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No direct value, but a print out
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim()
fit &lt;- pibble(sim$Y, sim$X)
print(fit)

</code></pre>

<hr>
<h2 id='print.orthusfit'>Print dimensions and coordinate system information for orthusfit object.</h2><span id='topic+print.orthusfit'></span>

<h3>Description</h3>

<p>Print dimensions and coordinate system information for orthusfit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orthusfit'
print(x, summary = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.orthusfit_+3A_x">x</code></td>
<td>
<p>an object of class orthusfit</p>
</td></tr>
<tr><td><code id="print.orthusfit_+3A_summary">summary</code></td>
<td>
<p>if true also calculates and prints summary</p>
</td></tr>
<tr><td><code id="print.orthusfit_+3A_...">...</code></td>
<td>
<p>other arguments to pass to summary function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No direct return, prints out summary
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.orthusfit">summary.orthusfit</a></code> summarizes posterior intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- orthus_sim()
fit &lt;- orthus(sim$Y, sim$Z, sim$X)
print(fit)
</code></pre>

<hr>
<h2 id='print.pibblefit'>Print dimensions and coordinate system information for pibblefit object.</h2><span id='topic+print.pibblefit'></span>

<h3>Description</h3>

<p>Print dimensions and coordinate system information for pibblefit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
print(x, summary = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pibblefit_+3A_x">x</code></td>
<td>
<p>an object of class pibblefit</p>
</td></tr>
<tr><td><code id="print.pibblefit_+3A_summary">summary</code></td>
<td>
<p>if true also calculates and prints summary</p>
</td></tr>
<tr><td><code id="print.pibblefit_+3A_...">...</code></td>
<td>
<p>other arguments to pass to summary function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No direct return, prints out summary
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.pibblefit">summary.pibblefit</a></code> summarizes posterior intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim()
fit &lt;- pibble(sim$Y, sim$X)
print(fit)

</code></pre>

<hr>
<h2 id='random_pibble_init'>Provide random initialization for pibble model</h2><span id='topic+random_pibble_init'></span>

<h3>Description</h3>

<p>Randomly initializes based on ALR transform of counts
plus random pseudocounts uniformily distributed between 
0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_pibble_init(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_pibble_init_+3A_y">Y</code></td>
<td>
<p>matrix (D x N) of counts</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notation: <code>N</code> is number of samples and
<code>D</code> is number of multinomial categories
</p>


<h3>Value</h3>

<p>(D-1) x N matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- matrix(sample(1:100, 100), 10, 10)
random_pibble_init(Y)
</code></pre>

<hr>
<h2 id='refit'>Generic method for fitting model from passed model fit object</h2><span id='topic+refit'></span>

<h3>Description</h3>

<p>Generic method for fitting model from passed model fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refit(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refit_+3A_m">m</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="refit_+3A_...">...</code></td>
<td>
<p>other arguments passed that control fitting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of the same class as <code>m</code>
</p>

<hr>
<h2 id='req'>Generic method for ensuring object contains required elements</h2><span id='topic+req'></span>

<h3>Description</h3>

<p>Intended to be called internally by package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req(m, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="req_+3A_m">m</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="req_+3A_r">r</code></td>
<td>
<p>vector of elements to test for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>throws error if required element is not present
</p>

<hr>
<h2 id='req.maltipoofit'>require elements to be non-null in pibblefit or throw error</h2><span id='topic+req.maltipoofit'></span>

<h3>Description</h3>

<p>require elements to be non-null in pibblefit or throw error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maltipoofit'
req(m, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="req.maltipoofit_+3A_m">m</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="req.maltipoofit_+3A_r">r</code></td>
<td>
<p>vector of elements to test for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Throws an error if null
</p>

<hr>
<h2 id='req.orthusfit'>require elements to be non-null in orthusfit or throw error</h2><span id='topic+req.orthusfit'></span>

<h3>Description</h3>

<p>require elements to be non-null in orthusfit or throw error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orthusfit'
req(m, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="req.orthusfit_+3A_m">m</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="req.orthusfit_+3A_r">r</code></td>
<td>
<p>vector of elements to test for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, throws an error if NULL
</p>

<hr>
<h2 id='req.pibblefit'>require elements to be non-null in pibblefit or throw error</h2><span id='topic+req.pibblefit'></span>

<h3>Description</h3>

<p>require elements to be non-null in pibblefit or throw error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
req(m, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="req.pibblefit_+3A_m">m</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="req.pibblefit_+3A_r">r</code></td>
<td>
<p>vector of elements to test for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, throws an error if NULL
</p>

<hr>
<h2 id='sample_prior'>Generic method for sampling from prior distribution of object</h2><span id='topic+sample_prior'></span>

<h3>Description</h3>

<p>Generic method for sampling from prior distribution of object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_prior(m, n_samples = 2000L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_prior_+3A_m">m</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="sample_prior_+3A_n_samples">n_samples</code></td>
<td>
<p>number of samples to produce</p>
</td></tr>
<tr><td><code id="sample_prior_+3A_...">...</code></td>
<td>
<p>other arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of the same class
</p>

<hr>
<h2 id='sample_prior.pibblefit'>Sample from the prior distribution of pibblefit object</h2><span id='topic+sample_prior.pibblefit'></span>

<h3>Description</h3>

<p>Note this can be used to sample from prior and then predict can
be called to get counts or LambdaX (<code><a href="#topic+predict.pibblefit">predict.pibblefit</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
sample_prior(
  m,
  n_samples = 2000L,
  pars = c("Eta", "Lambda", "Sigma"),
  use_names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_prior.pibblefit_+3A_m">m</code></td>
<td>
<p>object of class pibblefit</p>
</td></tr>
<tr><td><code id="sample_prior.pibblefit_+3A_n_samples">n_samples</code></td>
<td>
<p>number of samples to produce</p>
</td></tr>
<tr><td><code id="sample_prior.pibblefit_+3A_pars">pars</code></td>
<td>
<p>parameters to sample</p>
</td></tr>
<tr><td><code id="sample_prior.pibblefit_+3A_use_names">use_names</code></td>
<td>
<p>should names be used if available</p>
</td></tr>
<tr><td><code id="sample_prior.pibblefit_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Could be greatly speed up in the future if needed by sampling
directly from cholesky form of inverse wishart (currently implemented as 
header in this library - see MatDist.h).
</p>


<h3>Value</h3>

<p>A pibblefit object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample prior of already fitted  pibblefit object
sim &lt;- pibble_sim()
attach(sim)
fit &lt;- pibble(Y, X)
head(sample_prior(fit))

# Sample prior as part of model fitting
m &lt;- pibblefit(N=as.integer(sim$N), D=as.integer(sim$D), Q=as.integer(sim$Q), 
                iter=2000L, upsilon=upsilon, 
                Xi=Xi, Gamma=Gamma, Theta=Theta, X=X, 
                coord_system="alr", alr_base=D)
m &lt;- sample_prior(m)
plot(m) # plot prior distribution (defaults to parameter Lambda) 
</code></pre>

<hr>
<h2 id='store_coord'>Holds information on coordinates system to later be reapplied</h2><span id='topic+store_coord'></span><span id='topic+reapply_coord'></span>

<h3>Description</h3>

<p><code>store_coord</code> stores coordinate information for pibblefit object
and can be reapplied with function <code>reapply_coord</code>. Some coordinate
systems are not useful for computation and this makes it simple keep 
returned object from computations in the same coordinate system as the input. 
(Likely most useful inside of a package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store_coord(m)

reapply_coord(m, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="store_coord_+3A_m">m</code></td>
<td>
<p>object of class pibblefit</p>
</td></tr>
<tr><td><code id="store_coord_+3A_l">l</code></td>
<td>
<p>object returned by function <code>store_coord</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>store_coord</code> list with important information to identify c
coordinate system of pibblefit object. <code>reapply_coord</code> pibblefit object
in coordinate system previously stored.
</p>

<hr>
<h2 id='summarise_posterior'>Shortcut for summarize variable with quantiles and mean</h2><span id='topic+summarise_posterior'></span>

<h3>Description</h3>

<p>Shortcut for summarize variable with quantiles and mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_posterior(data, var, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_posterior_+3A_data">data</code></td>
<td>
<p>tidy data frame</p>
</td></tr>
<tr><td><code id="summarise_posterior_+3A_var">var</code></td>
<td>
<p>variable name (unquoted) to be summarised</p>
</td></tr>
<tr><td><code id="summarise_posterior_+3A_...">...</code></td>
<td>
<p>other expressions to pass to summarise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notation: <code>pX</code> refers to the <code>X</code>% quantile
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame("a"=sample(1:10, 50, TRUE),
                "b"=rnorm(50))

# Summarize posterior for b over grouping of a and also calcuate
# minmum of b (in addition to normal statistics returned)
d &lt;- dplyr::group_by(d, a)
summarise_posterior(d, b, mean.b = mean(b), min=min(b))
</code></pre>

<hr>
<h2 id='summary'>Summarise pibblefit or orthusfit object and print posterior quantiles</h2><span id='topic+summary'></span>

<h3>Description</h3>

<p>Default calculates median, mean, 50% and 95% credible interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>an object of class pibblefit or orthusfit</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>other objects to be passed to 'summary.pibblefit' or 'summary.orthusfit'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list if class is 'pibblefit' or 'orthusfit'
</p>

<hr>
<h2 id='summary.orthusfit'>Summarise orthusfit object and print posterior quantiles</h2><span id='topic+summary.orthusfit'></span>

<h3>Description</h3>

<p>Default calculates median, mean, 50% and 95% credible interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orthusfit'
summary(
  object,
  pars = NULL,
  use_names = TRUE,
  as_factor = FALSE,
  gather_prob = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.orthusfit_+3A_object">object</code></td>
<td>
<p>an object of class orthusfit</p>
</td></tr>
<tr><td><code id="summary.orthusfit_+3A_pars">pars</code></td>
<td>
<p>character vector (default: c(&quot;Eta&quot;, &quot;Lambda&quot;, &quot;Sigma&quot;))</p>
</td></tr>
<tr><td><code id="summary.orthusfit_+3A_use_names">use_names</code></td>
<td>
<p>should summary replace dimension indices with orthusfit 
names if names Y and X were named in call to <code><a href="#topic+orthus">orthus</a></code></p>
</td></tr>
<tr><td><code id="summary.orthusfit_+3A_as_factor">as_factor</code></td>
<td>
<p>if use_names and as_factor then returns names as factors 
(useful for maintaining orderings when plotting)</p>
</td></tr>
<tr><td><code id="summary.orthusfit_+3A_gather_prob">gather_prob</code></td>
<td>
<p>if TRUE then prints quantiles in long format rather than 
wide (useful for some plotting functions)</p>
</td></tr>
<tr><td><code id="summary.orthusfit_+3A_...">...</code></td>
<td>
<p>other expressions to pass to summarise (using name 'val' unquoted is 
probably what you want)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>

<hr>
<h2 id='summary.pibblefit'>Summarise pibblefit object and print posterior quantiles</h2><span id='topic+summary.pibblefit'></span>

<h3>Description</h3>

<p>Default calculates median, mean, 50% and 95% credible interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
summary(
  object,
  pars = NULL,
  use_names = TRUE,
  as_factor = FALSE,
  gather_prob = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pibblefit_+3A_object">object</code></td>
<td>
<p>an object of class pibblefit</p>
</td></tr>
<tr><td><code id="summary.pibblefit_+3A_pars">pars</code></td>
<td>
<p>character vector (default: c(&quot;Eta&quot;, &quot;Lambda&quot;, &quot;Sigma&quot;))</p>
</td></tr>
<tr><td><code id="summary.pibblefit_+3A_use_names">use_names</code></td>
<td>
<p>should summary replace dimension indices with pibblefit 
names if names Y and X were named in call to <code><a href="#topic+pibble">pibble</a></code></p>
</td></tr>
<tr><td><code id="summary.pibblefit_+3A_as_factor">as_factor</code></td>
<td>
<p>if use_names and as_factor then returns names as factors 
(useful for maintaining orderings when plotting)</p>
</td></tr>
<tr><td><code id="summary.pibblefit_+3A_gather_prob">gather_prob</code></td>
<td>
<p>if TRUE then prints quantiles in long format rather than 
wide (useful for some plotting functions)</p>
</td></tr>
<tr><td><code id="summary.pibblefit_+3A_...">...</code></td>
<td>
<p>other expressions to pass to summarise (using name 'val' unquoted is 
probably what you want)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>

<hr>
<h2 id='uncollapsePibble'>Uncollapse output from optimPibbleCollapsed to full pibble Model</h2><span id='topic+uncollapsePibble'></span>

<h3>Description</h3>

<p>See details for model. Should likely be called following
<code><a href="#topic+optimPibbleCollapsed">optimPibbleCollapsed</a></code>. Notation: <code>N</code> is number of samples,
<code>D</code> is number of multinomial categories, <code>Q</code> is number
of covariates, <code>iter</code> is the number of samples of <code>eta</code> (e.g.,
the parameter <code>n_samples</code> in the function <code>optimPibbleCollapsed</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncollapsePibble(
  eta,
  X,
  Theta,
  Gamma,
  Xi,
  upsilon,
  seed,
  ret_mean = FALSE,
  ncores = -1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncollapsePibble_+3A_eta">eta</code></td>
<td>
<p>array of dimension (D-1) x N x iter (e.g., <code>Pars</code> output of
function optimPibbleCollapsed)</p>
</td></tr>
<tr><td><code id="uncollapsePibble_+3A_x">X</code></td>
<td>
<p>matrix of covariates of dimension Q x N</p>
</td></tr>
<tr><td><code id="uncollapsePibble_+3A_theta">Theta</code></td>
<td>
<p>matrix of prior mean of dimension (D-1) x Q</p>
</td></tr>
<tr><td><code id="uncollapsePibble_+3A_gamma">Gamma</code></td>
<td>
<p>covariance matrix of dimension Q x Q</p>
</td></tr>
<tr><td><code id="uncollapsePibble_+3A_xi">Xi</code></td>
<td>
<p>covariance matrix of dimension (D-1) x (D-1)</p>
</td></tr>
<tr><td><code id="uncollapsePibble_+3A_upsilon">upsilon</code></td>
<td>
<p>scalar (must be &gt; D) degrees of freedom for InvWishart prior</p>
</td></tr>
<tr><td><code id="uncollapsePibble_+3A_seed">seed</code></td>
<td>
<p>seed to use for random number generation</p>
</td></tr>
<tr><td><code id="uncollapsePibble_+3A_ret_mean">ret_mean</code></td>
<td>
<p>if true then uses posterior mean of Lambda and Sigma
corresponding to each sample of eta rather than sampling from
posterior of Lambda and Sigma (useful if Laplace approximation
is not used (or fails) in optimPibbleCollapsed)</p>
</td></tr>
<tr><td><code id="uncollapsePibble_+3A_ncores">ncores</code></td>
<td>
<p>(default:-1) number of cores to use, if ncores==-1 then
uses default from OpenMP typically to use all available cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notation: Let Z_j denote the J-th row of a matrix Z.
While the collapsed model is given by:
</p>
<p style="text-align: center;"><code class="reqn">Y_j ~ Multinomial(Pi_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Pi_j = Phi^{-1}(Eta_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Eta ~ T_{D-1, N}(upsilon, Theta*X, K, A)</code>
</p>

<p>Where A = I_N + X * Gamma * X', K = Xi is a (D-1)x(D-1) covariance
matrix, Gamma is a Q x Q covariance matrix, and Phi^-1 is ALRInv_D
transform.
</p>
<p>The uncollapsed model (Full pibble model) is given by:
</p>
<p style="text-align: center;"><code class="reqn">Y_j ~ Multinomial(Pi_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Pi_j = Phi^{-1}(Eta_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">Eta ~ MN_{D-1 x N}(Lambda*X, Sigma, I_N)</code>
</p>

<p style="text-align: center;"><code class="reqn">Lambda ~ MN_{D-1 x Q}(Theta, Sigma, Gamma)</code>
</p>

<p style="text-align: center;"><code class="reqn">Sigma ~ InvWish(upsilon, Xi)</code>
</p>

<p>This function provides a means of sampling from the posterior distribution of
<code>Lambda</code> and <code>Sigma</code> given posterior samples of <code>Eta</code> from
the collapsed model.
</p>


<h3>Value</h3>

<p>List with components
</p>

<ol>
<li><p> Lambda Array of dimension (D-1) x Q x iter (posterior samples)
</p>
</li>
<li><p> Sigma Array of dimension (D-1) x (D-1) x iter (posterior samples)
</p>
</li>
<li><p> The number of cores used
</p>
</li>
<li><p> Timer
</p>
</li></ol>



<h3>References</h3>

<p>JD Silverman K Roche, ZC Holmes, LA David, S Mukherjee.
Bayesian Multinomial Logistic Normal Models through Marginally Latent Matrix-T Processes.
2019, arXiv e-prints, arXiv:1903.11695
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimPibbleCollapsed">optimPibbleCollapsed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- pibble_sim()

# Fit model for eta
fit &lt;- optimPibbleCollapsed(sim$Y, sim$upsilon, sim$Theta%*%sim$X, sim$KInv, 
                             sim$AInv, random_pibble_init(sim$Y))  

# Finally obtain samples from Lambda and Sigma
fit2 &lt;- uncollapsePibble(fit$Samples, sim$X, sim$Theta, 
                                   sim$Gamma, sim$Xi, sim$upsilon, 
                                   seed=2849)
</code></pre>

<hr>
<h2 id='verify'>Generic method for verifying new objects</h2><span id='topic+verify'></span>

<h3>Description</h3>

<p>Intended to be called internally by package or object creator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_+3A_m">m</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="verify_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to verify</p>
</td></tr>
</table>


<h3>Value</h3>

<p>throws error if verify test fails
</p>

<hr>
<h2 id='verify.bassetfit'>Simple verification of passed bassetfit object</h2><span id='topic+verify.bassetfit'></span>

<h3>Description</h3>

<p>Simple verification of passed bassetfit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bassetfit'
verify(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify.bassetfit_+3A_m">m</code></td>
<td>
<p>an object of class bassetfit</p>
</td></tr>
<tr><td><code id="verify.bassetfit_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>throws error if any verification tests fail
</p>

<hr>
<h2 id='verify.maltipoofit'>Simple verification of passed multipoo object</h2><span id='topic+verify.maltipoofit'></span>

<h3>Description</h3>

<p>Simple verification of passed multipoo object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maltipoofit'
verify(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify.maltipoofit_+3A_m">m</code></td>
<td>
<p>an object of class multipoo</p>
</td></tr>
<tr><td><code id="verify.maltipoofit_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>throws error if any verification tests fail
</p>

<hr>
<h2 id='verify.orthusfit'>Simple verification of passed orthusfit object</h2><span id='topic+verify.orthusfit'></span>

<h3>Description</h3>

<p>Simple verification of passed orthusfit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orthusfit'
verify(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify.orthusfit_+3A_m">m</code></td>
<td>
<p>an object of class orthusfit</p>
</td></tr>
<tr><td><code id="verify.orthusfit_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>throws error if any verification tests fail
</p>

<hr>
<h2 id='verify.pibblefit'>Simple verification of passed pibblefit object</h2><span id='topic+verify.pibblefit'></span>

<h3>Description</h3>

<p>Simple verification of passed pibblefit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pibblefit'
verify(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify.pibblefit_+3A_m">m</code></td>
<td>
<p>an object of class pibblefit</p>
</td></tr>
<tr><td><code id="verify.pibblefit_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>throws error if any verification tests fail
</p>

<hr>
<h2 id='Y'>Data from Silverman et al. (2019) bioRxiv</h2><span id='topic+Y'></span>

<h3>Description</h3>

<p>Mock communities and calibration samples created for measuring and validating model
of PCR bias. This data has been preprocessed as in the original manuscript.
</p>


<h3>Format</h3>

<p>an matrix Y (counts for each community member)
</p>


<h3>References</h3>

<p>Justin D. Silverman, Rachael J. Bloom, Sharon Jiang, Heather K. Durand, Sayan Mukherjee, 
Lawrence A. David. (2019) Measuring and Mitigating PCR Bias in Microbiome Data. 
bioRxiv 604025; doi: https://doi.org/10.1101/604025
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
