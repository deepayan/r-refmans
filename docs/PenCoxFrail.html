<!DOCTYPE html><html><head><title>Help for package PenCoxFrail</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PenCoxFrail}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pencoxfrail'>
<p>Regularization in Cox Frailty Models.</p></a></li>
<li><a href='#bs.design'><p>Generate a B-spline design matrix</p></a></li>
<li><a href='#coxFL'>
<p>A full likelihood approach for Cox Frailty Models.</p></a></li>
<li><a href='#coxFLControl'><p>Control Values for <code>coxFL</code> fit</p></a></li>
<li><a href='#coxlasso'>
<p>A LASSO approach for Cox Frailty Models.</p></a></li>
<li><a href='#coxlassoControl'><p>Control Values for <code>coxlasso</code> fit</p></a></li>
<li><a href='#coxridge'>
<p>A ridge approach for Cox Frailty Models.</p></a></li>
<li><a href='#cv.coxlasso'><p>Cross-validation for coxlasso</p></a></li>
<li><a href='#int.approx'><p>Approximation of a Cox likelihood intergral</p></a></li>
<li><a href='#pencoxfrailControl'><p>Control Values for <code>pencoxfrail</code> fit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Regularization in Cox Frailty Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-04</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Groll</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Groll &lt;groll@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Different regularization approaches for Cox Frailty Models by penalization methods are provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.6), Matrix, methods, coxme</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-04 14:54:48 UTC; user</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-04 22:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='pencoxfrail'>
Regularization in Cox Frailty Models.</h2><span id='topic+pencoxfrail'></span><span id='topic+PenCoxFrail-package'></span>

<h3>Description</h3>

<p>A regularization approach for Cox Frailty Models by penalization methods is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pencoxfrail(fix=formula, rnd=formula, vary.coef=formula, data, xi, 
              adaptive.weights = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pencoxfrail_+3A_fix">fix</code></td>
<td>
<p>a two-sided linear formula object describing the unpenalized
fixed (time-constant) effects part of the model, with the response on the left of a
<code>~</code> operator and the terms, separated by <code>+</code> operators, on
the right. The response must be a survival object as returned by the <code><a href="survival.html#topic+Surv">Surv</a></code> function.</p>
</td></tr>  
<tr><td><code id="pencoxfrail_+3A_rnd">rnd</code></td>
<td>
<p>a two-sided linear formula object describing the
random-effects part of the model, with the grouping factor on the left of a
<code>~</code> operator and the random terms, separated by <code>+</code> operators, on
the right.</p>
</td></tr>
<tr><td><code id="pencoxfrail_+3A_vary.coef">vary.coef</code></td>
<td>
<p>a one-sided linear formula object describing the
time-varying effects part of the model, with the time-varying terms, separated by <code>+</code> operators,
on the right side of a <code>~</code> operator.</p>
</td></tr>
<tr><td><code id="pencoxfrail_+3A_data">data</code></td>
<td>
<p>the data frame containing the variables named in the three preceding
<code>formula</code> arguments.</p>
</td></tr>
<tr><td><code id="pencoxfrail_+3A_xi">xi</code></td>
<td>
<p>the overall penalty parameter that controls the strenght of both penalty terms in <code class="reqn">\xi\cdot J(\zeta,\alpha)</code> and, hence, controls the overall amount of smoothness (up to constant effects) and variable selection for a given proportion <code class="reqn">\zeta</code>.
The optimal penalty parameter is a tuning parameter of the procedure that has to be determined, 
e.g. by K-fold cross validation. (See details or the quick demo for an example.)</p>
</td></tr> 
<tr><td><code id="pencoxfrail_+3A_adaptive.weights">adaptive.weights</code></td>
<td>
<p>a two-column matrix of adaptive weights passed to the procedure; the first column contains the weights <code class="reqn">w_{\Delta,k}</code>, the second column the weights <code class="reqn">v_{k}</code> from <code class="reqn">\xi\cdot J(\zeta,\alpha)</code>. If no adaptive weights are specified all weights are set to one. The recommended strategy is to first fit an unpenalized model (i.e. <code class="reqn">\xi=0</code>) and then use the obtained adaptive weights (see value section) when fitting the model for all other combinations of <code class="reqn">\xi</code> and <code class="reqn">\zeta</code>.</p>
</td></tr> 
<tr><td><code id="pencoxfrail_+3A_control">control</code></td>
<td>
<p>a list of control values for the estimation algorithm to replace the default values returned by the function <code><a href="#topic+pencoxfrailControl">pencoxfrailControl</a></code>. Defaults to an empty list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pencoxfrail</code> algorithm is designed to investigate
the effect structure in the Cox frailty model, which is a
widely used model that accounts for heterogeneity in survival data.
Since in survival models one has to account for possible variation of
the effect strength over time the selection of the relevant features distinguishes between the folllowing cases:
covariates can have time-varying effects, can have time-constant effects
or be irrelevant. For this purpose, the following specific penality is applied on the vectors of B-spline coefficients <code class="reqn">\alpha_k</code>, assuming <code class="reqn">k=1,...,r</code> different, potentially time-varying effects, each expanded in <code class="reqn">M</code> B-spline basis functions:
</p>
<p style="text-align: center;"><code class="reqn">\xi \cdot J(\zeta,\alpha) = \xi\left( \zeta\sum_{k=1}^{r} \psi\, w_{\Delta,k} ||\Delta_{M}\alpha_{k}||_{2} + (1-\zeta)\sum_{k=1}^{r} \phi\, v_{k} ||\alpha_{k}||_{2}\right)</code>
</p>

<p>This penalty is able to distinguish between these
types of effects to obtain a sparse representation that includes the relevant effects in a proper form.
</p>
<p>The penalty is depending on two tuning parameters, <code class="reqn">\xi</code> and <code class="reqn">\zeta</code>, which have to be determined by a suitable technique, e.g. by 
(2-dimensional) K-fold cross validation.
</p>
<p>The first term of the penalty controls the smoothness of the time-varying covariate effects, whereby for
values of <code class="reqn">\xi</code> and <code class="reqn">\zeta</code> large enough, all differences <code class="reqn">(\alpha_{k,l} - \alpha_{k,l-1}),  l=2,... ,M</code>, are removed from the model, resulting in constant covariate effects.
As the B-splines of each variable with varying coefficients sum up to one,
a constant effect is obtained if all spline coefficients are set equal.
Hence, the first penalty term does not affect the spline's global level.
The second term penalizes all spline coefficients belonging to a single time-varying effect in the way
of a group LASSO and, hence, controls the selection of covariates.
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> pencoxfrail</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-25</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>for loading a dataset type data(nameofdataset)
</p>


<h3>Value</h3>

<p>Generic functions such as <code>print</code>, <code>predict</code>, <code>plot</code> and <code>summary</code> have methods to show the results of the fit.
</p>
<p>The <code>predict</code> function uses also estimates of random effects for prediction, if possible (i.e. for known subjects of the grouping factor). 
Either the survival stepfunction or the baseline hazard (not cumulative!) can be calculated by specifying one of two possible methods: <code>method=c("hazard","survival")</code>. By default, for each new subject in <code>new.data</code> an individual stepfunction is calculated on a pre-specified time grid, also accounting for covariate changes over time. Alternatively, for <code>new.data</code> a single vector of a specific (time-constant) covariate combination can be specified.
</p>
<p>Usage:  <code>
predict(pencoxfrail.obj,new.data,time.grid,method=c("hazard","survival"))
</code>     
</p>
<p>The <code>plot</code> function plots all time-varying effects, including the baseline hazard. 
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>a list containing an image of the <code>pencoxfrail</code> call that produced the object.</p>
</td></tr>  
<tr><td><code>baseline</code></td>
<td>
<p>a vector containing the estimated B-spline coefficients of the baseline hazard.
If the covariates corresponding to the time-varying effects are centered (and standardized, see <code><a href="#topic+pencoxfrailControl">pencoxfrailControl</a></code>), the coefficients are transformed back to the original scale.</p>
</td></tr> 
<tr><td><code>time.vary</code></td>
<td>
<p>a vector containing the estimated B-spline coefficients of all time-varying effects.
If the covariates corresponding to the time-varying effects are standardized (see <code><a href="#topic+pencoxfrailControl">pencoxfrailControl</a></code>) 
the coefficients are transformed back to the original scale.</p>
</td></tr> 
<tr><td><code>coefficients</code></td>
<td>
<p>a vector containing the estimated fixed effects.</p>
</td></tr>
<tr><td><code>ranef</code></td>
<td>
<p>a vector containing the estimated random effects.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>a scalar or matrix containing the estimates of the random effects standard deviation or variance-covariance parameters, respectively.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p>a matrix containing the estimates of fixed and random effects (columns) for each iteration (rows) of the main algorithm (i.e. before the final re-estimation step is performed, see details).</p>
</td></tr>
<tr><td><code>Q_long</code></td>
<td>
<p>a list containing the estimates of the random effects variance-covariance parameters for each iteration of the main algorithm.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations until the main algorithm has converged.</p>
</td></tr>
<tr><td><code>adaptive.weights</code></td>
<td>
<p>If <code class="reqn">\xi=0</code>, a two-column matrix of adaptive weights is calculated; the first column contains the weights <code class="reqn">w_{\Delta,k}</code>, the second column the weights <code class="reqn">v_{k}</code> from <code class="reqn">\xi\cdot J(\zeta,\alpha)</code>. If <code class="reqn">\xi&gt;0</code>,
the adaptive weights that have been used in the function's argument are displayed.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>vector of knots used in the B-spline representation.</p>
</td></tr>
<tr><td><code>Phi.big</code></td>
<td>
<p>large B-spline design matrix corresponding to the baseline hazard and all time-varying effects. For the time-varying effects, the B-spline functions (as a function of time) have already been multiplied with their associated covariates.</p>
</td></tr>
<tr><td><code>time.grid</code></td>
<td>
<p>the time grid used in when approximating the (Riemann) integral involved in the model's full likelihood.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>number of metric covariates with time-varying effects.</p>
</td></tr>
<tr><td><code>m2</code></td>
<td>
<p>number of categorical covariates with time-varying effects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Groll  <a href="mailto:groll@math.lmu.de">groll@math.lmu.de</a>
</p>


<h3>References</h3>

<p>Groll, A., T. Hastie and G. Tutz (2017). 
Selection of Effects in Cox Frailty Models by Regularization Methods. <em>Biometrics</em> 73(3): 846-856.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pencoxfrailControl">pencoxfrailControl</a>,<a href="survival.html#topic+Surv">Surv</a>,<a href="survival.html#topic+pbc">pbc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(lung)

# remove NAs
lung &lt;- lung[!is.na(lung$inst),]

# transform inst into factor variable
lung$inst &lt;- as.factor(lung$inst)

# Random institutional effect
fix.form &lt;- as.formula("Surv(time, status) ~ 1")
vary.coef &lt;- as.formula("~ age")

pen.obj &lt;- pencoxfrail(fix=fix.form,vary.coef=vary.coef, rnd = list(inst=~1), 
              data=lung, xi=10,control=list(print.iter=TRUE))

# show fit
plot(pen.obj)

# predict survival curve of new subject, institution 1 and up to time 500
pred.obj &lt;- predict(pen.obj,newdata=data.frame(inst=1,time=NA,status=NA,age=26),
              time.grid=seq(0,500,by=1))

# plot predicted hazard function
plot(pred.obj$time.grid,pred.obj$haz,type="l",xlab="time",ylab="hazard")

# plot predicted survival function
plot(pred.obj$time.grid,pred.obj$survival,type="l",xlab="time",ylab="survival")

# see also demo("pencoxfrail-pbc")

## End(Not run)</code></pre>

<hr>
<h2 id='bs.design'>Generate a B-spline design matrix</h2><span id='topic+bs.design'></span>

<h3>Description</h3>

<p>The function generates a B-spline design matrix with equidistant knots for given degree of the splines and number of basis functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bs.design(x, xl, xr, spline.degree, nbasis, comp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bs.design_+3A_x">x</code></td>
<td>
<p>the positions where spline to be evaluated.</p>
</td></tr>
<tr><td><code id="bs.design_+3A_xl">xl</code></td>
<td>
<p>lower intervall boundary where spline functions are relevant.</p>
</td></tr>
<tr><td><code id="bs.design_+3A_xr">xr</code></td>
<td>
<p>upper intervall boundary where spline functions are relevant.</p>
</td></tr>
<tr><td><code id="bs.design_+3A_spline.degree">spline.degree</code></td>
<td>
<p>(polynomial) degree of the B-splines.</p>
</td></tr>
<tr><td><code id="bs.design_+3A_nbasis">nbasis</code></td>
<td>
<p>number of basis functions used.</p>
</td></tr>
<tr><td><code id="bs.design_+3A_comp">comp</code></td>
<td>
<p>Specify if only specific columns of the B-spline design matrix should be returned. Default is NULL and the whole B-spline design matrix is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The B-spline design matrix is returned.
</p>


<h3>Author(s)</h3>

<p>Andreas Groll <a href="mailto:groll@math.lmu.de">groll@math.lmu.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pencoxfrail">pencoxfrail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
B &lt;- bs.design(x=x, xl=min(x), xr=max(x), spline.degree=3, nbasis=5)
</code></pre>

<hr>
<h2 id='coxFL'>
A full likelihood approach for Cox Frailty Models.</h2><span id='topic+coxFL'></span>

<h3>Description</h3>

<p>A full likelihood approach for Cox Frailty Models based on the full likelihood is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxFL(fix=formula, rnd=NULL, vary.coef=NULL, data, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxFL_+3A_fix">fix</code></td>
<td>
<p>a two-sided linear formula object describing the unpenalized
fixed (time-constant) effects part of the model, with the response on the left of a
<code>~</code> operator and the terms, separated by <code>+</code> operators, on
the right. The response must be a survival object as returned by the <code><a href="survival.html#topic+Surv">Surv</a></code> function.</p>
</td></tr>  
<tr><td><code id="coxFL_+3A_rnd">rnd</code></td>
<td>
<p>a two-sided linear formula object describing the
random-effects part of the model, with the grouping factor on the left of a
<code>~</code> operator and the random terms, separated by <code>+</code> operators, on
the right.Default is NULL, so no random effects are present.</p>
</td></tr>
<tr><td><code id="coxFL_+3A_vary.coef">vary.coef</code></td>
<td>
<p>a one-sided linear formula object describing the
time-varying effects part of the model, with the time-varying terms, separated by <code>+</code> operators,
on the right side of a <code>~</code> operator.Default is NULL, so no time-varying effects are incorporated.</p>
</td></tr>
<tr><td><code id="coxFL_+3A_data">data</code></td>
<td>
<p>the data frame containing the variables named in the three preceding
<code>formula</code> arguments.</p>
</td></tr>
<tr><td><code id="coxFL_+3A_control">control</code></td>
<td>
<p>a list of control values for the estimation algorithm to replace the default values returned by the function <code><a href="#topic+coxlassoControl">coxlassoControl</a></code>. Defaults to an empty list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>coxFL</code> algorithm is designed to investigate
the effect structure in the Cox frailty model, which is a
widely used model that accounts for heterogeneity in time-to-event data.
Since in survival models one has to account for possible variation of
the effect strength over time, some features can incorporated with time-varying effects. 
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> pencoxfrail</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-25</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>for loading a dataset type data(nameofdataset)
</p>


<h3>Value</h3>

<p>Generic functions such as <code>print</code>, <code>predict</code>, <code>plot</code> and <code>summary</code> have methods to show the results of the fit.
</p>
<p>The <code>predict</code> function uses also estimates of random effects for prediction, if possible (i.e. for known subjects of the grouping factor). 
Either the survival stepfunction or the baseline hazard (not cumulative!) can be calculated by specifying one of two possible methods: <code>method=c("hazard","survival")</code>. By default, for each new subject in <code>new.data</code> an individual stepfunction is calculated on a pre-specified time grid, also accounting for covariate changes over time. Alternatively, for <code>new.data</code> a single vector of a specific (time-constant) covariate combination can be specified.
</p>
<p>Usage:  <code>
predict(coxlasso.obj,new.data,time.grid,method=c("hazard","survival"))
</code>     
</p>
<p>The <code>plot</code> function plots all time-varying effects, including the baseline hazard. 
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>a list containing an image of the <code>coxlasso</code> call that produced the object.</p>
</td></tr>  
<tr><td><code>baseline</code></td>
<td>
<p>a vector containing the estimated B-spline coefficients of the baseline hazard.
If the covariates corresponding to the time-varying effects are centered (and standardized, see <code><a href="#topic+coxlassoControl">coxlassoControl</a></code>), the coefficients are transformed back to the original scale.</p>
</td></tr> 
<tr><td><code>time.vary</code></td>
<td>
<p>a vector containing the estimated B-spline coefficients of all time-varying effects.
If the covariates corresponding to the time-varying effects are standardized (see <code><a href="#topic+coxlassoControl">coxlassoControl</a></code>) 
the coefficients are transformed back to the original scale.</p>
</td></tr> 
<tr><td><code>coefficients</code></td>
<td>
<p>a vector containing the estimated fixed effects.</p>
</td></tr>
<tr><td><code>ranef</code></td>
<td>
<p>a vector containing the estimated random effects.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>a scalar or matrix containing the estimates of the random effects standard deviation or variance-covariance parameters, respectively.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p>a matrix containing the estimates of fixed and random effects (columns) for each iteration (rows) of the main algorithm (i.e. before the final re-estimation step is performed, see details).</p>
</td></tr>
<tr><td><code>Q_long</code></td>
<td>
<p>a list containing the estimates of the random effects variance-covariance parameters for each iteration of the main algorithm.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations until the main algorithm has converged.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>vector of knots used in the B-spline representation.</p>
</td></tr>
<tr><td><code>Phi.big</code></td>
<td>
<p>large B-spline design matrix corresponding to the baseline hazard and all time-varying effects. For the time-varying effects, the B-spline functions (as a function of time) have already been multiplied with their associated covariates.</p>
</td></tr>
<tr><td><code>time.grid</code></td>
<td>
<p>the time grid used in when approximating the (Riemann) integral involved in the model's full likelihood.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>number of metric covariates with time-varying effects.</p>
</td></tr>
<tr><td><code>m2</code></td>
<td>
<p>number of categorical covariates with time-varying effects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Groll  <a href="mailto:groll@statistik.tu-dortmund.de">groll@statistik.tu-dortmund.de</a>
</p>


<h3>References</h3>

<p>Groll, A., T. Hastie and G. Tutz (2016). 
Regularization in Cox Frailty Models. Ludwig-Maximilians-University. <em>Technical Report</em> 191.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxFLControl">coxFLControl</a>,<a href="survival.html#topic+Surv">Surv</a>,<a href="survival.html#topic+pbc">pbc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(lung)

# remove NAs
lung &lt;- lung[!is.na(lung$inst),]

# transform inst into factor variable
lung$inst &lt;- as.factor(lung$inst)

# just for illustration, create factor with only three ph.ecog classes
lung$ph.ecog[is.na(lung$ph.ecog)] &lt;- 2
lung$ph.ecog[lung$ph.ecog==3] &lt;- 2
lung$ph.ecog &lt;- as.factor(lung$ph.ecog)

fix.form &lt;- as.formula("Surv(time, status) ~ 1 + age + ph.ecog + sex")

coxFL.obj &lt;- coxFL(fix=fix.form, data=lung, 
                control=list(print.iter=TRUE, exact = 1))
coef(coxFL.obj)             
                
# For comparison: coxph
coxph.1 &lt;- coxph(fix.form , data=lung)
coef(coxph.1)

# now add random institutional effect
coxFL.obj2 &lt;- coxFL(fix=fix.form, rnd = list(inst=~1), 
              data=lung, control=list(print.iter=TRUE, exact = 1))
coef(coxFL.obj2)             
# print frailty Std.Dev.
print(coxFL.obj2$Q)
# print frailties
print(coxFL.obj2$ranef)

# For comparison:  coxph
fix.form.cox &lt;- update(fix.form, ~ . + frailty(inst, distribution="gaussian"))
coxph.2 &lt;- coxph(fix.form.cox , data=lung)
coef(coxph.2)
# print frailty Std.Dev.
print(sqrt(coxph.2$history[[1]]$history[nrow(coxph.2$history[[1]]$history), 1])) 
# print frailties
print(coxph.2$frail)



# now fit a time-varying effect for age
fix.form &lt;- as.formula("Surv(time, status) ~ 1 + ph.ecog + sex")
vary.coef &lt;- as.formula("~ age")

coxFL.obj3 &lt;- coxFL(fix=fix.form,vary.coef=vary.coef,  
              data=lung, control=list(print.iter=TRUE))
summary(coxFL.obj3)

# show fit
plot(coxFL.obj3)

# predict survival curve of new subject, institution 1 and up to time 300
pred.obj &lt;- predict(coxFL.obj2, newdata=data.frame(inst=1, time=NA, status=NA, age=26,
              ph.ecog=2,sex=1), time.grid=seq(0,300,by=1))

# plot predicted hazard function
plot(pred.obj$time.grid,pred.obj$haz,type="l",xlab="time",ylab="hazard")

# plot predicted survival function
plot(pred.obj$time.grid,pred.obj$survival,type="l",xlab="time",ylab="survival")

## specify a larger new data set
new.data &lt;- data.frame(inst=c(1,1,6), time=c(20,40,200), 
      status=c(NA,NA,NA), age=c(26,26,54), ph.ecog=c(0,0,2),sex=c(1,1,1))

## as here no frailties have been specified, id.var needs to be given!
pred.obj2 &lt;- predict(coxFL.obj3, newdata=new.data,id.var = "inst")

# plot predicted hazard functions (for the available time intervals)
# for individual 1 and 3
plot(pred.obj2$time.grid[!is.na(pred.obj2$haz[,1])],
      pred.obj2$haz[,1][!is.na(pred.obj2$haz[,1])],
      type="l",xlab="time",ylab="hazard",xlim=c(0,200),
      ylim=c(0,max(pred.obj2$haz,na.rm=T)))
lines(pred.obj2$time.grid[!is.na(pred.obj2$haz[,3])],
      pred.obj2$haz[,3][!is.na(pred.obj2$haz[,3])],
      col="red",lty=2,)

# plot predicted survival functions (for the available time intervals)
# for individual 1 and 3
plot(pred.obj2$time.grid[!is.na(pred.obj2$survival[,1])],
    pred.obj2$survival[,1][!is.na(pred.obj2$survival[,1])],
    type="l",xlab="time",ylab="hazard",xlim=c(0,200),
    ylim=c(0,max(pred.obj2$survival,na.rm=T)))
lines(pred.obj2$time.grid[!is.na(pred.obj2$survival[,3])],
      pred.obj2$survival[,3][!is.na(pred.obj2$survival[,3])],
      col="red",lty=2,)


## End(Not run)</code></pre>

<hr>
<h2 id='coxFLControl'>Control Values for <code>coxFL</code> fit</h2><span id='topic+coxFLControl'></span>

<h3>Description</h3>

<p>The values supplied in the function call replace the defaults and a list with all possible arguments is returned. The returned list is used as the <code>control</code> argument to the <code>coxFL</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
coxFLControl(start = NULL, index=NULL, q_start = NULL, conv.eps = 1e-3, 
                          standardize = FALSE, center = FALSE,
                          smooth=list(nbasis = 6, penal = 1e+2), 
                          print.iter = FALSE, max.iter = 100, 
                          exact = NULL, xr = NULL, eps = 1e-3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxFLControl_+3A_start">start</code></td>
<td>
<p>a vector of suitable length containing starting values for the spline-coefficients of the baseline hazard and the time-varying effects, followed by the fixed and random effects. The correct ordering is important. Default is a vector full of zeros.</p>
</td></tr>
<tr><td><code id="coxFLControl_+3A_index">index</code></td>
<td>
<p>vector which defines the grouping of the variables. Components sharing the same number build a group and factor variables get a single number (and are automatically treated as a group). Non-penalized coefficients are marked with NA.</p>
</td></tr>
<tr><td><code id="coxFLControl_+3A_q_start">q_start</code></td>
<td>
<p>a scalar or matrix of suitable dimension, specifying starting values for the random-effects variance-covariance matrix. Default is a scalar 0.1 or diagonal matrix with 0.1 in the diagonal, depending on the dimension of the random effects.</p>
</td></tr>
<tr><td><code id="coxFLControl_+3A_conv.eps">conv.eps</code></td>
<td>
<p>controls the speed of convergence. Default is 1e-3.</p>
</td></tr>
<tr><td><code id="coxFLControl_+3A_smooth">smooth</code></td>
<td>
<p>a list specifying the number of basis functions <code>nbasis</code> (used for the baseline hazard and all time-varying effects) and the starting value for the smoothness penalty parameter <code>penal</code>, which is only applied in the first iteration. Then, in all following iterations the wiggly components of the smooths are treated as random effects. The degree of the B-splines is fixed to be three (i.e. cubic splines).</p>
</td></tr>
<tr><td><code id="coxFLControl_+3A_standardize">standardize</code></td>
<td>
<p>logical. If true, the covariates corresponding to the fixed effects will be
scaled to a variance equal to one. Default is TRUE.</p>
</td></tr>
<tr><td><code id="coxFLControl_+3A_center">center</code></td>
<td>
<p>logical. If true, the covariates corresponding to the time-varying effects will be
centered. Default is FALSE (and centering is only recommended if really necessary; it can also have a strong effect on the baseline hazard, in particular, if a strong penalty is selected).</p>
</td></tr>
<tr><td><code id="coxFLControl_+3A_print.iter">print.iter</code></td>
<td>
<p>logical. Should the number of iterations be printed? Default is FALSE.</p>
</td></tr>
<tr><td><code id="coxFLControl_+3A_max.iter">max.iter</code></td>
<td>
<p>the number of iterations for the final Fisher scoring re-estimation procedure. Default is 200.</p>
</td></tr>
<tr><td><code id="coxFLControl_+3A_exact">exact</code></td>
<td>
<p>controls the exactness of the (Riemann) integral approximations. If not set by the user to a specific value, it will
be automatically chosen such that the time interval [0,t_max] will be divided in about 1000 equal sized Riemann bars.</p>
</td></tr>
<tr><td><code id="coxFLControl_+3A_xr">xr</code></td>
<td>
<p>maximal time point that is regarded. Default is NULL and the maximal event or censoring time point in the data is used.</p>
</td></tr>
<tr><td><code id="coxFLControl_+3A_eps">eps</code></td>
<td>
<p>Small epsilon that controls which fixed effects are set to zero: parameters with an absolute value smaller than epsilon are taken to be zero. Default is 1e-3.</p>
</td></tr>
<tr><td><code id="coxFLControl_+3A_...">...</code></td>
<td>
<p>Futher arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components for each of the possible arguments.
</p>


<h3>Author(s)</h3>

<p>Andreas Groll <a href="mailto:groll@math.lmu.de">groll@math.lmu.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxFL">coxFL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use different weighting of the two penalty parts
# and lighten the convergence criterion 
coxFLControl(c.app = 1e-5, conv.eps=1e-3)
</code></pre>

<hr>
<h2 id='coxlasso'>
A LASSO approach for Cox Frailty Models.</h2><span id='topic+coxlasso'></span>

<h3>Description</h3>

<p>A LASSO approach for Cox Frailty Models based on the Cox full likelihood is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxlasso(fix=formula, rnd=NULL, vary.coef=NULL, data, xi, 
              adaptive.weights = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxlasso_+3A_fix">fix</code></td>
<td>
<p>a two-sided linear formula object describing the LASSO-penalized
fixed (time-constant) effects part of the model, with the response on the left of a
<code>~</code> operator and the terms, separated by <code>+</code> operators, on
the right. The response must be a survival object as returned by the <code><a href="survival.html#topic+Surv">Surv</a></code> function.</p>
</td></tr>  
<tr><td><code id="coxlasso_+3A_rnd">rnd</code></td>
<td>
<p>a two-sided linear formula object describing the
random-effects part of the model, with the grouping factor on the left of a
<code>~</code> operator and the random terms, separated by <code>+</code> operators, on
the right.Default is NULL, so no random effects are present.</p>
</td></tr>
<tr><td><code id="coxlasso_+3A_vary.coef">vary.coef</code></td>
<td>
<p>a one-sided linear formula object describing the
time-varying effects part of the model, with the time-varying terms, separated by <code>+</code> operators,
on the right side of a <code>~</code> operator.Default is NULL, so no time-varying effects are incorporated.</p>
</td></tr>
<tr><td><code id="coxlasso_+3A_data">data</code></td>
<td>
<p>the data frame containing the variables named in the three preceding
<code>formula</code> arguments.</p>
</td></tr>
<tr><td><code id="coxlasso_+3A_xi">xi</code></td>
<td>
<p>the LASSO-penalty parameter that controls the strenght of the penalty term.
The optimal penalty parameter is a tuning parameter of the procedure that has to be determined, 
e.g. by K-fold cross validation (see <code><a href="#topic+cv.coxlasso">cv.coxlasso</a></code> for details or the quick demo for an example).</p>
</td></tr> 
<tr><td><code id="coxlasso_+3A_adaptive.weights">adaptive.weights</code></td>
<td>
<p>for the LASSO-penalized fixed effects a vector of adaptive weights can be passed to the procedure. If no adaptive weights are specified, an unpenalized model (i.e. <code class="reqn">\xi=0</code>) is fitted by the <code><a href="#topic+coxFL">coxFL</a></code> function and the obtained estimates are used as adaptive weights (see value section).</p>
</td></tr> 
<tr><td><code id="coxlasso_+3A_control">control</code></td>
<td>
<p>a list of control values for the estimation algorithm to replace the default values returned by the function <code><a href="#topic+coxlassoControl">coxlassoControl</a></code>. Defaults to an empty list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>coxlasso</code> algorithm is designed to investigate
the effect structure in the Cox frailty model, which is a
widely used model that accounts for heterogeneity in time-to-event data.
Since in survival models one has to account for possible variation of
the effect strength over time, some features can incorporated with time-varying effects. 
</p>
<p>The penalty is depending on the LASSO tuning parameter <code class="reqn">\xi</code>, which has to be determined by a suitable technique, e.g. by K-fold cross validation.
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> pencoxfrail</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-25</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>for loading a dataset type data(nameofdataset)
</p>


<h3>Value</h3>

<p>Generic functions such as <code>print</code>, <code>predict</code>, <code>plot</code> and <code>summary</code> have methods to show the results of the fit.
</p>
<p>The <code>predict</code> function uses also estimates of random effects for prediction, if possible (i.e. for known subjects of the grouping factor). 
Either the survival stepfunction or the baseline hazard (not cumulative!) can be calculated by specifying one of two possible methods: <code>method=c("hazard","survival")</code>. By default, for each new subject in <code>new.data</code> an individual stepfunction is calculated on a pre-specified time grid, also accounting for covariate changes over time. Alternatively, for <code>new.data</code> a single vector of a specific (time-constant) covariate combination can be specified.
</p>
<p>Usage:  <code>
predict(coxlasso.obj,new.data,time.grid,method=c("hazard","survival"))
</code>     
</p>
<p>The <code>plot</code> function plots all time-varying effects, including the baseline hazard. 
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>a list containing an image of the <code>coxlasso</code> call that produced the object.</p>
</td></tr>  
<tr><td><code>baseline</code></td>
<td>
<p>a vector containing the estimated B-spline coefficients of the baseline hazard.
If the covariates corresponding to the time-varying effects are centered (and standardized, see <code><a href="#topic+coxlassoControl">coxlassoControl</a></code>), the coefficients are transformed back to the original scale.</p>
</td></tr> 
<tr><td><code>time.vary</code></td>
<td>
<p>a vector containing the estimated B-spline coefficients of all time-varying effects.
If the covariates corresponding to the time-varying effects are standardized (see <code><a href="#topic+coxlassoControl">coxlassoControl</a></code>) 
the coefficients are transformed back to the original scale.</p>
</td></tr> 
<tr><td><code>coefficients</code></td>
<td>
<p>a vector containing the estimated fixed effects.</p>
</td></tr>
<tr><td><code>ranef</code></td>
<td>
<p>a vector containing the estimated random effects.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>a scalar or matrix containing the estimates of the random effects standard deviation or variance-covariance parameters, respectively.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p>a matrix containing the estimates of fixed and random effects (columns) for each iteration (rows) of the main algorithm (i.e. before the final re-estimation step is performed, see details).</p>
</td></tr>
<tr><td><code>Q_long</code></td>
<td>
<p>a list containing the estimates of the random effects variance-covariance parameters for each iteration of the main algorithm.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations until the main algorithm has converged.</p>
</td></tr>
<tr><td><code>adaptive.weights</code></td>
<td>
<p>if not given as an argument by the user, a two-column matrix of adaptive weights is calculated by the <code><a href="#topic+coxFL">coxFL</a></code> function; the first column contains the weights <code class="reqn">w_{\Delta,k}</code>, the second column the weights <code class="reqn">v_{k}</code> from <code class="reqn">\xi\cdot J(\zeta,\alpha)</code>.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>vector of knots used in the B-spline representation.</p>
</td></tr>
<tr><td><code>Phi.big</code></td>
<td>
<p>large B-spline design matrix corresponding to the baseline hazard and all time-varying effects. For the time-varying effects, the B-spline functions (as a function of time) have already been multiplied with their associated covariates.</p>
</td></tr>
<tr><td><code>time.grid</code></td>
<td>
<p>the time grid used in when approximating the (Riemann) integral involved in the model's full likelihood.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>number of metric covariates with time-varying effects.</p>
</td></tr>
<tr><td><code>m2</code></td>
<td>
<p>number of categorical covariates with time-varying effects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Groll <a href="mailto:groll@statistik.tu-dortmund.de">groll@statistik.tu-dortmund.de</a> <br /> Maike Hohberg <a href="mailto:mhohber@uni-goettingen.de">mhohber@uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>Groll, A., T. Hastie and G. Tutz (2017). 
Selection of Effects in Cox Frailty Models by
Regularization Methods. <em>Biometrics</em> 73(3): 846-856.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxlassoControl">coxlassoControl</a>,<a href="#topic+cv.coxlasso">cv.coxlasso</a>,<a href="#topic+coxFL">coxFL</a>,<a href="survival.html#topic+Surv">Surv</a>,<a href="survival.html#topic+pbc">pbc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(lung)

# remove NAs
lung &lt;- lung[!is.na(lung$inst),]

# transform inst into factor variable
lung$inst &lt;- as.factor(lung$inst)

# just for illustration, create factor with only three ph.ecog classes
lung$ph.ecog[is.na(lung$ph.ecog)] &lt;- 2
lung$ph.ecog[lung$ph.ecog==3] &lt;- 2
lung$ph.ecog &lt;- as.factor(lung$ph.ecog)

fix.form &lt;- as.formula("Surv(time, status) ~ 1 + age + ph.ecog + sex")

lasso.obj &lt;- coxlasso(fix=fix.form, data=lung, xi=10,
                control=list(print.iter=TRUE, exact = 1))
coef(lasso.obj)             
                

# now add random institutional effect
lasso.obj2 &lt;- coxlasso(fix=fix.form, rnd = list(inst=~1), 
              data=lung, xi=10,control=list(print.iter=TRUE, exact = 1))
coef(lasso.obj2)             
# print frailty Std.Dev.
print(lasso.obj2$Q)
# print frailties
print(lasso.obj2$ranef)


# now fit a time-varying effect for age
fix.form &lt;- as.formula("Surv(time, status) ~ 1 + ph.ecog + sex")
vary.coef &lt;- as.formula("~ age")

lasso.obj3 &lt;- coxlasso(fix=fix.form,vary.coef=vary.coef,  
              data=lung, xi=10,control=list(print.iter=TRUE))
summary(lasso.obj3)

# show fit
plot(lasso.obj3)

# predict survival curve of new subject, institution 1 and up to time 300
pred.obj &lt;- predict(lasso.obj2, newdata=data.frame(inst=1, time=NA, status=NA, age=26,
              ph.ecog=2,sex=1), time.grid=seq(0,300,by=1))

# plot predicted hazard function
plot(pred.obj$time.grid,pred.obj$haz,type="l",xlab="time",ylab="hazard")

# plot predicted survival function
plot(pred.obj$time.grid,pred.obj$survival,type="l",xlab="time",ylab="survival")

## specify a larger new data set
new.data &lt;- data.frame(inst=c(1,1,6), time=c(20,40,200), 
      status=c(NA,NA,NA), age=c(26,26,54), ph.ecog=c(0,0,2),sex=c(1,1,1))

## as here no frailties have been specified, id.var needs to be given!
pred.obj2 &lt;- predict(lasso.obj3, newdata=new.data,id.var = "inst")

# plot predicted hazard functions (for the available time intervals)
plot(pred.obj2$time.grid[!is.na(pred.obj2$haz[,1])],
      pred.obj2$haz[,1][!is.na(pred.obj2$haz[,1])],
      type="l",xlab="time",ylab="hazard",xlim=c(0,200),
      ylim=c(0,max(pred.obj2$haz,na.rm=T)))
lines(pred.obj2$time.grid[!is.na(pred.obj2$haz[,3])],
      pred.obj2$haz[,3][!is.na(pred.obj2$haz[,3])],
      col="red",lty=2,)

# plot predicted survival functions (for the available time intervals)
plot(pred.obj2$time.grid[!is.na(pred.obj2$survival[,1])],
    pred.obj2$survival[,1][!is.na(pred.obj2$survival[,1])],
    type="l",xlab="time",ylab="hazard",xlim=c(0,200),
    ylim=c(0,max(pred.obj2$survival,na.rm=T)))
lines(pred.obj2$time.grid[!is.na(pred.obj2$survival[,3])],
      pred.obj2$survival[,3][!is.na(pred.obj2$survival[,3])],
      col="red",lty=2,)


# see also demo("coxlasso-lung")

## End(Not run)</code></pre>

<hr>
<h2 id='coxlassoControl'>Control Values for <code>coxlasso</code> fit</h2><span id='topic+coxlassoControl'></span>

<h3>Description</h3>

<p>The values supplied in the function call replace the defaults and a list with all possible arguments is returned. The returned list is used as the <code>control</code> argument to the <code>coxlasso</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
coxlassoControl(start = NULL, index=NULL, q_start = NULL, conv.eps = 1e-3, 
                          standardize = TRUE, center = FALSE,
                          smooth=list(nbasis = 6, penal = 1e+2), 
                          print.iter = FALSE, max.iter = 100, c.app = 1e-6,  
                          exact = NULL, xr = NULL, eps = 1e-2, quant.knots = TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxlassoControl_+3A_start">start</code></td>
<td>
<p>a vector of suitable length containing starting values for the spline-coefficients of the baseline hazard and the time-varying effects, followed by the fixed and random effects. The correct ordering is important. Default is a vector full of zeros.</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_index">index</code></td>
<td>
<p>vector which defines the grouping of the variables. Components sharing the same number build a group and factor variables get a single number (and are automatically treated as a group). Non-penalized coefficients are marked with NA.</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_q_start">q_start</code></td>
<td>
<p>a scalar or matrix of suitable dimension, specifying starting values for the random-effects variance-covariance matrix. Default is a scalar 0.1 or diagonal matrix with 0.1 in the diagonal, depending on the dimension of the random effects.</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_conv.eps">conv.eps</code></td>
<td>
<p>controls the speed of convergence. Default is 1e-3.</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_center">center</code></td>
<td>
<p>logical. If true, the covariates corresponding to the time-varying effects will be
centered. Default is FALSE (and centering is only recommended if really necessary; it can also have a strong effect on the baseline hazard, in particular, if a strong penalty is selected).</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_standardize">standardize</code></td>
<td>
<p>logical. If true, the covariates corresponding to the fixed effects will be
scaled to a variance equal to one. Default is TRUE.</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_smooth">smooth</code></td>
<td>
<p>a list specifying the number of basis functions <code>nbasis</code> (used for the baseline hazard and all time-varying effects) and the smoothness penalty parameter <code>penal</code>, which is only applied to the baseline hazard. All time-varying effects are penalized by the specific double-penalty <code class="reqn">\xi\cdot J(\zeta,\alpha)</code> (see <code><a href="#topic+coxlasso">coxlasso</a></code>), which is based on the overall penalty parameter <code class="reqn">\xi</code> (specified in the main function <code><a href="#topic+coxlasso">coxlasso</a></code>) and on the weighting between the two penalty parts <code class="reqn">\zeta</code>. The degree of the B-splines is fixed to be three (i.e. cubic splines).</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_print.iter">print.iter</code></td>
<td>
<p>logical. Should the number of iterations be printed? Default is FALSE.</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_max.iter">max.iter</code></td>
<td>
<p>the number of iterations for the final Fisher scoring re-estimation procedure. Default is 200.</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_c.app">c.app</code></td>
<td>
<p>The parameter controlling the exactness of the quadratic approximations of the penalties. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_exact">exact</code></td>
<td>
<p>controls the exactness of the (Riemann) integral approximations. If not set by the user to a specific value, it will
be automatically chosen such that the time interval [0,t_max] will be divided in about 1000 equal sized Riemann bars.</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_xr">xr</code></td>
<td>
<p>maximal time point that is regarded. Default is NULL and the maximal event or censoring time point in the data is used.</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_eps">eps</code></td>
<td>
<p>Small epsilon that controls which fixed effects are set to zero: parameters with an absolute value smaller than epsilon are taken to be zero. Default is 1e-2.</p>
</td></tr>
<tr><td><code id="coxlassoControl_+3A_quant.knots">quant.knots</code></td>
<td>
<p>Shall the knots be defined based on quantiles? Default is TRUE.</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="coxlassoControl_+3A_...">...</code></td>
<td>
<p>Futher arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components for each of the possible arguments.
</p>


<h3>Author(s)</h3>

<p>Andreas Groll <a href="mailto:groll@math.lmu.de">groll@math.lmu.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxlasso">coxlasso</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use different weighting of the two penalty parts
# and lighten the convergence criterion 
coxlassoControl(c.app = 1e-5, conv.eps=1e-3)
</code></pre>

<hr>
<h2 id='coxridge'>
A ridge approach for Cox Frailty Models.</h2><span id='topic+coxridge'></span>

<h3>Description</h3>

<p>A ridge regression approach for Cox Frailty Models based on the Cox full likelihood is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxridge(fix=formula, rnd=NULL, vary.coef=NULL, xi.ridge, data, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxridge_+3A_fix">fix</code></td>
<td>
<p>a two-sided linear formula object describing the LASSO-penalized
fixed (time-constant) effects part of the model, with the response on the left of a
<code>~</code> operator and the terms, separated by <code>+</code> operators, on
the right. The response must be a survival object as returned by the <code><a href="survival.html#topic+Surv">Surv</a></code> function.</p>
</td></tr>  
<tr><td><code id="coxridge_+3A_rnd">rnd</code></td>
<td>
<p>a two-sided linear formula object describing the
random-effects part of the model, with the grouping factor on the left of a
<code>~</code> operator and the random terms, separated by <code>+</code> operators, on
the right.Default is NULL, so no random effects are present.</p>
</td></tr>
<tr><td><code id="coxridge_+3A_vary.coef">vary.coef</code></td>
<td>
<p>a one-sided linear formula object describing the
time-varying effects part of the model, with the time-varying terms, separated by <code>+</code> operators,
on the right side of a <code>~</code> operator.Default is NULL, so no time-varying effects are incorporated.</p>
</td></tr>
<tr><td><code id="coxridge_+3A_xi.ridge">xi.ridge</code></td>
<td>
<p>the ridge-penalty parameter that controls the strenght of the penalty term.
The optimal penalty parameter is a tuning parameter of the procedure that has to be determined, 
e.g. by K-fold cross validation.</p>
</td></tr> 
<tr><td><code id="coxridge_+3A_data">data</code></td>
<td>
<p>the data frame containing the variables named in the three preceding
<code>formula</code> arguments.</p>
</td></tr>
<tr><td><code id="coxridge_+3A_control">control</code></td>
<td>
<p>a list of control values for the estimation algorithm to replace the default values returned by the function <code><a href="#topic+coxlassoControl">coxlassoControl</a></code>. Defaults to an empty list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>coxridge</code> algorithm is designed to investigate
the effect structure in the Cox frailty model, which is a
widely used model that accounts for heterogeneity in time-to-event data.
Since in survival models one has to account for possible variation of
the effect strength over time, some features can incorporated with time-varying effects. 
</p>
<p>The penalty is depending on the ridge tuning parameter <code class="reqn">\xi</code>.ridge, which has to be determined by a suitable technique, e.g. by K-fold cross validation.
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> pencoxfrail</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-25</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>for loading a dataset type data(nameofdataset)
</p>


<h3>Value</h3>

<p>Generic functions such as <code>print</code>, <code>predict</code>, <code>plot</code> and <code>summary</code> have methods to show the results of the fit.
</p>
<p>The <code>predict</code> function uses also estimates of random effects for prediction, if possible (i.e. for known subjects of the grouping factor). 
Either the survival stepfunction or the baseline hazard (not cumulative!) can be calculated by specifying one of two possible methods: <code>method=c("hazard","survival")</code>. By default, for each new subject in <code>new.data</code> an individual stepfunction is calculated on a pre-specified time grid, also accounting for covariate changes over time. Alternatively, for <code>new.data</code> a single vector of a specific (time-constant) covariate combination can be specified.
</p>
<p>Usage:  <code>
predict(coxlasso.obj,new.data,time.grid,method=c("hazard","survival"))
</code>     
</p>
<p>The <code>plot</code> function plots all time-varying effects, including the baseline hazard. 
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>a list containing an image of the <code>coxlasso</code> call that produced the object.</p>
</td></tr>  
<tr><td><code>baseline</code></td>
<td>
<p>a vector containing the estimated B-spline coefficients of the baseline hazard.
If the covariates corresponding to the time-varying effects are centered (and standardized, see <code><a href="#topic+coxlassoControl">coxlassoControl</a></code>), the coefficients are transformed back to the original scale.</p>
</td></tr> 
<tr><td><code>time.vary</code></td>
<td>
<p>a vector containing the estimated B-spline coefficients of all time-varying effects.
If the covariates corresponding to the time-varying effects are standardized (see <code><a href="#topic+coxlassoControl">coxlassoControl</a></code>) 
the coefficients are transformed back to the original scale.</p>
</td></tr> 
<tr><td><code>coefficients</code></td>
<td>
<p>a vector containing the estimated fixed effects.</p>
</td></tr>
<tr><td><code>ranef</code></td>
<td>
<p>a vector containing the estimated random effects.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>a scalar or matrix containing the estimates of the random effects standard deviation or variance-covariance parameters, respectively.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p>a matrix containing the estimates of fixed and random effects (columns) for each iteration (rows) of the main algorithm (i.e. before the final re-estimation step is performed, see details).</p>
</td></tr>
<tr><td><code>Q_long</code></td>
<td>
<p>a list containing the estimates of the random effects variance-covariance parameters for each iteration of the main algorithm.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations until the main algorithm has converged.</p>
</td></tr>
<tr><td><code>adaptive.weights</code></td>
<td>
<p>if not given as an argument by the user, a two-column matrix of adaptive weights is calculated by the <code><a href="#topic+coxFL">coxFL</a></code> function; the first column contains the weights <code class="reqn">w_{\Delta,k}</code>, the second column the weights <code class="reqn">v_{k}</code> from <code class="reqn">\xi\cdot J(\zeta,\alpha)</code>.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>vector of knots used in the B-spline representation.</p>
</td></tr>
<tr><td><code>Phi.big</code></td>
<td>
<p>large B-spline design matrix corresponding to the baseline hazard and all time-varying effects. For the time-varying effects, the B-spline functions (as a function of time) have already been multiplied with their associated covariates.</p>
</td></tr>
<tr><td><code>time.grid</code></td>
<td>
<p>the time grid used in when approximating the (Riemann) integral involved in the model's full likelihood.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>number of metric covariates with time-varying effects.</p>
</td></tr>
<tr><td><code>m2</code></td>
<td>
<p>number of categorical covariates with time-varying effects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Groll <a href="mailto:groll@statistik.tu-dortmund.de">groll@statistik.tu-dortmund.de</a> <br /> Maike Hohberg <a href="mailto:mhohber@uni-goettingen.de">mhohber@uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>Groll, A., T. Hastie and G. Tutz (2017). 
Selection of Effects in Cox Frailty Models by
Regularization Methods. <em>Biometrics</em> 73(3): 846-856.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxlassoControl">coxlassoControl</a>,<a href="#topic+cv.coxlasso">cv.coxlasso</a>,<a href="#topic+coxFL">coxFL</a>,<a href="survival.html#topic+Surv">Surv</a>,<a href="survival.html#topic+pbc">pbc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# remove NAs
lung &lt;- lung[!is.na(lung$inst),]

# transform inst into factor variable
lung$inst &lt;- as.factor(lung$inst)

# just for illustration, create factor with only three ph.ecog classes
lung$ph.ecog[is.na(lung$ph.ecog)] &lt;- 2
lung$ph.ecog[lung$ph.ecog==3] &lt;- 2
lung$ph.ecog &lt;- as.factor(lung$ph.ecog)

fix.form &lt;- as.formula("Surv(time, status) ~ 1 + age + ph.ecog + sex")

ridge.obj &lt;- coxridge(fix=fix.form, data=lung, xi.ridge=10,
                control=list(print.iter=TRUE, exact = 1))
coef(ridge.obj)             
                

# now add random institutional effect
ridge.obj2 &lt;- coxridge(fix=fix.form, rnd = list(inst=~1), 
              data=lung, xi.ridge=10,control=list(print.iter=TRUE, exact = 1))
coef(ridge.obj2)             
# print frailty Std.Dev.
print(ridge.obj2$Q)
# print frailties
print(ridge.obj2$ranef)


# now fit a time-varying effect for age
fix.form &lt;- as.formula("Surv(time, status) ~ 1 + ph.ecog + sex")
vary.coef &lt;- as.formula("~ age")

ridge.obj3 &lt;- ridgelasso(fix=fix.form,vary.coef=vary.coef,  
              data=lung, xi.ridge=10,control=list(print.iter=TRUE))
summary(ridge.obj3)

# show fit
plot(ridge.obj3)

# predict survival curve of new subject, institution 1 and up to time 300
pred.obj &lt;- predict(ridge.obj2, newdata=data.frame(inst=1, time=NA, status=NA, age=26,
              ph.ecog=2,sex=1), time.grid=seq(0,300,by=1))

# plot predicted hazard function
plot(pred.obj$time.grid,pred.obj$haz,type="l",xlab="time",ylab="hazard")

# plot predicted survival function
plot(pred.obj$time.grid,pred.obj$survival,type="l",xlab="time",ylab="survival")

## specify a larger new data set
new.data &lt;- data.frame(inst=c(1,1,6), time=c(20,40,200), 
      status=c(NA,NA,NA), age=c(26,26,54), ph.ecog=c(0,0,2),sex=c(1,1,1))

## as here no frailties have been specified, id.var needs to be given!
pred.obj2 &lt;- predict(lasso.obj3, newdata=new.data,id.var = "inst")

# plot predicted hazard functions (for the available time intervals)
plot(pred.obj2$time.grid[!is.na(pred.obj2$haz[,1])],
      pred.obj2$haz[,1][!is.na(pred.obj2$haz[,1])],
      type="l",xlab="time",ylab="hazard",xlim=c(0,200),
      ylim=c(0,max(pred.obj2$haz,na.rm=T)))
lines(pred.obj2$time.grid[!is.na(pred.obj2$haz[,3])],
      pred.obj2$haz[,3][!is.na(pred.obj2$haz[,3])],
      col="red",lty=2,)

# plot predicted survival functions (for the available time intervals)
plot(pred.obj2$time.grid[!is.na(pred.obj2$survival[,1])],
    pred.obj2$survival[,1][!is.na(pred.obj2$survival[,1])],
    type="l",xlab="time",ylab="hazard",xlim=c(0,200),
    ylim=c(0,max(pred.obj2$survival,na.rm=T)))
lines(pred.obj2$time.grid[!is.na(pred.obj2$survival[,3])],
      pred.obj2$survival[,3][!is.na(pred.obj2$survival[,3])],
      col="red",lty=2,)


# see also demo("coxlasso-lung")

## End(Not run)</code></pre>

<hr>
<h2 id='cv.coxlasso'>Cross-validation for coxlasso</h2><span id='topic+cv.coxlasso'></span>

<h3>Description</h3>

<p>performs k-fold cross-validation for <code>coxlasso</code>, produces a plot, and returns a value for the LASSO tuning parameter <code class="reqn">\xi</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.coxlasso(fix, rnd = NULL, vary.coef = NULL, n.folds = 10, xi = NULL,
            data, adaptive.weights = NULL, print.fold = TRUE, print.xi = FALSE,
            len.xi = 100, lgrid = TRUE, ran.seed = 1909, xi.factor = 1.01, min.fold = 4,
            pass.on.start = TRUE, control = list(print.iter = FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.coxlasso_+3A_fix">fix</code></td>
<td>
<p>a two-sided linear formula object describing the fixed (time-constant) effects part of the model, with the response on the left of a
<code>~</code> operator and the terms, separated by <code>+</code> operators, on
the right. The response must be a survival object as returned by the <code><a href="survival.html#topic+Surv">Surv</a></code> function.</p>
</td></tr>  
<tr><td><code id="cv.coxlasso_+3A_rnd">rnd</code></td>
<td>
<p>a two-sided linear formula object describing the
random-effects part of the model, with the grouping factor on the left of a
<code>~</code> operator and the random terms, separated by <code>+</code> operators, on
the right. Default is NULL, so no random effects are present.</p>
</td></tr>
<tr><td><code id="cv.coxlasso_+3A_vary.coef">vary.coef</code></td>
<td>
<p>a one-sided linear formula object describing the
time-varying effects part of the model, with the time-varying terms, separated by <code>+</code> operators,
on the right side of a <code>~</code> operator. Default is NULL, so no time-varying effects are incorporated.</p>
</td></tr>
<tr><td><code id="cv.coxlasso_+3A_n.folds">n.folds</code></td>
<td>
<p>number of folds. Default is 10.</p>
</td></tr> 
<tr><td><code id="cv.coxlasso_+3A_xi">xi</code></td>
<td>
<p>Optional user-supplied xi sequence; default is NULL, and cv.coxlasso chooses its own sequence</p>
</td></tr>
<tr><td><code id="cv.coxlasso_+3A_data">data</code></td>
<td>
<p>the data frame containing the variables named in the three preceding
<code>formula</code> arguments.</p>
</td></tr>
<tr><td><code id="cv.coxlasso_+3A_adaptive.weights">adaptive.weights</code></td>
<td>
<p>for the LASSO-penalized fixed effects a vector of adaptive weights can be passed to the procedure. If no adaptive weights are specified, an unpenalized model (i.e. <code class="reqn">\xi=0</code>) is fitted by the <code><a href="#topic+coxFL">coxFL</a></code> function and the obtained estimates are used as adaptive weights (see value section).</p>
</td></tr> 
<tr><td><code id="cv.coxlasso_+3A_print.fold">print.fold</code></td>
<td>
<p>Should folds of CV be printed? Default is yes.</p>
</td></tr>
<tr><td><code id="cv.coxlasso_+3A_print.xi">print.xi</code></td>
<td>
<p>Should current <code class="reqn">\xi</code> value be printed? Default is no.</p>
</td></tr>
<tr><td><code id="cv.coxlasso_+3A_len.xi">len.xi</code></td>
<td>
<p>Length of <code class="reqn">\xi</code> grid. Default is 100.</p>
</td></tr>
<tr><td><code id="cv.coxlasso_+3A_lgrid">lgrid</code></td>
<td>
<p>Logical; shall a logarithmized grid version for the penalty parameter be used? Default is TRUE.</p>
</td></tr>
<tr><td><code id="cv.coxlasso_+3A_ran.seed">ran.seed</code></td>
<td>
<p>Random seed number to be set. Default is 1909, the year of birth of Borussia Dortmund football club.</p>
</td></tr>
<tr><td><code id="cv.coxlasso_+3A_xi.factor">xi.factor</code></td>
<td>
<p>A factor which increases xi.max once again to be sure that xi is large enough on all sets. Default is 1.01</p>
</td></tr>
<tr><td><code id="cv.coxlasso_+3A_min.fold">min.fold</code></td>
<td>
<p>Only those xi values are taken into account where at least min.fold folds are not NA. Default is 4.</p>
</td></tr>
<tr><td><code id="cv.coxlasso_+3A_pass.on.start">pass.on.start</code></td>
<td>
<p>Shall starting values be passed onthroughout estimation? Default is TRUE</p>
</td></tr>
<tr><td><code id="cv.coxlasso_+3A_control">control</code></td>
<td>
<p>a list of control values for the estimation algorithm to replace the default values returned by the function <code><a href="#topic+coxlassoControl">coxlassoControl</a></code>. Default is <code>print.iter = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code>coxlasso</code> over a grid of values <code class="reqn">\xi</code> for each training data set with one fold omitted. 
</p>
<p>For each run, the value for the full likelihood is calculated and the average for each <code class="reqn">\xi</code> on the grid is computed over the folds. The function choses the <code class="reqn">\xi</code> that maximizes this likelihood value as the optimal tuning parameter value.  
</p>


<h3>Value</h3>

<p>The function returns a list <code>"cv.coxlasso"</code> which includes:    
</p>
<table>
<tr><td><code>cv.error</code></td>
<td>
<p>a vector of mean CV error (i.e., negative likelihood) values for each <code class="reqn">\xi</code> on the grid averaged over the folds.</p>
</td></tr>
<tr><td><code>xi.opt</code></td>
<td>
<p>a scalar value of <code class="reqn">\xi</code> associated with the smallest CV error.</p>
</td></tr>
<tr><td><code>xi.1se</code></td>
<td>
<p>largest value of <code class="reqn">\xi</code> such that error is within 1 standard error of the minimum.</p>
</td></tr>
</table>
<p>The <code>plot</code> function plots the values of <code class="reqn">\xi</code> against the corresponding CV error (i.e., negative likelihood) values.   
</p>


<h3>Author(s)</h3>

<p>Andreas Groll  <a href="mailto:groll@statistik.tu-dortmund.de">groll@statistik.tu-dortmund.de</a> <br />
Maike Hohberg <a href="mailto:mhohber@uni-goettingen.de">mhohber@uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>To appear soon.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxlasso">coxlasso</a>, <a href="#topic+coxlassoControl">coxlassoControl</a>, <a href="#topic+coxFL">coxFL</a>, <a href="survival.html#topic+Surv">Surv</a>, <a href="survival.html#topic+pbc">pbc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(lung)

# remove NAs
lung &lt;- lung[!is.na(lung$inst),]

# transform inst into factor variable
lung$inst &lt;- as.factor(lung$inst)

# just for illustration, create factor with only three ph.ecog classes
lung$ph.ecog[is.na(lung$ph.ecog)] &lt;- 2
lung$ph.ecog[lung$ph.ecog==3] &lt;- 2
lung$ph.ecog &lt;- as.factor(lung$ph.ecog)

fix.form &lt;- as.formula("Surv(time, status) ~ 1 + age + ph.ecog + sex")

# find optimal tuning paramater
cv.coxlasso.obj &lt;- cv.coxlasso(fix = fix.form, data = lung, n.folds = 5)

# estimate coxlasso model with optimal xi
lasso.obj &lt;- coxlasso(fix=fix.form, data=lung, xi=cv.coxlasso.obj$xi.opt,
                control=list(print.iter=TRUE))

coef(lasso.obj)             
                

# see also demo("coxlasso-lung")

## End(Not run)</code></pre>

<hr>
<h2 id='int.approx'>Approximation of a Cox likelihood intergral</h2><span id='topic+int.approx'></span>

<h3>Description</h3>

<p>The function approximates the integral <code class="reqn">\int_0^t exp(u B(s) \alpha) ds)</code> which appears in the (full) Cox likelihood
if the covariate <code class="reqn">u</code> has a time-varying effect <code class="reqn">\beta(t)</code>, which is expanded in B-splines, i.e. <code class="reqn">\beta(t) = B(t) \alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int.approx(z,time.grid,B,nbasis,alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int.approx_+3A_z">z</code></td>
<td>
<p>a vector which contains at the first component a time point up to which it should be integrated and the covariates <code class="reqn">u</code> in the remaining components.</p>
</td></tr>
<tr><td><code id="int.approx_+3A_time.grid">time.grid</code></td>
<td>
<p>an equally-spaced time grid on which the B-spline design matrix <code class="reqn">B</code> has been generated.
The maximal value of the time grid should usually be the maximal upper integral border that is of interest.</p>
</td></tr>
<tr><td><code id="int.approx_+3A_b">B</code></td>
<td>
<p>a B-spline design matrix, which has been created with the function <code><a href="#topic+bs.design">bs.design</a></code> on the full time grid <code>time.grid</code>.</p>
</td></tr>
<tr><td><code id="int.approx_+3A_nbasis">nbasis</code></td>
<td>
<p>number of basis functions used when the B-spline design matrix <code class="reqn">B</code> has been generated.</p>
</td></tr>
<tr><td><code id="int.approx_+3A_alpha">alpha</code></td>
<td>
<p>vector of B-spline coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The B-spline design matrix is returned.
</p>


<h3>Author(s)</h3>

<p>Andreas Groll <a href="mailto:groll@math.lmu.de">groll@math.lmu.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pencoxfrail">pencoxfrail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate time grid and corresponding B-spline design matrix
time.grid &lt;- seq(0,200,by=1)
B &lt;- bs.design(x=time.grid, xl=min(time.grid), xr=max(time.grid), spline.degree=3, nbasis=5)

## specify spline coefficients and covariate vector (with upper integral bound as first component)
alpha &lt;- c(0.1,0.2,0.05,0.1,0.15)
z &lt;- c(time=100,age=25)

## calculate intergal from 0 to 100
int.approx(z=z,time.grid=time.grid,B=B,nbasis=5,alpha=alpha)
</code></pre>

<hr>
<h2 id='pencoxfrailControl'>Control Values for <code>pencoxfrail</code> fit</h2><span id='topic+pencoxfrailControl'></span>

<h3>Description</h3>

<p>The values supplied in the function call replace the defaults and a list with all possible arguments is returned. The returned list is used as the <code>control</code> argument to the <code>pencoxfrail</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
pencoxfrailControl(start = NULL, q_start = NULL, conv.eps = 1e-4, 
                          standardize = FALSE, center = FALSE,
                          smooth=list(nbasis = 6, penal = 0.1), 
                          ridge.pen = 1e-4, print.iter = FALSE, 
                          max.iter = 100, c.app = 1e-6, zeta = 0.5, 
                          exact = 1e-2, xr = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pencoxfrailControl_+3A_start">start</code></td>
<td>
<p>a vector of suitable length containing starting values for the spline-coefficients of the baseline hazard and the time-varying effects, followed by the fixed and random effects. The correct ordering is important. Default is a vector full of zeros.</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_q_start">q_start</code></td>
<td>
<p>a scalar or matrix of suitable dimension, specifying starting values for the random-effects variance-covariance matrix. Default is a scalar 0.1 or diagonal matrix with 0.1 in the diagonal, depending on the dimension of the random effects.</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_conv.eps">conv.eps</code></td>
<td>
<p>controls the speed of convergence. Default is 1e-4.</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_center">center</code></td>
<td>
<p>logical. If true, the covariates corresponding to the time-varying effects will be
centered. Default is FALSE (and centering is only recommended if really necessary; it can also have a strong effect on the baseline hazard, in particular, if a strong penalty is selected).</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_standardize">standardize</code></td>
<td>
<p>logical. If true, the the covariates corresponding to the time-varying effects will be
scaled to a variance equal to one (*after* possible centering). Default is FALSE.</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_smooth">smooth</code></td>
<td>
<p>a list specifying the number of basis functions <code>nbasis</code> (used for the baseline hazard and all time-varying effects) and the smoothness penalty parameter <code>penal</code>, which is only applied to the baseline hazard. All time-varying effects are penalized by the specific double-penalty <code class="reqn">\xi\cdot J(\zeta,\alpha)</code> (see <code><a href="#topic+pencoxfrail">pencoxfrail</a></code>), which is based on the overall penalty parameter <code class="reqn">\xi</code> (specified in the main function <code><a href="#topic+pencoxfrail">pencoxfrail</a></code>) and on the weighting between the two penalty parts <code class="reqn">\zeta</code>. The degree of the B-splines is fixed to be three (i.e. cubic splines).</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_ridge.pen">ridge.pen</code></td>
<td>
<p>On all time-varying effects (except for the baseline hazard) a slight ridge penalty is applied on the second order differences of the corresponding spline coefficients to stabilize estimation. Default is 1e-4.</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_print.iter">print.iter</code></td>
<td>
<p>logical. Should the number of iterations be printed? Default is FALSE.</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_max.iter">max.iter</code></td>
<td>
<p>the number of iterations for the final Fisher scoring re-estimation procedure. Default is 200.</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_c.app">c.app</code></td>
<td>
<p>The parameter controlling the exactness of the quadratic approximations of the penalties. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_zeta">zeta</code></td>
<td>
<p>The parameter controlling the weighting between the two penalty parts in the specific double-penalty <code class="reqn">\xi\cdot J(\zeta,\alpha)</code> (see <code><a href="#topic+pencoxfrail">pencoxfrail</a></code>). Default is 0.5.</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_exact">exact</code></td>
<td>
<p>controls the exactness of the (Riemann) integral approximations. Default is 1e-2.</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_xr">xr</code></td>
<td>
<p>maximal time point that is regarded. Default is NULL and the maximal event or censoring time point in the data is used.</p>
</td></tr>
<tr><td><code id="pencoxfrailControl_+3A_...">...</code></td>
<td>
<p>Futher arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components for each of the possible arguments.
</p>


<h3>Author(s)</h3>

<p>Andreas Groll <a href="mailto:groll@math.lmu.de">groll@math.lmu.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pencoxfrail">pencoxfrail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use different weighting of the two penalty parts
# and lighten the convergence criterion 
pencoxfrailControl(zeta=0.3, conv.eps=1e-3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
