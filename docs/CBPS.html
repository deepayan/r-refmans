<!DOCTYPE html><html><head><title>Help for package CBPS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CBPS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AsyVar'><p>Asymptotic Variance and Confidence Interval Estimation of the ATE</p></a></li>
<li><a href='#balance'><p>Optimal Covariate Balance</p></a></li>
<li><a href='#balance.CBPS'><p>Calculates the pre- and post-weighting difference in standardized means for covariate within each contrast</p></a></li>
<li><a href='#balance.CBPSContinuous'><p>Calculates the pre- and post-weighting correlations between each covariate and the T</p></a></li>
<li><a href='#balance.npCBPS'><p>Calls the appropriate balance function based on the number of treatments</p></a></li>
<li><a href='#Blackwell'><p>Blackwell Data for Covariate Balancing Propensity Score</p></a></li>
<li><a href='#CBIV'><p>Covariate Balancing Propensity Score for Instrumental Variable Estimates</p>
(CBIV)</a></li>
<li><a href='#CBMSM'><p>Covariate Balancing Propensity Score (CBPS) for Marginal Structural Models</p></a></li>
<li><a href='#CBMSM.fit'><p>CBMSM.fit</p></a></li>
<li><a href='#CBPS'><p>Covariate Balancing Propensity Score (CBPS) Estimation</p></a></li>
<li><a href='#CBPS.fit'><p>CBPS.fit determines the proper routine (what kind of treatment) and calls the</p>
approporiate function.  It also pre- and post-processes the data</a></li>
<li><a href='#hdCBPS'><p>hdCBPS high dimensional CBPS method to parses the formula object and passes the result to hdCBPS.fit, which calculates ATE using CBPS method in a high dimensional setting.</p></a></li>
<li><a href='#LaLonde'><p>LaLonde Data for Covariate Balancing Propensity Score</p></a></li>
<li><a href='#npCBPS'><p>Non-Parametric Covariate Balancing Propensity Score (npCBPS) Estimation</p></a></li>
<li><a href='#npCBPS.fit'><p>npCBPS.fit</p></a></li>
<li><a href='#plot.CBMSM'><p>Plotting CBPS Estimation for Marginal Structural Models</p></a></li>
<li><a href='#plot.CBPS'><p>Plotting Covariate Balancing Propensity Score Estimation</p></a></li>
<li><a href='#plot.CBPSContinuous'><p>Plot the pre-and-post weighting correlations between X and T</p></a></li>
<li><a href='#plot.npCBPS'><p>Calls the appropriate plot function, based on the number of treatments</p></a></li>
<li><a href='#print.CBPS'><p>Print coefficients and model fit statistics</p></a></li>
<li><a href='#summary.CBPS'><p>Summarizing Covariate Balancing Propensity Score Estimation</p></a></li>
<li><a href='#vcov_outcome'><p>Calculate Variance-Covariance Matrix for Outcome Model</p></a></li>
<li><a href='#vcov_outcome.CBPSContinuous'><p>vcov_outcome</p></a></li>
<li><a href='#vcov.CBPS'><p>Calculate Variance-Covariance Matrix for a Fitted CBPS Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.23</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-01-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Covariate Balancing Propensity Score</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4), MASS, MatchIt, nnet, numDeriv, glmnet</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the covariate balancing propensity score (CBPS) proposed
    by Imai and Ratkovic (2014) &lt;<a href="https://doi.org/10.1111%2Frssb.12027">doi:10.1111/rssb.12027</a>&gt;. The propensity score is
    estimated such that it maximizes the resulting covariate balance as well as the
    prediction of treatment assignment. The method, therefore, avoids an iteration
    between model fitting and balance checking.  The package also implements optimal
    CBPS from Fan et al. (in-press) &lt;<a href="https://doi.org/10.1080%2F07350015.2021.2002159">doi:10.1080/07350015.2021.2002159</a>&gt;,  
    several extensions of the CBPS beyond the cross-sectional, binary treatment setting.
    They include the CBPS for longitudinal settings so that it can be used in 
    conjunction with marginal structural models from Imai and Ratkovic (2015) 
    &lt;<a href="https://doi.org/10.1080%2F01621459.2014.956872">doi:10.1080/01621459.2014.956872</a>&gt;, treatments with three- and four-valued treatment 
    variables, continuous-valued treatments from Fong, Hazlett, and Imai (2018) 
    &lt;<a href="https://doi.org/10.1214%2F17-AOAS1101">doi:10.1214/17-AOAS1101</a>&gt;, propensity score estimation with a large number of 
    covariates from Ning, Peng, and Imai (2020) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasaa020">doi:10.1093/biomet/asaa020</a>&gt;, and the situation 
    with multiple distinct binary treatments administered simultaneously. In the future 
    it will be extended to other settings including the generalization of experimental 
    and instrumental variable estimates. </td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-18 16:34:12 UTC; chris</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Fong [aut, cre],
  Marc Ratkovic [aut],
  Kosuke Imai [aut],
  Chad Hazlett [ctb],
  Xiaolin Yang [ctb],
  Sida Peng [ctb],
  Inbeom Lee [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Fong &lt;cjfong@umich.edu&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-18 18:02:52 UTC</td>
</tr>
</table>
<hr>
<h2 id='AsyVar'>Asymptotic Variance and Confidence Interval Estimation of the ATE</h2><span id='topic+AsyVar'></span>

<h3>Description</h3>

<p><code>AsyVar</code> estimates the asymptotic variance of the ATE obtained with the CBPS or oCBPS method. It also returns the finite variance estimate, the finite standard error, and a CI for the ATE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AsyVar(
  Y,
  Y_1_hat = NULL,
  Y_0_hat = NULL,
  CBPS_obj,
  method = "CBPS",
  X = NULL,
  TL = NULL,
  pi = NULL,
  mu = NULL,
  CI = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AsyVar_+3A_y">Y</code></td>
<td>
<p>The vector of actual outcome values (observations).</p>
</td></tr>
<tr><td><code id="AsyVar_+3A_y_1_hat">Y_1_hat</code></td>
<td>
<p>The vector of estimated outcomes according to the treatment model. (AsyVar automatically sets the treatment model as a linear regression model and it is fitted within the function.) If <code>CBPS_obj</code> is specified, or if <code>X</code> <code class="reqn">and</code> <code>TL</code> are specified, this is unnecessary.</p>
</td></tr>
<tr><td><code id="AsyVar_+3A_y_0_hat">Y_0_hat</code></td>
<td>
<p>The vector of estimated outcomes according to the control model. (AsyVar automatically sets the control model as a linear regression model and it is fitted within the function.) If <code>CBPS_obj</code> is specified, or if <code>X</code> <code class="reqn">and</code> <code>TL</code> are specified, this is unnecessary.</p>
</td></tr>
<tr><td><code id="AsyVar_+3A_cbps_obj">CBPS_obj</code></td>
<td>
<p>An object obtained with the CBPS function. If this object is not sepecified, then <code>X</code>, <code>TL</code>, <code>pi</code>, and <code>mu</code> must <code class="reqn">all</code> be specified instead.</p>
</td></tr>
<tr><td><code id="AsyVar_+3A_method">method</code></td>
<td>
<p>The specific method to be considered. Either <code>"CBPS"</code> or <code>"oCBPS"</code> must be selected.</p>
</td></tr>
<tr><td><code id="AsyVar_+3A_x">X</code></td>
<td>
<p>The matrix of covariates with the rows corresponding to the observations and the columns corresponding to the variables. The left most column must be a column of 1's for the intercept. (<code>X</code> is not necessary if <code>CBPS_obj</code> is specified.)</p>
</td></tr>
<tr><td><code id="AsyVar_+3A_tl">TL</code></td>
<td>
<p>The vector of treatment labels. More specifically, the label is 1 if it is in the treatment group and 0 if it is in the control group. (<code>TL</code> is not necessary if <code>CBPS_obj</code> is specified.)</p>
</td></tr>
<tr><td><code id="AsyVar_+3A_pi">pi</code></td>
<td>
<p>The vector of estimated propensity scores. (<code>pi</code> is not necessary if <code>CBPS_obj</code> is specified.)</p>
</td></tr>
<tr><td><code id="AsyVar_+3A_mu">mu</code></td>
<td>
<p>The estimated average treatment effect obtained with either the CBPS or oCBPS method. (<code>mu</code> is not necessary if <code>CBPS_obj</code> is specified.)</p>
</td></tr>
<tr><td><code id="AsyVar_+3A_ci">CI</code></td>
<td>
<p>The specified confidence level (between 0 and 1) for calculating the confidence interval for the average treatment effect. Default value is 0.95.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>mu.hat</code></td>
<td>
<p>The estimated average treatment effect, <code class="reqn">hat{\mu}</code>.</p>
</td></tr> 
<tr><td><code>asy.var</code></td>
<td>
<p>The estimated asymptotic variance of <code class="reqn">\sqrt{n}*hat{\mu}</code> obtained with the CBPS or oCBPS method.</p>
</td></tr> 
<tr><td><code>var</code></td>
<td>
<p>The estimated variance of <code class="reqn">hat{\mu}</code> obtained with the CBPS or oCBPS method.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>The standard error of <code class="reqn">hat{\mu}</code> obtained with the CBPS or oCBPS method.</p>
</td></tr>
<tr><td><code>CI.mu.hat</code></td>
<td>
<p>The confidence interval of <code class="reqn">hat{\mu}</code> obtained with the CBPS or oCBPS method with the confidence level specified in the input argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Inbeom Lee
</p>


<h3>References</h3>

<p>Fan, Jianqing and Imai, Kosuke and Lee, Inbeom and Liu, Han and Ning, Yang and Yang, Xiaolin. 2021. 
&ldquo;Optimal Covariate Balancing Conditions in Propensity Score Estimation.&rdquo; Journal of Business &amp; Economic Statistics. 
<a href="https://imai.fas.harvard.edu/research/CBPStheory.html">https://imai.fas.harvard.edu/research/CBPStheory.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#GENERATING THE DATA
n=300
          
#Initialize the X matrix.
X_v1 &lt;- rnorm(n,3,sqrt(2))
X_v2 &lt;- rnorm(n,0,1)
X_v3 &lt;- rnorm(n,0,1)
X_v4 &lt;- rnorm(n,0,1)
X_mat &lt;- as.matrix(cbind(rep(1,n), X_v1, X_v2, X_v3, X_v4)) 
          
#Initialize the Y_1 and Y_0 vector using the treatment model and the control model.
Y_1 &lt;- X_mat %*% matrix(c(200, 27.4, 13.7, 13.7, 13.7), 5, 1) + rnorm(n)
Y_0 &lt;- X_mat %*% matrix(c(200, 0 , 13.7, 13.7, 13.7), 5, 1) + rnorm(n)
          
#True Propensity Score calculation.
pre_prop &lt;- X_mat[,2:5] %*% matrix(c(0, 0.5, -0.25, -0.1), 4, 1)
propensity_true &lt;- (exp(pre_prop))/(1+(exp(pre_prop)))
          
#Generate T_vec, the treatment vector, with the true propensity scores.
T_vec &lt;- rbinom(n, size=1, prob=propensity_true)
          
#Now generate the actual outcome Y_outcome (accounting for treatment/control groups).
Y_outcome &lt;- Y_1*T_vec + Y_0*(1-T_vec)
          
#Use oCBPS.
ocbps.fit &lt;- CBPS(T_vec ~ X_mat, ATT=0, baseline.formula = ~X_mat[,c(1,3:5)], 
                 diff.formula = ~X_mat[,2])
          
#Use the AsyVar function to get the asymptotic variance of the 
#estimated average treatment effect and its confidence interval when using oCBPS.
AsyVar(Y=Y_outcome, CBPS_obj=ocbps.fit, method="oCBPS", CI=0.95)

#Use CBPS.
cbps.fit &lt;- CBPS(T_vec ~ X_mat, ATT=0)

#Use the AsyVar function to get the asymptotic variance of the
#estimated average treatment effect and its confidence interval when using CBPS.
AsyVar(Y=Y_outcome, CBPS_obj=cbps.fit, method="CBPS", CI=0.95)

</code></pre>

<hr>
<h2 id='balance'>Optimal Covariate Balance</h2><span id='topic+balance'></span>

<h3>Description</h3>

<p>Returns the mean and standardized mean associated with each treatment group,
before and after weighting.  To access more comprehensive diagnotistics for 
assessing covariate balance, consider using Noah Greifer's <code>cobalt</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balance_+3A_object">object</code></td>
<td>
<p>A CBPS, npCBPS, or CBMSM object.</p>
</td></tr>
<tr><td><code id="balance_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to balance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For binary and multi-valued treatments as well as marginal structural
models, each of the matrices' rows are the covariates and whose columns are
the weighted mean, and standardized mean associated with each treatment
group.  The standardized mean is the weighted mean divided by the standard
deviation of the covariate for the whole population.  For continuous
treatments, returns the absolute Pearson correlation between the treatment
and each covariate.
</p>
<p>### @aliases balance balance.npCBPS balance.CBPS balance.CBMSM
</p>


<h3>Value</h3>

<p>Returns a list of two matrices, &quot;original&quot; (before weighting) and
&quot;balanced&quot; (after weighting).
</p>


<h3>Author(s)</h3>

<p>Christian Fong, Marc Ratkovic, and Kosuke Imai.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###
### Example: Assess Covariate Balance
###
data(LaLonde)
## Estimate CBPS
fit &lt;- CBPS(treat ~ age + educ + re75 + re74 + 
			I(re75==0) + I(re74==0), 
			data = LaLonde, ATT = TRUE)
balance(fit)

</code></pre>

<hr>
<h2 id='balance.CBPS'>Calculates the pre- and post-weighting difference in standardized means for covariate within each contrast</h2><span id='topic+balance.CBPS'></span>

<h3>Description</h3>

<p>Calculates the pre- and post-weighting difference in standardized means for covariate within each contrast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBPS'
balance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balance.CBPS_+3A_object">object</code></td>
<td>
<p>A CBPS, npCBPS, or CBMSM object.</p>
</td></tr>
<tr><td><code id="balance.CBPS_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to balance.</p>
</td></tr>
</table>

<hr>
<h2 id='balance.CBPSContinuous'>Calculates the pre- and post-weighting correlations between each covariate and the T</h2><span id='topic+balance.CBPSContinuous'></span>

<h3>Description</h3>

<p>Calculates the pre- and post-weighting correlations between each covariate and the T
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBPSContinuous'
balance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balance.CBPSContinuous_+3A_object">object</code></td>
<td>
<p>A CBPS, npCBPS, or CBMSM object.</p>
</td></tr>
<tr><td><code id="balance.CBPSContinuous_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to balance.</p>
</td></tr>
</table>

<hr>
<h2 id='balance.npCBPS'>Calls the appropriate balance function based on the number of treatments</h2><span id='topic+balance.npCBPS'></span>

<h3>Description</h3>

<p>Calls the appropriate balance function based on the number of treatments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'npCBPS'
balance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balance.npCBPS_+3A_object">object</code></td>
<td>
<p>A CBPS, npCBPS, or CBMSM object.</p>
</td></tr>
<tr><td><code id="balance.npCBPS_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed.</p>
</td></tr>
</table>

<hr>
<h2 id='Blackwell'>Blackwell Data for Covariate Balancing Propensity Score</h2><span id='topic+Blackwell'></span>

<h3>Description</h3>

<p>This data set gives the outcomes a well as treatment assignments and
covariates for the example from Blackwell (2013).
</p>


<h3>Format</h3>

<p>A data frame consisting of 13 columns (including treatment
assignment, time, and identifier vectors) and 570 observations.
</p>


<h3>Source</h3>

<p>d.gone.neg is the treatment. d.gone.neg.l1, d.gone.neg.l2, and
d.gone.neg.l3 are lagged treatment variables. camp.length, deminc,
base.poll, base.und, and office covariates. year is the year of the
particular race, and time goes from the first measurement (time = 1) to the
election (time = 5). demName is the identifier, and demprcnt is the outcome.
</p>


<h3>References</h3>

<p>Blackwell, Matthew. (2013). A framework for dynamic causal
inference in political science. American Journal of Political Science 57, 2,
504-619.
</p>

<hr>
<h2 id='CBIV'>Covariate Balancing Propensity Score for Instrumental Variable Estimates
(CBIV)</h2><span id='topic+CBIV'></span>

<h3>Description</h3>

<p><code>CBIV</code> estimates propensity scores for compliance status in an
instrumental variables setup such that both covariate balance and prediction
of treatment assignment are maximized.  The method, therefore, avoids an
iterative process between model fitting and balance checking and implements
both simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CBIV(
  Tr,
  Z,
  X,
  iterations = 1000,
  method = "over",
  twostep = TRUE,
  twosided = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CBIV_+3A_tr">Tr</code></td>
<td>
<p>A binary treatment variable.</p>
</td></tr>
<tr><td><code id="CBIV_+3A_z">Z</code></td>
<td>
<p>A binary encouragement variable.</p>
</td></tr>
<tr><td><code id="CBIV_+3A_x">X</code></td>
<td>
<p>A pre-treatment covariate matrix.</p>
</td></tr>
<tr><td><code id="CBIV_+3A_iterations">iterations</code></td>
<td>
<p>An optional parameter for the maximum number of iterations
for the optimization.  Default is 1000.</p>
</td></tr>
<tr><td><code id="CBIV_+3A_method">method</code></td>
<td>
<p>Choose &quot;over&quot; to fit an over-identified model that combines
the propensity score and covariate balancing conditions; choose &quot;exact&quot; to
fit a model that only contains the covariate balancing conditions.  Our
simulations suggest that &quot;over&quot; dramatically outperforms &quot;exact.&quot;</p>
</td></tr>
<tr><td><code id="CBIV_+3A_twostep">twostep</code></td>
<td>
<p>Default is <code>TRUE</code> for a two-step GMM estimator, which
will run substantially faster than continuous-updating.  Set to <code>FALSE</code>
to use the continuous-updating GMM estimator.</p>
</td></tr>
<tr><td><code id="CBIV_+3A_twosided">twosided</code></td>
<td>
<p>Default is <code>TRUE</code>, which allows for two-sided
noncompliance with both always-takers and never-takers.  Set to <code>FALSE</code>
for one-sided noncompliance, which allows only for never-takers.</p>
</td></tr>
<tr><td><code id="CBIV_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to <code>optim()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits covariate balancing propensity scores for generalizing local average
treatment effect estimates obtained from instrumental variables analysis.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>A named matrix of coefficients, where the first
column gives the complier coefficients and the second column gives the
always-taker coefficients.</p>
</td></tr> <tr><td><code>fitted.values</code></td>
<td>
<p>The fitted N x 3 compliance
score matrix.  The first column gives the estimated probability of being a
complier, the second column gives the estimated probability of being an
always-taker, and the third column gives the estimated probability of being
a never-taker.</p>
</td></tr> <tr><td><code>weights</code></td>
<td>
<p>The optimal weights: the reciprocal of the
probability of being a complier.</p>
</td></tr> <tr><td><code>deviance</code></td>
<td>
<p>Minus twice the
log-likelihood of the CBIV fit.</p>
</td></tr> <tr><td><code>converged</code></td>
<td>
<p>Convergence value.
Returned from the call to <code>optim()</code>.</p>
</td></tr> <tr><td><code>J</code></td>
<td>
<p>The J-statistic at
convergence</p>
</td></tr> <tr><td><code>df</code></td>
<td>
<p>The number of linearly independent covariates.</p>
</td></tr>
<tr><td><code>bal</code></td>
<td>
<p>The covariate balance associated with the optimal weights,
calculated as the GMM loss of the covariate balance conditions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Fong
</p>


<h3>References</h3>

<p>Imai, Kosuke and Marc Ratkovic.  2014. &ldquo;Covariate Balancing
Propensity Score.&rdquo; Journal of the Royal Statistical Society, Series B
(Statistical Methodology).
<a href="http://imai.princeton.edu/research/CBPS.html">http://imai.princeton.edu/research/CBPS.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###
### Example: propensity score matching
### (Need to fix when we have an actual example).

##Load the LaLonde data
data(LaLonde)
## Estimate CBPS
fit &lt;- CBPS(treat ~ age + educ + re75 + re74 + 
			I(re75==0) + I(re74==0), 
			data = LaLonde, ATT = TRUE)
summary(fit)


</code></pre>

<hr>
<h2 id='CBMSM'>Covariate Balancing Propensity Score (CBPS) for Marginal Structural Models</h2><span id='topic+CBMSM'></span>

<h3>Description</h3>

<p><code>CBMSM</code> estimates propensity scores such that both covariate balance
and prediction of treatment assignment are maximized.  With longitudinal
data, the method returns marginal structural model weights that can be
entered directly into a linear model.  The method also handles multiple
binary treatments administered concurrently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CBMSM(
  formula,
  id,
  time,
  data,
  type = "MSM",
  twostep = TRUE,
  msm.variance = "approx",
  time.vary = FALSE,
  init = "opt",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CBMSM_+3A_formula">formula</code></td>
<td>
<p>A formula of the form treat ~ X.  The same covariates are used
in each time period.  At default values, a single set of coefficients is estimated
across all time periods.  To allow a different set of coefficients for each 
time period, set <code>time.vary = TRUE</code>.   Data should be sorted by time.</p>
</td></tr>
<tr><td><code id="CBMSM_+3A_id">id</code></td>
<td>
<p>A vector which identifies the unit associated with each row of
treat and X.</p>
</td></tr>
<tr><td><code id="CBMSM_+3A_time">time</code></td>
<td>
<p>A vector which identifies the time period associated with each
row of treat and X.  All data should be sorted by time.</p>
</td></tr>
<tr><td><code id="CBMSM_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment (or object coercible
by as.data.frame to a data frame) containing the variables in the model. If
not found in data, the variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>CBMSM</code> is called.  Data should be 
sorted by time.</p>
</td></tr>
<tr><td><code id="CBMSM_+3A_type">type</code></td>
<td>
<p>&quot;MSM&quot; for a marginal structural model, with multiple time
periods or &quot;MultiBin&quot; for multiple binary treatments at the same time
period.</p>
</td></tr>
<tr><td><code id="CBMSM_+3A_twostep">twostep</code></td>
<td>
<p>Set to <code>TRUE</code> to use a two-step estimator, which will
run substantially faster than continuous-updating.  Default is <code>FALSE</code>,
which uses the continuous-updating estimator described by Imai and Ratkovic
(2014).</p>
</td></tr>
<tr><td><code id="CBMSM_+3A_msm.variance">msm.variance</code></td>
<td>
<p>Default is <code>FALSE</code>, which uses the low-rank
approximation of the variance described in Imai and Ratkovic (2014).  Set to
<code>TRUE</code> to use the full variance matrix.</p>
</td></tr>
<tr><td><code id="CBMSM_+3A_time.vary">time.vary</code></td>
<td>
<p>Default is <code>FALSE</code>, which uses the same coefficients
across time period.  Set to <code>TRUE</code> to fit one set per time period.</p>
</td></tr>
<tr><td><code id="CBMSM_+3A_init">init</code></td>
<td>
<p>Default is <code>"opt"</code>, which uses CBPS and logistic regression
starting values, and chooses the one that achieves the best balance.  Other options 
are &quot;glm&quot; and &quot;CBPS&quot;</p>
</td></tr>
<tr><td><code id="CBMSM_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to <code>optim()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits covariate balancing propensity scores for marginal structural models.
</p>
<p>### @aliases CBMSM CBMSM.fit
</p>


<h3>Value</h3>

<table>
<tr><td><code>weights</code></td>
<td>
<p>The optimal weights.</p>
</td></tr> <tr><td><code>fitted.values</code></td>
<td>
<p>The fitted
propensity score for each observation.</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>The treatment vector used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The covariate matrix.</p>
</td></tr> <tr><td><code>id</code></td>
<td>
<p>The vector id used in CBMSM.fit.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>The vector time used in CBMSM.fit.</p>
</td></tr> <tr><td><code>model</code></td>
<td>
<p>The model
frame.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr> <tr><td><code>formula</code></td>
<td>
<p>The formula supplied.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data argument.</p>
</td></tr> <tr><td><code>treat.hist</code></td>
<td>
<p>A matrix of the treatment
history, with each observation in rows and time in columns.</p>
</td></tr>
<tr><td><code>treat.cum</code></td>
<td>
<p>A vector of the cumulative treatment history, by
individual.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marc Ratkovic, Christian Fong, and Kosuke Imai; The CBMSM function
is based on the code for version 2.15.0 of the glm function implemented in
the stats package, originally written by Simon Davies.  This documenation is
likewise modeled on the documentation for glm and borrows its language where
the arguments and values are the same.
</p>


<h3>References</h3>

<p>Imai, Kosuke and Marc Ratkovic.  2014. &ldquo;Covariate Balancing Propensity
Score.&rdquo; Journal of the Royal Statistical Society, Series B (Statistical
Methodology). <a href="http://imai.princeton.edu/research/CBPS.html">http://imai.princeton.edu/research/CBPS.html</a>
</p>
<p>Imai, Kosuke and Marc Ratkovic.  2015.  &ldquo;Robust Estimation of Inverse
Probability Weights for Marginal Structural Models.&rdquo; Journal of the
American Statistical Association.
<a href="http://imai.princeton.edu/research/MSM.html">http://imai.princeton.edu/research/MSM.html</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.CBMSM">plot.CBMSM</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##Load Blackwell data

data(Blackwell)

## Quickly fit a short model to test
form0 &lt;- "d.gone.neg ~ d.gone.neg.l1 + camp.length"
fit0&lt;-CBMSM(formula = form0, time=Blackwell$time,id=Blackwell$demName,
			data=Blackwell, type="MSM",  iterations = NULL, twostep = TRUE, 
			msm.variance = "approx", time.vary = FALSE)

## Not run: 
##Fitting the models in Imai and Ratkovic  (2014)		
##Warning: may take a few mintues; setting time.vary to FALSE
##Results in a quicker fit but with poorer balance
##Usually, it is best to use time.vary TRUE
form1&lt;-"d.gone.neg ~ d.gone.neg.l1 + d.gone.neg.l2 + d.neg.frac.l3 + 
		camp.length + camp.length + deminc + base.poll + year.2002 + 
		year.2004 + year.2006 + base.und + office"

##Note that 	init="glm" gives the published results but the default is now init="opt"
fit1&lt;-CBMSM(formula = form1, time=Blackwell$time,id=Blackwell$demName,
			data=Blackwell, type="MSM",  iterations = NULL, twostep = TRUE, 
			msm.variance = "full", time.vary = TRUE, init="glm")

fit2&lt;-CBMSM(formula = form1, time=Blackwell$time,id=Blackwell$demName,
			data=Blackwell, type="MSM",  iterations = NULL, twostep = TRUE, 
			msm.variance = "approx", time.vary = TRUE, init="glm")


##Assessing balance

bal1&lt;-balance.CBMSM(fit1)
bal2&lt;-balance.CBMSM(fit2)

##Effect estimation: Replicating Effect Estimates in 
##Table 3 of Imai and Ratkovic (2014)

lm1&lt;-lm(demprcnt[time==1]~fit1$treat.hist,data=Blackwell,
weights=fit1$glm.weights)
lm2&lt;-lm(demprcnt[time==1]~fit1$treat.hist,data=Blackwell,
weights=fit1$weights)
lm3&lt;-lm(demprcnt[time==1]~fit1$treat.hist,data=Blackwell,
weights=fit2$weights)

lm4&lt;-lm(demprcnt[time==1]~fit1$treat.cum,data=Blackwell,
weights=fit1$glm.weights)
lm5&lt;-lm(demprcnt[time==1]~fit1$treat.cum,data=Blackwell,
weights=fit1$weights)
lm6&lt;-lm(demprcnt[time==1]~fit1$treat.cum,data=Blackwell,
weights=fit2$weights)



### Example: Multiple Binary Treatments Administered at the Same Time
n&lt;-200
k&lt;-4
set.seed(1040)
X1&lt;-cbind(1,matrix(rnorm(n*k),ncol=k))

betas.1&lt;-betas.2&lt;-betas.3&lt;-c(2,4,4,-4,3)/5
probs.1&lt;-probs.2&lt;-probs.3&lt;-(1+exp(-X1 %*% betas.1))^-1

treat.1&lt;-rbinom(n=length(probs.1),size=1,probs.1)
treat.2&lt;-rbinom(n=length(probs.2),size=1,probs.2)
treat.3&lt;-rbinom(n=length(probs.3),size=1,probs.3)
treat&lt;-c(treat.1,treat.2,treat.3)
X&lt;-rbind(X1,X1,X1)
time&lt;-c(rep(1,nrow(X1)),rep(2,nrow(X1)),rep(3,nrow(X1)))
id&lt;-c(rep(1:nrow(X1),3))
y&lt;-cbind(treat.1,treat.2,treat.3) %*% c(2,2,2) + 
X1 %*% c(-2,8,7,6,2) + rnorm(n,sd=5)

multibin1&lt;-CBMSM(treat~X,id=id,time=time,type="MultiBin",twostep=TRUE)
summary(lm(y~-1+treat.1+treat.2+treat.3+X1, weights=multibin1$w))

## End(Not run)

</code></pre>

<hr>
<h2 id='CBMSM.fit'>CBMSM.fit</h2><span id='topic+CBMSM.fit'></span>

<h3>Description</h3>

<p>CBMSM.fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CBMSM.fit(
  treat,
  X,
  id,
  time,
  MultiBin.fit,
  twostep,
  msm.variance,
  time.vary,
  init,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CBMSM.fit_+3A_treat">treat</code></td>
<td>
<p>A vector of treatment assignments.  For N observations over T
time periods, the length of treat should be N*T.</p>
</td></tr>
<tr><td><code id="CBMSM.fit_+3A_x">X</code></td>
<td>
<p>A covariate matrix.  For N observations over T time periods, X
should have N*T rows.</p>
</td></tr>
<tr><td><code id="CBMSM.fit_+3A_id">id</code></td>
<td>
<p>A vector which identifies the unit associated with each row of
treat and X.</p>
</td></tr>
<tr><td><code id="CBMSM.fit_+3A_time">time</code></td>
<td>
<p>A vector which identifies the time period associated with each
row of treat and X.</p>
</td></tr>
<tr><td><code id="CBMSM.fit_+3A_multibin.fit">MultiBin.fit</code></td>
<td>
<p>A parameter for whether the multiple binary treatments
occur concurrently (<code>FALSE</code>) or over consecutive time periods
(<code>TRUE</code>) as in a marginal structural model.  Setting type = &quot;MultiBin&quot;
when calling <code>CBMSM</code> will set MultiBin.fit to <code>TRUE</code> when
CBMSM.fit is called.</p>
</td></tr>
<tr><td><code id="CBMSM.fit_+3A_twostep">twostep</code></td>
<td>
<p>Set to <code>TRUE</code> to use a two-step estimator, which will
run substantially faster than continuous-updating.  Default is <code>FALSE</code>,
which uses the continuous-updating estimator described by Imai and Ratkovic
(2014).</p>
</td></tr>
<tr><td><code id="CBMSM.fit_+3A_msm.variance">msm.variance</code></td>
<td>
<p>Default is <code>FALSE</code>, which uses the low-rank
approximation of the variance described in Imai and Ratkovic (2014).  Set to
<code>TRUE</code> to use the full variance matrix.</p>
</td></tr>
<tr><td><code id="CBMSM.fit_+3A_time.vary">time.vary</code></td>
<td>
<p>Default is <code>FALSE</code>, which uses the same coefficients
across time period.  Set to <code>TRUE</code> to fit one set per time period.</p>
</td></tr>
<tr><td><code id="CBMSM.fit_+3A_init">init</code></td>
<td>
<p>Default is <code>"opt"</code>, which uses CBPS and logistic regression
starting values, and chooses the one that achieves the best balance.  Other options 
are &quot;glm&quot; and &quot;CBPS&quot;</p>
</td></tr>
<tr><td><code id="CBMSM.fit_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to <code>optim()</code></p>
</td></tr>
</table>

<hr>
<h2 id='CBPS'>Covariate Balancing Propensity Score (CBPS) Estimation</h2><span id='topic+CBPS'></span>

<h3>Description</h3>

<p><code>CBPS</code> estimates propensity scores such that both covariate balance and
prediction of treatment assignment are maximized.  The method, therefore,
avoids an iterative process between model fitting and balance checking and
implements both simultaneously. For cross-sectional data, the method can
take continuous treatments and treatments with a control (baseline)
condition and either 1, 2, or 3 distinct treatment conditions.
</p>
<p>Fits covariate balancing propensity scores.
</p>
<p>### @aliases CBPS CBPS.fit print.CBPS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CBPS(
  formula,
  data,
  na.action,
  ATT = 1,
  iterations = 1000,
  standardize = TRUE,
  method = "over",
  twostep = TRUE,
  sample.weights = NULL,
  baseline.formula = NULL,
  diff.formula = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CBPS_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>formula</code> (or one that can be coerced
to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="CBPS_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment (or object coercible
by as.data.frame to a data frame) containing the variables in the model. If
not found in data, the variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>CBPS</code> is called.</p>
</td></tr>
<tr><td><code id="CBPS_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen when the data
contain NAs. The default is set by the na.action setting of options, and is
na.fail if that is unset.</p>
</td></tr>
<tr><td><code id="CBPS_+3A_att">ATT</code></td>
<td>
<p>Default is 1, which finds the average treatment effect on the
treated interpreting the second level of the treatment factor as the
treatment.  Set to 2 to find the ATT interpreting the first level of the
treatment factor as the treatment.  Set to 0 to find the average treatment
effect. For non-binary treatments, only the ATE is available.</p>
</td></tr>
<tr><td><code id="CBPS_+3A_iterations">iterations</code></td>
<td>
<p>An optional parameter for the maximum number of iterations
for the optimization.  Default is 1000.</p>
</td></tr>
<tr><td><code id="CBPS_+3A_standardize">standardize</code></td>
<td>
<p>Default is <code>TRUE</code>, which normalizes weights to sum
to 1 within each treatment group.  For continuous treatments, normalizes
weights to sum up to 1 for the entire sample.  Set to <code>FALSE</code> to return
Horvitz-Thompson weights.</p>
</td></tr>
<tr><td><code id="CBPS_+3A_method">method</code></td>
<td>
<p>Choose &quot;over&quot; to fit an over-identified model that combines
the propensity score and covariate balancing conditions; choose &quot;exact&quot; to
fit a model that only contains the covariate balancing conditions.</p>
</td></tr>
<tr><td><code id="CBPS_+3A_twostep">twostep</code></td>
<td>
<p>Default is <code>TRUE</code> for a two-step estimator, which will
run substantially faster than continuous-updating.  Set to <code>FALSE</code> to
use the continuous-updating estimator described by Imai and Ratkovic (2014).</p>
</td></tr>
<tr><td><code id="CBPS_+3A_sample.weights">sample.weights</code></td>
<td>
<p>Survey sampling weights for the observations, if
applicable.  When left NULL, defaults to a sampling weight of 1 for each
observation.</p>
</td></tr>
<tr><td><code id="CBPS_+3A_baseline.formula">baseline.formula</code></td>
<td>
<p>Used only to fit iCBPS (see Fan et al). Currently
only works with binary treatments.  A formula specifying the balancing
covariates in the baseline outcome model, i.e., E(Y(0)|X).</p>
</td></tr>
<tr><td><code id="CBPS_+3A_diff.formula">diff.formula</code></td>
<td>
<p>Used only to fit iCBPS (see Fan et al).  Currently only
works with binary treatments.  A formula specifying the balancing covariates
in the difference between the treatment and baseline outcome model, i.e.,
E(Y(1)-Y(0)|X).</p>
</td></tr>
<tr><td><code id="CBPS_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to <code>optim()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted propensity score</p>
</td></tr>
<tr><td><code>linear.predictor</code></td>
<td>
<p>X * beta</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Minus twice the log-likelihood of the CBPS fit</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>The optimal weights.  Let <code class="reqn">\pi_i = f(T_i | X_i)</code>.  For binary ATE, these are given by <code class="reqn">\frac{T_i}{\pi_i} +
\frac{(1 - T_i)}{(1 - \pi_i)}</code>.  For
binary ATT, these are given by <code class="reqn">\frac{n}{n_t} * \frac{T_i - \pi_i}{1 -
\pi_i}</code>.  For multi_valued treatments,
these are given by <code class="reqn">\sum_{j=0}^{J-1} T_{i,j} /
\pi_{i,j}</code>.  For continuous treatments,
these are given by <code class="reqn">\frac{f(T_i)}{f(T_i | X_i)}</code>.  These expressions for weights are all before standardization (i.e. with
standardize=<code>FALSE</code>).  Standardization will make weights sum to 1
within each treatment group.  For continuous treatment, standardization will
make all weights sum to 1.  If sampling weights are used, the weight for
each observation is multiplied by the survey sampling weight.</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>The
treatment vector used</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The covariate matrix</p>
</td></tr> <tr><td><code>model</code></td>
<td>
<p>The model
frame</p>
</td></tr> <tr><td><code>converged</code></td>
<td>
<p>Convergence value.  Returned from the call to
<code>optim()</code>.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The matched call</p>
</td></tr> <tr><td><code>formula</code></td>
<td>
<p>The formula
supplied</p>
</td></tr> <tr><td><code>data</code></td>
<td>
<p>The data argument</p>
</td></tr> <tr><td><code>coefficients</code></td>
<td>
<p>A named vector
of coefficients</p>
</td></tr> <tr><td><code>sigmasq</code></td>
<td>
<p>The sigma-squared value, for continuous
treatments only</p>
</td></tr> <tr><td><code>J</code></td>
<td>
<p>The J-statistic at convergence</p>
</td></tr> <tr><td><code>mle.J</code></td>
<td>
<p>The
J-statistic for the parameters from maximum likelihood estimation</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The covariance matrix for the coefficients.</p>
</td></tr> <tr><td><code>Ttilde</code></td>
<td>
<p>For
internal use only.</p>
</td></tr> <tr><td><code>Xtilde</code></td>
<td>
<p>For internal use only.</p>
</td></tr>
<tr><td><code>beta.tilde</code></td>
<td>
<p>For internal use only.</p>
</td></tr> <tr><td><code>simgasq.tilde</code></td>
<td>
<p>For internal
use only.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Fong, Marc Ratkovic, Kosuke Imai, and Xiaolin Yang; The
CBPS function is based on the code for version 2.15.0 of the glm function
implemented in the stats package, originally written by Simon Davies.  This
documentation is likewise modeled on the documentation for glm and borrows
its language where the arguments and values are the same.
</p>


<h3>References</h3>

<p>Imai, Kosuke and Marc Ratkovic.  2014. &ldquo;Covariate Balancing
Propensity Score.&rdquo; Journal of the Royal Statistical Society, Series B
(Statistical Methodology).
<a href="http://imai.princeton.edu/research/CBPS.html">http://imai.princeton.edu/research/CBPS.html</a> <br /> Fong, Christian, Chad
Hazlett, and Kosuke Imai.  2018.  &ldquo;Covariate Balancing Propensity Score
for a Continuous Treatment.&rdquo; The Annals of Applied Statistics.
<a href="http://imai.princeton.edu/research/files/CBGPS.pdf">http://imai.princeton.edu/research/files/CBGPS.pdf</a> <br />
Fan, Jianqing and Imai, Kosuke and Liu, Han and Ning, Yang and Yang,
Xiaolin. &ldquo;Improving Covariate Balancing Propensity Score: A Doubly Robust
and Efficient Approach.&rdquo; Unpublished Manuscript.
<a href="http://imai.princeton.edu/research/CBPStheory.html">http://imai.princeton.edu/research/CBPStheory.html</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+summary.CBPS">summary.CBPS</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###
### Example: propensity score matching
###

##Load the LaLonde data
data(LaLonde)
## Estimate CBPS
fit &lt;- CBPS(treat ~ age + educ + re75 + re74 + 
			I(re75==0) + I(re74==0), 
			data = LaLonde, ATT = TRUE)
summary(fit)
## Not run: 
## matching via MatchIt: one to one nearest neighbor with replacement
library(MatchIt)
m.out &lt;- matchit(treat ~ fitted(fit), method = "nearest", 
				 data = LaLonde, replace = TRUE)

### Example: propensity score weighting 
###
## Simulation from Kang and Shafer (2007).
set.seed(123456)
n &lt;- 500
X &lt;- mvrnorm(n, mu = rep(0, 4), Sigma = diag(4))
prop &lt;- 1 / (1 + exp(X[,1] - 0.5 * X[,2] + 
			 0.25*X[,3] + 0.1 * X[,4]))
treat &lt;- rbinom(n, 1, prop)
y &lt;- 210 + 27.4*X[,1] + 13.7*X[,2] + 13.7*X[,3] + 13.7*X[,4] + rnorm(n)

##Estimate CBPS with a misspecified model
X.mis &lt;- cbind(exp(X[,1]/2), X[,2]*(1+exp(X[,1]))^(-1)+10, 
			  (X[,1]*X[,3]/25+.6)^3, (X[,2]+X[,4]+20)^2)
fit1 &lt;- CBPS(treat ~ X.mis, ATT = 0)
summary(fit1)
	
## Horwitz-Thompson estimate
mean(treat*y/fit1$fitted.values)
## Inverse propensity score weighting
sum(treat*y/fit1$fitted.values)/sum(treat/fit1$fitted.values)

rm(list=c("y","X","prop","treat","n","X.mis","fit1"))

### Example: Continuous Treatment as in Fong, Hazlett, 
### and Imai (2018).  See 
### https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/AIF4PI
### for a real data example.
set.seed(123456)
n &lt;- 1000
X &lt;- mvrnorm(n, mu = rep(0,2), Sigma = diag(2))
beta &lt;- rnorm(ncol(X)+1, sd = 1)
treat &lt;- cbind(1,X)%*%beta + rnorm(n, sd = 5)

treat.effect &lt;- 1
effect.beta &lt;- rnorm(ncol(X))
y &lt;- rbinom(n, 1, (1 + exp(-treat.effect*treat - 
				   X%*%effect.beta))^-1)

fit2 &lt;- CBPS(treat ~ X)
summary(fit2)
summary(glm(y ~ treat + X, weights = fit2$weights, 
			family = "quasibinomial"))

rm(list=c("n", "X", "beta", "treat", "treat.effect",
		  "effect.beta", "y", "fit2"))

### Simulation example: Improved CBPS (or iCBPS) from Fan et al
set.seed(123456)
n &lt;- 500
X &lt;- mvrnorm(n, mu = rep(0, 4), Sigma = diag(4))
prop &lt;- 1 / (1 + exp(X[,1] - 0.5 * X[,2] + 0.25*X[,3] + 0.1 * X[,4]))
treat &lt;- rbinom(n, 1, prop)
y1 &lt;- 210 + 27.4*X[,1] + 13.7*X[,2] + 13.7*X[,3] + 13.7*X[,4] + rnorm(n)
y0 &lt;- 210 + 13.7*X[,2] + 13.7*X[,3] + 13.7*X[,4] + rnorm(n)
##Estimate iCBPS with a misspecificied model
X.mis &lt;- cbind(exp(X[,1]/2), X[,2]*(1+exp(X[,1]))^(-1)+10, 
			   (X[,1]*X[,3]/25+.6)^3, (X[,2]+X[,4]+20)^2)
fit1 &lt;- CBPS(treat ~ X.mis, baseline.formula=~X.mis[,2:4], 
			 diff.formula=~X.mis[,1], ATT = FALSE)
summary(fit1)

## End(Not run)

</code></pre>

<hr>
<h2 id='CBPS.fit'>CBPS.fit determines the proper routine (what kind of treatment) and calls the 
approporiate function.  It also pre- and post-processes the data</h2><span id='topic+CBPS.fit'></span>

<h3>Description</h3>

<p>CBPS.fit determines the proper routine (what kind of treatment) and calls the 
approporiate function.  It also pre- and post-processes the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CBPS.fit(
  treat,
  X,
  baselineX,
  diffX,
  ATT,
  method,
  iterations,
  standardize,
  twostep,
  sample.weights = sample.weights,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CBPS.fit_+3A_treat">treat</code></td>
<td>
<p>A vector of treatment assignments.  Binary or multi-valued
treatments should be factors.  Continuous treatments should be numeric.</p>
</td></tr>
<tr><td><code id="CBPS.fit_+3A_x">X</code></td>
<td>
<p>A covariate matrix.</p>
</td></tr>
<tr><td><code id="CBPS.fit_+3A_baselinex">baselineX</code></td>
<td>
<p>Similar to <code>baseline.formula</code>, but in matrix form.</p>
</td></tr>
<tr><td><code id="CBPS.fit_+3A_diffx">diffX</code></td>
<td>
<p>Similar to <code>diff.formula</code>, but in matrix form.</p>
</td></tr>
<tr><td><code id="CBPS.fit_+3A_att">ATT</code></td>
<td>
<p>Default is 1, which finds the average treatment effect on the
treated interpreting the second level of the treatment factor as the
treatment.  Set to 2 to find the ATT interpreting the first level of the
treatment factor as the treatment.  Set to 0 to find the average treatment
effect. For non-binary treatments, only the ATE is available.</p>
</td></tr>
<tr><td><code id="CBPS.fit_+3A_method">method</code></td>
<td>
<p>Choose &quot;over&quot; to fit an over-identified model that combines
the propensity score and covariate balancing conditions; choose &quot;exact&quot; to
fit a model that only contains the covariate balancing conditions.</p>
</td></tr>
<tr><td><code id="CBPS.fit_+3A_iterations">iterations</code></td>
<td>
<p>An optional parameter for the maximum number of iterations
for the optimization.  Default is 1000.</p>
</td></tr>
<tr><td><code id="CBPS.fit_+3A_standardize">standardize</code></td>
<td>
<p>Default is <code>TRUE</code>, which normalizes weights to sum
to 1 within each treatment group.  For continuous treatments, normalizes
weights to sum up to 1 for the entire sample.  Set to <code>FALSE</code> to return
Horvitz-Thompson weights.</p>
</td></tr>
<tr><td><code id="CBPS.fit_+3A_twostep">twostep</code></td>
<td>
<p>Default is <code>TRUE</code> for a two-step estimator, which will
run substantially faster than continuous-updating.  Set to <code>FALSE</code> to
use the continuous-updating estimator described by Imai and Ratkovic (2014).</p>
</td></tr>
<tr><td><code id="CBPS.fit_+3A_sample.weights">sample.weights</code></td>
<td>
<p>Survey sampling weights for the observations, if
applicable.  When left NULL, defaults to a sampling weight of 1 for each
observation.</p>
</td></tr>
<tr><td><code id="CBPS.fit_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to <code>optim()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>CBPS.fit object
</p>

<hr>
<h2 id='hdCBPS'>hdCBPS high dimensional CBPS method to parses the formula object and passes the result to hdCBPS.fit, which calculates ATE using CBPS method in a high dimensional setting.</h2><span id='topic+hdCBPS'></span><span id='topic+hdCBPS.fit'></span>

<h3>Description</h3>

<p>hdCBPS high dimensional CBPS method to parses the formula object and passes the result to hdCBPS.fit, which calculates ATE using CBPS method in a high dimensional setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdCBPS(
  formula,
  data,
  na.action,
  y,
  ATT = 0,
  iterations = 1000,
  method = "linear"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hdCBPS_+3A_formula">formula</code></td>
<td>
<p>An object of class formula (or one that can be coerced to
that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="hdCBPS_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment (or object coercible
by as.data.frame to a data frame) containing the variables in the model. If
not found in data, the variables are taken from environment(formula),
typically the environment from which CBPS is called.</p>
</td></tr>
<tr><td><code id="hdCBPS_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen when the data
contain NAs. The default is set by the na.action setting of options, and is
na.fail if that is unset.</p>
</td></tr>
<tr><td><code id="hdCBPS_+3A_y">y</code></td>
<td>
<p>An outcome variable.</p>
</td></tr>
<tr><td><code id="hdCBPS_+3A_att">ATT</code></td>
<td>
<p>Option to calculate ATT</p>
</td></tr>
<tr><td><code id="hdCBPS_+3A_iterations">iterations</code></td>
<td>
<p>An optional parameter for the maximum number of iterations
for the optimization. Default is 1000.</p>
</td></tr>
<tr><td><code id="hdCBPS_+3A_method">method</code></td>
<td>
<p>Choose among &quot;linear&quot;, &quot;binomial&quot;, and &quot;possion&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>ATT</code></td>
<td>
<p>Average treatment effect on the treated.</p>
</td></tr>
<tr><td><code>ATE</code></td>
<td>
<p>Average treatment effect.</p>
</td></tr> 
<tr><td><code>s</code></td>
<td>
<p>Standard Error.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted propensity score</p>
</td></tr>
<tr><td><code>coefficients1</code></td>
<td>
<p>Coefficients for the treated propensity score</p>
</td></tr>
<tr><td><code>coefficients0</code></td>
<td>
<p>Coefficients for the untreated propensity score</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model frame</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sida Peng
</p>

<hr>
<h2 id='LaLonde'>LaLonde Data for Covariate Balancing Propensity Score</h2><span id='topic+LaLonde'></span>

<h3>Description</h3>

<p>This data set gives the outcomes a well as treatment assignments and
covariates for the econometric evaluation of training programs in LaLonde
(1986).
</p>


<h3>Format</h3>

<p>A data frame consisting of 12 columns (including a treatment
assignment vector) and 3212 observations.
</p>


<h3>Source</h3>

<p>Data from the National Supported Work Study.  A benchmark matching
dataset.  Columns consist of an indicator for whether the observed unit was
in the experimental subset; an indicator for whether the individual received
the treatment; age in years; schooling in years; indicators for black and
Hispanic; an indicator for marriage status, one of married; an indicator for
no high school degree; reported earnings in 1974, 1975, and 1978; and
whether the 1974 earnings variable is missing.  Data not missing 1974
earnings are the Dehejia-Wahba subsample of the LaLonde data.  Missing
values for 1974 earnings set to zero. 1974 and 1975 earnings are
pre-treatment.  1978 earnings is taken as the outcome variable.
</p>


<h3>References</h3>

<p>LaLonde, R.J. (1986). Evaluating the econometric evaluations of
training programs with experimental data. American Economic Review 76, 4,
604-620.
</p>

<hr>
<h2 id='npCBPS'>Non-Parametric Covariate Balancing Propensity Score (npCBPS) Estimation</h2><span id='topic+npCBPS'></span>

<h3>Description</h3>

<p><code>npCBPS</code> is a method to estimate weights interpretable as (stabilized)
inverse generlized propensity score weights, w_i = f(T_i)/f(T_i|X), without
actually estimating a model for the treatment to arrive at f(T|X) estimates.
In brief, this works by maximizing the empirical likelihood of observing the
values of treatment and covariates that were observed, while constraining
the weights to be those that (a) ensure balance on the covariates, and (b)
maintain the original means of the treatment and covariates.
</p>
<p>In the continuous treatment context, this balance on covariates means zero
correlation of each covariate with the treatment. In binary or categorical
treatment contexts, balance on covariates implies equal means on the
covariates for observations at each level of the treatment.  When given a
numeric treatment the software handles it continuously. To handle the
treatment as binary or categorical is must be given as a factor.
</p>
<p>Furthermore, we apply a Bayesian variant that allows the correlation of each
covariate with the treatment to be slightly non-zero, as might be expected
in a a given finite sample.
</p>
<p>Estimates non-parametric covariate balancing propensity score weights.
</p>
<p>### @aliases npCBPS npCBPS.fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npCBPS(formula, data, na.action, corprior = 0.01, print.level = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npCBPS_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>formula</code> (or one that can be coerced
to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="npCBPS_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment (or object coercible
by as.data.frame to a data frame) containing the variables in the model. If
not found in data, the variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>CBPS</code> is called.</p>
</td></tr>
<tr><td><code id="npCBPS_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen when the data
contain NAs. The default is set by the na.action setting of options, and is
na.fail if that is unset.</p>
</td></tr>
<tr><td><code id="npCBPS_+3A_corprior">corprior</code></td>
<td>
<p>Prior hyperparameter controlling the expected amount of
correlation between each covariate and the treatment. Specifically, the
amount of correlation between the k-dimensional covariates, X, and the
treatment T after weighting is assumed to have prior distribution
MVN(0,sigma^2 I_k). We conceptualize sigma^2 as a tuning parameter to be
used pragmatically. It's default of 0.1 ensures that the balance constraints
are not too harsh, and that a solution is likely to exist. Once the
algorithm works at such a high value of sigma^2, the user may wish to
attempt values closer to 0 to get finer balance.</p>
</td></tr>
<tr><td><code id="npCBPS_+3A_print.level">print.level</code></td>
<td>
<p>Controls verbosity of output to the screen while npCBPS
runs. At the default of print.level=0, little output is produced. It
print.level&gt;0, it outputs diagnostics including the log posterior
(log_post), the log empirical likelihood associated with the weights
(log_el), and the log prior probability of the (weighted) correlation of
treatment with the covariates.</p>
</td></tr>
<tr><td><code id="npCBPS_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>weights</code></td>
<td>
<p>The optimal weights</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>The treatment vector
used</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The covariate matrix</p>
</td></tr> <tr><td><code>model</code></td>
<td>
<p>The model frame</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call</p>
</td></tr> <tr><td><code>formula</code></td>
<td>
<p>The formula supplied</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data argument</p>
</td></tr> <tr><td><code>log.p.eta</code></td>
<td>
<p>The log density for the
(weighted) correlation of the covariates with the treatment, given the
choice of prior (<code>corprior</code>)</p>
</td></tr> <tr><td><code>log.el</code></td>
<td>
<p>The log empirical
likelihood of the observed data at the chosen set of IPW weights.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>A vector describing the correlation between the treatment and
each covariate on the weighted data at the solution.</p>
</td></tr> <tr><td><code>sumw0</code></td>
<td>
<p>The sum
of weights, provided as a check on convergence. This is always 1 when
convergence occurs unproblematically. If it differs from 1 substantially, no
solution perfectly satisfying the conditions was found, and the user may
consider a larger value of <code>corprior</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Fong, Chad Hazlett, and Kosuke Imai
</p>


<h3>References</h3>

<p>Fong, Christian, Chad Hazlett, and Kosuke Imai.  &ldquo;Parametric
and Nonparametric Covariate Balancing Propensity Score for General Treatment
Regimes.&rdquo; Unpublished Manuscript.
<a href="http://imai.princeton.edu/research/files/CBGPS.pdf">http://imai.princeton.edu/research/files/CBGPS.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Generate data
data(LaLonde)

## Restricted two only two covariates so that it will run quickly.
## Performance will remain good if the full LaLonde specification is used
fit &lt;- npCBPS(treat ~ age + educ, data = LaLonde, corprior=.1/nrow(LaLonde))
plot(fit)

</code></pre>

<hr>
<h2 id='npCBPS.fit'>npCBPS.fit</h2><span id='topic+npCBPS.fit'></span>

<h3>Description</h3>

<p>npCBPS.fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npCBPS.fit(treat, X, corprior, print.level, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npCBPS.fit_+3A_treat">treat</code></td>
<td>
<p>A vector of treatment assignments.  Binary or multi-valued
treatments should be factors.  Continuous treatments should be numeric.</p>
</td></tr>
<tr><td><code id="npCBPS.fit_+3A_x">X</code></td>
<td>
<p>A covariate matrix.</p>
</td></tr>
<tr><td><code id="npCBPS.fit_+3A_corprior">corprior</code></td>
<td>
<p>Prior hyperparameter controlling the expected amount of
correlation between each covariate and the treatment. Specifically, the
amount of correlation between the k-dimensional covariates, X, and the
treatment T after weighting is assumed to have prior distribution
MVN(0,sigma^2 I_k). We conceptualize sigma^2 as a tuning parameter to be
used pragmatically. It's default of 0.1 ensures that the balance constraints
are not too harsh, and that a solution is likely to exist. Once the
algorithm works at such a high value of sigma^2, the user may wish to
attempt values closer to 0 to get finer balance.</p>
</td></tr>
<tr><td><code id="npCBPS.fit_+3A_print.level">print.level</code></td>
<td>
<p>Controls verbosity of output to the screen while npCBPS
runs. At the default of print.level=0, little output is produced. It
print.level&gt;0, it outputs diagnostics including the log posterior
(log_post), the log empirical likelihood associated with the weights
(log_el), and the log prior probability of the (weighted) correlation of
treatment with the covariates.</p>
</td></tr>
<tr><td><code id="npCBPS.fit_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.CBMSM'>Plotting CBPS Estimation for Marginal Structural Models</h2><span id='topic+plot.CBMSM'></span>

<h3>Description</h3>

<p>Plots the absolute difference in standardized means before and after
weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBMSM'
plot(x, covars = NULL, silent = TRUE, boxplot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CBMSM_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;CBMSM&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.CBMSM_+3A_covars">covars</code></td>
<td>
<p>Indices of the covariates to be plotted (excluding the
intercept).  For example, if only the first two covariates from
<code>balance</code> are desired, set <code>covars</code> to 1:2.  The default is
<code>NULL</code>, which plots all covariates.</p>
</td></tr>
<tr><td><code id="plot.CBMSM_+3A_silent">silent</code></td>
<td>
<p>If set to <code>FALSE</code>, returns the absolute imbalance for
each treatment history pair before and after weighting.  This helps the user
to create his or her own customized plot. Default is <code>TRUE</code>, which
returns nothing.</p>
</td></tr>
<tr><td><code id="plot.CBMSM_+3A_boxplot">boxplot</code></td>
<td>
<p>If set to <code>TRUE</code>, returns a boxplot summarizing the
imbalance on the covariates instead of a point for each covariate.  Useful
if there are many covariates.</p>
</td></tr>
<tr><td><code id="plot.CBMSM_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariate balance is improved if the plot's points are below the plotted
line of y=x.
</p>


<h3>Value</h3>

<p>The x-axis gives the imbalance for each covariate-treatment history
pair without any weighting, and the y-axis gives the imbalance for each
covariate-treatment history pair after CBMSM weighting.  Imbalance is
measured as the absolute difference in standardized means for the two
treatment histories.  Means are standardized by the standard deviation of
the covariate in the full sample.
</p>


<h3>Author(s)</h3>

<p>Marc Ratkovic and Christian Fong
</p>


<h3>See Also</h3>

<p><a href="#topic+CBMSM">CBMSM</a>, <a href="graphics.html#topic+plot">plot</a>
</p>

<hr>
<h2 id='plot.CBPS'>Plotting Covariate Balancing Propensity Score Estimation</h2><span id='topic+plot.CBPS'></span>

<h3>Description</h3>

<p>This function plots the absolute difference in standardized means before and after
weighting.  To access more sophisticated graphics for assessing covariate balance,
consider using Noah Greifer's <code>cobalt</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBPS'
plot(x, covars = NULL, silent = TRUE, boxplot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CBPS_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;CBPS&rdquo; or &ldquo;npCBPS&rdquo;, usually, a
result of a call to <code>CBPS</code> or <code>npCBPS</code>.</p>
</td></tr>
<tr><td><code id="plot.CBPS_+3A_covars">covars</code></td>
<td>
<p>Indices of the covariates to be plotted (excluding the
intercept).  For example, if only the first two covariates from
<code>balance</code> are desired, set <code>covars</code> to 1:2.  The default is
<code>NULL</code>, which plots all covariates.</p>
</td></tr>
<tr><td><code id="plot.CBPS_+3A_silent">silent</code></td>
<td>
<p>If set to <code>FALSE</code>, returns the imbalances used to
construct the plot.  Default is <code>TRUE</code>, which returns nothing.</p>
</td></tr>
<tr><td><code id="plot.CBPS_+3A_boxplot">boxplot</code></td>
<td>
<p>If set to <code>TRUE</code>, returns a boxplot summarizing the
imbalance on the covariates instead of a point for each covariate.  Useful
if there are many covariates.</p>
</td></tr>
<tr><td><code id="plot.CBPS_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;Before Weighting&quot; plot gives the balance before weighting, and the
&quot;After Weighting&quot; plot gives the balance after weighting.
</p>
<p>### @aliases plot.CBPS plot.npCBPS
</p>


<h3>Value</h3>

<p>For binary and multi-valued treatments, plots the absolute
difference in standardized means by contrast for all covariates before and
after weighting.  This quantity for a single covariate and a given pair of
treatment conditions is given by <code class="reqn">\frac{\sum_{i=1}^{n} w_i * (T_i == 1)
* X_i}{\sum_{i=1}^{n} (T_i == 1) * w_i} - \frac{\sum_{i=1}^{n} w_i * (T_i ==
0) * X_i}{\sum_{i=1}^{n} (T_i == 0) * w_i}</code>.  For continuous treatments, plots the weighted absolute
Pearson correlation between the treatment and each covariate.  See
<a href="https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient#Weighted_correlation_coefficient.">https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient#Weighted_correlation_coefficient.</a>
</p>


<h3>Author(s)</h3>

<p>Christian Fong, Marc Ratkovic, and Kosuke Imai.
</p>


<h3>See Also</h3>

<p><a href="#topic+CBPS">CBPS</a>, <a href="graphics.html#topic+plot">plot</a>
</p>

<hr>
<h2 id='plot.CBPSContinuous'>Plot the pre-and-post weighting correlations between X and T</h2><span id='topic+plot.CBPSContinuous'></span>

<h3>Description</h3>

<p>Plot the pre-and-post weighting correlations between X and T
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBPSContinuous'
plot(x, covars = NULL, silent = TRUE, boxplot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CBPSContinuous_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;CBPS&rdquo; or &ldquo;npCBPS&rdquo;, usually, a
result of a call to <code>CBPS</code> or <code>npCBPS</code>.</p>
</td></tr>
<tr><td><code id="plot.CBPSContinuous_+3A_covars">covars</code></td>
<td>
<p>Indices of the covariates to be plotted (excluding the intercept).  For example, 
if only the first two covariates from <code>balance</code> are desired, set <code>covars</code> to 1:2.  
The default is <code>NULL</code>, which plots all covariates.</p>
</td></tr>
<tr><td><code id="plot.CBPSContinuous_+3A_silent">silent</code></td>
<td>
<p>If set to <code>FALSE</code>, returns the imbalances used to
construct the plot.  Default is <code>TRUE</code>, which returns nothing.</p>
</td></tr>
<tr><td><code id="plot.CBPSContinuous_+3A_boxplot">boxplot</code></td>
<td>
<p>If set to <code>TRUE</code>, returns a boxplot summarizing the
imbalance on the covariates instead of a point for each covariate.  Useful
if there are many covariates.</p>
</td></tr>
<tr><td><code id="plot.CBPSContinuous_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to balance.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.npCBPS'>Calls the appropriate plot function, based on the number of treatments</h2><span id='topic+plot.npCBPS'></span>

<h3>Description</h3>

<p>Calls the appropriate plot function, based on the number of treatments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'npCBPS'
plot(x, covars = NULL, silent = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.npCBPS_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;CBPS&rdquo; or &ldquo;npCBPS&rdquo;, usually, a
result of a call to <code>CBPS</code> or <code>npCBPS</code>.</p>
</td></tr>
<tr><td><code id="plot.npCBPS_+3A_covars">covars</code></td>
<td>
<p>Indices of the covariates to be plotted (excluding the intercept).  For example, 
if only the first two covariates from <code>balance</code> are desired, set <code>covars</code> to 1:2.  
The default is <code>NULL</code>, which plots all covariates.</p>
</td></tr>
<tr><td><code id="plot.npCBPS_+3A_silent">silent</code></td>
<td>
<p>If set to <code>FALSE</code>, returns the imbalances used to
construct the plot.  Default is <code>TRUE</code>, which returns nothing.</p>
</td></tr>
<tr><td><code id="plot.npCBPS_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to balance.</p>
</td></tr>
</table>

<hr>
<h2 id='print.CBPS'>Print coefficients and model fit statistics</h2><span id='topic+print.CBPS'></span>

<h3>Description</h3>

<p>Print coefficients and model fit statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBPS'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.CBPS_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;CBPS&rdquo; or &ldquo;npCBPS&rdquo;, usually, a result of a call to <code>CBPS</code> or <code>npCBPS</code>.</p>
</td></tr>
<tr><td><code id="print.CBPS_+3A_digits">digits</code></td>
<td>
<p>the number of digits to keep for the numerical quantities.</p>
</td></tr>
<tr><td><code id="print.CBPS_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to summary.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.CBPS'>Summarizing Covariate Balancing Propensity Score Estimation</h2><span id='topic+summary.CBPS'></span>

<h3>Description</h3>

<p>Prints a summary of a fitted CBPS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBPS'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.CBPS_+3A_object">object</code></td>
<td>
<p>an object of class &ldquo;CBPS&rdquo;, usually, a result of a call
to CBPS.</p>
</td></tr>
<tr><td><code id="summary.CBPS_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to summary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints a summmary of a CBPS object, in a format similar to glm.  The
variance matrix is calculated from the numerical Hessian at convergence of
CBPS.
</p>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr> <tr><td><code>deviance.residuals</code></td>
<td>
<p>The five
number summary and the mean of the deviance residuals.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>A table including the estimate for the each coefficient
and the standard error, z-value, and two-sided p-value for these estimates.</p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p>Hansen's J-Statistic for the fitted model.</p>
</td></tr>
<tr><td><code>Log-Likelihood</code></td>
<td>
<p>The log-likelihood of the fitted model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Fong, Marc Ratkovic, and Kosuke Imai.
</p>


<h3>See Also</h3>

<p><a href="#topic+CBPS">CBPS</a>, <a href="base.html#topic+summary">summary</a>
</p>

<hr>
<h2 id='vcov_outcome'>Calculate Variance-Covariance Matrix for Outcome Model</h2><span id='topic+vcov_outcome'></span>

<h3>Description</h3>

<p><code>vcov_outcome</code> Returns the variance-covariance matrix of the main
parameters of a fitted CBPS object.
</p>
<p>This adjusts the standard errors of the weighted regression of Y on Z for
uncertainty in the weights.
</p>
<p>### @aliases vcov_outcome vcov_outcome.CBPSContinuous
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcov_outcome(object, Y, Z, delta, tol = 10^(-5), lambda = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov_outcome_+3A_object">object</code></td>
<td>
<p>A fitted CBPS object.</p>
</td></tr>
<tr><td><code id="vcov_outcome_+3A_y">Y</code></td>
<td>
<p>The outcome.</p>
</td></tr>
<tr><td><code id="vcov_outcome_+3A_z">Z</code></td>
<td>
<p>The covariates (including the treatment and an intercept term) that
predict the outcome.</p>
</td></tr>
<tr><td><code id="vcov_outcome_+3A_delta">delta</code></td>
<td>
<p>The coefficients from regressing Y on Z, weighting by the
cbpsfit$weights.</p>
</td></tr>
<tr><td><code id="vcov_outcome_+3A_tol">tol</code></td>
<td>
<p>Tolerance for choosing whether to improve conditioning of the &quot;M&quot;
matrix prior to conversion.  Equal to 1/(condition number), i.e. the
smallest eigenvalue divided by the largest.</p>
</td></tr>
<tr><td><code id="vcov_outcome_+3A_lambda">lambda</code></td>
<td>
<p>The amount to be added to the diagonal of M if the condition
of the matrix is worse than tol.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the estimated covariances between the parameter
estimates in the weighted outcome regression, adjusted for uncertainty in
the weights.
</p>


<h3>Author(s)</h3>

<p>Christian Fong, Chad Hazlett, and Kosuke Imai.
</p>


<h3>References</h3>

<p>Lunceford and Davididian 2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###
### Example: Variance-Covariance Matrix
###

##Load the LaLonde data
data(LaLonde)
## Estimate CBPS via logistic regression
fit &lt;- CBPS(treat ~ age + educ + re75 + re74 + I(re75==0) + I(re74==0), 
		    data = LaLonde, ATT = TRUE)
## Get the variance-covariance matrix.
vcov(fit)

</code></pre>

<hr>
<h2 id='vcov_outcome.CBPSContinuous'>vcov_outcome</h2><span id='topic+vcov_outcome.CBPSContinuous'></span>

<h3>Description</h3>

<p>vcov_outcome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBPSContinuous'
vcov_outcome(object, Y, Z, delta, tol = 10^(-5), lambda = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov_outcome.CBPSContinuous_+3A_object">object</code></td>
<td>
<p>A fitted CBPS object.</p>
</td></tr>
<tr><td><code id="vcov_outcome.CBPSContinuous_+3A_y">Y</code></td>
<td>
<p>The outcome.</p>
</td></tr>
<tr><td><code id="vcov_outcome.CBPSContinuous_+3A_z">Z</code></td>
<td>
<p>The covariates (including the treatment and an intercept term) that predict the outcome.</p>
</td></tr>
<tr><td><code id="vcov_outcome.CBPSContinuous_+3A_delta">delta</code></td>
<td>
<p>The coefficients from regressing Y on Z, weighting by the cbpsfit$weights.</p>
</td></tr>
<tr><td><code id="vcov_outcome.CBPSContinuous_+3A_tol">tol</code></td>
<td>
<p>Tolerance for choosing whether to improve conditioning of the &quot;M&quot;
matrix prior to conversion.  Equal to 1/(condition number), i.e. the
smallest eigenvalue divided by the largest.</p>
</td></tr>
<tr><td><code id="vcov_outcome.CBPSContinuous_+3A_lambda">lambda</code></td>
<td>
<p>The amount to be added to the diagonal of M if the condition of the matrix is worse than tol.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance-Covariance Matrix for Outcome Model
</p>

<hr>
<h2 id='vcov.CBPS'>Calculate Variance-Covariance Matrix for a Fitted CBPS Object</h2><span id='topic+vcov.CBPS'></span>

<h3>Description</h3>

<p><code>vcov.CBPS</code> Returns the variance-covariance matrix of the main
parameters of a fitted CBPS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBPS'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.CBPS_+3A_object">object</code></td>
<td>
<p>An object of class <code>formula</code> (or one that can be coerced
to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="vcov.CBPS_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to vcov.CBPS</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the CBPS implementation of the generic function vcov().
</p>


<h3>Value</h3>

<p>A matrix of the estimated covariances between the parameter
estimates in the linear or non-linear predictor of the model.
</p>


<h3>Author(s)</h3>

<p>Christian Fong, Marc Ratkovic, and Kosuke Imai.
</p>


<h3>References</h3>

<p>This documentation is modeled on the documentation of the
generic <a href="stats.html#topic+vcov">vcov</a>.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+vcov">vcov</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###
### Example: Variance-Covariance Matrix
###

##Load the LaLonde data
data(LaLonde)
## Estimate CBPS via logistic regression
fit &lt;- CBPS(treat ~ age + educ + re75 + re74 + I(re75==0) + I(re74==0), 
		    data = LaLonde, ATT = TRUE)
## Get the variance-covariance matrix.
vcov(fit)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
