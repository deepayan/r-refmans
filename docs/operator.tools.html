<!DOCTYPE html><html><head><title>Help for package operator.tools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {operator.tools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.initOps'><p>Initialize operators</p></a></li>
<li><a href='#can.operator'><p>can.operator</p></a></li>
<li><a href='#fun2name'><p>Convert between a function and its name and vice versa.</p></a></li>
<li><a href='#inverse'><p>Invert an R operator</p></a></li>
<li><a href='#is.operator'><p>Utilities for operators</p></a></li>
<li><a href='#notin'><p>NOT IN</p></a></li>
<li><a href='#operator.type'><p>Return the type for an operator.</p></a></li>
<li><a href='#operators'><p>Return the _names_ of defined operators.</p></a></li>
<li><a href='#rel.type'><p>Get the relational type of a relational operator.</p></a></li>
<li><a href='#removeOperator'><p>Unregister a an operator.</p></a></li>
<li><a href='#setOperator'><p>Registers an operator for use with operator.tools package.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Utilities for Working with R's Operators</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-02-28</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils (&ge; 3.3.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>operators (&ge; 0.1.8), magrittr (&ge; 1.5), testthat (&ge; 1.0.2)</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a collection of utilities that allow programming with 
    R's operators. Routines allow classifying operators, 
    translating to and from an operator and its underlying function, and inverting 
    some operators (e.g. comparison operators), etc. All methods can be extended
    to custom infix operators. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/decisionpatterns/operator.tools">https://github.com/decisionpatterns/operator.tools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/decisionpatterns/operator.tools/issues">https://github.com/decisionpatterns/operator.tools/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1.9000</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-02-28 14:38:49 UTC; cbrown</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Brown [aut, cre],
  Decision Patterns [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Brown &lt;chris.brown@decisionpatterns.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-02-28 23:13:22</td>
</tr>
</table>
<hr>
<h2 id='.initOps'>Initialize operators</h2><span id='topic+.initOps'></span>

<h3>Description</h3>

<p>Initialize operators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.initOps()
</code></pre>

<hr>
<h2 id='can.operator'>can.operator</h2><span id='topic+can.operator'></span>

<h3>Description</h3>

<p>tests whether an object can be coerced to a operator, optionally an operator
of 'types'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>can.operator(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="can.operator_+3A_x">x</code></td>
<td>
<p>object; to test</p>
</td></tr>
<tr><td><code id="can.operator_+3A_...">...</code></td>
<td>
<p>additional arguments 
</p>
<p><code>can.operator</code> test whether an object can be coerced to an operator.
Methods exist for name, function amd character classes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='fun2name'>Convert between a function and its name and vice versa.</h2><span id='topic+fun2name'></span><span id='topic+name2fun'></span>

<h3>Description</h3>

<p><code>fun2name</code> compares a function (body) to all defined functions. If an
identical match is found to a defined function, that function is returned.
NB. This does not search through S4 methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun2name(f)

name2fun(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun2name_+3A_f">f</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="fun2name_+3A_x">x</code></td>
<td>
<p>name; more specifically, an object to be converted into a name and eval'd
</p>
<p><code>fun2name</code> compares the function against existing functions using
<code><a href="base.html#topic+identical">identical</a></code>. If a match is found, the name of the matching 
function ( expressed as a <code>character</code> ) is returned.
</p>
<p><code>fun2name</code> will not work for S4 Methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>name2fun</code> simply converts its argument to a name and than evals it 
to produce a function definition
</p>


<h3>Value</h3>

<p>fun2name: character (name of function)  
name2fun: function
</p>

<hr>
<h2 id='inverse'>Invert an R operator</h2><span id='topic+inverse'></span><span id='topic+inverse.name'></span><span id='topic+inverse.function'></span>

<h3>Description</h3>

<p><code>inverse</code> is a S3 generic method for inverting an R operator in the
mathematical sense. Presently, inverses are defined for relational
operators, i.e. changing <code>&gt;</code> to <code>&lt;=</code> etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverse_+3A_x">x</code></td>
<td>
<p>object representing an R operator</p>
</td></tr>
<tr><td><code id="inverse_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments will be checked against the defined list of inverses,
If an entry exists, the corresponding inverse is returned.
</p>


<h3>Value</h3>

<p><code>inverse</code> returns the inverse in the same form as the <code>x</code>
argument. Thus, if a name is provided, a name is returned. If a function is
provided, a function is returned.
</p>


<h3>Author(s)</h3>

<p>Christopher Brown
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Inverse_mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+operators">operators</a></code> especially <code>operators(type="relational"))</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    inverse( as.name( '!=' ) )
    inverse( `==` )
 
## End(Not run) 
</code></pre>

<hr>
<h2 id='is.operator'>Utilities for operators</h2><span id='topic+is.operator'></span>

<h3>Description</h3>

<p>These S4 Methods are utilies for working with operators. In R, operators are
functions with special syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.operator(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.operator_+3A_x">x</code></td>
<td>
<p>object to be tested or coerced. Can be <code>function</code> or
<code>name</code>.</p>
</td></tr>
<tr><td><code id="is.operator_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+operators">operators</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is.operator</code> tests whether the object is one of the defined
<code><a href="#topic+operators">operators</a></code>.
</p>
<p><code>can.operator</code> tests whether the object can be coerced to an operator.
</p>
<p><code>as.operator</code> coerced the object to an operator.
</p>
<p>Optionally, you can specify one of the that it tests for a specific type of
operator.  See details, below.
</p>
<p>An operator is R function with special syntax.
</p>
<p>( See <code>??operator</code> for examples of each. )
</p>
<p><code>is.operator</code> tests whether the argumenst is an operator.
</p>
<p><code>as.operator</code> coerces <code>x</code> to a operator, otherwise fails.
</p>
<p><code>can.operator</code> test whether the object can be coerced to an operator.
</p>
<p>All functions can accepts a <code>types</code> argument which is passed to
<code>link{operators}</code>.  By specifying one or more types, these functions
test using those <code>types</code> only.
</p>
<p>New operators can be &quot;registered&quot; using <code><a href="#topic+setOperator">setOperator</a></code>.
</p>


<h3>Value</h3>

<p><code>is.operator</code> and <code>can.operator</code> return logical.
</p>
<p><code>as.operator</code> returns the argument coerced to the concommitant R
function.
</p>


<h3>Author(s)</h3>

<p>Christopher Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+operators">operators</a></code>, <code><a href="utils.html#topic+apropos">apropos</a></code>,
<code><a href="base.html#topic+match.fun">match.fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

 ## Not run: 
   is.operator( `+` )
   is.operator( 'xyzzy' )
   is.operator( `+`, types="arithmetic" )
   is.operator( `+`, types="relational" )

   can.operator( `+` )
   can.operator( 'xyzzy' )
   can.operator( `+`, types="arithmetic" )
   can.operator( `+`, types="relational" )

   as.operator( `+` )
   as.operator( '+' )
   as.operator( as.name('+') )  
 
## End(Not run)

</code></pre>

<hr>
<h2 id='notin'>NOT IN</h2><span id='topic+notin'></span><span id='topic++25+21in+25'></span>

<h3>Description</h3>

<p>Commonly created NOT-IN operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %!in% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="notin_+3A_x">x</code></td>
<td>
<p>object on the lhs</p>
</td></tr>
<tr><td><code id="notin_+3A_table">table</code></td>
<td>
<p>object/list on the rhs</p>
</td></tr>
</table>

<hr>
<h2 id='operator.type'>Return the type for an operator.</h2><span id='topic+operator.type'></span><span id='topic+operator.type.name'></span><span id='topic+operator.type.function'></span>

<h3>Description</h3>

<p>Given an operator or its name/symbol, return the <b>type</b> of operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>operator.type(op)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="operator.type_+3A_op">op</code></td>
<td>
<p>An operator either as a name/symbol or function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The operator is first checked against all operators that have been
registered with the <code><a href="#topic+setOperator">setOperator</a></code> command.  If there is a match,
its type is returned. If no matching operator is found, <code>op</code> is matched
against unregistered operators that have been defined with the
<code>%any%</code>-syntax. If a match is found, UNREGISTERED is returned.
</p>
<p>The list of operators are maintained in <code>.Options\$operators</code> and be
altered suing the <code><a href="#topic+setOperator">setOperator</a></code> command.
</p>


<h3>Value</h3>

<p>A <code>character</code> value.
</p>
<p>For registered operators, the registered type is returned.  For Base R
operators, the types come from <code><a href="base.html#topic+Syntax">Syntax</a></code>.
</p>
<p>For operators defined with the <code>%any%</code>-syntax but, not registered using
<code><a href="#topic+setOperator">setOperator</a></code>, &quot;UNREGISTERED&quot; is returned.
</p>
<p>NULL is returned otherwise.
</p>


<h3>Author(s)</h3>

<p>Christopher Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+operators">operators</a></code>, <code><a href="#topic+setOperator">setOperator</a></code>. <a href="base.html#topic+Syntax">Syntax</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 ## Not run: 
  operator.type( `+` )
  operator.type( `&lt;=` )
  
  e &lt;- quote( A +B )
  operator.type( e[[1]] )

  operator.type( as.name('+') )
 
## End(Not run)
 
</code></pre>

<hr>
<h2 id='operators'>Return the _names_ of defined operators.</h2><span id='topic+operators'></span>

<h3>Description</h3>

<p><code>operators</code> returns the names of defined operators. Argument
<code>types</code> can be used to select operators of a specified type(s) or
GROUPING(s).  See Details for specifics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>operators(types = "REGISTERED")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="operators_+3A_types">types</code></td>
<td>
<p>A character vector with the types of operators to return. The
types may one or more of: 'namespace', 'component', 'indexing', 'sequence',
'arithmetic', 'relational', 'logical', 'tilde', 'assignment', 'help',
'user', or user-defined type specified in a call to
<code><a href="#topic+setOperator">setOperator</a></code>.  It may also be one of the special groups:
'REG(ISTERED)', 'UNREG(ISTERED)', 'SPECIAL', 'ALL'. See Details.
</p>
<p><code>operators</code> provides the <b>names</b> of defined operators.  These can
be either registered operators (using <code><a href="#topic+setOperators">setOperators</a></code>), or
unregistered operators definde by the <code>%any%</code> syntax.
</p>
<p>By default, only registered operators are returned. This is purely for
performance reasons as an exhausting search for <code>%any%</code> functions is
expensive.
</p>
<p>See <a href="base.html#topic+Syntax">Syntax</a>.for the core R operators
</p>
<p><code>types</code> may also be one a special operator groupings: </p>
 <ul>
<li>
<p>REG(ISTERED): (Default). Those registered by <code><a href="#topic+setOperators">setOperators</a></code>
</p>
</li>
<li><p> UNREG(ISTERED): Unregisted operators, requires expensive search.
</p>
</li>
<li><p> ALL: All operators, requires expensive search of environments.  </p>
</li>
<li>
<p>SPECIAL: All operators defined using the <code>%any%</code> syntax.  </p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of unique operator names.
</p>


<h3>Note</h3>

<p>The right arrow assignment operators, <code>-&gt;</code> and <code>-&gt;&gt;</code> is not
an operator but a syntatic variant.  Consequently, it does not behave
properly as an operator.  They are omitted from the operator list as they
are not correctly identified as primitives or functions by the R language.
</p>


<h3>Author(s)</h3>

<p>Christopher Brown
</p>


<h3>References</h3>

<p><a href="https://cran.r-project.org/doc/manuals/R-lang.html">https://cran.r-project.org/doc/manuals/R-lang.html</a>
<a href="https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=14310">https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=14310</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Syntax">Syntax</a></code>, <code><a href="#topic+setOperator">setOperator</a></code>,
<code><a href="#topic+setOperators">setOperators</a></code>, and the help files on the individial operators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run:  
  operators()
  operators( types="arithmetic" )
  operators( types=c("arithmetic","logical" ) )
  operators( types='ALL' )
  operators( types='REG' )
  operators( types='UNREG' )
  operators( types='SPECIAL' )
 
## End(Not run)

</code></pre>

<hr>
<h2 id='rel.type'>Get the relational type of a relational operator.</h2><span id='topic+rel.type'></span><span id='topic+rel.type.function'></span><span id='topic+rel.type.name'></span><span id='topic+rel.type.call'></span><span id='topic+rel.type.expression'></span>

<h3>Description</h3>

<p><code>rel.type</code> gets the relational type of a relational operator. The
relational type is one of <code>'gt'</code>, <code>'lt'</code>, <code>'eq'</code>,
<code>'ne'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.type(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.type_+3A_x">x</code></td>
<td>
<p>An operators expressed as a <code>function</code> or <code>name</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A relational operator is an operate that relates the relationship between
arguments. The core relational operators are: &gt;, &gt;=, &lt;, &lt;=, ==, !=, 
</p>
<p>The relational.type is a simple roll-up of these operators. &gt; and &gt;= are gt,
etc. The value is retrieved from .Options$operators[[x]][['rel.type']] and
can be defined for relational operators using <code><a href="#topic+setOperator">setOperator</a></code>.
</p>
<p>A relational type provides an indication of nature of the relational
operator.
</p>


<h3>Value</h3>

<p><code>character</code> value of the operator.  One of: <code>'gt'</code>,
<code>'lt'</code>, <code>'eq'</code>, <code>'ne'</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+operators">operators</a></code>, <code><a href="#topic+setOperator">setOperator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
  rel.type( `==` ) 
  rel.type( as.name('==') )
 
## End(Not run)

</code></pre>

<hr>
<h2 id='removeOperator'>Unregister a an operator.</h2><span id='topic+removeOperator'></span>

<h3>Description</h3>

<p><code>removeOperator</code> unregisted an operator by removing it from the list of
operators found at <code> .Options$operators </code>. All operator attributes are
that have been set will be lost.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeOperator(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeOperator_+3A_x">x</code></td>
<td>
<p><code>character</code>. The name of the operator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warns if the operator has not been registered.
</p>


<h3>Value</h3>

<p>None. Used for side-effects.
</p>


<h3>Author(s)</h3>

<p>Christopher Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setOperators">setOperators</a></code> for registering Operators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Unregister ? as an operator.
  ## Not run: 
    removeOperator( '?' )
  
## End(Not run)

</code></pre>

<hr>
<h2 id='setOperator'>Registers an operator for use with operator.tools package.</h2><span id='topic+setOperator'></span><span id='topic+setOperators'></span><span id='topic+setOperators'></span>

<h3>Description</h3>

<p><code>setOperator</code> registers a user-defined operator as a given type.
Subsequently, this operator can be treated as a member of a class of
operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setOperator(name, type = "user", ...)

setOperators(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setOperator_+3A_name">name</code></td>
<td>
<p>A character vector containing the <b>names</b> of one or more
functions which will be registered.</p>
</td></tr>
<tr><td><code id="setOperator_+3A_type">type</code></td>
<td>
<p>The type of operator. See Details.</p>
</td></tr>
<tr><td><code id="setOperator_+3A_...">...</code></td>
<td>
<p>Attributes for the operator(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>setOperators</code> scans defined functions looking for any that have been
defined by the user using the special <code>any</code> syntax.  If found, these
are registered with <code>setOperator</code> and given the default type='user'.
</p>
<p><code>setOperator</code> registers a single operator similar to the way that
<code>setMethod</code> registers a method.  The definition for these operators are
defined by <code>.Options$operators</code>.
</p>
<p><code>setOperators</code> scans the environments for user-defined operators. If
found and not already registered, these are registered by
<code>setOperator</code>. Registered operators are much more efficient than
unregisted ones, so it is often advantageous to register the operators. When
<code>...</code> is supplied, these attributes are set for all unregistered
operators.
</p>
<p>Operators are allowed to have attributes. The one required attribute is
<code>type</code>, which is just a character value that serves to classification
the operator.  On package load, All operators from base R are assigned a
core type as specified in <a href="base.html#topic+Syntax">Syntax</a>.  These are: namespace,
component, indexing, sequence, arithmetic, arithmetic, relational, logical,
tilde, assignment, help.
</p>
<p>Users may use one of these types or assign a type of their own choosing. The
<code>type</code> is largely unrestricted, but cannot be one of the reserved
operator groupings: ALL, REG(ISTERED), UNREG(ISTERED), SPECIAL or user.
These have special meaning as described in <code><a href="#topic+operators">operators</a></code>. Users
are encouraaged to make their own types in lower case.
</p>


<h3>Value</h3>

<p>None. This function exists for assigning a operator to
<code>options('operators')</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+operators">operators</a></code>, <a href="base.html#topic+Syntax">Syntax</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
    setOperator( '%!in%', 'relational' )
    operators( type='relational' )
  
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
