<!DOCTYPE html><html lang="en"><head><title>Help for package tagtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tagtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a2pr'><p>Pitch and roll from acceleration</p></a></li>
<li><a href='#absorption'><p>Calculates the absorption coefficient for sound in seawater</p></a></li>
<li><a href='#acc_wgs84'><p>Calculate total acceleration</p></a></li>
<li><a href='#add_nc'><p>Save an item to a NetCDF or add one tag sensor or metadata variable to a NetCDF archive file.</p></a></li>
<li><a href='#apply_cal'><p>Implement a calibration on tag sensor data</p></a></li>
<li><a href='#beaked_whale'><p>Set of sensor lists for a beaked_whale</p></a></li>
<li><a href='#block_acf'><p>Compute autocorrelation function</p></a></li>
<li><a href='#block_mean'><p>Compute mean of sample blocks</p></a></li>
<li><a href='#block_rms'><p>Compute RMS of sample blocks</p></a></li>
<li><a href='#body_axes'><p>Generate the cardinal axes of an animal</p></a></li>
<li><a href='#buffer'><p>Buffers a signal vector into matrix</p></a></li>
<li><a href='#check_AM'><p>Compute field intensity of tag acceleration and magnetometer data.</p></a></li>
<li><a href='#cline'><p>Add colored line segments to a plot</p></a></li>
<li><a href='#col_line3'><p>Plot coloured line(s) in 3 dimensions with plot_ly</p></a></li>
<li><a href='#comp_filt'><p>Complementary filtering of a signal.</p></a></li>
<li><a href='#crop'><p>Interactive data cropping tool.</p></a></li>
<li><a href='#crop_all'><p>Reduce the time span of a dataset</p></a></li>
<li><a href='#crop_to'><p>Reduce the time span of data</p></a></li>
<li><a href='#csv2struct'><p>Read tag metadata from csv</p></a></li>
<li><a href='#decdc'><p>Reduce the sampling rate</p></a></li>
<li><a href='#decz'><p>Decimate sampling rate recursively.</p></a></li>
<li><a href='#depth_rate'><p>Estimate the vertical velocity</p></a></li>
<li><a href='#depth2pressure'><p>Convert depth to pressure</p></a></li>
<li><a href='#detect_peaks'><p>Detect peaks in signal vector data</p></a></li>
<li><a href='#dive_stats'><p>Compute summary statistics for dives or flights</p></a></li>
<li><a href='#draw_axis'><p>Draw time axis on plott plot.</p></a></li>
<li><a href='#dsf'><p>Estimate the dominant stroke frequency</p></a></li>
<li><a href='#euler2rotmat'><p>Make a rotation (or direction cosine) matrix</p></a></li>
<li><a href='#extract'><p>Extract a sub-sample of data</p></a></li>
<li><a href='#extract_cues'><p>Extract multiple sub-samples of data</p></a></li>
<li><a href='#find_dives'><p>Find time cues for dives</p></a></li>
<li><a href='#fir_nodelay'><p>Delay-free filtering</p></a></li>
<li><a href='#fit_tracks'><p>Integrate track with reference positions</p></a></li>
<li><a href='#fix_offset_3d'><p>Estimate the offset in each axis</p></a></li>
<li><a href='#fix_pressure'><p>Correct a depth or altitude profile</p></a></li>
<li><a href='#get_researcher'><p>Find matching researcher in a list of known tag researchers</p></a></li>
<li><a href='#get_species'><p>Find matching species in a list of marine mammals</p></a></li>
<li><a href='#harbor_seal'><p>Set of sensor lists for a harbor seal</p></a></li>
<li><a href='#hilbert_env'><p>Compute the envelope of X using Hilbert transform.</p>
</p>
<p>Compute the envelope of the signal matrix X using the Hilbert transform.</p>
To avoid long transforms, this function uses the overlap and add method.</a></li>
<li><a href='#hilbert_transform'><p>Return the Hilbert transform of a signal</p></a></li>
<li><a href='#htrack'><p>Simple horizontal dead-reckoned track</p></a></li>
<li><a href='#image_irreg'><p>Plot an image with an irregular grid.</p></a></li>
<li><a href='#inclination'><p>Estimate the inclination angle</p></a></li>
<li><a href='#interp_nan'><p>Remove NAs from sensor data and return indices of (rows of) filled values</p></a></li>
<li><a href='#interp2length'><p>Interpolate regularly sampled data to increase its sampling rate and match its length to another variable.</p></a></li>
<li><a href='#inv_axis'><p>Identify invariant axis in triaxial movement measurements.</p></a></li>
<li><a href='#julian_day'><p>Convert between dates and Julian day numbers.</p></a></li>
<li><a href='#lalo2llf'><p>Convert latitude-longitude track points into a local level frame</p></a></li>
<li><a href='#load_nc'><p>Load a tag dataset from a netCDF file.</p></a></li>
<li><a href='#m_dist'><p>Calculate Mahalanobis distance</p></a></li>
<li><a href='#m2h'><p>Heading from accelerometer and magnetometer data</p></a></li>
<li><a href='#make_info'><p>Make an info structure with tag metadata</p></a></li>
<li><a href='#make_specgram'><p>Plot a spectrogram with default settings</p></a></li>
<li><a href='#mean_absorption'><p>Calculate the mean absorption in salt water</p></a></li>
<li><a href='#median_filter'><p>Computes the nth-order median filter</p></a></li>
<li><a href='#merge_fields'><p>Merge the fields of two lists</p></a></li>
<li><a href='#metadata_editor'><p>Edits a html file from given csv.</p></a></li>
<li><a href='#msa'><p>Compute MSA</p></a></li>
<li><a href='#njerk'><p>Compute the norm-jerk</p></a></li>
<li><a href='#norm2'><p>Compute the row-wise vector norm</p></a></li>
<li><a href='#ocdr'><p>Estimate the forward speed</p></a></li>
<li><a href='#odba'><p>Compute ODBA</p></a></li>
<li><a href='#plott'><p>Plot tag data time series</p></a></li>
<li><a href='#plott_base'><p>Plot tag data time series</p></a></li>
<li><a href='#plott_static_panel'><p>Helper function for plott</p></a></li>
<li><a href='#prh_predictor1'><p>Predict the tag position on a diving animal from depth and acceleration data</p></a></li>
<li><a href='#prh_predictor2'><p>Predict the tag position on a diving animal from depth and acceleration data</p></a></li>
<li><a href='#ptrack'><p>Estimate simple dead-reckoned track</p></a></li>
<li><a href='#read_cats'><p>Read a CATS data file and convert to .nc</p></a></li>
<li><a href='#read_cats_csv'><p>Read a CSV file with sensor data from a CATS tag</p></a></li>
<li><a href='#rotate_data'><p>Rotate data.</p></a></li>
<li><a href='#rotate_vecs'><p>Rotate triaxial vector measurements</p></a></li>
<li><a href='#rotation_test'><p>Carry out a rotation randomization test.</p></a></li>
<li><a href='#rotmat2euler'><p>Decompose a rotation (or direction cosine) matrix</p></a></li>
<li><a href='#rough_cal_3d'><p>Estimate scale factors and offsets</p></a></li>
<li><a href='#save_nc'><p>Save a tag dataset to a netCDF file.</p></a></li>
<li><a href='#sens_struct'><p>Generate a sensor structure from a sensor data vector or matrix.</p></a></li>
<li><a href='#smooth'><p>Low pass filter a time series</p></a></li>
<li><a href='#sound_speed'><p>Sound speed estimation</p></a></li>
<li><a href='#spectrum_level'><p>Compute the spectrum level of a signal x.</p></a></li>
<li><a href='#speed_from_depth'><p>Estimate the forward speed of a diving animal</p></a></li>
<li><a href='#spherical_cal'><p>Deduce the calibration constants</p></a></li>
<li><a href='#tag2animal'><p>Tag-frame to animal-frame conversion</p></a></li>
<li><a href='#tortuosity'><p>Measure tortuosity index</p></a></li>
<li><a href='#track3D'><p>Reconstruct a track from pitch, heading and depth data, given a starting position</p></a></li>
<li><a href='#undo_cal'><p>Undo calibrations steps</p></a></li>
<li><a href='#zero_crossings'><p>Find zero-crossings in a vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Work with Data from High-Resolution Biologging Tags</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>High-resolution movement-sensor tags typically include accelerometers 
    to measure body posture and sudden movements or changes in speed, 
    magnetometers to measure direction of travel, and pressure sensors
    to measure dive depth in aquatic or marine animals. The sensors in these tags usually sample many times per second. Some tags include sensors for speed, turning rate (gyroscopes), and sound. This package provides software tools to facilitate calibration, processing, and analysis of such data. Tools are provided for: data import/export; 
    calibration (from raw data to calibrated data in scientific units); 
    visualization (for example, multi-panel time-series plots); 
    data processing (such as event detection, calculation of derived metrics like jerk and 
    dynamic acceleration, dive detection, and dive parameter calculation); and statistical analysis (for example, track reconstruction, a rotation test, and Mahalanobis distance analysis).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>CircStats, cowplot, dplyr, ggplot2, graphics, latex2exp,
lubridate, matlab, ncdf4, plotly, pracma, readr, signal, stats,
stringr, utils, zoo, zoom</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://animaltags.org&amp;gt;">https://animaltags.org&gt;</a>,
&lt;<a href="https://animaltags.github.io/tagtools_r/index.html&amp;gt;">https://animaltags.github.io/tagtools_r/index.html&gt;</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/animaltags/tagtools_r/issues">https://github.com/animaltags/tagtools_r/issues</a></td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-28 14:18:31 UTC; sld33</td>
</tr>
<tr>
<td>Author:</td>
<td>Stacy DeRuiter <a href="https://orcid.org/0000-0002-0571-0306"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Mark Johnson [aut, cph],
  David Sweeney [aut],
  Ye Joo McNamara-Oh [aut],
  Samuel Fynewever [aut],
  (Oghenkevwe) Racheal Tejevbo [aut],
  Tiago Marques [aut],
  Yuqian Wang [aut],
  (Oghenesuvwe) Su Ogedegbe [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stacy DeRuiter &lt;stacy.deruiter@calvin.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-28 14:30:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='a2pr'>Pitch and roll from acceleration</h2><span id='topic+a2pr'></span>

<h3>Description</h3>

<p>Pitch and roll estimation from triaxial accelerometer data. This is a non-iterative estimator with |pitch| constrained to &lt;= 90 degrees. The pitch and roll estimates give the least-square-norm error between A and the A-vector that would be measured at the estimated pitch and roll. If A is in the animal frame, the resulting pitch and roll define the orientation of the animal with respect to its navigation frame. If A is in the tag frame, the pitch and roll will define the tag orientation with respect to its navigation frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a2pr(A, sampling_rate = NULL, fc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="a2pr_+3A_a">A</code></td>
<td>
<p>An nx3 acceleration matrix with columns [ax ay az] or acceleration sensor list (e.g., from readtag.R). Acceleration can be in any consistent unit, e.g., g or m/s^2.</p>
</td></tr>
<tr><td><code id="a2pr_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>(optional) The sampling rate of the sensor data in Hz (samples per second). This is only needed if filtering is required. If A is a sensor data list, sampling_rate is obtained from its metadata (A$sampling_rate).</p>
</td></tr>
<tr><td><code id="a2pr_+3A_fc">fc</code></td>
<td>
<p>(optional) The cut-off frequency of a low-pass filter to apply to A before computing pitch and roll. The filter cut-off frequency is in Hertz. The filter length is 4*sampling_rate/fc. Filtering adds no group delay. If fc is not specified, no filtering is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 elements:
</p>

<ul>
<li><p><strong>p: </strong> The pitch estimate in radians
</p>
</li>
<li><p><strong>r: </strong> The roll estimate in radians
</p>
</li></ul>



<h3>Note</h3>

<p>Output sampling rate is the same as the input sampling rate.
</p>
<p>Frame: This function assumes a [north,east,up] navigation frame and a [forward,right,up] local frame. In these frames, a positive pitch angle is an anti-clockwise rotation around the y-axis. A positive roll angle is a clockwise rotation around the x-axis. A descending animal will have a negative pitch angle while an animal rolled with its right side up will have a positive roll angle.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+m2h">m2h</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samplematrix &lt;- matrix(c(0.77, -0.6, -0.22, 0.45, -0.32, 0.99, 0.2, -0.56, 0.5),
  byrow = TRUE, nrow = 3
)
list &lt;- a2pr(samplematrix)

</code></pre>

<hr>
<h2 id='absorption'>Calculates the absorption coefficient for sound in seawater</h2><span id='topic+absorption'></span>

<h3>Description</h3>

<p>Calculates the absorption coefficient for sound in seawater
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absorption(freq, temperature, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="absorption_+3A_freq">freq</code></td>
<td>
<p>frequency in Hz</p>
</td></tr>
<tr><td><code id="absorption_+3A_temperature">temperature</code></td>
<td>
<p>temperature in degrees C</p>
</td></tr>
<tr><td><code id="absorption_+3A_d">d</code></td>
<td>
<p>depth in meters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sound absorption in dB per metre.
</p>


<h3>Note</h3>

<p>Input arguments can be scalars, or a mixture of vectors and scalars as long as each argument is either a vector of length nx1 (with n being the same for all vector arguments) or a scalar.
</p>
<p>After Kinsler and Frey pp. 159-160
</p>


<h3>Examples</h3>

<pre><code class='language-R'>absorption(140e3, 13, 10)
</code></pre>

<hr>
<h2 id='acc_wgs84'>Calculate total acceleration</h2><span id='topic+acc_wgs84'></span>

<h3>Description</h3>

<p>This function calculates the total acceleration due to gravitation and centripetal force at the earth's surface according to the WGS84 international gravity formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acc_wgs84(latitude)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acc_wgs84_+3A_latitude">latitude</code></td>
<td>
<p>The latitude in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>g given in units of $m/s^2$
</p>


<h3>Note</h3>

<p>Source: http://solid_earth.ou.edu/notes/potential/igf.htm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>acc_wgs84(50)
</code></pre>

<hr>
<h2 id='add_nc'>Save an item to a NetCDF or add one tag sensor or metadata variable to a NetCDF archive file.</h2><span id='topic+add_nc'></span>

<h3>Description</h3>

<p>Add one tag sensor or metadata variable to a NetCDF archive file. If the archive file does not exist,
it is created. The file is assumed to be in the current working directory
unless a pathname is added to the beginning of fname.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_nc(file, D, vname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_nc_+3A_file">file</code></td>
<td>
<p>The name of the netCDF file to which to save. If the name does not include a .nc suffix, this will be added automatically.</p>
</td></tr>
<tr><td><code id="add_nc_+3A_d">D</code></td>
<td>
<p>The sensor data or metadata list to be saved.</p>
</td></tr>
<tr><td><code id="add_nc_+3A_vname">vname</code></td>
<td>
<p>The name of the sensor data stream to be saved. Defaults to the entry &quot;name&quot; from the sensor or metadata list provided by the user (but an option to specify a name is provided to facilitate calling this function from <code>save_nc</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return; adds a structure to an <code>animaltag</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+save_nc">save_nc</a></code>, <code><a href="#topic+load_nc">load_nc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
BW &lt;- beaked_whale
add_nc("beaked_whale", njerk(BW$A), "Jerk")


</code></pre>

<hr>
<h2 id='apply_cal'>Implement a calibration on tag sensor data</h2><span id='topic+apply_cal'></span>

<h3>Description</h3>

<p>Given an appropriate set of calibration constants and information, this function will apply the calibration procedure to a tag sensor data set. Cal fields currently supported are: poly, cross, map, tcomp, tref
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_cal(X, cal, Tempr = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_cal_+3A_x">X</code></td>
<td>
<p>A tag sensor data list, or a matrix or vector containing tag sensor data</p>
</td></tr>
<tr><td><code id="apply_cal_+3A_cal">cal</code></td>
<td>
<p>A calibration list for the data in X from, for example, spherical_cal.</p>
</td></tr>
<tr><td><code id="apply_cal_+3A_tempr">Tempr</code></td>
<td>
<p>a tag sensor data list or a vector of temperature measurements for use in temperature compensation.
If Tempr is not a sensor data list, it must be the same size and sampling rate as the data in <code>X</code>.
Tempr is only required if there is a tcomp item in the <code>cal</code> list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tag sensor data structure (or a matrix or vector, if X was a matrix or vector) with the calibration implemented. Data size and sampling rate are the same as for the input data <code>X</code>, but units may have changed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A_cal &lt;- apply_cal(harbor_seal$A,spherical_cal(harbor_seal$A$data))

</code></pre>

<hr>
<h2 id='beaked_whale'>Set of sensor lists for a beaked_whale</h2><span id='topic+beaked_whale'></span>

<h3>Description</h3>

<p>Data is from a _Mesoplodon densirostris_ with tag ID md13_134a. The device used was a DTAG3 and it was deployed at 2013-05-14 12:42:00 in El Hierro, Canary Islands, Spain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beaked_whale
</code></pre>


<h3>Format</h3>

<p>A set of sensor lists:
</p>

<dl>
<dt>A</dt><dd><p>sensor list containing a triaxial acceleration matrix sampled at 25 Hz</p>
</dd>
<dt>M</dt><dd><p>sensor list containing a triaxial magnetometer matrix sampled at 25 Hz</p>
</dd>
<dt>P</dt><dd><p>sensor list containing a pressure (depth) vector sampled at 25 Hz</p>
</dd>
</dl>


<hr>
<h2 id='block_acf'>Compute autocorrelation function</h2><span id='topic+block_acf'></span>

<h3>Description</h3>

<p>This function allows calculation of an autocorrelation function (ACF) for a dataset with multiple independent units (for example, data from several individuals, data from multiple dives by an individual animal, etc.). The groups (individual, dive, etc.) should be coded in a categorical variable. The function calculates correlation coefficients over all levels of the categorical variable, but respecting divisions between levels (for example, individual animals are kept separate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_acf(resids, blocks, max_lag, make_plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="block_acf_+3A_resids">resids</code></td>
<td>
<p>The variable for which the ACF is to be computed (often a vector of residuals from a fitted model)</p>
</td></tr>
<tr><td><code id="block_acf_+3A_blocks">blocks</code></td>
<td>
<p>A categorical variable indicating the groupings (must be the same length as resids. ACF will be computed only for data points within the same block.)</p>
</td></tr>
<tr><td><code id="block_acf_+3A_max_lag">max_lag</code></td>
<td>
<p>ACF will be computed at 0-max_lag lags, ignoring all observations that span blocks. Defaults to the minimum number of observations in any block. The function will allow you to specify a max_lag longer than the shortest block if you so choose.</p>
</td></tr>
<tr><td><code id="block_acf_+3A_make_plot">make_plot</code></td>
<td>
<p>Logical. Should a plot be produced? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="block_acf_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to plot.acf</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 1 variable containing the values of ACF.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>block_acf(
  resids = ChickWeight$weight,
  blocks = ChickWeight$Chick
)
</code></pre>

<hr>
<h2 id='block_mean'>Compute mean of sample blocks</h2><span id='topic+block_mean'></span>

<h3>Description</h3>

<p>This function is used to compute the means of successive blocks of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_mean(X, n, nov)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="block_mean_+3A_x">X</code></td>
<td>
<p>A vector or a matrix containing samples of a signal in each column.</p>
</td></tr>
<tr><td><code id="block_mean_+3A_n">n</code></td>
<td>
<p>The number of samples from X to use in each analysis block.</p>
</td></tr>
<tr><td><code id="block_mean_+3A_nov">nov</code></td>
<td>
<p>(optional) The number of samples that the next block overlaps the previous block. The default value is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 elements:
</p>

<ul>
<li><p><strong>Y: </strong> A vector or matrix containing the mean value of each block. If X is a mxn matrix, Y is pxn where p is the number of complete n-length blocks with nov that can be made out of m samples, i.e., n+(p-1)*(n-nov) &lt; m
</p>
</li>
<li><p><strong>samples: </strong> The time at which each output in Y is reported, in units of samples of X.  So if samples[1] = 12, then the value Y[1] corresponds to the “time” 12 samples in X.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>samplematrix &lt;- matrix(c(1, 3, 5, 7, 9, 11, 13, 15, 17), byrow = TRUE, ncol = 3)
list &lt;- block_mean(samplematrix, n = 3, nov = 1)
</code></pre>

<hr>
<h2 id='block_rms'>Compute RMS of sample blocks</h2><span id='topic+block_rms'></span>

<h3>Description</h3>

<p>This function is used to compute the RMS (root-mean-square) of successive blocks of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_rms(X, n, nov = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="block_rms_+3A_x">X</code></td>
<td>
<p>A vector or a matrix containing samples of a signal in each column.</p>
</td></tr>
<tr><td><code id="block_rms_+3A_n">n</code></td>
<td>
<p>The number of samples from X to use in each analysis block.</p>
</td></tr>
<tr><td><code id="block_rms_+3A_nov">nov</code></td>
<td>
<p>The number of samples that the next block overlaps the previous block.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 elements:
</p>

<ul>
<li><p><strong>Y: </strong> A vector or matrix containing the RMS value of each block. If X is a mxn matrix, Y is pxn where p is the number of complete n-length blocks with nov that can be made out of m samples, i.e., n+(p-1)*(n-nov) &lt; m
</p>
</li>
<li><p><strong>samples: </strong> The time at which each output in Y is reported, in units of samples of X.  So if samples[1] = 12, then the value Y[1] corresponds to the “time” 12 samples in X. The times at which Y values are reported are the centers of the averaging windows.
</p>
</li></ul>



<h3>Note</h3>

<p>Output sampling rate is the same as the input sampling rate so s and v have the same size as p.
</p>
<p>Frame: This function assumes a [north,east,up] navigation frame and a [forward,right,up] local frame. In these frames, a positive pitch angle is an anti-clockwise rotation around the y-axis. A descending animal will have a negative pitch angle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(c(1:20), byrow = TRUE, nrow = 4)
block_rms(X, n = 2, nov = NULL)
</code></pre>

<hr>
<h2 id='body_axes'>Generate the cardinal axes of an animal</h2><span id='topic+body_axes'></span>

<h3>Description</h3>

<p>This function is used to generate the cardinal axes of an animal (i.e., the longitudinal, transverse, and ventro-dorsal) from accelerometer and magnetic field measurements. This functions generates an approximate orthonormal basis from each measurement of A and M by: (i) normalizing A and M to unit length, (ii) rotating the magnetometer measurement to the horizontal plane (Mh), (iii) computing the cross-product, N, of A and Mh to generate the third axis, (iv) transposing [Mh,N,A] to form the body axis basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>body_axes(A, M, sampling_rate = NULL, fc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="body_axes_+3A_a">A</code></td>
<td>
<p>The acceleration matrix with columns [ax ay az], or a sensor data list. Acceleration can be in any consistent unit, e.g., g or $m/s^2$.</p>
</td></tr>
<tr><td><code id="body_axes_+3A_m">M</code></td>
<td>
<p>The magnetometer signal matrix, M=[mx,my,mz], or a sensor data list, in any consistent unit (e.g., in uT or Gauss).</p>
</td></tr>
<tr><td><code id="body_axes_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>sampling rate of A and M in Hz (optional if A and M are sensor data lists)</p>
</td></tr>
<tr><td><code id="body_axes_+3A_fc">fc</code></td>
<td>
<p>(optional) The cut-off frequency of a low-pass filter to apply to A and M before computing the axes. The filter cut-off frequency is in Hz. The filter length is 4*fs/fc. Filtering adds no group delay. If fc is not specified, no filtering  is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>W, a list with entries <code>x</code>, <code>y</code>, and <code>z</code>; each is an nx3 matrix of body axes where n is the number of rows in M and A.
W$x is a nx3 matrix (or a length-3 vector if A and M have one row) containing the X or longitudinal (caudo-rostral) axes.
W$y is a nx3 matrix (or a length-3 vector if A and M have one row) containing the Y or transverse (left-right) axes.
W$z is a nx3 matrix (or a length-3 vector if A and M have one row) containing the Z or ventro-dorsal axes.
W$sampling_rate has the sampling rate of the A and M.
</p>


<h3>Note</h3>

<p>Output sampling rate is the same as the input sampling rate. Irregularly sampled data can be used, but then filtering must not be applied (<code>fc = NULL</code>).
</p>
<p>Frame: This function assumes a [north,east,up] navigation frame and a [forward,right,up] local frame. This function will only return the animal's cardinal axes if the tag was attached so that the sensor axes aligned with the animal's axes OR if the tag A and M measurements are rotated to account for the orientation of the tag on the animal. Otherwise, the axes returned by this function will be the cardinal axes of the tag, not the animal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samplematrix1 &lt;- matrix(c(7, 2, 3, 6, 4, 9), byrow = TRUE, ncol = 3)
samplematrix2 &lt;- matrix(c(6, 5, 3, 4, 8, 9), byrow = TRUE, ncol = 3)
W &lt;- body_axes(A = samplematrix1, M = samplematrix2, fc = NULL)
</code></pre>

<hr>
<h2 id='buffer'>Buffers a signal vector into matrix</h2><span id='topic+buffer'></span>

<h3>Description</h3>

<p>This function is used to buffer a signal vector into a matrix of data frames. If the input for nodelay is TRUE, the the signal is buffered with no delay. If nodelay is FALSE, and specifies a vector of samples to precede x[1] in an overlapping buffer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buffer(x, n, overlap, opt, nodelay = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buffer_+3A_x">x</code></td>
<td>
<p>The signal vector to be buffered</p>
</td></tr>
<tr><td><code id="buffer_+3A_n">n</code></td>
<td>
<p>The desired length of data segments (rows).</p>
</td></tr>
<tr><td><code id="buffer_+3A_overlap">overlap</code></td>
<td>
<p>The desired amount of overlap between consecutive frames (columns) in the output matrix</p>
</td></tr>
<tr><td><code id="buffer_+3A_opt">opt</code></td>
<td>
<p>The vector of samples specified to precede x[1] in an overlapping buffer</p>
</td></tr>
<tr><td><code id="buffer_+3A_nodelay">nodelay</code></td>
<td>
<p>A logical statement to determine if the vector should be buffered with or without delay. Default is FALSE (with delay)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 elements is returned if nodelay = FALSE:
</p>

<ul>
<li><p><strong>X: </strong> A matrix of the buffered signal vector &quot;vec&quot; with &quot;n&quot; data segments and an overlap between consecutive frames specified by &quot;p&quot;. The matrix starts with &quot;opt&quot; values if nodelay is FALSE.
</p>
</li>
<li><p><strong>z: </strong>  The remainder of the vector which was not included in the matrix if the last column did not have a full number of rows.
</p>
</li>
<li><p><strong>opt: </strong> The last values, length of &quot;p&quot;, of the matrix &quot;X&quot;.
</p>
</li></ul>

<p>If nodelay = TRUE, then a matrix of the buffered signal vector &quot;vec&quot; with &quot;n&quot; data segments and an overlap between consecutive frames specified by &quot;overlap&quot;. The matrix starts with &quot;opt&quot; values if nodelay is FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:10)
n &lt;- 3
overlap &lt;- 2
opt &lt;- c(2, 1)
list1 &lt;- buffer(x, n, overlap, opt)
list2 &lt;- buffer(x, n, overlap, nodelay = TRUE)
</code></pre>

<hr>
<h2 id='check_AM'>Compute field intensity of tag acceleration and magnetometer data.</h2><span id='topic+check_AM'></span>

<h3>Description</h3>

<p>Compute field intensity of acceleration and magnetometer data,
and the inclination angle of the magnetic field.
This is useful for checking the quality of a calibration,
for detecting drift, and for validating the mapping
of the sensor axes to the tag axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_AM(A, M = NULL, fs = NULL, find_incl = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_AM_+3A_a">A</code></td>
<td>
<p>An accelerometer sensor structure or matrix with columns [ax ay az]. Acceleration can be in any consistent unit, e.g., g or m/s^2.</p>
</td></tr>
<tr><td><code id="check_AM_+3A_m">M</code></td>
<td>
<p>A magnetometer sensor structure or matrix, M=[mx,my,mz] in any consistent  unit (e.g., in uT or Gauss).</p>
</td></tr>
<tr><td><code id="check_AM_+3A_fs">fs</code></td>
<td>
<p>(optional) The sampling rate of the sensor data in Hz (samples per second). This is only needed if A and M are not sensor structures and filtering is required.</p>
</td></tr>
<tr><td><code id="check_AM_+3A_find_incl">find_incl</code></td>
<td>
<p>(optional; logical) Should inclination be computed and returned? Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sampling rate of fstr and incl is the same as the input sampling rate.
This function automatically low-pass filters the data with a cut-off frequency
of 5 Hz if the sampling rate is greater than 10 Hz.
Frame: This function assumes a [north,east,up] navigation frame and a
[forward,right,up] local frame.
</p>


<h3>Value</h3>

<p>If find_incl is false, then the matrix fstr is returned. Otherwise, check_AM returns a list with elements:
</p>

<ul>
<li> <p><code>fstr, </code> The estimated field intensity of A and or M in the same units as A and M.
fstr is a vector or a two column matrix. If only one type of data is input,
fstr will be a column vector. If both A and M are input, fstr will have two columns
with the field strength of A in the 1st column and the field strength of M in the
2nd column.
</p>
</li>
<li> <p><code>incl, </code> The estimated field inclination angle (i.e., the angle with respect to the
horizontal plane) in radians. incl is a column vector. By convention, a field
vector pointing below the horizon has a positive inclination angle. This is only
returned if the function is called with both A and M data.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>AMcheck &lt;- check_AM(
  A = matrix(c(-0.3, 0.52, 0.8), nrow = 1),
  M = matrix(c(22, -22, 14), nrow = 1),
  fs = 1
)
</code></pre>

<hr>
<h2 id='cline'>Add colored line segments to a plot</h2><span id='topic+cline'></span>

<h3>Description</h3>

<p>This function adds colored line segments to an existing plot.  The line is plotted at points specified by inputs x and y, and colored according to factor input z (with one color for each level of z).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cline(x, y, z, color_vector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cline_+3A_x">x</code></td>
<td>
<p>x positions of points to be plotted</p>
</td></tr>
<tr><td><code id="cline_+3A_y">y</code></td>
<td>
<p>y positions of points to be plotted</p>
</td></tr>
<tr><td><code id="cline_+3A_z">z</code></td>
<td>
<p>a factor, the same length as x and y. Line segments in the resulting plot will be colored according to the levels of z.</p>
</td></tr>
<tr><td><code id="cline_+3A_color_vector">color_vector</code></td>
<td>
<p>a list of colors to use (length should match the number of levels in z).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adds colored lines to a graph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cline(x=ChickWeight$Time, y=ChickWeight$weight, 
      z=as.factor(ChickWeight$Diet), 
      color_vector=c('black', 'grey20', 
                     'grey50', 'grey70'))
</code></pre>

<hr>
<h2 id='col_line3'>Plot coloured line(s) in 3 dimensions with plot_ly</h2><span id='topic+col_line3'></span>

<h3>Description</h3>

<p>This function is used to plot three dimensional lines with segments colored. It may be just as simple to use plotly::plot_ly() directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_line3(x, y, z = 0, c, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_line3_+3A_x">x</code></td>
<td>
<p>name of object or variable containing data for x axis</p>
</td></tr>
<tr><td><code id="col_line3_+3A_y">y</code></td>
<td>
<p>name of object or variable containing data for y axis</p>
</td></tr>
<tr><td><code id="col_line3_+3A_z">z</code></td>
<td>
<p>name of object or variable containing data for z axis</p>
</td></tr>
<tr><td><code id="col_line3_+3A_c">c</code></td>
<td>
<p>name of object or variable by which to color</p>
</td></tr>
<tr><td><code id="col_line3_+3A_...">...</code></td>
<td>
<p>Additional inputs for plot_ly()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot_ly() graphics object
</p>


<h3>Note</h3>

<p>x, y, z and c must all be the same size vectors. The color axis will by default span the range of values in c, i.e., caxis will be c(min(min(c)), max(max(c))).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cline">cline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col_line3(1:20, 1:20, 1:20, 1:20)
</code></pre>

<hr>
<h2 id='comp_filt'>Complementary filtering of a signal.</h2><span id='topic+comp_filt'></span>

<h3>Description</h3>

<p>This function breaks signal X into two or more frequency bands such that the sum of the signals in the separate bands is equal to the original signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_filt(X, sampling_rate = NULL, fc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_filt_+3A_x">X</code></td>
<td>
<p>A sensor vector or matrix (i.e., with a signal in each column) or sensor list (e.g., from readtag.R).</p>
</td></tr>
<tr><td><code id="comp_filt_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate of the sensor data in Hz (samples per second).</p>
</td></tr>
<tr><td><code id="comp_filt_+3A_fc">fc</code></td>
<td>
<p>Specifies the cut-off frequency or frequencies of the complementary filters. Frequencies are in Hz. If one frequency is given, X will be split into a low- and a high-frequency component. If fc contains more than one value, X will be split into multiple complementary bands. Each filter length is 4*sampling_rate/fc. Filtering adds no group delay.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible input combinations: comp_filt(X,sampling_rate,fc) if X is a vector or matrix, comp_filt(X,fc = fc) if X is a list
</p>


<h3>Value</h3>

<p>A list of filtered signals. There are n+1 sections of the list where n is the length of fc. List sections are ordered in Xf from lowest to highest frequency. Each list section contains a vector or matrix of the same size as X, and at the same sampling rate as X.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Xf &lt;- comp_filt(X = beaked_whale$A$data, sampling_rate = beaked_whale$A$sampling_rate, fc = .15)
xf &lt;- list(Xf1 = Xf[[1]], Xf2 = Xf[[2]])
plott_base(xf, beaked_whale$A$sampling_rate)

</code></pre>

<hr>
<h2 id='crop'>Interactive data cropping tool.</h2><span id='topic+crop'></span>

<h3>Description</h3>

<p>This function plots the input data # and allows the user to select start and end times for cropping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop(X, sampling_rate = NULL, times = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crop_+3A_x">X</code></td>
<td>
<p>A sensor list, vector or matrix. X can be regularly or irregularly sampled data in any frame and unit.</p>
</td></tr>
<tr><td><code id="crop_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate of X in Hz. This is only needed if X is not a sensor list. If X is regularly sampled, sampling_rate is one number.</p>
</td></tr>
<tr><td><code id="crop_+3A_times">times</code></td>
<td>
<p>A vector of sampling times for X. This is only needed if X is not a sensor list and X is not regularly sampled.</p>
</td></tr>
<tr><td><code id="crop_+3A_quiet">quiet</code></td>
<td>
<p>If quiet is false, print to the screen</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible input combinations include: crop(X) if X is a sensor list, crop(X, sampling_rate) if X is a vector or matrix.
</p>


<h3>Value</h3>

<p>A list with 3 elements:
</p>

<ul>
<li><p><strong>Y: </strong> A sensor list, vector or matrix containing the cropped data segment. If the input is a sensor list, the output will also be. The output has the same units, frame and sampling characteristics as the input.
</p>
</li>
<li><p><strong>times: </strong> A vector of sampling times for Y. This is only returned if X is irregularly sampled and X is not a sensor list. If X is a sensor list, the sampling times are stored in the list.
</p>
</li>
<li><p><strong>tcues: </strong> tcues is a two-element vector containing the start and end time cue in seconds of the data segment kept, i.e., tcues = c(start_time, end_time).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- beaked_whale
Pc &lt;- crop(data$P, quiet=TRUE) 
Ydata &lt;- Pc$data
plot(-Ydata)
</code></pre>

<hr>
<h2 id='crop_all'>Reduce the time span of a dataset</h2><span id='topic+crop_all'></span>

<h3>Description</h3>

<p>This function is used to reduce the time span of a dataset by cropping out any data that falls before and after two time cues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_all(tcues, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crop_all_+3A_tcues">tcues</code></td>
<td>
<p>A two-element vector containing the start and end time cue in seconds of the data segment to keep, i.e., tcues = c(start_time, end_time).</p>
</td></tr>
<tr><td><code id="crop_all_+3A_x">X</code></td>
<td>
<p>A sensor list or a set of sensor lists (e.g., from load_nc).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible input combinations: crop_all(X) if X is a sensor list or set of sensor lists, crop_all(tcues, X, Y, ...) if X, Y, ... are sensor lists.
</p>


<h3>Value</h3>

<p>A sensor list or set of sensor lists containing the cropped data segment. The output data have the same units, frame and sampling characteristics as the input. The list may have many sublists which are additional sensor structures as required to match the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- find_dives(beaked_whale$P,300) 
         X &lt;- crop_all(c(d$start[1], d$end[1]), beaked_whale)	#crop all data to 1st dive
         plott_base(X = list(X$P, X$A), r = c(1, 0), panel_labels = c('Depth', 'Acc'))
</code></pre>

<hr>
<h2 id='crop_to'>Reduce the time span of data</h2><span id='topic+crop_to'></span>

<h3>Description</h3>

<p>This function is used to reduce the time span of data by cropping out any data that falls before and after two time cues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_to(X, sampling_rate = NULL, tcues, times = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crop_to_+3A_x">X</code></td>
<td>
<p>A sensor list, vector, or matrix. X can be regularly or irregularly samples data in any frame and unit.</p>
</td></tr>
<tr><td><code id="crop_to_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate of X in Hz. This is only needed if X is not a sensor structure.</p>
</td></tr>
<tr><td><code id="crop_to_+3A_tcues">tcues</code></td>
<td>
<p>A two-element vector containing the start and end time cues in seconds of the data segment to keep (i.e., tcues &lt;- c(start_time, end_time)).</p>
</td></tr>
<tr><td><code id="crop_to_+3A_times">times</code></td>
<td>
<p>A vector of sampling times for X. This is only needed if X is not a sensor list and X is not regularly sampled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cropped data in the same format as X, unless X is irregularly sampled and NOT a sensor list. In that case, the function returns a list with 2 elements:
</p>

<ul>
<li><p><strong>X: </strong> A sensor list, vector or matrix containing the cropped data segment. If the input is a sensor list, the output will also be. The output has the same units, frame and sampling characteristics as the input.
</p>
</li>
<li><p><strong>times: </strong> A vector of sampling times for Y. This is only returned if X is irregularly sampled and X is not a sensor list. (If X is a sensor list, the sampling times are stored in the list.)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>         d &lt;- find_dives(beaked_whale$P,300) 
         P2 &lt;- crop_to(beaked_whale$P, tcues = c(d$start[1], d$end[1]))	#crop to 1st dive
         plott_base(X = list(P2), r=c(1), panel_labels=c('Depth'))
</code></pre>

<hr>
<h2 id='csv2struct'>Read tag metadata from csv</h2><span id='topic+csv2struct'></span>

<h3>Description</h3>

<p>Read a CSV metadata file and convert it into a metadata list.
A metadata file is a comma-separated text file (.csv) containing a line for each metadata
entry. The first comma-separated field in each line is the name of the
entry. The last field in each line contains the value to
be assigned to this metadata entry. The value can be a string or number
but is always saved as a string in the structure - it is up to downstream
users of the metadata to parse/decode the entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csv2struct(fname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csv2struct_+3A_fname">fname</code></td>
<td>
<p>Name of the text file to be read. If no file extension is provided, '.csv' will be
added automatically. If the file is not located in the current working directory, then <code>fname</code> must include the correct relative or absolute path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a metadata list populated from <code>fname</code> (one list element per row in the file). All list elements are stored as <code>"character"</code> class objects (even if the field contains a number, a date, etc) - no attempt is made to determine the most appropriate class for each item.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hold &lt;- system.file("extdata","metadata_example.csv", package = "tagtools", mustWork = TRUE)
S &lt;- csv2struct(hold)

</code></pre>

<hr>
<h2 id='decdc'>Reduce the sampling rate</h2><span id='topic+decdc'></span>

<h3>Description</h3>

<p>This function is used to reduce the sampling rate of a time series by an integer factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decdc(x, df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decdc_+3A_x">x</code></td>
<td>
<p>A data structure, vector or matrix containing the signal(s) to be decimated. If x is a matrix, each column is decimated separately.</p>
</td></tr>
<tr><td><code id="decdc_+3A_df">df</code></td>
<td>
<p>The decimation factor. The output sampling rate is the input sampling rate divided by df. df must be an integer greater than 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y The decimated signal vector or matrix. It has the same number of columns as x but has 1/df of the rows.
</p>


<h3>Note</h3>

<p>Decimation is performed by first low-pass filtering x and then keeping 1 sample out of every df. A symmetric FIR filter with length 12*df and cutoff frequency 0.4*fs/df is used. The group delay of the filter is removed. For large decimation factors (e.g., df&gt;&gt;50), it is better to perform several decimations with lower factors. For example to decimate by 120, use: decdc(decdc(x,10),12).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- matrix(sin(2 * pi / 100 * c(0:1000) - 1), ncol = 1)
plot(c(1:length(s)), s) 
y &lt;- decdc(x = s, df = 4)
plot(c(1:length(y)), y) 

</code></pre>

<hr>
<h2 id='decz'>Decimate sampling rate recursively.</h2><span id='topic+decz'></span>

<h3>Description</h3>

<p>Recursive sampling rate decimator. This function can be run iteratively over a long data set, e.g., to decimate an entire recording that is too large to be read into memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decz(x, df = NULL, Z = NULL, nf = 12, frbw = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decz_+3A_x">x</code></td>
<td>
<p>A vector, matrix, or tag data list containing the signal(s) to be decimated. If x is a matrix, each column is decimated separately. If inputs <code>df</code> and <code>Z</code> are both provided, then the value of <code>df</code> stored in <code>Z</code> will override the user-provided <code>df</code>.</p>
</td></tr>
<tr><td><code id="decz_+3A_df">df</code></td>
<td>
<p>The decimation factor. The output sampling rate is the input sampling rate divided by df. df must be an integer greater than 1. df can also be a three element vector in which case: df(1) is the decimation factor; df(2) is the number of output samples spanned by the filter (default value is 12). A larger value makes the filter steeper; df(3) is the fractional bandwidth of the filter (default value is 0.8) relative to the output Nyquist frequency. If df(2) is greater than 12, df(3) can be closer to 1.</p>
</td></tr>
<tr><td><code id="decz_+3A_z">Z</code></td>
<td>
<p>The 'state' list that is generated by a previous call to decz. This is how the function keeps track of filter internal values (i.e., memory) from call-to-call.</p>
</td></tr>
<tr><td><code id="decz_+3A_nf">nf</code></td>
<td>
<p>The number of output samples spanned by the filter (default value is 12). A larger value makes the filter steeper.</p>
</td></tr>
<tr><td><code id="decz_+3A_frbw">frbw</code></td>
<td>
<p>The fractional bandwidth of the filter (default value is 0.8) relative to the output Nyquist frequency. If <code>nf</code> is greater than 12, <code>frbw</code> can be closer to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first time decz is called, use the following format: y = decz(x,df). The subsequent calls to decz for contiguous input data are: decz(x,Z). The final call when there is no more input data is: decz(x = NULL, Z = Z). Each output y in the above contains a segment of the decimated signal and so these need to be concatenated.
Decimation is performed in the same way as for <code><a href="#topic+decdc">decdc</a></code>. The group delay of the filter is removed. For large decimation factors (e.g., df much greater than 50), it is better to perform several nested decimations with lower factors.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li><p><strong>y: </strong> The decimated signal vector or matrix. It has the same number of columns as x but has, on average, 1/df of the rows.
</p>
</li>
<li><p><strong>Z: </strong> The state list (for internal tracking of filter internal values). Contains elements df (the decimation factor), nf (used to compute the filter length), frbw (the bandwidth of the filter relative to the new Nyquist frequency), h (the FIR filter coefficients), n (the filter length), z (padded signal used for filtering), and ov (&quot;overflow&quot; samples to be passed to future iterations).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+decdc">decdc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plott_base(list(Accel = beaked_whale$A)) # acceleration data before decimation
a_rows &lt;- nrow(beaked_whale$A$data)
a_ind &lt;- data.frame(start = c(1, floor(a_rows / 3), floor(2 * a_rows / 3)))
a_ind$end &lt;- c(a_ind$start[2:3] - 1, a_rows)
df &lt;- 10
Z &lt;- NULL
y &lt;- NULL
for (k in 1:nrow(a_ind)) {
  decz_out &lt;- decz(
    x = beaked_whale$A$data[c(a_ind[k, 1]:a_ind[k, 2]), ],
    df = df, Z = Z
  )
  df &lt;- NULL
  Z &lt;- decz_out$Z
  y &lt;- rbind(y, decz_out$y)
}

</code></pre>

<hr>
<h2 id='depth_rate'>Estimate the vertical velocity</h2><span id='topic+depth_rate'></span>

<h3>Description</h3>

<p>This function is used to estimate the vertical velocity by differentiating a depth or altitude time series. A low-pass filter reduces the sensor noise that is amplified by the differentiation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth_rate(p, fs, fc, depth)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="depth_rate_+3A_p">p</code></td>
<td>
<p>A vector of depth or altitude data, or an animaltags list object containing depth or altitude data.</p>
</td></tr>
<tr><td><code id="depth_rate_+3A_fs">fs</code></td>
<td>
<p>(required only if p is a vector) is the sampling rate of p in Hz.</p>
</td></tr>
<tr><td><code id="depth_rate_+3A_fc">fc</code></td>
<td>
<p>(optional) A smoothing filter cut-off frequency in Hz. If fc is not given, a default value is used of 0.2 Hz (5 second time constant).</p>
</td></tr>
<tr><td><code id="depth_rate_+3A_depth">depth</code></td>
<td>
<p>(optional) The behavior of animals. Required only if dealing with animals not behave descent but ascent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>v, The vertical velocity with the same sampling rate as p. v is a vector with the same dimensions as p. The unit of v depends on the unit of p. For example, if p is in meters, v is in meters/second
</p>


<h3>Note</h3>

<p>The low-pass filter is a symmetric FIR with length 4fs/fc. The group delay of the filters is removed. Usually, the function handles data pertaining to diving animals, where data is measured as the depth beneath the water surface. For ascending data coming from birds and alike data, setting depth = FALSE will help calculating the right vertical velocity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- depth_rate(p = beaked_whale$P)
plott_base(list(beaked_whale$P$data, v),
  fs = beaked_whale$P$sampling_rate,
  r = c(1, 0), panel_labels = c("Depth\n(m)", "Vertical Velocity\n(m/s)")
)
</code></pre>

<hr>
<h2 id='depth2pressure'>Convert depth to pressure</h2><span id='topic+depth2pressure'></span>

<h3>Description</h3>

<p>This function is used to convert the depth (in meters) to the pressure in Pascals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth2pressure(d, latitude)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="depth2pressure_+3A_d">d</code></td>
<td>
<p>The depth in meters</p>
</td></tr>
<tr><td><code id="depth2pressure_+3A_latitude">latitude</code></td>
<td>
<p>The latitude in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pressure in Pa
</p>


<h3>Note</h3>

<p>Based on the Leroy and Parthiot (1998) formula. See: http://resource.npl.co.uk/acoustics/techguides/soundseawater/content.html#UNESCO
</p>


<h3>Examples</h3>

<pre><code class='language-R'>depth2pressure(1000, 27)
</code></pre>

<hr>
<h2 id='detect_peaks'>Detect peaks in signal vector data</h2><span id='topic+detect_peaks'></span>

<h3>Description</h3>

<p>This function detects peaks in time series data that exceed a specified threshold and returns each peak's start time, end time, maximum peak value, time of the maximum peak value, threshold level, and blanking time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_peaks(
  data,
  sr,
  FUN = NULL,
  thresh = NULL,
  bktime = NULL,
  plot_peaks = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect_peaks_+3A_data">data</code></td>
<td>
<p>A vector (of all positive values) or matrix of data to be used in peak detection. If data is a matrix, you must specify a FUN to be applied to data.</p>
</td></tr>
<tr><td><code id="detect_peaks_+3A_sr">sr</code></td>
<td>
<p>The sampling rate in Hz of the date. This is the same as fs in other tagtools functions. This is used to calculate the bktime in the case that the input for bktime is missing.</p>
</td></tr>
<tr><td><code id="detect_peaks_+3A_fun">FUN</code></td>
<td>
<p>A function to be applied to data before the data is run through the peak detector. Only specify the function name (i.e. njerk). If left blank, the data input will be immediately passed through the peak detector.</p>
</td></tr>
<tr><td><code id="detect_peaks_+3A_thresh">thresh</code></td>
<td>
<p>The threshold level above which peaks in signal are detected. Inputs must be in the same units as the signal. If the input for thresh is missing/empty, the default level is the 0.99 quantile</p>
</td></tr>
<tr><td><code id="detect_peaks_+3A_bktime">bktime</code></td>
<td>
<p>The specified length of time (seconds) between signal values detected above the threshold value (from the moment the first peak recedes below the threshold level to the moment the second peak surpasses the threshold level) that is required for each value to be considered a separate and unique peak. If the input for bktime is missing/empty the default value for the blanking time is set as the .80 quantile of the vector of time differences for signal values above the specified threshold.</p>
</td></tr>
<tr><td><code id="detect_peaks_+3A_plot_peaks">plot_peaks</code></td>
<td>
<p>A conditional input. If the input is TRUE or missing, an interactive plot is generated, allowing the user to manipulate the thresh and bktime values and observe the changes in peak detection. If the input is FALSE, the interactive plot is not generated. Look to the console for help on how to use the plot upon running of this function.</p>
</td></tr>
<tr><td><code id="detect_peaks_+3A_quiet">quiet</code></td>
<td>
<p>If quiet is true, do not print to the screen</p>
</td></tr>
<tr><td><code id="detect_peaks_+3A_...">...</code></td>
<td>
<p>Additional inputs to be passed to FUN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the start times, end times, peak times, peak maxima, thresh, and bktime. All times are presented as the sampling value.
</p>


<h3>Note</h3>

<p>As specified above under the description for the input of plot_peaks, an interactive plot can be generated, allowing the user to manipulate the thresh and bktime values and observe the changes in peak detection. The plot output is only given if the input for plot_peaks is specified as true or if the input is left missing/empty.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BW &lt;- beaked_whale
detect_peaks(data = BW$A$data, sr = BW$A$sampling_rate, 
FUN = njerk, thresh = NULL, bktime = NULL, 
plot_peaks = NULL, sampling_rate = BW$A$sampling_rate, quiet=TRUE)

</code></pre>

<hr>
<h2 id='dive_stats'>Compute summary statistics for dives or flights</h2><span id='topic+dive_stats'></span>

<h3>Description</h3>

<p>Given a depth/altitude profile and a series of dive/flight start and end times,
compute summary dive statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dive_stats(
  P,
  X = NULL,
  dive_cues,
  sampling_rate = NULL,
  prop = 0.85,
  angular = FALSE,
  X_name = NULL,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dive_stats_+3A_p">P</code></td>
<td>
<p>Depth data. A vector (or one-column matrix), or a tag sensor data list.</p>
</td></tr>
<tr><td><code id="dive_stats_+3A_x">X</code></td>
<td>
<p>(optional) Another data stream (as a vector (or a one-column matrix) or a tag sensor data list) for which to compute mean and variability. If <code>angular</code> is TRUE, interpreted as angular data (for example pitch, roll, or heading) and means and variances are computed accordingly.
The unit of measure must be radians (NOT degrees). Currently, <code>X</code> must be regularly sampled.</p>
</td></tr>
<tr><td><code id="dive_stats_+3A_dive_cues">dive_cues</code></td>
<td>
<p>A two-column data frame or matrix with dive/flight start times in the first column and dive/flight end times in the second. May be obtained from <code><a href="#topic+find_dives">find_dives</a></code>. Units should be seconds since start of tag recording.</p>
</td></tr>
<tr><td><code id="dive_stats_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>(optional and ignored if <code>P</code> or <code>X</code> are tag sensor data lists) Sampling rate of <code>P</code> (and <code>X</code>, if <code>X</code> is given). If omitted, then input data must be sensor data lists. If one value is given and both <code>P</code> and <code>X</code> are input, they are assumed to have the same sampling rate. If <code>P</code> and <code>X</code> have different sampling rates, then this input can have two elements (first for <code>P</code>, second for <code>X</code>).</p>
</td></tr>
<tr><td><code id="dive_stats_+3A_prop">prop</code></td>
<td>
<p>The proportion of the maximal excursion to use for defining the &quot;destination&quot; phase of a dive or flight. For example, if <code>prop</code> is 0.85 (the default), then the destination phase lasts from the first to the last time depth/altitude exceeds 0.85 times the within-dive maximum.</p>
</td></tr>
<tr><td><code id="dive_stats_+3A_angular">angular</code></td>
<td>
<p>Is X angular data? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="dive_stats_+3A_x_name">X_name</code></td>
<td>
<p>A short name to use for X variable in the output data frame. For example, if X is pitch data, use X_name='pitch' to get outputs column names like mean_pitch, etc. Defaults to 'angle' for angular data and 'aux' for non-angular data.</p>
</td></tr>
<tr><td><code id="dive_stats_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, default is TRUE. If TRUE, then returned mean values ignore missing values, computing an average over all non-missing observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the maximum excursion and duration, <code>dive_stats</code> divides each excursion into three phases:
&quot;to&quot; (descent for dives, ascent for flights), &quot;from&quot; (ascent for dives, descent for flights), and &quot;destination&quot;.
The &quot;destination&quot; (bottom for dives and top for flights)
phase of the excursion is identified using a &quot;proportion of maximum depth/altitude&quot; method,
whereby for example the bottom phase of a dive lasts from the first to the last time the depth exceeds a stated proportion of the maximum depth.
Average vertical velocity is computed for the to and from phases using a simple method: total depth/altitude change divided by total time.
If an angular data variable is also supplied (for example, pitch, roll or heading),
then the circular mean (computed via <code><a href="CircStats.html#topic+circ.mean">circ.mean</a></code>) and variance (computed via <code><a href="CircStats.html#topic+circ.disp">circ.disp</a></code> and reporting the <code>var</code> output)
are also computed for each dive phase and the dive as a whole.
</p>


<h3>Value</h3>

<p>A data frame with one row for each dive/flight and columns as detailed below. All times are in seconds, and rates in units of x/sec where x is the units of <code>P</code>.
</p>

<ul>
<li> <p><code>max</code>  The maximum depth or altitude
</p>
</li>
<li> <p><code>st</code> start time of dive (seconds) - from input dive_cues
</p>
</li>
<li> <p><code>et</code> end time of dive (seconds) - from input dive_cues
</p>
</li>
<li> <p><code>dur</code>  The duration of the excursion
</p>
</li>
<li> <p><code>dest_st</code>  The start time of the destination phase in seconds since start of tag recording (which is also the end time of to phase)
</p>
</li>
<li> <p><code>dest_et</code>  The end time of the destination phase in seconds since start of tag recording (which is also the start of the from phase).
</p>
</li>
<li> <p><code>dest_dur</code>  The duration in seconds of destination phase
</p>
</li>
<li> <p><code>to_dur</code>  The duration in seconds of to phase
</p>
</li>
<li> <p><code>from_dur</code>  The duration in seconds of from phase
</p>
</li>
<li> <p><code>mean_angle</code>  If angular=TRUE and X is input, the mean angle for the entire excursion. Values for each phase are also provided in columns <code>mean_to_angle</code>, <code>mean_dest_angle</code>, and <code>mean_from_angle</code>.
</p>
</li>
<li> <p><code>angle_var</code>  If angular=TRUE and X is input, the angular variance for the entire excursion. Values for each phase are also provided individually in columns <code>to_angle_var</code>, <code>dest_angle_var</code>, and <code>from_angle_var</code>.
</p>
</li>
<li> <p><code>mean_aux</code>  If angular=FALSE and X is input, the mean value of X for the entire excursion. Values for each phase are also provided in columns <code>mean_to_aux</code>, <code>mean_dest_aux</code>, and <code>mean_from_aux</code>.
</p>
</li>
<li> <p><code>aux_sd</code>  If angular=FALSE and X is input, the standard deviation of X for the entire excursion. Values for each phase are also provided individually in columns <code>to_aux_sd</code>, <code>dest_aux_sd</code>, and <code>from_aux_sd</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+find_dives">find_dives</a></code>
</p>

<hr>
<h2 id='draw_axis'>Draw time axis on plott plot.</h2><span id='topic+draw_axis'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+plott">plott</a></code> to add a time axis to a plot created by <code><a href="#topic+plott">plott</a></code>. Users are unlikely to need to call the function directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_axis(side = 1, x = NULL, date_time, last_panel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_axis_+3A_side">side</code></td>
<td>
<p>see <code><a href="graphics.html#topic+axis">axis</a></code>.</p>
</td></tr>
<tr><td><code id="draw_axis_+3A_x">x</code></td>
<td>
<p>A date-time or date object, or other types of objects that can be converted appropriately.</p>
</td></tr>
<tr><td><code id="draw_axis_+3A_date_time">date_time</code></td>
<td>
<p>Logical. Is the data being plotted date-time (POSIX) or time in seconds?</p>
</td></tr>
<tr><td><code id="draw_axis_+3A_last_panel">last_panel</code></td>
<td>
<p>Logical. Is this the last panel (in other words, should x axis tick labels be drawn)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a time axis on a graph
</p>

<hr>
<h2 id='dsf'>Estimate the dominant stroke frequency</h2><span id='topic+dsf'></span>

<h3>Description</h3>

<p>This function can be used to estimate the dominant stroke frequency from triaxial accelerometer data [ax,ay,az].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsf(A, sampling_rate = NULL, fc = NULL, Nfft = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsf_+3A_a">A</code></td>
<td>
<p>A sensor data list or an nx3 acceleration matrix with columns [ax ay az]. Acceleration can be in any consistent unit, e.g., g or m/s^2.</p>
</td></tr>
<tr><td><code id="dsf_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate of the sensor data in Hz (samples per second).</p>
</td></tr>
<tr><td><code id="dsf_+3A_fc">fc</code></td>
<td>
<p>(optional) The cut-off frequency in Hz of a low-pass filter to apply to A before computing the spectra. This prevents high frequency transients e.g., in foraging, from dominating the spectra. The filter  length is 6*sampling_rate/fc. If fc is not specified, it defaults to 2.5 Hz. If fc&gt;sampling_rate/2, the filtering operation is skipped.</p>
</td></tr>
<tr><td><code id="dsf_+3A_nfft">Nfft</code></td>
<td>
<p>(optional) The FFT length and therefore the frequency resolution. The default value is the power of two closest to 20*sampling_rate, i.e., an analysis block length of about 20 s and a frequency resolution of about 0.05 Hz. A shorter FFT may be required if movement behaviour is very variable. A longer FFT may work well if propulsion is continuous and stereotyped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Animals tend to produce propulsive movements with a narrow frequency range. These movements cause cyclical changes in posture and/or specific acceleration, both of which are measured by an animal-attached accelerometer. Thus sections of accelerometer data that largely contain propulsion should show a spectral peak in one or more axes at the dominant stroke frequency.
</p>


<h3>Value</h3>

<p>A list with 2 elements:
</p>

<ul>
<li><p><strong>fpk: </strong>The dominant stroke frequency (i.e., the peak frequency in the sum of the acceleration power spectra) in Hz. Quadratic interpolation is used over the spectral peak to improve resolution.
</p>
</li>
<li><p><strong>q: </strong> The quality of the peak measured by the peak power divided by the mean power of the spectra. This is a dimensionless number which is large if there is a clear spectral peak.
</p>
</li></ul>



<h3>Note</h3>

<p>Frame: This function makes no assumption about accelerometer frame. Data in any frame can be used.
</p>
<p>Data selection: This function works best if the sensor matrix, A, covers an interval in which propulsion is the main activity. This could be a complete dive or an interval of running or flapping flight. The interval length should be at least Nfft/sampling_rate seconds, i.e., 20 s for the default FFT length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dsf(harbor_seal$A)

</code></pre>

<hr>
<h2 id='euler2rotmat'>Make a rotation (or direction cosine) matrix</h2><span id='topic+euler2rotmat'></span>

<h3>Description</h3>

<p>This function is used to make a rotation (or direction cosine) matrix out of sets of Euler angles, pitch, roll, and heading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler2rotmat(p, r, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euler2rotmat_+3A_p">p</code></td>
<td>
<p>The pitch angle in radians.</p>
</td></tr>
<tr><td><code id="euler2rotmat_+3A_r">r</code></td>
<td>
<p>The roll angle in radians.</p>
</td></tr>
<tr><td><code id="euler2rotmat_+3A_h">h</code></td>
<td>
<p>The heading or yaw angle in radians.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One or more 3x3 rotation matrices. If p, r, and h are all scalars, Q is a 3x3 matrix, Q = H 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec1 &lt;- matrix(c(1:10), nrow = 10)
vec2 &lt;- matrix(c(11:20), nrow = 10)
vec3 &lt;- matrix(c(21:30), nrow = 10)
Q &lt;- euler2rotmat(p = vec1, r = vec2, h = vec3)
</code></pre>

<hr>
<h2 id='extract'>Extract a sub-sample of data</h2><span id='topic+extract'></span>

<h3>Description</h3>

<p>This function is used to extract a sub-sample of data from a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract(x, sampling_rate, tst, ted)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_+3A_x">x</code></td>
<td>
<p>A vector or matrix of measurements. If x is a matrix, each column is treated as a separate measurement vector.</p>
</td></tr>
<tr><td><code id="extract_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>the sampling rate in Hz of the data in x.</p>
</td></tr>
<tr><td><code id="extract_+3A_tst">tst</code></td>
<td>
<p>Defines the start time in seconds of the interval to be extracted from x.</p>
</td></tr>
<tr><td><code id="extract_+3A_ted">ted</code></td>
<td>
<p>Defines the end time in seconds of the interval to be extracted from x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>X: </strong> A matrix containing a sub-sample of x. X has the same number of columns as x. The length of the sub-sample will be round(sampling_rate*(tend-tstart)) samples.
</p>


<h3>Note</h3>

<p>Output sampling rate is the same as the input sampling rate.
</p>
<p>If either tst or ted are beyond the length of x, non-existing samples will be replaced with NaN in X.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BW &lt;- beaked_whale
BW_subset &lt;- extract(x = BW$A$data, sampling_rate = BW$A$sampling_rate, tst = 3, ted = 100)
</code></pre>

<hr>
<h2 id='extract_cues'>Extract multiple sub-samples of data</h2><span id='topic+extract_cues'></span>

<h3>Description</h3>

<p>This function is used to extract multiple sub-samples of data from a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_cues(x, sampling_rate, cues, len)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_cues_+3A_x">x</code></td>
<td>
<p>is a vector or matrix of measurements. If x is a matrix, each column is treated as a separate measurement vector.</p>
</td></tr>
<tr><td><code id="extract_cues_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>is the sampling rate in Hz of the data in x.</p>
</td></tr>
<tr><td><code id="extract_cues_+3A_cues">cues</code></td>
<td>
<p>defines the start time in seconds of the intervals to be extracted from x.</p>
</td></tr>
<tr><td><code id="extract_cues_+3A_len">len</code></td>
<td>
<p>is the length of the interval to extract in seconds. This should be a scalar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 elements:
</p>

<ul>
<li><p><strong>X: </strong> A matrix containing sub-samples of x. If x is a vector, X has as many columns as there are cues, i.e., each cue generates a column of X. If x is a pxm matrix, X will be a qxmxn matrix where n is the size of cues and q is the length of the interval requested, i.e., round(sampling_rate*len) samples.
</p>
</li>
<li><p><strong>cues: </strong> The list of cues actually used. cues that require data outside of x are rejected.
</p>
</li></ul>



<h3>Note</h3>

<p>Output sampling rate is the same as the input sampling rate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BW &lt;- beaked_whale # beaked_whale must be in your working directory
list &lt;- extract_cues(x = BW$A$data, sampling_rate = BW$A$sampling_rate, cues = c(6, 40), len = 11)
</code></pre>

<hr>
<h2 id='find_dives'>Find time cues for dives</h2><span id='topic+find_dives'></span>

<h3>Description</h3>

<p>This function is used to find the time cues for the start and end of either dives in a depth record or flights in an altitude record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_dives(p, mindepth, sampling_rate = NULL, surface = 1, findall = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_dives_+3A_p">p</code></td>
<td>
<p>A depth or altitude time series (a sensor data list or  a vector) in meters.</p>
</td></tr>
<tr><td><code id="find_dives_+3A_mindepth">mindepth</code></td>
<td>
<p>The threshold in meters at which to recognize a dive or flight. Dives shallow or flights lower than mindepth will be ignored.</p>
</td></tr>
<tr><td><code id="find_dives_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate of the sensor data in Hz (samples per second).</p>
</td></tr>
<tr><td><code id="find_dives_+3A_surface">surface</code></td>
<td>
<p>(optional) The threshold in meters at which the animal is presumed to have reached the surface. Default value is 1. A smaller value can be used if the dive/altitude data are very accurate and you need to detect shallow dives/flights.</p>
</td></tr>
<tr><td><code id="find_dives_+3A_findall">findall</code></td>
<td>
<p>(optional) When TRUE, forces the algorithm to include incomplete dives at the start and end of the record. Default is FALSE which only recognizes complete dives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dives is a data frame with one row for each dive/flight found. The columns of dives are: start (time in seconds of the start of each dive/flight), end (time in seconds of the start of each dive/flight), max (maximum depth/altitude reached in each dive/flight), tmax	(time in seconds at which the animal reaches the max depth/altitude).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BW &lt;- beaked_whale
dives &lt;- find_dives(p = BW$P$data, 
sampling_rate = BW$P$sampling_rate, 
mindepth = 25, surface = 5, 
findall = FALSE)
</code></pre>

<hr>
<h2 id='fir_nodelay'>Delay-free filtering</h2><span id='topic+fir_nodelay'></span>

<h3>Description</h3>

<p>This function is used to gather a delay-free filtering using a linear-phase (symmetric) FIR filter followed by group delay correction. Delay-free filtering is needed when the relative timing between signals is important e.g., when integrating signals that have been sampled at different rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fir_nodelay(x, n, fc, qual = "low", return_coefs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fir_nodelay_+3A_x">x</code></td>
<td>
<p>The signal to be filtered. It can be multi-channel with a signal in each column, e.g., an acceleration matrix. The number of samples (i.e., the number of rows in x) must be larger than the filter length, n.</p>
</td></tr>
<tr><td><code id="fir_nodelay_+3A_n">n</code></td>
<td>
<p>The length of symmetric FIR filter to use in units of input samples (i.e., samples of x). The length should be at least 4/fc. A longer filter gives a steeper cut-off.</p>
</td></tr>
<tr><td><code id="fir_nodelay_+3A_fc">fc</code></td>
<td>
<p>The filter cut-off frequency relative to sampling_rate/2=1. If a single number is given, the filter is a low-pass or high-pass. If fc is a vector with two numbers, the filter is a bandpass filter with lower and upper cut-off frequencies given by fc(1) and fc(2). For a bandpass filter, n should be at least 4/fc(1) or 4/diff(fc) whichever is larger.</p>
</td></tr>
<tr><td><code id="fir_nodelay_+3A_qual">qual</code></td>
<td>
<p>An optional qualifier determining if the filter is: &quot;low&quot; for low-pass (the default value if fc has a single number), or &quot;high&quot; for high-pass. Default is &quot;low&quot;.</p>
</td></tr>
<tr><td><code id="fir_nodelay_+3A_return_coefs">return_coefs</code></td>
<td>
<p>Logical. Return filter coefficients instead of filtered signal? If TRUE, the function will return the FIR filter coefficients instead of the filtered signal. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If return_coefs is FALSE (the default), <code>fir_nodelay()</code> returns the filtered signal (same size as x). If return_coefs is TRUE, returns the vector of filter coefficients only.
</p>


<h3>Note</h3>

<p>The filter is generated by a call to <code><a href="signal.html#topic+fir1">fir1</a></code>: <code>h &lt;- fir1(n, fc, qual)</code>.
</p>
<p>h is always an odd length filter even if n is even. This is needed to ensure that the filter is both symmetric and has a group delay which is an integer number of samples.
</p>
<p>The filter has a support of n samples, i.e., it uses n samples from x to compute each sample in y.
</p>
<p>The input samples used are those from n/2 samples before to n/2 samples after the sample number being computed. This means that samples at the start and end of the output vector y need input samples before the start of x and after the end of x. These are faked by reversing the first n/2 samples of x and concatenating them to the start of x. The same trick is used at the end of x. As a result, the first and last n/2 samples in y are untrustworthy. This initial condition problem is true for any filter but the FIR filter used here makes it easy to identify precisely which samples are unreliable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sin(t(2 * pi * 0.05 * (1:100)) +
  t(cos(2 * pi * 0.25 * (1:100))))
Y &lt;- fir_nodelay(x = x, n = 30, fc = 0.2, qual = "low")
plot(c(1:length(x)), x,
  type = "l", col = "grey42",
  xlab = "index", ylab = "input x and output y"
)
lines(c(1:length(Y)), Y, lwd = 2)

</code></pre>

<hr>
<h2 id='fit_tracks'>Integrate track with reference positions</h2><span id='topic+fit_tracks'></span>

<h3>Description</h3>

<p>Simple track integration method to merge infrequent
but accurate positions with a regularly sampled track
that is not absolutely accurate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_tracks(P, times = NULL, D, sampling_rate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_tracks_+3A_p">P</code></td>
<td>
<p>a two column matrix or data frame containing the anchor positions. The first column should be the &quot;northing&quot; and the second the &quot;easting&quot; coordinates. (If data frame is input, then columns with those two names, in any position, will be used if present).</p>
</td></tr>
<tr><td><code id="fit_tracks_+3A_times">times</code></td>
<td>
<p>a vector of times corresponding to the positions P. If P is a data frame with a column called &quot;times&quot; then that column will be used.
Times are in seconds since the start of the regularly sampled track.
times must have the same number of rows as P. Times
must be greater than or equal to 0 and less than the time length of the regularly sampled track.</p>
</td></tr>
<tr><td><code id="fit_tracks_+3A_d">D</code></td>
<td>
<p>a two column matrix containing the regularly sampled track
points. If D is a data frame with columns named 'northing' and 'easting' those will be used regardless of position; otherwise the first column will be northing and the second easting. The two columns contain the 'x' and 'y' coordinates of the
track points in a local level frame. Units, axes and frame must match those of P.</p>
</td></tr>
<tr><td><code id="fit_tracks_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>is the sampling rate in Hz of D.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>D, a data frame with 4 columns: &quot;northing&quot; and &quot;easting&quot; along the new track,
and &quot;current_n&quot; and &quot;current_e&quot;, the track increments needed to match the tracks.
If the difference between the two tracks is due to the medium moving,
these increments can be considered an estimate of the current in m/s.
The axes and frame are the same as for the input data.
</p>

<hr>
<h2 id='fix_offset_3d'>Estimate the offset in each axis</h2><span id='topic+fix_offset_3d'></span>

<h3>Description</h3>

<p>This function is used to estimate the offset in each axis of a triaxial field measurement, e.g., from an accelerometer or magnetometer. This is useful for correcting drift or calibration errors in a sensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_offset_3d(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_offset_3d_+3A_x">X</code></td>
<td>
<p>A sensor list or matrix containing measurements from a triaxial field sensor such as an accelerometer of magnetometer. X can be in any units and frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 elements:
</p>

<ul>
<li><p><strong>X: </strong> A sensor list or matrix containing the adjusted triaxial sensor measurements. It is the same size and has the same sampling rate and units as the input data. If the input is a sensor list, the output will also.
</p>
</li>
<li><p><strong>G: </strong> A calibration list containing one field: G$poly. The first column of G$poly contains 1 as this function does not adjust the scale factor of X. The second column of G$poly is the offset added to each column of X.
</p>
</li></ul>



<h3>Note</h3>

<p>This function is only usable for field sensors. It will not work for gyroscope data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- fix_offset_3d(harbor_seal$A)

</code></pre>

<hr>
<h2 id='fix_pressure'>Correct a depth or altitude profile</h2><span id='topic+fix_pressure'></span>

<h3>Description</h3>

<p>This function is used to correct a depth or altitude profile for offsets caused by miscalibration and temperature. This function finds minima in the dive/altitude profile that are consistent with surfacing/landing. It uses the depth/height at these points to fit a temperature regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_pressure(p, t, sampling_rate, maxp = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_pressure_+3A_p">p</code></td>
<td>
<p>A sensor list or vector of depth/altitude in meters</p>
</td></tr>
<tr><td><code id="fix_pressure_+3A_t">t</code></td>
<td>
<p>A sensor list or vector of temperature in degrees Celsius</p>
</td></tr>
<tr><td><code id="fix_pressure_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling_rate of p and t in Hz. This is only needed if p and t are not sensor lists. The depth and temperature must both have the same sampling rate (use 'decdc' if needed to achieve this).</p>
</td></tr>
<tr><td><code id="fix_pressure_+3A_maxp">maxp</code></td>
<td>
<p>The maximum depth or altitude reading in the pressure data for which the animal could actually be at the surface. This is a rough measurement of the potential error in the pressure data. The unit is meters. Start with a small value, e.g., 2m and rerun fix_pressure with a larger value if there are still obvious temperature-related errors in the resulting depth/altitude profile.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 elements:
</p>

<ul>
<li><p><strong>p: </strong> A sensor list or vector of corrected depth/altitude measurements at the same sampling rate as the input data. If the input is a sensor list, the output will also be.
</p>
</li>
<li><p><strong>pc: </strong> A list containing the pressure offset and temperature correction coefficients. It has fields: pc$tref which is the temperature compensation polynomial. This is used within the function to correct pressure as follows: p + stats::polyval(pc$tcomp, t - pc$tref).
</p>
</li></ul>



<h3>Note</h3>

<p>This function makes a number of assumptions about the depth/altitude data and about the behaviour of animals: First, the depth data should have few incorrect outlier (negative) values that fall well beyond the surface. These can be reduced using median_filter.m before calling fix_depth. Second, the animal is assumed to be near the surface at least 2
</p>

<hr>
<h2 id='get_researcher'>Find matching researcher in a list of known tag researchers</h2><span id='topic+get_researcher'></span>

<h3>Description</h3>

<p>Find matching researcher in a list of known tag researchers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_researcher(initial)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_researcher_+3A_initial">initial</code></td>
<td>
<p>a two-letter code for the researcher of interest (first letter of first name and first letter of last name)</p>
</td></tr>
</table>

<hr>
<h2 id='get_species'>Find matching species in a list of marine mammals</h2><span id='topic+get_species'></span>

<h3>Description</h3>

<p>Find matching species in a list of marine mammals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_species(initial)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_species_+3A_initial">initial</code></td>
<td>
<p>a two-letter code for the species of interest (first letter of Genus and first letter of species)</p>
</td></tr>
</table>

<hr>
<h2 id='harbor_seal'>Set of sensor lists for a harbor seal</h2><span id='topic+harbor_seal'></span>

<h3>Description</h3>

<p>Data is from a _Phoca vitulina_ with tag ID 'hs16_265c'. The device used was a DTAG4 and it was deployed at 2016-09-21 07:55:22 in Husum, Germany.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harbor_seal
</code></pre>


<h3>Format</h3>

<p>A set of sensor lists:
</p>

<dl>
<dt>A</dt><dd><p>sensor list containing a triaxial acceleration matrix sampled at 5 Hz</p>
</dd>
<dt>M</dt><dd><p>sensor list containing a triaxial magnetometer matrix sampled at 5 Hz</p>
</dd>
<dt>P</dt><dd><p>sensor list containing a pressure (depth) vector sampled at 5 Hz</p>
</dd>
<dt>POS</dt><dd><p>sensor list containing a position matrix with columns [sampling time, latitude, longitude]</p>
</dd>
</dl>


<hr>
<h2 id='hilbert_env'>Compute the envelope of X using Hilbert transform.
Compute the envelope of the signal matrix X using the Hilbert transform. 
To avoid long transforms, this function uses the overlap and add method.</h2><span id='topic+hilbert_env'></span>

<h3>Description</h3>

<p>Compute the envelope of X using Hilbert transform.
</p>
<p>Compute the envelope of the signal matrix X using the Hilbert transform. 
To avoid long transforms, this function uses the overlap and add method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert_env(X, N = 1024)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hilbert_env_+3A_x">X</code></td>
<td>
<p>a vector or matrix of signals. If X is a matrix, each column is treated as a separate signal.
The signals must be regularly sampled for the result to be correctly interpretable as the envelope.</p>
</td></tr>
<tr><td><code id="hilbert_env_+3A_n">N</code></td>
<td>
<p>(optional) specifies the transform length used. 
The default value is 1024 and this may be fine for most situations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>E, the envelope of X. E is the same size as X: it has the same number of columns 
and the same number of samples per signal. It has the same units as
X but being an envelope, all values are &gt;=0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- matrix(sin(0.1 * c(1:10000)), ncol = 1) *
 matrix(sin(0.001 * c(1:10000)), ncol = 1)
E &lt;- hilbert_env(s)
plot(c(1:length(s)), s, col = 'grey34')
lines(c(1:length(E)), E, col = 'black')

</code></pre>

<hr>
<h2 id='hilbert_transform'>Return the Hilbert transform of a signal</h2><span id='topic+hilbert_transform'></span>

<h3>Description</h3>

<p>This function is used to compute the Hilbert transform of a signal. It is based on function HilbertTransform() from (defunct) package hht, which was modified from the EMD package by Donghoh Kim and Hee-Seok Oh (http://dasan.sejong.ac.kr/~dhkim/software.emd.html)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert_transform(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hilbert_transform_+3A_x">x</code></td>
<td>
<p>The signal vector to be buffered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The &quot;analytic signal,&quot; in other words the Hilbert transform of the input signal x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timez &lt;- seq(from = 0, by = 1/1024, to = 1)
x &lt;- sin(2*pi*60*timez)
y &lt;- hilbert_transform(x)
</code></pre>

<hr>
<h2 id='htrack'>Simple horizontal dead-reckoned track</h2><span id='topic+htrack'></span>

<h3>Description</h3>

<p>This function is used to estimate the simple horizontal dead-reckoned track (pseudo-track) based on speed and heading. This differs from ptrack in that the animals body angle is not considered. This makes it appropriate for animals that do not always move in the direction of their longitudinal axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htrack(A, M, s, sampling_rate = NULL, fc = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="htrack_+3A_a">A</code></td>
<td>
<p>The nx3 acceleration matrix with columns [ax ay az] or acceleration sensor list. Acceleration can be in any consistent unit, e.g., g or m/s^2.</p>
</td></tr>
<tr><td><code id="htrack_+3A_m">M</code></td>
<td>
<p>The magnetometer signal matrix, M = [mx,my,mz] in any consistent unit (e.g., in uT or Gauss) or magnetometer sensor list. A and M must have the same size (and so are both measured at the same sampling rate).</p>
</td></tr>
<tr><td><code id="htrack_+3A_s">s</code></td>
<td>
<p>The forward speed of the animal in m/s. s can be a single number meaning that the animal is assumed to travel at a constant speed. s can also be a vector with the same number of rows as M, e.g., generated by <code><a href="#topic+ocdr">ocdr</a></code>.</p>
</td></tr>
<tr><td><code id="htrack_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate of the sensor data in Hz (samples per second).</p>
</td></tr>
<tr><td><code id="htrack_+3A_fc">fc</code></td>
<td>
<p>(optional) Specifies the cut-off frequency of a low-pass filter to apply to A and M before computing heading. The filter cut-off frequency is in Hz. The filter length is 4*sampling_rate/fc. Filtering adds no group delay. If fc is empty or not given, the default value of 0.2 Hz (i.e., a 5 second time constant) is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame track containing the estimated track in a local level frame. The track is defined as meters of northward and eastward movement (termed 'northing' and 'easting', i.e, columns of track are <code>northing</code> and <code>easting</code> relative to the animal's position at the start of the measurements (which is defined as [0,0]). The track sampling rate is the same as for the input data and so each row of track defines the track coordinates at times 0,1/sampling_rate,2/sampling_rate,... relative to the start time of the measurements.
</p>


<h3>Note</h3>

<p>Frame: This function assumes a [north,east,up] navigation frame and a [forward,right,up] local frame. Both A and M must be rotated if needed to match the animal's cardinal axes otherwise the track will not be meaningful. Unless the local declination angle is also corrected with rotframe, the dead-reckoned track will use magnetic north rather than true north.
</p>
<p>CAUTION: dead-reckoned tracks are usually very inaccurate. 
They are useful to get an idea of HOW animals move rather than WHERE they go. Few animals probably travel in exactly the direction of their longitudinal axis. Additionally, measuring the precise orientation of the longitudinal axis of a non-rigid animal is fraught with error. 
Moreover, if there is net flow in the medium, the animal will be advected by the flow in addition to its autonomous movement. For swimming animals this can lead to substantial errors. The forward speed is assumed to be with respect to the medium so the track derived here is NOT the 'track-made-good', i.e., the geographic movement of the animal. It estimates the movement of the animal with respect to the medium. 
There are numerous other sources of error so use at your own risk!
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptrack">ptrack</a></code>, <code><a href="#topic+fit_tracks">fit_tracks</a></code>, <code><a href="#topic+track3D">track3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bwhtrack &lt;- htrack(A = beaked_whale$A, M = beaked_whale$M, s = 4)
plot(bwhtrack$easting, bwhtrack$northing, xlab = "Easting, m", ylab = "Northing, m")

</code></pre>

<hr>
<h2 id='image_irreg'>Plot an image with an irregular grid.</h2><span id='topic+image_irreg'></span>

<h3>Description</h3>

<p>This function is used to plot an image with an irregular grid. This is useful for plotting matrix data (i.e., sampled data that is a function of two parameters) in which one or both of the sampling schemes is not regularly spaced. image_irreg plots R(i,j) as a coloured patch centered on x(i), y(j) and with dimension determined by x[i] - x[i-1] and y[i] - y[i-1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_irreg(x, y, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_irreg_+3A_x">x</code></td>
<td>
<p>is a vector with the horizontal axis coordinates of each value in R.</p>
</td></tr>
<tr><td><code id="image_irreg_+3A_y">y</code></td>
<td>
<p>is a vector with the vertical axis coordinates of each value in R.</p>
</td></tr>
<tr><td><code id="image_irreg_+3A_r">R</code></td>
<td>
<p>is a matrix of measurements to display. The values in R are converted to colours in the current colormap and caxis. R must be length(x) by length(y). Use NaN to have a patch not display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image plot on an irregular grid
</p>

<hr>
<h2 id='inclination'>Estimate the inclination angle</h2><span id='topic+inclination'></span>

<h3>Description</h3>

<p>This function is used to estimate the local magnetic field vector inclination angle directly from acceleration and magnetic field measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inclination(A, M, fc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inclination_+3A_a">A</code></td>
<td>
<p>The accelerometer data structure or signal matrix, A = [ax,ay,az] in any consistent unit (e.g., in g or m/s2). A can be in any frame.</p>
</td></tr>
<tr><td><code id="inclination_+3A_m">M</code></td>
<td>
<p>The magnetometer data structure or signal matrix, M = [mx,my,mz] in any consistent unit (e.g., in uT or Gauss). M must be in the same frame as A.</p>
</td></tr>
<tr><td><code id="inclination_+3A_fc">fc</code></td>
<td>
<p>(optional) The cut-off frequency of a low-pass filter to apply to A and M before computing the inclination angle. The filter cut-off frequency is with respect to 1=Nyquist frequency. Filtering adds no group delay. If fc is not specified, no filtering is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The magnetic field inclination angle in radians.
</p>


<h3>Note</h3>

<p>Output sampling rate is the same as the input sampling rate.
</p>
<p>Frame: This function assumes a [north,east,up] navigation frame and a [forward,right,up] local frame. In these frames, the magnetic field vector has a positive inclination angle when it points below the horizon. Other frames can be used as long as A and M are in the same frame however the interpretation of incl will differ accordingly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1, -0.5, 0.1, 0.8, -0.2, 0.6, 0.5, -0.9, -0.7),
  byrow = TRUE, nrow = 3, ncol = 3
)
M &lt;- matrix(c(1.3, -0.25, 0.16, 0.78, -0.3, 0.5, 0.5, -0.49, -0.6),
  byrow = TRUE, nrow = 3, ncol = 3
)
incl &lt;- inclination(A, M)

</code></pre>

<hr>
<h2 id='interp_nan'>Remove NAs from sensor data and return indices of (rows of) filled values</h2><span id='topic+interp_nan'></span>

<h3>Description</h3>

<p>This is an internal function used by <code><a href="#topic+htrack">htrack</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp_nan(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp_nan_+3A_data">data</code></td>
<td>
<p>a data vector or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries <code>data</code> (the input data with NAs filled in) and <code>k</code> a logical vector indicating the position (if data was a vector) or rows (if data was a matrix) where NAs were filled in. Internal NAs are filled via linear interoplation, while leading and trailing ones are filled using the first following or last preceding good value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(NA, NA, 3, 4, 5, 6, 7, 8, 9, 10, NA, NA, 13, 14, 15, 16, NA, NA), ncol = 2)
result &lt;- interp_nan(A)

</code></pre>

<hr>
<h2 id='interp2length'>Interpolate regularly sampled data to increase its sampling rate and match its length to another variable.</h2><span id='topic+interp2length'></span>

<h3>Description</h3>

<p>This function is used to reduce the time span of data by cropping out any data that falls before and after two time cues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp2length(X, Z, fs_in = NULL, fs_out = NULL, n_out = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp2length_+3A_x">X</code></td>
<td>
<p>A sensor list, vector, or matrix. If x is or contains  matrix, each column is treated as an independent signal.</p>
</td></tr>
<tr><td><code id="interp2length_+3A_z">Z</code></td>
<td>
<p>is a sensor structure, vector or matrix whose sampling rate and length is to be matched.</p>
</td></tr>
<tr><td><code id="interp2length_+3A_fs_in">fs_in</code></td>
<td>
<p>is the sampling rate in Hz of the data in X. This is only needed if X is not a sensor structure.</p>
</td></tr>
<tr><td><code id="interp2length_+3A_fs_out">fs_out</code></td>
<td>
<p>is the required new sampling rate in Hz. This is only needed if Z is not given.</p>
</td></tr>
<tr><td><code id="interp2length_+3A_n_out">n_out</code></td>
<td>
<p>is an optional length for the output data. If n_out is not given, the output data length will be the input data length * fs_out/fs_in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Y is a sensor structure, vector or matrix of interpolated data with the same number of columns as X.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>         plott_base(X = list(harbor_seal$P), fsx = 5)
         P_dec &lt;- decdc(harbor_seal$P, 5)
         P_interp &lt;- interp2length(X = P_dec, Z = harbor_seal$A)
         plott_base(X = list(P_interp$data), fsx = 1)
</code></pre>

<hr>
<h2 id='inv_axis'>Identify invariant axis in triaxial movement measurements.</h2><span id='topic+inv_axis'></span>

<h3>Description</h3>

<p>This function processes tri-axial movement data (for example, from an accelerometer, magentometer or gyroscope) to identify the one axis that varies the least, i.e., the invariant axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_axis(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv_axis_+3A_data">data</code></td>
<td>
<p>The triaxial sensor measurement axis e.g., from on accelerometer or magnetometer. The frame and unit of A do not matter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rotational and linear movement in some types of propulsion largely occur in 2 dimensions e.g., body rotation in cetacean caudal propulsion occurs around the animal's transverse axis. Likewise sychronized wing flaps in flight or pectoral swimming may generate acceleration in the longitudinal and dorso-ventral axes but much less in the transverse axis. This function identifies the direction of the axis that moves the least in a movement matrix.
</p>


<h3>Value</h3>

<p>A list with two entries:
</p>

<ul>
<li><p><code>V </code> A 3x1 numeric vector defining the least varying axis in <code>data</code>. This vector is a direction vector so has a magnitude of 1 and is unit-less. The vector is defined in the same frame as A, so the first, second, and third entries correspond to the first, second and third columns of the data matrix, and axis orientation conventions are preserved.
</p>
</li>
<li><p><code>q </code> The proportion of movement in the invariant axis. A small number (e.g., less than 0.05) implies that very little movement occurs in this axis and so the movement is largely planar (i.e., two-dimensional). If the fraction is much larger than 0.05, the motion in A is better described as three-dimensional. <code>q</code> is a proportion and so it is unitless.
</p>
</li></ul>



<h3>Note</h3>

<p>This function returns one invariant axis that applies to the entire input signal so it is important to choose a relevant sub-sample of movement data, A, to analyse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> s &lt;- matrix(sin( 2 * pi * 0.1 * c(1:100)), ncol=1)
 A &lt;- s %*% c(0.9, -0.4, 0.3) + s^2 %*% c(0, 0.2, 0.1)
 inv_axis_out &lt;- inv_axis(A)
 
</code></pre>

<hr>
<h2 id='julian_day'>Convert between dates and Julian day numbers.</h2><span id='topic+julian_day'></span>

<h3>Description</h3>

<p>This function is used to convert between dates and Julian day numbers. 
There are three different input arrangements, each of which returns a different output. For a description of the different input arrangements, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>julian_day(y = NULL, m = NULL, d = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="julian_day_+3A_y">y</code></td>
<td>
<p>A single year or vector of years</p>
</td></tr>
<tr><td><code id="julian_day_+3A_m">m</code></td>
<td>
<p>A single month or vector of months</p>
</td></tr>
<tr><td><code id="julian_day_+3A_d">d</code></td>
<td>
<p>A single day or vector of days</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible input combinations: 
(n &lt;- julian_day()) returns the Julian day number for today. 
(n = julian_day(y,d)) where y is a single year or a vector of years and d is a single day number or a vector of daynumbers, 
returns the date vector [year,month,day] for each year, day pair. 
(n = julian_day(y,m,d)) where y is a single year or a vector of years, m is a single month or vector of months, and d is a single month day or a vector of month days, 
returns the Julian day number for each year, month, day.
</p>


<h3>Value</h3>

<p>See the description section for details on the return.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>julian_day(y = 2016, d = 12, m = 10)
julian_day(y = 2016, 286)
</code></pre>

<hr>
<h2 id='lalo2llf'>Convert latitude-longitude track points into a local level frame</h2><span id='topic+lalo2llf'></span>

<h3>Description</h3>

<p>Convert latitude-longitude track points into a local level frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lalo2llf(trk, pt = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lalo2llf_+3A_trk">trk</code></td>
<td>
<p>A data frame, two-column matrix, two-element vector  of track points c(latitude, longitude) or sensor data  structure.</p>
</td></tr>
<tr><td><code id="lalo2llf_+3A_pt">pt</code></td>
<td>
<p>c(latitude, longitude) of the centre point of the local level frame. If pt is not given, the first point in the track will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns <code>northing</code> and <code>easting</code> of track points in the local level frame. Northing and easting are in metres. The axes of the frame are true (geographic) north and true east.
</p>


<h3>Note</h3>

<p>This function assumes the track is on the surface of the geoid,
and also uses a simple spherical model for the geoid. For
more accurate conversion to a Cartesian frame, use spatial and mapping packages in Matlab/Octave.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coordinates &lt;- matrix(c(
-122.4194, 37.7749,
-73.9352,  40.7306), nrow = 2, ncol = 2, byrow = TRUE)
lalo2llf(coordinates, c(15,19))
</code></pre>

<hr>
<h2 id='load_nc'>Load a tag dataset from a netCDF file.</h2><span id='topic+load_nc'></span>

<h3>Description</h3>

<p>This function loads a tag dataset from a netCDF file (this is an archival file format supported by the tagtools package and suitable for submission to online data archives).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_nc(file, which_vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_nc_+3A_file">file</code></td>
<td>
<p>File name (and path, if necessary) of netCDF file to be read, as a quoted character string.</p>
</td></tr>
<tr><td><code id="load_nc_+3A_which_vars">which_vars</code></td>
<td>
<p>(Optional) A list of quoted character strings giving the exact names of variables to be read in. Default is to read all variables present in the file. parameters should be read in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>animaltag</code> object (a list) containing sensor and metadata structures. The item names in X will be the same as the names of the variables in the NetCDF file (plus an &quot;info&quot; one), e.g., if the file contains A and P, output object X will have fields X$A, X$P and X$info (the file metadata).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hold &lt;- system.file("extdata","beaked_whale.nc", package = "tagtools", mustWork = TRUE)
load_nc(hold)

</code></pre>

<hr>
<h2 id='m_dist'>Calculate Mahalanobis distance</h2><span id='topic+m_dist'></span>

<h3>Description</h3>

<p>This function is used to calculate the Mahalanobis distance for a multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m_dist(
  data,
  sampling_rate,
  smoothDur,
  overlap,
  consec,
  cumSum,
  expStart,
  expEnd,
  baselineStart,
  baselineEnd,
  BL_COV
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="m_dist_+3A_data">data</code></td>
<td>
<p>A data frame or matrix with one row for each time point. Note that the Mahalanobis distance calculation should be carried out on continuous data only, so if your data contain logical, factor or character data, proceed at your own risk...errors (or at least meaningless results) will probably ensue.</p>
</td></tr>
<tr><td><code id="m_dist_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate in Hz (data should be regularly sampled). If not specified it will be assumed to be 1 Hz.</p>
</td></tr>
<tr><td><code id="m_dist_+3A_smoothdur">smoothDur</code></td>
<td>
<p>The length, in minutes, of the window to use for calculation of &quot;comparison&quot; values. If not specified or zero, there will be no smoothing (a distance will be calculated for each data observation).</p>
</td></tr>
<tr><td><code id="m_dist_+3A_overlap">overlap</code></td>
<td>
<p>The amount of overlap, in minutes, between consecutive &quot;comparison&quot; windows. smooth_dur - overlap will give the time resolution of the  resulting distance time series. If not specified or zero, there will be no overlap.  Overlap will also be set to zero if smoothDur is unspecified or zero.</p>
</td></tr>
<tr><td><code id="m_dist_+3A_consec">consec</code></td>
<td>
<p>Logical. If consec = TRUE, then the calculated distances are between consecutive windows of duration smoothDur, sliding forward over the data set by a time step of (smoothDur-overlap) minutes. If TRUE, baselineStart and baselineEnd inputs will be used to define the period used to calculate the data covariance matrix. Default is consec = FALSE.</p>
</td></tr>
<tr><td><code id="m_dist_+3A_cumsum">cumSum</code></td>
<td>
<p>Logical.  If cum_sum = TRUE, then output will be the cumulative sum of the calculated distances, rather than the distances themselves. Default is cum_sum = FALSE.</p>
</td></tr>
<tr><td><code id="m_dist_+3A_expstart">expStart</code></td>
<td>
<p>Start times (in seconds since start of the data set) of the experimental exposure period(s).</p>
</td></tr>
<tr><td><code id="m_dist_+3A_expend">expEnd</code></td>
<td>
<p>End times (in seconds since start of the data set) of the experimental exposure period(s). If either or both of exp_start and exp_end are missing, the distance will be calculated over whole dataset and full dataset will be assumed to be baseline.</p>
</td></tr>
<tr><td><code id="m_dist_+3A_baselinestart">baselineStart</code></td>
<td>
<p>Start time (in seconds since start of the data set) of the baseline period (the mean data values for this period will be used as the 'control' to which all &quot;comparison&quot; data points (or windows) will be compared. if not specified, it will be assumed to be 0 (start of record).</p>
</td></tr>
<tr><td><code id="m_dist_+3A_baselineend">baselineEnd</code></td>
<td>
<p>End time (in seconds since start of the data set) of the baseline period. If not specified, the entire data set will be used (baseline_end will be the last sampled time-point in the data set).</p>
</td></tr>
<tr><td><code id="m_dist_+3A_bl_cov">BL_COV</code></td>
<td>
<p>Logical.  If BL_COV=  TRUE, then a covariance matrix using all data in baseline period will be used for calculating the Mahalanobis distance. Default is BL_COV = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containing results: variable seconds is times in seconds since start of dataset, at which Mahalanobis distances are reported. If a smoothDur was applied, then the reported times will be the start times of each &quot;comparison&quot; window. Variable dist is the Mahalanobis distances between the specified baseline period and the specified &quot;comparison&quot; periods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BW &lt;- beaked_whale
m_dist_result &lt;- m_dist(BW$A$data, BW$A$sampling_rate)

</code></pre>

<hr>
<h2 id='m2h'>Heading from accelerometer and magnetometer data</h2><span id='topic+m2h'></span>

<h3>Description</h3>

<p>This function is used to compute the heading, field intensity, and the inclination angle by gimballing the magnetic field measurement matrix with the pitch and roll estimated from the accelerometer matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2h(M, A, sampling_rate = NULL, fc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="m2h_+3A_m">M</code></td>
<td>
<p>A sensor data structure or matrix, M = [mx,my,mz] in any consistent unit (e.g., in uT or Gauss) or magnetometer sensor list (e.g., from readtag.R).</p>
</td></tr>
<tr><td><code id="m2h_+3A_a">A</code></td>
<td>
<p>A sensor data structure or matrix with columns [ax ay az] or acceleration sensor list (e.g., from readtag.R). Acceleration can be in any consistent unit, e.g., g or m/s^2.</p>
</td></tr>
<tr><td><code id="m2h_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>(optional) The sampling rate of the sensor data in Hz (samples per second). This is only needed if filtering is required. If <code>A</code> and <code>M</code> are sensor data lists, then sampling_rate is obtained from them.</p>
</td></tr>
<tr><td><code id="m2h_+3A_fc">fc</code></td>
<td>
<p>(optional) The cut-off frequency of a low-pass filter to apply to A and M before computing heading. The filter cut-off frequency is with in Hertz. The filter length is 4*sampling_rate/fc. Filtering adds no group delay. If fc is not specified, no filtering is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 elements:
</p>

<ul>
<li><p><strong>h: </strong> The heading in radians in the same frame as M. The heading is with respect to magnetic north (i.e., the north vector of the navigation frame) and so must be corrected for declination. 
</p>
</li>
<li><p><strong>v: </strong> The estimated magnetic field intensity in the same units as M. This is computed by taking the 2-norm of M, after filtering (if any filtering was specified).
</p>
</li>
<li><p><strong>incl: </strong> The estimated magnetic field inclination angle (i.e., the angle with respect to the horizontal plane) in radians. By convention, a field vector pointing below the horizon has a positive inclination angle. See note in the function if using incl.
</p>
</li></ul>



<h3>Note</h3>

<p>Output sampling rate is the same as the input sampling rate (i.e. h, v, and incl are estimated with the same sampling rate as M and A and so are each nx1 vectors).
</p>
<p>Frame: This function assumes a [north,east,up] navigation frame and a [forward,right,up] local frame. North and east are magnetic, not true. In these frames a positive heading is a clockwise rotation around the z-axis.
</p>
<p>The heading is computed with respect to the frame of M and is the magnetic heading NOT the true heading. M and A must have the same sampling rate, frame, and number of rows.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+a2pr">a2pr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m2h_out &lt;- m2h(M = matrix(c(22, -24, 14), nrow = 1), 
                        A = matrix(c(-0.3, 0.52, 0.8), nrow = 1))
</code></pre>

<hr>
<h2 id='make_info'>Make an info structure with tag metadata</h2><span id='topic+make_info'></span>

<h3>Description</h3>

<p>This function allows the user to generate a &quot;skeleton&quot; info structure for a tag deployment, with some common pieces of metadata filled in. Additional information can then be added manually or using a custom script before saving this <code>info</code> as part of a netCDF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_info(depid, tagtype, species, owner)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_info_+3A_depid">depid</code></td>
<td>
<p>Deployment id string for this tag record</p>
</td></tr>
<tr><td><code id="make_info_+3A_tagtype">tagtype</code></td>
<td>
<p>String identifying the tag type, for example 'dtag', 'cats', 'mk10', ...</p>
</td></tr>
<tr><td><code id="make_info_+3A_species">species</code></td>
<td>
<p>(optional) 2-letter string with the first letters of the species binomial</p>
</td></tr>
<tr><td><code id="make_info_+3A_owner">owner</code></td>
<td>
<p>(optional) String with initials of the tag data owner</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing metadata for a tag deployment. It's recommended to name this output &quot;info&quot; and save it as part of a netCDF tag data archive file (along with the tag sensor data).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>info &lt;- make_info("d4_template", "dtag4", "zc", "sdr")

</code></pre>

<hr>
<h2 id='make_specgram'>Plot a spectrogram with default settings</h2><span id='topic+make_specgram'></span>

<h3>Description</h3>

<p>This is a wrapper function for <a href="signal.html#topic+specgram">specgram</a> to draw a spectrogram with
the same input argument names and defaults as the tag tools Matlab/Octave function make_specgram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_specgram(
  x,
  nfft = 256,
  fs = 2,
  window = signal::hanning(nfft),
  noverlap = length(window)/2,
  draw_plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_specgram_+3A_x">x</code></td>
<td>
<p>The input signal</p>
</td></tr>
<tr><td><code id="make_specgram_+3A_nfft">nfft</code></td>
<td>
<p>specifies the number of frequency points used to calculate the discrete Fourier transforms.</p>
</td></tr>
<tr><td><code id="make_specgram_+3A_fs">fs</code></td>
<td>
<p>The sampling frequency in Hz</p>
</td></tr>
<tr><td><code id="make_specgram_+3A_window">window</code></td>
<td>
<p>If you specify a scalar for <code>window</code>,
make_specgram uses a Hanning window of that length.
<code>window</code> must have length smaller than or equal to <code>nfft</code> and greater than <code>noverlap</code>.</p>
</td></tr>
<tr><td><code id="make_specgram_+3A_noverlap">noverlap</code></td>
<td>
<p>The number of samples the sections of <code>x</code> overlap.</p>
</td></tr>
<tr><td><code id="make_specgram_+3A_draw_plot">draw_plot</code></td>
<td>
<p>(logical) Should a plot be drawn? Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>draw_plot</code> is TRUE, a plot is produced. If it is FALSE, a list is returned, with as follows. Each element is a matrix and all three matrices are the same size.
</p>

<ul>
<li> <p><code>s, </code> A matrix of spectrogram values of signal x in dB. 
</p>
</li>
<li> <p><code>f, </code> Frequencies (Hz) corresponding to the rows of s
</p>
</li>
<li> <p><code>t, </code> Time indices corresponding to the columns of s
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- signal::chirp(seq(from = 0, by = 0.001, to = 2),
  f0 = 0,
  t1 = 2,
  f1 = 500
)
fs &lt;- 2
nfft &lt;- 256
numoverlap &lt;- 128
window &lt;- signal::hanning(nfft)
S &lt;- make_specgram(x, nfft, fs, window, numoverlap, draw_plot = FALSE)
</code></pre>

<hr>
<h2 id='mean_absorption'>Calculate the mean absorption in salt water</h2><span id='topic+mean_absorption'></span>

<h3>Description</h3>

<p>This function is used to calculate the mean absorption in salt water over a frequency range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_absorption(freq, r, depth, Ttab = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_absorption_+3A_freq">freq</code></td>
<td>
<p>Specifies the frequency range, freq = c(fmin, fmax) in Hz. For a single frequency, use a scalar value for freq.</p>
</td></tr>
<tr><td><code id="mean_absorption_+3A_r">r</code></td>
<td>
<p>The path (slant) length in metres.</p>
</td></tr>
<tr><td><code id="mean_absorption_+3A_depth">depth</code></td>
<td>
<p>The depths covered by the path. This can be a single value for a horizontal path or a two component vector i.e., depth = c(dmax, dmin) for a path that extends between two depths.</p>
</td></tr>
<tr><td><code id="mean_absorption_+3A_ttab">Ttab</code></td>
<td>
<p>(optional) The temperature (a scalar) in degrees C or specifies a temperature profile Ttab = c(depth, tempr) where depth and tempr are equal-sized column vectors. Default value is an isothermal profile of 13 degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean sound absorption over the path in dB.
</p>


<h3>Note</h3>

<p>After Kinsler and Frey pp. 159-160.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean_absorption(c(25e3, 60e3), 1000, c(0, 700))
</code></pre>

<hr>
<h2 id='median_filter'>Computes the nth-order median filter</h2><span id='topic+median_filter'></span>

<h3>Description</h3>

<p>This function computes the nth-order median filter each column of X. The filter output is the median of each consecutive group of n samples. This is useful for removing occasional outliers in data that is otherwise fairly smooth. This makes it appropriate for pressure, temperature and magnetometer data (amongst other sensors) but not so suitable for acceleration which can be highly dynamic. The filter does not introduce delay. The start and end values, i.e., within n samples of the start or end of the input data, are computed with decreasing order median filters unless noend = TRUE. If noend = TRUE, start and end values are taken directly from X without short median filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_filter(X, n, noend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="median_filter_+3A_x">X</code></td>
<td>
<p>A sensor list or a vector or matrix. If there are multiple columns in the data, each column is treated as a separate signal to be filtered.</p>
</td></tr>
<tr><td><code id="median_filter_+3A_n">n</code></td>
<td>
<p>The filter length. If an even n is given, it is automatically incremented to make it odd. This ensures that the median is well-defined (the median of an even length vector is usually defined as the mean of the middle two points but may differ in different programmes). Note that a short n (e.g., 3 or 5) is usually sufficient and that processing will be very slow if n is large.</p>
</td></tr>
<tr><td><code id="median_filter_+3A_noend">noend</code></td>
<td>
<p>If TRUE (the default), then start and end values are taken directly from X without short median filters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of the filter. It has the same size as S and has the same sampling rate and units as X. If X is a sensor list, the return will also be.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- matrix(c(1, 3, 4, 4, 20, -10, 5, 6, 6, 7), ncol = 1)
w &lt;- median_filter(v, n = 3)
</code></pre>

<hr>
<h2 id='merge_fields'>Merge the fields of two lists</h2><span id='topic+merge_fields'></span>

<h3>Description</h3>

<p>This function is used to merge the fields of two lists. If there are duplicate fields, the fields in s1 are taken.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_fields(s1, s2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_fields_+3A_s1">s1</code></td>
<td>
<p>Arbitrary list e.g., containing metadata or settings.</p>
</td></tr>
<tr><td><code id="merge_fields_+3A_s2">s2</code></td>
<td>
<p>Arbitrary list e.g., containing metadata or settings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing all of the fields in s1 and s2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- list(a = 1, b = c(2, 3, 4))
s2 &lt;- list(b = 3, c = "cat")
s &lt;- merge_fields(s1, s2)
</code></pre>

<hr>
<h2 id='metadata_editor'>Edits a html file from given csv.</h2><span id='topic+metadata_editor'></span>

<h3>Description</h3>

<p>Takes data from csv, and edits a default or given html to fill in data from the csv. HTML must be tagmetadata.html or variations, csv should only contain metadata of tag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metadata_editor(
  masterHTML = system.file("extdata", "tagmetadata.html", package = "tagtools"),
  csvfilename = system.file("extdata", "blank_template.csv", package = "tagtools")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metadata_editor_+3A_masterhtml">masterHTML</code></td>
<td>
<p>default masterHTML is located in the package, or can be changed according to user input.</p>
</td></tr>
<tr><td><code id="metadata_editor_+3A_csvfilename">csvfilename</code></td>
<td>
<p>file name of csv to be used for editing the HTML</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;dynamic tagmetadata.html&quot; which is the masterHTML with changes from csv. This file is written to the current working directory, and also opened for editing by the user.
</p>

<hr>
<h2 id='msa'>Compute MSA</h2><span id='topic+msa'></span>

<h3>Description</h3>

<p>This function is used to compute the Minimum Specific Acceleration (MSA). This is the absolute value of the norm of the acceleration minus 1 g, i.e., the amount that the acceleration differs from the gravity value. This is always equal to or less than the actual specific acceleration if A is correctly calibrated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msa(A, ref)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msa_+3A_a">A</code></td>
<td>
<p>An nx3 acceleration matrix with columns [ax ay az], or a tag sensor data list containing acceleration data. Acceleration can be in any consistent unit, e.g., g or m/s^2. A can be in any frame as the MSA is rotation independent.</p>
</td></tr>
<tr><td><code id="msa_+3A_ref">ref</code></td>
<td>
<p>The gravitational field strength in the same units as A. This is not needed if A is a sensor structure. If A is a matrix, the default value is 9.81 which assumes that A is in m/s^2. Use ref = 1 if the unit of A is g.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible input combinations: msa(A) if A is a list, msa(A,ref) if A is a matrix.
</p>


<h3>Value</h3>

<p>A column vector of MSA with the same number of rows as A, or a tag sensor data list (output matches input). m has the same units as A.
</p>


<h3>Note</h3>

<p>See Simon et al. (2012) Journal of Experimental Biology, 215:3786-3798.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+odba">odba</a></code>, <code><a href="#topic+njerk">njerk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sampleMatrix &lt;- matrix(c(1, -0.5, 0.1, 0.8, -0.2, 0.6, 0.5, -0.9, -0.7),
  byrow = TRUE, nrow = 3, ncol = 3
)
msa(A = sampleMatrix, ref = 1)
</code></pre>

<hr>
<h2 id='njerk'>Compute the norm-jerk</h2><span id='topic+njerk'></span>

<h3>Description</h3>

<p>This function is used to compute the norm-jerk from triaxial acceleration data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>njerk(A, sampling_rate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="njerk_+3A_a">A</code></td>
<td>
<p>A tag sensor data list or a nx3 acceleration matrix with columns [ax ay az]. Acceleration can be in any consistent unit, e.g., g or m/s^2. A can be in any frame as the norm-jerk is rotation independent. A must have at least 2 rows (i.e., n&gt;=2).</p>
</td></tr>
<tr><td><code id="njerk_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate in Hz of the acceleration signals. This is used to estimate the differential by a first-order difference.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The norm-jerk from triaxial acceleration data in the form of a column vector with the same number of rows as in A, or a tag sensor data structure (if the input A was one). The norm-jerk is ||dA/dt||, where ||x|| is the 2-norm of x, i.e., the square-root of the sum of the squares of each axis. If the unit of A is m/s^2, the norm-jerk has unit m/s^3. If the unit of A is g, the norm-jerk has unit g/s. As j is the norm of the jerk, it is always positive or zero (if the acceleration is constant). The final value in j is always 0 because the last finite difference cannot be calculated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msa">msa</a></code>, <code><a href="#topic+odba">odba</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sampleMatrix &lt;- matrix(c(1, 2, 3, 2, 2, 4, 1, -2, 4, 4, 4, 4), byrow = TRUE, nrow = 4, ncol = 3)
norm_jerk &lt;- njerk(A = sampleMatrix, sampling_rate = 5)

</code></pre>

<hr>
<h2 id='norm2'>Compute the row-wise vector norm</h2><span id='topic+norm2'></span>

<h3>Description</h3>

<p>This function is used to compute the row-wise vector norm of X if X is a matrix. If X is a vector (row or column), v is the vector norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm2(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm2_+3A_x">X</code></td>
<td>
<p>A data structure, vector or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The row-wise vector-norm of matrix X, i.e., the square-root of the sum of the squares for each row. If X is a vector (row or column), v is the vector norm and norm2() is equivalent to the built-in function norm(). But if X is a matrix e.g., a triaxial accelerometer or magnetometer matrix, norm() gives the overall norm of the matrix whereas norm2() gives the vector norm of each row (i.e., the field strength in the case of a magnetometer matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sampleMatrix &lt;- matrix(c(0.2, 0.4, -0.7, -0.3, 1.1, 0.1), byrow = TRUE, nrow = 2, ncol = 3)
norm2(X = sampleMatrix)
</code></pre>

<hr>
<h2 id='ocdr'>Estimate the forward speed</h2><span id='topic+ocdr'></span>

<h3>Description</h3>

<p>This function is used to estimate the forward speed of a flying or diving animal by first computing the altitude or depth-rate (i.e., the first differential of the pressure in meters) and then correcting for the pitch angle. This is called the Orientation Corrected Depth Rate. There are two major assumptions in this method: (i) the animal moves in the direction of its longitudinal axis, and (ii) the frame of A coincides with the animal's axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocdr(p, A, sampling_rate, fc, plim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ocdr_+3A_p">p</code></td>
<td>
<p>The depth or altitude vector (a regularly sampled time series) or depth or altitude sensors list in meters, sampled at sampling_rate Hz.</p>
</td></tr>
<tr><td><code id="ocdr_+3A_a">A</code></td>
<td>
<p>The nx3 acceleration matrix with columns [ax ay az] or acceleration sensor list (e.g., from readtag.R). Acceleration can be in any consistent unit, e.g., g or m/s^2. A must have the same number of rows as p.</p>
</td></tr>
<tr><td><code id="ocdr_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate of p and A in Hz (samples per second).</p>
</td></tr>
<tr><td><code id="ocdr_+3A_fc">fc</code></td>
<td>
<p>(optional) Specifies the cut-off frequency of a low-pass filter to apply to p after computing depth-rate and to A before computing pitch. The filter cut-off frequency is in Hz. The filter length is 4*sampling_rate/fc. Filtering adds no group delay. If fc is empty or not given, the default value of 0.2 Hz (i.e., a 5 second time constant) is used.</p>
</td></tr>
<tr><td><code id="ocdr_+3A_plim">plim</code></td>
<td>
<p>(optional) Specifies the minimum pitch angle in radians at which speed can be computed. Errors in speed estimation using this method increase strongly at low pitch angles. To avoid estimates with poor accuracy being used in later analyses, speed estimates at low pitch angles are replaced by NaN (not-a-number). The default threshold for this is 20 degrees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible input combinations: ocdr(p,A) if p and A are lists, ocdr(p,A,fc = fc) if p and A are lists, ocdr(p,A,fc = fc,plim = plim) if p and A are lists, ocdr(p,A,sampling_rate) if p and A are vectors/matrices, ocdr(p,A,sampling_rate,fc) if p and A are vectors/matrices, ocdr(p,A,sampling_rate,fc,plim) if p and A are vectors/matrices.
</p>


<h3>Value</h3>

<p>The forward speed estimate in m/s
</p>


<h3>Note</h3>

<p>Output sampling rate is the same as the input sampling rate so s has the same size as p.
</p>
<p>Frame: This function assumes a [north,east,up] navigation frame and a [forward,right,up] local frame. In these frames, a positive pitch angle is an anti-clockwise rotation around the y-axis. A descending animal will have a negative pitch angle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS &lt;- harbor_seal
s &lt;- ocdr(p = HS$P$data, A = HS$A$data, sampling_rate = HS$P$sampling_rate, fc = NULL, plim = NULL)
speed &lt;- list(s = s)
plott_base(speed, HS$P$sampling_rate)

</code></pre>

<hr>
<h2 id='odba'>Compute ODBA</h2><span id='topic+odba'></span>

<h3>Description</h3>

<p>This function is used to compute the 'Overall Dynamic Body Acceleration' sensu Wilson et al. 2006. ODBA is the norm of the high-pass-filtered acceleration. Several methods for computing ODBA are in use which differ by which norm and which filter are used. 
In the Wilson paper, the 1-norm and a rectangular window (moving average) filter are used. The moving average is subtracted from the input accelerations to implement a high-pass filter. 
The 2-norm may be preferable if the tag orientation is unknown or may change and this is termed VeDBA. A tapered symmetric FIR  filter gives more efficient high-pass filtering compared to the rectangular window method and avoids lobes in the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odba(A, sampling_rate = NULL, fh = NULL, method = "fir", n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="odba_+3A_a">A</code></td>
<td>
<p>A tag sensor data list containing tri-axial acceleration data or an nx3 acceleration matrix with columns [ax ay az]. Acceleration can be in any consistent unit, e.g., g or m/s^2. A can be in any frame but the result depends on the method used to compute ODBA. 
The default method and VeDBA method are rotation independent and so give the same result irrespective of the frame of A. The 1-norm method has a more complex dependency on frame.</p>
</td></tr>
<tr><td><code id="odba_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate in Hz of the acceleration signals. Required for 'fir' method if A is not a tag sensor data list.</p>
</td></tr>
<tr><td><code id="odba_+3A_fh">fh</code></td>
<td>
<p>The high-pass filter cut-off frequency in Hz. This should be chosen to be about half of the stroking rate for the animal (e.g., using dsf.R). Required for the default 'fir' method.</p>
</td></tr>
<tr><td><code id="odba_+3A_method">method</code></td>
<td>
<p>A character containing either 'wilson' or 'vedba' or 'fir'. This determines the method by which the ODBA is calculated. The default method is 'fir'.</p>
</td></tr>
<tr><td><code id="odba_+3A_n">n</code></td>
<td>
<p>The rectangular window (moving average) length in samples. This is only needed if using the classic ODBA and VeDBA forms (methods 'wilson' and 'vedba').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column vector of ODBA with the same number of rows as A. e has the same units as A.
</p>


<h3>Note</h3>

<p>If applying the default (FIR filtering) method to calculate odba, use the inputs A, sampling_rate, and fh. When applying the 'vedba' or 'wilson' method, use the inputs A, n, and method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BW &lt;- beaked_whale
e &lt;- odba(A = BW$A$data, sampling_rate = BW$A$sampling_rate, fh = 0.05)
ba &lt;- list(e = e)
plott_base(ba, BW$A$sampling_rate)

</code></pre>

<hr>
<h2 id='plott'>Plot tag data time series</h2><span id='topic+plott'></span>

<h3>Description</h3>

<p>Plot time series in a single or multi-paneled figure, using ggplot2 graphics for static graphs and plotly for interactive ones. This is useful, for example, for comparing measurements across different sensors in an animaltag data object. The time axis is automatically displayed in seconds, minutes, hours, or days according to the span of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plott(
  X,
  fsx = NULL,
  r = FALSE,
  offset = 0,
  date_time_axis = FALSE,
  recording_start = NULL,
  panel_heights = rep.int(1, length(X))/length(X),
  panel_labels = names(X),
  line_colors,
  interactive = FALSE,
  draw = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plott_+3A_x">X</code></td>
<td>
<p>List whose elements are either lists (containing data and metadata) or vectors/matrices of time series data. See details.</p>
</td></tr>
<tr><td><code id="plott_+3A_fsx">fsx</code></td>
<td>
<p>(Optional) A numeric vector whose length matches the number of sensor data streams (list elements) in X. (If shorter, <code>fsx</code> will be recycled to the appropriate length). <code>fsx</code> gives the sampling rate in Hz for each data object. Sampling rates are not needed when the data object(s) <code>X</code> are list(s) that contain sampling rate information &ndash; and beware, because <code>fsx</code> (if given) will override sensor metadata.</p>
</td></tr>
<tr><td><code id="plott_+3A_r">r</code></td>
<td>
<p>(Optional) Logical. Should the direction of the y-axis be flipped? Default is FALSE. If <code>r</code> is of length one (or shorter than the number of sensor data streams in X) it will be recycled to match the number of sensor data streams. Reversed y-axes are useful, for example, for plotting dive profiles which match the physical situation (with greater depths lower in the display). If the name of a sensor list is &quot;P&quot; or contains the word &quot;depth&quot;, it will automatically be reversed.</p>
</td></tr>
<tr><td><code id="plott_+3A_offset">offset</code></td>
<td>
<p>(Optional) A vector of offsets, in seconds, between the start of each sensor data stream and the start of the first one. For example, if acceleration data collection started and then depth data collection commenced 436 seconds later, then the <code>offset</code> for the depth data would be 436.</p>
</td></tr>
<tr><td><code id="plott_+3A_date_time_axis">date_time_axis</code></td>
<td>
<p>(Optional) Logical. Should the x-axis units be date-times rather than time-since-start-of-recording?  Ignored if <code>recording_start</code> is not provided and <code>X</code> does not contain metadata on recording start time. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plott_+3A_recording_start">recording_start</code></td>
<td>
<p>(Optional) The start time of the tag recording as a <code><a href="base.html#topic+POSIXct">POSIXct</a></code> object. If provided, the time axis will show calendar date/times; if not, it will show days/hours/minutes/seconds (as appropriate) since time 0 = the start of recording. If a character string is provided it will be coerced to POSIXct with <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>.</p>
</td></tr>
<tr><td><code id="plott_+3A_panel_heights">panel_heights</code></td>
<td>
<p>(Optional) A vector of relative or absolute heights for the different panels (one entry for each sensor data stream in <code>X</code>). Default is equal-height panels. If <code>panel_heights</code> is a numeric vector, it is interpreted as relative panel heights.</p>
</td></tr>
<tr><td><code id="plott_+3A_panel_labels">panel_labels</code></td>
<td>
<p>(Optional) A list of y-axis labels for the panels. Defaults to names(X).</p>
</td></tr>
<tr><td><code id="plott_+3A_line_colors">line_colors</code></td>
<td>
<p>(Optional) A list of colors for lines for multivariate data streams (for example, if a panel plots tri-axial acceleration, it will have three lines &ndash; their line colors will be the first three in this list). May be specified in any specification R understands for colors. Defaults to c(&quot;#000000&quot;, &quot;#009E73&quot;, &quot;#9ad0f3&quot;, &quot;#0072B2&quot;, &quot;#e79f00&quot;, &quot;#D55E00&quot;)</p>
</td></tr>
<tr><td><code id="plott_+3A_interactive">interactive</code></td>
<td>
<p>(Optional) Should an interactive figure (allowing zoom/pan/etc.) be produced? Default is FALSE. Interactive plotting requires the package plotly.</p>
</td></tr>
<tr><td><code id="plott_+3A_draw">draw</code></td>
<td>
<p>(Optional) Whether or not to draw the plot. Defaults to TRUE. If FALSE, a list of ggplot objects (if interactive is FALSE; this list is suitable to plot with <code>cowplot::plot_grid()</code>) or a list of plotly objects (if interactive is TRUE) will be returned. This may be useful if you wish to further customize the plot panels, for example adding detected events atop the dive profile.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input data X is an <code>animaltag</code> object, then all sensor variables in the object will be plotted. To plot only selected sensors from the <code>animaltag</code> object <code>my_tag</code>, for example, the input X=list(my_tag$A, my_tag$M) would plot just the accelerometer and magnetometer data. If possible, the plot will have
</p>


<h3>Value</h3>

<p>A plot of time-series data created with ggplot or plotly. If you prefer base R graphics, consider function <code><a href="#topic+plott_base">plott_base</a></code> instead.
</p>


<h3>Note</h3>

<p>This is a flexible plotting tool which can be used to display and explore sensor data with different sampling rates on a uniform time grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plott(list(depth = harbor_seal$P, Accel = harbor_seal$A))

</code></pre>

<hr>
<h2 id='plott_base'>Plot tag data time series</h2><span id='topic+plott_base'></span>

<h3>Description</h3>

<p>Plot time series in a single or multi-paneled figure, using base R graphics. This is useful, for example, for comparing measurements across different sensors in an animaltag data object. The time axis is automatically displayed in seconds, minutes, hours, or days according to the span of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plott_base(
  X,
  fsx = NULL,
  r = FALSE,
  offset = 0,
  date_time_axis = FALSE,
  recording_start = NULL,
  panel_heights = rep.int(1, length(X)),
  panel_labels = names(X),
  line_colors,
  interactive = FALSE,
  par_opts,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plott_base_+3A_x">X</code></td>
<td>
<p>List whose elements are either lists (containing data and metadata) or vectors/matrices of time series data. See details.</p>
</td></tr>
<tr><td><code id="plott_base_+3A_fsx">fsx</code></td>
<td>
<p>(Optional) A numeric vector whose length matches the number of sensor data streams (list elements) in X. (If shorter, <code>fsx</code> will be recycled to the appropriate length). <code>fsx</code> gives the sampling rate in Hz for each data object. Sampling rates are not needed when the data object(s) <code>X</code> are list(s) that contain sampling rate information &ndash; and beware, because <code>fsx</code> (if given) will override sensor metadata.</p>
</td></tr>
<tr><td><code id="plott_base_+3A_r">r</code></td>
<td>
<p>(Optional) Logical. Should the direction of the y-axis be flipped? Default is FALSE. If <code>r</code> is of length one (or shorter than the number of sensor data streams in X) it will be recycled to match the number of sensor data streams. Reversed y-axes are useful, for example, for plotting dive profiles which match the physical situation (with greater depths lower in the display). If the name of a sensor list is &quot;P&quot; or contains the word &quot;depth&quot;, it will automatically be reversed.</p>
</td></tr>
<tr><td><code id="plott_base_+3A_offset">offset</code></td>
<td>
<p>(Optional) A vector of offsets, in seconds, between the start of each sensor data stream and the start of the first one. For example, if acceleration data collection started and then depth data collection commenced 436 seconds later, then the <code>offset</code> for the depth data would be 436.</p>
</td></tr>
<tr><td><code id="plott_base_+3A_date_time_axis">date_time_axis</code></td>
<td>
<p>(Optional) Logical. Should the x-axis units be date-times rather than time-since-start-of-recording?  Ignored if <code>recording_start</code> is not provided and <code>X</code> does not contain metadata on recording start time. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plott_base_+3A_recording_start">recording_start</code></td>
<td>
<p>(Optional) The start time of the tag recording as a <code><a href="base.html#topic+POSIXct">POSIXct</a></code> object. If provided, the time axis will show calendar date/times; if not, it will show days/hours/minutes/seconds (as appropriate) since time 0 = the start of recording. If a character string is provided it will be coerced to POSIXct with <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>.</p>
</td></tr>
<tr><td><code id="plott_base_+3A_panel_heights">panel_heights</code></td>
<td>
<p>(Optional) A vector of relative or absolute heights for the different panels (one entry for each sensor data stream in <code>X</code>). Default is equal-height panels. If <code>panel_heights</code> is a numeric vector, it is interpreted as relative panel heights. To specify absolute panel heights in centimeters using <code>lcm</code> (see help for <code><a href="graphics.html#topic+layout">layout</a></code>).</p>
</td></tr>
<tr><td><code id="plott_base_+3A_panel_labels">panel_labels</code></td>
<td>
<p>(Optional) A list of y-axis labels for the panels. Defaults to names(X).</p>
</td></tr>
<tr><td><code id="plott_base_+3A_line_colors">line_colors</code></td>
<td>
<p>(Optional) A list of colors for lines for multivariate data streams (for example, if a panel plots tri-axial acceleration, it will have three lines &ndash; their line colors will be the first three in this list). May be specified in any specification R understands for colors. Defaults to c(&quot;#000000&quot;, &quot;#009E73&quot;, &quot;#9ad0f3&quot;, &quot;#0072B2&quot;, &quot;#e79f00&quot;, &quot;#D55E00&quot;)</p>
</td></tr>
<tr><td><code id="plott_base_+3A_interactive">interactive</code></td>
<td>
<p>(Optional) Should an interactive figure (allowing zoom/pan/etc.) be produced? Default is FALSE. Interactive plotting requires the zoom package for its <code><a href="zoom.html#topic+zm">zm</a></code> function.</p>
</td></tr>
<tr><td><code id="plott_base_+3A_par_opts">par_opts</code></td>
<td>
<p>(Optional) A list of options to be passed to <code><a href="graphics.html#topic+par">par</a></code> before plotting. Default is mar=c(1,5,0,0), oma=c(2,0,2,1), las=1, lwd=1, cex=0.8.</p>
</td></tr>
<tr><td><code id="plott_base_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input data X is an <code>animaltag</code> object, then all sensor variables in the object will be plotted. To plot only selected sensors from the <code>animaltag</code> object <code>my_tag</code>, for example, the input X=list(my_tag$A, my_tag$M) would plot just the accelerometer and magnetometer data. If possible, the plot will have
</p>


<h3>Value</h3>

<p>A plot of time-series data
</p>


<h3>Note</h3>

<p>This is a flexible plotting tool which can be used to display and explore sensor data with different sampling rates on a uniform time grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plott_base(list(depth = harbor_seal$P, Accel = harbor_seal$A))

</code></pre>

<hr>
<h2 id='plott_static_panel'>Helper function for plott</h2><span id='topic+plott_static_panel'></span>

<h3>Description</h3>

<p>This internal function helps<code>plott</code> produce the individual panels that make up the static ggplot output. It will not usually be needed by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plott_static_panel(
  sensor,
  sensor_data,
  line_colors,
  panel_labels,
  axis_names = c("X", "Y", "Z"),
  times,
  x_lab,
  r
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plott_static_panel_+3A_sensor">sensor</code></td>
<td>
<p>Which sensor to plot</p>
</td></tr>
<tr><td><code id="plott_static_panel_+3A_sensor_data">sensor_data</code></td>
<td>
<p>List whose elements are either lists (containing data and metadata) or vectors/matrices of time series data. See details.</p>
</td></tr>
<tr><td><code id="plott_static_panel_+3A_line_colors">line_colors</code></td>
<td>
<p>Vector of colors to use for lines</p>
</td></tr>
<tr><td><code id="plott_static_panel_+3A_panel_labels">panel_labels</code></td>
<td>
<p>Labels for each panel (sensor)</p>
</td></tr>
<tr><td><code id="plott_static_panel_+3A_axis_names">axis_names</code></td>
<td>
<p>Names for different axes for sensors with more than one (for example: X, Y, Z)</p>
</td></tr>
<tr><td><code id="plott_static_panel_+3A_times">times</code></td>
<td>
<p>List of vectors of times for the x axis of each panel (one list element per panel)</p>
</td></tr>
<tr><td><code id="plott_static_panel_+3A_x_lab">x_lab</code></td>
<td>
<p>Title for x axis (string)</p>
</td></tr>
<tr><td><code id="plott_static_panel_+3A_r">r</code></td>
<td>
<p>whether or not to reverse the y axis scale for each sensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot for &quot;one panel,&quot; that is, with the data from one sensor
</p>

<hr>
<h2 id='prh_predictor1'>Predict the tag position on a diving animal from depth and acceleration data</h2><span id='topic+prh_predictor1'></span>

<h3>Description</h3>

<p>Predict the tag position on a diving animal parameterized by p0, r0, and
h0, the canonical angles between the principal axes of the tag and the animal.
The tag orientation on the animal can change with time and this function
provides a way to estimate the orientation at the start and end of each suitable
dive. The function critically assumes that the animal rests horizontally at the
surface (at least on average) and dives steeply away from the surface without an
initial roll. If ascents are processed, there must also be no roll in the last
seconds of the ascents. See prh_predictor2 for a method more suitable to animals
that make short dives between respirations.
The function provides a graphical interface showing the estimated tag-to-animal
orientation throughout the deployment. Follow the directions above the top panel
of the figure to edit or delete an orientation estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prh_predictor1(P, A, sampling_rate = NULL, TH = 100, DIR = "descent")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prh_predictor1_+3A_p">P</code></td>
<td>
<p>is a dive depth vector or sensor structure with units of m H2O.</p>
</td></tr>
<tr><td><code id="prh_predictor1_+3A_a">A</code></td>
<td>
<p>is an acceleration matrix or sensor structure with columns ax, ay, and az. Acceleration can be in any consistent unit, e.g., g or m/s^2, and must have the same sampling rate as P.</p>
</td></tr>
<tr><td><code id="prh_predictor1_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>is the sampling rate of the sensor data in Hz (samples per second). This is only needed if neither A nor M are sensor structures.</p>
</td></tr>
<tr><td><code id="prh_predictor1_+3A_th">TH</code></td>
<td>
<p>is an optional minimum dive depth threshold (default is 100m). Only the descents at the start of dives deeper than TH will be analysed (and the ascents at the end of dives deeper than TH if ALL is true).</p>
</td></tr>
<tr><td><code id="prh_predictor1_+3A_dir">DIR</code></td>
<td>
<p>is an optional dive direction constraint. The default (DIR = 'descent') is to only analyse descents as these tend to give better results. But if DIR = 'both', both descents and ascents are analysed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PRH, a data frame with columns <code>cue</code> <code>p0</code>, <code>r0</code>, <code>h0</code>, and <code>q</code>
with a row for each dive edge analysed. <code>cue</code> is the time in second-since-tag-start of the dive edge analysed.
<code>p0</code>, <code>r0</code>, and <code>h0</code> are the deduced tag orientation angles in radians.
<code>q</code> is the quality indicator with a low value (near 0, e.g., &lt;0.05) indicating that the data fit more consistently with the assumptions of the method.
</p>


<h3>See Also</h3>

<p><a href="#topic+prh_predictor2">prh_predictor2</a>, <a href="#topic+tag2animal">tag2animal</a>
</p>

<hr>
<h2 id='prh_predictor2'>Predict the tag position on a diving animal from depth and acceleration data</h2><span id='topic+prh_predictor2'></span>

<h3>Description</h3>

<p>Predict the tag position on a diving animal parametrized by p0, r0, and
h0, the canonical angles between the principal axes of the tag and the animal.
The tag orientation on the animal can change with time and this function
provides a way to estimate the orientation at the start and end of each suitable
dive. The function critically assumes that the animal makes a sequence of short
dives between respirations and that the animal remains upright (i.e., does not roll)
during these shallow dives. See prh_predictor1 for a method more suitable to animals
that rest horizontally at the surface. The function provides a graphical interface showing the estimated tag-to-animal
orientation throughout the deployment. Follow the directions above the top panel
of the figure to edit or delete an orientation estimate.
The function provides a graphical interface showing the estimated tag-to-animal
orientation throughout the deployment. Follow the directions above the top panel
of the figure to edit or delete an orientation estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prh_predictor2(P, A, sampling_rate = NULL, MAXD = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prh_predictor2_+3A_p">P</code></td>
<td>
<p>is a dive depth vector or sensor structure with units of m H2O.</p>
</td></tr>
<tr><td><code id="prh_predictor2_+3A_a">A</code></td>
<td>
<p>is an acceleration matrix or sensor structure with columns ax, ay, and az. Acceleration can be in any consistent unit, e.g., g or m/s^2, and must have the same sampling rate as P.</p>
</td></tr>
<tr><td><code id="prh_predictor2_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>is the sampling rate of the sensor data in Hz (samples per second). This is only needed if neither A nor M are sensor structures.</p>
</td></tr>
<tr><td><code id="prh_predictor2_+3A_maxd">MAXD</code></td>
<td>
<p>is the optional maximum depth of near-surface dives. The default value is 10 m. This is used to find contiguous surface intervals suitable for analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PRH, a data frame with columns <code>cue</code> <code>p0</code>, <code>r0</code>, <code>h0</code>, and <code>q</code>
with a row for each dive edge analysed. <code>cue</code> is the time in second-since-tag-start of the dive edge analysed.
<code>p0</code>, <code>r0</code>, and <code>h0</code> are the deduced tag orientation angles in radians.
<code>q</code> is the quality indicator with a low value (near 0, e.g., &lt;0.05) indicating that the data fit more consistently with the assumptions of the method.
</p>


<h3>See Also</h3>

<p><a href="#topic+prh_predictor1">prh_predictor1</a>, <a href="#topic+tag2animal">tag2animal</a>
</p>

<hr>
<h2 id='ptrack'>Estimate simple dead-reckoned track</h2><span id='topic+ptrack'></span>

<h3>Description</h3>

<p>This function is used to estimate the simple dead-reckoned track (pseudo-track) based on speed and bodypointing angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptrack(A, M, s, sampling_rate = NULL, fc = 0.2, return_pe = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptrack_+3A_a">A</code></td>
<td>
<p>An nx3 acceleration matrix with columns [ax ay az] or acceleration sensor list. Acceleration can be in any consistent unit, e.g., g or m/s^2.</p>
</td></tr>
<tr><td><code id="ptrack_+3A_m">M</code></td>
<td>
<p>The magnetometer signal matrix, M = [mx,my,mz] in any consistent unit (e.g., in uT or Gauss)  or magnetometer sensor list. A and M must have the same size (and so are both measured at the same sampling rate).</p>
</td></tr>
<tr><td><code id="ptrack_+3A_s">s</code></td>
<td>
<p>The forward speed of the animal in m/s. s can be a single number meaning that the animal is assumed to travel at a constant speed. s can also be a vector with the same number of rows as A and M, e.g., generated by speed_from_depth().</p>
</td></tr>
<tr><td><code id="ptrack_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate of the sensor data in Hz (samples per second). This input will be ignored if A and/or M are sensor lists, in which case the sampling rate will be extracted from them.</p>
</td></tr>
<tr><td><code id="ptrack_+3A_fc">fc</code></td>
<td>
<p>(optional) The cut-off frequency of a low-pass filter to apply to A and M before computing bodypointing angle. The filter cut-off frequency is in Hz. The filter length is 4*sampling_rate/fc. Filtering adds no group delay. If fc is empty or not given, the default value of 0.2 Hz (i.e., a 5 second time constant) is used.</p>
</td></tr>
<tr><td><code id="ptrack_+3A_return_pe">return_pe</code></td>
<td>
<p>Logical. If return_pe is TRUE, the estimated depth or altitude predicted will be returned with the estimated track. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated track in a local level frame. The track is defined as meters of northward and eastward movement (variables 'northing' and 'easting' in the output data frame) relative to the animal's position at the start of the measurements  (which is defined as [0,0]). The track sampling rate is the same as for the input data and so each row of track object defines the track coordinates at times 0,1/sampling_rate,2/sampling_rate,... relative to the start time of the measurements. OR, if return_pe = TRUE, this function returns the above value and the estimated depth or altitude predicted from the speed and pitch angle. This can be compared against the measured depth/altitude to assess errors in the dead-reckoned track. Note that even if pe matches the observed depth, this does not guarantee that the track is accurate.
</p>


<h3>Note</h3>

<p>Frame: This function assumes a [north,east,up] navigation frame and a [forward,right,up] local frame. Both A and M must be rotated if needed to match the animal's cardinal axes otherwise the track will not be meaningful.
</p>
<p>CAUTION: dead-reckoned tracks are usually very inaccurate. They are useful to get an idea of HOW animals move rather than WHERE they go. Few animals probably travel in exactly the direction of their longitudinal axis and anyway measuring the precise orientation of the longitudinal axis of a non-rigid animal is fraught with error. Moreover, if there is net flow in the medium, the animal will be affected by the flow in addition to its autonomous movement. For swimming animals this can lead to substantial errors. The forward speed is assumed to be with respect to the medium so the track derived here is NOT the 'track-made-good', i.e., the geographic movement of the animal. It estimates the movement of the animal with respect to the medium. There are numerous other sources of error so use at your own risk!
</p>


<h3>See Also</h3>

<p><code><a href="#topic+htrack">htrack</a></code>, <code><a href="#topic+fit_tracks">fit_tracks</a></code>, <code><a href="#topic+track3D">track3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BW &lt;- beaked_whale
list &lt;- ptrack(A = BW$A$data, M = BW$M$data, s = 3, 
sampling_rate = BW$A$sampling_rate, fc = NULL, 
return_pe = TRUE)
plot(list$track$easting, list$track$northing, xlab = "Easting, m", ylab = "Northing, m")

</code></pre>

<hr>
<h2 id='read_cats'>Read a CATS data file and convert to .nc</h2><span id='topic+read_cats'></span>

<h3>Description</h3>

<p>Read a .csv file with data from a CATS tag deployment, including associated metadata, and store the resulting data in a .nc file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_cats(fname, depid)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_cats_+3A_fname">fname</code></td>
<td>
<p>is the file name of the CATS CSV file including the complete
path name if the file is not in the current working directory or in a
directory on the path. The .csv suffix is optional.</p>
</td></tr>
<tr><td><code id="read_cats_+3A_depid">depid</code></td>
<td>
<p>is a string containing the deployment identification code assigned
to this deployment, for example, 'mn12_186a'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string (constructed by: '<code>depid</code>_raw.nc'; for example, 'mn12_186a_raw.nc') containing the file name of the netCDF (.nc) file in which the output has been saved. This function
generates a netCDF file in the current working directory containing
the tag data variables, including:
</p>

<ul>
<li> <p>A, Accelerometer data structure
</p>
</li>
<li> <p>M, Magnetometer data structure
</p>
</li>
<li> <p>temp, Temperature sensor data structure
</p>
</li>
<li> <p>info	Information structure for the deployment
</p>
</li></ul>



<h3>Note</h3>

<p>CATS loggers can produce very large csv files which are slow to
process. This function is (somewhat) optimised for speed and memory use so will
tolerate large files. But processing could be slow. Note also that although CATs tags use a NED axis orientation for 3D sensors, 
this function converts to the NEU orientation expected by the animaltag tool kit. 
To revert (if continuing analysis with CATs-specific tools outside animaltags), 
simply multiply all z-axis values by -1. 
Also note that Cade et al. 2021 note that not all CATs tags have the same internal orientation of the triaxial sensors &ndash; 
such that the first column in the data may or may not be the &quot;x axis.&quot; 
Here, we assume that the three columns of data for any triaxial sensor are correctly labeled with X,Y,Z included in the column name in the CATs csv file. 
If not, further data-based bench calibration of the device may be needed to determine correct axis orientation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nc_filename &lt;- read_cats("my_cats_file.csv", "my_cats_deplyment_name")
load_nc("my_cats_deployment_name_raw.nc")

## End(Not run)
</code></pre>

<hr>
<h2 id='read_cats_csv'>Read a CSV file with sensor data from a CATS tag</h2><span id='topic+read_cats_csv'></span>

<h3>Description</h3>

<p>Read in data from a CATS tag deployment (stored in a .csv file). This function is usable by itself but is more normally
called by <code><a href="#topic+read_cats">read_cats</a></code> which handles metadata and creates a NetCDF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_cats_csv(fname, max_samps = Inf, skip_samps = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_cats_csv_+3A_fname">fname</code></td>
<td>
<p>is the file name of the CATS CSV file including the complete
path name if the file is not in the current working directory or in a
directory on the path. The .csv suffix is optional.</p>
</td></tr>
<tr><td><code id="read_cats_csv_+3A_max_samps">max_samps</code></td>
<td>
<p>is optional and is used to limit reading to a maximum number of samples (rows) per sensor. This is useful to read in a part of a very large file
for testing. If max_samps is not given, the entire file is read.</p>
</td></tr>
<tr><td><code id="read_cats_csv_+3A_skip_samps">skip_samps</code></td>
<td>
<p>Number of lines of data to skip (excluding header) before starting to read in data. Defaults to 0 (start at the beginning of the file), but can be used to read in a part of a file, or to read in and process a large file in chunks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble data frame containing the data read from the file. The column names are
taken from the first line of the CSV file and include units and axis. Some columns may be empty (if for example, a tag did not record data from a certain sensor type).
</p>


<h3>Note</h3>

<p>CATS csv files can be extremely large; perhaps too large to read the entire file into memory at once and work with it.
</p>

<hr>
<h2 id='rotate_data'>Rotate data.</h2><span id='topic+rotate_data'></span>

<h3>Description</h3>

<p>Rotate a numeric vector (for rotation_test, this will be a set of event times).  &quot;Rotating&quot; the vector entails advancing all values by a random increment, then subtracting
the maximum expected value from all rotated entries that exceed that maximum.
This is a utility function used by <code><a href="#topic+rotation_test">rotation_test</a></code>, but advanced users may wish to use it directly to carry out non-standard rotation tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_data(event_times, full_period)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate_data_+3A_event_times">event_times</code></td>
<td>
<p>A vector of the times of events. Times can be given in any format. If <code>event_times</code> should not be sorted prior to analysis (for example, if times are given in hours of the day and the times in the dataset span several days), be sure to specify <code>skip_sort=TRUE</code>.</p>
</td></tr>
<tr><td><code id="rotate_data_+3A_full_period">full_period</code></td>
<td>
<p>A length two vector giving the start and end times of the full period during which events in event_times might have occurred. If missing, default is range(<code>event_times</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rotation test was applied in Miller et al. 2004 and detailed in DeRuiter and Solow 2008. This test is a
variation on standard randomization or permutation tests that is appropriate for time-series of non-independent events
(for example, time series of behavioral events that tend to occur in clusters). This implementation of the rotation test compares a test statistic (some summary of
an &quot;experimental&quot; time-period) to its expected value during non-experimental periods. Instead of resampling random subsets of observations from the original dataset,
the rotation test samples many contiguous blocks from the original data, each the same duration as the experimental period. The summary statistic,
computed for these &quot;rotated&quot; samples, provides a distribution to which the test statistic from the data can be compared.
</p>


<h3>Value</h3>

<p>A vector of numeric values the same length as <code>event_times</code> generated by rotating the event times by a random amount
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_events &lt;- 1500 * stats::runif(10) # 10 events at "times" between 0 and 1500
my_events
rotated_events &lt;- rotate_data(my_events, full_period = c(0, 1500))
rotated_events
</code></pre>

<hr>
<h2 id='rotate_vecs'>Rotate triaxial vector measurements</h2><span id='topic+rotate_vecs'></span>

<h3>Description</h3>

<p>This function is used to rotate triaxial vector measurements from one frame to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_vecs(V, Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate_vecs_+3A_v">V</code></td>
<td>
<p>is a tag data structure, a 3-element vector or a 3-column matrix of vector measurements for example V could be from an accelerometer or magnetometer.</p>
</td></tr>
<tr><td><code id="rotate_vecs_+3A_q">Q</code></td>
<td>
<p>is the rotation matrix. If Q is a single 3x3 matrix, the same rotation is applied to all vectors in V. If Q is a 3x3xn matrix where n is the number of rows in V, a different transformation given by Q[,, k] is applied to each row of V.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The rotated vector or matrix with the same size as the input V.
</p>


<h3>Note</h3>

<p>Frame: This function makes no assumptions about frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- (pi / 180) * matrix(c(25, -60, 33), ncol = 3)
Q &lt;- euler2rotmat(x[, 1], x[, 2], x[, 3])
V &lt;- rotate_vecs(c(0.77, -0.6, -0.22), Q)

</code></pre>

<hr>
<h2 id='rotation_test'>Carry out a rotation randomization test.</h2><span id='topic+rotation_test'></span>

<h3>Description</h3>

<p>Carry out a rotation test (as applied in Miller et al. 2004 and detailed in DeRuiter and Solow 2008). This test is a
variation on standard randomization or permutation tests that is appropriate for time-series of non-independent events
(for example, time series of behavioral events that tend to occur in clusters).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotation_test(
  event_times,
  exp_period,
  full_period = range(event_times, na.rm = TRUE),
  n_rot = 10000,
  ts_fun = length,
  skip_sort = FALSE,
  conf_level = 0.95,
  return_rot_stats = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotation_test_+3A_event_times">event_times</code></td>
<td>
<p>A vector of the times of events. Times can be given in any format. If <code>event_times</code> should not be sorted prior to analysis (for example, if times are given in hours of the day and the times in the dataset span several days), be sure to specify <code>skip_sort=TRUE</code>.</p>
</td></tr>
<tr><td><code id="rotation_test_+3A_exp_period">exp_period</code></td>
<td>
<p>A two-column vector, matrix, or data frame specifying the start and end times of the &quot;experimental&quot; period for the test. If a matrix or data frame is provided, one column should be start time(s) and the other end time(s). 
Note that all data that falls into any experimental period will be concatenated and passed to <code>ts_fun</code>. If finer control is desired, consider writing your own test using the underlying function <code>rotate_data</code>.</p>
</td></tr>
<tr><td><code id="rotation_test_+3A_full_period">full_period</code></td>
<td>
<p>A length two vector giving the start and end times of the full period during which events in event_times might have occurred. If missing, default is range(<code>event_times</code>).</p>
</td></tr>
<tr><td><code id="rotation_test_+3A_n_rot">n_rot</code></td>
<td>
<p>Number of rotations (randomizations) to carry out. Default is <code>n_rot=10000</code>.</p>
</td></tr>
<tr><td><code id="rotation_test_+3A_ts_fun">ts_fun</code></td>
<td>
<p>A function to compute the test statistic. Input provided to this function will be the times of events that occur during the &quot;experimental&quot; period.  The default function is <code>length</code> - in other words, the default test statistic is the number of events that happen during the experimental period.</p>
</td></tr>
<tr><td><code id="rotation_test_+3A_skip_sort">skip_sort</code></td>
<td>
<p>Logical. Should times be sorted in ascending order? Default is <code>skip_sort=FALSE</code>.</p>
</td></tr>
<tr><td><code id="rotation_test_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level to be used for the bootstrap CI calculation, specified as a proportion. (default is <code>conf_level=0.95</code>, or 95% confidence.)</p>
</td></tr>
<tr><td><code id="rotation_test_+3A_return_rot_stats">return_rot_stats</code></td>
<td>
<p>Logical. Should output include the test statistics computed for each rotation of the data? Default is <code>return_rot_stats=FALSE</code>.</p>
</td></tr>
<tr><td><code id="rotation_test_+3A_...">...</code></td>
<td>
<p>Additional inputs to be passed to <code>ts_fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation of the rotation test compares a test statistic (some summary of
an &quot;experimental&quot; time-period) to its expected value during non-experimental periods. Instead of resampling random subsets of observations from the original dataset,
the rotation test samples many contiguous blocks from the original data, each the same duration as the experimental period. The summary statistic,
computed for these &quot;rotated&quot; samples, provides a distribution to which the test statistic from the data can be compared.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<ul>
<li> <p><strong>result</strong>, A one-row data frame with rows:
</p>

<ul>
<li> <p><strong>statistic: </strong> Test statistic (from original data)
</p>
</li>
<li> <p><strong>p_value: </strong> P-value of the test (2-sided)
</p>
</li>
<li> <p><strong>n_rot: </strong> Number of rotations
</p>
</li>
<li> <p><strong>CI_low: </strong> Lower bound on rotation-resampling percentile-based confidence interval
</p>
</li>
<li> <p><strong>CI_up: </strong> Upper bound on rotation-resampling percentile-based confidence interval
</p>
</li>
<li> <p><strong>conf_level: </strong> Confidence level, as a proportion
</p>
</li></ul>

</li>
<li> <p><strong>rot_stats</strong> (If <code>return_rot_stats</code> is TRUE), a vector of <code>n_rot</code> statistics from the rotated datasets
</p>
</li></ul>



<h3>References</h3>

<p>Miller, P. J. O., Shapiro, A. D., Tyack, P. L. and Solow, A. R. (2004). Call-type matching in vocal exchanges of free-ranging resident killer whales, Orcinus orca. Anim. Behav. 67, 1099–1107.
</p>
<p>DeRuiter, S. L. and Solow, A. R. (2008). A rotation test for behavioural point-process data. Anim. Behav. 76, 1103–1452.
</p>


<h3>See Also</h3>

<p>Advanced users seeking more flexibility may want to use the underlying function <code><a href="#topic+rotate_data">rotate_data</a></code> to carry out customized rotation resampling. <code><a href="#topic+rotate_data">rotate_data</a></code> generates one rotated dataset from <code>event_times</code> and <code>exp_period</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rotation_test(
  event_times =
    2000 * runif(500),
  exp_period = c(100, 200),
  return_rot_stats = TRUE, ts_fun = mean
)
</code></pre>

<hr>
<h2 id='rotmat2euler'>Decompose a rotation (or direction cosine) matrix</h2><span id='topic+rotmat2euler'></span>

<h3>Description</h3>

<p>This function is used to decompose a rotation (or direction cosine) matrix into Euler angles, pitch, roll, and heading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotmat2euler(Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotmat2euler_+3A_q">Q</code></td>
<td>
<p>is a 3x3 rotation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 1x3 vector containing: prh=[p,r,h] where p is the pitch angle in radians, r is the roll angle in radians, and h is the heading or yaw angle in radians.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set &lt;- matrix(c(0.6765458, 0.7227523, 0.1411200,
0.3675912, -0.4975063, 0.7857252,
0.6380928, -0.4797047, -0.6022632), nrow = 3, ncol = 3)
rotmat2euler(set)
</code></pre>

<hr>
<h2 id='rough_cal_3d'>Estimate scale factors and offsets</h2><span id='topic+rough_cal_3d'></span>

<h3>Description</h3>

<p>This function is used to estimate scale factors and offsets for measurements from a triaxial field sensor. This function estimates the scale factor needed to make the magnitude of X close to the expected field strength. It then calls fix_offset_3d to correct any offset errors in X. This function does not try to optimize the results. See spherical_cal for a more powerful data-driven calibration method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rough_cal_3d(X, fstr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rough_cal_3d_+3A_x">X</code></td>
<td>
<p>A sensor structure or matrix containing measurements from a triaxial field sensor such as an accelerometer or magnetometer. X can be in any units and frame.</p>
</td></tr>
<tr><td><code id="rough_cal_3d_+3A_fstr">fstr</code></td>
<td>
<p>The expected field strength at the measurement location in the same units as X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 elements:
</p>

<ul>
<li><p><strong>X: </strong> A sensor structure or matrix containing the adjusted triaxial sensor measurements. It is the same size and has the same sampling rate and units as the input data. If the input is a sensor structure, the output will be also.
</p>
</li>
<li><p><strong>G: </strong> A list of calibration information containing one field: G$poly, a 3x2 matrix. Rows correspond to X,Y,Z axes. with one column for each of the X, Y, Z axes. The first column of G$poly contains scale factors and second column of G$poly is the offset added to each column of X after scaling. 
</p>
</li></ul>



<h3>Note</h3>

<p>This function requires a lot of data as it is looking for extreme values in each axis. A minimum data size of 1000 samples should be used. This function is only usable for field sensors. It will not work for gyroscope data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BW &lt;- beaked_whale
plot(x = c(1:length(BW$M$data)), y = BW$M$data)
rcal &lt;- rough_cal_3d(BW$M$data, fstr = 38.2)
cal &lt;- list(x = c(1:length(rcal$X)), y = rcal$X)
plot(cal)
</code></pre>

<hr>
<h2 id='save_nc'>Save a tag dataset to a netCDF file.</h2><span id='topic+save_nc'></span>

<h3>Description</h3>

<p>This function saves a tag dataset to a netCDF file (this is an archival file format supported by the tagtools package and suitable for submission to online data archives).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_nc(file, X, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_nc_+3A_file">file</code></td>
<td>
<p>The name of the data and metadata file to be written. If <code>file</code> does not include a .nc suffix, this will be added automatically.</p>
</td></tr>
<tr><td><code id="save_nc_+3A_x">X</code></td>
<td>
<p>An <code>animaltag</code> object, or a list of tag sensor and/or metadata lists. Alternatively, sensor and metadata lists may be input as multiple separate unnamed inputs. Only these kind of variables can be saved
in a NetCDF file because the supporting information in these structures is
needed to describe the contents of the file. For non-archive and non-portable
storage of variables, consider using <code><a href="base.html#topic+save">save</a></code> or various functions to write data to text files.</p>
</td></tr>
<tr><td><code id="save_nc_+3A_...">...</code></td>
<td>
<p>Additional sensor or metadata lists, if user has not bundled them all into a list already but is providing individual structures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: this will overwrite any previous NetCDF file with the same name. The file is assumed to be in the current working directory unless <code>file</code> includes file path information.
</p>


<h3>Value</h3>

<p>no return; saves a dataset to an nc file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
BW &lt;- beaked_whale
save_nc("beaked_whale_test", BW)


</code></pre>

<hr>
<h2 id='sens_struct'>Generate a sensor structure from a sensor data vector or matrix.</h2><span id='topic+sens_struct'></span>

<h3>Description</h3>

<p>Generate a sensor structure from a sensor data vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sens_struct(
  data,
  sampling_rate = NULL,
  times = NULL,
  depid,
  type,
  unit = NULL,
  frame = NULL,
  name = NULL,
  start_offset = 0,
  start_offset_units = "second",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sens_struct_+3A_data">data</code></td>
<td>
<p>sensor data vector or matrix</p>
</td></tr>
<tr><td><code id="sens_struct_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>(optional) sensor data sampling rate in Hz</p>
</td></tr>
<tr><td><code id="sens_struct_+3A_times">times</code></td>
<td>
<p>(optional) is the time in seconds of each measurement in data for irregularly sampled data. The time reference (i.e., the 0 time) should be with respect to the start time of the deployment.</p>
</td></tr>
<tr><td><code id="sens_struct_+3A_depid">depid</code></td>
<td>
<p>string that provides a unique identifier for this tag deployment</p>
</td></tr>
<tr><td><code id="sens_struct_+3A_type">type</code></td>
<td>
<p>is a string containing the first few letters of the sensor type,
e.g., acc for acceleration. These will be matched to the list of
sensor names in the sensor_names.csv file. If more than one sensor
matches type, a warning will be given. type can be in upper or lower case.</p>
</td></tr>
<tr><td><code id="sens_struct_+3A_unit">unit</code></td>
<td>
<p>(optional) units in which data are sampled. Default determined by matching <code>type</code> with defaults in sensor_names.csv</p>
</td></tr>
<tr><td><code id="sens_struct_+3A_frame">frame</code></td>
<td>
<p>(optional) frame of reference for data axes, for example 'animal' or 'tag'. Default determined by matching <code>type</code> with defaults in sensor_names.csv.</p>
</td></tr>
<tr><td><code id="sens_struct_+3A_name">name</code></td>
<td>
<p>(optional) &quot;full name&quot; to assign to the variable. Default determined by matching <code>type</code> to defaults in sensor_names.csv/</p>
</td></tr>
<tr><td><code id="sens_struct_+3A_start_offset">start_offset</code></td>
<td>
<p>(optional) offset in start time for this sensor relative to start of tag recording. Defaults to 0.</p>
</td></tr>
<tr><td><code id="sens_struct_+3A_start_offset_units">start_offset_units</code></td>
<td>
<p>(optional) units of start_offset. default is 'second'.</p>
</td></tr>
<tr><td><code id="sens_struct_+3A_quiet">quiet</code></td>
<td>
<p>prints to screen if quiet is set to false</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sensor list with field <code>data</code> containing the data and with metadata fields pre-populated from the sensor_names.csv file. Change these manually as needed (or specify the relevant inputs to <code>sens_struct</code>) to the correct values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HB &lt;- harbor_seal
A &lt;- sens_struct(data=HB$A$data,sampling_rate=3,depid='md13_134a', type='acc', quiet=TRUE)

</code></pre>

<hr>
<h2 id='smooth'>Low pass filter a time series</h2><span id='topic+smooth'></span>

<h3>Description</h3>

<p>This function is used to low pass filter (smooth) a regularly-sampled time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_+3A_x">x</code></td>
<td>
<p>The signal to be filtered. It can be multi-channel with a signal in each column, e.g., an acceleration matrix. The number of samples (i.e., the number of rows in x) must be larger than the filter length, n.</p>
</td></tr>
<tr><td><code id="smooth_+3A_n">n</code></td>
<td>
<p>The smoothing parameter - use a larger number to smooth more. n must be greater than 1. Signal components above 1/n of the Nyquist frequency are filtered out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input signal has the first and fifth harmonic. Applying the low-pass filter removes most of the fifth harmonic so the output appears as a sinewave except for the first few samples which are affected by the filter startup transient. Smooth uses fir_nodelay to perform the filtering and so introduces no delay.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- sin((2 * pi * 0.05) %*% t(c(1:100))) + cos((2 * pi * 0.25) %*% t(c(1:100)))
x1 = c(1:length(y1))
plot(x = x1, y = y1)
y2 &lt;- smooth(x1, n = 4)
x2 = c(1:length(y2))
plot(x = x2, y = y2)

</code></pre>

<hr>
<h2 id='sound_speed'>Sound speed estimation</h2><span id='topic+sound_speed'></span>

<h3>Description</h3>

<p>This function is used to estimate the sound speed using Coppens equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sound_speed(temperature, D = NULL, S = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sound_speed_+3A_temperature">temperature</code></td>
<td>
<p>The temperature in degrees C</p>
</td></tr>
<tr><td><code id="sound_speed_+3A_d">D</code></td>
<td>
<p>(optional) The depth in meters (defaults to 1 m)</p>
</td></tr>
<tr><td><code id="sound_speed_+3A_s">S</code></td>
<td>
<p>The salinity in part-per-thousand (defaults to 35 ppt)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sound speed in m/s
</p>


<h3>Note</h3>

<p>Range of validity: temperature 0 to 35 °C, salinity 0 to 45 parts per thousand, depth 0 to 4000 m
</p>
<p>Source: http://resource.npl.co.uk/acoustics/techguides/soundseawater/content.html#UNESCO
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sound_speed(8, 1000, 34)
</code></pre>

<hr>
<h2 id='spectrum_level'>Compute the spectrum level of a signal x.</h2><span id='topic+spectrum_level'></span>

<h3>Description</h3>

<p>This function is used to compute the spectrum level of a signal x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectrum_level(x, nfft, sampling_rate, w, nov)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectrum_level_+3A_x">x</code></td>
<td>
<p>A vector containing the signal to be processed. For signals with multiple channels, each channel should be in a column of x.</p>
</td></tr>
<tr><td><code id="spectrum_level_+3A_nfft">nfft</code></td>
<td>
<p>The length of the fft to use. Choose a power of two for fastest operation. Default value is 512.</p>
</td></tr>
<tr><td><code id="spectrum_level_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate of x in Hz. Default value is 1. sampling_rate is the vector of frequencies at which SL is calculated.</p>
</td></tr>
<tr><td><code id="spectrum_level_+3A_w">w</code></td>
<td>
<p>The window length. The default value is nfft. If w&lt;nfft, each segment of w samples is zero-padded to nfft.</p>
</td></tr>
<tr><td><code id="spectrum_level_+3A_nov">nov</code></td>
<td>
<p>The number of samples to overlap each segment. The default value is half of the window length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 elements:
</p>

<ul>
<li><p><strong>SL: </strong>The spectrum level at each frequency in dB RMS re root-Hz. The spectrum is single-sided and extends to sampling_rate/2. The reference level is 1.0 (i.e., white noise with unit variance will have a spectrum level of 3-10*log10(sampling_rate). The 3dB is because both the negative and positive spectra are added together so that the total power in the signal is the same as the total power in the spectrum.
</p>
</li>
<li><p><strong>freq: </strong> The vector of frequencies at which SL is calculated.
</p>
</li></ul>



<h3>Note</h3>

<p>The spectrum is single-sided and extends to sampling_rate/2. The reference level is 1.0 (i.e., white noise with unit variance will have a spectrum level of 3-10*log10(sampling_rate). The 3dB is because both the negative and positive spectra are added together so that the total power in the signal is the same as the total power in the spectrum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BW &lt;- beaked_whale
list &lt;- spectrum_level(x = BW$P$data, nfft = 4, sampling_rate = BW$P$sampling_rate)

</code></pre>

<hr>
<h2 id='speed_from_depth'>Estimate the forward speed of a diving animal</h2><span id='topic+speed_from_depth'></span>

<h3>Description</h3>

<p>This function is used to estimate the forward speed of a diving animal by first computing the depth-rate (i.e., the first differential of the depth) and then correcting for the pitch angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>speed_from_depth(
  p,
  A = NULL,
  fs_p = NULL,
  fs_A = NULL,
  fc = 0.2,
  plim = 20/180 * pi
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="speed_from_depth_+3A_p">p</code></td>
<td>
<p>The depth vector (a regularly sampled time series) in meters. sampled at sampling_rate Hz. This can either be an animaltags sensor list, or a vector.</p>
</td></tr>
<tr><td><code id="speed_from_depth_+3A_a">A</code></td>
<td>
<p>(optional) A matrix or animaltags sensor data list containing acceleration data. If A is not provided then only vertical velocity is returned (same output as depth_rate()). Acceleration can be in any consistent unit, e.g., g or m/s^2. Acceleration data must have the same number of rows as p.</p>
</td></tr>
<tr><td><code id="speed_from_depth_+3A_fs_p">fs_p</code></td>
<td>
<p>(optional) The sampling rate of p in Hz (samples per second). Required only if p is vector rather than sensor data list.</p>
</td></tr>
<tr><td><code id="speed_from_depth_+3A_fs_a">fs_A</code></td>
<td>
<p>(optional) The sampling rate of A in Hz (samples per second). Required only if A is vector rather than sensor data list.</p>
</td></tr>
<tr><td><code id="speed_from_depth_+3A_fc">fc</code></td>
<td>
<p>(optional) Specifies the cut-off frequency of a low-pass filter to apply to p after computing depth-rate and to A before computing pitch. The filter cut-off frequency is in Hz. The filter length is 4*sampling_rate/fc. Filtering adds no group delay. If fc is empty or not given, the default value of 0.2 Hz (i.e., a 5 second time constant) is used.</p>
</td></tr>
<tr><td><code id="speed_from_depth_+3A_plim">plim</code></td>
<td>
<p>(optional) Minimum pitch angle, in radians, at which speed can be computed. Default: 0.3490659 radians = 20 degrees. Errors in speed estimation using this method increase strongly at low pitch angles. To avoid estimates with poor accuracy being used in later analyses, speed estimates at low pitch angles are replaced by NaN (not-a-number). The default threshold for this is 20 degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either forward speed or vertical speed:
</p>

<ul>
<li><p><strong>s: </strong> If both <code>p</code> and <code>A</code> are input, the forward speed estimate in m/s is returned
</p>
</li>
<li><p><strong>v: </strong> If only <code>p</code> is input, the depth-rate (or vertical velocity) in m/s is returned
</p>
</li></ul>



<h3>Note</h3>

<p>Output sampling rate is the same as the input sampling rate. If A and p are input and A has a higher sampling rate, then p and the output are interpolated to match A using <code><a href="#topic+interp2length">interp2length</a></code> .
</p>
<p>Frame: This function assumes a [north,east,up] navigation frame and a [forward,right,up] local frame. In these frames, a positive pitch angle is an anti-clockwise rotation around the y-axis. A descending animal will have a negative pitch angle.
</p>
<p>Forward velocity for animals could be negative if its vertical velocity is negative and pitch angle is positive, or, its vertical velocity is positive and pitch angle is negative. One could avoid getting negative forward velocity by taking the absolute value of the output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- speed_from_depth(harbor_seal$P, harbor_seal$A)
</code></pre>

<hr>
<h2 id='spherical_cal'>Deduce the calibration constants</h2><span id='topic+spherical_cal'></span>

<h3>Description</h3>

<p>This function is used to deduce the calibration constants for a triaxial field sensor, such as an accelerometer or magnetometer, based on movement data. This can be used to do a 'bench' calibration of a sensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spherical_cal(X, n = NULL, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spherical_cal_+3A_x">X</code></td>
<td>
<p>The segment of triaxial sensor data to calibrate. It must be a 3-column matrix. X can come from any triaxial field sensor and can be in any unit and any frame.</p>
</td></tr>
<tr><td><code id="spherical_cal_+3A_n">n</code></td>
<td>
<p>The target field magnitude e.g., 9.81 for accelerometer data using m/s^2 as the unit.</p>
</td></tr>
<tr><td><code id="spherical_cal_+3A_method">method</code></td>
<td>
<p>An optional string selecting the type of calibration. The default is to calibrate for offset and scaling only. Other options are: 'gain' adjust gain of axes 2 and 3 relative to 1, or 'cross' adjust gain and remove cross-axis correlations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reports the residual and the axial balance of the data.
A low residual e.g., &lt;5% indicates that the data can be calibrated
well and there is not much noise.
The axial balance indicates whether the movement in X is
suitable for data-driven calibration. If the movement covers all
directions fairly equally, the axial balance will be high.
A balance &lt;20 % may lead to unreliable calibration.
For bench calibrations, a high axial balance is achieved by
rotating the sensor through the full 3-dimensions.
Sampling rate and frame of Y are the same as the input data so
Y has the same size as X. The units of Y are the same as the units
used for n. If n is not specified, the units of Y are the same as
for the input data. It is a good idea to low-pass filter and/or
remove outliers from the sensor data before using this function
to reduce errors from specific acceleration and sensor noise.
</p>


<h3>Value</h3>

<p>A list with 2 elements:
</p>

<ul>
<li><p><strong>Y: </strong> The matrix of converted sensor values. These will have the same units as for input argument n. The size of Y is the same as the size of X and it has the same frame and sampling rate.
</p>
</li>
<li><p><strong>G: </strong> The calibration structure containing fields: G.poly is a matrix of polynomials. The first column of G.poly is the three scale factors applied to the columns of X. The second column is the offset added to each column of X after scaling. G.cross is a 3x3 matrix of cross-factors. If there are no cross-terms, this is the identity matrix. Off-axis terms correct for cross-axis sensitivity.
</p>
</li></ul>

<p>A message will also be printed to the screen presenting
</p>


<h3>Note</h3>

<p>This function uses a Simplex search for optimal calibration parameters and so can be slow if the data size is large.
For this reason it is most suitable for bench calibrations rather than
field data. This function is only usable for field sensors.
It will not work for gyroscope data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- spherical_cal(harbor_seal$A$data)

</code></pre>

<hr>
<h2 id='tag2animal'>Tag-frame to animal-frame conversion</h2><span id='topic+tag2animal'></span>

<h3>Description</h3>

<p>Convert tag frame measurements to animal frame using pre-determined tag orientation(s) on the animal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tag2animal(X, sampling_rate, OTAB, Ya = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tag2animal_+3A_x">X</code></td>
<td>
<p>Data from a triaxial sensor such as an accelerometer, magnetometer or a gyroscope. X can be a three column matrix or a sensor structure (<strong>not</strong> a data frame or tbl). In either case, X is in the tag frame, i.e., expressed in the canonical axes of the tag, not the animal. X can have any unit and any regular sampling rate (i.e., measurements are regularly sampled; equally spaced in time).</p>
</td></tr>
<tr><td><code id="tag2animal_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>(optional) The sampling rate of the sensor data in Hz (samples per second). This is only needed if X is not a sensor structure. If X is a sensor data list, sampling_rate is obtained from its metadata (X$sampling_rate).</p>
</td></tr>
<tr><td><code id="tag2animal_+3A_otab">OTAB</code></td>
<td>
<p>is a matrix defining the orientation of the tag on the animal as a function of time. Each row of OTAB is: <code>cue1, cue2, pitch, roll, heading</code>. (See <strong>Details</strong>.)</p>
</td></tr>
<tr><td><code id="tag2animal_+3A_ya">Ya</code></td>
<td>
<p>is an optional sensor structure in which the sensor data has already been
converted to the animal frame. The OTAB is extracted from this structure. This
is useful, for example, to replicate tag-to-animal conversions at different
sampling rates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the OTAB matrix to convert sensor data <code>X</code> from tag frame of reference to whale frame of reference.
Each row of OTAB is: <code>cue1, cue2, pitch, roll, heading</code>
where cue1 is the start time of a move in seconds with respect to the
start of X. cue2 is the end time of the move. If cue1 and cue2 are the
same, the move is instantaneous, otherwise a gradual move will be implemented
in which the orientation of the tag is linearly interpolated between the
previous and the new orientation.
The pitch, roll and heading angles describe the tag orientation on the
animal at the end of the move (angles are in radians).
The first row of OTAB must have cue1 and cue2 equal to 0 as this is the initial
orientation of the tag on the animal. Subsequent rows (if any) of OTAB describe
</p>


<h3>Value</h3>

<p>Xa,the sensor data in the animal frame, i.e., rotated to correct for the tag
orientation on the animal. If X is a sensor structure, Xa will also be one. In this
case the structure elements 'frame' and 'name' will be changed. The OTAB will also
be added to the structure.
</p>


<h3>See Also</h3>

<p>[prh_predictor1], [prh_predictor2]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Aw &lt;- tag2animal(beaked_whale$A, OTAB = matrix(c(0,0,0.1, 0.04, -0.2), nrow = 1))

</code></pre>

<hr>
<h2 id='tortuosity'>Measure tortuosity index</h2><span id='topic+tortuosity'></span>

<h3>Description</h3>

<p>This function is used to measure the tortuosity of a regularly sampled horizontal track. Tortuosity can be measured in a number of ways. This function compares the stretched-out track length (STL) over an interval of time with the distance made good (DMG, i.e., the distance actually covered in the interval). The index returned is (STL-DMG)/STL which is 0 for straightline movement and 1 for extreme circular movement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tortuosity(track, sampling_rate, intvl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tortuosity_+3A_track">track</code></td>
<td>
<p>Contains the animal positions in a local horizontal plane. The track parameter has a row for each position and two columns: northing and easting. The positions can be in any consistent spatial unit, e.g., metres, km, nautical miles, and are referenced to an arbitrary 0,0 location. track object cannot be in degrees as the distance equivalent to a degree latitude is not the same as for a degree longitude.</p>
</td></tr>
<tr><td><code id="tortuosity_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>The sampling rate of the positions in Hertz (samples per second).</p>
</td></tr>
<tr><td><code id="tortuosity_+3A_intvl">intvl</code></td>
<td>
<p>The time interval in seconds over which tortuosity is calculated. This should be chosen according to the scale of interest, e.g., the typical length of a foraging bout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The tortuosity index which is between 0 and 1 as described above. t contains a value for each period of intvl seconds.
</p>


<h3>Note</h3>

<p>This tortuosity index is fairly insensitive to speed so if track is produced by dead-reckoning (e.g., using ptrack or htrack), the speed estimate is not important. Also the frame of track is not important as long as the two axes (nominally called northing and easting) used to describe the positions are perpendicular.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BW &lt;- beaked_whale
track &lt;- ptrack(
  A = BW$A$data, M = BW$M$data, s = 3,
  sampling_rate = BW$A$sampling_rate,
  fc = NULL, return_pe = TRUE
)$track
tortuosity &lt;- tortuosity(track, sampling_rate = BW$A$sampling_rate, intvl = 25)
</code></pre>

<hr>
<h2 id='track3D'>Reconstruct a track from pitch, heading and depth data, given a starting position</h2><span id='topic+track3D'></span>

<h3>Description</h3>

<p>The track3D function will use data from a tag to reconstruct a track by fitting a state space model using a Kalman filter. If no x,y observations are provided then this corresponds to a pseudo-track obtained via dead reckoning and extreme care is required in interpreting the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track3D(
  z,
  phi,
  psi,
  sf,
  r = 0.001,
  q1p = 0.02,
  q2p = 0.08,
  q3p = 1.6e-05,
  tagonx,
  tagony,
  enforce = TRUE,
  x,
  y
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="track3D_+3A_z">z</code></td>
<td>
<p>A vector with depth over time (in meters, an observation)</p>
</td></tr>
<tr><td><code id="track3D_+3A_phi">phi</code></td>
<td>
<p>A vector with pitch over time (in Radians, assumed as a known covariate)</p>
</td></tr>
<tr><td><code id="track3D_+3A_psi">psi</code></td>
<td>
<p>A vector with heading over time (in Radians, assumed as a known covariate)</p>
</td></tr>
<tr><td><code id="track3D_+3A_sf">sf</code></td>
<td>
<p>A scalar defining the sampling rate (in Hz)</p>
</td></tr>
<tr><td><code id="track3D_+3A_r">r</code></td>
<td>
<p>Observation error</p>
</td></tr>
<tr><td><code id="track3D_+3A_q1p">q1p</code></td>
<td>
<p>speed state error</p>
</td></tr>
<tr><td><code id="track3D_+3A_q2p">q2p</code></td>
<td>
<p>depth state error</p>
</td></tr>
<tr><td><code id="track3D_+3A_q3p">q3p</code></td>
<td>
<p>x and y state error</p>
</td></tr>
<tr><td><code id="track3D_+3A_tagonx">tagonx</code></td>
<td>
<p>Easting of starting position (in meters, so requires projected data)</p>
</td></tr>
<tr><td><code id="track3D_+3A_tagony">tagony</code></td>
<td>
<p>Northing of starting position (in meters, so requires projected data)</p>
</td></tr>
<tr><td><code id="track3D_+3A_enforce">enforce</code></td>
<td>
<p>If TRUE (the default), then speed and depth are kept strictly positive</p>
</td></tr>
<tr><td><code id="track3D_+3A_x">x</code></td>
<td>
<p>Direct observations of Easting (in meters, so requires projected data)</p>
</td></tr>
<tr><td><code id="track3D_+3A_y">y</code></td>
<td>
<p>Direct observations of Northing (in meters, so requires projected data)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 10 elements:
</p>

<ul>
<li><p><strong>p: </strong> the smoothed speeds
</p>
</li>
<li><p><strong>fit.ks: </strong> the fitted speeds
</p>
</li>
<li><p><strong>fit.kd: </strong> the fitted depths
</p>
</li>
<li><p><strong>fit.xs: </strong> the fitted xs
</p>
</li>
<li><p><strong>fit.ys: </strong> the fitted ys
</p>
</li>
<li><p><strong>fit.rd: </strong> the smoothed depths
</p>
</li>
<li><p><strong>fit.rx: </strong> the smoothed xs
</p>
</li>
<li><p><strong>fit.ry: </strong> the smoothed ys
</p>
</li>
<li><p><strong>fit.kp: </strong> the kalman a posteriori state covariance
</p>
</li>
<li><p><strong>fit.ksmo: </strong> the kalman smoother variance
</p>
</li></ul>



<h3>Note</h3>

<p>Output sampling rate is the same as the input sampling rate.
</p>
<p>Frame: This function assumes a [north,east,up] navigation frame and a [forward,right,up] local frame. In these frames, a positive pitch angle is an anti-clockwise rotation around the y-axis. A positive roll angle is a clockwise rotation around the x-axis. A descending animal will have a negative pitch angle while an animal rolled with its right side up will have a positive roll angle.
</p>
<p>This function output can be quite sensitive to the inputs used, namely those that define the relative weight given to the existing data, in particular regarding (x,y)=(lat,long); increasing q3p, the (x,y) state variance, will increase the weight given to independent observations of (x,y), say from GPS readings
</p>


<h3>See Also</h3>

<p><code><a href="#topic+m2h">m2h</a>,<a href="#topic+a2pr">a2pr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- a2pr(A = beaked_whale$A$data)
h &lt;- m2h(M = beaked_whale$M$data, A = beaked_whale$A$data)
track &lt;- track3D(z = beaked_whale$P$data, phi = p$p, 
psi = h$h, sf = beaked_whale$A$sampling_rate, 
r = 0.001, q1p = 0.02, q2p = 0.08, q3p = 1.6e-05, 
tagonx = 1000, tagony = 1000, enforce = TRUE, x = NA, y = NA)
oldpar &lt;- graphics::par(no.readonly = TRUE)
graphics::par(mfrow = c(2, 1), mar = c(4, 4, 0.5, 0.5))
plot(-beaked_whale$P$data, pch = ".", ylab = "Depth (m)", 
xlab = "Time")
plot(track$fit.rx, track$fit.ry, xlab = "X", 
ylab = "Y", pch = ".")
points(track$fit.rx[c(1, length(track$fit.rx))], 
track$fit.ry[c(1, length(track$fit.rx))], pch = 21, bg = 5:6)
legend("bottomright", cex = 0.7, legend = c("Start", "End"), 
col = c(5, 6), pt.bg = c(5, 6), pch = c(21, 21))
graphics::par(oldpar)

</code></pre>

<hr>
<h2 id='undo_cal'>Undo calibrations steps</h2><span id='topic+undo_cal'></span>

<h3>Description</h3>

<p>This function is used to undo any calibration steps that have been applied to sensor data. This will reverse any re-mapping, scaling and offset adjustments that have been applied to the data, reverting the sensor data to the state it was when read in from the source (excluding any filtering or decimation steps).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undo_cal(X, temperature)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="undo_cal_+3A_x">X</code></td>
<td>
<p>A sensor list or set of sensor lists in the tag frame, i.e., with calibrations applied.</p>
</td></tr>
<tr><td><code id="undo_cal_+3A_temperature">temperature</code></td>
<td>
<p>A vector of temperature measurements with the same number of samples and sampling rate as the data in the input sensor data structure X. The temperature parameter indicates the temperature experienced by the sensor during data collection (not necessarily the ambient temperature experienced by the animal), and may affect calibration because many sensors’ output values change depending on the temperature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sensor list or set of sensor lists reverted to the sensor frame, i.e., without calibrations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BW &lt;- beaked_whale
no_cal &lt;- undo_cal(BW)

</code></pre>

<hr>
<h2 id='zero_crossings'>Find zero-crossings in a vector</h2><span id='topic+zero_crossings'></span>

<h3>Description</h3>

<p>This function is used to find the zero-crossings in a vector using a hysteretic detector. This is useful, e.g., to locate cyclic postural changes due to propulsion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_crossings(x, TH, Tmax = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zero_crossings_+3A_x">x</code></td>
<td>
<p>A vector of data. This can be from any sensor and with any sampling rate.</p>
</td></tr>
<tr><td><code id="zero_crossings_+3A_th">TH</code></td>
<td>
<p>The magnitude threshold for detecting a zero-crossing. A zero-crossing is only detected when values in x pass from -TH to +TH or vice versa.</p>
</td></tr>
<tr><td><code id="zero_crossings_+3A_tmax">Tmax</code></td>
<td>
<p>(optional) The maximum duration in samples between threshold crossings. To be accepted as a zero-crossing, the signal must pass from below -TH to above TH, or vice versa, in no more than Tmax samples. This is useful to eliminate slow transitions. If Tmax is not given, there is no limit on the number of samples between threshold crossings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>

<ul>
<li><p><strong>K: </strong> A vector of cues (in samples) to zero-crossings in x.
</p>
</li>
<li><p><strong>s: </strong> A vector containing the sign of each zero-crossing (1 = positive-going, -1 = negative-going). s is the same size as K. If no zero-crossings are found, K and s will be empty
</p>
</li>
<li><p><strong>KK: </strong> The zero crossings of the vertical velocity vector
</p>
</li></ul>



<h3>Note</h3>

<p>Frame: This function assumes a [north,east,up] navigation frame and a [forward,right,up] local frame. Both A and M must be rotated if needed to match the animal's cardinal axes otherwise the track will not be meaningful.
</p>
<p>CAUTION: dead-reckoned tracks are usually very inaccurate. They are useful to get an idea of HOW animals move rather than WHERE they go. 
Few animals probably travel in exactly the direction of their longitudinal axis and anyway measuring the precise orientation of the longitudinal axis of a non-rigid animal is fraught with error. 
Moreover, if there is net flow in the medium, the animal will be advected by the flow in addition to its autonomous movement. For swimming animals this can lead to substantial errors. 
The forward speed is assumed to be  with respect to the medium so the track derived here is NOT the 'track-made-good', i.e., the geographic movement of the animal. It estimates the movement of the animal with respect to the medium. 
There are numerous other sources of error so use at your own risk!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- zero_crossings(sin(2 * pi * 0.033 * c(1:100)), 0.3)
s &lt;- c(-1, 1, -1, 1, -1, 1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
