<!DOCTYPE html><html lang="en"><head><title>Help for package bayesMig</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesMig}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesMig-package'><p>Bayesian Projection of Migration</p></a></li>
<li><a href='#convert.mig.trajectories'><p>Converting Trajectories of Migration Rates into ACSII Files</p></a></li>
<li><a href='#get.mig.convergence'><p>Accessing Convergence Diagnostics Object</p></a></li>
<li><a href='#get.mig.mcmc'><p>Access MCMC results</p></a></li>
<li><a href='#get.mig.parameter.traces'><p>Accessing MCMC Parameter Traces</p></a></li>
<li><a href='#get.mig.prediction'><p>Access Prediction Object</p></a></li>
<li><a href='#get.mig.trajectories'><p>Accessing Trajectories of Net Migration Rate</p></a></li>
<li><a href='#mig.coda.list.mcmc'><p>Conversion to coda-formatted objects</p></a></li>
<li><a href='#mig.diagnose'><p>MCMC convergence diagnostics</p></a></li>
<li><a href='#mig.map'><p>World Map of Net Migration Rate</p></a></li>
<li><a href='#mig.median.set'><p>Adjusting the Projection Medians</p></a></li>
<li><a href='#mig.parameter.names'><p>Accessing Parameter Names</p></a></li>
<li><a href='#mig.pardensity.plot'><p>Plotting MCMC Parameter Density</p></a></li>
<li><a href='#mig.partraces.plot'><p>Plotting MCMC Parameter Traces</p></a></li>
<li><a href='#mig.predict'><p>Generate posterior trajectories of net migration rates</p></a></li>
<li><a href='#mig.trajectories.plot'><p>Output of posterior distribution of migration trajectories</p></a></li>
<li><a href='#mig.write.projection.summary'><p>Writing Projection Summary Files</p></a></li>
<li><a href='#run.mig.mcmc'><p>Run Markov chain Monte Carlo for parameters of net migration rate model</p></a></li>
<li><a href='#store.bayesMig.convergence'><p>Internal Functions and datasets of bayesMig</p></a></li>
<li><a href='#summary.bayesMig.convergence'><p>Summary of Convergence Diagnostics</p></a></li>
<li><a href='#summary.bayesMig.mcmc'><p>Summary Statistics for Migration Markov Chain Monte Carlo</p></a></li>
<li><a href='#summary.bayesMig.prediction'><p>Summary of Prediction of Net Migration Rate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Projection of Migration</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), bayesTFR (&ge; 7.4.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, truncnorm, wpp2019, data.table</td>
</tr>
<tr>
<td>Description:</td>
<td>Producing probabilistic projections of net migration rate for all countries of the world
    or for subnational units using a Bayesian hierarchical model by Azose an Raftery (2015) &lt;<a href="https://doi.org/10.1007%2Fs13524-015-0415-0">doi:10.1007/s13524-015-0415-0</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://bayespop.csss.washington.edu">http://bayespop.csss.washington.edu</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-09 01:18:27 UTC; hana</td>
</tr>
<tr>
<td>Author:</td>
<td>Jon Azose [aut],
  Hana Sevcikova [aut, cre],
  Adrian Raftery [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hana Sevcikova &lt;hanas@uw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-09 11:20:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesMig-package'>Bayesian Projection of Migration</h2><span id='topic+bayesMig-package'></span><span id='topic+bayesMig'></span>

<h3>Description</h3>

<p>Collection of functions for making probabilistic projections of net migration rate for all countries of the world,
using a Bayesian hierarchical model (BHM) and the United Nations demographic time series. The model can be also applied
to user-defined data for other locations, such as subnational units.
Methodological details are provided in Azose &amp; Raftery (2015). The projected rates can be used
as input to population projections generated via the <span class="pkg">bayesPop</span> package.
</p>


<h3>Details</h3>

<p>The package is implemented in a similar way as the <span class="pkg">bayesTFR</span>
package and thus, many functions have their equivalents in <span class="pkg">bayesTFR</span>.
The main functions of the package are:
</p>

<ul>
<li> <p><code><a href="#topic+run.mig.mcmc">run.mig.mcmc</a></code>: Runs a Markov Chain Monte Carlo (MCMC) simulation.
It results in posterior samples of the model parameters.
</p>
</li>
<li> <p><code><a href="#topic+mig.predict">mig.predict</a></code>: Using the posterior parameter samples, trajectories of future
net migration rates are generated for all countries or given locations.
</p>
</li></ul>

<p>The following functions can be used to analyze results:
</p>

<ul>
<li> <p><code><a href="#topic+mig.trajectories.plot">mig.trajectories.plot</a></code>: Shows the posterior trajectories for a given location, including the median and given probability intervals.
</p>
</li>
<li> <p><code><a href="#topic+mig.trajectories.table">mig.trajectories.table</a></code>: Shows a tabular form of the posterior trajectories for a given location.
</p>
</li>
<li> <p><a href="#topic+mig.map">mig.map</a>, <a href="#topic+mig.ggmap">mig.ggmap</a> and <a href="#topic+mig.map.gvis">mig.map.gvis</a>: Show a world map of migration rates
for a given projection or observed period, or for country-specific parameter estimates.
</p>
</li>
<li> <p><code><a href="#topic+mig.partraces.plot">mig.partraces.plot</a></code> and <code><a href="#topic+mig.partraces.cs.plot">mig.partraces.cs.plot</a></code>: Plot the MCMC traces
of country-independent parameters and country-specific parameters, respectively.
</p>
</li>
<li> <p><code><a href="#topic+mig.pardensity.plot">mig.pardensity.plot</a></code> and <code><a href="#topic+mig.pardensity.cs.plot">mig.pardensity.cs.plot</a></code>: Plot the posterior density of the
country-independent parameters and country-specific parameters, respectively.
</p>
</li>
<li> <p><code><a href="#topic+summary.bayesMig.mcmc.set">summary.bayesMig.mcmc.set</a></code>: Summary method for the MCMC results.
</p>
</li>
<li> <p><code><a href="#topic+summary.bayesMig.prediction">summary.bayesMig.prediction</a></code>: Summary method for the prediction results.
</p>
</li></ul>

<p>For MCMC diagnostics, function <code><a href="#topic+mig.coda.list.mcmc">mig.coda.list.mcmc</a></code> creates an object of type
&ldquo;mcmc.list&rdquo; that can be used with the <span class="pkg">coda</span> package.
Furthermore, function <code><a href="#topic+mig.diagnose">mig.diagnose</a></code> analyzes the MCMCs using the
Raftery diagnostics implemented in the <span class="pkg">coda</span> package and gives information
about parameters that did not converge.
</p>
<p>Existing results can be accessed using the <code><a href="#topic+get.mig.mcmc">get.mig.mcmc</a></code> (estimation) and
<code><a href="#topic+get.mig.prediction">get.mig.prediction</a></code> (prediction) functions.
Existing convergence diagnostics can be accessed using the <code><a href="#topic+get.mig.convergence">get.mig.convergence</a></code> and
<code><a href="#topic+get.mig.convergence.all">get.mig.convergence.all</a></code> functions.
</p>
<p>Historical data on migration rates are taken from the <span class="pkg">wpp2019</span> (default),
<a href="https://github.com/PPgp/wpp2024"><span class="pkg">wpp2024</span></a> , <a href="https://github.com/PPgp/wpp2022"><span class="pkg">wpp2022</span></a>
or <span class="pkg">wpp2017</span> package,
depending on users settings. Alternatively, users can input their own data. These can be either
5-year or annual time series. An example file with historical annual US migration rates is included
in the package. Its usage is shown in the Example of <code><a href="#topic+mig.predict">mig.predict</a></code>.
</p>


<h3>Note</h3>

<p>As this package has been designed for simulating migration on a national level, many
functions use arguments and terminology related to countries. However, a &ldquo;country&rdquo;
is to be interpreted as any location included in the simulation.
</p>


<h3>Author(s)</h3>

<p>Jon Azose, Hana Sevcikova and Adrian Raftery
</p>
<p>Maintainer: Hana Sevcikova <a href="mailto:hanas@uw.edu">hanas@uw.edu</a>
</p>


<h3>References</h3>

<p>Azose, J. J., &amp; Raftery, A. E. (2015).
Bayesian probabilistic projection of international migration. Demography, 52(5), 1627-1650.
<a href="https://doi.org/10.1007/s13524-015-0415-0">doi:10.1007/s13524-015-0415-0</a>.
</p>
<p>Azose, J.J., Ševčíková, H., Raftery, A.E. (2016): Probabilistic population projections with migration uncertainty.
Proceedings of the National Academy of Sciences 113:6460–6465. <a href="https://doi.org/10.1073/pnas.1606119113">doi:10.1073/pnas.1606119113</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="http://bayespop.csss.washington.edu">http://bayespop.csss.washington.edu</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Run a real simulation (can take long time)
sim.dir &lt;- tempfile()
m &lt;- run.mig.mcmc(nr.chains = 4, iter = 10000, thin = 10, output.dir = sim.dir,
        verbose.iter = 1000)

# Prediction for all countries 
# (use argument save.as.ascii for passing predictions into bayesPop)
pred &lt;- mig.predict(sim.dir = sim.dir, nr.traj = 1000, burnin = 1000)

# Explore results
summary(pred, country = "Germany")
mig.trajectories.plot(pred, country = "Germany", nr.traj = 50)

# Check convergence diagnostics
mig.diagnose(sim.dir, burnin = 4000, thin = 1)

unlink(sim.dir, recursive = TRUE)
# For annual projections on sub-national level, see ?mig.predict.

## End(Not run)

</code></pre>

<hr>
<h2 id='convert.mig.trajectories'>Converting Trajectories of Migration Rates into ACSII Files</h2><span id='topic+convert.mig.trajectories'></span>

<h3>Description</h3>

<p>Converts trajectories of the net migration rates stored 
in a binary format into two CSV files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.mig.trajectories(
  sim.dir = NULL,
  n = 1000,
  output.dir = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.mig.trajectories_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory containing the prediction object. It should be the same as
the <code>output.dir</code> argument in <code><a href="#topic+mig.predict">mig.predict</a></code>.</p>
</td></tr>
<tr><td><code id="convert.mig.trajectories_+3A_n">n</code></td>
<td>
<p>Number of trajectories to be stored. It can be either a single number 
or the word &ldquo;all&rdquo; in which case all available trajectories are converted.
If the number is smaller than the number of trajectories available 
in the prediction object, they are selected by equal spacing.</p>
</td></tr>
<tr><td><code id="convert.mig.trajectories_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which the resulting files will be stored. 
If it is <code>NULL</code>, the same directory is used as for the prediction.</p>
</td></tr>
<tr><td><code id="convert.mig.trajectories_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. Switches log messages on and off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates two files. First, &ldquo;ascii_trajectories.csv&rdquo;
is a comma-separated table with the following columns: 
</p>

<dl>
<dt>&ldquo;LocID&rdquo;: </dt><dd><p>country code</p>
</dd> 
<dt>&ldquo;Period&rdquo;: </dt><dd><p>prediction interval, e.g. 2015-2020</p>
</dd> 
<dt>&ldquo;Year&rdquo;: </dt><dd><p>middle year of the prediction interval</p>
</dd>
<dt>&ldquo;Trajectory&rdquo;: </dt><dd><p>identifier of the trajectory</p>
</dd>
<dt>&ldquo;mig&rdquo;: </dt><dd><p>net migration rate</p>
</dd>
</dl>

<p>The second file is called &ldquo;ascii_trajectories_wide.csv&rdquo;, also 
a comma-separated table and it contains the same information as above 
but in a wide format. I.e. the data for one country are 
ordered in columns, thus, there is one column per country. The country columns 
are ordered alphabetically. 
</p>
<p>If the prediction object has been adjusted via any of the <a href="#topic+mig.median.set">adjustment functions</a>, 
the exported trajectories are also adjusted.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Note</h3>

<p>This function is automatically called from the <code><a href="#topic+mig.predict">mig.predict</a></code> 
function, therefore in standard cases it will not be needed to call it directly. 
However, it can be useful for example, if different number of trajectories are to be converted, 
without having to re-run the prediction, or if the trajectories were adjusted.
</p>


<h3>See Also</h3>

<p><code><a href="bayesTFR.html#topic+convert.tfr.trajectories">convert.tfr.trajectories</a></code>, 
<code><a href="#topic+mig.write.projection.summary">mig.write.projection.summary</a></code>, <code><a href="#topic+get.mig.trajectories">get.mig.trajectories</a></code>
</p>

<hr>
<h2 id='get.mig.convergence'>Accessing Convergence Diagnostics Object</h2><span id='topic+get.mig.convergence'></span><span id='topic+get.mig.convergence.all'></span>

<h3>Description</h3>

<p>The function retrieves results of convergence diagnostics 
(created by <code><a href="#topic+mig.diagnose">mig.diagnose</a></code>) from disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mig.convergence(sim.dir, thin = 225, burnin = 10000)

get.mig.convergence.all(sim.dir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.mig.convergence_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Simulation directory used for computing the diagnostics.</p>
</td></tr>
<tr><td><code id="get.mig.convergence_+3A_thin">thin</code></td>
<td>
<p>Thinning interval used with this diagnostics.</p>
</td></tr>
<tr><td><code id="get.mig.convergence_+3A_burnin">burnin</code></td>
<td>
<p>Burn-in used for computing the diagnostics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>get.mig.convergence</code> loads an object of class 
<code><a href="#topic+bayesMig.convergence">bayesMig.convergence</a></code> for the specific <code>thin</code> and <code>burnin</code> 
used in <code><a href="#topic+mig.diagnose">mig.diagnose</a></code> to generate this object. 
Function <code>get.mig.convergence.all</code> loads all <code><a href="#topic+bayesMig.convergence">bayesMig.convergence</a></code> objects 
available in <code>sim.dir</code>.
</p>


<h3>Value</h3>

<p><code>get.mig.convergence</code> returns an object of class <code><a href="#topic+bayesMig.convergence">bayesMig.convergence</a></code>; <br />
<code>get.mig.convergence.all</code> returns a list of objects of class <code><a href="#topic+bayesMig.convergence">bayesMig.convergence</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mig.diagnose">mig.diagnose</a></code>, <code><a href="#topic+summary.bayesMig.convergence">summary.bayesMig.convergence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run a real simulation (can take long time)
sim.dir &lt;- tempfile()
m &lt;- run.mig.mcmc(nr.chains = 2, iter = 10000, thin = 10, output.dir = sim.dir)

# Run convergence diagnostics with different burning and thin
mig.diagnose(sim.dir, burnin = 1000, thin = 2)
mig.diagnose(sim.dir, burnin = 500, thin = 1)

diags &lt;- get.mig.convergence.all(sim.dir)
for(i in 1:length(diags))
    print(summary(diags[[i]]))

unlink(sim.dir, recursive = TRUE)

</code></pre>

<hr>
<h2 id='get.mig.mcmc'>Access MCMC results</h2><span id='topic+get.mig.mcmc'></span><span id='topic+has.mig.mcmc'></span>

<h3>Description</h3>

<p>Function <code>get.mig.mcmc</code> retrieves results of an MCMC simulation and creates an object of class
<code><a href="#topic+bayesMig.mcmc.set">bayesMig.mcmc.set</a></code>. Function <code>has.mig.mcmc</code> checks the existence of such results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mig.mcmc(
  sim.dir,
  chain.ids = NULL,
  low.memory = TRUE,
  burnin = 0,
  verbose = FALSE
)

has.mig.mcmc(sim.dir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.mig.mcmc_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory where simulation results are stored.</p>
</td></tr>
<tr><td><code id="get.mig.mcmc_+3A_chain.ids">chain.ids</code></td>
<td>
<p>Chain identifiers in case only specific chains should be included
in the resulting object. By default, all available chains are included.</p>
</td></tr>
<tr><td><code id="get.mig.mcmc_+3A_low.memory">low.memory</code></td>
<td>
<p>Logical. If <code>FALSE</code> full MCMC traces are loaded into memory.</p>
</td></tr>
<tr><td><code id="get.mig.mcmc_+3A_burnin">burnin</code></td>
<td>
<p>Burn-in used for loading traces. Only relevant, if <code>low.memory=FALSE</code>.</p>
</td></tr>
<tr><td><code id="get.mig.mcmc_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. Switches log messages on and off.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get.mig.mcmc</code> returns an object of class <code><a href="#topic+bayesMig.mcmc.set">bayesMig.mcmc.set</a></code>.
</p>
<p><code>has.mig.mcmc</code> returns a logical value indicating if a migration simulation
exists in the given directory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.mig.mcmc">run.mig.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Toy simulation
sim.dir &lt;- tempfile()
m &lt;- run.mig.mcmc(nr.chains = 1, iter = 10, output.dir = sim.dir)

# can be later accessed via
m &lt;- get.mig.mcmc(sim.dir)
summary(m)

has.mig.mcmc(sim.dir) # should be TRUE

unlink(sim.dir, recursive = TRUE)

</code></pre>

<hr>
<h2 id='get.mig.parameter.traces'>Accessing MCMC Parameter Traces</h2><span id='topic+get.mig.parameter.traces'></span><span id='topic+get.mig.parameter.traces.cs'></span>

<h3>Description</h3>

<p>Functions for accessing traces of the MCMC parameters, either country-independent 
or country-specific.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mig.parameter.traces(
  mcmc.list,
  par.names = NULL,
  burnin = 0,
  thinning.index = NULL,
  thin = NULL
)

get.mig.parameter.traces.cs(
  mcmc.list,
  country.obj,
  par.names = NULL,
  burnin = 0,
  thinning.index = NULL,
  thin = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.mig.parameter.traces_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code><a href="#topic+bayesMig.mcmc">bayesMig.mcmc</a></code> objects.</p>
</td></tr>
<tr><td><code id="get.mig.parameter.traces_+3A_par.names">par.names</code></td>
<td>
<p>Names of country-independent parameters (in case of 
<code>get.mig.parameter.traces</code>) or country-specific parameters 
(in case of <code>get.mig.parameter.traces.cs</code>) to be included. 
By default all parameters are included, given either by <code><a href="#topic+mig.parameter.names">mig.parameter.names</a>()</code> 
(for global parameters) or <code><a href="#topic+mig.parameter.names.cs">mig.parameter.names.cs</a>()</code> (for location-specific parameters).</p>
</td></tr>
<tr><td><code id="get.mig.parameter.traces_+3A_burnin">burnin</code></td>
<td>
<p>Burn-in indicating how many iterations should be removed 
from the beginning of each chain.</p>
</td></tr>
<tr><td><code id="get.mig.parameter.traces_+3A_thinning.index">thinning.index</code></td>
<td>
<p>Index of the traces for thinning. If it is <code>NULL</code>, 
<code>thin</code> is used. <code>thinning.index</code> does not include <code>burnin</code> 
and should be flattened over all chains. For example, if there are two MCMC 
chains of length 1000, <code>burnin=200</code> and we want an equidistantly spaced 
sample of length 400, then the value should be <br />
<code>thinning.index = seq(1, 1600, length = 400)</code>.</p>
</td></tr>
<tr><td><code id="get.mig.parameter.traces_+3A_thin">thin</code></td>
<td>
<p>An integer value for thinning. It is an alternative to 
<code>thinning.index</code>. The above example is equivalent to <code>thin=4</code>.</p>
</td></tr>
<tr><td><code id="get.mig.parameter.traces_+3A_country.obj">country.obj</code></td>
<td>
<p>Country object (see <code><a href="bayesTFR.html#topic+get.country.object">get.country.object</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return a matrix with columns being the parameters and 
rows being the MCMC values, attached to one another in case of multiple chains. 
<code>get.mig.parameter.traces</code> returns country-independent parameters, 
<code>get.mig.parameter.traces.cs</code> returns country-specific parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mig.coda.list.mcmc">mig.coda.list.mcmc</a></code> for another way of retrieving parameter traces;
<code><a href="#topic+mig.parameter.names">mig.parameter.names</a></code> and <code><a href="#topic+mig.parameter.names.cs">mig.parameter.names.cs</a></code> for parameter names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Toy simulation for US states
us.mig.file &lt;- file.path(find.package("bayesMig"), "extdata", "USmigrates.txt")
sim.dir &lt;- tempfile()
m &lt;- run.mig.mcmc(nr.chains = 2, iter = 30, thin = 1, my.mig.file = us.mig.file, 
        output.dir = sim.dir, present.year = 2017, annual = TRUE)
# obtain traces of hierarchical parameters     
par.values &lt;- get.mig.parameter.traces(m$mcmc.list, burnin = 5)
dim(par.values) # matrix 50 x 4
hist(par.values[, "mu_global"], main = "mu")

# obtain traces of location-specific traces for California
mig.parameter.names.cs() # allowed parameter names 
par.values.cs &lt;- get.mig.parameter.traces.cs(m$mcmc.list, 
        country.obj = get.country.object("California", meta = m$meta),
        burnin = 5, par.names = "phi_c")
dim(par.values.cs) # matrix 50 x 1
hist(par.values.cs, main = colnames(par.values.cs))
unlink(sim.dir, recursive = TRUE)
    
</code></pre>

<hr>
<h2 id='get.mig.prediction'>Access Prediction Object</h2><span id='topic+get.mig.prediction'></span><span id='topic+has.mig.prediction'></span>

<h3>Description</h3>

<p>Function <code>get.mig.prediction</code> retrieves results of a prediction and creates an object of class
<code><a href="#topic+bayesMig.prediction">bayesMig.prediction</a></code>. Function <code>has.mig.prediction</code> checks an existence of such results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mig.prediction(mcmc = NULL, sim.dir = NULL, mcmc.dir = NULL)

has.mig.prediction(mcmc = NULL, sim.dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.mig.prediction_+3A_mcmc">mcmc</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesMig.mcmc.set">bayesMig.mcmc.set</a></code> used to make the prediction. 
If it is <code>NULL</code>, the prediction is loaded from directory given by <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="get.mig.prediction_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory where the prediction is stored.</p>
</td></tr>
<tr><td><code id="get.mig.prediction_+3A_mcmc.dir">mcmc.dir</code></td>
<td>
<p>Optional argument to be used only in a special case when the mcmc object 
contained in the prediction object was estimated in different directory than in the one 
to which it points to (for example due to moving or renaming the original directory). 
The argument causes that the mcmc is redirected to the given directory. 
It can be set to <code>NA</code> if no loading of the mcmc object is desired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mcmc</code> is not <code>NULL</code>, the search directory is set to 
<code>mcmc$meta$output.dir</code>. This approach assumes that the prediction was stored in the 
same directory as the MCMC simulation, i.e. the <code>output.dir</code> argument of the 
<code><a href="#topic+mig.predict">mig.predict</a></code> function was set to <code>NULL</code>. If it is not the case, 
the argument <code>mcmc.dir</code> should be used.
</p>


<h3>Value</h3>

<p>Function <code>get.mig.prediction</code> returns an object of class <code><a href="#topic+bayesMig.prediction">bayesMig.prediction</a></code>.
</p>
<p>Function <code>has.mig.prediction</code> returns  a logical indicating if a prediction exists.
</p>

<hr>
<h2 id='get.mig.trajectories'>Accessing Trajectories of Net Migration Rate</h2><span id='topic+get.mig.trajectories'></span>

<h3>Description</h3>

<p>Function for accessing all future trajectories of the net migration rate 
from a prediction object in a form of an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mig.trajectories(mig.pred, country)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.mig.trajectories_+3A_mig.pred">mig.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesMig.prediction">bayesMig.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="get.mig.trajectories_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as
ISO-2 or ISO-3 characters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function loads projected trajectories of net migration rate for the given country from disk
and returns it as a matrix.
</p>


<h3>Value</h3>

<p>Array of size the number of projection periods (including the present year) times the number of trajectories.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesMig.prediction">bayesMig.prediction</a></code>, <code><a href="#topic+get.mig.prediction">get.mig.prediction</a></code>, <code><a href="#topic+mig.trajectories.table">mig.trajectories.table</a></code>
</p>

<hr>
<h2 id='mig.coda.list.mcmc'>Conversion to coda-formatted objects</h2><span id='topic+mig.coda.list.mcmc'></span>

<h3>Description</h3>

<p>The functions convert MCMC traces (simulated using <code><a href="#topic+run.mig.mcmc">run.mig.mcmc</a></code>) into 
objects that can be used with the <span class="pkg">coda</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig.coda.list.mcmc(
  mcmc.list = NULL,
  country = NULL,
  chain.ids = NULL,
  sim.dir = NULL,
  par.names = NULL,
  par.names.cs = NULL,
  low.memory = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig.coda.list.mcmc_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>A list of objects of class <code>bayesMig.mcmc</code>, or an object of class <code><a href="#topic+bayesMig.mcmc.set">bayesMig.mcmc.set</a></code> or <code><a href="#topic+bayesMig.prediction">bayesMig.prediction</a></code>.
If <code>NULL</code>, the MCMCs are
loaded from <code>sim.dir</code>. Either <code>mcmc</code> or <code>sim.dir</code> must be given.</p>
</td></tr>
<tr><td><code id="mig.coda.list.mcmc_+3A_country">country</code></td>
<td>
<p>Location name or code. Used in connection with the <code>par.names.cs</code> argument
(see below).</p>
</td></tr>
<tr><td><code id="mig.coda.list.mcmc_+3A_chain.ids">chain.ids</code></td>
<td>
<p>Vector of chain identifiers. By default, all chains available in the <code>mcmc.list</code>
object are included.</p>
</td></tr>
<tr><td><code id="mig.coda.list.mcmc_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. Only used if <code>mcmc.list</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mig.coda.list.mcmc_+3A_par.names">par.names</code></td>
<td>
<p>Names of country-independent parameters to be included. Default names are
those returned by the <code>mig.parameter.names</code> function, which includes all country-independent
parameters in the BHM.</p>
</td></tr>
<tr><td><code id="mig.coda.list.mcmc_+3A_par.names.cs">par.names.cs</code></td>
<td>
<p>Names of country-specific parameters to be included. The argument <code>country</code>
is used to filter out traces that correspond to a specific location. If <code>country</code> is not given, 
traces of each parameter are given for all countries. Default names are those returned by 
<code>mig.parameter.names.cs()</code>, which includes all country-specific parameters in the BHM.</p>
</td></tr>
<tr><td><code id="mig.coda.list.mcmc_+3A_low.memory">low.memory</code></td>
<td>
<p>Logical indicating if the function should run in a memory-efficient mode.</p>
</td></tr>
<tr><td><code id="mig.coda.list.mcmc_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <span class="pkg">coda</span>'s <code><a href="coda.html#topic+mcmc">mcmc</a></code> function, such as <code>burnin</code> and <code>thin</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>mcmc.list</code> defined in the <span class="pkg">coda</span> package.
</p>

<hr>
<h2 id='mig.diagnose'>MCMC convergence diagnostics</h2><span id='topic+mig.diagnose'></span><span id='topic+bayesMig.convergence'></span><span id='topic+mig.raftery.diag'></span><span id='topic+estimate.a.hw'></span>

<h3>Description</h3>

<p>Runs convergence diagnostics of existing migration Markov chains 
using the <code>raftery.diag</code> function from the <code>coda</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig.diagnose(
  sim.dir,
  thin = 80,
  burnin = 2000,
  express = FALSE,
  country.sampling.prop = NULL,
  keep.thin.mcmc = FALSE,
  verbose = TRUE
)

mig.raftery.diag(
  mcmc = NULL,
  sim.dir = NULL,
  burnin = 0,
  country = NULL,
  par.names = NULL,
  par.names.cs = NULL,
  country.sampling.prop = 1,
  verbose = TRUE,
  ...
)

estimate.a.hw(mcmc, burnin = 0, thin = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig.diagnose_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with MCMC simulation results.</p>
</td></tr>
<tr><td><code id="mig.diagnose_+3A_thin">thin</code></td>
<td>
<p>Thinning interval.</p>
</td></tr>
<tr><td><code id="mig.diagnose_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to discard from the beginning of the parameter traces.</p>
</td></tr>
<tr><td><code id="mig.diagnose_+3A_express">express</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the convergence diagnostic is run only on the country-independent
parameters. If <code>FALSE</code>, the country-specific parameters are included in the diagnostics. The number of
countries can be controlled by <code>country.sampling.prop</code>.</p>
</td></tr>
<tr><td><code id="mig.diagnose_+3A_country.sampling.prop">country.sampling.prop</code></td>
<td>
<p>Proportion of countries to include in the diagnostics. If it is <code>NULL</code> and
<code>express=FALSE</code>, all countries are included. Setting a number between 0 and 1 will determine the proportion of countries
to be randomly sampled. For long Markov chains, this argument may significantly influence the runtime of this function.</p>
</td></tr>
<tr><td><code id="mig.diagnose_+3A_keep.thin.mcmc">keep.thin.mcmc</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the thinned traces used for computing the diagnostics are stored on disk.</p>
</td></tr>
<tr><td><code id="mig.diagnose_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. Switches log messages on and off.</p>
</td></tr>
<tr><td><code id="mig.diagnose_+3A_mcmc">mcmc</code></td>
<td>
<p>A <code><a href="#topic+bayesMig.mcmc">bayesMig.mcmc</a></code> or <code><a href="#topic+bayesMig.mcmc.set">bayesMig.mcmc.set</a></code> object. 
If not given, the object is loaded from the simulation directory given by 
<code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="mig.diagnose_+3A_country">country</code></td>
<td>
<p>Name or code of a country. If it is given, only country-specific 
parameters parameters of that country are considered.</p>
</td></tr>
<tr><td><code id="mig.diagnose_+3A_par.names">par.names</code></td>
<td>
<p>Names of country-independent parameters for which the Raftery 
diagnostics should be computed. By default all parameters are used.</p>
</td></tr>
<tr><td><code id="mig.diagnose_+3A_par.names.cs">par.names.cs</code></td>
<td>
<p>Names of country-specific parameters for which the Raftery 
diagnostics should be computed. By default all parameters are used.</p>
</td></tr>
<tr><td><code id="mig.diagnose_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="#topic+mig.coda.list.mcmc">mig.coda.list.mcmc</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mig.diagnose</code> function invokes the <code><a href="#topic+mig.raftery.diag">mig.raftery.diag</a></code> 
function separately for country-independent parameters and for country-specific 
parameters. It results in two possible states: red, i.e. it did not converge, and green, 
i.e. it converged. The resulting object is stored in 
&lsquo;<span class="file">{sim.dir}/diagnostics/bayesMig.convergence_{thin}_{burnin}.rda</span>&rsquo; 
and can be accessed using the function <code><a href="#topic+get.mig.convergence">get.mig.convergence</a></code>.
</p>
<p>Function <code><a href="bayesTFR.html#topic+has.mcmc.converged">has.mcmc.converged</a></code> from the <span class="pkg">bayesTFR</span> package 
can be used to check if the existing diagnostics converged.
</p>
<p>For details on the <code>mig.raftery.diag</code> function, see <code><a href="bayesTFR.html#topic+tfr.raftery.diag">tfr.raftery.diag</a></code>.
</p>
<p>The <code>estimate.a.hw</code> function estimates an optimal value for the <code>a.half.width</code>
argument in <code><a href="#topic+run.mig.mcmc">run.mig.mcmc</a></code>.
</p>


<h3>Value</h3>

<p><code>mig.diagnose</code> returns an object of class <code>bayesMig.convergence</code> 
containing summaries of the convergence check inputs and outputs. It has the 
same structure as <code><a href="bayesTFR.html#topic+bayesTFR.convergence">bayesTFR.convergence</a></code>. 
In addition it has an element <code>a.hw.est</code> which is the estimated value for 
the <code>a.half.width</code> argument in <code><a href="#topic+run.mig.mcmc">run.mig.mcmc</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="bayesTFR.html#topic+tfr.raftery.diag">tfr.raftery.diag</a></code>, <code><a href="coda.html#topic+raftery.diag">raftery.diag</a></code>, <code><a href="#topic+get.mig.convergence">get.mig.convergence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples in ?bayesMig and ?get.mig.convergence

</code></pre>

<hr>
<h2 id='mig.map'>World Map of Net Migration Rate</h2><span id='topic+mig.map'></span><span id='topic+mig.ggmap'></span><span id='topic+mig.map.gvis'></span><span id='topic+mig.map.all'></span><span id='topic+get.mig.map.parameters'></span>

<h3>Description</h3>

<p>Generates a world map of the net migration rate for given quantile and 
time period, which can be either projection or estimation time period, using different techniques: 
<code>mig.map</code> and <code>mig.map.all</code> use <span class="pkg">rworldmap</span>, <code>mig.ggmap</code> uses <span class="pkg">ggplot2</span>, and 
<code>mig.map.gvis</code> creates an interactive map via <span class="pkg">GoogleVis</span>. A map of 
country-specific model parameters is also supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig.map(pred, ...)

mig.ggmap(pred, ...)

mig.map.gvis(pred, ...)

mig.map.all(
  pred,
  output.dir,
  output.type = "png",
  mig.range = NULL,
  nr.cats = 50,
  same.scale = TRUE,
  quantile = 0.5,
  file.prefix = "migwrldmap_",
  ...
)

get.mig.map.parameters(
  pred,
  mig.range = NULL,
  nr.cats = 50,
  same.scale = TRUE,
  quantile = 0.5,
  palette = "Blue-Red",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig.map_+3A_pred">pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesMig.prediction">bayesMig.prediction</a></code>. Note that location codes
must correspond to the UN country codes in order to generate a world map.</p>
</td></tr>
<tr><td><code id="mig.map_+3A_...">...</code></td>
<td>
<p>In <code>mig.map</code>, ... are all arguments that can be passed 
to <code><a href="bayesTFR.html#topic+tfr.map">tfr.map</a></code>, such as <code>quantile</code>, <code>year</code>, 
<code>projection.index</code>, <code>par.name</code>, <code>adjusted</code>, <code>device</code>, <code>main</code>, 
<code>device.args</code>, and <code>data.args</code>. 
In <code>mig.map.gvis</code>, ... are all arguments that can be passed 
to <code><a href="bayesTFR.html#topic+tfr.map.gvis">tfr.map.gvis</a></code>. In <code>e0.ggmap</code>, ... are arguments that can be passed 
to <code><a href="bayesTFR.html#topic+tfr.ggmap">tfr.ggmap</a></code>. In addition, functions that use the <span class="pkg">rworldmap</span> package accept 
arguments passed to the <code><a href="rworldmap.html#topic+mapCountryData">mapCountryData</a></code> function of the <span class="pkg">rworldmap</span> package.</p>
</td></tr>
<tr><td><code id="mig.map_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which resulting maps are stored.</p>
</td></tr>
<tr><td><code id="mig.map_+3A_output.type">output.type</code></td>
<td>
<p>Type of the resulting files. It can be &ldquo;png&rdquo;, &ldquo;pdf&rdquo;, 
&ldquo;jpeg&rdquo;, &ldquo;bmp&rdquo;, &ldquo;tiff&rdquo;, or &ldquo;postscript&rdquo;.</p>
</td></tr>
<tr><td><code id="mig.map_+3A_mig.range">mig.range</code></td>
<td>
<p>Range of the migration rate to be displayed. It is of the form 
<code>c(</code><var>mig.min</var>, <var>mig.max</var><code>)</code>. By default, the whole available range is considered. 
Note that countries with values outside of the given range will appear white.</p>
</td></tr>
<tr><td><code id="mig.map_+3A_nr.cats">nr.cats</code></td>
<td>
<p>Number of color categories.</p>
</td></tr>
<tr><td><code id="mig.map_+3A_same.scale">same.scale</code></td>
<td>
<p>Logical controlling if maps for all years of this prediction object 
should be on the same color scale.</p>
</td></tr>
<tr><td><code id="mig.map_+3A_quantile">quantile</code></td>
<td>
<p>Quantile for which the map should be generated. It must be equal to one of the 
values in <code>dimnames(pred$quantiles)[[2]]</code>, 
i.e. 0, 0.025, 0.05, 0.1, 0.2, 0.25, 0.3, 0.4, 0.5, 0.6, 0.7, 0.75, 0.8, 0.9, 0.95, 0.975, 1. 
Value 0.5 corresponds to the median.</p>
</td></tr>
<tr><td><code id="mig.map_+3A_file.prefix">file.prefix</code></td>
<td>
<p>Prefix for file names.</p>
</td></tr>
<tr><td><code id="mig.map_+3A_palette">palette</code></td>
<td>
<p>Color palette to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions only work for national simulations where location codes 
correspond to the countries' UN codes.  
</p>
<p><code>mig.map</code> creates a single map for the given time period and quantile. 
<code>mig.map.all</code> generates a sequence of maps, namely one for each projection period. 
If the package <span class="pkg">fields</span> is installed, a color bar legend at the botom of the map is created.
</p>
<p>Function <code>get.mig.map.parameters</code> can be used in combination with <code>mig.map</code>. 
(Note that <code>get.mig.map.parameters</code> is called from inside of <code>mig.map.all</code>.) 
It sets breakpoints for the color scheme.
</p>
<p>Function <code>mig.ggmap</code> is similar to <code>mig.map</code>, but used the <span class="pkg">ggplot2</span> package 
in combination with the <code>geom_sf</code> function.
</p>
<p>Function <code>mig.map.gvis</code> creates an interactive map using the <span class="pkg">googleVis</span> package 
and opens it in an internet browser. It also generates a table of the mapped values that 
can be sorted by columns interactively in the browser. 
</p>
<p>By default, <code>mig.map</code>, <code>mig.ggmap</code> and <code>mig.map.gvis</code> produce maps of net migration rates. 
Alternatively, the functions can be used to plot country-specific MCMC parameters into a world map. 
They are given by the argument <code>par.name</code>. One can pass any value from 
<code><a href="#topic+mig.parameter.names.cs">mig.parameter.names.cs</a>()</code>.
</p>


<h3>Value</h3>

<p><code>get.mig.map.parameters</code> returns a list with elements:
</p>

<dl>
<dt>pred</dt><dd><p>The <code><a href="#topic+bayesMig.prediction">bayesMig.prediction</a></code> object used in the function.</p>
</dd>
<dt>quantile</dt><dd><p>Value of the argument <code>quantile</code>.</p>
</dd>
<dt>catMethod</dt><dd><p>If the argument <code>same.scale</code> is <code>TRUE</code>, this element 
contains breakpoints for categorization generated using the quantiles.
Otherwise, it is <code>NULL</code>.</p>
</dd>
<dt>numCats</dt><dd><p>Number of categories.</p>
</dd>
<dt>coulourPalette</dt><dd><p>The color palette.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="bayesTFR.html#topic+tfr.map">tfr.map</a></code>
</p>

<hr>
<h2 id='mig.median.set'>Adjusting the Projection Medians</h2><span id='topic+mig.median.set'></span><span id='topic+mig.median.shift'></span><span id='topic+mig.median.reset'></span><span id='topic+mig.align.predictions'></span><span id='topic+mig.shift.prediction.to.wpp'></span>

<h3>Description</h3>

<p>These functions are to be used by expert analysts. They allow to 
change the projection medians either to specific values, or shift the medians 
by a given constant or align one projection object with another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig.median.set(sim.dir, country, values, years = NULL, ...)

mig.median.shift(
  sim.dir,
  country,
  reset = FALSE,
  shift = 0,
  from = NULL,
  to = NULL
)

mig.median.reset(sim.dir, countries = NULL)

mig.align.predictions(
  sim.dir1,
  sim.dir2,
  country.codes = NULL,
  years = NULL,
  ...
)

mig.shift.prediction.to.wpp(sim.dir, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig.median.set_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory containing the prediction object.</p>
</td></tr>
<tr><td><code id="mig.median.set_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country.</p>
</td></tr>
<tr><td><code id="mig.median.set_+3A_values">values</code></td>
<td>
<p>Vector of the new median values.</p>
</td></tr>
<tr><td><code id="mig.median.set_+3A_years">years</code></td>
<td>
<p>Numeric vector giving years for which to change the median. 
In <code>mig.median.set</code> it gives years which <code>values</code> correspond to.
Ideally it should be of the same length as <code>values</code>. If it is <code>NULL</code>, 
<code>values</code> are set starting from the first prediction time period. 
If <code>values</code> correspond to consecutive years, only the first year might be given here.
In <code>mig.align.predictions</code> it gives years for which the medians should be aligned.</p>
</td></tr>
<tr><td><code id="mig.median.set_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying adjustment functions, such as 
<code>verbose</code> to show/hide the progress of the adjustment.
For <code>mig.shift.prediction.to.wpp</code> it can be <code>stat</code> with values &ldquo;median&rdquo; (default) 
or &ldquo;mean&rdquo; to specify which statistics should be adjusted; 
<code>wpp.year</code> to adjust it to if it differs from the wpp year of the simulation.</p>
</td></tr>
<tr><td><code id="mig.median.set_+3A_reset">reset</code></td>
<td>
<p>Logical. If <code>TRUE</code> medians in a range of <code>from</code> and <code>to</code> are
reset to their original values.</p>
</td></tr>
<tr><td><code id="mig.median.set_+3A_shift">shift</code></td>
<td>
<p>Constant by which the medians should be offset. It is not used if <code>reset</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mig.median.set_+3A_from">from</code></td>
<td>
<p>Year from which the offset/reset should start. By default, it starts at the first prediction period.</p>
</td></tr>
<tr><td><code id="mig.median.set_+3A_to">to</code></td>
<td>
<p>Year until which the offset/reset should be done. By default, it is set to the last prediction period.</p>
</td></tr>
<tr><td><code id="mig.median.set_+3A_countries">countries</code></td>
<td>
<p>Vector of country names or codes. If this argument is <code>NULL</code> (default), 
the reset is done for all countries.</p>
</td></tr>
<tr><td><code id="mig.median.set_+3A_sim.dir1">sim.dir1</code></td>
<td>
<p>Directory with the bayesMig prediction object to be adjusted.</p>
</td></tr>
<tr><td><code id="mig.median.set_+3A_sim.dir2">sim.dir2</code></td>
<td>
<p>Directory with the bayesMig prediction object used to align the medians from <code>sim.dir1</code> to.</p>
</td></tr>
<tr><td><code id="mig.median.set_+3A_country.codes">country.codes</code></td>
<td>
<p>Numerical codes of countries to adjust. By default all countries 
found in <code>sim.dir2</code> are adjusted in <code>sim.dir1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>mig.median.set</code> can be used to set the medians of the
given country to specific values.
</p>
<p>Function <code>mig.median.shift</code> can be used to offset the medians by a specific constant, or to reset
the medians to their original values.
</p>
<p>Function <code>mig.median.reset</code> resets medians of the given countries
to the original values. By default it deletes adjustments for all countries.
</p>
<p>Function <code>mig.align.predictions</code> shifts medians stored in <code>sim.dir1</code> to match 
the medians in <code>sim.dir1</code>.
</p>
<p>In all cases, if a median is modified, the corresponding offset is stored in the prediction object 
(element <code>median.shift</code>). All functions write the updated prediction object back to disk. All
functions in the package that use trajectories and trajectory statistics use the <code>median.shift</code> 
values to offset the results correspondingly, i.e. trajectories are shifted the same way as the
medians.
</p>
<p>Function <code>mig.shift.prediction.to.wpp</code> shifts the projected medians or means 
(if <code>stat</code> is &ldquo;mean&rdquo;), so that they correspond to the values found in the <code>migproj1dt</code> or <code>migproj5dt</code>
datasets of the <span class="pkg">wpp</span> package that either corresponds to the package used for the simulation itself 
or is given by the <code>wpp.year</code> argument. Currently, the function only works for <span class="pkg">wpp2024</span>.
Note that regardless if it is an adjustment of the median or mean, the corresponding offset is always 
converted to a shift of the median.
</p>


<h3>Value</h3>

<p>All functions return an updated object of class <code><a href="#topic+bayesMig.prediction">bayesMig.prediction</a></code>.
</p>

<hr>
<h2 id='mig.parameter.names'>Accessing Parameter Names</h2><span id='topic+mig.parameter.names'></span><span id='topic+mig.parameter.names.cs'></span>

<h3>Description</h3>

<p>Functions for accessing names of the MCMC parameters, 
either country-independent or country-specific.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig.parameter.names()

mig.parameter.names.cs(country.code = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig.parameter.names_+3A_country.code">country.code</code></td>
<td>
<p>Location code. If it is given, the country-specific parameter names contain 
the suffix &lsquo;_country<code class="reqn">X</code>&rsquo; where <code class="reqn">X</code> is the <code>country.code</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mig.parameter.names</code> returns names of the world parameters.
</p>
<p><code>mig.parameter.names.cs</code> returns names of the country-specific parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mig.parameter.names()

mig.parameter.names.cs()

</code></pre>

<hr>
<h2 id='mig.pardensity.plot'>Plotting MCMC Parameter Density</h2><span id='topic+mig.pardensity.plot'></span><span id='topic+mig.pardensity.cs.plot'></span>

<h3>Description</h3>

<p>Functions for plotting the density of the posterior distribution of the MCMC parameters from the migration model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig.pardensity.plot(
  mcmc.list = NULL,
  sim.dir = NULL,
  chain.ids = NULL,
  par.names = mig.parameter.names(),
  burnin = NULL,
  dev.ncol = 2,
  low.memory = TRUE,
  ...
)

mig.pardensity.cs.plot(
  country,
  mcmc.list = NULL,
  sim.dir = NULL,
  chain.ids = NULL,
  par.names = mig.parameter.names.cs(),
  burnin = NULL,
  dev.ncol = 3,
  low.memory = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig.pardensity.plot_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code><a href="#topic+bayesMig.mcmc">bayesMig.mcmc</a></code> objects, or an object of class
<code><a href="#topic+bayesMig.mcmc.set">bayesMig.mcmc.set</a></code> or of class <code>bayesMig.prediction</code>. If it is <code>NULL</code>, the 
values are loaded from <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="mig.pardensity.plot_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. It is only used if <code>mcmc.list</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mig.pardensity.plot_+3A_chain.ids">chain.ids</code></td>
<td>
<p>List of MCMC identifiers to be plotted. If it is <code>NULL</code>, all chains found in 
<code>mcmc.list</code> or <code>sim.dir</code> are plotted.</p>
</td></tr>
<tr><td><code id="mig.pardensity.plot_+3A_par.names">par.names</code></td>
<td>
<p>Names of parameters for which density should be plotted. By default all 
country-independent parameters are plotted if used within <code>mig.pardensity.plot</code>, or 
country-specific parameters are plotted if used within <code>mig.pardensity.cs.plot</code>.</p>
</td></tr>
<tr><td><code id="mig.pardensity.plot_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of each chain before 
computing the density.</p>
</td></tr>
<tr><td><code id="mig.pardensity.plot_+3A_dev.ncol">dev.ncol</code></td>
<td>
<p>Number of column for the graphics device. If the number of parameters is smaller
than <code>dev.ncol</code>, the number of columns is automatically decreased.</p>
</td></tr>
<tr><td><code id="mig.pardensity.plot_+3A_low.memory">low.memory</code></td>
<td>
<p>Logical indicating if the processing should run in a low-memory mode. If it is 
<code>FALSE</code>, traces of all available parameters are loaded into memory. Otherwise, parameters are
loaded as they are needed.</p>
</td></tr>
<tr><td><code id="mig.pardensity.plot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="stats.html#topic+density">density</a></code> function.</p>
</td></tr>
<tr><td><code id="mig.pardensity.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions plot the density of the posterior distribution either for 
country-independent parameters (<code>mig.pardensity.plot</code> or for country-specific 
parameters (<code>mig.pardensity.cs.plot</code>, one graph per parameter.  
One can restrict it to specific chains by setting the <code>chain.ids</code> argument and to specific 
parameters by setting the <code>par.names</code> argument. 
</p>
<p>If <code>mcmc.list</code> is an object of class <code><a href="#topic+bayesMig.prediction">bayesMig.prediction</a></code> 
and if this object contains thinned traces, they are used instead of the full chains. 
In such a case, <code>burnin</code> and <code>chain.ids</code> cannot be modified - their value is set 
to the one used when the thinned traces were created, namely when running 
<code><a href="#topic+mig.predict">mig.predict</a></code>. In a situation with long MCMC chains, this approach can  
significantly speed-up creation of the density plots.
</p>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='mig.partraces.plot'>Plotting MCMC Parameter Traces</h2><span id='topic+mig.partraces.plot'></span><span id='topic+mig.partraces.cs.plot'></span>

<h3>Description</h3>

<p>Functions for plotting the MCMC parameter traces from the migration model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig.partraces.plot(
  mcmc.list = NULL,
  sim.dir = NULL,
  chain.ids = NULL,
  par.names = mig.parameter.names(),
  nr.points = NULL,
  dev.ncol = 2,
  ...
)

mig.partraces.cs.plot(
  country,
  mcmc.list = NULL,
  sim.dir = NULL,
  chain.ids = NULL,
  par.names = mig.parameter.names.cs(),
  nr.points = NULL,
  dev.ncol = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig.partraces.plot_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code><a href="#topic+bayesMig.mcmc">bayesMig.mcmc</a></code> objects, or an object of class
<code><a href="#topic+bayesMig.mcmc.set">bayesMig.mcmc.set</a></code> or of class <code>bayesMig.prediction</code>. If it is <code>NULL</code>, the 
traces are loaded from <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="mig.partraces.plot_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. It is only used if <code>mcmc.list</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mig.partraces.plot_+3A_chain.ids">chain.ids</code></td>
<td>
<p>List of MCMC identifiers to be plotted. If it is <code>NULL</code>, all chains found in 
<code>mcmc.list</code> or <code>sim.dir</code> are plotted.</p>
</td></tr>
<tr><td><code id="mig.partraces.plot_+3A_par.names">par.names</code></td>
<td>
<p>Names of parameters for which traces should be plotted. By default all 
country-independent parameters are plotted if used within <code>mig.partraces.plot</code>, or 
country-specific parameters are plotted if used within <code>mig.partraces.cs.plot</code>.</p>
</td></tr>
<tr><td><code id="mig.partraces.plot_+3A_nr.points">nr.points</code></td>
<td>
<p>Number of points to be plotted. If <code>NULL</code>, all points are plotted, 
otherwise the traces are thinned evenly.</p>
</td></tr>
<tr><td><code id="mig.partraces.plot_+3A_dev.ncol">dev.ncol</code></td>
<td>
<p>Number of column for the graphics device. If the number of parameters is smaller
than <code>dev.ncol</code>, the number of columns is automatically decreased.</p>
</td></tr>
<tr><td><code id="mig.partraces.plot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters.</p>
</td></tr>
<tr><td><code id="mig.partraces.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions plot MCMC traces either for country-independent parameters 
(<code>mig.partraces.plot</code> or for country-specific parameters (<code>mig.partraces.cs.plot</code>, 
one graph per parameter.  One can restrict it to specific chains by setting 
the <code>chain.ids</code> argument, and to specific parameters by setting the <code>par.names</code> 
argument.
</p>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='mig.predict'>Generate posterior trajectories of net migration rates</h2><span id='topic+mig.predict'></span><span id='topic+bayesMig.prediction'></span>

<h3>Description</h3>

<p>Using the posterior parameter samples simulated by <code><a href="#topic+run.mig.mcmc">run.mig.mcmc</a></code>,
generate posterior trajectories for the net migration rates for all countries of
the world, or all locations included in the estimation. This code <em>does not</em> adjust trajectories to ensure that net
migration counts over all countries sum to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig.predict(
  mcmc.set = NULL,
  end.year = 2100,
  sim.dir = NULL,
  replace.output = FALSE,
  start.year = NULL,
  nr.traj = NULL,
  thin = NULL,
  burnin = 20000,
  use.cummulative.threshold = FALSE,
  ignore.gcc.in.threshold = FALSE,
  fixed.thresholds = NULL,
  post.last.observed = c("obsdata", "alldata", "impute"),
  save.as.ascii = 0,
  output.dir = NULL,
  seed = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig.predict_+3A_mcmc.set">mcmc.set</code></td>
<td>
<p>Object of class <code>bayesMig.mcmc.set</code> corresponding to sampled
parameter values for net migration model. If it is <code>NULL</code>, the object
is loaded from the directory specified in <code>sim.dir</code></p>
</td></tr>
<tr><td><code id="mig.predict_+3A_end.year">end.year</code></td>
<td>
<p>End year of the prediction</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with MCMC simulation results. It should be the same as
the <code>output.dir</code> argument in <code><a href="#topic+run.mig.mcmc">run.mig.mcmc</a></code></p>
</td></tr>
<tr><td><code id="mig.predict_+3A_replace.output">replace.output</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, existing predictions in
<code>output.dir</code> will be replaced by results of this run.</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_start.year">start.year</code></td>
<td>
<p>Start year of the prediction, i.e. the first predicted year. By default the prediction is 
started at the next time period after <code>present.year</code> set in the estimation
step. If <code>start.year</code> is smaller than the default, the behavior is controlled by 
the <code>post.last.observed</code> argument: Either data post <code>start.year</code> is ignored (default)
or the projection is set to the available data (<code>post.last.observed = "a"</code>).</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to be generated. 
If <code>NULL</code>, the argument <code>thin</code> is taken to determine the number of 
trajectories. If both are <code>NULL</code>, the number of trajectories
corresponds to the size of the parameter sample.</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_thin">thin</code></td>
<td>
<p>Thinning interval used for determining the number of trajectories. 
Only relevant if <code>nr.traj</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of the parameter traces.</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_use.cummulative.threshold">use.cummulative.threshold</code></td>
<td>
<p>If <code>TRUE</code> historical cummulative thresholds are applied
to avoid sampling rates that are too extreme. The thresholds are
derived over prior rates of all locations. As a time span for deriving the limits on projected rates, 
at each projected time point, six prior time periods are used in a 5-year simulation, 
corresponding to 30 years in an annual simulation.
In a national simulation, prior rates of GCC countries (plus Western Sahara and Djibouti) are excluded 
when deriving thresholds for non-GCC countries. If this option is used in a non-country simulation,
e.g. in a sub-national settings, set the <code>ignore.gcc.in.threshold</code> argument to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_ignore.gcc.in.threshold">ignore.gcc.in.threshold</code></td>
<td>
<p>If <code>use.cummulative.threshold</code> is <code>TRUE</code>, by default the GCC countries
(plus Western Sahara and Djibouti) identified by numerical codes of the countries are excluded from computing 
the historical cummulative thresholds for non-GCC countries. If this argument is <code>TRUE</code>, this distinction is not made. 
It is important to set it to <code>TRUE</code> in a sub-national simulation to avoid any random overlaps 
of UN codes and user-defined codes.</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_fixed.thresholds">fixed.thresholds</code></td>
<td>
<p>List with optional elements &ldquo;lower&rdquo; and &ldquo;upper&rdquo;. Each of them is a list defining 
lower and upper bounds of the future migration rate for specific locations. The name of each item is the location code
and the value is one number defining the corresponding threshold.</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_post.last.observed">post.last.observed</code></td>
<td>
<p>If a user-specific data file was used during estimation and the data 
contained the &ldquo;last.observed&rdquo; column, this argument determines how to treat the time periods 
between the last observed point and the start year of the prediction, for locations where there is
a gap between them, or if short-term predictions were included in the file. It is also relevant
if <code>start.year</code> is set to a smaller value than <code>present.year</code> in the estimation.
Possible values are:
</p>
    
<ul>
<li> <p>&ldquo;obsdata&rdquo; or &ldquo;o&rdquo; (default) uses any non-missing observed data 
provided in the data file during estimation, up to the time point defined by the argument <code>start.year</code> 
(excluding the start year itself). 
</p>
</li>
<li> <p>&ldquo;alldata&rdquo; or &ldquo;a&rdquo; would similarly use 
the provided data but would use all data, even if it goes beyond the start year. This allows
to use short-term deterministic projections for locations where it is available. 
</p>
</li>
<li> <p>&ldquo;impute&rdquo; or &ldquo;i&rdquo; would ignore all data beyond the last observed data point 
and impute the missing time periods.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mig.predict_+3A_save.as.ascii">save.as.ascii</code></td>
<td>
<p>Either a number determining how many trajectories should be
converted into an ASCII file, or 'all' in which case all trajectories are converted.
It should be set to 0 if no conversion is desired. If this argument 
is larger than zero, the resulting file can be used as input into population projection via <span class="pkg">bayesPop</span>,
see Details.</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which the resulting prediction object and the 
trajectories are stored. If it is <code>NULL</code>, it is set to either <code>sim.dir</code>,
or to <code>output.dir</code> of <code>mcmc.set$meta</code> if <code>mcmc.set</code> is given.</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_seed">seed</code></td>
<td>
<p>Seed of the random number generator. If <code>NULL</code> no seed is set. 
Can be used to generate reproducible projections.</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. Switches log messages on and off.</p>
</td></tr>
<tr><td><code id="mig.predict_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trajectories of net migration rates for each location are generated using the model of Azose &amp; Raftery (2015).
Parameter samples  simulated via <code><a href="#topic+run.mig.mcmc">run.mig.mcmc</a></code> are used from all chains, from which the given <code>burnin</code> 
was discarded. They are evenly thinned to match <code>nr.traj</code> or using the <code>thin</code> argument. 
Such thinned parameter traces, collapsed into one chain, if they do not already exist, are stored on disk 
into the sub-directory &lsquo;<span class="file">thinned_mcmc_<em>t</em>_<em>b</em></span>&rsquo; where <em>t</em> is the value  of <code>thin</code> and 
<em>b</em> the value of <code>burnin</code>.
</p>
<p>The projection is run for all missing values before the present year, if any. 
Medians over the trajectories are used as imputed values and the trajectories are discarded. 
The process then continues by projecting the future values where all generated trajectories are kept.
</p>
<p>A special case is when the argument <code>start.year</code> is given that is smaller than or equal to
the present year. In such a case, imputed missing values before present year are treated 
as ordinary predictions (trajectories are kept). If <code>post.last.observed</code> is &ldquo;a&rdquo;, 
all historical data between start year and present year are used as projections.
</p>
<p>The resulting prediction object is saved into &lsquo;<span class="file">{output.dir}/predictions</span>&rsquo;. Trajectories 
for all locations are saved into the same directory in a binary format, one file per location. 
At the end of the projection, if <code>save.as.ascii</code> is larger than 0, the function converts 
the given number of trajectories into a CSV file, called &lsquo;<span class="file">ascii_trajectories.csv</span>&rsquo; also located
in the &lsquo;<span class="file">predictions</span>&rsquo; directory. The converted trajectories are selected by equal spacing. 
In addition to the converted trajectories, two summary files are created: one in a user-friendly format, the other using 
a UN-specific coding, as described in <code><a href="#topic+mig.write.projection.summary">mig.write.projection.summary</a></code>.
</p>
<p>If it is desired to use these predictions as input to population projections in <span class="pkg">bayesPop</span>,
enter the full file path of the &lsquo;<span class="file">ascii_trajectories.csv</span>&rsquo; file into the <code>inputs</code> argument 
of <code>bayesPop::pop.predict</code> as item <code>migtraj</code> and set the argument <code>mig.is.rate</code> appropriately.
</p>


<h3>Value</h3>

<p>Object of class <code>bayesMig.prediction</code> which is a list with components
containing details of the prediction. Key result component is an array of <code>quantiles</code> with dimensions
(number of locations) x (number of computed quantiles) x (number of projected time points).
First time point in the sequence is not a projection, but the last observed time period.
</p>
<p>Other key result components include <code>traj.mean.sd</code>, a summary of means and standard deviations for each country
at each time point. See <code><a href="bayesTFR.html#topic+bayesTFR.prediction">bayesTFR.prediction</a></code> for more detail.
</p>


<h3>References</h3>

<p>Azose, J. J., &amp; Raftery, A. E. (2015). 
Bayesian probabilistic projection of international migration. Demography, 52(5), 1627-1650.
<a href="https://doi.org/10.1007/s13524-015-0415-0">doi:10.1007/s13524-015-0415-0</a>.
</p>
<p>Azose, J.J., Ševčíková, H., Raftery, A.E. (2016): Probabilistic population projections with migration uncertainty. 
Proceedings of the National Academy of Sciences 113:6460–6465. <a href="https://doi.org/10.1073/pnas.1606119113">doi:10.1073/pnas.1606119113</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Toy simulation for US states
us.mig.file &lt;- file.path(find.package("bayesMig"), "extdata", "USmigrates.txt")
sim.dir &lt;- tempfile()
m &lt;- run.mig.mcmc(nr.chains = 2, iter = 30, thin = 1, my.mig.file = us.mig.file, 
        output.dir = sim.dir, present.year = 2017, annual = TRUE)

# Prediction
pred &lt;- mig.predict(sim.dir = sim.dir, burnin = 5, end.year = 2050)
# here unrealistic results since this is a toy simulation 
mig.trajectories.plot(pred, "Hawaii", pi = 80, ylim = c(-0.02, 0.02)) 
mig.trajectories.table(pred, "Hawaii")
summary(pred, "California")

# view locations included in the simulation
get.countries.table(pred)

unlink(sim.dir, recursive = TRUE)
# For projections on national level, see ?bayesMig.
</code></pre>

<hr>
<h2 id='mig.trajectories.plot'>Output of posterior distribution of migration trajectories</h2><span id='topic+mig.trajectories.plot'></span><span id='topic+mig.trajectories.plot.all'></span><span id='topic+mig.trajectories.table'></span>

<h3>Description</h3>

<p>The functions plot/tabulate the posterior distribution of trajectories of net migration rates
for a given location, or for all locations, including their median and given probability 
intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig.trajectories.plot(
  mig.pred,
  country,
  pi = c(80, 95),
  nr.traj = 50,
  mark.estimation.points = FALSE,
  adjusted.only = TRUE,
  traj.index = NULL,
  show.mean = FALSE,
  show.median = TRUE,
  xlim = NULL,
  ylim = NULL,
  type = "b",
  xlab = "Year",
  ylab = "Migration rate",
  main = NULL,
  lwd = c(2, 2, 2, 2, 1),
  col = c("black", "green", "red", "red", "#00000020"),
  show.legend = TRUE,
  add = FALSE,
  scale = FALSE,
  ...
)

mig.trajectories.plot.all(
  mig.pred,
  output.dir = NULL,
  output.type = "png",
  verbose = FALSE,
  ...
)

mig.trajectories.table(mig.pred, country, pi = c(80, 95), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig.trajectories.plot_+3A_mig.pred">mig.pred</code></td>
<td>
<p>Prediction object of class <code>bayesMig.prediction</code>.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a location. If it is a country, it can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_pi">pi</code></td>
<td>
<p>Probability interval (as percentage) to be included in the output. It can be a single number or a vector.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to be plotted. If <code>NULL</code>, all trajectories are plotted, otherwise they are thinned evenly.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_mark.estimation.points">mark.estimation.points</code></td>
<td>
<p>Logical. If <code>TRUE</code>, points that were not used in the estimation are shown in a lighter color.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_adjusted.only">adjusted.only</code></td>
<td>
<p>Logical. By default, if the projection median is adjusted using e.g. <code><a href="#topic+mig.median.set">mig.median.set</a></code>, 
the function plots the adjusted median. If this argument is <code>FALSE</code> the original (non-adjusted) median is plotted as well.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_traj.index">traj.index</code></td>
<td>
<p>Vector of trajectory indices to show. If not given, the trajectories are selected using equidistant spacing.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_show.mean">show.mean</code>, <code id="mig.trajectories.plot_+3A_show.median">show.median</code></td>
<td>
<p>Logical indicating if the mean or/and the median of the distribution should be shown.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_xlim">xlim</code>, <code id="mig.trajectories.plot_+3A_ylim">ylim</code>, <code id="mig.trajectories.plot_+3A_type">type</code>, <code id="mig.trajectories.plot_+3A_xlab">xlab</code>, <code id="mig.trajectories.plot_+3A_ylab">ylab</code></td>
<td>
<p>Graphical parameters passed to the <code><a href="base.html#topic+plot">plot</a></code> function.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_main">main</code></td>
<td>
<p>Main title for the plot(s). In <code>mig.trajectories.plot.all</code> any occurrence of the string 
&ldquo;XXX&rdquo; is replaced by the name of the appropriate country.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_lwd">lwd</code>, <code id="mig.trajectories.plot_+3A_col">col</code></td>
<td>
<p>Vector of five elements giving the line width and color for: 1. observed data, 
2. imputed values, 3. median, 4. quantiles, 5. trajectories.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical controlling whether a legend should be drawn.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_add">add</code></td>
<td>
<p>Logical controlling whether the trajectories should be plotted into a new graphic 
device (<code>FALSE</code>) or into an existing device (<code>TRUE</code>). One can use this argument to plot
trajectories from multiple countries into one graphics.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_scale">scale</code></td>
<td>
<p>Logical. If <code>TRUE</code>, values are scaled to be &ldquo;per population&rdquo;, i.e. 
they are divided by <code>pop.denom</code> passed to <code><a href="#topic+run.mig.mcmc">run.mig.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters. In addition, for <code>mig.trajectories.plot.all</code> 
any of the arguments of <code>tfr.trajectories.plot</code> can be passed here.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which resulting plots are written. By default,
the plots are saved into directory {sim.dir}/predictions/migTrajectories.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_output.type">output.type</code></td>
<td>
<p>Type of the resulting plot files. Can be &quot;png&quot;, &quot;pdf&quot;, &quot;jpeg&quot;, &quot;bmp&quot;,
&quot;tiff&quot;, or &quot;postscript&quot;.</p>
</td></tr>
<tr><td><code id="mig.trajectories.plot_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. Switches log messages on and off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mig.trajectories.plot</code> plots posterior distribution of trajectories of net migration
rates for a given location. <code>mig.trajectories.table</code> gives the same output as a table. 
<code>mig.trajectories.plot.all</code> creates a set of graphs (one per location) that are stored in 
<code>output.dir</code>.
</p>
<p>The median and given probability intervals are computed using all available trajectories. 
Thus, <code>nr.traj</code> does not influence those values - it is used only to control the number 
of trajectories in the graphs.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mig.predict">mig.predict</a></code>, <code><a href="#topic+summary.bayesMig.prediction">summary.bayesMig.prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See example in ?mig.predict

</code></pre>

<hr>
<h2 id='mig.write.projection.summary'>Writing Projection Summary Files</h2><span id='topic+mig.write.projection.summary'></span>

<h3>Description</h3>

<p>The function creates two files containing projection summaries, 
such as the median, the lower and upper bound of the 80 and 90% probability 
intervals, respectively, and the constant variant. One file is in a user-friendly 
format, whereas the other is in a UN-specific format with internal coding of the 
time and the variants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig.write.projection.summary(pred, output.dir, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig.write.projection.summary_+3A_pred">pred</code></td>
<td>
<p>Object of class <code>bayesMig.prediction</code>.</p>
</td></tr>
<tr><td><code id="mig.write.projection.summary_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory where output is written.</p>
</td></tr>
<tr><td><code id="mig.write.projection.summary_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying functions. 
Here, argument <code>precision</code> can be set to determine the number 
of significant digits (default is 4).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>See Also</h3>

<p><code><a href="bayesTFR.html#topic+write.projection.summary">write.projection.summary</a></code>
</p>

<hr>
<h2 id='run.mig.mcmc'>Run Markov chain Monte Carlo for parameters of net migration rate model</h2><span id='topic+run.mig.mcmc'></span><span id='topic+bayesMig.mcmc.set'></span><span id='topic+bayesMig.mcmc'></span><span id='topic+bayesMig.mcmc.meta'></span>

<h3>Description</h3>

<p>Runs MCMCs for simulating the net migration rate of all countries of the
world or for locations specified by users, using the Bayesian hierarchical model of Azose &amp; Raftery (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.mig.mcmc(
  output.dir,
  nr.chains = 3,
  iter = 50000,
  thin = 1,
  replace.output = FALSE,
  annual = FALSE,
  start.year = 1950,
  present.year = 2020,
  wpp.year = 2019,
  my.mig.file = NULL,
  sigma.c.min = 1e-04,
  a.ini = NULL,
  a.half.width = NULL,
  mu.ini = NULL,
  exclude.from.world = NULL,
  pop.denom = 1,
  seed = NULL,
  parallel = FALSE,
  nr.nodes = nr.chains,
  buffer.size = 1000,
  verbose = TRUE,
  verbose.iter = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.mig.mcmc_+3A_output.dir">output.dir</code></td>
<td>
<p>A file path pointing to the directory in which to store results.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_nr.chains">nr.chains</code></td>
<td>
<p>An integer number of independent Markov chains to run.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_iter">iter</code></td>
<td>
<p>The number of iterations to run per Markov chain.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_thin">thin</code></td>
<td>
<p>Thinning interval. A chain with 1000 iterations thinned by 20 will return a 
final count of 50 iterations.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_replace.output">replace.output</code></td>
<td>
<p>If the specified output directory already exists, should it be overwritten?</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_annual">annual</code></td>
<td>
<p>If <code>TRUE</code>, the model assumes the underlying data is on annual time scale.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_start.year">start.year</code></td>
<td>
<p>Start year for using historical data.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_present.year">present.year</code></td>
<td>
<p>End year for using historical data.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_wpp.year">wpp.year</code></td>
<td>
<p>Year for which WPP data is used if no user data is provided via <code>my.mig.file</code>. 
In such a case, the function loads a package called <span class="pkg">wpp</span><code class="reqn">x</code> where <code class="reqn">x</code> is the <code>wpp.year</code> and generates 
historical migration rates using the 
<code><a href="wpp2019.html#topic+migration">migration</a></code> and <code><a href="wpp2019.html#topic+pop">pop</a></code> datasets.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_my.mig.file">my.mig.file</code></td>
<td>
<p>File name containing user-specified historical time series of migration rates 
for all locations that should be included in the simulation. It should be a tab-separated file.
For structure, see Details below.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_sigma.c.min">sigma.c.min</code>, <code id="run.mig.mcmc_+3A_a.ini">a.ini</code>, <code id="run.mig.mcmc_+3A_mu.ini">mu.ini</code></td>
<td>
<p>Settings for the parameters
of the model (see Azose &amp; Raftery 2015), such as minimum value and initial values.
Initial values (*.ini) can be given as a vector of length <code>nr.chains</code>, giving one initial value per chain.
By default the initial values are equidistantly spread between their respective ranges.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_a.half.width">a.half.width</code></td>
<td>
<p>Half width for Metropolis proposals of the a parameter. This argument can greatly influence 
the convergence and it is dependent on the scale of the data. By default it is set to 0.01 for 5-year data 
defined as rate per population; to 0.03 for 5-year data defined as per 1000; to 0.3 for 
annual data per population; to 0.5 for annual data per 1000. If the default does not 
yield satisfactory results, use the function <code><a href="#topic+estimate.a.hw">estimate.a.hw</a></code> to estimate 
an appropriate value, based on an existing simulation. Also it is important to set the <code>pop.denom</code>
argument correctly.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_exclude.from.world">exclude.from.world</code></td>
<td>
<p>Vector of location codes that should be excluded from estimating the hyperparameters. 
These would be for example small locations or locations with unusual patters. 
Note that location-specific parameters are generated for all locations, regardless of this setting.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_pop.denom">pop.denom</code></td>
<td>
<p>Denominator used to generate the input migration rates. It is used to derive an appropriate scaler 
for the priors and conditional distributions. Typically, this will be either 1 (default) if the rates are 
defined as per population, or 1000, if the rates are per 1000 population. 
Use this argument only if user-specified rates are supplied via the <code>my.mig.file</code> argument.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_seed">seed</code></td>
<td>
<p>Seed of the random number generator. If <code>NULL</code> no seed is set. It can be used to generate reproducible results.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_parallel">parallel</code></td>
<td>
<p>Whether to run code in parallel.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_nr.nodes">nr.nodes</code></td>
<td>
<p>Relevant only if <code>parallel</code> is <code>TRUE</code>. It gives the number of nodes for running the simulation in parallel. 
By default it equals to the number of chains.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_buffer.size">buffer.size</code></td>
<td>
<p>Buffer size (in number of iterations) for keeping data in the memory before flushing to disk.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to print status updates to console window while the code is running.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_verbose.iter">verbose.iter</code></td>
<td>
<p>If verbose is TRUE, the number of iterations to wait between printing updates.</p>
</td></tr>
<tr><td><code id="run.mig.mcmc_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the function <code><a href="snowFT.html#topic+performParallel">performParallel</a></code>, if <code>parallel</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates an object of class <code><a href="#topic+bayesMig.mcmc.meta">bayesMig.mcmc.meta</a></code> and 
stores it in <code>output.dir</code>. It launches <code>nr.chains</code> MCMCs, either sequentially or 
in parallel. Parameter traces of each chain are stored as ASCII files in a subdirectory 
of <code>output.dir</code>, called <code>mc</code><em>x</em> where <em>x</em> is the identifier of that chain. 
There is one file per parameter, named after the parameter with the suffix &ldquo;.txt&rdquo;.
Location-specific parameters have the suffix <code>_country</code><em>c</em> where <em>c</em> is the location code.
In addition to the trace files, each <code>mc</code><em>x</em> directory contains the object 
<code><a href="#topic+bayesMig.mcmc">bayesMig.mcmc</a></code> in binary format.  
All chain-specific files  are written onto disk after the first, last and each 
<code class="reqn">i</code>-th (thinned) iteration, where <code class="reqn">i</code> is given by the argument <code>buffer.size</code>.
</p>
<p>By default (if no data is passed via the <code>my.mig.file</code> argument), the function 
loads observed data (further denoted as WPP dataset), from the <code><a href="wpp2019.html#topic+migration">migration</a></code> 
and <code><a href="wpp2019.html#topic+pop">pop</a></code> datasets in the <span class="pkg">wpp</span><code class="reqn">x</code> package where <code class="reqn">x</code> is 
the <code>wpp.year</code>. Net migration rates are computed as migration(<code class="reqn">t</code>) / (population(<code class="reqn">t_e</code>) - migration(<code class="reqn">t</code>)) 
where <code class="reqn">t_e</code> means the end of time period <code class="reqn">t</code>. For an annual simulation and 
<code>wpp.year</code> set to 2022, <code class="reqn">t = t_e</code> because the population in year <code class="reqn">t</code> 
is considered at the end of the year. If <code>wpp.year</code> is smaller than 2022 and <code>annual</code> is <code>TRUE</code>
the default dataset is interpolated from 5-year data.
</p>
<p>The argument <code>my.mig.file</code> can be used to overwrite the default data. It should be a tab-separated file.
If it is used, it should contain net migration rates for all locations to be used in the simulation, as no WPP data is used 
in such a case. The structure of the file has the same format as the <code><a href="wpp2019.html#topic+migration">migration</a></code> dataset,
but the values should be rates (instead of counts). Use the argument <code>pop.denom</code> to define the scale of the 
denominator in these rates, i.e. if the rates are to be interpreted as per population (default) or some other scale. 
Each row in the <code>my.mig.file</code> file corresponds to a location. It does not have 
to be necessarily a country - it can be for example a subnational unit. It must contain columns 
&ldquo;country_code&rdquo; or &ldquo;code&rdquo; (unique identifier of the location), &ldquo;name&rdquo;, and columns representing 
5-year time intervals (if <code>annual</code> is <code>FALSE</code>), e.g., &ldquo;1995-2000&rdquo;, &ldquo;2000-2005&rdquo; etc., or single years
(if <code>annual</code> is <code>TRUE</code>). An example dataset of annual net migration rates for US states is included in the package, 
see example below. 
</p>
<p>Optionally, the <code>my.mig.file</code> can contain columns called &ldquo;first.observed&rdquo; and/or &ldquo;last.observed&rdquo;, containing 
for each location the year of the first and last observation, respectively. In such a case, any data 
before and after those time points will be ignored. Furthermore, the function <code><a href="#topic+mig.predict">mig.predict</a></code> fills in the missing values 
after the last observation, using the median of the BHM procedure.
</p>
<p>If there are countries or locations that should be excluded from influencing the hyperparameters,
for example small countries or locations with unique migration patterns, their codes 
should be included in the argument <code>exclude.from.world</code>. These locations will still get 
their parameters simulated and thus, will be included in a projection. Alternatively 
if <code>my.mig.file</code> is used, these locations can be determined using an additional column, called 
&ldquo;include_code&rdquo;. Value 2 means the location is included in the BHM; value 1 means it's 
excluded but location-specific parameters are generated; value 0 means the location is ignored.
</p>


<h3>Value</h3>

<p>An object of class <code>bayesMig.mcmc.set</code> which is a list with two components:
</p>
<table role = "presentation">
<tr><td><code>meta</code></td>
<td>
<p>An object of class <code>bayesMig.mcmc.meta</code>. It contains information that is common to all chains.
Most items are the same as in <code><a href="bayesTFR.html#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code>. In addition, <code>mig.rates</code>
is a matrix of the observed migration rates with <code>NA</code>s in spots that were not used 
for estimation. <code>mig.rates.all</code> is a similar matrix but contains all data, regardless
if used for estimation or not. Item <code>user.data</code> is a logical indicating 
if the migration rates are given by the user (<code>TRUE</code>) or are taken from a <span class="pkg">wpp</span> package
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code>mcmc.list</code></td>
<td>
<p>A list of objects of class <code>bayesMig.mcmc</code>, one for each MCMC. 
Information stored here is specific to each MCMC chain, similarly to <code><a href="bayesTFR.html#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Azose, J. J., &amp; Raftery, A. E. (2015). 
Bayesian probabilistic projection of international migration. Demography, 52(5), 1627-1650.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.mig.mcmc">get.mig.mcmc</a></code>, <code><a href="#topic+summary.bayesMig.mcmc.set">summary.bayesMig.mcmc.set</a></code>, <code><a href="#topic+mig.partraces.plot">mig.partraces.plot</a></code>,
<code><a href="#topic+mig.pardensity.plot">mig.pardensity.plot</a></code>, <code><a href="#topic+mig.predict">mig.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Toy simulation for US states
us.mig.file &lt;- file.path(find.package("bayesMig"), "extdata", "USmigrates.txt")
sim.dir &lt;- tempfile()
m &lt;- run.mig.mcmc(nr.chains = 3, iter = 100, thin = 1, my.mig.file = us.mig.file, 
        annual = TRUE, output.dir = sim.dir)
summary(m)
summary(m, "Washington")

mig.partraces.plot(m)
mig.partraces.cs.plot("California", m)

# later one can access the object from disk
m &lt;- get.mig.mcmc(sim.dir)
 
unlink(sim.dir, recursive = TRUE)
# For a country-level simulation, see example in ?bayesMig. 

</code></pre>

<hr>
<h2 id='store.bayesMig.convergence'>Internal Functions and datasets of bayesMig</h2><span id='topic+store.bayesMig.convergence'></span><span id='topic+store.bayesMig.prediction'></span><span id='topic+get.mig.shift'></span>

<h3>Description</h3>

<p>These functions and datasets are not to be used directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store.bayesMig.convergence(diag, thin, burnin, output.dir)

store.bayesMig.prediction(pred, output.dir = NULL)

get.mig.shift(country.code, pred)
</code></pre>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='summary.bayesMig.convergence'>Summary of Convergence Diagnostics</h2><span id='topic+summary.bayesMig.convergence'></span>

<h3>Description</h3>

<p>Summary of an object of class <code><a href="#topic+bayesMig.convergence">bayesMig.convergence</a></code> created 
using the <code><a href="#topic+mig.diagnose">mig.diagnose</a></code> function. It gives an overview about parameters 
that did not converge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesMig.convergence'
summary(object, expand = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bayesMig.convergence_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesMig.prediction">bayesMig.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.convergence_+3A_expand">expand</code></td>
<td>
<p>By default, the function does not show country-specific parameters 
for which there was no convergence (only country-independent parameters), 
if the status is &lsquo;red&rsquo;. This argument can switch that option on.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.convergence_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with items that summarize an object of class <code><a href="#topic+bayesMig.convergence">bayesMig.convergence</a></code>.
</p>

<hr>
<h2 id='summary.bayesMig.mcmc'>Summary Statistics for Migration Markov Chain Monte Carlo</h2><span id='topic+summary.bayesMig.mcmc'></span><span id='topic+summary.bayesMig.mcmc.set'></span>

<h3>Description</h3>

<p>Summary of an object <code><a href="#topic+bayesMig.mcmc.set">bayesMig.mcmc.set</a></code> or <code><a href="#topic+bayesMig.mcmc">bayesMig.mcmc</a></code>,
computed via <code><a href="#topic+run.mig.mcmc">run.mig.mcmc</a></code>.  It can be obtained either for all locations or 
for a specific location, and either for all parameters or for specific parameters.
The function uses the <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code> function of the <span class="pkg">coda</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesMig.mcmc'
summary(
  object,
  country = NULL,
  par.names = NULL,
  par.names.cs = NULL,
  thin = 1,
  burnin = 0,
  ...
)

## S3 method for class 'bayesMig.mcmc.set'
summary(
  object,
  country = NULL,
  chain.id = NULL,
  par.names = NULL,
  par.names.cs = NULL,
  meta.only = FALSE,
  thin = 1,
  burnin = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bayesMig.mcmc_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesMig.mcmc.set">bayesMig.mcmc.set</a></code> or <code><a href="#topic+bayesMig.mcmc">bayesMig.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.mcmc_+3A_country">country</code></td>
<td>
<p>Location name or code if a location-specific summary is desired. The code can be either numeric 
or (if locations are countries) ISO-2 or ISO-3 characters. By default, summary 
for all locations is generated.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.mcmc_+3A_par.names">par.names</code></td>
<td>
<p>Country independent parameters (hyperparameters) to be included in the summary. 
The default names are given by <code><a href="#topic+mig.parameter.names">mig.parameter.names</a>()</code>.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.mcmc_+3A_par.names.cs">par.names.cs</code></td>
<td>
<p>Location-specific parameters to be included in the summary.
The default names are given by <code><a href="#topic+mig.parameter.names.cs">mig.parameter.names.cs</a>()</code>.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.mcmc_+3A_thin">thin</code></td>
<td>
<p>Thinning interval. Only used if larger than the <code>thin</code> argument used in <code><a href="#topic+run.mig.mcmc">run.mig.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.mcmc_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of each chain before computing the summary.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.mcmc_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code> function of the <span class="pkg">coda</span> package.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.mcmc_+3A_chain.id">chain.id</code></td>
<td>
<p>Identifiers of MCMC chains. By default, all chains are considered.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.mcmc_+3A_meta.only">meta.only</code></td>
<td>
<p>Logical. If it is <code>TRUE</code>, only meta information of the simulation is included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return list with elements:
</p>

<dl>
<dt>meta</dt><dd><p>contains meta information about the object.</p>
</dd>
<dt>results</dt><dd><p>contains result of <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>.</p>
</dd>
<dt>country.name</dt><dd><p>optional; available if <code>country</code> is provided as argument.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># See example in ?run.mig.mcmc
</code></pre>

<hr>
<h2 id='summary.bayesMig.prediction'>Summary of Prediction of Net Migration Rate</h2><span id='topic+summary.bayesMig.prediction'></span><span id='topic+print.summary.bayesMig.prediction'></span>

<h3>Description</h3>

<p>Summary of an object of class <code><a href="#topic+bayesMig.prediction">bayesMig.prediction</a></code>, 
created using the function <code><a href="#topic+mig.predict">mig.predict</a></code>. The summary contains the mean, 
standard deviation and several commonly used quantiles of the simulated trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesMig.prediction'
summary(object, country = NULL, compact = TRUE, ...)

## S3 method for class 'summary.bayesMig.prediction'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bayesMig.prediction_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesMig.prediction">bayesMig.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.prediction_+3A_country">country</code></td>
<td>
<p>Location name or code if a location-specific summary is desired. 
The code can be either numeric or (if locations are countries) ISO-2 or ISO-3 characters. 
If it is <code>NULL</code>, only prediction meta info is included.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.prediction_+3A_compact">compact</code></td>
<td>
<p>Logical switching between a smaller and larger number of displayed quantiles.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.prediction_+3A_...">...</code></td>
<td>
<p>A list of further arguments.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.prediction_+3A_x">x</code></td>
<td>
<p>A result of the <code>summary</code> function.</p>
</td></tr>
<tr><td><code id="summary.bayesMig.prediction_+3A_digits">digits</code></td>
<td>
<p>Minimal number of significant digits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary</code> returns a list with objects <code>burnin</code>, <code>nr.traj</code>, <code>projection.years</code>,
<code>country.name</code> containing the MCMC burn-in, number of trajectories, projected years
and name of the location, respectively. The projection results are stored in the item 
<code>projections</code> which is a matrix with rows being the years and columns being the mean
and various quantiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See example in ?mig.predict
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
