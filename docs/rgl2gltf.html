<!DOCTYPE html><html lang="en"><head><title>Help for package rgl2gltf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rgl2gltf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.gltf'>
<p>Produce glTF objects</p></a></li>
<li><a href='#as.rglscene.gltf'>
<p>Convert a glTF object to an rglscene or mesh3d object.</p></a></li>
<li><a href='#extractTexture'>
<p>Extract a texture file from a glTF object</p></a></li>
<li><a href='#findEntry'>
<p>Find a component of a recursive object</p></a></li>
<li><a href='#getTangents'>
<p>Use the MikkTSpace code to generate tangent vectors.</p></a></li>
<li><a href='#Gltf'><p>R6 Class for glTF file objects</p></a></li>
<li><a href='#gltfWidget'>
<p>Create a widget for a glTF display.</p></a></li>
<li><a href='#imports'>
<p>Imports from rgl</p></a></li>
<li><a href='#matrixSequence'>
<p>Print the sequence of matrices affecting an object.</p></a></li>
<li><a href='#modifyShaders'>
<p>Edit shader code</p></a></li>
<li><a href='#playgltf'>
<p>Play an animated glTF object.</p></a></li>
<li><a href='#readGLB'>
<p>Read a GLB file.</p></a></li>
<li><a href='#readglTF'>
<p>Read a glTF file</p></a></li>
<li><a href='#setPBRshaders'>
<p>Set shaders for physically based rendering.</p></a></li>
<li><a href='#showTags'>
<p>Debugging tool:  show tags for objects in rgl scene</p></a></li>
<li><a href='#showtree'>
<p>Show the tree structure of nodes in a glTF object or rglscene</p>
object.</a></li>
<li><a href='#writeglTF'>
<p>Write a glTF or GLB file.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read and Write '.gltf' and '.glb' Files</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Duncan Murdoch &lt;murdoch.duncan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'glTF' file format is used to describe 3D models.  This package 
 provides read and write functions to work with it.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>jsonlite, rgl (&ge; 0.108.43), grDevices, R6, base64enc</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dmurdoch/rgl2gltf">https://github.com/dmurdoch/rgl2gltf</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dmurdoch/rgl2gltf/issues">https://github.com/dmurdoch/rgl2gltf/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, misc3d, V8, manipulateWidget, png, jpeg</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-19 17:02:38 UTC; murdoch</td>
</tr>
<tr>
<td>Author:</td>
<td>Duncan Murdoch [aut, cre],
  Morten S. Mikkelsen [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-21 08:40:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.gltf'>
Produce glTF objects
</h2><span id='topic+as.gltf'></span><span id='topic+as.gltf.mesh3d'></span><span id='topic+as.gltf.rglscene'></span><span id='topic+as.gltf.default'></span>

<h3>Description</h3>

<p>The glTF file is the JSON part of a glTF representation of a 3D
scene.  This function creates the R structure corresponding to
one, and writes the binary buffer file for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.gltf(x, ...)

## Default S3 method:
as.gltf(x, y = NULL, z = NULL, vertices,
                            material = NULL,
                            normals = NULL,
                            texcoords = NULL,
                            points = NULL, segments = NULL,
                            triangles = NULL,
                            quads = NULL,
                            transform = diag(4),
                            extras = NULL,
                            ...,
                            rglscene = list(),
                            previous = Gltf$new(),
                            newScene = FALSE,
                            parentNode = NULL,
                            dir = tempdir(),
                            scale = c(1,1,1))

## S3 method for class 'rglscene'
as.gltf(x, ..., previous = Gltf$new(),
                            newScene = FALSE)
## S3 method for class 'mesh3d'
as.gltf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.gltf_+3A_x">x</code></td>
<td>

<p>An object to convert to a <code>"gltf"</code> object.
</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_y">y</code>, <code id="as.gltf_+3A_z">z</code></td>
<td>
<p>In the default method, combined with <code>x</code>
to make coordinates.  Any reasonable way of defining the coordinates is acceptable. See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code> for details.</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_vertices">vertices</code></td>
<td>
<p>A 3 or 4 row matrix of Euclidean or homogeneous coordinates; takes
precedence over <code>x, y, z</code>.</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_material">material</code></td>
<td>
<p>material properties for rendering</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_normals">normals</code></td>
<td>
<p>normals at each vertex as a 3 or 4 <b>column</b> matrix</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_texcoords">texcoords</code></td>
<td>
<p>texture coordinates at each vertex as a 2 column matrix</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_points">points</code></td>
<td>
<p>vector of indices of vertices to draw as points</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_segments">segments</code></td>
<td>
<p>2 x n matrix of indices of vertices to draw as
segments</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_triangles">triangles</code></td>
<td>
<p>3 x n matrix of indices of vertices to draw
as triangles</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_quads">quads</code></td>
<td>
<p>4 x n matrix of indices of vertices to draw as quads</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_transform">transform</code></td>
<td>
<p>4 x 4 matrix associated with this object
(e.g. a subscene)</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_extras">extras</code></td>
<td>
<p>A list to attach as <code>extras</code> component to
the result</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_...">...</code></td>
<td>

<p>Other parameters passed to the default method.
</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_rglscene">rglscene</code></td>
<td>
<p>The RGL scene this came from, e.g. to look
up defaults</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_previous">previous</code></td>
<td>

<p>Optionally a previously produced <code>"gltf"</code> object;
the new geometry will be added to it.
</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_newscene">newScene</code></td>
<td>
<p>logical; if <code>TRUE</code>, add a new
scene to <code>previous</code>, otherwise try to add to the existing
scene.</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_parentnode">parentNode</code></td>
<td>
<p>If not <code>NULL</code>, add the new object
as a child of this node, otherwise add to the first node of the
default scene.</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_dir">dir</code></td>
<td>

<p>Where to write the binary buffer file.
</p>
</td></tr>
<tr><td><code id="as.gltf_+3A_scale">scale</code></td>
<td>

<p>Rescaling in the enclosing subscene.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.gltf</code> is a generic function.
</p>
<p>The method for <code>"rglscene"</code> objects can handle most
objects produced by <code><a href="rgl.html#topic+scene3d">scene3d</a></code>, but not all
objects will be handled.  In particular:
</p>

<ul>
<li><p>Lights, text, bounding box decorations and backgrounds are saved in &ldquo;extra&rdquo; fields, so
they can be read by <span class="pkg">rgl2gltf</span>, but most other
software will ignore them or only display some parts.
</p>
</li>
<li><p>Most material properties are also stored in &ldquo;extra&rdquo;
fields.
</p>
</li></ul>

<p>There are methods for many individual types of <code>"rglobject"</code>, but these are intended for internal
use.
</p>


<h3>Value</h3>

<p>A <code>"gltf"</code> object.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>The specification of the glTF format:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cube &lt;- rgl::rotate3d(rgl::cube3d(col = "red"), -pi/10, 1,0,0)
gltf &lt;- as.gltf(cube)
rgl::plot3d(gltf)
gltf$closeBuffers()
</code></pre>

<hr>
<h2 id='as.rglscene.gltf'>
Convert a glTF object to an rglscene or mesh3d object.
</h2><span id='topic+as.rglscene.gltf'></span><span id='topic+as.mesh3d.gltf'></span>

<h3>Description</h3>

<p>These methods convert a <code>"gltf"</code> object to
a <code>"rglscene"</code> object, similar to what <code><a href="rgl.html#topic+scene3d">scene3d</a></code>
would produce, or a <code>"mesh3d"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gltf'
as.rglscene(x, scene = x$scene, nodes = NULL,
         useRGLinfo = TRUE, time = NULL, ani = 0, clone = TRUE,
         quick = FALSE, add = FALSE, ...)
## S3 method for class 'gltf'
as.mesh3d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.rglscene.gltf_+3A_x">x</code></td>
<td>

<p>The <code>"gltf"</code> object to convert.
</p>
</td></tr>
<tr><td><code id="as.rglscene.gltf_+3A_scene">scene</code></td>
<td>
<p>Which scene to convert?  If <code>NULL</code> (e.g.
<code>x</code> doesn't define a default scene), scene 0 will be used.
</p>
</td></tr>
<tr><td><code id="as.rglscene.gltf_+3A_nodes">nodes</code></td>
<td>
<p>Which nodes to convert? If <code>NULL</code>, all
nodes used in the scene will be converted, otherwise only
the listed ones and their children.
</p>
</td></tr>
<tr><td><code id="as.rglscene.gltf_+3A_userglinfo">useRGLinfo</code></td>
<td>
<p><code>"gltf"</code> objects contain RGL-specific information
in &ldquo;extra&rdquo; fields.  If <code>useRGLinfo</code> is <code>TRUE</code>, we use
that information, otherwise include only what standard glTF viewers would display.</p>
</td></tr>
<tr><td><code id="as.rglscene.gltf_+3A_time">time</code></td>
<td>
<p>Set the &quot;time&quot; within an animation.</p>
</td></tr>
<tr><td><code id="as.rglscene.gltf_+3A_ani">ani</code></td>
<td>
<p>Animation number to use.</p>
</td></tr>
<tr><td><code id="as.rglscene.gltf_+3A_clone">clone</code></td>
<td>
<p>Whether to clone the <code>gltf</code> object.  See the Details below.</p>
</td></tr>
<tr><td><code id="as.rglscene.gltf_+3A_quick">quick</code></td>
<td>
<p>If <code>TRUE</code>, <code><a href="#topic+plot3d">plot3d</a></code> will work
on the result, but it is not sufficiently complete to use
as the scene in <code><a href="rgl.html#topic+rglwidget">rglwidget</a></code>.</p>
</td></tr>
<tr><td><code id="as.rglscene.gltf_+3A_add">add</code></td>
<td>
<p>If <code>quick = FALSE</code>, the scene will be plotted
in an existing rgl scene, and both old and new parts will be returned.</p>
</td></tr>
<tr><td><code id="as.rglscene.gltf_+3A_...">...</code></td>
<td>
<p><code>as.mesh3d</code> passes these arguments to <code>as.rglscene</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions need to modify the glTF object, caching
some information to help with the conversion.  By default
they do this on a cloned copy of it, and the original is
left unchanged.  If the object has already been cloned
this can be skipped by setting <code>clone = FALSE</code>.
</p>


<h3>Value</h3>

<p>An <code>"rglscene"</code> object.
</p>

<hr>
<h2 id='extractTexture'>
Extract a texture file from a glTF object
</h2><span id='topic+extractTexture'></span>

<h3>Description</h3>

<p>Extracts a texture from a glTF object, and writes it
to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractTexture(gltf, index = 0,
               outfile = tempfile(),
               verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractTexture_+3A_gltf">gltf</code></td>
<td>

<p>The glTF object.
</p>
</td></tr>
<tr><td><code id="extractTexture_+3A_index">index</code></td>
<td>

<p>The texture number (starting from 0).
</p>
</td></tr>
<tr><td><code id="extractTexture_+3A_outfile">outfile</code></td>
<td>

<p>The filename to write to.  If <code>outfile</code> has no
file extension, one will be added based on the MIME type
of the texture.
</p>
</td></tr>
<tr><td><code id="extractTexture_+3A_verbose">verbose</code></td>
<td>

<p>Whether to report on success.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since <span class="pkg">rgl</span> doesn't support any texture format except
PNG, this function will attempt to convert JPEG textures to
PNG.  To do that it needs to have the <span class="pkg">jpeg</span> and <span class="pkg">png</span>
packages available.
</p>


<h3>Value</h3>

<p>Returns the filename that was written, or <code>NULL</code>
if the request failed.
</p>
<p>If <code>closeConnections = FALSE</code>, the filename will have
attribute <code>"gltf"</code> containing the <code>gltf</code>
object which might now contain a new open connection.
</p>
<p>If the texture has a recorded MIME type in <code>gltf</code>,
that will be returned in attribute <code>"mimeType"</code>.
</p>

<hr>
<h2 id='findEntry'>
Find a component of a recursive object
</h2><span id='topic+findEntry'></span><span id='topic+namePattern'></span><span id='topic+hasClass'></span>

<h3>Description</h3>

<p><code>findEntry</code> searches recursive objects for components
matching a condition.  <code>namePattern</code> creates a test of
whether the component name matches a pattern.  <code>hasClass</code>
creates a test of whether the component has a class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findEntry(x, test, ..., path = c())
namePattern(pattern)
hasClass(class)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findEntry_+3A_x">x</code></td>
<td>

<p>The recursive object to search.
</p>
</td></tr>
<tr><td><code id="findEntry_+3A_test">test</code></td>
<td>

<p>A test function.  See Details below.
</p>
</td></tr>
<tr><td><code id="findEntry_+3A_pattern">pattern</code></td>
<td>

<p>A regexp pattern to match the desired name(s).
</p>
</td></tr>
<tr><td><code id="findEntry_+3A_class">class</code></td>
<td>

<p>A class name to search for.
</p>
</td></tr>
<tr><td><code id="findEntry_+3A_...">...</code></td>
<td>

<p>Optional additional arguments to pass to the test function.
</p>
</td></tr>
<tr><td><code id="findEntry_+3A_path">path</code></td>
<td>

<p>For internal use:  names to prepend to the path.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Utility/debugging functions to search a large recursive object
for a particular component name or class.
</p>
<p>The <code>test</code> function should have header <code>function(name, value)</code>, and may include other arguments which will
be taken from <code>...</code>.
</p>


<h3>Value</h3>

<p><code>findEntry</code> returns
a list with one entry per hit.  Each entry in the list is a named vector
giving the path to the hit, numerically in the values, and as an R expression
by concatenating the names.  The test functions will be passed
single names and values, and should return a single logical result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list( a = list( b = list(c(d="A", e="B"), 1L, 1:3)))
locations &lt;- findEntry(x, namePattern("e"))
locations

#This shows how the result can be used:
x[[locations[[1]]]]
expr &lt;- paste0(c("x", names(locations[[1]])), collapse = "")
expr
eval(parse(text=expr))

findEntry(x, hasClass("integer"))
</code></pre>

<hr>
<h2 id='getTangents'>
Use the MikkTSpace code to generate tangent vectors.
</h2><span id='topic+getTangents'></span>

<h3>Description</h3>

<p>This function generates tangent vectors using the MikkTSpace
code by Morten S. Mikkelsen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTangents(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTangents_+3A_obj">obj</code></td>
<td>

<p>A triangles or quads object as returned by <code>rgl::scene3d()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>glTF files include normal textures, which require the tangent
space to be specified:  the normals at each vertex are
supplemented with a tangent vector and a bitangent vector
that is their cross product.  The standard recommends
that if the glTF file doesn't specify tangents, they should
be generated using the MikkTSpace code.
</p>
<p>Note that a comment in &lsquo;<span class="file">mikktspace.h</span>&rsquo; indicates that
indexing needs to be recalculated after computing the tangents,
so this function works on unindexed inputs, and reapplies
indexing at the end.
</p>


<h3>Value</h3>

<p>A modified copy of the original object, adding a 4 column
<code>tangents</code> entry.  The order and number of indices
may have changed.
</p>


<h3>Author(s)</h3>

<p>Morten S. Mikkelsen, Johannes Kuehnel and Duncan Murdoch.
</p>


<h3>References</h3>

<p>The MikkTSpace code was obtained from <a href="https://github.com/mmikk/MikkTSpace">https://github.com/mmikk/MikkTSpace</a>.  The interface code is based on
code from <a href="https://www.turais.de/using-mikktspace-in-your-project/">https://www.turais.de/using-mikktspace-in-your-project/</a> by Johannes Kuehnel.
</p>

<hr>
<h2 id='Gltf'>R6 Class for glTF file objects</h2><span id='topic+Gltf'></span>

<h3>Description</h3>

<p>The glTF file spec is described here: <a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html</a>.  This
object encapsulates most of the data from those files.
</p>


<h3>Super class</h3>

<p><code><a href="rgl.html#topic+Buffer">rgl::Buffer</a></code> -&gt; <code>gltf</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>scene</code></dt><dd><p>The default scene number</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-gltf-new"><code>Gltf$new()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-addAccessor"><code>Gltf$addAccessor()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getScene"><code>Gltf$getScene()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-setScene"><code>Gltf$setScene()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-addScene"><code>Gltf$addScene()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-addToScene"><code>Gltf$addToScene()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-defaultScene"><code>Gltf$defaultScene()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getNode"><code>Gltf$getNode()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-setNode"><code>Gltf$setNode()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-addNode"><code>Gltf$addNode()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-addChild"><code>Gltf$addChild()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-setParents"><code>Gltf$setParents()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getSkin"><code>Gltf$getSkin()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-setSkin"><code>Gltf$setSkin()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getJoint"><code>Gltf$getJoint()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getInverseBindMatrices"><code>Gltf$getInverseBindMatrices()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getForwardBindMatrices"><code>Gltf$getForwardBindMatrices()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getCamera"><code>Gltf$getCamera()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getExtras"><code>Gltf$getExtras()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-setExtras"><code>Gltf$setExtras()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getMesh"><code>Gltf$getMesh()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-setMesh"><code>Gltf$setMesh()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-addMesh"><code>Gltf$addMesh()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getMaterial"><code>Gltf$getMaterial()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getTexture"><code>Gltf$getTexture()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getImage"><code>Gltf$getImage()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-addMaterial"><code>Gltf$addMaterial()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-addTexture"><code>Gltf$addTexture()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-addImage"><code>Gltf$addImage()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-addSampler"><code>Gltf$addSampler()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getMaterialNumber"><code>Gltf$getMaterialNumber()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-writeVectors"><code>Gltf$writeVectors()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-makePrimitive"><code>Gltf$makePrimitive()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getAsset"><code>Gltf$getAsset()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-setAsset"><code>Gltf$setAsset()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getTransform"><code>Gltf$getTransform()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getRglMaterial"><code>Gltf$getRglMaterial()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-getAnimation"><code>Gltf$getAnimation()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-setAnimation"><code>Gltf$setAnimation()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-timerange"><code>Gltf$timerange()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-initAnimation"><code>Gltf$initAnimation()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-settime"><code>Gltf$settime()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-print"><code>Gltf$print()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-listCount"><code>Gltf$listCount()</code></a>
</p>
</li>
<li> <p><a href="#method-gltf-clone"><code>Gltf$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="addBufferView"><a href='../../rgl/html/Buffer.html#method-Buffer-addBufferView'><code>rgl::Buffer$addBufferView()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="as.list"><a href='../../rgl/html/Buffer.html#method-Buffer-as.list'><code>rgl::Buffer$as.list()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="closeBuffer"><a href='../../rgl/html/Buffer.html#method-Buffer-closeBuffer'><code>rgl::Buffer$closeBuffer()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="closeBuffers"><a href='../../rgl/html/Buffer.html#method-Buffer-closeBuffers'><code>rgl::Buffer$closeBuffers()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="dataURI"><a href='../../rgl/html/Buffer.html#method-Buffer-dataURI'><code>rgl::Buffer$dataURI()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="getAccessor"><a href='../../rgl/html/Buffer.html#method-Buffer-getAccessor'><code>rgl::Buffer$getAccessor()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="getBuffer"><a href='../../rgl/html/Buffer.html#method-Buffer-getBuffer'><code>rgl::Buffer$getBuffer()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="getBufferview"><a href='../../rgl/html/Buffer.html#method-Buffer-getBufferview'><code>rgl::Buffer$getBufferview()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="load"><a href='../../rgl/html/Buffer.html#method-Buffer-load'><code>rgl::Buffer$load()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="openBuffer"><a href='../../rgl/html/Buffer.html#method-Buffer-openBuffer'><code>rgl::Buffer$openBuffer()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="openBufferview"><a href='../../rgl/html/Buffer.html#method-Buffer-openBufferview'><code>rgl::Buffer$openBufferview()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="readAccessor"><a href='../../rgl/html/Buffer.html#method-Buffer-readAccessor'><code>rgl::Buffer$readAccessor()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="readAccessor0"><a href='../../rgl/html/Buffer.html#method-Buffer-readAccessor0'><code>rgl::Buffer$readAccessor0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="saveOpenBuffer"><a href='../../rgl/html/Buffer.html#method-Buffer-saveOpenBuffer'><code>rgl::Buffer$saveOpenBuffer()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="setAccessor"><a href='../../rgl/html/Buffer.html#method-Buffer-setAccessor'><code>rgl::Buffer$setAccessor()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="setBuffer"><a href='../../rgl/html/Buffer.html#method-Buffer-setBuffer'><code>rgl::Buffer$setBuffer()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="setBufferview"><a href='../../rgl/html/Buffer.html#method-Buffer-setBufferview'><code>rgl::Buffer$setBufferview()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgl" data-topic="Buffer" data-id="writeBuffer"><a href='../../rgl/html/Buffer.html#method-Buffer-writeBuffer'><code>rgl::Buffer$writeBuffer()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-gltf-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Gltf$new(json = NULL, defaultbin = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>json</code></dt><dd><p>List read from glTF file.</p>
</dd>
<dt><code>defaultbin</code></dt><dd><p>Optional external binary file.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-gltf-addAccessor"></a>



<h4>Method <code>addAccessor()</code></h4>

<p>Write values to accessor, including <code>min</code> and <code>max</code>.
</p>
<p>The glTF standard requires <code>min</code> and <code>max</code> values in
accessors, whereas other uses of buffers may not.
This function stores in the usual way using the
<code><a href="rgl.html#topic+Buffer">Buffer$addAccessor()</a></code> method, and then adds
<code>min</code> and <code>max</code> values.
</p>
<p>The standard also doesn't support signed 4 byte integers
or double precision values, so we test for those here.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$addAccessor(values, target = NULL, types = "anyGLTF", normalized = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>values</code></dt><dd><p>Values to write.</p>
</dd>
<dt><code>target</code></dt><dd><p>Optional target use for values.</p>
</dd>
<dt><code>types</code></dt><dd><p>Allowed types (from names of <code>rgl::gltfTypes</code>), or <code>c("any", "anyGLTF")</code>).</p>
</dd>
<dt><code>normalized</code></dt><dd><p>Are these normalized
integer values?</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New accessor number.
</p>


<hr>
<a id="method-gltf-getScene"></a>



<h4>Method <code>getScene()</code></h4>

<p>Get scene object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getScene(sc)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sc</code></dt><dd><p>Scene number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Scene object, documented here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-scene">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-scene</a>.
</p>


<hr>
<a id="method-gltf-setScene"></a>



<h4>Method <code>setScene()</code></h4>

<p>Update scene record.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$setScene(sc, scene)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sc</code></dt><dd><p>Which scene to update.</p>
</dd>
<dt><code>scene</code></dt><dd><p>New scene record.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-gltf-addScene"></a>



<h4>Method <code>addScene()</code></h4>

<p>Add a scene object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$addScene()</pre></div>



<h5>Returns</h5>

<p>Scene number.
</p>


<hr>
<a id="method-gltf-addToScene"></a>



<h4>Method <code>addToScene()</code></h4>

<p>Add node to scene.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$addToScene(scene, node)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scene</code></dt><dd><p>Scene number to modify.</p>
</dd>
<dt><code>node</code></dt><dd><p>Node number(s) to add.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-gltf-defaultScene"></a>



<h4>Method <code>defaultScene()</code></h4>

<p>Get default scene, creating it if necessary.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$defaultScene()</pre></div>



<h5>Returns</h5>

<p>Scene number.
</p>


<hr>
<a id="method-gltf-getNode"></a>



<h4>Method <code>getNode()</code></h4>

<p>Get node object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getNode(n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Node number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Node object, documented here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-node">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-node</a>.
</p>


<hr>
<a id="method-gltf-setNode"></a>



<h4>Method <code>setNode()</code></h4>

<p>Set node object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$setNode(n, node)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Node number.</p>
</dd>
<dt><code>node</code></dt><dd><p>New node object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-gltf-addNode"></a>



<h4>Method <code>addNode()</code></h4>

<p>Add a node object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$addNode(mesh = NULL, matrix = NULL, extras = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mesh</code></dt><dd><p>A mesh number.</p>
</dd>
<dt><code>matrix</code></dt><dd><p>A matrix transformation for the node.</p>
</dd>
<dt><code>extras</code></dt><dd><p>A list of extras, typically <code>rgl</code> objects.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Node number.
</p>


<hr>
<a id="method-gltf-addChild"></a>



<h4>Method <code>addChild()</code></h4>

<p>Add node as child of another.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$addChild(parent, node)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parent</code></dt><dd><p>Node number to modify.</p>
</dd>
<dt><code>node</code></dt><dd><p>Node number(s) to add as children.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-gltf-setParents"></a>



<h4>Method <code>setParents()</code></h4>

<p>Set parent member for all nodes
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$setParents()</pre></div>


<hr>
<a id="method-gltf-getSkin"></a>



<h4>Method <code>getSkin()</code></h4>

<p>Get skin object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getSkin(skin)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>skin</code></dt><dd><p>Skin number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Skin object, documented here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-skin">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-skin</a>.
</p>


<hr>
<a id="method-gltf-setSkin"></a>



<h4>Method <code>setSkin()</code></h4>

<p>Set skin object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$setSkin(n, skin)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Skin number.</p>
</dd>
<dt><code>skin</code></dt><dd><p>New skin object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-gltf-getJoint"></a>



<h4>Method <code>getJoint()</code></h4>

<p>Get joint node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getJoint(skin, num)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>skin</code></dt><dd><p>Skin number.</p>
</dd>
<dt><code>num</code></dt><dd><p>Joint number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Node object
</p>


<hr>
<a id="method-gltf-getInverseBindMatrices"></a>



<h4>Method <code>getInverseBindMatrices()</code></h4>

<p>Get &quot;inverse bind matrices&quot;.
</p>
<p>These matrices undo the existing
transformation before applying the skin
transformations.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getInverseBindMatrices(skin)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>skin</code></dt><dd><p>Skin number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A 4x4xn array of matrices, one per joint.
</p>


<hr>
<a id="method-gltf-getForwardBindMatrices"></a>



<h4>Method <code>getForwardBindMatrices()</code></h4>

<p>Get &quot;forward bind matrices&quot;.
</p>
<p>These matrices applying the skin
transformations.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getForwardBindMatrices(skin)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>skin</code></dt><dd><p>Skin number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A 4x4xn array of matrices, one per joint.
</p>


<hr>
<a id="method-gltf-getCamera"></a>



<h4>Method <code>getCamera()</code></h4>

<p>Get camera object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getCamera(cam)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cam</code></dt><dd><p>Camera number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Camera object, documented here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-camera">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-camera</a>.
</p>


<hr>
<a id="method-gltf-getExtras"></a>



<h4>Method <code>getExtras()</code></h4>

<p>Get top-level extras list.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getExtras()</pre></div>



<h5>Returns</h5>

<p>Extras list, including rgl objects.
</p>


<hr>
<a id="method-gltf-setExtras"></a>



<h4>Method <code>setExtras()</code></h4>

<p>Set extras list.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$setExtras(extras)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>extras</code></dt><dd><p>New extras list.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-gltf-getMesh"></a>



<h4>Method <code>getMesh()</code></h4>

<p>Get mesh object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getMesh(m)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>m</code></dt><dd><p>Mesh number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Mesh object, documented here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-mesh">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-mesh</a>.
</p>


<hr>
<a id="method-gltf-setMesh"></a>



<h4>Method <code>setMesh()</code></h4>

<p>Set mesh object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$setMesh(m, mesh)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>m</code></dt><dd><p>Mesh number.</p>
</dd>
<dt><code>mesh</code></dt><dd><p>New mesh object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-gltf-addMesh"></a>



<h4>Method <code>addMesh()</code></h4>

<p>Add a mesh object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$addMesh(primitives)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>primitives</code></dt><dd><p>A list of primitive objects.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Mesh number.
</p>


<hr>
<a id="method-gltf-getMaterial"></a>



<h4>Method <code>getMaterial()</code></h4>

<p>Get material object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getMaterial(m)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>m</code></dt><dd><p>Material number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Material object, documented here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-material">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-material</a>.
</p>


<hr>
<a id="method-gltf-getTexture"></a>



<h4>Method <code>getTexture()</code></h4>

<p>Get texture object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getTexture(tex)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tex</code></dt><dd><p>Texture number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Texture object, documented here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-texture">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-texture</a>.
</p>


<hr>
<a id="method-gltf-getImage"></a>



<h4>Method <code>getImage()</code></h4>

<p>Get image object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getImage(im)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>im</code></dt><dd><p>Image number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Image object, documented here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-image">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-image</a>.
</p>


<hr>
<a id="method-gltf-addMaterial"></a>



<h4>Method <code>addMaterial()</code></h4>

<p>Construct and possibly add material.
</p>
<p>This will return an existing material if possible.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$addMaterial(mat, defaultMaterial = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mat</code></dt><dd><p>An <code>rgl</code> material record.</p>
</dd>
<dt><code>defaultMaterial</code></dt><dd><p>Default material properties.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Material number.
</p>


<hr>
<a id="method-gltf-addTexture"></a>



<h4>Method <code>addTexture()</code></h4>

<p>Add a texture.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$addTexture(mat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mat</code></dt><dd><p>An <code>rgl</code> material record.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Texture number.
</p>


<hr>
<a id="method-gltf-addImage"></a>



<h4>Method <code>addImage()</code></h4>

<p>Add an image for a texture.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$addImage(mat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mat</code></dt><dd><p>An <code>rgl</code> material record.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Image number.
</p>


<hr>
<a id="method-gltf-addSampler"></a>



<h4>Method <code>addSampler()</code></h4>

<p>Add a sampler.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$addSampler(mat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mat</code></dt><dd><p>An <code>rgl</code> material record.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Sampler number.
</p>


<hr>
<a id="method-gltf-getMaterialNumber"></a>



<h4>Method <code>getMaterialNumber()</code></h4>

<p>Add or return a material.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getMaterialNumber(material)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>material</code></dt><dd><p>A glTF material record.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Material number.
</p>


<hr>
<a id="method-gltf-writeVectors"></a>



<h4>Method <code>writeVectors()</code></h4>

<p>Write data.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$writeVectors(
  coords,
  target = targetArray,
  types = "anyGLTF",
  normalized = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>coords</code></dt><dd><p>Data to write, or <code>NULL</code>.</p>
</dd>
<dt><code>target</code></dt><dd><p>Optional target use for data.</p>
</dd>
<dt><code>types</code></dt><dd><p>A character vector of allowed types, or &quot;any&quot; or &quot;anyGLTF&quot;</p>
</dd>
<dt><code>normalized</code></dt><dd><p>Are these integer values representing floats?</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Accessor number, or <code>NULL</code>.
</p>


<hr>
<a id="method-gltf-makePrimitive"></a>



<h4>Method <code>makePrimitive()</code></h4>

<p>Create a primitive record.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$makePrimitive(inds, mode = NULL, attributes = NULL, matnum = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inds</code></dt><dd><p>Indices of vertices.</p>
</dd>
<dt><code>mode</code></dt><dd><p>Mode of primitive.</p>
</dd>
<dt><code>attributes</code></dt><dd><p>Primitive attributes.</p>
</dd>
<dt><code>matnum</code></dt><dd><p>Material number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Primitive record, documented here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-primitive">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-primitive</a>.
</p>


<hr>
<a id="method-gltf-getAsset"></a>



<h4>Method <code>getAsset()</code></h4>

<p>Get asset list.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getAsset()</pre></div>



<h5>Returns</h5>

<p>Asset object, documented here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-asset">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-asset</a>.
</p>


<hr>
<a id="method-gltf-setAsset"></a>



<h4>Method <code>setAsset()</code></h4>

<p>Set asset list.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$setAsset(version, generator)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>version</code></dt><dd><p>Version number of glTF format.</p>
</dd>
<dt><code>generator</code></dt><dd><p>Identifier of code generating it.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-gltf-getTransform"></a>



<h4>Method <code>getTransform()</code></h4>

<p>Get local transform.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getTransform(n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Node number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>4x4 matrix of local transform.
</p>


<hr>
<a id="method-gltf-getRglMaterial"></a>



<h4>Method <code>getRglMaterial()</code></h4>

<p>Reconstruct <code>rgl</code> material.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getRglMaterial(n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Material number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>rgl</code> material record.
</p>


<hr>
<a id="method-gltf-getAnimation"></a>



<h4>Method <code>getAnimation()</code></h4>

<p>Get animation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$getAnimation(ani)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ani</code></dt><dd><p>Animation number</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Animation object, documented here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-animation">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-animation</a>.
</p>


<hr>
<a id="method-gltf-setAnimation"></a>



<h4>Method <code>setAnimation()</code></h4>

<p>Set animation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$setAnimation(ani, animation)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ani</code></dt><dd><p>Animation number</p>
</dd>
<dt><code>animation</code></dt><dd><p>New animation object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-gltf-timerange"></a>



<h4>Method <code>timerange()</code></h4>

<p>Find time range of an animation
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$timerange(ani)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ani</code></dt><dd><p>Animation number</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Min and max times from the samplers in the animation.
</p>


<hr>
<a id="method-gltf-initAnimation"></a>



<h4>Method <code>initAnimation()</code></h4>

<p>Initialize animation.
</p>
<p>This builds all of the interpolation functions
in the samplers.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$initAnimation(ani)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ani</code></dt><dd><p>Animation number</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Modified animation object
</p>


<hr>
<a id="method-gltf-settime"></a>



<h4>Method <code>settime()</code></h4>

<p>Set time for an animation.
</p>
<p>This evaluates all the interpolators and modifies
self to reflect the specified time point.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$settime(time, ani = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>time</code></dt><dd><p>Time to set.</p>
</dd>
<dt><code>ani</code></dt><dd><p>Animation number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of node numbers that were changed.
</p>


<hr>
<a id="method-gltf-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print <code>gltf</code> objects with various levels of detail.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$print(verbose = FALSE, names = FALSE, showExtras = TRUE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>Logical indicator of verbose printing, or
character vector of components to print verbosely.</p>
</dd>
<dt><code>names</code></dt><dd><p>Print names for components.</p>
</dd>
<dt><code>showExtras</code></dt><dd><p>Logical:  show extra fields?</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed <code>...</code> .</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
samples &lt;- "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0"
gltf &lt;- readGLB(paste0(samples, "/2CylinderEngine/glTF-Binary/2CylinderEngine.glb?raw=true"))
gltf$print(names = "meshes")
}
</pre>
</div>


<hr>
<a id="method-gltf-listCount"></a>



<h4>Method <code>listCount()</code></h4>

<p>Get number of items in private list.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$listCount(list)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>list</code></dt><dd><p>Name of list to get.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-gltf-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gltf$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Gltf$print`
## ------------------------------------------------


samples &lt;- "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0"
gltf &lt;- readGLB(paste0(samples, "/2CylinderEngine/glTF-Binary/2CylinderEngine.glb?raw=true"))
gltf$print(names = "meshes")

</code></pre>

<hr>
<h2 id='gltfWidget'>
Create a widget for a glTF display.
</h2><span id='topic+gltfWidget'></span>

<h3>Description</h3>

<p>This creates a widget holding a glTF scene, with controls
to animate it if it supports animation, and with
shaders that implement normal textures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gltfWidget(gltf,
           animation = 0,
           start = times[1], stop = times[2],
           times = gltf$timerange(animation),
           method = c("shader", "rigid"),
           add = FALSE, close = !add,
           verbose = FALSE,
           open3dParams = getr3dDefaults(),
           usePBR = hasPBRparams(gltf),
           PBRargs = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gltfWidget_+3A_gltf">gltf</code></td>
<td>

<p>A <code>"gltf"</code> object, e.g. produced by <code><a href="#topic+readglTF">readglTF</a></code>.
</p>
</td></tr>
<tr><td><code id="gltfWidget_+3A_animation">animation</code></td>
<td>

<p>Which animation to use?  If no animation is present,
this is ignored.
</p>
</td></tr>
<tr><td><code id="gltfWidget_+3A_start">start</code>, <code id="gltfWidget_+3A_stop">stop</code></td>
<td>

<p>The starting and stopping times for the animation.  Ignored
if no animation.
</p>
</td></tr>
<tr><td><code id="gltfWidget_+3A_times">times</code></td>
<td>

<p>An alternate way to specify the times.  Ignored if no
animation.
</p>
</td></tr>
<tr><td><code id="gltfWidget_+3A_method">method</code></td>
<td>

<p>The
<code>"shader"</code> method installs a custom shader to implement
the animation in GLSL, as intended for glTF.  This is necessary
for the normal texture support.
The <code>"rigid"</code> method duplicates vertices as necessary so
that all triangles remain rigid as the vertices move, and
should match the corresponding method in <code><a href="#topic+playgltf">playgltf</a></code>.
</p>
</td></tr>
<tr><td><code id="gltfWidget_+3A_add">add</code></td>
<td>

<p>Should the gltf object be added to an existing <span class="pkg">rgl</span>
scene, or should it open a new scene?
</p>
</td></tr>
<tr><td><code id="gltfWidget_+3A_close">close</code></td>
<td>

<p>Should <code>gltfWidget</code> close the <span class="pkg">rgl</span> scene after
producing the widget?
</p>
</td></tr>
<tr><td><code id="gltfWidget_+3A_verbose">verbose</code></td>
<td>

<p>Give some progress information.
</p>
</td></tr>
<tr><td><code id="gltfWidget_+3A_open3dparams">open3dParams</code></td>
<td>

<p>A list to pass as the <code>params</code> argument to
<code><a href="rgl.html#topic+open3d">open3d</a></code>.
</p>
</td></tr>
<tr><td><code id="gltfWidget_+3A_usepbr">usePBR</code></td>
<td>

<p>Whether to use physically based rendering methods.
The default
uses an internal function to determine if <code>gltf</code>
actually contains PBR parameters.
</p>
</td></tr>
<tr><td><code id="gltfWidget_+3A_pbrargs">PBRargs</code></td>
<td>

<p>A list containing optional arguments to the <code><a href="#topic+setPBRshaders">setPBRshaders</a></code> function.
</p>
</td></tr>
<tr><td><code id="gltfWidget_+3A_...">...</code></td>
<td>

<p>Additional parameters which will be passed to <code>rgl::<a href="rgl.html#topic+playwidget">playwidget</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+playgltf">playgltf</a></code> for a description of the method
used for animation.  The <code>"fixed"</code> method is fast, but
doesn't do a good job on some animations.
</p>
<p>If the <code>gltf</code> object doesn't contain any animations,
or <code>animation = NA</code>, this
will simply display it as a widget with no controls.
</p>


<h3>Value</h3>

<p>A widget suitable for display or inclusion in an
R Markdown document.
</p>


<h3>Note</h3>

<p>Physically based rendering (PBR, controlled by <code>usePBR</code>) is
only used with <code>method = "shader"</code>.
</p>
<p>If PBR is not used,
the <span class="pkg">V8</span> package is required so that the shaders can be
modified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if ((interactive() || rgl::in_pkgdown_example()) &amp;&amp; requireNamespace("manipulateWidget")) {
  gltf &lt;- readGLB(system.file("glb/RiggedSimple.glb", package = "rgl2gltf"))
  gltfWidget(gltf)
}

</code></pre>

<hr>
<h2 id='imports'>
Imports from rgl
</h2><span id='topic+plot3d'></span><span id='topic+as.rglscene'></span><span id='topic+as.mesh3d'></span>

<h3>Description</h3>

<p>These generic functions are imported from <span class="pkg">rgl</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3d(x, ...)
as.rglscene(x, ...)
as.mesh3d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imports_+3A_x">x</code></td>
<td>

<p>Objects to handle.
</p>
</td></tr>
<tr><td><code id="imports_+3A_...">...</code></td>
<td>

<p>Additional arguments to pass to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main documentation for these generics is in <span class="pkg">rgl</span>:
<code><a href="rgl.html#topic+plot3d">plot3d</a></code>.
</p>
<p>This package defines <code>"gltf"</code> methods for the generics.
Documentation for <code><a href="#topic+as.rglscene.gltf">as.rglscene.gltf</a></code> is included.
</p>

<hr>
<h2 id='matrixSequence'>
Print the sequence of matrices affecting an object.
</h2><span id='topic+matrixSequence'></span><span id='topic+print.matrixSequence'></span>

<h3>Description</h3>

<p>This is used for debugging, to see how an object within
nested <span class="pkg">rgl</span> subscenes is affected by their user matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixSequence(tag, scene = scene3d())
## S3 method for class 'matrixSequence'
print(x, n = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrixSequence_+3A_tag">tag</code></td>
<td>

<p>Which objects to report on?
</p>
</td></tr>
<tr><td><code id="matrixSequence_+3A_scene">scene</code></td>
<td>

<p>The <span class="pkg">rgl</span> scene to work from.
</p>
</td></tr>
<tr><td><code id="matrixSequence_+3A_x">x</code></td>
<td>

<p>Object to print.
</p>
</td></tr>
<tr><td><code id="matrixSequence_+3A_n">n</code></td>
<td>

<p>In the print method, how many vertices and indices should be printed?
</p>
</td></tr>
<tr><td><code id="matrixSequence_+3A_...">...</code></td>
<td>
<p> Ignored. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing records with entries as follows:
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p>The object id</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>The object's vertices</p>
</td></tr>
<tr><td><code>indices</code></td>
<td>
<p>The object's indices</p>
</td></tr>
<tr><td><code>userMatrix</code></td>
<td>
<p>A list of user matrices affecting this object</p>
</td></tr>
</table>

<hr>
<h2 id='modifyShaders'>
Edit shader code
</h2><span id='topic+modifyShaders'></span>

<h3>Description</h3>

<p>This function applies specified edits to shader code
to support new functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifyShaders(shaders, mod, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modifyShaders_+3A_shaders">shaders</code></td>
<td>

<p>A list of shaders, e.g. as produced by <code><a href="rgl.html#topic+getShaders">getShaders</a></code>.
</p>
</td></tr>
<tr><td><code id="modifyShaders_+3A_mod">mod</code></td>
<td>

<p>Either a character value naming a built-in set of mods (currently just <code>"skins"</code>), or a list of mods as described
in the Details section.
</p>
</td></tr>
<tr><td><code id="modifyShaders_+3A_...">...</code></td>
<td>

<p>Optional arguments; all will be passed to any functions
in <code>mods</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mods</code> argument is organized in a nested list.
</p>

<ol>
<li><p>The top level can contain <code>vertexShader</code> and
<code>fragmentShader</code> components.
</p>
</li>
<li><p>Each of those is a list of changes to apply to
that shader.
</p>
</li>
<li><p>Each change is a list with <code>old</code> and <code>new</code>
entries.
</p>
</li>
<li><p>The <code>old</code> entry is used as a &quot;fixed&quot; pattern to
select one or more lines from the shader to be replaced.
Multiple matches are allowed, but they shouldn't overlap.
Changes will be applied in the order specified, so take care
that a pattern doesn't match new text from an earlier change.
</p>
</li>
<li><p>The <code>new</code> entry contains the replacement.  It
can either be a character vector or a function that returns
a character vector.  If it is a function, it will be passed
the <code>...</code> argument.
</p>
<p>See <code>rgl2gltf:::shaderChanges</code> for the built-in modifications.

</p>
</li></ol>



<h3>Value</h3>

<p>A new shader object incorporating the edits.
</p>

<hr>
<h2 id='playgltf'>
Play an animated glTF object.
</h2><span id='topic+playgltf'></span><span id='topic+showNodes'></span>

<h3>Description</h3>

<p>&lsquo;<span class="file">.gltf</span>&rsquo; and &lsquo;<span class="file">.glb</span>&rsquo; files can contain animation instructions.
This function interprets them and plays them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>playgltf(gltf, animation = 0,
         start = times[1], stop = times[2],
         times = gltf$timerange(animation),
         method = c("rigid", "wholeScene", "partialScene"),
         speed = 1, by = NULL, verbose = FALSE, ...)
showNodes(gltf, animation = 0,
          start = times[1], stop = times[2],
          times = gltf$timerange(animation),
          speed = 1, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="playgltf_+3A_gltf">gltf</code></td>
<td>

<p>A <code>"gltf"</code> object.
</p>
</td></tr>
<tr><td><code id="playgltf_+3A_animation">animation</code></td>
<td>

<p>Which animation from the object?  An integer from 0 to the
number of animations defined in <code>gltf</code>.
</p>
</td></tr>
<tr><td><code id="playgltf_+3A_start">start</code>, <code id="playgltf_+3A_stop">stop</code></td>
<td>

<p>Starting and stopping times.
</p>
</td></tr>
<tr><td><code id="playgltf_+3A_times">times</code></td>
<td>

<p>An alternate way to specify <code>start</code> and <code>stop</code>.
</p>
</td></tr>
<tr><td><code id="playgltf_+3A_method">method</code></td>
<td>

<p>Which drawing method to use?  See details below.
</p>
</td></tr>
<tr><td><code id="playgltf_+3A_speed">speed</code>, <code id="playgltf_+3A_by">by</code></td>
<td>

<p>Control the updates; see details below.
</p>
</td></tr>
<tr><td><code id="playgltf_+3A_verbose">verbose</code></td>
<td>

<p>Whether to print status updates.
</p>
</td></tr>
<tr><td><code id="playgltf_+3A_...">...</code></td>
<td>

<p>Parameter settings to pass to <code><a href="rgl.html#topic+plot3d.rglscene">plot3d.rglscene</a></code> (and hence
to <code><a href="rgl.html#topic+open3d">open3d</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>glTF files are animated by time dependent changes to the
transformations in their nodes.  Those transformations
correspond to RGL <code>par3d("userMatrix")</code> settings in
subscenes and can sometimes be directly imported as such.
</p>
<p>However, glTF files also support &quot;skins&quot;, a computer graphics
concept not supported in RGL.  A skin is a way to say that
different vertices of the same object (typically a triangle mesh)
respond to different nodes.  This allows shapes to be stretched,
similar to skin on a moving body.  RGL assumes that all
graphics objects are rigid.
</p>
<p>The <code>playgltf</code> function provides partial support for
skins.  Using the <code>"wholeScene"</code> method, it can modify the vertices of an entire scene
and redraw the scene.  Typically this is quite slow, and
not very satisfactory.  The <code>"partialScene"</code> method
allows only the
changed objects to be redrawn, which might help speed things up.
Finally, the <code>"rigid"</code> method converts all polygons
to rigid ones that are supported by <span class="pkg">rgl</span>, so that motion
is done by changes to the transformations.  This is likely the fastest
method, but for some animations the errors introduced by the
conversion are unacceptably large.
</p>
<p>The <code>showNodes</code> function displays each node number as
text at the origin for that node.  By default it plays the
animation showing how the nodes move.
</p>
<p>For both functions, the <code>speed</code> and <code>by</code> arguments
specify the &ldquo;times&rdquo; at which the animation is drawn.  If
<code>by</code> is specified, then a frame is drawn at time <code>start</code> and
subsequent frames increment the time by <code>by</code>.  If it is
<code>NULL</code> (the default), then the <code>speed</code> argument is used
as a multiplier on the internal time (taken to be in seconds).
For example, with the default <code>speed = 1</code>, the first frame will
be drawn at time <code>start</code>, and when it is complete, the next one
will be drawn according to how many seconds have passed in real time,
etc.
</p>


<h3>Value</h3>

<p>Called for the side effect of drawing the animation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive() &amp;&amp; !rgl::in_pkgdown_example()) {
# This example is fast enough using the "whole" method:

gltf1 &lt;- readGLB(system.file("glb/RiggedSimple.glb", package = "rgl2gltf"))
playgltf(gltf1, start = 0, stop = 3, method = "whole")

# It looks terrible using the "rigid" method, because some triangles
# need to be deformed:

playgltf(gltf1, start = 0, stop = 3, method = "rigid")

# This example is too slow using anything but "rigid", but it's fine there:

samples &lt;- "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0"
gltf2 &lt;- readGLB(paste0(samples, "/BrainStem/glTF-Binary/BrainStem.glb?raw=true"))
playgltf(gltf2, start = 0, stop = 2, speed = 0.25, method = "rigid")
}

</code></pre>

<hr>
<h2 id='readGLB'>
Read a GLB file.
</h2><span id='topic+readGLB'></span>

<h3>Description</h3>

<p>GLB is the self-contained binary format of glTF
files.  This function reads one, extracts the embedded files
into the temporary directory, and returns a <code>"gltf"</code>
object containing the information in R format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readGLB(con, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readGLB_+3A_con">con</code></td>
<td>

<p>The connection or filename to read from.
</p>
</td></tr>
<tr><td><code id="readGLB_+3A_verbose">verbose</code></td>
<td>

<p>Whether to report on the process.
</p>
</td></tr>
<tr><td><code id="readGLB_+3A_...">...</code></td>
<td>

<p>Currently unused.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"gltf"</code>.  This is an R version of
the structure represented by a &ldquo;glTF&rdquo; file's JSON
information.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>The specification of the glTF format:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readglTF">readglTF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This web page has lots of sample files

samples &lt;- "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0"

# Get one of them:  an avocado

gltf &lt;- readGLB(paste0(samples, "/Avocado/glTF-Binary/Avocado.glb?raw=true"))

if (interactive())
  rgl::plot3d(gltf)

if (rgl::in_pkgdown_example())
  gltfWidget(gltf)

gltf$closeBuffers()

</code></pre>

<hr>
<h2 id='readglTF'>
Read a glTF file
</h2><span id='topic+readglTF'></span>

<h3>Description</h3>

<p>The glTF file is the JSON part of a glTF representation of a 3D
scene.  This function reads one and returns a <code>"gltf"</code>
object containing the information in R format.
</p>
<p>Typically most of the data for the scene is contained in other
files named in this one, usually found in the same file
folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readglTF(path, defaultbin = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readglTF_+3A_path">path</code></td>
<td>

<p>The path to the file being read.  R connections
cannot be used.
</p>
</td></tr>
<tr><td><code id="readglTF_+3A_defaultbin">defaultbin</code></td>
<td>

<p>The name of the default associated binary file, if it is
not named in the JSON.  This is typically used when the JSON
has been extracted from a GLB file.
</p>
</td></tr>
<tr><td><code id="readglTF_+3A_...">...</code></td>
<td>

<p>Not currently used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"gltf"</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>The specification of the glTF format:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# This web page has lots of sample files

samples &lt;- "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0"
filename &lt;- tempfile(fileext = ".gltf")

# Get one of them:  a 2 cylinder engine.  We need both parts
# to be able to view it, though only the .gltf part is
# needed for readglTF()

download.file(paste0(samples, "/2CylinderEngine/glTF/2CylinderEngine.gltf"),
  destfile = filename)
download.file(paste0(samples, "/2CylinderEngine/glTF/2CylinderEngine0.bin?raw=true"),
  destfile = file.path(tempdir(), "2CylinderEngine0.bin"),
  mode = "wb")

gltf &lt;- readglTF(filename)
gltf

# gltf files contain references to other files using
# relative paths, so we can only use them from their
# own directory
olddir &lt;- setwd(dirname(filename))
rgl::plot3d(gltf)
setwd(olddir)


</code></pre>

<hr>
<h2 id='setPBRshaders'>
Set shaders for physically based rendering.
</h2><span id='topic+setPBRshaders'></span>

<h3>Description</h3>

<p>The glTF format is designed to hold objects which
are intended for &quot;physically based rendering&quot;, where the
parameters of the object map to physical properties such
as metallicity, roughness, etc.  This function
replaces the default <span class="pkg">rgl</span> shaders with PBR shaders
based on the reference implementation in
<a href="https://github.com/KhronosGroup/glTF-Sample-Viewer/tree/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders">https://github.com/KhronosGroup/glTF-Sample-Viewer/tree/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPBRshaders(gltf, gltfMat, id,
              scene = scene3d(minimal = TRUE),
              useIBL = TRUE,
              brdfLUT = system.file("textures/brdfLUT.png", package = "rgl2gltf"),
              IBLspecular = system.file("textures/refmap.png", package = "rgl"),
              IBLdiffuse = system.file("textures/refmapblur.jpeg", package = "rgl2gltf"),
              debugBaseColor = 0,
              debugMetallic = 0,
              debugRoughness = 0,
              debugSpecularReflection = 0,
              debugGeometricOcclusion = 0,
              debugMicrofacetDistribution = 0,
              debugSpecContrib = 0,
              debugDiffuseContrib = 0,
              debugIBLDiffuse = 1,
              debugIBLSpecular = 1,
              defines = list(),
              uniforms = list(),
              attributes = list(),
              textures = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPBRshaders_+3A_gltf">gltf</code>, <code id="setPBRshaders_+3A_gltfmat">gltfMat</code></td>
<td>

<p>A <code>"gltf"</code> object, and a material record from it.
</p>
</td></tr>
<tr><td><code id="setPBRshaders_+3A_id">id</code>, <code id="setPBRshaders_+3A_scene">scene</code></td>
<td>

<p>The <span class="pkg">rgl</span> id of the corresponding object and the scene holding it.
</p>
</td></tr>
<tr><td><code id="setPBRshaders_+3A_useibl">useIBL</code></td>
<td>

<p>Whether to use image based lighting.
</p>
</td></tr>
<tr><td><code id="setPBRshaders_+3A_brdflut">brdfLUT</code></td>
<td>

<p>The texture to use for the &quot;bidirectional reflectance distribution
function&quot; lookup table.
</p>
</td></tr>
<tr><td><code id="setPBRshaders_+3A_iblspecular">IBLspecular</code></td>
<td>

<p>The texture to use for the &quot;image based specular lighting&quot;.
</p>
</td></tr>
<tr><td><code id="setPBRshaders_+3A_ibldiffuse">IBLdiffuse</code></td>
<td>

<p>The texture to use for the &quot;image based diffuse lighting&quot;.
</p>
</td></tr>
<tr><td><code id="setPBRshaders_+3A_debugbasecolor">debugBaseColor</code>, <code id="setPBRshaders_+3A_debugmetallic">debugMetallic</code>, <code id="setPBRshaders_+3A_debugroughness">debugRoughness</code>, <code id="setPBRshaders_+3A_debugspecularreflection">debugSpecularReflection</code>, <code id="setPBRshaders_+3A_debuggeometricocclusion">debugGeometricOcclusion</code>, <code id="setPBRshaders_+3A_debugmicrofacetdistribution">debugMicrofacetDistribution</code>, <code id="setPBRshaders_+3A_debugspeccontrib">debugSpecContrib</code>, <code id="setPBRshaders_+3A_debugdiffusecontrib">debugDiffuseContrib</code></td>
<td>

<p>These are flags used for debugging.  Setting one of these to
1 will display just that contribution to the rendering.
</p>
</td></tr>
<tr><td><code id="setPBRshaders_+3A_debugibldiffuse">debugIBLDiffuse</code>, <code id="setPBRshaders_+3A_debugiblspecular">debugIBLSpecular</code></td>
<td>

<p>Two more debugging settings.  These should be set to non-negative
values to control the contribution from each of those components
to the image based lighting.
</p>
</td></tr>
<tr><td><code id="setPBRshaders_+3A_defines">defines</code>, <code id="setPBRshaders_+3A_uniforms">uniforms</code>, <code id="setPBRshaders_+3A_attributes">attributes</code>, <code id="setPBRshaders_+3A_textures">textures</code></td>
<td>

<p>Values to use in <code><a href="rgl.html#topic+setUserShaders">setUserShaders</a></code> in addition
to the ones determined by this function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">rgl</span> is designed to work with WebGL version 1, which doesn't
support all of the features used in the reference shaders.  In
particular, no extensions are assumed, and the IBL textures are
single 2D textures rather than cube maps.
</p>


<h3>Value</h3>

<p>This function modifies the <code>id</code> object in <code>scene</code>,
and returns the modified scene.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch for the adaptation to <span class="pkg">rgl</span>, various
others for the original shaders.
</p>


<h3>References</h3>

<p><a href="https://github.com/KhronosGroup/glTF-Sample-Viewer">https://github.com/KhronosGroup/glTF-Sample-Viewer</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gltfWidget">gltfWidget</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This web page has lots of sample files

samples &lt;- "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0"

# Get one of them:  a 2 cylinder engine

gltf &lt;- readGLB(paste0(samples, "/NormalTangentTest/glTF-Binary/NormalTangentTest.glb?raw=true"))
gltfMat &lt;- gltf$getMaterial(0)
scene &lt;- as.rglscene(gltf)
id &lt;- scene$objects[[1]]$id
scene &lt;- setPBRshaders(gltf, gltfMat, id, scene)
cat(scene$objects[[1]]$userFragmentShader)

</code></pre>

<hr>
<h2 id='showTags'>
Debugging tool:  show tags for objects in rgl scene
</h2><span id='topic+showTags'></span>

<h3>Description</h3>

<p>This function uses <code>text3d</code> to display the tags
at the center of the objects they label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showTags(tags = NULL, ids = NULL,
         subscenes = ids3d("subscene", subscene = 0)$id,
         depth_test = "always", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showTags_+3A_tags">tags</code>, <code id="showTags_+3A_ids">ids</code></td>
<td>

<p>If non-NULL, display only these tags and ids.
</p>
</td></tr>
<tr><td><code id="showTags_+3A_subscenes">subscenes</code></td>
<td>

<p>Which subscenes to examine.
</p>
</td></tr>
<tr><td><code id="showTags_+3A_depth_test">depth_test</code></td>
<td>

<p>The <code>"depth_test"</code> material property to use on the
displayed tags.  The default will put the tag in front of
everything, so it won't be obscured by other objects.
</p>
</td></tr>
<tr><td><code id="showTags_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to <code><a href="rgl.html#topic+text3d">text3d</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If selected objects don't have tags, they will be labelled
using their <code>id</code> value instead.
</p>


<h3>Value</h3>

<p>The <span class="pkg">rgl</span> ids of the text objects added (one text object
per tagged object, with tags as names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("plot3d", package = "rgl")
showTags()
</code></pre>

<hr>
<h2 id='showtree'>
Show the tree structure of nodes in a glTF object or rglscene
object.
</h2><span id='topic+showtree'></span><span id='topic+showtree.gltf'></span><span id='topic+showtree.rglscene'></span>

<h3>Description</h3>

<p>glTF files contain nodes corresponding to objects and groups of objects
in 3D scenes.  They must be a tree or forest:  a node can only have
zero or one parent.  This function displays that structure,
or the similar structure for rglscene objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showtree(x, ...)
## S3 method for class 'gltf'
showtree(x, ...)
## S3 method for class 'rglscene'
showtree(x, transform = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showtree_+3A_x">x</code></td>
<td>

<p>A <code>"gltf"</code> or <code>"rglscene"</code> object.
</p>
</td></tr>
<tr><td><code id="showtree_+3A_transform">transform</code></td>
<td>
<p>Whether to show the transform associated
with a subscene.</p>
</td></tr>
<tr><td><code id="showtree_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently unused.</p>
</td></tr>
</table>

<hr>
<h2 id='writeglTF'>
Write a glTF or GLB file.
</h2><span id='topic+writeglTF'></span><span id='topic+writeGLB'></span>

<h3>Description</h3>

<p>GLB is the self-contained binary format of glTF
files.  These functions write a <code>"gltf"</code>
object to one of these formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeglTF(x, path, bin = TRUE)
writeGLB(x, con)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeglTF_+3A_x">x</code></td>
<td>

<p>A <code>"gltf"</code> object, e.g. from <code><a href="#topic+as.gltf">as.gltf</a></code>.
</p>
</td></tr>
<tr><td><code id="writeglTF_+3A_path">path</code></td>
<td>

<p>A filename in which to write the JSON part of the file.
</p>
</td></tr>
<tr><td><code id="writeglTF_+3A_bin">bin</code></td>
<td>
<p>logical; whether or not to write the binary
part of the object.</p>
</td></tr>
<tr><td><code id="writeglTF_+3A_con">con</code></td>
<td>

<p>A filename or connection to which to write the GLB file.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>bin = TRUE</code> (the default),
<code>writeglTF</code> will write the binary part of the object
to one or more separate files with filename constructed by
concatenating the main part of <code>path</code>, followed by a number
and the extension &lsquo;<span class="file">.bin</span>&rsquo;.
</p>


<h3>Value</h3>

<p><code>writeglTF</code> returns <code>path</code> invisibly.
<code>writeGLB</code> returns <code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>The specification of the glTF format:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readglTF">readglTF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename &lt;- tempfile(fileext = ".glb")
writeGLB(as.gltf(rgl::cube3d(col = "red")), filename)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
