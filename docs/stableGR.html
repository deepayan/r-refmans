<!DOCTYPE html><html><head><title>Help for package stableGR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stableGR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asym.var'><p>Asymptotic covariance matrix estimation for Markov chain Monte Carlo</p></a></li>
<li><a href='#mvn.gibbs'><p>Two block Gibbs sampler for a multivariate normal distribution</p></a></li>
<li><a href='#n.eff'><p>Effective sample size</p></a></li>
<li><a href='#stable.GR'><p>Gelman-Rubin diagnostic using stable variance estimators</p></a></li>
<li><a href='#stableGR-package'>
<p>A Stable Gelman-Rubin Diagnostic for Markov Chain Monte Carlo</p></a></li>
<li><a href='#target.psrf'><p>Calculates a Gelman Rubin diagnostic threshold using effective sample size thresholds.</p></a></li>
<li><a href='#titanic.complete'><p>Titanic passenger data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Stable Gelman-Rubin Diagnostic for Markov Chain Monte Carlo</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christina Knudson &lt;drchristinaknudson@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Practitioners of Bayesian statistics often use Markov chain Monte Carlo (MCMC) samplers to sample from a posterior distribution. This package determines whether the MCMC sample is large enough   to yield reliable estimates of the target distribution. In particular, this calculates a Gelman-Rubin convergence diagnostic using stable and consistent estimators of Monte Carlo variance. Additionally, this uses the connection between an MCMC sample's effective sample size and the Gelman-Rubin diagnostic to produce a threshold for terminating MCMC simulation. Finally, this informs the user whether enough samples have been collected  and (if necessary) estimates the number of samples needed for a desired level of accuracy. The theory underlying these methods can be found in "Revisiting the Gelman-Rubin Diagnostic" by Vats and  Knudson (2018) &lt;arXiv:1812:09384&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), mcmcse(&ge; 1.4-1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-07 21:11:40 UTC; christina.knudson</td>
</tr>
<tr>
<td>Author:</td>
<td>Christina Knudson [aut, cre],
  Dootika Vats [aut]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-07 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='asym.var'>Asymptotic covariance matrix estimation for Markov chain Monte Carlo</h2><span id='topic+asym.var'></span>

<h3>Description</h3>

<p>Estimates the asymptotic covariance matrix for Monte Carlo estimators,  compatible with multiple chains. If a single chain is input, it calls <code>mcmcse::mcse.multi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asym.var(
  x,
  multivariate = TRUE,
  method = "lug",
  size = NULL,
  autoburnin = FALSE,
  adjust = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asym.var_+3A_x">x</code></td>
<td>
<p>a list of matrices, where each matrix is <code class="reqn">n \times p</code>. Each row of the matrices represents one step of the chain. Each column of the matrices represents one variable. A list with a single matrix (chain) is allowed. Optionally, this can be an <code>mcmclist</code> object.</p>
</td></tr>
<tr><td><code id="asym.var_+3A_multivariate">multivariate</code></td>
<td>
<p>a logical flag indicating whether the full matrix is returned (TRUE) or only the diagonals (FALSE)</p>
</td></tr>
<tr><td><code id="asym.var_+3A_method">method</code></td>
<td>
<p>the method used to compute the matrix. This is one of &ldquo;<code>lug</code>&rdquo; (lugsail, the default), &ldquo;<code>bm</code>&rdquo; (batch means), &ldquo;<code>obm</code>&rdquo; (overlapping batch means), &ldquo;<code>tukey</code>&rdquo; (spectral variance method with a Tukey-Hanning window), or &ldquo;<code>bartlett</code>&rdquo; (spectral variance method with a Bartlett window).</p>
</td></tr>
<tr><td><code id="asym.var_+3A_size">size</code></td>
<td>
<p>options are <code>NULL</code> (default, which calculates an ideal batch size), character values of <code>sqroot</code> and <code>cuberoot</code>, or any numeric value between 1 and <code class="reqn">n</code>. Size represents the batch size in &ldquo;<code>bm</code>&rdquo; (batch means) and the truncation point in &ldquo;<code>bartlett</code>&rdquo; and &ldquo;<code>tukey</code>&rdquo;. sqroot means size is floor(n^(1/2) and cuberoot means size is floor(n^(1/3)).</p>
</td></tr>
<tr><td><code id="asym.var_+3A_autoburnin">autoburnin</code></td>
<td>
<p>a logical flag indicating whether only the second half of the series should be used in the computation.  If set to TRUE and <code>start(x)</code> is less than <code>end(x)/2</code> then start of series will be adjusted so that only second half of series is used.</p>
</td></tr>
<tr><td><code id="asym.var_+3A_adjust">adjust</code></td>
<td>
<p>this argument is now obselete due to package updates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns estimate of the univariate or multivariate asymptotic (co)variance of Monte Carlo estimators. If <code class="reqn">X_1, \dots X_n</code> are the MCMC samples, then function returns the estimate of <code class="reqn">\lim_{n\to \infty} n Var(\bar{X})</code>. In other words, if a Markov chain central limit holds such that, as <code class="reqn">n \to \infty</code>
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{n}(\bar{X} - \mu) \to N(0, \Sigma) </code>
</p>

<p>then the function returns an estimator of <code class="reqn">\Sigma</code> from the m different chains. If <code>multivariate == FALSE</code>, then only the diagonal of <code class="reqn">\Sigma</code> are returned.
</p>


<h3>Value</h3>

<p>The asymptotic variance estimate (if <code>multivariate = FALSE</code>) or the asymptotic covariance matrix (if <code>multivariate = TRUE</code>) in the Markov chain central limit theorem.
</p>


<h3>References</h3>

<p>Vats, D. and Knudson, C. Revisiting the Gelman-Rubin Diagnostic.	arXiv:1812.09384. 
</p>
<p>Vats, D. and Flegal, J. Lugsail lag windows and their application to MCMC. arXiv: 1809.04541.
</p>
<p>Flegal, J. M. and Jones, G. L. (2010) Batch means and spectral variance estimators in Markov chain Monte Carlo. <em>The Annals of Statistics</em>, <b>38</b>, 1034&ndash;1070.
</p>
<p>Gelman, A and Rubin, DB (1992) Inference from iterative simulation using multiple sequences, <em>Statistical Science</em>, <b>7</b>, 457-511. 
</p>
<p>Brooks, SP. and Gelman, A. (1998) General methods for monitoring convergence of iterative simulations. <em>Journal of Computational and Graphical Statistics</em>, <b>7</b>, 434-455.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stableGR)
set.seed(100)
p &lt;- 2
n &lt;- 100 # n is tiny here purely for demo purposes.
# use n much larger for real problems!

sig.mat = matrix(c(1, .8, .8, 1), ncol = 2, nrow = 2)

# Making 3 chains
chain1 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)
chain2 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)
chain3 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)

# find GR diagnostic using all three chains
x &lt;- list(chain1, chain2, chain3)
asym.var(x)

</code></pre>

<hr>
<h2 id='mvn.gibbs'>Two block Gibbs sampler for a multivariate normal distribution</h2><span id='topic+mvn.gibbs'></span>

<h3>Description</h3>

<p>This function generates a Markov chain sample from a multivariate normal distribution using a two-block Gibbs sampler. The function is used mainly for implementation in the examples of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvn.gibbs(N = 10000, p, mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvn.gibbs_+3A_n">N</code></td>
<td>
<p>number of Markov chain samples desired</p>
</td></tr>
<tr><td><code id="mvn.gibbs_+3A_p">p</code></td>
<td>
<p>dimension of the multivariate normal target distribution</p>
</td></tr>
<tr><td><code id="mvn.gibbs_+3A_mu">mu</code></td>
<td>
<p>mean vector of the multivariate normal distribution</p>
</td></tr>
<tr><td><code id="mvn.gibbs_+3A_sigma">sigma</code></td>
<td>
<p>covariance matrix of the multivariate normal distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N by p matrix of samples from the multivariate normal target distribution
</p>

<hr>
<h2 id='n.eff'>Effective sample size</h2><span id='topic+n.eff'></span>

<h3>Description</h3>

<p>For an estimator, effective sample size is the number of independent samples with the same standard error as a correlated sample. This function calculates effective sample size for a set of Markov chains using lugsail variance estimators. This also determines whether the Markov chains have converged. If they have not, this function approximates the number of samples needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.eff(
  x,
  multivariate = TRUE,
  epsilon = 0.05,
  delta = NULL,
  alpha = 0.05,
  method = "lug",
  size = NULL,
  autoburnin = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.eff_+3A_x">x</code></td>
<td>
<p>a list of matrices, where each matrix represents one Markov chain sample. Each row of the matrices represents one step of the chain. Each column of the matrices represents one variable. A list with a single matrix (chain) is allowed. Optionally, this can be an <code>mcmclist</code> object.</p>
</td></tr>
<tr><td><code id="n.eff_+3A_multivariate">multivariate</code></td>
<td>
<p>a logical flag indicating whether the effective sample size should be calculated for multivariate chains.</p>
</td></tr>
<tr><td><code id="n.eff_+3A_epsilon">epsilon</code></td>
<td>
<p>relative precision level. Values less than .10 are recommended.</p>
</td></tr>
<tr><td><code id="n.eff_+3A_delta">delta</code></td>
<td>
<p>desired delta value - the cutoff for potential scale reduction factor.</p>
</td></tr>
<tr><td><code id="n.eff_+3A_alpha">alpha</code></td>
<td>
<p>significance level for confidence regions for the Monte Carlo estimators.</p>
</td></tr>
<tr><td><code id="n.eff_+3A_method">method</code></td>
<td>
<p>the method used to compute the standard error of the chains. This is one of &ldquo;<code>lug</code>&rdquo; (lugsail, the default), &ldquo;<code>bm</code>&rdquo; (batch means), &ldquo;<code>obm</code>&rdquo; (overlapping batch means), &ldquo;<code>tukey</code>&rdquo; (spectral variance method with a Tukey-Hanning window), or &ldquo;<code>bartlett</code>&rdquo; (spectral variance method with a Bartlett window).</p>
</td></tr>
<tr><td><code id="n.eff_+3A_size">size</code></td>
<td>
<p>options are <code>NULL</code> (default, which calculates an ideal batch size), character values of <code>sqroot</code> and <code>cuberoot</code>, or any numeric value between 1 and <code class="reqn">n</code>. Size represents the batch size in &ldquo;<code>bm</code>&rdquo; (batch means) and the truncation point in &ldquo;<code>bartlett</code>&rdquo; and &ldquo;<code>tukey</code>&rdquo;. sqroot means size is floor(n^(1/2) and cuberoot means size is floor(n^(1/3)).</p>
</td></tr>
<tr><td><code id="n.eff_+3A_autoburnin">autoburnin</code></td>
<td>
<p>a logical flag indicating whether only the second half of the series should be used in the computation.  If set to TRUE and <code>start(x)</code> is less than <code>end(x)/2</code> then start of series will be adjusted so that only second half of series is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>n.eff</code></td>
<td>
<p>a scalar point estimate of the effective sample size.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>a logical indicating whether sufficient samples have been obtained.</p>
</td></tr>
<tr><td><code>n.target</code></td>
<td>
<p>NULL (if <code>converged == TRUE</code>) or a scalar estimate of the chain length required for convergence, assuming the number of chains is unchanged.  </p>
</td></tr>
</table>


<h3>References</h3>

<p>Vats, D. and Knudson, C. Revisiting the Gelman-Rubin Diagnostic.	arXiv:1812.09384. 
</p>
<p>Vats, D. and Flegal, J. Lugsail lag windows and their application to MCMC. arXiv: 1809.04541.
</p>
<p>Flegal, J. M. and Jones, G. L. (2010) Batch means and spectral variance estimators in Markov chain Monte Carlo. <em>The Annals of Statistics</em>, <b>38</b>, 1034&ndash;1070. <br />
</p>
<p>Gelman, A and Rubin, DB (1992) Inference from iterative simulation using multiple sequences, <em>Statistical Science</em>, <b>7</b>, 457-511. <br />
</p>
<p>Brooks, SP. and Gelman, A. (1998) General methods for monitoring convergence of iterative simulations. <em>Journal of Computational and Graphical Statistics</em>, <b>7</b>, 434-455.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stableGR)
set.seed(100)
p &lt;- 2
n &lt;- 100 # n is tiny here purely for demo purposes.
# use n much larger for real problems!


sig.mat = matrix(c(1, .8, .8, 1), ncol = 2, nrow = 2)
# Making 3 chains
chain1 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)
chain2 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)
chain3 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)

# find ESS using all three chains
x &lt;- list(chain1, chain2, chain3)
n.eff(x) 



</code></pre>

<hr>
<h2 id='stable.GR'>Gelman-Rubin diagnostic using stable variance estimators</h2><span id='topic+stable.GR'></span>

<h3>Description</h3>

<p>This function uses fast and strongly consistent estimators estimators of Monte Carlo variance to calculate the Gelman-Rubin convergence diagnostic for Markov chain Monte Carlo. A univariate &lsquo;potential scale reduction factor&rsquo; (PSRF) is calculated for each variable in <code>x</code>. For multivariate chains, a multivariate PSRF is calculated to take into account the interdependence of the chain's components.  The PSRFs decrease to 1 as the chain length increases. When the PSRF becomes sufficiently close to 1, the sample collected by the Markov chain has converged to the target distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stable.GR(
  x,
  multivariate = TRUE,
  mapping = "determinant",
  method = "lug",
  size = NULL,
  autoburnin = FALSE,
  blather = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stable.GR_+3A_x">x</code></td>
<td>
<p>a list of matrices, where each matrix represents one Markov chain sample. Each row of the matrices represents one step of the chain. Each column of the matrices represents one variable. A list with a single matrix (chain) is allowed. Optionally, this can be an <code>mcmclist</code> object.</p>
</td></tr>
<tr><td><code id="stable.GR_+3A_multivariate">multivariate</code></td>
<td>
<p>a logical flag indicating whether the multivariate potential scale reduction factor should be calculated for multivariate chains.</p>
</td></tr>
<tr><td><code id="stable.GR_+3A_mapping">mapping</code></td>
<td>
<p>the function used to map the covariance matrix to a scalar. This is one of &ldquo;<code>determinant</code>&rdquo; (determinant of the covariance matrix, the default) or &ldquo;<code>maxeigen</code>&rdquo; (the largest eigenvalue of the covariance matrix).</p>
</td></tr>
<tr><td><code id="stable.GR_+3A_method">method</code></td>
<td>
<p>the method used to compute the standard error of the chains. This is one of &ldquo;<code>lug</code>&rdquo; (lugsail, the default), &ldquo;<code>bm</code>&rdquo; (batch means), &ldquo;<code>obm</code>&rdquo; (overlapping batch means), &ldquo;<code>tukey</code>&rdquo; (spectral variance method with a Tukey-Hanning window), or &ldquo;<code>bartlett</code>&rdquo; (spectral variance method with a Bartlett window).</p>
</td></tr>
<tr><td><code id="stable.GR_+3A_size">size</code></td>
<td>
<p>options are <code>NULL</code> (default, which calculates an ideal batch size), character values of <code>sqroot</code> and <code>cuberoot</code>, or any numeric value between 1 and <code class="reqn">n</code>. Size represents the batch size in &ldquo;<code>bm</code>&rdquo; (batch means) and the truncation point in &ldquo;<code>bartlett</code>&rdquo; and &ldquo;<code>tukey</code>&rdquo;. sqroot means size is floor(n^(1/2) and cuberoot means size is floor(n^(1/3)).</p>
</td></tr>
<tr><td><code id="stable.GR_+3A_autoburnin">autoburnin</code></td>
<td>
<p>a logical flag indicating whether only the second half of the series should be used in the computation.  If set to TRUE and <code>start(x)</code> is less than <code>end(x)/2</code> then start of series will be adjusted so that only second half of series is used.</p>
</td></tr>
<tr><td><code id="stable.GR_+3A_blather">blather</code></td>
<td>
<p>a logical flag indicating whether to include additional output.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>psrf</code></td>
<td>
<p>A vector containing the point estimates of the PSRF.</p>
</td></tr>
<tr><td><code>mpsrf</code></td>
<td>
<p>A scalar point estimate of the multivariate PSRF.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>A vector containing the sample means based on the chains provided.</p>
</td></tr>
<tr><td><code>n.eff</code></td>
<td>
<p>A scalar point estimate of the effective sample size.</p>
</td></tr>
<tr><td><code>blather</code></td>
<td>
<p>Either <code>FALSE</code> or a list containing intermediate calculations.</p>
</td></tr>
</table>


<h3>Theory</h3>

<p>Gelman and Rubin (1992) and Brooks and Gelman (1998) first constructed the univariate and 
multivariate potential scale reduction factors (PSRF), respectively,  to diagnose Markov chain 
convergence. The function <code>stable.GR</code> stabilizes the PSRF and improves the PSRF's efficiency by 
incorporating lugsail estimators for the target variance. The PSRF decreases to 1 as the chain length
increases; when the PSRF becomes sufficiently close to 1, the sample collected by the Markov chain has 
converged to to the target distribution. A PSRF convergence threshold can be calculated using 
<code>choosepsrf</code>.
</p>


<h3>References</h3>

<p>Vats, D. and Knudson, C. Revisiting the Gelman-Rubin Diagnostic.	arXiv:1812.09384. 
</p>
<p>Vats, D. and Flegal, J. Lugsail lag windows and their application to MCMC. arXiv: 1809.04541.
</p>
<p>Flegal, J. M. and Jones, G. L. (2010) Batch means and spectral variance estimators in Markov chain Monte Carlo. <em>The Annals of Statistics</em>, <b>38</b>, 1034&ndash;1070. <br />
</p>
<p>Gelman, A and Rubin, DB (1992) Inference from iterative simulation using multiple sequences, <em>Statistical Science</em>, <b>7</b>, 457-511. <br />
</p>
<p>Brooks, SP. and Gelman, A. (1998) General methods for monitoring convergence of iterative simulations. <em>Journal of Computational and Graphical Statistics</em>, <b>7</b>, 434-455.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stableGR)
set.seed(100)
p &lt;- 2
n &lt;- 100 # n is tiny here purely for demo purposes.
# use n much larger for real problems!

sig.mat = matrix(c(1, .8, .8, 1), ncol = 2, nrow = 2)

# Making 3 chains
chain1 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)
chain2 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)
chain3 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)

# find GR diagnostic using all three chains
x &lt;- list(chain1, chain2, chain3)
stable.GR(x) 


</code></pre>

<hr>
<h2 id='stableGR-package'>
A Stable Gelman-Rubin Diagnostic for Markov Chain Monte Carlo
</h2><span id='topic+stableGR-package'></span><span id='topic+stableGR'></span>

<h3>Description</h3>


<p>Practitioners of Bayesian statistics often use Markov chain Monte Carlo (MCMC) samplers to sample from a posterior distribution. This package determines whether the MCMC sample is large enough   to yield reliable estimates of the target distribution. In particular, this calculates a Gelman-Rubin convergence diagnostic using stable and consistent estimators of Monte Carlo variance. Additionally, this uses the connection between an MCMC sample's effective sample size and the Gelman-Rubin diagnostic to produce a threshold for terminating MCMC simulation. Finally, this informs the user whether enough samples have been collected  and (if necessary) estimates the number of samples needed for a desired level of accuracy. The theory underlying these methods can be found in &quot;Revisiting the Gelman-Rubin Diagnostic&quot; by Vats and  Knudson (2018) &lt;arXiv:1812:09384&gt;. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> stableGR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> A Stable Gelman-Rubin Diagnostic for Markov Chain Monte Carlo</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-10-7</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Christina", "Knudson", role = c("aut", "cre"),
    email = "drchristinaknudson@gmail.com"), person("Dootika", "Vats", role = c("aut"), email = "dootika.vats@gmail.com"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Christina Knudson &lt;drchristinaknudson@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Practitioners of Bayesian statistics often use Markov chain Monte Carlo (MCMC) samplers to sample from a posterior distribution. This package determines whether the MCMC sample is large enough   to yield reliable estimates of the target distribution. In particular, this calculates a Gelman-Rubin convergence diagnostic using stable and consistent estimators of Monte Carlo variance. Additionally, this uses the connection between an MCMC sample's effective sample size and the Gelman-Rubin diagnostic to produce a threshold for terminating MCMC simulation. Finally, this informs the user whether enough samples have been collected  and (if necessary) estimates the number of samples needed for a desired level of accuracy. The theory underlying these methods can be found in "Revisiting the Gelman-Rubin Diagnostic" by Vats and  Knudson (2018) &lt;arXiv:1812:09384&gt;. </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5), mcmcse(&gt;= 1.4-1)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> mvtnorm</td>
</tr>
<tr>
 <td style="text-align: left;">
ByteCompile: </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository: </td><td style="text-align: left;"> CRAN</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Christina Knudson [aut, cre],
  Dootika Vats [aut]</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Practitioners of Bayesian statistics often use Markov chain Monte Carlo (MCMC) samplers to sample from a posterior distribution. This package determines whether the MCMC sample is large enough   to yield reliable estimates of the target distribution. In particular, this calculates a Gelman-Rubin convergence diagnostic using stable and consistent estimators of Monte Carlo variance. Additionally, this uses the connection between an MCMC sample's effective sample size and the Gelman-Rubin diagnostic to produce a threshold for terminating MCMC simulation. Finally, this informs the user whether enough samples have been collected  and (if necessary) estimates the number of samples needed for a desired level of accuracy. The theory underlying these methods can be found in &quot;Revisiting the Gelman-Rubin Diagnostic&quot; by Vats and  Knudson (2018) &lt;arXiv:1812:09384&gt;. 
</p>
<p>This package is unique in a few ways. First, it uses stable variance estimators to calculate a stabilized Gelman-Rubin statistic. Second, it leverages the connection between effective sample size and the potential scale reduction factor (PSRF). Third, this diagnostic can be used whether MCMC samples were created from a single chain or multiple chains. 
</p>
<p>The main functions in the package are <code>stable.GR</code>, <code>n.eff</code>, and <code>target.psrf</code>. <code>stable.GR</code>  returns the univariate PSRF, the multivariate PSRF, and the estimated effective sample size. <code>n.eff</code>  returns informs the user whether sufficient MCMC samples have been collected; if not, <code>n.eff</code> also returns the estimated target sample size <code>target.psrf</code> creates a termination threshold for <code>stable.GR</code>; MCMC sampling can terminate when the MCMC samples' psrf is smaller than the value returned by <code>target.psrf</code>.
</p>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Christina Knudson &lt;drchristinaknudson@gmail.com&gt;
</p>


<h3>References</h3>

 
<p>Vats, D. and Knudson, C. Revisiting the Gelman-Rubin Diagnostic.	arXiv:1812.09384. 
</p>
<p>Vats, D. and Flegal, J. Lugsail lag windows and their application to MCMC. arXiv: 1809.04541.
</p>
<p>Flegal, J. M. and Jones, G. L. (2010) Batch means and spectral variance estimators in Markov chain Monte Carlo. <em>The Annals of Statistics</em>, <b>38</b>, 1034&ndash;1070. 
</p>
<p>Gelman, A and Rubin, DB (1992) Inference from iterative simulation using multiple sequences, <em>Statistical Science</em>, <b>7</b>, 457-511. 
</p>
<p>Brooks, SP. and Gelman, A. (1998) General methods for monitoring convergence of iterative simulations. <em>Journal of Computational and Graphical Statistics</em>, <b>7</b>, 434-455.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stableGR)
set.seed(100)
p &lt;- 2
n &lt;- 100 # For real problems, use a MUCH larger n.

sig.mat = matrix(c(1, .8, .8, 1), ncol = 2, nrow = 2)

# Making 3 chains
chain1 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)
chain2 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)
chain3 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)

# find GR diagnostic using all three chains
x &lt;- list(chain1, chain2, chain3)
stable.GR(x) 


</code></pre>

<hr>
<h2 id='target.psrf'>Calculates a Gelman Rubin diagnostic threshold using effective sample size thresholds.</h2><span id='topic+target.psrf'></span>

<h3>Description</h3>

<p>When the sample diagnostic reaches the psrf threshold calculated in this function, sufficient samples have been obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.psrf(p, m, epsilon = 0.05, delta = NULL, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.psrf_+3A_p">p</code></td>
<td>
<p>dimension of the estimation problem.</p>
</td></tr>
<tr><td><code id="target.psrf_+3A_m">m</code></td>
<td>
<p>number of chains.</p>
</td></tr>
<tr><td><code id="target.psrf_+3A_epsilon">epsilon</code></td>
<td>
<p>relative precision level. Values less than .10 are recommended.</p>
</td></tr>
<tr><td><code id="target.psrf_+3A_delta">delta</code></td>
<td>
<p>desired delta value - the cutoff for potential scale reduction factor. If specified, then the corresponding <code>epsilon</code> is returned.</p>
</td></tr>
<tr><td><code id="target.psrf_+3A_alpha">alpha</code></td>
<td>
<p>significance level for confidence regions for the Monte Carlo estimators.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>psrf</code></td>
<td>
<p>The desired PSRF cutoff to stop the simulation.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>The epsilon value used to calculate the PSRF threshold.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Vats, D. and Knudson, C. Revisiting the Gelman-Rubin Diagnostic.	arXiv:1812.09384 
</p>
<p>Vats, D. and Flegal, J. Lugsail lag windows and their application to MCMC. arXiv: 1809.04541.
</p>
<p>Flegal, J. M. and Jones, G. L. (2010) Batch means and spectral variance estimators in Markov chain Monte Carlo. <em>The Annals of Statistics</em>, <b>38</b>, 1034&ndash;1070. <br />
</p>
<p>Gelman, A and Rubin, DB (1992) Inference from iterative simulation using multiple sequences, <em>Statistical Science</em>, <b>7</b>, 457-511. <br />
</p>
<p>Brooks, SP. and Gelman, A. (1998) General methods for monitoring convergence of iterative simulations. <em>Journal of Computational and Graphical Statistics</em>, <b>7</b>, 434-455.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target.psrf(p = 2, m = 3, epsilon = .05,  alpha = .05)

</code></pre>

<hr>
<h2 id='titanic.complete'>Titanic passenger data</h2><span id='topic+titanic.complete'></span>

<h3>Description</h3>

<p>Titanic passenger survival data. Complete cases only.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(titanic.complete)</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt>Survived</dt><dd><p>Whether a passenger survived.</p>
</dd>
<dt>Pclass</dt><dd><p>The class of the passenger's ticket. A factor with 3 levels.</p>
</dd>
<dt>Sex</dt><dd><p>Male or female. A factor with 2 levels.</p>
</dd>
<dt>Age</dt><dd><p>The age of the passenger.</p>
</dd>
<dt>SibSp</dt><dd><p>The number of siblings/spouse aboard.</p>
</dd>
<dt>Parch</dt><dd><p>The number of parents/children aboard.</p>
</dd>
<dt>Fare</dt><dd><p>The passenger's fare.</p>
</dd>
<dt>Embarked</dt><dd><p>The passenger's port of embarkation. A factor with 3 levels.</p>
</dd>
</dl>



<h3>References</h3>

<p>https://www.kaggle.com/c/titanic/data</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(titanic.complete)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
