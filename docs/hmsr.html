<!DOCTYPE html><html><head><title>Help for package hmsr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hmsr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#default_run_gradient_method'><p>Function that runs gradient method for one deme.</p>
Wrapper function for stats::optim.</a></li>
<li><a href='#ecr_metaepoch'><p>Function that runs one ecr metaepoch. Wrapper function for ecr::ecr.</p></a></li>
<li><a href='#euclidean_distance'><p>Euclidean distance</p></a></li>
<li><a href='#ga_metaepoch'><p>Function that runs one GA metaepoch. Wrapper function for GA::ga.</p></a></li>
<li><a href='#gsc_max_fitness_evaluations'><p>Factory function for a global stopping condition that stops</p>
the computation after fitness function has been evaluated
given number of times.</a></li>
<li><a href='#gsc_metaepochs_count'><p>Factory function for a global stopping condition that stops</p>
the computation after given number of metaepochs.</a></li>
<li><a href='#gsc_trivial'><p>Factory function for a global stopping condition that never stops</p>
the computation. It results in hms running until there are no more
active demes.</a></li>
<li><a href='#hms'><p>Maximization (or minimization) of a fitness function using Hierarchic Memetic Strategy.</p></a></li>
<li><a href='#hms-class'><p>A S4 class representing a result of hms.</p></a></li>
<li><a href='#lsc_max_fitness_evaluations'><p>Factory function for a local stopping condition that stops a deme</p>
after given number of fitness function evaluations has been made
in that deme.</a></li>
<li><a href='#lsc_metaepochs_without_active_child'><p>Factory function for a local stopping condition that stops a deme</p>
after given number of metaepochs have past since last metaepoch during
which this deme had an active child.</a></li>
<li><a href='#lsc_metaepochs_without_improvement'><p>Factory function for a local stopping condition that stops a deme</p>
after given number of consecutive metaeopochs without an improvement
of the best solution found in that deme.</a></li>
<li><a href='#lsc_trivial'><p>Factory function for a trivial local stopping condition that</p>
lets a deme be active forever. It is usually used in the root of
a hms tree.</a></li>
<li><a href='#manhattan_distance'><p>Manhattan distance</p></a></li>
<li><a href='#MetaepochSnapshot-class'><p>A S4 class representing a snapshot of one metaepoch.</p></a></li>
<li><a href='#plot,hms-method'><p>Plot method for &quot;hms&quot; class.</p></a></li>
<li><a href='#plotActiveDemes'><p>plotActiveDemes method for &quot;hms&quot; class.</p></a></li>
<li><a href='#plotActiveDemes,hms-method'><p>plotActiveDemes method for &quot;hms&quot; class.</p></a></li>
<li><a href='#plotPopulation'><p>plotPopulation method for &quot;hms&quot; class.</p></a></li>
<li><a href='#plotPopulation,hms-method'><p>plotPopulation method for &quot;hms&quot; class.</p></a></li>
<li><a href='#print,hms-method'><p>Print method for class &quot;hms&quot;.</p></a></li>
<li><a href='#printBlockedSprouts'><p>printBlockedSprouts method for &quot;hms&quot; class.</p></a></li>
<li><a href='#printBlockedSprouts,hms-method'><p>printBlockedSprouts method for &quot;hms&quot; class.</p></a></li>
<li><a href='#printTree'><p>printTree method for class &quot;hms&quot;.</p></a></li>
<li><a href='#printTree,hms-method'><p>printTree method for class &quot;hms&quot;.</p></a></li>
<li><a href='#rtnorm_mutation'><p>Factory function that creates normal mutation function</p></a></li>
<li><a href='#saveMetaepochsPopulations'><p>saveMetaepochsPopulations method for &quot;hms&quot; class.</p></a></li>
<li><a href='#saveMetaepochsPopulations,hms-method'><p>saveMetaepochsPopulations</p></a></li>
<li><a href='#sc_max_metric'><p>Default sprouting condition based on given metric.</p></a></li>
<li><a href='#show,hms-method'><p>Show method for class &quot;hms&quot;.</p></a></li>
<li><a href='#summary,hms-method'><p>Summary method for class &quot;hms&quot;.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multipopulation Evolutionary Strategy HMS</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>
  The HMS (Hierarchic Memetic Strategy) is a composite global optimization
  strategy consisting of a multi-population evolutionary strategy and some
  auxiliary methods. The HMS makes use of a dynamically-evolving data structure
  that provides an organization among the component populations. It is a tree
  with a fixed maximal height and variable internal node degree. Each component
  population is governed by a particular evolutionary engine. This package
  provides a simple R implementation with examples of using different genetic
  algorithms as the population engines. References: J. Sawicki, M. Łoś,
  M. Smołka, J. Alvarez-Aramberri (2022) &lt;<a href="https://doi.org/10.1007%2Fs11047-020-09836-w">doi:10.1007/s11047-020-09836-w</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>GA, msm, methods, uuid, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), ecr, filelock, parallel, doParallel,
grDevices, smoof</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/WojtAcht/hms/issues">https://github.com/WojtAcht/hms/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://wojtacht.github.io/hms/">https://wojtacht.github.io/hms/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-24 18:38:02 UTC; wojciechachtelik</td>
</tr>
<tr>
<td>Author:</td>
<td>Wojciech Achtelik [aut, cre],
  Marcin Kozubek [aut],
  Maciej Smołka <a href="https://orcid.org/0000-0002-3386-0555"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths, aut] (Java original),
  AGH University of Kraków [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wojciech Achtelik &lt;wachtelik@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-25 07:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='default_run_gradient_method'>Function that runs gradient method for one deme.
Wrapper function for stats::optim.</h2><span id='topic+default_run_gradient_method'></span>

<h3>Description</h3>

<p>Function that runs gradient method for one deme.
Wrapper function for stats::optim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_run_gradient_method(deme, fitness, optim_args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_run_gradient_method_+3A_deme">deme</code></td>
<td>

<ul>
<li><p> Deme
</p>
</li></ul>
</td></tr>
<tr><td><code id="default_run_gradient_method_+3A_fitness">fitness</code></td>
<td>

<ul>
<li><p> fitness function
</p>
</li></ul>
</td></tr>
<tr><td><code id="default_run_gradient_method_+3A_optim_args">optim_args</code></td>
<td>

<ul>
<li><p> list of additional parameters (stats::optim parameters)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>list with named fields: solution, population, value. See
<code><a href="#topic+ga_metaepoch">ga_metaepoch</a></code> for more details.
</p>

<hr>
<h2 id='ecr_metaepoch'>Function that runs one ecr metaepoch. Wrapper function for ecr::ecr.</h2><span id='topic+ecr_metaepoch'></span>

<h3>Description</h3>

<p>Function that runs one ecr metaepoch. Wrapper function for ecr::ecr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecr_metaepoch(config_ecr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecr_metaepoch_+3A_config_ecr">config_ecr</code></td>
<td>

<ul>
<li><p> list of ecr::ecr params
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>list with named fields: solution, population, value. See
<code><a href="#topic+ga_metaepoch">ga_metaepoch</a></code> for more details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree_height &lt;- 3
empty_config_ecr &lt;- lapply(1:tree_height, function(x) {
  list()
})
ecr_metaepoch(empty_config_ecr)
</code></pre>

<hr>
<h2 id='euclidean_distance'>Euclidean distance</h2><span id='topic+euclidean_distance'></span>

<h3>Description</h3>

<p>Euclidean distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidean_distance(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euclidean_distance_+3A_x">x</code></td>
<td>

<ul>
<li><p> numeric
</p>
</li></ul>
</td></tr>
<tr><td><code id="euclidean_distance_+3A_y">y</code></td>
<td>

<ul>
<li><p> numeric
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric - euclidean distance between x and y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euclidean_distance(c(1, 1), c(1, 2))
</code></pre>

<hr>
<h2 id='ga_metaepoch'>Function that runs one GA metaepoch. Wrapper function for GA::ga.</h2><span id='topic+ga_metaepoch'></span>

<h3>Description</h3>

<p>Function that runs one GA metaepoch. Wrapper function for GA::ga.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ga_metaepoch(config_ga)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ga_metaepoch_+3A_config_ga">config_ga</code></td>
<td>

<ul>
<li><p> list of GA::ga params
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>list with named fields: solution, population, value. A solution is a
value of the decision variable giving the best fitness. A population is a
matrix representing final population. Value is the value of a fitness
function for the solution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree_height &lt;- 3
empty_config_ga &lt;- lapply(1:tree_height, function(x) {
  list()
})
ga_metaepoch(empty_config_ga)
</code></pre>

<hr>
<h2 id='gsc_max_fitness_evaluations'>Factory function for a global stopping condition that stops
the computation after fitness function has been evaluated
given number of times.</h2><span id='topic+gsc_max_fitness_evaluations'></span>

<h3>Description</h3>

<p>Factory function for a global stopping condition that stops
the computation after fitness function has been evaluated
given number of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsc_max_fitness_evaluations(max_evaluations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsc_max_fitness_evaluations_+3A_max_evaluations">max_evaluations</code></td>
<td>

<ul>
<li><p> numeric - maximum number of fitness function evaluations
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Function that receives a list of metaepoch snapshots
and returns a Boolean value determining whether the computation
should be stopped based on how many fitness function evaluations
have been made, which can be used as a global stopping condition
for the hms function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>global_stopping_condition &lt;- gsc_max_fitness_evaluations(10000)
</code></pre>

<hr>
<h2 id='gsc_metaepochs_count'>Factory function for a global stopping condition that stops
the computation after given number of metaepochs.</h2><span id='topic+gsc_metaepochs_count'></span>

<h3>Description</h3>

<p>Factory function for a global stopping condition that stops
the computation after given number of metaepochs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsc_metaepochs_count(metaepochs_count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsc_metaepochs_count_+3A_metaepochs_count">metaepochs_count</code></td>
<td>

<ul>
<li><p> numeric - maximum number of metaepochs
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Function that receives a list of metaepoch snapshots
and returns a Boolean value determining whether the computation
should be stopped based on how many metaepochs have passed,
which can be used as a global stopping condition for the hms function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>global_stopping_condition &lt;- gsc_metaepochs_count(10)
</code></pre>

<hr>
<h2 id='gsc_trivial'>Factory function for a global stopping condition that never stops
the computation. It results in hms running until there are no more
active demes.</h2><span id='topic+gsc_trivial'></span>

<h3>Description</h3>

<p>Factory function for a global stopping condition that never stops
the computation. It results in hms running until there are no more
active demes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsc_trivial()
</code></pre>


<h3>Value</h3>

<p>function that always returns <code>FALSE</code>, which can be used
as a global stopping condition for the hms function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>global_stopping_condition &lt;- gsc_trivial()
</code></pre>

<hr>
<h2 id='hms'>Maximization (or minimization) of a fitness function using Hierarchic Memetic Strategy.</h2><span id='topic+hms'></span>

<h3>Description</h3>

<p>Maximization (or minimization) of a fitness function using Hierarchic Memetic Strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hms(
  tree_height = 3,
  minimize = FALSE,
  fitness,
  lower,
  upper,
  sigma = default_sigma(lower, upper, tree_height),
  population_sizes = default_population_sizes(tree_height),
  run_metaepoch = default_ga_metaepoch(tree_height),
  gsc = gsc_default,
  lsc = lsc_default,
  sc = sc_max_metric(euclidean_distance, sprouting_default_euclidean_distances(sigma)),
  create_population = default_create_population(sigma),
  suggestions = NULL,
  with_gradient_method = FALSE,
  gradient_method_args = default_gradient_method_args,
  run_gradient_method,
  monitor_level = "basic",
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hms_+3A_tree_height">tree_height</code></td>
<td>
<p>numeric - default value: 5. It determines the maximum tree height
which will usually be reached unless a very strict local stopping condition, global
stopping condition or sprouting condition is used.</p>
</td></tr>
<tr><td><code id="hms_+3A_minimize">minimize</code></td>
<td>
<p>logical - <code>TRUE</code> when fitness shall be minimized.</p>
</td></tr>
<tr><td><code id="hms_+3A_fitness">fitness</code></td>
<td>
<p>fitness function, that returns a numerical value, to be optimized by the strategy.</p>
</td></tr>
<tr><td><code id="hms_+3A_lower">lower</code></td>
<td>
<p>numeric - lower bound of the domain, a vector of length equal
to the decision variables.</p>
</td></tr>
<tr><td><code id="hms_+3A_upper">upper</code></td>
<td>
<p>numeric - upper bound of the domain, a vector of length equal
to the decision variables.</p>
</td></tr>
<tr><td><code id="hms_+3A_sigma">sigma</code></td>
<td>
<p>numeric - Vector of standard deviations for each tree level used to create
a population of a sprouted deme.</p>
</td></tr>
<tr><td><code id="hms_+3A_population_sizes">population_sizes</code></td>
<td>
<p>numeric - Sizes of deme populations on each tree level.</p>
</td></tr>
<tr><td><code id="hms_+3A_run_metaepoch">run_metaepoch</code></td>
<td>
<p>A function that takes 5 parameters: fitness, suggestions, lower,
upper, tree_level, runs a metaepoch on the given deme population and returns list with
3 named fields: solution, population, value.</p>
</td></tr>
<tr><td><code id="hms_+3A_gsc">gsc</code></td>
<td>
<p>global stopping condition function taking a list of MetaepochSnapshot
objects and returning a logical value; it is evaluated after every metaepoch and
determines whether whole computation should be stopped. See <code><a href="#topic+gsc_metaepochs_count">gsc_metaepochs_count</a></code> for more details.</p>
</td></tr>
<tr><td><code id="hms_+3A_lsc">lsc</code></td>
<td>
<p>local stopping condition - function taking a deme and a list of MetaepochSmapshot
objects representing previous metaepochs; it is run on every deme after it has run a metaepoch
and determines whether that deme will remain active. See <code><a href="#topic+lsc_max_fitness_evaluations">lsc_max_fitness_evaluations</a></code> for more details.</p>
</td></tr>
<tr><td><code id="hms_+3A_sc">sc</code></td>
<td>
<p>sprouting condition - function taking 3 arguments: an individual, a tree level
and a list of Deme objects; it determines whether the given individual can sprout a new deme
on the given level. See <code><a href="#topic+sc_max_metric">sc_max_metric</a></code> for more details.</p>
</td></tr>
<tr><td><code id="hms_+3A_create_population">create_population</code></td>
<td>
<p>function taking 6 parameters: mean, lower, upper, population_size,
tree_level, sigma that returns a population for a Deme object to be created on the given
tree level.</p>
</td></tr>
<tr><td><code id="hms_+3A_suggestions">suggestions</code></td>
<td>
<p>matrix of individuals for the initial population of the root</p>
</td></tr>
<tr><td><code id="hms_+3A_with_gradient_method">with_gradient_method</code></td>
<td>
<p>logical determining whether a gradient method should be run
for all leaves at the end of the computation to refine their best solutions.</p>
</td></tr>
<tr><td><code id="hms_+3A_gradient_method_args">gradient_method_args</code></td>
<td>
<p>list of parameters that are passed to the gradient method</p>
</td></tr>
<tr><td><code id="hms_+3A_run_gradient_method">run_gradient_method</code></td>
<td>
<p>function - returns list with named fields: solution, population, value</p>
</td></tr>
<tr><td><code id="hms_+3A_monitor_level">monitor_level</code></td>
<td>
<p>string - one of: 'none', 'basic', 'basic_tree', 'verbose_tree'.</p>
</td></tr>
<tr><td><code id="hms_+3A_parallel">parallel</code></td>
<td>
<p>logical - <code>TRUE</code> when run_metaepoch runs in parallel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class hms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
</code></pre>

<hr>
<h2 id='hms-class'>A S4 class representing a result of hms.</h2><span id='topic+hms-class'></span>

<h3>Description</h3>

<p>A S4 class representing a result of hms.
</p>


<h3>Slots</h3>


<dl>
<dt><code>root_id</code></dt><dd><p>character - UUID of a root Deme.</p>
</dd>
<dt><code>metaepoch_snapshots</code></dt><dd><p>list of objects of class MetaepochSnapshot.</p>
</dd>
<dt><code>best_fitness</code></dt><dd><p>numeric - best fitness value of all metaepochs.</p>
</dd>
<dt><code>best_solution</code></dt><dd><p>numeric -  best solution of all metaepochs.</p>
</dd>
<dt><code>total_time_in_seconds</code></dt><dd><p>numeric - time of a hms execution in seconds.</p>
</dd>
<dt><code>total_metaepoch_time_in_seconds</code></dt><dd><p>numeric - time of all metaepochs in seconds.</p>
</dd>
<dt><code>metaepochs_count</code></dt><dd><p>numeric - total number of all metaepochs.</p>
</dd>
<dt><code>deme_population_sizes</code></dt><dd><p>numeric - sizes of deme populations on each tree level.
Same as <code>population_sizes</code> parameter of hms function.</p>
</dd>
<dt><code>lower</code></dt><dd><p>numeric - lower bound of the domain, a vector of length equal
to the decision variables.</p>
</dd>
<dt><code>upper</code></dt><dd><p>numeric - upper bound of the domain, a vector of length equal
to the decision variables.</p>
</dd>
<dt><code>call</code></dt><dd><p>language - an object of class &quot;call&quot; representing the matched call.</p>
</dd>
</dl>

<hr>
<h2 id='lsc_max_fitness_evaluations'>Factory function for a local stopping condition that stops a deme
after given number of fitness function evaluations has been made
in that deme.</h2><span id='topic+lsc_max_fitness_evaluations'></span>

<h3>Description</h3>

<p>Factory function for a local stopping condition that stops a deme
after given number of fitness function evaluations has been made
in that deme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsc_max_fitness_evaluations(max_evaluations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsc_max_fitness_evaluations_+3A_max_evaluations">max_evaluations</code></td>
<td>

<ul>
<li><p> numeric
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Function that can be used as a local stopping condition for hms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local_stopping_condition &lt;- lsc_max_fitness_evaluations(500)
</code></pre>

<hr>
<h2 id='lsc_metaepochs_without_active_child'>Factory function for a local stopping condition that stops a deme
after given number of metaepochs have past since last metaepoch during
which this deme had an active child.</h2><span id='topic+lsc_metaepochs_without_active_child'></span>

<h3>Description</h3>

<p>Factory function for a local stopping condition that stops a deme
after given number of metaepochs have past since last metaepoch during
which this deme had an active child.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsc_metaepochs_without_active_child(metaepochs_limit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsc_metaepochs_without_active_child_+3A_metaepochs_limit">metaepochs_limit</code></td>
<td>

<ul>
<li><p> number of metaepochs that a deme can be active
without any active child
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Function that can be used as a local stopping condition for hms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local_stopping_condition &lt;- lsc_metaepochs_without_active_child(3)
</code></pre>

<hr>
<h2 id='lsc_metaepochs_without_improvement'>Factory function for a local stopping condition that stops a deme
after given number of consecutive metaeopochs without an improvement
of the best solution found in that deme.</h2><span id='topic+lsc_metaepochs_without_improvement'></span>

<h3>Description</h3>

<p>Factory function for a local stopping condition that stops a deme
after given number of consecutive metaeopochs without an improvement
of the best solution found in that deme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsc_metaepochs_without_improvement(max_metaepochs_without_improvement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsc_metaepochs_without_improvement_+3A_max_metaepochs_without_improvement">max_metaepochs_without_improvement</code></td>
<td>

<ul>
<li><p> numeric
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Function that can be used as a local stopping condition for hms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local_stopping_condition &lt;- lsc_metaepochs_without_improvement(5)
</code></pre>

<hr>
<h2 id='lsc_trivial'>Factory function for a trivial local stopping condition that
lets a deme be active forever. It is usually used in the root of
a hms tree.</h2><span id='topic+lsc_trivial'></span>

<h3>Description</h3>

<p>Factory function for a trivial local stopping condition that
lets a deme be active forever. It is usually used in the root of
a hms tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsc_trivial()
</code></pre>


<h3>Value</h3>

<p>Function that always returns <code>FALSE</code>, which can be
used as a local stopping condition for hms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local_stopping_condition &lt;- lsc_trivial()
</code></pre>

<hr>
<h2 id='manhattan_distance'>Manhattan distance</h2><span id='topic+manhattan_distance'></span>

<h3>Description</h3>

<p>Manhattan distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manhattan_distance(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manhattan_distance_+3A_x">x</code></td>
<td>

<ul>
<li><p> numeric
</p>
</li></ul>
</td></tr>
<tr><td><code id="manhattan_distance_+3A_y">y</code></td>
<td>

<ul>
<li><p> numeric
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric - manhattan distance between x and y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>manhattan_distance(c(1, 1), c(1, 2))
</code></pre>

<hr>
<h2 id='MetaepochSnapshot-class'>A S4 class representing a snapshot of one metaepoch.</h2><span id='topic+MetaepochSnapshot-class'></span>

<h3>Description</h3>

<p>A S4 class representing a snapshot of one metaepoch.
</p>


<h3>Slots</h3>


<dl>
<dt><code>demes</code></dt><dd><p>list of objects of class Deme.</p>
</dd>
<dt><code>best_fitness</code></dt><dd><p>numeric - best fitness value of a metaepoch.</p>
</dd>
<dt><code>best_solution</code></dt><dd><p>numeric - best solution of a metaepoch.</p>
</dd>
<dt><code>time_in_seconds</code></dt><dd><p>numeric - time of metaepoch in seconds.</p>
</dd>
<dt><code>fitness_evaluations</code></dt><dd><p>numeric - number of fitness evaluations.</p>
</dd>
<dt><code>blocked_sprouts</code></dt><dd><p>list - list of sprouts that were blocked by sprouting
condition. A sprout is a potential origin of a new Deme, it can be blocked
by sc &ndash; sprouting condition. See <code><a href="#topic+sc_max_metric">sc_max_metric</a></code> for more details.</p>
</dd>
<dt><code>is_evolutionary</code></dt><dd><p>logical - <code>TRUE</code> for all metaepochs except the
gradient one.</p>
</dd>
</dl>

<hr>
<h2 id='plot+2Chms-method'>Plot method for &quot;hms&quot; class.</h2><span id='topic+plot+2Chms-method'></span>

<h3>Description</h3>

<p>Plot method for &quot;hms&quot; class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hms'
plot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Chms-method_+3A_x">x</code></td>
<td>

<ul>
<li><p> hms s4 object
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>It doesn't return anything meaningful. It plots the fitness by metaepoch count.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
plot(result)
</code></pre>

<hr>
<h2 id='plotActiveDemes'>plotActiveDemes method for &quot;hms&quot; class.</h2><span id='topic+plotActiveDemes'></span>

<h3>Description</h3>

<p>plotActiveDemes method for &quot;hms&quot; class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotActiveDemes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotActiveDemes_+3A_object">object</code></td>
<td>

<ul>
<li><p> hms s4 object
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>It doesn't return anything meaningful. It plots the number of active
demes per metaepoch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
plotActiveDemes(result)
</code></pre>

<hr>
<h2 id='plotActiveDemes+2Chms-method'>plotActiveDemes method for &quot;hms&quot; class.</h2><span id='topic+plotActiveDemes+2Chms-method'></span>

<h3>Description</h3>

<p>plotActiveDemes method for &quot;hms&quot; class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hms'
plotActiveDemes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotActiveDemes+2B2Chms-method_+3A_object">object</code></td>
<td>

<ul>
<li><p> hms s4 object
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>It doesn't return anything meaningful. It plots the number of active
demes per metaepoch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
plotActiveDemes(result)
</code></pre>

<hr>
<h2 id='plotPopulation'>plotPopulation method for &quot;hms&quot; class.</h2><span id='topic+plotPopulation'></span>

<h3>Description</h3>

<p>plotPopulation method for &quot;hms&quot; class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPopulation(object, dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPopulation_+3A_object">object</code></td>
<td>

<ul>
<li><p> hms s4 object
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotPopulation_+3A_dimensions">dimensions</code></td>
<td>

<ul>
<li><p> two selected dimensions
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>It doesn't return anything meaningful. It plots the selected two
dimensions of a population.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
plotPopulation(result, c(1, 1))
</code></pre>

<hr>
<h2 id='plotPopulation+2Chms-method'>plotPopulation method for &quot;hms&quot; class.</h2><span id='topic+plotPopulation+2Chms-method'></span>

<h3>Description</h3>

<p>plotPopulation method for &quot;hms&quot; class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hms'
plotPopulation(object, dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPopulation+2B2Chms-method_+3A_object">object</code></td>
<td>

<ul>
<li><p> hms s4 object
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotPopulation+2B2Chms-method_+3A_dimensions">dimensions</code></td>
<td>

<ul>
<li><p> two selected dimensions
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>It doesn't return anything meaningful. It plots the selected two
dimensions of a population.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
plotPopulation(result, c(1, 1))
</code></pre>

<hr>
<h2 id='print+2Chms-method'>Print method for class &quot;hms&quot;.</h2><span id='topic+print+2Chms-method'></span>

<h3>Description</h3>

<p>Print method for class &quot;hms&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hms'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2Chms-method_+3A_x">x</code></td>
<td>

<ul>
<li><p> hms s4 object
</p>
</li></ul>
</td></tr>
<tr><td><code id="print+2B2Chms-method_+3A_...">...</code></td>
<td>

<ul>
<li><p> other print arguments
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>It does not return anything. The obvious side effect is output to the terminal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
print(result)
</code></pre>

<hr>
<h2 id='printBlockedSprouts'>printBlockedSprouts method for &quot;hms&quot; class.</h2><span id='topic+printBlockedSprouts'></span>

<h3>Description</h3>

<p>printBlockedSprouts method for &quot;hms&quot; class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printBlockedSprouts(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printBlockedSprouts_+3A_object">object</code></td>
<td>

<ul>
<li><p> hms s4 object
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>It doesn't return anything. It prints blocked sprouts per metaepoch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
printBlockedSprouts(result)
</code></pre>

<hr>
<h2 id='printBlockedSprouts+2Chms-method'>printBlockedSprouts method for &quot;hms&quot; class.</h2><span id='topic+printBlockedSprouts+2Chms-method'></span>

<h3>Description</h3>

<p>printBlockedSprouts method for &quot;hms&quot; class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hms'
printBlockedSprouts(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printBlockedSprouts+2B2Chms-method_+3A_object">object</code></td>
<td>

<ul>
<li><p> hms s4 object
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>It doesn't return anything. It prints blocked sprouts per metaepoch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
printBlockedSprouts(result)
</code></pre>

<hr>
<h2 id='printTree'>printTree method for class &quot;hms&quot;.</h2><span id='topic+printTree'></span>

<h3>Description</h3>

<p>printTree method for class &quot;hms&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printTree(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printTree_+3A_object">object</code></td>
<td>

<ul>
<li><p> hms s4 object
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>It does not return anything. It prints the hms tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
printTree(result)
</code></pre>

<hr>
<h2 id='printTree+2Chms-method'>printTree method for class &quot;hms&quot;.</h2><span id='topic+printTree+2Chms-method'></span>

<h3>Description</h3>

<p>printTree method for class &quot;hms&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hms'
printTree(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printTree+2B2Chms-method_+3A_object">object</code></td>
<td>

<ul>
<li><p> hms s4 object
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>It does not return anything. It prints the hms tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
printTree(result)
</code></pre>

<hr>
<h2 id='rtnorm_mutation'>Factory function that creates normal mutation function</h2><span id='topic+rtnorm_mutation'></span>

<h3>Description</h3>

<p>Given the domain bounds and standard deviation returns a function
compatible with GA interface that performs a mutation on the given
individual using truncated normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtnorm_mutation(lower, upper, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtnorm_mutation_+3A_lower">lower</code></td>
<td>

<ul>
<li><p> Lower bound of the problem's domain
</p>
</li></ul>
</td></tr>
<tr><td><code id="rtnorm_mutation_+3A_upper">upper</code></td>
<td>

<ul>
<li><p> Upper bound of the problem's domain
</p>
</li></ul>
</td></tr>
<tr><td><code id="rtnorm_mutation_+3A_sd">sd</code></td>
<td>

<ul>
<li><p> Standard deviation of the truncated normal distribution
used for the mutation
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Function that takes two parameters (the GA object <code>object</code>
and an individual to perform the mutation on <code>parent</code>) and returns
a new individual that is the result of normal mutation applied to the parent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mutation &lt;- rtnorm_mutation(
  lower = rep(-500, 5),
  upper = rep(500, 5),
  sd = rep(50, 5)
)
</code></pre>

<hr>
<h2 id='saveMetaepochsPopulations'>saveMetaepochsPopulations method for &quot;hms&quot; class.</h2><span id='topic+saveMetaepochsPopulations'></span>

<h3>Description</h3>

<p>saveMetaepochsPopulations method for &quot;hms&quot; class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveMetaepochsPopulations(object, path, dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveMetaepochsPopulations_+3A_object">object</code></td>
<td>
<p>hms s4 object</p>
</td></tr>
<tr><td><code id="saveMetaepochsPopulations_+3A_path">path</code></td>
<td>
<p>path</p>
</td></tr>
<tr><td><code id="saveMetaepochsPopulations_+3A_dimensions">dimensions</code></td>
<td>
<p>vector of two selected dimensions e.g. c(1,2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It doesn't return anything. It creates plots and saves them to a specified
directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitness &lt;- function(x) x[1] + x[2]
lower &lt;- c(-5, -5)
upper &lt;- c(5, 5)
result &lt;- hms(fitness = fitness, lower = lower, upper = upper)
selected_dimensions &lt;- c(1, 2)
saveMetaepochsPopulations(result, tempdir(), selected_dimensions)
</code></pre>

<hr>
<h2 id='saveMetaepochsPopulations+2Chms-method'>saveMetaepochsPopulations</h2><span id='topic+saveMetaepochsPopulations+2Chms-method'></span>

<h3>Description</h3>

<p>saveMetaepochsPopulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hms'
saveMetaepochsPopulations(object, path, dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveMetaepochsPopulations+2B2Chms-method_+3A_object">object</code></td>
<td>
<p>hms s4 object</p>
</td></tr>
<tr><td><code id="saveMetaepochsPopulations+2B2Chms-method_+3A_path">path</code></td>
<td>
<p>path</p>
</td></tr>
<tr><td><code id="saveMetaepochsPopulations+2B2Chms-method_+3A_dimensions">dimensions</code></td>
<td>
<p>vector of two selected dimensions e.g. c(1,2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It doesn't return anything. It creates plots and saves them to a specified
directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitness &lt;- function(x) x[1] + x[2]
lower &lt;- c(-5, -5)
upper &lt;- c(5, 5)
result &lt;- hms(fitness = fitness, lower = lower, upper = upper)
selected_dimensions &lt;- c(1, 2)
saveMetaepochsPopulations(result, tempdir(), selected_dimensions)
</code></pre>

<hr>
<h2 id='sc_max_metric'>Default sprouting condition based on given metric.</h2><span id='topic+sc_max_metric'></span>

<h3>Description</h3>

<p>It allows an individual to sprout only if there are no other
demes on the target level that have centroid within the given
distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_max_metric(metric, max_distances)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc_max_metric_+3A_metric">metric</code></td>
<td>

<ul>
<li><p> Metric used for deme distance comparison (e.g.
euclidean_distance, manhattan_distance)
</p>
</li></ul>
</td></tr>
<tr><td><code id="sc_max_metric_+3A_max_distances">max_distances</code></td>
<td>

<ul>
<li><p> numeric - maximum distance to a centroid of
a deme on the target level that would allow the individual to sprout
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Function that can be used as a sprouting condition of hms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sprouting_condition &lt;- sc_max_metric(euclidean_distance, c(20, 10))
</code></pre>

<hr>
<h2 id='show+2Chms-method'>Show method for class &quot;hms&quot;.</h2><span id='topic+show+2Chms-method'></span>

<h3>Description</h3>

<p>Show method for class &quot;hms&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hms'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Chms-method_+3A_object">object</code></td>
<td>

<ul>
<li><p> hms s4 object
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns the names of the slots and the classes associated with the
slots in the &quot;hms&quot; class. It prints call details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
show(result)
</code></pre>

<hr>
<h2 id='summary+2Chms-method'>Summary method for class &quot;hms&quot;.</h2><span id='topic+summary+2Chms-method'></span>

<h3>Description</h3>

<p>Summary method for class &quot;hms&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hms'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2Chms-method_+3A_object">object</code></td>
<td>

<ul>
<li><p> hms s4 object
</p>
</li></ul>
</td></tr>
<tr><td><code id="summary+2B2Chms-method_+3A_...">...</code></td>
<td>

<ul>
<li><p> other summary arguments
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with fields: fitness, solution, metaepochs, deme_population_sizes,
lower_bound, upper_bound, computation_time. These fields should match fields
of class &quot;hms&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x
result &lt;- hms(fitness = f, lower = -5, upper = 5)
summary(result)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
