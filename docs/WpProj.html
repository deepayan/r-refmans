<!DOCTYPE html><html><head><title>Help for package WpProj</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WpProj}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#WpProj-package'><p>WpProj: Linear p-Wasserstein Projections</p></a></li>
<li><a href='#binary_program_method_options'><p>Options For Use With the Binary Program Method</p></a></li>
<li><a href='#combine.distcompare'><p>Combine distance calculations from the distCompare function</p></a></li>
<li><a href='#combine.WPR2'><p>A Function to Combine <code class="reqn">W_p R ^2</code> Objects</p></a></li>
<li><a href='#distCompare'><p>Compares Optimal Transport Distances Between WpProj and Original Models</p></a></li>
<li><a href='#HC'><p>Run the Hahn-Carvalho Method</p></a></li>
<li><a href='#L0_method_options'><p>Options For Use With the L0 Method</p></a></li>
<li><a href='#L1_method_options'><p>Options For Use With the L1 Method</p></a></li>
<li><a href='#L1_penalty_options'><p>Recognized L1 Penalties</p></a></li>
<li><a href='#plot_ranks'><p>Plot the Rankings of the 'combine.distcompare' Objects</p></a></li>
<li><a href='#plot,combine_distcompare-method'><p>Plot 'combine.distcompare' Objects</p></a></li>
<li><a href='#plot,distcompare-method'><p>Plot <code>distcompare</code> Objects</p></a></li>
<li><a href='#plot,WPR2-method'><p>Plot Function for <code class="reqn">W_p R^2</code> Objects</p></a></li>
<li><a href='#rank_distcompare'><p>Ranks <code>distcompare</code> Objects</p></a></li>
<li><a href='#ridgePlot'><p>Ridge Plots for a Range of Coefficients</p></a></li>
<li><a href='#simulated_annealing_method_options'><p>Options For Use With the Simulated Annealing Selection Method</p></a></li>
<li><a href='#stepwise_method_options'><p>Options For Use With the Stepwise Selection Method</p></a></li>
<li><a href='#transport_options'><p>Available Wasserstein Distance Methods</p></a></li>
<li><a href='#W1L1'><p>1-Wasserstein projection</p></a></li>
<li><a href='#W2IP'><p>2-Wasserstein distance selection by Integer Programming</p></a></li>
<li><a href='#W2L1'><p>2-Wasserstein distance linear projections with an <code class="reqn">L_1</code> penalty</p></a></li>
<li><a href='#wasserstein'><p>Calculate Wasserstein distances</p></a></li>
<li><a href='#WInfL1'><p>Infinity-Wasserstein Linear Projections With an L1 Penalty</p></a></li>
<li><a href='#WPL0'><p>p-Wasserstein projections with an L0 penalty</p></a></li>
<li><a href='#WPL1'><p>p-Wasserstein Linear Projections With an <code class="reqn">L_1</code> Penalty</p></a></li>
<li><a href='#WpProj'><p>p-Wasserstein Linear Projections</p></a></li>
<li><a href='#WPR2'><p><code class="reqn">W_p R^2</code> Function to Evaluate Performance</p></a></li>
<li><a href='#WPSA'><p>p-Wasserstein distance projections using simulated annealing</p></a></li>
<li><a href='#WPSW'><p>p-Wasserstein Distance Linear Projections Using a Stepwise Method</p></a></li>
<li><a href='#WPVI'><p>p-Wasserstein Variable Importance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Linear p-Wasserstein Projections</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-31</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs Wasserstein projections from the predictive distributions of any model into the space of predictive distributions of linear models. We utilize L1 penalties to also reduce the complexity of the model space. This package employs the methods as described in Dunipace, Eric and Lorenzo Trippa (2020) &lt;<a href="https://doi.org/10.48550/arXiv.2012.09999">doi:10.48550/arXiv.2012.09999</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (== 3.0)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, ggsci, ggridges, glmnet, oem, Rcpp, rlang, ROI,
ROI.plugin.ecos, ROI.plugin.lpsolve, Matrix, rqPen, quantreg,
doParallel, foreach, doRNG, dplyr, stats, magrittr, methods,
slam, lifecycle</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, Rcpp (&ge; 1.0.0), RcppEigen (&ge; 0.3.3.4.0), RcppProgress,
RcppCGAL, RSpectra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), transport, Rmosek, spelling, ECOSolveR</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ericdunipace/WpProj">https://github.com/ericdunipace/WpProj</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ericdunipace/WpProj/issues">https://github.com/ericdunipace/WpProj/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-01 21:49:55 UTC; eifer</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric Dunipace <a href="https://orcid.org/0000-0001-8909-213X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Clemens Schmid <a href="https://orcid.org/0000-0003-3448-5715"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (ETA progres bar is adapted from their code),
  Espen Bernton [ctb] ('Hilbert Sort' adapted from their code),
  Mathieu Gerber [ctb] ('Hilbert Sort' adapted from their code),
  Pierre Jacob [ctb] ('Hilbert Sort' adapted from their code),
  Bin Dai [ctb] (W2 projections adapted from their 'OEM' code),
  Jared Huling <a href="https://orcid.org/0000-0003-0670-4845"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (W2 projections adapted from their 'OEM' code),
  Yixuan Qiu [ctb] (W2 projections adapted from their 'OEM' code),
  Dominic Schuhmacher [ctb] ('Shortsimplex 'optimal transport method
    adapted from their code),
  Nicolas Bonneel [ctb] ('Network Simplex' algorithm adapted from their
    code)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Dunipace &lt;edunipace@mail.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 10:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='WpProj-package'>WpProj: Linear p-Wasserstein Projections</h2><span id='topic+WpProj-package'></span>

<h3>Description</h3>

<p>Performs Wasserstein projections from the predictive distributions of any model into the space of predictive distributions of linear models. We utilize L1 penalties to also reduce the complexity of the model space. This package employs the methods as described in Dunipace, Eric and Lorenzo Trippa (2020) <a href="https://arxiv.org/abs/2012.09999">arXiv:2012.09999</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eric Dunipace <a href="mailto:edunipace@mail.harvard.edu">edunipace@mail.harvard.edu</a> (<a href="https://orcid.org/0000-0001-8909-213X">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Clemens Schmid <a href="mailto:clemens@nevrome.de">clemens@nevrome.de</a> (<a href="https://orcid.org/0000-0003-3448-5715">ORCID</a>) (ETA progres bar is adapted from their code) [contributor]
</p>
</li>
<li><p> Espen Bernton ('Hilbert Sort' adapted from their code) [contributor]
</p>
</li>
<li><p> Mathieu Gerber ('Hilbert Sort' adapted from their code) [contributor]
</p>
</li>
<li><p> Pierre Jacob ('Hilbert Sort' adapted from their code) [contributor]
</p>
</li>
<li><p> Bin Dai <a href="mailto:bdai@uwalumni.com">bdai@uwalumni.com</a> (W2 projections adapted from their 'OEM' code) [contributor]
</p>
</li>
<li><p> Jared Huling <a href="mailto:jaredhuling@gmail.com">jaredhuling@gmail.com</a> (<a href="https://orcid.org/0000-0003-0670-4845">ORCID</a>) (W2 projections adapted from their 'OEM' code) [contributor]
</p>
</li>
<li><p> Yixuan Qiu (W2 projections adapted from their 'OEM' code) [contributor]
</p>
</li>
<li><p> Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a> ('Shortsimplex 'optimal transport method adapted from their code) [contributor]
</p>
</li>
<li><p> Nicolas Bonneel ('Network Simplex' algorithm adapted from their code) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ericdunipace/WpProj">https://github.com/ericdunipace/WpProj</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ericdunipace/WpProj/issues">https://github.com/ericdunipace/WpProj/issues</a>
</p>
</li></ul>


<hr>
<h2 id='binary_program_method_options'>Options For Use With the Binary Program Method</h2><span id='topic+binary_program_method_options'></span>

<h3>Description</h3>

<p>Options For Use With the Binary Program Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary_program_method_options(
  maxit = 500L,
  infimum.maxit = 100L,
  transport.method = transport_options(),
  epsilon = 0.05,
  OTmaxit = 100L,
  model.size = NULL,
  nvars = NULL,
  tol = 1e-07,
  display.progress = FALSE,
  parallel = NULL,
  solver.options = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_program_method_options_+3A_maxit">maxit</code></td>
<td>
<p>The maximum iterations for the optimizer. Default is 500.</p>
</td></tr>
<tr><td><code id="binary_program_method_options_+3A_infimum.maxit">infimum.maxit</code></td>
<td>
<p>Maximum iterations to alternate binary program and Wasserstein distance calculations</p>
</td></tr>
<tr><td><code id="binary_program_method_options_+3A_transport.method">transport.method</code></td>
<td>
<p>Method for Wasserstein distance calculation. Should be one the outputs of <code><a href="#topic+transport_options">transport_options()</a></code></p>
</td></tr>
<tr><td><code id="binary_program_method_options_+3A_epsilon">epsilon</code></td>
<td>
<p>A value &gt; 0 for the penalty parameter of if using the Sinkhorn method</p>
</td></tr>
<tr><td><code id="binary_program_method_options_+3A_otmaxit">OTmaxit</code></td>
<td>
<p>The number of iterations to run the Wasserstein distance solvers.</p>
</td></tr>
<tr><td><code id="binary_program_method_options_+3A_model.size">model.size</code></td>
<td>
<p>What is the maximum number of coefficients to have in the final model. Default is NULL. If NULL, will find models from the minimum size, 0, to the number of columns in <code>X</code>.</p>
</td></tr>
<tr><td><code id="binary_program_method_options_+3A_nvars">nvars</code></td>
<td>
<p>The number of variables to explore. Should be an integer vector of model sizes. Default is NULL which will explore all models from 1 to <code>model.size</code>.</p>
</td></tr>
<tr><td><code id="binary_program_method_options_+3A_tol">tol</code></td>
<td>
<p>The tolerance for convergence</p>
</td></tr>
<tr><td><code id="binary_program_method_options_+3A_display.progress">display.progress</code></td>
<td>
<p>Logical. Should intermediate progress be displayed? TRUE or FALSE. Default is FALSE.</p>
</td></tr>
<tr><td><code id="binary_program_method_options_+3A_parallel">parallel</code></td>
<td>
<p>A cluster backend to be used by <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>. See <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code> for details about how to set them up. The <code>WpProj</code> functions will register the cluster with the <code><a href="doParallel.html#topic+registerDoParallel">doParallel::registerDoParallel()</a></code> function internally.</p>
</td></tr>
<tr><td><code id="binary_program_method_options_+3A_solver.options">solver.options</code></td>
<td>
<p>Options to be passed on to the solver. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will setup the default arguments used by the binary program method. Of note, for the argument <code>solver.options</code>, If using the &quot;lasso&quot; solver, you should provide arguments such as &quot;penalty&quot;, &quot;nlambda&quot;, &quot;lambda.min.ratio&quot;, &quot;gamma&quot;, and &quot;lambda&quot; in a list. A simple way to do this is to feed the output of the <code><a href="#topic+L1_method_options">L1_method_options()</a></code> function to the argument <code>solver.options.</code> This will tell the approximate solver, which uses a lasso method that then will project the parameters back to the <code class="reqn">\{0,1\}</code> space. For the other solvers, you can see the options in the ECOS solver package, <code><a href="ECOSolveR.html#topic+ecos.control">ECOSolveR::ecos.control()</a></code>, and the options for the mosek solver, <code><a href="Rmosek.html#topic+mosek">Rmosek::mosek()</a></code>.
</p>


<h3>Value</h3>

<p>A list with names corresponding to each argument above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WpProj">WpProj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>binary_program_method_options()
# is using the lasso solver for the binary program method to give an approximate solution
binary_program_method_options(solver.options = L1_method_options(nlambda = 50L))
</code></pre>

<hr>
<h2 id='combine.distcompare'>Combine distance calculations from the distCompare function</h2><span id='topic+combine.distcompare'></span>

<h3>Description</h3>

<p>Combine distance calculations from the distCompare function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.distcompare(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.distcompare_+3A_...">...</code></td>
<td>
<p><code>distcompare</code> objects that are the result of <code><a href="#topic+distCompare">distCompare()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>combine.distcompare</code>, the combined <code>distcompare</code> class objects as returned by <code><a href="#topic+distCompare">distCompare()</a></code> function
</p>

<hr>
<h2 id='combine.WPR2'>A Function to Combine <code class="reqn">W_p R ^2</code> Objects</h2><span id='topic+combine.WPR2'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Will combine <code class="reqn">W_p R ^2</code> objects into a single object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.WPR2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.WPR2_+3A_...">...</code></td>
<td>
<p>List of <code class="reqn">W_p R^2</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code class="reqn">W_p R^2</code> objects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WPR2">WPR2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (rlang::is_installed("stats")) {
n &lt;- 128
p &lt;- 10
s &lt;- 99
x &lt;- matrix( stats::rnorm( p * n ), nrow = n, ncol = p )
beta &lt;- (1:10)/10
y &lt;- x %*% beta + stats::rnorm(n)
post_beta &lt;- matrix(beta, nrow=p, ncol=s) + stats::rnorm(p*s, 0, 0.1)
post_mu &lt;- x %*% post_beta


fit1 &lt;-  WpProj(X=x, eta=post_mu, theta = post_beta,
               power = 2.0, method = "binary program")
fit2 &lt;-  WpProj(X=x, eta=post_mu, power = 2.0,
               options = list(penalty = "lasso")
)



out1 &lt;- WPR2(predictions = post_mu, projected_model = fit1)
out2 &lt;- WPR2(predictions = post_mu, projected_model = fit2)

combine &lt;- combine.WPR2(out1, out2)
}
</code></pre>

<hr>
<h2 id='distCompare'>Compares Optimal Transport Distances Between WpProj and Original Models</h2><span id='topic+distCompare'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Will compare the Wasserstein distance between the original model and the <code>WpProj</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distCompare(
  models,
  target = list(parameters = NULL, predictions = NULL),
  power = 2,
  method = "exact",
  quantity = c("parameters", "predictions"),
  parallel = NULL,
  transform = function(x) {
     return(x)
 },
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distCompare_+3A_models">models</code></td>
<td>
<p>A list of models from WpProj methods</p>
</td></tr>
<tr><td><code id="distCompare_+3A_target">target</code></td>
<td>
<p>The target to compare the methods to. Should be a list with slots &quot;parameters&quot; to compare the parameters and &quot;predictions&quot; to compare predictions</p>
</td></tr>
<tr><td><code id="distCompare_+3A_power">power</code></td>
<td>
<p>The power parameter of the Wasserstein distance.</p>
</td></tr>
<tr><td><code id="distCompare_+3A_method">method</code></td>
<td>
<p>Which approximation to the Wasserstein distance to use. Should be one of the outputs of <code><a href="#topic+transport_options">transport_options()</a></code>.</p>
</td></tr>
<tr><td><code id="distCompare_+3A_quantity">quantity</code></td>
<td>
<p>Should the function target the &quot;parameters&quot; or the &quot;predictions&quot;. Can choose both.</p>
</td></tr>
<tr><td><code id="distCompare_+3A_parallel">parallel</code></td>
<td>
<p>Parallel backend to use for the <code>foreach</code> package. See <code style="white-space: pre;">&#8288;foreach::registerDoParallel(&#8288;</code> for more details.</p>
</td></tr>
<tr><td><code id="distCompare_+3A_transform">transform</code></td>
<td>
<p>Transformation function for the predictions.</p>
</td></tr>
<tr><td><code id="distCompare_+3A_...">...</code></td>
<td>
<p>other options passed to the <code><a href="#topic+wasserstein">wasserstein()</a></code> distance function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the data frames, <code>dist</code> is the Wasserstein distance, <code>nactive</code> is the number of active variables in the model, <code>groups</code> is the name distinguishing the model, and <code>method</code> is the method used to calculate the distance (i.e., exact, sinkhorn, etc.). If the list in <code>models</code> is named, these will be used as the group names otherwise the group names will be created based on the call from the <code>WpProj</code> method.
</p>


<h3>Value</h3>

<p>an object of class <code>distcompare</code> with slots <code>parameters</code>, <code>predictions</code>, and <code>p</code>. The slots <code>parameters</code> and <code>predictions</code> are data frames. See the details for more info. The slot <code>p</code> is the power parameter of the Wasserstein distance used in the distance calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rlang::is_installed("stats")) {
n &lt;- 32
p &lt;- 10
s &lt;- 21
x &lt;- matrix( stats::rnorm( p * n ), nrow = n, ncol = p )
beta &lt;- (1:10)/10
y &lt;- x %*% beta + stats::rnorm(n)
post_beta &lt;- matrix(beta, nrow=p, ncol=s) + stats::rnorm(p*s, 0, 0.1)
post_mu &lt;- x %*% post_beta

fit1 &lt;-  WpProj(X=x, eta=post_mu, power = 2.0,
               options = list(penalty = "lasso")
)
fit2 &lt;-  WpProj(X=x, eta=post_mu, theta = post_beta, power = 2.0,
               method = "binary program", solver = "lasso",
               options = list(solver.options = list(penalty = "mcp"))
)
dc &lt;- distCompare(models = list("L1" = fit1, "BP" = fit2),
                 target = list(parameters = post_beta, predictions = post_mu))
plot(dc)
}
</code></pre>

<hr>
<h2 id='HC'>Run the Hahn-Carvalho Method</h2><span id='topic+HC'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Runs the Hahn-Carvalho method but adapted to return full distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HC(
  X,
  Y = NULL,
  theta,
  family = "gaussian",
  penalty = c("elastic.net", "selection.lasso", "lasso", "ols", "mcp", "scad", "mcp.net",
    "scad.net", "grp.lasso", "grp.lasso.net", "grp.mcp", "grp.scad", "grp.mcp.net",
    "grp.scad.net", "sparse.grp.lasso"),
  method = c("selection.variable", "projection"),
  lambda = numeric(0),
  nlambda = 100L,
  lambda.min.ratio = NULL,
  alpha = 1,
  gamma = 1,
  tau = 0.5,
  groups = numeric(0),
  penalty.factor = NULL,
  group.weights = NULL,
  maxit = 500L,
  tol = 1e-07,
  irls.maxit = 100L,
  irls.tol = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HC_+3A_x">X</code></td>
<td>
<p>Covariates</p>
</td></tr>
<tr><td><code id="HC_+3A_y">Y</code></td>
<td>
<p>Predictions</p>
</td></tr>
<tr><td><code id="HC_+3A_theta">theta</code></td>
<td>
<p>Parameters</p>
</td></tr>
<tr><td><code id="HC_+3A_family">family</code></td>
<td>
<p>Family for method. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="HC_+3A_penalty">penalty</code></td>
<td>
<p>Penalty function. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="HC_+3A_method">method</code></td>
<td>
<p>Should we run a selection variable methodology or projection?</p>
</td></tr>
<tr><td><code id="HC_+3A_lambda">lambda</code></td>
<td>
<p>lambda for lasso. See <a href="oem.html#topic+oem">oem</a> for this and all options below</p>
</td></tr>
<tr><td><code id="HC_+3A_nlambda">nlambda</code></td>
<td>
<p>Number of lambda values.</p>
</td></tr>
<tr><td><code id="HC_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Minimum lambda ratio for self selected lambda</p>
</td></tr>
<tr><td><code id="HC_+3A_alpha">alpha</code></td>
<td>
<p>elastic net mixing.</p>
</td></tr>
<tr><td><code id="HC_+3A_gamma">gamma</code></td>
<td>
<p>tuning parameters for SCAD and MCP</p>
</td></tr>
<tr><td><code id="HC_+3A_tau">tau</code></td>
<td>
<p>mixing parameter for sparse group lasso</p>
</td></tr>
<tr><td><code id="HC_+3A_groups">groups</code></td>
<td>
<p>A vector of grouping values</p>
</td></tr>
<tr><td><code id="HC_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>Penalty factor for OEM.</p>
</td></tr>
<tr><td><code id="HC_+3A_group.weights">group.weights</code></td>
<td>
<p>Weights for groupped lasso</p>
</td></tr>
<tr><td><code id="HC_+3A_maxit">maxit</code></td>
<td>
<p>Max iteration for OEM</p>
</td></tr>
<tr><td><code id="HC_+3A_tol">tol</code></td>
<td>
<p>Tolerance for OEM</p>
</td></tr>
<tr><td><code id="HC_+3A_irls.maxit">irls.maxit</code></td>
<td>
<p>IRLS max iterations for OEM</p>
</td></tr>
<tr><td><code id="HC_+3A_irls.tol">irls.tol</code></td>
<td>
<p>IRLS tolerance for OEM</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>WpProj</code> object with selected covariates and their values
</p>


<h3>References</h3>

<p>Hahn, P. Richard and Carlos M. Carvalho. (2014) &quot;Decoupling Shrinkage and Selection in Bayesian Linear Models: A Posterior Summary Perspective.&quot; <a href="https://arxiv.org/pdf/1408.0464.pdf">https://arxiv.org/pdf/1408.0464.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 32
p &lt;- 10
s &lt;- 99
x &lt;- matrix( 1, nrow = n, ncol = p )
beta &lt;- (1:10)/10
y &lt;- x %*% beta
post_beta &lt;- matrix(beta, nrow=p, ncol=s) 
post_mu &lt;- x %*% post_beta

fit &lt;-  HC(X=x, Y=post_mu, theta = post_beta,
               penalty = "lasso", 
               method = "projection"
)
</code></pre>

<hr>
<h2 id='L0_method_options'>Options For Use With the L0 Method</h2><span id='topic+L0_method_options'></span>

<h3>Description</h3>

<p>Options For Use With the L0 Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L0_method_options(
  method = c("binary program", "projection"),
  transport.method = transport_options(),
  epsilon = 0.05,
  OTmaxit = 100,
  parallel = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L0_method_options_+3A_method">method</code></td>
<td>
<p>Should covariates be selected as an approximate &quot;binary program&quot; or should a projection method be used. Default is the approximate binary program.</p>
</td></tr>
<tr><td><code id="L0_method_options_+3A_transport.method">transport.method</code></td>
<td>
<p>Method for Wasserstein distance calculation. Should be one the outputs of <code><a href="#topic+transport_options">transport_options()</a></code>.</p>
</td></tr>
<tr><td><code id="L0_method_options_+3A_epsilon">epsilon</code></td>
<td>
<p>A value &gt; 0 for the penalty parameter if using the Sinkhorn method for optimal transport</p>
</td></tr>
<tr><td><code id="L0_method_options_+3A_otmaxit">OTmaxit</code></td>
<td>
<p>The number of iterations to run the Wasserstein distance solvers.</p>
</td></tr>
<tr><td><code id="L0_method_options_+3A_parallel">parallel</code></td>
<td>
<p>A cluster backend to be used by <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code> if parallelization is desired.</p>
</td></tr>
<tr><td><code id="L0_method_options_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list corresponding to the above arguments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L0_method_options()
</code></pre>

<hr>
<h2 id='L1_method_options'>Options For Use With the L1 Method</h2><span id='topic+L1_method_options'></span>

<h3>Description</h3>

<p>Options For Use With the L1 Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L1_method_options(
  penalty = L1_penalty_options(),
  lambda = numeric(0),
  nlambda = 500L,
  lambda.min.ratio = 1e-04,
  gamma = 1,
  maxit = 500L,
  model.size = NULL,
  tol = 1e-07,
  display.progress = FALSE,
  solver.options = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L1_method_options_+3A_penalty">penalty</code></td>
<td>
<p>The penalty to use. See <code><a href="#topic+L1_penalty_options">L1_penalty_options()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="L1_method_options_+3A_lambda">lambda</code></td>
<td>
<p>The penalty parameter to use if method is &quot;L1&quot;.</p>
</td></tr>
<tr><td><code id="L1_method_options_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of lambdas to explore for the &quot;L1&quot; method if <code>lambda</code> is not provided</p>
</td></tr>
<tr><td><code id="L1_method_options_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>The minimum ratio of max to min lambda for &quot;L1&quot; method. Default 1e-4.</p>
</td></tr>
<tr><td><code id="L1_method_options_+3A_gamma">gamma</code></td>
<td>
<p>Tuning parameter for SCAD and MCP penalties if method = &quot;L1&quot;.</p>
</td></tr>
<tr><td><code id="L1_method_options_+3A_maxit">maxit</code></td>
<td>
<p>The maximum iterations for optimization. Default is 500.</p>
</td></tr>
<tr><td><code id="L1_method_options_+3A_model.size">model.size</code></td>
<td>
<p>What is the maximum number of coefficients to have in the final model. Default is NULL. If NULL, will find models from the minimum size, 0, to the number of columns in <code>X</code>.</p>
</td></tr>
<tr><td><code id="L1_method_options_+3A_tol">tol</code></td>
<td>
<p>The tolerance for convergence</p>
</td></tr>
<tr><td><code id="L1_method_options_+3A_display.progress">display.progress</code></td>
<td>
<p>Logical. Should intermediate progress be displayed? TRUE or FALSE. Default is FALSE.</p>
</td></tr>
<tr><td><code id="L1_method_options_+3A_solver.options">solver.options</code></td>
<td>
<p>Options to be passed on to the solver. Only used for &quot;ecos&quot; and &quot;mosek&quot; solvers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with names corresponding to each argument above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WpProj">WpProj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L1_method_options()
</code></pre>

<hr>
<h2 id='L1_penalty_options'>Recognized L1 Penalties</h2><span id='topic+L1_penalty_options'></span>

<h3>Description</h3>

<p>Recognized L1 Penalties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L1_penalty_options()
</code></pre>


<h3>Value</h3>

<p>A character vector with the possible penalties for L1 methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L1_penalty_options()
# [1] "lasso"            "ols"              "mcp"              "elastic.net"      "scad"            
# [6] "mcp.net"          "scad.net"         "grp.lasso"        "grp.lasso.net"    "grp.mcp"         
# [11] "grp.scad"         "grp.mcp.net"      "grp.scad.net"     "sparse.grp.lasso"
</code></pre>

<hr>
<h2 id='plot_ranks'>Plot the Rankings of the 'combine.distcompare' Objects</h2><span id='topic+plot_ranks'></span>

<h3>Description</h3>

<p>Plot the Rankings of the 'combine.distcompare' Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ranks(distances, ylim = NULL, ylabs = c(NULL, NULL), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ranks_+3A_distances">distances</code></td>
<td>
<p>A <code>combine.distcompare</code> object resulting from the <code><a href="#topic+combine.distcompare">combine.distcompare()</a></code> function</p>
</td></tr>
<tr><td><code id="plot_ranks_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="plot_ranks_+3A_ylabs">ylabs</code></td>
<td>
<p>y-axis labels</p>
</td></tr>
<tr><td><code id="plot_ranks_+3A_...">...</code></td>
<td>
<p>additional plot arguments like alpha parameter in ggplot2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>plotrank</code> which is a list with slots &quot;parameters&quot; and &quot;predictions&quot;
</p>

<hr>
<h2 id='plot+2Ccombine_distcompare-method'>Plot 'combine.distcompare' Objects</h2><span id='topic+plot+2Ccombine_distcompare-method'></span>

<h3>Description</h3>

<p>Plot 'combine.distcompare' Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'combine_distcompare'
plot(x, ylim = NULL, ylabs = c(NULL, NULL), facet.group = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Ccombine_distcompare-method_+3A_x">x</code></td>
<td>
<p><code>combine.distcompare</code> objects resulting from the <code><a href="#topic+combine.distcompare">combine.distcompare()</a></code> function</p>
</td></tr>
<tr><td><code id="plot+2B2Ccombine_distcompare-method_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="plot+2B2Ccombine_distcompare-method_+3A_ylabs">ylabs</code></td>
<td>
<p>y-axis labels</p>
</td></tr>
<tr><td><code id="plot+2B2Ccombine_distcompare-method_+3A_facet.group">facet.group</code></td>
<td>
<p>groups to facet by</p>
</td></tr>
<tr><td><code id="plot+2B2Ccombine_distcompare-method_+3A_...">...</code></td>
<td>
<p>additional plotting parameters like alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>plotcombine</code>that is a list of various diagnostic plots of the <code>WpProj</code> objects
</p>

<hr>
<h2 id='plot+2Cdistcompare-method'>Plot <code>distcompare</code> Objects</h2><span id='topic+plot+2Cdistcompare-method'></span>

<h3>Description</h3>

<p>Plot <code>distcompare</code> Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'distcompare'
plot(
  x = NULL,
  models = NULL,
  ylim = NULL,
  ylabs = c(NULL, NULL),
  xlab = NULL,
  xlim = NULL,
  linesize = 0.5,
  pointsize = 1.5,
  facet.group = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Cdistcompare-method_+3A_x">x</code></td>
<td>
<p>object of class <code>distcompare</code></p>
</td></tr>
<tr><td><code id="plot+2B2Cdistcompare-method_+3A_models">models</code></td>
<td>
<p>Can give list of <code>WpProj</code> outputs and have them turned into <code>distcompare</code> object for immediate plotting</p>
</td></tr>
<tr><td><code id="plot+2B2Cdistcompare-method_+3A_ylim">ylim</code></td>
<td>
<p>Limits on y-axis</p>
</td></tr>
<tr><td><code id="plot+2B2Cdistcompare-method_+3A_ylabs">ylabs</code></td>
<td>
<p>Y-axis labels</p>
</td></tr>
<tr><td><code id="plot+2B2Cdistcompare-method_+3A_xlab">xlab</code></td>
<td>
<p>X-axis labels</p>
</td></tr>
<tr><td><code id="plot+2B2Cdistcompare-method_+3A_xlim">xlim</code></td>
<td>
<p>Limits of the x-axis</p>
</td></tr>
<tr><td><code id="plot+2B2Cdistcompare-method_+3A_linesize">linesize</code></td>
<td>
<p>How big to make the lines?</p>
</td></tr>
<tr><td><code id="plot+2B2Cdistcompare-method_+3A_pointsize">pointsize</code></td>
<td>
<p>How big to make the points?</p>
</td></tr>
<tr><td><code id="plot+2B2Cdistcompare-method_+3A_facet.group">facet.group</code></td>
<td>
<p>Should the plots be turned into a <a href="ggplot2.html#topic+facet_grid">facet_grid</a>?</p>
</td></tr>
<tr><td><code id="plot+2B2Cdistcompare-method_+3A_...">...</code></td>
<td>
<p>Additional options for the wasserstein distance if just inputing raw <code>WpProj</code> models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object
</p>

<hr>
<h2 id='plot+2CWPR2-method'>Plot Function for <code class="reqn">W_p R^2</code> Objects</h2><span id='topic+plot+2CWPR2-method'></span>

<h3>Description</h3>

<p>Plot Function for <code class="reqn">W_p R^2</code> Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'WPR2'
plot(
  x,
  xlim = NULL,
  ylim = NULL,
  linesize = 0.5,
  pointsize = 1.5,
  facet.group = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CWPR2-method_+3A_x">x</code></td>
<td>
<p>A <code class="reqn">W_p R^2</code> object</p>
</td></tr>
<tr><td><code id="plot+2B2CWPR2-method_+3A_xlim">xlim</code></td>
<td>
<p>x-axis limits</p>
</td></tr>
<tr><td><code id="plot+2B2CWPR2-method_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="plot+2B2CWPR2-method_+3A_linesize">linesize</code></td>
<td>
<p>Linesize for <a href="ggplot2.html#topic+geom_line">geom_line</a></p>
</td></tr>
<tr><td><code id="plot+2B2CWPR2-method_+3A_pointsize">pointsize</code></td>
<td>
<p>Point size for <a href="ggplot2.html#topic+geom_point">geom_point</a></p>
</td></tr>
<tr><td><code id="plot+2B2CWPR2-method_+3A_facet.group">facet.group</code></td>
<td>
<p>Group to do facet_grid by</p>
</td></tr>
<tr><td><code id="plot+2B2CWPR2-method_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 128
p &lt;- 10
s &lt;- 99
x &lt;- matrix( stats::rnorm( p * n ), nrow = n, ncol = p )
beta &lt;- (1:10)/10
y &lt;- x %*% beta + stats::rnorm(n)
post_beta &lt;- matrix(beta, nrow=p, ncol=s) + stats::rnorm(p*s, 0, 0.1)
post_mu &lt;- x %*% post_beta

fit &lt;-  WpProj(X=x, eta=post_mu, power = 2.0,
               options = list(penalty = "lasso")
)
obj &lt;- WPR2(predictions = post_mu, projected_model = fit)
p &lt;- plot(obj)
</code></pre>

<hr>
<h2 id='rank_distcompare'>Ranks <code>distcompare</code> Objects</h2><span id='topic+rank_distcompare'></span>

<h3>Description</h3>

<p>Ranks <code>distcompare</code> Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_distcompare(distances)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_distcompare_+3A_distances">distances</code></td>
<td>
<p>A <code>distcompare</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ranks of a <code>distcompare</code> object as a list containing slots &quot;predictions&quot; and &quot;parameters&quot;.
</p>

<hr>
<h2 id='ridgePlot'>Ridge Plots for a Range of Coefficients</h2><span id='topic+ridgePlot'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
This function will plot the distribution of predictions for a range of active coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridgePlot(
  fit,
  index = 1,
  minCoef = 1,
  maxCoef = 10,
  scale = 1,
  alpha = 0.5,
  full = NULL,
  transform = function(x) {
     x
 },
  xlab = "Predictions",
  bandwidth = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ridgePlot_+3A_fit">fit</code></td>
<td>
<p>A <code>WpProj</code> object or list of <code>WpProj</code> objects</p>
</td></tr>
<tr><td><code id="ridgePlot_+3A_index">index</code></td>
<td>
<p>The observation number to select. Can be a vector</p>
</td></tr>
<tr><td><code id="ridgePlot_+3A_mincoef">minCoef</code></td>
<td>
<p>The minimum number of coefficients to use</p>
</td></tr>
<tr><td><code id="ridgePlot_+3A_maxcoef">maxCoef</code></td>
<td>
<p>The maximum number of coefficients to use</p>
</td></tr>
<tr><td><code id="ridgePlot_+3A_scale">scale</code></td>
<td>
<p>How the densities should be scale</p>
</td></tr>
<tr><td><code id="ridgePlot_+3A_alpha">alpha</code></td>
<td>
<p>Alpha term from ggplot2 object</p>
</td></tr>
<tr><td><code id="ridgePlot_+3A_full">full</code></td>
<td>
<p>&quot;True&quot; prediction to compare to</p>
</td></tr>
<tr><td><code id="ridgePlot_+3A_transform">transform</code></td>
<td>
<p>transform for predictions</p>
</td></tr>
<tr><td><code id="ridgePlot_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="ridgePlot_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Bandwidth for kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rlang::is_installed("stats")) {
n &lt;- 128
p &lt;- 10
s &lt;- 99
x &lt;- matrix(stats::rnorm(n*p), nrow = n, ncol = p )
beta &lt;- (1:10)/10
y &lt;- x %*% beta + stats::rnorm(n)
post_beta &lt;- matrix(beta, nrow=p, ncol=s) + matrix(stats::rnorm(p*s, 0, 0.1), p, s)
post_mu &lt;- x %*% post_beta
fit &lt;-  WpProj(X=x, eta=post_mu, 
             power = 2
)
ridgePlot(fit)
}
</code></pre>

<hr>
<h2 id='simulated_annealing_method_options'>Options For Use With the Simulated Annealing Selection Method</h2><span id='topic+simulated_annealing_method_options'></span>

<h3>Description</h3>

<p>Options For Use With the Simulated Annealing Selection Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulated_annealing_method_options(
  force = NULL,
  method = c("binary program", "projection"),
  transport.method = transport_options(),
  OTmaxit = 100L,
  epsilon = 0.05,
  maxit = 1L,
  temps = 1000L,
  max.time = 3600,
  proposal.method = c("covariance", "uniform"),
  energy.distribution = c("boltzman", "bose-einstein"),
  cooling.schedule = c("Geman-Geman", "exponential"),
  model.size = NULL,
  display.progress = FALSE,
  parallel = NULL,
  calc.theta = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulated_annealing_method_options_+3A_force">force</code></td>
<td>
<p>Any covariates to force into the model? Should be by column number or NULL if no variables to force into the model.</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_method">method</code></td>
<td>
<p>Should covariates be selected as an approximate &quot;binary program&quot; or should a projection method be used. Default is the approximate binary program.</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_transport.method">transport.method</code></td>
<td>
<p>Method for Wasserstein distance calculation. Should be one the outputs of <code><a href="#topic+transport_options">transport_options()</a></code></p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_otmaxit">OTmaxit</code></td>
<td>
<p>The number of iterations to run the Wasserstein distance solvers.</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_epsilon">epsilon</code></td>
<td>
<p>A value &gt; 0 for the penalty parameter of if using the Sinkhorn method for optimal transport</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations per temperature</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_temps">temps</code></td>
<td>
<p>Number of temperatures to try</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_max.time">max.time</code></td>
<td>
<p>Maximum time in seconds to run the algorithm</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_proposal.method">proposal.method</code></td>
<td>
<p>The method to propose the next covariate to add. One of &quot;covariance&quot; or &quot;random&quot;. &quot;covariance&quot; will randomly select from covariates with probability proportional to the absolute value of the covariance. &quot;uniform&quot; will select covariates uniformly at random.</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_energy.distribution">energy.distribution</code></td>
<td>
<p>The energy distribution to use for evaluating proposals. One of &quot;boltzman&quot; or &quot;bose-einstein&quot;. Default is &quot;boltzman&quot;.</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_cooling.schedule">cooling.schedule</code></td>
<td>
<p>The schedule to use for cooling temperatures. One of &quot;Geman-Geman&quot; or &quot;exponential&quot;. Default is &quot;Geman-Geman&quot;.</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_model.size">model.size</code></td>
<td>
<p>How many coefficients should the maximum final model have?</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_display.progress">display.progress</code></td>
<td>
<p>Logical. Should intermediate progress be displayed? TRUE or FALSE. Default is FALSE.</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_parallel">parallel</code></td>
<td>
<p>A cluster backend to be used by <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>. See <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code> for details about how to set them up. The <code>WpProj</code> functions will register the cluster with the <code><a href="doParallel.html#topic+registerDoParallel">doParallel::registerDoParallel()</a></code> function internally.</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_calc.theta">calc.theta</code></td>
<td>
<p>Return the linear coefficients? Default is TRUE.</p>
</td></tr>
<tr><td><code id="simulated_annealing_method_options_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the above arguments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_annealing_method_options()
</code></pre>

<hr>
<h2 id='stepwise_method_options'>Options For Use With the Stepwise Selection Method</h2><span id='topic+stepwise_method_options'></span>

<h3>Description</h3>

<p>Options For Use With the Stepwise Selection Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise_method_options(
  force = NULL,
  direction = c("backward", "forward"),
  method = c("binary program", "projection"),
  transport.method = transport_options(),
  OTmaxit = 100,
  epsilon = 0.05,
  model.size = NULL,
  display.progress = FALSE,
  parallel = NULL,
  calc.theta = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise_method_options_+3A_force">force</code></td>
<td>
<p>Any covariates to force into the model? Should be by column number or NULL if no variables to force into the model.</p>
</td></tr>
<tr><td><code id="stepwise_method_options_+3A_direction">direction</code></td>
<td>
<p>&quot;forward&quot; or &quot;backward&quot; selection? Default is &quot;backward&quot;</p>
</td></tr>
<tr><td><code id="stepwise_method_options_+3A_method">method</code></td>
<td>
<p>Should covariates be selected as an approximate &quot;binary program&quot; or should a projection method be used. Default is the approximate binary program.</p>
</td></tr>
<tr><td><code id="stepwise_method_options_+3A_transport.method">transport.method</code></td>
<td>
<p>Method for Wasserstein distance calculation. Should be one the outputs of <code><a href="#topic+transport_options">transport_options()</a></code></p>
</td></tr>
<tr><td><code id="stepwise_method_options_+3A_otmaxit">OTmaxit</code></td>
<td>
<p>The number of iterations to run the Wasserstein distance solvers.</p>
</td></tr>
<tr><td><code id="stepwise_method_options_+3A_epsilon">epsilon</code></td>
<td>
<p>A value &gt; 0 for the penalty parameter of if using the Sinkhorn method for optimal transport</p>
</td></tr>
<tr><td><code id="stepwise_method_options_+3A_model.size">model.size</code></td>
<td>
<p>How many coefficients should the maximum final model have?</p>
</td></tr>
<tr><td><code id="stepwise_method_options_+3A_display.progress">display.progress</code></td>
<td>
<p>Logical. Should intermediate progress be displayed? TRUE or FALSE. Default is FALSE.</p>
</td></tr>
<tr><td><code id="stepwise_method_options_+3A_parallel">parallel</code></td>
<td>
<p>A cluster backend to be used by <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>. See <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code> for details about how to set them up. The <code>WpProj</code> functions will register the cluster with the <code><a href="doParallel.html#topic+registerDoParallel">doParallel::registerDoParallel()</a></code> function internally.</p>
</td></tr>
<tr><td><code id="stepwise_method_options_+3A_calc.theta">calc.theta</code></td>
<td>
<p>Return the linear coefficients? Default is TRUE.</p>
</td></tr>
<tr><td><code id="stepwise_method_options_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the above arguments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stepwise_method_options()
</code></pre>

<hr>
<h2 id='transport_options'>Available Wasserstein Distance Methods</h2><span id='topic+transport_options'></span>

<h3>Description</h3>

<p>Available Wasserstein Distance Methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transport_options()
</code></pre>


<h3>Details</h3>

<p>This function features several methods of calculating approximate optimal transport methods in addition to the exact method. The first is the &quot;sinkhorn&quot; method of Cuturi (2013). The second is the &quot;greenkhorn&quot; method of Altschuler et al. (2017). The third is the Hilbert sorting method of Bernton et al (2017). Then there are two novel approximation methods based on the univariate ranks of each covariate to obtain the average rank &quot;rank&quot;, and a method based on the univariate distances for each covariate &quot;univariate.approximation.pwr&quot;
</p>


<h3>Value</h3>

<p>A character vector of available methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>transport_options()
</code></pre>

<hr>
<h2 id='W1L1'>1-Wasserstein projection</h2><span id='topic+W1L1'></span>

<h3>Description</h3>

<p>1-Wasserstein projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W1L1(
  X,
  Y,
  theta = NULL,
  penalty = c("none", "lasso", "scad", "mcp"),
  model.size = NULL,
  lambda = numeric(0),
  lambda.min.ratio = 1e-04,
  nlambda = 10,
  gamma = 1,
  display.progress = FALSE,
  solver = c("cone", "rqPen", "gurobi", "mosek"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="W1L1_+3A_x">X</code></td>
<td>
<p>Covariates</p>
</td></tr>
<tr><td><code id="W1L1_+3A_y">Y</code></td>
<td>
<p>Predictions from arbitrary model</p>
</td></tr>
<tr><td><code id="W1L1_+3A_theta">theta</code></td>
<td>
<p>Parameters of original linear model. Optional.</p>
</td></tr>
<tr><td><code id="W1L1_+3A_penalty">penalty</code></td>
<td>
<p>penalty term to use. One of &quot;none&quot;, &quot;lasso&quot;,&quot;scad&quot;,&quot;mcp&quot;</p>
</td></tr>
<tr><td><code id="W1L1_+3A_model.size">model.size</code></td>
<td>
<p>Maximum number of coefficients in interpretable model</p>
</td></tr>
<tr><td><code id="W1L1_+3A_lambda">lambda</code></td>
<td>
<p>Lambdas to use</p>
</td></tr>
<tr><td><code id="W1L1_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Minimum lambda to select if choosing lambdas using default methods</p>
</td></tr>
<tr><td><code id="W1L1_+3A_nlambda">nlambda</code></td>
<td>
<p>number of lambdas to look through</p>
</td></tr>
<tr><td><code id="W1L1_+3A_gamma">gamma</code></td>
<td>
<p>parameter for SCAD and MCP methods</p>
</td></tr>
<tr><td><code id="W1L1_+3A_display.progress">display.progress</code></td>
<td>
<p>Print intermediate output?</p>
</td></tr>
<tr><td><code id="W1L1_+3A_solver">solver</code></td>
<td>
<p>Solver to use. Must be one of &quot;rqPen&quot;, &quot;gurobi&quot;, &quot;mosek&quot;, though &quot;mosek&quot; is preferred.</p>
</td></tr>
<tr><td><code id="W1L1_+3A_...">...</code></td>
<td>
<p>options to pass to solvers</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>WpProj</code> object
</p>

<hr>
<h2 id='W2IP'>2-Wasserstein distance selection by Integer Programming</h2><span id='topic+W2IP'></span>

<h3>Description</h3>

<p>2-Wasserstein distance selection by Integer Programming
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W2IP(
  X,
  Y = NULL,
  theta,
  transport.method = transport_options(),
  model.size = NULL,
  nvars = NULL,
  maxit = 100L,
  infimum.maxit = 100L,
  tol = 1e-07,
  solver = c("cone", "lp", "mosek", "cplex", "gurobi"),
  display.progress = FALSE,
  parallel = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="W2IP_+3A_x">X</code></td>
<td>
<p>Covariates</p>
</td></tr>
<tr><td><code id="W2IP_+3A_y">Y</code></td>
<td>
<p>Predictions from arbitrary model</p>
</td></tr>
<tr><td><code id="W2IP_+3A_theta">theta</code></td>
<td>
<p>Parameters of original linear model. Required</p>
</td></tr>
<tr><td><code id="W2IP_+3A_transport.method">transport.method</code></td>
<td>
<p>Method for Wasserstein distance calculation. Should be one of the outputs of <code><a href="#topic+transport_options">transport_options()</a></code>.</p>
</td></tr>
<tr><td><code id="W2IP_+3A_model.size">model.size</code></td>
<td>
<p>Maximum number of coefficients in interpretable model</p>
</td></tr>
<tr><td><code id="W2IP_+3A_nvars">nvars</code></td>
<td>
<p>The number of variables to explore. Should be an integer vector of model sizes. Default is NULL which will explore all models from 1 to <code>model.size</code>.</p>
</td></tr>
<tr><td><code id="W2IP_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of solver iterations</p>
</td></tr>
<tr><td><code id="W2IP_+3A_infimum.maxit">infimum.maxit</code></td>
<td>
<p>Maximum iterations to alternate binary program and Wasserstein distance calculation</p>
</td></tr>
<tr><td><code id="W2IP_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence of coefficients</p>
</td></tr>
<tr><td><code id="W2IP_+3A_solver">solver</code></td>
<td>
<p>The solver to use. Must be one of &quot;cone&quot;,&quot;lp&quot;, &quot;cplex&quot;, &quot;gurobi&quot;,&quot;mosek&quot;.</p>
</td></tr>
<tr><td><code id="W2IP_+3A_display.progress">display.progress</code></td>
<td>
<p>Should progress be printed?</p>
</td></tr>
<tr><td><code id="W2IP_+3A_parallel">parallel</code></td>
<td>
<p>foreach back end. See <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="W2IP_+3A_...">...</code></td>
<td>
<p>Extra args to Wasserstein distance methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For argument <code>solution.method</code>, options &quot;cone&quot; and &quot;lp&quot; use the free solvers &quot;ECOS&quot; and &quot;lpSolver&quot;, respectively. &quot;cplex&quot;, &quot;gurobi&quot; and &quot;mosek&quot; require installing the corresponding commercial solvers.
</p>

<hr>
<h2 id='W2L1'>2-Wasserstein distance linear projections with an <code class="reqn">L_1</code> penalty</h2><span id='topic+W2L1'></span>

<h3>Description</h3>

<p>2-Wasserstein distance linear projections with an <code class="reqn">L_1</code> penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W2L1(
  X,
  Y = NULL,
  theta = NULL,
  penalty = c("lasso", "ols", "mcp", "elastic.net", "selection.lasso", "scad", "mcp.net",
    "scad.net", "grp.lasso", "grp.lasso.net", "grp.mcp", "grp.scad", "grp.mcp.net",
    "grp.scad.net", "sparse.grp.lasso"),
  method = c("projection", "selection.variable", "location.scale", "scale"),
  transport.method = transport_options(),
  epsilon = 0.05,
  OTmaxit = 100,
  model.size = NULL,
  lambda = numeric(0),
  nlambda = 100L,
  lambda.min.ratio = NULL,
  alpha = 1,
  gamma = 1,
  tau = 0.5,
  groups = numeric(0),
  scale.factor = numeric(0),
  penalty.factor = NULL,
  group.weights = NULL,
  maxit = 500L,
  tol = 1e-07,
  irls.maxit = 100L,
  irls.tol = 0.001,
  infimum.maxit = NULL,
  display.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="W2L1_+3A_x">X</code></td>
<td>
<p>An n x p matrix of covariates</p>
</td></tr>
<tr><td><code id="W2L1_+3A_y">Y</code></td>
<td>
<p>An n x s matrix of predictions</p>
</td></tr>
<tr><td><code id="W2L1_+3A_theta">theta</code></td>
<td>
<p>optional parameter matrix for selection methods. Should be p x s.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_penalty">penalty</code></td>
<td>
<p>Form of penalty. One of &quot;lasso&quot;, &quot;ols&quot;, &quot;mcp&quot;, &quot;elastic.net&quot;,&quot;selection.lasso&quot;, &quot;scad&quot;, &quot;mcp.net&quot;, &quot;scad.net&quot;, &quot;grp.lasso&quot;, &quot;grp.lasso.net&quot;, &quot;grp.mcp&quot;,&quot;grp.scad&quot;, &quot;grp.mcp.net&quot;, &quot;grp.scad.net&quot;, &quot;sparse.grp.lasso&quot;</p>
</td></tr>
<tr><td><code id="W2L1_+3A_method">method</code></td>
<td>
<p>&quot;selection.variable&quot; or &quot;projection</p>
</td></tr>
<tr><td><code id="W2L1_+3A_transport.method">transport.method</code></td>
<td>
<p>Method for calculating the Wasserstein distance. One of &quot;exact&quot;, &quot;sinkhorn&quot;, &quot;greenkhorn&quot;,&quot;hilbert&quot;</p>
</td></tr>
<tr><td><code id="W2L1_+3A_epsilon">epsilon</code></td>
<td>
<p>Penalty parameter for Sinkhorn and Greenkhorn and  optimal transport</p>
</td></tr>
<tr><td><code id="W2L1_+3A_otmaxit">OTmaxit</code></td>
<td>
<p>Maximum iterations for the optimal transport iterations</p>
</td></tr>
<tr><td><code id="W2L1_+3A_model.size">model.size</code></td>
<td>
<p>The maximum number of desired covariates. Defaults to the number of covariates.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter for lasso regression. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_nlambda">nlambda</code></td>
<td>
<p>Number of lambda values. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Minimum lambda ratio for self selected lambda. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_alpha">alpha</code></td>
<td>
<p>elastic net mixing. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_gamma">gamma</code></td>
<td>
<p>tuning parameters for SCAD and MCP. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_tau">tau</code></td>
<td>
<p>mixing parameter for sparse group lasso. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_groups">groups</code></td>
<td>
<p>A vector of grouping values. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_scale.factor">scale.factor</code></td>
<td>
<p>Value to standardize the covariates by. Typically, is the standard deviation. Should have length 1 or length same as the number of covariates</p>
</td></tr>
<tr><td><code id="W2L1_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>Penalty factor for OEM. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_group.weights">group.weights</code></td>
<td>
<p>Weights for group lasso. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_maxit">maxit</code></td>
<td>
<p>Max iteration for OEM. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_tol">tol</code></td>
<td>
<p>Tolerance for OEM. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_irls.maxit">irls.maxit</code></td>
<td>
<p>IRLS max iterations for OEM. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_irls.tol">irls.tol</code></td>
<td>
<p>IRLS tolerance for OEM. See <a href="oem.html#topic+oem">oem</a>.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_infimum.maxit">infimum.maxit</code></td>
<td>
<p>Maximum number of iterations alternating optimization and Wasserstein distance calculation. Irrelevant for projection method.</p>
</td></tr>
<tr><td><code id="W2L1_+3A_display.progress">display.progress</code></td>
<td>
<p>Display intermediate progress?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>WpProj</code>
</p>

<hr>
<h2 id='wasserstein'>Calculate Wasserstein distances</h2><span id='topic+wasserstein'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
This function will calculate exact or approximate Wasserstein distances between two groups of observations. Please note that this function will likely be deprecated in favor of using the native function from the <code>approxOT</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wasserstein(
  X,
  Y,
  p = 2,
  ground_p = 2,
  observation.orientation = c("rowwise", "colwise"),
  method = c("exact", "sinkhorn", "greenkhorn", "hilbert", "rank",
    "univariate.approximation", "univariate.approximation.pwr", "univariate"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wasserstein_+3A_x">X</code></td>
<td>
<p>Matrix for first group</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_y">Y</code></td>
<td>
<p>Matrix for second group</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_p">p</code></td>
<td>
<p>Power of the Wasserstein distance</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_ground_p">ground_p</code></td>
<td>
<p>Power of the distance metric. Usually same as <code>p</code></p>
</td></tr>
<tr><td><code id="wasserstein_+3A_observation.orientation">observation.orientation</code></td>
<td>
<p>Are observations unique by rows or columns? One of &quot;colwise&quot; or &quot;rowwise&quot;</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_method">method</code></td>
<td>
<p>One of the outputs of <code><a href="#topic+transport_options">transport_options()</a></code></p>
</td></tr>
<tr><td><code id="wasserstein_+3A_...">...</code></td>
<td>
<p>additional options for sinkhorn based methods. <code>epsilon</code> and <code>niter</code> determining the hyperparameters for the negative entropy penalty</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rlang::is_installed("stats")) {
n &lt;- 128
p &lt;- 10
x &lt;- matrix( stats::rnorm( p * n ), nrow = n, ncol = p )
y &lt;- matrix( stats::rnorm( p * n ), nrow = n, ncol = p )

dist &lt;- wasserstein(x,y, p = 2, ground_p = 1, observation.orientation = "rowwise",
            method = "hilbert") #fast
print(dist)
}
</code></pre>

<hr>
<h2 id='WInfL1'>Infinity-Wasserstein Linear Projections With an L1 Penalty</h2><span id='topic+WInfL1'></span>

<h3>Description</h3>

<p>Infinity-Wasserstein Linear Projections With an L1 Penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WInfL1(
  X,
  Y,
  theta = NULL,
  penalty = c("none", "lasso", "mcp", "scad"),
  lambda = numeric(0),
  lambda.min.ratio = 1e-04,
  gamma = 1.5,
  nlambda = 10,
  solver = c("cone", "mosek", "gurobi"),
  options = list(solver_opts = NULL, init = NULL, tol = 1e-07, iter = 100),
  model.size = NULL,
  display.progress = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WInfL1_+3A_x">X</code></td>
<td>
<p>An n x p matrix of covariates</p>
</td></tr>
<tr><td><code id="WInfL1_+3A_y">Y</code></td>
<td>
<p>An n x s matrix of predictions</p>
</td></tr>
<tr><td><code id="WInfL1_+3A_theta">theta</code></td>
<td>
<p>optional parameter matrix for selection methods. Should be p x s.</p>
</td></tr>
<tr><td><code id="WInfL1_+3A_penalty">penalty</code></td>
<td>
<p>Form of penalty. One of &quot;none&quot;, &quot;lasso&quot;, &quot;mcp&quot;,&quot;scad&quot;</p>
</td></tr>
<tr><td><code id="WInfL1_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter for lasso regression.</p>
</td></tr>
<tr><td><code id="WInfL1_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Minimum lambda ratio for self selected lambda.</p>
</td></tr>
<tr><td><code id="WInfL1_+3A_gamma">gamma</code></td>
<td>
<p>tuning parameters for SCAD and MCP.</p>
</td></tr>
<tr><td><code id="WInfL1_+3A_nlambda">nlambda</code></td>
<td>
<p>Number of lambda values.</p>
</td></tr>
<tr><td><code id="WInfL1_+3A_solver">solver</code></td>
<td>
<p>Which solver to use. One of &quot;cone&quot;,&quot;mosek&quot;, or &quot;gurobi&quot;. Note &quot;mosek&quot; and &quot;gurobi&quot; are commercial installers.</p>
</td></tr>
<tr><td><code id="WInfL1_+3A_options">options</code></td>
<td>
<p>A list containing slots <code>solver_opts</code>, options for each solver, <code>init</code>, initial conditions fed into each solver, <code>tol</code>, tolerance for convergence, and <code>iter</code>, the maximum number of iterations</p>
</td></tr>
<tr><td><code id="WInfL1_+3A_model.size">model.size</code></td>
<td>
<p>The maximum number of paramters to consider. Should be an integer greater than 1 and less than or equal to the number of covariates</p>
</td></tr>
<tr><td><code id="WInfL1_+3A_display.progress">display.progress</code></td>
<td>
<p>Whether to display progress. TRUE or FALSE</p>
</td></tr>
<tr><td><code id="WInfL1_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the solver as needed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>WpProj</code> object
</p>

<hr>
<h2 id='WPL0'>p-Wasserstein projections with an L0 penalty</h2><span id='topic+WPL0'></span>

<h3>Description</h3>

<p>p-Wasserstein projections with an L0 penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WPL0(
  X,
  Y = NULL,
  theta,
  power = 2,
  method = c("selection.variable", "projection"),
  transport.method = transport_options(),
  epsilon = 0.05,
  OTmaxit = 100,
  parallel = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WPL0_+3A_x">X</code></td>
<td>
<p>matrix of covariates</p>
</td></tr>
<tr><td><code id="WPL0_+3A_y">Y</code></td>
<td>
<p>matrix of predictions</p>
</td></tr>
<tr><td><code id="WPL0_+3A_theta">theta</code></td>
<td>
<p>optional matrix of coefficients from original model, if relevant</p>
</td></tr>
<tr><td><code id="WPL0_+3A_power">power</code></td>
<td>
<p>power of the Wasserstein distance</p>
</td></tr>
<tr><td><code id="WPL0_+3A_method">method</code></td>
<td>
<p>One of &quot;selection.variable&quot; or &quot;projection&quot;. Methods decide whether covariate matrix in <code>theta</code> is preserved (&quot;selection.variable&quot;) or if new projections are generated (&quot;projection&quot;)</p>
</td></tr>
<tr><td><code id="WPL0_+3A_transport.method">transport.method</code></td>
<td>
<p>Method for Wasserstein distance calculation. Should be one of the outputs of <code><a href="#topic+transport_options">transport_options()</a></code>.</p>
</td></tr>
<tr><td><code id="WPL0_+3A_epsilon">epsilon</code></td>
<td>
<p>hyperparameter for sinkhorn iterations</p>
</td></tr>
<tr><td><code id="WPL0_+3A_otmaxit">OTmaxit</code></td>
<td>
<p>max iteration for sinkhorn iterations</p>
</td></tr>
<tr><td><code id="WPL0_+3A_parallel">parallel</code></td>
<td>
<p>foreach backend</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>WpProj</code> object
</p>

<hr>
<h2 id='WPL1'>p-Wasserstein Linear Projections With an <code class="reqn">L_1</code> Penalty</h2><span id='topic+WPL1'></span>

<h3>Description</h3>

<p>p-Wasserstein Linear Projections With an <code class="reqn">L_1</code> Penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WPL1(
  X,
  Y = NULL,
  theta = NULL,
  power = 2,
  penalty = c("lasso", "ols", "mcp", "elastic.net", "selection.lasso", "scad", "mcp.net",
    "scad.net", "grp.lasso", "grp.lasso.net", "grp.mcp", "grp.scad", "grp.mcp.net",
    "grp.scad.net", "sparse.grp.lasso"),
  model.size = NULL,
  lambda = numeric(0),
  nlambda = 100L,
  lambda.min.ratio = 1e-04,
  gamma = 1,
  maxit = 500L,
  tol = 1e-07,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WPL1_+3A_x">X</code></td>
<td>
<p>matrix of covariates</p>
</td></tr>
<tr><td><code id="WPL1_+3A_y">Y</code></td>
<td>
<p>matrix of predictions</p>
</td></tr>
<tr><td><code id="WPL1_+3A_theta">theta</code></td>
<td>
<p>optional parameter matrix for selection methods.</p>
</td></tr>
<tr><td><code id="WPL1_+3A_power">power</code></td>
<td>
<p>power of the Wasserstein distance</p>
</td></tr>
<tr><td><code id="WPL1_+3A_penalty">penalty</code></td>
<td>
<p>Form of penalty. One of &quot;lasso&quot;, &quot;ols&quot;, &quot;mcp&quot;, &quot;elastic.net&quot;,&quot;selection.lasso&quot;, &quot;scad&quot;, &quot;mcp.net&quot;, &quot;scad.net&quot;, &quot;grp.lasso&quot;, &quot;grp.lasso.net&quot;, &quot;grp.mcp&quot;,&quot;grp.scad&quot;, &quot;grp.mcp.net&quot;, &quot;grp.scad.net&quot;, &quot;sparse.grp.lasso&quot;</p>
</td></tr>
<tr><td><code id="WPL1_+3A_model.size">model.size</code></td>
<td>
<p>How many coefficients should final model have</p>
</td></tr>
<tr><td><code id="WPL1_+3A_lambda">lambda</code></td>
<td>
<p>penalty parameter</p>
</td></tr>
<tr><td><code id="WPL1_+3A_nlambda">nlambda</code></td>
<td>
<p>number of lambdas to explore</p>
</td></tr>
<tr><td><code id="WPL1_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>minimum ratio of max to min lambda</p>
</td></tr>
<tr><td><code id="WPL1_+3A_gamma">gamma</code></td>
<td>
<p>Tuning parameter for SCAD and MCP methods</p>
</td></tr>
<tr><td><code id="WPL1_+3A_maxit">maxit</code></td>
<td>
<p>maximum iterations for optimization</p>
</td></tr>
<tr><td><code id="WPL1_+3A_tol">tol</code></td>
<td>
<p>tolerance for convergence</p>
</td></tr>
<tr><td><code id="WPL1_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods such as Wasserstein distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>WpProj</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+W1L1">W1L1()</a></code>, <code><a href="#topic+W2L1">W2L1()</a></code>, <a href="#topic+WInfL1">WInfL1</a>
</p>

<hr>
<h2 id='WpProj'>p-Wasserstein Linear Projections</h2><span id='topic+WpProj'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
This function will calculate linear projections from a set of predictions into the space of the covariates in terms of the p-Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WpProj(
  X,
  eta = NULL,
  theta = NULL,
  power = 2,
  method = c("L1", "binary program", "stepwise", "simulated annealing", "L0"),
  solver = c("lasso", "ecos", "lpsolve", "mosek"),
  options = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WpProj_+3A_x">X</code></td>
<td>
<p>An <code class="reqn">n \times p</code> matrix of covariates</p>
</td></tr>
<tr><td><code id="WpProj_+3A_eta">eta</code></td>
<td>
<p>An <code class="reqn">n \times s</code> matrix of predictions from a model</p>
</td></tr>
<tr><td><code id="WpProj_+3A_theta">theta</code></td>
<td>
<p>An optional An <code class="reqn">p \times s</code> parameter matrix for selection methods. Only makes sense if the original model is a linear model.</p>
</td></tr>
<tr><td><code id="WpProj_+3A_power">power</code></td>
<td>
<p>The power of the Wasserstein distance to use. Must be <code style="white-space: pre;">&#8288;&gt;= 1.0&#8288;</code>. Will default to <code>2.0</code>.</p>
</td></tr>
<tr><td><code id="WpProj_+3A_method">method</code></td>
<td>
<p>The algorithm to calculate the Wasserstein projections. One of &quot;L1&quot;, &quot;binary program&quot;, &quot;IP&quot;, &quot;stepwise&quot;,&quot;simulated annealing&quot;, or &quot;L0&quot;. Will default to &quot;L1&quot; if not provided. See details for more information.</p>
</td></tr>
<tr><td><code id="WpProj_+3A_solver">solver</code></td>
<td>
<p>Which solver to use? One of &quot;lasso&quot;, &quot;ecos&quot;, &quot;lpsolve&quot;, or &quot;mosek&quot;. See details for more information</p>
</td></tr>
<tr><td><code id="WpProj_+3A_options">options</code></td>
<td>
<p>Options passed to the particular method and desired solver. See details for more information.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Methods</h4>

<p>The <code>WpProj</code> function is a wrapper for the various Wasserstein projection methods. It is designed to be a one-stop shop for all Wasserstein projection methods. It will automatically choose the correct method and solver based on the arguments provided. It will also return a standardized output for all methods. Each method has its own set of options that can be passed to it. See the documentation for each method for more information.
</p>
<p>For the L1 methods, see <code><a href="#topic+L1_method_options">L1_method_options()</a></code> for more information. For the binary program methods, see <code><a href="#topic+binary_program_method_options">binary_program_method_options()</a></code> for more information. For the stepwise methods, see <code><a href="#topic+stepwise_method_options">stepwise_method_options()</a></code> for more information. For the simulated annealing methods, see <code><a href="#topic+simulated_annealing_method_options">simulated_annealing_method_options()</a></code> for more information.
</p>
<p>In most cases, we recommend using the L1 methods or binary program methods. The L1 methods are the fastest and applicable to Wasserstein powers of any value greater than 1 and function as direct linear projections into the space of the covariates. The binary program methods instead preserve the coefficients of the original model if this is of interest, such as when the original model was already a linear model. The binary program will instead function as a way of turning on and off certain coefficients in a way that minimizes the Wasserstein distance between reduced and original models. Of note, we also have available an approximate binary program method using a lasso solver. This method is faster than the exact binary program method but is not guaranteed to find the optimal solution. It is recommended to use the exact binary program method if possible. See <code><a href="#topic+binary_program_method_options">binary_program_method_options()</a></code> for more information on how to set up the approximate method as some arguments for the lasso solver should be specified. For more information on how this works, please also see the referenced paper.
</p>
<p>The stepwise, simulated annealing, and L0 methods also select covariates like the binary program methods but they can be slower. They are presented merely for comparison purposes given they were used in the original paper.
</p>



<h4>Wasserstein distances and powers</h4>

<p>The Wasserstein distance is a measure of distance between two probability distributions. It is defined as:
</p>
<p style="text-align: center;"><code class="reqn">W_p(\mu,\nu) = \left(\inf_{\pi \in \Pi(\mu,\nu)} \int_{\mathbb{R}^d \times \mathbb{R}^d} \|x-y\|^p d\pi(x,y)\right)^{1/p},</code>
</p>

<p>where <code class="reqn">\Pi(\mu,\nu)</code> is the set of all joint distributions with marginals <code class="reqn">\mu</code> and <code class="reqn">\nu</code>. The Wasserstein distance is a generalization of the Euclidean distance, which is the case when <code class="reqn">p=2</code>. In our function we have argument <code>power</code> that corresponds to the <code class="reqn">p</code> of the equation above. The default <code>power</code> is <code>2.0</code> but any value greater than or equal to <code>1.0</code> is allowed. For more information, see the references.
</p>
<p>The particular implementation of the Wasserstein distance is as follows. If  <code class="reqn">\mu</code> is the original prediction from the original model, then we seek to find a new prediction <code class="reqn">\nu</code> that minimizes the Wasserstein distance between the two: <code class="reqn">\text{argmin}_\nu W_p(\mu,\nu)</code>.
</p>



<h3>Value</h3>

<p>object of class <code>WpProj</code>, which is a list with the following slots:
</p>

<ul>
<li><p><code>call</code>: The call to the function
</p>
</li>
<li><p><code>theta</code>: A list of the final parameter matrices for each returned model
</p>
</li>
<li><p><code>fitted.values</code>: A list of the fitted values for each returned model
</p>
</li>
<li><p><code>power</code>: The power of the Wasserstein distance used
</p>
</li>
<li><p><code>method</code>: The method used to calculate the Wasserstein projections
</p>
</li>
<li><p><code>solver</code>: The solver used to calculate the Wasserstein projections
</p>
</li>
<li><p><code>niter</code>: The number of iterations used to calculate the Wasserstein projections. Not all methods return a number of iterations so this may be <code>NULL</code>
</p>
</li>
<li><p><code>nzero</code>: The number of non zero coefficients in the final models
</p>
</li></ul>



<h3>References</h3>

<p>Dunipace, Eric and Lorenzo Trippa (2020) <a href="https://arxiv.org/abs/2012.09999">https://arxiv.org/abs/2012.09999</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rlang::is_installed("stats")) {
# note we don't generate believable data with real posteriors
# these examples are just to show how to use the function
n &lt;- 32
p &lt;- 10
s &lt;- 21

# covariates and coefficients
x &lt;- matrix( stats::rnorm( p * n ), nrow = n, ncol = p )
beta &lt;- (1:10)/10

#outcome
y &lt;- x %*% beta + stats::rnorm(n)

# fake posterior
post_beta &lt;- matrix(beta, nrow=p, ncol=s) + stats::rnorm(p*s, 0, 0.1)
post_mu &lt;- x %*% post_beta #posterior predictive distributions

# fit models
## L1 model
fit.p2     &lt;-  WpProj(X=x, eta=post_mu, power = 2.0,
                   method = "L1", #default
                   solver = "lasso" #default
)

## approximate binary program
fit.p2.bp &lt;-  WpProj(X=x, eta=post_mu, theta = post_beta, power = 2.0,
                   method = "binary program",
                   solver = "lasso" #default because approximate algorithm is faster
)

## compare performance by measuring distance from full model
dc &lt;- distCompare(models = list("L1" = fit.p2, "BP" = fit.p2.bp))
plot(dc)

## compare performance by measuring the relative distance between a null model 
## and the predictions of interest as a pseudo R^2
r2.expect &lt;- WPR2(predictions = post_mu, projected_model = dc) # can have negative values
r2.null  &lt;- WPR2(projected_model = dc) # should be between 0 and 1
plot(r2.null)

## we can also examine how predictions change in the models for individual observations
ridgePlot(fit.p2, index = 21, minCoef = 0, maxCoef = 10)
}
</code></pre>

<hr>
<h2 id='WPR2'><code class="reqn">W_p R^2</code> Function to Evaluate Performance</h2><span id='topic+WPR2'></span><span id='topic+WPR2+2CANY+2Cmatrix-method'></span><span id='topic+WPR2+2CANY+2Cdistcompare-method'></span><span id='topic+WPR2+2CANY+2Clist-method'></span><span id='topic+WPR2+2CANY+2CWpProj-method'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
This function will calculate p-Wasserstein distances between the predictions of interest and the projected model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WPR2(
  predictions = NULL,
  projected_model,
  p = 2,
  method = "exact",
  base = NULL,
  ...
)

## S4 method for signature 'ANY,matrix'
WPR2(
  predictions = NULL,
  projected_model,
  p = 2,
  method = "exact",
  base = NULL,
  ...
)

## S4 method for signature 'ANY,distcompare'
WPR2(
  predictions = NULL,
  projected_model,
  p = 2,
  method = "exact",
  base = NULL,
  ...
)

## S4 method for signature 'ANY,list'
WPR2(
  predictions = NULL,
  projected_model,
  p = 2,
  method = "exact",
  base = NULL,
  ...
)

## S4 method for signature 'ANY,WpProj'
WPR2(
  predictions = NULL,
  projected_model,
  p = 2,
  method = "exact",
  base = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WPR2_+3A_predictions">predictions</code></td>
<td>
<p>Predictions of interest, likely from the original model</p>
</td></tr>
<tr><td><code id="WPR2_+3A_projected_model">projected_model</code></td>
<td>
<p>A matrix of competing predictions, possibly from a WpProj fit, a WpProj fit itself, or a list of WpProj objects</p>
</td></tr>
<tr><td><code id="WPR2_+3A_p">p</code></td>
<td>
<p>Power of the Wasserstein distance to use in distance calculations</p>
</td></tr>
<tr><td><code id="WPR2_+3A_method">method</code></td>
<td>
<p>Method for calculating Wasserstein distance</p>
</td></tr>
<tr><td><code id="WPR2_+3A_base">base</code></td>
<td>
<p>The baseline result to compare to. If not provided, defaults to the model with no covariates and only an intercept.</p>
</td></tr>
<tr><td><code id="WPR2_+3A_...">...</code></td>
<td>
<p>Arguments passed to Wasserstein distance calculation. See <code><a href="#topic+wasserstein">wasserstein</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">W_p R ^2</code> values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (rlang::is_installed("stats")) {
# this example is not a true posterior estimation, but is used for illustration
n &lt;- 32
p &lt;- 10
s &lt;- 21
x &lt;- matrix( stats::rnorm(n*p), nrow = n, ncol = p )
beta &lt;- (1:10)/10
y &lt;- x %*% beta + stats::rnorm(n)
post_beta &lt;- matrix(beta, nrow=p, ncol=s) + 
    matrix(rnorm(p*s), p, s) # not a true posterior
post_mu &lt;- x %*% post_beta

fit &lt;-  WpProj(X=x, eta=post_mu, power = 2.0)

out &lt;- WPR2(predictions = post_mu, projected_model = fit, 
base = rowMeans(post_mu) # same as intercept only projection
)
}
</code></pre>

<hr>
<h2 id='WPSA'>p-Wasserstein distance projections using simulated annealing</h2><span id='topic+WPSA'></span>

<h3>Description</h3>

<p>p-Wasserstein distance projections using simulated annealing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WPSA(
  X,
  Y = NULL,
  theta,
  power = 2,
  force = NULL,
  model.size = 3,
  nvars = NULL,
  maxit = 1,
  temps = 1000,
  max.time = 3600,
  const = NULL,
  proposal = proposal.fun,
  options = list(method = c("selection.variable", "scale", "projection"),
    transport.method = transport_options(), energy.distribution = "boltzman",
    cooling.schedule = "Geman-Geman", proposal.method = "covariance", epsilon = 0.05,
    OTmaxit = 100),
  display.progress = FALSE,
  parallel = NULL,
  calc.theta = TRUE,
  xtx = NULL,
  xty = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WPSA_+3A_x">X</code></td>
<td>
<p>Covariate vector</p>
</td></tr>
<tr><td><code id="WPSA_+3A_y">Y</code></td>
<td>
<p>Predictions</p>
</td></tr>
<tr><td><code id="WPSA_+3A_theta">theta</code></td>
<td>
<p>Optional matrix of parameters for generating predictions</p>
</td></tr>
<tr><td><code id="WPSA_+3A_power">power</code></td>
<td>
<p>Power of the Wasserstein distance</p>
</td></tr>
<tr><td><code id="WPSA_+3A_force">force</code></td>
<td>
<p>Any covariates to force into the model?</p>
</td></tr>
<tr><td><code id="WPSA_+3A_model.size">model.size</code></td>
<td>
<p>Maximum number of coefficients</p>
</td></tr>
<tr><td><code id="WPSA_+3A_nvars">nvars</code></td>
<td>
<p>The number of variables to explore. Should be an integer vector of model sizes. Default is NULL which will explore all models from 1 to <code>model.size</code>.</p>
</td></tr>
<tr><td><code id="WPSA_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="WPSA_+3A_temps">temps</code></td>
<td>
<p>Number of temperatures</p>
</td></tr>
<tr><td><code id="WPSA_+3A_max.time">max.time</code></td>
<td>
<p>Maximum time in seconds to run</p>
</td></tr>
<tr><td><code id="WPSA_+3A_const">const</code></td>
<td>
<p>Maximum value for simulated annealing distance</p>
</td></tr>
<tr><td><code id="WPSA_+3A_proposal">proposal</code></td>
<td>
<p>Proposal function. There is a default method but can provide your own with parameters <code>xty</code>, <code>cur</code>, <code>idx</code>, <code>force</code>, <code>d</code>, <code>method</code></p>
</td></tr>
<tr><td><code id="WPSA_+3A_options">options</code></td>
<td>
<p>Options for simulated annealing</p>
</td></tr>
<tr><td><code id="WPSA_+3A_display.progress">display.progress</code></td>
<td>
<p>Whether to display solver progress. TRUE or FALSE. Default is FALSE.</p>
</td></tr>
<tr><td><code id="WPSA_+3A_parallel">parallel</code></td>
<td>
<p>A <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code> backend</p>
</td></tr>
<tr><td><code id="WPSA_+3A_calc.theta">calc.theta</code></td>
<td>
<p>Should the model save the linear coefficients? TRUE or FALSE. Default is TRUE</p>
</td></tr>
<tr><td><code id="WPSA_+3A_xtx">xtx</code></td>
<td>
<p>precomputed crossproduct <code>crossprod(X,X)</code></p>
</td></tr>
<tr><td><code id="WPSA_+3A_xty">xty</code></td>
<td>
<p>precomputed <code>crossprod(X, Y)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>WpProj</code>
</p>

<hr>
<h2 id='WPSW'>p-Wasserstein Distance Linear Projections Using a Stepwise Method</h2><span id='topic+WPSW'></span>

<h3>Description</h3>

<p>p-Wasserstein Distance Linear Projections Using a Stepwise Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WPSW(
  X,
  Y,
  theta,
  power = 2,
  force = NULL,
  direction = c("backward", "forward"),
  method = c("selection.variable", "scale", "projection"),
  transport.method = transport_options(),
  OTmaxit = 100,
  epsilon = 0.05,
  calc.theta = TRUE,
  model.size = NULL,
  parallel = NULL,
  display.progress = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WPSW_+3A_x">X</code></td>
<td>
<p>matrix of covariates</p>
</td></tr>
<tr><td><code id="WPSW_+3A_y">Y</code></td>
<td>
<p>matrix of predictions</p>
</td></tr>
<tr><td><code id="WPSW_+3A_theta">theta</code></td>
<td>
<p>optional parameter matrix for selection methods.</p>
</td></tr>
<tr><td><code id="WPSW_+3A_power">power</code></td>
<td>
<p>Power of the Wasserstein distance</p>
</td></tr>
<tr><td><code id="WPSW_+3A_force">force</code></td>
<td>
<p>Any covariates to force into the model?</p>
</td></tr>
<tr><td><code id="WPSW_+3A_direction">direction</code></td>
<td>
<p>forward or backward selection</p>
</td></tr>
<tr><td><code id="WPSW_+3A_method">method</code></td>
<td>
<p>&quot;selection.variable&quot; or &quot;projection</p>
</td></tr>
<tr><td><code id="WPSW_+3A_transport.method">transport.method</code></td>
<td>
<p>Method for calculating the Wasserstein distance. Should be one of the outputs of <code><a href="#topic+transport_options">transport_options()</a></code>.</p>
</td></tr>
<tr><td><code id="WPSW_+3A_otmaxit">OTmaxit</code></td>
<td>
<p>maximum number of iterations for the opt?imal transport methods</p>
</td></tr>
<tr><td><code id="WPSW_+3A_epsilon">epsilon</code></td>
<td>
<p>hyperparameter if using sinkhorn iterations to approximate OT</p>
</td></tr>
<tr><td><code id="WPSW_+3A_calc.theta">calc.theta</code></td>
<td>
<p>should we get the linear coefficients</p>
</td></tr>
<tr><td><code id="WPSW_+3A_model.size">model.size</code></td>
<td>
<p>Maximum model size</p>
</td></tr>
<tr><td><code id="WPSW_+3A_parallel">parallel</code></td>
<td>
<p>foreach backend</p>
</td></tr>
<tr><td><code id="WPSW_+3A_display.progress">display.progress</code></td>
<td>
<p>Display intermediate progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>WpProj</code>
</p>

<hr>
<h2 id='WPVI'>p-Wasserstein Variable Importance</h2><span id='topic+WPVI'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
This function will measure how much removing each covariate harms prediction accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WPVI(
  X,
  eta,
  theta,
  pred.fun = NULL,
  p = 2,
  ground_p = 2,
  transport.method = transport_options(),
  epsilon = 0.05,
  OTmaxit = 100,
  display.progress = FALSE,
  parallel = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WPVI_+3A_x">X</code></td>
<td>
<p>Covariates</p>
</td></tr>
<tr><td><code id="WPVI_+3A_eta">eta</code></td>
<td>
<p>Predictions from the estimated model</p>
</td></tr>
<tr><td><code id="WPVI_+3A_theta">theta</code></td>
<td>
<p>Parameters from the estimated model.</p>
</td></tr>
<tr><td><code id="WPVI_+3A_pred.fun">pred.fun</code></td>
<td>
<p>A prediction function. must take variables x, theta as arguments: <code>pred.fun(x,theta)</code></p>
</td></tr>
<tr><td><code id="WPVI_+3A_p">p</code></td>
<td>
<p>Power of Wasserstein distance</p>
</td></tr>
<tr><td><code id="WPVI_+3A_ground_p">ground_p</code></td>
<td>
<p>Power of distance metric</p>
</td></tr>
<tr><td><code id="WPVI_+3A_transport.method">transport.method</code></td>
<td>
<p>Transport methods. See <code><a href="#topic+transport_options">transport_options()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="WPVI_+3A_epsilon">epsilon</code></td>
<td>
<p>Hyperparameter for Sinkhorn iterations</p>
</td></tr>
<tr><td><code id="WPVI_+3A_otmaxit">OTmaxit</code></td>
<td>
<p>Maximum number of iterations for the Wasserstein method</p>
</td></tr>
<tr><td><code id="WPVI_+3A_display.progress">display.progress</code></td>
<td>
<p>Display intermediate progress</p>
</td></tr>
<tr><td><code id="WPVI_+3A_parallel">parallel</code></td>
<td>
<p>a foreach backend if already created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an integer vector ranking covariate importance from most to least important.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 128
p &lt;- 10
s &lt;- 99
x &lt;- matrix(1, nrow = n, ncol = p )
beta &lt;- (1:10)/10
y &lt;- x %*% beta 
post_beta &lt;- matrix(beta, nrow=p, ncol=s) 
post_mu &lt;- x %*% post_beta

fit &lt;-  WpProj(X=x, eta=post_mu, power = 2.0)
WPVI(X = x, eta = post_mu, theta = post_beta, transport.method = "hilbert")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
