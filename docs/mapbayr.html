<!DOCTYPE html><html><head><title>Help for package mapbayr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mapbayr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_covariates'><p>Add covariate columns to a dataset</p></a></li>
<li><a href='#adm_rows'><p>Add administration lines to a dataset</p></a></li>
<li><a href='#as.data.frame.mapbayests'><p>Return the mapbay_tab as a data.frame</p></a></li>
<li><a href='#augment'><p>Compute full PK profile prediction from mapbayr estimates.</p></a></li>
<li><a href='#augment.mapbayests'><p>Compute full PK profile prediction from mapbayr estimates.</p></a></li>
<li><a href='#check_mapbayr_model'><p>Check if model is valid for 'mapbayr'</p></a></li>
<li><a href='#compute_ofv'><p>Compute the objective function value</p></a></li>
<li><a href='#data_helpers'><p>Data helpers: functions to build the dataset</p></a></li>
<li><a href='#deprecations'><p>Deprecated functions</p></a></li>
<li><a href='#do_mapbayr_sim'><p>Simulate with mapbayr</p></a></li>
<li><a href='#est001'><p>Estimation object</p></a></li>
<li><a href='#eta'><p>Generate a vector of &quot;ETA&quot;</p></a></li>
<li><a href='#exmodel_exdata'><p>Example model and data</p></a></li>
<li><a href='#filter.mrgmod'><p>Filter a dataset within a mrgmod</p></a></li>
<li><a href='#get_x'><p>Get content from object</p></a></li>
<li><a href='#hist.mapbayests'><p>Plot posterior distribution of bayesian estimates</p></a></li>
<li><a href='#mapbayest'><p>Estimate parameters (maximum a posteriori)</p></a></li>
<li><a href='#mapbayr_plot'><p>Make mapbayr plot</p></a></li>
<li><a href='#mapbayr_vpc'><p>Visual Predicted Checks</p></a></li>
<li><a href='#model_averaging'><p>Average predictions from multiple models</p></a></li>
<li><a href='#obs_rows'><p>Add observation lines to a dataset</p></a></li>
<li><a href='#parse_datehour'><p>Parse value to &quot;POSIXct&quot;</p></a></li>
<li><a href='#plot.mapbayests'><p>Plot predictions from mapbayests object</p></a></li>
<li><a href='#preprocess.ofv'><p>Preprocess model and data for ofv computation</p></a></li>
<li><a href='#preprocess.optim'><p>Pre-process: arguments for optimization function</p></a></li>
<li><a href='#print.mapbayests'><p>Print a mapbayests object</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#use_posterior'><p>Use posterior estimation</p></a></li>
<li><a href='#vs_nonmem'><p>Compare results to NONMEM .phi</p></a></li>
<li><a href='#x_cmt'><p>Read compartment options in a model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>MAP-Bayesian Estimation of PK Parameters</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs maximum a posteriori Bayesian estimation of individual pharmacokinetic parameters from a model defined in 'mrgsolve', typically for model-based therapeutic drug monitoring. Internally computes an objective function value from model and data, performs optimization and returns predictions in a convenient format. The performance of the package was described by Le Louedec et al (2021) &lt;<a href="https://doi.org/10.1002%2Fpsp4.12689">doi:10.1002/psp4.12689</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2 (&ge; 3.4.0), magrittr, mrgsolve (&ge; 1.0.8),
progress, purrr, rlang, stringr, tidyr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/FelicienLL/mapbayr">https://github.com/FelicienLL/mapbayr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/FelicienLL/mapbayr/issues">https://github.com/FelicienLL/mapbayr/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, lubridate, minqa, scales, testthat (&ge; 3.0.0), tibble</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-17 07:54:03 UTC; le_louedec</td>
</tr>
<tr>
<td>Author:</td>
<td>Felicien Le Louedec
    <a href="https://orcid.org/0000-0003-3699-2729"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Kyle T Baron <a href="https://orcid.org/0000-0001-7252-5656"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Laura Morvan [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Felicien Le Louedec &lt;felicienlelouedec@proton.me&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-17 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_covariates'>Add covariate columns to a dataset</h2><span id='topic+add_covariates'></span><span id='topic+add_covariates.data.frame'></span><span id='topic+add_covariates.mrgmod'></span>

<h3>Description</h3>

<p>The <code>add_covariates()</code> function adds an one or several covariate columns to a dataset provided as a proper data.frame or within a 'mrgsolve' model. Used in combination with <code><a href="#topic+adm_rows">adm_rows()</a></code> and <code><a href="#topic+obs_rows">obs_rows()</a></code>, it helps the creation of datasets in the proper format for simulations with 'mrgsolve' or parameter estimation with 'mapbayr', as explained in <a href="#topic+data_helpers">data_helpers</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_covariates(x, ...)

## S3 method for class 'data.frame'
add_covariates(x, ..., covariates = list(), AOLA = FALSE, TOLA = FALSE)

## S3 method for class 'mrgmod'
add_covariates(x, ..., covariates = list(), AOLA = NULL, TOLA = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_covariates_+3A_x">x</code></td>
<td>
<p>either a data.frame or a 'mrgsolve' model object</p>
</td></tr>
<tr><td><code id="add_covariates_+3A_...">...</code></td>
<td>
<p>covariates values to add to the data. For each variable, supply a vector of length 1 or with the same number of rows. Ignored if <code>covariates</code> argument is used.</p>
</td></tr>
<tr><td><code id="add_covariates_+3A_covariates">covariates</code></td>
<td>
<p>Covariates passed as a single list of variables. Overrides <code>...</code>.</p>
</td></tr>
<tr><td><code id="add_covariates_+3A_aola">AOLA</code>, <code id="add_covariates_+3A_tola">TOLA</code></td>
<td>
<p>a logical. Should the &quot;Amount Of Last Administration&quot; and &quot;Time Of Last Administration&quot; variables be added into the dataset? Default if FALSE if <code>x</code> is a dataset, TRUE if <code>x</code> is a 'mrgsolve' model where <code>AOLA</code> and <code>TOLA</code> are defined as covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame, or a 'mrgsolve' model with a dataset in the <code style="white-space: pre;">&#8288;@args$data&#8288;</code> slot (accessible with <code><a href="#topic+get_data">get_data()</a></code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+data_helpers">data_helpers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cannot start from scratch
## Not run: 
add_covariates(BW = 90, SEX = 0)

## End(Not run)

library(magrittr)
adm_rows(time = c(0, 24, 48), cmt = 1, amt = c(100, 200, 300)) %&gt;%
  add_covariates(BW = c(90, 85, 80), SEX = 0)

# If covariates are stored in a list, use `covariates = `
adm_rows(time = c(0, 24, 48), cmt = 1, amt = c(100, 200, 300)) %&gt;%
  add_covariates(covariates = list(BW = c(90, 85, 80), SEX = 0))

# Missing values are filled with the "next observation carried backward" rule
adm_rows(time = c(0, 24, 48), cmt = 1, amt = c(100, 200, 300)) %&gt;%
  add_covariates(BW = c(90, 85, 80), SEX = 0) %&gt;%
  obs_rows(time = 36, DV = .0123, cmt = 2)
# Always verify the output in case of time-varying covariates

# Possibility to add Time and Amount of last administration as covariates
adm_rows(time = c(0, 24, 48), amt = c(100, 200, 300), cmt = 1) %&gt;%
  obs_rows(time = c(8, 16, 32, 40), cmt = 2, DV = runif(4)) %&gt;%
  add_covariates(TOLA = TRUE, AOLA = TRUE) %&gt;%
  obs_rows(time = 72, cmt = 2, DV = .123) # AOLA/TOLA re-updated afterwards

# Automatic inclusion of `TOLA`/`AOLA` if they are covariates of the model
library(mrgsolve)
model &lt;- mcode("model", "
$PARAM @annotated @covariates
TOLA : 0 : Time Last Adm
AOLA : 0 : Amount Last Adm
", compile = FALSE)

model %&gt;%
  adm_rows(time = c(0, 24, 48), amt = c(100, 200, 300), cmt = 1) %&gt;%
  add_covariates() %&gt;%
  get_data()
</code></pre>

<hr>
<h2 id='adm_rows'>Add administration lines to a dataset</h2><span id='topic+adm_rows'></span><span id='topic+adm_rows.data.frame'></span><span id='topic+adm_rows.missing'></span><span id='topic+adm_rows.mrgmod'></span>

<h3>Description</h3>

<p>The <code>adm_rows()</code> function adds an one or several administration lines to a dataset provided as a proper data.frame or within a 'mrgsolve' model. Used in combination with <code><a href="#topic+obs_rows">obs_rows()</a></code> and <code><a href="#topic+add_covariates">add_covariates()</a></code>, it helps the creation of datasets in the proper format for simulations with 'mrgsolve' or parameter estimation with 'mapbayr', as explained in <a href="#topic+data_helpers">data_helpers</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adm_rows(x, ...)

## S3 method for class 'data.frame'
adm_rows(
  x,
  ID = NULL,
  time = NULL,
  evid = 1L,
  cmt,
  amt,
  mdv = 1L,
  addl = NULL,
  ss = NULL,
  ii = NULL,
  rate = NULL,
  .datehour = NULL,
  ...
)

## S3 method for class 'missing'
adm_rows(...)

## S3 method for class 'mrgmod'
adm_rows(x, cmt = adm_cmt(x), rate = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adm_rows_+3A_x">x</code></td>
<td>
<p>either a data.frame or a 'mrgsolve' model object</p>
</td></tr>
<tr><td><code id="adm_rows_+3A_...">...</code></td>
<td>
<p>additional columns or arguments for <code><a href="mrgsolve.html#topic+ev">mrgsolve::ev()</a></code></p>
</td></tr>
<tr><td><code id="adm_rows_+3A_id">ID</code></td>
<td>
<p>subject ID (default is 1)</p>
</td></tr>
<tr><td><code id="adm_rows_+3A_time">time</code></td>
<td>
<p>event time. Default is 0 if no previous events. Mind consistency with <code>.datehour</code>.</p>
</td></tr>
<tr><td><code id="adm_rows_+3A_evid">evid</code></td>
<td>
<p>event identification (default is 1 for administration, 0 for observation)</p>
</td></tr>
<tr><td><code id="adm_rows_+3A_cmt">cmt</code></td>
<td>
<p>compartment (no default, except if <code style="white-space: pre;">&#8288;[ADM]&#8288;</code> was tagged in the <code style="white-space: pre;">&#8288;$CMT&#8288;</code> block in model code. See <code>examples</code>.)</p>
</td></tr>
<tr><td><code id="adm_rows_+3A_amt">amt</code></td>
<td>
<p>dose amount (for administration records only)</p>
</td></tr>
<tr><td><code id="adm_rows_+3A_mdv">mdv</code></td>
<td>
<p>missing dependent value (default is 1 for administration records)</p>
</td></tr>
<tr><td><code id="adm_rows_+3A_addl">addl</code></td>
<td>
<p>additional dose (optional)</p>
</td></tr>
<tr><td><code id="adm_rows_+3A_ss">ss</code></td>
<td>
<p>steady-state (optional, is this dose the last of an infinity of administration? Yes, 1, or no, 0)</p>
</td></tr>
<tr><td><code id="adm_rows_+3A_ii">ii</code></td>
<td>
<p>inter-dose interval (optional, use it with <code>ss</code> and <code>addl</code>)</p>
</td></tr>
<tr><td><code id="adm_rows_+3A_rate">rate</code></td>
<td>
<p>rate of administration (optional, set to -2 if you model zero-order infusion. See <code>examples</code>.)</p>
</td></tr>
<tr><td><code id="adm_rows_+3A_.datehour">.datehour</code></td>
<td>
<p>a object of class POSIXct, a number or a character vector that can be passed to <code><a href="#topic+parse_datehour">parse_datehour()</a></code>. Using <code>.datehour</code> will update the value of <code>time</code> in the dataset, with units in hours. Mind consistency with the <code>time</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame, or a 'mrgsolve' model with a dataset in the <code style="white-space: pre;">&#8288;@args$data&#8288;</code> slot (accessible with <code><a href="#topic+get_data">get_data()</a></code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+data_helpers">data_helpers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a dataset from scratch
adm_rows(amt = 100, cmt = 1)

# Pipe-friendly addition of administration record to a pre-existing dataset
library(magrittr)
adm_rows(amt = 100, cmt = 1) %&gt;%
  adm_rows(time = 3, amt = 200, cmt = 1, addl = 3, ii = 1)

# Inform times using the `.datehour` argument:
adm_rows(.datehour = "2020-01-01 11:11", amt = 100, cmt = 1) %&gt;%
  adm_rows(.datehour = "2020-01-02 22:22", amt = 200, cmt = 1) %&gt;%
  adm_rows(time = 48, amt = 300, cmt = 1)

# Start from a 'mrgsolve' model
library(mrgsolve)
house() %&gt;%
  adm_rows(amt = 100, cmt = 1) %&gt;%
  adm_rows(time = 3, amt = 200, cmt = 1, addl = 3, ii = 1) %&gt;%
  mrgsim(delta = 1)

# Default administration compartments
# Set default administration compartments in the code with `[ADM]`
model &lt;- mcode("model", "
$CMT @annotated
DEPOT : Depot [ADM]
CENTR : Central
", compile = FALSE)
adm_cmt(model)

# Thus, no need to manually specify `cmt = 1` anymore.
model %&gt;%
  adm_rows(amt = 100) %&gt;%
  adm_rows(time = 3, amt = 200, addl = 3, ii = 1) %&gt;%
  get_data()

# Automatic lines duplication if multiple depot compartments
# Automatic `rate = -2` increment if model with 0-order absorption
model &lt;- mcode("model", "
$PARAM DUR = 1.0
$CMT @annotated
DEPOT : Depot [ADM]
CENTR : Central [ADM]
$MAIN
D_CENTR = DUR ;
", compile = FALSE)
adm_cmt(model)

model %&gt;%
  adm_rows(amt = 100) %&gt;%
  adm_rows(time = 3, amt = 200, addl = 3, ii = 1) %&gt;%
  get_data()
</code></pre>

<hr>
<h2 id='as.data.frame.mapbayests'>Return the mapbay_tab as a data.frame</h2><span id='topic+as.data.frame.mapbayests'></span>

<h3>Description</h3>

<p>Return the mapbay_tab as a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mapbayests'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.mapbayests_+3A_x">x</code></td>
<td>
<p>A <code>mapbayests</code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.mapbayests_+3A_row.names">row.names</code>, <code id="as.data.frame.mapbayests_+3A_optional">optional</code>, <code id="as.data.frame.mapbayests_+3A_...">...</code></td>
<td>
<p>passed to as.data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame (the mapbay_tab from estimation)
</p>

<hr>
<h2 id='augment'>Compute full PK profile prediction from mapbayr estimates.</h2><span id='topic+augment'></span>

<h3>Description</h3>

<p>Compute full PK profile prediction from mapbayr estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augment(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment_+3A_x">x</code></td>
<td>
<p>object to augment</p>
</td></tr>
<tr><td><code id="augment_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an augmented object (depending on the object passed).
</p>

<hr>
<h2 id='augment.mapbayests'>Compute full PK profile prediction from mapbayr estimates.</h2><span id='topic+augment.mapbayests'></span>

<h3>Description</h3>

<p>Compute full PK profile prediction from mapbayr estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mapbayests'
augment(
  x,
  data = NULL,
  start = NULL,
  end = NULL,
  delta = NULL,
  ci = FALSE,
  ci_width = 90,
  ci_method = "delta",
  ci_sims = 500,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.mapbayests_+3A_x">x</code></td>
<td>
<p>A <code>mapbayests</code> object.</p>
</td></tr>
<tr><td><code id="augment.mapbayests_+3A_data">data</code></td>
<td>
<p>dataset to pass to mrgsolve for simulation (default is dataset used for estimation)</p>
</td></tr>
<tr><td><code id="augment.mapbayests_+3A_start">start</code>, <code id="augment.mapbayests_+3A_end">end</code>, <code id="augment.mapbayests_+3A_delta">delta</code></td>
<td>
<p>start, end and delta of simulation time passed to <code>mrgsim()</code> (see details)</p>
</td></tr>
<tr><td><code id="augment.mapbayests_+3A_ci">ci</code></td>
<td>
<p>a logical. If TRUE, compute a confidence interval around the prediction (default is FALSE)</p>
</td></tr>
<tr><td><code id="augment.mapbayests_+3A_ci_width">ci_width</code></td>
<td>
<p>a number between 0 and 100, width of the confidence interval (default is &quot;90&quot; for a 90%CI)</p>
</td></tr>
<tr><td><code id="augment.mapbayests_+3A_ci_method">ci_method</code></td>
<td>
<p>method to compute the confidence interval. Can be &quot;delta&quot; (the default) to use the Delta approximation. Alternatively &quot;simulations&quot; for a more accurate approach, but also more time-consuming.</p>
</td></tr>
<tr><td><code id="augment.mapbayests_+3A_ci_sims">ci_sims</code></td>
<td>
<p>number of replicates to simulate in order to derive the confidence interval (default is 500)</p>
</td></tr>
<tr><td><code id="augment.mapbayests_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>mrgsim()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called in the background by <code>plot()</code> in order to simulate the full PK profile, and return a <code>mapbayests</code> object with an additional <code>aug_tab</code> data.frame inside. The latter is used with by the plot method.
The time grid, for each PK profile (i.e. patient) is defaulted with the minimum time in the dataset for <code>start</code> and the maximum time in the dataset +20% for <code>end</code>. <code>delta</code> is a power of 10 (e.g. 0.1, 1, 10 etc...), automatically chosen to render visually appealing graphs with a reasonable computing time (about 200 time points).
Additional arguments can be passed to <code>mrgsim()</code> through <code>...</code>. Note that <code>recsort</code> is set to 3 (see mrgsolve documentation for more details).
</p>


<h3>Value</h3>

<p>a <code>mapbayests</code> object, augmented of an <code>aug_tab</code> data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#x is the result of `mapbayest()`.
#Default plot is returned by:
# plot(x)
#Argument passed to `plot()` are passed to `augment()` in the background:
# plot(x, end = 240, ci = TRUE)
#Save the augmented object if simulation time is long
# x2 &lt;- augment(x, ci = TRUE, ci_method = "simulations", ci_sims = 10000) %&gt;%
# plot(x2)

</code></pre>

<hr>
<h2 id='check_mapbayr_model'>Check if model is valid for 'mapbayr'</h2><span id='topic+check_mapbayr_model'></span>

<h3>Description</h3>

<p>Checks that the model respects points related exclusively to 'mapbayr'. Useful at the time you wish to convert a &quot;regular&quot; 'mrgsolve' model you used for simulation into a model to perform MAP-Bayesian estimation.
Note that some elements cannot be checked:
</p>

<ul>
<li><p> In <code style="white-space: pre;">&#8288;$MAIN&#8288;</code> block, make sure that you added <code style="white-space: pre;">&#8288;ETA1, ETA2...&#8288;</code> in the code. For instance: <code style="white-space: pre;">&#8288;double CL = TVCL * exp(ETA(1) + ETA1) ;&#8288;</code>.
</p>
</li>
<li><p> In <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code> block, make sure the order of the (diagonal) values is the same as for ETAs in <code style="white-space: pre;">&#8288;$PARAM&#8288;</code>. For instance, if <code>ETA1</code> corresponds to clearance, the first value in <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code> must be the variance of clearance.
</p>
</li>
<li><p> In <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code> block, make sure the order is respected: proportional error first, and additive error secondly.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>check_mapbayr_model(x, check_compile = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_mapbayr_model_+3A_x">x</code></td>
<td>
<p>model file</p>
</td></tr>
<tr><td><code id="check_mapbayr_model_+3A_check_compile">check_compile</code></td>
<td>
<p>check if model is compiled</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> (invisibly) if checks are passed, errors otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mapbayr)
library(mrgsolve)
## Not run: check_mapbayr_model(house())
</code></pre>

<hr>
<h2 id='compute_ofv'>Compute the objective function value</h2><span id='topic+compute_ofv'></span><span id='topic+do_compute_ofv'></span>

<h3>Description</h3>

<p>Compute the objective function value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_ofv(
  eta,
  qmod,
  sigma,
  omega_inv,
  all_cmt,
  log_transformation,
  lambda = 1,
  idvaliddata,
  idDV,
  idcmt,
  idblq = NULL,
  idlloq = NULL,
  ...
)

do_compute_ofv(eta, argofv, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_ofv_+3A_eta">eta</code></td>
<td>
<p>a named vector/list of parameters</p>
</td></tr>
<tr><td><code id="compute_ofv_+3A_qmod">qmod</code>, <code id="compute_ofv_+3A_sigma">sigma</code>, <code id="compute_ofv_+3A_log_transformation">log_transformation</code>, <code id="compute_ofv_+3A_omega_inv">omega_inv</code>, <code id="compute_ofv_+3A_all_cmt">all_cmt</code>, <code id="compute_ofv_+3A_lambda">lambda</code></td>
<td>
<p>generated by <code><a href="#topic+preprocess.ofv.fix">preprocess.ofv.fix</a></code></p>
</td></tr>
<tr><td><code id="compute_ofv_+3A_idvaliddata">idvaliddata</code>, <code id="compute_ofv_+3A_iddv">idDV</code>, <code id="compute_ofv_+3A_idcmt">idcmt</code></td>
<td>
<p>generated by <code><a href="#topic+preprocess.ofv.id">preprocess.ofv.id</a></code></p>
</td></tr>
<tr><td><code id="compute_ofv_+3A_idblq">idblq</code>, <code id="compute_ofv_+3A_idlloq">idlloq</code></td>
<td>
<p>optionally generated by <code><a href="#topic+preprocess.ofv.id">preprocess.ofv.id</a></code></p>
</td></tr>
<tr><td><code id="compute_ofv_+3A_...">...</code></td>
<td>
<p>for compatibility (not used)</p>
</td></tr>
<tr><td><code id="compute_ofv_+3A_argofv">argofv</code></td>
<td>
<p>above mentioned arguments as a list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called iteratively by the optimization function. Arguments should not be passed directly, but generated by the pre-processing functions (see <code><a href="#topic+preprocess.ofv">preprocess.ofv</a></code>).
</p>


<h3>Value</h3>

<p>a single numeric value (the objective function value)
</p>

<hr>
<h2 id='data_helpers'>Data helpers: functions to build the dataset</h2><span id='topic+data_helpers'></span>

<h3>Description</h3>

<p>Use <code><a href="#topic+adm_rows">adm_rows()</a></code>, <code><a href="#topic+obs_rows">obs_rows()</a></code> and <code><a href="#topic+add_covariates">add_covariates()</a></code> to create or modify a dataset from scratch, from a pre-existing dataset, or from a dataset stored into a 'mrgsolve' model.
</p>


<h3>Details</h3>

<p>Instead of importing a '.csv' file, or painfully build a data set with a call to <code>data.frame()</code> and mind how to format the data, you can pass information about:
</p>

<ul>
<li><p> administrations with <code><a href="#topic+adm_rows">adm_rows()</a></code>,
</p>
</li>
<li><p> observations with <code><a href="#topic+obs_rows">obs_rows()</a></code>,
</p>
</li>
<li><p> covariates with <code><a href="#topic+add_covariates">add_covariates()</a></code>,
</p>
</li></ul>

<p>all being called jointly with a pipe (<code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> or <code style="white-space: pre;">&#8288;|&gt;&#8288;</code>).
These functions can be used to create or modify a dataset as a proper data.frame, or to create or modify a dataset within a 'mrgsolve' model (<code style="white-space: pre;">&#8288;@args$data&#8288;</code> slot).
The latter is particularly useful in order to:
</p>

<ul>
<li><p> automatically use default administration and observation compartments,
</p>
</li>
<li><p> automatically duplicate rows if there are several depot compartments,
</p>
</li>
<li><p> automatically set <code>rate = -2</code> if model has zero-order absorption pathways,
</p>
</li>
<li><p> automatically duplicate rows if concentrations of Parent drug and Metabolite are observed together,
</p>
</li>
<li><p> automatically add &quot;Amount Of Last Administration&quot; and &quot;Time Of Last Administration&quot; variables if these are covariates,
</p>
</li>
<li><p> subsequently call <code>mrgsim()</code> or <code>mapbayest()</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
# First option: work with a data.frame

adm_rows(amt = 1000, cmt = 1, addl = 4, ii = 12) %&gt;%
  obs_rows(time = c(12.3, 45.6), DV = c(.111, .222), cmt = 2) %&gt;%
  obs_rows(time = 48, cmt = 2) %&gt;%
  add_covariates(BW = 90, SEX = 0, TOLA = TRUE)

# You can even inform "time" using date and hours:
adm_rows(amt = 1000, cmt = 1, addl = 4, ii = 12, .datehour = "2022-01-01 11:11:11") %&gt;%
  obs_rows(.datehour = "2022-01-02 22:22:22", DV = 0.111, cmt = 2)

# Second option: work with a dataset within a 'mrgsolve' model

mod &lt;- exmodel(add_exdata = FALSE)
# call `mrgsolve::see(mod)` to see how default compartment were coded
adm_cmt(mod)
obs_cmt(mod)

mod %&gt;%
  adm_rows(amt = 10000) %&gt;%
  obs_rows(time = c(1.5, 4.4, 7.5, 24.6), DV = c(91.2904, 110.826, 79.384, 20.6671)) %&gt;%
  # get_data() # for curiosity, you can extract the data set at this step
  mapbayest()


</code></pre>

<hr>
<h2 id='deprecations'>Deprecated functions</h2><span id='topic+deprecations'></span><span id='topic+mbrest'></span><span id='topic+adm_lines'></span><span id='topic+obs_lines'></span>

<h3>Description</h3>

<p>Deprecated functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbrest(...)

adm_lines(...)

obs_lines(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deprecations_+3A_...">...</code></td>
<td>
<p>passed to the corresponding function</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> mbrest() is now <code><a href="#topic+mapbayest">mapbayest()</a></code>
</p>
</li>
<li><p> adm_lines() is now <code><a href="#topic+adm_rows">adm_rows()</a></code>
</p>
</li>
<li><p> obs_lines() is now <code><a href="#topic+obs_rows">obs_rows()</a></code>
</p>
</li></ul>


<hr>
<h2 id='do_mapbayr_sim'>Simulate with mapbayr</h2><span id='topic+do_mapbayr_sim'></span>

<h3>Description</h3>

<p>A wrapper around <code><a href="mrgsolve.html#topic+mrgsim">mrgsolve::mrgsim()</a></code> for results generated from <code><a href="#topic+mapbayest">mapbayest()</a></code>. Exported for the purpose of utility but might be prone to changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_mapbayr_sim(
  x,
  data,
  recsort = 3,
  output = "df",
  ...,
  eta = NULL,
  nrep = NULL,
  new_omega = NULL,
  new_sigma = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_mapbayr_sim_+3A_x">x</code></td>
<td>
<p>the model object</p>
</td></tr>
<tr><td><code id="do_mapbayr_sim_+3A_data">data</code></td>
<td>
<p>NMTRAN-like data set</p>
</td></tr>
<tr><td><code id="do_mapbayr_sim_+3A_recsort">recsort</code></td>
<td>
<p>record sorting flag. Defaulted to 3. See <code><a href="mrgsolve.html#topic+mrgsim">mrgsolve::mrgsim()</a></code>.</p>
</td></tr>
<tr><td><code id="do_mapbayr_sim_+3A_output">output</code></td>
<td>
<p>type of object returned. Defaulted to <code>"df"</code> for a data.frame. See <code><a href="mrgsolve.html#topic+mrgsim">mrgsolve::mrgsim()</a></code>.</p>
</td></tr>
<tr><td><code id="do_mapbayr_sim_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="mrgsolve.html#topic+mrgsim">mrgsolve::mrgsim()</a></code>.</p>
</td></tr>
<tr><td><code id="do_mapbayr_sim_+3A_eta">eta</code></td>
<td>
<p>a matrix of individual point estimates of ETA. Most likely obtained with <code><a href="#topic+get_eta">get_eta()</a></code>.</p>
</td></tr>
<tr><td><code id="do_mapbayr_sim_+3A_nrep">nrep</code></td>
<td>
<p>number of replicates. If used, the original &quot;ID&quot; in the data will be replaced by unique identifiers.</p>
</td></tr>
<tr><td><code id="do_mapbayr_sim_+3A_new_omega">new_omega</code>, <code id="do_mapbayr_sim_+3A_new_sigma">new_sigma</code></td>
<td>
<p>New &quot;omega&quot; and &quot;sigma&quot; matrices to use instead of those defined in &quot;$OMEGA&quot; and &quot;$SIGMA&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output from <code><a href="mrgsolve.html#topic+mrgsim">mrgsolve::mrgsim()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mrgsolve)
mod &lt;- exmodel(1, exdata = FALSE)
dat &lt;- exdata(ID = c(1,2))

# Classic framework
set.seed(123)
do_mapbayr_sim(x = mod, data = dat, Request = "DV")

# No random effect
do_mapbayr_sim(x = zero_re(mod), data = dat)
do_mapbayr_sim(x = mod, data = dat, new_omega = "zero_re")

# New random effects
## New omega matrix
do_mapbayr_sim(x = mod, data = dat, new_omega = dmat(0.1, 0.03, 0.01), nrep = 10)

## Matrix with "eta" as mean and "new_omega" as variance covariance matrix
etamat &lt;- get_eta(est001, output = "num")[1:2,]

do_mapbayr_sim(
  x = mod, data = dat, nrep = 10,
  eta = etamat, new_omega = dmat(0.1, 0.03, 0.01)
)

</code></pre>

<hr>
<h2 id='est001'>Estimation object</h2><span id='topic+est001'></span>

<h3>Description</h3>

<p>An example of <code>mapbayests</code> object, corresponding to the parameter estimation of the 8 subjects from model 1. Note that the model object within is not associated to a shared object, which make some features unavailable. This object can be re-generated by executing <code>est001 &lt;- mapbayest(exmodel(ID = 1:8))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est001
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mapbayests</code> of length 9.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mapbayest">mapbayest</a></code>
</p>

<hr>
<h2 id='eta'>Generate a vector of &quot;ETA&quot;</h2><span id='topic+eta'></span>

<h3>Description</h3>

<p>Generate a vector of &quot;ETA&quot; values. If x is a <code>mrgsolve</code> model, these will be extracted from values defined in <code style="white-space: pre;">&#8288;$PARAM&#8288;</code>. Otherwise, any numeric values passed to <code>x</code> and <code>...</code> as vector(s) or list(s) will be coerced as a single vector. Alternatively, if <code>x</code> and <code>...</code> are missing, generate a vector of ETA equal to <code>val</code> of length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eta(x, ..., n, val = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eta_+3A_x">x</code></td>
<td>
<p>either a <code>mrgsolve</code> model object, or a numeric</p>
</td></tr>
<tr><td><code id="eta_+3A_...">...</code></td>
<td>
<p>additional numeric(s)</p>
</td></tr>
<tr><td><code id="eta_+3A_n">n</code>, <code id="eta_+3A_val">val</code></td>
<td>
<p>generate a sequence of <code>val</code> of length <code>n</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single named vector of numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extract ETA from the model
mod &lt;- exmodel()
eta(mod)

# Coerce numeric values
eta(0.1, 0.2, c(0.3, 0.4), list(0.5, 0.6))
eta(rnorm(4))

# Generate a sequence from scratch
eta(n = 3)
eta(n = 3, val = 0.001)
</code></pre>

<hr>
<h2 id='exmodel_exdata'>Example model and data</h2><span id='topic+exmodel_exdata'></span><span id='topic+exmodel'></span><span id='topic+exdata'></span>

<h3>Description</h3>

<p>A collection of example models and corresponding data to test and explore <code>mapbayr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exmodel(
  num = 1,
  add_exdata = TRUE,
  cache = TRUE,
  quiet = getOption("mrgsolve_mread_quiet", TRUE),
  ...,
  ID = 1,
  clean_data = TRUE
)

exdata(num = 1, ID = 1, clean_data = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exmodel_exdata_+3A_num">num</code></td>
<td>
<p>model number (see details)</p>
</td></tr>
<tr><td><code id="exmodel_exdata_+3A_add_exdata">add_exdata</code></td>
<td>
<p>should data be automatically loaded with the model</p>
</td></tr>
<tr><td><code id="exmodel_exdata_+3A_cache">cache</code></td>
<td>
<p>read the model with <code>mrgsolve::mread_cache()</code></p>
</td></tr>
<tr><td><code id="exmodel_exdata_+3A_quiet">quiet</code></td>
<td>
<p>don't print messages when compiling</p>
</td></tr>
<tr><td><code id="exmodel_exdata_+3A_...">...</code></td>
<td>
<p>passed to <code>mrgsolve::mread()</code> or <code>mrgsolve::mread_cache()</code></p>
</td></tr>
<tr><td><code id="exmodel_exdata_+3A_id">ID</code></td>
<td>
<p>individual number to include in the data (from 1 to 8)</p>
</td></tr>
<tr><td><code id="exmodel_exdata_+3A_clean_data">clean_data</code></td>
<td>
<p>remove useless columns and rows from the original data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available models are:
</p>

<ul>
<li><p> 1: Base model. A simple monocompartmental PK model with inter-individual variability on absorption constant (KA), volume of distribution (VC) and clearance (CL). The residual error model is proportional.
</p>
</li>
<li><p> 6: Complex absorption model. Dual 0- and 1st orders absorption phenomenons.
</p>
</li>
<li><p> 301: Time-varying covariates. A continuous covariate (body weight &quot;BW&quot;) and a categorical one (sex &quot;SEX&quot;) influence the clearance parameter. In the corresponding dataset, the values randomly changes from one record to another within a single individual.
</p>
</li>
<li><p> 401: Metabolite. The PK model of both a parent drug and its metabolite.
</p>
</li></ul>

<p>An example dataset of eight (simulated) individuals is available for each model. Individuals differ in terms of sampling times (sparse or rich) and dosing regimen (single or multiple dosing).
</p>
<p>Model code and data files are stored at the location given by <code>system.file("exmodel", package = "mapbayr")</code>.
</p>
<p>These models and data were created for the validation study of <code>mapbayr</code> published in <a href="https://pubmed.ncbi.nlm.nih.gov/34342170/">CPT:Pharmacometrics &amp; System Pharmacology</a>. More models and full datasets can be accessed <a href="https://github.com/FelicienLL/mapbayr-CPTPSP-2021">in a dedicated repository</a>
</p>


<h3>Value</h3>

<p><code>exmodel()</code> reads and compiles code, and returns a (<code>mrgmod</code>) model object. <code>exdata()</code> returns a data.frame.
</p>


<h3>Source</h3>

<p><a href="https://github.com/FelicienLL/mapbayr-CPTPSP-2021">https://github.com/FelicienLL/mapbayr-CPTPSP-2021</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Models can be loaded with data (the default), ready for parameter estimation
est &lt;- mapbayest(exmodel())

# Number of subjects in dataset can be chosen up to 8 individuals
exdata(301, ID = c(5,8))
</code></pre>

<hr>
<h2 id='filter.mrgmod'>Filter a dataset within a mrgmod</h2><span id='topic+filter.mrgmod'></span>

<h3>Description</h3>

<p>Filter a dataset within a mrgmod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrgmod'
filter(.data, ..., .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.mrgmod_+3A_.data">.data</code></td>
<td>
<p>a mrgmod</p>
</td></tr>
<tr><td><code id="filter.mrgmod_+3A_...">...</code>, <code id="filter.mrgmod_+3A_.preserve">.preserve</code></td>
<td>
<p>additional arguments for <code>dplyr::filter()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mrgmod
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
mod &lt;- mrgsolve::mcode("mod", "$CMT FOO", compile = FALSE)
mod %&gt;%
  adm_rows(amt = c(100, 200, 300), cmt = 1) %&gt;%
  filter(amt != 200) %&gt;%
  get_data()
</code></pre>

<hr>
<h2 id='get_x'>Get content from object</h2><span id='topic+get_x'></span><span id='topic+get_data'></span><span id='topic+get_data.mrgmod'></span><span id='topic+get_data.mapbayests'></span><span id='topic+get_eta'></span><span id='topic+get_eta.mapbayests'></span><span id='topic+get_cov'></span><span id='topic+get_cov.mapbayests'></span><span id='topic+get_param'></span><span id='topic+get_param.mapbayests'></span><span id='topic+get_phi'></span><span id='topic+get_phi.mapbayests'></span>

<h3>Description</h3>

<p>Helpful functions to get content from a <code>mrgmod</code> object (i.e. data) or from a <code>mapbayests</code> object (<code>data</code>, <code>eta</code>, <code>cov</code>, <code>param</code>, <code>phi</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(x, ...)

## S3 method for class 'mrgmod'
get_data(x, ...)

## S3 method for class 'mapbayests'
get_data(x, ..., output = "df")

get_eta(x, ...)

## S3 method for class 'mapbayests'
get_eta(x, ..., output = NULL)

get_cov(x, ...)

## S3 method for class 'mapbayests'
get_cov(x, ..., simplify = TRUE)

get_param(x, ...)

## S3 method for class 'mapbayests'
get_param(x, ..., output = NULL, keep_ID = NULL, keep_names = NULL)

get_phi(x, ...)

## S3 method for class 'mapbayests'
get_phi(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_x_+3A_x">x</code></td>
<td>
<p>mapbayests object</p>
</td></tr>
<tr><td><code id="get_x_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="get_x_+3A_output">output</code></td>
<td>
<p>either a data.frame (&quot;df&quot;) or a vector of numeric (&quot;num&quot;). Default to &quot;num&quot; if only one ID</p>
</td></tr>
<tr><td><code id="get_x_+3A_simplify">simplify</code></td>
<td>
<p>a logical. If TRUE (the default) and only one ID, one matrix is returned instead of a list of length 1</p>
</td></tr>
<tr><td><code id="get_x_+3A_keep_id">keep_ID</code></td>
<td>
<p>a logical. By default, the ID variable is dropped if one ID in data.</p>
</td></tr>
<tr><td><code id="get_x_+3A_keep_names">keep_names</code></td>
<td>
<p>a logical. By default, names are dropped if one parameter is requested, and output is not a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the class of the object returned depends on the function, and on their arguments. Typically, a data.frame or a vector if the output can be reduced to one line.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# From a model object (mrgmod)
mod &lt;- exmodel(ID = 1:2, cache = FALSE, capture = "CL")
get_data(mod)

# From an estimation object (mapbayests)
est &lt;- mapbayest(mod)
get_data(est)
get_data(est, output = "list")

get_eta(est)
get_eta(est, output = "list")

get_cov(est)

get_param(est)

get_phi(est)

</code></pre>

<hr>
<h2 id='hist.mapbayests'>Plot posterior distribution of bayesian estimates</h2><span id='topic+hist.mapbayests'></span>

<h3>Description</h3>

<p>Plot posterior distribution of bayesian estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mapbayests'
hist(x, select_eta = x$arg.optim$select_eta, shk = c("sd", "var", NA), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.mapbayests_+3A_x">x</code></td>
<td>
<p>A <code>mapbayests</code> object.</p>
</td></tr>
<tr><td><code id="hist.mapbayests_+3A_select_eta">select_eta</code></td>
<td>
<p>a vector of numeric values, the numbers of the ETAs to show (default are estimated ETAs).</p>
</td></tr>
<tr><td><code id="hist.mapbayests_+3A_shk">shk</code></td>
<td>
<p>method to compute the shrinkage if multiple subjects are analyzed. Possible values are &quot;sd&quot; (based on the ratio of standard deviation like in 'NONMEM'), &quot;var&quot; (based on the ratio of variances like 'Monolix'), or NA (do not show the shrinkage)</p>
</td></tr>
<tr><td><code id="hist.mapbayests_+3A_...">...</code></td>
<td>
<p>additional arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function to plot the results of the estimations, in the form of histograms with the <em>a priori</em> distribution in the background. For every parameter, the inter-individual variability is displayed, as well as the percentile of the patient in the corresponding distribution (if n = 1 patient).
For additional modifications, you can add extra <code style="white-space: pre;">&#8288;+function(...)&#8288;</code> in order to modify the plot as a regular <code>ggplot2</code> object.
</p>


<h3>Value</h3>

<p>a <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
est &lt;- mapbayest(exmodel(ID = 1))

# Default Method
h &lt;- hist(est)

# Can be modified with `ggplot2`
h +
  ggplot2::labs(title = "Awesome estimations")

# Select the ETAs
hist(est, select_eta = c(1,3))

</code></pre>

<hr>
<h2 id='mapbayest'>Estimate parameters (maximum a posteriori)</h2><span id='topic+mapbayest'></span>

<h3>Description</h3>

<p>The main function of the mapbayr package. Performs a <em>maximum a posteriori</em> Bayesian estimation of parameters, from a mrgsolve model object and a dataset containing information about administrations and observed concentrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapbayest(
  x,
  data = NULL,
  method = c("L-BFGS-B", "newuoa"),
  hessian = stats::optimHess,
  select_eta = NULL,
  lambda = 1,
  lloq = NULL,
  force_initial_eta = NULL,
  quantile_bound = 0.001,
  control = list(),
  check = TRUE,
  verbose = TRUE,
  progress = TRUE,
  reset = 50,
  output = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapbayest_+3A_x">x</code></td>
<td>
<p>the model object</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_data">data</code></td>
<td>
<p>NMTRAN-like data set</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_method">method</code></td>
<td>
<p>optimization method; the default is <code>"L-BFGS-B"</code> (from <code>stat::optim()</code>), alternatively <code>"newuoa"</code> for <code>minqa::newuoa()</code></p>
</td></tr>
<tr><td><code id="mapbayest_+3A_hessian">hessian</code></td>
<td>
<p>function used to compute the Hessian and variance-covariance matrix with (default is <code>stats::optimHess</code>, alternatively use <code>nlmixr::nlmixrHess</code>)</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_select_eta">select_eta</code></td>
<td>
<p>a vector of numeric values, the numbers of the ETAs to be estimated (default is <code>NULL</code>, all ETAs non-equal to zero)</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_lambda">lambda</code></td>
<td>
<p>a numeric value, the weight applied to the model prior (default is 1)</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_lloq">lloq</code></td>
<td>
<p>a numeric value, the lower limit of quantification. If not NULL, <code>LLOQ</code> and <code>BLQ</code> (below limit of quantification) variables will be added to the data. The related records will be censored with the M3 method. Ignored if <code>LLOQ</code> already in the data.</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_force_initial_eta">force_initial_eta</code></td>
<td>
<p>a vector of numeric values to start the estimation from (default to 0 for &quot;L-BFGS-B&quot;)</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_quantile_bound">quantile_bound</code></td>
<td>
<p>a numeric value representing the quantile of the normal distribution admitted to define the bounds for L-BFGS-B (default is 0.001, i.e. 0.1%)</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_control">control</code></td>
<td>
<p>a list passed to the optimizer (see <code><a href="stats.html#topic+optim">stats::optim()</a></code> or  <code><a href="minqa.html#topic+newuoa">minqa::newuoa()</a></code> documentation)</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_check">check</code></td>
<td>
<p>check model code for mapbayr specification (a logical, default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_verbose">verbose</code></td>
<td>
<p>print a message whenever optimization is reset (a logical, default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_progress">progress</code></td>
<td>
<p>print a progress bar (a logical, default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_reset">reset</code></td>
<td>
<p>maximum allowed reset of the optimizer with new initial eta values if numerical difficulties, or with new bounds (L-BFGS-B) if estimate equal to a bound. (a numeric, default is 50)</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_output">output</code></td>
<td>
<p>if <code>NULL</code> (the default) a mapbayests object is returned; if <code>df</code> a <em>mapbay_tab</em> dataframe is returned</p>
</td></tr>
<tr><td><code id="mapbayest_+3A_...">...</code></td>
<td>
<p>for compatibility (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mapbayests object. Basically a list containing:
</p>

<ul>
<li><p> model: the model object
</p>
</li>
<li><p> arg.ofv.optim, arg.ofv.fix, arg.ofv.id: arguments passed to the optimization function. Useful for debugging but not relevant for a basic usage. Access to the data with <code>get_data(x)</code>
</p>
</li>
<li><p> opt.value: the original output of the optimization function
</p>
</li>
<li><p> final_eta: a list of individual vectors of final estimates. Access it with <code>x$final_eta</code> or <code>get_eta(x)</code>.
</p>
</li>
<li><p> covariance: a list of individual variance-covariance matrix of estimation. Access it with <code>x$covariance</code> or <code>get_cov(x)</code>.
</p>
</li>
<li><p> mapbay_tab: an output table containing the results of your estimations (data, IPRED, PRED, covariates, captured items, ETA etc...). Access it with <code>x$mapbay_tab</code>, <code>as.data.frame(x)</code> or <code>as_tibble(x)</code>.
</p>
</li>
<li><p> information: run times and package versions.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+hist.mapbayests">hist.mapbayests</a></code>
</p>
<p><code><a href="#topic+plot.mapbayests">plot.mapbayests</a></code>
</p>
<p><code><a href="#topic+use_posterior">use_posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, code a model
code1 &lt;- "$PARAM ETA1 = 0, ETA2 = 0,
KA = 0.5, TVCL = 1.1, TVV = 23.3
$OMEGA 0.41 0.32
$SIGMA 0.04 0
$CMT DEPOT CENT
$PK
double CL=TVCL*exp(ETA1+ETA(1));
double V=TVV*exp(ETA2+ETA(2)) ;
$ERROR
double DV=CENT/V*(1+EPS(1))+EPS(2);
$PKMODEL ncmt = 1, depot = TRUE
$CAPTURE DV CL
"

my_model &lt;- mrgsolve::mcode("my_model", code1)
# Then, import your data
my_data &lt;- data.frame(ID = 1, TIME = c(0, 1.1, 5.2, 12.3), EVID = c(1,0,0,0), AMT = c(500, 0,0,0),
 CMT = c(1,2,2,2), DV = c(0, 15.1, 29.5, 22.3))
print(my_data)

# And estimate
my_est &lt;- mapbayest(x = my_model, data = my_data)
print(my_est)
# see also plot(my_est) and hist(my_est)

# Use your estimation
get_eta(my_est)
get_param(my_est)
as.data.frame(my_est)
use_posterior(my_est)

</code></pre>

<hr>
<h2 id='mapbayr_plot'>Make mapbayr plot</h2><span id='topic+mapbayr_plot'></span>

<h3>Description</h3>

<p>Make mapbayr plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapbayr_plot(
  aug_tab,
  obs_tab = NULL,
  PREDICTION = c("IPRED", "PRED"),
  MODEL_color = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapbayr_plot_+3A_aug_tab">aug_tab</code></td>
<td>
<p>a table of predictions, generated by <code>augment(x)</code> and available at <code>x$aug_tab</code></p>
</td></tr>
<tr><td><code id="mapbayr_plot_+3A_obs_tab">obs_tab</code></td>
<td>
<p>a table of observations</p>
</td></tr>
<tr><td><code id="mapbayr_plot_+3A_prediction">PREDICTION</code></td>
<td>
<p>plot either &quot;IPRED&quot;, &quot;PRED&quot; or both.</p>
</td></tr>
<tr><td><code id="mapbayr_plot_+3A_model_color">MODEL_color</code></td>
<td>
<p>a vector of strings interpretable as colors, with names that correspond to a value in <code>aug_tab$MODEL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aug &lt;- data.frame(
  ID = 1, name = factor("DV"), cmt = 2, time = rep(c(0,8,16,24), each = 2),
  type = rep(c("PRED", "IPRED"), 4), value = c(0,0, 1, 2, 4, 8, 2, 4)
  )

obs &lt;- data.frame(
  ID = 1, time = c(6, 20), evid = 0,
  mdv = c(0,1), DV = c(0.5, 5), cmt = 2
  )

mapbayr_plot(aug, obs)
mapbayr_plot(aug, obs, PREDICTION = "IPRED")

aug2 &lt;- dplyr::bind_rows(
  FOO = aug,
  BAZ = dplyr::mutate(aug, value = value * 2),
  BAR = dplyr::mutate(aug, value = value * 3),
  .id = "MODEL"
  )

mapbayr_plot(aug2, obs)
mapbayr_plot(aug2, obs, PREDICTION = "IPRED")
mapbayr_plot(aug2, obs, PREDICTION = "IPRED", MODEL_color = c(FOO = "black"))


</code></pre>

<hr>
<h2 id='mapbayr_vpc'>Visual Predicted Checks</h2><span id='topic+mapbayr_vpc'></span>

<h3>Description</h3>

<p>Visual Predicted Checks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapbayr_vpc(
  x,
  data = NULL,
  nrep = 500,
  pcvpc = TRUE,
  idv = "time",
  stratify_on = NULL,
  start = NULL,
  end = NULL,
  delta = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapbayr_vpc_+3A_x">x</code></td>
<td>
<p>the model object</p>
</td></tr>
<tr><td><code id="mapbayr_vpc_+3A_data">data</code></td>
<td>
<p>NMTRAN-like data set</p>
</td></tr>
<tr><td><code id="mapbayr_vpc_+3A_nrep">nrep</code></td>
<td>
<p>a numeric, the number of replicates for stochastic simulations. Default is 500.</p>
</td></tr>
<tr><td><code id="mapbayr_vpc_+3A_pcvpc">pcvpc</code></td>
<td>
<p>a logical, if <code>TRUE</code> (the default) will output &quot;prediction-corrected VPC&quot; (see Details).</p>
</td></tr>
<tr><td><code id="mapbayr_vpc_+3A_idv">idv</code></td>
<td>
<p>a character indicating the variable used as independent variable. Default is &quot;time&quot;, alternatively use &quot;tad&quot; to automatically compute the time after last dose.</p>
</td></tr>
<tr><td><code id="mapbayr_vpc_+3A_stratify_on">stratify_on</code></td>
<td>
<p>a character (vector) indicating the variables of the data used to stratify the results. Variables must be numeric (as they are passed to <code><a href="mrgsolve.html#topic+carry_out">mrgsolve::carry_out()</a></code>)</p>
</td></tr>
<tr><td><code id="mapbayr_vpc_+3A_start">start</code>, <code id="mapbayr_vpc_+3A_end">end</code>, <code id="mapbayr_vpc_+3A_delta">delta</code>, <code id="mapbayr_vpc_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="mrgsolve.html#topic+mrgsim">mrgsolve::mrgsim()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Prediction-corrected VPC
</p>
</li></ul>

<p>By default, VPC are prediction corrected (Bergstrand et al (2011) <a href="https://doi.org/10.1208/s12248-011-9255-z">doi:10.1208/s12248-011-9255-z</a>).
This correction is advised if several levels of doses or covariates are in the dataset for instance.
Note that the implemented correction formula does not take into account the 'lower bound' term (<em>lbij</em>), nor the log-transformed variables.
</p>


<h3>Value</h3>

<p>a <code>ggplot</code> object, results of the VPC. The median and the 50%, 80% and 90% prediction intervals of the simulated distributions are reported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mrgsolve)
library(magrittr)
# Define a model. Adding variability to house model because default is 0.
mod &lt;- house() %&gt;%
  omat(dmat(rep(0.2,4)))

# Creating dataset for the example
# Same concentration, but different dose (ID 2) and covariate (ID 3)
data &lt;- adm_rows(ID = 1, amt = 1000, cmt = 1, addl = 6, ii = 12) %&gt;%
  obs_rows(DV = 50, cmt = 2, time = 7 * 12) %&gt;%
  adm_rows(ID = 2, time = 0, amt = 2000, cmt = 1, addl = 6, ii = 12) %&gt;%
  obs_rows(DV = 50, cmt = 2, time = 7 * 12) %&gt;%
  adm_rows(ID = 3, time = 0, amt = 1000, cmt = 1, addl = 6, ii = 12) %&gt;%
  obs_rows(DV = 50, cmt = 2, time = 7 * 12) %&gt;%
  add_covariates(SEX = c(0,0,0,0,1,1))

mapbayr_vpc(mod, data, nrep = 30) # prediction-corrected by default
mapbayr_vpc(mod, data, idv = "tad", start = 72, nrep = 30)
mapbayr_vpc(mod, data, pcvpc = FALSE, nrep = 30)
mapbayr_vpc(mod, data, stratify_on = "SEX", nrep = 30)
</code></pre>

<hr>
<h2 id='model_averaging'>Average predictions from multiple models</h2><span id='topic+model_averaging'></span><span id='topic+compute_weights'></span><span id='topic+do_model_averaging'></span>

<h3>Description</h3>

<p>Model Averaging consists in analyzing the same data with different models
and to average their predictions.
In order to perform weighted means of clearance predictions, (or
concentrations, or any metric of interest), it is necessary to compute
the &quot;weight&quot; of each estimation.
It is informed by the likelihood of estimation.
Two weighting scheme are currently implemented, one based on the log-
likelihood (&quot;LL&quot;, the default), the other on the Akaike criterion (&quot;AIC&quot;).
The method was previously described by Uster et al (2021) <a href="https://doi.org/10.1002/cpt.2065">doi:10.1002/cpt.2065</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_averaging(
  ...,
  output_function = as.data.frame,
  scheme = c("LL", "AIC"),
  estlist = NULL
)

compute_weights(..., scheme = c("LL", "AIC"), estlist = NULL)

do_model_averaging(list_of_tabs, weights_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_averaging_+3A_...">...</code></td>
<td>
<p>estimation objects generated with <code><a href="#topic+mapbayest">mapbayest()</a></code>, from which the weights will be computed</p>
</td></tr>
<tr><td><code id="model_averaging_+3A_output_function">output_function</code></td>
<td>
<p>a unique function that takes any estimation object and returns a table with controlled variables, dimensions and attributes.</p>
</td></tr>
<tr><td><code id="model_averaging_+3A_scheme">scheme</code></td>
<td>
<p>scheme weight, either &quot;LL&quot; or &quot;AIC&quot;</p>
</td></tr>
<tr><td><code id="model_averaging_+3A_estlist">estlist</code></td>
<td>
<p>a list of estimation objects. Overrides <code>...</code></p>
</td></tr>
<tr><td><code id="model_averaging_+3A_list_of_tabs">list_of_tabs</code>, <code id="model_averaging_+3A_weights_matrix">weights_matrix</code></td>
<td>
<p>respectively outputs of the <code>output_function</code> and <code><a href="#topic+compute_weights">compute_weights()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+model_averaging">model_averaging()</a></code> and <code><a href="#topic+do_model_averaging">do_model_averaging()</a></code>: a data.frame of the same dimensions and attributes as the outputs
</p>
</li>
<li> <p><code><a href="#topic+compute_weights">compute_weights()</a></code>: a matrix with IDs as rows and estimation weights as columns
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

# Three different models: A, B, and C.
modA &lt;- exmodel(1, add_exdata = FALSE)
modB &lt;- mrgsolve::param(modA, TVCL = 2, TVVC = 30)
modC &lt;- mrgsolve::param(modA, TVCL = 10)

# A common dataset that has 2 patients (ID 2 &amp; 9)
data &lt;- adm_rows(ID = 2, time = 0, amt = 200, addl = 3, ii = 24, cmt = 1) %&gt;%
    obs_rows(ID = 2, time = 84, DV = 1.5, cmt = 2) %&gt;%
    adm_rows(ID = 9, time = 0, amt = 100, addl = 3, ii = 24, cmt = 1) %&gt;%
    obs_rows(ID = 9, time = 96, DV = 1, cmt = 2)

# Three different estimation objects: A, B and C.
estA &lt;- mapbayest(modA, data)
as.data.frame(estA)
plot(estA) # Fit is pretty good

estB &lt;- mapbayest(modB, data)
as.data.frame(estB)
plot(estB) # Excellent fit

estC &lt;- mapbayest(modC, data)
as.data.frame(estC)
plot(estC) # Fit is worst

# Model averaging
model_averaging(A = estA, B = estB, C = estC)
# Weighted average of the table returned by as.data.frame(est))

# Internally, it first computes the "weight" of each model such as:
W &lt;- compute_weights(A = estA, B = estB, C = estC)

# Then multiply the prediction table with each weight such as:
do_model_averaging(
  list_of_tabs = list(
    A = as.data.frame(estA),
    B = as.data.frame(estB),
    C = as.data.frame(estC)
    ),
  weights_matrix = W
  )

# If you do not want to perform an average of the full table, you can specify
# a function that takes the estimation object as an input and returns
# value(s) of interest: a single prediction, a clearance value, a full
# table of augmented predictions... as long as the structure of the final
# object is the same whatever the model.

reframe &lt;- function(est){
  # From any estimation object, return a table with ID, time and predictions
  as.data.frame(est)[,c("ID", "time", "DV", "IPRED")]
}

model_averaging(A = estA, B = estB, C = estC, output_function = reframe)

# Make a plot that compares predictions
List_aug_tab &lt;- lapply(
  X = list(A = estA, B = estB, C = estC),
  FUN = \(x) augment(x)$aug_tab
)
List_aug_tab$.AVERAGE &lt;- do_model_averaging(List_aug_tab, W)

mapbayr_plot(
 aug_tab = dplyr::bind_rows(List_aug_tab, .id = "MODEL"),
 obs_tab = data,
 PREDICTION = "IPRED",
 MODEL_color = c(.AVERAGE = "black")
)

</code></pre>

<hr>
<h2 id='obs_rows'>Add observation lines to a dataset</h2><span id='topic+obs_rows'></span><span id='topic+obs_rows.data.frame'></span><span id='topic+obs_rows.missing'></span><span id='topic+obs_rows.mrgmod'></span>

<h3>Description</h3>

<p>The <code>obs_rows()</code> function adds an one or several observation lines to a dataset provided as a proper data.frame or within a 'mrgsolve' model. Used in combination with <code><a href="#topic+adm_rows">adm_rows()</a></code> and <code><a href="#topic+add_covariates">add_covariates()</a></code>, it helps the creation of datasets in the proper format for simulations with 'mrgsolve' or parameter estimation with 'mapbayr', as explained in <a href="#topic+data_helpers">data_helpers</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obs_rows(x, ...)

## S3 method for class 'data.frame'
obs_rows(
  x,
  ID = NULL,
  time = NULL,
  evid = 0L,
  cmt,
  DV = NA_real_,
  mdv = NULL,
  .datehour = NULL,
  ...
)

## S3 method for class 'missing'
obs_rows(...)

## S3 method for class 'mrgmod'
obs_rows(x, cmt = NULL, DV = NA_real_, DVmet = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obs_rows_+3A_x">x</code></td>
<td>
<p>either a data.frame or a 'mrgsolve' model object</p>
</td></tr>
<tr><td><code id="obs_rows_+3A_...">...</code></td>
<td>
<p>additional columns</p>
</td></tr>
<tr><td><code id="obs_rows_+3A_id">ID</code></td>
<td>
<p>subject ID (default is 1)</p>
</td></tr>
<tr><td><code id="obs_rows_+3A_time">time</code></td>
<td>
<p>event time. Default is 0 if no previous events. Mind consistency with <code>.datehour</code>.</p>
</td></tr>
<tr><td><code id="obs_rows_+3A_evid">evid</code></td>
<td>
<p>event identification (default is 1 for administration, 0 for observation)</p>
</td></tr>
<tr><td><code id="obs_rows_+3A_cmt">cmt</code></td>
<td>
<p>compartment (no default, except if <code style="white-space: pre;">&#8288;[OBS]&#8288;</code> was tagged in the <code style="white-space: pre;">&#8288;$CMT&#8288;</code> block in model code. See <code>examples</code>.)</p>
</td></tr>
<tr><td><code id="obs_rows_+3A_dv">DV</code></td>
<td>
<p>dependent value, i.e. observed concentration.</p>
</td></tr>
<tr><td><code id="obs_rows_+3A_mdv">mdv</code></td>
<td>
<p>missing dependent value (default is 0 a non-missing concentration value to take into account for parameter estimation, 1 otherwise)</p>
</td></tr>
<tr><td><code id="obs_rows_+3A_.datehour">.datehour</code></td>
<td>
<p>a object of class POSIXct, a number or a character vector that can be passed to <code><a href="#topic+parse_datehour">parse_datehour()</a></code>. Using <code>.datehour</code> will update the value of <code>time</code> in the dataset, with units in hours. Mind consistency with the <code>time</code> argument.</p>
</td></tr>
<tr><td><code id="obs_rows_+3A_dvmet">DVmet</code></td>
<td>
<p>second observation at the same time (e.g. a metabolite, &quot;DVmet&quot;) observed jointly with parent drug (&quot;DV&quot;). Works only if <code>x</code> is a 'mrgsolve' model where two <code style="white-space: pre;">&#8288;[OBS]&#8288;</code> compartments were defined (see <code>examples</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame, or a 'mrgsolve' model with a dataset in the <code style="white-space: pre;">&#8288;@args$data&#8288;</code> slot (accessible with <code><a href="#topic+get_data">get_data()</a></code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+data_helpers">data_helpers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a dataset from scratch
obs_rows(time = 12, DV = 0.12, cmt = 2)

# Pipe-friendly addition of observation record to a pre-existing dataset
library(magrittr)
obs_rows(time = 12, DV = 0.12, cmt = 2) %&gt;%
  obs_rows(time = c(24, 36, 48), DV = c(0.34, 0.56, 0.78), mdv = c(0, 1, 0), cmt = 2)

# Inform times using the `.datehour` argument:
obs_rows(.datehour = "2020-01-01 11:11", DV = 0.12, cmt = 1) %&gt;%
  obs_rows(.datehour = "2020-01-02 22:22", DV = 0.34, cmt = 1) %&gt;%
  obs_rows(time = 48, DV = 0.56, cmt = 1)

# Start from a 'mrgsolve' model
library(mrgsolve)
house() %&gt;%
  obs_rows(time = 12, DV = 0.12, cmt = 2) %&gt;%
  obs_rows(time = c(24, 36, 48), DV = c(0.34, 0.56, 0.78), mdv = c(0, 1, 0), cmt = 2) %&gt;%
  mrgsim()

# Default observation compartments
# Set default observation compartments in the code with `[OBS]`
model &lt;- mcode("model", "
$CMT @annotated
DEPOT : Depot
CENTR : Central [OBS]
", compile = FALSE)
obs_cmt(model)

# Thus, no need to manually specify `cmt = 2` anymore.
model %&gt;%
  obs_rows(time = 12, DV = 0.12) %&gt;%
  obs_rows(time = c(24, 36, 48), DV = c(0.34, 0.56, 0.78), mdv = c(0, 1, 0)) %&gt;%
  get_data()

# Automatic lines duplication if parent + metabolite defined in the model
model &lt;- mcode("model", "
$CMT @annotated
DEPOT : Depot
CENTR : Central [OBS]
PERIPH : Periph
METABO : Metabo [OBS]
", compile = FALSE)
obs_cmt(model)

model %&gt;%
  obs_rows(time = 12, DV = 0.12, DVmet = 120) %&gt;%
  obs_rows(
    time = c(24, 36, 48), DV = c(0.34, 0.56, 0.78),
    mdv = c(0, 1, 0), DVmet = c(340, 560, 780)
  ) %&gt;%
  get_data()
</code></pre>

<hr>
<h2 id='parse_datehour'>Parse value to &quot;POSIXct&quot;</h2><span id='topic+parse_datehour'></span>

<h3>Description</h3>

<p>A wrapper around functions of <code>lubridate</code>, mainly in order to transform characters into a date-time (&quot;POSIXct&quot;) format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_datehour(
  x,
  orders = getOption("mapbayr.datehour", default = c("Ymd HMS", "Ymd HM", "dmY HMS",
    "dmY HM"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_datehour_+3A_x">x</code></td>
<td>
<p>a numeric or a character.</p>
</td></tr>
<tr><td><code id="parse_datehour_+3A_orders">orders</code></td>
<td>
<p>format specification for x, passed to <code><a href="lubridate.html#topic+parse_date_time">lubridate::parse_date_time()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a POSIXct
</p>


<h3>Examples</h3>

<pre><code class='language-R'># POSITct are returned as is.
parse_datehour(x = as.POSIXct("2022-02-02 22:22:22", tz = "UTC"))

# Numerics are passed to `lubridate::as_datetime()`.
parse_datehour(1643840542)

# Characters are passed to `lubridate::parse_date_time()`.
# The format used will be the one defined in `orders`
parse_datehour(x = "2022-02-02 22:22:22", orders = "Ymd HMS")
parse_datehour(x = "02-02-2022 22:22", orders = "dmY HM")

# By default, the following formats will be subsequently tried:
# "Ymd HMS", "Ymd HM", "dmY HMS", "dmY HM"

# Alternatively, set a format through `options(mapbayr.datehour)`.
# Convenient for the use `.datehour` in  `adm_rows()` and `obs_rows()`.

# Following format will return NA:
adm_rows(.datehour = "22:22 02-02-2022", amt = 100, cmt = 1)

options(mapbayr.datehour = "HM dmY")
adm_rows(.datehour = "22:22 02-02-2022", amt = 100, cmt = 1)
options(mapbayr.datehour = NULL)

</code></pre>

<hr>
<h2 id='plot.mapbayests'>Plot predictions from mapbayests object</h2><span id='topic+plot.mapbayests'></span>

<h3>Description</h3>

<p>Plot predictions from mapbayests object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mapbayests'
plot(x, ..., PREDICTION = c("IPRED", "PRED"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mapbayests_+3A_x">x</code></td>
<td>
<p>A <code>mapbayests</code> object.</p>
</td></tr>
<tr><td><code id="plot.mapbayests_+3A_...">...</code></td>
<td>
<p>additional arguments (passed to <code><a href="#topic+augment.mapbayests">augment.mapbayests</a></code>)</p>
</td></tr>
<tr><td><code id="plot.mapbayests_+3A_prediction">PREDICTION</code></td>
<td>
<p>plot either &quot;IPRED&quot;, &quot;PRED&quot; or both.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function to plot the results of the estimations, in the form of concentration vs time profiles for every patient of the data set.
For additional modifications, you can:
</p>

<ul>
<li><p> see <code><a href="#topic+augment.mapbayests">augment.mapbayests</a></code> to modify the simulation output.
</p>
</li>
<li><p> add extra <code style="white-space: pre;">&#8288;+function(...)&#8288;</code> in order to modify the plot as a regular <code>ggplot2</code> object.
</p>
</li></ul>



<h3>Value</h3>

<p>a <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>est &lt;- mapbayest(exmodel(ID = 1))
plot(est, end = 48) +
  ggplot2::labs(title = "Awesome prediction")


</code></pre>

<hr>
<h2 id='preprocess.ofv'>Preprocess model and data for ofv computation</h2><span id='topic+preprocess.ofv'></span><span id='topic+preprocess.ofv.fix'></span><span id='topic+preprocess.ofv.id'></span>

<h3>Description</h3>

<p>Functions to generate arguments passed to <code><a href="#topic+compute_ofv">compute_ofv</a></code>. Arguments that are fixed between individuals are created once (<code>preprocess.ofv.fix</code>), while others are specific of each individual (<code>preprocess.ofv.id</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess.ofv.fix(x, data, select_eta = seq_along(eta(x)), lambda = 1)

preprocess.ofv.id(x, iddata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess.ofv_+3A_x">x</code></td>
<td>
<p>the model object</p>
</td></tr>
<tr><td><code id="preprocess.ofv_+3A_data">data</code>, <code id="preprocess.ofv_+3A_iddata">iddata</code></td>
<td>
<p>NMTRAN-like data set. iddata is likely a dataset of one individual</p>
</td></tr>
<tr><td><code id="preprocess.ofv_+3A_select_eta">select_eta</code></td>
<td>
<p>numbers of the ETAs taken into account. Set the dimensions of the inversed OMEGA matrix</p>
</td></tr>
<tr><td><code id="preprocess.ofv_+3A_lambda">lambda</code></td>
<td>
<p>a numeric value, the weight applied to the model prior (default is 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of arguments used to compute the objective function value.
</p>
<p>The following arguments are fixed between individuals:
</p>

<ul>
<li> <p><code>qmod</code>: model object, modified to simulate without random effects and with controlled outputs
</p>
</li>
<li> <p><code>sigma</code>: a single matrix object
</p>
</li>
<li> <p><code>log_transformation</code>: a logical, whether predictions need to be log-transformed for ofv computation
</p>
</li>
<li> <p><code>omega_inv</code>: a single matrix object
</p>
</li>
<li> <p><code>all_cmt</code>: a vector of compartment numbers where observations can be expected
</p>
</li></ul>

<p>The following arguments differs between individuals:
</p>

<ul>
<li> <p><code>idvaliddata</code>: a matrix, individual data set (with administrations and covariates), validated with <code><a href="mrgsolve.html#topic+valid_data_set">valid_data_set</a></code>
</p>
</li>
<li> <p><code>idDV</code>: a vector of (possibly log-transformed) observations
</p>
</li>
<li> <p><code>idcmt</code>: a vector of compartments where observations belong to
</p>
</li>
<li> <p><code>idblq</code>,<code>idlloq</code>: optional, a logical and numerical vector indicating if the observation is below the lower limit of quantification, and the LLOQ value, respectively
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- exmodel(add_exdata = FALSE, compile = FALSE)
dat &lt;- exdata(ID = c(1,4))

preprocess.ofv.fix(x = mod, data = dat)
preprocess.ofv.id(x = mod, iddata = dat[dat$ID == 1,])
preprocess.ofv.id(x = mod, iddata = dat[dat$ID == 4,])

</code></pre>

<hr>
<h2 id='preprocess.optim'>Pre-process: arguments for optimization function</h2><span id='topic+preprocess.optim'></span>

<h3>Description</h3>

<p>Pre-process: arguments for optimization function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess.optim(
  x,
  method = c("L-BFGS-B", "newuoa"),
  select_eta = NULL,
  control = list(),
  force_initial_eta = NULL,
  quantile_bound = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess.optim_+3A_x">x</code></td>
<td>
<p>the model object</p>
</td></tr>
<tr><td><code id="preprocess.optim_+3A_method">method</code></td>
<td>
<p>optimization method; the default is <code>"L-BFGS-B"</code> (from <code>stat::optim()</code>), alternatively <code>"newuoa"</code> for <code>minqa::newuoa()</code></p>
</td></tr>
<tr><td><code id="preprocess.optim_+3A_select_eta">select_eta</code></td>
<td>
<p>a vector of numeric values, the numbers of the ETAs to be estimated (default is <code>NULL</code>, all ETAs non-equal to zero)</p>
</td></tr>
<tr><td><code id="preprocess.optim_+3A_control">control</code></td>
<td>
<p>a list passed to the optimizer (see <code><a href="stats.html#topic+optim">stats::optim()</a></code> or  <code><a href="minqa.html#topic+newuoa">minqa::newuoa()</a></code> documentation)</p>
</td></tr>
<tr><td><code id="preprocess.optim_+3A_force_initial_eta">force_initial_eta</code></td>
<td>
<p>a vector of numeric values to start the estimation from (default to 0 for &quot;L-BFGS-B&quot;)</p>
</td></tr>
<tr><td><code id="preprocess.optim_+3A_quantile_bound">quantile_bound</code></td>
<td>
<p>a numeric value representing the quantile of the normal distribution admitted to define the bounds for L-BFGS-B (default is 0.001, i.e. 0.1%)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of named arguments passed to optimizer (i.e. arg.optim)
</p>

<hr>
<h2 id='print.mapbayests'>Print a mapbayests object</h2><span id='topic+print.mapbayests'></span>

<h3>Description</h3>

<p>Print a mapbayests object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mapbayests'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mapbayests_+3A_x">x</code></td>
<td>
<p>A <code>mapbayests</code> object.</p>
</td></tr>
<tr><td><code id="print.mapbayests_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>print the results of the estimation to the console, and returns it invisibly.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+filter'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter">filter</a></code></p>
</dd>
</dl>

<hr>
<h2 id='use_posterior'>Use posterior estimation</h2><span id='topic+use_posterior'></span>

<h3>Description</h3>

<p>Use posterior estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_posterior(
  x,
  update_omega = FALSE,
  update_cov = TRUE,
  update_eta = TRUE,
  .zero_re = NULL,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_posterior_+3A_x">x</code></td>
<td>
<p>A <code>mapbayests</code> object.</p>
</td></tr>
<tr><td><code id="use_posterior_+3A_update_omega">update_omega</code></td>
<td>
<p>Update the OMEGA matrix with the variance-covariance matrix of estimation (a logical, default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="use_posterior_+3A_update_cov">update_cov</code></td>
<td>
<p>Update the values of covariates with the individual values (a logical, default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="use_posterior_+3A_update_eta">update_eta</code></td>
<td>
<p>Update the values of ETA with the final estimates (a logical, default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="use_posterior_+3A_.zero_re">.zero_re</code></td>
<td>
<p>Set all elements of the OMEGA or SIGMA matrix to zero. Default is &quot;both&quot; if <code>update_omega</code> is FALSE, &quot;sigma&quot; otherwise. (possible values are &quot;both&quot;, &quot;sigma&quot;, &quot;omega&quot;, &quot;none&quot;)</p>
</td></tr>
<tr><td><code id="use_posterior_+3A_simplify">simplify</code></td>
<td>
<p>a logical. If TRUE (the default) and only one ID, one mrgmod is returned instead of a list of length 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the results of an estimation (i.e. a <code>mapbayests</code> object) and return a modified <code>mrgmod</code> in order to perform <em>a posteriori</em> simulations. Modifications are:
</p>

<ul>
<li><p> If <code>update_eta</code> is <code>TRUE</code>, the values of ETA are updated to the estimated values (instead of 0) in $PARAM.
</p>
</li>
<li><p> If <code>update_cov</code> is <code>TRUE</code>, the covariates values are updated to the values of the individual (instead of default model values) in $PARAM.
</p>
</li>
<li><p> If <code>update_omega</code> is <code>TRUE</code>, the values of OMEGA are updated with the variance-covariance matrix of estimation (i.e. an approximation of the <em>a posteriori</em> distribution) instead of the inter-individual variability (i.e. the <em>a priori</em> distribution). Use this command in order to derive a confidence interval of concentrations that reflects the uncertainty about parameter estimation when a large number of profiles are simulated. Note that if inter-individual variability was initially defined in multiple $OMEGA blocks in the model, they will be collapsed to a single full matrix (this is irreversible).
</p>
</li>
<li><p> Depending on the values of <code>.zero_re</code>, the elements of $OMEGA or $SIGMA can be set to zero, whether you want to simulate one profile, or several in order to derive confidence/prediction intervals.
It does not handle time-varying covariates: only the first value will be used as the individual value.
</p>
</li></ul>



<h3>Value</h3>

<p>a mrgmod, or a list of mrgmod if there is more than 1 ID
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
est &lt;- mapbayest(exmodel())
est %&gt;%
  use_posterior() %&gt;%
  mrgsolve::ev(amt = 50000) %&gt;%
  mrgsolve::mrgsim()

</code></pre>

<hr>
<h2 id='vs_nonmem'>Compare results to NONMEM .phi</h2><span id='topic+vs_nonmem'></span><span id='topic+read_nmphi'></span><span id='topic+merge_phi'></span><span id='topic+plot_phi'></span><span id='topic+summarise_phi'></span><span id='topic+bar_phi'></span>

<h3>Description</h3>

<p>Compare results to NONMEM .phi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_nmphi(x)

merge_phi(mapbayr_phi, nonmem_phi)

plot_phi(merged_phi, only_ETA = TRUE)

summarise_phi(
  merged_phi,
  group,
  only_ETA = TRUE,
  levels = c(Excellent = 0, Acceptable = 0.001, Discordant = 0.1)
)

bar_phi(summarised_phi, xaxis = NULL, facet = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vs_nonmem_+3A_x">x</code></td>
<td>
<p>full path to a .phi file generated by NONMEM</p>
</td></tr>
<tr><td><code id="vs_nonmem_+3A_mapbayr_phi">mapbayr_phi</code></td>
<td>
<p>results of mapbayr estimations, in the form of a tibble data.frame, typically obtained from <code>get_phi()</code></p>
</td></tr>
<tr><td><code id="vs_nonmem_+3A_nonmem_phi">nonmem_phi</code></td>
<td>
<p>results of NONMEM estimations, in the form of a tibble data.frame, typically obtained from <code>read_nmphi()</code></p>
</td></tr>
<tr><td><code id="vs_nonmem_+3A_merged_phi">merged_phi</code></td>
<td>
<p>merged results of estimations, typically obtained from <code>merge_phi()</code></p>
</td></tr>
<tr><td><code id="vs_nonmem_+3A_only_eta">only_ETA</code></td>
<td>
<p>filter the data with <code>type=="ETA"</code> (a logical, default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="vs_nonmem_+3A_group">group</code></td>
<td>
<p>one or multiple variables to <code>group_by()</code></p>
</td></tr>
<tr><td><code id="vs_nonmem_+3A_levels">levels</code></td>
<td>
<p>a named vector of length 3 in order to classify the absolute differences. Default cut-offs are 0.1% and 10% in the parameters space.</p>
</td></tr>
<tr><td><code id="vs_nonmem_+3A_summarised_phi">summarised_phi</code></td>
<td>
<p>summarized results of estimations, typically obtained from <code>summarise_phi()</code></p>
</td></tr>
<tr><td><code id="vs_nonmem_+3A_xaxis">xaxis</code></td>
<td>
<p>optional. A character value, that correspond to a variable in data, passed to the x-axis to plot multiple bars side-by-side.</p>
</td></tr>
<tr><td><code id="vs_nonmem_+3A_facet">facet</code></td>
<td>
<p>a formula, that will be passed to <code>ggplot2::facet_wrap()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions were made to easily compare the results of mapbayr to NONMEM. For instance, it could be useful in the case of the transposition of a pre-existing NONMEM model into mapbayr. For this, you need to code your model in both mapbayr and NONMEM, and perform the MAP-Bayesian estimation on the <strong>same dataset</strong>. Ideally, the latter contains a substantial number of patients. NONMEM returns the estimations results into a .phi file.
</p>
<p>Use <code>read_nmphi()</code> to parse the NONMEM .phi file into a convenient tibble data.frame with the columns:
</p>

<ul>
<li> <p><code>SUBJECT_NO</code>, <code>ID</code>: Subject identification.
</p>
</li>
<li> <p><code>ETA1</code>, <code>ETA2</code>, ..., <code>ETAn</code>: Point estimates of eta.
</p>
</li>
<li> <p><code>ETC1_1</code>, <code>ETC2_1</code>, <code>ETC2_2</code>, ...,  <code>ETCn_n</code>: Variance-covariance matrix of estimation.
</p>
</li>
<li> <p><code>OBJ</code>: objective function value
</p>
</li></ul>

<p>Use <code>get_phi()</code> to access to the estimations of mapbayr with the same &quot;phi&quot; format.
</p>
<p>Use <code>merge_phi()</code> to combine mapbayr and NONMEM &quot;phi files&quot; into a single long-form data.frame with the columns:
</p>

<ul>
<li> <p><code>SUBJECT_NO</code>, <code>ID</code>: Subject identification.
</p>
</li>
<li> <p><code>variable</code> name and its <code>type</code>: ETA (point estimate), VARIANCE (on-diagonal element of the matrix), COVARIANCE (off-diagonal), and OBJ.
</p>
</li>
<li> <p><code>mapbayr</code> and <code>nonmem</code>: corresponding values
</p>
</li>
<li> <p><code>adiff</code>: absolute difference between <code>mapbayr</code> and <code>nonmem</code> values.
</p>
</li></ul>

<p>Use <code>plot_phi()</code> to graphically represent <code>adiff</code> <em>vs</em> <code>variable</code>. Alternatively, the table returned by <code>merge_phi()</code> is easy to play with in order to derive performance statistics or the graphical plot of your choice.
</p>
<p>Use <code>summarise_phi()</code> to classify the estimation as &quot;Excellent&quot;, &quot;Acceptable&quot; or &quot;Discordant&quot;, over the whole dataset or by <code>group</code>.
</p>
<p>Use <code>bar_phi()</code> to graphically represent the proportion of the aforementioned classification as bar plot.
</p>


<h3>Value</h3>


<ul>
<li><p> read_nmphi: a tibble data.frame with a format close to the original .phi file
</p>
</li>
<li><p> merge_phi: a long-form tibble data.frame with results of mapbayr and NONMEM
</p>
</li>
<li><p> summarise_phi: a summarized tibble data.frame classifying the performance of mapbayr and NONMEM
</p>
</li>
<li><p> plot_phi, bar_phi: a <code>ggplot2</code> object
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(mapbayr)
nmphi &lt;- read_nmphi(system.file("nm001", "run001.phi", package = "mapbayr"))
mapbayrphi &lt;- get_phi(est001)

merged &lt;- merge_phi(mapbayrphi, nmphi)
plot_phi(merged)

summarised &lt;- summarise_phi(merged)
bar_phi(summarised)


# Analyse the results of multiple runs simultaneously

#Example dataset that represents 3 runs
merge3 &lt;- dplyr::bind_rows(merged, merged, merged, .id = "RUN")
merge3$adiff &lt;- 10 ^ runif(nrow(merge3), -8, 0)

summarised3 &lt;- summarise_phi(merge3, group = RUN)
bar_phi(summarised3, xaxis = "RUN")

</code></pre>

<hr>
<h2 id='x_cmt'>Read compartment options in a model</h2><span id='topic+x_cmt'></span><span id='topic+adm_cmt'></span><span id='topic+obs_cmt'></span>

<h3>Description</h3>

<p>Read compartment options in a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adm_cmt(x)

obs_cmt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_cmt_+3A_x">x</code></td>
<td>
<p>model object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a mrgsolve model, it is possible to specify options in <code style="white-space: pre;">&#8288;$CMT&#8288;</code>. If <code style="white-space: pre;">&#8288;[ADM]&#8288;</code> or <code style="white-space: pre;">&#8288;[OBS]&#8288;</code> are set, mapbayr will interpret these as defaults administration and observation compartments, respectively.
</p>


<h3>Value</h3>

<p>a vector of compartment identified as default &quot;administration&quot; or &quot;observation&quot; compartments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Administration:  Both 1st and 0- order
model &lt;- exmodel(6, compile = FALSE)
mrgsolve::see(model)
adm_cmt(model)

#Observation: Both parent drug and metabolite
model &lt;- exmodel(401, compile = FALSE)
mrgsolve::see(model)
obs_cmt(model)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
