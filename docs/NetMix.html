<!DOCTYPE html><html><head><title>Help for package NetMix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NetMix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#approxB'><p>Internal functions and generics for <code>mmsbm</code> package</p></a></li>
<li><a href='#coef.mmsbm'><p>Extract Regression Coefficients for a Fitted <code>mmsbm</code> Object</p></a></li>
<li><a href='#covFX'><p>Generate estimated monadic covariate effects for estimated mmsbm model</p></a></li>
<li><a href='#gof'><p>Posterior predictive checks using structural network charactericts</p></a></li>
<li><a href='#head.mmsbm'><p>Identify nodes with most frequent membership in latent groups</p></a></li>
<li><a href='#lazega_dyadic'><p>Dyadic predictors in the Lazega friendship network (Lazega 2001).</p></a></li>
<li><a href='#lazega_monadic'><p>Monadic predictors in the Lazega friendship network (Lazega 2001).</p></a></li>
<li><a href='#mmsbm'><p>Dynamic mixed-membership stochastic blockmodel with covariates</p></a></li>
<li><a href='#mmsbm_fit'><p>Fitter Function for dynamic MMSBM Model</p></a></li>
<li><a href='#plot.mmsbm'><p>Various visualization tools for 'mmsbm' objects</p></a></li>
<li><a href='#predict.mmsbm'><p>Predict edges based on estimated mmsbm model</p></a></li>
<li><a href='#simulate.mmsbm'><p>Simulate a complete sociomatrix from an <code>mmsbm</code> object</p></a></li>
<li><a href='#summary.mmsbm'><p>Summarize 'mmsbm' object</p></a></li>
<li><a href='#vcov.mmsbm'><p>Extract Variance-Covariance Matrix for a Fitted <code>mmsbm</code> Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Dynamic Mixed-Membership Network Regression Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-11</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Santiago Olivella [aut, cre],
  Adeline Lo [aut, cre],
	Tyler Pratt [aut, cre],
	Kosuke Imai [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Santiago Olivella &lt;olivella@unc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Stochastic collapsed variational inference on mixed-membership stochastic blockmodel for networks,
             incorporating node-level predictors of mixed-membership vectors, as well as 
             dyad-level predictors. For networks observed over time, the model defines a hidden
             Markov process that allows the effects of node-level predictors to evolve in discrete,
             historical periods. In addition, the package offers a variety of utilities for 
             exploring results of estimation, including tools for conducting posterior 
             predictive checks of goodness-of-fit and several plotting functions. The package 
             implements methods described in Olivella, Pratt and Imai (2019) 'Dynamic Stochastic
             Blockmodel Regression for Social Networks: Application to International Conflicts',
             available at <a href="https://www.santiagoolivella.info/pdfs/socnet.pdf">https://www.santiagoolivella.info/pdfs/socnet.pdf</a>.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/solivella/NetMix/issues">https://github.com/solivella/NetMix/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ergm (&ge; 3.9.4), ggplot2 (&ge; 3.1.1), network (&ge; 1.13),
scales (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>clue (&ge; 0.3-58), graphics (&ge; 3.5.2), grDevices (&ge; 3.5.2),
gtools (&ge; 3.8.1), igraph (&ge; 1.2.4.1), lda (&ge; 1.4.2), Matrix
(&ge; 1.2-15), MASS (&ge; 7.3-51.4), methods (&ge; 3.5.2), poisbinom
(&ge; 1.0.1), Rcpp (&ge; 1.0.2), stats (&ge; 3.5.2), utils (&ge; 3.5.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 04:13:09 UTC; olivella</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-13 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='approxB'>Internal functions and generics for <code>mmsbm</code> package</h2><span id='topic+approxB'></span><span id='topic+getZ'></span><span id='topic+alphaLBound'></span><span id='topic+alphaGrad'></span><span id='topic+auxfuns'></span><span id='topic+.cbind.fill'></span><span id='topic+.scaleVars'></span><span id='topic+.transf_muvar'></span><span id='topic+.bar.legend'></span><span id='topic+.mpower'></span><span id='topic+.findPerm'></span><span id='topic+.transf'></span><span id='topic+.compute.alpha'></span><span id='topic+.vcovBeta'></span><span id='topic+.e.pi'></span><span id='topic+.initPi'></span>

<h3>Description</h3>

<p>These are various utilities and generic methods used by 
the main package function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxB(y, d_id, pi_mat, directed = TRUE)

getZ(pi_mat)

alphaLBound(par, tot_nodes, c_t, x_t, s_mat, t_id, var_beta, mu_beta)

alphaGrad(par, tot_nodes, c_t, x_t, s_mat, t_id, var_beta, mu_beta)

.cbind.fill(...)

.scaleVars(x, keep_const = TRUE)

.transf_muvar(orig, is_var, is_array, des.mat, nblock = NULL, nstate = NULL)

.bar.legend(colPalette, range)

.mpower(mat, p)

.findPerm(block_list, target_mat = NULL, use_perms = TRUE)

.transf(mat)

.compute.alpha(X, beta)

.vcovBeta(
  all_phi,
  beta_coef,
  n.sim,
  n.blk,
  n.hmm,
  n.nodes,
  n.periods,
  mu.beta,
  var.beta,
  est_kappa,
  t_id_n,
  X
)

.e.pi(alpha_list, kappa, C_mat = NULL)

.initPi(
  soc_mats,
  dyads,
  edges,
  nodes_pp,
  dyads_pp,
  n.blocks,
  periods,
  directed,
  ctrl
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approxB_+3A_y">y</code>, <code id="approxB_+3A_d_id">d_id</code>, <code id="approxB_+3A_pi_mat">pi_mat</code>, <code id="approxB_+3A_directed">directed</code></td>
<td>
<p>Internal arguments for blockmodel approximation.</p>
</td></tr>
<tr><td><code id="approxB_+3A_par">par</code></td>
<td>
<p>Vector of parameter values.</p>
</td></tr>
<tr><td><code id="approxB_+3A_tot_nodes">tot_nodes</code></td>
<td>
<p>Integer vector; total number of nodes each node interacts with.</p>
</td></tr>
<tr><td><code id="approxB_+3A_c_t">c_t</code></td>
<td>
<p>Integer matrix; samples from Poisson-Binomial counts of a node instantiating a group.</p>
</td></tr>
<tr><td><code id="approxB_+3A_x_t">x_t</code></td>
<td>
<p>Numeric matrix; transposed monadic design matrices.</p>
</td></tr>
<tr><td><code id="approxB_+3A_s_mat">s_mat</code></td>
<td>
<p>Integer matrix; Samples of HMM states by time period.</p>
</td></tr>
<tr><td><code id="approxB_+3A_t_id">t_id</code></td>
<td>
<p>Integer vector; for each node, what time-period is it observed in? zero-indexed.</p>
</td></tr>
<tr><td><code id="approxB_+3A_mu_beta">mu_beta</code>, <code id="approxB_+3A_var_beta">var_beta</code></td>
<td>
<p>Numeric arrays; prior mean and variances of monadic coefficients.</p>
</td></tr>
<tr><td><code id="approxB_+3A_...">...</code></td>
<td>
<p>Numeric vectors; vectors of potentially different length to be cbind-ed.</p>
</td></tr>
<tr><td><code id="approxB_+3A_x">x</code>, <code id="approxB_+3A_keep_const">keep_const</code></td>
<td>
<p>Internal arguments for matrix scaling.</p>
</td></tr>
<tr><td><code id="approxB_+3A_orig">orig</code></td>
<td>
<p>Object to be transformed.</p>
</td></tr>
<tr><td><code id="approxB_+3A_is_var">is_var</code></td>
<td>
<p>Boolean. Is the object to be transformed a variance term?</p>
</td></tr>
<tr><td><code id="approxB_+3A_is_array">is_array</code></td>
<td>
<p>Boolean. Is the object to be transformed an array?</p>
</td></tr>
<tr><td><code id="approxB_+3A_des.mat">des.mat</code></td>
<td>
<p>Numeric matrix. Design matrix corresponding to transformed object.</p>
</td></tr>
<tr><td><code id="approxB_+3A_nblock">nblock</code></td>
<td>
<p>Number of groups in model, defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="approxB_+3A_nstate">nstate</code></td>
<td>
<p>Number of hidden Markov states in model, defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="approxB_+3A_colpalette">colPalette</code></td>
<td>
<p>A function produced by <code>colorRamp</code>.</p>
</td></tr>
<tr><td><code id="approxB_+3A_range">range</code></td>
<td>
<p>The range of values to label the legend.</p>
</td></tr>
<tr><td><code id="approxB_+3A_mat">mat</code></td>
<td>
<p>Numeric matrix.</p>
</td></tr>
<tr><td><code id="approxB_+3A_p">p</code></td>
<td>
<p>Numeric scalar; power to raise matrix to.</p>
</td></tr>
<tr><td><code id="approxB_+3A_block_list">block_list</code></td>
<td>
<p>List of matrices; each element is a square, numeric matrix 
that defines a blockmodel,</p>
</td></tr>
<tr><td><code id="approxB_+3A_target_mat">target_mat</code></td>
<td>
<p>Numeric matrix; reference blockmodel that those in block_list should 
be aligned to. Optional, defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="approxB_+3A_use_perms">use_perms</code></td>
<td>
<p>Boolean; should all row/column permutations be explored when
realigning matrices? defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="approxB_+3A_x">X</code></td>
<td>
<p>Numeric matrix; design matrix of monadic predictors.</p>
</td></tr>
<tr><td><code id="approxB_+3A_beta">beta</code></td>
<td>
<p>Numeric array; array of coefficients associated with monadic predictors. 
It of dimensions Nr. Predictors by Nr. of Blocks by Nr. of HMM states.</p>
</td></tr>
<tr><td><code id="approxB_+3A_all_phi">all_phi</code>, <code id="approxB_+3A_beta_coef">beta_coef</code>, <code id="approxB_+3A_n.sim">n.sim</code>, <code id="approxB_+3A_n.blk">n.blk</code>, <code id="approxB_+3A_n.hmm">n.hmm</code>, <code id="approxB_+3A_n.nodes">n.nodes</code>, <code id="approxB_+3A_n.periods">n.periods</code>, <code id="approxB_+3A_mu.beta">mu.beta</code>, <code id="approxB_+3A_var.beta">var.beta</code>, <code id="approxB_+3A_est_kappa">est_kappa</code>, <code id="approxB_+3A_t_id_n">t_id_n</code></td>
<td>
<p>Additional internal arguments for covariance estimation.</p>
</td></tr>
<tr><td><code id="approxB_+3A_alpha_list">alpha_list</code></td>
<td>
<p>List of mixed-membership parameter matrices.</p>
</td></tr>
<tr><td><code id="approxB_+3A_kappa">kappa</code></td>
<td>
<p>Numeric matrix; matrix of marginal HMM state probabilities.</p>
</td></tr>
<tr><td><code id="approxB_+3A_c_mat">C_mat</code></td>
<td>
<p>Numeric matrix; matrix of posterior counts of block instantiations per node.</p>
</td></tr>
<tr><td><code id="approxB_+3A_soc_mats">soc_mats</code>, <code id="approxB_+3A_dyads">dyads</code>, <code id="approxB_+3A_edges">edges</code>, <code id="approxB_+3A_nodes_pp">nodes_pp</code>, <code id="approxB_+3A_dyads_pp">dyads_pp</code>, <code id="approxB_+3A_n.blocks">n.blocks</code>, <code id="approxB_+3A_periods">periods</code>, <code id="approxB_+3A_ctrl">ctrl</code></td>
<td>
<p>Internal arguments for MM computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are meant for internal use only.
</p>


<h3>Value</h3>

<p>See individual return section for each function:
</p>

<dl>
<dt>.cbind.fill</dt><dd><p>Matrix of <code>cbind</code>'ed elements in <code>...</code>, with missing values in each vector filled with <code>NA</code>.</p>
</dd>
<dt>.mpower</dt><dd><p>Matrix; the result of raising <code>mat</code> to the <code>p</code> power.</p>
</dd>
<dt>.findPerm</dt><dd><p>List of permuted blockmodel matrices.</p>
</dd>
<dt>.transf</dt><dd><p>Matrix with transformed mixed-membership vectors along its rows, s.t. no element is equal to 0.0 or 1.0.</p>
</dd>
<dt>.compute.alpha</dt><dd><p>List of predicted alpha matrices, one element per HMM state.</p>
</dd>
<dt>.e.pi</dt><dd><p>Matrix of predicted mixed-membership vectors along its rows, with expectation computed over marginal 
distribution over HMM states for each time period.</p>
</dd>
<dt>.missing</dt><dd><p>Transformed data.frame with missing values list-wise deleted, or expanded
with missing indicator variables.</p>
</dd>
<dt>.createSocioB</dt><dd><p>List of sociomatrices.</p>
</dd>
<dt>.vertboot2</dt><dd><p>List of bootstrapped sociomatrices.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Santiago Olivella (olivella@unc.edu), Adeline Lo (aylo@wisc.edu), Tyler Pratt (tyler.pratt@yale.edu), Kosuke Imai (imai@harvard.edu)
</p>

<hr>
<h2 id='coef.mmsbm'>Extract Regression Coefficients for a Fitted <code>mmsbm</code> Object</h2><span id='topic+coef.mmsbm'></span>

<h3>Description</h3>

<p>Extract Regression Coefficients for a Fitted <code>mmsbm</code> Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmsbm'
coef(object, param = "All", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.mmsbm_+3A_object">object</code></td>
<td>
<p>An object of class <code>mmsbm</code>, a result of a call to <code>mmsbm</code></p>
</td></tr>
<tr><td><code id="coef.mmsbm_+3A_param">param</code></td>
<td>
<p>Character string, which set of parameters should the vcov be extracted for? One
of <code>"MonadCoef"</code>, <code>"DyadCoef"</code> or <code>"All"</code> (the default).</p>
</td></tr>
<tr><td><code id="coef.mmsbm_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>param="DyadCoef"</code>, a numeric vector. For <code>param="MonadCoef"</code>, an array
with HMM states along the third dimension. For <code>param="All"</code>, named list of individual return components.
</p>


<h3>Author(s)</h3>

<p>Santiago Olivella (olivella@unc.edu), Adeline Lo (aylo@wisc.edu), Tyler Pratt (tyler.pratt@yale.edu), Kosuke Imai (imai@harvard.edu)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(NetMix)
## Load datasets
data("lazega_dyadic")
data("lazega_monadic")
## Estimate model with 2 groups
lazega_mmsbm &lt;- mmsbm(SocializeWith ~ Coworkers,
                      ~  School,
                      senderID = "Lawyer1",
                      receiverID = "Lawyer2",
                      nodeID = "Lawyer",
                      data.dyad = lazega_dyadic,
                      data.monad = lazega_monadic,
                      n.blocks = 2,
                      mmsbm.control = list(seed = 123,
                                           conv_tol = 1e-2,
                                           hessian = FALSE))

coef(lazega_mmsbm, "MonadCoef")

</code></pre>

<hr>
<h2 id='covFX'>Generate estimated monadic covariate effects for estimated mmsbm model</h2><span id='topic+covFX'></span>

<h3>Description</h3>

<p>The function estimates the effect of a shift in monadic covariate values on the probability of edge formation in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covFX(fm, cov, shift, max.val = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covFX_+3A_fm">fm</code></td>
<td>
<p>An object of class <code>mmsbm</code>, a result of a call to <code>mmsbm</code>.</p>
</td></tr>
<tr><td><code id="covFX_+3A_cov">cov</code></td>
<td>
<p>Character string identifying the monadic covariate to be shifted.</p>
</td></tr>
<tr><td><code id="covFX_+3A_shift">shift</code></td>
<td>
<p>Numeric value specifying the desired increase or decrease in the monadic covariate.  The monadic predictor will be shifted by this value for all nodes and time periods.</p>
</td></tr>
<tr><td><code id="covFX_+3A_max.val">max.val</code></td>
<td>
<p>An optional numeric value specifying the maximum possible value for the monadic covariate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with named components:
</p>

<dl>
<dt>Overall Avg. Effect</dt><dd><p>Overall average effect of the covariate shift on the predicted probability of edge formation.</p>
</dd>
<dt>Avg. Effect by Time</dt><dd><p>Vector of average effects of the covariate shift on the predicted probability of edge formation for each time period.</p>
</dd>
<dt>Avg. Effect by Node</dt><dd><p>Vector of average effects of the covariate shift on the predicted probability of edge formation for each node.</p>
</dd>
<dt>Avg. Effect by Dyad</dt><dd><p>Vector of average effects of the covariate shift on the predicted probability of edge formation for each node dyad.</p>
</dd>
<dt>Avg. Effect Dyad-Time</dt><dd><p>Vector of estimated effects of the covariate shift on the predicted probability of edge formation for each node dyad-time unit.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Santiago Olivella (olivella@unc.edu), Adeline Lo (aylo@wisc.edu), Tyler Pratt (tyler.pratt@yale.edu), Kosuke Imai (imai@harvard.edu)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(NetMix)
## Load datasets
data("lazega_dyadic")
data("lazega_monadic")
## Estimate model with 2 groups
lazega_mmsbm &lt;- mmsbm(SocializeWith ~ Coworkers,
                      ~  Age,
                      senderID = "Lawyer1",
                      receiverID = "Lawyer2",
                      nodeID = "Lawyer",
                      data.dyad = lazega_dyadic,
                      data.monad = lazega_monadic,
                      n.blocks = 2,
                      mmsbm.control = list(seed = 123, 
                                           conv_tol = 1e-2, 
                                           hessian = FALSE))

## Compute effect of decreasing every lawyers' age by 10 years
fx_list &lt;- covFX(lazega_mmsbm, cov = "Age", shift = -10)
fx_list[["Overall Avg. Effect of Age"]]

</code></pre>

<hr>
<h2 id='gof'>Posterior predictive checks using structural network charactericts</h2><span id='topic+gof'></span><span id='topic+gof.mmsbm'></span>

<h3>Description</h3>

<p>The function generates a variety of plots that serve as posterior predictive checks on the goodness of fit of a fitted <code>mmsbm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(x, ...)

## S3 method for class 'mmsbm'
gof(
  x,
  gof_stat = c("Geodesics", "Degree"),
  level = 0.95,
  samples = 50,
  new.data.dyad = NULL,
  new.data.monad = NULL,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_+3A_x">x</code></td>
<td>
<p>An object of class <code>mmsbm</code>, a result of a call to <code>mmsbm</code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="gof_+3A_gof_stat">gof_stat</code></td>
<td>
<p>Character vector. Accepts any subset from &quot;Geodesics&quot;,&quot;Degree&quot;, &quot;Indegree&quot;, &quot;Outdegree&quot;, &quot;3-Motifs&quot;,
&quot;Dyad Shared Partners&quot;, &quot;Edge Shared Partners&quot;, and &quot;Incoming K-stars&quot;. See details.</p>
</td></tr>
<tr><td><code id="gof_+3A_level">level</code></td>
<td>
<p>Double. Level of credible interval for posterior predictive distribution around structural quantities of interest.</p>
</td></tr>
<tr><td><code id="gof_+3A_samples">samples</code></td>
<td>
<p>Integer. Number of sampled networks from model's posterior predictive using <code><a href="#topic+simulate.mmsbm">simulate.mmsbm</a></code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_new.data.dyad">new.data.dyad</code></td>
<td>
<p>See <code><a href="#topic+simulate.mmsbm">simulate.mmsbm</a></code>. Enables out-of-sample checking.</p>
</td></tr>
<tr><td><code id="gof_+3A_new.data.monad">new.data.monad</code></td>
<td>
<p>See <code><a href="#topic+simulate.mmsbm">simulate.mmsbm</a></code>. Enables out-of-sample checking.</p>
</td></tr>
<tr><td><code id="gof_+3A_seed">seed</code></td>
<td>
<p>See <code><a href="#topic+simulate.mmsbm">simulate.mmsbm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Goodness of fit of network models has typically been established by evaluating how the structural characteristics of predicted networks 
compare to those of the observed network. When estimated in a Bayesian framework, this approach is equivalent to 
conducting posterior preditive checks on these structural quantities of interest. When <code>new.data.dyad</code> and/or <code>new.data.monad</code> are
passed that are different from those used in estimation, this is equivalent to conducting posterior predictive checks out-of-sample. 
</p>
<p>The set of structural features used to determine goodness of fit is somewhat arbitrary, and chosen mostly to incorporate various 
first order, second order, and (to the extent possible) third-order characteristics of the network. &quot;Geodesics&quot; focuses on the distribution over 
observed and predicted geodesic distances between nodes; &quot;Indegree&quot; and &quot;Outdegree&quot; focuses on the distribution over incoming and outgoing connections 
per node; &quot;3-motifs&quot; focus on a distribution over possible connectivity patterns between triads (i.e. the triadic census); &quot;Dyad Shared Partners&quot; focuses on the distribution
over the number of shared partners between any two dayds; &quot;Edge Shared Partners&quot; is similarly defined, but w.r.t. edges, rather than dyads; and finally
&quot;Incoming K-stars&quot; focuses on a frequency distribution over stars with k=1,... spokes. 
</p>
<p>Obtaining samples of the last three structural features can be very computationally expensive, and is discouraged on networks with more than 50
nodes.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Author(s)</h3>

<p>Santiago Olivella (olivella@unc.edu), Adeline Lo (aylo@wisc.edu), Tyler Pratt (tyler.pratt@yale.edu), Kosuke Imai (imai@harvard.edu)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(NetMix)
## Load datasets
data("lazega_dyadic")
data("lazega_monadic")

## Estimate model with 2 groups
lazega_mmsbm &lt;- mmsbm(SocializeWith ~ Coworkers,
                      senderID = "Lawyer1",
                      receiverID = "Lawyer2",
                      nodeID = "Lawyer",
                      data.dyad = lazega_dyadic,
                      data.monad = lazega_monadic,
                      n.blocks = 2,
                      mmsbm.control = list(seed = 123,
                                           conv_tol = 1e-2,
                                           hessian = FALSE))

## Plot observed (red) and simulated (gray) distributions over 
## indegrees
## (typically a larger number of samples would be taken) 
## (strictly requires ggplot2)


gof(lazega_mmsbm, gof_stat = "Indegree", samples = 2)


</code></pre>

<hr>
<h2 id='head.mmsbm'>Identify nodes with most frequent membership in latent groups</h2><span id='topic+head.mmsbm'></span>

<h3>Description</h3>

<p>The function lists the nodes (optionally, node-time periods) that most frequently instantiate membership in each latent group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmsbm'
head(x, n = 6, t = NULL, node = TRUE, t.correct = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head.mmsbm_+3A_x">x</code></td>
<td>
<p>An object of class <code>mmsbm</code>, a result of a call to <code>mmsbm</code>.</p>
</td></tr>
<tr><td><code id="head.mmsbm_+3A_n">n</code></td>
<td>
<p>Numeric or integer; specifies how many units will be identified for each group.</p>
</td></tr>
<tr><td><code id="head.mmsbm_+3A_t">t</code></td>
<td>
<p>Optional vector of time periods to be used for assessing latent group membership.</p>
</td></tr>
<tr><td><code id="head.mmsbm_+3A_node">node</code></td>
<td>
<p>Logical; indicates whether latent group memberships should be averaged at the node level.  If FALSE, the function returns the node-time period units with highest estimated membership in each latent group.</p>
</td></tr>
<tr><td><code id="head.mmsbm_+3A_t.correct">t.correct</code></td>
<td>
<p>Logical; indicates whether latent group memberships should be corrected for temporal trends.  If TRUE, the function returns the node-time period units with highest estimated membership in each latent group.</p>
</td></tr>
<tr><td><code id="head.mmsbm_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length <code>n.blocks</code>.  Each entry contains a sorted vector of average latent membership probabilities of length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Santiago Olivella (olivella@unc.edu), Adeline Lo (aylo@wisc.edu), Tyler Pratt (tyler.pratt@yale.edu), Kosuke Imai (imai@harvard.edu)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(NetMix)
## Load datasets
data("lazega_dyadic")
data("lazega_monadic")
## Estimate model with 2 groups
set.seed(123)
lazega_mmsbm &lt;- mmsbm(SocializeWith ~ Coworkers,
                      ~  School + Practice + Status,
                      senderID = "Lawyer1",
                      receiverID = "Lawyer2",
                      nodeID = "Lawyer",
                      data.dyad = lazega_dyadic,
                      data.monad = lazega_monadic,
                      n.blocks = 2,
                      mmsbm.control = list(seed = 123,
                                           conv_tol = 1e-2,
                                           hessian = FALSE))

## Show top 6 lawyers in each estimated latent block
head(lazega_mmsbm)

</code></pre>

<hr>
<h2 id='lazega_dyadic'>Dyadic predictors in the Lazega friendship network (Lazega 2001).</h2><span id='topic+lazega_dyadic'></span>

<h3>Description</h3>

<p>A dataset containing edges and dyad-level predictors in the network
of friendships among lawyers in a New England law firm. More 
details are available in Lazega (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lazega_dyadic)
</code></pre>


<h3>Format</h3>

<p>A data frame with 5041 rows and 4 variables:
</p>

<dl>
<dt>Lawyer1, Lawyer2</dt><dd><p>lawyer ID, corresponding to identifiers common
to those in <code>lazega_monadic</code>; numeric</p>
</dd>
<dt>SocializeWith</dt><dd><p>value of edge in network; binary</p>
</dd>
<dt>Coworkers</dt><dd><p>are the corresponding lawyers in the same office? boolean</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/Z-co/networkdata/blob/master/networkdata/data/lazega.rda">https://github.com/Z-co/networkdata/blob/master/networkdata/data/lazega.rda</a>
</p>


<h3>References</h3>

<p>Emmanuel Lazega, <em>The Collegial Phenomenon: The Social Mechanisms of Cooperation Among Peers in a Corporate Law Partnership</em>, Oxford University Press (2001).
</p>

<hr>
<h2 id='lazega_monadic'>Monadic predictors in the Lazega friendship network (Lazega 2001).</h2><span id='topic+lazega_monadic'></span>

<h3>Description</h3>

<p>A dataset containing vertex-level predictors in the network
of sought-after advise among lawyers in a New England law firm. More 
details are available in Lazega (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lazega_monadic)
</code></pre>


<h3>Format</h3>

<p>A data frame with 71 rows and 7 variables:
</p>

<dl>
<dt>Lawyer</dt><dd><p>lawyer ID,corresponding to identifiers common
to those in <code>lazega_dyadic</code>; numeric</p>
</dd>
<dt>Age</dt><dd><p>age, in years; numeric</p>
</dd>
<dt>Gender</dt><dd><p>1=man; 2=woman; factor</p>
</dd>
<dt>School</dt><dd><p>1=harvard, yale; 2=ucon; 3= other; factor</p>
</dd>
<dt>Practice</dt><dd><p>1=litigation; 2=corporate; factor</p>
</dd>
<dt>Seniority</dt><dd><p>time in the firm, in years; numeric</p>
</dd>
<dt>Status</dt><dd><p>1=partner; 2=associate; factor</p>
</dd>
</dl>



<h3>Source</h3>

<p>Emmanuel Lazega, <em>The Collegial Phenomenon: The Social Mechanisms of Cooperation Among Peers in a Corporate Law Partnership</em>, Oxford University Press (2001).
</p>
<p><a href="https://github.com/Z-co/networkdata/blob/master/networkdata/data/lazega.rda">https://github.com/Z-co/networkdata/blob/master/networkdata/data/lazega.rda</a>
</p>

<hr>
<h2 id='mmsbm'>Dynamic mixed-membership stochastic blockmodel with covariates</h2><span id='topic+mmsbm'></span>

<h3>Description</h3>

<p>The function estimates a dynamic mixed-membership stochastic
blockmodel that incorporates covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmsbm(
  formula.dyad,
  formula.monad = ~1,
  senderID,
  receiverID,
  nodeID = NULL,
  timeID = NULL,
  data.dyad,
  data.monad = NULL,
  n.blocks,
  n.hmmstates = 1,
  directed = TRUE,
  mmsbm.control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmsbm_+3A_formula.dyad">formula.dyad</code></td>
<td>
<p>A <code>formula</code> object. The variable in <code>data.dyad</code> that contains 
binary edges should be used as a LHS, and any dyadic predictors 
can be included on the RHS (when no dyadic covariates are available, use <code>y ~ 1</code>).
Same syntax as a <code>glm</code> formula.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_formula.monad">formula.monad</code></td>
<td>
<p>An optional <code>formula</code> object. LHS is ignored. RHS contains 
names of nodal atrributes found in <code>data.monad</code>.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_senderid">senderID</code></td>
<td>
<p>Character string. Quoted name of the variable in <code>data.dyad</code> identifying 
the sender node. For undirected networks, the variable simply contains name of first node 
in dyad. Cannot contain special charecter &quot;'@'&quot;.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_receiverid">receiverID</code></td>
<td>
<p>Character string. Quoted name of the variable in <code>data.dyad</code> identifying 
the receiver node. For undirected networks, the variable simply contains name of second node 
in dyad. Cannot contain special charecter &quot;'@'&quot;.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_nodeid">nodeID</code></td>
<td>
<p>Character string. Quoted name of the variable in <code>data.monad</code> identifying 
a node in either <code>data.dyad[,senderID]</code> or <code>data.dyad[,senderID]</code>. If not <code>NULL</code>,
every node <code>data.dyad[,senderID]</code> or <code>data.dyad[,senderID]</code> must be present in 
<code>data.monad[,nodeID]</code>. Cannot contain special charecter &quot;'@'&quot;.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_timeid">timeID</code></td>
<td>
<p>Character string. Quoted name of the variable in both <code>data.dyad</code> and
<code>data.monad</code> indicating the time in which network (and correspding nodal atrributes)
were observed. The variable itself must be composed of integers. Cannot contain special charecter &quot;'@'&quot;.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_data.dyad">data.dyad</code></td>
<td>
<p>Data frame. Sociomatrix in &ldquo;long&rdquo; (i.e. dyadic) format. Must contain at
least three variables: the sender identifier (or identifier of the first node in an undirected networks dyad),
the receiver identifier (or identifier of the second node in an undirected network dyad), and the value
of the edge between them. Currently, only edges between zero and one (inclusive) are supported.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_data.monad">data.monad</code></td>
<td>
<p>Data frame. Nodal atributes. Must contain a node identifier matching the names of nodes
used in the <code>data.dyad</code> data frame.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_n.blocks">n.blocks</code></td>
<td>
<p>Integer value. How many latent groups should be used to estimate the model?</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_n.hmmstates">n.hmmstates</code></td>
<td>
<p>Integer value. How many hidden Markov state should be used in the HMM? Defaults 
to 1 (i.e. no HMM).</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_directed">directed</code></td>
<td>
<p>Boolean. Is the network directed? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_mmsbm.control">mmsbm.control</code></td>
<td>
<p>A named list of optional algorithm control parameters.
</p>

<dl>
<dt>seed</dt><dd><p>Integer. Seed the RNG. By default, a random seed is generated and returned for reproducibility purposes.</p>
</dd>
<dt>nstart</dt><dd><p>Integer. Number of random initialization trials. Defaults to 5.</p>
</dd>
<dt>spectral</dt><dd><p>Boolean. Type of initialization algorithm for mixed-membership vectors in static case. If <code>TRUE</code> (default),
use spectral clustering with degree correction; otherwise, use kmeans algorithm.</p>
</dd>
<dt>init_gibbs</dt><dd><p>Boolean. Should a collapsed Gibbs sampler of non-regression mmsbm be used to initialize
mixed-membership vectors, instead of a spectral or simple kmeans initialization?
Setting to <code>TRUE</code> will result in slower initialization and faster model estimation. When <code>TRUE</code>, results are typically very sensitive to
choice of alpha (see below).</p>
</dd>            
<dt>alpha</dt><dd><p>Numeric positive value. Concentration parameter for collapsed Gibbs sampler to find initial
mixed-membership values when <code>init_gibbs=TRUE</code>. Defaults to 1.0.</p>
</dd>            
<dt>missing</dt><dd><p>Means of handling missing data. One of &quot;indicator method&quot; (default) or &quot;listwise deletion&quot;.</p>
</dd>  
<dt>svi</dt><dd><p>Boolean; should stochastic variational inference be used? Defaults to <code>TRUE</code>.</p>
</dd>     
<dt>vi_iter</dt><dd><p>Number of maximum iterations in stochastic variational updates. Defaults to 5e2.</p>
</dd>
<dt>batch_size</dt><dd><p>When <code>svi=TRUE</code>, proportion of nodes sampled in each local. Defaults to 0.05 when <code>svi=TRUE</code>, and to 1.0 otherwise.</p>
</dd>                                 
<dt>forget_rate</dt><dd><p>When <code>svi=TRUE</code>, value between (0.5,1], controlling speed of decay of weight of prior
parameter values in global steps. Defaults to 0.75 when <code>svi=TRUE</code>, and to 0.0 otherwise.</p>
</dd>
<dt>delay</dt><dd><p>When <code>svi=TRUE</code>, non-negative value controlling weight of past iterations in global steps. Defaults to 1.0 when <code>svi=TRUE</code>,
and ignored otherwise.</p>
</dd>                    
<dt>opt_iter</dt><dd><p>Number of maximum iterations of BFGS in global step. Defaults to 10e3.</p>
</dd>
<dt>hessian</dt><dd><p>Boolean indicating whether the Hessian matrix of regression coefficients should e returned. Defaults to <code>TRUE</code>.</p>
</dd>
<dt>assortative</dt><dd><p>Boolean indicating whether blockmodel should be assortative (i.e. stronger connections within groups) or disassortative
(i.e. stronger connections between groups). Defaults to <code>TRUE</code>.</p>
</dd>
<dt>mu_block</dt><dd><p>Numeric vector with two elements: prior mean of blockmodel's main diagonal elements, and
and prior mean of blockmodel's offdiagonal elements. Defaults to <code>c(5.0, -5.0)</code> if <code>assortative=TRUE</code> (default)
and to <code>c(-5.0, 5.0)</code> otherwise.</p>
</dd>
<dt>var_block</dt><dd><p>Numeric vector with two positive elements: prior variance of blockmodel's main diagonal elements, and
and prior variance of blockmodel's offdiagonal elements. Defaults to <code>c(5.0, 5.0)</code>.</p>
</dd>
<dt>mu_beta</dt><dd><p>Either single numeric value, in which case the same prior mean is applied to all monadic coefficients, or
an array that is <code>npredictors</code> by <code>n.blocks</code> by <code>n.hmmstates</code>, where <code>npredictors</code>
is the number of monadic predictors for which a prior mean is being set (prior means need not be set for all)
predictors). The rows in the array should be named to identify which variables a prior mean is being set for.
Defaults to a common prior mean of 0.0 for all monadic coefficients.</p>
</dd>            
<dt>var_beta</dt><dd><p>See <code>mu_beta</code>. Defaults to a single common prior variance of 5.0 for all (standardized) monadic coefficients.</p>
</dd>
<dt>mu_gamma</dt><dd><p>Either a single numeric value, in which case the same prior mean is applied to all dyadic coefficients, or
a named vector of numeric values (with names corresponding to the name of the variable 
for which a prior mean is being set). Defaults to a common prior mean of 0.0 for all dyadic coefficients.</p>
</dd>
<dt>var_gamma</dt><dd><p>See <code>mu_gamma</code>. Defaults to a single common prior variance of 5.0 for all (standardized) dyadic coefficients.</p>
</dd>
<dt>eta</dt><dd><p>Numeric positive value. Concentration hyper-parameter for HMM. Defaults to 1.0.</p>
</dd>
<dt>se_sim</dt><dd><p>Number of samples from variational posterior of latent variables on which approximation to variance-covariance
matrices are based. Defaults to 10.</p>
</dd>
<dt>dyad_vcov_samp</dt><dd><p>Maximum number of dyads to sample in computation of variance-covariance of dyadic and blockmodel parameters, when compared to 
ten percent of the observed dyads. Defaults to 1000.</p>
</dd>
<dt>fixed_mm</dt><dd><p>Optional character vector, with <code>"nodeID@timeID"</code> as elements, indicating which mixed-membership vectors
should remain constant at their initial values throughout estimation. When only one year is observed, elements should be 
<code>"nodeID@1"</code>. Typically used with <code>mm_init_t</code>.</p>
</dd>                      
<dt>mm_init_t</dt><dd><p>Matrix, <code>n.blocks</code> by nodes across years. Optional initial values for mixed-membership vectors.
Although initial values need not be provided for all nodes, column names must have a <code>nodeID@timeID</code> format to 
avoid ambiguity. When only one year is observed, names should be <code>"nodeID@1"</code>.</p>
</dd>
<dt>kappa_init_t</dt><dd><p>Matrix, <code>n.hmmstates</code> by number of years. Optional initial values for variational 
parameters for state probabilities. Columns must be named according to unique year values.</p>
</dd>
<dt>b_init_t</dt><dd><p>Matrix, <code>n.blocks</code> by <code>n.blocks</code>. Optional initial values for blockmodel.</p>
</dd>
<dt>beta_init</dt><dd><p>Array, <code>predictors</code> by <code>n.blocks</code> by <code>n.hmmstates</code>. Optional initial values for monadic coefficients. If </p>
</dd>
<dt>gamma_init</dt><dd><p>Vector. Optional initial values for dyadic coefficients.</p>
</dd>
<dt>permute</dt><dd><p>Boolean. Should all permutations be tested to realign initial block models in dynamic case? If <code>FALSE</code>, realignment is 
done via faster graph matching algorithm, but may not be exact. Defaults to <code>TRUE</code>.</p>
</dd>
<dt>conv_tol</dt><dd><p>Numeric value. Absolute tolerance for VI convergence. Defaults to 1e-3.</p>
</dd>
<dt>verbose</dt><dd><p>Boolean. Should extra information be printed as model iterates? Defaults to FALSE.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>mmsbm</code>. List with named components:
</p>

<dl>
<dt>MixedMembership</dt><dd><p>Matrix of variational posterior of mean of mixed-membership vectors. <code>nodes</code> by
<code>n.blocks</code>.</p>
</dd>
<dt>BlockModel</dt><dd><p><code>n.blocks</code> by <code>n.blocks</code> matrix of estimated tie log-odds between members
of corresponding latent groups. The blockmodel.</p>
</dd>
<dt>vcov_blockmodel</dt><dd><p>If <code>hessian=TRUE</code>, variance-covariance matrix of parameters in blockmodel, ordered in column-major order.</p>
</dd>
<dt>MonadCoef</dt><dd><p>Array of estimated coefficient values for monadic covariates. Has <code>n.blocks</code> columns,
and <code>n.hmmstates</code> slices.</p>
</dd>
<dt>vcov_monad</dt><dd><p>If <code>hessian=TRUE</code>, variance-covariance matrix of monadic coefficients.</p>
</dd>                  
<dt>DyadCoef</dt><dd><p>Vector estimated coefficient values for dyadic covariates.</p>
</dd>
<dt>vcov_dyad</dt><dd><p>If <code>hessian=TRUE</code>, variance-covariance matrix of dyadic coefficients.</p>
</dd>
<dt>TransitionKernel</dt><dd><p>Matrix of estimated HMM transition probabilities.</p>
</dd>
<dt>Kappa</dt><dd><p>Matrix of marginal probabilities of being in an HMM state at any given point in time. 
<code>n.hmmstates</code> by years (or whatever time interval networks are observed at).</p>
</dd>
<dt>LowerBound</dt><dd><p>Final LB value</p>
</dd>
<dt>lb</dt><dd><p>Vector of all LB across iterations, useful to check early convergence issues.</p>
</dd>              
<dt>niter</dt><dd><p>Final number of VI iterations.</p>
</dd>
<dt>converged</dt><dd><p>Convergence indicator; zero indicates failure to converge.</p>
</dd>
<dt>NodeIndex</dt><dd><p>Order in which nodes are stored in all return objects.</p>
</dd>
<dt>monadic.data, dyadic.data</dt><dd><p>Model frames used during estimation (stripped of attributes).</p>
</dd>
<dt>forms</dt><dd><p>Values of selected formal arguments used by other methods.</p>
</dd>
<dt>seed</dt><dd><p>The value of RNG seed used during estimation.</p>
</dd>
<dt>call</dt><dd><p>Original (unevaluated) function call.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Santiago Olivella (olivella@unc.edu), Adeline Lo (aylo@wisc.edu), Tyler Pratt (tyler.pratt@yale.edu), Kosuke Imai (imai@harvard.edu)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(NetMix)
## Load datasets
data("lazega_dyadic")
data("lazega_monadic")
## Estimate model with 2 groups
## Setting to `hessian=TRUE` increases computation time
## but is needed if standard errors are to be computed. 
lazega_mmsbm &lt;- mmsbm(SocializeWith ~ Coworkers,
                      ~  School + Practice + Status,
                      senderID = "Lawyer1",
                      receiverID = "Lawyer2",
                      nodeID = "Lawyer",
                      data.dyad = lazega_dyadic,
                      data.monad = lazega_monadic,
                      n.blocks = 2,
                      mmsbm.control = list(seed = 123,
                                           conv_tol = 1e-2,
                                           hessian = FALSE))

</code></pre>

<hr>
<h2 id='mmsbm_fit'>Fitter Function for dynamic MMSBM Model</h2><span id='topic+mmsbm_fit'></span>

<h3>Description</h3>

<p>This is the interface to the C++ fitter for the dynamic mixed-membership
stochastic blockmodel for network regression.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmsbm_fit_+3A_z_t">z_t</code></td>
<td>
<p>Numeric matrix; transpose of monadic design matrix. Should not include intercept row.</p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_x_t">x_t</code></td>
<td>
<p>Numeric matrix; transpose of dyadic design matrix.</p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_y">y</code></td>
<td>
<p>Numeric vector; vector of edge values. Must have same number of elements as <code>ncol(x_t)</code></p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_time_id_dyad">time_id_dyad</code></td>
<td>
<p>Integer vector; zero-based time-period identifier for each node.</p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_nodes_per_period">nodes_per_period</code></td>
<td>
<p>Integer vector; total number of unique nodes observed in each time period.</p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_node_id_dyad">node_id_dyad</code></td>
<td>
<p>Integer matrix; zero-based sender and receiver identifier per dyad.</p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_mu_b">mu_b</code></td>
<td>
<p>Numeric matrix; matrix of prior means for elements in blockmodel matrix.</p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_var_b">var_b</code></td>
<td>
<p>Numeric matrix; matrix of prior variances for elements in blockmodel matrix.</p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_pi_init">pi_init</code></td>
<td>
<p>Numeric matrix; matrix of initial mixed-memberships. Nodes along columns.</p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_kappa_init_t">kappa_init_t</code></td>
<td>
<p>Numeric matrix; matrix of initial marginal HMM state probabilities. Time-periods along columns.</p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_b_init_t">b_init_t</code></td>
<td>
<p>Numeric matrix; square matrix of initial values of blockmodel.</p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_beta_init">beta_init</code></td>
<td>
<p>Numeric vector; flat array (column-major order) of initial values of monadic coefficients.</p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_gamma_init">gamma_init</code></td>
<td>
<p>Numeric vector; vector of initial values of dyadic coefficients</p>
</td></tr>
<tr><td><code id="mmsbm_fit_+3A_control">control</code></td>
<td>
<p>List; see the <code>mmsbm.control</code> argument of <code><a href="#topic+mmsbm">mmsbm</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Unclassed list with named components; see <code>Value</code> of <code><a href="#topic+mmsbm">mmsbm</a></code>
</p>


<h3>Warning</h3>

<p>This function is for internal use only. End-users should always resort to <code><a href="#topic+mmsbm">mmsbm</a></code>.
In particular, that interface post-processes the return value of this internal in important ways.
</p>


<h3>Author(s)</h3>

<p>Santiago Olivella (olivella@unc.edu), Adeline Lo (adelinel@princeton.edu), Tyler Pratt (tyler.pratt@yale.edu), Kosuke Imai (imai@harvard.edu)
</p>

<hr>
<h2 id='plot.mmsbm'>Various visualization tools for 'mmsbm' objects</h2><span id='topic+plot.mmsbm'></span>

<h3>Description</h3>

<p>The function provides a variety of plotting options for a fitted <code>mmsbm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmsbm'
plot(x, type = "groups", FX = NULL, node = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mmsbm_+3A_x">x</code></td>
<td>
<p>An object of class <code>mmsbm</code>, a result of a call to <code>mmsbm</code>.</p>
</td></tr>
<tr><td><code id="plot.mmsbm_+3A_type">type</code></td>
<td>
<p>character string denoting the type of plot. The default, &quot;<code>groups</code>,&quot; plots the estimated matrix of 
group by group edge formation probabilities as a network plot, with nodes representing groups (sized proportional to relative membership) 
and edge colors encoding probability of between-group ties. &quot;<code>blockmodel</code>&quot; plots the same information,
but using a tile plot instead of a network plot.  &quot;<code>membership</code>&quot; plots average membership in
each latent group by time period. &quot;<code>effect</code>&quot; provides a series of plots showing the estimated effect 
of a shfit in monadic covariate values.</p>
</td></tr>
<tr><td><code id="plot.mmsbm_+3A_fx">FX</code></td>
<td>
<p>with <code>type == "effect"</code>; a list resulting from a call to <code>covFX</code>.</p>
</td></tr>
<tr><td><code id="plot.mmsbm_+3A_node">node</code></td>
<td>
<p>with <code>type == "membership"</code>; a character string specifying the node for which group membership should be plotted.</p>
</td></tr>
<tr><td><code id="plot.mmsbm_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The requested plot object.
</p>


<h3>Author(s)</h3>

<p>Santiago Olivella (olivella@unc.edu), Adeline Lo (aaylo@wisc.edu), Tyler Pratt (tyler.pratt@yale.edu), Kosuke Imai (imai@harvard.edu)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(NetMix)
## Load datasets
data("lazega_dyadic")
data("lazega_monadic")
## Estimate model with 2 groups
lazega_mmsbm &lt;- mmsbm(SocializeWith ~ Coworkers,
                      ~  School + Practice + Status,
                      senderID = "Lawyer1",
                      receiverID = "Lawyer2",
                      nodeID = "Lawyer",
                      data.dyad = lazega_dyadic,
                      data.monad = lazega_monadic,
                      n.blocks = 2,
                      mmsbm.control = list(seed = 123,
                                           conv_tol = 1e-2,
                                           hessian = FALSE))

## Plot blockmodel as network
plot(lazega_mmsbm)

</code></pre>

<hr>
<h2 id='predict.mmsbm'>Predict edges based on estimated mmsbm model</h2><span id='topic+predict.mmsbm'></span>

<h3>Description</h3>

<p>The function produces expected posterior edges based  
on estimated parameters and (optionally new) predictor data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmsbm'
predict(
  object,
  new.data.dyad = NULL,
  new.data.monad = NULL,
  forecast = FALSE,
  type = c("link", "response", "mm"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mmsbm_+3A_object">object</code></td>
<td>
<p>Object of class <code>mmsbm</code>.</p>
</td></tr>
<tr><td><code id="predict.mmsbm_+3A_new.data.dyad">new.data.dyad</code></td>
<td>
<p>An optional <code>data.frame</code> object.</p>
</td></tr>
<tr><td><code id="predict.mmsbm_+3A_new.data.monad">new.data.monad</code></td>
<td>
<p>An optional <code>data.frame</code> object.</p>
</td></tr>
<tr><td><code id="predict.mmsbm_+3A_forecast">forecast</code></td>
<td>
<p>Boolean. Should prediction forcast one step into the future? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="predict.mmsbm_+3A_type">type</code></td>
<td>
<p>Character string. The default is to use the linear predictor of edges. The alternative
&quot;response&quot; returns predicted probabilities. The alternative &quot;mm&quot; returns predicted mixed-membership vectors.</p>
</td></tr>
<tr><td><code id="predict.mmsbm_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>new.data.dyad = NULL</code>, vector of length <code>nrow(object$dyadic.data)</code>. Else, vector of length <code>nrow(new.data.dyad)</code>.
</p>


<h3>Author(s)</h3>

<p>Santiago Olivella (olivella@unc.edu), Adeline Lo (aylo@wisc.edu), Tyler Pratt (tyler.pratt@yale.edu), Kosuke Imai (imai@harvard.edu)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(NetMix)
## Load datasets
data("lazega_dyadic")
data("lazega_monadic")
## Estimate model with 2 groups
lazega_mmsbm &lt;- mmsbm(SocializeWith ~ Coworkers,
                      ~  School + Practice + Status,
                      senderID = "Lawyer1",
                      receiverID = "Lawyer2",
                      nodeID = "Lawyer",
                      data.dyad = lazega_dyadic,
                      data.monad = lazega_monadic,
                      n.blocks = 2,
                      mmsbm.control = list(seed = 123,
                                           conv_tol = 1e-2, 
                                           hessian = FALSE))

## Get in-sample predicted edge probabilities
lazega_preds &lt;- predict(lazega_mmsbm, type = "response")

</code></pre>

<hr>
<h2 id='simulate.mmsbm'>Simulate a complete sociomatrix from an <code>mmsbm</code> object</h2><span id='topic+simulate.mmsbm'></span>

<h3>Description</h3>

<p>The function generates one sample network from the posterior predictive of the model represented by a fitted <code>mmsbm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmsbm'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  new.data.dyad = NULL,
  new.data.monad = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.mmsbm_+3A_object">object</code></td>
<td>
<p>An object of class <code>mmsbm</code>, a result of a call to <code>mmsbm</code></p>
</td></tr>
<tr><td><code id="simulate.mmsbm_+3A_nsim">nsim</code></td>
<td>
<p>Number of networks to simulate</p>
</td></tr>
<tr><td><code id="simulate.mmsbm_+3A_seed">seed</code></td>
<td>
<p>RNG seed.</p>
</td></tr>
<tr><td><code id="simulate.mmsbm_+3A_new.data.dyad">new.data.dyad</code></td>
<td>
<p>An optional <code>data.frame</code> object. If not <code>NULL</code>, use these 
dyadic predictor values instead of those used to fit the original model.</p>
</td></tr>
<tr><td><code id="simulate.mmsbm_+3A_new.data.monad">new.data.monad</code></td>
<td>
<p>An optional <code>data.frame</code> object. See <code>new.data.dyad</code>.</p>
</td></tr>
<tr><td><code id="simulate.mmsbm_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length <code>nsim</code> of simulated networks. 
If <code>new.data.dyad = NULL</code>, each element is a vector of length <code>nrow(object$dyadic.data)</code>. 
Else, vector of length <code>nrow(new.data.dyad)</code>. If <code>seed</code> is not NULL, return object
includes its value as attribute &quot;seed&quot;.
</p>


<h3>Author(s)</h3>

<p>Santiago Olivella (olivella@unc.edu), Adeline Lo (aylo@wisc.edu), Tyler Pratt (tyler.pratt@yale.edu), Kosuke Imai (imai@harvard.edu)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(NetMix)
## Load datasets
data("lazega_dyadic")
data("lazega_monadic")
## Estimate model with 2 groups
lazega_mmsbm &lt;- mmsbm(SocializeWith ~ Coworkers,
                      ~  School + Practice + Status,
                      senderID = "Lawyer1",
                      receiverID = "Lawyer2",
                      nodeID = "Lawyer",
                      data.dyad = lazega_dyadic,
                      data.monad = lazega_monadic,
                      n.blocks = 2,
                      mmsbm.control = list(seed = 123, 
                                           conv_tol = 1e-2,
                                           hessian = FALSE))

## Simulate 5 new networks
lazega_sim &lt;- simulate(lazega_mmsbm, nsim = 5, seed = 123)

</code></pre>

<hr>
<h2 id='summary.mmsbm'>Summarize 'mmsbm' object</h2><span id='topic+summary.mmsbm'></span>

<h3>Description</h3>

<p>The function summarizes the output of a dynMMSBM model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmsbm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mmsbm_+3A_object">object</code></td>
<td>
<p>An object of class <code>mmsbm</code>, a result of a call to <code>mmsbm</code>.</p>
</td></tr>
<tr><td><code id="summary.mmsbm_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with named components:
</p>

<dl>
<dt>N</dt><dd><p>Total number of dyad-time period observations.</p>
</dd>
<dt>Number of Clusters</dt><dd><p>Number of latent groups included in the dynMMSBM model.</p>
</dd>
<dt>Percent of Observations in Each Cluster</dt><dd><p>Average membership in each latent group, across all node-time periods.</p>
</dd>
<dt>Edge Formation Probabilities</dt><dd><p><code>n.groups</code> by <code>n.groups</code> matrix of estimated edge formation probabilities between latent groups.</p>
</dd>
<dt>Dyadic Coefficients</dt><dd><p>Vector of estimated coefficient values for dyadic covariates.</p>
</dd>
<dt>Monadic Coefficients</dt><dd><p>Array of estimated coefficient values for monadic covariates. Has <code>n.groups</code> columns,
and <code>n.hmmstates</code> slices.</p>
</dd>
<dt>Markov State Probabilities</dt><dd><p>Average HMM state probabilities across all time periods.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Santiago Olivella (olivella@unc.edu), Adeline Lo (aylo@wisc.edu), Tyler Pratt (tyler.pratt@yale.edu), Kosuke Imai (imai@harvard.edu)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(NetMix)
## Load datasets
data("lazega_dyadic")
data("lazega_monadic")
## Estimate model with 2 groups
lazega_mmsbm &lt;- mmsbm(SocializeWith ~ Coworkers,
                      ~  School + Practice + Status,
                      senderID = "Lawyer1",
                      receiverID = "Lawyer2",
                      nodeID = "Lawyer",
                      data.dyad = lazega_dyadic,
                      data.monad = lazega_monadic,
                      n.blocks = 2,
                      mmsbm.control = list(seed = 123,
                                           conv_tol = 1e-2,
                                           hessian = TRUE))

## Summarize estimated model
summary(lazega_mmsbm)

</code></pre>

<hr>
<h2 id='vcov.mmsbm'>Extract Variance-Covariance Matrix for a Fitted <code>mmsbm</code> Object</h2><span id='topic+vcov.mmsbm'></span>

<h3>Description</h3>

<p>Extract Variance-Covariance Matrix for a Fitted <code>mmsbm</code> Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmsbm'
vcov(object, param = "All", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.mmsbm_+3A_object">object</code></td>
<td>
<p>An object of class <code>mmsbm</code>, a result of a call to <code>mmsbm</code></p>
</td></tr>
<tr><td><code id="vcov.mmsbm_+3A_param">param</code></td>
<td>
<p>Character string, which set of parameters should the vcov be extracted for? One
of <code>"MonadCoef"</code>, <code>"DyadCoef"</code>, <code>"BlockModel"</code> or <code>"All"</code> (the default).</p>
</td></tr>
<tr><td><code id="vcov.mmsbm_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>param="All"</code>, named list of individual return components. For all other values of <code>param</code>,
a numeric covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Santiago Olivella (olivella@unc.edu), Adeline Lo (aylo@wisc.edu), Tyler Pratt (tyler.pratt@yale.edu), Kosuke Imai (imai@harvard.edu)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(NetMix)
## Load datasets
data("lazega_dyadic")
data("lazega_monadic")
## Estimate model with 2 groups
lazega_mmsbm &lt;- mmsbm(SocializeWith ~ Coworkers,
                      ~  School + Practice + Status,
                      senderID = "Lawyer1",
                      receiverID = "Lawyer2",
                      nodeID = "Lawyer",
                      data.dyad = lazega_dyadic,
                      data.monad = lazega_monadic,
                      n.blocks = 2,
                      mmsbm.control = list(seed = 123, 
                                           conv_tol = 1e-2,
                                           se_sim = 2)) # Usually requires more samples.

vcov(lazega_mmsbm, "MonadCoef")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
