<!DOCTYPE html><html lang="en-GB"><head><title>Help for package deident</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {deident}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaptive_noise'><p>Function factory to apply white noise to a vector proportional to the spread</p>
of the data</a></li>
<li><a href='#add_blur'><p>De-identification via categorical aggregation</p></a></li>
<li><a href='#add_encrypt'><p>De-identification via hash encryption</p></a></li>
<li><a href='#add_group'><p>Add aggregation to pipelines</p></a></li>
<li><a href='#add_numeric_blur'><p>De-identification via numeric aggregation</p></a></li>
<li><a href='#add_perturb'><p>De-identification via random noise</p></a></li>
<li><a href='#add_pseudonymize'><p>De-identification via  replacement</p></a></li>
<li><a href='#add_shuffle'><p>De-identification via random sampling</p></a></li>
<li><a href='#apply_deident'><p>Apply a 'deident' pipeline</p></a></li>
<li><a href='#apply_to_data_frame'><p>Apply a 'deident' pipeline to a new data frame</p></a></li>
<li><a href='#BaseDeident'><p>Base class for all De-identifier classes</p></a></li>
<li><a href='#Blurer'><p>Deidentifier class for applying 'blur' transform</p></a></li>
<li><a href='#category_blur'><p>Utility for producing 'blur'</p></a></li>
<li><a href='#create_deident'><p>Create a deident pipeline</p></a></li>
<li><a href='#deident'><p>Define a transformation pipeline</p></a></li>
<li><a href='#deident_job_from_folder'><p>Apply a pipeline to files on disk.</p></a></li>
<li><a href='#Drop'><p>R6 class for the removal of variables from a pipeline</p></a></li>
<li><a href='#Encrypter'><p>Deidentifier class for applying 'encryption' transform</p></a></li>
<li><a href='#from_yaml'><p>Restore a serialized deident from file</p></a></li>
<li><a href='#GroupedShuffler'><p>GroupedShuffler class for applying 'shuffling' transform with data</p>
aggregated</a></li>
<li><a href='#lognorm_noise'><p>Function factory to apply log-normal noise to a vector</p></a></li>
<li><a href='#new_deident'><p>Deidentification API root</p></a></li>
<li><a href='#NumericBlurer'><p>Group numeric data into baskets</p></a></li>
<li><a href='#Perturber'><p>R6 class for deidentification via random noise</p></a></li>
<li><a href='#Pseudonymizer'><p>R6 class for deidentification via replacement</p></a></li>
<li><a href='#ShiftsWorked'><p>Synthetic data set listing daily shift pattern for fictitious employees</p></a></li>
<li><a href='#Shuffler'><p>Shuffler class for applying 'shuffling' transform</p></a></li>
<li><a href='#starwars'><p>Starwars characters</p></a></li>
<li><a href='#tidyeval'><p>Tidy eval helpers</p></a></li>
<li><a href='#white_noise'><p>Function factory to apply white noise to a vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Persistent Data Anonymization Pipeline</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework for the replicable removal of personally identifiable data 
    (PID) in data sets.  The package implements a suite of methods to suit different 
    data types based on the suggestions of  Garfinkel (2015) &lt;<a href="https://doi.org/10.6028%2FNIST.IR.8053">doi:10.6028/NIST.IR.8053</a>&gt; 
    and the ICO "Guidelines on Anonymization" (2012) <a href="https://ico.org.uk/media/1061/anonymisation-code.pdf">https://ico.org.uk/media/1061/anonymisation-code.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), checkmate, knitr, rmarkdown, roxygen2</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, dplyr, openssl, tidyselect, rlang (&ge; 0.4.11), glue,
purrr, stringr, yaml, readr, openxlsx, lemon, withr, fs</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-18 11:36:38 UTC; rzc1</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert Cook <a href="https://orcid.org/0000-0003-3343-8271"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Md Assaduzaman <a href="https://orcid.org/0000-0002-8885-6721"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sarahjane Jones <a href="https://orcid.org/0000-0003-4729-4029"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert Cook &lt;robert.cook@staffs.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-19 09:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaptive_noise'>Function factory to apply white noise to a vector proportional to the spread
of the data</h2><span id='topic+adaptive_noise'></span>

<h3>Description</h3>

<p>Function factory to apply white noise to a vector proportional to the spread
of the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptive_noise(sd.ratio = 1/10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adaptive_noise_+3A_sd.ratio">sd.ratio</code></td>
<td>
<p>the level of noise to apply relative to the vectors standard
deviation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- adaptive_noise(0.2)
f(1:10)

</code></pre>

<hr>
<h2 id='add_blur'>De-identification via categorical aggregation</h2><span id='topic+add_blur'></span>

<h3>Description</h3>

<p><code>add_blur()</code> adds an bluring step to a transformation pipeline
(NB: intended for categorical data).  When ran as a transformation, values
are recoded to a lower cardinality as defined by <code>blur</code>.
#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_blur(object, ..., blur = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_blur_+3A_object">object</code></td>
<td>
<p>Either a <code>data.frame</code>, <code>tibble</code>, or existing <code>DeidentList</code> pipeline.</p>
</td></tr>
<tr><td><code id="add_blur_+3A_...">...</code></td>
<td>
<p>variables to be transformed.</p>
</td></tr>
<tr><td><code id="add_blur_+3A_blur">blur</code></td>
<td>
<p>a key-value pair such that 'key' is replaced by 'value' on
transformation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'DeidentList' representing the untrained transformation pipeline.
The object contains fields:
</p>

<ul>
<li> <p><code>deident_methods</code> a list of each step in the pipeline (consisting of <code>variables</code> and <code>method</code>)
</p>
</li></ul>

<p>and methods:
</p>

<ul>
<li> <p><code>mutate</code> apply the pipeline to a new data set
</p>
</li>
<li> <p><code>to_yaml</code> serialize the pipeline to a '.yml' file
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+category_blur">category_blur()</a></code> is provided to aid in defining the <code>blur</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.blur &lt;- category_blur(ShiftsWorked$Shift, `Working` = "Day|Night")
pipe.blur &lt;- add_blur(ShiftsWorked, `Shift`, blur = .blur)
pipe.blur$mutate(ShiftsWorked)
 
</code></pre>

<hr>
<h2 id='add_encrypt'>De-identification via hash encryption</h2><span id='topic+add_encrypt'></span>

<h3>Description</h3>

<p><code>add_encrypt()</code> adds an encryption step to a transformation pipeline.
When ran as a transformation, each specified variable  undergoes replacement
via  an encryption hashing function depending on the <code>hash_key</code> and <code>seed</code> set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_encrypt(object, ..., hash_key = "", seed = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_encrypt_+3A_object">object</code></td>
<td>
<p>Either a <code>data.frame</code>, <code>tibble</code>, or existing <code>DeidentList</code> pipeline.</p>
</td></tr>
<tr><td><code id="add_encrypt_+3A_...">...</code></td>
<td>
<p>variables to be transformed.</p>
</td></tr>
<tr><td><code id="add_encrypt_+3A_hash_key">hash_key</code></td>
<td>
<p>a random alphanumeric key to control encryption</p>
</td></tr>
<tr><td><code id="add_encrypt_+3A_seed">seed</code></td>
<td>
<p>a random alphanumeric to concat to the value being encrypted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'DeidentList' representing the untrained transformation pipeline.
The object contains fields:
</p>

<ul>
<li> <p><code>deident_methods</code> a list of each step in the pipeline (consisting of <code>variables</code> and <code>method</code>)
</p>
</li></ul>

<p>and methods:
</p>

<ul>
<li> <p><code>mutate</code> apply the pipeline to a new data set
</p>
</li>
<li> <p><code>to_yaml</code> serialize the pipeline to a '.yml' file
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Basic usage; without setting a `hash_key` or `seed` encryption is poor.
pipe.encrypt &lt;- add_encrypt(ShiftsWorked, Employee)
pipe.encrypt$mutate(ShiftsWorked)

# Once set the encryption is more secure assuming `hash_key` and `seed` are 
# not exposed.
pipe.encrypt.secure &lt;- add_encrypt(ShiftsWorked, Employee, hash_key="hash1", seed="Seed2")
pipe.encrypt.secure$mutate(ShiftsWorked)

</code></pre>

<hr>
<h2 id='add_group'>Add aggregation to pipelines</h2><span id='topic+add_group'></span><span id='topic+add_ungroup'></span>

<h3>Description</h3>

<p><code>add_group()</code> allows for the injection of aggregation into the transformation
pipeline.  Should you need to apply a transformation under aggregation (e.g.
<code>add_shuffle</code>) this helper creates a grouped <code>data.frame</code> as would be done
with <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>.
The function <code>add_ungroup()</code> is supplied to perform the inverse operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_group(object, ...)

add_ungroup(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_group_+3A_object">object</code></td>
<td>
<p>Either a <code>data.frame</code>, <code>tibble</code>, or existing <code>DeidentList</code> pipeline.</p>
</td></tr>
<tr><td><code id="add_group_+3A_...">...</code></td>
<td>
<p>Variables on which data is to be grouped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'DeidentList' representing the untrained transformation pipeline.
The object contains fields:
</p>

<ul>
<li> <p><code>deident_methods</code> a list of each step in the pipeline (consisting of <code>variables</code> and <code>method</code>)
</p>
</li></ul>

<p>and methods:
</p>

<ul>
<li> <p><code>mutate</code> apply the pipeline to a new data set
</p>
</li>
<li> <p><code>to_yaml</code> serialize the pipeline to a '.yml' file
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>pipe.grouped &lt;- add_group(ShiftsWorked, Date, Shift)
pipe.grouped_shuffle &lt;- add_shuffle(pipe.grouped, `Daily Pay`)
add_ungroup(pipe.grouped_shuffle, `Daily Pay`)
</code></pre>

<hr>
<h2 id='add_numeric_blur'>De-identification via numeric aggregation</h2><span id='topic+add_numeric_blur'></span>

<h3>Description</h3>

<p><code>add_numeric_blur()</code> adds an bluring step to a transformation pipeline
(NB: intended for numeric data).  When ran as a transformation, the data is
split into intervals depending on the <code>cuts</code> supplied of the series
[-Inf, cut.1), [cut.1, cut.2), ..., [cut.n, Inf] where
<code>cuts</code> = c(cut.1, cut.2, ..., cut.n).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_numeric_blur(object, ..., cuts = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_numeric_blur_+3A_object">object</code></td>
<td>
<p>Either a <code>data.frame</code>, <code>tibble</code>, or existing <code>DeidentList</code> pipeline.</p>
</td></tr>
<tr><td><code id="add_numeric_blur_+3A_...">...</code></td>
<td>
<p>variables to be transformed.</p>
</td></tr>
<tr><td><code id="add_numeric_blur_+3A_cuts">cuts</code></td>
<td>
<p>The position in which data is to be divided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'DeidentList' representing the untrained transformation pipeline.
The object contains fields:
</p>

<ul>
<li> <p><code>deident_methods</code> a list of each step in the pipeline (consisting of <code>variables</code> and <code>method</code>)
</p>
</li></ul>

<p>and methods:
</p>

<ul>
<li> <p><code>mutate</code> apply the pipeline to a new data set
</p>
</li>
<li> <p><code>to_yaml</code> serialize the pipeline to a '.yml' file
</p>
</li></ul>


<hr>
<h2 id='add_perturb'>De-identification via random noise</h2><span id='topic+add_perturb'></span>

<h3>Description</h3>

<p><code>add_perturb()</code> adds an perturbation step to a transformation pipeline
(NB: intended for numeric data).  When ran as a transformation, each
specified variable is transformed by the <code>noise</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_perturb(object, ..., noise = adaptive_noise(0.1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_perturb_+3A_object">object</code></td>
<td>
<p>Either a <code>data.frame</code>, <code>tibble</code>, or existing <code>DeidentList</code> pipeline.</p>
</td></tr>
<tr><td><code id="add_perturb_+3A_...">...</code></td>
<td>
<p>variables to be transformed.</p>
</td></tr>
<tr><td><code id="add_perturb_+3A_noise">noise</code></td>
<td>
<p>a single-argument function that applies randomness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'DeidentList' representing the untrained transformation pipeline.
The object contains fields:
</p>

<ul>
<li> <p><code>deident_methods</code> a list of each step in the pipeline (consisting of <code>variables</code> and <code>method</code>)
</p>
</li></ul>

<p>and methods:
</p>

<ul>
<li> <p><code>mutate</code> apply the pipeline to a new data set
</p>
</li>
<li> <p><code>to_yaml</code> serialize the pipeline to a '.yml' file
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+adaptive_noise">adaptive_noise()</a></code>, <code><a href="#topic+white_noise">white_noise()</a></code>, and <code><a href="#topic+lognorm_noise">lognorm_noise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pipe.perturb &lt;- add_perturb(ShiftsWorked, `Daily Pay`)
pipe.perturb$mutate(ShiftsWorked)

pipe.perturb.white_noise &lt;- add_perturb(ShiftsWorked, `Daily Pay`, noise=white_noise(0.1))
pipe.perturb.white_noise$mutate(ShiftsWorked)

pipe.perturb.noisy_adaptive &lt;- add_perturb(ShiftsWorked, `Daily Pay`, noise=adaptive_noise(1))
pipe.perturb.noisy_adaptive$mutate(ShiftsWorked)
</code></pre>

<hr>
<h2 id='add_pseudonymize'>De-identification via  replacement</h2><span id='topic+add_pseudonymize'></span>

<h3>Description</h3>

<p><code>add_pseudonymize()</code> adds a psuedonymization step to a transformation pipeline.
When ran as a transformation, terms that have not been seen before are given a new
random alpha-numeric string while terms that have been previously transformed
reuse the same term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_pseudonymize(object, ..., lookup = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_pseudonymize_+3A_object">object</code></td>
<td>
<p>Either a <code>data.frame</code>, <code>tibble</code>, or existing <code>DeidentList</code> pipeline.</p>
</td></tr>
<tr><td><code id="add_pseudonymize_+3A_...">...</code></td>
<td>
<p>variables to be transformed.</p>
</td></tr>
<tr><td><code id="add_pseudonymize_+3A_lookup">lookup</code></td>
<td>
<p>a pre-existing name-value pair to define intended psuedonymizations.
Instances of 'name' will be replaced with 'value' on transformation.#'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'DeidentList' representing the untrained transformation pipeline.
The object contains fields:
</p>

<ul>
<li> <p><code>deident_methods</code> a list of each step in the pipeline (consisting of <code>variables</code> and <code>method</code>)
</p>
</li></ul>

<p>and methods:
</p>

<ul>
<li> <p><code>mutate</code> apply the pipeline to a new data set
</p>
</li>
<li> <p><code>to_yaml</code> serialize the pipeline to a '.yml' file
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Basic usage; 
pipe.pseudonymize &lt;- add_pseudonymize(ShiftsWorked, Employee)
pipe.pseudonymize$mutate(ShiftsWorked)

pipe.pseudonymize2 &lt;- add_pseudonymize(ShiftsWorked, Employee, 
                                    lookup=list("Kyle Wilson" = "Kyle"))
pipe.pseudonymize2$mutate(ShiftsWorked)

</code></pre>

<hr>
<h2 id='add_shuffle'>De-identification via random sampling</h2><span id='topic+add_shuffle'></span>

<h3>Description</h3>

<p><code>add_shuffle()</code> adds a shuffling step to a transformation pipeline.
When ran as a transformation, each specified variable undergoes a random sample without
replacement so that summary metrics  on a single variable are unchanged, but
inter-variable metrics are rendered spurious.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_shuffle(object, ..., limit = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_shuffle_+3A_object">object</code></td>
<td>
<p>Either a <code>data.frame</code>, <code>tibble</code>, or existing <code>DeidentList</code> pipeline.</p>
</td></tr>
<tr><td><code id="add_shuffle_+3A_...">...</code></td>
<td>
<p>variables to be transformed.</p>
</td></tr>
<tr><td><code id="add_shuffle_+3A_limit">limit</code></td>
<td>
<p>integer - the minimum number of observations a variable needs to
have for shuffling to be performed.  If the variable has length less than <code>limit</code>
values are replaced with <code>NA</code>s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'DeidentList' representing the untrained transformation pipeline.
The object contains fields:
</p>

<ul>
<li> <p><code>deident_methods</code> a list of each step in the pipeline (consisting of <code>variables</code> and <code>method</code>)
</p>
</li></ul>

<p>and methods:
</p>

<ul>
<li> <p><code>mutate</code> apply the pipeline to a new data set
</p>
</li>
<li> <p><code>to_yaml</code> serialize the pipeline to a '.yml' file
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+add_group">add_group()</a></code> for usage under aggregation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Basic usage; 
pipe.shuffle &lt;- add_shuffle(ShiftsWorked, Employee)
pipe.shuffle$mutate(ShiftsWorked)

pipe.shuffle.limit &lt;- add_shuffle(ShiftsWorked, Employee, limit=1)
pipe.shuffle.limit$mutate(ShiftsWorked)

</code></pre>

<hr>
<h2 id='apply_deident'>Apply a 'deident' pipeline</h2><span id='topic+apply_deident'></span>

<h3>Description</h3>

<p>Applies a pipeline as defined by <code>deident</code> to a data frame. tibble, or file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_deident(object, deident, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_deident_+3A_object">object</code></td>
<td>
<p>The data to be deidentified</p>
</td></tr>
<tr><td><code id="apply_deident_+3A_deident">deident</code></td>
<td>
<p>A deidentification pipeline to be used.</p>
</td></tr>
<tr><td><code id="apply_deident_+3A_...">...</code></td>
<td>
<p>Terms to be passed to other methods</p>
</td></tr>
</table>

<hr>
<h2 id='apply_to_data_frame'>Apply a 'deident' pipeline to a new data frame</h2><span id='topic+apply_to_data_frame'></span>

<h3>Description</h3>

<p>Apply a 'deident' pipeline to a new data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_to_data_frame(data, transformer, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_to_data_frame_+3A_data">data</code></td>
<td>
<p>The data set to be converted</p>
</td></tr>
<tr><td><code id="apply_to_data_frame_+3A_transformer">transformer</code></td>
<td>
<p>The pipeline to be used</p>
</td></tr>
<tr><td><code id="apply_to_data_frame_+3A_...">...</code></td>
<td>
<p>To be passed on to other methods</p>
</td></tr>
</table>

<hr>
<h2 id='BaseDeident'>Base class for all De-identifier classes</h2><span id='topic+BaseDeident'></span>

<h3>Description</h3>

<p>Create new Deidentifier object
</p>
<p>Setter for 'method' field
</p>
<p>Save 'Deidentifier' to serialized object.
</p>
<p>Apply 'method' to a vector of values
</p>
<p>Apply 'method' to variables in a data frame
</p>
<p>Apply 'mutate' method to an aggregated data frame.
</p>
<p>Aggregate a data frame and apply 'mutate' to each.
</p>
<p>Convert <code>self</code> to a list
</p>
<p>String representation of <code>self</code>
</p>
<p>Check if parameters are in allowed fields
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BaseDeident_+3A_method">method</code></td>
<td>
<p>New function to be used as the method.</p>
</td></tr>
<tr><td><code id="BaseDeident_+3A_location">location</code></td>
<td>
<p>File path to save to.</p>
</td></tr>
<tr><td><code id="BaseDeident_+3A_keys">keys</code></td>
<td>
<p>Vector of values to be processed</p>
</td></tr>
<tr><td><code id="BaseDeident_+3A_force">force</code></td>
<td>
<p>Perform transformation on all variables even if some given
are not in the data.</p>
</td></tr>
<tr><td><code id="BaseDeident_+3A_grouped_data">grouped_data</code></td>
<td>
<p>a 'grouped_df' object</p>
</td></tr>
<tr><td><code id="BaseDeident_+3A_data">data</code></td>
<td>
<p>A data frame to be manipulated</p>
</td></tr>
<tr><td><code id="BaseDeident_+3A_grp_cols">grp_cols</code></td>
<td>
<p>Vector of variables in 'data' to group on.</p>
</td></tr>
<tr><td><code id="BaseDeident_+3A_mutate_cols">mutate_cols</code></td>
<td>
<p>Vector of variables in 'data' to transform.</p>
</td></tr>
<tr><td><code id="BaseDeident_+3A_type">type</code></td>
<td>
<p>character vector describing the object.  Defaults to class.</p>
</td></tr>
<tr><td><code id="BaseDeident_+3A_...">...</code></td>
<td>
<p>Options to check exist</p>
</td></tr>
</table>


<h3>Fields</h3>


<dl>
<dt><code>method</code></dt><dd><p>Function to call for data transform.</p>
</dd>
</dl>

<hr>
<h2 id='Blurer'>Deidentifier class for applying 'blur' transform</h2><span id='topic+Blurer'></span>

<h3>Description</h3>

<p>Convert <code>self</code> to a list.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Blurer_+3A_blur">blur</code></td>
<td>
<p>Look-up list to define aggregation.</p>
</td></tr>
<tr><td><code id="Blurer_+3A_keys">keys</code></td>
<td>
<p>Vector of values to be processed</p>
</td></tr>
<tr><td><code id="Blurer_+3A_...">...</code></td>
<td>
<p>Values to be concatenated to keys</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Bluring' refers to aggregation of data e.g. converting city to country,
or post code to IMD.  The level of blurring is defined by the list given
at initialization which maps key to value e.g.
list(London = &quot;England&quot;, Paris = &quot;France&quot;).
</p>


<h3>Value</h3>

<p><code>Blurer</code>
Apply blur to a vector of values
</p>


<h3>Fields</h3>


<dl>
<dt><code>blur</code></dt><dd><p>List of aggregations to be applied.
Create new Blurer object</p>
</dd>
</dl>

<hr>
<h2 id='category_blur'>Utility for producing 'blur'</h2><span id='topic+category_blur'></span>

<h3>Description</h3>

<p>Utility for producing 'blur'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>category_blur(vec, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="category_blur_+3A_vec">vec</code></td>
<td>
<p>The vector of values to be used</p>
</td></tr>
<tr><td><code id="category_blur_+3A_...">...</code></td>
<td>
<p><code>Replacement</code> = <code>RegexPattern</code> pairs of arguments</p>
</td></tr>
</table>

<hr>
<h2 id='create_deident'>Create a deident pipeline</h2><span id='topic+create_deident'></span>

<h3>Description</h3>

<p>Create a deident pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_deident(method, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_deident_+3A_method">method</code></td>
<td>
<p>A deidentifier to initialize.</p>
</td></tr>
<tr><td><code id="create_deident_+3A_...">...</code></td>
<td>
<p>list of variables to be deidentifier. NB: key word arguments will
be passed to method at initialization.</p>
</td></tr>
</table>

<hr>
<h2 id='deident'>Define a transformation pipeline</h2><span id='topic+deident'></span>

<h3>Description</h3>

<p><code>deident()</code> creates a transformation pipeline of 'deidentifiers' for
the repeated application of  anonymization transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deident(data, deidentifier, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deident_+3A_data">data</code></td>
<td>
<p>A data frame, existing pipeline, or a 'deidentifier'
(as either initialized object, class generator, or character string)</p>
</td></tr>
<tr><td><code id="deident_+3A_deidentifier">deidentifier</code></td>
<td>
<p>A deidentifier' (as either initialized object,
class generator, or character string) to be appended to the current
pipeline</p>
</td></tr>
<tr><td><code id="deident_+3A_...">...</code></td>
<td>
<p>Positional arguments are variables of 'data' to be transformed
and key-word arguments are passed to 'deidentifier' at creation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'DeidentList' representing the untrained transformation pipeline.
The object contains fields:
</p>

<ul>
<li> <p><code>deident_methods</code> a list of each step in the pipeline (consisting of <code>variables</code> and <code>method</code>)
</p>
</li></ul>

<p>and methods:
</p>

<ul>
<li> <p><code>mutate</code> apply the pipeline to a new data set
</p>
</li>
<li> <p><code>to_yaml</code> serialize the pipeline to a '.yml' file
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# 
pipe &lt;- deident(ShiftsWorked, Pseudonymizer, Employee)

print(pipe)

apply_deident(ShiftsWorked, pipe)
  
</code></pre>

<hr>
<h2 id='deident_job_from_folder'>Apply a pipeline to files on disk.</h2><span id='topic+deident_job_from_folder'></span>

<h3>Description</h3>

<p>Apply a deident pipeline to a set of files and save them back to disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deident_job_from_folder(
  deident_pipeline,
  data_dir,
  result_dir = "Deident_results"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deident_job_from_folder_+3A_deident_pipeline">deident_pipeline</code></td>
<td>
<p>The deident list to be used.</p>
</td></tr>
<tr><td><code id="deident_job_from_folder_+3A_data_dir">data_dir</code></td>
<td>
<p>a path to the files to be transformed.</p>
</td></tr>
<tr><td><code id="deident_job_from_folder_+3A_result_dir">result_dir</code></td>
<td>
<p>a path to where files are to be saved.</p>
</td></tr>
</table>

<hr>
<h2 id='Drop'>R6 class for the removal of variables from a pipeline</h2><span id='topic+Drop'></span>

<h3>Description</h3>

<p>A <code>Deident</code> class dealing with the exclusion of variables.
</p>

<hr>
<h2 id='Encrypter'>Deidentifier class for applying 'encryption' transform</h2><span id='topic+Encrypter'></span>

<h3>Description</h3>

<p>Create new Encrypter object
</p>
<p>Convert <code>self</code> to a list.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Encrypter_+3A_hash_key">hash_key</code></td>
<td>
<p>An alpha numeric key for use in encryption</p>
</td></tr>
<tr><td><code id="Encrypter_+3A_seed">seed</code></td>
<td>
<p>An alpha numeric key which is concatenated to
minimize brute force attacks</p>
</td></tr>
<tr><td><code id="Encrypter_+3A_keys">keys</code></td>
<td>
<p>Vector of values to be processed</p>
</td></tr>
<tr><td><code id="Encrypter_+3A_...">...</code></td>
<td>
<p>Values to be concatenated to keys</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Encrypting' refers to the cryptographic hashing  of data e.g. md5
checksum.  Encryption is more powerful if a random hash and seed are
supplied and kept secret.
</p>


<h3>Value</h3>

<p><code>Encrypter</code>
Apply blur to a vector of values
</p>


<h3>Fields</h3>


<dl>
<dt><code>hash_key</code></dt><dd><p>Alpha-numeric secret key for encryption</p>
</dd>
<dt><code>seed</code></dt><dd><p>String for concatenation to raw value</p>
</dd>
</dl>

<hr>
<h2 id='from_yaml'>Restore a serialized deident from file</h2><span id='topic+from_yaml'></span>

<h3>Description</h3>

<p>Restore a serialized deident from file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_yaml(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="from_yaml_+3A_path">path</code></td>
<td>
<p>Path to serialized deident.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
deident &lt;- deident(ShiftsWorked, Pseudonymizer, Employee)
.tempfile &lt;- tempfile(fileext = ".yml")
deident$to_yaml(.tempfile)

deident.yaml &lt;- from_yaml(.tempfile)
deident.yaml$mutate(ShiftsWorked)

</code></pre>

<hr>
<h2 id='GroupedShuffler'>GroupedShuffler class for applying 'shuffling' transform with data
aggregated</h2><span id='topic+GroupedShuffler'></span>

<h3>Description</h3>

<p>Convert <code>self</code> to a list.
</p>
<p>Character representation of the class
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GroupedShuffler_+3A_limit">limit</code></td>
<td>
<p>Minimum number of rows required to shuffle data</p>
</td></tr>
<tr><td><code id="GroupedShuffler_+3A_data">data</code></td>
<td>
<p>A data frame to be manipulated</p>
</td></tr>
<tr><td><code id="GroupedShuffler_+3A_...">...</code></td>
<td>
<p>Vector of variables in 'data' to transform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Shuffling' refers to the a random sampling of a variable without
replacement e.g. [A, B, C] becoming [B, A, C] but not [A, A, B].  &quot;Grouped
shuffling&quot; refers to aggregating the data by another feature before applying
the shuffling process.  Grouped shuffling will preserve aggregate level
metrics (e.g. mean, median, mode) but removes ordinal properties
i.e. correlations and auto-correlations
</p>


<h3>Fields</h3>


<dl>
<dt><code>group_on</code></dt><dd><p>Symbolic representation of grouping variables</p>
</dd>
<dt><code>limit</code></dt><dd><p>Minimum number of rows required to shuffle data
Create new GroupedShuffler object</p>
</dd>
</dl>

<hr>
<h2 id='lognorm_noise'>Function factory to apply log-normal noise to a vector</h2><span id='topic+lognorm_noise'></span>

<h3>Description</h3>

<p>Function factory to apply log-normal noise to a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lognorm_noise(sd = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lognorm_noise_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of noise to apply.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- lognorm_noise(1)
f(1:10)

</code></pre>

<hr>
<h2 id='new_deident'>Deidentification API root</h2><span id='topic+new_deident'></span>

<h3>Description</h3>

<p>A general function for defining a deident function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_deident(object, ..., encrypter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_deident_+3A_object">object</code></td>
<td>
<p>Either a <code>data.frame</code>, <code>tibble</code>, or existing <code>DeidentList</code> pipeline.</p>
</td></tr>
<tr><td><code id="new_deident_+3A_...">...</code></td>
<td>
<p>variables to be transformed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'DeidentList' representing the untrained transformation pipeline.
The object contains fields:
</p>

<ul>
<li> <p><code>deident_methods</code> a list of each step in the pipeline (consisting of <code>variables</code> and <code>method</code>)
</p>
</li></ul>

<p>and methods:
</p>

<ul>
<li> <p><code>mutate</code> apply the pipeline to a new data set
</p>
</li>
<li> <p><code>to_yaml</code> serialize the pipeline to a '.yml' file
</p>
</li></ul>


<hr>
<h2 id='NumericBlurer'>Group numeric data into baskets</h2><span id='topic+NumericBlurer'></span>

<h3>Description</h3>

<p>Group numeric data into baskets
</p>

<hr>
<h2 id='Perturber'>R6 class for deidentification via random noise</h2><span id='topic+Perturber'></span>

<h3>Description</h3>

<p>A <code>Deident</code> class dealing with the addition of random noise to a
numeric variable.
</p>
<p>Create new Perturber object
</p>
<p>Apply noise to a vector of values
</p>
<p>Convert <code>self</code> to a list.
</p>
<p>Character representation of the class
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Perturber_+3A_noise">noise</code></td>
<td>
<p>a single-argument function that applies randomness.</p>
</td></tr>
<tr><td><code id="Perturber_+3A_keys">keys</code></td>
<td>
<p>Vector of values to be processed</p>
</td></tr>
<tr><td><code id="Perturber_+3A_...">...</code></td>
<td>
<p>Values to be concatenated to keys</p>
</td></tr>
</table>


<h3>Fields</h3>


<dl>
<dt><code>noise.str</code></dt><dd><p>character representation of <code>noise</code></p>
</dd>
<dt><code>method</code></dt><dd><p>random noise function</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>  pert &lt;- Perturber$new()
  pert$transform(1:10)

</code></pre>

<hr>
<h2 id='Pseudonymizer'>R6 class for deidentification via replacement</h2><span id='topic+Pseudonymizer'></span>

<h3>Description</h3>

<p>A <code>Deident</code> class dealing with the (repeatable) random replacement of
string for deidentification.
</p>
<p>Create new <code>Pseudonymizer</code> object
</p>
<p>Check if a key exists in <code>lookup</code>
</p>
<p>Check if a key exists in <code>lookup</code>
</p>
<p>Retrieve a value from <code>lookup</code>
</p>
<p>Returns <code>self$lookup</code> formatted as a tibble
</p>
<p>Convert <code>self</code> to a list.
</p>
<p>Apply the deidentifcation method to the supplied <code>keys</code>
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pseudonymizer_+3A_lookup">lookup</code></td>
<td>
<p>a pre-existing name-value pair to define intended psuedonymizations.
Instances of 'name' will be replaced with 'value' on transformation.</p>
</td></tr>
<tr><td><code id="Pseudonymizer_+3A_keys">keys</code></td>
<td>
<p>value to be checked</p>
</td></tr>
<tr><td><code id="Pseudonymizer_+3A_...">...</code></td>
<td>
<p>values to concatenate to <code>key</code> and check</p>
</td></tr>
<tr><td><code id="Pseudonymizer_+3A_parse_numerics">parse_numerics</code></td>
<td>
<p>True: Force columns to characters.  NB: only
character vectors will be parsed.</p>
</td></tr>
</table>


<h3>Fields</h3>


<dl>
<dt><code>lookup</code></dt><dd><p>list of mapping from key-value on transform.</p>
</dd>
</dl>

<hr>
<h2 id='ShiftsWorked'>Synthetic data set listing daily shift pattern for fictitious employees</h2><span id='topic+ShiftsWorked'></span>

<h3>Description</h3>

<p>A synthetic data set intended to demonstrate the design and application of a
deidentification pipeline.  Employee names are entirely fictitious and constructed
from the
<a href="https://www.kaggle.com/datasets/fivethirtyeight/fivethirtyeight-most-common-name-dataset?resource=download&amp;select=new-top-surnames.csv"><code style="white-space: pre;">&#8288;FiveThirtyEight Most Common Name Dataset&#8288;</code></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShiftsWorked
</code></pre>


<h3>Format</h3>

<p>A data frame with 3,100 rows and 6 columns:
</p>

<dl>
<dt>Record ID</dt><dd><p>Table primary key (integer)</p>
</dd>
<dt>Employee</dt><dd><p>Name of listed employee</p>
</dd>
<dt>Date</dt><dd><p>The date being considered</p>
</dd>
<dt>Shift</dt><dd><p>The shift-type done by <code>employee</code> on <code>date</code>.  One of 'Day', 'Night' or 'Rest'.</p>
</dd>
<dt>Shift Start</dt><dd><p>Shift start time (missing if on 'Rest' shift)</p>
</dd>
<dt>Shift End</dt><dd><p>Shift end time (missing if on 'Rest' shift)</p>
</dd>
<dt>Daily Pay</dt><dd><p>Shift end time (missing if on 'Rest' shift)</p>
</dd>
</dl>


<hr>
<h2 id='Shuffler'>Shuffler class for applying 'shuffling' transform</h2><span id='topic+Shuffler'></span>

<h3>Description</h3>

<p>Create new Shuffler object
</p>
<p>Update minimum vector size for shuffling
</p>
<p>Apply the deidentifcation method to the supplied <code>keys</code>
</p>
<p>Convert <code>self</code> to a list.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Shuffler_+3A_method">method</code></td>
<td>
<p>[optional] A function representing the method of re-sampling
to be used.  By default uses exhaustive sampling without replacement.</p>
</td></tr>
<tr><td><code id="Shuffler_+3A_keys">keys</code></td>
<td>
<p>Value(s) to be transformed.</p>
</td></tr>
<tr><td><code id="Shuffler_+3A_...">...</code></td>
<td>
<p>Value(s) to concatenate to <code>keys</code> and transform
@inheritParams Pseudonymizer</p>
</td></tr>
<tr><td><code id="Shuffler_+3A_limit">limit</code></td>
<td>
<p>integer - the minimum number of observations a variable needs to
have for shuffling to be performed.  If the variable has length less than <code>limit</code>
values are replaced with <code>NA</code>s.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Shuffling' refers to the a random sampling of a variable without
replacement e.g. [A, B, C] becoming [B, A, C] but not [A, A, B].
Shuffling will preserve top level metrics (e.g. mean, median, mode) but
removes ordinal properties i.e. correlations and auto-correlations
</p>


<h3>Fields</h3>


<dl>
<dt><code>limit</code></dt><dd><p>minimum vector length to be shuffled.  If vector to be
transformed has length &lt; limit, the data is replaced with NAs</p>
</dd>
</dl>

<hr>
<h2 id='starwars'>Starwars characters</h2><span id='topic+starwars'></span>

<h3>Description</h3>

<p>The original data, from SWAPI, the Star Wars API, <a href="https://swapi.py4e.com/">https://swapi.py4e.com/</a>, has been revised
to reflect additional research into gender and sex determinations of characters.  NB: taken from <code>dplyr</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>starwars
</code></pre>


<h3>Format</h3>

<p>A tibble with 87 rows and 14 variables:
</p>

<dl>
<dt>name</dt><dd><p>Name of the character</p>
</dd>
<dt>height</dt><dd><p>Height (cm)</p>
</dd>
<dt>mass</dt><dd><p>Weight (kg)</p>
</dd>
<dt>hair_color,skin_color,eye_color</dt><dd><p>Hair, skin, and eye colors</p>
</dd>
<dt>birth_year</dt><dd><p>Year born (BBY = Before Battle of Yavin)</p>
</dd>
<dt>sex</dt><dd><p>The biological sex of the character, namely male, female, hermaphroditic, or none (as in the case for Droids).</p>
</dd>
<dt>gender</dt><dd><p>The gender role or gender identity of the character as determined by their personality or the way they were programmed (as in the case for Droids).</p>
</dd>
<dt>homeworld</dt><dd><p>Name of homeworld</p>
</dd>
<dt>species</dt><dd><p>Name of species</p>
</dd>
<dt>films</dt><dd><p>List of films the character appeared in</p>
</dd>
<dt>vehicles</dt><dd><p>List of vehicles the character has piloted</p>
</dd>
<dt>starships</dt><dd><p>List of starships the character has piloted</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>starwars
</code></pre>

<hr>
<h2 id='tidyeval'>Tidy eval helpers</h2><span id='topic+tidyeval'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+.data'></span><span id='topic++3A+3D'></span><span id='topic+as_name'></span><span id='topic+as_label'></span>

<h3>Description</h3>

<p>This page lists the tidy eval tools reexported in this package from
rlang. To learn about using tidy eval in scripts and packages at a
high level, see the <a href="https://dplyr.tidyverse.org/articles/programming.html">dplyr programming vignette</a>
and the <a href="https://ggplot2.tidyverse.org/articles/ggplot2-in-packages.html">ggplot2 in packages vignette</a>.
The <a href="https://adv-r.hadley.nz/metaprogramming.html">Metaprogramming section</a> of <a href="https://adv-r.hadley.nz">Advanced R</a> may also be useful for a deeper dive.
</p>

<ul>
<li><p> The tidy eval operators <code style="white-space: pre;">&#8288;{{&#8288;</code>, <code style="white-space: pre;">&#8288;!!&#8288;</code>, and <code style="white-space: pre;">&#8288;!!!&#8288;</code> are syntactic
constructs which are specially interpreted by tidy eval functions.
You will mostly need <code style="white-space: pre;">&#8288;{{&#8288;</code>, as <code style="white-space: pre;">&#8288;!!&#8288;</code> and <code style="white-space: pre;">&#8288;!!!&#8288;</code> are more advanced
operators which you should not have to use in simple cases.
</p>
<p>The curly-curly operator <code style="white-space: pre;">&#8288;{{&#8288;</code> allows you to tunnel data-variables
passed from function arguments inside other tidy eval functions.
<code style="white-space: pre;">&#8288;{{&#8288;</code> is designed for individual arguments. To pass multiple
arguments contained in dots, use <code>...</code> in the normal way.
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, ...) {
  data %&gt;%
    group_by(...) %&gt;%
    summarise(mean = mean({{ var }}))
}
</pre></div>
</li>
<li> <p><code><a href="#topic+enquo">enquo()</a></code> and <code><a href="#topic+enquos">enquos()</a></code> delay the execution of one or several
function arguments. The former returns a single expression, the
latter returns a list of expressions. Once defused, expressions
will no longer evaluate on their own. They must be injected back
into an evaluation context with <code style="white-space: pre;">&#8288;!!&#8288;</code> (for a single expression) and
<code style="white-space: pre;">&#8288;!!!&#8288;</code> (for a list of expressions).
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, ...) {
  # Defuse
  var &lt;- enquo(var)
  dots &lt;- enquos(...)

  # Inject
  data %&gt;%
    group_by(!!!dots) %&gt;%
    summarise(mean = mean(!!var))
}
</pre></div>
<p>In this simple case, the code is equivalent to the usage of <code style="white-space: pre;">&#8288;{{&#8288;</code>
and <code>...</code> above. Defusing with <code>enquo()</code> or <code>enquos()</code> is only
needed in more complex cases, for instance if you need to inspect
or modify the expressions in some way.
</p>
</li>
<li><p> The <code>.data</code> pronoun is an object that represents the current
slice of data. If you have a variable name in a string, use the
<code>.data</code> pronoun to subset that variable with <code>[[</code>.
</p>
<div class="sourceCode"><pre>my_var &lt;- "disp"
mtcars %&gt;% summarise(mean = mean(.data[[my_var]]))
</pre></div>
</li>
<li><p> Another tidy eval operator is <code style="white-space: pre;">&#8288;:=&#8288;</code>. It makes it possible to use
glue and curly-curly syntax on the LHS of <code>=</code>. For technical
reasons, the R language doesn't support complex expressions on
the left of <code>=</code>, so we use <code style="white-space: pre;">&#8288;:=&#8288;</code> as a workaround.
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, suffix = "foo") {
  # Use `{{` to tunnel function arguments and the usual glue
  # operator `{` to interpolate plain strings.
  data %&gt;%
    summarise("{{ var }}_mean_{suffix}" := mean({{ var }}))
}
</pre></div>
</li>
<li><p> Many tidy eval functions like <code>dplyr::mutate()</code> or
<code>dplyr::summarise()</code> give an automatic name to unnamed inputs. If
you need to create the same sort of automatic names by yourself,
use <code>as_label()</code>. For instance, the glue-tunnelling syntax above
can be reproduced manually with:
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, suffix = "foo") {
  var &lt;- enquo(var)
  prefix &lt;- as_label(var)
  data %&gt;%
    summarise("{prefix}_mean_{suffix}" := mean(!!var))
}
</pre></div>
<p>Expressions defused with <code>enquo()</code> (or tunnelled with <code style="white-space: pre;">&#8288;{{&#8288;</code>) need
not be simple column names, they can be arbitrarily complex.
<code>as_label()</code> handles those cases gracefully. If your code assumes
a simple column name, use <code>as_name()</code> instead. This is safer
because it throws an error if the input is not a name as expected.
</p>
</li></ul>


<hr>
<h2 id='white_noise'>Function factory to apply white noise to a vector</h2><span id='topic+white_noise'></span>

<h3>Description</h3>

<p>Function factory to apply white noise to a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>white_noise(sd = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="white_noise_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of noise to apply.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- white_noise(1)
f(1:10)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
