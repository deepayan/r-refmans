<!DOCTYPE html><html><head><title>Help for package metaRange</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metaRange}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculate_dispersal_kernel'><p>Calculate 2D dispersal kernel.</p></a></li>
<li><a href='#calculate_normalization_constant'><p>Normalization constant calculation</p></a></li>
<li><a href='#calculate_suitability'><p>Calculate (estimate) environmental suitability</p></a></li>
<li><a href='#create_simulation'><p>Create a simulation</p></a></li>
<li><a href='#dispersal'><p>Dispersal process</p></a></li>
<li><a href='#dispersal_fixed_unweighted'><p>Unweighted and fixed sized dispersal</p></a></li>
<li><a href='#dispersal_fixed_weighted'><p>Weighted and fixed sized dispersal</p></a></li>
<li><a href='#metabolic_scaling'><p>Metabolic scaling</p></a></li>
<li><a href='#metaRange-package'><p>metaRange: Framework to Build Mechanistic and Metabolic Constrained Species Distribution Models</p></a></li>
<li><a href='#metaRangeEnvironment'><p>metaRangeEnvironment object</p></a></li>
<li><a href='#metaRangePriorityQueue'><p>Process priority queue</p></a></li>
<li><a href='#metaRangeProcess'><p>metaRangeProcess object</p></a></li>
<li><a href='#metaRangeSimulation'><p>metaRangeSimulation object</p></a></li>
<li><a href='#metaRangeSpecies'><p>metaRangeSpecies object</p></a></li>
<li><a href='#negative_exponential_function'><p>Negative Exponential kernel</p></a></li>
<li><a href='#plot.metaRangeEnvironment'><p>Plotting function</p></a></li>
<li><a href='#plot.metaRangeSimulation'><p>Plotting function</p></a></li>
<li><a href='#plot.metaRangeSpecies'><p>Plotting function</p></a></li>
<li><a href='#print.metaRangeVariableStorage'><p>Print traits or globals</p></a></li>
<li><a href='#ricker_allee_reproduction_model'><p>Ricker reproduction model with Allee effects</p></a></li>
<li><a href='#ricker_reproduction_model'><p>Ricker reproduction model</p></a></li>
<li><a href='#save_species'><p>Save function</p></a></li>
<li><a href='#set_verbosity'><p>Set verbosity of metaRange simulation</p></a></li>
<li><a href='#summary.metaRangeSimulation'><p>Summary for metaRange simulation</p></a></li>
<li><a href='#summary.metaRangeSpecies'><p>Summary for metaRange species</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Framework to Build Mechanistic and Metabolic Constrained Species
Distribution Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Build spatially and temporally explicit
    process-based species distribution models, that can include an arbitrary
    number of environmental factors, species and processes including metabolic
    constraints and species interactions. The focus of the package is simulating
    populations of one or multiple species in a grid-based landscape and studying
    the meta-population dynamics and emergent patterns that arise from the
    interaction of species under complex environmental conditions. It
    provides functions for common ecological processes such as
    negative exponential, kernel-based dispersal (see
    Nathan et al. (2012) &lt;<a href="https://doi.org/10.1093%2Facprof%3Aoso%2F9780199608898.003.0015">doi:10.1093/acprof:oso/9780199608898.003.0015</a>&gt;),
    calculation of the environmental suitability based on cardinal values (
    Yin et al. (1995) &lt;<a href="https://doi.org/10.1016%2F0168-1923%2895%2902236-Q">doi:10.1016/0168-1923(95)02236-Q</a>&gt;, simplified by
    Yan and Hunt (1999) &lt;<a href="https://doi.org/10.1006%2Fanbo.1999.0955">doi:10.1006/anbo.1999.0955</a>&gt; see eq: 4), reproduction in
    form of an Ricker model (see Ricker (1954) &lt;<a href="https://doi.org/10.1139%2Ff54-039">doi:10.1139/f54-039</a>&gt; and
    Cabral and Schurr (2010) &lt;<a href="https://doi.org/10.1111%2Fj.1466-8238.2009.00492.x">doi:10.1111/j.1466-8238.2009.00492.x</a>&gt;),
    as well as metabolic scaling based on the metabolic theory of ecology
    (see Brown et al. (2004) &lt;<a href="https://doi.org/10.1890%2F03-9000">doi:10.1890/03-9000</a>&gt; and
    Brown, Sibly and Kodric-Brown (2012)
    &lt;<a href="https://doi.org/10.1002%2F9781119968535.ch">doi:10.1002/9781119968535.ch</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>see inst/COPYRIGHTS</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://metaRange.github.io/metaRange/">https://metaRange.github.io/metaRange/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/metaRange/metaRange/issues">https://github.com/metaRange/metaRange/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), terra, R6, checkmate, grDevices, graphics,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-09 11:51:34 UTC; srfall</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Fallert <a href="https://orcid.org/0000-0002-9939-4219"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Lea Li [aut, cph] (Implemented the first version of the metabolic
    scaling),
  Juliano Sarmento Cabral
    <a href="https://orcid.org/0000-0002-0116-220X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cph,
    ths],
  Tyler Morgan-Wall <a href="https://orcid.org/0000-0002-3131-3814"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cph],
  Bavarian Ministry of Science and Arts (bayklif) [fnd],
  Deutsche Bundesstiftung Umwelt (DBU) [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Fallert &lt;srfallert@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-09 12:20:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculate_dispersal_kernel'>Calculate 2D dispersal kernel.</h2><span id='topic+calculate_dispersal_kernel'></span>

<h3>Description</h3>

<p>Use a user defined function to create a 2D dispersal kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_dispersal_kernel(max_dispersal_dist, kfun, normalize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_dispersal_kernel_+3A_max_dispersal_dist">max_dispersal_dist</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> maximum dispersal distance.</p>
</td></tr>
<tr><td><code id="calculate_dispersal_kernel_+3A_kfun">kfun</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;function&gt;&#8288;</code> the kernel function to use. Can be user-defined,
in which case it needs to vectorized and accept (at least) the parameter
&quot;x&quot; representing the distance from the source as its input and return a
vector of the same size as <code>max_dispersal_dist</code>.</p>
</td></tr>
<tr><td><code id="calculate_dispersal_kernel_+3A_normalize">normalize</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;boolean&gt;&#8288;</code> whether to normalize the kernel.</p>
</td></tr>
<tr><td><code id="calculate_dispersal_kernel_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dispersal kernel with probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a very simple uniform kernel
uniform_kernel &lt;- calculate_dispersal_kernel(
    max_dispersal_dist = 3,
    kfun = function(x) {
        x * 0 + 1
    }
)
# same as
stopifnot(
    uniform_kernel == matrix(1 / 49, nrow = 7, ncol = 7)
)

# now a negative exponential kernel
# not that `mean_dispersal_dist`
# is passed to the kernel function.
calculate_dispersal_kernel(
    max_dispersal_dist = 3,
    kfun = negative_exponential_function,
    mean_dispersal_dist = 1
)
</code></pre>

<hr>
<h2 id='calculate_normalization_constant'>Normalization constant calculation</h2><span id='topic+calculate_normalization_constant'></span>

<h3>Description</h3>

<p>Calculates the normalization constant for the metabolic scaling
based on a known or estimated parameter value under at a reference temperature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_normalization_constant(
  parameter_value,
  scaling_exponent,
  mass,
  reference_temperature,
  E = NULL,
  k = 8.617333e-05,
  warn_if_possibly_false_input = getOption("metaRange.verbose", default = FALSE) &gt; 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_normalization_constant_+3A_parameter_value">parameter_value</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> parameter value at the reference temperature.</p>
</td></tr>
<tr><td><code id="calculate_normalization_constant_+3A_scaling_exponent">scaling_exponent</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> allometric scaling exponent of the mass.</p>
</td></tr>
<tr><td><code id="calculate_normalization_constant_+3A_mass">mass</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code>  mean (individual) mass.</p>
</td></tr>
<tr><td><code id="calculate_normalization_constant_+3A_reference_temperature">reference_temperature</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> reference temperature in kelvin (K).</p>
</td></tr>
<tr><td><code id="calculate_normalization_constant_+3A_e">E</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> Activation energy in electronvolts (eV).</p>
</td></tr>
<tr><td><code id="calculate_normalization_constant_+3A_k">k</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> Boltzmann's constant (eV / K).</p>
</td></tr>
<tr><td><code id="calculate_normalization_constant_+3A_warn_if_possibly_false_input">warn_if_possibly_false_input</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;boolean&gt;&#8288;</code> Print a warning if the input
is different from the known literature value combinations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note the different scaling values for different parameter.
The following is a summary from table 4 in Brown, Sibly and Kodric-Brown (2012)
(see references).</p>

<table>
<tr>
 <td style="text-align: left;">
   Parameter </td><td style="text-align: center;"> Scaling exponent </td><td style="text-align: right;"> Activation energy </td>
</tr>
<tr>
 <td style="text-align: left;">
   resource usage </td><td style="text-align: center;"> 3/4 </td><td style="text-align: right;"> -0.65 </td>
</tr>
<tr>
 <td style="text-align: left;">
   reproduction, mortality </td><td style="text-align: center;"> -1/4 </td><td style="text-align: right;"> -0.65 </td>
</tr>
<tr>
 <td style="text-align: left;">
   carrying capacity </td><td style="text-align: center;"> -3/4 </td><td style="text-align: right;"> 0.65 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>The calculated normalization constant.
</p>


<h3>References</h3>

<p>Brown, J.H., Gillooly, J.F., Allen, A.P., Savage, V.M. and West, G.B. (2004)
Toward a Metabolic Theory of Ecology. <em>Ecology</em>, <strong>85</strong> 1771&ndash;1789.
<a href="https://doi.org/10.1890/03-9000">doi:10.1890/03-9000</a>
</p>
<p>Brown, J.H., Sibly, R.M. and Kodric-Brown, A. (2012)
Introduction: Metabolism as the Basis for a Theoretical Unification of Ecology.
In <em>Metabolic Ecology</em> (eds R.M. Sibly, J.H. Brown and A. Kodric-Brown)
<a href="https://doi.org/10.1002/9781119968535.ch">doi:10.1002/9781119968535.ch</a>
</p>


<h3>See Also</h3>

<p><code>metabolic_scaling()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calculate_normalization_constant(
    parameter_value = 1,
    scaling_exponent = -1 / 4,
    mass = 1,
    reference_temperature = 273.15,
    E = -0.65
)
</code></pre>

<hr>
<h2 id='calculate_suitability'>Calculate (estimate) environmental suitability</h2><span id='topic+calculate_suitability'></span>

<h3>Description</h3>

<p>Calculate / estimate the environmental suitability for a given environmental value,
based on a beta distribution, using the three &quot;cardinal&quot; values of the species for that environmental niche.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_suitability(vmax, vopt, vmin, venv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_suitability_+3A_vmax">vmax</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> upper (i.e. maximum) tolerable value</p>
</td></tr>
<tr><td><code id="calculate_suitability_+3A_vopt">vopt</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> optimal (i.e. preferred) value</p>
</td></tr>
<tr><td><code id="calculate_suitability_+3A_vmin">vmin</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> lower (i.e. minimum) tolerable value</p>
</td></tr>
<tr><td><code id="calculate_suitability_+3A_venv">venv</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> environmental value for which to calculate the suitability</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The environmental suitability is calculated based on a beta distribution
after a formula provided by Yin et al. (1995) and simplified by Yan and Hunt (1999) (see references paragraph)
</p>
<p style="text-align: center;"><code class="reqn">suitability = (\frac{V_{max} - V_{env}}{V_{max} - V_{opt}}) * (\frac{V_{env} - V_{min}}{V_{opt} - V_{min}})^{\frac{V_{opt} - V_{min}}{V_{max} - V_{opt}}}</code>
</p>



<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> environmental suitability
</p>


<h3>Note</h3>

<p>The original formula by Yin et al. was only intended to calculate
the relative daily growth rate of plants in relation to temperature. The abstraction to
use this to A) calculate a niche suitability; and B) use it on other
environmental values than temperature might not be valid. However, the assumption that the
environmental suitability for one niche dimension is highest at one optimal value and
decreases towards the tolerable minimum and maximum values in a nonlinear fashion seems reasonable.
</p>


<h3>References</h3>

<p>Yin, X., Kropff, M.J., McLaren, G., Visperas, R.M., (1995)
A nonlinear model for crop development as a function of temperature,
<em>Agricultural and Forest Meteorology</em>,
Volume <strong>77</strong>, Issues 1–2,
Pages 1&ndash;16,
<a href="https://doi.org/10.1016/0168-1923%2895%2902236-Q">doi:10.1016/0168-1923(95)02236-Q</a>
</p>
<p>Also, see equation 4 in:
Weikai Yan, L.A. Hunt, (1999)
An Equation for Modelling the Temperature Response of Plants using only the Cardinal Temperatures,
<em>Annals of Botany</em>,
Volume <strong>84</strong>, Issue 5,
Pages 607&ndash;614,
ISSN 0305-7364,
<a href="https://doi.org/10.1006/anbo.1999.0955">doi:10.1006/anbo.1999.0955</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calculate_suitability(
    vmax = 30,
    vopt = 25,
    vmin = 10,
    venv = 1:40
)
calculate_suitability(
    vmax = seq(30, 32, length.out = 40),
    vopt = seq(20, 23, length.out = 40),
    vmin = seq(9, 11, length.out = 40),
    venv = 1:40
)

try(calculate_suitability(
    vmax = 1,
    vopt = seq(20, 23, length.out = 40),
    vmin = seq(9, 11, length.out = 40),
    venv = 1:40
))
</code></pre>

<hr>
<h2 id='create_simulation'>Create a simulation</h2><span id='topic+create_simulation'></span>

<h3>Description</h3>

<p>Creates a <a href="#topic+metaRangeSimulation">metaRangeSimulation</a> object.
A convenience wrapper for <code>metaRangeSimulation$new()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_simulation(source_environment, ID = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_simulation_+3A_source_environment">source_environment</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;SpatRasterDataset&gt;&#8288;</code> created by <code><a href="terra.html#topic+sds">terra::sds()</a></code> that represents the environment.
The individual data sets represent different environmental variables
(e.g. temperature or habitat availability) and the different layer of the data sets
represent the different timesteps of the simulation.
The function <a href="#topic+metaRangeSimulation">metaRangeSimulation</a><code style="white-space: pre;">&#8288;$set_time_layer_mapping()&#8288;</code> can be used
to extend/ shorten the simulation timesteps and set the mapping between each time step and a corresponding
environmental layer. This can be used e.g. to repeat the first (few) layer as a burn-in period.
The number of layers must be the same for all data sets.</p>
</td></tr>
<tr><td><code id="create_simulation_+3A_id">ID</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> optional simulation identification string.
Will be set automatically if none is specified.</p>
</td></tr>
<tr><td><code id="create_simulation_+3A_seed">seed</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> optional seed for the random number generator.
Will be set automatically if none is specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+metaRangeSimulation">metaRangeSimulation</a> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
names(sim_env) &lt;- "env_01"
test_sim &lt;- create_simulation(sim_env)
</code></pre>

<hr>
<h2 id='dispersal'>Dispersal process</h2><span id='topic+dispersal'></span>

<h3>Description</h3>

<p>Disperse a (abundance) matrix using a dispersal kernel and optional weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispersal(dispersal_kernel, abundance, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispersal_+3A_dispersal_kernel">dispersal_kernel</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code> dispersal kernel.</p>
</td></tr>
<tr><td><code id="dispersal_+3A_abundance">abundance</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code> abundance matrix.</p>
</td></tr>
<tr><td><code id="dispersal_+3A_weights">weights</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code>  optional weights in form of a matrix
that has the same dimensions as the abundance and a range: between <code style="white-space: pre;">&#8288;0, 1&#8288;</code>.
Should not contain any <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The abundance matrix is dispersed using the dispersal kernel.
If a matrix of weights is supplied, the individuals will redistribute
within the dispersal kernel according to the weights.
I.e. individuals will more likely move towards areas with a higher
weight, if they are within their dispersal distance.
Note:
</p>

<ul>
<li><p> the abundance is modified in place, to optimize performance.
</p>
</li>
<li><p> Any <code>NA</code> or <code>NaN</code> in abundance or weights will be (in-place) replaced by <code>0</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code> Dispersed abundance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
n2 &lt;- n^2
abu &lt;- matrix(1:n2, nrow = n, ncol = n)
suitab &lt;- matrix(1, nrow = n, ncol = n)
kernel &lt;- calculate_dispersal_kernel(
    max_dispersal_dist = 4,
    kfun = negative_exponential_function,
    mean_dispersal_dist = 1.2
)
res1 &lt;- dispersal(
    dispersal_kernel = kernel,
    abundance = abu
)
res2 &lt;- dispersal(
    dispersal_kernel = kernel,
    abundance = abu,
    weights = suitab
)
stopifnot(sum(res1) - sum(res2) &lt; 0.01)
# Note that the abundance is modified in place, i.e:
stopifnot(sum(abu - res2) &lt; 0.01)
</code></pre>

<hr>
<h2 id='dispersal_fixed_unweighted'>Unweighted and fixed sized dispersal</h2><span id='topic+dispersal_fixed_unweighted'></span>

<h3>Description</h3>

<p>Dispersal function that uses a fixed sized kernel that isn't influenced by
external factors. The individuals in each cell are redistributed to the
surrounding cells according to probability defined in the dispersal kernel.
Useful for e.g. wind dispersed plants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispersal_fixed_unweighted(abundance, dispersal_kernel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispersal_fixed_unweighted_+3A_abundance">abundance</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code> Values need to be non-negative.</p>
</td></tr>
<tr><td><code id="dispersal_fixed_unweighted_+3A_dispersal_kernel">dispersal_kernel</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code> Dispersal kernel. Needs to have an odd size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code> The new abundance matrix.
</p>

<hr>
<h2 id='dispersal_fixed_weighted'>Weighted and fixed sized dispersal</h2><span id='topic+dispersal_fixed_weighted'></span>

<h3>Description</h3>

<p>Dispersal function that uses a fixed sized kernel and weighted dispersal towards areas that have a higher weight.
Use case are e.g. animals that can sense their surroundings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispersal_fixed_weighted(abundance, weights, dispersal_kernel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispersal_fixed_weighted_+3A_abundance">abundance</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code> Values need to be non-negative.</p>
</td></tr>
<tr><td><code id="dispersal_fixed_weighted_+3A_weights">weights</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code> Values need to non-missing and between 0 and 1 for the result to make sense.
Needs to have same size as abundance.</p>
</td></tr>
<tr><td><code id="dispersal_fixed_weighted_+3A_dispersal_kernel">dispersal_kernel</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code> Dispersal kernel. Needs to have an odd size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code> The new abundance matrix.
</p>

<hr>
<h2 id='metabolic_scaling'>Metabolic scaling</h2><span id='topic+metabolic_scaling'></span>

<h3>Description</h3>

<p>A function to calculate the metabolic scaling of a parameter, based on the
metabolic theory of ecology (Brown et al. 2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metabolic_scaling(
  normalization_constant,
  scaling_exponent,
  mass,
  temperature,
  E,
  k = 8.617333e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metabolic_scaling_+3A_normalization_constant">normalization_constant</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> normalization constant.</p>
</td></tr>
<tr><td><code id="metabolic_scaling_+3A_scaling_exponent">scaling_exponent</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> allometric scaling exponent of the mass.</p>
</td></tr>
<tr><td><code id="metabolic_scaling_+3A_mass">mass</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code>  mean (individual) mass.</p>
</td></tr>
<tr><td><code id="metabolic_scaling_+3A_temperature">temperature</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric matrix&gt;&#8288;</code> temperature in kelvin (K).</p>
</td></tr>
<tr><td><code id="metabolic_scaling_+3A_e">E</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> activation energy in electronvolts (eV).</p>
</td></tr>
<tr><td><code id="metabolic_scaling_+3A_k">k</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> Boltzmann's constant (eV / K).</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Equation:</h4>

<p>The function uses the equation in the form of:
</p>
<p style="text-align: center;"><code class="reqn">parameter = normalization\_constant \cdot mass^{scaling\_exponent} \cdot e^{\frac{Activation\_energy}{k \cdot temperature}}</code>
</p>




<h4>Parameter:</h4>

<p>Note the different scaling values for different parameter.
The following is a summary from table 4 in Brown, Sibly and Kodric-Brown (2012)
(see references).</p>

<table>
<tr>
 <td style="text-align: left;">
   Parameter </td><td style="text-align: center;"> Scaling exponent </td><td style="text-align: right;"> Activation energy </td>
</tr>
<tr>
 <td style="text-align: left;">
   resource usage </td><td style="text-align: center;"> 3/4 </td><td style="text-align: right;"> -0.65 </td>
</tr>
<tr>
 <td style="text-align: left;">
   reproduction, mortality </td><td style="text-align: center;"> -1/4 </td><td style="text-align: right;"> -0.65 </td>
</tr>
<tr>
 <td style="text-align: left;">
   carrying capacity </td><td style="text-align: center;"> -3/4 </td><td style="text-align: right;"> 0.65 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h4>Units:</h4>

<p style="text-align: center;"><code class="reqn">1 \ electronvolt = 1.602176634 \cdot 10^{-19} Joule</code>
</p>

<p style="text-align: center;"><code class="reqn">Boltzmann \ constant = 1.380649 \cdot 10^{-23} \frac{Joule}{Kelvin}</code>
</p>

<p style="text-align: center;"><code class="reqn">Boltzmann \ constant \ in \frac{eV}{K} = 8.617333e-05 = \frac{1.380649 \cdot 10^{-23}}{1.602176634 \cdot 10^{-19}}</code>
</p>




<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> The scaled parameter.
</p>


<h3>References</h3>

<p>Brown, J.H., Gillooly, J.F., Allen, A.P., Savage, V.M. and West, G.B. (2004)
Toward a Metabolic Theory of Ecology. <em>Ecology</em>, <strong>85</strong> 1771&ndash;1789.
<a href="https://doi.org/10.1890/03-9000">doi:10.1890/03-9000</a>
</p>
<p>Brown, J.H., Sibly, R.M. and Kodric-Brown, A. (2012)
Introduction: Metabolism as the Basis for a Theoretical Unification of Ecology.
In <em>Metabolic Ecology</em> (eds R.M. Sibly, J.H. Brown and A. Kodric-Brown)
<a href="https://doi.org/10.1002/9781119968535.ch">doi:10.1002/9781119968535.ch</a>
</p>


<h3>See Also</h3>

<p><code>calculate_normalization_constant()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reproduction_rate &lt;- 0.25
E_reproduction_rate &lt;- -0.65
estimated_normalization_constant &lt;-
    calculate_normalization_constant(
        parameter_value = reproduction_rate,
        scaling_exponent = -1/4,
        mass = 100,
        reference_temperature = 273.15 + 10,
        E = E_reproduction_rate
    )
metabolic_scaling(
    normalization_constant = estimated_normalization_constant,
    scaling_exponent = -1/4,
    mass = 100,
    temperature = 273.15 + 20,
    E = E_reproduction_rate
)

carrying_capacity &lt;- 100
E_carrying_capacity &lt;- 0.65
estimated_normalization_constant &lt;-
    calculate_normalization_constant(
        parameter_value = carrying_capacity,
        scaling_exponent = -3/4,
        mass = 100,
        reference_temperature = 273.15 + 10,
        E = E_carrying_capacity
    )
metabolic_scaling(
    normalization_constant = estimated_normalization_constant,
    scaling_exponent = -3/4,
    mass = 100,
    temperature = 273.15 + 20,
    E = E_carrying_capacity
)
</code></pre>

<hr>
<h2 id='metaRange-package'>metaRange: Framework to Build Mechanistic and Metabolic Constrained Species Distribution Models</h2><span id='topic+metaRange'></span><span id='topic+metaRange-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Build spatially and temporally explicit process-based species distribution models, that can include an arbitrary number of environmental factors, species and processes including metabolic constraints and species interactions. The focus of the package is simulating populations of one or multiple species in a grid-based landscape and studying the meta-population dynamics and emergent patterns that arise from the interaction of species under complex environmental conditions. It provides functions for common ecological processes such as negative exponential, kernel-based dispersal (see Nathan et al. (2012) <a href="https://doi.org/10.1093/acprof%3Aoso/9780199608898.003.0015">doi:10.1093/acprof:oso/9780199608898.003.0015</a>), calculation of the environmental suitability based on cardinal values ( Yin et al. (1995) <a href="https://doi.org/10.1016/0168-1923%2895%2902236-Q">doi:10.1016/0168-1923(95)02236-Q</a>, simplified by Yan and Hunt (1999) <a href="https://doi.org/10.1006/anbo.1999.0955">doi:10.1006/anbo.1999.0955</a> see eq: 4), reproduction in form of an Ricker model (see Ricker (1954) <a href="https://doi.org/10.1139/f54-039">doi:10.1139/f54-039</a> and Cabral and Schurr (2010) <a href="https://doi.org/10.1111/j.1466-8238.2009.00492.x">doi:10.1111/j.1466-8238.2009.00492.x</a>), as well as metabolic scaling based on the metabolic theory of ecology (see Brown et al. (2004) <a href="https://doi.org/10.1890/03-9000">doi:10.1890/03-9000</a> and Brown, Sibly and Kodric-Brown (2012) <a href="https://doi.org/10.1002/9781119968535.ch">doi:10.1002/9781119968535.ch</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Stefan Fallert <a href="mailto:srfallert@gmail.com">srfallert@gmail.com</a> (<a href="https://orcid.org/0000-0002-9939-4219">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Lea Li (Implemented the first version of the metabolic scaling) [copyright holder]
</p>
</li>
<li><p> Juliano Sarmento Cabral <a href="mailto:j.sarmentocabral@bham.ac.uk">j.sarmentocabral@bham.ac.uk</a> (<a href="https://orcid.org/0000-0002-0116-220X">ORCID</a>) [copyright holder, thesis advisor]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Tyler Morgan-Wall (<a href="https://orcid.org/0000-0002-3131-3814">ORCID</a>) [contributor, copyright holder]
</p>
</li>
<li><p> Bavarian Ministry of Science and Arts (bayklif) [funder]
</p>
</li>
<li><p> Deutsche Bundesstiftung Umwelt (DBU) [funder]
</p>
</li></ul>



<h3>References</h3>

<p>Fallert, S., Li, L., &amp; Sarmento Cabral, J. (2023).
metaRange: Framework to Build Mechanistic and Metabolic Constrained Species Distribution Models.
Zenodo. <a href="https://doi.org/10.5281/zenodo.10364778">doi:10.5281/zenodo.10364778</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://metaRange.github.io/metaRange/">https://metaRange.github.io/metaRange/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/metaRange/metaRange/issues">https://github.com/metaRange/metaRange/issues</a>
</p>
</li></ul>


<hr>
<h2 id='metaRangeEnvironment'>metaRangeEnvironment object</h2><span id='topic+metaRangeEnvironment'></span>

<h3>Description</h3>

<p>Creates an <a href="#topic+metaRangeEnvironment">metaRangeEnvironment</a> object in form of an
<a href="R6.html#topic+R6Class">R6</a> class that stores and handles the environmental
values that influence the species in the simulation.
</p>


<h3>Value</h3>

<p>An <code style="white-space: pre;">&#8288;&lt;metaRangeEnvironment&gt;&#8288;</code> object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>sourceSDS</code></dt><dd><p>A <em>SpatRasterDataset</em> created by <code><a href="terra.html#topic+sds">terra::sds()</a></code>
that holds all the environmental values influencing the simulation.
Note that the individual data sets should be sensibly named as
their names will used throughout the simulation to refer to them.</p>
</dd>
<dt><code>current</code></dt><dd><p>an R environment that holds all the
environmental values influencing the present time step of the
simulation as regular 2D R matrices.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-metaRangeEnvironment-new"><code>metaRangeEnvironment$new()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeEnvironment-set_current"><code>metaRangeEnvironment$set_current()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeEnvironment-print"><code>metaRangeEnvironment$print()</code></a>
</p>
</li></ul>


<hr>
<a id="method-metaRangeEnvironment-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new <a href="#topic+metaRangeEnvironment">metaRangeEnvironment</a> object.
This is done automatically when a simulation is created. No need to
call this as user.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeEnvironment$new(sourceSDS = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sourceSDS</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;SpatRasterDataset&gt;&#8288;</code> created by <code><a href="terra.html#topic+sds">terra::sds()</a></code>
that holds all the environmental values influencing the simulation.
Note that the individual data sets should be sensibly named as
their names will used throughout the simulation to refer to them.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code style="white-space: pre;">&#8288;&lt;metaRangeEnvironment&gt;&#8288;</code> object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Note: Only for illustration purposes.
env &lt;- metaRangeEnvironment$new(sourceSDS = terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2)))
env
</pre>
</div>


<hr>
<a id="method-metaRangeEnvironment-set_current"></a>



<h4>Method <code>set_current()</code></h4>

<p>Set current (active) time step / environment.
No reason to call this as user. The current time step is set automatically.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeEnvironment$set_current(layer)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>layer</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> layer</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Only for illustration purposes.
sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2, nlyr = 2))
names(sim_env) &lt;- "env_01"
env &lt;- metaRangeEnvironment$new(sourceSDS = sim_env)
env$set_current(layer = 1)
</pre>
</div>


<hr>
<a id="method-metaRangeEnvironment-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints information about the environment to the console
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeEnvironment$print()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>env &lt;- metaRangeEnvironment$new(
    sourceSDS = terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2, nlyr = 2))
)
env$print()
</pre>
</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `metaRangeEnvironment$new`
## ------------------------------------------------

# Note: Only for illustration purposes.
env &lt;- metaRangeEnvironment$new(sourceSDS = terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2)))
env

## ------------------------------------------------
## Method `metaRangeEnvironment$set_current`
## ------------------------------------------------

# Only for illustration purposes.
sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2, nlyr = 2))
names(sim_env) &lt;- "env_01"
env &lt;- metaRangeEnvironment$new(sourceSDS = sim_env)
env$set_current(layer = 1)

## ------------------------------------------------
## Method `metaRangeEnvironment$print`
## ------------------------------------------------

env &lt;- metaRangeEnvironment$new(
    sourceSDS = terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2, nlyr = 2))
)
env$print()
</code></pre>

<hr>
<h2 id='metaRangePriorityQueue'>Process priority queue</h2><span id='topic+metaRangePriorityQueue'></span>

<h3>Description</h3>

<p>Creates a priority queue in form of an <a href="R6.html#topic+R6Class">R6</a> class,
that manages the correct process execution order.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;metaRangePriorityQueue&gt;&#8288;</code> A <a href="#topic+metaRangePriorityQueue">metaRangePriorityQueue</a> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-metaRangePriorityQueue-new"><code>metaRangePriorityQueue$new()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangePriorityQueue-execute_next_process"><code>metaRangePriorityQueue$execute_next_process()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangePriorityQueue-enqueue"><code>metaRangePriorityQueue$enqueue()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangePriorityQueue-dequeue"><code>metaRangePriorityQueue$dequeue()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangePriorityQueue-sort_future_queue"><code>metaRangePriorityQueue$sort_future_queue()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangePriorityQueue-update"><code>metaRangePriorityQueue$update()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangePriorityQueue-is_empty"><code>metaRangePriorityQueue$is_empty()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangePriorityQueue-get_queue"><code>metaRangePriorityQueue$get_queue()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangePriorityQueue-get_future_queue"><code>metaRangePriorityQueue$get_future_queue()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangePriorityQueue-get_current_index"><code>metaRangePriorityQueue$get_current_index()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangePriorityQueue-print"><code>metaRangePriorityQueue$print()</code></a>
</p>
</li></ul>


<hr>
<a id="method-metaRangePriorityQueue-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new <a href="#topic+metaRangePriorityQueue">metaRangePriorityQueue</a> object.
Note: No reason to call this as user.
The priority queue is created automatically when a simulation is created.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangePriorityQueue$new()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;metaRangePriorityQueue&gt;&#8288;</code> A <a href="#topic+metaRangePriorityQueue">metaRangePriorityQueue</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Only for illustration purposes.
pr_queue &lt;- metaRangePriorityQueue$new()
pr_queue
</pre>
</div>


<hr>
<a id="method-metaRangePriorityQueue-execute_next_process"></a>



<h4>Method <code>execute_next_process()</code></h4>

<p>Executes the next process in the queue.
No reason to call this as user. The next process is executed automatically.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangePriorityQueue$execute_next_process(verbose)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;logical&gt;&#8288;</code> Print timing and information or not.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;logical&gt;&#8288;</code> <code>TRUE</code> if the next process has been executed,
<code>FALSE</code> if not and the queue is empty.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Only for illustration purposes.
pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$update()
pr_queue$execute_next_process(verbose = TRUE)
</pre>
</div>


<hr>
<a id="method-metaRangePriorityQueue-enqueue"></a>



<h4>Method <code>enqueue()</code></h4>

<p>Add a process to the (future) queue.
Users should only use this method if they added a process to the simulation
via the add_process method of the simulation object with the argument
<code>queue = FALSE</code>. Otherwise the process is added to the queue automatically.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangePriorityQueue$enqueue(process)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>process</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;metaRangeProcess&gt;&#8288;</code> A <a href="#topic+metaRangeProcess">metaRangeProcess</a> that should be added
to the queue.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;boolean&gt;&#8288;</code> <code>TRUE</code> on success <code>FALSE</code> on failure.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$get_future_queue()
</pre>
</div>


<hr>
<a id="method-metaRangePriorityQueue-dequeue"></a>



<h4>Method <code>dequeue()</code></h4>

<p>Remove a process from the (future) queue.
Useful to remove a process from the queue if it is no longer needed.
E.g. if a species went extinct.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangePriorityQueue$dequeue(PID = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>PID</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> the ID of the process, that should be dequeued.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;boolean&gt;&#8288;</code> <code>TRUE</code> on success <code>FALSE</code> on failure.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$dequeue(pr$get_PID())
pr_queue$get_future_queue()
</pre>
</div>


<hr>
<a id="method-metaRangePriorityQueue-sort_future_queue"></a>



<h4>Method <code>sort_future_queue()</code></h4>

<p>Sort the (future) queue based on the execution priority.
This method is called automatically when a process is added to the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangePriorityQueue$sort_future_queue()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$sort_future_queue()
# at least no error
</pre>
</div>


<hr>
<a id="method-metaRangePriorityQueue-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update and reset the queue.
This method is called automatically at the end of each time step.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangePriorityQueue$update()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$update()
pr_queue$get_queue()
</pre>
</div>


<hr>
<a id="method-metaRangePriorityQueue-is_empty"></a>



<h4>Method <code>is_empty()</code></h4>

<p>Check if the queue is empty.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangePriorityQueue$is_empty()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;boolean&gt;&#8288;</code> <code>TRUE</code> if queue is empty <code>FALSE</code> otherwise.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr_queue &lt;- metaRangePriorityQueue$new()
stopifnot(pr_queue$is_empty())
</pre>
</div>


<hr>
<a id="method-metaRangePriorityQueue-get_queue"></a>



<h4>Method <code>get_queue()</code></h4>

<p>Get the current queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangePriorityQueue$get_queue()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;named int vector&gt;&#8288;</code> The current queue.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$update()
pr_queue$get_queue()
</pre>
</div>


<hr>
<a id="method-metaRangePriorityQueue-get_future_queue"></a>



<h4>Method <code>get_future_queue()</code></h4>

<p>Get the future queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangePriorityQueue$get_future_queue()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;named int vector&gt;&#8288;</code> The future queue.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$get_future_queue()
</pre>
</div>


<hr>
<a id="method-metaRangePriorityQueue-get_current_index"></a>



<h4>Method <code>get_current_index()</code></h4>

<p>Get the number / index of the next to be executed process.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangePriorityQueue$get_current_index()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> The index.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$update()
pr_queue$get_current_index()
</pre>
</div>


<hr>
<a id="method-metaRangePriorityQueue-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints information about the queue to the console.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangePriorityQueue$print()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr_queue &lt;- metaRangePriorityQueue$new()
pr_queue$print()
</pre>
</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `metaRangePriorityQueue$new`
## ------------------------------------------------

# Only for illustration purposes.
pr_queue &lt;- metaRangePriorityQueue$new()
pr_queue

## ------------------------------------------------
## Method `metaRangePriorityQueue$execute_next_process`
## ------------------------------------------------

# Only for illustration purposes.
pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$update()
pr_queue$execute_next_process(verbose = TRUE)

## ------------------------------------------------
## Method `metaRangePriorityQueue$enqueue`
## ------------------------------------------------

pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$get_future_queue()

## ------------------------------------------------
## Method `metaRangePriorityQueue$dequeue`
## ------------------------------------------------

pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$dequeue(pr$get_PID())
pr_queue$get_future_queue()

## ------------------------------------------------
## Method `metaRangePriorityQueue$sort_future_queue`
## ------------------------------------------------

pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$sort_future_queue()
# at least no error

## ------------------------------------------------
## Method `metaRangePriorityQueue$update`
## ------------------------------------------------

pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$update()
pr_queue$get_queue()

## ------------------------------------------------
## Method `metaRangePriorityQueue$is_empty`
## ------------------------------------------------

pr_queue &lt;- metaRangePriorityQueue$new()
stopifnot(pr_queue$is_empty())

## ------------------------------------------------
## Method `metaRangePriorityQueue$get_queue`
## ------------------------------------------------

pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$update()
pr_queue$get_queue()

## ------------------------------------------------
## Method `metaRangePriorityQueue$get_future_queue`
## ------------------------------------------------

pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$get_future_queue()

## ------------------------------------------------
## Method `metaRangePriorityQueue$get_current_index`
## ------------------------------------------------

pr_queue &lt;- metaRangePriorityQueue$new()
pr &lt;- metaRangeProcess$new("A", "1", \() {message("test")}, 1, new.env())
pr_queue$enqueue(pr)
pr_queue$update()
pr_queue$get_current_index()

## ------------------------------------------------
## Method `metaRangePriorityQueue$print`
## ------------------------------------------------

pr_queue &lt;- metaRangePriorityQueue$new()
pr_queue$print()
</code></pre>

<hr>
<h2 id='metaRangeProcess'>metaRangeProcess object</h2><span id='topic+metaRangeProcess'></span>

<h3>Description</h3>

<p>Creates an metaRangeProcess object in form of an
<a href="R6.html#topic+R6Class">R6</a> class that stores and handles all the individual parts
that define a process.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;metaRangeProcess&gt;&#8288;</code> A <a href="#topic+metaRangeProcess">metaRangeProcess</a> object.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>fun</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;function&gt;&#8288;</code> The processes function.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-metaRangeProcess-new"><code>metaRangeProcess$new()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeProcess-get_PID"><code>metaRangeProcess$get_PID()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeProcess-get_name"><code>metaRangeProcess$get_name()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeProcess-get_priority"><code>metaRangeProcess$get_priority()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeProcess-get_env_label"><code>metaRangeProcess$get_env_label()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeProcess-print"><code>metaRangeProcess$print()</code></a>
</p>
</li></ul>


<hr>
<a id="method-metaRangeProcess-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new <a href="#topic+metaRangeProcess">metaRangeProcess</a> object
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeProcess$new(
  process_name,
  id = "",
  process_fun,
  execution_priority,
  env,
  env_label = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>process_name</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> name of the process.</p>
</dd>
<dt><code>id</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> optional ID of the process.</p>
</dd>
<dt><code>process_fun</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;function&gt;&#8288;</code> The function to be
called when the process is executed. This function will be executed
in the specified environment (see argument: env) and has access to all the
variables in that environment. This function may not have any arguments,
i.e. <code>is.null(formals(process_fun))</code> must be <code>TRUE</code>.</p>
</dd>
<dt><code>execution_priority</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> the priority of the process.
The lower the number the earlier the process is executed.
Note that the priority is only used to sort the processes
in the priority queue. The actual execution order is determined
by the order of the processes in the queue.</p>
</dd>
<dt><code>env</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;environment&gt;&#8288;</code> the environment where the process should be executed.</p>
</dd>
<dt><code>env_label</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> optional name of the execution environment.
Just used as a human readable label for debug purposes.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;metaRangeProcess&gt;&#8288;</code> A <a href="#topic+metaRangeProcess">metaRangeProcess</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Note: Only for illustration purposes. Use the add_process method of the
# simulation object to add processes to a simulation.
pr &lt;- metaRangeProcess$new(
   process_name = "ecological_process",
   process_fun = function() {
      cat("Execute ecological process!")
   },
   execution_priority = 1L,
   env = new.env(),
   env_label = "a_species_name"
)
pr
</pre>
</div>


<hr>
<a id="method-metaRangeProcess-get_PID"></a>



<h4>Method <code>get_PID()</code></h4>

<p>get the process ID
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeProcess$get_PID()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> The process ID
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr &lt;- metaRangeProcess$new("A", "1", \() {}, 1, new.env())
pr$get_PID()
</pre>
</div>


<hr>
<a id="method-metaRangeProcess-get_name"></a>



<h4>Method <code>get_name()</code></h4>

<p>get the process name
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeProcess$get_name()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> The process name
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr &lt;- metaRangeProcess$new("A", "1", \() {}, 1, new.env())
pr$get_name()
</pre>
</div>


<hr>
<a id="method-metaRangeProcess-get_priority"></a>



<h4>Method <code>get_priority()</code></h4>

<p>get the process execution priority
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeProcess$get_priority()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> The process execution priority
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr &lt;- metaRangeProcess$new("A", "1", \() {}, 1, new.env())
pr$get_priority()
</pre>
</div>


<hr>
<a id="method-metaRangeProcess-get_env_label"></a>



<h4>Method <code>get_env_label()</code></h4>

<p>get the name of the process execution environment
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeProcess$get_env_label()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> The name of the process execution environment or NULL
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr &lt;- metaRangeProcess$new("A", "1", \() {}, 1, new.env(), "human_readable_label")
pr$get_env_label()
</pre>
</div>


<hr>
<a id="method-metaRangeProcess-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints information about the process to the console
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeProcess$print()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>pr &lt;- metaRangeProcess$new("A", "1", \() {}, 1, new.env())
pr$print()
</pre>
</div>




<h3>See Also</h3>

<p><a href="#topic+metaRangePriorityQueue">metaRangePriorityQueue</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `metaRangeProcess$new`
## ------------------------------------------------

# Note: Only for illustration purposes. Use the add_process method of the
# simulation object to add processes to a simulation.
pr &lt;- metaRangeProcess$new(
   process_name = "ecological_process",
   process_fun = function() {
      cat("Execute ecological process!")
   },
   execution_priority = 1L,
   env = new.env(),
   env_label = "a_species_name"
)
pr

## ------------------------------------------------
## Method `metaRangeProcess$get_PID`
## ------------------------------------------------

pr &lt;- metaRangeProcess$new("A", "1", \() {}, 1, new.env())
pr$get_PID()

## ------------------------------------------------
## Method `metaRangeProcess$get_name`
## ------------------------------------------------

pr &lt;- metaRangeProcess$new("A", "1", \() {}, 1, new.env())
pr$get_name()

## ------------------------------------------------
## Method `metaRangeProcess$get_priority`
## ------------------------------------------------

pr &lt;- metaRangeProcess$new("A", "1", \() {}, 1, new.env())
pr$get_priority()

## ------------------------------------------------
## Method `metaRangeProcess$get_env_label`
## ------------------------------------------------

pr &lt;- metaRangeProcess$new("A", "1", \() {}, 1, new.env(), "human_readable_label")
pr$get_env_label()

## ------------------------------------------------
## Method `metaRangeProcess$print`
## ------------------------------------------------

pr &lt;- metaRangeProcess$new("A", "1", \() {}, 1, new.env())
pr$print()
</code></pre>

<hr>
<h2 id='metaRangeSimulation'>metaRangeSimulation object</h2><span id='topic+metaRangeSimulation'></span>

<h3>Description</h3>

<p>Creates an simulation object in form of an
<a href="R6.html#topic+R6Class">R6</a> class that stores and handles all the individual parts
that are necessary to run a simulation.
</p>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;metaRangeSimulation&gt;&#8288;</code> object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ID</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> simulation identification.</p>
</dd>
<dt><code>globals</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;environment&gt;&#8288;</code> a place to store global variables.</p>
</dd>
<dt><code>environment</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;metaRangeEnvironment&gt;&#8288;</code> A <a href="#topic+metaRangeEnvironment">metaRangeEnvironment</a>
that holds all the environmental values influencing the simulation.</p>
</dd>
<dt><code>number_time_steps</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> number of time steps in the simulation.</p>
</dd>
<dt><code>time_step_layer</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> vector of layer IDs
that describe which environmental layer to use at each time step.</p>
</dd>
<dt><code>current_time_step</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> current time step.</p>
</dd>
<dt><code>queue</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;metaRangePriorityQueue&gt;&#8288;</code> manages the order in which the processes should be executed.</p>
</dd>
<dt><code>processes</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;list&gt;&#8288;</code> of global (simulation level) <code style="white-space: pre;">&#8288;&lt;metaRangeProcess&gt;&#8288;</code> (es).</p>
</dd>
<dt><code>seed</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> seed for the random number generator.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-metaRangeSimulation-new"><code>metaRangeSimulation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeSimulation-add_globals"><code>metaRangeSimulation$add_globals()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeSimulation-set_time_layer_mapping"><code>metaRangeSimulation$set_time_layer_mapping()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeSimulation-get_current_time_step"><code>metaRangeSimulation$get_current_time_step()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeSimulation-add_species"><code>metaRangeSimulation$add_species()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeSimulation-species_names"><code>metaRangeSimulation$species_names()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeSimulation-add_process"><code>metaRangeSimulation$add_process()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeSimulation-add_traits"><code>metaRangeSimulation$add_traits()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeSimulation-exit"><code>metaRangeSimulation$exit()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeSimulation-begin"><code>metaRangeSimulation$begin()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeSimulation-print"><code>metaRangeSimulation$print()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeSimulation-summary"><code>metaRangeSimulation$summary()</code></a>
</p>
</li></ul>


<hr>
<a id="method-metaRangeSimulation-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new <a href="#topic+metaRangeSimulation">metaRangeSimulation</a> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSimulation$new(source_environment, ID = NULL, seed = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>source_environment</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;SpatRasterDataset&gt;&#8288;</code> created by <code><a href="terra.html#topic+sds">terra::sds()</a></code> that represents the environment.
The individual data sets represent different environmental variables
(e.g. temperature or habitat availability) and the different layer of the data sets
represent the different timesteps of the simulation.
The function <a href="#topic+metaRangeSimulation">metaRangeSimulation</a><code style="white-space: pre;">&#8288;$set_time_layer_mapping()&#8288;</code> can be used
to extend/ shorten the simulation timesteps and set the mapping between each time step and a corresponding
environmental layer. This can be used e.g. to repeat the first (few) layer as a burn-in period.
The number of layers must be the same for all data sets.</p>
</dd>
<dt><code>ID</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> optional simulation identification string.
Will be set automatically if none is specified.</p>
</dd>
<dt><code>seed</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> optional seed for the random number generator.
Will be set automatically if none is specified.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code style="white-space: pre;">&#8288;&lt;metaRangeSimulation&gt;&#8288;</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim
</pre>
</div>


<hr>
<a id="method-metaRangeSimulation-add_globals"></a>



<h4>Method <code>add_globals()</code></h4>

<p>Add global variables to the simulation
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSimulation$add_globals(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;any&gt;&#8288;</code> the variables to add.
Variables to add to the simulation. They will be saved and accessible
through the 'globals' field.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_globals(a = 1, b = 2)
sim$globals$a
#&gt; [1] 1
</pre>
</div>


<hr>
<a id="method-metaRangeSimulation-set_time_layer_mapping"></a>



<h4>Method <code>set_time_layer_mapping()</code></h4>

<p>Set the time layer of the simulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSimulation$set_time_layer_mapping(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> vector of layer indices
that describe which environmental layer to use at each time step.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2, nlyr = 4))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$set_time_layer_mapping(1:2)
stopifnot(identical(sim$time_step_layer, 1:2))
</pre>
</div>


<hr>
<a id="method-metaRangeSimulation-get_current_time_step"></a>



<h4>Method <code>get_current_time_step()</code></h4>

<p>Get current time step
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSimulation$get_current_time_step()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> the current time step
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$get_current_time_step()
#&gt; [1] 1
</pre>
</div>


<hr>
<a id="method-metaRangeSimulation-add_species"></a>



<h4>Method <code>add_species()</code></h4>

<p>Adds new species to the simulation
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSimulation$add_species(names)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>names</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> names of the species to add.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible boolean&gt;&#8288;</code> <code>TRUE</code> on success <code>FALSE</code> on failure.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_species(c("species_1", "species_2"))
sim$species_1
</pre>
</div>


<hr>
<a id="method-metaRangeSimulation-species_names"></a>



<h4>Method <code>species_names()</code></h4>

<p>Returns the names of all species in the simulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSimulation$species_names()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> vector of species names
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_species("species_1")
sim$add_species("species_2")
sim$species_names()
#&gt; [1] "species_1" "species_2"
</pre>
</div>


<hr>
<a id="method-metaRangeSimulation-add_process"></a>



<h4>Method <code>add_process()</code></h4>

<p>Adds a process to the simulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSimulation$add_process(
  species = NULL,
  process_name,
  process_fun,
  execution_priority,
  queue = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>species</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> Names of the species that the process should be added to.
If <code>NULL</code> the process will be added to the simulation object itself.</p>
</dd>
<dt><code>process_name</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> Name of the process to add.</p>
</dd>
<dt><code>process_fun</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;named function&gt;&#8288;</code> The function to call when the process gets executed.</p>
</dd>
<dt><code>execution_priority</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;positive integer&gt;&#8288;</code> When this process should run within each time step.
1 == highest priority i.e. this function will be the executed first.</p>
</dd>
<dt><code>queue</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;boolean&gt;&#8288;</code> If <code>TRUE</code> the process will be added to the process execution queue directly.
If <code>FALSE</code> the process will be added to the simulation but not to the queue,
which means that in order to execute the process, it has to be added manually
via the <a href="#topic+metaRangePriorityQueue">metaRangePriorityQueue</a><code style="white-space: pre;">&#8288;$enqueue()&#8288;</code> method.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_species("species_1")
sim$add_process("species_1", "species_process_1", function() {message("process_1")}, 1)
sim$species_1$processes$species_process_1
sim$add_process(species = NULL, "global_process_2", function() {message("process_2")}, 2)
sim$processes$global_process_2
</pre>
</div>


<hr>
<a id="method-metaRangeSimulation-add_traits"></a>



<h4>Method <code>add_traits()</code></h4>

<p>Adds traits to a species.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSimulation$add_traits(species, population_level = TRUE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>species</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> Names of the species that the traits should be added to.</p>
</dd>
<dt><code>population_level</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;boolean&gt;&#8288;</code> If <code>TRUE</code> the traits will be added at the population level
(i.e. as a matrix with same dimensions (nrow/ncol) as the environment with one value for each population).
This means that the traits either need to be single values that will be extended
to such a matrix via <code><a href="base.html#topic+matrix">base::matrix()</a></code> or they already need to be a matrix with these dimension.
If <code>FALSE</code> the traits will be added without any conversion and may have any type and dimension.</p>
</dd>
<dt><code>...</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;atomic&gt;&#8288;</code> (see <code><a href="base.html#topic+is.recursive">base::is.atomic()</a></code>) The named traits to be added.
Named means: <code>Name = value</code> e.g. <code>a = 1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_species("species_1")
sim$add_traits("species_1", population_level = TRUE, a = 1)
sim$add_traits("species_1", population_level = FALSE, b = 2, c = "c")
sim$species_1$traits$a
#&gt;      [,1] [,2]
#&gt; [1,]    1    1
#&gt; [2,]    1    1
sim$species_1$traits$b
#&gt; [1] 2
sim$species_1$traits$c
#&gt; [1] "c"
</pre>
</div>


<hr>
<a id="method-metaRangeSimulation-exit"></a>



<h4>Method <code>exit()</code></h4>

<p>When called, will end the simulation (prematurely) once the current process is finished.
Useful to e.g. end the simulation safely (i.e. without an error) when no species is alive anymore
and there would be no benefit to continue the execution until the last time step.
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSimulation$exit()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;invisible NULL&#8288;</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2, nlyr = 4))
names(sim_env) &lt;- "env_var_name"
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_species("species_1")
sim$add_process("species_1", "species_process_1", function() {self$sim$exit()}, 1)
sim$begin()
</pre>
</div>


<hr>
<a id="method-metaRangeSimulation-begin"></a>



<h4>Method <code>begin()</code></h4>

<p>Begins the simulation
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSimulation$begin()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code> The finished simulation
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2, nlyr = 4))
names(sim_env) &lt;- "env_var_name"
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_process(
     species = NULL,
     "timestep_counter",
     function() {
         message("timestep: ", self$get_current_time_step())
     },
     1
)
sim$begin()
</pre>
</div>


<hr>
<a id="method-metaRangeSimulation-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints information about the simulation to the console
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSimulation$print()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$print()
</pre>
</div>


<hr>
<a id="method-metaRangeSimulation-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Summarizes information about the simulation and outputs
it to the console
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSimulation$summary()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$summary()
</pre>
</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `metaRangeSimulation$new`
## ------------------------------------------------

sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim

## ------------------------------------------------
## Method `metaRangeSimulation$add_globals`
## ------------------------------------------------

sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_globals(a = 1, b = 2)
sim$globals$a
#&gt; [1] 1

## ------------------------------------------------
## Method `metaRangeSimulation$set_time_layer_mapping`
## ------------------------------------------------

sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2, nlyr = 4))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$set_time_layer_mapping(1:2)
stopifnot(identical(sim$time_step_layer, 1:2))

## ------------------------------------------------
## Method `metaRangeSimulation$get_current_time_step`
## ------------------------------------------------

sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$get_current_time_step()
#&gt; [1] 1

## ------------------------------------------------
## Method `metaRangeSimulation$add_species`
## ------------------------------------------------

sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_species(c("species_1", "species_2"))
sim$species_1

## ------------------------------------------------
## Method `metaRangeSimulation$species_names`
## ------------------------------------------------

sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_species("species_1")
sim$add_species("species_2")
sim$species_names()
#&gt; [1] "species_1" "species_2"

## ------------------------------------------------
## Method `metaRangeSimulation$add_process`
## ------------------------------------------------

sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_species("species_1")
sim$add_process("species_1", "species_process_1", function() {message("process_1")}, 1)
sim$species_1$processes$species_process_1
sim$add_process(species = NULL, "global_process_2", function() {message("process_2")}, 2)
sim$processes$global_process_2

## ------------------------------------------------
## Method `metaRangeSimulation$add_traits`
## ------------------------------------------------

sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_species("species_1")
sim$add_traits("species_1", population_level = TRUE, a = 1)
sim$add_traits("species_1", population_level = FALSE, b = 2, c = "c")
sim$species_1$traits$a
#&gt;      [,1] [,2]
#&gt; [1,]    1    1
#&gt; [2,]    1    1
sim$species_1$traits$b
#&gt; [1] 2
sim$species_1$traits$c
#&gt; [1] "c"

## ------------------------------------------------
## Method `metaRangeSimulation$exit`
## ------------------------------------------------

sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2, nlyr = 4))
names(sim_env) &lt;- "env_var_name"
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_species("species_1")
sim$add_process("species_1", "species_process_1", function() {self$sim$exit()}, 1)
sim$begin()

## ------------------------------------------------
## Method `metaRangeSimulation$begin`
## ------------------------------------------------

sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2, nlyr = 4))
names(sim_env) &lt;- "env_var_name"
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$add_process(
     species = NULL,
     "timestep_counter",
     function() {
         message("timestep: ", self$get_current_time_step())
     },
     1
)
sim$begin()

## ------------------------------------------------
## Method `metaRangeSimulation$print`
## ------------------------------------------------

sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$print()

## ------------------------------------------------
## Method `metaRangeSimulation$summary`
## ------------------------------------------------

sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sim$summary()
</code></pre>

<hr>
<h2 id='metaRangeSpecies'>metaRangeSpecies object</h2><span id='topic+metaRangeSpecies'></span>

<h3>Description</h3>

<p>Creates an species object in form of an
<a href="R6.html#topic+R6Class">R6</a> class that stores and handles all the individual parts
that define a species.
</p>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;metaRangeSpecies&gt;&#8288;</code> object.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> name or ID of the species.</p>
</dd>
<dt><code>processes</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;list&gt;&#8288;</code> of <code style="white-space: pre;">&#8288;&lt;metaRangeProcesses&gt;&#8288;</code>.
The processes that describe how the species interacts
with the environment, itself and other species.</p>
</dd>
<dt><code>traits</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;environment&gt;&#8288;</code> holds the traits of the species.</p>
</dd>
<dt><code>sim</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;metaRangeSimulation&gt;&#8288;</code> A reference to the <a href="#topic+metaRangeSimulation">metaRangeSimulation</a>
simulation object that the species is part of.
Useful to access environmental data or data of other species.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-metaRangeSpecies-new"><code>metaRangeSpecies$new()</code></a>
</p>
</li>
<li> <p><a href="#method-metaRangeSpecies-print"><code>metaRangeSpecies$print()</code></a>
</p>
</li></ul>


<hr>
<a id="method-metaRangeSpecies-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new <a href="#topic+metaRangeSpecies">metaRangeSpecies</a> object
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSpecies$new(name, sim)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> name or ID of the species.</p>
</dd>
<dt><code>sim</code></dt><dd><p><code style="white-space: pre;">&#8288;&lt;metaRangeSimulation&gt;&#8288;</code> A reference to the <a href="#topic+metaRangeSimulation">metaRangeSimulation</a>
simulation object that the species is part of.
Useful to access environmental data or data of other species.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code style="white-space: pre;">&#8288;&lt;metaRangeSpecies&gt;&#8288;</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># The following is bad practice, since species should be added to a simulation
# via the add_species method of the simulation object. But for illustration
# purposes:
sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
test_sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sp &lt;- metaRangeSpecies$new(name = "species_01", sim = test_sim)
sp
</pre>
</div>


<hr>
<a id="method-metaRangeSpecies-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints information about the species to the console
</p>


<h5>Usage</h5>

<div class="r"><pre>metaRangeSpecies$print()</pre></div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;&lt;invisible self&gt;&#8288;</code>
</p>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `metaRangeSpecies$new`
## ------------------------------------------------

# The following is bad practice, since species should be added to a simulation
# via the add_species method of the simulation object. But for illustration
# purposes:
sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
test_sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
sp &lt;- metaRangeSpecies$new(name = "species_01", sim = test_sim)
sp
</code></pre>

<hr>
<h2 id='negative_exponential_function'>Negative Exponential kernel</h2><span id='topic+negative_exponential_function'></span>

<h3>Description</h3>

<p>Negative Exponential kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negative_exponential_function(x, mean_dispersal_dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negative_exponential_function_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> distance at which the probability is calculated.</p>
</td></tr>
<tr><td><code id="negative_exponential_function_+3A_mean_dispersal_dist">mean_dispersal_dist</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> mean dispersal distance (&gt;0)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The negative exponential kernel is defined as:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{1}{2 \pi a^2} e^{-\frac{x}{a}}</code>
</p>

<p>where <code class="reqn">a</code> is the mean dispersal distance divided by 2.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> The probability at distance x.
</p>


<h3>References</h3>

<p>Nathan, R., Klein, E., Robledo-Arnuncio, J.J. and Revilla, E. (2012)
Dispersal kernels: review.
in: <em>Dispersal Ecology and Evolution</em> pp. 187&ndash;210.
(eds J. Clobert, M. Baguette, T.G. Benton and J.M. Bullock),
Oxford, UK: Oxford Academic, 2013.
<a href="https://doi.org/10.1093/acprof%3Aoso/9780199608898.003.0015">doi:10.1093/acprof:oso/9780199608898.003.0015</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>negative_exponential_function(1, 1)
</code></pre>

<hr>
<h2 id='plot.metaRangeEnvironment'>Plotting function</h2><span id='topic+plot.metaRangeEnvironment'></span>

<h3>Description</h3>

<p>Plots the specified current environment of a <a href="#topic+metaRangeSimulation">metaRangeSimulation</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaRangeEnvironment'
plot(x, env_name, col, as_timeseries = FALSE, main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.metaRangeEnvironment_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;metaRangeEnvironment&gt;&#8288;</code> <a href="#topic+metaRangeEnvironment">metaRangeEnvironment</a> object.</p>
</td></tr>
<tr><td><code id="plot.metaRangeEnvironment_+3A_env_name">env_name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> name of the (sub) environment to plot.</p>
</td></tr>
<tr><td><code id="plot.metaRangeEnvironment_+3A_col">col</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> colors to use. Defaults to <code>grDevices::hcl.colors()</code> with
<code>n = 50</code> and a random palette.</p>
</td></tr>
<tr><td><code id="plot.metaRangeEnvironment_+3A_as_timeseries">as_timeseries</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;logical&gt;&#8288;</code> if <code>TRUE</code>, plot the mean of each layer of the (source)
environment as a line graph over time, if <code>FALSE</code> plot the (current) environment as a raster.</p>
</td></tr>
<tr><td><code id="plot.metaRangeEnvironment_+3A_main">main</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> optional title of the plot. Will be labeled automatically when NULL.</p>
</td></tr>
<tr><td><code id="plot.metaRangeEnvironment_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <a href="terra.html#topic+plot">terra::plot</a> or <a href="base.html#topic+plot">base::plot</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;invisible NULL&gt;&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_env &lt;- terra::sds(terra::rast(vals = rep(1:4, 4), nrow = 2, ncol = 2, nlyr = 4))
names(sim_env) &lt;- "env_01"
test_sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
test_sim$environment$set_current(1)
plot(test_sim$environment, "env_01")
plot(test_sim$environment, "env_01", as_timeseries = TRUE)
</code></pre>

<hr>
<h2 id='plot.metaRangeSimulation'>Plotting function</h2><span id='topic+plot.metaRangeSimulation'></span>

<h3>Description</h3>

<p>Plots the specified element of a <a href="#topic+metaRangeSimulation">metaRangeSimulation</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaRangeSimulation'
plot(x, obj, name, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.metaRangeSimulation_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;metaRangeSimulation&gt;&#8288;</code> <a href="#topic+metaRangeSimulation">metaRangeSimulation</a> object.</p>
</td></tr>
<tr><td><code id="plot.metaRangeSimulation_+3A_obj">obj</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> either the string <code>environment</code> or the name of a species.</p>
</td></tr>
<tr><td><code id="plot.metaRangeSimulation_+3A_name">name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> either the name of an environment of the name of a species trait.</p>
</td></tr>
<tr><td><code id="plot.metaRangeSimulation_+3A_col">col</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> colors to use. Defaults to <code>grDevices::hcl.colors()</code> with
<code>n = 50</code> and a random palette.</p>
</td></tr>
<tr><td><code id="plot.metaRangeSimulation_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <a href="terra.html#topic+plot">terra::plot</a> or <a href="base.html#topic+plot">base::plot</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;invisible NULL&gt;&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
names(sim_env) &lt;- "env_01"
test_sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
plot(test_sim, "environment", "env_01")

test_sim$add_species("species_01")
test_sim$add_traits("species_01", trait_01 = matrix(1, nrow = 2, ncol = 2))
plot(test_sim, "species_01", "trait_01")

test_sim$add_globals("global_01" = 1:10)
plot(test_sim, "globals", "global_01")
</code></pre>

<hr>
<h2 id='plot.metaRangeSpecies'>Plotting function</h2><span id='topic+plot.metaRangeSpecies'></span>

<h3>Description</h3>

<p>Plots the specified trait of a <a href="#topic+metaRangeSpecies">metaRangeSpecies</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaRangeSpecies'
plot(x, trait_name, col, main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.metaRangeSpecies_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;metaRangeSpecies&gt;&#8288;</code> <a href="#topic+metaRangeSpecies">metaRangeSpecies</a> object.</p>
</td></tr>
<tr><td><code id="plot.metaRangeSpecies_+3A_trait_name">trait_name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> name of the trait to plot.</p>
</td></tr>
<tr><td><code id="plot.metaRangeSpecies_+3A_col">col</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> colors to use. Defaults to <code>grDevices::hcl.colors()</code> with
<code>n =50</code> and a random palette.</p>
</td></tr>
<tr><td><code id="plot.metaRangeSpecies_+3A_main">main</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> optional title of the plot. Will be labeled automatically when NULL.</p>
</td></tr>
<tr><td><code id="plot.metaRangeSpecies_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <a href="terra.html#topic+plot">terra::plot</a> or <a href="base.html#topic+plot">base::plot</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;invisible NULL&gt;&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
names(sim_env) &lt;- "env_01"
test_sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
test_sim$add_species("species_01")
test_sim$add_traits("species_01", trait_01 = matrix(1:4, nrow = 2, ncol = 2))
plot(test_sim$species_01, "trait_01")
</code></pre>

<hr>
<h2 id='print.metaRangeVariableStorage'>Print traits or globals</h2><span id='topic+print.metaRangeVariableStorage'></span>

<h3>Description</h3>

<p>Print method for species traits and simulation globals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaRangeVariableStorage'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.metaRangeVariableStorage_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;metaRangeVariableStorage&gt;&#8288;</code> The object to print.</p>
</td></tr>
<tr><td><code id="print.metaRangeVariableStorage_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;any&gt;&#8288;</code> ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;invisible x&gt;&#8288;</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
names(sim_env) &lt;- "env_01"
test_sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
test_sim$add_species("species_01")
test_sim$add_traits(species = "species_01", a = 1)
print(test_sim$species_01$traits)
test_sim$add_globals(b = 2)
print(test_sim$globals)
</code></pre>

<hr>
<h2 id='ricker_allee_reproduction_model'>Ricker reproduction model with Allee effects</h2><span id='topic+ricker_allee_reproduction_model'></span>

<h3>Description</h3>

<p>An implementation of the Ricker reproduction model with Allee effects based on
(Cabral and Schurr, 2010) with variable overcompensation and an extension to
handle negative reproduction rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ricker_allee_reproduction_model(
  abundance,
  reproduction_rate,
  carrying_capacity,
  allee_threshold,
  overcomp_factor = as.numeric(c(1))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ricker_allee_reproduction_model_+3A_abundance">abundance</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> vector (or matrix) of abundances.</p>
</td></tr>
<tr><td><code id="ricker_allee_reproduction_model_+3A_reproduction_rate">reproduction_rate</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> vector (or matrix) of reproduction rates.</p>
</td></tr>
<tr><td><code id="ricker_allee_reproduction_model_+3A_carrying_capacity">carrying_capacity</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> vector (or matrix) of carrying capacities.</p>
</td></tr>
<tr><td><code id="ricker_allee_reproduction_model_+3A_allee_threshold">allee_threshold</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> vector (or matrix) of Allee thresholds.</p>
</td></tr>
<tr><td><code id="ricker_allee_reproduction_model_+3A_overcomp_factor">overcomp_factor</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> overcompensation factor (default: 1.0).
Higher values lead to stronger overcompensation. Can also be a vector or matrix.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Equations:</h4>

<p>If <code class="reqn">reproduction\_rate &gt;= 0</code> (based on: Cabral and Schurr, 2010):
</p>
<p style="text-align: center;"><code class="reqn">N_{t+1} = N_t e^{b r \frac{(K - N_t)(N_t - C)}{(K - C)^2})}</code>
</p>

<p>If <code class="reqn">reproduction\_rate &lt; 0</code>:
</p>
<p style="text-align: center;"><code class="reqn">N_{t+1} = N_t \cdot e^{r}</code>
</p>

<p>With:
</p>

<ul>
<li> <p><code class="reqn">N_t</code> = abundance at time t
</p>
</li>
<li> <p><code class="reqn">N_{t+1}</code> = abundance at time t+1
</p>
</li>
<li> <p><code class="reqn">r</code> = reproduction rate
</p>
</li>
<li> <p><code class="reqn">K</code> = carrying capacity
</p>
</li>
<li> <p><code class="reqn">C</code> = (critical) Allee threshold
</p>
</li>
<li> <p><code class="reqn">b</code> = overcompensation factor
</p>
</li></ul>

<p>Note that:
</p>

<ul>
<li> <p><code>abundance</code> should generally be greater than 0.
</p>
</li>
<li> <p><code>reproduction_rate</code>, <code>carrying_capacity</code> and <code>allee_threshold</code> should either all have the same size as the input abundance or all be of length 1.
</p>
</li>
<li> <p><code>carrying_capacity</code> should be greater than 0. If it is 0 or less, the abundance will be set to 0.
</p>
</li>
<li> <p><code>allee_threshold</code> should be less than <code>carrying_capacity</code>. If it is greater than or equal, the abundance will be set to 0.
</p>
</li></ul>

<p>Important Note:
To optimize performance, the functions modifies the abundance in-place.
This mean the input abundance will be modified (See Examples).
Since the result of this function is usually assigned to the same variable as the input abundance, this is unnoticable in most use cases.
Should you wish to keep the input abundance unchanged, you can <code>rlang::duplicate()</code> it before passing it to this function.
</p>



<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> vector (or matrix) of abundances.
</p>


<h3>References</h3>

<p>Cabral, J.S. and Schurr, F.M. (2010)
Estimating demographic models for the range dynamics of plant species.
<em>Global Ecology and Biogeography</em>, <strong>19</strong>, 85&ndash;97.
<a href="https://doi.org/10.1111/j.1466-8238.2009.00492.x">doi:10.1111/j.1466-8238.2009.00492.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ricker_allee_reproduction_model(
    abundance = 50,
    reproduction_rate = 2,
    carrying_capacity = 100,
    allee_threshold = -100
)
ricker_allee_reproduction_model(
    abundance = 50,
    reproduction_rate = 2,
    carrying_capacity = 100,
    allee_threshold = -100,
    overcomp_factor = 4
)
ricker_allee_reproduction_model(
    abundance = matrix(10, 5, 5),
    reproduction_rate =  0.25,
    carrying_capacity =  100,
    allee_threshold =  20
)
ricker_allee_reproduction_model(
    abundance = matrix(10, 5, 5),
    reproduction_rate =  matrix(seq(-0.5, 0.5, length.out = 25), 5, 5),
    carrying_capacity =  matrix(100, 5, 5),
    allee_threshold =  matrix(20, 5, 5)
)
ricker_allee_reproduction_model(
    abundance = matrix(10, 5, 5),
    reproduction_rate =  matrix(1, 5, 5),
    carrying_capacity =  matrix(100, 5, 5),
    allee_threshold =  matrix(seq(0, 100, length.out = 25), 5, 5)
)
ricker_allee_reproduction_model(
    abundance = matrix(10, 5, 5),
    reproduction_rate =  matrix(seq(0, -2, length.out = 25), 5, 5),
    carrying_capacity =  matrix(100, 5, 5),
    allee_threshold =  matrix(20, 5, 5)
)
# Note that the input abundance is modified in-place
abu &lt;- 10
res &lt;- ricker_allee_reproduction_model(
    abundance = abu,
    reproduction_rate = 0.25,
    carrying_capacity = 100,
    allee_threshold = -100
)
stopifnot(identical(abu, res))
</code></pre>

<hr>
<h2 id='ricker_reproduction_model'>Ricker reproduction model</h2><span id='topic+ricker_reproduction_model'></span>

<h3>Description</h3>

<p>An implementation of the Ricker reproduction model (Ricker, 1954) with
an extension to handle negative reproduction rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ricker_reproduction_model(abundance, reproduction_rate, carrying_capacity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ricker_reproduction_model_+3A_abundance">abundance</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> vector (or matrix) of abundances.</p>
</td></tr>
<tr><td><code id="ricker_reproduction_model_+3A_reproduction_rate">reproduction_rate</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> vector (or matrix) of reproduction rates.</p>
</td></tr>
<tr><td><code id="ricker_reproduction_model_+3A_carrying_capacity">carrying_capacity</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> vector (or matrix) of carrying capacities.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Equations:</h4>

<p>If <code class="reqn">reproduction\_rate &gt;= 0</code> (Ricker, 1954):
</p>
<p style="text-align: center;"><code class="reqn">N_{t+1} = N_t e^{r (1 - \frac{N_t}{K})}</code>
</p>

<p>If <code class="reqn">reproduction\_rate &lt; 0</code>:
</p>
<p style="text-align: center;"><code class="reqn">N_{t+1} = N_t \cdot e^{r}</code>
</p>

<p>With:
</p>

<ul>
<li> <p><code class="reqn">N_t</code> = abundance at time t
</p>
</li>
<li> <p><code class="reqn">N_{t+1}</code> = abundance at time t+1
</p>
</li>
<li> <p><code class="reqn">r</code> = reproduction rate
</p>
</li>
<li> <p><code class="reqn">K</code> = carrying capacity
</p>
</li></ul>

<p>Note that:
</p>

<ul>
<li> <p><code>abundance</code> should generally be greater than 0.
</p>
</li>
<li> <p><code>reproduction_rate</code> and  <code>carrying_capacity</code> should either both have the same size as the input abundance or both be of length 1.
</p>
</li>
<li> <p><code>carrying_capacity</code> should generally be greater than 0. If it is 0 or less, the abundance will be set to 0.
</p>
</li></ul>

<p>Important Note:
To optimize performance, the functions modifies the abundance in-place.
This mean the input abundance will be modified (See Examples).
Since the result of this function is usually assigned to the same variable as the input abundance, this is unnoticable in most use cases.
Should you wish to keep the input abundance unchanged, you can <code>rlang::duplicate()</code> it before passing it to this function.
</p>



<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> vector (or matrix) of abundances.
</p>


<h3>References</h3>

<p>Ricker, W.E. (1954) Stock and recruitment.
<em>Journal of the Fisheries Research Board of Canada</em>, <strong>11</strong>, 559&ndash;623.
<a href="https://doi.org/10.1139/f54-039">doi:10.1139/f54-039</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ricker_reproduction_model(
    abundance = 10,
    reproduction_rate = 0.25,
    carrying_capacity = 100
)
ricker_reproduction_model(
    abundance = matrix(10, 5, 5),
    reproduction_rate =  0.25,
    carrying_capacity =  100
)
ricker_reproduction_model(
    abundance = matrix(10, 5, 5),
    reproduction_rate =  matrix(seq(-0.5, 0.5, length.out = 25), 5, 5),
    carrying_capacity =  matrix(100, 5, 5)
)
ricker_reproduction_model(
    abundance = matrix(10, 5, 5),
    reproduction_rate =  matrix(seq(0, -2, length.out = 25), 5, 5),
    carrying_capacity =  matrix(100, 5, 5)
)
# Note that the input abundance is modified in-place
abu &lt;- 10
res &lt;- ricker_reproduction_model(
    abundance = abu,
    reproduction_rate = 0.25,
    carrying_capacity = 100
)
stopifnot(identical(abu, res))
</code></pre>

<hr>
<h2 id='save_species'>Save function</h2><span id='topic+save_species'></span>

<h3>Description</h3>

<p>Saves the specified traits of a <a href="#topic+metaRangeSpecies">metaRangeSpecies</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_species(x, traits = NULL, prefix = NULL, path, overwrite = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_species_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;metaRangeSpecies&gt;&#8288;</code> <a href="#topic+metaRangeSpecies">metaRangeSpecies</a> object.</p>
</td></tr>
<tr><td><code id="save_species_+3A_traits">traits</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> NULL or a character vector specifying the trait to save.
If NULL, all traits are saved.</p>
</td></tr>
<tr><td><code id="save_species_+3A_prefix">prefix</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code> prefix for the file names or NULL.</p>
</td></tr>
<tr><td><code id="save_species_+3A_path">path</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;string&gt;&#8288;</code>path to the directory where the files are saved.</p>
</td></tr>
<tr><td><code id="save_species_+3A_overwrite">overwrite</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;boolean&gt;&#8288;</code> overwrite existing files.</p>
</td></tr>
<tr><td><code id="save_species_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <a href="terra.html#topic+writeRaster">terra::writeRaster</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generated file names are of the form
<code>file.path(path, paste0(prefix, species_name, "_", trait_name, ".file_extension"))</code>.
If the trait is in a matrix or raster form, the file extension is <code>.tif</code>. Otherwise it is <code>.csv</code>.
The prefix is optional and mainly useful to add a time step to the file name, in case the trait
is saved multiple times during a simulation.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;invisible character&gt;&#8288;</code> the paths to the saved files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
names(sim_env) &lt;- "env_01"
test_sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
test_sim$add_species("species_01")
test_sim$add_traits(
    "species_01",
    trait_01 = matrix(1, nrow = 2, ncol = 2),
    trait_02 = matrix(2, nrow = 2, ncol = 2)
)

file_prefix &lt;- "This_could_be_a_time_step"
directory_name &lt;- tempdir()

res_path &lt;- save_species(
    test_sim$species_01,
    traits = "trait_01",
    prefix = file_prefix,
    path = directory_name
)
# the following should be TRUE
# but might fail due to floating point errors (that's why we round the values)
identical(
    round(terra::as.matrix(terra::rast(res_path), wide = TRUE)),
    round(test_sim$species_01$traits[["trait_01"]])
)

# test overwrite
res_path2 &lt;- save_species(
    test_sim$species_01,
    traits = "trait_01",
    prefix = file_prefix,
    path = directory_name,
    overwrite = TRUE
)
stopifnot(identical(res_path, res_path2))

# Saving all traits
res_path3 &lt;- save_species(
    test_sim$species_01,
    prefix = basename(tempfile()),
    path = directory_name
)
res_path3
# cleanup
unlink(c(res_path, res_path3))
stopifnot(all(!file.exists(res_path, res_path3)))
</code></pre>

<hr>
<h2 id='set_verbosity'>Set verbosity of metaRange simulation</h2><span id='topic+set_verbosity'></span>

<h3>Description</h3>

<p>Just a wrapper for <code style="white-space: pre;">&#8288;options(metaRange.verbose = [0 | 1 | 2])&#8288;</code> but documented.
If <code>0</code>, metaRange functions will print no messages to the console.
If <code>1</code>, metaRange functions will print some messages to the console.
If <code>2</code>, metaRange functions will print many messages to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_verbosity(verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_verbosity_+3A_verbose">verbose</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code> message verbosity (see description).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;invisible list&gt;&#8288;</code> a list with the previous verbosity setting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_verbosity(0)
getOption("metaRange.verbose")
</code></pre>

<hr>
<h2 id='summary.metaRangeSimulation'>Summary for metaRange simulation</h2><span id='topic+summary.metaRangeSimulation'></span>

<h3>Description</h3>

<p>Print a summary of the simulation to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaRangeSimulation'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.metaRangeSimulation_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;metaRangeSimulation&gt;&#8288;</code> The <a href="#topic+metaRangeSimulation">metaRangeSimulation</a> object to summarize.</p>
</td></tr>
<tr><td><code id="summary.metaRangeSimulation_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;any&gt;&#8288;</code> ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;invisible NULL&gt;&#8288;</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
names(sim_env) &lt;- "env_01"
test_sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
test_sim$add_species("species_01")
summary(test_sim)
</code></pre>

<hr>
<h2 id='summary.metaRangeSpecies'>Summary for metaRange species</h2><span id='topic+summary.metaRangeSpecies'></span>

<h3>Description</h3>

<p>Summary for metaRange species
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaRangeSpecies'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.metaRangeSpecies_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;metaRangeSpecies&gt;&#8288;</code> The <a href="#topic+metaRangeSpecies">metaRangeSpecies</a> object to summarize.</p>
</td></tr>
<tr><td><code id="summary.metaRangeSpecies_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;any&gt;&#8288;</code> ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;&lt;invisible NULL&gt;&#8288;</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_env &lt;- terra::sds(terra::rast(vals = 1, nrow = 2, ncol = 2))
names(sim_env) &lt;- "env_01"
test_sim &lt;- metaRangeSimulation$new(source_environment = sim_env)
test_sim$add_species("species_01")
summary(test_sim$species_01)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
