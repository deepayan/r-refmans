<!DOCTYPE html><html><head><title>Help for package SVDNF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SVDNF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DNF.dynamicsSVM'>
<p>Discrete Nonlinear Filtering Algorithm for Stochastic Volatility Models</p></a></li>
<li><a href='#DNFOptim.dynamicsSVM'>
<p>Discrete Nonlinear Filter Maximum Likelihood Estimation Function</p></a></li>
<li><a href='#dynamicsSVM'>
<p>Stochastic Volatility Models Dynamics</p></a></li>
<li><a href='#logLik.SVDNF'><p>Extract Log-Likelihood for <code>SVDNF</code> and <code>DNFOptim</code> Objects</p></a></li>
<li><a href='#modelSim.dynamicsSVM'>
<p>Simulation from Stochastic Volatility Models with Jumps</p></a></li>
<li><a href='#plot.predict.DNFOptim'><p>Plot Predictions from <code>DNFOptim</code> or <code>SVDNF</code> Objects</p></a></li>
<li><a href='#plot.SVDNF'>
<p>DNF Filtering Distribution Plot Function</p></a></li>
<li><a href='#predict.DNFOptim'>
<p>Predict Method for <code>DNFOptim</code> and <code>SVDNF</code> Objects</p></a></li>
<li><a href='#summary.DNFOptim'><p>Summarizing Stochastic Volatility Model Fits from the Discrete Nonlinear Filter</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Discrete Nonlinear Filtering for Stochastic Volatility Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Author:</td>
<td>Louis Arsenault-Mahjoubi [aut, cre],
  Jean-François Bégin [aut],
  Mathieu Boudreault [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Louis Arsenault-Mahjoubi &lt;larsenau@sfu.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates simulated paths from various financial stochastic volatility models
 with jumps and applies the discrete nonlinear filter (DNF) of Kitagawa (1987) &lt;<a href="https://doi.org/10.1080%2F01621459.1987.10478534">doi:10.1080/01621459.1987.10478534</a>&gt; to 
 compute likelihood evaluations, filtering distribution estimates, and maximum likelihood parameter estimates.
 The algorithm is implemented following the work of Bégin and Boudreault (2021) &lt;<a href="https://doi.org/10.1080%2F10618600.2020.1840995">doi:10.1080/10618600.2020.1840995</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.9), methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-28 21:28:08 UTC; Louis</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-08 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DNF.dynamicsSVM'>
Discrete Nonlinear Filtering Algorithm for Stochastic Volatility Models
</h2><span id='topic+DNF.dynamicsSVM'></span><span id='topic+DNF'></span>

<h3>Description</h3>

<p>The <code>DNF</code> function applies the discrete nonlinear filter (DNF) of Kitagawa (1987) as per the implementation of Bégin &amp; Boudreault (2020) to obtain likelihood evaluations and filtering distribution estimates for a wide class of stochastic volatility models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamicsSVM'
DNF(dynamics, data, N = 50, K = 20, R = 1, grids, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DNF.dynamicsSVM_+3A_dynamics">dynamics</code></td>
<td>
<p>A dynamicsSVM object representing the model dynamics to be used by the DNF.</p>
</td></tr>
<tr><td><code id="DNF.dynamicsSVM_+3A_data">data</code></td>
<td>
<p>A series of asset returns for which we want to run the DNF.</p>
</td></tr>
<tr><td><code id="DNF.dynamicsSVM_+3A_n">N</code></td>
<td>
<p>Number of nodes in the variance grid.</p>
</td></tr>
<tr><td><code id="DNF.dynamicsSVM_+3A_k">K</code></td>
<td>
<p>Number of nodes in the jump size grid.</p>
</td></tr>
<tr><td><code id="DNF.dynamicsSVM_+3A_r">R</code></td>
<td>
<p>Maximum number of jumps used in the numerical integration at each timestep.</p>
</td></tr> 
<tr><td><code id="DNF.dynamicsSVM_+3A_grids">grids</code></td>
<td>
<p>Grids to be used for numerical integration by the <code>DNF</code> function. The <code>DNF</code> function creates grids for built-in models. However, this arguments must be provided for custom models. It should contain a list of three sequences: <code>var_mid_points</code> (variance mid-point sequence), <code>j_nums</code> (sequence for the number of jumps), and <code>jump_mid_points</code> (jump mid-point sequence). If there are no variance jumps in the model, set <code>jump_mid_points</code> equal to zero. If there are no jumps in the model, both <code>j_nums</code> and <code>jump_mid_points</code> should be set to zero.</p>
</td></tr>
<tr><td><code id="DNF.dynamicsSVM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>log_likelihood</code></td>
<td>
<p>Log-likelihood evaluation based on the DNF.</p>
</td></tr>
<tr><td><code>filter_grid</code></td>
<td>
<p>Grid of dimensions <code>N</code> by <code>T+1</code> that stores each time-step's filtering distributions (we assume the filtering distribution is uniform at <code class="reqn">t = 0</code>).</p>
</td></tr>
<tr><td><code>likelihoods</code></td>
<td>
<p>Likelihood contribution at each time-step throughout the series.</p>
</td></tr>
<tr><td><code>grids</code></td>
<td>
<p>List of grids used for numerical integration by the DNF.</p>
</td></tr>
<tr><td><code>dynamics</code></td>
<td>
<p>The model dynamics used by the DNF.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The series of asset returns to which the DNF was applied.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bégin, J.F., Boudreault, M. (2021) Likelihood evaluation of jump-diffusion models using deterministic nonlinear filters. <em>Journal of Computational and Graphical Statistics</em>, 30(2), 452&ndash;466.
</p>
<p>Kitagawa, G. (1987) Non-Gaussian state-space modeling of nonstationary time series.
<em>Journal of the American Statistical Association</em>, 82(400), 1032&ndash;1041.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# Generate 200 returns from the DuffiePanSingleton model
DuffiePanSingleton_mod &lt;- dynamicsSVM(model = "DuffiePanSingleton") 
DuffiePanSingleton_sim &lt;- modelSim(t = 200, dynamics = DuffiePanSingleton_mod) 

# Run DNF on the data
dnf_filter &lt;- DNF(data = DuffiePanSingleton_sim$returns,
  dynamics = DuffiePanSingleton_mod) 

# Print log-likelihood evaluation.
logLik(dnf_filter)

# Using a custom model.
# Here, we define the DuffiePanSingleton model as a custom model
# to get the same log-likelihood found using the built-in option

# Daily observations
h &lt;- 1/252

# Parameter values 
mu &lt;- 0.038; kappa &lt;- 3.689; theta &lt;- 0.032
sigma &lt;- 0.446; rho &lt;- -0.745; omega &lt;- 5.125
delta &lt;- 0.03; alpha &lt;- -0.014; rho_z &lt;- -1.809; nu &lt;- 0.004

# Jump compensator
alpha_bar &lt;- exp(alpha + 0.5 * delta^2) / (1 - rho_z * nu) - 1

# Returns drift and diffusion
mu_y &lt;- function(x, mu, alpha_bar, omega, h) {
  return(h * (mu - x / 2 - alpha_bar * omega))
}
mu_y_params &lt;- list(mu, alpha_bar, omega, h)
sigma_y &lt;- function(x, h) {
  return(sqrt(h * pmax(x, 0)))
}
sigma_y_params &lt;- list(h)

# Volatility factor drift and diffusion
mu_x &lt;- function(x, kappa, theta, h) {
  return(x + h * kappa * (theta - pmax(0, x)))
}
mu_x_params &lt;- list(kappa, theta, h)

sigma_x &lt;- function(x, sigma, h) {
  return(sigma * sqrt(h * pmax(x, 0)))
}
sigma_x_params &lt;- list(sigma, h)

# Jump distribution for the DuffiePanSingleton Model
jump_density &lt;- dpois
jump_dist &lt;- rpois
jump_params &lt;- c(h * omega)

# Create the custom model
custom_mod &lt;- dynamicsSVM(model = 'Custom',
  mu_x = mu_x, mu_y = mu_y, sigma_x = sigma_x, sigma_y = sigma_y,
  mu_x_params = mu_x_params, mu_y_params = mu_y_params,
  sigma_x_params = sigma_x_params, sigma_y_params = sigma_y_params,
  jump_params = jump_params, jump_dist = jump_dist, jump_density = jump_density,
  nu = nu, rho_z = rho_z, rho = rho)
# Define the grid for DNF
N &lt;- 50; R &lt;- 1; K &lt;- 20
var_mid_points &lt;- seq(from = sqrt(0.0000001),
  to = sqrt(theta + (3 + log(N)) * sqrt(0.5 * theta * sigma^2 / kappa)), length = N)^2
  
j_nums &lt;- seq(from = 0, to = R, by = 1)

jump_mid_points &lt;- seq(from = 0.000001, to = (3 + log(K)) * sqrt(R) * nu, length = K)

grids &lt;- list(var_mid_points = var_mid_points,
  j_nums = j_nums, jump_mid_points = jump_mid_points)

# Run the DNF function with the custom model
dnf_custom &lt;- DNF(data = DuffiePanSingleton_sim$returns, grids = grids, 
  dynamics = custom_mod)
  
# Check if we get the same log-likelihoods
dnf_custom$log_likelihood; dnf_filter$log_likelihood 
</code></pre>

<hr>
<h2 id='DNFOptim.dynamicsSVM'>
Discrete Nonlinear Filter Maximum Likelihood Estimation Function
</h2><span id='topic+DNFOptim.dynamicsSVM'></span><span id='topic+DNFOptim'></span>

<h3>Description</h3>

<p>The <code>DNFOptim</code> function finds maximum likelihood estimates for stochastic volatility models parameters using the <code>DNF</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamicsSVM'
DNFOptim(dynamics, data, N = 50, K = 20, R = 1,
  grids = 'Default',
  rho = 0, delta = 0, alpha = 0, rho_z = 0, nu = 0, jump_params_list = "dummy",
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DNFOptim.dynamicsSVM_+3A_dynamics">dynamics</code></td>
<td>
<p>A dynamicsSVM object representing the model dynamics to be used by the optimizer to find maximum likelihood parameter estimates.</p>
</td></tr>
<tr><td><code id="DNFOptim.dynamicsSVM_+3A_data">data</code></td>
<td>
<p>A series of asset returns for which we want to find maximum likelihood estimates.</p>
</td></tr>
<tr><td><code id="DNFOptim.dynamicsSVM_+3A_n">N</code></td>
<td>
<p>Number of nodes in the variance grid.</p>
</td></tr>
<tr><td><code id="DNFOptim.dynamicsSVM_+3A_k">K</code></td>
<td>
<p>Number of nodes in the jump size grid.</p>
</td></tr>
<tr><td><code id="DNFOptim.dynamicsSVM_+3A_grids">grids</code></td>
<td>
<p>Grids to be used for numerical integration by the <code>DNF</code> function. The <code>DNF</code> function creates grids for built-in models. However, this arguments must be provided for custom models. It should contain a list of three sequences: <code>var_mid_points</code> (variance mid-point sequence), <code>j_nums</code> (sequence for the number of jumps), and <code>jump_mid_points</code> (jump mid-point sequence). If there are no variance jumps in the model, set <code>jump_mid_points</code> equal to zero. If there are no jumps in the model, both <code>j_nums</code> and <code>jump_mid_points</code> should be set to zero.</p>
</td></tr>
<tr><td><code id="DNFOptim.dynamicsSVM_+3A_r">R</code></td>
<td>
<p>Maximum number of jumps used in the numerical integration at each timestep.</p>
</td></tr> 
<tr><td><code id="DNFOptim.dynamicsSVM_+3A_rho">rho</code>, <code id="DNFOptim.dynamicsSVM_+3A_delta">delta</code>, <code id="DNFOptim.dynamicsSVM_+3A_alpha">alpha</code>, <code id="DNFOptim.dynamicsSVM_+3A_rho_z">rho_z</code>, <code id="DNFOptim.dynamicsSVM_+3A_nu">nu</code></td>
<td>
<p>See <code>help(dynamicsSVM)</code> for a description of each of these arguments individually. These arguments should be used only for custom models and can be fixed to a certain
value (e.g., <code>rho = -0.75</code>). If they are estimated, they should be set to <code>'var'</code> (e.g., to estimate <code>rho</code> set <code>rho = 'var'</code>) and include it in the vector par to be passed to the optim function.
See Note for more details on the order in which custom models should receive parameters.</p>
</td></tr>
<tr><td><code id="DNFOptim.dynamicsSVM_+3A_jump_params_list">jump_params_list</code></td>
<td>
<p>List of the names of the arguments in the jump parameter distribution is the order that thye are used by the <code>jump_dist</code> function. This is used by <code>DNFOptim</code> to check for parameters that occur both in the <code>jump_dist</code> function and as arguments in drift or diffusion functions.</p>
</td></tr>
<tr><td><code id="DNFOptim.dynamicsSVM_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the <code>optim</code> function. See Note.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>optim</code></td>
<td>
<p>Returns a list obtained from R's <code>optim</code> function. See <code>help(optim)</code> for details about the output.</p>
</td></tr>
<tr><td><code>SVDNF</code></td>
<td>
<p>Returns a SVDNF object obtained from running the <code>DNF</code> function at the MLE parameter values. See <code>help(DNF)</code> for details about the output</p>
</td></tr>
<tr><td><code>rho</code>, <code>delta</code>, <code>alpha</code>, <code>rho_z</code>, <code>nu</code></td>
<td>
<p>See <code>help(dynamicsSVM)</code> for a description of each of these arguments individually. If they are estimated, they are set to <code>'var'</code>. If the parameters were fixed during the estimation, this will return the value at which they were fixed.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When passing the initial parameter vector <code>par</code> to the <code>optim</code> function (via <code>...</code>), the parameters should follow a specific order.
</p>
<p>For the <code>PittMalikDoucet</code> model, the parameters should be in the following order: <code>phi</code>, <code>theta</code>, <code>sigma</code>, <code>rho</code>, <code>delta</code>, <code>alpha</code>, and <code>p</code>.
</p>
<p>For the <code>DuffiePanSingleton</code> model, the parameters should be in the following order: <code>mu</code>, <code>alpha</code>, <code>delta</code>, <code>rho_z</code>, <code>nu</code>, <code>omega</code>, <code>kappa</code>, <code>theta</code>, <code>sigma</code>, and <code>rho</code>.
</p>
<p>All other built-in models can be seen as being nested within these two  models (i.e., <code>Heston</code> and <code>Bates</code> models are nested in the <code>DuffiePanSingleton</code> model, while <code>Taylor</code> and <br /> <code>TaylorWithLeverage</code> are nested in the <code>PittMalikDoucet</code> model). Their parameters should be passed in the same order as those in the more general models, minus the parameters not found in these nested models.
</p>
<p>For example, the <code>Taylor</code> model contains neither jumps nor correlation between volatility and returns innovations. Thus, its three parameters are passed in the order: <code>phi</code>, <code>theta</code>, and <code>sigma</code>.
</p>
<p>When <code>models = "Custom"</code>, parameters should be passed in the following order: <code>mu_y_params</code>, <code>sigma_y_params</code>, <code>mu_x_params</code>, <code>sigma_x_params</code>, <code>rho</code>, <code>delta</code>, <code>alpha</code>, <code>rho_z</code>, <code>nu</code>, and <code>jump_params</code>. If an argument is repeated (e.g., both <code>mu_y_params</code> and  <code>sigma_y_params</code> use the same parameter), write it only when it first appears in the custom model order.
</p>


<h3>References</h3>

<p>R Core Team (2019). R: A language and environment for statistical computing. R Foundation
for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

# Generating return data
Taylor_mod &lt;- dynamicsSVM(model = "Taylor", phi = 0.9,
  theta = -7.36, sigma = 0.363)
Taylor_sim &lt;- modelSim(t = 30, dynamics = Taylor_mod, init_vol = -7.36)
plot(Taylor_sim$volatility_factor, type = 'l')
plot(Taylor_sim$returns, type = 'l')

# Initial values and optimization bounds
init_par &lt;- c( 0.7, -5, 0.3)
lower &lt;- c(0.01, -20, 0.1); upper &lt;- c(0.99, 0, 1)

# Running DNFOptim to get MLEs
optim_test &lt;- DNFOptim(data = Taylor_sim$returns,
  dynamics = Taylor_mod,
  par = init_par, lower = lower, upper = upper, method = "L-BFGS-B")
                
# Parameter estimates
summary(optim_test)

# Plot prediction and filtering distributions
plot(optim_test, type = 'l')

</code></pre>

<hr>
<h2 id='dynamicsSVM'>
Stochastic Volatility Models Dynamics 
</h2><span id='topic+dynamicsSVM'></span>

<h3>Description</h3>

<p><code>dynamicsSVM</code> creates stochastic volatility model dynamics by either choosing from a set of built-in model dynamics or using custom drift and diffusion functions, as well as custom jump distributions. See Note for information about how to define custom functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynamicsSVM(mu = 0.038, kappa = 3.689, theta = 0.032, sigma = 0.446,
rho = -0.745, omega = 5.125, delta = 0.03, alpha = -0.014,
rho_z = -1.809, nu = 0.004, p = 0.01, phi = 0.965, h = 1/252,
model = "Heston", mu_x, mu_y, sigma_x, sigma_y,
jump_dist = rpois, jump_density = dpois, jump_params = 0,
mu_x_params, mu_y_params, sigma_x_params, sigma_y_params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamicsSVM_+3A_mu">mu</code></td>
<td>
<p>Annual expected rate of return.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_kappa">kappa</code></td>
<td>
<p>Variance rate of mean reversion.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_theta">theta</code></td>
<td>
<p>Unconditional mean variance.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_sigma">sigma</code></td>
<td>
<p>Volatility of the variance.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_rho">rho</code></td>
<td>
<p>Correlation between the return and the variance noise terms.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_omega">omega</code></td>
<td>
<p>Jump arrival intensity for models with Poisson jumps.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_delta">delta</code></td>
<td>
<p>Standard deviation of return jumps.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_alpha">alpha</code></td>
<td>
<p>Mean of return jumps.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_rho_z">rho_z</code></td>
<td>
<p>Pseudo-correlation parameter between return and variance jumps.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_nu">nu</code></td>
<td>
<p>Mean for variance jumps.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_p">p</code></td>
<td>
<p>Jump probability for models with Bernoulli jumps.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_phi">phi</code></td>
<td>
<p>Volatility persistence parameter.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_h">h</code></td>
<td>
<p>Time interval between observations (e.g., <code>h = 1/252</code> for daily data).</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_model">model</code></td>
<td>
<p>Model used by the discrete nonlinear filter. The options are <code>"Heston"</code>,    <code>"Bates"</code>, <code>"DuffiePanSingleton"</code>, <code>"Taylor"</code>, <code>"TaylorWithLeverage"</code>, <br />  <code>"PittMalikDoucet"</code>, and <code>"Custom"</code>. If <code>model = "Custom"</code>, users should pass the drift  functions (i.e., <code>mu_x</code> and <code>mu_y</code>), the diffusion functions (i.e., <code>sigma_x</code> and  <code>sigma_y</code>), and the jump distribution, (i.e., <code>jump_dist</code>) as well as their parameters to the <code>DNF</code> function. See Examples.</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_mu_x">mu_x</code></td>
<td>
<p>Function for variance drift (to be used with a custom model).</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_mu_y">mu_y</code></td>
<td>
<p>Function for returns drift (to be used with a custom model).</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_sigma_x">sigma_x</code></td>
<td>
<p>Function for variance diffusion (to be used with a custom model).</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_sigma_y">sigma_y</code></td>
<td>
<p>Function for returns diffusion (to be used with a custom model).</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_jump_dist">jump_dist</code></td>
<td>
<p>Distribution used to generate return or volatility jumps at each  timestep (if both types of jumps are in the model, they are assumed to occur simulaneously).</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_jump_density">jump_density</code></td>
<td>
<p>Probability mass function used to compute the probability of return or volatility jumps at each  timestep (if both types of jumps are in the model, they are assumed to occur simulaneously).</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_jump_params">jump_params</code></td>
<td>
<p>List of parameters to be used as arguments in the <code>jump_dist</code> and <code>jump_density</code> function (parameters should be listed in the order that jump_dist uses them).</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_mu_x_params">mu_x_params</code></td>
<td>
<p>List of parameters to be used as arguments in the <code>mu_x</code> function (parameters should be listed in the order that <code>mu_x</code> uses them).</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_mu_y_params">mu_y_params</code></td>
<td>
<p>List of parameters to be used as arguments in the <code>mu_y</code> function (parameters should be listed in the order that <code>mu_y</code> uses them).</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_sigma_x_params">sigma_x_params</code></td>
<td>
<p>List of parameters to be used as arguments in the <code>sigma_x</code> function (parameters should be listed in the order that <code>sigma_x</code> uses them).</p>
</td></tr>
<tr><td><code id="dynamicsSVM_+3A_sigma_y_params">sigma_y_params</code></td>
<td>
<p>List of parameters to be used as arguments in the <code>sigma_y</code> function (parameters should be listed in the order that <code>sigma_y</code> uses them).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of type dynamicsSVM.
</p>


<h3>Note</h3>

<p>Custom functions should have <code>x</code> (the volatility factor) as well as the function's other parameters as arguments.
</p>
<p>If the custom function does not use any parameters, one should include an argument called dummy and its parameters as a <code>list(0)</code>. For example, for the Taylor model, 
</p>
<p><code>sigma_y_taylor &lt;- function(x, dummy) {
  return(exp(x / 2))
}</code> <br />
<code>sigma_y_params &lt;- list(0)</code>
</p>
<p>It should also be noted that the custom function is a vector for <code>x</code>. This means that users should use vectorized version of functions. For example, <code>pmax(0,x)</code> instead of <code>max(0,x)</code> as code seen in the Example section below. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a dynamicsSVM object with model DuffiePanSingleton and default parameters
DuffiePanSingleton_mod &lt;- dynamicsSVM(model = "DuffiePanSingleton") 

# Here, we define the same DuffiePanSingleton model 
# using the custom model option.

# Daily observations
h &lt;- 1/252

# Parameter values 
mu &lt;- 0.038; kappa &lt;- 3.689; theta &lt;- 0.032
sigma &lt;- 0.446; rho &lt;- -0.745; omega &lt;- 5.125
delta &lt;- 0.03; alpha &lt;- -0.014; rho_z &lt;- -1.809; nu &lt;- 0.004

# Jump compensator
alpha_bar &lt;- exp(alpha + 0.5 * delta^2) / (1 - rho_z * nu) - 1

# Returns drift and diffusion
mu_y &lt;- function(x, mu, alpha_bar, omega, h) {
  return(h * (mu - x / 2 - alpha_bar * omega))
}
mu_y_params &lt;- list(mu, alpha_bar, omega, h)
sigma_y &lt;- function(x, h) {
  return(sqrt(h * pmax(x, 0)))
}
sigma_y_params &lt;- list(h)

# Volatility factor drift and diffusion
mu_x &lt;- function(x, kappa, theta, h) {
  return(x + h * kappa * (theta - pmax(0, x)))
}
mu_x_params &lt;- list(kappa, theta, h)

sigma_x &lt;- function(x, sigma, h) {
  return(sigma * sqrt(h * pmax(x, 0)))
}
sigma_x_params &lt;- list(sigma, h)

# Jump distribution for the DuffiePanSingleton Model
jump_density &lt;- dpois
jump_dist &lt;- rpois
jump_params &lt;- c(h * omega)

# Create the custom model
custom_DPS &lt;- dynamicsSVM(model = 'Custom',
  mu_x = mu_x, mu_y = mu_y, sigma_x = sigma_x, sigma_y = sigma_y,
  mu_x_params = mu_x_params, mu_y_params = mu_y_params,
  sigma_x_params = sigma_x_params, sigma_y_params = sigma_y_params,
  jump_params = jump_params, jump_dist = jump_dist, jump_density = jump_density,
  nu = nu, rho_z = rho_z)
</code></pre>

<hr>
<h2 id='logLik.SVDNF'>Extract Log-Likelihood for <code>SVDNF</code> and <code>DNFOptim</code> Objects</h2><span id='topic+logLik.SVDNF'></span><span id='topic+logLik.DNFOptim'></span>

<h3>Description</h3>

<p>Returns the log-likelihood value of the stochastic volatility
model represented by <code>object</code> evaluated at the parameters given in the <code>DNF</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SVDNF'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.SVDNF_+3A_object">object</code></td>
<td>
<p>an object of class <code>SVDNF</code> or <code>DNFOptim</code>.</p>
</td></tr>
<tr><td><code id="logLik.SVDNF_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood of the stochastic volatility model given by
<code>object</code> evaluated at the parameters given to the <code>DNF</code> function. For <code>DNFOptim</code> objects, this returns the log-likelihood at the MLE parameter values and the number of free parameters in the model. 
</p>


<h3>Note</h3>

<p>It will always be the case <code>df = NULL</code> for <code>SVDNF</code> objects as they are evaluations of the DNF algorithm for a fixed set of parameters. However, for <code>DNFOptim</code> objects, <code>df</code> will be the number of free parameters in the optimization.</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# Generate 200 returns from the DuffiePanSingleton model
DuffiePanSingleton_mod &lt;- dynamicsSVM(model = "DuffiePanSingleton") 
DuffiePanSingleton_sim &lt;- modelSim(t = 200, dynamics = DuffiePanSingleton_mod) 

# Run DNF on the data
dnf_filter &lt;- DNF(data = DuffiePanSingleton_sim$returns,
  dynamics = DuffiePanSingleton_mod) 

# Print log-likelihood evaluation.
logLik(dnf_filter)
</code></pre>

<hr>
<h2 id='modelSim.dynamicsSVM'>
Simulation from Stochastic Volatility Models with Jumps
</h2><span id='topic+modelSim.dynamicsSVM'></span><span id='topic+modelSim'></span>

<h3>Description</h3>

<p>The <code>modelSim</code> function generates returns and variances for a wide class of stochastic volatility models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynamicsSVM'
modelSim(dynamics, t, init_vol = 0.032, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelSim.dynamicsSVM_+3A_dynamics">dynamics</code></td>
<td>
<p>A dynamicsSVM object representing the model dynamics to be used for simulating data.</p>
</td></tr>
<tr><td><code id="modelSim.dynamicsSVM_+3A_t">t</code></td>
<td>
<p>Number of observations to be simulated.</p>
</td></tr>
<tr><td><code id="modelSim.dynamicsSVM_+3A_init_vol">init_vol</code></td>
<td>
<p>Initial value of the volatility factor (e.i., value of <code>x_0</code>).</p>
</td></tr>
<tr><td><code id="modelSim.dynamicsSVM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>volatility_factor</code></td>
<td>
<p>Vector of the instantaneous volatility factor values generated by the <code>modelSim</code> function.</p>
</td></tr>
<tr><td><code>returns</code></td>
<td>
<p>Vector of the returns generated by the <code>modelSim</code> function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# Generate 250 returns from the DuffiePanSingleton model
DuffiePanSingleton_mod &lt;- dynamicsSVM(model = "DuffiePanSingleton") 
DuffiePanSingleton_sim &lt;- modelSim(t = 200, dynamics = DuffiePanSingleton_mod) 

# Plot the volatility factor and returns that were generated
plot(DuffiePanSingleton_sim$volatility_factor, type = 'l',
  main = 'DuffiePanSingleton Model Simulated Volatility Factor', ylab = 'Volatility Factor')
 
plot(DuffiePanSingleton_sim$returns, type = 'l',
  main = 'DuffiePanSingleton Model Simulated Returns', ylab = 'Returns')
 
# Generate 250 steps from a custom model
# Set parameters
kappa &lt;- 100; theta &lt;- 0.05; sigma &lt;- 2.3; h &lt;- 1/252 ; mu &lt;- 0.04
rho &lt;- -0.8; omega &lt;- 5; alpha &lt;- -0.025; nu &lt;- 0.01; rho_z &lt;- -1; delta &lt;- 0.025
# Jump compensator
alpha_bar &lt;- exp(alpha + 0.5 * delta^2) / (1 - rho_z * nu) - 1

# Define returns drift and diffusion functions
# Returns drift and diffusion
mu_y &lt;- function(x, mu, alpha_bar, omega, h){
  return(h * (mu - x / 2 - alpha_bar * omega))
}
mu_y_params &lt;- list(mu, alpha_bar, omega , h)
sigma_y &lt;- function(x, h, sigma){
  return(sigma * sqrt(h) * pmax(x,0))
}
sigma_y_params &lt;- list(h, sigma)

# Volatility factor drift and diffusion functions
mu_x &lt;- function(x, h, kappa, theta){
  return(x + h * kappa * pmax(0,x) * (theta - pmax(0,x)))
}
mu_x_params &lt;- list(h, kappa, theta)

sigma_x &lt;- function(x, sigma, h){
  return(sigma * sqrt(h) * pmax(0,x))
}
sigma_x_params &lt;- list(sigma, h)

# Include simultaneous return and volatility factor jumps
# based on the Poisson distribution for jump times
jump_dist &lt;- rpois
jump_params &lt;- list(omega * h)
custom_mod &lt;- dynamicsSVM(model = "Custom", mu_x = mu_x, mu_y = mu_y,
  sigma_x = sigma_x, sigma_y = sigma_y,
  mu_x_params = mu_x_params, mu_y_params = mu_y_params,
  sigma_x_params = sigma_x_params, sigma_y_params = sigma_y_params,
  jump_dist = jump_dist, jump_params = jump_params, 
  nu = nu, rho_z = rho_z, omega = omega, alpha = alpha, delta = delta)
custom &lt;- modelSim(t = 250, dynamics = custom_mod)
  
plot(custom$volatility_factor, type = 'l',
  main = 'Custom Model Simulated Volatility Factor', ylab = 'Volatility Factor')
plot(custom$returns, type = 'l',
  main = 'Custom Model Simulated Returns', ylab = 'Returns')
</code></pre>

<hr>
<h2 id='plot.predict.DNFOptim'>Plot Predictions from <code>DNFOptim</code> or <code>SVDNF</code> Objects</h2><span id='topic+plot.predict.DNFOptim'></span><span id='topic+plot.predict.SVDNF'></span>

<h3>Description</h3>

<p>Plot predictions from a <code>DNFOptim</code> or <code>SVDNF</code> object, including volatility and return mean predictions with confidence intervals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'predict.DNFOptim'
plot(x, ...)
  
  ## S3 method for class 'predict.SVDNF'
plot(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.predict.DNFOptim_+3A_x">x</code></td>
<td>
<p>an object of class <code>predict.DNFOptim</code> or  <code>predict.SVDNF</code>.</p>
</td></tr>
<tr><td><code id="plot.predict.DNFOptim_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the volatility and return predictions with confidence intervals obtained from a <code>DNFOptim</code> object.
</p>
<p>For the volatility plot, it displays the DNF's filtering distribution median volatility for all time points in the series and, after the last observation, plots the predicted mean volatility with its confidence interval.
</p>
<p>For the returns plot, it displays the observed returns for all time points in the series and, after the last observation, plots the predicted mean return with its confidence interval.
</p>


<h3>Value</h3>

<p>No return value; this function generates two plots.
</p>
<p>The first has the median volatility from the filtering distribution as well as the mean predicted volatility from Monte Carlo simulated paths with its confidence interval.
</p>
<p>The second has the observed asset returns as well as the mean predicted returns from Monte Carlo simulated paths with its confidence interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating return data
Taylor_mod &lt;- dynamicsSVM(model = "Taylor", phi = 0.9,
                           theta = -7.36, sigma = 0.363)
Taylor_sim &lt;- modelSim(t = 100, dynamics = Taylor_mod, init_vol = -7.36)
 
# Run the DNF
DNF_Taylor &lt;- DNF(dynamics = Taylor_mod, data = Taylor_sim$returns)
 
# Predict the next 10 time steps
predict_Taylor &lt;- predict(DNF_Taylor, n_ahead = 10)

# Plot the predictions
plot(predict_Taylor)

</code></pre>

<hr>
<h2 id='plot.SVDNF'>
DNF Filtering Distribution Plot Function</h2><span id='topic+plot.SVDNF'></span>

<h3>Description</h3>

<p>This function plots the median of the filtering and prediction distributions estimated from the <code>DNF</code> along with user-selected upper and lower percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SVDNF'
plot(x, lower_p = 0.05, upper_p = 0.95, tlim = 'default',
  location = 'topright', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SVDNF_+3A_x">x</code></td>
<td>
<p>An <code>SVDNF</code> object. The <code>plot</code> plots the median and selected percentiles from the filtering distribution.</p>
</td></tr>
<tr><td><code id="plot.SVDNF_+3A_lower_p">lower_p</code></td>
<td>
<p>Lower percentile of the filtering distribution to plot.</p>
</td></tr>
<tr><td><code id="plot.SVDNF_+3A_upper_p">upper_p</code></td>
<td>
<p>Upper percentile of the filtering distribution to plot.</p>
</td></tr>
<tr><td><code id="plot.SVDNF_+3A_tlim">tlim</code></td>
<td>
<p>The <code>plot</code> function plots the filtering and prediction distributions over the interval <code>tlim</code>. For example to plot the first <code>500</code> steps, set <code>tlim = c(1, 500)</code>. By default, filtering and prediction distribution estimates for every step in the time-series are generated.
</p>
<p>If <code>tlim</code> is set to a single number (e.g., <code>tlim = c(5)</code>), <code>plot</code> graphs the estimated probability density functions of the filtering (in magenta) and prediction (in blue) distributions at that timestep.</p>
</td></tr>
<tr><td><code id="plot.SVDNF_+3A_location">location</code></td>
<td>
<p>Location keyword passed to the <code>legend</code> function to determine the location of the legend. The keyword should be selected from the list <code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, <code>"left"</code>, <code>"topleft"</code>, <code>"top"</code>, <code>"topright"</code>, <code>"right"</code>, and <code>"center"</code>.</p>
</td></tr>
<tr><td><code id="plot.SVDNF_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value; this function generates two plots.
</p>
<p>The first has the median of the volatility factor obtained from the prediction distribution as well as its upper and lower percentiles from <code>lower_p</code> and <code>upper_p</code>.
</p>
<p>The second has the median of the volatility factor obtained from the filtering distribution as well as its upper and lower percentiles from <code>lower_p</code> and <code>upper_p</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# Generate 500 returns from the Bates model.
Bates_mod &lt;- dynamicsSVM(model = "Bates")
Bates_sim &lt;- modelSim(t = 500, dynamics = Bates_mod)

# Runs DNF on the data.
dnf_filter &lt;- DNF(data = Bates_sim$returns, dynamics = Bates_mod)

# Plot whole interval (default)
plot(dnf_filter, ylim = c(0, 0.15), type = 'l',
ylab = "Volatility Factor", xlab = 'Time')

# Plot specific interval
tlim &lt;- c(100,350)
plot(dnf_filter, ylim = c(0, 0.15), type = 'l',
  ylab = "Volatility Factor", xlab = 'Time', tlim = tlim)

# Plot specific point 
tlim &lt;- c(100)
plot(dnf_filter, ylim = c(0, 0.15), type = 'l',
  ylab = "Volatility Factor", xlab = 'Time', tlim = tlim)

</code></pre>

<hr>
<h2 id='predict.DNFOptim'>
Predict Method for <code>DNFOptim</code> and <code>SVDNF</code> Objects
</h2><span id='topic+predict.DNFOptim'></span><span id='topic+predict.SVDNF'></span>

<h3>Description</h3>

<p>This function generates Monte Carlo predictions for <code>DNFOptim</code> objects. The function does this by sampling volatilities from the discrete nonlinear filter's last filtering distribution. Then, using these volatilities as inital values for the <code>modelSim</code> function, the predict method generates <code>n_sim</code> path and estimates the means and confidence intervals for future volatility factor and return values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'DNFOptim'
predict(object, n_ahead = 15, n_sim = 1000, confidence = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.DNFOptim_+3A_object">object</code></td>
<td>
<p>An object of class <code>"DNFOptim"</code>.</p>
</td></tr>
<tr><td><code id="predict.DNFOptim_+3A_n_ahead">n_ahead</code></td>
<td>
<p>Number of periods ahead to predict.</p>
</td></tr>
<tr><td><code id="predict.DNFOptim_+3A_n_sim">n_sim</code></td>
<td>
<p>Number of simulated paths used to estimate the future volatility factor and return means and confidence intervals.</p>
</td></tr>
<tr><td><code id="predict.DNFOptim_+3A_confidence">confidence</code></td>
<td>
<p>Confidence level for prediction intervals. Should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="predict.DNFOptim_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses Monte Carlo paths simulated from the MLE dynamics obtained via a <code>DNFOptim</code> object to generate predictions for a specified number of periods ahead.
It returns predicted mean volatility and return values based on simulations with confidence intervals.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>volatility_pred</code></td>
<td>
<p>A list with mean volatility values and confidence intervals. Contains the following components:</p>
</td></tr>
</table>

<ul>
<li><p><code>UB_vol</code>: Upper bound of the confidence interval for volatility.
</p>
</li>
<li><p><code>mean_vol_pred</code>: Mean prediction for volatility.
</p>
</li>
<li><p><code>LB_vol</code>: Lower bound of the confidence interval for volatility.
</p>
</li></ul>

<table>
<tr><td><code>ret_pred</code></td>
<td>
<p>A list with mean return values and confidence intervals. Contains the following components:</p>
</td></tr>
</table>

<ul>
<li><p><code>UB_ret</code>: Upper bound of the confidence interval for mean returns.
</p>
</li>
<li><p><code>mean_ret_pred</code>: Mean prediction for mean returns.
</p>
</li>
<li><p><code>LB_ret</code>: Lower bound of the confidence interval for mean returns.
</p>
</li></ul>

<table>
<tr><td><code>object</code></td>
<td>
<p>The <code>DNFOptim</code> object input to the <code>predict</code> function.</p>
</td></tr>
<tr><td><code>confidence</code></td>
<td>
<p>The specified confidence level.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+DNFOptim">DNFOptim</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

# Generating return data
Taylor_mod &lt;- dynamicsSVM(model = "Taylor", phi = 0.9,
  theta = -7.36, sigma = 0.363)
Taylor_sim &lt;- modelSim(t = 30, dynamics = Taylor_mod, init_vol = -7.36)

# Initial values and optimization bounds
init_par &lt;- c( 0.7, -5, 0.3)
lower &lt;- c(0.01, -20, 0.1); upper &lt;- c(0.99, 0, 1)

# Running DNFOptim to get MLEs
optim_test &lt;- DNFOptim(data = Taylor_sim$returns,
  dynamics = Taylor_mod,
  par = init_par, lower = lower, upper = upper, method = "L-BFGS-B")
                
# Parameter estimates
summary(optim_test)

# Predict 5 steps ahead
preds &lt;- predict(optim_test, n_ahead = 5)

# Plot predictions with 95 percent confidence interval
plot(preds)
</code></pre>

<hr>
<h2 id='summary.DNFOptim'>Summarizing Stochastic Volatility Model Fits from the Discrete Nonlinear Filter</h2><span id='topic+summary.DNFOptim'></span><span id='topic+print.summary.DNFOptim'></span>

<h3>Description</h3>

<p>Summary method for <code>DNFOptim</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DNFOptim'
summary(object, confidence, ...)

## S3 method for class 'summary.DNFOptim'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.DNFOptim_+3A_object">object</code></td>
<td>
<p>an object of class <code>DNFOptim</code> that you want to summary the parameter estimates.</p>
</td></tr>
<tr><td><code id="summary.DNFOptim_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.DNFOptim</code>.</p>
</td></tr>
<tr><td><code id="summary.DNFOptim_+3A_confidence">confidence</code></td>
<td>
<p>Confidence level for computing confidence intervals. Should be between 0 and 1. Default is 0.95.</p>
</td></tr>
<tr><td><code id="summary.DNFOptim_+3A_digits">digits</code></td>
<td>
<p>The number of digits to be printed in the <code>print</code> method for <code>summary.DNFOptim</code> objects.</p>
</td></tr>
<tr><td><code id="summary.DNFOptim_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the summary of the output of a <code>DNFOptim</code> object.
</p>


<h3>Value</h3>

<p>Returns a list with the model used and its estimated parameters.
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>The model that was estimated with the <code>DNFOptim</code> object.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Table with the maximum likelihood parameters estimates. If <code>hessian = TRUE</code> was set in the <code>DNFOptim</code> function, standard errors and 95% confidence intervals are given. Then, the table has the following columns:
</p>

<ul>
<li><p>Estimate The parameter estimate.
</p>
</li>
<li><p>Std Error The standard error of the estimate.
</p>
</li>
<li><p>Lower Bound The lower bound of the confidence interval.
</p>
</li>
<li><p>Upper Bound The upper bound of the confidence interval.
</p>
</li></ul>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>Log-likelihood value at the parameter maximum likelihood estimates and the model's degrees of freedom</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(DNFOptim)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
