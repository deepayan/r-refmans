<!DOCTYPE html><html lang="en"><head><title>Help for package msde</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {msde}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#msde-package'><p>msde: Bayesian Inference for Multivariate Stochastic Differential Equations</p></a></li>
<li><a href='#mou.loglik'><p>Loglikelihood for multivariate Ornstein-Uhlenbeck process.</p></a></li>
<li><a href='#mvn.hyper.check'><p>Argument checking for the default multivariate normal prior.</p></a></li>
<li><a href='#sde.diff'><p>SDE diffusion function.</p></a></li>
<li><a href='#sde.drift'><p>SDE drift function.</p></a></li>
<li><a href='#sde.examples'><p>Example SDE models.</p></a></li>
<li><a href='#sde.init'><p>MCMC initialization.</p></a></li>
<li><a href='#sde.loglik'><p>SDE loglikelihood function.</p></a></li>
<li><a href='#sde.make.model'><p>Create an SDE model object.</p></a></li>
<li><a href='#sde.post'><p>MCMC sampler for the SDE posterior.</p></a></li>
<li><a href='#sde.prior'><p>SDE prior function.</p></a></li>
<li><a href='#sde.sim'><p>Simulation of multivariate SDE trajectories.</p></a></li>
<li><a href='#sde.valid'><p>SDE data and parameter validators.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian Inference for Multivariate Stochastic Differential
Equations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-12-16</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements an MCMC sampler for the posterior distribution of arbitrary time-homogeneous multivariate stochastic differential equation (SDE) models with possibly latent components.  The package provides a simple entry point to integrate user-defined models directly with the sampler's C++ code, and parallelizes large portions of the calculations when compiled with 'OpenMP'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.7), methods, stats, tools, whisker</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, RcppProgress</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-17 04:37:01 UTC; mlysy</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Lysy [aut, cre],
  Feiyu Zhu [aut],
  JunYong Tong [aut],
  Trevor Kitt [ctb],
  Nigel Delaney [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Lysy &lt;mlysy@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-17 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='msde-package'>msde: Bayesian Inference for Multivariate Stochastic Differential Equations</h2><span id='topic+msde'></span><span id='topic+msde-package'></span>

<h3>Description</h3>

<p>Implements an MCMC sampler for the posterior distribution of arbitrary time-homogeneous multivariate stochastic differential equation (SDE) models with possibly latent components. The package provides a simple entry point to integrate user-defined models directly with the sampler's C++ code, and parallelizes large portions of the calculations when compiled with 'OpenMP'.
</p>


<h3>Details</h3>

<p>See package vignettes; <code>vignette("msde-quicktut")</code> for a tutorial and <code>vignette("msde-exmodels")</code> for several example models.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin Lysy <a href="mailto:mlysy@uwaterloo.ca">mlysy@uwaterloo.ca</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Feiyu Zhu
</p>
</li>
<li><p> JunYong Tong
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Trevor Kitt [contributor]
</p>
</li>
<li><p> Nigel Delaney [contributor]
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Posterior inference for Heston's model

# compile model
hfile &lt;- sde.examples("hest", file.only = TRUE)
param.names &lt;- c("alpha", "gamma", "beta", "sigma", "rho")
data.names &lt;- c("X", "Z")
hmod &lt;- sde.make.model(ModelFile = hfile,
                       param.names = param.names,
                       data.names = data.names)
# or simply load pre-compiled version
hmod &lt;- sde.examples("hest")

# Simulate data
X0 &lt;- c(X = log(1000), Z = 0.1)
theta &lt;- c(alpha = 0.1, gamma = 1, beta = 0.8, sigma = 0.6, rho = -0.8)
dT &lt;- 1/252
nobs &lt;- 1000
hest.sim &lt;- sde.sim(model = hmod, x0 = X0, theta = theta,
                    dt = dT, dt.sim = dT/10, nobs = nobs)

# initialize MCMC sampler
# both components observed, no missing data between observations
init &lt;- sde.init(model = hmod, x = hest.sim$data,
                 dt = hest.sim$dt, theta = theta)

# Initialize posterior sampling argument
nsamples &lt;- 1e4
burn &lt;- 1e3
hyper &lt;- NULL # flat prior
hest.post &lt;- sde.post(model = hmod, init = init, hyper = hyper,
                      nsamples = nsamples, burn = burn)

# plot the histogram for the sampled parameters
par(mfrow = c(2,3))
for(ii in 1:length(hmod$param.names)) {
  hist(hest.post$params[,ii],breaks=100, freq = FALSE,
       main = parse(text = hmod$param.names[ii]), xlab = "")
}

</code></pre>

<hr>
<h2 id='mou.loglik'>Loglikelihood for multivariate Ornstein-Uhlenbeck process.</h2><span id='topic+mou.loglik'></span>

<h3>Description</h3>

<p>Computes the exact Euler loglikelihood for any amount of missing data using a Kalman filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mou.loglik(X, dt, nvar.obs, Gamma, Lambda, Phi, mu0, Sigma0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mou.loglik_+3A_x">X</code></td>
<td>
<p>An <code style="white-space: pre;">&#8288;nobs x ndims&#8288;</code> matrix of complete data.</p>
</td></tr>
<tr><td><code id="mou.loglik_+3A_dt">dt</code></td>
<td>
<p>A scalar or length <code>nobs-1</code> vector of interobservations times.</p>
</td></tr>
<tr><td><code id="mou.loglik_+3A_nvar.obs">nvar.obs</code></td>
<td>
<p>A scalar or length <code>nobs</code> vector of integers between 0 and <code>ndims</code> denoting the number of observed SDE variables in each row of <code>data</code>.  Defaults to <code>ndims</code>.  See <code><a href="#topic+sde.init">sde.init()</a></code> for details.</p>
</td></tr>
<tr><td><code id="mou.loglik_+3A_gamma">Gamma</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;ndims x ndims&#8288;</code> of linear-drift parameters.  See Details.</p>
</td></tr>
<tr><td><code id="mou.loglik_+3A_lambda">Lambda</code></td>
<td>
<p>A length-<code>ndims</code> vector of constant-drift parameters.  See Details.</p>
</td></tr>
<tr><td><code id="mou.loglik_+3A_phi">Phi</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;ndims x ndims&#8288;</code> positive definite variance matrix.  See Details.</p>
</td></tr>
<tr><td><code id="mou.loglik_+3A_mu0">mu0</code>, <code id="mou.loglik_+3A_sigma0">Sigma0</code></td>
<td>
<p>Mean and variance of marginal multivariate normal distribution of <code>X[1,]</code>.  Defaults to iid standard normals for each component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">p</code>-dimensional multivariate Ornstein-Uhlenbeck (mOU) process <code class="reqn">Y_t = (Y_{1t}, \ldots, Y_{dt})</code> satisfies the SDE
</p>
<p style="text-align: center;"><code class="reqn">
dY_t = (\Gamma Y_t + \Lambda)dt + \Phi^{1/2} dB_t,
</code>
</p>

<p>where <code class="reqn">B_t = (B_{1t}, \ldots, B_{pt})</code> is <code class="reqn">p</code>-dimensional Brownian motion.  Its Euler discretization is of the form
</p>
<p style="text-align: center;"><code class="reqn">
Y_{n+1} = Y_n + (\Gamma Y_n + \Lambda) \Delta_n + \Phi^{1/2} \Delta B_n,
</code>
</p>

<p>where <code class="reqn">Y_n = Y(t_n)</code>, <code class="reqn">\Delta_n = t_{n+1} - t_n</code> and
</p>
<p style="text-align: center;"><code class="reqn">
\Delta B_n = B(t_{n+1}) - B(t_n) \stackrel{\textnormal{ind}}{\sim} \mathcal N(0, \Delta_n).
</code>
</p>

<p>Thus, <code class="reqn">Y_0, \ldots, Y_N</code> is multivariate normal Markov chain for which the marginal distribution of any subset of timepoints and/or components can be efficiently calculated using the Kalman filter.  This can be used to check the MCMC output of <code><a href="#topic+sde.post">sde.post()</a></code> as in the example.
</p>


<h3>Value</h3>

<p>Scalar value of the loglikelihood.  See Details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# bivariate OU model
bmod &lt;- sde.examples("biou")

# simulate some data

# true parameter values
Gamma0 &lt;- .1 * crossprod(matrix(rnorm(4),2,2))
Lambda0 &lt;- rnorm(2)
Phi0 &lt;- crossprod(matrix(rnorm(4),2,2))
Psi0 &lt;- chol(Phi0) # precompiled model uses the Cholesky scale
theta0 &lt;- c(Gamma0, Lambda0, Psi0[c(1,3,4)])
names(theta0) &lt;- bmod$param.names
# initial value
Y0 &lt;- rnorm(2)
names(Y0) &lt;- bmod$data.names

# simulation
dT &lt;- runif(1, max = .1) # time step
nObs &lt;- 10
bsim &lt;- sde.sim(bmod, x0 = Y0, theta = theta0,
                dt = dT, dt.sim = dT, nobs = nObs)
YObs &lt;- bsim$data

# inference via MCMC
binit &lt;- sde.init(bmod, x = YObs, dt = dT, theta = theta0,
                  nvar.obs = 1) # second component is unobserved
# only Lambda1 is unknown
fixed.params &lt;- rep(TRUE, bmod$nparams)
names(fixed.params) &lt;- bmod$param.names
fixed.params["Lambda1"] &lt;- FALSE
# prior on (Lambda1, Y_0)
hyper &lt;- list(mu = c(0,0), Sigma = diag(2))
names(hyper$mu) &lt;- bmod$data.names
dimnames(hyper$Sigma) &lt;- rep(list(bmod$data.names), 2)

# posterior sampling
nsamples &lt;- 1e5
burn &lt;- 1e3
bpost &lt;- sde.post(bmod, binit, hyper = hyper,
                  fixed.params = fixed.params,
                  nsamples = nsamples, burn = burn)
L1.mcmc &lt;- bpost$params[,"Lambda1"]

# analytic posterior
L1.seq &lt;- seq(min(L1.mcmc), max(L1.mcmc), len = 500)
L1.loglik &lt;- sapply(L1.seq, function(l1) {
  lambda &lt;- Lambda0
  lambda[1] &lt;- l1
  mou.loglik(X = YObs, dt = dT, nvar.obs = 1,
             Gamma = Gamma0, Lambda = lambda, Phi = Phi0,
             mu0 = hyper$mu, Sigma0 = hyper$Sigma)
})
# normalize density
L1.Kalman &lt;- exp(L1.loglik - max(L1.loglik))
L1.Kalman &lt;- L1.Kalman/sum(L1.Kalman)/(L1.seq[2]-L1.seq[1])

# compare
hist(L1.mcmc, breaks = 100, freq = FALSE,
     main = expression(p(Lambda[1]*" | "*bold(Y)[1])),
     xlab = expression(Lambda[1]))
lines(L1.seq, L1.Kalman, col = "red")
legend("topright", legend = c("Analytic", "MCMC"),
       pch = c(NA, 22), lty = c(1, NA), col = c("red", "black"))

</code></pre>

<hr>
<h2 id='mvn.hyper.check'>Argument checking for the default multivariate normal prior.</h2><span id='topic+mvn.hyper.check'></span>

<h3>Description</h3>

<p>Argument checking for the default multivariate normal prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvn.hyper.check(hyper, param.names, data.names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvn.hyper.check_+3A_hyper">hyper</code></td>
<td>
<p>The normal prior's hyperparameters: <code>NULL</code>, or a list with elements <code>mu</code> and <code>Sigma</code>, corresponding to a named mean vector and variance matrix (see Details).</p>
</td></tr>
<tr><td><code id="mvn.hyper.check_+3A_param.names">param.names</code></td>
<td>
<p>Vector of parameter names (see Details).</p>
</td></tr>
<tr><td><code id="mvn.hyper.check_+3A_data.names">data.names</code></td>
<td>
<p>Vector of data names (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not meant to be called directly by the user, but rather to parse the hyper-parameters of a default multivariate normal prior distribution to be passed to the C++ code in <code><a href="#topic+sde.prior">sde.prior()</a></code> and <code><a href="#topic+sde.post">sde.post()</a></code>.  This default prior is multivariate normal on the elements of <code style="white-space: pre;">&#8288;(theta, x0)&#8288;</code> specified by each of <code>names(mu)</code>, <code>rownames(Sigma)</code>, and <code>colnames(Sigma)</code>.  The remaining components are given Lebesgue priors, or a full Lebesgue prior if <code>hyper == NULL</code>.  If the names of <code>mu</code> and <code>Sigma</code> are inconsistent an error is thrown.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<dl>
<dt><code>mean</code></dt><dd><p>The mean vector.</p>
</dd>
<dt><code>cholSd</code></dt><dd><p>The upper upper Cholesky factor of the variance matrix.</p>
</dd>
<dt><code>thetaId</code></dt><dd><p>The index of the corresponding variables in <code>theta</code>.</p>
</dd>
<dt><code>xId</code></dt><dd><p>The index of the corresponding variables in <code>x0</code>.</p>
</dd>
</dl>


<hr>
<h2 id='sde.diff'>SDE diffusion function.</h2><span id='topic+sde.diff'></span>

<h3>Description</h3>

<p>Computes the SDE model's diffusion function given data and parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sde.diff(model, x, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sde.diff_+3A_model">model</code></td>
<td>
<p>An <code>sde.model</code> object.</p>
</td></tr>
<tr><td><code id="sde.diff_+3A_x">x</code></td>
<td>
<p>A vector or matrix of data with <code>ndims</code> columns.</p>
</td></tr>
<tr><td><code id="sde.diff_+3A_theta">theta</code></td>
<td>
<p>A vector or matrix of parameters with <code>nparams</code> columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>ndims^2</code> columns containing the diffusion function evaluated at <code>x</code> and <code>theta</code>. Each row corresponds to the upper triangular Cholesky factor of the diffusion matrix.  If either input contains invalid SDE data or parameters an error is thrown.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load Heston's model
hmod &lt;- sde.examples("hest")
#'
# single input
theta &lt;- c(alpha = 0.1, gamma = 1, beta = 0.8, sigma = 0.6, rho = -0.8)
x0 &lt;- c(X = log(1000), Z = 0.1)
sde.diff(model = hmod, x = x0, theta = theta)
#'
# multiple inputs
nreps &lt;- 10
Theta &lt;- apply(t(replicate(nreps, theta)), 2, jitter)
X0 &lt;- apply(t(replicate(nreps, x0)), 2, jitter)
sde.diff(model = hmod, x = X0, theta = Theta)
#'
# mixed inputs
sde.diff(model = hmod, x = x0, theta = Theta)
</code></pre>

<hr>
<h2 id='sde.drift'>SDE drift function.</h2><span id='topic+sde.drift'></span>

<h3>Description</h3>

<p>Computes the SDE model's drift function given data and parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sde.drift(model, x, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sde.drift_+3A_model">model</code></td>
<td>
<p>An <code>sde.model</code> object.</p>
</td></tr>
<tr><td><code id="sde.drift_+3A_x">x</code></td>
<td>
<p>A vector or matrix of data with <code>ndims</code> columns.</p>
</td></tr>
<tr><td><code id="sde.drift_+3A_theta">theta</code></td>
<td>
<p>A vector or matrix of parameters with <code>nparams</code> columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>ndims</code> columns containing the drift function evaluated at <code>x</code> and <code>theta</code>.  If either input contains invalid SDE data or parameters an error is thrown.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load Heston's model
hmod &lt;- sde.examples("hest")

# single input
x0 &lt;- c(X = log(1000), Z = 0.1)
theta &lt;- c(alpha = 0.1, gamma = 1, beta = 0.8, sigma = 0.6, rho = -0.8)
sde.drift(model = hmod, x = x0, theta = theta)

# multiple inputs
nreps &lt;- 10
Theta &lt;- apply(t(replicate(nreps,theta)),2,jitter)
X0 &lt;- apply(t(replicate(nreps,x0)),2,jitter)
sde.drift(model = hmod, x = X0, theta = Theta)
</code></pre>

<hr>
<h2 id='sde.examples'>Example SDE models.</h2><span id='topic+sde.examples'></span>

<h3>Description</h3>

<p>Provides sample <code style="white-space: pre;">&#8288;C++&#8288;</code> code for several SDE models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sde.examples(
  model = c("hest", "pgnet", "lotvol", "biou", "eou"),
  file.only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sde.examples_+3A_model">model</code></td>
<td>
<p>Character string giving the name of a sample model.  Possible values are: <code>hest</code>, <code>pgnet</code>, <code>lotvol</code>, <code>biou</code>, <code>eou</code>.  See Details.</p>
</td></tr>
<tr><td><code id="sde.examples_+3A_file.only">file.only</code></td>
<td>
<p>If <code>TRUE</code> returns only the path to the header file containing the <code>sdeModel</code> object implementation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All pre-compiled models are with the default prior and with <code>OpenMP</code> disabled.  A full description of the example models can be found in the package vignette; to view it run <code>vignette("msde-exmodels")</code>.
</p>


<h3>Value</h3>

<p>An <code>sde.model</code> object, or the path to the C++ model header file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sde.make.model">sde.make.model()</a></code> for <code>sde.model</code> objects, <code><a href="#topic+mvn.hyper.check">mvn.hyper.check()</a></code> for specification of the default prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Heston's model
hmod &lt;- sde.examples("hest") # load pre-compiled model

# inspect model's C++ code
hfile &lt;- sde.examples("hest", file.only = TRUE)
cat(readLines(hfile), sep = "\n")

## Not run: 
# compile it from scratch
param.names &lt;- c("alpha", "gamma", "beta", "sigma", "rho")
data.names &lt;- c("X", "Z")
hmod &lt;- sde.make.model(ModelFile = hfile,
                       param.names = param.names,
                       data.names = data.names)

## End(Not run)
</code></pre>

<hr>
<h2 id='sde.init'>MCMC initialization.</h2><span id='topic+sde.init'></span>

<h3>Description</h3>

<p>Specifies the observed SDE data, interobservation times, initial parameter and missing data values to be supplied to <code><a href="#topic+sde.post">sde.post()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sde.init(model, x, dt, m = 1, nvar.obs, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sde.init_+3A_model">model</code></td>
<td>
<p>An <code>sde.model</code> object.</p>
</td></tr>
<tr><td><code id="sde.init_+3A_x">x</code></td>
<td>
<p>An <code style="white-space: pre;">&#8288;nobs x ndims&#8288;</code> matrix of data.</p>
</td></tr>
<tr><td><code id="sde.init_+3A_dt">dt</code></td>
<td>
<p>A scalar or length <code>nobs-1</code> vector of interobservations times.</p>
</td></tr>
<tr><td><code id="sde.init_+3A_m">m</code></td>
<td>
<p>Positive integer, such that <code>m-1</code> evenly-spaced missing data time points are placed between observations.  See Details.</p>
</td></tr>
<tr><td><code id="sde.init_+3A_nvar.obs">nvar.obs</code></td>
<td>
<p>A scalar or length <code>nobs</code> vector of integers between 0 and <code>ndims</code> denoting the number of observed SDE variables in each row of <code>data</code>.  Defaults to <code>ndims</code>.  See Details.</p>
</td></tr>
<tr><td><code id="sde.init_+3A_theta">theta</code></td>
<td>
<p>A length <code>nparams</code> vector of parameter values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sde.init</code> object, corresponding to a list with elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>An <code style="white-space: pre;">&#8288;ncomp x ndims&#8288;</code> matrix of complete data, where <code>ncomp = N_m = m * (nobs-1)+1</code>.</p>
</dd>
<dt><code>dt.m</code></dt><dd><p>The complete data interobservation time, <code>dt_m = dt/m</code>.</p>
</dd>
<dt><code>nvar.obs.m</code></dt><dd><p>The number of variables observed per row of <code>data</code>.  Note that <code>nvar.obs.m[(i-1)*m+1] == nvar.obs[ii]</code>, and that <code>nvar.obs.m[i-1] == 0</code> if <code>i</code> is not a multiple of <code>m</code>.</p>
</dd>
<dt><code>params</code></dt><dd><p>Parameter initial values.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load Heston's model
hmod &lt;- sde.examples("hest")

# generate some observed data
nObs &lt;- 5
x0 &lt;- c(X = log(1000), Z = 0.1)
X0 &lt;- apply(t(replicate(nObs, x0)), 2, jitter)
dT &lt;- .6
theta &lt;- c(alpha = 0.1, gamma = 1, beta = 0.8, sigma = 0.6, rho = -0.8)

# no missing data
sde.init(model = hmod, x = X0, dt = dT, theta = theta)

# all but endpoint volatilities are missing
sde.init(model = hmod, x = X0, dt = dT, m = 1,
         nvar.obs = c(2, rep(1, nObs-2), 2), theta = theta)

# all volatilities missing,
# two completely missing SDE timepoints between observations
m &lt;- 3 # divide each observation interval into m equally spaced timepoints
sde.init(model = hmod, x = X0, dt = dT,
         m = m, nvar.obs = 1, theta = theta)
</code></pre>

<hr>
<h2 id='sde.loglik'>SDE loglikelihood function.</h2><span id='topic+sde.loglik'></span>

<h3>Description</h3>

<p>Evaluates the loglikelihood function given SDE data and parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sde.loglik(model, x, dt, theta, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sde.loglik_+3A_model">model</code></td>
<td>
<p>An <code>sde.model</code> object.</p>
</td></tr>
<tr><td><code id="sde.loglik_+3A_x">x</code></td>
<td>
<p>A matrix or 3-d array of data with <code>dim(x)[1]</code> observations and <code>dim(x)[2] == ndims</code>.</p>
</td></tr>
<tr><td><code id="sde.loglik_+3A_dt">dt</code></td>
<td>
<p>A scalar or vector of length <code>dim(x)[1]-1</code> of time intervals between observations.</p>
</td></tr>
<tr><td><code id="sde.loglik_+3A_theta">theta</code></td>
<td>
<p>A vector or matrix of parameters with <code>nparams</code> columns.</p>
</td></tr>
<tr><td><code id="sde.loglik_+3A_ncores">ncores</code></td>
<td>
<p>If <code>model</code> is compiled with <code>OpenMP</code>, the number of cores to use for parallel processing.  Otherwise, uses <code>ncores = 1</code> and gives a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of loglikelihood evaluations, of the same length as the  third dimension of <code>x</code> and/or first dimension of <code>theta</code>.  If input contains invalid data or parameters an error is thrown.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load Heston's model
hmod &lt;- sde.examples("hest")

# Simulate data
nreps &lt;- 10
nobs &lt;- 100
theta &lt;- c(alpha = 0.1, gamma = 1, beta = 0.8, sigma = 0.6, rho = -0.8)
Theta &lt;- apply(t(replicate(nreps, theta)), 2, jitter)
x0 &lt;- c(X = log(1000), Z = 0.1)
X0 &lt;- apply(t(replicate(nreps,x0)), 2, jitter)
dT &lt;- 1/252
hsim &lt;- sde.sim(model = hmod, x0 = X0, theta = Theta,
                dt = dT, dt.sim = dT/10, nobs = nobs, nreps = nreps)

# single parameter, single data
sde.loglik(model = hmod, x = hsim$data[,,1], dt = dT, theta = theta)
# multiple parameters, single data
sde.loglik(model = hmod, x = hsim$data[,,1], dt = dT, theta = Theta)
# multiple parameters, multiple data
sde.loglik(model = hmod, x = hsim$data, dt = dT, theta = Theta)
</code></pre>

<hr>
<h2 id='sde.make.model'>Create an SDE model object.</h2><span id='topic+sde.make.model'></span>

<h3>Description</h3>

<p>Compiles the C++ code for various SDE-related algorithms and makes the routines available within R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sde.make.model(
  ModelFile,
  PriorFile = "default",
  data.names,
  param.names,
  hyper.check,
  OpenMP = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sde.make.model_+3A_modelfile">ModelFile</code></td>
<td>
<p>Path to the header file where the SDE model is defined.</p>
</td></tr>
<tr><td><code id="sde.make.model_+3A_priorfile">PriorFile</code></td>
<td>
<p>Path to the header file where the SDE prior is defined.  See <code><a href="#topic+sde.prior">sde.prior()</a></code> for details.</p>
</td></tr>
<tr><td><code id="sde.make.model_+3A_data.names">data.names</code></td>
<td>
<p>Vector of names for the SDE components.  Defaults to <code style="white-space: pre;">&#8288;X1,...,Xd&#8288;</code>.</p>
</td></tr>
<tr><td><code id="sde.make.model_+3A_param.names">param.names</code></td>
<td>
<p>Vector of names for the SDE parameters.  Defaults to <code style="white-space: pre;">&#8288;theta1,...,thetap&#8288;</code>.</p>
</td></tr>
<tr><td><code id="sde.make.model_+3A_hyper.check">hyper.check</code></td>
<td>
<p>A function with arguments <code>hyper</code>, <code>param.names</code>, and <code>data.names</code> used for passing the model hyper parameters to the C++ code.  See <code><a href="#topic+mvn.hyper.check">mvn.hyper.check()</a></code> for details.</p>
</td></tr>
<tr><td><code id="sde.make.model_+3A_openmp">OpenMP</code></td>
<td>
<p>Logical; whether the model is compiled with <code>OpenMP</code> for C++ level parallelization.</p>
</td></tr>
<tr><td><code id="sde.make.model_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="Rcpp.html#topic+sourceCpp">Rcpp::sourceCpp()</a></code> for compiling the C++ code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sde.model</code> object, consisting of a list with the following elements:
</p>

<dl>
<dt><code>ptr</code></dt><dd><p>Pointer to C++ sde object (<code>sdeRobj</code>) implementing the member functions: drift/diffusion, data/parameter validators, loglikelihood, prior distribution, forward simulation, MCMC algorithm for Bayesian inference.</p>
</dd>
<dt><code>ndims</code>, <code>nparams</code></dt><dd><p>The number of SDE components and parameters.</p>
</dd>
<dt><code>data.names</code>, <code>param.names</code></dt><dd><p>The names of the SDE components and parameters.</p>
</dd>
<dt><code>omp</code></dt><dd><p>A logical flag for whether or not the model was compiled for multicore functionality with <code>OpenMP</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+sde.drift">sde.drift()</a></code>, <code><a href="#topic+sde.diff">sde.diff()</a></code>, <code><a href="#topic+sde.valid">sde.valid()</a></code>, <code><a href="#topic+sde.loglik">sde.loglik()</a></code>, <code><a href="#topic+sde.prior">sde.prior()</a></code>, <code><a href="#topic+sde.sim">sde.sim()</a></code>, <code><a href="#topic+sde.post">sde.post()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># header (C++) file for Heston's model
hfile &lt;- sde.examples("hest", file.only = TRUE)
cat(readLines(hfile), sep = "\n")


# compile the model
param.names &lt;- c("alpha", "gamma", "beta", "sigma", "rho")
data.names &lt;- c("X", "Z")
hmod &lt;- sde.make.model(ModelFile = hfile,
                       param.names = param.names,
                       data.names = data.names)

hmod

</code></pre>

<hr>
<h2 id='sde.post'>MCMC sampler for the SDE posterior.</h2><span id='topic+sde.post'></span>

<h3>Description</h3>

<p>A Metropolis-within-Gibbs sampler for the Euler-Maruyama approximation to the true posterior density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sde.post(
  model,
  init,
  hyper,
  nsamples,
  burn,
  mwg.sd = NULL,
  adapt = TRUE,
  loglik.out = FALSE,
  last.miss.out = FALSE,
  update.data = TRUE,
  data.out,
  update.params = TRUE,
  fixed.params,
  ncores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sde.post_+3A_model">model</code></td>
<td>
<p>An <code>sde.model</code> object constructed with <code><a href="#topic+sde.make.model">sde.make.model()</a></code>.</p>
</td></tr>
<tr><td><code id="sde.post_+3A_init">init</code></td>
<td>
<p>An <code>sde.init</code> object constructed with <code><a href="#topic+sde.init">sde.init()</a></code>.</p>
</td></tr>
<tr><td><code id="sde.post_+3A_hyper">hyper</code></td>
<td>
<p>The hyperparameters of the SDE prior.  See <code><a href="#topic+sde.prior">sde.prior()</a></code>.</p>
</td></tr>
<tr><td><code id="sde.post_+3A_nsamples">nsamples</code></td>
<td>
<p>Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="sde.post_+3A_burn">burn</code></td>
<td>
<p>Integer number of burn-in samples, or fraction of <code>nsamples</code> to prepend as burn-in.</p>
</td></tr>
<tr><td><code id="sde.post_+3A_mwg.sd">mwg.sd</code></td>
<td>
<p>Standard deviation jump size for Metropolis-within-Gibbs on parameters and missing components of first SDE observation (see Details).</p>
</td></tr>
<tr><td><code id="sde.post_+3A_adapt">adapt</code></td>
<td>
<p>Logical or list to specify adaptive Metropolis-within-Gibbs sampling (see Details).</p>
</td></tr>
<tr><td><code id="sde.post_+3A_loglik.out">loglik.out</code></td>
<td>
<p>Logical, whether to return the loglikelihood at each step.</p>
</td></tr>
<tr><td><code id="sde.post_+3A_last.miss.out">last.miss.out</code></td>
<td>
<p>Logical, whether to return the missing sde components of the last observation.</p>
</td></tr>
<tr><td><code id="sde.post_+3A_update.data">update.data</code></td>
<td>
<p>Logical, whether to update the missing data.</p>
</td></tr>
<tr><td><code id="sde.post_+3A_data.out">data.out</code></td>
<td>
<p>A scalar, integer vector, or list of three integer vectors determining the subset of data to be returned (see Details).</p>
</td></tr>
<tr><td><code id="sde.post_+3A_update.params">update.params</code></td>
<td>
<p>Logical, whether to update the model parameters.</p>
</td></tr>
<tr><td><code id="sde.post_+3A_fixed.params">fixed.params</code></td>
<td>
<p>Logical vector of length <code>nparams</code> indicating which parameters are to be held fixed in the MCMC sampler.</p>
</td></tr>
<tr><td><code id="sde.post_+3A_ncores">ncores</code></td>
<td>
<p>If <code>model</code> is compiled with <code>OpenMP</code>, the number of cores to use for parallel processing.  Otherwise, uses <code>ncores = 1</code> and gives a warning.</p>
</td></tr>
<tr><td><code id="sde.post_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to periodically output MCMC status.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Metropolis-within-Gibbs (MWG) jump sizes can be specified as a scalar, a vector or length <code>nparams + ndims</code>, or a named vector containing the elements defined by <code>sde.init$nvar.obs.m[1]</code> (the missing variables in the first SDE observation) and <code>fixed.params</code> (the SDE parameters which are not held fixed).  The default jump sizes for each MWG random variable are <code style="white-space: pre;">&#8288;.25 * |initial_value|&#8288;</code> when <code style="white-space: pre;">&#8288;|initial_value| &gt; 0&#8288;</code>, and 1 otherwise.
</p>
<p><code>adapt == TRUE</code> implements an adaptive MCMC proposal by Roberts and Rosenthal (2009).  At step <code class="reqn">n</code> of the MCMC, the jump size of each MWG random variable is increased or decreased by <code class="reqn">\delta(n)</code>, depending on whether the cumulative acceptance rate is above or below the optimal value of 0.44.  If <code class="reqn">\sigma_n</code> is the size of the jump at step <code class="reqn">n</code>, then the next jump size is determined by
</p>
<p style="text-align: center;"><code class="reqn">
\log(\sigma_{n+1}) = \log(\sigma_n) \pm \delta(n), \qquad \delta(n) = \min(.01, 1/n^{1/2}).
</code>
</p>

<p>When <code>adapt</code> is not logical, it is a list with elements <code>max</code> and <code>rate</code>, such that <code>delta(n) = min(max, 1/n^rate)</code>.  These elements can be scalars or vectors in the same manner as <code>mwg.sd</code>.
</p>
<p>For SDE models with thousands of latent variables, <code>data.out</code> can be used to thin the MCMC missing data output.  An integer vector or scalar returns specific or evenly-spaced posterior samples from the <code style="white-space: pre;">&#8288;ncomp x ndims&#8288;</code> complete data matrix.  A list with elements <code>isamples</code>, <code>icomp</code>, and <code>idims</code> determines which samples, time points, and SDE variables to return.  The first of these can be a scalar or vector with the same meaning as before.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<dl>
<dt><code>params</code></dt><dd><p>An <code style="white-space: pre;">&#8288;nsamples x nparams&#8288;</code> matrix of posterior parameter draws.</p>
</dd>
<dt><code>data</code></dt><dd><p>A 3-d array of posterior missing data draws, for which the output dimensions are specified by <code>data.out</code>.</p>
</dd>
<dt><code>init</code></dt><dd><p>The <code>sde.init</code> object which initialized the sampler.</p>
</dd>
<dt><code>data.out</code></dt><dd><p>A list of three integer vectors specifying which timepoints, variables, and MCMC iterations correspond to the values in the <code>data</code> output.</p>
</dd>
<dt><code>mwg.sd</code></dt><dd><p>A named vector of Metropolis-within-Gibbs standard devations used at the last posterior iteration.</p>
</dd>
<dt><code>hyper</code></dt><dd><p>The hyperparameter specification.</p>
</dd>
<dt><code>loglik</code></dt><dd><p>If <code>loglik.out == TRUE</code>, the vector of <code>nsamples</code> complete data loglikelihoods calculated at each posterior sample.</p>
</dd>
<dt><code>last.iter</code></dt><dd><p>A list with elements <code>data</code> and <code>params</code> giving the last MCMC sample.  Useful for resuming the MCMC from that point.</p>
</dd>
<dt><code>last.miss</code></dt><dd><p>If <code>last.miss.out == TRUE</code>, an <code style="white-space: pre;">&#8288;nsamples x nmissN&#8288;</code> matrix of all posterior draws for the missing data in the final observation.  Useful for SDE forecasting at future timepoints.</p>
</dd>
<dt><code>accept</code></dt><dd><p>A named list of acceptance rates for the various components of the MCMC sampler.</p>
</dd>
</dl>



<h3>References</h3>

<p>Roberts, G.O. and Rosenthal, J.S. &quot;Examples of adaptive MCMC.&quot; <em>Journal of Computational and Graphical Statistics</em> 18.2 (2009): 349-367. <a href="http://www.probability.ca/jeff/ftpdir/adaptex.pdf">http://www.probability.ca/jeff/ftpdir/adaptex.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Posterior inference for Heston's model
hmod &lt;- sde.examples("hest") # load pre-compiled model

# Simulate data
X0 &lt;- c(X = log(1000), Z = 0.1)
theta &lt;- c(alpha = 0.1, gamma = 1, beta = 0.8, sigma = 0.6, rho = -0.8)
dT &lt;- 1/252
nobs &lt;- 1000
hest.sim &lt;- sde.sim(model = hmod, x0 = X0, theta = theta,
                    dt = dT, dt.sim = dT/10, nobs = nobs)

# initialize MCMC sampler
# both components observed, no missing data between observations
init &lt;- sde.init(model = hmod, x = hest.sim$data,
                 dt = hest.sim$dt, theta = theta)

# Initialize posterior sampling argument
nsamples &lt;- 1e4
burn &lt;- 1e3
hyper &lt;- NULL # flat prior
hest.post &lt;- sde.post(model = hmod, init = init, hyper = hyper,
                      nsamples = nsamples, burn = burn)

# plot the histogram for the sampled parameters
par(mfrow = c(2,3))
for(ii in 1:length(hmod$param.names)) {
  hist(hest.post$params[,ii],breaks=100, freq = FALSE,
       main = parse(text = hmod$param.names[ii]), xlab = "")
}

</code></pre>

<hr>
<h2 id='sde.prior'>SDE prior function.</h2><span id='topic+sde.prior'></span>

<h3>Description</h3>

<p>Evaluates the SDE prior given data, parameter, and hyperparameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sde.prior(model, theta, x, hyper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sde.prior_+3A_model">model</code></td>
<td>
<p>An <code>sde.model</code> object.</p>
</td></tr>
<tr><td><code id="sde.prior_+3A_theta">theta</code></td>
<td>
<p>A vector or matrix of parameters with <code>nparams</code> columns.</p>
</td></tr>
<tr><td><code id="sde.prior_+3A_x">x</code></td>
<td>
<p>A vector or matrix of data with <code>ndims</code> columns.</p>
</td></tr>
<tr><td><code id="sde.prior_+3A_hyper">hyper</code></td>
<td>
<p>The hyperparameters of the SDE prior.  See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prior is constructed at the <code style="white-space: pre;">&#8288;C++&#8288;</code> level by defining a function (i.e., public member)</p>
<pre>double logPrior(double *theta, double *x)
</pre>
<p>within the <code>sdePrior</code> class.  At the <code>R</code> level, the <code>hyper.check</code> argument of <code><a href="#topic+sde.make.model">sde.make.model()</a></code> is a function with arguments <code>hyper</code>, <code>param.names</code>, <code>data.names</code> used to convert <code>hyper</code> into a list of <code>NULL</code> or double-vectors which get passed on to the <code style="white-space: pre;">&#8288;C++&#8288;</code> code.  This function can also be used to throw <code>R</code>-level errors to protect the <code style="white-space: pre;">&#8288;C++&#8288;</code> code from invalid inputs, as is done for the default prior in <code><a href="#topic+mvn.hyper.check">mvn.hyper.check()</a></code>.  For a full example see the &quot;Custom Prior&quot; section in <code>vignette("msde-quicktut")</code>.
</p>


<h3>Value</h3>

<p>A vector of log-prior densities evaluated at the inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hmod &lt;- sde.examples("hest") # load Heston's model

# setting prior for 3 parameters
rv.names &lt;- c("alpha","gamma","rho")
mu &lt;- rnorm(3)
Sigma &lt;- crossprod(matrix(rnorm(9),3,3))
names(mu) &lt;- rv.names
colnames(Sigma) &lt;- rv.names
rownames(Sigma) &lt;- rv.names
hyper &lt;- list(mu = mu, Sigma = Sigma)

# Simulate data
nreps &lt;- 10
theta &lt;- c(alpha = 0.1, gamma = 1, beta = 0.8, sigma = 0.6, rho = -0.8)
x0 &lt;- c(X = log(1000), Z = 0.1)
Theta &lt;- apply(t(replicate(nreps,theta)),2,jitter)
X0 &lt;- apply(t(replicate(nreps,x0)),2,jitter)

sde.prior(model = hmod, x = X0, theta = Theta, hyper = hyper)
</code></pre>

<hr>
<h2 id='sde.sim'>Simulation of multivariate SDE trajectories.</h2><span id='topic+sde.sim'></span>

<h3>Description</h3>

<p>Simulates a discretized Euler-Maruyama approximation to the true SDE trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sde.sim(
  model,
  x0,
  theta,
  dt,
  dt.sim,
  nobs,
  burn = 0,
  nreps = 1,
  max.bad.draws = 5000,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sde.sim_+3A_model">model</code></td>
<td>
<p>An <code>sde.model</code> object.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_x0">x0</code></td>
<td>
<p>A vector or a matrix of size <code style="white-space: pre;">&#8288;nreps x ndims&#8288;</code> of the SDE values at time 0.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_theta">theta</code></td>
<td>
<p>A vector or matrix of size <code style="white-space: pre;">&#8288;nreps x nparams&#8288;</code> of SDE parameters.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_dt">dt</code></td>
<td>
<p>Scalar interobservation time.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_dt.sim">dt.sim</code></td>
<td>
<p>Scalar interobservation time for simulation.  That is, interally the interobservation time is <code>dt.sim</code> but only one out of every <code>dt/dt.sim</code> simulation steps is kept in the output.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_nobs">nobs</code></td>
<td>
<p>The number of SDE observations per trajectory to generate.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_burn">burn</code></td>
<td>
<p>Scalar burn-in value.  Either an integer giving the number of burn-in steps, or a value between 0 and 1 giving the fraction of burn-in relative to <code>nobs</code>.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_nreps">nreps</code></td>
<td>
<p>The number of SDE trajectories to generate.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_max.bad.draws">max.bad.draws</code></td>
<td>
<p>The maximum number of times that invalid forward steps are proposed.  See Details.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to display information on the simulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation algorithm is a Markov process with <code class="reqn">Y_0 = x_0</code> and
</p>
<p style="text-align: center;"><code class="reqn">
Y_{t+1} \sim \mathcal{N}(Y_t + \mathrm{dr}(Y_t, \theta) dt_{\mathrm{sim}}, \mathrm{df}(Y_t, \theta) dt_{\mathrm{sim}}),
</code>
</p>

<p>where <code class="reqn">\mathrm{dr}(y, \theta)</code> is the SDE drift function and <code class="reqn">\mathrm{df}(y, \theta)</code> is the diffusion function on the <strong>variance</strong> scale.  At each step, a while-loop is used until a valid SDE draw is produced.  The simulation algorithm terminates after <code>nreps</code> trajectories are drawn or once a total of <code>max.bad.draws</code> are reached.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>An array of size <code style="white-space: pre;">&#8288;nobs x ndims x nreps&#8288;</code> containing the simulated SDE trajectories.</p>
</dd>
<dt><code>params</code></dt><dd><p>The vector or matrix of parameter values used to generate the data.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;dt, dt.sim&#8288;</code></dt><dd><p>The actual and internal interobservation times.</p>
</dd>
<dt><code>nbad</code></dt><dd><p>The total number of bad draws.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load pre-compiled model
hmod &lt;- sde.examples("hest")

# initial values
x0 &lt;- c(X = log(1000), Z = 0.1)
theta &lt;- c(alpha = 0.1, gamma = 1, beta = 0.8, sigma = 0.6, rho = -0.8)

# simulate data
dT &lt;- 1/252
nobs &lt;- 2000
burn &lt;- 500
hsim &lt;- sde.sim(model = hmod, x0 = x0, theta = theta,
                dt = dT, dt.sim = dT/10,
                nobs = nobs, burn = burn)

par(mfrow = c(1,2))
plot(hsim$data[,"X"], type = "l", xlab = "Time", ylab = "",
     main = expression(X[t]))
plot(hsim$data[,"Z"], type = "l", xlab = "Time", ylab = "",
     main = expression(Z[t]))
</code></pre>

<hr>
<h2 id='sde.valid'>SDE data and parameter validators.</h2><span id='topic+sde.valid'></span><span id='topic+sde.valid.data'></span><span id='topic+sde.valid.params'></span>

<h3>Description</h3>

<p>Checks whether input SDE data and parameters are valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sde.valid.data(model, x, theta)

sde.valid.params(model, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sde.valid_+3A_model">model</code></td>
<td>
<p>An <code>sde.model</code> object.</p>
</td></tr>
<tr><td><code id="sde.valid_+3A_x">x</code></td>
<td>
<p>A length-<code>ndims</code> vector or <code>ndims</code>-column matrix of SDE data.</p>
</td></tr>
<tr><td><code id="sde.valid_+3A_theta">theta</code></td>
<td>
<p>A length-<code>nparams</code> vector or <code>nparams</code>-column of SDE parameter values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical scalar or vector indicating whether the given data/parameter pair is valid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Heston's model
# valid data is: Z &gt; 0
# valid parameters are: gamma, sigma &gt; 0, |rho| &lt; 1, beta &gt; .5 * sigma^2
hmod &lt;- sde.examples("hest") # load model

theta &lt;- c(alpha = 0.1, gamma = 1, beta = 0.8, sigma = 0.6, rho = -0.8)

# valid data
x0 &lt;- c(X = log(1000), Z = 0.1)
sde.valid.data(model = hmod, x = x0, theta = theta)

# invalid data
x0 &lt;- c(X = log(1000), Z = -0.1)
sde.valid.data(model = hmod, x = x0, theta = theta)

# valid parameters
theta &lt;- c(alpha = 0.1, gamma = 1, beta = 0.8, sigma = 0.6, rho = -0.8)
sde.valid.params(model = hmod, theta = theta)

# invalid parameters
theta &lt;- c(alpha = 0.1, gamma = -4, beta = 0.8, sigma = 0.6, rho = -0.8)
sde.valid.params(model = hmod, theta = theta)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
