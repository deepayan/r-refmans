<!DOCTYPE html><html><head><title>Help for package hydroloom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hydroloom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accumulate_downstream'><p>Accumulate Variable Downstream</p></a></li>
<li><a href='#add_divergence'><p>Add Divergence Attribute</p></a></li>
<li><a href='#add_levelpaths'><p>Add Level Paths</p></a></li>
<li><a href='#add_pathlength'><p>Add Path Length</p></a></li>
<li><a href='#add_pfafstetter'><p>Add Pfafstetter Codes</p></a></li>
<li><a href='#add_return_divergence'><p>Add Return Divergence</p></a></li>
<li><a href='#add_streamlevel'><p>Add Streamlevel</p></a></li>
<li><a href='#add_streamorder'><p>add Streamorder</p></a></li>
<li><a href='#add_toids'><p>Add Downstream IDs</p></a></li>
<li><a href='#add_topo_sort'><p>Add topo_sort</p></a></li>
<li><a href='#align_names'><p>Align Names to Hydroloom Convention</p></a></li>
<li><a href='#check_hy_graph'><p>Check hy Graph</p></a></li>
<li><a href='#disambiguate_indexes'><p>Disambiguate Flowline Indexes</p></a></li>
<li><a href='#fix_flowdir'><p>Fix Flow Direction</p></a></li>
<li><a href='#format_index_ids'><p>Format Index ids</p></a></li>
<li><a href='#get_hydro_location'><p>Get Hydro Location</p></a></li>
<li><a href='#get_node'><p>Get Line Node</p></a></li>
<li><a href='#get_partial_length'><p>Get Partial Flowpath Length</p></a></li>
<li><a href='#hy'><p>Create a hy Fabric S3 Object</p></a></li>
<li><a href='#hy_reverse'><p>Reverse <code>hy</code> to Original Names</p></a></li>
<li><a href='#hydroloom_name_definitions'><p>Hydroloom Name Definitions</p></a></li>
<li><a href='#hydroloom_names'><p>Get or Set Hydroloom Names</p></a></li>
<li><a href='#index_points_to_lines'><p>Index Points to Lines</p></a></li>
<li><a href='#index_points_to_waterbodies'><p>Index Points to Waterbodies</p></a></li>
<li><a href='#is.hy'><p>Is Valid <code>hy</code> Class?</p></a></li>
<li><a href='#make_attribute_topology'><p>Make Attribute Topology</p></a></li>
<li><a href='#make_fromids'><p>Convert &quot;to&quot; index ids to &quot;from&quot; index ids</p></a></li>
<li><a href='#make_index_ids'><p>Make Index ids</p></a></li>
<li><a href='#make_node_topology'><p>Make Node Topology from Edge Topology</p></a></li>
<li><a href='#navigate_connected_paths'><p>Navigate Connected Paths</p></a></li>
<li><a href='#navigate_hydro_network'><p>Navigate Hydro Network</p></a></li>
<li><a href='#navigate_network_dfs'><p>Navigate all Paths Depth First</p></a></li>
<li><a href='#rename_geometry'><p>Rename Geometry</p></a></li>
<li><a href='#rescale_measures'><p>Rescale Aggregate id Measure to id Measure</p></a></li>
<li><a href='#sort_network'><p>Sort Network</p></a></li>
<li><a href='#st_compatibalize'><p>Make Spatial Inputs Compatible</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Utilities to Weave Hydrologic Fabrics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of utilities that support creation of network attributes for hydrologic networks. Methods and algorithms implemented are documented in Moore et al. (2019) &lt;<a href="https://doi.org/10.3133%2Fofr20191096">doi:10.3133/ofr20191096</a>&gt;), Cormen and Leiserson (2022) &lt;ISBN:9780262046305&gt; and Verdin and Verdin (1999) &lt;<a href="https://doi.org/10.1016%2FS0022-1694%2899%2900011-6">doi:10.1016/S0022-1694(99)00011-6</a>&gt;.  </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, data.table, sf, units, stats, methods, utils, pbapply,
tidyr, RANN, rlang, fastmap</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, nhdplusTools, future, lwgeom, future.apply, knitr,
gifski, mapview</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DOI-USGS/hydroloom">https://github.com/DOI-USGS/hydroloom</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-15 15:29:30 UTC; dblodgett</td>
</tr>
<tr>
<td>Author:</td>
<td>David Blodgett <a href="https://orcid.org/0000-0001-9489-1710"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Blodgett &lt;dblodgett@usgs.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-15 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='accumulate_downstream'>Accumulate Variable Downstream</h2><span id='topic+accumulate_downstream'></span><span id='topic+accumulate_downstream.data.frame'></span><span id='topic+accumulate_downstream.hy'></span>

<h3>Description</h3>

<p>given a variable, accumulate according to network topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accumulate_downstream(x, var)

## S3 method for class 'data.frame'
accumulate_downstream(x, var)

## S3 method for class 'hy'
accumulate_downstream(x, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accumulate_downstream_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="accumulate_downstream_+3A_var">var</code></td>
<td>
<p>variable to accumulate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of the same length as <code>nrow(x)</code> containing values of <code>var</code> accumulated downstream
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

x$totDASqKM &lt;- accumulate_downstream(add_toids(x), "AreaSqKM")

plot(x['totDASqKM'], lwd = x$totDASqKM / 50)
</code></pre>

<hr>
<h2 id='add_divergence'>Add Divergence Attribute</h2><span id='topic+add_divergence'></span><span id='topic+add_divergence.data.frame'></span><span id='topic+add_divergence.hy'></span>

<h3>Description</h3>

<p>Given a non-dendritic flow network and required attributes,
adds a divergence attribute according to NHDPlus data model methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_divergence(
  x,
  coastal_outlet_ids,
  inland_outlet_ids,
  name_attr,
  type_attr,
  major_types
)

## S3 method for class 'data.frame'
add_divergence(
  x,
  coastal_outlet_ids,
  inland_outlet_ids,
  name_attr,
  type_attr,
  major_types
)

## S3 method for class 'hy'
add_divergence(
  x,
  coastal_outlet_ids,
  inland_outlet_ids,
  name_attr,
  type_attr,
  major_types
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_divergence_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="add_divergence_+3A_coastal_outlet_ids">coastal_outlet_ids</code></td>
<td>
<p>vector of identifiers for network outlets that
terminate at the coast.</p>
</td></tr>
<tr><td><code id="add_divergence_+3A_inland_outlet_ids">inland_outlet_ids</code></td>
<td>
<p>vector of identifiers for network outlets that
terminate inland.</p>
</td></tr>
<tr><td><code id="add_divergence_+3A_name_attr">name_attr</code></td>
<td>
<p>character attribute name of attribute containing a feature
name or name identifier.</p>
</td></tr>
<tr><td><code id="add_divergence_+3A_type_attr">type_attr</code></td>
<td>
<p>character attribute name of attribute containing a feature
type indicator.</p>
</td></tr>
<tr><td><code id="add_divergence_+3A_major_types">major_types</code></td>
<td>
<p>vector of values of <code>type_attr</code> that should be interpreted
as being &quot;major&quot;. e.g. river might be major and canal might be minor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When considering downstream connections with diversions, there are three
factors considered to determine which is primary.<br>
1a) same name<br>
1b) is named<br>
2) feature type (type_attr controls this)<br>
3) flows to coast (has a coastal connection is preferred)<br>
</p>
<p>The following list describes the order of precedence for tests<br>
1: 1a, 2, 3<br>
2: 1a, 2<br>
3: The NHDPlus uses diverted fraction this is not used currently.<br>
4: 1b, 2, 3<br>
5: 2, 3<br>
6: 1b, 3<br>
7: 3,<br>
8: 1b, 2<br>
9: 2<br>
10: 1b<br>
</p>
<p>If all checks return and no primary connection has been identified, the
connection with a smaller id is chosen.
</p>
<p>In the case that there are two or more upstream connections, the upstream
name to use is chosen 1) if there is only one upstream flowline with a name
2) if one of the upstream flowlines with a name matches the downstream line,
3) if one of the upstream flowlines is of a &quot;major&quot; type and others are not,
and, 4) if no criteria exist to select one, the smallest id value otherwise.
</p>


<h3>Value</h3>

<p>returns x with a <code>divergence</code> attribute appended
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- system.file("extdata/coastal_example.gpkg", package = "hydroloom")

g &lt;- sf::read_sf(f)
g &lt;- g[g$FTYPE != "Coastline", ]

outlets &lt;- g$COMID[!g$ToNode %in% g$FromNode]

g &lt;- dplyr::select(g, COMID, gnis_id, FTYPE,
                   FromNode, ToNode)

add_divergence(g,
               coastal_outlet_ids = outlets,
               inland_outlet_ids = c(),
               name_attr = "gnis_id",
               type_attr = "FTYPE",
               major_types = c("StreamRiver", "ArtificialPath", "Connector"))


</code></pre>

<hr>
<h2 id='add_levelpaths'>Add Level Paths</h2><span id='topic+add_levelpaths'></span><span id='topic+add_levelpaths.data.frame'></span><span id='topic+add_levelpaths.hy'></span>

<h3>Description</h3>

<p>Assigns level paths using the stream-leveling approach of
NHD and NHDPlus. If arbolate sum is provided in the weight column, this
will match the behavior of NHDPlus. Any numeric value can be
included in this column and the largest value will be followed when
no nameid is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_levelpaths(
  x,
  name_attribute,
  weight_attribute,
  override_factor = NULL,
  status = FALSE
)

## S3 method for class 'data.frame'
add_levelpaths(
  x,
  name_attribute,
  weight_attribute,
  override_factor = NULL,
  status = FALSE
)

## S3 method for class 'hy'
add_levelpaths(
  x,
  name_attribute,
  weight_attribute,
  override_factor = NULL,
  status = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_levelpaths_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="add_levelpaths_+3A_name_attribute">name_attribute</code></td>
<td>
<p>character attribute to be used as name identifiers.</p>
</td></tr>
<tr><td><code id="add_levelpaths_+3A_weight_attribute">weight_attribute</code></td>
<td>
<p>character attribute to be used as weight.</p>
</td></tr>
<tr><td><code id="add_levelpaths_+3A_override_factor">override_factor</code></td>
<td>
<p>numeric multiplier to use to override <code>name_attribute</code>.
See details.</p>
</td></tr>
<tr><td><code id="add_levelpaths_+3A_status">status</code></td>
<td>
<p>boolean if status updates should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The levelpath algorithm defines upstream mainstem paths through a network.
At a given junction with two or more upstream flowpaths, the main path is
either 1) the path with the same name, 2) the path with any name, 3) or the
path with the larger weight. If the <code>weight_attribute</code> is <code>override_factor</code>
times larger on a path, it will be followed regardless of the name_attribute
indication.
</p>


<h3>Value</h3>

<p>data.frame with id, levelpath_outlet_id, topo_sort, and levelpath columns.
See details for more info.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

test_flowline &lt;- add_toids(g)

# use NHDPlus attributes directly
add_levelpaths(test_flowline,
               name_attribute = "GNIS_ID",
               weight_attribute = "ArbolateSu")

# use hy attributes where they can be mapped
add_levelpaths(hy(test_flowline),
               name_attribute = "GNIS_ID",
               weight_attribute = "arbolate_sum")

</code></pre>

<hr>
<h2 id='add_pathlength'>Add Path Length</h2><span id='topic+add_pathlength'></span><span id='topic+add_pathlength.data.frame'></span><span id='topic+add_pathlength.hy'></span>

<h3>Description</h3>

<p>Generates the main path length to a basin's terminal path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_pathlength(x)

## S3 method for class 'data.frame'
add_pathlength(x)

## S3 method for class 'hy'
add_pathlength(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_pathlength_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing pathlength_km
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

x &lt;- add_toids(x)

x &lt;- add_pathlength(x)

plot(x["Pathlength"])

</code></pre>

<hr>
<h2 id='add_pfafstetter'>Add Pfafstetter Codes</h2><span id='topic+add_pfafstetter'></span><span id='topic+add_pfafstetter.data.frame'></span><span id='topic+add_pfafstetter.hy'></span>

<h3>Description</h3>

<p>Determines Pfafstetter codes for a dendritic network with
total drainage area, levelpath, and topo_sort attributes. Topo_sort and
levelpath attributes must be self consistent (levelpath values are the
same as the outlet topo_sort value) as generated by <a href="#topic+add_levelpaths">add_levelpaths</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_pfafstetter(x, max_level = 2, status = FALSE)

## S3 method for class 'data.frame'
add_pfafstetter(x, max_level = 2, status = FALSE)

## S3 method for class 'hy'
add_pfafstetter(x, max_level = 2, status = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_pfafstetter_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="add_pfafstetter_+3A_max_level">max_level</code></td>
<td>
<p>integer number of levels to attempt to calculate.
If the network doesn't have resolution to support the desired level,
unexpected behavior may occur.</p>
</td></tr>
<tr><td><code id="add_pfafstetter_+3A_status">status</code></td>
<td>
<p>boolean if status updates should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with added pfafstetter column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

x &lt;- add_toids(x)

pfaf &lt;- add_pfafstetter(x, max_level = 2)

plot(pfaf["pf_level_2"], lwd = 2)


if(require(nhdplusTools)) {

# uses tempdir for example
work_dir &lt;- nhdplusTools::nhdplusTools_data_dir(tempdir())

try(
source(system.file("extdata/nhdplushr_data.R", package = "nhdplusTools"))
)
if(exists("hr_data")) {
x &lt;- hy(hr_data$NHDFlowline)

x &lt;- add_toids(x)

x &lt;- dplyr::select(x, id, toid, da_sqkm)

#' add terminal_id -- add in function?
x &lt;- sort_network(x, split = TRUE)

x$total_da_sqkm &lt;- accumulate_downstream(x, "da_sqkm")
x$name &lt;- ""

x &lt;- add_levelpaths(x, name_attribute = "name", weight_attribute = "total_da_sqkm")

x &lt;- add_pfafstetter(x, max_level = 3)

plot(x["pf_level_3"], lwd = 2)

pfaf &lt;- add_pfafstetter(x, max_level = 4)

hr_catchment &lt;- dplyr::left_join(hr_data$NHDPlusCatchment,
                                 sf::st_drop_geometry(pfaf), by = c("FEATUREID" = "id"))

colors &lt;- data.frame(pf_level_4 = unique(hr_catchment$pf_level_4),
                     color = sample(terrain.colors(length(unique(hr_catchment$pf_level_4)))))

hr_catchment &lt;- dplyr::left_join(hr_catchment, colors, by = "pf_level_4")

plot(hr_catchment["color"], border = NA, reset = FALSE)
plot(sf::st_geometry(x), col = "blue", add = TRUE)
} else {
  message("nhdplusTools &gt; 1.0 required for this example")
}
}

</code></pre>

<hr>
<h2 id='add_return_divergence'>Add Return Divergence</h2><span id='topic+add_return_divergence'></span><span id='topic+add_return_divergence.data.frame'></span><span id='topic+add_return_divergence.hy'></span>

<h3>Description</h3>

<p>Adds a return divergence attribute to the provided network.
The method implemented matches that of the NHDPlus except
in the rare case that a diversion includes more than one secondary path.
</p>
<p>Requires and <code>id</code>, <code>fromnode</code>, <code>tonode</code> and <code>divergence</code> attribute.
See <a href="#topic+add_divergence">add_divergence</a> and <a href="#topic+make_node_topology">make_node_topology</a>.
</p>
<p>Algorithm:
</p>
<p>All network connections with more than one downstream feature
are considered.
</p>
<p><a href="#topic+navigate_network_dfs">navigate_network_dfs</a> is used to find all downstream
features emanating from the primary (<code>divergence == 1</code>) outlet of the
diversion in question and secondary (<code>divergence == 2</code>) outlet(s) starting
with the primary outlet.
</p>
<p><a href="#topic+navigate_network_dfs">navigate_network_dfs</a> is called with <code>reset = FALSE</code> such that the
secondary diversion paths terminate where they combine with a previously
visited feature.
</p>
<p>If the diverted paths result in only one outlet, the feature it flows to
is marked as a return divergence.
</p>
<p>If the diverted paths result in more than one outlet, the one that flows to
the most upstream feature in the set of features downstream of the primary
outlet of the diversion is marked as the return divergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_return_divergence(x, status = TRUE)

## S3 method for class 'data.frame'
add_return_divergence(x, status = TRUE)

## S3 method for class 'hy'
add_return_divergence(x, status = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_return_divergence_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="add_return_divergence_+3A_status">status</code></td>
<td>
<p>boolean if status updates should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing <code>return_divergence</code> attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

x &lt;- hy(x)

x &lt;- add_return_divergence(x)

sum(x$return_divergence == x$RtnDiv)

# see description for documentation of one that does not match

</code></pre>

<hr>
<h2 id='add_streamlevel'>Add Streamlevel</h2><span id='topic+add_streamlevel'></span><span id='topic+add_streamlevel.data.frame'></span><span id='topic+add_streamlevel.hy'></span>

<h3>Description</h3>

<p>Applies a topological sort and calculates stream level.
Algorithm: Terminal level paths are assigned level 1 (see note 1).
Paths that terminate at a level 1 are assigned level 2. This pattern is
repeated until no paths remain.
</p>
<p>If a TRUE/FALSE coastal attribute is included, coastal terminal paths
begin at 1 and internal terminal paths begin at 4 as is implemented by
the NHD stream leveling rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_streamlevel(x, coastal = NULL)

## S3 method for class 'data.frame'
add_streamlevel(x, coastal = NULL)

## S3 method for class 'hy'
add_streamlevel(x, coastal = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_streamlevel_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="add_streamlevel_+3A_coastal">coastal</code></td>
<td>
<p>character attribute name containing a logical flag
indicating if a given terminal catchment flows to the coast of is an
inland sink. If no coastal flag is included, all terminal paths are
assumed to be coastal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data,frame containing added <code>stream_level</code> attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

x &lt;- add_toids(x)

y &lt;- add_streamlevel(x)

plot(sf::st_geometry(y), lwd = y$streamlevel, col = "blue")

x$coastal &lt;- rep(FALSE, nrow(x))

y &lt;- add_streamlevel(x, coastal = "coastal")

unique(y$streamlevel)

x$coastal[!x$Hydroseq == min(x$Hydroseq)] &lt;- TRUE

y &lt;- add_streamlevel(x)

unique(y$streamlevel)

</code></pre>

<hr>
<h2 id='add_streamorder'>add Streamorder</h2><span id='topic+add_streamorder'></span><span id='topic+add_streamorder.data.frame'></span><span id='topic+add_streamorder.hy'></span>

<h3>Description</h3>

<p>Adds a strahler stream order.
</p>
<p>Algorithm: If more than one upstream flowpath has an order equal to the
maximum upstream order then the downstream flowpath is assigned the maximum
upstream order plus one. Otherwise it is assigned the maximum upstream order.
</p>
<p>To match the NHDPlus algorithm, non-dendritic network connectivity and a
<code>divergence</code> attribute must be included. All secondary paths will have the
<code>stream_order</code> of upstream primary paths and a <code>stream_calculator</code> value of 0.
Secondary paths have no affect on the order of downstream paths.
</p>
<p>Requires a toid attribute or fromnode, tonode, and divergence attributes
that will be used to construct a toid attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_streamorder(x, status = TRUE)

## S3 method for class 'data.frame'
add_streamorder(x, status = TRUE)

## S3 method for class 'hy'
add_streamorder(x, status = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_streamorder_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="add_streamorder_+3A_status">status</code></td>
<td>
<p>boolean if status updates should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing added <code>stream_order</code> and <code>stream_calculator</code> attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

x &lt;- dplyr::select(x, COMID, FromNode, ToNode, Divergence)

x &lt;- add_streamorder(x)

plot(sf::st_geometry(x), lwd = x$stream_order, col = "blue")
plot(sf::st_geometry(x), lwd = x$stream_calculator, col = "blue")

</code></pre>

<hr>
<h2 id='add_toids'>Add Downstream IDs</h2><span id='topic+add_toids'></span><span id='topic+add_toids.data.frame'></span><span id='topic+add_toids.hy'></span>

<h3>Description</h3>

<p>Given input with fromnode and tonode attributes,
will return the input with a toid attribute that is the result of joining
tonode and fromnode attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_toids(x, return_dendritic = TRUE)

## S3 method for class 'data.frame'
add_toids(x, return_dendritic = TRUE)

## S3 method for class 'hy'
add_toids(x, return_dendritic = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_toids_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="add_toids_+3A_return_dendritic">return_dendritic</code></td>
<td>
<p>logical remove non dendritic paths if TRUE. Requires
a &quot;divergence&quot; flag where 1 is main and 2 is secondary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hy object with toid attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

x &lt;- add_toids(hy(g))

y &lt;- add_toids(g)

names(g)[1:4]

names(x)[1:4]

names(y)[1:4]

</code></pre>

<hr>
<h2 id='add_topo_sort'>Add topo_sort</h2><span id='topic+add_topo_sort'></span><span id='topic+add_topo_sort.data.frame'></span><span id='topic+add_topo_sort.hy'></span>

<h3>Description</h3>

<p>calls <a href="#topic+sort_network">sort_network</a> without support for splitting the network
and adds a <code>nrow:1</code> topo_sort attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_topo_sort(x, outlets = NULL)

## S3 method for class 'data.frame'
add_topo_sort(x, outlets = NULL)

## S3 method for class 'hy'
add_topo_sort(x, outlets = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_topo_sort_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="add_topo_sort_+3A_outlets">outlets</code></td>
<td>
<p>same as id in x. if specified, only the network
emanating from these outlets will be considered and returned.
NOTE: If outlets does not include all outlets from a given
network containing diversions, a partial network may be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing a topo_sort attribute.
</p>

<hr>
<h2 id='align_names'>Align Names to Hydroloom Convention</h2><span id='topic+align_names'></span>

<h3>Description</h3>

<p>this function aligns the attribute names in x
with those used in hydroloom. See <a href="#topic+hydroloom_names">hydroloom_names</a> for how
to add more attribute name mappings if the attributes in your data
are not supported.
</p>
<p>See <a href="#topic+hydroloom_name_definitions">hydroloom_name_definitions</a> for definitions of the names
used in hydroloom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_names_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame renamed to match hydroloom as possible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

names(x)

x &lt;- align_names(x)

names(x)

</code></pre>

<hr>
<h2 id='check_hy_graph'>Check hy Graph</h2><span id='topic+check_hy_graph'></span>

<h3>Description</h3>

<p>check that a id toid graph doesn't contain localized loops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_hy_graph(x, loop_check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_hy_graph_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="check_hy_graph_+3A_loop_check">loop_check</code></td>
<td>
<p>logical if TRUE, the entire network is walked from
top to bottom searching for loops. This loop detection algorithm visits
a node in the network only once all its upstream neighbors have been
visited. A complete depth first search is performed at each node, searching
for paths that lead to an already visited (upstream) node. This algorithm
is often referred to as &quot;recursive depth first search&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if no localized loops are found, returns TRUE. If localized
loops are found, problem rows with a row number added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># notice that row 4 (id = 4, toid = 9) and row 8 (id = 9, toid = 4) is a loop.
test_data &lt;- data.frame(id = c(1, 2, 3, 4, 6, 7, 8, 9),
                      toid = c(2, 3, 4, 9, 7, 8, 9, 4))
check_hy_graph(test_data)

</code></pre>

<hr>
<h2 id='disambiguate_indexes'>Disambiguate Flowline Indexes</h2><span id='topic+disambiguate_indexes'></span>

<h3>Description</h3>

<p>Given a set of flowline indexes and numeric or ascii criteria,
return closest match. If numeric criteria are used, the minimum difference
in the numeric attribute is used for disambiguation. If ascii criteria are used,
the <a href="utils.html#topic+adist">adist</a> function is used with the following algorithm:
<code>1 - adist_score / max_string_length</code>. Comparisons ignore case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disambiguate_indexes(indexes, flowpath, hydro_location)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disambiguate_indexes_+3A_indexes">indexes</code></td>
<td>
<p>data.frame as output from <a href="#topic+index_points_to_lines">index_points_to_lines</a> with more than
one hydrologic location per indexed point.</p>
</td></tr>
<tr><td><code id="disambiguate_indexes_+3A_flowpath">flowpath</code></td>
<td>
<p>data.frame with two columns. The first should join to the id
field of the indexes and the second should be the numeric or ascii metric such as drainage
area or Name. Names of this data.frame are not used.</p>
</td></tr>
<tr><td><code id="disambiguate_indexes_+3A_hydro_location">hydro_location</code></td>
<td>
<p>data.frame with two columns. The first should join to the
id field of the indexes and the second should be the numeric or ascii metric such as drainage
area or GNIS Name. Names of this data.frame are not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame indexes deduplicated according to the minimum difference
between the values in the metric columns. If two or more result in the same &quot;minimum&quot;
value, duplicates will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(nhdplusTools)) {
source(system.file("extdata", "sample_flines.R", package = "nhdplusTools"))

hydro_location &lt;- sf::st_sf(id = c(1, 2, 3),
                            geom = sf::st_sfc(list(sf::st_point(c(-76.86934, 39.49328)),
                                                   sf::st_point(c(-76.91711, 39.40884)),
                                                   sf::st_point(c(-76.88081, 39.36354))),
                                              crs = 4326),
                            totda = c(23.6, 7.3, 427.9),
                            nameid = c("Patapsco", "", "Falls Run River"))

indexes &lt;- index_points_to_lines(sample_flines,
                                 hydro_location,
                                 search_radius = units::set_units(0.2, "degrees"),
                                 max_matches = 10)

disambiguate_indexes(indexes,
                     dplyr::select(sample_flines, COMID, TotDASqKM),
                     dplyr::select(hydro_location, id, totda))

result &lt;- disambiguate_indexes(indexes,
                               dplyr::select(sample_flines, COMID, GNIS_NAME),
                               dplyr::select(hydro_location, id, nameid))

result[result$point_id == 1, ]

result[result$point_id == 2, ]

result[result$point_id == 3, ]
}

</code></pre>

<hr>
<h2 id='fix_flowdir'>Fix Flow Direction</h2><span id='topic+fix_flowdir'></span>

<h3>Description</h3>

<p>If flowlines aren't digitized in the expected direction,
this will reorder the nodes so they are.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_flowdir(id, network = NULL, fn_list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_flowdir_+3A_id">id</code></td>
<td>
<p>integer The id of the flowline to check</p>
</td></tr>
<tr><td><code id="fix_flowdir_+3A_network">network</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="fix_flowdir_+3A_fn_list">fn_list</code></td>
<td>
<p>list containing named elements <code>flowline</code>, <code>network</code>, and <code>check_end</code>,
where <code>flowline</code> is the flowline to be checked and <code>network</code> the feature up or downstream
of the flowline to be checked, and <code>check_end</code> is <code>"start"</code> or <code>"end"</code> depending if the
<code>network</code> input is upstream (<code>"start"</code>) or downstream (<code>"end"</code>) of the flowline to be checked.
This option allows pre-compilation of pairs of features which may be useful for very large
numbers of flow direction checks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a geometry for the feature that has been reversed if needed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

# We add a tocomid with prepare_nhdplus
x &lt;- add_toids(hy(x))

# Look at the end node of the 10th line.
(n1 &lt;- get_node(x[10, ], position = "end"))

# Break the geometry by reversing it.
sf::st_geometry(x)[10] &lt;- sf::st_reverse(sf::st_geometry(x)[10])

# Note that the end node is different now.
(n2 &lt;- get_node(x[10, ], position = "end"))

# Pass the broken geometry to fix_flowdir with the network for toCOMID
sf::st_geometry(x)[10] &lt;- fix_flowdir(x$id[10], x)

# Note that the geometry is now in the right order.
(n3 &lt;- get_node(x[10, ], position = "end"))

plot(sf::st_geometry(x)[10])
plot(n1, add = TRUE)
plot(n2, add = TRUE, col = "blue")
plot(n3, add = TRUE, cex = 2, col = "red")

</code></pre>

<hr>
<h2 id='format_index_ids'>Format Index ids</h2><span id='topic+format_index_ids'></span>

<h3>Description</h3>

<p>Format Index ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_index_ids(g, return_list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_index_ids_+3A_g">g</code></td>
<td>
<p>data.frame graph with <code>id</code>, <code>inid</code> and <code>toindid</code> as returned by <a href="#topic+make_index_ids">make_index_ids</a>
with <code>long_form</code>=TRUE.</p>
</td></tr>
<tr><td><code id="format_index_ids_+3A_return_list">return_list</code></td>
<td>
<p>logical if TRUE, the returned list will include a
&quot;froms_list&quot; element containing all from ids in a list form.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing an adjacency matrix and a lengths vector indicating
the number of connections from each node. If <code>complete</code> is <code>TRUE</code> return
will also include a data.frame with an <code>indid</code> column and a <code>toindid</code> list
column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

y &lt;- add_toids(x) |&gt;
  make_index_ids(long_form = TRUE) |&gt;
  format_index_ids()

</code></pre>

<hr>
<h2 id='get_hydro_location'>Get Hydro Location</h2><span id='topic+get_hydro_location'></span>

<h3>Description</h3>

<p>given a flowline index, returns the hydrologic location (point)
along the specific linear element referenced by the index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hydro_location(indexes, flowpath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_hydro_location_+3A_indexes">indexes</code></td>
<td>
<p>data.frame as output from <a href="#topic+index_points_to_lines">index_points_to_lines</a>.</p>
</td></tr>
<tr><td><code id="get_hydro_location_+3A_flowpath">flowpath</code></td>
<td>
<p>data.frame with three columns: id, frommeas, and tomeas
as well as geometry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sfc_POINT simple feature geometry list of length <code>nrow(indexes)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(nhdplusTools)) {
source(system.file("extdata", "sample_flines.R", package = "nhdplusTools"))

indexes &lt;- index_points_to_lines(sample_flines,
                   sf::st_sfc(sf::st_sfc(list(sf::st_point(c(-76.86934, 39.49328)),
                                              sf::st_point(c(-76.91711, 39.40884)),
                                              sf::st_point(c(-76.88081, 39.36354))),
                              crs = 4326)))

get_hydro_location(indexes, sample_flines)
}
</code></pre>

<hr>
<h2 id='get_node'>Get Line Node</h2><span id='topic+get_node'></span>

<h3>Description</h3>

<p>Given one or more lines, returns a particular node from
the line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_node(x, position = "end")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_node_+3A_x">x</code></td>
<td>
<p>sf sf data.frame with one or more LINESTRING features</p>
</td></tr>
<tr><td><code id="get_node_+3A_position">position</code></td>
<td>
<p>character either &quot;start&quot; or &quot;end&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf data.frame containing requested nodes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

start &lt;- get_node(x, "start")
end &lt;- get_node(x, "end")

plot(sf::st_zm(sf::st_geometry(x)),
     lwd = x$StreamOrde, col = "blue")
plot(sf::st_geometry(start), add = TRUE)

plot(sf::st_zm(sf::st_geometry(x)),
     lwd = x$StreamOrde, col = "blue")
plot(sf::st_geometry(end), add = TRUE)

</code></pre>

<hr>
<h2 id='get_partial_length'>Get Partial Flowpath Length</h2><span id='topic+get_partial_length'></span>

<h3>Description</h3>

<p>Finds the upstream and downstream lengths along a given
flowpath (flowline in NHDPlus terminology). Internally, the function
rescales the aggregate_id_measure to a id_measure and applies that
rescaled measure to the length of the flowpath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_partial_length(hydro_location, network = NULL, flowpath = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_partial_length_+3A_hydro_location">hydro_location</code></td>
<td>
<p>list containing a hydrologic locations with names
aggregate_id (reachcode) and aggregate_id_measure (reachcode measure).</p>
</td></tr>
<tr><td><code id="get_partial_length_+3A_network">network</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="get_partial_length_+3A_flowpath">flowpath</code></td>
<td>
<p>data.frame containing one flowpath that corresponds to the
<code>hydro_location</code>. Not required if <code>x</code> is provided. <code>x</code> is not required if
<code>flowpath</code> is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing <code>up</code> and <code>dn</code> elements with numeric length in
km.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- sf::read_sf(system.file("extdata", "walker.gpkg", package = "hydroloom"))

hydro_location &lt;- list(comid = 5329339,
                       reachcode = "18050005000078",
                       reach_meas = 30)

(pl &lt;- get_partial_length(hydro_location, x))

</code></pre>

<hr>
<h2 id='hy'>Create a hy Fabric S3 Object</h2><span id='topic+hy'></span>

<h3>Description</h3>

<p>converts a compatible dataset into a fabric s3 class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hy(x, clean = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hy_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="hy_+3A_clean">clean</code></td>
<td>
<p>logical if TRUE, geometry and non-hydroloom compatible attributes
will be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hy object with attributes compatible with the hydroloom package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

hy(x)

hy(x, clean = TRUE)[1:10,]

attr(hy(x), "orig_names")

</code></pre>

<hr>
<h2 id='hy_reverse'>Reverse <code>hy</code> to Original Names</h2><span id='topic+hy_reverse'></span>

<h3>Description</h3>

<p>renames hy object to original names and removes hy object
attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hy_reverse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hy_reverse_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns x with attribute names converted to original names provided to <a href="#topic+hy">hy</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))
x &lt;- hy(x)

hy_reverse(x)

</code></pre>

<hr>
<h2 id='hydroloom_name_definitions'>Hydroloom Name Definitions</h2><span id='topic+hydroloom_name_definitions'></span>

<h3>Description</h3>

<p>A names character vector containing definitions of all
attributes used in the hydroloom package.
</p>


<h3>Value</h3>

<p>named character vector with <code>hydroloom_names</code> class to support custom print method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hydroloom_name_definitions
</code></pre>

<hr>
<h2 id='hydroloom_names'>Get or Set Hydroloom Names</h2><span id='topic+hydroloom_names'></span>

<h3>Description</h3>

<p>Retrieve hydroloom name mapping from hydroloom
environment. Hydroloom uses a specific set of attribute names within
the package and includes mappings from names used in some data sources.
This function will return those names and can be used to set additional
name mappings.
</p>
<p>NOTE: these values will reset when R is restarted. Add desired settings
to a project or user .Rprofile to make long term additions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hydroloom_names(x = NULL, clear = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hydroloom_names_+3A_x">x</code></td>
<td>
<p>named character vector of additional names to add to the
hydroloom environment. If not specified, no names will be added and
the current value stored in the hydroloom environment will be returned.</p>
</td></tr>
<tr><td><code id="hydroloom_names_+3A_clear">clear</code></td>
<td>
<p>logical if TRUE, all names will be removed and replaced with
x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named character vector containing hydroloom names with registered attribute name mappings in <code>names</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hydroloom_names()

</code></pre>

<hr>
<h2 id='index_points_to_lines'>Index Points to Lines</h2><span id='topic+index_points_to_lines'></span><span id='topic+index_points_to_lines.data.frame'></span><span id='topic+index_points_to_lines.hy'></span>

<h3>Description</h3>

<p>given an sf point geometry column, return id, aggregate_id
(e.g. reachcode), and aggregate id measure for each point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_points_to_lines(
  x,
  points,
  search_radius = NULL,
  precision = NA,
  max_matches = 1
)

## S3 method for class 'data.frame'
index_points_to_lines(
  x,
  points,
  search_radius = NULL,
  precision = NA,
  max_matches = 1
)

## S3 method for class 'hy'
index_points_to_lines(
  x,
  points,
  search_radius = NULL,
  precision = NA,
  max_matches = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_points_to_lines_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="index_points_to_lines_+3A_points">points</code></td>
<td>
<p>sf or sfc of type POINT in analysis projection. NOTE: x will
be projected to the projection of the points layer.</p>
</td></tr>
<tr><td><code id="index_points_to_lines_+3A_search_radius">search_radius</code></td>
<td>
<p>units distance for the nearest neighbor search
to extend in analysis projection. If missing or NULL, and points are in a lon
lat projection, a default of 0.01 degree is used, otherwise 200 m is used.
Conversion to the linear unit used by the provided crs of points is attempted.
See RANN nn2 documentation for more details.</p>
</td></tr>
<tr><td><code id="index_points_to_lines_+3A_precision">precision</code></td>
<td>
<p>numeric the resolution of measure precision in the output in meters.</p>
</td></tr>
<tr><td><code id="index_points_to_lines_+3A_max_matches">max_matches</code></td>
<td>
<p>numeric the maximum number of matches to return if multiple are
found in search_radius</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note 1: Inputs are cast into LINESTRINGS. Because of this, the measure output
of inputs that are true multipart lines may be in error.
</p>
<p>Note 2: This algorithm finds the nearest node in the input flowlines to
identify which flowline the point should belong to. As a second pass,
it can calculate the measure to greater precision than the nearest flowline
geometry node.
</p>
<p>Note 3: Offset is returned in units consistent with the projection of
the input points.
</p>
<p>Note 4: See <code>dfMaxLength</code> input to sf::st_segmentize() for details of
handling of precision parameter.
</p>
<p>Note 5: &quot;from&quot; is downstream &ndash; 0 is the outlet &quot;to&quot; is upstream &ndash; 100 is the inlet
</p>


<h3>Value</h3>

<p>data.frame with five columns, point_id, id, aggregate_id,
aggregate_id_measure, and offset. point_id is the row or list element in the
point input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if(require(nhdplusTools)) {
source(system.file("extdata", "sample_flines.R", package = "nhdplusTools"))

point &lt;- sf::st_sfc(sf::st_point(c(-76.87479, 39.48233)),
                    crs = 4326)

index_points_to_lines(sample_flines, point)

point &lt;- sf::st_transform(point, 5070)

index_points_to_lines(sample_flines, point,
                      search_radius = units::set_units(200, "m"))

index_points_to_lines(sample_flines, point, precision = 30)

index_points_to_lines(sample_flines,
                      sf::st_sfc(list(sf::st_point(c(-76.86934, 39.49328)),
                                      sf::st_point(c(-76.91711, 39.40884)),
                                      sf::st_point(c(-76.88081, 39.36354))),
                                 crs = 4326),
                      search_radius = units::set_units(0.2, "degrees"),
                      max_matches = 10)

 }
 

</code></pre>

<hr>
<h2 id='index_points_to_waterbodies'>Index Points to Waterbodies</h2><span id='topic+index_points_to_waterbodies'></span>

<h3>Description</h3>

<p>given an sf point geometry column, return waterbody id, and
COMID of dominant artificial path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_points_to_waterbodies(
  waterbodies,
  points,
  flines = NULL,
  search_radius = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_points_to_waterbodies_+3A_waterbodies">waterbodies</code></td>
<td>
<p>sf data.frame of type POLYGON or MULTIPOLYGON including
a &quot;wbid&quot; attribute.</p>
</td></tr>
<tr><td><code id="index_points_to_waterbodies_+3A_points">points</code></td>
<td>
<p>sfc of type POINT</p>
</td></tr>
<tr><td><code id="index_points_to_waterbodies_+3A_flines">flines</code></td>
<td>
<p>sf data.frame (optional) of type LINESTRING or MULTILINESTRING including
id, wbid, and topo_sort attributes. If omitted, only waterbody indexes are returned.</p>
</td></tr>
<tr><td><code id="index_points_to_waterbodies_+3A_search_radius">search_radius</code></td>
<td>
<p>units class with a numeric value indicating how far to
search for a waterbody boundary in units of provided projection. Set units with
<a href="units.html#topic+set_units">set_units</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns, <code>COMID</code>, <code>in_wb_COMID</code>, <code>near_wb_COMID</code>,
<code>near_wb_dist</code>, and <code>outlet_fline_COMID</code>.
Distance is in units of provided projection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
source(system.file("extdata/sample_data.R", package = "nhdplusTools"))

waterbodies &lt;- sf::st_transform(
  sf::read_sf(sample_data, "NHDWaterbody"), 5070)

points &lt;- sf::st_transform(
  sf::st_sfc(sf::st_point(c(-89.356086, 43.079943)),
             crs = 4326), 5070)

index_points_to_waterbodies(waterbodies, points,
                    search_radius = units::set_units(500, "m"))

</code></pre>

<hr>
<h2 id='is.hy'>Is Valid <code>hy</code> Class?</h2><span id='topic+is.hy'></span>

<h3>Description</h3>

<p>test if object is a valid according to the hy s3 class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.hy(x, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.hy_+3A_x">x</code></td>
<td>
<p>object to test</p>
</td></tr>
<tr><td><code id="is.hy_+3A_silent">silent</code></td>
<td>
<p>logical should messages be emitted?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical TRUE if valid
</p>

<hr>
<h2 id='make_attribute_topology'>Make Attribute Topology</h2><span id='topic+make_attribute_topology'></span><span id='topic+make_attribute_topology.data.frame'></span><span id='topic+make_attribute_topology.hy'></span>

<h3>Description</h3>

<p>given a set of lines with starting and ending nodes that
form a geometric network, construct an attribute topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_attribute_topology(x, min_distance)

## S3 method for class 'data.frame'
make_attribute_topology(x, min_distance)

## S3 method for class 'hy'
make_attribute_topology(x, min_distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_attribute_topology_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="make_attribute_topology_+3A_min_distance">min_distance</code></td>
<td>
<p>numeric distance in units compatible with the units of
the projection of <code>lines</code>. If no nodes are found within this distance, no
connection will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a <code>future</code> plan is set up, node distance calculations will be
applied using future workers.
</p>


<h3>Value</h3>

<p>data.frame with id and toid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

y &lt;- dplyr::select(x, COMID)

y &lt;- sf::st_transform(y, 5070)

z &lt;- make_attribute_topology(y, 10)

x &lt;- add_toids(hy(x), return_dendritic = FALSE)

x[x$id == x$id[1],]$toid
z[z$COMID == x$id[1],]$toid

</code></pre>

<hr>
<h2 id='make_fromids'>Convert &quot;to&quot; index ids to &quot;from&quot; index ids</h2><span id='topic+make_fromids'></span>

<h3>Description</h3>

<p>given a set of index ids as retrieved from <a href="#topic+make_index_ids">make_index_ids</a>
return an adjacency matrix with pointers to identifiers that flow to the
row of the matrix in question.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_fromids(index_ids, return_list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_fromids_+3A_index_ids">index_ids</code></td>
<td>
<p>data.frame as returned by <a href="#topic+make_index_ids">make_index_ids</a></p>
</td></tr>
<tr><td><code id="make_fromids_+3A_return_list">return_list</code></td>
<td>
<p>logical if TRUE, the returned list will include a
&quot;froms_list&quot; element containing all from ids in a list form.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing a &quot;froms&quot; matrix, &quot;lengths&quot; vector,
and optionally &quot;froms_list&quot; elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(id = c(1, 2, 3, 4, 5, 6, 7, 8, 9),
              toid = c(2, 3, 4, 5, 0, 7, 8, 9, 4))

y &lt;- make_index_ids(x)

make_fromids(y)

</code></pre>

<hr>
<h2 id='make_index_ids'>Make Index ids</h2><span id='topic+make_index_ids'></span><span id='topic+make_index_ids.data.frame'></span><span id='topic+make_index_ids.hy'></span>

<h3>Description</h3>

<p>makes index ids for the provided hy object. These can be used
for graph traversal algorithms such that the row number and id are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_index_ids(x, long_form = FALSE)

## S3 method for class 'data.frame'
make_index_ids(x, long_form = FALSE)

## S3 method for class 'hy'
make_index_ids(x, long_form = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_index_ids_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="make_index_ids_+3A_long_form">long_form</code></td>
<td>
<p>logical if TRUE, return will be a long-form version of the
<code>to_list</code>. This form can be converted to the default list format with
<a href="#topic+format_index_ids">format_index_ids</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing named elements: <code>to</code>: adjacency matrix <code>lengths</code>:
vector indicating the number of connections from each node, and: <code>to_list</code>:
a data.frame with an <code>id</code>, <code>indid</code> and a <code>toindid</code> list column. If long_form
= TRUE, return will be a long form data.frame with no list column as in <code>to_list</code>.
NOTE: the long_form output should be used with caution as indid may not
correspond to row number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(id = c(1, 2, 3, 4, 5, 6, 7, 8, 9),
              toid = c(2, 3, 4, 5, 0, 7, 8, 9, 4))

make_index_ids(x)

x &lt;- hy(sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom")))

x &lt;- add_toids(x, return_dendritic = FALSE)

x &lt;- make_index_ids(x)

names(x)
class(x$to)
class(x$lengths)
class(x$to_list)
is.list(x$to_list$toindid)

</code></pre>

<hr>
<h2 id='make_node_topology'>Make Node Topology from Edge Topology</h2><span id='topic+make_node_topology'></span><span id='topic+make_node_topology.data.frame'></span><span id='topic+make_node_topology.hy'></span>

<h3>Description</h3>

<p>creates a node topology table from an edge topology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_node_topology(x, add_div = NULL, add = TRUE)

## S3 method for class 'data.frame'
make_node_topology(x, add_div = NULL, add = TRUE)

## S3 method for class 'hy'
make_node_topology(x, add_div = NULL, add = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_node_topology_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="make_node_topology_+3A_add_div">add_div</code></td>
<td>
<p>data.frame of logical containing id and toid diverted paths to add.
Should have id and toid fields. If TRUE, the network will be interpreted as
a directed acyclic graph with downstream divergences included in the edge
topology.</p>
</td></tr>
<tr><td><code id="make_node_topology_+3A_add">add</code></td>
<td>
<p>logical if TRUE, node topology will be added to x in return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing id, fromnode, and tonode attributes or all
attributes provided with id, fromnode and tonode in the first three columns.
</p>
<p>If <code>add_div</code> is TRUE, will also add a <code>divergence</code> attribute where the
provided diverted paths are assigned value 2, existing main paths that
emanate from a divergence are assigned value 1, and all other paths
are assigned value 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

y &lt;- dplyr::select(add_toids(x), -ToNode, -FromNode)

y &lt;- make_node_topology(y)

# just the divergences which have unique fromids in x but don't in new hope.
div &lt;- add_toids(dplyr::select(x, COMID, FromNode, ToNode),
                 return_dendritic = FALSE)
div &lt;- div[div$toid %in%
           x$COMID[x$Divergence == 2],]

y &lt;- dplyr::select(add_toids(x), -ToNode, -FromNode)

y &lt;- make_node_topology(y, add_div = div)

</code></pre>

<hr>
<h2 id='navigate_connected_paths'>Navigate Connected Paths</h2><span id='topic+navigate_connected_paths'></span>

<h3>Description</h3>

<p>Given a network and set of ids, finds paths or lengths between all
identified flowpath outlets. This algorithm finds paths between outlets
regardless of flow direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>navigate_connected_paths(x, outlets, status = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="navigate_connected_paths_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="navigate_connected_paths_+3A_outlets">outlets</code></td>
<td>
<p>vector of ids from data.frame</p>
</td></tr>
<tr><td><code id="navigate_connected_paths_+3A_status">status</code></td>
<td>
<p>logical print status and progress bars?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing the distance between pairs of network outlets
and a list column containing flowpath identifiers along path that connect outlets.
For a network with one terminal outlet, the data.frame will have <code>nrow(x)^2</code> rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sf::read_sf(system.file("extdata", "walker.gpkg", package = "hydroloom"))

outlets &lt;- c(5329303, 5329357, 5329317, 5329365, 5329435, 5329817)

x &lt;- add_toids(hy(x))

navigate_connected_paths(x, outlets)

</code></pre>

<hr>
<h2 id='navigate_hydro_network'>Navigate Hydro Network</h2><span id='topic+navigate_hydro_network'></span><span id='topic+navigate_hydro_network.data.frame'></span><span id='topic+navigate_hydro_network.hy'></span>

<h3>Description</h3>

<p>Navigates a network of connected catchments using NHDPlus style
network attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>navigate_hydro_network(x, start, mode, distance = NULL)

## S3 method for class 'data.frame'
navigate_hydro_network(x, start, mode, distance = NULL)

## S3 method for class 'hy'
navigate_hydro_network(x, start, mode, distance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="navigate_hydro_network_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="navigate_hydro_network_+3A_start">start</code></td>
<td>
<p>character or numeric to match identifier attribute. The
starting catchment is included.</p>
</td></tr>
<tr><td><code id="navigate_hydro_network_+3A_mode">mode</code></td>
<td>
<p>character chosen from c(UM, DM, UT, or DD).
</p>

<ol>
<li><p> UM: upstream mainstem
</p>
</li>
<li><p> DM: downstream main
</p>
</li>
<li><p> UT: upstream with tributaries
</p>
</li>
<li><p> DD: downstream with diversions
</p>
</li></ol>
</td></tr>
<tr><td><code id="navigate_hydro_network_+3A_distance">distance</code></td>
<td>
<p>numeric distance in km to limit navigation. The first
catchment that exceeds the provided distance is included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if only <code>mode</code> is supplied, require network attributes are displayed.
</p>


<h3>Value</h3>

<p>vector of identifiers found along navigation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot_fun &lt;- function(x, s, n) {
   plot(sf::st_geometry(x), col = "grey")
   plot(sf::st_geometry(x[x$id %in% n, ]), add = TRUE)
   plot(sf::st_geometry(x[x$id %in% s, ]), col = "red", lwd = 3, add = TRUE)
}

x &lt;- hy(sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom")))

start &lt;- 8891126
dm &lt;- navigate_hydro_network(x, start, "DM")

plot_fun(x, start, dm)

dd &lt;- navigate_hydro_network(x, start, "DD")

plot_fun(x, start, dd)

start &lt;- 8894356

um &lt;- navigate_hydro_network(x, start, "UM")

plot_fun(x, start, um)

ut &lt;- navigate_hydro_network(x, start, "UT")

plot_fun(x, start, ut)

</code></pre>

<hr>
<h2 id='navigate_network_dfs'>Navigate all Paths Depth First</h2><span id='topic+navigate_network_dfs'></span>

<h3>Description</h3>

<p>given a starting node, return all reachable paths. Once visited,
a node is marked as visited and will not take part in a future path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>navigate_network_dfs(x, starts, direction = "down", reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="navigate_network_dfs_+3A_x">x</code></td>
<td>
<p>data.frame containing hydroloom compatible network or list
as returned by <a href="#topic+make_index_ids">make_index_ids</a> (for down) or <a href="#topic+make_fromids">make_fromids</a>
(for up). The list formats avoids recreating the index ids for every call
to navigate network dfs in the case that it needs to be called many times.</p>
</td></tr>
<tr><td><code id="navigate_network_dfs_+3A_starts">starts</code></td>
<td>
<p>vector with ids from x to start at.</p>
</td></tr>
<tr><td><code id="navigate_network_dfs_+3A_direction">direction</code></td>
<td>
<p>character &quot;up or &quot;down&quot;</p>
</td></tr>
<tr><td><code id="navigate_network_dfs_+3A_reset">reset</code></td>
<td>
<p>logical if TRUE, reset graph for each start such that later paths
will have overlapping results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing dfs result for each start.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- hy(sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom")))

x &lt;- add_toids(x, return_dendritic = FALSE)

navigate_network_dfs(x, 8893402)

navigate_network_dfs(x, 8897784, direction = "up")

</code></pre>

<hr>
<h2 id='rename_geometry'>Rename Geometry</h2><span id='topic+rename_geometry'></span>

<h3>Description</h3>

<p>correctly renames the geometry column
of a sf object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_geometry(g, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_geometry_+3A_g">g</code></td>
<td>
<p>sf data.table</p>
</td></tr>
<tr><td><code id="rename_geometry_+3A_name">name</code></td>
<td>
<p>character name to be used for geometry</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf data.frame with geometry column renamed according to name parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(g &lt;- sf::st_sf(a=3, geo = sf::st_sfc(sf::st_point(1:2))))
rename_geometry(g, "geometry")

</code></pre>

<hr>
<h2 id='rescale_measures'>Rescale Aggregate id Measure to id Measure</h2><span id='topic+rescale_measures'></span>

<h3>Description</h3>

<p>Given a aggregate id (e.g. reachcode) measure and the from and
to measure for a id (e.g. comid flowline), returns the measure along the
id line. This is a utility specific to the NHDPlus data model where
many comid flowlines make up a single reachcode / reach. &quot;Measures&quot;
are typically referenced to reaches. Flowlines have a stated from-measure /
to-measure. In some cases it is useful to rescale the measure such that it
is relative only to the flowline.
</p>
<p>from is downstream &ndash; 0 is the outlet
to is upstream &ndash; 100 is the inlet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_measures(measure, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_measures_+3A_measure">measure</code></td>
<td>
<p>numeric aggregate measure between 0 and 100</p>
</td></tr>
<tr><td><code id="rescale_measures_+3A_from">from</code></td>
<td>
<p>numeric from-measure relative to the aggregate</p>
</td></tr>
<tr><td><code id="rescale_measures_+3A_to">to</code></td>
<td>
<p>numeric to-measure relative to the aggregate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric rescaled measure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rescale_measures(40, 0, 50)
rescale_measures(60, 50, 100)

</code></pre>

<hr>
<h2 id='sort_network'>Sort Network</h2><span id='topic+sort_network'></span><span id='topic+sort_network.data.frame'></span><span id='topic+sort_network.hy'></span>

<h3>Description</h3>

<p>given a network with an id and and toid, returns a sorted
and potentially split set of output.
</p>
<p>Can also be used as a very fast implementation of upstream
with tributaries navigation. The full network from each
outlet is returned in sorted order.
</p>
<p>If a network includes diversions, all flowlines downstream of
the diversion are visited prior to continuing upstream. See
note on the <code>outlets</code> parameter for implications of this
implementation detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_network(x, split = FALSE, outlets = NULL)

## S3 method for class 'data.frame'
sort_network(x, split = FALSE, outlets = NULL)

## S3 method for class 'hy'
sort_network(x, split = FALSE, outlets = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_network_+3A_x">x</code></td>
<td>
<p>data.frame network compatible with <a href="#topic+hydroloom_names">hydroloom_names</a>.</p>
</td></tr>
<tr><td><code id="sort_network_+3A_split">split</code></td>
<td>
<p>logical if TRUE, the result will be split into
independent networks identified by the id of their outlet. The
outlet id of each independent network is added as a &quot;terminalid&quot;
attribute.</p>
</td></tr>
<tr><td><code id="sort_network_+3A_outlets">outlets</code></td>
<td>
<p>same as id in x. if specified, only the network
emanating from these outlets will be considered and returned.
NOTE: If outlets does not include all outlets from a given
network containing diversions, a partial network may be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing a topologically sorted version
of the requested network and optionally a terminal id.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

g &lt;- add_toids(x)

head(g &lt;- sort_network(g))

g$topo_sort &lt;- nrow(g):1

plot(g['topo_sort'])

g &lt;- add_toids(x, return_dendritic = FALSE)

g &lt;- sort_network(g)

g$topo_sort &lt;- nrow(g):1

plot(g['topo_sort'])

</code></pre>

<hr>
<h2 id='st_compatibalize'>Make Spatial Inputs Compatible</h2><span id='topic+st_compatibalize'></span>

<h3>Description</h3>

<p>makes sf1 compatible with sf2 by projecting into
the projection of 2 and ensuring that the geometry columns are the
same name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_compatibalize(sf1, sf2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_compatibalize_+3A_sf1">sf1</code></td>
<td>
<p>sf data.frame</p>
</td></tr>
<tr><td><code id="st_compatibalize_+3A_sf2">sf2</code></td>
<td>
<p>sf data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf1 transformed and renamed to be compatible with sf2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

one &lt;- dplyr::select(x)
two &lt;- sf::st_transform(one, 5070)

attr(one, "sf_column") &lt;- "geotest"
names(one)[names(one) == "geom"] &lt;- "geotest"

st_compatibalize(one, two)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
