<!DOCTYPE html><html><head><title>Help for package scpi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scpi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#scpi-package'><p><code>scpi</code>: A Package to Compute Synthetic Control Prediction Intervals With Multiple Treated Units and Staggered Adoption</p></a></li>
<li><a href='#coef.scest'><p>Coef Method for Synthetic Control Methods</p></a></li>
<li><a href='#coef.scpi'><p>Coef Method for Synthetic Control Methods</p></a></li>
<li><a href='#print.scdata'><p>Summary Method for Synthetic Control</p></a></li>
<li><a href='#print.scdataMulti'><p>Summary Method for Synthetic Control</p></a></li>
<li><a href='#print.scest'><p>Print Method for Synthetic Control Methods</p></a></li>
<li><a href='#print.scpi'><p>Print Method for Synthetic Control Inference</p></a></li>
<li><a href='#scdata'><p>Data Preparation for <code>scest</code> or <code>scpi</code> for Point Estimation and Inference Procedures Using Synthetic Control Methods.</p></a></li>
<li><a href='#scdataMulti'><p>Data Preparation for <code>scest</code> or <code>scpi</code> for Point Estimation and Inference Procedures Using Synthetic Control Methods.</p></a></li>
<li><a href='#scest'><p>Prediction of Synthetic Control</p></a></li>
<li><a href='#scpi'><p>Prediction Intervals for Synthetic Control Methods</p></a></li>
<li><a href='#scpi_germany'><p>Replication Dataset for Estimating the Economic Impact of German Reunification</p></a></li>
<li><a href='#scplot'><p>Plot Synthetic Control Point Estimates and Prediction Interval</p></a></li>
<li><a href='#scplotMulti'><p>Plot Synthetic Control Point Estimates and Prediction Interval With Multiple Treated units and Staggered Adoption</p></a></li>
<li><a href='#summary.scdata'><p>Summary Method for Synthetic Control Prediction</p></a></li>
<li><a href='#summary.scdataMulti'><p>Summary Method for Synthetic Control Prediction</p></a></li>
<li><a href='#summary.scest'><p>Summary Method for Synthetic Control Prediction</p></a></li>
<li><a href='#summary.scpi'><p>Summary Method for Synthetic Control Inference</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Prediction Intervals for Synthetic Control Methods with Multiple
Treated Units and Staggered Adoption</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.5</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nppackages.github.io/scpi/">https://nppackages.github.io/scpi/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of prediction and inference procedures for Synthetic Control methods using least square, lasso, ridge, or simplex-type constraints. Uncertainty is quantified with prediction intervals as developed in Cattaneo, Feng, and Titiunik (2021) <a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf</a> for a single treated unit and in Cattaneo, Feng, Palomba, and Titiunik (2023) &lt;<a href="https://doi.org/10.48550/arXiv.2210.05026">doi:10.48550/arXiv.2210.05026</a>&gt; for multiple treated units and staggered adoption. More details about the software implementation can be found in Cattaneo, Feng, Palomba, and Titiunik (2022) &lt;<a href="https://doi.org/10.48550/arXiv.2202.05984">doi:10.48550/arXiv.2202.05984</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind (&ge; 1.4.5), CVXR (&ge; 1.0-10), doSNOW (&ge; 1.0.19), dplyr
(&ge; 1.0.7), ECOSolveR (&ge; 0.5.4), fastDummies (&ge; 1.6.3),
foreach (&ge; 1.5.1), ggplot2 (&ge; 3.3.3), magrittr (&ge; 2.0.1),
MASS (&ge; 7.3), Matrix (&ge; 1.3.3), methods (&ge; 4.1.0), parallel
(&ge; 4.1.0), purrr (&ge; 0.3.4), Qtools (&ge; 1.5.6), reshape2 (&ge;
1.4.4), rlang (&ge; 0.4.11), stats (&ge; 4.1.0), stringr (&ge;
1.4.0), tibble (&ge; 3.1.2), tidyr (&ge; 1.1.3), utils (&ge; 4.1.1)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-01 01:20:38 UTC; fpalomba</td>
</tr>
<tr>
<td>Author:</td>
<td>Matias Cattaneo [aut],
  Yingjie Feng [aut],
  Filippo Palomba [aut, cre],
  Rocio Titiunik [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Filippo Palomba &lt;fpalomba@princeton.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-01 06:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='scpi-package'><code>scpi</code>: A Package to Compute Synthetic Control Prediction Intervals With Multiple Treated Units and Staggered Adoption</h2><span id='topic+scpi-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>The package implements estimation, inference procedures, and produces plots for Synthetic Control (SC) methods
using least squares, lasso, ridge, or simplex-type
constraints. Uncertainty is quantified using prediction intervals according to
<a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, Feng, and Titiunik (2021)</a>.
</p>
<p>Included functions are: <a href="#topic+scdata">scdata</a> and <a href="#topic+scdataMulti">scdataMulti</a> for data preparation, <a href="#topic+scest">scest</a> for point estimation,
<a href="#topic+scpi">scpi</a> for inference procedures, and <a href="#topic+scplot">scplot</a> and <a href="#topic+scplotMulti">scplotMulti</a> for plots.
</p>
<p><code>print()</code> and <code>summary()</code> methods are available for <code><a href="#topic+scest">scest</a></code> and <code><a href="#topic+scpi">scpi</a></code>.
</p>
<p>Companion <a href="https://www.stata.com/">Stata</a> and <a href="https://www.python.org/">Python</a> packages are described in
<a href="https://arxiv.org/abs/2202.05984">Cattaneo, Feng, Palomba, and Titiunik (2022)</a>.
</p>
<p>Related Stata, R, and Python packages useful for inference in SC designs are described in the following website:
</p>
<p><a href="https://nppackages.github.io/scpi/"> https://nppackages.github.io/scpi/</a>
</p>
<p>For an introduction to synthetic control methods, see <a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie (2021)</a> and references therein.
</p>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie, A. (2021)</a>. Using synthetic controls: Feasibility, data requirements, and methodological aspects.
<em>Journal of Economic Literature</em>, 59(2), 391-425.
</p>
</li>
<li><p><a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, M. D., Feng, Y., and Titiunik, R.
(2021)</a>. Prediction intervals for synthetic control methods. <em>Journal of the American Statistical Association</em>, 116(536), 1865-1880.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2202.05984">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
scpi: Uncertainty Quantification for Synthetic Control Methods, <em>arXiv</em>:2202.05984.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2210.05026">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
Uncertainty Quantification in Synthetic Controls with Staggered Treatment Adoption, <em>arXiv</em>:2210.05026.
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://nppackages.github.io/scpi/">https://nppackages.github.io/scpi/</a>
</p>
</li></ul>


<hr>
<h2 id='coef.scest'>Coef Method for Synthetic Control Methods</h2><span id='topic+coef.scest'></span>

<h3>Description</h3>

<p>The coef method for synthetic control prediction fitted objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scest'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.scest_+3A_object">object</code></td>
<td>
<p>Class &quot;scest&quot; object, obtained by calling <code><a href="#topic+scest">scest</a></code>.</p>
</td></tr>
<tr><td><code id="coef.scest_+3A_...">...</code></td>
<td>
<p>Other arguments (eg. <code>ncols</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to show <code><a href="#topic+scest">scest</a></code> constructed weights.
</p>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scest">scest</a></code> for synthetic control prediction.
</p>
<p>Supported methods: <code><a href="#topic+print.scest">print.scest</a></code>, <code><a href="#topic+summary.scest">summary.scest</a></code>, <code><a href="#topic+coef.scest">coef.scest</a></code>.
</p>

<hr>
<h2 id='coef.scpi'>Coef Method for Synthetic Control Methods</h2><span id='topic+coef.scpi'></span>

<h3>Description</h3>

<p>The coef method for synthetic control prediction fitted objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scpi'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.scpi_+3A_object">object</code></td>
<td>
<p>Class &quot;scpi&quot; object, obtained by calling <code><a href="#topic+scpi">scpi</a></code>.</p>
</td></tr>
<tr><td><code id="coef.scpi_+3A_...">...</code></td>
<td>
<p>Other arguments (eg. <code>ncols</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to show <code><a href="#topic+scpi">scpi</a></code> constructed weights.
</p>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scpi">scpi</a></code> for synthetic control prediction.
</p>
<p>Supported methods: <code><a href="#topic+print.scpi">print.scpi</a></code>, <code><a href="#topic+summary.scpi">summary.scpi</a></code>, <code><a href="#topic+coef.scpi">coef.scpi</a></code>.
</p>

<hr>
<h2 id='print.scdata'>Summary Method for Synthetic Control</h2><span id='topic+print.scdata'></span>

<h3>Description</h3>

<p>The print method for synthetic control data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdata'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.scdata_+3A_x">x</code></td>
<td>
<p>Class &quot;scdata&quot; object, obtained by calling <code><a href="#topic+scdata">scdata</a></code>.</p>
</td></tr>
<tr><td><code id="print.scdata_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print <code><a href="#topic+scdata">scdata</a></code> results.
</p>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scdata">scdata</a></code> for synthetic control data preparation.
</p>
<p>Supported methods: <code><a href="#topic+print.scdata">print.scdata</a></code>, <code><a href="#topic+summary.scdata">summary.scdata</a></code>.
</p>

<hr>
<h2 id='print.scdataMulti'>Summary Method for Synthetic Control</h2><span id='topic+print.scdataMulti'></span>

<h3>Description</h3>

<p>The print method for synthetic control data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdataMulti'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.scdataMulti_+3A_x">x</code></td>
<td>
<p>Class &quot;scdataMulti&quot; object, obtained by calling  <code><a href="#topic+scdataMulti">scdataMulti</a></code>.</p>
</td></tr>
<tr><td><code id="print.scdataMulti_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print <code><a href="#topic+scdataMulti">scdataMulti</a></code> results.
</p>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scdataMulti">scdataMulti</a></code> for synthetic control data preparation.
</p>
<p>Supported methods: <code><a href="#topic+print.scdataMulti">print.scdataMulti</a></code>, <code><a href="#topic+summary.scdataMulti">summary.scdataMulti</a></code>.
</p>

<hr>
<h2 id='print.scest'>Print Method for Synthetic Control Methods</h2><span id='topic+print.scest'></span>

<h3>Description</h3>

<p>The print method for synthetic control prediction fitted objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.scest_+3A_x">x</code></td>
<td>
<p>Class &quot;scest&quot; object, obtained by calling <code><a href="#topic+scest">scest</a></code>.</p>
</td></tr>
<tr><td><code id="print.scest_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print <code><a href="#topic+scest">scest</a></code> results.
</p>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scest">scest</a></code> for synthetic control prediction.
</p>
<p>Supported methods: <code><a href="#topic+print.scest">print.scest</a></code>, <code><a href="#topic+summary.scest">summary.scest</a></code>, <code><a href="#topic+coef.scest">coef.scest</a></code>.
</p>

<hr>
<h2 id='print.scpi'>Print Method for Synthetic Control Inference</h2><span id='topic+print.scpi'></span>

<h3>Description</h3>

<p>The print method for synthetic control inference objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scpi'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.scpi_+3A_x">x</code></td>
<td>
<p>Class &quot;scpi&quot; object, obtained by calling <code><a href="#topic+scpi">scpi</a></code>.</p>
</td></tr>
<tr><td><code id="print.scpi_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print <code><a href="#topic+scpi">scpi</a></code> results.
</p>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scpi">scpi</a></code> for synthetic control inference
</p>
<p>Supported methods: <code><a href="#topic+print.scpi">print.scpi</a></code>, <code><a href="#topic+summary.scpi">summary.scpi</a></code>.
</p>

<hr>
<h2 id='scdata'>Data Preparation for <code>scest</code> or <code>scpi</code> for Point Estimation and Inference Procedures Using Synthetic Control Methods.</h2><span id='topic+scdata'></span>

<h3>Description</h3>

<p>The command prepares the data to be used by <code><a href="#topic+scest">scest</a></code> or <code><a href="#topic+scpi">scpi</a></code> to implement estimation and
inference procedures for Synthetic Control (SC) methods.
It allows the user to specify the outcome variable, the features of the treated unit to be
matched, and covariate-adjustment feature by feature. The names of the output matrices
follow the terminology proposed in <a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, Feng, and Titiunik (2021)</a>.
</p>
<p>Companion <a href="https://www.stata.com/">Stata</a> and <a href="https://www.python.org/">Python</a> packages are described in
<a href="https://arxiv.org/abs/2202.05984">Cattaneo, Feng, Palomba, and Titiunik (2022)</a>.
</p>
<p>Companion commands are: <a href="#topic+scdataMulti">scdataMulti</a> for data preparation in the multiple treated units case with staggered adoption,
<a href="#topic+scest">scest</a> for point estimation, <a href="#topic+scpi">scpi</a> for inference procedures, <a href="#topic+scplot">scplot</a> and <a href="#topic+scplotMulti">scplotMulti</a> for plots in
the single and multiple treated unit(s) cases, respectively.
</p>
<p>Related Stata, R, and Python packages useful for inference in SC designs are described in the following website:
</p>
<p><a href="https://nppackages.github.io/scpi/"> https://nppackages.github.io/scpi/</a>
</p>
<p>For an introduction to synthetic control methods, see <a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie (2021)</a> and references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scdata(
  df,
  id.var,
  time.var,
  outcome.var,
  period.pre,
  period.post,
  unit.tr,
  unit.co,
  features = NULL,
  cov.adj = NULL,
  cointegrated.data = FALSE,
  anticipation = 0,
  constant = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scdata_+3A_df">df</code></td>
<td>
<p>a dataframe object.</p>
</td></tr>
<tr><td><code id="scdata_+3A_id.var">id.var</code></td>
<td>
<p>a character or numeric scalar with the name of the variable containing units' IDs. The ID variable can be numeric or character.</p>
</td></tr>
<tr><td><code id="scdata_+3A_time.var">time.var</code></td>
<td>
<p>a character with the name of the time variable. The time variable has to be numeric, integer, or Date. In
case <code>time.var</code> is Date it should be the output of <code><a href="base.html#topic+as.Date">as.Date</a>()</code> function. An integer or
numeric time variable is suggested when working with yearly data, whereas for all other formats a Date type
time variable is preferred.</p>
</td></tr>
<tr><td><code id="scdata_+3A_outcome.var">outcome.var</code></td>
<td>
<p>a character with the name of the outcome variable. The outcome variable has to be numeric.</p>
</td></tr>
<tr><td><code id="scdata_+3A_period.pre">period.pre</code></td>
<td>
<p>a numeric vector that identifies the pre-treatment period in time.var.</p>
</td></tr>
<tr><td><code id="scdata_+3A_period.post">period.post</code></td>
<td>
<p>a numeric vector that identifies the post-treatment period in time.var.</p>
</td></tr>
<tr><td><code id="scdata_+3A_unit.tr">unit.tr</code></td>
<td>
<p>a character or numeric scalar that identifies the treated unit in <code>id.var</code>.</p>
</td></tr>
<tr><td><code id="scdata_+3A_unit.co">unit.co</code></td>
<td>
<p>a character or numeric vector that identifies the donor pool in <code>id.var</code>.</p>
</td></tr>
<tr><td><code id="scdata_+3A_features">features</code></td>
<td>
<p>a character vector containing the name of the feature variables used for estimation.
If this option is not specified the default is <code>features = outcome.var</code>.</p>
</td></tr>
<tr><td><code id="scdata_+3A_cov.adj">cov.adj</code></td>
<td>
<p>a list specifying the names of the covariates to be used for adjustment for each feature. If <code>outcome.var</code> is
not in the variables specified in <code>features</code>, we force <code>cov.adj&lt;-NULL</code>. See the <strong>Details</strong> section for more.</p>
</td></tr>
<tr><td><code id="scdata_+3A_cointegrated.data">cointegrated.data</code></td>
<td>
<p>a logical that indicates if there is a belief that the data is cointegrated or not.
The default value is <code>FALSE</code>.  See the <strong>Details</strong> section for more.</p>
</td></tr>
<tr><td><code id="scdata_+3A_anticipation">anticipation</code></td>
<td>
<p>a scalar that indicates the number of periods of potential anticipation effects. Default is 0.</p>
</td></tr>
<tr><td><code id="scdata_+3A_constant">constant</code></td>
<td>
<p>a logical which controls the inclusion of a constant term across features. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scdata_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> prints additional information in the console.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><code>cov.adj</code> can be used in two ways. First, if only one feature is specified through the option <code>features</code>,
<code>cov.adj</code> has to be a list with one (even unnamed) element (eg. <code>cov.adj = list(c("constant","trend"))</code>).
Alternatively, if multiple features are specified, then the user has two possibilities:
</p>

<ul>
<li><p>provide a list with one element, then the same covariates are used for
adjustment for each feature. For example, if there are two features specified and the user inputs
<code>cov.adj = list(c("constant","trend"))</code>, then a constant term and a linear trend are for adjustment for both features.
</p>
</li>
<li><p>provide a list with as many elements as the number of features specified, then
feature-specific covariate adjustment is implemented. For example,
<code>cov.adj = list('f1' = c("constant","trend"), 'f2' = c("trend"))</code>. In this case the name of each element
of the list should be one (and only one) of the features specified. Note that if two (or more) features are
specified and covariates adjustment has to be specified just for one of them, the user must still provide a list
of the same length of the number of features, e.g., <code>cov.adj = list('f1' = c("constant","trend"), 'f2' = NULL</code>.
</p>
</li></ul>

<p>This option allows the user to include feature-specific constant terms
or time trends by simply including &quot;constant&quot; or &quot;trend&quot; in the corresponding
element of the list.
</p>
<p>When <code>outcome.var</code> is not included in <code>features</code>, we automatically set <code class="reqn">\mathcal{R}=\emptyset</code>, that is
we do not perform covariate adjustment. This is because, in this setting it is natural to create the out-of-sample
prediction matrix <code class="reqn">\mathbf{P}</code> using the post-treatment outcomes of the donor units only.

</p>
</li>
<li><p><code>cointegrated.data</code> allows the user to model the belief that <code class="reqn">\mathbf{A}</code> and <code class="reqn">\mathbf{B}</code> form a
cointegrated system. In practice, this implies that when dealing with the pseudo-true
residuals <code class="reqn">\mathbf{u}</code>, the first-difference of <code class="reqn">\mathbf{B}</code> are used rather than the levels.
</p>
</li></ul>



<h3>Value</h3>

<p>The command returns an object of class 'scdata' containing the following
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>a matrix containing pre-treatment features of the treated unit.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>a matrix containing pre-treatment features of the control units.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>a matrix containing covariates for adjustment.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>a matrix whose rows are the vectors used to predict the out-of-sample series for the synthetic unit.</p>
</td></tr>
<tr><td><code>Y.pre</code></td>
<td>
<p>a matrix containing the pre-treatment outcome of the treated unit.</p>
</td></tr>
<tr><td><code>Y.post</code></td>
<td>
<p>a matrix containing the post-treatment outcome of the treated unit.</p>
</td></tr>
<tr><td><code>Y.donors</code></td>
<td>
<p>a matrix containing the pre-treatment outcome of the control units.</p>
</td></tr>
<tr><td><code>specs</code></td>
<td>
<p>a list containing some specifics of the data:
</p>

<ul>
<li><p><code>J</code>, the number of control units
</p>
</li>
<li><p><code>K</code>, a numeric vector with the number of covariates used for adjustment for each feature
</p>
</li>
<li><p><code>KM</code>, the total number of covariates used for adjustment
</p>
</li>
<li><p><code>M</code>, number of features
</p>
</li>
<li><p><code>period.pre</code>, a numeric vector with the pre-treatment period
</p>
</li>
<li><p><code>period.post</code>, a numeric vector with the post-treatment period
</p>
</li>
<li><p><code>T0.features</code>, a numeric vector with the number of periods used in estimation for each feature
</p>
</li>
<li><p><code>T1.outcome</code>, the number of post-treatment periods
</p>
</li>
<li><p><code>outcome.var</code>, a character with the name of the outcome variable
</p>
</li>
<li><p><code>features</code>, a character vector with the name of the features
</p>
</li>
<li><p><code>constant</code>, for internal use only
</p>
</li>
<li><p><code>out.in.features</code>, for internal use only
</p>
</li>
<li><p><code>effect</code>, for internal use only
</p>
</li>
<li><p><code>sparse.matrices</code>, for internal use only
</p>
</li>
<li><p><code>treated.units</code>, list containing the IDs of all treated units</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie, A. (2021)</a>.
Using synthetic controls: Feasibility, data requirements, and methodological aspects.
<em>Journal of Economic Literature</em>, 59(2), 391-425.
</p>
</li>
<li><p><a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, M. D., Feng, Y., and Titiunik, R.
(2021)</a>. Prediction intervals for synthetic control methods. <em>Journal of the American Statistical Association</em>, 116(536), 1865-1880.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2202.05984">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
scpi: Uncertainty Quantification for Synthetic Control Methods, <em>arXiv</em>:2202.05984.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2210.05026">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
Uncertainty Quantification in Synthetic Controls with Staggered Treatment Adoption, <em>arXiv</em>:2210.05026.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+scdataMulti">scdataMulti</a></code>, <code><a href="#topic+scest">scest</a></code>, <code><a href="#topic+scpi">scpi</a></code>, <code><a href="#topic+scplot">scplot</a></code>, <code><a href="#topic+scplotMulti">scplotMulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- scpi_germany

df &lt;- scdata(df = data, id.var = "country", time.var = "year",
             outcome.var = "gdp", period.pre = (1960:1990),
             period.post = (1991:2003), unit.tr = "West Germany",
             unit.co = setdiff(unique(data$country), "West Germany"),
             constant = TRUE, cointegrated.data = TRUE)

</code></pre>

<hr>
<h2 id='scdataMulti'>Data Preparation for <code>scest</code> or <code>scpi</code> for Point Estimation and Inference Procedures Using Synthetic Control Methods.</h2><span id='topic+scdataMulti'></span>

<h3>Description</h3>

<p>The command prepares the data to be used by <code><a href="#topic+scest">scest</a></code> or <code><a href="#topic+scpi">scpi</a></code> to implement estimation
and inference procedures for Synthetic Control (SC) methods
in the general case of multiple treated units and staggered adoption. It is a generalization of <code><a href="#topic+scdata">scdata</a></code>, since this latter prepares
the data in the particular case of a single treated unit.
</p>
<p>The names of the output matrices follow the terminology proposed in
<a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, Feng, Palomba and Titiunik (2022)</a>.
</p>
<p>Companion <a href="https://www.stata.com/">Stata</a> and <a href="https://www.python.org/">Python</a> packages are
described in <a href="https://arxiv.org/abs/2202.05984">Cattaneo, Feng, Palomba, and Titiunik (2022)</a>.
</p>
<p>Companion commands are: <a href="#topic+scdata">scdata</a> for data preparation in the single treated unit case, <a href="#topic+scest">scest</a> for point estimation,
<a href="#topic+scpi">scpi</a> for inference procedures,
<a href="#topic+scplot">scplot</a> and <a href="#topic+scplotMulti">scplotMulti</a> for plots in the single and multiple treated unit(s) cases, respectively.
</p>
<p>Related Stata, R, and Python packages useful for inference in SC designs are described in the following website:
</p>
<p><a href="https://nppackages.github.io/scpi/"> https://nppackages.github.io/scpi/</a>
</p>
<p>For an introduction to synthetic control methods, see <a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie (2021)</a> and references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scdataMulti(
  df,
  id.var,
  time.var,
  outcome.var,
  treatment.var,
  features = NULL,
  cov.adj = NULL,
  cointegrated.data = FALSE,
  post.est = NULL,
  units.est = NULL,
  donors.est = NULL,
  anticipation = 0,
  effect = "unit-time",
  constant = FALSE,
  verbose = TRUE,
  sparse.matrices = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scdataMulti_+3A_df">df</code></td>
<td>
<p>a dataframe object.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_id.var">id.var</code></td>
<td>
<p>a character with the name of the variable containing units' IDs. The ID variable can be numeric or character.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_time.var">time.var</code></td>
<td>
<p>a character with the name of the time variable. The time variable has to be numeric, integer, or Date. In
case <code>time.var</code> is Date it should be the output of <code><a href="base.html#topic+as.Date">as.Date</a>()</code> function. An integer or
numeric time variable is suggested when working with yearly data, whereas for all other formats a Date type
time variable is preferred.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_outcome.var">outcome.var</code></td>
<td>
<p>a character with the name of the outcome variable. The outcome variable has to be numeric.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_treatment.var">treatment.var</code></td>
<td>
<p>a character with the name of the variable containing the treatment assignment of each unit. The referenced
variable has to take value 1 if the unit is treated in that period and value 0 otherwise. Please notice that, as common in the SC
literature, we presume that once a unit is treated it remains treated forever. If treatment.var does not comply with this requirement
the command would not work as expected!</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_features">features</code></td>
<td>
<p>a list containing the names of the feature variables used for estimation.
If this option is not specified the default is <code>features = outcome.var</code>.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_cov.adj">cov.adj</code></td>
<td>
<p>a list specifying the names of the covariates to be used for adjustment for each feature. If <code>outcome.var</code> is
not in the variables specified in <code>features</code>, we force <code>cov.adj&lt;-NULL</code>. See the <strong>Details</strong> section for more.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_cointegrated.data">cointegrated.data</code></td>
<td>
<p>a logical that indicates if there is a belief that the data is cointegrated or not. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_post.est">post.est</code></td>
<td>
<p>a scalar specifying the number of post-treatment periods or a list specifying the periods
for which treatment effects have to be computed for each treated unit.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_units.est">units.est</code></td>
<td>
<p>a list specifying the treated units for which treatment effects have to be computed.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_donors.est">donors.est</code></td>
<td>
<p>a list specifying the donors units to be used. If the list has length 1, then all treated units share the same
potential donors. Otherwise, if the user requires different donor pools for different treated units, the list must be of the same
length of the number of treated units and each element has to be named with one treated unit's name as specified in id.var.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_anticipation">anticipation</code></td>
<td>
<p>a scalar that indicates the number of periods of potential anticipation effects. Default is 0.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_effect">effect</code></td>
<td>
<p>a string indicating the type of treatment effect to be computed. Options are: 'unit-time', which estimates treatment effects for each
treated unit- post treatment period combination; 'unit', which estimates the treatment effect for each unit by averaging post-treatment features over time;
'time', which estimates the average treatment effect on the treated at various horizons.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_constant">constant</code></td>
<td>
<p>a logical which controls the inclusion of a constant term across features. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> prints additional information in the console.</p>
</td></tr>
<tr><td><code id="scdataMulti_+3A_sparse.matrices">sparse.matrices</code></td>
<td>
<p>if <code>TRUE</code> all block diagonal matrices (<code class="reqn">\mathbf{B}</code>, <code class="reqn">\mathbf{C}</code>, and <code class="reqn">\mathbf{P}</code>)
are sparse matrices. This is suggested if the dimension of the dataset is large as it will likely reduce the execution time.
The sparse matrices will be objects of class 'dgCMatrix' or 'lgCMatrix', thus to visualize them they need to be transformed
in matrices, e.g. <code>View(as.matrix(B))</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><strong>Covariate-adjustment.</strong> See the <strong>Details</strong> section in <code><a href="#topic+scdata">scdata</a></code> for further information on how
to specify covariate-adjustment feature-by-feature.
</p>
</li>
<li><p><strong>Cointegration.</strong> <code>cointegrated.data</code> allows the user to model the belief that <code class="reqn">\mathbf{A}</code> and <code class="reqn">\mathbf{B}</code> form a
cointegrated system. In practice, this implies that when dealing with the pseudo-true
residuals <code class="reqn">\mathbf{u}</code>, the first-difference of <code class="reqn">\mathbf{B}</code> are used rather than the levels.
</p>
</li>
<li><p><strong>Effect.</strong> <code>effect</code> allows the user to select between two causal quantities. The default
option, <code>effect = "unit-time"</code>, prepares the data for estimation of
</p>
<p style="text-align: center;"><code class="reqn">\tau_{ik},\quad k\geq, i=1,\ldots,N_1,</code>
</p>

<p>whereas the option <code>effect = "unit"</code> prepares the data for estimation of
</p>
<p style="text-align: center;"><code class="reqn">\tau_{\cdot k}=\frac{1}{N_1} \sum_{i=1}^{N_1} \tau_{i k}</code>
</p>

<p>which is the average effect on the treated unit across multiple post-treatment periods.
</p>
</li></ul>



<h3>Value</h3>

<p>The command returns an object of class 'scdataMulti' containing the following
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>a matrix containing pre-treatment features of the treated units.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>a matrix containing pre-treatment features of the control units.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>a matrix containing covariates for adjustment.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>a matrix whose rows are the vectors used to predict the out-of-sample series for the synthetic units.</p>
</td></tr>
<tr><td><code>P.diff</code></td>
<td>
<p>for internal use only.</p>
</td></tr>
<tr><td><code>Y.df</code></td>
<td>
<p>a dataframe containing the outcome variable for all units.</p>
</td></tr>
<tr><td><code>Y.pre</code></td>
<td>
<p>a matrix containing the pre-treatment outcome of the treated units.</p>
</td></tr>
<tr><td><code>Y.post</code></td>
<td>
<p>a matrix containing the post-treatment outcome of the treated units.</p>
</td></tr>
<tr><td><code>Y.donors</code></td>
<td>
<p>a matrix containing the pre-treatment outcome of the control units.</p>
</td></tr>
<tr><td><code>specs</code></td>
<td>
<p>a list containing some specifics of the data:
</p>

<ul>
<li><p><code>J</code>, a list containing the number of donors for each treated unit
</p>
</li>
<li><p><code>K</code>, a list containing the number of covariates used for adjustment for each feature for each treated unit
</p>
</li>
<li><p><code>KM</code>, a list containing the total number of covariates used for adjustment for each treated unit
</p>
</li>
<li><p><code>M</code>, a list containing number of features used for each treated unit
</p>
</li>
<li><p><code>I</code>, number of treated units
</p>
</li>
<li><p><code>KMI</code>, overall number of covariates used for adjustment
</p>
</li>
<li><p><code>period.pre</code>, a list containing a numeric vector with the pre-treatment period for each treated unit
</p>
</li>
<li><p><code>period.post</code>, a list containing a numeric vector with the post-treatment period for each treated unit
</p>
</li>
<li><p><code>T0.features</code>, a list containing a numeric vector with the number of periods used in estimation for each feature for each treated unit
</p>
</li>
<li><p><code>T1.outcome</code>, a list containing the number of post-treatment periods for each treated unit
</p>
</li>
<li><p><code>features.list</code>, a list containing the name of the features for each treated unit
</p>
</li>
<li><p><code>outcome.var</code>, a character containing the name of the outcome variable
</p>
</li>
<li><p><code>constant</code>, for internal use only
</p>
</li>
<li><p><code>effect</code>, for internal use only
</p>
</li>
<li><p><code>anticipation</code>, number of periods of potential anticipation effects
</p>
</li>
<li><p><code>out.in.features</code>, for internal use only
</p>
</li>
<li><p><code>sparse.matrices</code>, for internal use only
</p>
</li>
<li><p><code>treated.units</code>, list containing the IDs of all treated units
</p>
</li>
<li><p><code>donors.list</code>, list containing the IDs of the donors of each treated unit</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie, A. (2021)</a>. Using synthetic controls: Feasibility, data requirements, and methodological aspects.
<em>Journal of Economic Literature</em>, 59(2), 391-425.
</p>
</li>
<li><p><a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, M. D., Feng, Y., and Titiunik, R.
(2021)</a>. Prediction intervals for synthetic control methods. <em>Journal of the American Statistical Association</em>, 116(536), 1865-1880.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2202.05984">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
scpi: Uncertainty Quantification for Synthetic Control Methods, <em>arXiv</em>:2202.05984.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2210.05026">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
Uncertainty Quantification in Synthetic Controls with Staggered Treatment Adoption, <em>arXiv</em>:2210.05026.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+scdata">scdata</a></code>, <code><a href="#topic+scest">scest</a></code>, <code><a href="#topic+scpi">scpi</a></code>, <code><a href="#topic+scplot">scplot</a></code>, <code><a href="#topic+scplotMulti">scplotMulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
datager &lt;- scpi_germany

datager$tr_id &lt;- 0
datager$tr_id[(datager$country == "West Germany" &amp; datager$year &gt; 1990)] &lt;- 1
datager$tr_id[(datager$country == "Italy" &amp; datager$year &gt; 1992)] &lt;- 0

outcome.var &lt;- "gdp"
id.var &lt;- "country"
treatment.var &lt;- "tr_id"
time.var &lt;- "year"
df.unit &lt;- scdataMulti(datager, id.var = id.var, outcome.var = outcome.var,
                       treatment.var = treatment.var,
                       time.var = time.var, features = list(c("gdp", "trade")),
               		    cointegrated.data = TRUE, constant = TRUE)

</code></pre>

<hr>
<h2 id='scest'>Prediction of Synthetic Control</h2><span id='topic+scest'></span>

<h3>Description</h3>

<p>The command implements estimation procedures for Synthetic Control (SC) methods using least squares, lasso,
ridge, or simplex-type constraints. For more information see
<a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, Feng, and Titiunik (2021)</a>.
</p>
<p>Companion <a href="https://www.stata.com/">Stata</a> and <a href="https://www.python.org/">Python</a> packages are described
in <a href="https://arxiv.org/abs/2202.05984">Cattaneo, Feng, Palomba, and Titiunik (2022)</a>.
</p>
<p>Companion commands are: <a href="#topic+scdata">scdata</a> and <a href="#topic+scdataMulti">scdataMulti</a> for data preparation in the single and multiple treated unit(s) cases, respectively,
<a href="#topic+scpi">scpi</a> for inference procedures, <a href="#topic+scplot">scplot</a> and <a href="#topic+scplotMulti">scplotMulti</a> for plots in the single and multiple treated unit(s) cases, respectively.
</p>
<p>Related Stata, R, and Python packages useful for inference in SC designs are described in the following website:
</p>
<p><a href="https://nppackages.github.io/scpi/"> https://nppackages.github.io/scpi/</a>
</p>
<p>For an introduction to synthetic control methods, see <a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie (2021)</a> and references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scest(
  data,
  w.constr = NULL,
  V = "separate",
  V.mat = NULL,
  solver = "ECOS",
  plot = FALSE,
  plot.name = NULL,
  plot.path = NULL,
  save.data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scest_+3A_data">data</code></td>
<td>
<p>a class 'scdata' object, obtained by calling <code><a href="#topic+scdata">scdata</a></code>, or class 'scdataMulti' obtained via <code><a href="#topic+scdataMulti">scdataMulti</a></code>.</p>
</td></tr>
<tr><td><code id="scest_+3A_w.constr">w.constr</code></td>
<td>
<p>a list specifying the constraint set the estimated weights of the donors must belong to.
<code>w.constr</code> can contain up to four objects:
</p>

<ul>
<li><p> '<code>p</code>', a string indicating the norm to be constrained (<code>p</code> should be one of &quot;no norm&quot;, &quot;L1&quot;, and &quot;L2&quot;)
</p>
</li>
<li><p> '<code>dir</code>', a string indicating whether the constraint on the norm is an equality (&quot;==&quot;) or inequality (&quot;&lt;=&quot;)
</p>
</li>
<li><p> '<code>Q</code>', a scalar defining the value of the constraint on the norm
</p>
</li>
<li><p> '<code>lb</code>', a scalar defining the lower bound on the weights. It can be either 0 or <code>-Inf</code>.
</p>
</li>
<li><p> '<code>name</code>', a character selecting one of the default proposals.
See the <strong>Details</strong> section for more.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scest_+3A_v">V</code></td>
<td>
<p>specifies the type of weighting matrix to be used when minimizing the sum of squared residuals
</p>
<p style="text-align: center;"><code class="reqn">(\mathbf{A}-\mathbf{B}\mathbf{w}-\mathbf{C}\mathbf{r})'\mathbf{V}(\mathbf{A}-\mathbf{B}\mathbf{w}-\mathbf{C}\mathbf{r})</code>
</p>

<p>The default is the identity matrix, so equal weight is given to all observations. In the case of multiple treated observations
(you used <code><a href="#topic+scdataMulti">scdataMulti</a></code> to prepare the data), the user can specify <code>V</code> as a string equal to either &quot;separate&quot; or &quot;pooled&quot;.
If <code>scdata()</code> was used to prepare the data, <code>V</code> is automatically set to &quot;separate&quot; as the two options are
equivalent. See the <strong>Details</strong> section for more.</p>
</td></tr>
<tr><td><code id="scest_+3A_v.mat">V.mat</code></td>
<td>
<p>A conformable weighting matrix <code class="reqn">\mathbf{V}</code> to be used in the minimization of the sum of squared residuals
</p>
<p style="text-align: center;"><code class="reqn">(\mathbf{A}-\mathbf{B}\mathbf{w}-\mathbf{C}\mathbf{r})'\mathbf{V}(\mathbf{A}-\mathbf{B}\mathbf{w}-\mathbf{C}\mathbf{r}).</code>
</p>

<p>See the <strong>Details</strong> section for more information on how to prepare this matrix.</p>
</td></tr>
<tr><td><code id="scest_+3A_solver">solver</code></td>
<td>
<p>a string containing the name of the solver used by <code>CVXR</code> when computing the weights. You can check which solvers are available
on your machine by running <code>CVXR::installed_solvers()</code>. More information on what different solvers do can be found
at the following link https://cvxr.rbind.io/cvxr_examples/cvxr_using-other-solvers/. &quot;OSQP&quot; is the default solver when 'lasso'
is the constraint type, whilst &quot;ECOS&quot; is the default in all other cases.</p>
</td></tr>
<tr><td><code id="scest_+3A_plot">plot</code></td>
<td>
<p>a logical specifying whether <code><a href="#topic+scplot">scplot</a></code> should be called and a plot saved in the current working
directory. For more options see <code><a href="#topic+scplot">scplot</a></code>.</p>
</td></tr>
<tr><td><code id="scest_+3A_plot.name">plot.name</code></td>
<td>
<p>a string containing the name of the plot (the format is by default .png). For more options see <code><a href="#topic+scplot">scplot</a></code>.</p>
</td></tr>
<tr><td><code id="scest_+3A_plot.path">plot.path</code></td>
<td>
<p>a string containing the path at which the plot should be saved (default is output of <code>getwd()</code>.)</p>
</td></tr>
<tr><td><code id="scest_+3A_save.data">save.data</code></td>
<td>
<p>a character specifying the name and the path of the saved dataframe containing the processed data used to produce the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information is provided for the simple case in which <code class="reqn">N_1=1</code> if not specified otherwise.
</p>

<ul>
<li><p><strong>Estimation of Weights.</strong> <code>w.constr</code> specifies the constraint set on the weights. First, the element
<code>p</code> allows the user to choose between imposing a constraint on either the L1 (<code>p = "L1"</code>)
or the L2 (<code>p = "L2"</code>) norm of the weights and imposing no constraint on the norm (<code>p = "no norm"</code>).
Second, <code>Q</code> specifies the value of the constraint on the norm of the weights.
Third, <code>lb</code> sets the lower bound of each component of the vector of weights.
Fourth, <code>dir</code> sets the direction of the constraint on the norm in case <code>p = "L1"</code>
or <code>p = "L2"</code>. If <code>dir = "=="</code>, then
</p>
<p style="text-align: center;"><code class="reqn">||\mathbf{w}||_p = Q,\:\:\: w_j \geq lb,\:\: j =1,\ldots,J</code>
</p>

<p>If instead <code>dir = "&lt;="</code>, then
</p>
<p style="text-align: center;"><code class="reqn">||\mathbf{w}||_p \leq Q,\:\:\: w_j \geq lb,\:\: j =1,\ldots,J</code>
</p>

<p>If instead <code>dir = "NULL"</code> no constraint on the norm of the weights is imposed.
</p>
<p>An alternative to specifying an ad-hoc constraint set on the weights would be
choosing among some popular types of constraints. This can be done by including the element
'<code>name</code>' in the list <code>w.constr</code>. The following are available options:
</p>

<ul>
<li> <p>If <code>name == "simplex"</code> (the default), then
</p>
<p style="text-align: center;"><code class="reqn">||\mathbf{w}||_1 = 1,\:\:\: w_j \geq 0,\:\: j =1,\ldots,J.</code>
</p>

</li>
<li> <p>If <code>name == "lasso"</code>, then
</p>
<p style="text-align: center;"><code class="reqn">||\mathbf{w}||_1 \leq Q,</code>
</p>

<p>where <code>Q</code> is by default equal to 1 but it can be provided as an element of the list (eg. <code>w.constr =
list(name = "lasso", Q = 2)</code>).
</p>
</li>
<li><p>If <code>name == "ridge"</code>, then
</p>
<p style="text-align: center;"><code class="reqn">||\mathbf{w}||_2 \leq Q,</code>
</p>

<p>where <code>Q</code> is a tuning parameter that is by default computed as
</p>
<p style="text-align: center;"><code class="reqn">(J+KM) \widehat{\sigma}_u^{2}/||\widehat{\mathbf{w}}_{OLS}||_{2}^{2}</code>
</p>

<p>where <code class="reqn">J</code> is the number of donors and <code class="reqn">KM</code> is the total number of covariates used for adjustment.
The user can provide <code>Q</code> as an element of the list (eg. <code>w.constr =
list(name = "ridge", Q = 1)</code>).
</p>
</li>
<li><p>If <code>name == "ols"</code>, then the problem is unconstrained and the vector of weights
is estimated via ordinary least squares.
</p>
</li>
<li><p>If <code>name == "L1-L2"</code>, then
</p>
<p style="text-align: center;"><code class="reqn">||\mathbf{w}||_1 = 1,\:\:\: ||\mathbf{w}||_2 \leq Q,</code>
</p>

<p>where <code class="reqn">Q</code> is a tuning parameter computed as in the &quot;ridge&quot; case.
</p>
</li></ul>

</li>
<li><p><strong>Weighting Matrix.</strong>
</p>

<ul>
<li><p>if <code>V &lt;- "separate"</code>, then <code class="reqn">\mathbf{V} = \mathbf{I}</code> and the minimized objective function is
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^{N_1} \sum_{l=1}^{M} \sum_{t=1}^{T_{0}}\left(a_{t, l}^{i}-\mathbf{b}_{t, l}^{{i \prime }} \mathbf{w}^{i}-\mathbf{c}_{t, l}^{{i \prime}} \mathbf{r}_{l}^{i}\right)^{2},</code>
</p>

<p>which optimizes the separate fit for each treated unit.
</p>
</li>
<li><p>if <code>V &lt;- "pooled"</code>, then <code class="reqn">\mathbf{V} = \frac{1}{I}\mathbf{1}\mathbf{1}'\otimes \mathbf{I}</code> and the minimized objective function is
</p>
<p style="text-align: center;"><code class="reqn">\sum_{l=1}^{M} \sum_{t=1}^{T_{0}}\left(\frac{1}{N_1^2} \sum_{i=1}^{N_1}\left(a_{t, l}^{i}-\mathbf{b}_{t, l}^{i \prime} \mathbf{w}^{i}-\mathbf{c}_{t, l}^{i\prime} \mathbf{r}_{l}^{i}\right)\right)^{2},</code>
</p>

<p>which optimizes the pooled fit for the average of the treated units.
</p>
</li>
<li><p>if the user wants to provide their own weighting matrix, then it must use the option <code>V.mat</code> to input a <code class="reqn">v\times v</code> positive-definite matrix, where <code class="reqn">v</code> is the
number of rows of <code class="reqn">\mathbf{B}</code> (or <code class="reqn">\mathbf{C}</code>) after potential missing values have been removed. In case the user
wants to provide their own <code>V</code>, we suggest to check the appropriate dimension <code class="reqn">v</code> by inspecting the output
of either <code>scdata</code> or <code>scdataMulti</code> and check the dimensions of <code class="reqn">\mathbf{B}</code> (and <code class="reqn">\mathbf{C}</code>). Note that
the weighting matrix could cause problems to the optimizer if not properly scaled. For example, if <code class="reqn">\mathbf{V}</code> is diagonal
we suggest to divide each of its entries by <code class="reqn">\|\mathrm{diag}(\mathbf{V})\|_1</code>.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>The function returns an object of class 'scest' containing two lists. The first list is labeled 'data' and
contains used data as returned by <code><a href="#topic+scdata">scdata</a></code> and some other values.
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>a matrix containing pre-treatment features of the treated unit(s).</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>a matrix containing pre-treatment features of the control units.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>a matrix containing covariates for adjustment.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>a matrix whose rows are the vectors used to predict the out-of-sample series for the synthetic unit(s).</p>
</td></tr>
<tr><td><code>P.diff</code></td>
<td>
<p>for internal use only.</p>
</td></tr>
<tr><td><code>Y.pre</code></td>
<td>
<p>a matrix containing the (raw) pre-treatment outcome of the treated unit(s).</p>
</td></tr>
<tr><td><code>Y.post</code></td>
<td>
<p>a matrix containing the (raw) post-treatment outcome of the treated unit(s).</p>
</td></tr>
<tr><td><code>Y.pre.agg</code></td>
<td>
<p>a matrix containing the aggregate pre-treatment outcome of the treated unit(s). This differs from
Y.pre only in the case 'effect' in <code>scdataMulti()</code> is set to either 'unit' or 'time'.</p>
</td></tr>
<tr><td><code>Y.post.agg</code></td>
<td>
<p>a matrix containing the aggregate post-treatment outcome of the treated unit(s). This differs from
Y.post only in the case 'effect' in <code>scdataMulti()</code> is set to either 'unit' or 'time'.</p>
</td></tr>
<tr><td><code>Y.donors</code></td>
<td>
<p>a matrix containing the pre-treatment outcome of the control units.</p>
</td></tr>
<tr><td><code>specs</code></td>
<td>
<p>a list containing some specifics of the data:
</p>

<ul>
<li><p><code>J</code>, the number of control units
</p>
</li>
<li><p><code>K</code>, a numeric vector with the number of covariates used for adjustment for each feature
</p>
</li>
<li><p><code>M</code>, number of features
</p>
</li>
<li><p><code>KM</code>, the total number of covariates used for adjustment
</p>
</li>
<li><p><code>KMI</code>, the total number of covariates used for adjustment
</p>
</li>
<li><p><code>I</code>, number of treated units
</p>
</li>
<li><p><code>period.pre</code>, a numeric vector with the pre-treatment period
</p>
</li>
<li><p><code>period.post</code>, a numeric vector with the post-treatment period
</p>
</li>
<li><p><code>T0.features</code>, a numeric vector with the number of periods used in estimation for each feature
</p>
</li>
<li><p><code>T1.outcome</code>, the number of post-treatment periods
</p>
</li>
<li><p><code>constant</code>, for internal use only
</p>
</li>
<li><p><code>effect</code>, for internal use only
</p>
</li>
<li><p><code>anticipation</code>, number of periods of potential anticipation effects
</p>
</li>
<li><p><code>out.in.features</code>, for internal use only
</p>
</li>
<li><p><code>treated.units</code>, list containing the IDs of all treated units
</p>
</li>
<li><p><code>donors.list</code>, list containing the IDs of the donors of each treated unit
</p>
</li>
<li><p><code>class.type</code>, for internal use only</p>
</li></ul>
</td></tr>
</table>
<p>The second list is labeled 'est.results' and contains estimation results.
</p>
<table>
<tr><td><code>w</code></td>
<td>
<p>a matrix containing the estimated weights of the donors.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>a matrix containing the values of the covariates used for adjustment.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>a matrix containing <code class="reqn">\mathbf{w}</code> and <code class="reqn">\mathbf{r}</code>.</p>
</td></tr>
<tr><td><code>Y.pre.fit</code></td>
<td>
<p>a matrix containing the estimated pre-treatment outcome of the SC unit(s).</p>
</td></tr>
<tr><td><code>Y.post.fit</code></td>
<td>
<p>a matrix containing the estimated post-treatment outcome of the SC unit(s).</p>
</td></tr>
<tr><td><code>A.hat</code></td>
<td>
<p>a matrix containing the predicted values of the features of the treated unit(s).</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>a matrix containing the residuals <code class="reqn">\mathbf{A}-\widehat{\mathbf{A}}</code>.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>a matrix containing the weighting matrix used in estimation.</p>
</td></tr>
<tr><td><code>w.constr</code></td>
<td>
<p>a list containing the specifics of the constraint set used on the weights.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie, A. (2021)</a>. Using synthetic controls: Feasibility, data requirements, and methodological aspects.
<em>Journal of Economic Literature</em>, 59(2), 391-425.
</p>
</li>
<li><p><a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, M. D., Feng, Y., and Titiunik, R.
(2021)</a>. Prediction intervals for synthetic control methods. <em>Journal of the American Statistical Association</em>, 116(536), 1865-1880.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2202.05984">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
scpi: Uncertainty Quantification for Synthetic Control Methods, <em>arXiv</em>:2202.05984.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2210.05026">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
Uncertainty Quantification in Synthetic Controls with Staggered Treatment Adoption, <em>arXiv</em>:2210.05026.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+scdataMulti">scdataMulti</a></code>, <code><a href="#topic+scdata">scdata</a></code>, <code><a href="#topic+scpi">scpi</a></code>, <code><a href="#topic+scplot">scplot</a></code>, <code><a href="#topic+scplotMulti">scplotMulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- scpi_germany

df &lt;- scdata(df = data, id.var = "country", time.var = "year",
             outcome.var = "gdp", period.pre = (1960:1990),
             period.post = (1991:2003), unit.tr = "West Germany",
             unit.co = setdiff(unique(data$country), "West Germany"),
             constant = TRUE, cointegrated.data = TRUE)

result &lt;- scest(df, w.constr = list(name = "simplex", Q = 1))
result &lt;- scest(df, w.constr = list(lb = 0, dir = "==", p = "L1", Q = 1))

</code></pre>

<hr>
<h2 id='scpi'>Prediction Intervals for Synthetic Control Methods</h2><span id='topic+scpi'></span>

<h3>Description</h3>

<p>The command implements estimation and inference procedures for Synthetic Control (SC) methods using least squares, lasso, ridge, or simplex-type constraints. Uncertainty is quantified using prediction
intervals according to <a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, Feng, and Titiunik (2021)</a>. <code><a href="#topic+scpi">scpi</a></code> returns the estimated
post-treatment series for the synthetic unit through the command <code><a href="#topic+scest">scest</a></code> and quantifies in-sample and out-of-sample uncertainty to provide confidence intervals
for each point estimate.
</p>
<p>Companion <a href="https://www.stata.com/">Stata</a> and <a href="https://www.python.org/">Python</a> packages are described in <a href="https://arxiv.org/abs/2202.05984">Cattaneo, Feng, Palomba, and Titiunik (2022)</a>.
</p>
<p>Companion commands are:  <a href="#topic+scdata">scdata</a> and <a href="#topic+scdataMulti">scdataMulti</a> for data preparation in the single and multiple treated unit(s) cases, respectively,
<a href="#topic+scest">scest</a> for point estimation, <a href="#topic+scplot">scplot</a> and <a href="#topic+scplotMulti">scplotMulti</a> for plots in the single and multiple treated unit(s) cases, respectively.
</p>
<p>Related Stata, R, and Python packages useful for inference in SC designs are described in the following website:
</p>
<p><a href="https://nppackages.github.io/scpi/"> https://nppackages.github.io/scpi/</a>
</p>
<p>For an introduction to synthetic control methods, see <a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie (2021)</a> and references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scpi(
  data,
  w.constr = NULL,
  V = "separate",
  V.mat = NULL,
  solver = "ECOS",
  P = NULL,
  u.missp = TRUE,
  u.sigma = "HC1",
  u.order = 1,
  u.lags = 0,
  u.design = NULL,
  u.alpha = 0.05,
  e.method = "all",
  e.order = 1,
  e.lags = 0,
  e.design = NULL,
  e.alpha = 0.05,
  sims = 200,
  rho = NULL,
  rho.max = 0.2,
  lgapp = "generalized",
  cores = 1,
  plot = FALSE,
  plot.name = NULL,
  w.bounds = NULL,
  e.bounds = NULL,
  save.data = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scpi_+3A_data">data</code></td>
<td>
<p>a class 'scdata' object, obtained by calling <code><a href="#topic+scdata">scdata</a></code>, or class 'scdataMulti' obtained via <code><a href="#topic+scdataMulti">scdataMulti</a></code>.</p>
</td></tr>
<tr><td><code id="scpi_+3A_w.constr">w.constr</code></td>
<td>
<p>a list specifying the constraint set the estimated weights of the donors must belong to.
<code>w.constr</code> can contain up to five elements:
</p>

<ul>
<li><p> '<code>p</code>', a scalar indicating the norm to be used (<code>p</code> should be one of &quot;no norm&quot;, &quot;L1&quot;, and &quot;L2&quot;)
</p>
</li>
<li><p> '<code>dir</code>', a string indicating whether the constraint on the norm is an equality (&quot;==&quot;) or inequality (&quot;&lt;=&quot;)
</p>
</li>
<li><p> '<code>Q</code>', a scalar defining the value of the constraint on the norm
</p>
</li>
<li><p> '<code>lb</code>', a scalar defining the lower bound on the weights. It can be either 0 or <code>-Inf</code>.
</p>
</li>
<li><p> '<code>name</code>', a character selecting one of the default proposals
See the <strong>Details</strong> section for more.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scpi_+3A_v">V</code></td>
<td>
<p>specifies the type of weighting matrix to be used when minimizing the sum of squared residuals
</p>
<p style="text-align: center;"><code class="reqn">(\mathbf{A}-\mathbf{B}\mathbf{w}-\mathbf{C}\mathbf{r})'\mathbf{V}(\mathbf{A}-\mathbf{B}\mathbf{w}-\mathbf{C}\mathbf{r})</code>
</p>

<p>The default is the identity matrix, so equal weight is given to all observations. In the case of multiple treated observations
(you used <code><a href="#topic+scdataMulti">scdataMulti</a></code> to prepare the data), the user can specify <code>V</code> as a string equal to either &quot;separate&quot; or &quot;pooled&quot;.
If <code>scdata()</code> was used to prepare the data, <code>V</code> is automatically set to &quot;separate&quot; as the two options are
equivalent. See the <strong>Details</strong> section for more.</p>
</td></tr>
<tr><td><code id="scpi_+3A_v.mat">V.mat</code></td>
<td>
<p>A conformable weighting matrix <code class="reqn">\mathbf{V}</code> to be used in the minimization of the sum of squared residuals
</p>
<p style="text-align: center;"><code class="reqn">(\mathbf{A}-\mathbf{B}\mathbf{w}-\mathbf{C}\mathbf{r})'\mathbf{V}(\mathbf{A}-\mathbf{B}\mathbf{w}-\mathbf{C}\mathbf{r}).</code>
</p>

<p>See the <strong>Details</strong> section for more information on how to prepare this matrix.</p>
</td></tr>
<tr><td><code id="scpi_+3A_solver">solver</code></td>
<td>
<p>a string containing the name of the solver used by <code>CVXR</code> when computing the weights. You can check which solvers are available
on your machine by running <code>CVXR::installed_solvers()</code>. More information on what different solvers do can be found
at the following link https://cvxr.rbind.io/cvxr_examples/cvxr_using-other-solvers/. &quot;OSQP&quot; is the default solver when 'lasso'
is the constraint type, whilst &quot;ECOS&quot; is the default in all other cases.</p>
</td></tr>
<tr><td><code id="scpi_+3A_p">P</code></td>
<td>
<p>a <code class="reqn">I\cdot T_1\times I\cdot (J+KM)</code> matrix containing the design matrix to be used to obtain the predicted.
post-intervention outcome of the synthetic control unit. <code class="reqn">T_1</code> is the number of post-treatment periods,
<code class="reqn">J</code> is the size of the donor pool, and <code class="reqn">K_1</code> is the number of covariates used for adjustment in the outcome equation.</p>
</td></tr>
<tr><td><code id="scpi_+3A_u.missp">u.missp</code></td>
<td>
<p>a logical indicating if misspecification should be taken into account when dealing with <code class="reqn">\mathbf{u}</code>.</p>
</td></tr>
<tr><td><code id="scpi_+3A_u.sigma">u.sigma</code></td>
<td>
<p>a string specifying the type of variance-covariance estimator to be used when estimating
the conditional variance of <code class="reqn">\mathbf{u}</code>.</p>
</td></tr>
<tr><td><code id="scpi_+3A_u.order">u.order</code></td>
<td>
<p>a scalar that sets the order of the polynomial in <code class="reqn">\mathbf{B}</code> when predicting moments of <code class="reqn">\mathbf{u}</code>.
The default is <code>u.order = 1</code>, however if there is risk of over-fitting, the command automatically sets it
to <code>u.order = 0</code>. See the <strong>Details</strong> section for more information.</p>
</td></tr>
<tr><td><code id="scpi_+3A_u.lags">u.lags</code></td>
<td>
<p>a scalar that sets the number of lags of <code class="reqn">\mathbf{B}</code> when predicting moments of <code class="reqn">\mathbf{u}</code>.
The default is <code>u.lags = 0</code>, however if there is risk of over-fitting, the command automatically sets it
to <code>u.lags = 0</code>. See the <strong>Details</strong> section for more information.</p>
</td></tr>
<tr><td><code id="scpi_+3A_u.design">u.design</code></td>
<td>
<p>a matrix with the same number of rows of <code class="reqn">\mathbf{A}</code> and <code class="reqn">\mathbf{B}</code> and whose columns specify the design matrix
to be used when modeling the estimated pseudo-true residuals <code class="reqn">\mathbf{u}</code>.</p>
</td></tr>
<tr><td><code id="scpi_+3A_u.alpha">u.alpha</code></td>
<td>
<p>a scalar specifying the confidence level for in-sample uncertainty, i.e. 1 - <code>u.alpha</code> is the confidence level.</p>
</td></tr>
<tr><td><code id="scpi_+3A_e.method">e.method</code></td>
<td>
<p>a string selecting the method to be used in quantifying out-of-sample uncertainty among:
&quot;gaussian&quot; which uses conditional subgaussian bounds; &quot;ls&quot; which specifies a location-scale model for <code class="reqn">\mathbf{u}</code>; &quot;qreg&quot; which employs a
quantile regressions to get the conditional bounds; &quot;all&quot; uses each one of the previous methods.</p>
</td></tr>
<tr><td><code id="scpi_+3A_e.order">e.order</code></td>
<td>
<p>a scalar that sets the order of the polynomial in <code class="reqn">\mathbf{B}</code> when predicting moments of <code class="reqn">\mathbf{e}</code>.
The default is <code>e.order = 1</code>, however if there is risk of over-fitting, the command automatically sets it
to <code>e.order = 0</code>. See the <strong>Details</strong> section for more information.</p>
</td></tr>
<tr><td><code id="scpi_+3A_e.lags">e.lags</code></td>
<td>
<p>a scalar that sets the number of lags of <code class="reqn">\mathbf{B}</code> when predicting moments of <code class="reqn">\mathbf{e}</code>.
The default is <code>e.order = 1</code>, however if there is risk of over-fitting, the command automatically sets it
to <code>e.order = 0</code>. See the <strong>Details</strong> section for more information.</p>
</td></tr>
<tr><td><code id="scpi_+3A_e.design">e.design</code></td>
<td>
<p>a matrix with the same number of rows of <code class="reqn">\mathbf{A}</code> and <code class="reqn">\mathbf{B}</code> and whose columns specify the design matrix
to be used when modeling the estimated out-of-sample residuals <code class="reqn">\mathbf{e}</code>.</p>
</td></tr>
<tr><td><code id="scpi_+3A_e.alpha">e.alpha</code></td>
<td>
<p>a scalar specifying the confidence level for out-of-sample uncertainty, i.e. 1 - <code>e.alpha</code> is the confidence level.</p>
</td></tr>
<tr><td><code id="scpi_+3A_sims">sims</code></td>
<td>
<p>a scalar providing the number of simulations to be used in quantifying in-sample uncertainty.</p>
</td></tr>
<tr><td><code id="scpi_+3A_rho">rho</code></td>
<td>
<p>a string specifying the regularizing parameter that imposes sparsity on the estimated vector of weights. If
<code>rho = 'type-1'</code> (the default), then the tuning parameter is computed based on optimization inequalities. Users can provide a scalar
with their own value for <code>rho</code>. Other options are described in the <strong>Details</strong> section.</p>
</td></tr>
<tr><td><code id="scpi_+3A_rho.max">rho.max</code></td>
<td>
<p>a scalar indicating the maximum value attainable by the tuning parameter <code>rho</code>.</p>
</td></tr>
<tr><td><code id="scpi_+3A_lgapp">lgapp</code></td>
<td>
<p>selects the way local geometry is approximated in simulation. The options are &quot;generalized&quot;
and &quot;linear&quot;. The first one accommodates for possibly non-linear constraints, whilst the second one is valid
with linear constraints only.</p>
</td></tr>
<tr><td><code id="scpi_+3A_cores">cores</code></td>
<td>
<p>number of cores to be used by the command. The default is one.</p>
</td></tr>
<tr><td><code id="scpi_+3A_plot">plot</code></td>
<td>
<p>a logical specifying whether <code><a href="#topic+scplot">scplot</a></code> should be called and a plot saved in the current working
directory. For more options see <code><a href="#topic+scplot">scplot</a></code>.</p>
</td></tr>
<tr><td><code id="scpi_+3A_plot.name">plot.name</code></td>
<td>
<p>a string containing the name of the plot (the format is by default .png). For more options see <code><a href="#topic+scplot">scplot</a></code>.</p>
</td></tr>
<tr><td><code id="scpi_+3A_w.bounds">w.bounds</code></td>
<td>
<p>a <code class="reqn">N_1\cdot T_1\times 2</code> matrix with the user-provided bounds on <code class="reqn">\beta</code>. If <code>w.bounds</code> is provided, then
the quantification of in-sample uncertainty is skipped. It is possible to provide only the lower bound or the upper bound
by filling the other column with <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="scpi_+3A_e.bounds">e.bounds</code></td>
<td>
<p>a <code class="reqn">N_1\cdot T_1\times 2</code> matrix with the user-provided bounds on <code class="reqn">(\widehat{\mathbf{w}},
\widehat{\mathbf{r}})^{\prime}</code>. If <code>e.bounds</code> is provided, then
the quantification of out-of-sample uncertainty is skipped. It is possible to provide only the lower bound or the upper bound
by filling the other column with <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="scpi_+3A_save.data">save.data</code></td>
<td>
<p>a character specifying the name and the path of the saved dataframe containing the processed data used to produce the plot.</p>
</td></tr>
<tr><td><code id="scpi_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> prints additional information in the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information is provided for the simple case in which <code class="reqn">N_1=1</code> if not specified otherwise.
</p>

<ul>
<li><p><strong>Estimation of Weights.</strong> <code>w.constr</code> specifies the constraint set on the weights. First, the element
<code>p</code> allows the user to choose between imposing a constraint on either the L1 (<code>p = "L1"</code>)
or the L2 (<code>p = "L2"</code>) norm of the weights and imposing no constraint on the norm (<code>p = "no norm"</code>).
Second, <code>Q</code> specifies the value of the constraint on the norm of the weights.
Third, <code>lb</code> sets the lower bound of each component of the vector of weights.
Fourth, <code>dir</code> sets the direction of the constraint on the norm in case <code>p = "L1"</code>
or <code>p = "L2"</code>. If <code>dir = "=="</code>, then
</p>
<p style="text-align: center;"><code class="reqn">||\mathbf{w}||_p = Q,\:\:\: w_j \geq lb,\:\: j =1,\ldots,J</code>
</p>

<p>If instead <code>dir = "&lt;="</code>, then
</p>
<p style="text-align: center;"><code class="reqn">||\mathbf{w}||_p \leq Q,\:\:\: w_j \geq lb,\:\: j =1,\ldots,J</code>
</p>

<p>If instead <code>dir = "NULL"</code> no constraint on the norm of the weights is imposed.
</p>
<p>An alternative to specifying an ad-hoc constraint set on the weights would be
choosing among some popular types of constraints. This can be done by including the element
'<code>name</code>' in the list <code>w.constr</code>. The following are available options:
</p>

<ul>
<li> <p>If <code>name == "simplex"</code> (the default), then
</p>
<p style="text-align: center;"><code class="reqn">||\mathbf{w}||_1 = 1,\:\:\: w_j \geq 0,\:\: j =1,\ldots,J.</code>
</p>

</li>
<li> <p>If <code>name == "lasso"</code>, then
</p>
<p style="text-align: center;"><code class="reqn">||\mathbf{w}||_1 \leq Q,</code>
</p>

<p>where <code>Q</code> is by default equal to 1 but it can be provided as an element of the list (eg. <code>w.constr =
list(name = "lasso", Q = 2)</code>).
</p>
</li>
<li><p>If <code>name == "ridge"</code>, then
</p>
<p style="text-align: center;"><code class="reqn">||\mathbf{w}||_2 \leq Q,</code>
</p>

<p>where <code class="reqn">Q</code> is a tuning parameter that is by default computed as
</p>
<p style="text-align: center;"><code class="reqn">(J+KM) \widehat{\sigma}_u^{2}/||\widehat{\mathbf{w}}_{OLS}||_{2}^{2}</code>
</p>

<p>where <code class="reqn">J</code> is the number of donors and <code class="reqn">KM</code> is the total number of covariates used for adjustment.
The user can provide <code>Q</code> as an element of the list (eg. <code>w.constr =
list(name = "ridge", Q = 1)</code>).
</p>
</li>
<li><p>If <code>name == "ols"</code>, then the problem is unconstrained and the vector of weights
is estimated via ordinary least squares.
</p>
</li>
<li><p>If <code>name == "L1-L2"</code>, then
</p>
<p style="text-align: center;"><code class="reqn">||\mathbf{w}||_1 = 1,\:\:\: ||\mathbf{w}||_2 \leq Q,</code>
</p>

<p>where <code class="reqn">Q</code> is a tuning parameter computed as in the &quot;ridge&quot; case.
</p>
</li></ul>

</li>
<li><p><strong>Weighting Matrix.</strong>
</p>

<ul>
<li><p>if <code>V &lt;- "separate"</code>, then <code class="reqn">\mathbf{V} = \mathbf{I}</code> and the minimized objective function is
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^{N_1} \sum_{l=1}^{M} \sum_{t=1}^{T_{0}}\left(a_{t, l}^{i}-\mathbf{b}_{t, l}^{{i \prime }} \mathbf{w}^{i}-\mathbf{c}_{t, l}^{{i \prime}} \mathbf{r}_{l}^{i}\right)^{2},</code>
</p>

<p>which optimizes the separate fit for each treated unit.
</p>
</li>
<li><p>if <code>V &lt;- "pooled"</code>, then <code class="reqn">\mathbf{V} = \mathbf{1}\mathbf{1}'\otimes \mathbf{I}</code> and the minimized objective function is
</p>
<p style="text-align: center;"><code class="reqn">\sum_{l=1}^{M} \sum_{t=1}^{T_{0}}\left(\frac{1}{N_1^2} \sum_{i=1}^{N_1}\left(a_{t, l}^{i}-\mathbf{b}_{t, l}^{i \prime} \mathbf{w}^{i}-\mathbf{c}_{t, l}^{i\prime} \mathbf{r}_{l}^{i}\right)\right)^{2},</code>
</p>

<p>which optimizes the pooled fit for the average of the treated units.
</p>
</li>
<li><p>if the user wants to provide their own weighting matrix, then it must use the option <code>V.mat</code> to input a <code class="reqn">v\times v</code> positive-definite matrix, where <code class="reqn">v</code> is the
number of rows of <code class="reqn">\mathbf{B}</code> (or <code class="reqn">\mathbf{C}</code>) after potential missing values have been removed. In case the user
wants to provide their own <code>V</code>, we suggest to check the appropriate dimension <code class="reqn">v</code> by inspecting the output
of either <code>scdata</code> or <code>scdataMulti</code> and check the dimensions of <code class="reqn">\mathbf{B}</code> (and <code class="reqn">\mathbf{C}</code>). Note that
the weighting matrix could cause problems to the optimizer if not properly scaled. For example, if <code class="reqn">\mathbf{V}</code> is diagonal
we suggest to divide each of its entries by <code class="reqn">\|\mathrm{diag}(\mathbf{V})\|_1</code>.
</p>
</li></ul>

</li>
<li><p><strong>Regularization.</strong> <code>rho</code> is estimated through the formula
</p>
<p style="text-align: center;"><code class="reqn">\varrho = \mathcal{C}\frac{\log (T_0)^c}{T_0^{1/2}}</code>
</p>

<p>where <code class="reqn">\mathcal{C} = \widehat{\sigma}_u / \min_j \widehat{\sigma}_{b_j}</code> if <code>rho = 'type-1'</code>,
<code class="reqn">\mathcal{C} = \max_{j}\widehat{\sigma}_{b_j}\widehat{\sigma}_{u} / \min_j \widehat{\sigma}_{b_j}^2</code> if <code>rho = 'type-2'</code>, and
<code class="reqn">\mathcal{C} = \max_{j}\widehat{\sigma}_{b_ju} / \min_j \widehat{\sigma}_{b_j}^2</code> if <code>rho = 'type-3'</code>,
</p>
<p><code>rho</code> defines a new sparse weight vector as
</p>
<p style="text-align: center;"><code class="reqn">\widehat{w}^\star_j = \mathbf{1}(\widehat{w}_j\geq \varrho)</code>
</p>


</li>
<li><p><strong>In-sample uncertainty.</strong> To quantify in-sample uncertainty it is necessary to model the pseudo-residuals <code class="reqn">\mathbf{u}</code>.
First of all, estimation of the first moment of <code class="reqn">\mathbf{u}</code> can be controlled through
the option <code>u.missp</code>. When <code>u.missp = FALSE</code>, then <code class="reqn">\mathbf{E}[u\: |\: \mathbf{D}_u]=0</code>. If instead <code>u.missp = TRUE</code>,
then <code class="reqn">\mathbf{E}[\mathbf{u}\: |\: \mathbf{D}_u]</code> is estimated using a linear regression of
<code class="reqn">\widehat{\mathbf{u}}</code> on <code class="reqn">\mathbf{D}_u</code>. The default set of variables in <code class="reqn">\mathbf{D}_u</code> is composed of <code class="reqn">\mathbf{B}</code>,
<code class="reqn">\mathbf{C}</code> and, if required, it is augmented with lags (<code>u.lags</code>) and polynomials (<code>u.order</code>) of <code class="reqn">\mathbf{B}</code>.
The option <code>u.design</code> allows the user to provide an ad-hoc set of variables to form <code class="reqn">\mathbf{D}_u</code>.
Regarding the second moment of <code class="reqn">\mathbf{u}</code>, different estimators can be chosen:
HC0, HC1, HC2, HC3, and HC4 using the option <code>u.sigma</code>.
</p>
</li>
<li><p><strong>Out-of-sample uncertainty.</strong> To quantify out-of-sample uncertainty it is necessary to model the out-of-sample residuals
<code class="reqn">\mathbf{e}</code> and estimate relevant moments. By default, the design matrix used during estimation <code class="reqn">\mathbf{D}_e</code> is composed of the blocks in
<code class="reqn">\mathbf{B}</code> and <code class="reqn">\mathbf{C}</code> corresponding to the outcome variable. Moreover, if required by the user, <code class="reqn">\mathbf{D}_e</code>
is augmented with lags (<code>e.lags</code>) and polynomials (<code>e.order</code>) of <code class="reqn">\mathbf{B}</code>. The option <code>e.design</code> allows the user to provide an
ad-hoc set of variables to form <code class="reqn">\mathbf{D}_e</code>. Finally, the option <code>e.method</code> allows the user to select one of three
estimation methods: &quot;gaussian&quot; relies on conditional sub-Gaussian bounds; &quot;ls&quot; estimates conditional bounds using a location-scale
model; &quot;qreg&quot; uses conditional quantile regression of the residuals <code class="reqn">\mathbf{e}</code> on <code class="reqn">\mathbf{D}_e</code>.
</p>
</li>
<li><p><strong>Residual Estimation Over-fitting.</strong> To estimate conditional moments of <code class="reqn">\mathbf{u}</code> and <code class="reqn">e_t</code>
we rely on two design matrices, <code class="reqn">\mathbf{D}_u</code> and <code class="reqn">\mathbf{D}_e</code> (see above). Let <code class="reqn">d_u</code> and <code class="reqn">d_e</code> be the number of
columns in <code class="reqn">\mathbf{D}_u</code> and <code class="reqn">\mathbf{D}_e</code>, respectively. Assuming no missing values and balanced features, the
number of observation used to estimate moments of <code class="reqn">\mathbf{u}</code> is <code class="reqn">N_1\cdot T_0\cdot M</code>, whilst for moments of <code class="reqn">e_t</code> is <code class="reqn">T_0</code>.
Our rule of thumb to avoid over-fitting is to check if <code class="reqn">N_1\cdot T_0\cdot M \geq d_u + 10</code> or <code class="reqn">T_0 \geq d_e + 10</code>. If the
former condition is not satisfied we automatically set <code>u.order = u.lags = 0</code>, if instead the latter is not met
we automatically set <code>e.order = e.lags = 0</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The function returns an object of class 'scpi' containing three lists. The first list is labeled 'data' and contains used
data as returned by <code><a href="#topic+scdata">scdata</a></code> and some other values.
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>a matrix containing pre-treatment features of the treated unit(s).</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>a matrix containing pre-treatment features of the control units.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>a matrix containing covariates for adjustment.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>a matrix whose rows are the vectors used to predict the out-of-sample series for the synthetic unit(s).</p>
</td></tr>
<tr><td><code>Y.pre</code></td>
<td>
<p>a matrix containing the pre-treatment outcome of the treated unit(s).</p>
</td></tr>
<tr><td><code>Y.post</code></td>
<td>
<p>a matrix containing the post-treatment outcome of the treated unit(s).</p>
</td></tr>
<tr><td><code>Y.pre.agg</code></td>
<td>
<p>a matrix containing the aggregate pre-treatment outcome of the treated unit(s). This differs from
Y.pre only in the case 'effect' in <code>scdataMulti()</code> is set to either 'unit' or 'time'.</p>
</td></tr>
<tr><td><code>Y.post.agg</code></td>
<td>
<p>a matrix containing the aggregate post-treatment outcome of the treated unit(s). This differs from
Y.post only in the case 'effect' in <code>scdataMulti()</code> is set to either 'unit' or 'time'.</p>
</td></tr>
<tr><td><code>Y.donors</code></td>
<td>
<p>a matrix containing the pre-treatment outcome of the control units.</p>
</td></tr>
<tr><td><code>specs</code></td>
<td>
<p>a list containing some specifics of the data:
</p>

<ul>
<li><p><code>J</code>, the number of control units
</p>
</li>
<li><p><code>K</code>, a numeric vector with the number of covariates used for adjustment for each feature
</p>
</li>
<li><p><code>M</code>, number of features
</p>
</li>
<li><p><code>KM</code>, the total number of covariates used for adjustment
</p>
</li>
<li><p><code>KMI</code>, the total number of covariates used for adjustment
</p>
</li>
<li><p><code>I</code>, number of treated unit(s)
</p>
</li>
<li><p><code>period.pre</code>, a numeric vector with the pre-treatment period
</p>
</li>
<li><p><code>period.post</code>, a numeric vector with the post-treatment period
</p>
</li>
<li><p><code>T0.features</code>, a numeric vector with the number of periods used in estimation for each feature
</p>
</li>
<li><p><code>T1.outcome</code>, the number of post-treatment periods
</p>
</li>
<li><p><code>constant</code>, for internal use only
</p>
</li>
<li><p><code>effect</code>, for internal use only
</p>
</li>
<li><p><code>anticipation</code>, number of periods of potential anticipation effects
</p>
</li>
<li><p><code>out.in.features</code>, for internal use only
</p>
</li>
<li><p><code>treated.units</code>, list containing the IDs of all treated units
</p>
</li>
<li><p><code>donors.list</code>, list containing the IDs of the donors of each treated unit</p>
</li></ul>
</td></tr>
</table>
<p>The second list is labeled 'est.results' containing all the results from <code><a href="#topic+scest">scest</a></code>.
</p>
<table>
<tr><td><code>w</code></td>
<td>
<p>a matrix containing the estimated weights of the donors.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>a matrix containing the values of the covariates used for adjustment.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>a matrix containing <code class="reqn">\mathbf{w}</code> and <code class="reqn">\mathbf{r}</code>.</p>
</td></tr>
<tr><td><code>Y.pre.fit</code></td>
<td>
<p>a matrix containing the estimated pre-treatment outcome of the SC unit(s).</p>
</td></tr>
<tr><td><code>Y.post.fit</code></td>
<td>
<p>a matrix containing the estimated post-treatment outcome of the SC unit(s).</p>
</td></tr>
<tr><td><code>A.hat</code></td>
<td>
<p>a matrix containing the predicted values of the features of the treated unit(s).</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>a matrix containing the residuals <code class="reqn">\mathbf{A}-\widehat{\mathbf{A}}</code>.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>a matrix containing the weighting matrix used in estimation.</p>
</td></tr>
<tr><td><code>w.constr</code></td>
<td>
<p>a list containing the specifics of the constraint set used on the weights.</p>
</td></tr>
</table>
<p>The third list is labeled 'inference.results' and contains all the inference-related results.
</p>
<table>
<tr><td><code>CI.in.sample</code></td>
<td>
<p>a matrix containing the prediction intervals taking only in-sample uncertainty in to account.</p>
</td></tr>
<tr><td><code>CI.all.gaussian</code></td>
<td>
<p>a matrix containing the prediction intervals estimating out-of-sample uncertainty with sub-Gaussian bounds.</p>
</td></tr>
<tr><td><code>CI.all.ls</code></td>
<td>
<p>a matrix containing the prediction intervals estimating out-of-sample uncertainty with a location-scale model.</p>
</td></tr>
<tr><td><code>CI.all.qreg</code></td>
<td>
<p>a matrix containing the prediction intervals estimating out-of-sample uncertainty with quantile regressions.</p>
</td></tr>
<tr><td><code>bounds</code></td>
<td>
<p>a list containing the estimated bounds (in-sample and out-of-sample uncertainty).</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>a matrix containing the estimated (conditional) variance-covariance <code class="reqn">\boldsymbol{\Sigma}</code>.</p>
</td></tr>
<tr><td><code>u.mean</code></td>
<td>
<p>a matrix containing the estimated (conditional) mean of the pseudo-residuals <code class="reqn">\mathbf{u}</code>.</p>
</td></tr>
<tr><td><code>u.var</code></td>
<td>
<p>a matrix containing the estimated (conditional) variance-covariance of the pseudo-residuals <code class="reqn">\mathbf{u}</code>.</p>
</td></tr>
<tr><td><code>e.mean</code></td>
<td>
<p>a matrix containing the estimated (conditional) mean of the out-of-sample error <code class="reqn">e</code>.</p>
</td></tr>
<tr><td><code>e.var</code></td>
<td>
<p>a matrix containing the estimated (conditional) variance of the out-of-sample error <code class="reqn">e</code>.</p>
</td></tr>
<tr><td><code>u.missp</code></td>
<td>
<p>a logical indicating whether the model has been treated as misspecified or not.</p>
</td></tr>
<tr><td><code>u.lags</code></td>
<td>
<p>an integer containing the number of lags in B used in predicting moments of the pseudo-residuals <code class="reqn">\mathbf{u}</code>.</p>
</td></tr>
<tr><td><code>u.order</code></td>
<td>
<p>an integer containing the order of the polynomial in B used in predicting moments of the pseudo-residuals <code class="reqn">\mathbf{u}</code>.</p>
</td></tr>
<tr><td><code>u.sigma</code></td>
<td>
<p>a string indicating the estimator used for <code>Sigma</code>.</p>
</td></tr>
<tr><td><code>u.user</code></td>
<td>
<p>a logical indicating whether the design matrix to predict moments of <code class="reqn">\mathbf{u}</code> was user-provided.</p>
</td></tr>
<tr><td><code>u.T</code></td>
<td>
<p>a scalar indicating the number of observations used to predict moments of <code class="reqn">\mathbf{u}</code>.</p>
</td></tr>
<tr><td><code>u.params</code></td>
<td>
<p>a scalar indicating the number of parameters used to predict moments of <code class="reqn">\mathbf{u}</code>.</p>
</td></tr>
<tr><td><code>u.D</code></td>
<td>
<p>the design matrix used to predict moments of <code class="reqn">\mathbf{u}</code>,</p>
</td></tr>
<tr><td><code>u.alpha</code></td>
<td>
<p>a scalar determining the confidence level used for in-sample uncertainty, i.e. 1-<code>u.alpha</code> is the confidence level.</p>
</td></tr>
<tr><td><code>e.method</code></td>
<td>
<p>a string indicating the specification used to predict moments of the out-of-sample error <code class="reqn">e</code>.</p>
</td></tr>
<tr><td><code>e.lags</code></td>
<td>
<p>an integer containing the number of lags in B used in predicting moments of the out-of-sample error <code class="reqn">e</code>.</p>
</td></tr>
<tr><td><code>e.order</code></td>
<td>
<p>an integer containing the order of the polynomial in B used in predicting moments of the out-of-sample error <code class="reqn">e</code>.</p>
</td></tr>
<tr><td><code>e.user</code></td>
<td>
<p>a logical indicating whether the design matrix to predict moments of <code class="reqn">e</code> was user-provided.</p>
</td></tr>
<tr><td><code>e.T</code></td>
<td>
<p>a scalar indicating the number of observations used to predict moments of <code class="reqn">\mathbf{u}</code>.</p>
</td></tr>
<tr><td><code>e.params</code></td>
<td>
<p>a scalar indicating the number of parameters used to predict moments of <code class="reqn">\mathbf{u}</code>.</p>
</td></tr>
<tr><td><code>e.alpha</code></td>
<td>
<p>a scalar determining the confidence level used for out-of-sample uncertainty, i.e. 1-<code>e.alpha</code> is the confidence level.</p>
</td></tr>
<tr><td><code>e.D</code></td>
<td>
<p>the design matrix used to predict moments of <code class="reqn">\mathbf{u}</code>,</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>an integer specifying the estimated regularizing parameter that imposes sparsity on the estimated vector of weights.</p>
</td></tr>
<tr><td><code>Q.star</code></td>
<td>
<p>a list containing the regularized constraint on the norm.</p>
</td></tr>
<tr><td><code>epskappa</code></td>
<td>
<p>a vector containing the estimates for <code class="reqn">\epsilon_{\kappa}</code>.</p>
</td></tr>
<tr><td><code>sims</code></td>
<td>
<p>an integer indicating the number of simulations used in quantifying in-sample uncertainty.</p>
</td></tr>
<tr><td><code>failed.sims</code></td>
<td>
<p>a matrix containing the number of failed simulations per post-treatment period to estimate lower and upper bounds.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie, A. (2021)</a>. Using synthetic controls: Feasibility, data requirements, and methodological aspects.
<em>Journal of Economic Literature</em>, 59(2), 391-425.
</p>
</li>
<li><p><a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, M. D., Feng, Y., and Titiunik, R.
(2021)</a>. Prediction intervals for synthetic control methods. <em>Journal of the American Statistical Association</em>, 116(536), 1865-1880.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2202.05984">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
scpi: Uncertainty Quantification for Synthetic Control Methods, <em>arXiv</em>:2202.05984.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2210.05026">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
Uncertainty Quantification in Synthetic Controls with Staggered Treatment Adoption, <em>arXiv</em>:2210.05026.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+scdata">scdata</a></code>, <code><a href="#topic+scdataMulti">scdataMulti</a></code>, <code><a href="#topic+scest">scest</a></code>, <code><a href="#topic+scplot">scplot</a></code>, <code><a href="#topic+scplotMulti">scplotMulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- scpi_germany

df &lt;- scdata(df = data, id.var = "country", time.var = "year",
             outcome.var = "gdp", period.pre = (1960:1990),
             period.post = (1991:2003), unit.tr = "West Germany",
             unit.co = setdiff(unique(data$country), "West Germany"),
             constant = TRUE, cointegrated.data = TRUE)

result &lt;- scpi(df, w.constr = list(name = "simplex", Q = 1), cores = 1, sims = 10)
result &lt;- scpi(df, w.constr = list(lb = 0, dir = "==", p = "L1", Q = 1),
               cores = 1, sims = 10)
                           
</code></pre>

<hr>
<h2 id='scpi_germany'>Replication Dataset for Estimating the Economic Impact of German Reunification</h2><span id='topic+scpi_germany'></span>

<h3>Description</h3>

<p>A dataset containing some economic indicators of 17 OECD countries from 1960
to 2003.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scpi_germany
</code></pre>


<h3>Format</h3>

<p>A data frame with 748 rows and 11 variables:
</p>

<dl>
<dt>index</dt><dd><p>country index.</p>
</dd>
<dt>country</dt><dd><p>name of the country.</p>
</dd>
<dt>year</dt><dd><p>time index, in years.</p>
</dd>
<dt>gdp</dt><dd><p>GDP per Capita (PPP, 2002 USD).</p>
</dd>
<dt>infrate</dt><dd><p>annual percentage change in consumer prices (base year 1995).</p>
</dd>
<dt>trade</dt><dd><p>trade openness measured as export plus imports as percentage of GDP.</p>
</dd>
<dt>schooling</dt><dd><p>percentage of secondary school attained in the total population aged 25 and older.</p>
</dd>
<dt>industry</dt><dd><p>industry share of value added.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/24714">https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/24714</a>
</p>

<hr>
<h2 id='scplot'>Plot Synthetic Control Point Estimates and Prediction Interval</h2><span id='topic+scplot'></span>

<h3>Description</h3>

<p>The command plots the actual pre-treatment and post-treatment series of the treated
unit and the estimated counterfactual synthetic control unit with corresponding prediction intervals.
Prediction intervals can take into account either in-sample uncertainty only or in-sample and
out-of-sample uncertainty using the techniques developed in <a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, Feng, and Titiunik (2021)</a>. <code><a href="#topic+scpi">scpi</a></code>.
The input object should come from the command <code><a href="#topic+scest">scest</a></code> or from the command <code><a href="#topic+scpi">scpi</a></code>.
</p>
<p>Companion <a href="https://www.stata.com/">Stata</a> and <a href="https://www.python.org/">Python</a> packages are described in <a href="https://arxiv.org/abs/2202.05984">Cattaneo, Feng, Palomba, and Titiunik (2022)</a>.
</p>
<p>Companion commands are:  <a href="#topic+scdata">scdata</a> and <a href="#topic+scdataMulti">scdataMulti</a> for data preparation in the single and multiple treated unit(s) cases, respectively,
<a href="#topic+scest">scest</a> for point estimation, <a href="#topic+scpi">scpi</a> for inference procedures, and <a href="#topic+scplotMulti">scplotMulti</a> for plots with multiple treated units.
</p>
<p>Related Stata, R, and Python packages useful for inference in SC designs are described in the following website:
</p>
<p><a href="https://nppackages.github.io/scpi/"> https://nppackages.github.io/scpi/</a>
</p>
<p>For an introduction to synthetic control methods, see <a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie (2021)</a> and references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scplot(
  result,
  fig.path = NULL,
  fig.name = NULL,
  fig.format = "png",
  e.out = TRUE,
  joint = FALSE,
  col.treated = "black",
  col.synth = "mediumblue",
  label.xy = NULL,
  plot.range = NULL,
  x.ticks = NULL,
  event.label = NULL,
  plot.specs = NULL,
  save.data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scplot_+3A_result">result</code></td>
<td>
<p>a class 'scest' object, obtained by calling <code><a href="#topic+scest">scest</a></code>, or a class
'scpi' object, obtained by calling <code><a href="#topic+scpi">scpi</a></code>.</p>
</td></tr>
<tr><td><code id="scplot_+3A_fig.path">fig.path</code></td>
<td>
<p>a string indicating the path where the plot(s) should be saved.</p>
</td></tr>
<tr><td><code id="scplot_+3A_fig.name">fig.name</code></td>
<td>
<p>a string indicating the name of the plot(s). If multiple plots will be saved the command automatically
generates a numeric suffix to avoid overwriting them.</p>
</td></tr>
<tr><td><code id="scplot_+3A_fig.format">fig.format</code></td>
<td>
<p>a string indicating the format in which the plot(s) should be saved.</p>
</td></tr>
<tr><td><code id="scplot_+3A_e.out">e.out</code></td>
<td>
<p>a logical specifying whether out-of-sample uncertainty should be included in the plot(s).</p>
</td></tr>
<tr><td><code id="scplot_+3A_joint">joint</code></td>
<td>
<p>a logical specifying whether simultaneous prediction intervals should be included in the plot(s). It requires <code>e.out = TRUE</code>.</p>
</td></tr>
<tr><td><code id="scplot_+3A_col.treated">col.treated</code></td>
<td>
<p>a string specifying the color for the treated unit series. Find the full list at <a href="http://sape.inf.usi.ch/quick-reference/ggplot2/colour">http://sape.inf.usi.ch/quick-reference/ggplot2/colour</a>.</p>
</td></tr>
<tr><td><code id="scplot_+3A_col.synth">col.synth</code></td>
<td>
<p>a string specifying the color for the synthetic unit series. Find the full list at <a href="http://sape.inf.usi.ch/quick-reference/ggplot2/colour">http://sape.inf.usi.ch/quick-reference/ggplot2/colour</a>.</p>
</td></tr>
<tr><td><code id="scplot_+3A_label.xy">label.xy</code></td>
<td>
<p>a character list with two elements indicating the name of the axes
(eg. label.xy = list(x.lab = &quot;Year&quot;, y.lab = &quot;GDP growth (%)&quot;)).</p>
</td></tr>
<tr><td><code id="scplot_+3A_plot.range">plot.range</code></td>
<td>
<p>a numeric array indicating the time range of the plot(s).</p>
</td></tr>
<tr><td><code id="scplot_+3A_x.ticks">x.ticks</code></td>
<td>
<p>a numeric list containing the location of the ticks on the x axis.</p>
</td></tr>
<tr><td><code id="scplot_+3A_event.label">event.label</code></td>
<td>
<p>a list containing a character object ('lab') indicating the label of the event and
a numeric object indicating the height of the label in the plot.</p>
</td></tr>
<tr><td><code id="scplot_+3A_plot.specs">plot.specs</code></td>
<td>
<p>a list containing some specifics to be passed to ggsave (eg. img.width, img.height, dpi)</p>
</td></tr>
<tr><td><code id="scplot_+3A_save.data">save.data</code></td>
<td>
<p>a character specifying the name and the path of the saved dataframe containing the processed data used
to produce the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>plots</code></td>
<td>
<p>a list containing standard ggplot object(s) that can be used for further customization.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie, A. (2021)</a>. Using synthetic controls:
Feasibility, data requirements, and methodological aspects.
<em>Journal of Economic Literature</em>, 59(2), 391-425.
</p>
</li>
<li><p><a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, M. D., Feng, Y., and Titiunik, R.
(2021)</a>. Prediction intervals for synthetic control methods. <em>Journal of the American Statistical Association</em>, 116(536), 1865-1880.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2202.05984">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022)</a>,
scpi: Uncertainty Quantification for Synthetic Control Methods, <em>arXiv</em>:2202.05984.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2210.05026">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
Uncertainty Quantification in Synthetic Controls with Staggered Treatment Adoption, <em>arXiv</em>:2210.05026.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+scdata">scdata</a></code>, <code><a href="#topic+scdataMulti">scdataMulti</a></code>, <code><a href="#topic+scest">scest</a></code>, <code><a href="#topic+scpi">scpi</a></code>, <code><a href="#topic+scplotMulti">scplotMulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- scpi_germany

df &lt;- scdata(df = data, id.var = "country", time.var = "year",
             outcome.var = "gdp", period.pre = (1960:1990),
             period.post = (1991:2003), unit.tr = "West Germany",
             unit.co = setdiff(unique(data$country), "West Germany"),
             constant = TRUE, cointegrated.data = TRUE)

result &lt;- scest(df, w.constr = list(name = "simplex", Q = 1))

scplot(result)

</code></pre>

<hr>
<h2 id='scplotMulti'>Plot Synthetic Control Point Estimates and Prediction Interval With Multiple Treated units and Staggered Adoption</h2><span id='topic+scplotMulti'></span>

<h3>Description</h3>

<p>The command produces a wide range of plots of Synthetic Control estimates and corresponding prediction intervals. The command allows form multiple treated units and staggered adoption.
Prediction intervals can take into account either in-sample uncertainty only or in-sample and
out-of-sample uncertainty using the techniques developed in <a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, Feng, and Titiunik (2021)</a>. <code><a href="#topic+scpi">scpi</a></code>.
The input object should come from the command <code><a href="#topic+scest">scest</a></code> or from the command <code><a href="#topic+scpi">scpi</a></code>.
</p>
<p>Companion <a href="https://www.stata.com/">Stata</a> and <a href="https://www.python.org/">Python</a> packages are described in <a href="https://arxiv.org/abs/2202.05984">Cattaneo, Feng, Palomba, and Titiunik (2022)</a>.
</p>
<p>Companion commands are:  <a href="#topic+scdata">scdata</a> and <a href="#topic+scdataMulti">scdataMulti</a> for data preparation in the single and multiple treated unit(s) cases, respectively,
<a href="#topic+scest">scest</a> for point estimation, <a href="#topic+scpi">scpi</a> for inference procedures, and <a href="#topic+scplotMulti">scplotMulti</a> for plots with multiple treated units.
</p>
<p>Related Stata, R, and Python packages useful for inference in SC designs are described in the following website:
</p>
<p><a href="https://nppackages.github.io/scpi/"> https://nppackages.github.io/scpi/</a>
</p>
<p>For an introduction to synthetic control methods, see <a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie (2021)</a> and references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scplotMulti(
  result,
  type = "series",
  e.out = TRUE,
  joint = FALSE,
  col.treated = "black",
  col.synth = "mediumblue",
  scales = "fixed",
  point.size = 1.5,
  ncols = 3,
  save.data = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scplotMulti_+3A_result">result</code></td>
<td>
<p>a class 'scest' object, obtained by calling <code><a href="#topic+scest">scest</a></code>, or a class
'scpi' object, obtained by calling <code><a href="#topic+scpi">scpi</a></code>. The data object given as input to this command has to be
processed with <code><a href="#topic+scdataMulti">scdataMulti</a></code>.</p>
</td></tr>
<tr><td><code id="scplotMulti_+3A_type">type</code></td>
<td>
<p>a character that specifies the type of plot to be produced. If set to 'treatment' then treatment effects are plotted.
If set to 'series' (default), the actual and synthetic time series are reported.</p>
</td></tr>
<tr><td><code id="scplotMulti_+3A_e.out">e.out</code></td>
<td>
<p>a logical specifying whether out-of-sample uncertainty should be included in the plot(s).</p>
</td></tr>
<tr><td><code id="scplotMulti_+3A_joint">joint</code></td>
<td>
<p>a logical specifying whether simultaneous prediction intervals should be included in the plot(s). It requires <code>e.out = TRUE</code>.</p>
</td></tr>
<tr><td><code id="scplotMulti_+3A_col.treated">col.treated</code></td>
<td>
<p>a string specifying the color for the treated unit series. Find the full list at <a href="http://sape.inf.usi.ch/quick-reference/ggplot2/colour">http://sape.inf.usi.ch/quick-reference/ggplot2/colour</a>.</p>
</td></tr>
<tr><td><code id="scplotMulti_+3A_col.synth">col.synth</code></td>
<td>
<p>a string specifying the color for the synthetic unit series. Find the full list at <a href="http://sape.inf.usi.ch/quick-reference/ggplot2/colour">http://sape.inf.usi.ch/quick-reference/ggplot2/colour</a>.</p>
</td></tr>
<tr><td><code id="scplotMulti_+3A_scales">scales</code></td>
<td>
<p>should axes scales be fixed (&quot;fixed&quot;, the default), free (&quot;free&quot;), or free in one dimension (&quot;free_x&quot;, &quot;free_y&quot;)?</p>
</td></tr>
<tr><td><code id="scplotMulti_+3A_point.size">point.size</code></td>
<td>
<p>a scalar controlling the size of points in the scatter plot. Default is 1.5.</p>
</td></tr>
<tr><td><code id="scplotMulti_+3A_ncols">ncols</code></td>
<td>
<p>an integer controlling the number of columns in the plot.</p>
</td></tr>
<tr><td><code id="scplotMulti_+3A_save.data">save.data</code></td>
<td>
<p>a character specifying the name and the path of the saved dataframe containing the processed data used to produce the plot.</p>
</td></tr>
<tr><td><code id="scplotMulti_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> prints additional information in the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>plots</code></td>
<td>
<p>a list containing standard ggplot object(s) that can be used for further customization.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie, A. (2021)</a>. Using synthetic controls: Feasibility, data requirements, and methodological aspects.
<em>Journal of Economic Literature</em>, 59(2), 391-425.
</p>
</li>
<li><p><a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, M. D., Feng, Y., and Titiunik, R.
(2021)</a>. Prediction intervals for synthetic control methods. <em>Journal of the American Statistical Association</em>, 116(536), 1865-1880.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2202.05984">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022)</a>,
scpi: Uncertainty Quantification for Synthetic Control Methods, <em>arXiv</em>:2202.05984.
</p>
</li>
<li><p><a href="https://arxiv.org/abs/2210.05026">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
Uncertainty Quantification in Synthetic Controls with Staggered Treatment Adoption, <em>arXiv</em>:2210.05026.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+scdata">scdata</a></code>, <code><a href="#topic+scdataMulti">scdataMulti</a></code>, <code><a href="#topic+scest">scest</a></code>, <code><a href="#topic+scpi">scpi</a></code>, <code><a href="#topic+scplotMulti">scplotMulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
datager &lt;- scpi_germany

datager$tr_id &lt;- 0
datager$tr_id[(datager$country == "West Germany" &amp; datager$year &gt; 1990)] &lt;- 1
datager$tr_id[(datager$country == "Italy" &amp; datager$year &gt; 1992)] &lt;- 0

outcome.var &lt;- "gdp"
id.var &lt;- "country"
treatment.var &lt;- "tr_id"
time.var &lt;- "year"
df.unit &lt;- scdataMulti(datager, id.var = id.var, outcome.var = outcome.var,
                       treatment.var = treatment.var,
                       time.var = time.var, features = list(c("gdp", "trade")),
               		    cointegrated.data = TRUE, constant = TRUE)

res.unit &lt;- scpi(df.unit, sims = 10, cores = 1)
scplotMulti(res.unit, joint = TRUE)

</code></pre>

<hr>
<h2 id='summary.scdata'>Summary Method for Synthetic Control Prediction</h2><span id='topic+summary.scdata'></span>

<h3>Description</h3>

<p>The summary method for synthetic control prediction objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdata'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.scdata_+3A_object">object</code></td>
<td>
<p>Class &quot;scest&quot; object, obtained by calling <code><a href="#topic+scdata">scdata</a></code>.</p>
</td></tr>
<tr><td><code id="summary.scdata_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to summarize <code><a href="#topic+scdata">scdata</a></code> results.
</p>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scdata">scdata</a></code>
</p>
<p>Supported methods: <code><a href="#topic+print.scdata">print.scdata</a></code>, <code><a href="#topic+summary.scdata">summary.scdata</a></code>.
</p>

<hr>
<h2 id='summary.scdataMulti'>Summary Method for Synthetic Control Prediction</h2><span id='topic+summary.scdataMulti'></span>

<h3>Description</h3>

<p>The summary method for synthetic control prediction objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdataMulti'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.scdataMulti_+3A_object">object</code></td>
<td>
<p>Class &quot;scdataMulti&quot; object, obtained by calling <code><a href="#topic+scdataMulti">scdataMulti</a></code>.</p>
</td></tr>
<tr><td><code id="summary.scdataMulti_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to summarize <code><a href="#topic+scdataMulti">scdataMulti</a></code> results.
</p>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scdataMulti">scdataMulti</a></code>
</p>
<p>Supported methods: <code><a href="#topic+print.scdataMulti">print.scdataMulti</a></code>, <code><a href="#topic+summary.scdataMulti">summary.scdataMulti</a></code>.
</p>

<hr>
<h2 id='summary.scest'>Summary Method for Synthetic Control Prediction</h2><span id='topic+summary.scest'></span>

<h3>Description</h3>

<p>The summary method for synthetic control prediction fitted objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scest'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.scest_+3A_object">object</code></td>
<td>
<p>Class &quot;scest&quot; object, obtained by calling <code><a href="#topic+scest">scest</a></code>.</p>
</td></tr>
<tr><td><code id="summary.scest_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to summarize <code><a href="#topic+scest">scest</a></code> results.
</p>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scest">scest</a></code>
</p>
<p>Supported methods: <code><a href="#topic+print.scest">print.scest</a></code>, <code><a href="#topic+summary.scest">summary.scest</a></code>, <code><a href="#topic+coef.scest">coef.scest</a></code>.
</p>

<hr>
<h2 id='summary.scpi'>Summary Method for Synthetic Control Inference</h2><span id='topic+summary.scpi'></span>

<h3>Description</h3>

<p>The summary method for synthetic control inference objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scpi'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.scpi_+3A_object">object</code></td>
<td>
<p>Class &quot;scpi&quot; object, obtained by calling <code><a href="#topic+scpi">scpi</a></code>.</p>
</td></tr>
<tr><td><code id="summary.scpi_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to summarize <code><a href="#topic+scpi">scpi</a></code> results.
</p>


<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scpi">scpi</a></code>
</p>
<p>Supported methods: <code><a href="#topic+print.scpi">print.scpi</a></code>, <code><a href="#topic+summary.scpi">summary.scpi</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
