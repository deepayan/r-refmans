<!DOCTYPE html><html lang="en-US"><head><title>Help for package covdepGE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {covdepGE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#covdepGE-package'><p>covdepGE: Covariate Dependent Graph Estimation</p></a></li>
<li><a href='#covdepGE'><p>Covariate Dependent Graph Estimation</p></a></li>
<li><a href='#generateData'><p>Generate Covariate-Dependent Data</p></a></li>
<li><a href='#inclusionCurve'><p>Plot PIP as a Function of Index</p></a></li>
<li><a href='#matViz'><p>Visualize a matrix</p></a></li>
<li><a href='#plot.covdepGE'><p>Plot the Graphs Estimated by <code>covdepGE</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Covariate Dependent Graph Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-16</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JacobHelwig/covdepGE/issues">https://github.com/JacobHelwig/covdepGE/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JacobHelwig/covdepGE">https://github.com/JacobHelwig/covdepGE</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A covariate-dependent approach to Gaussian graphical modeling as described in Dasgupta et al. (2022). Employs a novel weighted pseudo-likelihood approach to model the conditional dependence structure of data as a continuous function of an extraneous covariate. The main function, covdepGE::covdepGE(), estimates a graphical representation of the conditional dependence structure via a block mean-field variational approximation, while several auxiliary functions (inclusionCurve(), matViz(), and plot.covdepGE()) are included for visualizing the resulting estimates. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, foreach, ggplot2, glmnet, latex2exp, MASS,
parallel, Rcpp, reshape2, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), covr, vdiffr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-16 15:25:55 UTC; jacob.a.helwig</td>
</tr>
<tr>
<td>Author:</td>
<td>Jacob Helwig [cre, aut],
  Sutanoy Dasgupta [aut],
  Peng Zhao [aut],
  Bani Mallick [aut],
  Debdeep Pati [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jacob Helwig &lt;jacob.a.helwig@tamu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-16 15:56:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='covdepGE-package'>covdepGE: Covariate Dependent Graph Estimation</h2><span id='topic+covdepGE-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>A covariate-dependent approach to Gaussian graphical modeling as described in Dasgupta et al. (2022). Employs a novel weighted pseudo-likelihood approach to model the conditional dependence structure of data as a continuous function of an extraneous covariate. The main function, covdepGE::covdepGE(), estimates a graphical representation of the conditional dependence structure via a block mean-field variational approximation, while several auxiliary functions (inclusionCurve(), matViz(), and plot.covdepGE()) are included for visualizing the resulting estimates.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jacob Helwig <a href="mailto:jacob.a.helwig@tamu.edu">jacob.a.helwig@tamu.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Sutanoy Dasgupta <a href="mailto:sutanoy@stat.tamu.edu">sutanoy@stat.tamu.edu</a>
</p>
</li>
<li><p> Peng Zhao <a href="mailto:pzhao@stat.tamu.edu">pzhao@stat.tamu.edu</a>
</p>
</li>
<li><p> Bani Mallick <a href="mailto:bmallick@stat.tamu.edu">bmallick@stat.tamu.edu</a>
</p>
</li>
<li><p> Debdeep Pati <a href="mailto:debdeep@stat.tamu.edu">debdeep@stat.tamu.edu</a>
</p>
</li></ul>



<h3>References</h3>

<p>(1) Sutanoy Dasgupta, Peng Zhao, Prasenjit Ghosh, Debdeep Pati, and Bani
Mallick. An approximate Bayesian approach to covariate-dependent graphical
modeling. pages 1–59, 2022.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/JacobHelwig/covdepGE">https://github.com/JacobHelwig/covdepGE</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/JacobHelwig/covdepGE/issues">https://github.com/JacobHelwig/covdepGE/issues</a>
</p>
</li></ul>


<hr>
<h2 id='covdepGE'>Covariate Dependent Graph Estimation</h2><span id='topic+covdepGE'></span><span id='topic+covdepGE-method'></span>

<h3>Description</h3>

<p>Model the conditional dependence structure of <code>X</code> as a function
of <code>Z</code> as described in (1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covdepGE(
  X,
  Z = NULL,
  hp_method = "hybrid",
  ssq = NULL,
  sbsq = NULL,
  pip = NULL,
  nssq = 5,
  nsbsq = 5,
  npip = 5,
  ssq_mult = 1.5,
  ssq_lower = 1e-05,
  snr_upper = 25,
  sbsq_lower = 1e-05,
  pip_lower = 1e-05,
  pip_upper = NULL,
  tau = NULL,
  norm = 2,
  center_X = TRUE,
  scale_Z = TRUE,
  alpha_tol = 1e-05,
  max_iter_grid = 10,
  max_iter = 100,
  edge_threshold = 0.5,
  sym_method = "mean",
  parallel = FALSE,
  num_workers = NULL,
  prog_bar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covdepGE_+3A_x">X</code></td>
<td>
<p><code class="reqn">n \times p</code> numeric matrix; data matrix. For best
results, <code class="reqn">n</code> should be greater than <code class="reqn">p</code></p>
</td></tr>
<tr><td><code id="covdepGE_+3A_z">Z</code></td>
<td>
<p><code>NULL</code> OR <code class="reqn">n \times q</code> numeric matrix; extraneous
covariates. If <code>NULL</code>, <code>Z</code> will be treated as constant for all observations,
i.e.:
</p>
<div class="sourceCode"><pre>Z &lt;- rep(0, nrow(X))
</pre></div>
<p>If <code>Z</code> is constant, the estimated graph will be homogeneous throughout the
data. <code>NULL</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_hp_method">hp_method</code></td>
<td>
<p><code>character</code> in <code>c("grid_search","model_average","hybrid")</code>;
method for selecting hyperparameters from the the hyperparameter grid. The
grid will be generated as the Cartesian product of <code>ssq</code>, <code>sbsq</code>, and <code>pip</code>.
Fix <code class="reqn">X_j</code>, the <code class="reqn">j</code>-th column of <code>X</code>, as the response; then, the
hyperparameters will be selected as follows:
</p>

<ul>
<li><p> If <code>"grid_search"</code>, the point in the hyperparameter grid that
maximizes the total ELBO summed across all <code class="reqn">n</code> regressions will be
selected
</p>
</li>
<li><p> If <code>"model_average"</code>, then all posterior quantities will be an
average of the variational estimates resulting from the model fit for each
point in the hyperparameter grid. The unnormalized averaging weights for
each of the <code class="reqn">n</code> regressions are the exponentiated ELBO
</p>
</li>
<li><p> If <code>"hybrid"</code>, then models will be averaged over <code>pip</code> as in
<code>"model_average"</code>, with <code class="reqn">\sigma^2</code> and
<code class="reqn">\sigma_\beta^2</code> chosen for each <code class="reqn">\pi</code> in <code>pip</code>
by maximizing the total ELBO over the grid defined by the Cartesian
product of <code>ssq</code> and <code>sbsq</code> as in <code>"grid_search"</code>
</p>
</li></ul>

<p><code>"hybrid"</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_ssq">ssq</code></td>
<td>
<p><code>NULL</code> OR numeric vector with positive entries; candidate values
of the hyperparameter <code class="reqn">\sigma^2</code> (prior residual variance). If
<code>NULL</code>, <code>ssq</code> will be generated for each variable <code class="reqn">X_j</code> fixed as the
response as:
</p>
<div class="sourceCode"><pre>ssq &lt;- seq(ssq_lower, ssq_upper, length.out = nssq)
</pre></div>
<p><code>NULL</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_sbsq">sbsq</code></td>
<td>
<p><code>NULL</code> OR numeric vector with positive entries; candidate values
of the hyperparameter <code class="reqn">\sigma_\beta^2</code> (prior slab
variance). If <code>NULL</code>, <code>sbsq</code> will be generated for each variable
<code class="reqn">X_j</code> fixed as the response as:
</p>
<div class="sourceCode"><pre>sbsq &lt;- seq(sbsq_lower, sbsq_upper, length.out = nsbsq)
</pre></div>
<p><code>NULL</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_pip">pip</code></td>
<td>
<p><code>NULL</code> OR numeric vector with entries in <code class="reqn">(0, 1)</code>; candidate
values of the hyperparameter <code class="reqn">\pi</code> (prior inclusion probability). If
<code>NULL</code>, <code>pip</code> will be generated for each variable <code class="reqn">X_j</code> fixed as the
response as:
</p>
<div class="sourceCode"><pre>pip &lt;- seq(pip_lower, pi_upper, length.out = npip)
</pre></div>
<p><code>NULL</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_nssq">nssq</code></td>
<td>
<p>positive integer; number of points to generate for <code>ssq</code> if
<code>ssq</code> is <code>NULL</code>. <code>5</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_nsbsq">nsbsq</code></td>
<td>
<p>positive integer; number of points to generate for <code>sbsq</code> if
<code>sbsq</code> is <code>NULL</code>. <code>5</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_npip">npip</code></td>
<td>
<p>positive integer; number of points to generate for <code>pip</code> if <code>pip</code>
is <code>NULL</code>. <code>5</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_ssq_mult">ssq_mult</code></td>
<td>
<p>positive numeric; if <code>ssq</code> is <code>NULL</code>, then for each variable
<code class="reqn">X_j</code> fixed as the response:
</p>
<div class="sourceCode"><pre>ssq_upper &lt;- ssq_mult * stats::var(X_j)
</pre></div>
<p>Then, <code>ssq_upper</code> will be the greatest value in <code>ssq</code> for variable
<code class="reqn">X_j</code>. <code>1.5</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_ssq_lower">ssq_lower</code></td>
<td>
<p>positive numeric; if <code>ssq</code> is <code>NULL</code>, then <code>ssq_lower</code> will
be the least value in <code>ssq</code>. <code>1e-5</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_snr_upper">snr_upper</code></td>
<td>
<p>positive numeric; upper bound on the signal-to-noise ratio.
If <code>sbsq</code> is <code>NULL</code>, then for each variable <code class="reqn">X_j</code> fixed as the
response:
</p>
<div class="sourceCode"><pre>s2_sum &lt;- sum(apply(X, 2, stats::var))
sbsq_upper &lt;- snr_upper / (pip_upper * s2_sum)
</pre></div>
<p>Then, <code>sbsq_upper</code> will be the greatest value in <code>sbsq</code>. <code>25</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_sbsq_lower">sbsq_lower</code></td>
<td>
<p>positive numeric; if <code>sbsq</code> is <code>NULL</code>, then <code>sbsq_lower</code>
will be the least value in <code>sbsq</code>. <code>1e-5</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_pip_lower">pip_lower</code></td>
<td>
<p>numeric in <code class="reqn">(0, 1)</code>; if <code>pip</code> is <code>NULL</code>, then
<code>pip_lower</code> will be the least value in <code>pip</code>. <code>1e-5</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_pip_upper">pip_upper</code></td>
<td>
<p><code>NULL</code> OR  numeric in <code class="reqn">(0, 1)</code>; if <code>pip</code> is <code>NULL</code>, then
<code>pip_upper</code> will be the greatest value in <code>pip</code>. If <code>sbsq</code> is <code>NULL</code>,
<code>pip_upper</code> will be used to calculate <code>sbsq_upper</code>. If <code>NULL</code>, <code>pip_upper</code>
will be calculated for each variable <code class="reqn">X_j</code> fixed as the response as:
</p>
<div class="sourceCode"><pre>lasso &lt;- glmnet::cv.glmnet(X, X_j)
non0 &lt;- sum(glmnet::coef.glmnet(lasso, s = "lambda.1se")[-1] != 0)
non0 &lt;- min(max(non0, 1), p - 1)
pip_upper &lt;- non0 / p
</pre></div>
<p><code>NULL</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_tau">tau</code></td>
<td>
<p><code>NULL</code> OR positive numeric OR numeric vector of length <code class="reqn">n</code>
with positive entries; bandwidth parameter. Greater values allow for more
information to be shared between observations. Allows for global or
observation-specific specification. If <code>NULL</code>, use 2-step KDE methodology as
described in (2) to calculate observation-specific bandwidths. <code>NULL</code> by
default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_norm">norm</code></td>
<td>
<p>numeric in <code class="reqn">[1, \infty]</code>; norm to use when
calculating weights. <code>Inf</code> results in infinity norm. <code>2</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_center_x">center_X</code></td>
<td>
<p>logical; if <code>TRUE</code>, center <code>X</code> column-wise to mean <code class="reqn">0</code>.
<code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_scale_z">scale_Z</code></td>
<td>
<p>logical; if <code>TRUE</code>, center and scale <code>Z</code> column-wise to mean
<code class="reqn">0</code>, standard deviation <code class="reqn">1</code> prior to calculating the weights. <code>TRUE</code>
by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_alpha_tol">alpha_tol</code></td>
<td>
<p>positive numeric; end CAVI when the Frobenius norm of the
change in the alpha matrix is within <code>alpha_tol</code>. <code>1e-5</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_max_iter_grid">max_iter_grid</code></td>
<td>
<p>positive integer; if tolerance criteria has not been
met by <code>max_iter_grid</code> iterations during grid search, end CAVI. After grid
search has completed, CAVI is performed with the final hyperparameters
selected by grid search for at most <code>max_iter</code> iterations. Does not apply to
<code>hp_method = "model_average"</code>. <code>10</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_max_iter">max_iter</code></td>
<td>
<p>positive integer; if tolerance criteria has not been met by
<code>max_iter</code> iterations, end CAVI. <code>100</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_edge_threshold">edge_threshold</code></td>
<td>
<p>numeric in <code class="reqn">(0, 1)</code>; a graph for each observation
will be constructed by including an edge between variable <code class="reqn">i</code> and
variable <code class="reqn">j</code> if, and only if, the <code class="reqn">(i, j)</code> entry of the symmetrized
posterior inclusion probability matrix corresponding to the observation is
greater than <code>edge_threshold</code>. <code>0.5</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_sym_method">sym_method</code></td>
<td>
<p><code>character</code> in <code>c("mean","max","min")</code>; to symmetrize
the posterior inclusion probability matrix for each observation, the
<code class="reqn">(i, j)</code> and <code class="reqn">(j, i)</code> entries will be post-processed as <code>sym_method</code>
applied to the <code class="reqn">(i, j)</code> and <code class="reqn">(j, i)</code> entries. <code>"mean"</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_parallel">parallel</code></td>
<td>
<p>logical; if <code>TRUE</code>, hyperparameter selection and CAVI for
each of the <code class="reqn">p</code> variables will be performed in parallel using <code>foreach</code>.
Parallel backend may be registered prior to making a call to <code>covdepGE</code>. If
no active parallel backend can be detected, then parallel backend will be
automatically registered using:
</p>
<div class="sourceCode"><pre>doParallel::registerDoParallel(num_workers)
</pre></div>
<p><code>FALSE</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_num_workers">num_workers</code></td>
<td>
<p><code>NULL</code> OR positive integer less than or equal to
<code>parallel::detectCores()</code>; argument to <code>doParallel::registerDoParallel</code> if
<code>parallel = TRUE</code> and no parallel backend is detected. If <code>NULL</code>, then:
</p>
<div class="sourceCode"><pre>num_workers &lt;- floor(parallel::detectCores() / 2)
</pre></div>
<p><code>NULL</code> by default</p>
</td></tr>
<tr><td><code id="covdepGE_+3A_prog_bar">prog_bar</code></td>
<td>
<p>logical; if <code>TRUE</code>, then a progress bar will be displayed
denoting the number of remaining variables to fix as the response and perform
CAVI. If <code>parallel</code>, no progress bar will be displayed. <code>TRUE</code> by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns object of class <code>covdepGE</code> with the following values:
</p>
<table role = "presentation">
<tr><td><code>graphs</code></td>
<td>
<p>list with the following values:
</p>

<ul>
<li> <p><code>graphs</code>: list of <code class="reqn">n</code> numeric matrices of dimension
<code class="reqn">p \times p</code>; the <code class="reqn">l</code>-th matrix is the adjacency matrix
for the <code class="reqn">l</code>-th observation
</p>
</li>
<li> <p><code>unique_graphs</code>: list; the <code class="reqn">l</code>-th element is a list containing
the <code class="reqn">l</code>-th unique graph and the indices of the observation(s)
corresponding to this graph
</p>
</li>
<li> <p><code>inclusion_probs_sym</code>: list of <code class="reqn">n</code> numeric matrices of
dimension <code class="reqn">p \times p</code>; the <code class="reqn">l</code>-th matrix is the
symmetrized posterior inclusion probability matrix for the <code class="reqn">l</code>-th
observation
</p>
</li>
<li> <p><code>inclusion_probs_asym</code>: list of <code class="reqn">n</code> numeric matrices of
dimension <code class="reqn">p \times p</code>; the <code class="reqn">l</code>-th matrix is the
posterior inclusion probability matrix for the <code class="reqn">l</code>-th observation
prior to symmetrization
</p>
</li></ul>

</td></tr>
<tr><td><code>variational_params</code></td>
<td>
<p>list with the following values:
</p>

<ul>
<li> <p><code>alpha</code>: list of <code class="reqn">p</code> numeric matrices of dimension
<code class="reqn">n \times (p - 1)</code>; the <code class="reqn">(i, j)</code> entry of the
<code class="reqn">k</code>-th matrix is the variational approximation to the posterior
inclusion probability of the <code class="reqn">j</code>-th variable in a weighted
regression with variable <code class="reqn">k</code> fixed as the response, where the
weights are taken with respect to observation <code class="reqn">i</code>
</p>
</li>
<li> <p><code>mu</code>: list of <code class="reqn">p</code> numeric matrices of dimension
<code class="reqn">n \times (p - 1)</code>; the <code class="reqn">(i, j)</code> entry of the
<code class="reqn">k</code>-th matrix is the variational approximation to the posterior slab
mean for the <code class="reqn">j</code>-th variable in a weighted regression with variable
<code class="reqn">k</code> fixed as the response, where the weights are taken with respect
to observation <code class="reqn">i</code>
</p>
</li>
<li> <p><code>ssq_var</code>: list of <code class="reqn">p</code> numeric
matrices of dimension <code class="reqn">n \times (p - 1)</code>; the
<code class="reqn">(i, j)</code> entry of the <code class="reqn">k</code>-th matrix is the variational
approximation to the posterior slab variance for the <code class="reqn">j</code>-th variable
in a weighted regression with variable <code class="reqn">k</code> fixed as the response,
where the weights are taken with respect to observation <code class="reqn">i</code>
</p>
</li></ul>

</td></tr>
<tr><td><code>hyperparameters</code></td>
<td>
<p>list of <code class="reqn">p</code> lists; the <code class="reqn">j</code>-th list has the
following values for variable <code class="reqn">j</code> fixed as the response:
</p>

<ul>
<li> <p><code>grid</code>: matrix of candidate hyperparameter values, corresponding
ELBO, and iterations to converge
</p>
</li>
<li> <p><code>final</code>: the final hyperparameters chosen by grid search and the
ELBO and iterations to converge for these hyperparameters
</p>
</li></ul>

</td></tr>
<tr><td><code>model_details</code></td>
<td>
<p>list with the following values:
</p>

<ul>
<li> <p><code>elapsed</code>: amount of time to fit the model
</p>
</li>
<li> <p><code>n</code>: number of observations
</p>
</li>
<li> <p><code>p</code>: number of variables
</p>
</li>
<li> <p><code>ELBO</code>: ELBO summed across all observations and variables. If
<code>hp_method</code> is <code>"model_average"</code> or <code>"hybrid"</code>, this ELBO is averaged
across the hyperparameter grid using the model averaging weights for
each variable
</p>
</li>
<li> <p><code>num_unique</code>: number of unique graphs
</p>
</li>
<li> <p><code>grid_size</code>: number of points in the hyperparameter grid
</p>
</li>
<li> <p><code>args</code>: list containing all passed arguments of length <code class="reqn">1</code>
</p>
</li></ul>

</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>list with the following values:
</p>

<ul>
<li> <p><code>weights</code>: <code class="reqn">n\times n</code> numeric matrix. The <code class="reqn">(i, j)</code>
entry is the similarity weight of the <code class="reqn">i</code>-th observation with
respect to the <code class="reqn">j</code>-th observation using the <code class="reqn">j</code>-th observation's
bandwidth
</p>
</li>
<li> <p><code>bandwidths</code>: numeric vector of length <code class="reqn">n</code>. The <code class="reqn">i</code>-th
entry is the bandwidth for the <code class="reqn">i</code>-th observation
</p>
</li></ul>

</td></tr>
</table>


<h3>References</h3>

<p>(1) Sutanoy Dasgupta, Peng Zhao, Prasenjit Ghosh, Debdeep Pati, and Bani
Mallick. An approximate Bayesian approach to covariate-dependent graphical
modeling. pages 1–59, 2022.
</p>
<p>(2) Sutanoy Dasgupta, Debdeep Pati, and Anuj Srivastava. A Two-Step Geometric
Framework For Density Modeling. <em>Statistica Sinica</em>, 30(4):2155–2177, 2020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ggplot2)

# get the data
set.seed(12)
data &lt;- generateData()
X &lt;- data$X
Z &lt;- data$Z
interval &lt;- data$interval
prec &lt;- data$true_precision

# get overall and within interval sample sizes
n &lt;- nrow(X)
n1 &lt;- sum(interval == 1)
n2 &lt;- sum(interval == 2)
n3 &lt;- sum(interval == 3)

# visualize the distribution of the extraneous covariate
ggplot(data.frame(Z = Z, interval = as.factor(interval))) +
  geom_histogram(aes(Z, fill = interval), color = "black", bins = n %/% 5)

# visualize the true precision matrices in each of the intervals

# interval 1
matViz(prec[[1]], incl_val = TRUE) +
  ggtitle(paste0("True precision matrix, interval 1, observations 1,...,", n1))

# interval 2 (varies continuously with Z)
cat("\nInterval 2, observations ", n1 + 1, ",...,", n1 + n2, sep = "")
int2_mats &lt;- prec[interval == 2]
int2_inds &lt;- c(5, n2 %/% 2, n2 - 5)
lapply(int2_inds, function(j) matViz(int2_mats[[j]], incl_val = TRUE) +
         ggtitle(paste("True precision matrix, interval 2, observation", j + n1)))

# interval 3
matViz(prec[[length(prec)]], incl_val = TRUE) +
  ggtitle(paste0("True precision matrix, interval 3, observations ",
                 n1 + n2 + 1, ",...,", n1 + n2 + n3))

# fit the model and visualize the estimated graphs
(out &lt;- covdepGE(X, Z))
plot(out)

# visualize the posterior inclusion probabilities for variables (1, 3) and (1, 2)
inclusionCurve(out, 1, 2)
inclusionCurve(out, 1, 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='generateData'>Generate Covariate-Dependent Data</h2><span id='topic+generateData'></span>

<h3>Description</h3>

<p>Generate a <code class="reqn">1</code>-dimensional extraneous covariate
and <code class="reqn">p</code>-dimensional Gaussian data with a precision matrix that varies as
a continuous function of the extraneous covariate. This data is distributed
similar to that used in the simulation study from (1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateData(p = 5, n1 = 60, n2 = 60, n3 = 60, Z = NULL, true_precision = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateData_+3A_p">p</code></td>
<td>
<p>positive integer; number of variables in the data matrix. <code>5</code> by
default</p>
</td></tr>
<tr><td><code id="generateData_+3A_n1">n1</code></td>
<td>
<p>positive integer; number of observations in the first interval.
<code>60</code> by default</p>
</td></tr>
<tr><td><code id="generateData_+3A_n2">n2</code></td>
<td>
<p>positive integer; number of observations in the second interval.
<code>60</code> by default</p>
</td></tr>
<tr><td><code id="generateData_+3A_n3">n3</code></td>
<td>
<p>positive integer; number of observations in the third interval.
<code>60</code> by default</p>
</td></tr>
<tr><td><code id="generateData_+3A_z">Z</code></td>
<td>
<p><code>NULL</code> or numeric vector; extraneous covariate values for each
observation. If <code>NULL</code>, <code>Z</code> will be generated from a uniform distribution on
each of the intervals</p>
</td></tr>
<tr><td><code id="generateData_+3A_true_precision">true_precision</code></td>
<td>
<p><code>NULL</code> OR list of matrices of dimension
<code class="reqn">p \times p</code>; true precision matrix for each observation. If
<code>NULL</code>, the true precision matrices will be generated dependent on <code>Z</code>.
<code>NULL</code> by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list with the following values:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>a <code>(n1 + n2 + n3)</code> <code class="reqn">\times p</code> numeric matrix, where
the <code class="reqn">i</code>-th row is drawn from a <code class="reqn">p</code>-dimensional Gaussian with mean
<code class="reqn">0</code> and precision matrix <code>true_precision[[i]]</code></p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>a <code>(n1 + n2 + n3)</code> <code class="reqn">\times 1</code> numeric matrix, where
the <code class="reqn">i</code>-th entry is the extraneous covariate <code class="reqn">z_i</code> for
observation <code class="reqn">i</code></p>
</td></tr>
<tr><td><code>true_precision</code></td>
<td>
<p>list of <code>n1 + n2 + n3</code> matrices of dimension
<code class="reqn">p \times p</code>; the <code class="reqn">i</code>-th matrix is the precision matrix for
the <code class="reqn">i</code>-th observation</p>
</td></tr>
<tr><td><code>interval</code></td>
<td>
<p>vector of length <code>n1 + n2 + n3</code>; interval assignments
for each of the observations, where the <code class="reqn">i</code>-th entry is the interval
assignment for the <code class="reqn">i</code>-th observation</p>
</td></tr>
</table>


<h3>Extraneous Covariate</h3>

<p>If <code>Z = NULL</code>, then the generation of <code>Z</code> is as follows:
</p>
<p>The first <code>n1</code> observations have <code class="reqn">z_i</code> from from a uniform
distribution on the interval <code class="reqn">(-3, -1)</code> (the first interval).
</p>
<p>Observations <code>n1 + 1</code> to <code>n1 + n2</code> have <code class="reqn">z_i</code> from from a uniform
distribution on the interval <code class="reqn">(-1, 1)</code> (the second interval).
</p>
<p>Observations <code>n1 + n2 + 1</code> to <code>n1 + n2 + n3</code> have <code class="reqn">z_i</code> from a
uniform distribution on the interval <code class="reqn">(1, 3)</code> (the third interval).
</p>


<h3>Precision Matrices</h3>

<p>If <code>true_precision = NULL</code>, then the generation of the true precision
matrices is as follows:
</p>
<p>All precision matrices have <code class="reqn">2</code> on the diagonal and <code class="reqn">1</code> in the
<code class="reqn">(2, 3)/ (3, 2)</code> positions.
</p>
<p>Observations in the first interval have a <code class="reqn">1</code> in the
<code class="reqn">(1, 2) / (1, 2)</code> positions, while observations in the third interval
have a <code class="reqn">1</code> in the <code class="reqn">(1, 3)/ (3, 1)</code> positions.
</p>
<p>Observations in the second interval have <code class="reqn">2</code> entries that vary as a
linear function of their extraneous covariate. Let
<code class="reqn">\beta = 1/2</code>. Then, the <code class="reqn">(1, 2)/(2, 1)</code> positions for
the <code class="reqn">i</code>-th observation in the second interval are
<code class="reqn">\beta\cdot(1 - z_i)</code>, while the <code class="reqn">(1, 3)/ (3, 1)</code>
entries are <code class="reqn">\beta\cdot(1 + z_i)</code>.
</p>
<p>Thus, as <code class="reqn">z_i</code> approaches <code class="reqn">-1</code> from the right, the associated
precision matrix becomes more similar to the matrix for observations in the
first interval. Similarly, as <code class="reqn">z_i</code> approaches <code class="reqn">1</code> from the left,
the matrix becomes more similar to the matrix for observations in the third
interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ggplot2)

# get the data
set.seed(12)
data &lt;- generateData()
X &lt;- data$X
Z &lt;- data$Z
interval &lt;- data$interval
prec &lt;- data$true_precision

# get overall and within interval sample sizes
n &lt;- nrow(X)
n1 &lt;- sum(interval == 1)
n2 &lt;- sum(interval == 2)
n3 &lt;- sum(interval == 3)

# visualize the distribution of the extraneous covariate
ggplot(data.frame(Z = Z, interval = as.factor(interval))) +
  geom_histogram(aes(Z, fill = interval), color = "black", bins = n %/% 5)

# visualize the true precision matrices in each of the intervals

# interval 1
matViz(prec[[1]], incl_val = TRUE) +
  ggtitle(paste0("True precision matrix, interval 1, observations 1,...,", n1))

# interval 2 (varies continuously with Z)
cat("\nInterval 2, observations ", n1 + 1, ",...,", n1 + n2, sep = "")
int2_mats &lt;- prec[interval == 2]
int2_inds &lt;- c(5, n2 %/% 2, n2 - 5)
lapply(int2_inds, function(j) matViz(int2_mats[[j]], incl_val = TRUE) +
         ggtitle(paste("True precision matrix, interval 2, observation", j + n1)))

# interval 3
matViz(prec[[length(prec)]], incl_val = TRUE) +
  ggtitle(paste0("True precision matrix, interval 3, observations ",
                 n1 + n2 + 1, ",...,", n1 + n2 + n3))

# fit the model and visualize the estimated graphs
(out &lt;- covdepGE(X, Z))
plot(out)

# visualize the posterior inclusion probabilities for variables (1, 3) and (1, 2)
inclusionCurve(out, 1, 2)
inclusionCurve(out, 1, 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='inclusionCurve'>Plot PIP as a Function of Index</h2><span id='topic+inclusionCurve'></span>

<h3>Description</h3>

<p>Plot the posterior inclusion probability of an edge between two
variables as a function of observation index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inclusionCurve(
  out,
  col_idx1,
  col_idx2,
  line_type = "solid",
  line_size = 0.5,
  line_color = "black",
  point_shape = 21,
  point_size = 1.5,
  point_color = "#500000",
  point_fill = "white"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inclusionCurve_+3A_out">out</code></td>
<td>
<p>object of class <code>covdepGE</code>; return of <code>covdepGE</code> function</p>
</td></tr>
<tr><td><code id="inclusionCurve_+3A_col_idx1">col_idx1</code></td>
<td>
<p>integer in <code class="reqn">[1, p]</code>; column index of the first variable</p>
</td></tr>
<tr><td><code id="inclusionCurve_+3A_col_idx2">col_idx2</code></td>
<td>
<p>integer in <code class="reqn">[1, p]</code>; column index of the second variable</p>
</td></tr>
<tr><td><code id="inclusionCurve_+3A_line_type">line_type</code></td>
<td>
<p>linetype; <code>ggplot2</code> line type to interpolate the
probabilities. <code>"solid"</code> by default</p>
</td></tr>
<tr><td><code id="inclusionCurve_+3A_line_size">line_size</code></td>
<td>
<p>positive numeric; thickness of the interpolating line.
<code>0.5</code> by default</p>
</td></tr>
<tr><td><code id="inclusionCurve_+3A_line_color">line_color</code></td>
<td>
<p>color; color of interpolating line. <code>"black"</code> by default</p>
</td></tr>
<tr><td><code id="inclusionCurve_+3A_point_shape">point_shape</code></td>
<td>
<p>shape; shape of the points denoting observation-specific
inclusion probabilities; <code>21</code> by default</p>
</td></tr>
<tr><td><code id="inclusionCurve_+3A_point_size">point_size</code></td>
<td>
<p>positive numeric; size of probability points. <code>1.5</code> by
default</p>
</td></tr>
<tr><td><code id="inclusionCurve_+3A_point_color">point_color</code></td>
<td>
<p>color; color of probability points. <code>"#500000"</code> by default</p>
</td></tr>
<tr><td><code id="inclusionCurve_+3A_point_fill">point_fill</code></td>
<td>
<p>color; fill of probability points. Only applies to select
shapes. <code>"white"</code> by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>ggplot2</code> visualization of inclusion probability curve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ggplot2)

# get the data
set.seed(12)
data &lt;- generateData()
X &lt;- data$X
Z &lt;- data$Z
interval &lt;- data$interval
prec &lt;- data$true_precision

# get overall and within interval sample sizes
n &lt;- nrow(X)
n1 &lt;- sum(interval == 1)
n2 &lt;- sum(interval == 2)
n3 &lt;- sum(interval == 3)

# visualize the distribution of the extraneous covariate
ggplot(data.frame(Z = Z, interval = as.factor(interval))) +
  geom_histogram(aes(Z, fill = interval), color = "black", bins = n %/% 5)

# visualize the true precision matrices in each of the intervals

# interval 1
matViz(prec[[1]], incl_val = TRUE) +
  ggtitle(paste0("True precision matrix, interval 1, observations 1,...,", n1))

# interval 2 (varies continuously with Z)
cat("\nInterval 2, observations ", n1 + 1, ",...,", n1 + n2, sep = "")
int2_mats &lt;- prec[interval == 2]
int2_inds &lt;- c(5, n2 %/% 2, n2 - 5)
lapply(int2_inds, function(j) matViz(int2_mats[[j]], incl_val = TRUE) +
         ggtitle(paste("True precision matrix, interval 2, observation", j + n1)))

# interval 3
matViz(prec[[length(prec)]], incl_val = TRUE) +
  ggtitle(paste0("True precision matrix, interval 3, observations ",
                 n1 + n2 + 1, ",...,", n1 + n2 + n3))

# fit the model and visualize the estimated graphs
(out &lt;- covdepGE(X, Z))
plot(out)

# visualize the posterior inclusion probabilities for variables (1, 3) and (1, 2)
inclusionCurve(out, 1, 2)
inclusionCurve(out, 1, 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='matViz'>Visualize a matrix</h2><span id='topic+matViz'></span>

<h3>Description</h3>

<p>Create a visualization of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matViz(
  x,
  color1 = "white",
  color2 = "#500000",
  grid_color = "black",
  incl_val = FALSE,
  prec = 2,
  font_size = 3,
  font_color1 = "black",
  font_color2 = "white",
  font_thres = mean(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matViz_+3A_x">x</code></td>
<td>
<p>matrix; matrix to be visualized</p>
</td></tr>
<tr><td><code id="matViz_+3A_color1">color1</code></td>
<td>
<p>color; color for low entries. <code>"white"</code> by default</p>
</td></tr>
<tr><td><code id="matViz_+3A_color2">color2</code></td>
<td>
<p>color; color for high entries. <code>"#500000"</code> by default</p>
</td></tr>
<tr><td><code id="matViz_+3A_grid_color">grid_color</code></td>
<td>
<p>color; color of grid lines. <code>"black"</code> by default</p>
</td></tr>
<tr><td><code id="matViz_+3A_incl_val">incl_val</code></td>
<td>
<p>logical; if <code>TRUE</code>, the value for each entry will be
displayed. <code>FALSE</code> by default</p>
</td></tr>
<tr><td><code id="matViz_+3A_prec">prec</code></td>
<td>
<p>positive integer; number of decimal places to round entries to if
<code>incl_val</code> is <code>TRUE</code>. <code>2</code> by default</p>
</td></tr>
<tr><td><code id="matViz_+3A_font_size">font_size</code></td>
<td>
<p>positive numeric; size of font if <code>incl_val</code> is <code>TRUE</code>. <code>3</code>
by default</p>
</td></tr>
<tr><td><code id="matViz_+3A_font_color1">font_color1</code></td>
<td>
<p>color; color of font for low entries if <code>incl_val</code> is
<code>TRUE</code>. <code>"black"</code> by default</p>
</td></tr>
<tr><td><code id="matViz_+3A_font_color2">font_color2</code></td>
<td>
<p>color; color of font for high entries if <code>incl_val</code> is
<code>TRUE</code>. <code>"white"</code> by default</p>
</td></tr>
<tr><td><code id="matViz_+3A_font_thres">font_thres</code></td>
<td>
<p>numeric; values less than <code>font_thres</code> will be displayed
in <code>font_color1</code> if <code>incl_val</code> is <code>TRUE</code>. <code>mean(x)</code> by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>ggplot2</code> visualization of matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ggplot2)

# get the data
set.seed(12)
data &lt;- generateData()
X &lt;- data$X
Z &lt;- data$Z
interval &lt;- data$interval
prec &lt;- data$true_precision

# get overall and within interval sample sizes
n &lt;- nrow(X)
n1 &lt;- sum(interval == 1)
n2 &lt;- sum(interval == 2)
n3 &lt;- sum(interval == 3)

# visualize the distribution of the extraneous covariate
ggplot(data.frame(Z = Z, interval = as.factor(interval))) +
  geom_histogram(aes(Z, fill = interval), color = "black", bins = n %/% 5)

# visualize the true precision matrices in each of the intervals

# interval 1
matViz(prec[[1]], incl_val = TRUE) +
  ggtitle(paste0("True precision matrix, interval 1, observations 1,...,", n1))

# interval 2 (varies continuously with Z)
cat("\nInterval 2, observations ", n1 + 1, ",...,", n1 + n2, sep = "")
int2_mats &lt;- prec[interval == 2]
int2_inds &lt;- c(5, n2 %/% 2, n2 - 5)
lapply(int2_inds, function(j) matViz(int2_mats[[j]], incl_val = TRUE) +
         ggtitle(paste("True precision matrix, interval 2, observation", j + n1)))

# interval 3
matViz(prec[[length(prec)]], incl_val = TRUE) +
  ggtitle(paste0("True precision matrix, interval 3, observations ",
                 n1 + n2 + 1, ",...,", n1 + n2 + n3))

# fit the model and visualize the estimated graphs
(out &lt;- covdepGE(X, Z))
plot(out)

# visualize the posterior inclusion probabilities for variables (1, 3) and (1, 2)
inclusionCurve(out, 1, 2)
inclusionCurve(out, 1, 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.covdepGE'>Plot the Graphs Estimated by <code>covdepGE</code></h2><span id='topic+plot.covdepGE'></span>

<h3>Description</h3>

<p>Create a list of the unique graphs estimated by <code>covdepGE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covdepGE'
plot(x, graph_colors = NULL, title_sum = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.covdepGE_+3A_x">x</code></td>
<td>
<p>object of class <code>covdepGE</code>; return of <code>covdepGE</code> function</p>
</td></tr>
<tr><td><code id="plot.covdepGE_+3A_graph_colors">graph_colors</code></td>
<td>
<p><code>NULL</code> OR vector; the <code class="reqn">j</code>-th element is the color for
the <code class="reqn">j</code>-th graph. If <code>NULL</code>, all graphs will be colored with <code>"#500000"</code>.
<code>NULL</code> by default</p>
</td></tr>
<tr><td><code id="plot.covdepGE_+3A_title_sum">title_sum</code></td>
<td>
<p>logical; if <code>TRUE</code> the indices of the observations
corresponding to the graph will be included in the title. <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot.covdepGE_+3A_...">...</code></td>
<td>
<p>additional arguments will be ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of <code>ggplot2</code> visualizations of unique graphs estimated
by <code>covdepGE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ggplot2)

# get the data
set.seed(12)
data &lt;- generateData()
X &lt;- data$X
Z &lt;- data$Z
interval &lt;- data$interval
prec &lt;- data$true_precision

# get overall and within interval sample sizes
n &lt;- nrow(X)
n1 &lt;- sum(interval == 1)
n2 &lt;- sum(interval == 2)
n3 &lt;- sum(interval == 3)

# visualize the distribution of the extraneous covariate
ggplot(data.frame(Z = Z, interval = as.factor(interval))) +
  geom_histogram(aes(Z, fill = interval), color = "black", bins = n %/% 5)

# visualize the true precision matrices in each of the intervals

# interval 1
matViz(prec[[1]], incl_val = TRUE) +
  ggtitle(paste0("True precision matrix, interval 1, observations 1,...,", n1))

# interval 2 (varies continuously with Z)
cat("\nInterval 2, observations ", n1 + 1, ",...,", n1 + n2, sep = "")
int2_mats &lt;- prec[interval == 2]
int2_inds &lt;- c(5, n2 %/% 2, n2 - 5)
lapply(int2_inds, function(j) matViz(int2_mats[[j]], incl_val = TRUE) +
         ggtitle(paste("True precision matrix, interval 2, observation", j + n1)))

# interval 3
matViz(prec[[length(prec)]], incl_val = TRUE) +
  ggtitle(paste0("True precision matrix, interval 3, observations ",
                 n1 + n2 + 1, ",...,", n1 + n2 + n3))

# fit the model and visualize the estimated graphs
(out &lt;- covdepGE(X, Z))
plot(out)

# visualize the posterior inclusion probabilities for variables (1, 3) and (1, 2)
inclusionCurve(out, 1, 2)
inclusionCurve(out, 1, 3)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
