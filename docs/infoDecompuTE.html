<!DOCTYPE html><html><head><title>Help for package infoDecompuTE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {infoDecompuTE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#infoDecompuTE-package'><p>Information Decomposition of Two-phase Experiments</p></a></li>
<li><a href='#adjustEffectNames'><p>Adjust the Effects' Names</p></a></li>
<li><a href='#adjustMissingLevels'><p>Adjust the Missing Levels</p></a></li>
<li><a href='#chrisEx1'><p>Randomised Block design consisted of 6 blocks and 3 plots.</p></a></li>
<li><a href='#chrisEx2'><p>Randomised Block design consisted of 8 blocks and 2 plots.</p></a></li>
<li><a href='#chrisEx3'><p>Randomised Block design consisted of 4 blocks and 2 plots.</p></a></li>
<li><a href='#getCoefVC.onePhase'><p>Get Variance Components' Coefficients and Mean Squares for Single-Phase or</p>
Two-Phase Experiments</a></li>
<li><a href='#getCoefVC.twoPhase'><p>Get Variance Components' Coefficients and Mean Squares for Single-Phase or</p>
Two-Phase Experiments</a></li>
<li><a href='#getEffFactor'><p>Construct the Matrix from Information Decomposition and Compute the</p>
Efficiency Factors of Treatment effects</a></li>
<li><a href='#getFixedEF.onePhase'><p>Get the Fixed Components' coefficients and Efficiency Factors of</p>
Single-Phase Experiments.</a></li>
<li><a href='#getFixedEF.twoPhase'><p>Get the Fixed Components' coefficients and Efficiency Factors of</p>
Two-Phase Experiments.</a></li>
<li><a href='#getTrtCoef'><p>Get the Treatment Coefficients</p></a></li>
<li><a href='#getTrtRep'><p>Calculate the Treatment Replication number</p></a></li>
<li><a href='#getVMat.onePhase'><p>Get the Variance Matrices for Single-Phase experiment</p></a></li>
<li><a href='#getVMat.twoPhase'><p>Get the Variance Matrices for Two-Phase experiment</p></a></li>
<li><a href='#identityMat'><p>Identity Matrix</p></a></li>
<li><a href='#infoDecompMat'><p>Construct the Matrix from Information Decomposition</p></a></li>
<li><a href='#invInfMat'><p>Invert the Information Matrix</p></a></li>
<li><a href='#J'><p>Identity Matrix Minus Averaging Matrix</p></a></li>
<li><a href='#K'><p>Averaging Matrix</p></a></li>
<li><a href='#makeBlkDesMat'><p>Construct Block Design Matrix</p></a></li>
<li><a href='#makeContrMat'><p>Make Contrast Matrix</p></a></li>
<li><a href='#makeOrthProjectors'><p>Construct Orthogonal Projector Matrices</p></a></li>
<li><a href='#makeOverDesMat'><p>Construct the Overall Treatment or Block design Matrix</p></a></li>
<li><a href='#projMat'><p>Construct a Projection Matrix</p></a></li>
<li><a href='#summaryAovOnePhase'><p>Summarize an Theoretical Analysis of Variance Model of Single-Phase</p>
Experiments</a></li>
<li><a href='#summaryAovTwoPhase'><p>Summarize an Theoretical Analysis of Variance Model of Two-Phase</p>
Experiments</a></li>
<li><a href='#toLatexTable'><p>Convert the R output to Latex Table</p></a></li>
<li><a href='#tr'><p>Trace of the Matrix</p></a></li>
<li><a href='#unity'><p>Construct a unity vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Information Decomposition of Two-Phase Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-28</td>
</tr>
<tr>
<td>Description:</td>
<td>The main purpose of this package is to generate the structure of the analysis of variance 
            (ANOVA) table of the two-phase experiments. The user only need to input the design and the 
              relationships of the random and fixed factors using the Wilkinson-Rogers' syntax, 
              this package can then quickly generate the structure of the ANOVA table with the 
              coefficients of the variance components for the expected mean squares.
              Thus, the balanced incomplete block design and provides the efficiency
              factors of the fixed effects can also be studied and compared much easily.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kcha193/infoDecompuTE">https://github.com/kcha193/infoDecompuTE</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kcha193/infoDecompuTE/issues">https://github.com/kcha193/infoDecompuTE/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-28 03:49:22 UTC; user</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Chang [aut, cre],
  Katya Ruggiero [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Chang &lt;k.chang@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-28 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='infoDecompuTE-package'>Information Decomposition of Two-phase Experiments</h2><span id='topic+infoDecompuTE-package'></span><span id='topic+infoDecompuTE'></span>

<h3>Description</h3>

<p>he main purpose of this package is to generate the structure of the analysis of variance 
(ANOVA) table of the two-phase experiments. The user only need to input the design and the
relationships of the random and fixed factors using the Wilkinson-Rogers' syntax, 
this package can then quickly generate the structure of the ANOVA table with the 
coefficients of the variance components for the expected mean squares.
Thus, the balanced incomplete block design and provides the efficiency
factors of the fixed effects can also be studied and compared much easily.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> infoDecompuTE</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version:
</td><td style="text-align: left;"> 0.6.1</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2018-05-28</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;= 3) </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Kevin Chang and Katya Ruggiero
</p>
<p>Maintainer: Kevin Chang &lt;k.chang@auckland.ac.nz&gt;
</p>

<hr>
<h2 id='adjustEffectNames'>Adjust the Effects' Names</h2><span id='topic+adjustEffectNames'></span>

<h3>Description</h3>

<p>Adjust for appropriate syntax describing the effects matching the
structural formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustEffectNames(effectsMatrix, effectNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustEffectNames_+3A_effectsmatrix">effectsMatrix</code></td>
<td>
<p>a matrix of variables by terms showing which variables
appear in which terms generated by the <code><a href="stats.html#topic+terms">terms</a></code>.</p>
</td></tr>
<tr><td><code id="adjustEffectNames_+3A_effectnames">effectNames</code></td>
<td>
<p>a vector of character containing the labels of the
treatment or block terms in the model generated by the <code><a href="stats.html#topic+terms">terms</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of character containing the labels of the terms in the
model with appropriate syntax describing the effects.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str.for = "A*(B/E/C)*D"
effectsMatrix= attr(terms(as.formula(paste("~", str.for)), keep.order = TRUE) , "factors")
effectNames =  attr(terms(as.formula(paste("~", str.for)), keep.order = TRUE) , "term.labels")

adjustEffectNames(effectsMatrix, effectNames) 

</code></pre>

<hr>
<h2 id='adjustMissingLevels'>Adjust the Missing Levels</h2><span id='topic+adjustMissingLevels'></span>

<h3>Description</h3>

<p>Adjust for appropriate syntax describing the effects matching the
structural formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustMissingLevels(design.df, str.for)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustMissingLevels_+3A_design.df">design.df</code></td>
<td>
<p>a data frame containing the experimental design. Requires
every column be a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="adjustMissingLevels_+3A_str.for">str.for</code></td>
<td>
<p>a single string of characters containing the structural
formula using the Wilkinson-Rogers' syntax.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a data frame with the experimental design and a
single string of characters containing the structural formula.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design.df = data.frame( Blk = factor(1:16),
                      	Ani = factor(c(	1,1,2,2,
                                      	1,1,2,2,
                                      	1,1,2,2,
                                      	1,1,2,2)),
                      	Trt = factor(c(	1,2,3,4,
                                      	1,2,3,4,
                                      	1,2,3,4,
                                     		1,2,3,4)), stringsAsFactors = TRUE )
 
adjustMissingLevels(design.df, str.for = "Ani/Trt") 

</code></pre>

<hr>
<h2 id='chrisEx1'>Randomised Block design consisted of 6 blocks and 3 plots.</h2><span id='topic+chrisEx1'></span>

<h3>Description</h3>

<p>Randomised Block design consisted of 6 blocks and 3 plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chrisEx1
</code></pre>


<h3>Format</h3>

<p>A data frame with 18 rows and 5 variables: </p>

<dl>
<dt>Blocks</dt><dd><p>Block factor containing 6 levels</p>
</dd> <dt>Plots</dt><dd><p>Plot factor
containing 3 levels</p>
</dd>
<dt>A</dt><dd><p>Treatment factor A containing 3 levels</p>
</dd>
<dt>B</dt><dd><p>Treatment factor B containing 3 levels</p>
</dd> 
<dt>C</dt><dd><p>Treatment factor C containing 9 levels</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'> data(chrisEx1)

summaryAovOnePhase(chrisEx1, "Blocks/Plots", "A*B*C")
</code></pre>

<hr>
<h2 id='chrisEx2'>Randomised Block design consisted of 8 blocks and 2 plots.</h2><span id='topic+chrisEx2'></span>

<h3>Description</h3>

<p>Randomised Block design consisted of 8 blocks and 2 plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chrisEx2
</code></pre>


<h3>Format</h3>

<p>A data frame with 18 rows and 5 variables: </p>

<dl>
<dt>Blocks</dt><dd><p>Block factor containing 6 levels</p>
</dd> <dt>Plots</dt><dd><p>Plot factor
containing 3 levels</p>
</dd> <dt>A</dt><dd><p>Treatment factor A containing 2 levels</p>
</dd>
<dt>B</dt><dd><p>Treatment factor B containing 2 levels</p>
</dd> <dt>C</dt><dd><p>Treatment factor
C containing 3 levels</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'> data(chrisEx2)

summaryAovOnePhase(chrisEx2, "Blocks/Plots", "A*B*C")
</code></pre>

<hr>
<h2 id='chrisEx3'>Randomised Block design consisted of 4 blocks and 2 plots.</h2><span id='topic+chrisEx3'></span>

<h3>Description</h3>

<p>Randomised Block design consisted of 4 blocks and 2 plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chrisEx3
</code></pre>


<h3>Format</h3>

<p>A data frame with 8 rows and 5 variables: </p>

<dl>
<dt>Blocks</dt><dd><p>Block factor containing 4 levels</p>
</dd> <dt>Plots</dt><dd><p>Plot factor
containing 2 levels</p>
</dd> <dt>A</dt><dd><p>Treatment factor A containing 2 levels</p>
</dd>
<dt>B</dt><dd><p>Treatment factor B containing 2 levels</p>
</dd> <dt>C</dt><dd><p>Treatment factor
C containing 4 levels</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'> data(chrisEx2)

summaryAovOnePhase(chrisEx2, "Blocks/Plots", "A*B*C") 
</code></pre>

<hr>
<h2 id='getCoefVC.onePhase'>Get Variance Components' Coefficients and Mean Squares for Single-Phase or
Two-Phase Experiments</h2><span id='topic+getCoefVC.onePhase'></span>

<h3>Description</h3>

<p>Compute the variance components' coefficients and corresponding to random
effects in the expected mean squares of ANOVA table in single-phase or
two-phase experiments. These coefficients are then inserted to a matrix
where the rows correspond to each source of variation and column correspond
to DF and every variance component. The mean squares is calculated if the
<code>response</code> argument is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCoefVC.onePhase(
  Pb,
  design.df,
  v.mat,
  response,
  table.legend,
  decimal,
  digits
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCoefVC.onePhase_+3A_pb">Pb</code></td>
<td>
<p>a list of matrices generated by <code><a href="#topic+infoDecompMat">infoDecompMat</a></code>
function.</p>
</td></tr>
<tr><td><code id="getCoefVC.onePhase_+3A_design.df">design.df</code></td>
<td>
<p>a data frame containing the experimental design. Requires
every column be a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="getCoefVC.onePhase_+3A_v.mat">v.mat</code></td>
<td>
<p>a list of matrix generated by <code><a href="#topic+getVMat.onePhase">getVMat.onePhase</a></code>
or <code><a href="#topic+getVMat.twoPhase">getVMat.twoPhase</a></code>.</p>
</td></tr>
<tr><td><code id="getCoefVC.onePhase_+3A_response">response</code></td>
<td>
<p>a numeric vector contains the responses from the
experiment.</p>
</td></tr>
<tr><td><code id="getCoefVC.onePhase_+3A_table.legend">table.legend</code></td>
<td>
<p>a logical allows users to generate a legend for the
variance components of the ANOVA table for large designs. Default is
<code>FALSE</code>, resulting in the use of original block factor names.</p>
</td></tr>
<tr><td><code id="getCoefVC.onePhase_+3A_decimal">decimal</code></td>
<td>
<p>a logical allows users to display the coefficients as the
decimals. Default is <code>FALSE</code>, resulting in the use of
<code>fractions</code>.</p>
</td></tr>
<tr><td><code id="getCoefVC.onePhase_+3A_digits">digits</code></td>
<td>
<p>a integer indicating the number of decimal places. Default is
2, resulting in 2 decimal places.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of this function is to combine the matrices presenting
every source of variation of the ANOVA table and the variance matrix to
compute the coefficients of the variance components.
</p>
<p>The complication arise in giving the row names of the matrix for the source
of variation in the ANOVA table.
</p>


<h3>Value</h3>

<p>A matrix containing the characters.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design1 &lt;- local({ 
  Ani &lt;- as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8)])
  Trt &lt;- as.factor(letters[c(1,1,1,1,
                            2,2,2,2)])
  data.frame(Ani, Trt, stringsAsFactors = TRUE )
})

blk.str &lt;- "Ani"
    
rT &lt;- terms(as.formula(paste("~", blk.str, sep = "")), keep.order = TRUE) 
blkTerm &lt;- attr(rT,"term.labels")
     
Z &lt;- makeBlkDesMat(design1, blkTerm)

trt.str &lt;- "Trt"              
fT &lt;- terms(as.formula(paste("~", trt.str, sep = "")), keep.order = TRUE)  #fixed terms

trtTerm &lt;- attr(fT, "term.labels")
effectsMatrix &lt;- attr(fT, "factor")        

T &lt;- makeContrMat(design1, trtTerm, effectsMatrix, contr.vec = NA)

N =  makeOverDesMat(design1, trtTerm)

Replist = getTrtRep(design1, trtTerm)   
 
Rep &lt;- Replist$Rep
trt.Sca &lt;- Replist$Sca
    
effFactors = lapply(makeOrthProjectors(Z), function(z) 
      getEffFactor(z, T, N, Rep, trt.Sca))

#Now construct variance matrices
Pb &lt;- effFactors[sort(1:length(effFactors), decreasing=TRUE)]

v.mat &lt;- getVMat.onePhase(Z.Phase1 = Z, design.df = design.df, var.comp = NA)
    
getCoefVC.onePhase(Pb = Pb, design.df = design1, v.mat = v.mat, response = NA, 
    table.legend = FALSE, decimal = FALSE, digit = 2)

</code></pre>

<hr>
<h2 id='getCoefVC.twoPhase'>Get Variance Components' Coefficients and Mean Squares for Single-Phase or
Two-Phase Experiments</h2><span id='topic+getCoefVC.twoPhase'></span>

<h3>Description</h3>

<p>Compute the variance components' coefficients and corresponding to random
effects in the expected mean squares of ANOVA table in single-phase or
two-phase experiments. These coefficients are then inserted to a matrix
where the rows correspond to each source of variation and column correspond
to DF and every variance component. The mean squares is calculated if the
<code>response</code> argument is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCoefVC.twoPhase(
  Pb,
  design.df,
  v.mat,
  response,
  table.legend,
  decimal,
  digits
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCoefVC.twoPhase_+3A_pb">Pb</code></td>
<td>
<p>a list of matrices generated by <code><a href="#topic+infoDecompMat">infoDecompMat</a></code>
function.</p>
</td></tr>
<tr><td><code id="getCoefVC.twoPhase_+3A_design.df">design.df</code></td>
<td>
<p>a data frame containing the experimental design. Requires
every column be a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="getCoefVC.twoPhase_+3A_v.mat">v.mat</code></td>
<td>
<p>a list of matrix generated by <code><a href="#topic+getVMat.onePhase">getVMat.onePhase</a></code>
or <code><a href="#topic+getVMat.twoPhase">getVMat.twoPhase</a></code>.</p>
</td></tr>
<tr><td><code id="getCoefVC.twoPhase_+3A_response">response</code></td>
<td>
<p>a numeric vector contains the responses from the
experiment.</p>
</td></tr>
<tr><td><code id="getCoefVC.twoPhase_+3A_table.legend">table.legend</code></td>
<td>
<p>a logical allows users to generate a legend for the
variance components of the ANOVA table for large designs. Default is
<code>FALSE</code>, resulting in the use of original block factor names.</p>
</td></tr>
<tr><td><code id="getCoefVC.twoPhase_+3A_decimal">decimal</code></td>
<td>
<p>a logical allows users to display the coefficients as the
decimals. Default is <code>FALSE</code>, resulting in the use of
<code>fractions</code>.</p>
</td></tr>
<tr><td><code id="getCoefVC.twoPhase_+3A_digits">digits</code></td>
<td>
<p>a integer indicating the number of decimal places. Default is
2, resulting in 2 decimal places.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of this function is to combine the matrices presenting
every source of variation of the ANOVA table and the variance matrix to
compute the coefficients of the variance components.
</p>
<p>The complication arise in giving the row names of the matrix for the source
of variation in the ANOVA table.
</p>


<h3>Value</h3>

<p>A matrix containing the characters.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>

<hr>
<h2 id='getEffFactor'>Construct the Matrix from Information Decomposition and Compute the
Efficiency Factors of Treatment effects</h2><span id='topic+getEffFactor'></span>

<h3>Description</h3>

<p>Perform the information decomposition for either the block or treatment
effects within a single stratum and Compute the Efficiency Factors for
every treatment effect within a single stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEffFactor(z, T, N, Rep, trt.Sca)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEffFactor_+3A_z">z</code></td>
<td>
<p>a matrix containing the orthogonal projector of a stratum
generated by <code><a href="#topic+makeOrthProjectors">makeOrthProjectors</a></code>.</p>
</td></tr>
<tr><td><code id="getEffFactor_+3A_t">T</code></td>
<td>
<p>a list of contrast matrices generated by
<code><a href="#topic+makeContrMat">makeContrMat</a></code>.</p>
</td></tr>
<tr><td><code id="getEffFactor_+3A_n">N</code></td>
<td>
<p>a matrix containing the design matrix generated by
<code><a href="#topic+makeOverDesMat">makeOverDesMat</a></code>.</p>
</td></tr>
<tr><td><code id="getEffFactor_+3A_rep">Rep</code></td>
<td>
<p>a matrix containing the treatment replication number and is
generated by <code><a href="#topic+getTrtRep">getTrtRep</a></code>.</p>
</td></tr>
<tr><td><code id="getEffFactor_+3A_trt.sca">trt.Sca</code></td>
<td>
<p>a numeric vector for computing a coefficients of the fixed
effect parameter in EMS and is generated by <code><a href="#topic+getTrtRep">getTrtRep</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of this function is to construct a list of resultant
matrices associated with each source of variation after the information
decomposition and to compute the canonical or average efficiency factors
for each treatment effects in each stratum of ANOVA table.
</p>
<p>The canonical efficiency factors are generated when the user input the
treatment contrasts, otherwise the average efficiency factors, which is the
harmonic mean of the canonical efficiency factors, are generated.
</p>


<h3>Value</h3>

<p>A list of matrices and numeric vectors containing the efficiency
factors of every treatment effect.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design1 &lt;- local({ 
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8)])
  Trt = as.factor(letters[c(1,1,1,1,
                            2,2,2,2)])
  data.frame(Ani, Trt, stringsAsFactors = TRUE )
})

blk.str = "Ani"
    
rT = terms(as.formula(paste("~", blk.str, sep = "")), keep.order = TRUE) 
blkTerm = attr(rT,"term.labels")
     
Z = makeBlkDesMat(design1, blkTerm)

trt.str = "Trt"              
fT &lt;- terms(as.formula(paste("~", trt.str, sep = "")), keep.order = TRUE)  #fixed terms

trtTerm &lt;- attr(fT, "term.labels")
effectsMatrix &lt;- attr(fT, "factor")        

T &lt;- makeContrMat(design1, trtTerm, effectsMatrix, contr.vec = NA)

N =  makeOverDesMat(design1, trtTerm)

Replist = getTrtRep(design1, trtTerm)   
 
Rep &lt;- Replist$Rep
trt.Sca &lt;- Replist$Sca
    
effFactors = lapply(makeOrthProjectors(Z), function(z) 
      getEffFactor(z, T, N, Rep, trt.Sca))


</code></pre>

<hr>
<h2 id='getFixedEF.onePhase'>Get the Fixed Components' coefficients and Efficiency Factors of
Single-Phase Experiments.</h2><span id='topic+getFixedEF.onePhase'></span>

<h3>Description</h3>

<p>Calculate coefficients of fixed effects components of EMS and Treatment
Efficiency Factors within each stratum in Single-Phase or two-phase
experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFixedEF.onePhase(
  effFactors,
  trt.Sca,
  T,
  Rep,
  table.legend,
  decimal,
  digits,
  list.sep
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFixedEF.onePhase_+3A_efffactors">effFactors</code></td>
<td>
<p>a list of numeric vector generated by
<code><a href="#topic+getEffFactor">getEffFactor</a></code> function.</p>
</td></tr>
<tr><td><code id="getFixedEF.onePhase_+3A_trt.sca">trt.Sca</code></td>
<td>
<p>a numeric vector generated by <code><a href="#topic+getTrtRep">getTrtRep</a></code>
function.</p>
</td></tr>
<tr><td><code id="getFixedEF.onePhase_+3A_t">T</code></td>
<td>
<p>a list of matrices generated by <code><a href="#topic+makeContrMat">makeContrMat</a></code>
function.</p>
</td></tr>
<tr><td><code id="getFixedEF.onePhase_+3A_rep">Rep</code></td>
<td>
<p>a numeric matrix generated by <code><a href="#topic+getTrtRep">getTrtRep</a></code> function.</p>
</td></tr>
<tr><td><code id="getFixedEF.onePhase_+3A_table.legend">table.legend</code></td>
<td>
<p>a logical allows users to generate a legend for the
variance components of the ANOVA table for large designs. Default is
<code>FALSE</code>, resulting in the use of original treatment factor names.</p>
</td></tr>
<tr><td><code id="getFixedEF.onePhase_+3A_decimal">decimal</code></td>
<td>
<p>a logical allows users to display the coefficients as the
decimals. Default is <code>FALSE</code>, resulting in the use of
<code>fractions</code>.</p>
</td></tr>
<tr><td><code id="getFixedEF.onePhase_+3A_digits">digits</code></td>
<td>
<p>a integer indicating the number of decimal places. Default is
2, resulting in 2 decimal places.</p>
</td></tr>
<tr><td><code id="getFixedEF.onePhase_+3A_list.sep">list.sep</code></td>
<td>
<p>a logical allows users to present the efficiency factors
and coefficients of the fixed effects a list of separate matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructs a matrix containing the coefficients of the coefficients of
fixed effects components of EMS within each stratum. Also calculates and
the average efficiency factors of each treatment effect across all strata
</p>
<p>Construct a matrix contain the coefficients of the fixed Components and the
average efficiency factors of single-phase experiments.
</p>
<p>The function uses the efficiency factors generated by <code>getEffFactor</code>
to calculated the coefficients of fixed Effects components of EMS and
insert the treatment efficiency factor within each stratum.
</p>
<p>The complication arise in giving the row names of the matrix for the source
of variation in the ANOVA table.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design1 &lt;- local({ 
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8)])
  Trt = as.factor(letters[c(1,1,1,1,
                            2,2,2,2)])
  data.frame(Ani, Trt, stringsAsFactors = TRUE )
})

blk.str &lt;- "Ani"
    
rT &lt;- terms(as.formula(paste("~", blk.str, sep = "")), keep.order = TRUE) 
blkTerm = attr(rT,"term.labels")
     
Z &lt;- makeBlkDesMat(design1, blkTerm)

trt.str &lt;- "Trt"              
fT &lt;- terms(as.formula(paste("~", trt.str, sep = "")), keep.order = TRUE)  #fixed terms

trtTerm &lt;- attr(fT, "term.labels")
effectsMatrix &lt;- attr(fT, "factor")        

T &lt;- makeContrMat(design1, trtTerm, effectsMatrix, contr.vec = NA)

N &lt;- makeOverDesMat(design1, trtTerm)
		
Replist = getTrtRep(design1, trtTerm)   
 
Rep &lt;- Replist$Rep
trt.Sca &lt;- Replist$Sca
    
effFactors = lapply(makeOrthProjectors(Z), function(z) getEffFactor(z, T, N, Rep, trt.Sca))


effFactors &lt;- effFactors[sort(1:length(effFactors), decreasing=TRUE)]

getFixedEF.onePhase(effFactors = effFactors, trt.Sca = trt.Sca,  T = T, Rep = Rep, 
			table.legend = FALSE, decimal = FALSE, digits = 2, list.sep = TRUE)

</code></pre>

<hr>
<h2 id='getFixedEF.twoPhase'>Get the Fixed Components' coefficients and Efficiency Factors of
Two-Phase Experiments.</h2><span id='topic+getFixedEF.twoPhase'></span>

<h3>Description</h3>

<p>Calculate coefficients of fixed effects components of EMS and Treatment
Efficiency Factors within each stratum in Single-Phase or two-phase
experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFixedEF.twoPhase(
  effFactors,
  trt.Sca,
  T,
  Rep,
  table.legend,
  decimal,
  digits,
  list.sep
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFixedEF.twoPhase_+3A_efffactors">effFactors</code></td>
<td>
<p>a list of numeric vector generated by
<code><a href="#topic+getEffFactor">getEffFactor</a></code> function.</p>
</td></tr>
<tr><td><code id="getFixedEF.twoPhase_+3A_trt.sca">trt.Sca</code></td>
<td>
<p>a numeric vector generated by <code><a href="#topic+getTrtRep">getTrtRep</a></code>
function.</p>
</td></tr>
<tr><td><code id="getFixedEF.twoPhase_+3A_t">T</code></td>
<td>
<p>a list of matrices generated by <code><a href="#topic+makeContrMat">makeContrMat</a></code>
function.</p>
</td></tr>
<tr><td><code id="getFixedEF.twoPhase_+3A_rep">Rep</code></td>
<td>
<p>a numeric matrix generated by <code><a href="#topic+getTrtRep">getTrtRep</a></code> function.</p>
</td></tr>
<tr><td><code id="getFixedEF.twoPhase_+3A_table.legend">table.legend</code></td>
<td>
<p>a logical allows users to generate a legend for the
variance components of the ANOVA table for large designs. Default is
<code>FALSE</code>, resulting in the use of original treatment factor names.</p>
</td></tr>
<tr><td><code id="getFixedEF.twoPhase_+3A_decimal">decimal</code></td>
<td>
<p>a logical allows users to display the coefficients as the
decimals. Default is <code>FALSE</code>, resulting in the use of
<code>fractions</code>.</p>
</td></tr>
<tr><td><code id="getFixedEF.twoPhase_+3A_digits">digits</code></td>
<td>
<p>a integer indicating the number of decimal places. Default is
2, resulting in 2 decimal places.</p>
</td></tr>
<tr><td><code id="getFixedEF.twoPhase_+3A_list.sep">list.sep</code></td>
<td>
<p>a logical allows users to present the efficiency factors
and coefficients of the fixed effects a list of separate matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructs a matrix containing the coefficients of the coefficients of
fixed effects components of EMS within each stratum. Also calculates and
the average efficiency factors of each treatment effect across all strata
</p>
<p>Construct a matrix contain the coefficients of the fixed Components and the
average efficiency factors of single-phase experiments.
</p>
<p>The function uses the efficiency factors generated by <code>getEffFactor</code>
to calculated the coefficients of fixed Effects components of EMS and
insert the treatment efficiency factor within each stratum.
</p>
<p>The complication arise in giving the row names of the matrix for the source
of variation in the ANOVA table.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>

<hr>
<h2 id='getTrtCoef'>Get the Treatment Coefficients</h2><span id='topic+getTrtCoef'></span>

<h3>Description</h3>

<p>Compute the overall coefficients every treatment term including the
interaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTrtCoef(design.df, trtTerm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTrtCoef_+3A_design.df">design.df</code></td>
<td>
<p>a data frame containing the experimental design. Requires
every column be a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="getTrtCoef_+3A_trtterm">trtTerm</code></td>
<td>
<p>a vector of character containing the labels of the treatment
terms in the model generated by <code><a href="stats.html#topic+terms">terms</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric vector.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design1 &lt;- local({ 
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8)])
  Trt = as.factor(letters[c(1,1,1,1,
                            2,2,2,2)])
  data.frame(Ani, Trt, stringsAsFactors = TRUE )
})

trt.str = "Trt"
  
fT = terms(as.formula(paste("~", trt.str, sep = "")), keep.order = TRUE)  #fixed terms

trtTerm = attr(fT,"term.labels")
effectsMatrix = attr(fT,"factor") 
		
trt.Coef = getTrtCoef(design1, trtTerm)


</code></pre>

<hr>
<h2 id='getTrtRep'>Calculate the Treatment Replication number</h2><span id='topic+getTrtRep'></span>

<h3>Description</h3>

<p>Calculate the replication number of every treatment term including the
interaction. This is used to compute the treatment efficiency factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTrtRep(design.df, trtTerm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTrtRep_+3A_design.df">design.df</code></td>
<td>
<p>a data frame containing the experimental design. Requires
every column be a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="getTrtRep_+3A_trtterm">trtTerm</code></td>
<td>
<p>a vector of character containing the labels of the treatment
terms in the model generated by the <code><a href="stats.html#topic+terms">terms</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two objects. The first object is a matrix called
<code>Rep</code> which contains the replication numbers, where the rows
correspond to each treatment combination and the columns correspond to the
treatment factors, i.e. the replication number with respect to each
treatment factor based on the treatment combination. The second object
called <code>Sca</code> which is a numeric vector for computing a coefficients of
the fixed effect parameter in EMS.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>References</h3>

<p>John J, Williams E (1987). <em>Cyclic and computer generated
Designs</em>. Second edition. Chapman &amp; Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design1 &lt;- local({ 
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8)])
  Trt = as.factor(letters[c(1,1,1,1,
                            2,2,2,2)])
  data.frame(Ani, Trt, stringsAsFactors = TRUE )
})

trt.str = "Trt"
  
fT = terms(as.formula(paste("~", trt.str, sep = "")), keep.order = TRUE)  #fixed terms

trtTerm = attr(fT,"term.labels")
effectsMatrix = attr(fT,"factor") 
		
getTrtRep(design1, trtTerm)   


</code></pre>

<hr>
<h2 id='getVMat.onePhase'>Get the Variance Matrices for Single-Phase experiment</h2><span id='topic+getVMat.onePhase'></span>

<h3>Description</h3>

<p>Construct the matrix for each variance components for the single-phase or
two-phase experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVMat.onePhase(Z.Phase1, design.df, var.comp = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVMat.onePhase_+3A_z.phase1">Z.Phase1</code></td>
<td>
<p>a list of block design matrix from <code>makeBlkDesMat</code>
function from Phase 1 block structure.</p>
</td></tr>
<tr><td><code id="getVMat.onePhase_+3A_design.df">design.df</code></td>
<td>
<p>a data frame containing the experimental design. Requires
every column be a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="getVMat.onePhase_+3A_var.comp">var.comp</code></td>
<td>
<p>a vector of characters containing the variance components
of interest this allows the user to specify the variance components to be
shown on the ANOVA table. This also allows the user to specify artificial
stratum to facilitate decomposition. Default is <code>NA</code>, which uses every
random factor as the variance components with the first phase's variance
components in appear before the second phase's variance components.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 design1 &lt;- local({ 
    Ani = as.factor(LETTERS[c(1,2,3,4,
                              5,6,7,8)])
    Trt = as.factor(letters[c(1,1,1,1,
                              2,2,2,2)])
    data.frame(Ani, Trt, stringsAsFactors = TRUE )
  })

    blk.str = "Ani"
    
		rT = terms(as.formula(paste("~", blk.str, sep = "")), keep.order = TRUE) 

    blkTerm = attr(rT,"term.labels")
		Z = makeBlkDesMat(design1, rev(attr(rT,"term.labels")))

    V = getVMat.onePhase(Z, design1)
    

</code></pre>

<hr>
<h2 id='getVMat.twoPhase'>Get the Variance Matrices for Two-Phase experiment</h2><span id='topic+getVMat.twoPhase'></span>

<h3>Description</h3>

<p>Construct the matrix for each variance components for the single-phase or
two-phase experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVMat.twoPhase(Z.Phase1, Z.Phase2, design.df, var.comp = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVMat.twoPhase_+3A_z.phase1">Z.Phase1</code></td>
<td>
<p>a list of block design matrix from <code>makeBlkDesMat</code>
function from Phase 1 block structure.</p>
</td></tr>
<tr><td><code id="getVMat.twoPhase_+3A_z.phase2">Z.Phase2</code></td>
<td>
<p>a list of block design matrix from <code>makeBlkDesMat</code>
function from Phase 2 block structure.</p>
</td></tr>
<tr><td><code id="getVMat.twoPhase_+3A_design.df">design.df</code></td>
<td>
<p>a data frame containing the experimental design. Requires
every column be a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="getVMat.twoPhase_+3A_var.comp">var.comp</code></td>
<td>
<p>a vector of characters containing the variance components
of interest this allows the user to specify the variance components to be
shown on the ANOVA table. This also allows the user to specify artificial
stratum to facilitate decomposition. Default is <code>NA</code>, which uses every
random factor as the variance components with the first phase's variance
components in appear before the second phase's variance components.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     design2 &lt;- local({ 
  Run = as.factor(rep(1:4, each = 4))
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8,
                            3,4,1,2,
                            7,8,5,6)])
  Tag = as.factor(c(114,115,116,117)[rep(1:4, 4)])
  Trt = as.factor(letters[c(1,2,1,2,
                            2,1,2,1,
                            1,2,1,2,
                            2,1,2,1)])
  data.frame(Run, Ani, Tag, Trt, stringsAsFactors = TRUE )
})

    blk.str1 = "Ani"
    blk.str2 = "Run"
   
	rT1 = terms(as.formula(paste("~", blk.str1, sep = "")), keep.order = TRUE) 
	#random terms phase 1
	rT2 = terms(as.formula(paste("~", blk.str2, sep = "")), keep.order = TRUE) 
	#random terms phase 2

	blkTerm1 = attr(rT1,"term.labels")
	blkTerm2 = attr(rT2,"term.labels")

	Z1 = makeBlkDesMat(design2, rev(blkTerm1))
	Z2 = makeBlkDesMat(design2, rev(blkTerm2))

	V = getVMat.twoPhase(Z1, Z2, design2, var.comp = NA)
</code></pre>

<hr>
<h2 id='identityMat'>Identity Matrix</h2><span id='topic+identityMat'></span>

<h3>Description</h3>

<p>Construct an identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identityMat(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identityMat_+3A_n">n</code></td>
<td>
<p>a numeric describes the dimension of the identity matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix with the diagonal elements equal to
one and the off-diagonal elements equal to zero.
</p>


<h3>Author(s)</h3>

<p>Kevin
</p>


<h3>References</h3>

<p>John J, Williams E (1987). <em>Cyclic and computer generated
Designs</em>. Second edition. Chapman &amp; Hall.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diag">diag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

identityMat(10)


</code></pre>

<hr>
<h2 id='infoDecompMat'>Construct the Matrix from Information Decomposition</h2><span id='topic+infoDecompMat'></span>

<h3>Description</h3>

<p>Perform the information decomposition for either the block or treatment
effects within a single stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infoDecompMat(z, T, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infoDecompMat_+3A_z">z</code></td>
<td>
<p>a matrix containing the orthogonal projector for a single stratum
generated by <code><a href="#topic+makeOrthProjectors">makeOrthProjectors</a></code>.</p>
</td></tr>
<tr><td><code id="infoDecompMat_+3A_t">T</code></td>
<td>
<p>a list of contrast matrices generated by
<code><a href="#topic+makeContrMat">makeContrMat</a></code>.</p>
</td></tr>
<tr><td><code id="infoDecompMat_+3A_n">N</code></td>
<td>
<p>a matrix containing the design matrix generated by
<code><a href="#topic+makeOverDesMat">makeOverDesMat</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of this function is to construct a list of resultant
matrices associated with each source of variation after the information
decomposition.
</p>
<p>This list of matrices are then used to compute the coefficient of the
variance components in the expected mean squares.
</p>


<h3>Value</h3>

<p>A list of matrices.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design1 &lt;- local({ 
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8)])
  Trt = as.factor(letters[c(1,1,1,1,
                            2,2,2,2)])
  data.frame(Ani, Trt, stringsAsFactors = TRUE )
})

blk.str = "Ani"
    
rT = terms(as.formula(paste("~", blk.str, sep = "")), keep.order = TRUE) 
blkTerm = attr(rT,"term.labels")
     
Z = makeBlkDesMat(design1, blkTerm)
Pb = makeOrthProjectors(Z)

trt.str = "Trt"              
fT &lt;- terms(as.formula(paste("~", trt.str, sep = "")), keep.order = TRUE)  #fixed terms

trtTerm &lt;- attr(fT, "term.labels")
effectsMatrix &lt;- attr(fT, "factors")        

T &lt;- makeContrMat(design1, trtTerm, effectsMatrix, contr.vec = NA)

N =  makeOverDesMat(design1, trtTerm)


infoDecompMat(Pb[[1]], T, N)


</code></pre>

<hr>
<h2 id='invInfMat'>Invert the Information Matrix</h2><span id='topic+invInfMat'></span>

<h3>Description</h3>

<p>Using the eigenvalue decomposition method to invert the information matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invInfMat(C, N, T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invInfMat_+3A_c">C</code></td>
<td>
<p>a matrix of block projector for a single stratum.</p>
</td></tr>
<tr><td><code id="invInfMat_+3A_n">N</code></td>
<td>
<p>a matrix representation the smallest unit of block or treatment
effects generated by <code><a href="#topic+makeOverDesMat">makeOverDesMat</a></code>.</p>
</td></tr>
<tr><td><code id="invInfMat_+3A_t">T</code></td>
<td>
<p>a list of contrast matrices from <code><a href="#topic+makeContrMat">makeContrMat</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>References</h3>

<p>Nelder JA (1965b). &quot;The Analysis of Randomized Experiments with
Orthogonal Block Structure. II. Treatment Structure and the General
Analysis of Variance.&quot; <em>Proceedings of the Royal Society of London.
Series A, Mathematical and Physical Sciences</em>, 283(1393), 163-178.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

m &lt;- matrix(rnorm(10), 10, 10)

invInfMat(m, identityMat(10), identityMat(10))
     


</code></pre>

<hr>
<h2 id='J'>Identity Matrix Minus Averaging Matrix</h2><span id='topic+J'></span>

<h3>Description</h3>

<p>Construct a square matrix which the identity matrix minus the averging
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>J(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="J_+3A_n">n</code></td>
<td>
<p>a numeric describes the dimension of the square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function return a square matrix which the identity matrix
minus the averaging matrix.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

J(10)


</code></pre>

<hr>
<h2 id='K'>Averaging Matrix</h2><span id='topic+K'></span>

<h3>Description</h3>

<p>Construct a n-by-n averaging matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>K(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="K_+3A_n">n</code></td>
<td>
<p>a numeric describes the dimension of the averaging matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a <code class="reqn">n \times n</code> square matrix with all
elements equal 1/n.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>References</h3>

<p>John J, Williams E (1987). <em>Cyclic and computer generated
Designs</em>. Second edition. Chapman &amp; Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

K(10)


</code></pre>

<hr>
<h2 id='makeBlkDesMat'>Construct Block Design Matrix</h2><span id='topic+makeBlkDesMat'></span>

<h3>Description</h3>

<p>Construct a binary matrix representing the block design. The rows are
corresponding to the observations and the columns are corresponding to the
blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBlkDesMat(design.df, blkTerm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeBlkDesMat_+3A_design.df">design.df</code></td>
<td>
<p>a data frame containing the experimental design. Requires
every column be a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="makeBlkDesMat_+3A_blkterm">blkTerm</code></td>
<td>
<p>a vector of character containing the labels of the block
terms in the model generated by the <code><a href="stats.html#topic+terms">terms</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the binary matrices.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+terms">terms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

design1 &lt;- local({ 
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8)])
  Trt = as.factor(letters[c(1,1,1,1,
                            2,2,2,2)])
  data.frame(Ani, Trt, stringsAsFactors = TRUE )
})

blk.str = "Ani*Trt"
    
rT = terms(as.formula(paste("~", blk.str, sep = "")), keep.order = TRUE) 

blkTerm = attr(rT,"term.labels")
Z = makeBlkDesMat(design1, blkTerm)



</code></pre>

<hr>
<h2 id='makeContrMat'>Make Contrast Matrix</h2><span id='topic+makeContrMat'></span>

<h3>Description</h3>

<p>Construct a list of contrast matrices for block for treatment effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeContrMat(design.df, effectNames, effectsMatrix, contr.vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeContrMat_+3A_design.df">design.df</code></td>
<td>
<p>a data frame containing the experimental design. Requires
every column be a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="makeContrMat_+3A_effectnames">effectNames</code></td>
<td>
<p>a vector of character containing the labels of the
treatment or block terms in the model generated by the <code><a href="stats.html#topic+terms">terms</a></code>.</p>
</td></tr>
<tr><td><code id="makeContrMat_+3A_effectsmatrix">effectsMatrix</code></td>
<td>
<p>a matrix of variables by terms showing which variables
appear in which terms generated by the <code><a href="stats.html#topic+terms">terms</a></code>.</p>
</td></tr>
<tr><td><code id="makeContrMat_+3A_contr.vec">contr.vec</code></td>
<td>
<p>a list of contrast vectors, this allows the user to
specify the contrasts for each treatment or block factor. Note that if this
argument is used, it is necessary to specify the contrasts for every
treatment or block factor with the same order as <code>effectNames</code>.
Default is <code>NA</code>, and the function output the C matrices described by
John and Williams (1987).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of this function is to compute a list of C matrices
described by John and Williams (1987). These C matrices are used for the
information decomposition for every treatment effect in every stratum of
the experiment.
</p>
<p>If the user input their own defined contrasts for each treatment effects.
This function will then transform the input contrasts to the C matrices for
the treatment effects.
</p>
<p>For the two-phase experiments, the same method of information decomposition
is used for the block effects of Phase 1 experiment in the stratum defined
from the block structure of the Phase 2 experiment. Hence, the C matrices
for the block effects of Phase 1 experiment can also be constructed using
this function.
</p>


<h3>Value</h3>

<p>A list of contrast matrices.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>References</h3>

<p>John J, Williams E (1987). <em>Cyclic and computer generated
Designs</em>. Second edition. Chapman &amp; Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design1 &lt;- local({ 
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8)])
  Trt = as.factor(letters[c(1,1,1,1,
                            2,2,2,2)])
  data.frame(Ani, Trt, stringsAsFactors = TRUE )
})

trt.str = "Trt"              
fT &lt;- terms(as.formula(paste("~", trt.str, sep = "")), keep.order = TRUE)  #fixed terms

trtTerm &lt;- attr(fT, "term.labels")
effectsMatrix &lt;- attr(fT, "factor")        

T &lt;- makeContrMat(design1, trtTerm, effectsMatrix, contr.vec = NA)
		
#Fit each treatment contrasts as a vector seperately
Trt1 &lt;- rep(c(1,-1), each = 4)
Trt2 &lt;-  rep(c(1,-1), time = 4)
Trt3 &lt;- Trt1*Trt2
  
T &lt;- makeContrMat(design1, trtTerm, effectsMatrix, 
      contr.vec =list(Trt = list(Trt1 = Trt1, Trt2 = Trt2, Trt3 = Trt3)))


</code></pre>

<hr>
<h2 id='makeOrthProjectors'>Construct Orthogonal Projector Matrices</h2><span id='topic+makeOrthProjectors'></span>

<h3>Description</h3>

<p>Construct a list of orthogonal projector matrices corresponding to all
strata of the experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeOrthProjectors(BlkDesList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeOrthProjectors_+3A_blkdeslist">BlkDesList</code></td>
<td>
<p>a list of block design matrices generated by
<code><a href="#topic+makeBlkDesMat">makeBlkDesMat</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The strata decomposition is performed within this function. The first step
is to convert the list of block design matrices generated by
<code><a href="#topic+makeBlkDesMat">makeBlkDesMat</a></code> to projection matrices using
<code><a href="#topic+projMat">projMat</a></code>. The second step is to use these projection matrices
to project the raw data vector from one stratum to next stratum of the
experiment; the resulting matrix corresponds to each stratum is the
orthogonal projector matrix of the given stratum.
</p>


<h3>Value</h3>

<p>A list containing matrices.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design1 &lt;- local({ 
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8)])
  Trt = as.factor(letters[c(1,1,1,1,
                            2,2,2,2)])
  data.frame(Ani, Trt, stringsAsFactors = TRUE )
})

blk.str = "Ani"
    
rT = terms(as.formula(paste("~", blk.str, sep = "")), keep.order = TRUE) 
blkTerm = attr(rT,"term.labels")
     
Z = makeBlkDesMat(design1, blkTerm)
Pb = makeOrthProjectors(Z)

</code></pre>

<hr>
<h2 id='makeOverDesMat'>Construct the Overall Treatment or Block design Matrix</h2><span id='topic+makeOverDesMat'></span>

<h3>Description</h3>

<p>Construct the treatment or block matrix of the smallest unit based from the
experimental design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeOverDesMat(design.df, effectNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeOverDesMat_+3A_design.df">design.df</code></td>
<td>
<p>a data frame containing the experimental design. Requires
every column be a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="makeOverDesMat_+3A_effectnames">effectNames</code></td>
<td>
<p>a vector of character containing the labels of the
treatment or block terms in the model generated by the <code><a href="stats.html#topic+terms">terms</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose this matrix is used in information decomposition. For the
factorial experiment, this matrix is typically the treatment design matrix
associated with the interaction effects, because the interaction effects
are the smallest unit for the treatment effects.
</p>
<p>For the two-phase experiments, the same method of information decomposition
is used for the block effects of Phase 1 experiment in the stratum defined
from the block structure of the Phase 2 experiment. Hence, the block design
matrix of the smallest unit for the block effects of Phase 1 experiment can
also be constructed using this function.
</p>


<h3>Value</h3>

<p>A matrix where the rows correspond to the observation and columns
correspond to the overall combination of the treatment factors or the block
factors of the Phase 1 experiment.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>References</h3>

<p>John J, Williams E (1987). <em>Cyclic and computer generated
Designs</em>. Second edition. Chapman &amp; Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design1 &lt;- local({ 
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8)])
  Trt = as.factor(letters[c(1,1,1,1,
                            2,2,2,2)])
  data.frame(Ani, Trt, stringsAsFactors = TRUE )
})

trt.str = "Trt"
  
fT = terms(as.formula(paste("~", trt.str, sep = "")), keep.order = TRUE) 

trtTerm = attr(fT,"term.labels")
effectsMatrix = attr(fT,"factor") 
    
makeOverDesMat(design1, trtTerm)
       


</code></pre>

<hr>
<h2 id='projMat'>Construct a Projection Matrix</h2><span id='topic+projMat'></span>

<h3>Description</h3>

<p>Compute the projection matrix from a square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projMat(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projMat_+3A_x">X</code></td>
<td>
<p>a square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

m = matrix(1, nrow = 10, ncol = 3)
projMat(m) 


</code></pre>

<hr>
<h2 id='summaryAovOnePhase'>Summarize an Theoretical Analysis of Variance Model of Single-Phase
Experiments</h2><span id='topic+summaryAovOnePhase'></span>

<h3>Description</h3>

<p>Computes the coefficients of the variance components for the expected mean
squares for single-phase experiments. The function accepts a data frame of
the experimental design with the structural formulae of the block and
treatment factors. Two tables containing the variance components of the
random effects and fixed effects are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryAovOnePhase(
  design.df,
  blk.str,
  trt.str,
  var.comp = NA,
  trt.contr = NA,
  table.legend = FALSE,
  response = NA,
  latex = FALSE,
  fixed.names = NA,
  decimal = FALSE,
  digits = 2,
  list.sep = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryAovOnePhase_+3A_design.df">design.df</code></td>
<td>
<p>a data frame containing the experimental design. Requires
every column be a <code><a href="base.html#topic+factor">factor</a>. Any punctuation or symbol such as
dots or parentheses should be avoid for the column names.</code>.</p>
</td></tr>
<tr><td><code id="summaryAovOnePhase_+3A_blk.str">blk.str</code></td>
<td>
<p>a single string of characters containing the structural
formula for the block factors using the Wilkinson-Rogers' syntax.</p>
</td></tr>
<tr><td><code id="summaryAovOnePhase_+3A_trt.str">trt.str</code></td>
<td>
<p>a single string of characters containing the structural
formula for the treatment factors using the Wilkinson-Rogers' syntax.</p>
</td></tr>
<tr><td><code id="summaryAovOnePhase_+3A_var.comp">var.comp</code></td>
<td>
<p>a vector of characters containing the variance components
of interest this allows the user to specify the variance components to be
shown on the ANOVA table. This also allows the user to specify artificial
stratum to facilitate decomposition. Default is <code>NA</code>, which uses every
random factor as the variance components from <code>random.terms</code>.</p>
</td></tr>
<tr><td><code id="summaryAovOnePhase_+3A_trt.contr">trt.contr</code></td>
<td>
<p>a list of treatment contrast vectors, this allows the user
to specify the contrasts for each treatment factor. Note that if this
argument is used, it is necessary to specify the contrasts for every
treatment factor with the same order as <code>fixed.terms</code>. Default is
<code>NA</code>, which uses the C matrix described by John and Williams (1987).</p>
</td></tr>
<tr><td><code id="summaryAovOnePhase_+3A_table.legend">table.legend</code></td>
<td>
<p>a logical allows the users to use the legend for the
variance components of the ANOVA table for a large design. Default is
<code>FALSE</code>, which uses the original names.</p>
</td></tr>
<tr><td><code id="summaryAovOnePhase_+3A_response">response</code></td>
<td>
<p>a numeric vector contains the responses from the
experiment.</p>
</td></tr>
<tr><td><code id="summaryAovOnePhase_+3A_latex">latex</code></td>
<td>
<p>a logical allows the users to output the Latex script to Latex
table. Once the Latex script is generated, it requires the user to install
and load two Latex packages: <code>booktabs</code> and <code>bm</code> to compile the
Latex script.</p>
</td></tr>
<tr><td><code id="summaryAovOnePhase_+3A_fixed.names">fixed.names</code></td>
<td>
<p>a vector of character allows the users to modify symbols
for the fixed effects for the Latex outputs.</p>
</td></tr>
<tr><td><code id="summaryAovOnePhase_+3A_decimal">decimal</code></td>
<td>
<p>a logical allows users to display the coefficients as the
decimals. Default is <code>FALSE</code>, resulting in the use of function
<code>fractions</code>.</p>
</td></tr>
<tr><td><code id="summaryAovOnePhase_+3A_digits">digits</code></td>
<td>
<p>a integer indicating the number of decimal places. Default is
2, resulting in 2 decimal places.</p>
</td></tr>
<tr><td><code id="summaryAovOnePhase_+3A_list.sep">list.sep</code></td>
<td>
<p>a logical allows users to present the efficiency factors
and coefficients of the fixed effects a list of separate matrices. Default
is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The values returned depends on the value of the <code>table.legend</code>
argument. If <code>table.legend = FALSE</code>, this function will return a list
of two data frames. The first data frame contains the random effects and
the second data frame contains the fixed effects. If the
<code>table.legend</code> argument is <code>TRUE</code>, then it will return a list
containing two lists. The first list consists of a data frame of random
effects and a character string for the legend. The second list consists of
a data frame of fixed effects and a character string for the legend.  If
<code>response</code> argument is used, the random effect table will have one
extra column with of mean squares computed from the responses from the
experiment.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>References</h3>

<p>John J, Williams E (1987). <em>Cyclic and computer generated
Designs</em>. Second edition. Chapman &amp; Hall.
</p>
<p>Nelder JA (1965b). &quot;The Analysis of Randomized Experiments with Orthogonal
Block Structure. II. Treatment Structure and the General Analysis of
Variance.&quot; <em>Proceedings of the Royal Society of London. Series A,
Mathematical and Physical Sciences</em>, 283(1393), 163-178.
</p>
<p>Wilkinson GN, Rogers CE (1973). &quot;Symbolic Description of Factorial Models
for Analysis of Variance.&quot; <em>Applied Statistics</em>, 22(3), 392-399.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+terms">terms</a></code> for more information on the structural
formula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design1 &lt;- local({ 
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8)])
  Trt = as.factor(letters[c(1,1,1,1,
                            2,2,2,2)])
  data.frame(Ani, Trt, stringsAsFactors = TRUE)
})

summaryAovOnePhase(design1, blk.str = "Ani", trt.str = "Trt") 

summaryAovOnePhase(design1, blk.str = "Ani", trt.str = "Trt", 
latex = TRUE, fixed.names = c("\\tau"))


</code></pre>

<hr>
<h2 id='summaryAovTwoPhase'>Summarize an Theoretical Analysis of Variance Model of Two-Phase
Experiments</h2><span id='topic+summaryAovTwoPhase'></span>

<h3>Description</h3>

<p>Computes the coefficients of the variance components for the expected mean
squares for two-phase experiments. The function accepts a data frame of the
experimental design with the structural formulae of the block and treatment
factors. Two tables containing the variance components of the random
effects and fixed effects are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryAovTwoPhase(
  design.df,
  blk.str1,
  blk.str2,
  trt.str,
  var.comp = NA,
  blk.contr = NA,
  trt.contr = NA,
  table.legend = FALSE,
  response = NA,
  latex = FALSE,
  fixed.names = NA,
  decimal = FALSE,
  digits = 2,
  list.sep = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryAovTwoPhase_+3A_design.df">design.df</code></td>
<td>
<p>a data frame containing the experimental design. Requires
every column be a <code><a href="base.html#topic+factor">factor</a>. Any punctuation or symbol such as
dots or parentheses should be avoid for the column names.</code>.</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_blk.str1">blk.str1</code></td>
<td>
<p>a single string of characters containing the structural
formula for the block factors of the first-phase experiment using the
Wilkinson-Rogers' syntax.</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_blk.str2">blk.str2</code></td>
<td>
<p>a single string of characters containing the structural
formula for the block factors of the second-phase experiment using the
Wilkinson-Rogers' syntax.</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_trt.str">trt.str</code></td>
<td>
<p>a single string of characters containing the structural
formula for the treatment factors using the Wilkinson-Rogers' syntax.</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_var.comp">var.comp</code></td>
<td>
<p>a vector of characters containing the variance components
of interest this allows the user to specify the variance components to be
shown on the ANOVA table. This also allows the user to specify artificial
stratum to facilitate decomposition. Default is <code>NA</code>, which uses every
random factor as the variance components with the first phase's variance
components in <code>random.terms1</code> appear before the second phase's
variance components in <code>random.terms2</code>.</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_blk.contr">blk.contr</code></td>
<td>
<p>a list of first-phase block contrast vectors, this allows
the user to specify the contrasts for each block factor in the first phase
experiment. Note that if this argument is used, it is necessary to specify
the contrasts for every treatment factor with the same order as
<code>fixed.terms</code>. Default is <code>NA</code>, which uses the C matrix described
by John and Williams (1987).</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_trt.contr">trt.contr</code></td>
<td>
<p>a list of treatment contrast vectors, this allows the user
to specify the contrasts for each treatment factor. Note that if this
argument is used, it is necessary to specify the contrasts for every
treatment factor with the same order as <code>fixed.terms</code>. Default is
<code>NA</code>, which uses the C matrix described by John and Williams (1987).</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_table.legend">table.legend</code></td>
<td>
<p>a logical allows the users to use the legend for the
variance components of the ANOVA table for a large design. Default is
<code>FALSE</code>, which uses the original names.</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_response">response</code></td>
<td>
<p>a numeric vector contains the responses from the
experiment.</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_latex">latex</code></td>
<td>
<p>a logical allows the users to output the Latex script to Latex
table. Once the Latex script is generated, it requires the user to install
and load two Latex packages: <code>booktabs</code> and <code>bm</code> to compile the
Latex script.</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_fixed.names">fixed.names</code></td>
<td>
<p>a vector of character allows the users to modify symbols
for the fixed effects for the Latex outputs.</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_decimal">decimal</code></td>
<td>
<p>a logical allows users to display the coefficients as the
decimals. Default is <code>FALSE</code>, resulting in the use of function
<code>fractions</code>.</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_digits">digits</code></td>
<td>
<p>a integer indicating the number of decimal places. Default is
2, resulting in 2 decimal places.</p>
</td></tr>
<tr><td><code id="summaryAovTwoPhase_+3A_list.sep">list.sep</code></td>
<td>
<p>a logical allows users to present the efficiency factors
and coefficients of the fixed effects a list of separate matrices. Default
is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The values returned depends on the value of the <code>table.legend</code>
argument. If <code>table.legend = FALSE</code>, this function will return a list
of two data frames. The first data frame contains the random effects and
the second data frame contains the fixed effects. If the
<code>table.legend</code> argument is <code>TRUE</code>, then it will return a list
containing two lists. The first list consists of a data frame of random
effects and a character string for the legend. The second list consists of
a data frame of fixed effects and a character string for the legend.  If
<code>response</code> argument is used, the random effect table will have one
extra column with of mean squares computed from the responses from the
experiment.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>References</h3>

<p>John J, Williams E (1987). <em>Cyclic and computer generated
Designs</em>. Second edition. Chapman &amp; Hall.
</p>
<p>Nelder JA (1965b). &quot;The Analysis of Randomized Experiments with Orthogonal
Block Structure. II. Treatment Structure and the General Analysis of
Variance.&quot; <em>Proceedings of the Royal Society of London. Series A,
Mathematical and Physical Sciences</em>, 283(1393), 163-178.
</p>
<p>Wilkinson GN, Rogers CE (1973). &quot;Symbolic Description of Factorial Models
for Analysis of Variance.&quot; <em>Applied Statistics</em>, 22(3), 392-399.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+terms">terms</a></code> for more information on the structural
formula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Phase 2 experiment  
design2 &lt;- local({ 
  Run = as.factor(rep(1:4, each = 4))
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8,
                            3,4,1,2,
                            7,8,5,6)])
  Sam = as.factor(as.numeric(duplicated(Ani)) + 1)
  Tag = as.factor(c(114,115,116,117)[rep(1:4, 4)])
  Trt = as.factor(c("healthy", "diseased")[c(1,2,1,2,
                            2,1,2,1,
                            1,2,1,2,
                            2,1,2,1)])
  data.frame(Run, Ani, Sam, Tag, Trt, stringsAsFactors = TRUE)
})
design2
                                  
summaryAovTwoPhase(design2, blk.str1 = "Ani", blk.str2 = "Run", 
trt.str = "Tag + Trt")                                            
   
#Add the sample into the Phase 1 block structure                                           
summaryAovTwoPhase(design2, blk.str1 = "Ani/Sam", blk.str2 = "Run", 
trt.str = "Tag + Trt")                                            


#Assuming there is crossing between the animals and samples 
summaryAovTwoPhase(design2, blk.str1 = "Ani*Sam", blk.str2 = "Run", 
trt.str = "Tag + Trt")                                            

 
#Set Artificial stratum 
design2$AniSet = as.factor(c(2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1))
design2

summaryAovTwoPhase(design2, blk.str1 =  "Ani/Sam", blk.str2 = "AniSet/Run", 
trt.str = "Tag + Trt", var.comp = c("Ani:Sam", "Ani", "Run"))                                    

#Define traetment contrasts                                   
TagA = rep(c(1,1,-1,-1),time = 4)                
TagB = rep(c(1,-1,1,-1),time = 4)                
TagC = TagA * TagB
Tag = list(TagA = TagA, TagB = TagB, TagC = TagC)
Tag


Trt = as.numeric(design2$Trt)-1.5
Trt


summaryAovTwoPhase(design2, blk.str1 =  "Ani/Sam", blk.str2 = "Run", 
trt.str = "Tag + Trt", 
trt.contr = list(Tag = list(TagA = TagA, TagB = TagB, TagC = TagC), Trt = Trt),
table.legend = TRUE)                                

#Compute MS 
set.seed(527)
summaryAovTwoPhase(design2, blk.str1 = "Ani/Sam", blk.str2 = "Run", 
trt.str = "Tag + Trt", response = rnorm(16))$ANOVA                                            

#Generate Latex scripts
summaryAovTwoPhase(design2, blk.str1 = "Ani/Sam", blk.str2 = "Run", 
trt.str = "Tag + Trt", latex = TRUE, fixed.names = c("\\gamma", "\\tau"))  

#Generate Latex scripts with MS
set.seed(527)
summaryAovTwoPhase(design2, blk.str1 = "Ani/Sam", blk.str2 = "Run", 
trt.str = "Tag + Trt", response = rnorm(16), latex = TRUE, 
fixed.names = c("\\gamma", "\\tau") )                               


</code></pre>

<hr>
<h2 id='toLatexTable'>Convert the R output to Latex Table</h2><span id='topic+toLatexTable'></span>

<h3>Description</h3>

<p>Print the Latex scripts on the screen for the user to output the table from
the Latex output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toLatexTable(ANOVA, EF, fixed.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toLatexTable_+3A_anova">ANOVA</code></td>
<td>
<p>a matrix containing the coefficients of the variance
components in EMS of ANOVA table generated by
<code><a href="#topic+getCoefVC.onePhase">getCoefVC.onePhase</a></code> or <code><a href="#topic+getCoefVC.twoPhase">getCoefVC.twoPhase</a></code>.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_ef">EF</code></td>
<td>
<p>a matrix containing the coefficient of the fixed effects
components and the treatment average efficiency factors generated by
<code><a href="#topic+getFixedEF.onePhase">getFixedEF.onePhase</a></code> or <code><a href="#topic+getFixedEF.onePhase">getFixedEF.onePhase</a></code>
function.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_fixed.names">fixed.names</code></td>
<td>
<p>a vector of character allows the users to modify symbols
for the fixed effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once the Latex script is generated, it requires the user to install and
load two Latex packages: <code>booktabs</code> and <code>bm</code> to compile the Latex
script.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design1 &lt;- local({ 
  Ani = as.factor(LETTERS[c(1,2,3,4,
                            5,6,7,8)])
  Trt = as.factor(letters[c(1,1,1,1,
                            2,2,2,2)])
  data.frame(Ani, Trt, stringsAsFactors = TRUE )
})

blk.str &lt;- "Ani"
    
rT &lt;- terms(as.formula(paste("~", blk.str, sep = "")), keep.order = TRUE) 
blkTerm &lt;- attr(rT,"term.labels")
     
Z &lt;- makeBlkDesMat(design1, blkTerm)


trt.str = "Trt"              
fT &lt;- terms(as.formula(paste("~", trt.str, sep = "")), keep.order = TRUE)  

trtTerm &lt;- attr(fT, "term.labels")
effectsMatrix &lt;- attr(fT, "factor")        

T &lt;- makeContrMat(design1, trtTerm, effectsMatrix, contr.vec = NA)

N &lt;- makeOverDesMat(design1, trtTerm)

Replist = getTrtRep(design1, trtTerm)   
 
Rep &lt;- Replist$Rep
trt.Sca &lt;- Replist$Sca
    
effFactors = lapply(makeOrthProjectors(Z), function(z) 
      getEffFactor(z, T, N, Rep, trt.Sca))

effFactors &lt;- effFactors[sort(1:length(effFactors), decreasing=TRUE)]

v.mat &lt;- getVMat.onePhase(Z.Phase1 = Z, design.df = design.df, var.comp = NA)
    
ANOVA &lt;- getCoefVC.onePhase(Pb = effFactors, design.df = design1, v.mat = v.mat, 
    response = NA, table.legend = FALSE, decimal = FALSE, digits = 2)
		
EF &lt;- getFixedEF.onePhase(effFactors = effFactors, trt.Sca = trt.Sca,  T = T, 
  Rep = Rep, 
	table.legend = FALSE, decimal = FALSE, digits = 2, list.sep = FALSE)

toLatexTable(ANOVA = ANOVA, EF = EF, fixed.names = c("\\tau"))

</code></pre>

<hr>
<h2 id='tr'>Trace of the Matrix</h2><span id='topic+tr'></span>

<h3>Description</h3>

<p>Compute the trace of the square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tr_+3A_x">X</code></td>
<td>
<p>a square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p>Kevin
</p>


<h3>References</h3>

<p>John J, Williams E (1987). <em>Cyclic and computer generated
Designs</em>. Second edition. Chapman &amp; Hall.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diag">diag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

m = matrix(1, nrow = 10, ncol = 10)
tr(m)   


</code></pre>

<hr>
<h2 id='unity'>Construct a unity vector</h2><span id='topic+unity'></span>

<h3>Description</h3>

<p>Construct a vector with all elements unity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unity(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unity_+3A_n">n</code></td>
<td>
<p>a numeric describe the length of vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a <code class="reqn">n \\times 1</code> matrix will all elements
unity.
</p>


<h3>Author(s)</h3>

<p>Kevin Chang
</p>


<h3>References</h3>

<p>John J, Williams E (1987). <em>Cyclic and computer generated
Designs</em>. Second edition. Chapman &amp; Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

unity(10)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
