<!DOCTYPE html><html><head><title>Help for package tidyindex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyindex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidyindex-package'><p>tidyindex: A Tidy Data Pipeline to Construct, Compare, and Analyse Indexes</p></a></li>
<li><a href='#add_paras'><p>Add parameters to an index table object</p></a></li>
<li><a href='#compute_indexes'><p>Calculate multiple indexes at once</p></a></li>
<li><a href='#dimension_reduction'><p>The dimension reduction module</p></a></li>
<li><a href='#distribution_fit'><p>The distribution fit module</p></a></li>
<li><a href='#gggi'><p>Global Gender Gap Index (2023)</p></a></li>
<li><a href='#hdi'><p>Human Development Index (2022)</p></a></li>
<li><a href='#init'><p>Initialise the tidyindex pipeline</p></a></li>
<li><a href='#normalise'><p>The normalise module</p></a></li>
<li><a href='#rescaling'><p>The rescaling module</p></a></li>
<li><a href='#swap_values'><p>Testing alternatives</p></a></li>
<li><a href='#temporal_aggregate'><p>The temporal processing module</p></a></li>
<li><a href='#tenterfield'><p>Weather data for in-situ stations in Queensland from 1990 to 2020</p></a></li>
<li><a href='#theme_benchmark'><p>A ggplot2 theme for benchmarking the index series</p></a></li>
<li><a href='#trans_thornthwaite'><p>Drought-related index functions</p></a></li>
<li><a href='#variable_trans'><p>The variable transformation module</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Tidy Data Pipeline to Construct, Compare, and Analyse Indexes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Construct and analyse indexes in a pipeline tidy workflow.
    'tidyindex' contains modules for transforming variables, aggregating 
    variables across time, reducing data dimension through weighting, and 
    fitting distributions. A manuscript describing the methodology can be 
    found at <a href="https://github.com/huizezhang-sherry/paper-tidyindex">https://github.com/huizezhang-sherry/paper-tidyindex</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/huizezhang-sherry/tidyindex">https://github.com/huizezhang-sherry/tidyindex</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/huizezhang-sherry/tidyindex/issues">https://github.com/huizezhang-sherry/tidyindex/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, generics, ggplot2, glue, purrr, rlang (&ge; 1.1.0),
tidyr, tidyselect, tsibble, vctrs</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, lmomco, lubridate, rmarkdown, slider, SPEI,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-15 01:54:51 UTC; hzha400</td>
</tr>
<tr>
<td>Author:</td>
<td>H. Sherry Zhang <a href="https://orcid.org/0000-0002-7122-1463"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Dianne Cook <a href="https://orcid.org/0000-0002-3813-7155"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Ursula Laa <a href="https://orcid.org/0000-0002-0249-6439"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Nicolas Langrené <a href="https://orcid.org/0000-0001-7601-4618"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Patricia Menéndez <a href="https://orcid.org/0000-0003-0701-6315"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>H. Sherry Zhang &lt;huize.zhang@monash.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-16 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidyindex-package'>tidyindex: A Tidy Data Pipeline to Construct, Compare, and Analyse Indexes</h2><span id='topic+tidyindex'></span><span id='topic+tidyindex-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Construct and analyse indexes in a pipeline tidy workflow. 'tidyindex' contains modules for transforming variables, aggregating variables across time, reducing data dimension through weighting, and fitting distributions. A manuscript describing the methodology can be found at <a href="https://github.com/huizezhang-sherry/paper-tidyindex">https://github.com/huizezhang-sherry/paper-tidyindex</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: H. Sherry Zhang <a href="mailto:huize.zhang@monash.edu">huize.zhang@monash.edu</a> (<a href="https://orcid.org/0000-0002-7122-1463">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Dianne Cook <a href="mailto:dicook@monash.edu">dicook@monash.edu</a> (<a href="https://orcid.org/0000-0002-3813-7155">ORCID</a>)
</p>
</li>
<li><p> Ursula Laa <a href="mailto:ursula.laa@boku.ac.at">ursula.laa@boku.ac.at</a> (<a href="https://orcid.org/0000-0002-0249-6439">ORCID</a>)
</p>
</li>
<li><p> Nicolas Langrené <a href="mailto:nicolas.langrene@csiro.au">nicolas.langrene@csiro.au</a> (<a href="https://orcid.org/0000-0001-7601-4618">ORCID</a>)
</p>
</li>
<li><p> Patricia Menéndez <a href="mailto:patricia.menendez@monash.edu">patricia.menendez@monash.edu</a> (<a href="https://orcid.org/0000-0003-0701-6315">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/huizezhang-sherry/tidyindex">https://github.com/huizezhang-sherry/tidyindex</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/huizezhang-sherry/tidyindex/issues">https://github.com/huizezhang-sherry/tidyindex/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_paras'>Add parameters to an index table object</h2><span id='topic+add_paras'></span>

<h3>Description</h3>

<p>The function joins the parameter table to the 'paras' element of an index
table object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_paras(data, para_tbl, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_paras_+3A_data">data</code></td>
<td>
<p>a <code>idx_tbl</code> object</p>
</td></tr>
<tr><td><code id="add_paras_+3A_para_tbl">para_tbl</code></td>
<td>
<p>a tibble or data frame object with parameter of variables</p>
</td></tr>
<tr><td><code id="add_paras_+3A_by">by</code></td>
<td>
<p>a single column name (support tidyselect) in the 'para_tbl' that
maps to the variable name in the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an index object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init(gggi) |&gt; add_paras(gggi_weights, by = "variable")
</code></pre>

<hr>
<h2 id='compute_indexes'>Calculate multiple indexes at once</h2><span id='topic+compute_indexes'></span><span id='topic+augment.idx_res'></span>

<h3>Description</h3>

<p>Calculate multiple indexes at once
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_indexes(.data, ...)

## S3 method for class 'idx_res'
augment(x, .id = ".id", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_indexes_+3A_.data">.data</code></td>
<td>
<p>an <code>idx_tbl</code> object</p>
</td></tr>
<tr><td><code id="compute_indexes_+3A_...">...</code></td>
<td>
<p>Unused, included for generic consistency only</p>
</td></tr>
<tr><td><code id="compute_indexes_+3A_x">x</code></td>
<td>
<p>an <code>idx_res</code> object, calculated from <code>compute_indexes</code></p>
</td></tr>
<tr><td><code id="compute_indexes_+3A_.id">.id</code></td>
<td>
<p>a character string, the name of the first column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>idx_res</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(lmomco)
library(generics)
res &lt;- tenterfield |&gt;
  mutate(month = lubridate::month(ym)) |&gt;
  init(id = id, time = ym, group = month) |&gt;
  compute_indexes(
    spi = idx_spi(),
    spei = idx_spei(.lat = lat, .tavg = tavg),
    edi = idx_edi()
 )
</code></pre>

<hr>
<h2 id='dimension_reduction'>The dimension reduction module</h2><span id='topic+dimension_reduction'></span><span id='topic+aggregate_linear'></span><span id='topic+aggregate_geometrical'></span><span id='topic+aggregate_manual'></span>

<h3>Description</h3>

<p>The module combines multiple variables into a new variable. The new variable
can be a linear combination of the original variables,
<code>aggregate_linear()</code>, or a geometric mean of the original variables,
<code>aggregate_geometry()</code>, or created from an user formula input,
<code>aggregate_manual()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimension_reduction(data, ...)

aggregate_linear(formula, weight)

aggregate_geometrical(formula)

aggregate_manual(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimension_reduction_+3A_data">data</code></td>
<td>
<p>used in <code>dimension_reduction()</code>, an <code>idx_tbl</code> object,
see [tidyindex::init()]</p>
</td></tr>
<tr><td><code id="dimension_reduction_+3A_...">...</code></td>
<td>
<p>used in <code>dimension_reduction()</code>, a dimension reduction
object of <code>dim_red</code> class, currently one of <code>aggregate_linear()</code>,
<code>aggregate_geometrical()</code>, or <code>aggregate_manual()</code>.</p>
</td></tr>
<tr><td><code id="dimension_reduction_+3A_formula">formula</code></td>
<td>
<p>the formula to evaluate</p>
</td></tr>
<tr><td><code id="dimension_reduction_+3A_weight">weight</code></td>
<td>
<p>used in <code>aggregate_linear()</code>, the column of the
linear weights from the <code>roles</code> element in an index table object.
See [tidyindex::add_paras()]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an index table object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- gggi |&gt;
  dplyr::select(country, sex_ratio_at_birth:healthy_life_expectancy) |&gt;
  init()

dt |&gt;
  dimension_reduction(health = aggregate_manual(
    ~sex_ratio_at_birth * 0.693 + healthy_life_expectancy * 0.307))
dt |&gt;
  add_paras(gggi_weights, by = variable) |&gt;
  dimension_reduction(health = aggregate_linear(
    ~sex_ratio_at_birth:healthy_life_expectancy, weight = var_weight))
dt |&gt;
  dimension_reduction(health = aggregate_geometrical(
    ~sex_ratio_at_birth:healthy_life_expectancy)
  )

</code></pre>

<hr>
<h2 id='distribution_fit'>The distribution fit module</h2><span id='topic+distribution_fit'></span><span id='topic+dist_gamma'></span><span id='topic+dist_glo'></span><span id='topic+dist_gev'></span><span id='topic+dist_pe3'></span>

<h3>Description</h3>

<p>This module fits a distribution to the variable of interest. Currently
implemented distributions are: gamma, <code>dist_gamma()</code>,
generalized logistic, <code>dist_glo()</code>, generalized extreme value,
<code>dist_gev()</code>, and Pearson Type III, <code>dist_pe3()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distribution_fit(data, ...)

dist_gamma(var, method = "lmoms", .n_boot = 1, .boot_seed = 123)

dist_glo(var, method = "lmoms", .n_boot = 1, .boot_seed = 123)

dist_gev(var, method = "lmoms", .n_boot = 1, .boot_seed = 123)

dist_pe3(var, method = "lmoms", .n_boot = 1, .boot_seed = 123)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribution_fit_+3A_data">data</code></td>
<td>
<p>an index table object</p>
</td></tr>
<tr><td><code id="distribution_fit_+3A_...">...</code></td>
<td>
<p>a distribution fit object, currently implemented are
<code>dist_gamma()</code>, <code>dist_glo()</code>, <code>dist_gev()</code>, and
<code>dist_pe3()</code></p>
</td></tr>
<tr><td><code id="distribution_fit_+3A_var">var</code></td>
<td>
<p>used in <code>dist_*()</code> functions, the variable to fit</p>
</td></tr>
<tr><td><code id="distribution_fit_+3A_method">method</code></td>
<td>
<p>used in <code>dist_*()</code> functions, the fitting method,
currently support &quot;lmoms&quot; for L-moment fit</p>
</td></tr>
<tr><td><code id="distribution_fit_+3A_.n_boot">.n_boot</code></td>
<td>
<p>the number of bootstrap replicate, default to 1</p>
</td></tr>
<tr><td><code id="distribution_fit_+3A_.boot_seed">.boot_seed</code></td>
<td>
<p>the seed to generate bootstrap replicate, default to 123</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an index table object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(lmomco)
tenterfield |&gt;
  mutate(month = lubridate::month(ym)) |&gt;
  init(id = id, time = ym, group = month) |&gt;
  temporal_aggregate(.agg = temporal_rolling_window(prcp, scale = 12)) |&gt;
  distribution_fit(.fit = dist_gamma(.agg, method = "lmoms"))
</code></pre>

<hr>
<h2 id='gggi'>Global Gender Gap Index (2023)</h2><span id='topic+gggi'></span><span id='topic+gggi_weights'></span>

<h3>Description</h3>

<p>The Global Gender Gap Index combines 14 variables from four dimensions to
measure the gender parity across 146 countries in the world.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gggi

gggi_weights
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 146 rows and 22 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 14 rows and 7 columns.
</p>


<h3>Details</h3>

<p>The dataset includes country, region, GGGI score and rank, the combined four
dimensions (Economic Participation and Opportunity, Educational Attainment,
Health and Survival, and Political Empowerment), and variables under each
dimensions. The variable composition of each dimension is as follows:
</p>
<p>* Economic Participation and Opportunity: Labour force
participation, Wage equality for similar work, Estimated earned income,
Legislators, senior officials and managers, and Professional and technical
workers
</p>
<p>* Educational attainment: Literacy rate, Enrolment in primary education,
Enrolment in secondary education, Enrolment in tertiary education
</p>
<p>* Health and survival: Sex ratio at birth and Healthy life expectancy
</p>
<p>* Political empowerment:  Women in parliament, Women in ministerial
positions, and Years with female head of state
</p>
<p>Variable names are cleaned with [janitor::clean_names()].
</p>
<p>The weight data is extracted from page 65 of the Global Gender Gap Report
(see reference), see page 61 for the region classification.
</p>


<h3>References</h3>

<p>https://www3.weforum.org/docs/WEF_GGGR_2023.pdf
</p>

<hr>
<h2 id='hdi'>Human Development Index (2022)</h2><span id='topic+hdi'></span><span id='topic+hdi_scales'></span>

<h3>Description</h3>

<p>Human Development Index (2022)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdi

hdi_scales
</code></pre>


<h3>Format</h3>

<p>A tibble with three columns:
</p>

<dl>
<dt>id</dt><dd><p>the row number</p>
</dd>
<dt>country</dt><dd><p>191 countries with computed HDI</p>
</dd>
<dt>hdi</dt><dd><p>the HDI index value</p>
</dd>
<dt>life_exp</dt><dd><p>life expectancy</p>
</dd>
<dt>exp_sch</dt><dd><p>expected schooling</p>
</dd>
<dt>avg_sch</dt><dd><p>average schooling</p>
</dd>
<dt>gni_pc</dt><dd><p>GNI per capital, logged</p>
</dd>
</dl>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 4 rows and 5 columns.
</p>


<h3>References</h3>

<p>https://hdr.undp.org/data-center/human-development-index#/indicies/HDI
</p>

<hr>
<h2 id='init'>Initialise the tidyindex pipeline</h2><span id='topic+init'></span><span id='topic+print.idx_tbl'></span>

<h3>Description</h3>

<p>Initialise an index table object with a data frame or a tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init(data, ...)

## S3 method for class 'idx_tbl'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_+3A_data">data</code></td>
<td>
<p>a tibble or data frame to be converted into a index object</p>
</td></tr>
<tr><td><code id="init_+3A_...">...</code></td>
<td>
<p>arguments to give variables roles, recorded in the <code>paras</code>
element of the index table object, currently used for <code>id</code> and
<code>time</code></p>
</td></tr>
<tr><td><code id="init_+3A_x">x</code></td>
<td>
<p>an index object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an index table object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init(hdi)
init(gggi)
</code></pre>

<hr>
<h2 id='normalise'>The normalise module</h2><span id='topic+normalise'></span><span id='topic+norm_quantile'></span>

<h3>Description</h3>

<p>The normalise module takes a probability value from a distribution fit
<code>norm_quantile()</code> to convert based on the normal quantile function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise(data, ...)

norm_quantile(var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalise_+3A_data">data</code></td>
<td>
<p>an index table object</p>
</td></tr>
<tr><td><code id="normalise_+3A_...">...</code></td>
<td>
<p>the expression to be evaluated</p>
</td></tr>
<tr><td><code id="normalise_+3A_var">var</code></td>
<td>
<p>used in <code>norm_quantile()</code>; the variable to be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an index table object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(lmomco)
tenterfield |&gt;
  mutate(month = lubridate::month(ym)) |&gt;
  init(id = id, time = ym, group = month) |&gt;
  temporal_aggregate(.agg = temporal_rolling_window(prcp, scale = 12)) |&gt;
  distribution_fit(.fit = dist_gamma(.agg, method = "lmoms")) |&gt;
  normalise(index = norm_quantile(.fit))
</code></pre>

<hr>
<h2 id='rescaling'>The rescaling module</h2><span id='topic+rescaling'></span><span id='topic+rescale_zscore'></span><span id='topic+rescale_minmax'></span><span id='topic+rescale_center'></span>

<h3>Description</h3>

<p>The rescale module changes the scale of the variable(s) using one of the
available rescaling functions: <code>rescale_zscore()</code>,
<code>rescale_minmax()</code>, and <code>rescale_center</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescaling(data, ...)

rescale_zscore(var, na.rm = TRUE)

rescale_minmax(var, min = NULL, max = NULL, na.rm = TRUE, censor = TRUE)

rescale_center(var, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaling_+3A_data">data</code></td>
<td>
<p>an index table object, see [tidyindex::init()]</p>
</td></tr>
<tr><td><code id="rescaling_+3A_...">...</code></td>
<td>
<p>used in <code>rescaling</code>, a rescaling object of class
<code>rescale</code>, currently one of the <code>rescale_zscore()</code>,
<code>rescale_minmax()</code>, and <code>rescale_center()</code>,</p>
</td></tr>
<tr><td><code id="rescaling_+3A_var">var</code></td>
<td>
<p>the variable(s) to rescale, accept tidyselect syntax</p>
</td></tr>
<tr><td><code id="rescaling_+3A_na.rm">na.rm</code></td>
<td>
<p>used in <code>rescale_*()</code>, logical, whether to remove NAs</p>
</td></tr>
<tr><td><code id="rescaling_+3A_min">min</code>, <code id="rescaling_+3A_max">max</code></td>
<td>
<p>used in <code>rescale_minmax()</code>, the minimum and maximum value</p>
</td></tr>
<tr><td><code id="rescaling_+3A_censor">censor</code></td>
<td>
<p>used in <code>rescale_minmax()</code>, logical;
whether to censor points outside min and max, if provided</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an index table object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- hdi |&gt; init()
dt |&gt; rescaling(life_exp = rescale_zscore(life_exp))
dt |&gt; rescaling(life_exp2 = rescale_minmax(life_exp, min = 20, max = 85))
</code></pre>

<hr>
<h2 id='swap_values'>Testing alternatives</h2><span id='topic+swap_values'></span><span id='topic+swap_exprs'></span>

<h3>Description</h3>

<p>The two functions allows you to substitute a value/expression in the pipeline
with other options. These functions will evaluate the modified pipeline step,
as well as its prior and subsequent steps to create different versions of the
index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_values(data, .var, .param, .values)

swap_exprs(data, .var, .exprs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_values_+3A_data">data</code></td>
<td>
<p>an <code>idx_tbl</code> object</p>
</td></tr>
<tr><td><code id="swap_values_+3A_.var">.var</code></td>
<td>
<p>the name of the variable, which the step is tested for
alternatives</p>
</td></tr>
<tr><td><code id="swap_values_+3A_.param">.param</code></td>
<td>
<p>the name of the parameter to swap</p>
</td></tr>
<tr><td><code id="swap_values_+3A_.values">.values</code>, <code id="swap_values_+3A_.exprs">.exprs</code></td>
<td>
<p>a list of values or expressions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an index table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(generics)
hdi_paras &lt;- hdi_scales |&gt;
dplyr::add_row(dimension = "Education", name = "Education",
               var = "sch", min = 0, max = 0) |&gt;
  dplyr::mutate(weight = c(1/3, 0, 0, 1/3, 1/3),
                weight2 = c(0.1, 0, 0, 0.8, 0.1),
                weight3 = c(0.8, 0, 0, 0.1, 0.1),
                weight4 = c(0.1, 0, 0, 0.1, 0.8))

dt &lt;- hdi |&gt;
  init(id = country) |&gt;
  add_paras(hdi_paras, by = var) |&gt;
  rescaling(life_exp = rescale_minmax(life_exp, min = min, max = max)) |&gt;
  rescaling(exp_sch = rescale_minmax(exp_sch, min = min, max = max)) |&gt;
  rescaling(avg_sch = rescale_minmax(avg_sch, min = min, max = max)) |&gt;
  rescaling(gni_pc = rescale_minmax(gni_pc, min = min, max = max)) |&gt;
  dimension_reduction(sch = aggregate_manual(~(exp_sch + avg_sch)/2)) |&gt;
  dimension_reduction(index = aggregate_linear(~c(life_exp, sch, gni_pc),
                      weight = weight))


dt2 &lt;- dt |&gt;
  swap_values(.var = "index", .param = weight,
              .value = list(weight2, weight3, weight4))
augment(dt2)

dt3 &lt;- dt |&gt;
  swap_exprs(.var = index, .exprs = list(
             aggregate_geometrical(~c(life_exp, sch, gni_pc))))
augment(dt3)
</code></pre>

<hr>
<h2 id='temporal_aggregate'>The temporal processing module</h2><span id='topic+temporal_aggregate'></span><span id='topic+temporal_rolling_window'></span>

<h3>Description</h3>

<p>The temporal processing module is used to aggregate data along the temporal
dimension. Current available aggregation recipe includes
<code>temporal_rolling_window</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temporal_aggregate(data, ...)

temporal_rolling_window(
  var,
  scale,
  .before = 0L,
  .step = 1L,
  .complete = TRUE,
  rm.na = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temporal_aggregate_+3A_data">data</code></td>
<td>
<p>an index table object, see [tidyindex::init()]</p>
</td></tr>
<tr><td><code id="temporal_aggregate_+3A_...">...</code></td>
<td>
<p>an temporal processing object of class <code>temporal_agg</code></p>
</td></tr>
<tr><td><code id="temporal_aggregate_+3A_var">var</code></td>
<td>
<p>the variable to aggregate</p>
</td></tr>
<tr><td><code id="temporal_aggregate_+3A_scale">scale</code></td>
<td>
<p>numeric, the scale (window) of the aggregation</p>
</td></tr>
<tr><td><code id="temporal_aggregate_+3A_.before">.before</code>, <code id="temporal_aggregate_+3A_.step">.step</code>, <code id="temporal_aggregate_+3A_.complete">.complete</code></td>
<td>
<p>see <code><a href="slider.html#topic+slide_dbl">slide_dbl</a></code></p>
</td></tr>
<tr><td><code id="temporal_aggregate_+3A_rm.na">rm.na</code></td>
<td>
<p>logical, whether to remove the first few rows with NAs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an index table object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tenterfield |&gt;
  init(time = ym) |&gt;
  temporal_aggregate(.agg = temporal_rolling_window(prcp, scale = 12))

# multiple ids (groups), and multiple scales
queensland |&gt;
  dplyr::filter(id %in% c("ASN00029038", "ASN00029127")) |&gt;
  init(id = id, time = ym) |&gt;
  temporal_aggregate(temporal_rolling_window(prcp, scale = c(12, 24)))
</code></pre>

<hr>
<h2 id='tenterfield'>Weather data for in-situ stations in Queensland from 1990 to 2020</h2><span id='topic+tenterfield'></span><span id='topic+aus_climate'></span><span id='topic+queensland'></span>

<h3>Description</h3>

<p>Weather data for in-situ stations in Queensland from 1990 to 2020
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tenterfield

aus_climate

queensland
</code></pre>


<h3>Format</h3>

<p>A tibble with 9 columns:
</p>

<dl>
<dt>id</dt><dd><p>station ID, ASN000xxxxx</p>
</dd>
<dt>ym</dt><dd><p>date in 'tsibble::yearmonth' format</p>
</dd>
<dt>prcp</dt><dd><p>aggregated monthly precipitation from daily data</p>
</dd>
<dt>tmax, tmin, tavg</dt><dd><p>maximum/minimum/ average temperature</p>
</dd>
<dt>long, lat</dt><dd><p>longitude and latitude of the station</p>
</dd>
<dt>name</dt><dd><p>station name</p>
</dd>
</dl>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 52373 rows and 9 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 11252 rows and 9 columns.
</p>

<hr>
<h2 id='theme_benchmark'>A ggplot2 theme for benchmarking the index series</h2><span id='topic+theme_benchmark'></span>

<h3>Description</h3>

<p>A ggplot2 theme for benchmarking the index series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_benchmark(yintercept = -2, linetype = "dashed")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_benchmark_+3A_yintercept">yintercept</code></td>
<td>
<p>intercept</p>
</td></tr>
<tr><td><code id="theme_benchmark_+3A_linetype">linetype</code></td>
<td>
<p>linetype</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE) ){
dplyr::tibble(x = 1:100, y = rnorm(100, sd = 2)) |&gt;
  ggplot(aes(x = x, y =y )) +
  geom_line() +
  theme_benchmark()
}
</code></pre>

<hr>
<h2 id='trans_thornthwaite'>Drought-related index functions</h2><span id='topic+trans_thornthwaite'></span><span id='topic+idx_spi'></span><span id='topic+idx_spei'></span><span id='topic+idx_rdi'></span><span id='topic+idx_edi'></span>

<h3>Description</h3>

<p>The functions are used for quick computing of some common drought indexes
built from wrappers of the underlying modules. For more customised needs,
users may build their own indexes from the modules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans_thornthwaite(var, lat, na.rm = FALSE, verbose = TRUE)

idx_spi(data, .prcp, .dist = dist_gamma(), .scale = 12)

idx_spei(
  data,
  .tavg,
  .lat,
  .prcp,
  .pet_method = trans_thornthwaite(),
  .scale = 12,
  .dist = dist_glo()
)

idx_rdi(
  data,
  .tavg,
  .lat,
  .prcp,
  .pet_method = trans_thornthwaite(),
  .scale = 12
)

idx_edi(data, .tavg, .lat, .prcp, .scale = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans_thornthwaite_+3A_var">var</code></td>
<td>
<p>the variable to be transformed, see [tidyindex::variable_trans()]
and [SPEI::thornthwaite()]</p>
</td></tr>
<tr><td><code id="trans_thornthwaite_+3A_lat">lat</code>, <code id="trans_thornthwaite_+3A_na.rm">na.rm</code>, <code id="trans_thornthwaite_+3A_verbose">verbose</code></td>
<td>
<p>see [SPEI::thornthwaite]</p>
</td></tr>
<tr><td><code id="trans_thornthwaite_+3A_data">data</code></td>
<td>
<p>an <code>id_tbl</code> object</p>
</td></tr>
<tr><td><code id="trans_thornthwaite_+3A_.dist">.dist</code></td>
<td>
<p>the distribution used for distribution fit, see
[tidyindex::distribution_fit()]</p>
</td></tr>
<tr><td><code id="trans_thornthwaite_+3A_.scale">.scale</code></td>
<td>
<p>the temporal aggregation scale, see
[tidyindex::temporal_aggregation()]</p>
</td></tr>
<tr><td><code id="trans_thornthwaite_+3A_.tavg">.tavg</code>, <code id="trans_thornthwaite_+3A_.lat">.lat</code>, <code id="trans_thornthwaite_+3A_.prcp">.prcp</code></td>
<td>
<p>variables to be used in the index calculation, see Details</p>
</td></tr>
<tr><td><code id="trans_thornthwaite_+3A_.pet_method">.pet_method</code></td>
<td>
<p>the method used for calculating potential
evapotranspitation, currently only <code>trans_thornthwaite()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below explains the steps wrapped in each index and the intermediate
variables created.
</p>
<p>The <code>idx_spi()</code> function performs
</p>

<ol>
<li><p>a temporal aggregation on the input precipitation series,
<code>.prcp</code>, as <code>.agg</code>,
</p>
</li>
<li><p>a distribution fit step on the aggregated precipitation
, <code>.agg</code>, as <code>.fit</code>, and
</p>
</li>
<li><p>a normalising step on the fitted values, <code>.fit</code>, as
<code>.index</code>
</p>
</li></ol>

<p>The <code>idx_spei()</code> function performs
</p>

<ol>
<li><p>a variable transformation step on the inut average temperature,
<code>.tavg</code>, to obtain the potential evapotranspiration, <code>.pet</code>,
</p>
</li>
<li><p>a dimension reduction step to calculate difference series,
<code>.diff</code>, between the input precipitation series, <code>.prcp</code>,
and <code>.pet</code>,
</p>
</li>
<li><p>a temporal aggregation step on the difference series, <code>.diff</code>,
as <code>.agg</code>, 
</p>
</li>
<li><p>a distribution fit step on the aggregated series, <code>.agg</code>,
as <code>.fit</code>, and
</p>
</li>
<li><p>a normalising step on the fitted value, <code>.fit</code>, to
obtain <code>.index</code>.
</p>
</li></ol>

<p>The <code>idx_rdi()</code> function performs
</p>

<ol>
<li><p>a variable transformation step on the input average temperature,
<code>.tavg</code>, to obtain potential evapotranspiration <code>.pet</code>,
</p>
</li>
<li><p>a dimension reduction step to calculate the ratio of input
precipitation, <code>.prcp</code>, to <code>.pet</code> as <code>.ratio</code>,
</p>
</li>
<li><p>a temporal aggregation step on the ratio series, <code>.ratio</code>, as
<code>.agg</code>
</p>
</li>
<li><p>a variable transformation step to take the log10 of the aggregated
series, <code>.agg</code>, as <code>.y</code>, and
</p>
</li>
<li><p>a rescaling step to rescale <code>.y</code> by zscore to obtain
<code>.index</code>.
</p>
</li></ol>

<p>The <code>idx_edi()</code> function performs
</p>

<ol>
<li><p>a dimension reduction step to aggregate the input precipitation
series, <code>prcp</code>, as <code>.mult</code>,
</p>
</li>
<li><p>a temporal aggregation step on the aggregated precipitation series
(<code>.mult</code>) as <code>.ep</code>, and
</p>
</li>
<li><p>a rescaling step to rescale <code>.ep</code> by zscore to obtain
<code>.index</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>an index table object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(lmomco)
dt &lt;- tenterfield |&gt;
  mutate(month = lubridate::month(ym)) |&gt;
  init(id = id, time = ym, group = month)

dt |&gt; idx_spi()
dt |&gt; idx_spi(.scale = c(12, 24))
dt |&gt; idx_spei(.lat = lat, .tavg = tavg)
dt |&gt; idx_rdi(.lat = lat, .tavg = tavg)
dt |&gt; idx_edi(.lat = lat, .tavg = tavg)

</code></pre>

<hr>
<h2 id='variable_trans'>The variable transformation module</h2><span id='topic+variable_trans'></span><span id='topic+trans_log10'></span><span id='topic+trans_quadratic'></span><span id='topic+trans_square_root'></span><span id='topic+trans_cubic_root'></span>

<h3>Description</h3>

<p>The variable transformation module is used to transform a single variable
in the index table object. The transformation is specified by a variable
transformation object of class <code>var_trans</code>, created by
<code>trans_*</code> functions. Currently, the following transformation functions
are supported: <code>trans_log10</code>, <code>trans_quadratic</code>,
<code>trans_square_root</code>, and <code>trans_cubic_root</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variable_trans(data, ...)

trans_log10(var)

trans_quadratic(var)

trans_square_root(var)

trans_cubic_root(var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variable_trans_+3A_data">data</code></td>
<td>
<p>an index table object</p>
</td></tr>
<tr><td><code id="variable_trans_+3A_...">...</code></td>
<td>
<p>an variable transformation recipe of class <code>var_trans</code>,
created by <code>trans_*</code> function, the transformation recipe to be
evaluated</p>
</td></tr>
<tr><td><code id="variable_trans_+3A_var">var</code></td>
<td>
<p>used in <code>trans_*</code> functions, the variable to be transformed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an index table object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hdi |&gt; init() |&gt; variable_trans(gni_pc = trans_log10(gni_pc))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
