<!DOCTYPE html><html><head><title>Help for package simule</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simule}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simule-package'>
<p>Shared and Individual parts of MULtiple graphs Explicitly</p></a></li>
<li><a href='#cancer'><p>Microarray data set for breast cancer</p></a></li>
<li><a href='#exampleData'><p>A simulated toy dataset that includes 2 data matrices (from 2 related</p>
tasks).</a></li>
<li><a href='#exampleDataGraph'><p>A simulated toy dataset that includes 3 igraph objects</p></a></li>
<li><a href='#nip_37_data'><p>NIPS word count dataset</p></a></li>
<li><a href='#plot.simule'><p>Plot simule result specified by user input</p></a></li>
<li><a href='#returngraph'><p>return igraph object from simule result specified by user input</p></a></li>
<li><a href='#simule'><p>A constrained l1 minimization approach for estimating multiple Sparse</p>
Gaussian or Nonparanormal Graphical Models
Estimate multiple, related sparse Gaussian or Nonparanormal graphical</a></li>
<li><a href='#wsimule'><p>A constrained and weighted l1 minimization approach for estimating multiple</p>
Sparse Gaussian or Nonparanormal Graphical Models</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-07-02</td>
</tr>
<tr>
<td>Title:</td>
<td>A Constrained L1 Minimization Approach for Estimating Multiple
Sparse Gaussian or Nonparanormal Graphical Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Beilun Wang [aut, cre],
  Yanjun Qi [aut],
  Zhaoyang Wang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Beilun Wang &lt;bw4mw@virginia.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), lpSolve, pcaPP, igraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel</td>
</tr>
<tr>
<td>Description:</td>
<td>This is an R implementation of a constrained l1 minimization approach for estimating multiple Sparse Gaussian or Nonparanormal Graphical Models (SIMULE). The SIMULE algorithm can be used to estimate multiple related precision matrices. For instance, it can identify context-specific gene networks from multi-context gene expression datasets. By performing data-driven network inference from high-dimensional and heterogenous data sets, this tool can help users effectively translate aggregated data into knowledge that take the form of graphs among entities. Please run demo(simuleDemo) to learn the basic functions provided by this package. For further details, please read the original paper: Beilun Wang, Ritambhara Singh, Yanjun Qi (2017) &lt;<a href="https://doi.org/10.1007%2Fs10994-017-5635-7">doi:10.1007/s10994-017-5635-7</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/QData/SIMULE">https://github.com/QData/SIMULE</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/QData/SIMULE">https://github.com/QData/SIMULE</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-02 20:41:57 UTC; Karen Chen</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-02 21:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='simule-package'>
Shared and Individual parts of MULtiple graphs Explicitly</h2><span id='topic+simule-package'></span>

<h3>Description</h3>

<p>This is an R implementation of a constrained l1 minimization approach for estimating multiple Sparse Gaussian or Nonparanormal Graphical Models (SIMULE). The SIMULE algorithm can be used to estimate multiple related precision matrices. For instance, it can identify context-specific gene networks from multi-context gene expression datasets. By performing data-driven network inference from high-dimensional and heterogeneous datasets, this tool can help users effectively translate aggregated data into knowledge that take the form of graphs among entities.
This package includes two graphical model options: Gaussian Graphical model and nonparanormal graphical model. The first model assumes that each dataset follows the Gaussian Distribution. The second one assumes that each dataset is nonparanormal distributed. This package provides two computational options: the multi-threading implementation and the single-threading implementation. Please run <code>demo(simuleDemo)</code> to learn the basic functions provided by this package.  For further details, please read the original paper:  &lt;http://link.springer.com/article/10.1007/s10994-017-5635-7&gt;.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> simule</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-07-02</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Identifying context-specific entity networks from aggregated data is an important task, often arising in bioinformatics and neuroimaging. Computationally, this task can be formulated as jointly estimating multiple different, but related, sparse Undirected Graphical Models (UGM) from aggregated samples across several contexts. Previous joint-UGM studies have mostly focused on sparse Gaussian Graphical Models (sGGMs) and can't identify context-specific edge patterns directly. We, therefore, propose a novel approach, SIMULE (detecting Shared and Individual parts of MULtiple graphs Explicitly) to learn multi-UGM via a constrained L1 minimization. SIMULE automatically infers both specific edge patterns that are unique to each context and shared interactions preserved among all the contexts. Through the L1 constrained formulation, this problem is cast as multiple independent subtasks of linear programming that can be solved efficiently in parallel. In addition to Gaussian data, SIMULE can also handle multivariate nonparanormal data that greatly relaxes the normality assumption that many real-world applications do not follow. We provide a novel theoretical proof showing that SIMULE achieves a consistent result at the rate O(log(Kp)/n_tot). On multiple synthetic datasets and two biomedical datasets, SIMULE shows significant improvement over state-of-the-art multi-sGGM and single-UGM baselines.
</p>


<h3>Author(s)</h3>

<p>Beilun Wang, Zhaoyang Wang (Arthur)
Beilun Wang(Maintainer)
</p>


<h3>References</h3>

<p>Beilun Wang, Ritambhara Singh, Yanjun Qi (2017).  A constrained L1 minimization approach for estimating multiple Sparse Gaussian or Nonparanormal Graphical Models. &lt;http://link.springer.com/article/10.1007/s10994-017-5635-7&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(exampleData)
simule(X = exampleData , 0.05, 1, covType = "cov", TRUE)
wsimule(X = exampleData , 0.05, 1, W = matrix(1,100,100), covType = "cov", TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cancer'>Microarray data set for breast cancer</h2><span id='topic+cancer'></span>

<h3>Description</h3>

<p><em>et al</em>'s paper. It concerns one hundred thirty-three patients with
stage I&ndash;III breast cancer.  Patients were treated with chemotherapy prior
to surgery. Patient response to the treatment can be classified as either a
pathologic complete response (pCR) or residual disease (not-pCR). Hess
<em>et al</em> developed and tested a reliable multigene predictor for
treatment response on this data set, composed by a set of 26 genes having a
high predictive value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cancer)
</code></pre>


<h3>Format</h3>

<p>a list of two objects: dataframe with 133 observations of 26 features and
factors indicating whether each sample (out of 133) is of type &quot;not&quot; or type &quot;pcr&quot;</p>


<h3>Details</h3>

<p>The dataset splits into 2 parts (pCR and not pCR), on which network
inference algorithms should be applied independently or in the multitask
framework: only individuals from the same classes should be consider as
independent and identically distributed.
</p>


<h3>References</h3>

<p>J.A. Mejia, D. Booser, R.L. Theriault, U.  Buzdar, P.J. Dempsey, R. Rouzier,
N. Sneige, J.S. Ross, T. Vidaurre, H.L. Gomez, G.N. Hortobagyi, and L.
Pustzai (2006). Pharmacogenomic predictor of sensitivity to preoperative
chemotherapy with Paclitaxel and Fluorouracil, Doxorubicin, and
Cyclophosphamide in breast cancer, <em>Journal of Clinical Oncology</em>, vol.
24(26), pp. 4236&ndash;4244.
</p>

<hr>
<h2 id='exampleData'>A simulated toy dataset that includes 2 data matrices (from 2 related
tasks).</h2><span id='topic+exampleData'></span>

<h3>Description</h3>

<p>A simulated toy dataset that includes 2 data matrices (from 2 related
tasks). Each data matrix is about 100 features observed in 200 samples. The
two data matrices are about exactly the same set of 100 features. This
multi-task dataset is generated from two related random graphs. Please run
demo(simule) to learn the basic functions provided by this package.  For
further details, please read the original paper:
&lt;http://link.springer.com/article/10.1007/s10994-017-5635-7&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exampleData)
</code></pre>


<h3>Format</h3>

<p>The format is: List of 2 matrices $ : num [1:200, 1:100] -0.0982
-0.2417 -1.704 0.4 ...  ..- attr(*, &quot;dimnames&quot;)=List of 2 .. ..$ : NULL ..
..$ : NULL $ : num [1:200, 1:100] -0.161 0.41 0.17 0. ...  ..- attr(*,
&quot;dimnames&quot;)=List of 2 .. ..$ : NULL .. ..$ : NULL</p>

<hr>
<h2 id='exampleDataGraph'>A simulated toy dataset that includes 3 igraph objects</h2><span id='topic+exampleDataGraph'></span>

<h3>Description</h3>

<p>(first one being the shared graph and second and third being task specific 1 and 2 graphs)
The graphs are generated from two related random graphs and the underlaying high dimensional gaussian distribution
generates the exampleData dataset. exampleDataGraph serves as a groundtruth to compare in demo(synthetic).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exampleDataGraph)
</code></pre>


<h3>Format</h3>

<p>A list of 3 igraph objects</p>

<hr>
<h2 id='nip_37_data'>NIPS word count dataset</h2><span id='topic+nip_37_data'></span>

<h3>Description</h3>

<p>This NIPS Conference Papers 1987-2015 Data set is avaiable at UCI Machine Learning Repository.
The original dataset is in the form of a 11463 x 5812 matrix of word counts (11463 words and 5812 conference papers)
Due to the size of the original dataset, it is preprocessed and reduced to a list of two matrices (2900 x 37 and 2911 x 37)
The dataset consists of two tasks (early (up to 2006) and recent (after 2006) NIPS conference papers) with 37 words
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nip_37_data)
</code></pre>


<h3>Format</h3>

<p>a list of two nonnegative integer matrices (1:2900, 1:37) and (1:2911,1:37)
Columns are named with year_paperid and rows are names with word name</p>


<h3>References</h3>

<p>'Poisson Random Fields for Dynamic Feature Models'. Perrone V., Jenkins P. A., Spano D., Teh Y. W. (2016)
</p>

<hr>
<h2 id='plot.simule'>Plot simule result specified by user input</h2><span id='topic+plot.simule'></span>

<h3>Description</h3>

<p>This function can plot and return multiple sparse graphs distinguished by edge colors
from the result generated by simule
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simule'
plot(x, graphlabel = NULL, type = "task",
  neighbouroption = "task", subID = NULL, index = NULL,
  graphlayout = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.simule_+3A_x">x</code></td>
<td>
<p>output generated from simule/wsimule function (simule/wsimule class)</p>
</td></tr>
<tr><td><code id="plot.simule_+3A_graphlabel">graphlabel</code></td>
<td>
<p>vertex names for the graph, there are three options:
(1) NA (no label)
(2) NULL (default numeric label according to the feature order)
(3) a vector of labels (a vector of labels cooresponding to x)
deault value is NULL</p>
</td></tr>
<tr><td><code id="plot.simule_+3A_type">type</code></td>
<td>
<p>type of graph, there are four options:
(1) &quot;task&quot; (graph for each task (including shared part) specified further by subID (task number))
(2) &quot;share&quot; (shared graph for all tasks)
(3) &quot;taskspecific&quot; (graph for each task specific (excluding shared part)
specified further by subID (task number) )
(4) &quot;neighbour&quot; (zoom into nodes in the graph specified further by neighbouroptoin, subID (task number)
and index (node id))</p>
</td></tr>
<tr><td><code id="plot.simule_+3A_neighbouroption">neighbouroption</code></td>
<td>
<p>determines what type of graph to zoom into when parameter type is &quot;neighbour&quot;
There are two options:
(1) &quot;task&quot; (zoom into graph for each task (including shared part))
(2) &quot;taskspecific&quot; (zoom into graph for each task specific (excluding shared part))</p>
</td></tr>
<tr><td><code id="plot.simule_+3A_subid">subID</code></td>
<td>
<p>selects which task to display
(1) 0 (only allowed when type is task or type is neighbour and neighbouroption is task) (selecting share graph)
(2) positive task number (selects a task number)
(3) a vector of task number (selects multiple tasks)
(4) NULL (selects all tasks (all graphs))</p>
</td></tr>
<tr><td><code id="plot.simule_+3A_index">index</code></td>
<td>
<p>determines which node(s) to zoom into when parameter type is &quot;neighbour&quot;
could either be an integer or vector of integers representing node ids
(zoom into one node or multiple nodes)</p>
</td></tr>
<tr><td><code id="plot.simule_+3A_graphlayout">graphlayout</code></td>
<td>
<p>layout for the graph (two column matrix specifying x,y coordinates of each node in graph)
if not provided, igraph will use the default layout_nicely() function present the graph</p>
</td></tr>
<tr><td><code id="plot.simule_+3A_...">...</code></td>
<td>
<p>extra parameters passed to plot.igraph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>when only the simulresult is provided, the function will plot all graphs with default numeric labels
User can specify multiple subID and multiple index to zoom in multiple nodes on multiple graphs
Each graph will include a decriptive title and legend to indicate correspondence between edge color and task.
The function will plot graph and return an igraph object at the same time
</p>


<h3>Value</h3>

<p>a plot of graph / subgraph from simule result specified by user input
</p>


<h3>Author(s)</h3>

<p>Beilun Wang, Zhaoyang Wang (Author), Beilun Wang (maintainer)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(exampleData)
result = simule(X = exampleData , lambda = 0.1, epsilon = 0.45, covType = "cov", FALSE)
plot.simule(result,  graphlabel = NULL, type="task", graphlayout = NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='returngraph'>return igraph object from simule result specified by user input</h2><span id='topic+returngraph'></span>

<h3>Description</h3>

<p>This function can return an igraph object from simule result for user to work with directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returngraph(x, type = "task", neighbouroption = "task", subID = NULL,
  index = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="returngraph_+3A_x">x</code></td>
<td>
<p>output generated from simule/wsimule function (simule/wsimule class)</p>
</td></tr>
<tr><td><code id="returngraph_+3A_type">type</code></td>
<td>
<p>type of graph, there are four options:
(1) &quot;task&quot; (graph for each task (including shared part) specified further by subID (task number))
(2) &quot;share&quot; (shared graph for all tasks)
(3) &quot;taskspecific&quot; (graph for each task specific (excluding shared part)
specified further by subID (task number) )
(4) &quot;neighbour&quot; (zoom into nodes in the graph specified further by neighbouroptoin, subID (task number)
and index (node id))</p>
</td></tr>
<tr><td><code id="returngraph_+3A_neighbouroption">neighbouroption</code></td>
<td>
<p>determines what type of graph to zoom into when parameter type is &quot;neighbour&quot;
There are two options:
(1) &quot;task&quot; (zoom into graph for each task (including shared part))
(2) &quot;taskspecific&quot; (zoom into graph for each task specific (excluding shared part))</p>
</td></tr>
<tr><td><code id="returngraph_+3A_subid">subID</code></td>
<td>
<p>selects which task to display
(1) 0 (only allowed when type is task or type is neighbour and neighbouroption is task) (selecting share graph)
(2) positive task number (selects a task number)
(3) a vector of task number (selects multiple tasks)
(4) NULL (selects all tasks (all graphs))</p>
</td></tr>
<tr><td><code id="returngraph_+3A_index">index</code></td>
<td>
<p>determines which node(s) to zoom into when parameter type is &quot;neighbour&quot;
could either be an integer or vector of integers representing node ids
(zoom into one node or multiple nodes)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the function aims to provide users the flexibility to explore and visualize the graph own their own
generated from simule / wsimule
</p>


<h3>Value</h3>

<p>an igraph object of graph / subgraph from simule result specified by user input
</p>


<h3>Author(s)</h3>

<p>Beilun Wang, Zhaoyang Wang (Author), Beilun Wang (maintainer)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(exampleData)
result = simule(X = exampleData , lambda = 0.1, epsilon = 0.45, covType = "cov", TRUE)
graph = returngraph(result, type="task")

## End(Not run)
</code></pre>

<hr>
<h2 id='simule'>A constrained l1 minimization approach for estimating multiple Sparse
Gaussian or Nonparanormal Graphical Models
Estimate multiple, related sparse Gaussian or Nonparanormal graphical</h2><span id='topic+simule'></span>

<h3>Description</h3>

<p>models from multiple related datasets using the SIMULE algorithm. Please
run demo(simule) to learn the basic functions provided by this package.
For further details, please read the original paper: Beilun Wang,
Ritambhara Singh, Yanjun Qi (2017) &lt;DOI:10.1007/s10994-017-5635-7&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simule(X, lambda, epsilon = 1, covType = "cov", parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simule_+3A_x">X</code></td>
<td>
<p>A List of input matrices. They can be data matrices or
covariance/correlation matrices. If every matrix in the X is a symmetric
matrix, the matrices are assumed to be covariance/correlation matrices.
More details at &lt;https://github.com/QData/SIMULE&gt;</p>
</td></tr>
<tr><td><code id="simule_+3A_lambda">lambda</code></td>
<td>
<p>A positive number. The hyperparameter controls the sparsity
level of the matrices. The \eqn\lambda_n in the following section:
Details.</p>
</td></tr>
<tr><td><code id="simule_+3A_epsilon">epsilon</code></td>
<td>
<p>A positive number. The hyperparameter controls the
differences between the shared pattern among graphs and the individual part
of each graph. The \eqn\epsilon in the following section: Details. If
epsilon becomes larger, the generated graphs will be more similar to each
other. The default value is 1, which means that we set the same weights to
the shared pattern among graphs and the individual part of each graph.</p>
</td></tr>
<tr><td><code id="simule_+3A_covtype">covType</code></td>
<td>
<p>A parameter to decide which Graphical model we choose to
estimate from the input data.
</p>
<p>If covType = &quot;cov&quot;, it means that we estimate multiple sparse Gaussian
Graphical models. This option assumes that we calculate (when input X
represents data directly) or use (when X elements are symmetric
representing covariance matrices) the sample covariance matrices as input
to the simule algorithm.
</p>
<p>If covType = &quot;kendall&quot;, it means that we estimate multiple nonparanormal
Graphical models. This option assumes that we calculate (when input X
represents data directly) or use (when X elements are symmetric
representing correlation matrices) the kendall's tau correlation matrices
as input to the simule algorithm.</p>
</td></tr>
<tr><td><code id="simule_+3A_parallel">parallel</code></td>
<td>
<p>A boolean. This parameter decides if the package will use
the multithreading architecture or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SIMULE algorithm is a constrained l1 minimization method that can
detect both the shared and the task-specific parts of multiple graphs
explicitly from data (through jointly estimating multiple sparse Gaussian
graphical models or Nonparanormal graphical models). It solves the
following equation: \deqn \hat\Omega^(1)_I, \hat\Omega^(2)_I,
\dots, \hat\Omega^(K)_I, \hat\Omega_S =
\min\limits_\Omega^(i)_I,\Omega_S\sum\limits_i ||\Omega^(i)_I||_1+
\epsilon K||\Omega_S||_1  Subject to : \deqn
||\Sigma^(i)(\Omega^(i)_I + \Omega_S) - I||_\infty \le \lambda_n, i
= 1,\dots,K \nonumber  Please also see the equation (7) in our paper. The
\eqn\lambda_n is the hyperparameter controlling the sparsity level of the
matrices and it is the \codelambda in our function. The \eqn\epsilon is
the hyperparameter controlling the differences between the shared pattern
among graphs and the individual part of each graph. It is the
\codeepsilon parameter in our function and the default value is 1. For
further details, please see our paper:
&lt;http://link.springer.com/article/10.1007/s10994-017-5635-7&gt;.
</p>


<h3>Value</h3>

<p>\itemGraphsA list of the estimated inverse
covariance/correlation matrices. \itemshareThe share graph among
multiple tasks.
</p>


<h3>Author(s)</h3>

<p>Beilun Wang
</p>


<h3>References</h3>

<p>Beilun Wang, Ritambhara Singh, Yanjun Qi (2017).  A constrained
L1 minimization approach for estimating multiple Sparse Gaussian or
Nonparanormal Graphical Models.
http://link.springer.com/article/10.1007/s10994-017-5635-7
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(exampleData)
result = simule(X = exampleData , lambda = 0.1, epsilon = 0.45, covType = "cov", FALSE)
plot.simule(result)

## End(Not run)
</code></pre>

<hr>
<h2 id='wsimule'>A constrained and weighted l1 minimization approach for estimating multiple
Sparse Gaussian or Nonparanormal Graphical Models</h2><span id='topic+wsimule'></span>

<h3>Description</h3>

<p>Estimate multiple, related sparse Gaussian or Nonparanormal graphical models
from multiple related datasets using the SIMULE algorithm. Please run
demo(wsimule) to learn the basic functions provided by this package.
For further details, please read the original paper: Beilun Wang, Ritambhara
Singh, Yanjun Qi (2017) &lt;DOI:10.1007/s10994-017-5635-7&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wsimule(X, lambda, epsilon = 1, W, covType = "cov", parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wsimule_+3A_x">X</code></td>
<td>
<p>A List of input matrices. They can be data matrices or
covariance/correlation matrices. If every matrix in the X is a symmetric
matrix, the matrices are assumed to be covariance/correlation matrices. More
details at &lt;https://github.com/QData/SIMULE&gt;</p>
</td></tr>
<tr><td><code id="wsimule_+3A_lambda">lambda</code></td>
<td>
<p>A positive number. The hyperparameter controls the sparsity
level of the matrices. The <code class="reqn">\lambda_n</code> in the following section:
Details.</p>
</td></tr>
<tr><td><code id="wsimule_+3A_epsilon">epsilon</code></td>
<td>
<p>A positive number. The hyperparameter controls the
differences between the shared pattern among graphs and the individual part
of each graph. The <code class="reqn">\epsilon</code> in the following section: Details. If
epsilon becomes larger, the generated graphs will be more similar to each
other. The default value is 1, which means that we set the same weights to
the shared pattern among graphs and the individual part of each graph.</p>
</td></tr>
<tr><td><code id="wsimule_+3A_w">W</code></td>
<td>
<p>A weight matrix. This matrix uses the prior knowledge of the
graphs. For example, if we use wsimule to infer multiple human brain
connectome graphs, the <code class="reqn">W</code> can be the anatomical distance matrix of
human brain. The default value is a matrix, whose entries all equals to 1.
This means that we do not have any prior knowledge.</p>
</td></tr>
<tr><td><code id="wsimule_+3A_covtype">covType</code></td>
<td>
<p>A parameter to decide which Graphical model we choose to
estimate from the input data.
</p>
<p>If covType = &quot;cov&quot;, it means that we estimate multiple sparse Gaussian
Graphical models. This option assumes that we calculate (when input X
represents data directly) or use (when X elements are symmetric representing
covariance matrices) the sample covariance matrices as input to the simule
algorithm.
</p>
<p>If covType = &quot;kendall&quot;, it means that we estimate multiple nonparanormal
Graphical models. This option assumes that we calculate (when input X
represents data directly) or use (when X elements are symmetric representing
correlation matrices) the kendall's tau correlation matrices as input to the
simule algorithm.</p>
</td></tr>
<tr><td><code id="wsimule_+3A_parallel">parallel</code></td>
<td>
<p>A boolean. This parameter decides if the package will use
the multithreading architecture or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SIMULE algorithm is a constrained l1 minimization method that can detect
both the shared and the task-specific parts of multiple graphs explicitly
from data (through jointly estimating multiple sparse Gaussian graphical
models or Nonparanormal graphical models). It solves the following equation:
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Omega}^{(1)}_I, \hat{\Omega}^{(2)}_I, \dots,
\hat{\Omega}^{(K)}_I, \hat{\Omega}_S =
\min\limits_{\Omega^{(i)}_I,\Omega_S}\sum\limits_i ||W \cdot
\Omega^{(i)}_I||_1+ \epsilon K||W \cdot \Omega_S||_1 </code>
</p>
<p> Subject to : </p>
<p style="text-align: center;"><code class="reqn">
||\Sigma^{(i)}(\Omega^{(i)}_I + \Omega_S) - I||_{\infty} \le \lambda_{n}, i
= 1,\dots,K \nonumber </code>
</p>
<p> Please also see the equation (7) in our paper. The
<code class="reqn">\lambda_n</code> is the hyperparameter controlling the sparsity level of the
matrices and it is the <code>lambda</code> in our function. The <code class="reqn">\epsilon</code> is
the hyperparameter controlling the differences between the shared pattern
among graphs and the individual part of each graph. It is the <code>epsilon</code>
parameter in our function and the default value is 1. For further details,
please see our paper:
&lt;http://link.springer.com/article/10.1007/s10994-017-5635-7&gt;.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Graphs</code></td>
<td>
<p>A list of the estimated inverse covariance/correlation
matrices.</p>
</td></tr> <tr><td><code>share</code></td>
<td>
<p>The share graph among multiple tasks.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Beilun Wang
</p>


<h3>References</h3>

<p>Beilun Wang, Ritambhara Singh, Yanjun Qi (2017).  A constrained
L1 minimization approach for estimating multiple Sparse Gaussian or
Nonparanormal Graphical Models.
http://link.springer.com/article/10.1007/s10994-017-5635-7
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(exampleData)
result = wsimule(X = exampleData , lambda = 0.1, epsilon = 0.45,
W = matrix(1,20,20), covType = "cov", FALSE)
plot.simule(result)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
