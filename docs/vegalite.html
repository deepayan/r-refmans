<!DOCTYPE html><html><head><title>Help for package vegalite</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vegalite}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#vegalite-package'><p>Create Vega-Lite specs using htmlwidget idioms</p></a></li>
<li><a href='#add_data'><p>Add data to a Vega-Lite spec</p></a></li>
<li><a href='#add_filter'><p>Add a filter</p></a></li>
<li><a href='#axis_facet_col'><p>General axis setttings (column facet)</p></a></li>
<li><a href='#axis_facet_row'><p>General axis setttings (row facets)</p></a></li>
<li><a href='#axis_x'><p>General axis setttings (x-axis)</p></a></li>
<li><a href='#axis_y'><p>General axis setttings (y-axis)</p></a></li>
<li><a href='#bin_x'><p>Group continuous data values (x-axis)</p></a></li>
<li><a href='#bin_y'><p>Group continuous data values (y-axis)</p></a></li>
<li><a href='#calculate'><p>Derive new fields</p></a></li>
<li><a href='#capture_widget'><p>Capture a static (png) version of a widget (e.g. for use in a PDF knitr document)</p></a></li>
<li><a href='#cell_size'><p>Add cell size to main Vega-Lite spec</p></a></li>
<li><a href='#config_color'><p>Color config</p></a></li>
<li><a href='#config_font'><p>Font config</p></a></li>
<li><a href='#config_opacity'><p>Opacity config</p></a></li>
<li><a href='#config_stroke'><p>Stroke config</p></a></li>
<li><a href='#config_text'><p>Text config</p></a></li>
<li><a href='#embed_spec'><p>Scaffold HTML/JavaScript/CSS code from <code>vegalite</code></p></a></li>
<li><a href='#encode_color'><p>Encode color &quot;channel&quot;</p></a></li>
<li><a href='#encode_detail'><p>Encode detail &quot;channel&quot;</p></a></li>
<li><a href='#encode_order'><p>Encode detail &quot;order&quot;</p></a></li>
<li><a href='#encode_path'><p>Encode detail &quot;path&quot;</p></a></li>
<li><a href='#encode_shape'><p>Encode shape &quot;channel&quot;</p></a></li>
<li><a href='#encode_size'><p>Encode size &quot;channel&quot;</p></a></li>
<li><a href='#encode_text'><p>Encode text &quot;channel&quot;</p></a></li>
<li><a href='#encode_x'><p>Encode x &quot;channel&quot;</p></a></li>
<li><a href='#encode_y'><p>Encode y &quot;channel&quot;</p></a></li>
<li><a href='#facet_cell'><p>Facet cell aesthetics</p></a></li>
<li><a href='#facet_col'><p>Create a horizontal ribbon of panels</p></a></li>
<li><a href='#facet_row'><p>Create a vertical ribbon of panels</p></a></li>
<li><a href='#filter_null'><p>Filter 'null' values</p></a></li>
<li><a href='#from_spec'><p>Take a JSON Vega-Lite Spec and render as an htmlwidget</p></a></li>
<li><a href='#grid_facet'><p>Facet grid aesthetics</p></a></li>
<li><a href='#JS'><p>Mark character strings as literal JavaScript code</p></a></li>
<li><a href='#legend_color'><p>Legend settings (color)</p></a></li>
<li><a href='#legend_shape'><p>Legend settings (shape)</p></a></li>
<li><a href='#legend_size'><p>Legend settings (size)</p></a></li>
<li><a href='#mark_area'><p>Area mark</p></a></li>
<li><a href='#mark_bar'><p>Bar mark</p></a></li>
<li><a href='#mark_circle'><p>Circle mark</p></a></li>
<li><a href='#mark_line'><p>Line mark</p></a></li>
<li><a href='#mark_point'><p>Point mark</p></a></li>
<li><a href='#mark_square'><p>Square mark</p></a></li>
<li><a href='#mark_text'><p>Text mark</p></a></li>
<li><a href='#mark_tick'><p>Tick mark</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#renderVegalite'><p>Widget render function for use in Shiny</p></a></li>
<li><a href='#saveWidget'><p>Save a widget to an HTML file</p></a></li>
<li><a href='#scale_color_nominal'><p>Nominal Color Scale</p></a></li>
<li><a href='#scale_color_sequential'><p>Sequential Color Scale</p></a></li>
<li><a href='#scale_shape'><p>Shape Scale</p></a></li>
<li><a href='#scale_x_linear'><p>Quantitative Scale</p></a></li>
<li><a href='#scale_x_log'><p>Log Scale</p></a></li>
<li><a href='#scale_x_ordinal'><p>Ordinal Scale</p></a></li>
<li><a href='#scale_x_pow'><p>Quantitative Scale</p></a></li>
<li><a href='#scale_x_quantile'><p>Quantile Scale</p></a></li>
<li><a href='#scale_x_quantize'><p>Quantize Scale</p></a></li>
<li><a href='#scale_x_sqrt'><p>Sqrt Scale</p></a></li>
<li><a href='#scale_x_threshold'><p>Threshold Scale</p></a></li>
<li><a href='#scale_x_time'><p>Temporal Scale</p></a></li>
<li><a href='#scale_y_linear'><p>Linear Scale</p></a></li>
<li><a href='#scale_y_log'><p>Log Scale</p></a></li>
<li><a href='#scale_y_ordinal'><p>Ordinal Scale</p></a></li>
<li><a href='#scale_y_pow'><p>Power Scale</p></a></li>
<li><a href='#scale_y_quantile'><p>Quantile Scale</p></a></li>
<li><a href='#scale_y_quantize'><p>Quantize Scale</p></a></li>
<li><a href='#scale_y_sqrt'><p>Sqrt Scale</p></a></li>
<li><a href='#scale_y_threshold'><p>Threshold Scale</p></a></li>
<li><a href='#scale_y_time'><p>Temporal Scale</p></a></li>
<li><a href='#sort_def'><p>Create a sort definition object</p></a></li>
<li><a href='#timeunit_x'><p>How to encode x-axis time values</p></a></li>
<li><a href='#timeunit_y'><p>How to encode y-axis time values</p></a></li>
<li><a href='#to_spec'><p>Convert a spec created with widget idioms to JSON</p></a></li>
<li><a href='#vegalite'><p>Create and (optionally) visualize a Vega-Lite spec</p></a></li>
<li><a href='#vegaliteOutput'><p>Widget output function for use in Shiny</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools to Encode Visualizations with the 'Grammar of
Graphics'-Like 'Vega-Lite' 'Spec'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-03-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bob Rudis &lt;bob@rudis.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'Vega-Lite' 'JavaScript' framework provides a higher-level grammar
    for visual analysis, akin to 'ggplot' or 'Tableau', that generates complete 'Vega'
    specifications. Functions exist which enable building a valid 'spec' from scratch
    or importing a previously created 'spec' file. Functions also exist to export 'spec'
    files and to generate code which will enable plots to be embedded in properly
    configured web pages. The default behavior is to generate an 'htmlwidget'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/hrbrmstr/vegalite">http://github.com/hrbrmstr/vegalite</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hrbrmstr/vegalite/issues">https://github.com/hrbrmstr/vegalite/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>jsonlite, htmlwidgets (&ge; 0.6), htmltools, magrittr, digest,
tools, clipr, utils, webshot, base64, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-03-22 01:12:02 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Bob Rudis [aut, cre],
  Kanit Wongsuphasawat, [aut] (Vega-Lite library),
  Jeffrey Heer [aut] (Vega-Lite library),
  Arvind Satyanarayan [aut] (Vega-Lite library),
  Mike Bostock [aut] (D3 library)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-03-22 23:51:16</td>
</tr>
</table>
<hr>
<h2 id='vegalite-package'>Create Vega-Lite specs using htmlwidget idioms</h2><span id='topic+vegalite-package'></span>

<h3>Description</h3>

<p>Creation of Vega-Lite spec charts is virtually 100% feature complete.
Some of the parameters to functions are only documented in TypeScript
source code which will take a bit of time to
wade through. All the visualizations you find in the
<a href="http://vega.github.io/vega-lite/gallery.html">Vega-Lite Gallery</a> work.
<br />
Functions also exist which enable creation of widgets from a JSON spec and
turning a <code>vegalite</code> package created object into a JSON spec.
</p>


<h3>Details</h3>

<p>You start by calling <code>vegalite()</code> which allows you to setup core
configuration options, including whether you want to display links to
show the source and export the visualization. You can also set the background
here and the <code>viewport_width</code> and <code>viewport_height</code>. Those are
very important as they control the height and width of the widget and also
the overall area for the chart. This does <em>not</em> set the height/width
of the actual chart. That is done with <code>cell_size()</code>.
</p>
<p>Once you instantiate the widget, you need to <code>add_data()</code> which can
be <code>data.frame</code>, local CSV, TSV or JSON file (that convert to
<code>data.frame</code>s) or a non-realive URL (wich will not be read and
converted but will remain a URL in the Vega-Lite spec.
</p>
<p>You then need to <code>encode_x()</code> &amp; <code>encode_y()</code> variables that
map to columns in the data spec and choose one <code>mark_...()</code> to
represent the encoding.
</p>
<p>Here's a sample, basic Vega-Lite widget:
</p>
<pre>
  dat &lt;- jsonlite::fromJSON('[
      {"a": "A","b": 28}, {"a": "B","b": 55}, {"a": "C","b": 43},
      {"a": "D","b": 91}, {"a": "E","b": 81}, {"a": "F","b": 53},
      {"a": "G","b": 19}, {"a": "H","b": 87}, {"a": "I","b": 52}
    ]')

vegalite() 
    add_data(dat) 
    encode_x("a", "ordinal") 
    encode_y("b", "quantitative") 
    mark_bar() -&gt; vl

vl
  </pre>
<p>That is the minimum set of requirements for a basic Vega-Lite spec and
will create a basic widget.
</p>
<p>You can also convert that R widget object <code>to_spec()</code> which will return
the JSON for the Vega-Lite spec (allowing you to use it outside of R).
</p>
<pre>

to_spec(vl)

{
  "description": "",
  "data": {
    "values": [
      { "a": "A", "b": 28 }, { "a": "B", "b": 55 }, { "a": "C", "b": 43 },
      { "a": "D", "b": 91 }, { "a": "E", "b": 81 }, { "a": "F", "b": 53 },
      { "a": "G", "b": 19 }, { "a": "H", "b": 87 }, { "a": "I", "b": 52 }
    ]
  },
  "mark": "bar",
  "encoding": {
    "x": {
      "field": "a",
      "type": "nominal"
    },
    "y": {
      "field": "b",
      "type": "quantitative"
    }
  },
  "config": [],
  "embed": {
    "renderer": "svg",
    "actions": {
      "export": false,
      "source": false,
      "editor": false
    }
  }
}

</pre>
<p>If you already have a Vega-Lite JSON spec that has embedded data or a
non-realtive URL, you can create a widget from it via <code>from_spec()</code>
by passing in the full JSON spec or a URL to a full JSON spec.
</p>
<p>If you're good with HTML (etc) and want a more lightweight embedding options, you
can also use <code><a href="#topic+embed_spec">embed_spec</a></code> which will scaffold a minimum <code>div</code> +
<code>script</code> source and embed a spec from a <code>vegalite</code> object.
</p>
<p>If you like the way Vega-Lite renders charts, you can also use them as static
images in PDF knitted documents with the new <code>capture_widget</code> function.
(NOTE that as of this writing, you can just use the development version of
<code>knitr</code> instead of this function.)
</p>


<h3>Author(s)</h3>

<p>Bob Rudis (@hrbrmstr)
</p>

<hr>
<h2 id='add_data'>Add data to a Vega-Lite spec</h2><span id='topic+add_data'></span>

<h3>Description</h3>

<p>Vega-Lite is more lightweight than full Vega. However, the spec is
flexible enough to support embedded data or using external sources that
are in JSON, CSV or TSV format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_data(vl, source, format_type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_data_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="add_data_+3A_source">source</code></td>
<td>
<p>you can specify a (fully qualified) URL or an existing
<code>data.frame</code> (or <code>ts</code>) object or a reference to a local file.
For the URL case, the <code>url</code> component of <code>data</code> will be set. You can help
Vega-Lite out by giving it a hint for the data type with <code>format_type</code>
but it is not required. For the local <code>data.frame</code> case it will embed
the data into the spec. For the case where a local file is specified, it
will be read in (either a JSON file, CSV file or TSV file) and converted
to a <code>data.frame</code> and embedded.</p>
</td></tr>
<tr><td><code id="add_data_+3A_format_type">format_type</code></td>
<td>
<p>if <code>source</code> is a URL, this should be one of <code>json</code>,
<code>csv</code> or <code>tsv</code>). It is not required and it is ignored if <code>source</code>
is not a URL.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/data.html">Vega-Lite Data spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- jsonlite::fromJSON('[
    {"a": "A","b": 28}, {"a": "B","b": 55}, {"a": "C","b": 43},
    {"a": "D","b": 91}, {"a": "E","b": 81}, {"a": "F","b": 53},
    {"a": "G","b": 19}, {"a": "H","b": 87}, {"a": "I","b": 52}
  ]')

vegalite() %&gt;%
  add_data(dat) %&gt;%
  encode_x("a", "ordinal") %&gt;%
  encode_y("b", "quantitative") %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='add_filter'>Add a filter</h2><span id='topic+add_filter'></span>

<h3>Description</h3>

<p>Add a filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_filter(vl, expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_filter_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object created by <code><a href="#topic+vegalite">vegalite</a></code></p>
</td></tr>
<tr><td><code id="add_filter_+3A_expr">expr</code></td>
<td>
<p>Vega Expression for filtering data items (or rows). Each datum
object can be referred using bound variable datum. For example, setting
<code>expr</code> to <code>"datum.datum.b2 &gt; 60"</code> would make the output data includes only
items that have values in the field <code>b2</code> over 60.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite(viewport_height=200, viewport_width=200) %&gt;%
  cell_size(200, 200) %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/population.json") %&gt;%
  add_filter("datum.year == 2000") %&gt;%
  calculate("gender", 'datum.sex == 2 ? "Female" : "Male"') %&gt;%
  encode_x("gender", "nominal") %&gt;%
  encode_y("people", "quantitative", aggregate="sum") %&gt;%
  encode_color("gender", "nominal") %&gt;%
  scale_x_ordinal(band_size=6) %&gt;%
  scale_color_nominal(range=c("#EA98D2", "#659CCA")) %&gt;%
  facet_col("age", "ordinal", padding=4) %&gt;%
  axis_x(remove=TRUE) %&gt;%
  axis_y(title="population", grid=FALSE) %&gt;%
  axis_facet_col(orient="bottom", axisWidth=1, offset=-8) %&gt;%
  facet_cell(stroke_width=0) %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='axis_facet_col'>General axis setttings (column facet)</h2><span id='topic+axis_facet_col'></span>

<h3>Description</h3>

<p>Axes provide axis lines, ticks and labels to convey how a spatial range represents
a data range. Simply put, axes visualize scales. <br />
<br />
By default, Vega-Lite automatically creates axes for x, y, row, and column channels
when they are encoded. Axis can be customized via the axis property of a channel
definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis_facet_col(vl, axisWidth = 0, layer = NULL, offset = NULL,
  grid = FALSE, labels = TRUE, labelAngle = NULL, labelAlign = NULL,
  labelBaseline = NULL, labelMaxLength = 25, shortTimeLabels = NULL,
  subdivide = NULL, ticks = NULL, tickPadding = NULL, tickSize = 0,
  tickSizeMajor = NULL, tickSizeMinor = NULL, tickSizeEnd = NULL,
  title = "", titleOffset = NULL, titleMaxLength = NULL,
  characterWidth = 6, orient = NULL, format = NULL, remove = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axis_facet_col_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="axis_facet_col_+3A_axiswidth">axisWidth</code>, <code id="axis_facet_col_+3A_layer">layer</code>, <code id="axis_facet_col_+3A_offset">offset</code>, <code id="axis_facet_col_+3A_grid">grid</code>, <code id="axis_facet_col_+3A_labels">labels</code>, <code id="axis_facet_col_+3A_labelangle">labelAngle</code>, <code id="axis_facet_col_+3A_labelalign">labelAlign</code>, <code id="axis_facet_col_+3A_labelbaseline">labelBaseline</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
<tr><td><code id="axis_facet_col_+3A_labelmaxlength">labelMaxLength</code>, <code id="axis_facet_col_+3A_shorttimelabels">shortTimeLabels</code>, <code id="axis_facet_col_+3A_subdivide">subdivide</code>, <code id="axis_facet_col_+3A_ticks">ticks</code>, <code id="axis_facet_col_+3A_tickpadding">tickPadding</code>, <code id="axis_facet_col_+3A_ticksize">tickSize</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
<tr><td><code id="axis_facet_col_+3A_ticksizemajor">tickSizeMajor</code>, <code id="axis_facet_col_+3A_ticksizeminor">tickSizeMinor</code>, <code id="axis_facet_col_+3A_ticksizeend">tickSizeEnd</code>, <code id="axis_facet_col_+3A_title">title</code>, <code id="axis_facet_col_+3A_titleoffset">titleOffset</code>, <code id="axis_facet_col_+3A_titlemaxlength">titleMaxLength</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
<tr><td><code id="axis_facet_col_+3A_characterwidth">characterWidth</code>, <code id="axis_facet_col_+3A_orient">orient</code>, <code id="axis_facet_col_+3A_format">format</code>, <code id="axis_facet_col_+3A_remove">remove</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/axis.html">Vega-List Axis spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/population.json") %&gt;%
  add_filter("datum.year == 2000") %&gt;%
  calculate("gender", 'datum.sex == 2 ? "Female" : "Male"') %&gt;%
  encode_x("gender", "nominal") %&gt;%
  encode_y("people", "quantitative", aggregate="sum") %&gt;%
  encode_color("gender", "nominal") %&gt;%
  scale_x_ordinal(band_size=6) %&gt;%
  scale_color_nominal(range=c("#EA98D2", "#659CCA")) %&gt;%
  facet_col("age", "ordinal", padding=4) %&gt;%
  axis_x(remove=TRUE) %&gt;%
  axis_y(title="population", grid=FALSE) %&gt;%
  axis_facet_col(orient="bottom", axisWidth=1, offset=-8) %&gt;%
  facet_cell(stroke_width=0) %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='axis_facet_row'>General axis setttings (row facets)</h2><span id='topic+axis_facet_row'></span>

<h3>Description</h3>

<p>Axes provide axis lines, ticks and labels to convey how a spatial range represents
a data range. Simply put, axes visualize scales. <br />
<br />
By default, Vega-Lite automatically creates axes for x, y, row, and column channels
when they are encoded. Axis can be customized via the axis property of a channel
definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis_facet_row(vl, axisWidth = 0, layer = NULL, offset = NULL,
  grid = FALSE, labels = TRUE, labelAngle = NULL, labelAlign = NULL,
  labelBaseline = NULL, labelMaxLength = 25, shortTimeLabels = NULL,
  subdivide = NULL, ticks = NULL, tickPadding = NULL, tickSize = 0,
  tickSizeMajor = NULL, tickSizeMinor = NULL, tickSizeEnd = NULL,
  title = "", titleOffset = NULL, titleMaxLength = NULL,
  characterWidth = 6, orient = NULL, format = NULL, remove = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axis_facet_row_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="axis_facet_row_+3A_axiswidth">axisWidth</code>, <code id="axis_facet_row_+3A_layer">layer</code>, <code id="axis_facet_row_+3A_offset">offset</code>, <code id="axis_facet_row_+3A_grid">grid</code>, <code id="axis_facet_row_+3A_labels">labels</code>, <code id="axis_facet_row_+3A_labelangle">labelAngle</code>, <code id="axis_facet_row_+3A_labelalign">labelAlign</code>, <code id="axis_facet_row_+3A_labelbaseline">labelBaseline</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
<tr><td><code id="axis_facet_row_+3A_labelmaxlength">labelMaxLength</code>, <code id="axis_facet_row_+3A_shorttimelabels">shortTimeLabels</code>, <code id="axis_facet_row_+3A_subdivide">subdivide</code>, <code id="axis_facet_row_+3A_ticks">ticks</code>, <code id="axis_facet_row_+3A_tickpadding">tickPadding</code>, <code id="axis_facet_row_+3A_ticksize">tickSize</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
<tr><td><code id="axis_facet_row_+3A_ticksizemajor">tickSizeMajor</code>, <code id="axis_facet_row_+3A_ticksizeminor">tickSizeMinor</code>, <code id="axis_facet_row_+3A_ticksizeend">tickSizeEnd</code>, <code id="axis_facet_row_+3A_title">title</code>, <code id="axis_facet_row_+3A_titleoffset">titleOffset</code>, <code id="axis_facet_row_+3A_titlemaxlength">titleMaxLength</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
<tr><td><code id="axis_facet_row_+3A_characterwidth">characterWidth</code>, <code id="axis_facet_row_+3A_orient">orient</code>, <code id="axis_facet_row_+3A_format">format</code>, <code id="axis_facet_row_+3A_remove">remove</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/axis.html">Vega-List Axis spec</a>
</p>

<hr>
<h2 id='axis_x'>General axis setttings (x-axis)</h2><span id='topic+axis_x'></span>

<h3>Description</h3>

<p>Axes provide axis lines, ticks and labels to convey how a spatial range represents
a data range. Simply put, axes visualize scales. <br />
<br />
By default, Vega-Lite automatically creates axes for x, y, row, and column channels
when they are encoded. Axis can be customized via the axis property of a channel
definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis_x(vl, axisWidth = NULL, layer = NULL, offset = NULL, grid = NULL,
  labels = TRUE, labelAngle = NULL, labelAlign = NULL,
  labelBaseline = NULL, labelMaxLength = 25, shortTimeLabels = NULL,
  subdivide = NULL, ticks = NULL, tickPadding = NULL, tickSize = NULL,
  tickSizeMajor = NULL, tickSizeMinor = NULL, tickSizeEnd = NULL,
  title = "", titleOffset = NULL, titleMaxLength = NULL,
  characterWidth = 6, orient = NULL, format = NULL, remove = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axis_x_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="axis_x_+3A_axiswidth">axisWidth</code>, <code id="axis_x_+3A_layer">layer</code>, <code id="axis_x_+3A_offset">offset</code>, <code id="axis_x_+3A_grid">grid</code>, <code id="axis_x_+3A_labels">labels</code>, <code id="axis_x_+3A_labelangle">labelAngle</code>, <code id="axis_x_+3A_labelalign">labelAlign</code>, <code id="axis_x_+3A_labelbaseline">labelBaseline</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
<tr><td><code id="axis_x_+3A_labelmaxlength">labelMaxLength</code>, <code id="axis_x_+3A_shorttimelabels">shortTimeLabels</code>, <code id="axis_x_+3A_subdivide">subdivide</code>, <code id="axis_x_+3A_ticks">ticks</code>, <code id="axis_x_+3A_tickpadding">tickPadding</code>, <code id="axis_x_+3A_ticksize">tickSize</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
<tr><td><code id="axis_x_+3A_ticksizemajor">tickSizeMajor</code>, <code id="axis_x_+3A_ticksizeminor">tickSizeMinor</code>, <code id="axis_x_+3A_ticksizeend">tickSizeEnd</code>, <code id="axis_x_+3A_title">title</code>, <code id="axis_x_+3A_titleoffset">titleOffset</code>, <code id="axis_x_+3A_titlemaxlength">titleMaxLength</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
<tr><td><code id="axis_x_+3A_characterwidth">characterWidth</code>, <code id="axis_x_+3A_orient">orient</code>, <code id="axis_x_+3A_format">format</code>, <code id="axis_x_+3A_remove">remove</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/axis.html">Vega-List Axis spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/population.json") %&gt;%
  add_filter("datum.year == 2000") %&gt;%
  calculate("gender", 'datum.sex == 2 ? "Female" : "Male"') %&gt;%
  encode_x("gender", "nominal") %&gt;%
  encode_y("people", "quantitative", aggregate="sum") %&gt;%
  encode_color("gender", "nominal") %&gt;%
  scale_x_ordinal(band_size=6) %&gt;%
  scale_color_nominal(range=c("#EA98D2", "#659CCA")) %&gt;%
  facet_col("age", "ordinal", padding=4) %&gt;%
  axis_x(remove=TRUE) %&gt;%
  axis_y(title="population", grid=FALSE) %&gt;%
  axis_facet_col(orient="bottom", axisWidth=1, offset=-8) %&gt;%
  facet_cell(stroke_width=0) %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='axis_y'>General axis setttings (y-axis)</h2><span id='topic+axis_y'></span>

<h3>Description</h3>

<p>Axes provide axis lines, ticks and labels to convey how a spatial range represents
a data range. Simply put, axes visualize scales. <br />
<br />
By default, Vega-Lite automatically creates axes for x, y, row, and column channels
when they are encoded. Axis can be customized via the axis property of a channel
definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis_y(vl, axisWidth = NULL, layer = NULL, offset = NULL, grid = NULL,
  labels = TRUE, labelAngle = NULL, labelAlign = NULL,
  labelBaseline = NULL, labelMaxLength = 25, shortTimeLabels = NULL,
  subdivide = NULL, ticks = NULL, tickPadding = NULL, tickSize = NULL,
  tickSizeMajor = NULL, tickSizeMinor = NULL, tickSizeEnd = NULL,
  title = "", titleOffset = NULL, titleMaxLength = NULL,
  characterWidth = 6, orient = NULL, format = NULL, remove = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axis_y_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="axis_y_+3A_axiswidth">axisWidth</code>, <code id="axis_y_+3A_layer">layer</code>, <code id="axis_y_+3A_offset">offset</code>, <code id="axis_y_+3A_grid">grid</code>, <code id="axis_y_+3A_labels">labels</code>, <code id="axis_y_+3A_labelangle">labelAngle</code>, <code id="axis_y_+3A_labelalign">labelAlign</code>, <code id="axis_y_+3A_labelbaseline">labelBaseline</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
<tr><td><code id="axis_y_+3A_labelmaxlength">labelMaxLength</code>, <code id="axis_y_+3A_shorttimelabels">shortTimeLabels</code>, <code id="axis_y_+3A_subdivide">subdivide</code>, <code id="axis_y_+3A_ticks">ticks</code>, <code id="axis_y_+3A_tickpadding">tickPadding</code>, <code id="axis_y_+3A_ticksize">tickSize</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
<tr><td><code id="axis_y_+3A_ticksizemajor">tickSizeMajor</code>, <code id="axis_y_+3A_ticksizeminor">tickSizeMinor</code>, <code id="axis_y_+3A_ticksizeend">tickSizeEnd</code>, <code id="axis_y_+3A_title">title</code>, <code id="axis_y_+3A_titleoffset">titleOffset</code>, <code id="axis_y_+3A_titlemaxlength">titleMaxLength</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
<tr><td><code id="axis_y_+3A_characterwidth">characterWidth</code>, <code id="axis_y_+3A_orient">orient</code>, <code id="axis_y_+3A_format">format</code>, <code id="axis_y_+3A_remove">remove</code></td>
<td>
<p>see <a href="http://vega.github.io/vega-lite/docs/axis.html">axis docs</a> &amp;
<a href="https://github.com/vega/vega-lite/blob/master/src/axis.ts">axis base config</a></p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/axis.html">Vega-List Axis spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/population.json") %&gt;%
  add_filter("datum.year == 2000") %&gt;%
  calculate("gender", 'datum.sex == 2 ? "Female" : "Male"') %&gt;%
  encode_x("gender", "nominal") %&gt;%
  encode_y("people", "quantitative", aggregate="sum") %&gt;%
  encode_color("gender", "nominal") %&gt;%
  scale_x_ordinal(band_size=6) %&gt;%
  scale_color_nominal(range=c("#EA98D2", "#659CCA")) %&gt;%
  facet_col("age", "ordinal", padding=4) %&gt;%
  axis_x(remove=TRUE) %&gt;%
  axis_y(title="population", grid=FALSE) %&gt;%
  axis_facet_col(orient="bottom", axisWidth=1, offset=-8) %&gt;%
  facet_cell(stroke_width=0) %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='bin_x'>Group continuous data values (x-axis)</h2><span id='topic+bin_x'></span>

<h3>Description</h3>

<p>The &quot;bin&quot; property is for grouping quantitative, continuous data values of a
particular field into smaller number of “bins” (e.g., for a histogram).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_x(vl, min = NULL, max = NULL, base = NULL, step = NULL,
  steps = NULL, minstep = NULL, div = NULL, maxbins = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_x_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="bin_x_+3A_min">min</code></td>
<td>
<p>the minimum bin value to consider.</p>
</td></tr>
<tr><td><code id="bin_x_+3A_max">max</code></td>
<td>
<p>the maximum bin value to consider.</p>
</td></tr>
<tr><td><code id="bin_x_+3A_base">base</code></td>
<td>
<p>the number base to use for automatic bin determination.</p>
</td></tr>
<tr><td><code id="bin_x_+3A_step">step</code></td>
<td>
<p>an exact step size to use between bins.</p>
</td></tr>
<tr><td><code id="bin_x_+3A_steps">steps</code></td>
<td>
<p>an array of allowable step sizes to choose from.</p>
</td></tr>
<tr><td><code id="bin_x_+3A_minstep">minstep</code></td>
<td>
<p>minimum allowable step size (particularly useful for integer values).</p>
</td></tr>
<tr><td><code id="bin_x_+3A_div">div</code></td>
<td>
<p>Scale factors indicating allowable subdivisions. The default value is
[5, 2], which indicates that for base 10 numbers (the default base),
the method may consider dividing bin sizes by 5 and/or 2. For example,
for an initial step size of 10, the method can check if bin sizes of 2
(= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given
constraints.</p>
</td></tr>
<tr><td><code id="bin_x_+3A_maxbins">maxbins</code></td>
<td>
<p>the maximum number of allowable bins.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/bin.html">Vega-Lite Binning</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/movies.json") %&gt;%
  encode_x("IMDB_Rating", "quantitative") %&gt;%
  encode_y("Rotten_Tomatoes_Rating", "quantitative") %&gt;%
  encode_size("*", "quantitative", aggregate="count") %&gt;%
  bin_x(maxbins=10) %&gt;%
  bin_y(maxbins=10) %&gt;%
  mark_point()
</code></pre>

<hr>
<h2 id='bin_y'>Group continuous data values (y-axis)</h2><span id='topic+bin_y'></span>

<h3>Description</h3>

<p>The &quot;bin&quot; property is for grouping quantitative, continuous data values of a
particular field into smaller number of “bins” (e.g., for a histogram).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_y(vl, min = NULL, max = NULL, base = NULL, step = NULL,
  steps = NULL, minstep = NULL, div = NULL, maxbins = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_y_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="bin_y_+3A_min">min</code></td>
<td>
<p>the minimum bin value to consider.</p>
</td></tr>
<tr><td><code id="bin_y_+3A_max">max</code></td>
<td>
<p>the maximum bin value to consider.</p>
</td></tr>
<tr><td><code id="bin_y_+3A_base">base</code></td>
<td>
<p>the number base to use for automatic bin determination.</p>
</td></tr>
<tr><td><code id="bin_y_+3A_step">step</code></td>
<td>
<p>an exact step size to use between bins.</p>
</td></tr>
<tr><td><code id="bin_y_+3A_steps">steps</code></td>
<td>
<p>an array of allowable step sizes to choose from.</p>
</td></tr>
<tr><td><code id="bin_y_+3A_minstep">minstep</code></td>
<td>
<p>minimum allowable step size (particularly useful for integer values).</p>
</td></tr>
<tr><td><code id="bin_y_+3A_div">div</code></td>
<td>
<p>Scale factors indicating allowable subdivisions. The default value is
[5, 2], which indicates that for base 10 numbers (the default base),
the method may consider dividing bin sizes by 5 and/or 2. For example,
for an initial step size of 10, the method can check if bin sizes of 2
(= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given
constraints.</p>
</td></tr>
<tr><td><code id="bin_y_+3A_maxbins">maxbins</code></td>
<td>
<p>the maximum number of allowable bins.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/bin.html">Vega-Lite Binning</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/movies.json") %&gt;%
  encode_x("IMDB_Rating", "quantitative") %&gt;%
  encode_y("Rotten_Tomatoes_Rating", "quantitative") %&gt;%
  encode_size("*", "quantitative", aggregate="count") %&gt;%
  bin_x(maxbins=10) %&gt;%
  bin_y(maxbins=10) %&gt;%
  mark_point()
</code></pre>

<hr>
<h2 id='calculate'>Derive new fields</h2><span id='topic+calculate'></span>

<h3>Description</h3>

<p>Derive new fields
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate(vl, field, expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object created by <code><a href="#topic+vegalite">vegalite</a></code></p>
</td></tr>
<tr><td><code id="calculate_+3A_field">field</code></td>
<td>
<p>the field name in which to store the computed value.</p>
</td></tr>
<tr><td><code id="calculate_+3A_expr">expr</code></td>
<td>
<p>a string containing an expression for the formula. Use the variable
<code>"datum"</code> to refer to the current data object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/population.json") %&gt;%
  add_filter("datum.year == 2000") %&gt;%
  calculate("gender", 'datum.sex == 2 ? "Female" : "Male"') %&gt;%
  encode_x("gender", "nominal") %&gt;%
  encode_y("people", "quantitative", aggregate="sum") %&gt;%
  encode_color("gender", "nominal") %&gt;%
  scale_x_ordinal(band_size=6) %&gt;%
  scale_color_nominal(range=c("#EA98D2", "#659CCA")) %&gt;%
  facet_col("age", "ordinal", padding=4) %&gt;%
  axis_x(remove=TRUE) %&gt;%
  axis_y(title="population", grid=FALSE) %&gt;%
  axis_facet_col(orient="bottom", axisWidth=1, offset=-8) %&gt;%
  facet_cell(stroke_width=0) %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='capture_widget'>Capture a static (png) version of a widget (e.g. for use in a PDF knitr document)</h2><span id='topic+capture_widget'></span>

<h3>Description</h3>

<p>Widgets are generally interactive beasts rendered in an HTML DOM with
javascript. That makes them unusable in PDF documents. However, many widgets
initial views would work well as static images. This function renders a widget
to a file and make it usable in a number of contexts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture_widget(wdgt, output = c("path", "markdown", "html", "inline"), height,
  width, png_render_path = tempfile(fileext = ".png"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capture_widget_+3A_wdgt">wdgt</code></td>
<td>
<p>htmlwidget to capture</p>
</td></tr>
<tr><td><code id="capture_widget_+3A_output">output</code></td>
<td>
<p>how to return the results of the capture (see Details section)</p>
</td></tr>
<tr><td><code id="capture_widget_+3A_height">height</code>, <code id="capture_widget_+3A_width">width</code></td>
<td>
<p>it's important for many widget to be responsive in HTML
documents. PDFs are static beasts and having a fixed image size works
better for them. <code>height</code> &amp; <code>width</code> will be passed into the
rendering process, which means you should probably specify similar
values in your widget creation process so the captured <code>&lt;div&gt;</code>
size matches the size you specify here.</p>
</td></tr>
<tr><td><code id="capture_widget_+3A_png_render_path">png_render_path</code></td>
<td>
<p>by default, this will be a temporary file location but
a fully qualified filename (with extension) can be specified. It's up to
the caller to free the storage when finished with the resource.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>What is returned depends on the value of <code>output</code>. By default (<code>"path"</code>),
the full disk path will be returned. If <code>markdown</code> is specified, a markdown
string will be returned with a <code>file:///...</code> URL. If <code>html</code> is
specified, an <code>&lt;img src='file:///...'/&gt;</code> tag will be returned and if
<code>inline</code> is specified, a base64 encoded <code>&lt;img&gt;</code> tag will be returned
(just like you'd see in a self-contained HTML file from <code>knitr</code>).
</p>


<h3>Value</h3>

<p>See Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(webshot)
library(vegalite)

dat &lt;- jsonlite::fromJSON('[
      {"a": "A","b": 28}, {"a": "B","b": 55}, {"a": "C","b": 43},
      {"a": "D","b": 91}, {"a": "E","b": 81}, {"a": "F","b": 53},
      {"a": "G","b": 19}, {"a": "H","b": 87}, {"a": "I","b": 52}
    ]')

vegalite(viewport_width=350, viewport_height=250) %&gt;%
  add_data(dat) %&gt;%
  encode_x("a", "ordinal") %&gt;%
  encode_y("b", "quantitative") %&gt;%
  mark_bar() -&gt; vl

capture_widget(vl, "inline", 250, 350)

## End(Not run)
</code></pre>

<hr>
<h2 id='cell_size'>Add cell size to main Vega-Lite spec</h2><span id='topic+cell_size'></span>

<h3>Description</h3>

<p>Short version: set this to control the height and with of a single plot panel.
It will also be the size of panels in a faceted/trellis plot, so make sure your
viewport height/width (set in the main call to the widget) is as large as you
want it to be (otheriwse this will do it's best to calculate it but will probably
not be what you ultimately want).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_size(vl, width = 200, height = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_size_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="cell_size_+3A_width">width</code></td>
<td>
<p>the width of the single plot or each plot in a trellis plot when
the visualization has continuous x-scale. (If the plot has ordinal x-scale, the
width is determined by the x-scale’s bandSize and the cardinality of the x-scale.
If the plot does not have a field on x, the width is derived from scale config’s
bandSize for all marks except text and from scale config’s textBandWidth for text mark.)
Default value: <code>200</code></p>
</td></tr>
<tr><td><code id="cell_size_+3A_height">height</code></td>
<td>
<p>the height of the single plot or each plot in a trellis plot when
the visualization has continuous y-scale. (If the visualization has ordinal y-scale,
the height is determined by the bandSize and the cardinality of the y-scale. If the
plot does not have a field on y, the height is scale config’s bandSize.)
Default value: <code>200</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>At its core, a Vega-Lite specification describes a single plot. When a
facet channel is added, the visualization is faceted into a trellis plot,
which contains multiple plots. Each plot in either a single plot or a trellis
plot is called a cell. Cell configuration allows us to customize each individual
single plot and each plot in a trellis plot.
</p>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/config.html#cell-config">Vega-Lite Cell spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  cell_size(300, 200) %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/unemployment-across-industries.json") %&gt;%
  encode_x("date", "temporal") %&gt;%
  encode_y("count", "quantitative", aggregate="sum") %&gt;%
  encode_color("series", "nominal") %&gt;%
  scale_color_nominal(range="category20b") %&gt;%
  timeunit_x("yearmonth") %&gt;%
  scale_x_time(nice="month") %&gt;%
  axis_x(axisWidth=0, format="%Y", labelAngle=0) %&gt;%
  mark_area()
</code></pre>

<hr>
<h2 id='config_color'>Color config</h2><span id='topic+config_color'></span>

<h3>Description</h3>

<p>Color config
</p>


<h3>Usage</h3>

<pre><code class='language-R'>config_color(vl, color = NULL, fill = NULL, stroke = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="config_color_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="config_color_+3A_color">color</code></td>
<td>
<p>color of the mark – either fill or stroke color based on the filled mark config.</p>
</td></tr>
<tr><td><code id="config_color_+3A_fill">fill</code></td>
<td>
<p>fill color. This config will be overridden by color channel’s
specified or mapped values if filled is true.</p>
</td></tr>
<tr><td><code id="config_color_+3A_stroke">stroke</code></td>
<td>
<p>stroke color. This config will be overridden by color channel’s
specified or mapped values if filled is false.</p>
</td></tr>
</table>

<hr>
<h2 id='config_font'>Font config</h2><span id='topic+config_font'></span>

<h3>Description</h3>

<p>Font config
</p>


<h3>Usage</h3>

<pre><code class='language-R'>config_font(vl, font = NULL, font_size = NULL, font_style = NULL,
  font_weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="config_font_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="config_font_+3A_font">font</code></td>
<td>
<p>typeface to set the text in (e.g., Helvetica Neue).</p>
</td></tr>
<tr><td><code id="config_font_+3A_font_size">font_size</code></td>
<td>
<p>font size, in pixels. The default value is 10.</p>
</td></tr>
<tr><td><code id="config_font_+3A_font_style">font_style</code></td>
<td>
<p>font style (e.g., italic).</p>
</td></tr>
<tr><td><code id="config_font_+3A_font_weight">font_weight</code></td>
<td>
<p>font weight (e.g., bold).</p>
</td></tr>
</table>

<hr>
<h2 id='config_opacity'>Opacity config</h2><span id='topic+config_opacity'></span>

<h3>Description</h3>

<p>Opacity config
</p>


<h3>Usage</h3>

<pre><code class='language-R'>config_opacity(vl, opacity = NULL, fill_opacity = NULL,
  stroke_opacity = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="config_opacity_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="config_opacity_+3A_opacity">opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="config_opacity_+3A_fill_opacity">fill_opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="config_opacity_+3A_stroke_opacity">stroke_opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
</table>

<hr>
<h2 id='config_stroke'>Stroke config</h2><span id='topic+config_stroke'></span>

<h3>Description</h3>

<p>Stroke config
</p>


<h3>Usage</h3>

<pre><code class='language-R'>config_stroke(vl, stroke = NULL, stroke_width = NULL, stroke_dash = NULL,
  stroke_dash_offset = NULL, stroke_opacity = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="config_stroke_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="config_stroke_+3A_stroke">stroke</code></td>
<td>
<p>stroke color</p>
</td></tr>
<tr><td><code id="config_stroke_+3A_stroke_width">stroke_width</code></td>
<td>
<p>stroke of the width in pixels</p>
</td></tr>
<tr><td><code id="config_stroke_+3A_stroke_dash">stroke_dash</code></td>
<td>
<p>an array of alternating stroke, space lengths for creating
dashed or dotted lines.</p>
</td></tr>
<tr><td><code id="config_stroke_+3A_stroke_dash_offset">stroke_dash_offset</code></td>
<td>
<p>the offset (in pixels) into which to begin drawing with the stroke dash array.</p>
</td></tr>
<tr><td><code id="config_stroke_+3A_stroke_opacity">stroke_opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
</table>

<hr>
<h2 id='config_text'>Text config</h2><span id='topic+config_text'></span>

<h3>Description</h3>

<p>Text config
</p>


<h3>Usage</h3>

<pre><code class='language-R'>config_text(vl, angle = NULL, align = NULL, baseline = NULL, dx = NULL,
  dy = NULL, radius = NULL, theta = NULL, format = NULL,
  short_time_labels = NULL, opacity = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="config_text_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="config_text_+3A_angle">angle</code></td>
<td>
<p>rotation angle of the text, in degrees.</p>
</td></tr>
<tr><td><code id="config_text_+3A_align">align</code></td>
<td>
<p>horizontal alignment of the text. One of left, right, center.</p>
</td></tr>
<tr><td><code id="config_text_+3A_baseline">baseline</code></td>
<td>
<p>vertical alignment of the text. One of top, middle, bottom.</p>
</td></tr>
<tr><td><code id="config_text_+3A_dx">dx</code>, <code id="config_text_+3A_dy">dy</code></td>
<td>
<p>horizontal/vertical in pixels, between the text label and its
anchor point. The offset is applied after rotation by the angle property.</p>
</td></tr>
<tr><td><code id="config_text_+3A_radius">radius</code></td>
<td>
<p>polar coordinate radial offset, in pixels, of the text label
from the origin determined by the x and y properties.</p>
</td></tr>
<tr><td><code id="config_text_+3A_theta">theta</code></td>
<td>
<p>polar coordinate angle, in radians, of the text label from the
origin determined by the x and y properties. Values for theta follow
the same convention of arc mark startAngle and endAngle properties:
angles are measured in radians, with 0 indicating “north”.</p>
</td></tr>
<tr><td><code id="config_text_+3A_format">format</code></td>
<td>
<p>ormatting pattern for text value. If not defined, this will be
determined automatically</p>
</td></tr>
<tr><td><code id="config_text_+3A_short_time_labels">short_time_labels</code></td>
<td>
<p>whether month names and weekday names should be abbreviated.</p>
</td></tr>
<tr><td><code id="config_text_+3A_opacity">opacity</code></td>
<td>
<p>0-1</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/mark.html">Vega-Lite Mark spec</a>
</p>

<hr>
<h2 id='embed_spec'>Scaffold HTML/JavaScript/CSS code from <code>vegalite</code></h2><span id='topic+embed_spec'></span>

<h3>Description</h3>

<p>Create minimal necessary HTML/JavaScript/CSS code to embed a
Vega-Lite spec into a web page. This assumes you have the necessary
boilerplate javascript &amp; HTML page shell defined as you see in
<a href="http://vega.github.io/vega-lite/tutorials/getting_started.html#embed">the Vega-Lite core example</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embed_spec(vl, element_id = generate_id(), to_cb = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embed_spec_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="embed_spec_+3A_element_id">element_id</code></td>
<td>
<p>if you don't specify one, an id will be generated. This should
be descriptive, but short, and valid javascript &amp; CSS identifier syntax as
is is appended to variable names.</p>
</td></tr>
<tr><td><code id="embed_spec_+3A_to_cb">to_cb</code></td>
<td>
<p>if <code>TRUE</code>, will copy the spec to the system clipboard. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you are generating more than one object to embed into a single web page,
you will need to ensure each <code>element_id</code> is unique. Each Vega-Lite
<code>div</code> is classed with <code>vldiv</code> so you can provide both a central style
(say, <code>display:inline-block; margin-auto;</code>) and targeted ones that use the
<code>div</code> <code>id</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- jsonlite::fromJSON('[
    {"a": "A","b": 28}, {"a": "B","b": 55}, {"a": "C","b": 43},
    {"a": "D","b": 91}, {"a": "E","b": 81}, {"a": "F","b": 53},
    {"a": "G","b": 19}, {"a": "H","b": 87}, {"a": "I","b": 52}
  ]')

vegalite() %&gt;%
  add_data(dat) %&gt;%
  encode_x("a", "ordinal") %&gt;%
  encode_y("b", "quantitative") %&gt;%
  mark_bar() -&gt; chart

embed_spec(chart)
</code></pre>

<hr>
<h2 id='encode_color'>Encode color &quot;channel&quot;</h2><span id='topic+encode_color'></span>

<h3>Description</h3>

<p>Encode color &quot;channel&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_color(vl, field = NULL, type, value = NULL, aggregate = NULL,
  sort = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_color_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object created by <code><a href="#topic+vegalite">vegalite</a></code></p>
</td></tr>
<tr><td><code id="encode_color_+3A_field">field</code></td>
<td>
<p>single element character vector naming the column</p>
</td></tr>
<tr><td><code id="encode_color_+3A_type">type</code></td>
<td>
<p>the encoded field’s type of measurement. This can be either a full type
name (<code>quantitative</code>, <code>temporal</code>, <code>ordinal</code>, and <code>nominal</code>)
or an initial character of the type name (<code>Q</code>, <code>T</code>, <code>O</code>, <code>N</code>).
This property is case insensitive. If <code>auto</code> is used, the type will
be guessed (so you may want to actually specify it if you want consistency).</p>
</td></tr>
<tr><td><code id="encode_color_+3A_value">value</code></td>
<td>
<p>scale value</p>
</td></tr>
<tr><td><code id="encode_color_+3A_aggregate">aggregate</code></td>
<td>
<p>perform aggregaton on <code>field</code>. See
<a href="http://vega.github.io/vega-lite/docs/aggregate.html">Supported Aggregation Options</a> for
more info on valid operations. Leave <code>NULL</code> for no aggregation.</p>
</td></tr>
<tr><td><code id="encode_color_+3A_sort">sort</code></td>
<td>
<p>either one of <code>ascending</code>, <code>descending</code> or (for ordinal scales)
the result of a call to <code><a href="#topic+sort_def">sort_def</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>right now, <code>type</code> == &quot;<code>auto</code>&quot; just assume &quot;<code>quantitative</code>&quot;. It
will eventually get smarter, but you are better off specifying it.
</p>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/encoding.html">Vega-Lite Encoding spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/cars.json") %&gt;%
  encode_x("Horsepower", "quantitative") %&gt;%
  encode_y("Miles_per_Gallon", "quantitative") %&gt;%
  encode_color("Origin", "nominal") %&gt;%
  encode_shape("Origin", "nominal") %&gt;%
  mark_point()
</code></pre>

<hr>
<h2 id='encode_detail'>Encode detail &quot;channel&quot;</h2><span id='topic+encode_detail'></span>

<h3>Description</h3>

<p>Grouping data is another important operation in visualizing data. For
aggregated plots, all encoded fields without aggregate functions are used as
grouping fields in the aggregation (similar to fields in GROUP BY in SQL).
For line and area marks, mapping a data field to color or shape channel will
group the lines and stacked areas by the field.<br />
<br />
detail channel allows providing an additional grouping field (level) for
grouping data in aggregation without mapping data to a specific visual
channel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_detail(vl, field = NULL, type, aggregate = NULL, sort = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_detail_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object created by <code><a href="#topic+vegalite">vegalite</a></code></p>
</td></tr>
<tr><td><code id="encode_detail_+3A_field">field</code></td>
<td>
<p>single element character vector naming the column</p>
</td></tr>
<tr><td><code id="encode_detail_+3A_type">type</code></td>
<td>
<p>the encoded field’s type of measurement. This can be either a full type
name (<code>quantitative</code>, <code>temporal</code>, <code>ordinal</code>, and <code>nominal</code>)
or an initial character of the type name (<code>Q</code>, <code>T</code>, <code>O</code>, <code>N</code>).
This property is case insensitive. If <code>auto</code> is used, the type will
be guessed (so you may want to actually specify it if you want consistency).</p>
</td></tr>
<tr><td><code id="encode_detail_+3A_aggregate">aggregate</code></td>
<td>
<p>perform aggregaton on <code>field</code>. See
<a href="http://vega.github.io/vega-lite/docs/aggregate.html">Supported Aggregation Options</a> for
more info on valid operations. Leave <code>NULL</code> for no aggregation.</p>
</td></tr>
<tr><td><code id="encode_detail_+3A_sort">sort</code></td>
<td>
<p>either one of <code>ascending</code>, <code>descending</code> or (for ordinal scales)
the result of a call to <code><a href="#topic+sort_def">sort_def</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>right now, <code>type</code> == &quot;<code>auto</code>&quot; just assume &quot;<code>quantitative</code>&quot;. It
will eventually get smarter, but you are better off specifying it.
</p>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/encoding.html">Vega-Lite Encoding spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  cell_size(200, 200) %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/stocks.csv") %&gt;%
  encode_x("date", "temporal") %&gt;%
  encode_y("price", "quantitative") %&gt;%
  encode_detail("symbol", "nominal") %&gt;%
  mark_line()
</code></pre>

<hr>
<h2 id='encode_order'>Encode detail &quot;order&quot;</h2><span id='topic+encode_order'></span>

<h3>Description</h3>

<p>Grouping data is another important operation in visualizing data. For
aggregated plots, all encoded fields without aggregate functions are used as
grouping fields in the aggregation (similar to fields in GROUP BY in SQL).
For line and area marks, mapping a data field to color or shape channel will
group the lines and stacked areas by the field.<br />
<br />
order channel sorts the layer order or stacking order (for stacked charts) of
the marks while path channel sorts the order of data points in line marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_order(vl, field = NULL, type, aggregate = NULL, sort = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_order_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object created by <code><a href="#topic+vegalite">vegalite</a></code></p>
</td></tr>
<tr><td><code id="encode_order_+3A_field">field</code></td>
<td>
<p>single element character vector naming the column</p>
</td></tr>
<tr><td><code id="encode_order_+3A_type">type</code></td>
<td>
<p>the encoded field’s type of measurement. This can be either a full type
name (<code>quantitative</code>, <code>temporal</code>, <code>ordinal</code>, and <code>nominal</code>)
or an initial character of the type name (<code>Q</code>, <code>T</code>, <code>O</code>, <code>N</code>).
This property is case insensitive. If <code>auto</code> is used, the type will
be guessed (so you may want to actually specify it if you want consistency).</p>
</td></tr>
<tr><td><code id="encode_order_+3A_aggregate">aggregate</code></td>
<td>
<p>perform aggregaton on <code>field</code>. See
<a href="http://vega.github.io/vega-lite/docs/aggregate.html">Supported Aggregation Options</a> for
more info on valid operations. Leave <code>NULL</code> for no aggregation.</p>
</td></tr>
<tr><td><code id="encode_order_+3A_sort">sort</code></td>
<td>
<p>either one of <code>ascending</code>, <code>descending</code> or (for ordinal scales)
the result of a call to <code><a href="#topic+sort_def">sort_def</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>right now, <code>type</code> == &quot;<code>auto</code>&quot; just assume &quot;<code>quantitative</code>&quot;. It
will eventually get smarter, but you are better off specifying it.
</p>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/encoding.html">Vega-Lite Encoding spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  cell_size(200, 200) %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/cars.json") %&gt;%
  encode_x("Horsepower", "quantitative") %&gt;%
  encode_y("Miles_per_Gallon", "quantitative") %&gt;%
  encode_color("Origin", "nominal") %&gt;%
  encode_order("Origin", "ordinal", sort="descending") %&gt;%
  mark_point()
</code></pre>

<hr>
<h2 id='encode_path'>Encode detail &quot;path&quot;</h2><span id='topic+encode_path'></span>

<h3>Description</h3>

<p>Grouping data is another important operation in visualizing data. For
aggregated plots, all encoded fields without aggregate functions are used as
grouping fields in the aggregation (similar to fields in GROUP BY in SQL).
For line and area marks, mapping a data field to color or shape channel will
group the lines and stacked areas by the field.<br />
<br />
By default, line marks order their points in their paths by the field of
channel x or y. However, to show a pattern of data change over time between x &amp; y
we use path channel to sort points in a paritcular order (e.g. by time).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_path(vl, field = NULL, type, aggregate = NULL, sort = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_path_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object created by <code><a href="#topic+vegalite">vegalite</a></code></p>
</td></tr>
<tr><td><code id="encode_path_+3A_field">field</code></td>
<td>
<p>single element character vector naming the column</p>
</td></tr>
<tr><td><code id="encode_path_+3A_type">type</code></td>
<td>
<p>the encoded field’s type of measurement. This can be either a full type
name (<code>quantitative</code>, <code>temporal</code>, <code>ordinal</code>, and <code>nominal</code>)
or an initial character of the type name (<code>Q</code>, <code>T</code>, <code>O</code>, <code>N</code>).
This property is case insensitive. If <code>auto</code> is used, the type will
be guessed (so you may want to actually specify it if you want consistency).</p>
</td></tr>
<tr><td><code id="encode_path_+3A_aggregate">aggregate</code></td>
<td>
<p>perform aggregaton on <code>field</code>. See
<a href="http://vega.github.io/vega-lite/docs/aggregate.html">Supported Aggregation Options</a> for
more info on valid operations. Leave <code>NULL</code> for no aggregation.</p>
</td></tr>
<tr><td><code id="encode_path_+3A_sort">sort</code></td>
<td>
<p>either one of <code>ascending</code>, <code>descending</code> or (for ordinal scales)
the result of a call to <code><a href="#topic+sort_def">sort_def</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>right now, <code>type</code> == &quot;<code>auto</code>&quot; just assume &quot;<code>quantitative</code>&quot;. It
will eventually get smarter, but you are better off specifying it.
</p>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/encoding.html">Vega-Lite Encoding spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  cell_size(300, 300) %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/driving.json") %&gt;%
  encode_x("miles", "quantitative") %&gt;%
  encode_y("gas", "quantitative") %&gt;%
  encode_path("year", "temporal") %&gt;%
  scale_x_linear(zero=FALSE) %&gt;%
  scale_y_linear(zero=FALSE) %&gt;%
  mark_line()
</code></pre>

<hr>
<h2 id='encode_shape'>Encode shape &quot;channel&quot;</h2><span id='topic+encode_shape'></span>

<h3>Description</h3>

<p>Encode shape &quot;channel&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_shape(vl, field = NULL, type, value = NULL, aggregate = NULL,
  sort = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_shape_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object created by <code><a href="#topic+vegalite">vegalite</a></code></p>
</td></tr>
<tr><td><code id="encode_shape_+3A_field">field</code></td>
<td>
<p>single element character vector naming the column</p>
</td></tr>
<tr><td><code id="encode_shape_+3A_type">type</code></td>
<td>
<p>the encoded field’s type of measurement. This can be either a full type
name (<code>quantitative</code>, <code>temporal</code>, <code>ordinal</code>, and <code>nominal</code>)
or an initial character of the type name (<code>Q</code>, <code>T</code>, <code>O</code>, <code>N</code>).
This property is case insensitive. If <code>auto</code> is used, the type will
be guessed (so you may want to actually specify it if you want consistency).</p>
</td></tr>
<tr><td><code id="encode_shape_+3A_value">value</code></td>
<td>
<p>scale value</p>
</td></tr>
<tr><td><code id="encode_shape_+3A_aggregate">aggregate</code></td>
<td>
<p>perform aggregaton on <code>field</code>. See
<a href="http://vega.github.io/vega-lite/docs/aggregate.html">Supported Aggregation Options</a> for
more info on valid operations. Leave <code>NULL</code> for no aggregation.</p>
</td></tr>
<tr><td><code id="encode_shape_+3A_sort">sort</code></td>
<td>
<p>either one of <code>ascending</code>, <code>descending</code> or (for ordinal scales)
the result of a call to <code><a href="#topic+sort_def">sort_def</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>right now, <code>type</code> == &quot;<code>auto</code>&quot; just assume &quot;<code>quantitative</code>&quot;. It
will eventually get smarter, but you are better off specifying it.
</p>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/encoding.html">Vega-Lite Encoding spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/cars.json") %&gt;%
  encode_x("Horsepower", "quantitative") %&gt;%
  encode_y("Miles_per_Gallon", "quantitative") %&gt;%
  encode_color("Origin", "nominal") %&gt;%
  encode_shape("Origin", "nominal") %&gt;%
  mark_point()
</code></pre>

<hr>
<h2 id='encode_size'>Encode size &quot;channel&quot;</h2><span id='topic+encode_size'></span>

<h3>Description</h3>

<p>Encode size &quot;channel&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_size(vl, field = NULL, type, value = NULL, aggregate = NULL,
  sort = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_size_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object created by <code><a href="#topic+vegalite">vegalite</a></code></p>
</td></tr>
<tr><td><code id="encode_size_+3A_field">field</code></td>
<td>
<p>single element character vector naming the column. Can be <code>*</code> is using
<code>aggregate</code>.</p>
</td></tr>
<tr><td><code id="encode_size_+3A_type">type</code></td>
<td>
<p>the encoded field’s type of measurement. This can be either a full type
name (<code>quantitative</code>, <code>temporal</code>, <code>ordinal</code>, and <code>nominal</code>)
or an initial character of the type name (<code>Q</code>, <code>T</code>, <code>O</code>, <code>N</code>).
This property is case insensitive. If <code>auto</code> is used, the type will
be guessed (so you may want to actually specify it if you want consistency).</p>
</td></tr>
<tr><td><code id="encode_size_+3A_value">value</code></td>
<td>
<p>scale value</p>
</td></tr>
<tr><td><code id="encode_size_+3A_aggregate">aggregate</code></td>
<td>
<p>perform aggregaton on <code>field</code>. See
<a href="http://vega.github.io/vega-lite/docs/aggregate.html">Supported Aggregation Options</a> for
more info on valid operations. Leave <code>NULL</code> for no aggregation.</p>
</td></tr>
<tr><td><code id="encode_size_+3A_sort">sort</code></td>
<td>
<p>either one of <code>ascending</code>, <code>descending</code> or (for ordinal scales)
the result of a call to <code><a href="#topic+sort_def">sort_def</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>right now, <code>type</code> == &quot;<code>auto</code>&quot; just assume &quot;<code>quantitative</code>&quot;. It
will eventually get smarter, but you are better off specifying it.
</p>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/encoding.html">Vega-Lite Encoding spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/cars.json") %&gt;%
  encode_x("Horsepower", "quantitative") %&gt;%
  encode_y("Miles_per_Gallon", "quantitative") %&gt;%
  encode_size("Acceleration", "quantitative") %&gt;%
  mark_point()
</code></pre>

<hr>
<h2 id='encode_text'>Encode text &quot;channel&quot;</h2><span id='topic+encode_text'></span>

<h3>Description</h3>

<p>Encode text &quot;channel&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_text(vl, field, type, value = NULL, aggregate = NULL, sort = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_text_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object created by <code><a href="#topic+vegalite">vegalite</a></code></p>
</td></tr>
<tr><td><code id="encode_text_+3A_field">field</code></td>
<td>
<p>single element character vector naming the column. Can be <code>*</code> is using
<code>aggregate</code>.</p>
</td></tr>
<tr><td><code id="encode_text_+3A_type">type</code></td>
<td>
<p>the encoded field’s type of measurement. This can be either a full type
name (<code>quantitative</code>, <code>temporal</code>, <code>ordinal</code>, and <code>nominal</code>)
or an initial character of the type name (<code>Q</code>, <code>T</code>, <code>O</code>, <code>N</code>).
This property is case insensitive. If <code>auto</code> is used, the type will
be guessed (so you may want to actually specify it if you want consistency).</p>
</td></tr>
<tr><td><code id="encode_text_+3A_value">value</code></td>
<td>
<p>scale value</p>
</td></tr>
<tr><td><code id="encode_text_+3A_aggregate">aggregate</code></td>
<td>
<p>perform aggregaton on <code>field</code>. See
<a href="http://vega.github.io/vega-lite/docs/aggregate.html">Supported Aggregation Options</a> for
more info on valid operations. Leave <code>NULL</code> for no aggregation.</p>
</td></tr>
<tr><td><code id="encode_text_+3A_sort">sort</code></td>
<td>
<p>either one of <code>ascending</code>, <code>descending</code> or (for ordinal scales)
the result of a call to <code><a href="#topic+sort_def">sort_def</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>right now, <code>type</code> == &quot;<code>auto</code>&quot; just assume &quot;<code>quantitative</code>&quot;. It
will eventually get smarter, but you are better off specifying it.
</p>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/encoding.html">Vega-Lite Encoding spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  cell_size(300, 200) %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/cars.json") %&gt;%
  encode_x("Horsepower", "quantitative") %&gt;%
  encode_y("Miles_per_Gallon", "quantitative") %&gt;%
  encode_color("Origin", "nominal") %&gt;%
  calculate("OriginInitial", "datum.Origin[0]") %&gt;%
  encode_text("OriginInitial", "nominal") %&gt;%
  mark_text()
</code></pre>

<hr>
<h2 id='encode_x'>Encode x &quot;channel&quot;</h2><span id='topic+encode_x'></span>

<h3>Description</h3>

<p>Vega-Lite has many &quot;encoding channels&quot;. Each channel definition object must
describe the data field encoded by the channel and its data type, or a constant
value directly mapped to the mark properties. In addition, it can describe the
mapped field’s transformation and properties for its scale and guide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_x(vl, field, type = "auto", aggregate = NULL, sort = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_x_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object created by <code><a href="#topic+vegalite">vegalite</a></code></p>
</td></tr>
<tr><td><code id="encode_x_+3A_field">field</code></td>
<td>
<p>single element character vector naming the column. Can be <code>*</code> is using
<code>aggregate</code>.</p>
</td></tr>
<tr><td><code id="encode_x_+3A_type">type</code></td>
<td>
<p>the encoded field’s type of measurement. This can be either a full type
name (<code>quantitative</code>, <code>temporal</code>, <code>ordinal</code>, and <code>nominal</code>)
or an initial character of the type name (<code>Q</code>, <code>T</code>, <code>O</code>, <code>N</code>).
This property is case insensitive. If <code>auto</code> is used, the type will
be guessed (so you may want to actually specify it if you want consistency).</p>
</td></tr>
<tr><td><code id="encode_x_+3A_aggregate">aggregate</code></td>
<td>
<p>perform aggregaton on <code>field</code>. See
<a href="http://vega.github.io/vega-lite/docs/aggregate.html">Supported Aggregation Options</a> for
more info on valid operations. Leave <code>NULL</code> for no aggregation.</p>
</td></tr>
<tr><td><code id="encode_x_+3A_sort">sort</code></td>
<td>
<p>either one of <code>ascending</code>, <code>descending</code> or (for ordinal scales)
the result of a call to <code><a href="#topic+sort_def">sort_def</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>right now, <code>type</code> == &quot;<code>auto</code>&quot; just assume &quot;<code>quantitative</code>&quot;. It
will eventually get smarter, but you are better off specifying it.
</p>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/encoding.html">Vega-Lite Encoding spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- jsonlite::fromJSON('[
    {"a": "A","b": 28}, {"a": "B","b": 55}, {"a": "C","b": 43},
    {"a": "D","b": 91}, {"a": "E","b": 81}, {"a": "F","b": 53},
    {"a": "G","b": 19}, {"a": "H","b": 87}, {"a": "I","b": 52}
  ]')

vegalite() %&gt;%
  add_data(dat) %&gt;%
  encode_x("a", "ordinal") %&gt;%
  encode_y("b", "quantitative") %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='encode_y'>Encode y &quot;channel&quot;</h2><span id='topic+encode_y'></span>

<h3>Description</h3>

<p>Vega-Lite has many &quot;encoding channels&quot;. Each channel definition object must
describe the data field encoded by the channel and its data type, or a constant
value directly mapped to the mark properties. In addition, it can describe the
mapped field’s transformation and properties for its scale and guide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_y(vl, field, type = "auto", aggregate = NULL, sort = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_y_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object created by <code><a href="#topic+vegalite">vegalite</a></code></p>
</td></tr>
<tr><td><code id="encode_y_+3A_field">field</code></td>
<td>
<p>single element character vector naming the column</p>
</td></tr>
<tr><td><code id="encode_y_+3A_type">type</code></td>
<td>
<p>the encoded field’s type of measurement. This can be either a full type
name (<code>quantitative</code>, <code>temporal</code>, <code>ordinal</code>, and <code>nominal</code>)
or an initial character of the type name (<code>Q</code>, <code>T</code>, <code>O</code>, <code>N</code>).
This property is case insensitive. If <code>auto</code> is used, the type will
be guessed (so you may want to actually specify it if you want consistency).</p>
</td></tr>
<tr><td><code id="encode_y_+3A_aggregate">aggregate</code></td>
<td>
<p>perform aggregaton on <code>field</code>. See
<a href="http://vega.github.io/vega-lite/docs/aggregate.html">Supported Aggregation Options</a> for
more info on valid operations. Leave <code>NULL</code> for no aggregation.</p>
</td></tr>
<tr><td><code id="encode_y_+3A_sort">sort</code></td>
<td>
<p>either one of <code>ascending</code>, <code>descending</code> or (for ordinal scales)
the result of a call to <code><a href="#topic+sort_def">sort_def</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>right now, <code>type</code> == &quot;<code>auto</code>&quot; just assume &quot;<code>quantitative</code>&quot;. It
will eventually get smarter, but you are better off specifying it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- jsonlite::fromJSON('[
    {"a": "A","b": 28}, {"a": "B","b": 55}, {"a": "C","b": 43},
    {"a": "D","b": 91}, {"a": "E","b": 81}, {"a": "F","b": 53},
    {"a": "G","b": 19}, {"a": "H","b": 87}, {"a": "I","b": 52}
  ]')

vegalite() %&gt;%
  add_data(dat) %&gt;%
  encode_x("a", "ordinal") %&gt;%
  encode_y("b", "quantitative") %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='facet_cell'>Facet cell aesthetics</h2><span id='topic+facet_cell'></span>

<h3>Description</h3>

<p>At its core, a Vega-Lite specification describes a single plot. When a facet
channel is added, the visualization is faceted into a trellis plot, which
contains multiple plots. Each plot in either a single plot or a trellis plot
is called a cell. Cell configuration allows us to customize each individual
single plot and each plot in a trellis plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_cell(vl, width = 200, height = 200, fill = NULL,
  fill_opacity = NULL, stroke = NULL, stroke_opacity = NULL,
  stroke_width = NULL, stroke_dash = NULL, stroke_dash_offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_cell_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="facet_cell_+3A_width">width</code>, <code id="facet_cell_+3A_height">height</code></td>
<td>
<p>width and height property of the cell configuration determine
the width of a visualization with a continuous x-scale and the height of
a visualization with a continuous y-scale respectively. Visit the
URL in the References section for more information.</p>
</td></tr>
<tr><td><code id="facet_cell_+3A_fill">fill</code></td>
<td>
<p>fill color</p>
</td></tr>
<tr><td><code id="facet_cell_+3A_fill_opacity">fill_opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="facet_cell_+3A_stroke">stroke</code></td>
<td>
<p>stroke color</p>
</td></tr>
<tr><td><code id="facet_cell_+3A_stroke_opacity">stroke_opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="facet_cell_+3A_stroke_width">stroke_width</code></td>
<td>
<p>stroke of the width in pixels</p>
</td></tr>
<tr><td><code id="facet_cell_+3A_stroke_dash">stroke_dash</code></td>
<td>
<p>an array of alternating stroke, space lengths for creating
dashed or dotted lines.</p>
</td></tr>
<tr><td><code id="facet_cell_+3A_stroke_dash_offset">stroke_dash_offset</code></td>
<td>
<p>the offset (in pixels) into which to begin drawing with the stroke dash array.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/config.html#facet-config">Vega-Lite Facet spec</a>
</p>

<hr>
<h2 id='facet_col'>Create a horizontal ribbon of panels</h2><span id='topic+facet_col'></span>

<h3>Description</h3>

<p>Create a horizontal ribbon of panels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_col(vl, field, type, round = TRUE, padding = 16)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_col_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="facet_col_+3A_field">field</code></td>
<td>
<p>single element character vector naming the column.</p>
</td></tr>
<tr><td><code id="facet_col_+3A_type">type</code></td>
<td>
<p>the encoded field’s type of measurement.</p>
</td></tr>
<tr><td><code id="facet_col_+3A_round">round</code></td>
<td>
<p>round values</p>
</td></tr>
<tr><td><code id="facet_col_+3A_padding">padding</code></td>
<td>
<p>facet padding</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/facet.html">Vega-Lite Faceting</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/population.json") %&gt;%
  add_filter("datum.year == 2000") %&gt;%
  calculate("gender", 'datum.sex == 2 ? "Female" : "Male"') %&gt;%
  encode_x("gender", "nominal") %&gt;%
  encode_y("people", "quantitative", aggregate="sum") %&gt;%
  encode_color("gender", "nominal") %&gt;%
  scale_x_ordinal(band_size=6) %&gt;%
  scale_color_nominal(range=c("#EA98D2", "#659CCA")) %&gt;%
  facet_col("age", "ordinal", padding=4) %&gt;%
  axis_x(remove=TRUE) %&gt;%
  axis_y(title="population", grid=FALSE) %&gt;%
  axis_facet_col(orient="bottom", axisWidth=1, offset=-8) %&gt;%
  facet_cell(stroke_width=0) %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='facet_row'>Create a vertical ribbon of panels</h2><span id='topic+facet_row'></span>

<h3>Description</h3>

<p>Create a vertical ribbon of panels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_row(vl, field, type, round = TRUE, padding = 16)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_row_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="facet_row_+3A_field">field</code></td>
<td>
<p>single element character vector naming the column.</p>
</td></tr>
<tr><td><code id="facet_row_+3A_type">type</code></td>
<td>
<p>the encoded field’s type of measurement.</p>
</td></tr>
<tr><td><code id="facet_row_+3A_round">round</code></td>
<td>
<p>round values</p>
</td></tr>
<tr><td><code id="facet_row_+3A_padding">padding</code></td>
<td>
<p>facet padding</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/facet.html">Vega-Lite Faceting</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see facet_col
</code></pre>

<hr>
<h2 id='filter_null'>Filter 'null' values</h2><span id='topic+filter_null'></span>

<h3>Description</h3>

<p>Whether to filter null values from the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_null(vl, setting = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_null_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object created by <code><a href="#topic+vegalite">vegalite</a></code></p>
</td></tr>
<tr><td><code id="filter_null_+3A_setting">setting</code></td>
<td>
<p>if <code>NULL</code> only quantitative and temporal fields are
filtered. If <code>TRUE</code>, all data items with 'null' values are
filtered. If <code>FALSE</code>, all data items are included.</p>
</td></tr>
</table>

<hr>
<h2 id='from_spec'>Take a JSON Vega-Lite Spec and render as an htmlwidget</h2><span id='topic+from_spec'></span>

<h3>Description</h3>

<p>Vega-Lite is - at the core - a JSON &quot;Grammar of Graphics&quot; specification
for how to build a data- &amp; stats-based visualization. While Vega &amp; D3 are
the main targets, the use of Vega-Lite does not have to be restricted to just
D3. For now, this function takes in a JSON spec (full text or URL) and
renders it as an htmlwidget. Data should either be embedded or use a
an absolute URL reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_spec(spec, width = NULL, height = NULL, renderer = c("svg",
  "canvas"), export = FALSE, source = FALSE, editor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_spec_+3A_spec">spec</code></td>
<td>
<p>URL to a Vega-Lite JSON file or the JSON text of a spec</p>
</td></tr>
<tr><td><code id="from_spec_+3A_width">width</code>, <code id="from_spec_+3A_height">height</code></td>
<td>
<p>widget width/height</p>
</td></tr>
<tr><td><code id="from_spec_+3A_renderer">renderer</code></td>
<td>
<p>the renderer to use for the view. One of <code>canvas</code> or
<code>svg</code> (the default)</p>
</td></tr>
<tr><td><code id="from_spec_+3A_export">export</code></td>
<td>
<p>if <code>TRUE</code> the <em>&quot;Export as...&quot;</em> link will
be displayed with the chart.(Default: <code>FALSE</code>.)</p>
</td></tr>
<tr><td><code id="from_spec_+3A_source">source</code></td>
<td>
<p>if <code>TRUE</code> the <em>&quot;View Source&quot;</em> link will be displayed
with the chart. (Default: <code>FALSE</code>.)</p>
</td></tr>
<tr><td><code id="from_spec_+3A_editor">editor</code></td>
<td>
<p>if <code>TRUE</code> the <em>&quot;Open in editor&quot;</em> link will be
displayed with the cahrt. (Default: <code>FALSE</code>.)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>from_spec("http://rud.is/dl/embedded.json")
</code></pre>

<hr>
<h2 id='grid_facet'>Facet grid aesthetics</h2><span id='topic+grid_facet'></span>

<h3>Description</h3>

<p>Facet grid aesthetics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_facet(vl, grid_color = NULL, grid_opacity = NULL, grid_offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_facet_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="grid_facet_+3A_grid_color">grid_color</code></td>
<td>
<p>color of the grid between facets.</p>
</td></tr>
<tr><td><code id="grid_facet_+3A_grid_opacity">grid_opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="grid_facet_+3A_grid_offset">grid_offset</code></td>
<td>
<p>offset for grid between facets.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/config.html#facet-config">Vega-Lite Facet spec</a>
</p>

<hr>
<h2 id='JS'>Mark character strings as literal JavaScript code</h2><span id='topic+JS'></span>

<h3>Description</h3>

<p>Mark character strings as literal JavaScript code
</p>

<hr>
<h2 id='legend_color'>Legend settings (color)</h2><span id='topic+legend_color'></span>

<h3>Description</h3>

<p>Legend settings (color)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legend_color(vl, orient = NULL, title = NULL, format = NULL,
  short_time_labels = NULL, value = NULL, remove = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legend_color_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="legend_color_+3A_orient">orient</code></td>
<td>
<p>the orientation of the legend. One of &quot;left&quot; or &quot;right&quot;. This
determines how the legend is positioned within the scene.</p>
</td></tr>
<tr><td><code id="legend_color_+3A_title">title</code></td>
<td>
<p>the title for the legend.</p>
</td></tr>
<tr><td><code id="legend_color_+3A_format">format</code></td>
<td>
<p>the formatting pattern for axis labels. This is D3’s number
format pattern for quantitative axis and D3’s time format pattern
for time axis.</p>
</td></tr>
<tr><td><code id="legend_color_+3A_short_time_labels">short_time_labels</code></td>
<td>
<p>whether month and day names should be abbreviated.</p>
</td></tr>
<tr><td><code id="legend_color_+3A_value">value</code></td>
<td>
<p>explicitly set the visible legend values.</p>
</td></tr>
<tr><td><code id="legend_color_+3A_remove">remove</code></td>
<td>
<p>if <code>TRUE</code>, there will be no legend for this aesthetic.</p>
</td></tr>
</table>

<hr>
<h2 id='legend_shape'>Legend settings (shape)</h2><span id='topic+legend_shape'></span>

<h3>Description</h3>

<p>Legend settings (shape)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legend_shape(vl, orient = NULL, title = NULL, format = NULL,
  short_time_labels = NULL, value = NULL, remove = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legend_shape_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="legend_shape_+3A_orient">orient</code></td>
<td>
<p>the orientation of the legend. One of &quot;left&quot; or &quot;right&quot;. This
determines how the legend is positioned within the scene.</p>
</td></tr>
<tr><td><code id="legend_shape_+3A_title">title</code></td>
<td>
<p>the title for the legend.</p>
</td></tr>
<tr><td><code id="legend_shape_+3A_format">format</code></td>
<td>
<p>the formatting pattern for axis labels. This is D3’s number
format pattern for quantitative axis and D3’s time format pattern
for time axis.</p>
</td></tr>
<tr><td><code id="legend_shape_+3A_short_time_labels">short_time_labels</code></td>
<td>
<p>whether month and day names should be abbreviated.</p>
</td></tr>
<tr><td><code id="legend_shape_+3A_value">value</code></td>
<td>
<p>explicitly set the visible legend values.</p>
</td></tr>
<tr><td><code id="legend_shape_+3A_remove">remove</code></td>
<td>
<p>if <code>TRUE</code>, there will be no legend for this aesthetic.</p>
</td></tr>
</table>

<hr>
<h2 id='legend_size'>Legend settings (size)</h2><span id='topic+legend_size'></span>

<h3>Description</h3>

<p>Legend settings (size)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legend_size(vl, orient = NULL, title = NULL, format = NULL,
  short_time_labels = NULL, value = NULL, remove = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legend_size_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="legend_size_+3A_orient">orient</code></td>
<td>
<p>the orientation of the legend. One of &quot;left&quot; or &quot;right&quot;. This
determines how the legend is positioned within the scene.</p>
</td></tr>
<tr><td><code id="legend_size_+3A_title">title</code></td>
<td>
<p>the title for the legend.</p>
</td></tr>
<tr><td><code id="legend_size_+3A_format">format</code></td>
<td>
<p>the formatting pattern for axis labels. This is D3’s number
format pattern for quantitative axis and D3’s time format pattern
for time axis.</p>
</td></tr>
<tr><td><code id="legend_size_+3A_short_time_labels">short_time_labels</code></td>
<td>
<p>whether month and day names should be abbreviated.</p>
</td></tr>
<tr><td><code id="legend_size_+3A_value">value</code></td>
<td>
<p>explicitly set the visible legend values.</p>
</td></tr>
<tr><td><code id="legend_size_+3A_remove">remove</code></td>
<td>
<p>if <code>TRUE</code>, there will be no legend for this aesthetic.</p>
</td></tr>
</table>

<hr>
<h2 id='mark_area'>Area mark</h2><span id='topic+mark_area'></span>

<h3>Description</h3>

<p>An area represent multiple data element as a single area shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_area(vl, orient = NULL, stack = NULL, interpolate = NULL,
  tension = NULL, opacity = NULL, filled = NULL, color = NULL,
  fill = NULL, stroke = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_area_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="mark_area_+3A_orient">orient</code></td>
<td>
<p>the orientation of a non-stacked bar, area, and line charts.
The value is either &quot;horizontal&quot;, or &quot;vertical&quot; (default). For bar and
tick, this determines whether the size of the bar and tick should be
applied to x or y dimension. For area, this property determines the
orient property of the Vega output. For line, this property determines
the path order of the points in the line if path channel is not specified.
For stacked charts, this is always determined by the orientation of the stack;
therefore explicitly specified value will be ignored.</p>
</td></tr>
<tr><td><code id="mark_area_+3A_stack">stack</code></td>
<td>
<p>stacking modes for bar and area marks. <code>zero</code> - stacking
with baseline offset at zero value of the scale (for creating typical stacked
bar and area chart). <code>normalize</code> - stacking with normalized domain (for
creating normalized stacked bar and area chart). <code>center</code> - stacking
with center baseline (for streamgraph). <code>none</code> - No-stacking. This will
produces layered bar and area chart.</p>
</td></tr>
<tr><td><code id="mark_area_+3A_interpolate">interpolate</code></td>
<td>
<p>The line interpolation method to use. One of <code>linear</code>
<code>step-before</code>, <code>step-after</code>, <code>basis</code>, <code>basis-open</code>,
<code>basis-closed</code>, <code>bundle</code>, <code>cardinal</code>, <code>cardinal-open</code>,
<code>cardinal-closed</code>, <code>monotone</code>. For more information about each
interpolation method, please see D3’s line interpolation.</p>
</td></tr>
<tr><td><code id="mark_area_+3A_tension">tension</code></td>
<td>
<p>Depending on the interpolation type, sets the tension parameter.
(See D3’s line interpolation.)</p>
</td></tr>
<tr><td><code id="mark_area_+3A_opacity">opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="mark_area_+3A_filled">filled</code></td>
<td>
<p>whether the shape's color should be used as fill color instead of stroke color.</p>
</td></tr>
<tr><td><code id="mark_area_+3A_color">color</code></td>
<td>
<p>color of the mark – either fill or stroke color based on the filled mark config.</p>
</td></tr>
<tr><td><code id="mark_area_+3A_fill">fill</code></td>
<td>
<p>fill color. This config will be overridden by color channel’s
specified or mapped values if filled is true.</p>
</td></tr>
<tr><td><code id="mark_area_+3A_stroke">stroke</code></td>
<td>
<p>stroke color. This config will be overridden by color channel’s
specified or mapped values if filled is false.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/mark.html">Vega-Lite Mark spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  cell_size(300, 200) %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/unemployment-across-industries.json") %&gt;%
  encode_x("date", "temporal") %&gt;%
  encode_y("count", "quantitative", aggregate="sum") %&gt;%
  encode_color("series", "nominal") %&gt;%
  scale_color_nominal(range="category20b") %&gt;%
  timeunit_x("yearmonth") %&gt;%
  scale_x_time(nice="month") %&gt;%
  axis_x(axisWidth=0, format="%Y", labelAngle=0) %&gt;%
  mark_area()
</code></pre>

<hr>
<h2 id='mark_bar'>Bar mark</h2><span id='topic+mark_bar'></span>

<h3>Description</h3>

<p>A bar mark represents each data point as a rectangle, where the length is
mapped to a quantitative scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_bar(vl, orient = NULL, stack = NULL, size = NULL, opacity = NULL,
  filled = NULL, color = NULL, fill = NULL, stroke = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_bar_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="mark_bar_+3A_orient">orient</code></td>
<td>
<p>the orientation of a non-stacked bar, area, and line charts.
The value is either &quot;horizontal&quot;, or &quot;vertical&quot; (default). For bar and
tick, this determines whether the size of the bar and tick should be
applied to x or y dimension. For area, this property determines the
orient property of the Vega output. For line, this property determines
the path order of the points in the line if path channel is not specified.
For stacked charts, this is always determined by the orientation of the stack;
therefore explicitly specified value will be ignored.</p>
</td></tr>
<tr><td><code id="mark_bar_+3A_stack">stack</code></td>
<td>
<p>stacking modes for bar and area marks. <code>zero</code> - stacking
with baseline offset at zero value of the scale (for creating typical stacked
bar and area chart). <code>normalize</code> - stacking with normalized domain (for
creating normalized stacked bar and area chart). <code>center</code> - stacking
with center baseline (for streamgraph). <code>none</code> - No-stacking. This will
produces layered bar and area chart.</p>
</td></tr>
<tr><td><code id="mark_bar_+3A_size">size</code></td>
<td>
<p>The pixel area each the point. For example: in the case of circles,
the radius is determined in part by the square root of the size value.</p>
</td></tr>
<tr><td><code id="mark_bar_+3A_opacity">opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="mark_bar_+3A_filled">filled</code></td>
<td>
<p>whether the shape's color should be used as fill color instead of stroke color.</p>
</td></tr>
<tr><td><code id="mark_bar_+3A_color">color</code></td>
<td>
<p>color of the mark – either fill or stroke color based on the filled mark config.</p>
</td></tr>
<tr><td><code id="mark_bar_+3A_fill">fill</code></td>
<td>
<p>fill color. This config will be overridden by color channel’s
specified or mapped values if filled is true.</p>
</td></tr>
<tr><td><code id="mark_bar_+3A_stroke">stroke</code></td>
<td>
<p>stroke color. This config will be overridden by color channel’s
specified or mapped values if filled is false.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/mark.html">Vega-Lite Mark spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- jsonlite::fromJSON('[
    {"a": "A","b": 28}, {"a": "B","b": 55}, {"a": "C","b": 43},
    {"a": "D","b": 91}, {"a": "E","b": 81}, {"a": "F","b": 53},
    {"a": "G","b": 19}, {"a": "H","b": 87}, {"a": "I","b": 52}
  ]')

vegalite() %&gt;%
  add_data(dat) %&gt;%
  encode_x("a", "ordinal") %&gt;%
  encode_y("b", "quantitative") %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='mark_circle'>Circle mark</h2><span id='topic+mark_circle'></span>

<h3>Description</h3>

<p>Circle and square marks are similar to point mark, except that (1) the shape
value is always set to circle or square (2) they are filled by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_circle(vl, size = NULL, opacity = NULL, filled = NULL,
  color = NULL, fill = NULL, stroke = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_circle_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="mark_circle_+3A_size">size</code></td>
<td>
<p>The pixel area each the point. For example: in the case of circles,
the radius is determined in part by the square root of the size value.</p>
</td></tr>
<tr><td><code id="mark_circle_+3A_opacity">opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="mark_circle_+3A_filled">filled</code></td>
<td>
<p>whether the shape's color should be used as fill color instead of stroke color.</p>
</td></tr>
<tr><td><code id="mark_circle_+3A_color">color</code></td>
<td>
<p>color of the mark – either fill or stroke color based on the filled mark config.</p>
</td></tr>
<tr><td><code id="mark_circle_+3A_fill">fill</code></td>
<td>
<p>fill color. This config will be overridden by color channel’s
specified or mapped values if filled is true.</p>
</td></tr>
<tr><td><code id="mark_circle_+3A_stroke">stroke</code></td>
<td>
<p>stroke color. This config will be overridden by color channel’s
specified or mapped values if filled is false.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/mark.html">Vega-Lite Mark spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/cars.json") %&gt;%
  encode_x("Horsepower", "quantitative") %&gt;%
  encode_y("Miles_per_Gallon", "quantitative") %&gt;%
  mark_circle()
</code></pre>

<hr>
<h2 id='mark_line'>Line mark</h2><span id='topic+mark_line'></span>

<h3>Description</h3>

<p>A line mark represents the data points stored in a field with a line
connecting all of these points. Unlike other marks except area that represents
one data element per mark, one line mark represent multiple data element as
a single line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_line(vl, orient = NULL, interpolate = NULL, tension = NULL,
  opacity = NULL, color = NULL, fill = NULL, stroke = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_line_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="mark_line_+3A_orient">orient</code></td>
<td>
<p>the orientation of a non-stacked bar, area, and line charts.
The value is either &quot;horizontal&quot;, or &quot;vertical&quot; (default). For bar and
tick, this determines whether the size of the bar and tick should be
applied to x or y dimension. For area, this property determines the
orient property of the Vega output. For line, this property determines
the path order of the points in the line if path channel is not specified.
For stacked charts, this is always determined by the orientation of the stack;
therefore explicitly specified value will be ignored.</p>
</td></tr>
<tr><td><code id="mark_line_+3A_interpolate">interpolate</code></td>
<td>
<p>The line interpolation method to use. One of <code>linear</code>
<code>step-before</code>, <code>step-after</code>, <code>basis</code>, <code>basis-open</code>,
<code>basis-closed</code>, <code>bundle</code>, <code>cardinal</code>, <code>cardinal-open</code>,
<code>cardinal-closed</code>, <code>monotone</code>. For more information about each
interpolation method, please see D3’s line interpolation.</p>
</td></tr>
<tr><td><code id="mark_line_+3A_tension">tension</code></td>
<td>
<p>Depending on the interpolation type, sets the tension parameter.
(See D3’s line interpolation.)</p>
</td></tr>
<tr><td><code id="mark_line_+3A_opacity">opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="mark_line_+3A_color">color</code></td>
<td>
<p>color of the mark – either fill or stroke color based on the filled mark config.</p>
</td></tr>
<tr><td><code id="mark_line_+3A_fill">fill</code></td>
<td>
<p>fill color. This config will be overridden by color channel’s
specified or mapped values if filled is true.</p>
</td></tr>
<tr><td><code id="mark_line_+3A_stroke">stroke</code></td>
<td>
<p>stroke color. This config will be overridden by color channel’s
specified or mapped values if filled is false.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/mark.html">Vega-Lite Mark spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  cell_size(300, 300) %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/driving.json") %&gt;%
  encode_x("miles", "quantitative") %&gt;%
  encode_y("gas", "quantitative") %&gt;%
  encode_path("year", "temporal") %&gt;%
  scale_x_linear(zero=FALSE) %&gt;%
  scale_y_linear(zero=FALSE) %&gt;%
  mark_line()
</code></pre>

<hr>
<h2 id='mark_point'>Point mark</h2><span id='topic+mark_point'></span>

<h3>Description</h3>

<p>A point mark represents each data point with a symbol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_point(vl, shape = "circle", size = NULL, opacity = NULL,
  filled = NULL, color = NULL, fill = NULL, stroke = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_point_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="mark_point_+3A_shape">shape</code></td>
<td>
<p>The symbol shape to use. One of <code>circle</code>, <code>square</code>,
<code>cross</code>, <code>diamond</code>, <code>triangle-up</code>, or <code>triangle-down</code>.
Default value: <code>circle</code>.</p>
</td></tr>
<tr><td><code id="mark_point_+3A_size">size</code></td>
<td>
<p>The pixel area each the point. For example: in the case of circles,
the radius is determined in part by the square root of the size value.</p>
</td></tr>
<tr><td><code id="mark_point_+3A_opacity">opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="mark_point_+3A_filled">filled</code></td>
<td>
<p>whether the shape's color should be used as fill color instead of stroke color.</p>
</td></tr>
<tr><td><code id="mark_point_+3A_color">color</code></td>
<td>
<p>color of the mark – either fill or stroke color based on the filled mark config.</p>
</td></tr>
<tr><td><code id="mark_point_+3A_fill">fill</code></td>
<td>
<p>fill color. This config will be overridden by color channel’s
specified or mapped values if filled is true.</p>
</td></tr>
<tr><td><code id="mark_point_+3A_stroke">stroke</code></td>
<td>
<p>stroke color. This config will be overridden by color channel’s
specified or mapped values if filled is false.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/mark.html">Vega-Lite Mark spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/cars.json") %&gt;%
  encode_x("Horsepower", "quantitative") %&gt;%
  encode_y("Miles_per_Gallon", "quantitative") %&gt;%
  mark_point()
</code></pre>

<hr>
<h2 id='mark_square'>Square mark</h2><span id='topic+mark_square'></span>

<h3>Description</h3>

<p>Circle and square marks are similar to point mark, except that (1) the shape
value is always set to circle or square (2) they are filled by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_square(vl, size = NULL, opacity = NULL, filled = NULL,
  color = NULL, fill = NULL, stroke = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_square_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="mark_square_+3A_size">size</code></td>
<td>
<p>The pixel area each the point. For example: in the case of circles,
the radius is determined in part by the square root of the size value.</p>
</td></tr>
<tr><td><code id="mark_square_+3A_opacity">opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="mark_square_+3A_filled">filled</code></td>
<td>
<p>whether the shape's color should be used as fill color instead of stroke color.</p>
</td></tr>
<tr><td><code id="mark_square_+3A_color">color</code></td>
<td>
<p>color of the mark – either fill or stroke color based on the filled mark config.</p>
</td></tr>
<tr><td><code id="mark_square_+3A_fill">fill</code></td>
<td>
<p>fill color. This config will be overridden by color channel’s
specified or mapped values if filled is true.</p>
</td></tr>
<tr><td><code id="mark_square_+3A_stroke">stroke</code></td>
<td>
<p>stroke color. This config will be overridden by color channel’s
specified or mapped values if filled is false.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/mark.html">Vega-Lite Mark spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/cars.json") %&gt;%
  encode_x("Horsepower", "quantitative") %&gt;%
  encode_y("Miles_per_Gallon", "quantitative") %&gt;%
  mark_square()
</code></pre>

<hr>
<h2 id='mark_text'>Text mark</h2><span id='topic+mark_text'></span>

<h3>Description</h3>

<p>A text mark represents each data point with a text instead of a point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_text(vl, opacity = NULL, color = NULL, fill = NULL, stroke = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_text_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="mark_text_+3A_opacity">opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="mark_text_+3A_color">color</code></td>
<td>
<p>color of the mark – either fill or stroke color based on the filled mark config.</p>
</td></tr>
<tr><td><code id="mark_text_+3A_fill">fill</code></td>
<td>
<p>fill color. This config will be overridden by color channel’s
specified or mapped values if filled is true.</p>
</td></tr>
<tr><td><code id="mark_text_+3A_stroke">stroke</code></td>
<td>
<p>stroke color. This config will be overridden by color channel’s
specified or mapped values if filled is false.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/mark.html">Vega-Lite Mark spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  cell_size(300, 200) %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/cars.json") %&gt;%
  encode_x("Horsepower", "quantitative") %&gt;%
  encode_y("Miles_per_Gallon", "quantitative") %&gt;%
  encode_color("Origin", "nominal") %&gt;%
  calculate("OriginInitial", "datum.Origin[0]") %&gt;%
  encode_text("OriginInitial", "nominal") %&gt;%
  mark_text()
</code></pre>

<hr>
<h2 id='mark_tick'>Tick mark</h2><span id='topic+mark_tick'></span>

<h3>Description</h3>

<p>A tick mark represents each data point as a short line. This is a useful
mark for displaying the distribution of values in a field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_tick(vl, orient = NULL, size = NULL, thickness = 1, opacity = NULL,
  color = NULL, fill = NULL, stroke = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_tick_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="mark_tick_+3A_orient">orient</code></td>
<td>
<p>the orientation of a non-stacked bar, area, and line charts.
The value is either &quot;horizontal&quot;, or &quot;vertical&quot; (default). For bar and
tick, this determines whether the size of the bar and tick should be
applied to x or y dimension. For area, this property determines the
orient property of the Vega output. For line, this property determines
the path order of the points in the line if path channel is not specified.
For stacked charts, this is always determined by the orientation of the stack;
therefore explicitly specified value will be ignored.</p>
</td></tr>
<tr><td><code id="mark_tick_+3A_size">size</code></td>
<td>
<p>The pixel area each the point. For example: in the case of circles,
the radius is determined in part by the square root of the size value.</p>
</td></tr>
<tr><td><code id="mark_tick_+3A_thickness">thickness</code></td>
<td>
<p>Thickness of the tick mark. Default value: 1</p>
</td></tr>
<tr><td><code id="mark_tick_+3A_opacity">opacity</code></td>
<td>
<p><code>0.0</code>-<code>1.0</code></p>
</td></tr>
<tr><td><code id="mark_tick_+3A_color">color</code></td>
<td>
<p>color of the mark – either fill or stroke color based on the filled mark config.</p>
</td></tr>
<tr><td><code id="mark_tick_+3A_fill">fill</code></td>
<td>
<p>fill color. This config will be overridden by color channel’s
specified or mapped values if filled is true.</p>
</td></tr>
<tr><td><code id="mark_tick_+3A_stroke">stroke</code></td>
<td>
<p>stroke color. This config will be overridden by color channel’s
specified or mapped values if filled is false.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/mark.html">Vega-Lite Mark spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/cars.json") %&gt;%
  encode_x("Horsepower", "quantitative") %&gt;%
  encode_y("Cylinders", "ordinal") %&gt;%
  mark_tick()
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic++25+3E+25'></span><span id='topic+reexports'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='renderVegalite'>Widget render function for use in Shiny</h2><span id='topic+renderVegalite'></span>

<h3>Description</h3>

<p>Widget render function for use in Shiny
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renderVegalite(expr, env = parent.frame(), quoted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renderVegalite_+3A_expr">expr</code></td>
<td>
<p>expr to render</p>
</td></tr>
<tr><td><code id="renderVegalite_+3A_env">env</code></td>
<td>
<p>evaluation environemnt</p>
</td></tr>
<tr><td><code id="renderVegalite_+3A_quoted">quoted</code></td>
<td>
<p>quote expression?</p>
</td></tr>
</table>

<hr>
<h2 id='saveWidget'>Save a widget to an HTML file</h2><span id='topic+saveWidget'></span>

<h3>Description</h3>

<p>Save a widget to an HTML file
</p>

<hr>
<h2 id='scale_color_nominal'>Nominal Color Scale</h2><span id='topic+scale_color_nominal'></span>

<h3>Description</h3>

<p>Nominal Color Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_color_nominal(vl, domain = NULL, range = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_color_nominal_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_color_nominal_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_color_nominal_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_color_sequential'>Sequential Color Scale</h2><span id='topic+scale_color_sequential'></span>

<h3>Description</h3>

<p>Sequential Color Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_color_sequential(vl, domain = NULL, range = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_color_sequential_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_color_sequential_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_color_sequential_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_shape'>Shape Scale</h2><span id='topic+scale_shape'></span>

<h3>Description</h3>

<p>Shape Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_shape(vl, domain = NULL, range = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_shape_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_shape_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_shape_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_x_linear'>Quantitative Scale</h2><span id='topic+scale_x_linear'></span>

<h3>Description</h3>

<p>Quantitative Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_linear(vl, domain = NULL, range = NULL, clamp = NULL,
  nice = NULL, zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_linear_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_x_linear_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_x_linear_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_x_linear_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_x_linear_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_x_linear_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_x_log'>Log Scale</h2><span id='topic+scale_x_log'></span>

<h3>Description</h3>

<p>Log Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_log(vl, domain = NULL, range = NULL, clamp = NULL, nice = NULL,
  zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_log_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_x_log_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_x_log_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_x_log_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_x_log_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_x_log_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_x_ordinal'>Ordinal Scale</h2><span id='topic+scale_x_ordinal'></span>

<h3>Description</h3>

<p>Ordinal Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_ordinal(vl, band_size = NULL, padding = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_ordinal_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_x_ordinal_+3A_band_size">band_size</code></td>
<td>
<p>band size</p>
</td></tr>
<tr><td><code id="scale_x_ordinal_+3A_padding">padding</code></td>
<td>
<p>padding</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/population.json") %&gt;%
  add_filter("datum.year == 2000") %&gt;%
  calculate("gender", 'datum.sex == 2 ? "Female" : "Male"') %&gt;%
  encode_x("gender", "nominal") %&gt;%
  encode_y("people", "quantitative", aggregate="sum") %&gt;%
  encode_color("gender", "nominal") %&gt;%
  scale_x_ordinal(band_size=6) %&gt;%
  scale_color_nominal(range=c("#EA98D2", "#659CCA")) %&gt;%
  facet_col("age", "ordinal", padding=4) %&gt;%
  axis_x(remove=TRUE) %&gt;%
  axis_y(title="population", grid=FALSE) %&gt;%
  axis_facet_col(orient="bottom", axisWidth=1, offset=-8) %&gt;%
  facet_cell(stroke_width=0) %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='scale_x_pow'>Quantitative Scale</h2><span id='topic+scale_x_pow'></span>

<h3>Description</h3>

<p>Quantitative Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_pow(vl, domain = NULL, range = NULL, clamp = NULL, exp = NULL,
  nice = NULL, zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_pow_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_x_pow_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_x_pow_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_x_pow_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_x_pow_+3A_exp">exp</code></td>
<td>
<p>exponent</p>
</td></tr>
<tr><td><code id="scale_x_pow_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_x_pow_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_x_quantile'>Quantile Scale</h2><span id='topic+scale_x_quantile'></span>

<h3>Description</h3>

<p>Quantile Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_quantile(vl, domain = NULL, range = NULL, clamp = NULL,
  nice = NULL, zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_quantile_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_x_quantile_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_x_quantile_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_x_quantile_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_x_quantile_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_x_quantile_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_x_quantize'>Quantize Scale</h2><span id='topic+scale_x_quantize'></span>

<h3>Description</h3>

<p>Quantize Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_quantize(vl, domain = NULL, range = NULL, clamp = NULL,
  nice = NULL, zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_quantize_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_x_quantize_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_x_quantize_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_x_quantize_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_x_quantize_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_x_quantize_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_x_sqrt'>Sqrt Scale</h2><span id='topic+scale_x_sqrt'></span>

<h3>Description</h3>

<p>Sqrt Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_sqrt(vl, domain = NULL, range = NULL, clamp = NULL, nice = NULL,
  zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_sqrt_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_x_sqrt_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_x_sqrt_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_x_sqrt_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_x_sqrt_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_x_sqrt_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_x_threshold'>Threshold Scale</h2><span id='topic+scale_x_threshold'></span>

<h3>Description</h3>

<p>Threshold Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_threshold(vl, domain = NULL, range = NULL, clamp = NULL,
  nice = NULL, zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_threshold_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_x_threshold_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_x_threshold_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_x_threshold_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_x_threshold_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_x_threshold_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_x_time'>Temporal Scale</h2><span id='topic+scale_x_time'></span>

<h3>Description</h3>

<p>Temporal Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_time(vl, domain = NULL, range = NULL, clamp = NULL, nice = NULL,
  zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_time_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_x_time_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_x_time_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_x_time_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_x_time_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_x_time_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_y_linear'>Linear Scale</h2><span id='topic+scale_y_linear'></span>

<h3>Description</h3>

<p>Linear Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_linear(vl, domain = NULL, range = NULL, clamp = NULL,
  nice = NULL, zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_y_linear_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_y_linear_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_y_linear_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_y_linear_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_y_linear_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_y_linear_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_y_log'>Log Scale</h2><span id='topic+scale_y_log'></span>

<h3>Description</h3>

<p>Log Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_log(vl, domain = NULL, range = NULL, clamp = NULL, nice = NULL,
  zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_y_log_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_y_log_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_y_log_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_y_log_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_y_log_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_y_log_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_y_ordinal'>Ordinal Scale</h2><span id='topic+scale_y_ordinal'></span>

<h3>Description</h3>

<p>Ordinal Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_ordinal(vl, band_size = NULL, padding = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_y_ordinal_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_y_ordinal_+3A_band_size">band_size</code></td>
<td>
<p>band size</p>
</td></tr>
<tr><td><code id="scale_y_ordinal_+3A_padding">padding</code></td>
<td>
<p>padding</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_y_pow'>Power Scale</h2><span id='topic+scale_y_pow'></span>

<h3>Description</h3>

<p>Power Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_pow(vl, domain = NULL, range = NULL, clamp = NULL, exp = NULL,
  nice = NULL, zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_y_pow_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_y_pow_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_y_pow_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_y_pow_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_y_pow_+3A_exp">exp</code></td>
<td>
<p>exponent</p>
</td></tr>
<tr><td><code id="scale_y_pow_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_y_pow_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_y_quantile'>Quantile Scale</h2><span id='topic+scale_y_quantile'></span>

<h3>Description</h3>

<p>Quantile Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_quantile(vl, domain = NULL, range = NULL, clamp = NULL,
  nice = NULL, zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_y_quantile_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_y_quantile_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_y_quantile_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_y_quantile_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_y_quantile_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_y_quantile_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_y_quantize'>Quantize Scale</h2><span id='topic+scale_y_quantize'></span>

<h3>Description</h3>

<p>Quantize Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_quantize(vl, domain = NULL, range = NULL, clamp = NULL,
  nice = NULL, zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_y_quantize_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_y_quantize_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_y_quantize_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_y_quantize_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_y_quantize_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_y_quantize_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_y_sqrt'>Sqrt Scale</h2><span id='topic+scale_y_sqrt'></span>

<h3>Description</h3>

<p>Sqrt Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_sqrt(vl, domain = NULL, range = NULL, clamp = NULL, nice = NULL,
  zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_y_sqrt_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_y_sqrt_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_y_sqrt_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_y_sqrt_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_y_sqrt_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_y_sqrt_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_y_threshold'>Threshold Scale</h2><span id='topic+scale_y_threshold'></span>

<h3>Description</h3>

<p>Threshold Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_threshold(vl, domain = NULL, range = NULL, clamp = NULL,
  nice = NULL, zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_y_threshold_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_y_threshold_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_y_threshold_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_y_threshold_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_y_threshold_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_y_threshold_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='scale_y_time'>Temporal Scale</h2><span id='topic+scale_y_time'></span>

<h3>Description</h3>

<p>Temporal Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_time(vl, domain = NULL, range = NULL, clamp = NULL, nice = NULL,
  zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_y_time_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="scale_y_time_+3A_domain">domain</code></td>
<td>
<p>Custom domain values. For quantitative data, this can take the
form of a two-element array with minimum and maximum values.</p>
</td></tr>
<tr><td><code id="scale_y_time_+3A_range">range</code></td>
<td>
<p>The range of the scale represents the set of output visual values.
Vega-Lite automatically determines appropriate range based on the scale’s
channel and type, but range property can be provided to customize range
values.</p>
</td></tr>
<tr><td><code id="scale_y_time_+3A_clamp">clamp</code></td>
<td>
<p>if true, values that exceed the data domain are clamped to either
the minimum or maximum range value. Default value: derived from scale
config (true by default) Supported Types: only linear, pow, sqrt, and log</p>
</td></tr>
<tr><td><code id="scale_y_time_+3A_nice">nice</code></td>
<td>
<p>If true, modifies the scale domain to use a more human-friendly
number range (e.g., 7 instead of 6.96). Default value: true only for
quantitative x and y scales and false otherwise.</p>
</td></tr>
<tr><td><code id="scale_y_time_+3A_zero">zero</code></td>
<td>
<p>If true, ensures that a zero baseline value is included in the
scale domain. Default value: true if the quantitative field is not binned.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/scale.html">Vega-Lite Scales spec</a>
</p>

<hr>
<h2 id='sort_def'>Create a sort definition object</h2><span id='topic+sort_def'></span>

<h3>Description</h3>

<p>You can sort by aggregated value of another “sort” field by creating a
sort field definition object. All three properties must be non-<code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_def(field, op = NULL, order = c("ascending", "descending"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_def_+3A_field">field</code></td>
<td>
<p>the field name to aggregate over.</p>
</td></tr>
<tr><td><code id="sort_def_+3A_op">op</code></td>
<td>
<p>a valid <a href="http://vega.github.io/vega-lite/docs/sort.html#aggregate">aggregation operator</a>.</p>
</td></tr>
<tr><td><code id="sort_def_+3A_order">order</code></td>
<td>
<p>either <code>ascending</code> or <code>descending</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/cars.json") %&gt;%
  encode_x("Horsepower", type="quantitative", aggregate="mean") %&gt;%
  encode_y("Origin", "ordinal", sort=sort_def("Horsepower", "mean")) %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='timeunit_x'>How to encode x-axis time values</h2><span id='topic+timeunit_x'></span>

<h3>Description</h3>

<p>How to encode x-axis time values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeunit_x(vl, unit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeunit_x_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="timeunit_x_+3A_unit">unit</code></td>
<td>
<p>the property of a channel definition sets the level of specificity
for a temporal field. Currently supported values are 'year', 'yearmonth',
'yearmonthday', 'yearmonthdate', 'yearday', 'yeardate', 'yearmonthdayhours'
and 'yearmonthdayhoursminutes' for non-periodic time units &amp; 'month',
'day', 'date', 'hours', 'minutes', 'seconds', 'milliseconds', 'hoursminutes',
'hoursminutesseconds', 'minutesseconds' and 'secondsmilliseconds' for
periodic time units.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/timeunit.html">Vega-Lite Time Unit</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vegalite() %&gt;%
  cell_size(300, 300) %&gt;%
  add_data("https://vega.github.io/vega-editor/app/data/unemployment-across-industries.json") %&gt;%
  encode_x("date", "temporal") %&gt;%
  encode_y("count", "quantitative", aggregate="sum") %&gt;%
  encode_color("series", "nominal") %&gt;%
  scale_x_time(nice="month") %&gt;%
  scale_color_nominal(range="category20b") %&gt;%
  axis_x(axisWidth=0, format="%Y", labelAngle=0) %&gt;%
  axis_y(remove=TRUE) %&gt;%
  timeunit_x("yearmonth") %&gt;%
  mark_area(stack="normalize")
</code></pre>

<hr>
<h2 id='timeunit_y'>How to encode y-axis time values</h2><span id='topic+timeunit_y'></span>

<h3>Description</h3>

<p>How to encode y-axis time values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeunit_y(vl, unit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeunit_y_+3A_vl">vl</code></td>
<td>
<p>Vega-Lite object</p>
</td></tr>
<tr><td><code id="timeunit_y_+3A_unit">unit</code></td>
<td>
<p>the property of a channel definition sets the level of specificity
for a temporal field. Currently supported values are 'year', 'yearmonth',
'yearmonthday', 'yearmonthdate', 'yearday', 'yeardate', 'yearmonthdayhours'
and 'yearmonthdayhoursminutes' for non-periodic time units &amp; 'month',
'day', 'date', 'hours', 'minutes', 'seconds', 'milliseconds', 'hoursminutes',
'hoursminutesseconds', 'minutesseconds' and 'secondsmilliseconds' for
periodic time units.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/timeunit.html">Vega-Lite Time Unit</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see timeunit_y()
</code></pre>

<hr>
<h2 id='to_spec'>Convert a spec created with widget idioms to JSON</h2><span id='topic+to_spec'></span>

<h3>Description</h3>

<p>Takes an htmlwidget object and turns it into a JSON Vega-Lite spec
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_spec(vl, pretty = TRUE, to_cb = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_spec_+3A_vl">vl</code></td>
<td>
<p>a Vega-Lite object</p>
</td></tr>
<tr><td><code id="to_spec_+3A_pretty">pretty</code></td>
<td>
<p>if <code>TRUE</code> (default) then a &quot;pretty-printed&quot; version of the spec
will be returned. Use <code>FALSE</code> for a more compact version.</p>
</td></tr>
<tr><td><code id="to_spec_+3A_to_cb">to_cb</code></td>
<td>
<p>if <code>TRUE</code>, will copy the spec to the system clipboard. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>JSON spec
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- jsonlite::fromJSON('[
    {"a": "A","b": 28}, {"a": "B","b": 55}, {"a": "C","b": 43},
    {"a": "D","b": 91}, {"a": "E","b": 81}, {"a": "F","b": 53},
    {"a": "G","b": 19}, {"a": "H","b": 87}, {"a": "I","b": 52}
  ]')

vegalite() %&gt;%
  add_data(dat) %&gt;%
  encode_x("a", "ordinal") %&gt;%
  encode_y("b", "quantitative") %&gt;%
  mark_bar() -&gt; chart

to_spec(chart)
</code></pre>

<hr>
<h2 id='vegalite'>Create and (optionally) visualize a Vega-Lite spec</h2><span id='topic+vegalite'></span>

<h3>Description</h3>

<p>Create and (optionally) visualize a Vega-Lite spec
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegalite(description = "", renderer = c("svg", "canvas"), export = FALSE,
  source = FALSE, editor = FALSE, viewport_width = NULL,
  viewport_height = NULL, background = NULL, time_format = NULL,
  number_format = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vegalite_+3A_description">description</code></td>
<td>
<p>a single element character vector that provides a description of
the plot/spec.</p>
</td></tr>
<tr><td><code id="vegalite_+3A_renderer">renderer</code></td>
<td>
<p>the renderer to use for the view. One of <code>canvas</code> or
<code>svg</code> (the default)</p>
</td></tr>
<tr><td><code id="vegalite_+3A_export">export</code></td>
<td>
<p>if <code>TRUE</code> the <em>&quot;Export as...&quot;</em> link will
be displayed with the chart.(Default: <code>FALSE</code>.)</p>
</td></tr>
<tr><td><code id="vegalite_+3A_source">source</code></td>
<td>
<p>if <code>TRUE</code> the <em>&quot;View Source&quot;</em> link will be displayed
with the chart. (Default: <code>FALSE</code>.)</p>
</td></tr>
<tr><td><code id="vegalite_+3A_editor">editor</code></td>
<td>
<p>if <code>TRUE</code> the <em>&quot;Open in editor&quot;</em> link will be
displayed with the cahrt. (Default: <code>FALSE</code>.)</p>
</td></tr>
<tr><td><code id="vegalite_+3A_viewport_width">viewport_width</code>, <code id="vegalite_+3A_viewport_height">viewport_height</code></td>
<td>
<p>height and width of the overall
visualziation viewport. This is the overall area reserved for the
plot. You can leave these <code>NULL</code> and use <code><a href="#topic+cell_size">cell_size</a></code>
instead but you will want to configure both when making faceted plots.</p>
</td></tr>
<tr><td><code id="vegalite_+3A_background">background</code></td>
<td>
<p>plot background color. If <code>NULL</code> the background will be transparent.</p>
</td></tr>
<tr><td><code id="vegalite_+3A_time_format">time_format</code></td>
<td>
<p>the default time format pattern for text and labels of
axes and legends (in the form of <a href="https://github.com/mbostock/d3/wiki/Time-Formatting">D3 time format pattern</a>).
Default: <code>%Y-%m-%d</code></p>
</td></tr>
<tr><td><code id="vegalite_+3A_number_format">number_format</code></td>
<td>
<p>the default number format pattern for text and labels of
axes and legends (in the form of
<a href="https://github.com/mbostock/d3/wiki/Formatting">D3 number format pattern</a>).
Default: <code>s</code></p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://vega.github.io/vega-lite/docs/config.html#top-level-config">Vega-Lite top-level config</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- jsonlite::fromJSON('[
    {"a": "A","b": 28}, {"a": "B","b": 55}, {"a": "C","b": 43},
    {"a": "D","b": 91}, {"a": "E","b": 81}, {"a": "F","b": 53},
    {"a": "G","b": 19}, {"a": "H","b": 87}, {"a": "I","b": 52}
  ]')

vegalite() %&gt;%
  add_data(dat) %&gt;%
  encode_x("a", "ordinal") %&gt;%
  encode_y("b", "quantitative") %&gt;%
  mark_bar()
</code></pre>

<hr>
<h2 id='vegaliteOutput'>Widget output function for use in Shiny</h2><span id='topic+vegaliteOutput'></span>

<h3>Description</h3>

<p>Widget output function for use in Shiny
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegaliteOutput(outputId, width = "100%", height = "400px")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vegaliteOutput_+3A_outputid">outputId</code></td>
<td>
<p>widget output id</p>
</td></tr>
<tr><td><code id="vegaliteOutput_+3A_width">width</code>, <code id="vegaliteOutput_+3A_height">height</code></td>
<td>
<p>widget height/width</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
