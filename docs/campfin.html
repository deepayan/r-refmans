<!DOCTYPE html><html><head><title>Help for package campfin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {campfin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#%out%'><p>Inverted match</p></a></li>
<li><a href='#abbrev_full'><p>Abbreviate full strings</p></a></li>
<li><a href='#abbrev_state'><p>Abbreviate US state names</p></a></li>
<li><a href='#add_prop'><p>Add proportions</p></a></li>
<li><a href='#all_files_new'><p>Check if all files in a directory are new</p></a></li>
<li><a href='#campfin-package'><p><code>campfin</code> package</p></a></li>
<li><a href='#check_city'><p>Check whether an input is a valid place with Google Maps API</p></a></li>
<li><a href='#col_date_mdy'><p>Parse USA date columns in readr functions</p></a></li>
<li><a href='#col_stats'><p>Apply a statistic function to all column vectors</p></a></li>
<li><a href='#count_diff'><p>Count set difference</p></a></li>
<li><a href='#count_in'><p>Count in</p></a></li>
<li><a href='#count_na'><p>Count missing</p></a></li>
<li><a href='#count_out'><p>Count out</p></a></li>
<li><a href='#dark2'><p>Dark Color Palette</p></a></li>
<li><a href='#expand_abbrev'><p>Expand Abbreviations</p></a></li>
<li><a href='#expand_state'><p>Expand US state names</p></a></li>
<li><a href='#explore_plot'><p>Create Basic Barplots</p></a></li>
<li><a href='#extra_city'><p>Additional US City Names</p></a></li>
<li><a href='#fetch_city'><p>Return Closest Match Result of Cities from Google Maps API</p></a></li>
<li><a href='#file_age'><p>File modification date age</p></a></li>
<li><a href='#file_encoding'><p>File Encoding</p></a></li>
<li><a href='#flag_dupes'><p>Flag Duplicate Rows With New Column</p></a></li>
<li><a href='#flag_na'><p>Flag Missing Values With New Column</p></a></li>
<li><a href='#flush_memory'><p>Flush Garbage Memory</p></a></li>
<li><a href='#guess_delim'><p>Guess the delimiter of a text file</p></a></li>
<li><a href='#invalid_city'><p>Invalid City Names</p></a></li>
<li><a href='#invert_named'><p>Invert a named vector</p></a></li>
<li><a href='#is_abbrev'><p>Check if abbreviation</p></a></li>
<li><a href='#is_binary'><p>Check if Binary</p></a></li>
<li><a href='#is_even'><p>Check if even</p></a></li>
<li><a href='#keypad_convert'><p>Convert letters or numbers to their keypad counterpart</p></a></li>
<li><a href='#most_common'><p>Find most common values</p></a></li>
<li><a href='#na_in'><p>Remove in</p></a></li>
<li><a href='#na_out'><p>Remove out</p></a></li>
<li><a href='#na_rep'><p>Remove repeated character elements</p></a></li>
<li><a href='#non_ascii'><p>Show non-ASCII lines of file</p></a></li>
<li><a href='#normal_address'><p>Normalize street addresses</p></a></li>
<li><a href='#normal_city'><p>Normalize city names</p></a></li>
<li><a href='#normal_phone'><p>Normalize phone number</p></a></li>
<li><a href='#normal_state'><p>Normalize US State Abbreviations</p></a></li>
<li><a href='#normal_zip'><p>Normalize ZIP codes</p></a></li>
<li><a href='#path.abbrev'><p>Abbreviate a file path</p></a></li>
<li><a href='#progress_table'><p>Create a progress table</p></a></li>
<li><a href='#prop_distinct'><p>Proportion missing</p></a></li>
<li><a href='#prop_in'><p>Proportion in</p></a></li>
<li><a href='#prop_na'><p>Proportion missing</p></a></li>
<li><a href='#prop_out'><p>Proportion out</p></a></li>
<li><a href='#read_names'><p>Read column names</p></a></li>
<li><a href='#rename_prefix'><p>Convert data frame name suffixes to prefixes</p></a></li>
<li><a href='#rx_break'><p>Form a word break regex pattern</p></a></li>
<li><a href='#rx_phone'><p>Phone number regex</p></a></li>
<li><a href='#rx_state'><p>State regex</p></a></li>
<li><a href='#rx_url'><p>URL regex</p></a></li>
<li><a href='#rx_zip'><p>ZIP code regex</p></a></li>
<li><a href='#scale_x_truncate'><p>Truncate and wrap x-axis labels</p></a></li>
<li><a href='#str_dist'><p>Calculate string distance</p></a></li>
<li><a href='#str_normal'><p>Normalize a character string</p></a></li>
<li><a href='#this_file_new'><p>Check if a single file is new</p></a></li>
<li><a href='#url_file_size'><p>Check a URL file size</p></a></li>
<li><a href='#url2path'><p>Make a File Path from a URL</p></a></li>
<li><a href='#use_diary'><p>Create a new template data diary</p></a></li>
<li><a href='#usps_city'><p>USPS City Abbreviations</p></a></li>
<li><a href='#usps_state'><p>USPS State Abbreviations</p></a></li>
<li><a href='#usps_street'><p>USPS Street Abbreviations</p></a></li>
<li><a href='#valid_abb'><p>US State Abbreviations</p></a></li>
<li><a href='#valid_city'><p>US City Names</p></a></li>
<li><a href='#valid_name'><p>US State Names</p></a></li>
<li><a href='#valid_state'><p>US State Abbreviations</p></a></li>
<li><a href='#valid_zip'><p>Almost all of the valid USA ZIP Codes</p></a></li>
<li><a href='#what_in'><p>Which in</p></a></li>
<li><a href='#what_out'><p>Which out</p></a></li>
<li><a href='#zipcodes'><p>US City, state, and ZIP</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wrangle Campaign Finance Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.11</td>
</tr>
<tr>
<td>Description:</td>
<td>Explore and normalize American campaign finance
    data. Created by the Investigative Reporting Workshop to facilitate
    work on The Accountability Project, an effort to collect public data
    into a central, standard database that is more easily searched:
    <a href="https://publicaccountability.org/">https://publicaccountability.org/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by/4.0">CC BY 4.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/irworkshop/campfin">https://github.com/irworkshop/campfin</a>,
<a href="https://irworkshop.github.io/campfin/">https://irworkshop.github.io/campfin/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/irworkshop/campfin/issues">https://github.com/irworkshop/campfin/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.8.3), fs (&ge; 1.3.1), ggplot2 (&ge; 3.2.1), glue (&ge;
1.3.1), httr (&ge; 1.4.1), lubridate (&ge; 1.7.4), magrittr (&ge;
1.5), purrr (&ge; 0.3.2), readr (&ge; 1.3.1), rlang (&ge; 0.4.0),
scales (&ge; 1.0.0), stringdist (&ge; 0.9.5.2), stringr (&ge; 1.4.0),
tibble (&ge; 2.1.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr (&ge; 3.3.2), knitr (&ge; 1.23), rmarkdown (&ge; 1.14),
spelling (&ge; 2.1), testthat (&ge; 2.1.0), usethis (&ge; 1.6.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-19 15:10:41 UTC; kiernan</td>
</tr>
<tr>
<td>Author:</td>
<td>Kiernan Nicholls [aut, cre, cph],
  Investigative Reporting Workshop [cph],
  Yanqi Xu [aut],
  Schuyler Erle [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kiernan Nicholls &lt;kiernann@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-20 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='+25out+25'>Inverted match</h2><span id='topic++25out+25'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;%out%&#8288;</code> is an inverted version of the infix <code>%in%</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %out% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25out+2B25_+3A_x">x</code></td>
<td>
<p>vector: the values to be matched. Long vectors are supported.</p>
</td></tr>
<tr><td><code id="+2B25out+2B25_+3A_table">table</code></td>
<td>
<p>vector or <code>NULL</code>: the values to be matched against.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code style="white-space: pre;">&#8288;%out%&#8288;</code> is currently defined as
<code>"%out%" &lt;- function(x, table) match(x, table, nomatch = 0) == 0</code>
</p>


<h3>Value</h3>

<p>logical; if <code>x</code> is not present in <code>table</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c("A", "B", "3") %out% LETTERS
</code></pre>

<hr>
<h2 id='abbrev_full'>Abbreviate full strings</h2><span id='topic+abbrev_full'></span>

<h3>Description</h3>

<p>Create or use a named vector (<code>c("full" = "abb")</code>) and pass it to
<code><a href="stringr.html#topic+str_replace">stringr::str_replace_all()</a></code>. The <code>full</code> argument is surrounded with <code style="white-space: pre;">&#8288;\\b&#8288;</code> to
capture only isolated intended full versions. Note that the built-in
<a href="#topic+usps_street">usps_street</a>, <a href="#topic+usps_city">usps_city</a>, and <a href="#topic+usps_state">usps_state</a> dataframes have the columns
reversed from what this function needs (to work by default with the
counterpart <code><a href="#topic+expand_abbrev">expand_abbrev()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abbrev_full(x, full = NULL, rep = NULL, end = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abbrev_full_+3A_x">x</code></td>
<td>
<p>A vector containing full words.</p>
</td></tr>
<tr><td><code id="abbrev_full_+3A_full">full</code></td>
<td>
<p>One of three objects: (1) A dataframe with full strings in the
<em>first</em> column and corresponding abbreviations in the <em>second</em>
column; (2) a <em>named</em> vector, with full strings as names for their
respective abbreviations (e.g., <code>c("full" = "abb")</code>); or (3) an unnamed
vector of full words with an unnamed vector of abbreviations in the <code>rep</code>
argument.</p>
</td></tr>
<tr><td><code id="abbrev_full_+3A_rep">rep</code></td>
<td>
<p>If <code>full</code> is an unnamed vector, a vector of abbreviations strings
for each full word in <code>abb</code>.</p>
</td></tr>
<tr><td><code id="abbrev_full_+3A_end">end</code></td>
<td>
<p>logical; if <code>TRUE</code>, then the <code>$</code> regular expression will be used
to only replace words at the <em>end</em> of a string (such as &quot;ROAD&quot; in a street
address). If <code>FALSE</code> (default), then the <code style="white-space: pre;">&#8288;\b&#8288;</code> regular expression will
target <em>all</em> instances of <code>full</code> to be replaced with <code>rep</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector <code>x</code> with full words replaced with their abbreviations.
</p>


<h3>See Also</h3>

<p>Other geographic normalization functions: 
<code><a href="#topic+abbrev_state">abbrev_state</a>()</code>,
<code><a href="#topic+check_city">check_city</a>()</code>,
<code><a href="#topic+expand_abbrev">expand_abbrev</a>()</code>,
<code><a href="#topic+expand_state">expand_state</a>()</code>,
<code><a href="#topic+fetch_city">fetch_city</a>()</code>,
<code><a href="#topic+normal_address">normal_address</a>()</code>,
<code><a href="#topic+normal_city">normal_city</a>()</code>,
<code><a href="#topic+normal_state">normal_state</a>()</code>,
<code><a href="#topic+normal_zip">normal_zip</a>()</code>,
<code><a href="#topic+str_normal">str_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>abbrev_full("MOUNT VERNON", full = c("MOUNT" = "MT"))
abbrev_full("123 MOUNTAIN ROAD", full = usps_street)
abbrev_full("123 MOUNTAIN ROAD", full = usps_street, end = TRUE)
abbrev_full("Vermont", full = state.name, rep = state.abb)
</code></pre>

<hr>
<h2 id='abbrev_state'>Abbreviate US state names</h2><span id='topic+abbrev_state'></span>

<h3>Description</h3>

<p>This function is used to first normalize a <code>full</code> state name and then call
<code><a href="#topic+abbrev_full">abbrev_full()</a></code> using <a href="#topic+valid_name">valid_name</a> and <a href="#topic+valid_state">valid_state</a> as the <code>full</code> and <code>rep</code>
arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abbrev_state(full)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abbrev_state_+3A_full">full</code></td>
<td>
<p>A full US state name character vector (e.g., &quot;Vermont&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The 2-letter USPS abbreviation of for state names (e.g., &quot;VT&quot;).
</p>


<h3>See Also</h3>

<p>Other geographic normalization functions: 
<code><a href="#topic+abbrev_full">abbrev_full</a>()</code>,
<code><a href="#topic+check_city">check_city</a>()</code>,
<code><a href="#topic+expand_abbrev">expand_abbrev</a>()</code>,
<code><a href="#topic+expand_state">expand_state</a>()</code>,
<code><a href="#topic+fetch_city">fetch_city</a>()</code>,
<code><a href="#topic+normal_address">normal_address</a>()</code>,
<code><a href="#topic+normal_city">normal_city</a>()</code>,
<code><a href="#topic+normal_state">normal_state</a>()</code>,
<code><a href="#topic+normal_zip">normal_zip</a>()</code>,
<code><a href="#topic+str_normal">str_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>abbrev_state(full = state.name)
abbrev_state(full = c("new mexico", "france"))
</code></pre>

<hr>
<h2 id='add_prop'>Add proportions</h2><span id='topic+add_prop'></span>

<h3>Description</h3>

<p>Use <code><a href="base.html#topic+prop.table">prop.table()</a></code> to add a proportion column to a <code><a href="dplyr.html#topic+count">dplyr::count()</a></code> tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_prop(.data, n, sum = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_prop_+3A_.data">.data</code></td>
<td>
<p>A data frame with a count column.</p>
</td></tr>
<tr><td><code id="add_prop_+3A_n">n</code></td>
<td>
<p>The column name with a count, usually <code>n</code> from <code><a href="dplyr.html#topic+count">dplyr::count()</a></code>.</p>
</td></tr>
<tr><td><code id="add_prop_+3A_sum">sum</code></td>
<td>
<p>Should <code><a href="base.html#topic+cumsum">cumsum()</a></code> be called on the new <code>p</code> column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mean(x %in% y)</code>
</p>


<h3>Value</h3>

<p>A data frame with the new column <code>p</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_prop(dplyr::count(ggplot2::diamonds, cut))
</code></pre>

<hr>
<h2 id='all_files_new'>Check if all files in a directory are new</h2><span id='topic+all_files_new'></span>

<h3>Description</h3>

<p>Tests whether all the files in a given directory have a modification date
equal to the system date. Useful when repeatedly running code with a lengthy
download stage. Many state databases are updated daily, so new data can be
helpful but not always necessary. Set this function in an <code>if</code> statement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_files_new(path, glob = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_files_new_+3A_path">path</code></td>
<td>
<p>The path to a directory to check.</p>
</td></tr>
<tr><td><code id="all_files_new_+3A_glob">glob</code></td>
<td>
<p>A pattern to search for files (e.g., &quot;*.csv&quot;).</p>
</td></tr>
<tr><td><code id="all_files_new_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="fs.html#topic+dir_ls">fs::dir_ls()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical; Whether <code><a href="base.html#topic+all">all()</a></code> files in the directory have a modification
date equal to today.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempdir()
file.create(tempfile(pattern = as.character(1:5)))
all_files_new(tmp)
</code></pre>

<hr>
<h2 id='campfin-package'><code>campfin</code> package</h2><span id='topic+campfin'></span><span id='topic+campfin-package'></span>

<h3>Description</h3>

<p>The campfin package was written to facilitate the work done on The
Accountability Project (TAP) by the data journalists at The Investigative
Reporting Workshop in Washington, DC.
</p>


<h3>Details</h3>

<p>TAP is an effort to centralize many public databases into a searchable
website. To improve the searchability of the database, the campfin package
is used to normalize values in a common format. The normalization vignette
provides examples on how this process improved a database.
</p>
<p>The other functions in this package are written to facilitate the exploration
of a database. The Investigative Reporting Workshop writes public data
diaries to document the data wrangling process; the open source campfin
functions help download, import, explore, and wrangle public database.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kiernan Nicholls <a href="mailto:kiernann@protonmail.com">kiernann@protonmail.com</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Yanqi Xu <a href="mailto:yanqixu@outlook.com">yanqixu@outlook.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Investigative Reporting Workshop [copyright holder]
</p>
</li>
<li><p> Schuyler Erle <a href="mailto:schuyler@geocoder.us">schuyler@geocoder.us</a> [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/irworkshop/campfin">https://github.com/irworkshop/campfin</a>
</p>
</li>
<li> <p><a href="https://irworkshop.github.io/campfin/">https://irworkshop.github.io/campfin/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/irworkshop/campfin/issues">https://github.com/irworkshop/campfin/issues</a>
</p>
</li></ul>


<hr>
<h2 id='check_city'>Check whether an input is a valid place with Google Maps API</h2><span id='topic+check_city'></span>

<h3>Description</h3>

<p>Check whether a place is a valid place or misspelling by matching against the
Google Geocoding search result. Use the <code><a href="httr.html#topic+GET">httr::GET()</a></code> to send a request to
the Google Maps API for geocoding information. The query will concatenate all
the geographical information that is passed in into a long string. Then the
function pulls the <code>formatted_address</code> endpoint of the API results and then
identifies and extracts the long name field from the API <em>locality</em> result
and compare it against the input to see if the input and output match up.
Note that you will need to pass in your Google Maps Place API key to the
<code>key</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_city(city = NULL, state = NULL, zip = NULL, key = NULL, guess = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_city_+3A_city">city</code></td>
<td>
<p>A string of city name to be submitted to the Geocode API.</p>
</td></tr>
<tr><td><code id="check_city_+3A_state">state</code></td>
<td>
<p>Optional. The state associated with the <code>city</code>.</p>
</td></tr>
<tr><td><code id="check_city_+3A_zip">zip</code></td>
<td>
<p>Optional. Supply a string of ZIP code to increase precision.</p>
</td></tr>
<tr><td><code id="check_city_+3A_key">key</code></td>
<td>
<p>A character string to be passed into <code>key</code>. Save your key as
&quot;GEOCODE_KEY&quot; using <code>Sys.setenv()</code> or by editing your <code>.Renviron</code> file.</p>
</td></tr>
<tr><td><code id="check_city_+3A_guess">guess</code></td>
<td>
<p>logical; Should the function return a single row tibble
containing the original data sent and the multiple components returned by
the Geocode API.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value by default. If the city returned by the API
comes back the same as the city input, the function will evaluate to
<code>TRUE</code>, in all other circumstances (including API errors) <code>FALSE</code> is returned.
</p>
<p>If the the <code>guess</code> argument is set to <code>TRUE</code>, a tibble with 1 row and six
columns is returned:
</p>

<ul>
<li> <p><code>original_city</code>: The <code>city</code> value sent to the API.
</p>
</li>
<li> <p><code>original_state</code>: The <code>state</code> value sent to the API.
</p>
</li>
<li> <p><code>original_zip</code>: The <code>zip</code> value sent to the API.
</p>
</li>
<li> <p><code>check_city_flag</code>: logical; whether the guessed city matches.
</p>
</li>
<li> <p><code>guess_city</code>: The legal city guessed by the API.
</p>
</li>
<li> <p><code>guess_place</code>: The generic locality guessed by the API.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="https://developers.google.com/maps/documentation/geocoding/overview?csw=1">https://developers.google.com/maps/documentation/geocoding/overview?csw=1</a>
</p>
<p>Other geographic normalization functions: 
<code><a href="#topic+abbrev_full">abbrev_full</a>()</code>,
<code><a href="#topic+abbrev_state">abbrev_state</a>()</code>,
<code><a href="#topic+expand_abbrev">expand_abbrev</a>()</code>,
<code><a href="#topic+expand_state">expand_state</a>()</code>,
<code><a href="#topic+fetch_city">fetch_city</a>()</code>,
<code><a href="#topic+normal_address">normal_address</a>()</code>,
<code><a href="#topic+normal_city">normal_city</a>()</code>,
<code><a href="#topic+normal_state">normal_state</a>()</code>,
<code><a href="#topic+normal_zip">normal_zip</a>()</code>,
<code><a href="#topic+str_normal">str_normal</a>()</code>
</p>

<hr>
<h2 id='col_date_mdy'>Parse USA date columns in readr functions</h2><span id='topic+col_date_mdy'></span><span id='topic+col_date_usa'></span>

<h3>Description</h3>

<p>Parse dates with format MM/DD/YYYY. This function simply wraps around
<code><a href="readr.html#topic+parse_datetime">readr::col_date()</a></code> with the <code>format</code> argument set to <code>"%m/%d/%Y"</code>. Many US
campaign finance datasets use this format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_date_mdy()

col_date_usa()
</code></pre>


<h3>Value</h3>

<p>A <code>POSIXct</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>readr::read_csv(file = "x\n11/09/2016", col_types = readr::cols(x = col_date_mdy()))
</code></pre>

<hr>
<h2 id='col_stats'>Apply a statistic function to all column vectors</h2><span id='topic+col_stats'></span><span id='topic+glimpse_fun'></span>

<h3>Description</h3>

<p>Apply a counting summary function like <code><a href="dplyr.html#topic+n_distinct">dplyr::n_distinct()</a></code> or <code><a href="#topic+count_na">count_na()</a></code>
to every column of a data frame and return the results along with a
<em>percentage</em> of that value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_stats(data, fun, print = TRUE)

glimpse_fun(data, fun, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_stats_+3A_data">data</code></td>
<td>
<p>A data frame to glimpse.</p>
</td></tr>
<tr><td><code id="col_stats_+3A_fun">fun</code></td>
<td>
<p>A function to map to each column.</p>
</td></tr>
<tr><td><code id="col_stats_+3A_print">print</code></td>
<td>
<p>logical; Should all columns be printed as rows?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with a row for every column with the count and proportion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col_stats(dplyr::storms, dplyr::n_distinct)
col_stats(dplyr::storms, campfin::count_na)
</code></pre>

<hr>
<h2 id='count_diff'>Count set difference</h2><span id='topic+count_diff'></span>

<h3>Description</h3>

<p>Find the length of the set of difference between <code>x</code> and <code>y</code> vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_diff(x, y, ignore.case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_diff_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
<tr><td><code id="count_diff_+3A_y">y</code></td>
<td>
<p>A vector to compare against.</p>
</td></tr>
<tr><td><code id="count_diff_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical; if <code>FALSE</code>, the pattern matching is case
sensitive and if <code>TRUE</code>, case is ignored during matching.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sum(x %out% y)</code>
</p>


<h3>Value</h3>

<p>The number of <em>unique</em> values of <code>x</code> not in <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_in">count_in</a>()</code>,
<code><a href="#topic+count_na">count_na</a>()</code>,
<code><a href="#topic+count_out">count_out</a>()</code>,
<code><a href="#topic+na_in">na_in</a>()</code>,
<code><a href="#topic+na_out">na_out</a>()</code>,
<code><a href="#topic+na_rep">na_rep</a>()</code>,
<code><a href="#topic+prop_distinct">prop_distinct</a>()</code>,
<code><a href="#topic+prop_in">prop_in</a>()</code>,
<code><a href="#topic+prop_na">prop_na</a>()</code>,
<code><a href="#topic+prop_out">prop_out</a>()</code>,
<code><a href="#topic+what_in">what_in</a>()</code>,
<code><a href="#topic+what_out">what_out</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># only unique values are checked
count_diff(c("VT", "NH", "ZZ", "ZZ", "ME"), state.abb)
</code></pre>

<hr>
<h2 id='count_in'>Count in</h2><span id='topic+count_in'></span>

<h3>Description</h3>

<p>Count the total values of <code>x</code> that are <code>%in%</code> the vector <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_in(x, y, na.rm = TRUE, ignore.case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_in_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
<tr><td><code id="count_in_+3A_y">y</code></td>
<td>
<p>A vector to compare against.</p>
</td></tr>
<tr><td><code id="count_in_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; Should <code>NA</code> be ignored?</p>
</td></tr>
<tr><td><code id="count_in_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical; if <code>FALSE</code>, the pattern matching is case
sensitive and if <code>TRUE</code>, case is ignored during matching.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sum(x %out% y)</code>
</p>


<h3>Value</h3>

<p>The sum of <code>x</code> present in <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_diff">count_diff</a>()</code>,
<code><a href="#topic+count_na">count_na</a>()</code>,
<code><a href="#topic+count_out">count_out</a>()</code>,
<code><a href="#topic+na_in">na_in</a>()</code>,
<code><a href="#topic+na_out">na_out</a>()</code>,
<code><a href="#topic+na_rep">na_rep</a>()</code>,
<code><a href="#topic+prop_distinct">prop_distinct</a>()</code>,
<code><a href="#topic+prop_in">prop_in</a>()</code>,
<code><a href="#topic+prop_na">prop_na</a>()</code>,
<code><a href="#topic+prop_out">prop_out</a>()</code>,
<code><a href="#topic+what_in">what_in</a>()</code>,
<code><a href="#topic+what_out">what_out</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>count_in(c("VT", "NH", "ZZ", "ME"), state.abb)
</code></pre>

<hr>
<h2 id='count_na'>Count missing</h2><span id='topic+count_na'></span>

<h3>Description</h3>

<p>Count the total values of <code>x</code> that are <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_na_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sum(is.na(x))</code>
</p>


<h3>Value</h3>

<p>The sum of <code>x</code> that are <code>NA</code>
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_diff">count_diff</a>()</code>,
<code><a href="#topic+count_in">count_in</a>()</code>,
<code><a href="#topic+count_out">count_out</a>()</code>,
<code><a href="#topic+na_in">na_in</a>()</code>,
<code><a href="#topic+na_out">na_out</a>()</code>,
<code><a href="#topic+na_rep">na_rep</a>()</code>,
<code><a href="#topic+prop_distinct">prop_distinct</a>()</code>,
<code><a href="#topic+prop_in">prop_in</a>()</code>,
<code><a href="#topic+prop_na">prop_na</a>()</code>,
<code><a href="#topic+prop_out">prop_out</a>()</code>,
<code><a href="#topic+what_in">what_in</a>()</code>,
<code><a href="#topic+what_out">what_out</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>count_na(c("VT", "NH", NA, "ME"))
</code></pre>

<hr>
<h2 id='count_out'>Count out</h2><span id='topic+count_out'></span>

<h3>Description</h3>

<p>Count the total values of <code>x</code> that are are <code style="white-space: pre;">&#8288;%out%&#8288;</code> of the vector <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_out(x, y, na.rm = TRUE, ignore.case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_out_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
<tr><td><code id="count_out_+3A_y">y</code></td>
<td>
<p>A vector to compare against.</p>
</td></tr>
<tr><td><code id="count_out_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; Should <code>NA</code> be ignored?</p>
</td></tr>
<tr><td><code id="count_out_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical; if <code>FALSE</code>, the pattern matching is case
sensitive and if <code>TRUE</code>, case is ignored during matching.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sum(x %out% y)</code>
</p>


<h3>Value</h3>

<p>The sum of <code>x</code> absent in <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_diff">count_diff</a>()</code>,
<code><a href="#topic+count_in">count_in</a>()</code>,
<code><a href="#topic+count_na">count_na</a>()</code>,
<code><a href="#topic+na_in">na_in</a>()</code>,
<code><a href="#topic+na_out">na_out</a>()</code>,
<code><a href="#topic+na_rep">na_rep</a>()</code>,
<code><a href="#topic+prop_distinct">prop_distinct</a>()</code>,
<code><a href="#topic+prop_in">prop_in</a>()</code>,
<code><a href="#topic+prop_na">prop_na</a>()</code>,
<code><a href="#topic+prop_out">prop_out</a>()</code>,
<code><a href="#topic+what_in">what_in</a>()</code>,
<code><a href="#topic+what_out">what_out</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>count_out(c("VT", "NH", "ZZ", "ME"), state.abb)
</code></pre>

<hr>
<h2 id='dark2'>Dark Color Palette</h2><span id='topic+dark2'></span>

<h3>Description</h3>

<p>The Dark2 brewer color palette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dark2
</code></pre>


<h3>Format</h3>

<p>A named character vector of hex color codes (length 8).
</p>

<hr>
<h2 id='expand_abbrev'>Expand Abbreviations</h2><span id='topic+expand_abbrev'></span>

<h3>Description</h3>

<p>Create or use a named vector (<code>c("abb" = "rep")</code>) and pass it to
<code><a href="stringr.html#topic+str_replace">stringr::str_replace_all()</a></code>. The <code>abb</code> argument is surrounded with <code style="white-space: pre;">&#8288;\\b&#8288;</code>
to capture only isolated abbreviations. To be used inside
<code><a href="#topic+normal_address">normal_address()</a></code> and <code><a href="#topic+normal_city">normal_city()</a></code> with <a href="#topic+usps_street">usps_street</a> and <a href="#topic+usps_city">usps_city</a>,
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_abbrev(x, abb = NULL, rep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_abbrev_+3A_x">x</code></td>
<td>
<p>A vector containing abbreviations.</p>
</td></tr>
<tr><td><code id="expand_abbrev_+3A_abb">abb</code></td>
<td>
<p>One of three objects: (1) A dataframe with abbreviations in the
<em>first</em> column and corresponding replacement strings in the <em>second</em>
column; (2) a <em>named</em> vector, with abbreviations as names for their
respective replacements (e.g., <code>c("abb" = "rep")</code>); or (3) an unnamed
vector of abbreviations with an unnamed vector of replacements in the <code>rep</code>
argument.</p>
</td></tr>
<tr><td><code id="expand_abbrev_+3A_rep">rep</code></td>
<td>
<p>If <code>abb</code> is an unnamed vector, a vector of replacement strings for
each abbreviation in <code>abb</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector <code>x</code> with abbreviation replaced with their full version.
</p>


<h3>See Also</h3>

<p>Other geographic normalization functions: 
<code><a href="#topic+abbrev_full">abbrev_full</a>()</code>,
<code><a href="#topic+abbrev_state">abbrev_state</a>()</code>,
<code><a href="#topic+check_city">check_city</a>()</code>,
<code><a href="#topic+expand_state">expand_state</a>()</code>,
<code><a href="#topic+fetch_city">fetch_city</a>()</code>,
<code><a href="#topic+normal_address">normal_address</a>()</code>,
<code><a href="#topic+normal_city">normal_city</a>()</code>,
<code><a href="#topic+normal_state">normal_state</a>()</code>,
<code><a href="#topic+normal_zip">normal_zip</a>()</code>,
<code><a href="#topic+str_normal">str_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expand_abbrev(x = "MT VERNON", abb = c("MT" = "MOUNT"))
expand_abbrev(x = "VT", abb = state.abb, rep = state.name)
expand_abbrev(x = "Low FE Level", abb = tibble::tibble(x = "FE", y = "Iron"))
</code></pre>

<hr>
<h2 id='expand_state'>Expand US state names</h2><span id='topic+expand_state'></span>

<h3>Description</h3>

<p>This function is used to first normalize an <code>abb</code> and then call
<code><a href="#topic+expand_abbrev">expand_abbrev()</a></code> using <a href="#topic+valid_state">valid_state</a> and <a href="#topic+valid_name">valid_name</a> as the <code>abb</code> and <code>rep</code>
arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_state(abb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_state_+3A_abb">abb</code></td>
<td>
<p>A abb US state name character vector (e.g., &quot;Vermont&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The 2-letter USPS abbreviation of for state names (e.g., &quot;VT&quot;).
</p>


<h3>See Also</h3>

<p>Other geographic normalization functions: 
<code><a href="#topic+abbrev_full">abbrev_full</a>()</code>,
<code><a href="#topic+abbrev_state">abbrev_state</a>()</code>,
<code><a href="#topic+check_city">check_city</a>()</code>,
<code><a href="#topic+expand_abbrev">expand_abbrev</a>()</code>,
<code><a href="#topic+fetch_city">fetch_city</a>()</code>,
<code><a href="#topic+normal_address">normal_address</a>()</code>,
<code><a href="#topic+normal_city">normal_city</a>()</code>,
<code><a href="#topic+normal_state">normal_state</a>()</code>,
<code><a href="#topic+normal_zip">normal_zip</a>()</code>,
<code><a href="#topic+str_normal">str_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expand_state(abb = state.abb)
expand_state(abb = c("nm", "fr"))
</code></pre>

<hr>
<h2 id='explore_plot'>Create Basic Barplots</h2><span id='topic+explore_plot'></span>

<h3>Description</h3>

<p>This function simply wraps around <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_col()</a></code> to take a dataframe
and categorical variable to return a custom barplot <code>ggplot</code> object. The bars
are arranged in descending order and are limited to the 8 most frequent
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explore_plot(data, var, nbar = 8, palette = "Dark2", na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explore_plot_+3A_data">data</code></td>
<td>
<p>The data frame to explore.</p>
</td></tr>
<tr><td><code id="explore_plot_+3A_var">var</code></td>
<td>
<p>A variable to plot.</p>
</td></tr>
<tr><td><code id="explore_plot_+3A_nbar">nbar</code></td>
<td>
<p>The number of bars to plot. Always shows most common values.</p>
</td></tr>
<tr><td><code id="explore_plot_+3A_palette">palette</code></td>
<td>
<p>The color palette passed to [ggplot2::scale_fill_brewer().</p>
</td></tr>
<tr><td><code id="explore_plot_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: Should <code>NA</code> values of <code>var</code> be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> barplot object. Can then be combined with other <code>ggplot</code>
layers with <code>+</code> to customize.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>explore_plot(iris, Species)
</code></pre>

<hr>
<h2 id='extra_city'>Additional US City Names</h2><span id='topic+extra_city'></span>

<h3>Description</h3>

<p>Cities not contained in <a href="#topic+valid_city">valid_city</a>, but are
accepted localities (neighborhoods or census designated
places). This vector consists of normalized self-reported cities in the
public data processed by accountability project that were validated
by Google Maps Geocoding API (whose <code><a href="#topic+check_city">check_city()</a></code> results evaluate to <code>TRUE</code>).
The most recent updated version of the extra_city can be found in
<a href="https://docs.google.com/spreadsheets/d/17pi8LW1nTaGzThfUmQMZ_6HMWPxUPatqrTEWzY6LPoI">this Google Sheet</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extra_city
</code></pre>


<h3>Format</h3>

<p>A sorted vector of unique locality names (length 127).
</p>

<hr>
<h2 id='fetch_city'>Return Closest Match Result of Cities from Google Maps API</h2><span id='topic+fetch_city'></span>

<h3>Description</h3>

<p>Use the <code><a href="httr.html#topic+GET">httr::GET()</a></code> to send a request to the Google Maps API for geocoding
information. The query will concatenate all the geographical information that
is passed in into a single string. Then the function pulls the
<code>formatted_address</code> endpoint of the API results and extracts the the first
field of the result. Note that you will need to pass in your Google Maps
Place API key with the <code>key</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_city(address = NULL, key = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetch_city_+3A_address">address</code></td>
<td>
<p>A vector of street addresses. Sent to the API as one string.</p>
</td></tr>
<tr><td><code id="fetch_city_+3A_key">key</code></td>
<td>
<p>A character containing your alphanumeric Google Maps API key.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of formatted address endpoints from Google. This
will include all the fields from street address, city, state/province,
zipcode/postal code to country/regions. <code>NA_character_</code> is returned for
all errored API calls.
</p>


<h3>See Also</h3>

<p><a href="https://developers.google.com/maps/documentation/geocoding/overview?csw=1">https://developers.google.com/maps/documentation/geocoding/overview?csw=1</a>
</p>
<p>Other geographic normalization functions: 
<code><a href="#topic+abbrev_full">abbrev_full</a>()</code>,
<code><a href="#topic+abbrev_state">abbrev_state</a>()</code>,
<code><a href="#topic+check_city">check_city</a>()</code>,
<code><a href="#topic+expand_abbrev">expand_abbrev</a>()</code>,
<code><a href="#topic+expand_state">expand_state</a>()</code>,
<code><a href="#topic+normal_address">normal_address</a>()</code>,
<code><a href="#topic+normal_city">normal_city</a>()</code>,
<code><a href="#topic+normal_state">normal_state</a>()</code>,
<code><a href="#topic+normal_zip">normal_zip</a>()</code>,
<code><a href="#topic+str_normal">str_normal</a>()</code>
</p>

<hr>
<h2 id='file_age'>File modification date age</h2><span id='topic+file_age'></span>

<h3>Description</h3>

<p>The period of time since a system file was modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_age(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_age_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+file.info">file.info()</a></code>, namely character vectors
containing file paths. Tilde-expansion is done: see <code><a href="base.html#topic+path.expand">path.expand()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Period class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file_age(system.file("README.md", package = "campfin"))
</code></pre>

<hr>
<h2 id='file_encoding'>File Encoding</h2><span id='topic+file_encoding'></span>

<h3>Description</h3>

<p>Call the <code>file</code> command line tool with option <code>-i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_encoding(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_encoding_+3A_path">path</code></td>
<td>
<p>A local file path or glob to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of file encoding.
</p>

<hr>
<h2 id='flag_dupes'>Flag Duplicate Rows With New Column</h2><span id='topic+flag_dupes'></span>

<h3>Description</h3>

<p>This function uses <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> to create a new <code>dupe_flag</code> logical
variable with <code>TRUE</code> values for any record duplicated more than once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_dupes(data, ..., .check = TRUE, .both = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flag_dupes_+3A_data">data</code></td>
<td>
<p>A data frame to flag.</p>
</td></tr>
<tr><td><code id="flag_dupes_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> (needs to be at least
<code><a href="dplyr.html#topic+reexports">dplyr::everything()</a></code>).</p>
</td></tr>
<tr><td><code id="flag_dupes_+3A_.check">.check</code></td>
<td>
<p>Whether the resulting column should be summed and
removed if empty.</p>
</td></tr>
<tr><td><code id="flag_dupes_+3A_.both">.both</code></td>
<td>
<p>Whether to flag both duplicates or just subsequent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a new <code>dupe_flag</code> logical variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flag_dupes(iris, dplyr::everything())
flag_dupes(iris, dplyr::everything(), .both = FALSE)
</code></pre>

<hr>
<h2 id='flag_na'>Flag Missing Values With New Column</h2><span id='topic+flag_na'></span>

<h3>Description</h3>

<p>This function uses <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> to create a new <code>na_flag</code> logical
variable with <code>TRUE</code> values for any record missing <em>any</em> value in the
selected columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_na(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flag_na_+3A_data">data</code></td>
<td>
<p>A data frame to flag.</p>
</td></tr>
<tr><td><code id="flag_na_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> (needs to be at least
<code><a href="dplyr.html#topic+reexports">dplyr::everything()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a new <code>na_flag</code> logical variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flag_na(dplyr::starwars, hair_color)
</code></pre>

<hr>
<h2 id='flush_memory'>Flush Garbage Memory</h2><span id='topic+flush_memory'></span>

<h3>Description</h3>

<p>Run a full <code><a href="base.html#topic+gc">gc()</a></code> a number of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flush_memory(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flush_memory_+3A_n">n</code></td>
<td>
<p>The number of times to run <code><a href="base.html#topic+gc">gc()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='guess_delim'>Guess the delimiter of a text file</h2><span id='topic+guess_delim'></span>

<h3>Description</h3>

<p>Taken from code used in <a href="https://github.com/tidyverse/vroom/blob/85143f7a417376eaf0e2037ca9575f637e4346c2/R/vroom.R#L288">vroom::vroom()</a> with automatic reading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_delim(file, delims = c(",", "\t", "|", ";"), string = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_delim_+3A_file">file</code></td>
<td>
<p>Either a path to a file or character string (with at least one
newline character).</p>
</td></tr>
<tr><td><code id="guess_delim_+3A_delims">delims</code></td>
<td>
<p>The vector of single characters to guess from. Defaults to:
comma, tab, pipe, or semicolon.</p>
</td></tr>
<tr><td><code id="guess_delim_+3A_string">string</code></td>
<td>
<p>Should the file be treated as a string regardless of newline.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The single character guessed as a delimiter.
</p>


<h3>Source</h3>

<p><a href="https://github.com/tidyverse/vroom/blob/85143f7a417376eaf0e2037ca9575f637e4346c2/R/vroom.R#L288">https://github.com/tidyverse/vroom/blob/85143f7a417376eaf0e2037ca9575f637e4346c2/R/vroom.R#L288</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>guess_delim(system.file("extdata", "vt_contribs.csv", package = "campfin"))
guess_delim("ID;FirstName;MI;LastName;JobTitle", string = TRUE)
guess_delim("
a|b|c
1|2|3
")
</code></pre>

<hr>
<h2 id='invalid_city'>Invalid City Names</h2><span id='topic+invalid_city'></span>

<h3>Description</h3>

<p>A custom vector containing common invalid city names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invalid_city
</code></pre>


<h3>Format</h3>

<p>A vector of length 54.
</p>

<hr>
<h2 id='invert_named'>Invert a named vector</h2><span id='topic+invert_named'></span>

<h3>Description</h3>

<p>Invert the names and elements of a vector, useful when using named vectors as
the abbreviation arguments both of <code><a href="#topic+expand_abbrev">expand_abbrev()</a></code> and <code><a href="#topic+abbrev_full">abbrev_full()</a></code> (or
their parent normalization functions like <code><a href="#topic+normal_address">normal_address()</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_named(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_named_+3A_x">x</code></td>
<td>
<p>A named vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with names in place of elements and <em>vice versa</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>invert_named(x = c("name" = "element"))
</code></pre>

<hr>
<h2 id='is_abbrev'>Check if abbreviation</h2><span id='topic+is_abbrev'></span>

<h3>Description</h3>

<p>To return a value of <code>TRUE</code>, (1) the first letter of <code>abb</code> must match the
first letter of <code>full</code>, (2) <em>all</em> letters of <code>abb</code> must exist in <code>full</code>, and
(3) those letters of <code>abb</code> must be in the same order as they appear in
<code>full</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_abbrev(abb, full)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_abbrev_+3A_abb">abb</code></td>
<td>
<p>A suspected abbreviation</p>
</td></tr>
<tr><td><code id="is_abbrev_+3A_full">full</code></td>
<td>
<p>A long form string to test against</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical; whether <code>abb</code> is potential abbreviation of <code>full</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_abbrev(abb = "BRX", full = "BRONX")
is_abbrev(abb = state.abb, full = state.name)
is_abbrev(abb = "NOLA", full = "New Orleans")
is_abbrev(abb = "FE", full = "Iron")
</code></pre>

<hr>
<h2 id='is_binary'>Check if Binary</h2><span id='topic+is_binary'></span>

<h3>Description</h3>

<p>Uses <code><a href="dplyr.html#topic+n_distinct">dplyr::n_distinct()</a></code> to check if there are only two unique values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_binary(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_binary_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="is_binary_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; Should NA be ignored, <code>TRUE</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if only 2 unique values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (is_binary(x &lt;- c("Yes", "No"))) x == "Yes"
</code></pre>

<hr>
<h2 id='is_even'>Check if even</h2><span id='topic+is_even'></span>

<h3>Description</h3>

<p>Check if even
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_even(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_even_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical; Whether the integer is even or odd.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_even(1:10)
is_even(10L)
</code></pre>

<hr>
<h2 id='keypad_convert'>Convert letters or numbers to their keypad counterpart</h2><span id='topic+keypad_convert'></span>

<h3>Description</h3>

<p>This function works best when converting numbers to letters, as each number
only has a single possible letter. For each letter, there are 3 or 4 possible
letters, resulting in a number of possible conversions. This function was
intended to convert phonetic telephone numbers to their valid numeric
equivalent; when used in this manner, each letter in a string can be lazily
replaced without changing the rest of the string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keypad_convert(x, ext = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keypad_convert_+3A_x">x</code></td>
<td>
<p>A vector of characters or letters.</p>
</td></tr>
<tr><td><code id="keypad_convert_+3A_ext">ext</code></td>
<td>
<p>logical; Should extension text be converted to numbers. Defaults to
<code>FALSE</code> and matches x, ext, and extension followed by a space or number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When replacing letters, this function relies on the feature of
<code><a href="stringr.html#topic+str_replace">stringr::str_replace_all()</a></code> to work with named vectors (<code>c("A" = "2")</code>).
</p>


<h3>Value</h3>

<p>If a character vector is supplied, a vector of each elements numeric
counterpart is returned. If a numeric vector (or a completely coercible
character vector) is supplied, then a <strong>list</strong> is returned, each element of
which contacts a vector of letters for each number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>keypad_convert("1-800-CASH-NOW ext123")
keypad_convert(c("abc", "123"))
keypad_convert(letters)
</code></pre>

<hr>
<h2 id='most_common'>Find most common values</h2><span id='topic+most_common'></span>

<h3>Description</h3>

<p>From a character vector, which values are most common?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>most_common(x, n = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="most_common_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="most_common_+3A_n">n</code></td>
<td>
<p>Number of values to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sorted vector of <code>n</code> most common values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>most_common(iris$Species, n = 1)
</code></pre>

<hr>
<h2 id='na_in'>Remove in</h2><span id='topic+na_in'></span>

<h3>Description</h3>

<p>Set <code>NA</code> for the values of <code>x</code> that are <code>%in%</code> the vector <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_in(x, y, ignore.case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_in_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
<tr><td><code id="na_in_+3A_y">y</code></td>
<td>
<p>A vector to compare against.</p>
</td></tr>
<tr><td><code id="na_in_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical; if <code>FALSE</code>, the pattern matching is case
sensitive and if <code>TRUE</code>, case is ignored during matching.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector <code>x</code> missing any values in <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_diff">count_diff</a>()</code>,
<code><a href="#topic+count_in">count_in</a>()</code>,
<code><a href="#topic+count_na">count_na</a>()</code>,
<code><a href="#topic+count_out">count_out</a>()</code>,
<code><a href="#topic+na_out">na_out</a>()</code>,
<code><a href="#topic+na_rep">na_rep</a>()</code>,
<code><a href="#topic+prop_distinct">prop_distinct</a>()</code>,
<code><a href="#topic+prop_in">prop_in</a>()</code>,
<code><a href="#topic+prop_na">prop_na</a>()</code>,
<code><a href="#topic+prop_out">prop_out</a>()</code>,
<code><a href="#topic+what_in">what_in</a>()</code>,
<code><a href="#topic+what_out">what_out</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na_in(c("VT", "NH", "ZZ", "ME"), state.abb)
na_in(1:10, seq(1, 10, 2))
</code></pre>

<hr>
<h2 id='na_out'>Remove out</h2><span id='topic+na_out'></span>

<h3>Description</h3>

<p>Set <code>NA</code> for the values of <code>x</code> that are <code style="white-space: pre;">&#8288;%out%&#8288;</code> of the vector <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_out(x, y, ignore.case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_out_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
<tr><td><code id="na_out_+3A_y">y</code></td>
<td>
<p>A vector to compare against.</p>
</td></tr>
<tr><td><code id="na_out_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical; if <code>FALSE</code>, the pattern matching is case
sensitive and if <code>TRUE</code>, case is ignored during matching.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector <code>x</code> missing any values not in <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_diff">count_diff</a>()</code>,
<code><a href="#topic+count_in">count_in</a>()</code>,
<code><a href="#topic+count_na">count_na</a>()</code>,
<code><a href="#topic+count_out">count_out</a>()</code>,
<code><a href="#topic+na_in">na_in</a>()</code>,
<code><a href="#topic+na_rep">na_rep</a>()</code>,
<code><a href="#topic+prop_distinct">prop_distinct</a>()</code>,
<code><a href="#topic+prop_in">prop_in</a>()</code>,
<code><a href="#topic+prop_na">prop_na</a>()</code>,
<code><a href="#topic+prop_out">prop_out</a>()</code>,
<code><a href="#topic+what_in">what_in</a>()</code>,
<code><a href="#topic+what_out">what_out</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na_out(c("VT", "NH", "ZZ", "ME"), state.abb)
na_out(1:10, seq(1, 10, 2))
</code></pre>

<hr>
<h2 id='na_rep'>Remove repeated character elements</h2><span id='topic+na_rep'></span>

<h3>Description</h3>

<p>Set <code>NA</code> for the values of <code>x</code> that contain a single repeating character and
no other characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_rep(x, n = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_rep_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
<tr><td><code id="na_rep_+3A_n">n</code></td>
<td>
<p>The minimum number times a character must repeat. If 0, the default,
then any string of one character will be replaced with <code>NA</code>. If greater
than 0, the string must contain greater than <code>n</code> number of repetitions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the regular expression <code>"^(.)\\1+$"</code>.
</p>


<h3>Value</h3>

<p>The vector <code>x</code> with <code>NA</code> replacing repeating character values.
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_diff">count_diff</a>()</code>,
<code><a href="#topic+count_in">count_in</a>()</code>,
<code><a href="#topic+count_na">count_na</a>()</code>,
<code><a href="#topic+count_out">count_out</a>()</code>,
<code><a href="#topic+na_in">na_in</a>()</code>,
<code><a href="#topic+na_out">na_out</a>()</code>,
<code><a href="#topic+prop_distinct">prop_distinct</a>()</code>,
<code><a href="#topic+prop_in">prop_in</a>()</code>,
<code><a href="#topic+prop_na">prop_na</a>()</code>,
<code><a href="#topic+prop_out">prop_out</a>()</code>,
<code><a href="#topic+what_in">what_in</a>()</code>,
<code><a href="#topic+what_out">what_out</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na_rep(c("VT", "NH", "ZZ", "ME"))
</code></pre>

<hr>
<h2 id='non_ascii'>Show non-ASCII lines of file</h2><span id='topic+non_ascii'></span>

<h3>Description</h3>

<p>Show non-ASCII lines of file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>non_ascii(path, highlight = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="non_ascii_+3A_path">path</code></td>
<td>
<p>The path to a text file to check.</p>
</td></tr>
<tr><td><code id="non_ascii_+3A_highlight">highlight</code></td>
<td>
<p>A function used to add ANSI escapes to highlight bytes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of line locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>non_ascii(system.file("README.md", package = "campfin"))
</code></pre>

<hr>
<h2 id='normal_address'>Normalize street addresses</h2><span id='topic+normal_address'></span>

<h3>Description</h3>

<p>Return consistent version of a US Street Address using <code style="white-space: pre;">&#8288;stringr::str_*()&#8288;</code>
functions. Letters are capitalized, punctuation is removed or replaced, and
excess whitespace is trimmed and squished. Optionally, street suffix
abbreviations (&quot;AVE&quot;) can be replaced with their long form (&quot;AVENUE&quot;).
Invalid addresses from a vector can be removed (possibly using
<a href="#topic+invalid_city">invalid_city</a>) as well as single (repeating) character strings (&quot;XXXXXX&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_address(
  address,
  abbs = NULL,
  na = c("", "NA"),
  punct = "",
  na_rep = FALSE,
  abb_end = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_address_+3A_address">address</code></td>
<td>
<p>A vector of street addresses (ideally without city, state, or
postal code).</p>
</td></tr>
<tr><td><code id="normal_address_+3A_abbs">abbs</code></td>
<td>
<p>A named vector or two-column data frame (like <a href="#topic+usps_street">usps_street</a>)
passed to <code><a href="#topic+expand_abbrev">expand_abbrev()</a></code>. See <code>?expand_abbrev</code> for the type of object
structure needed.</p>
</td></tr>
<tr><td><code id="normal_address_+3A_na">na</code></td>
<td>
<p>A character vector of values to make <code>NA</code> (like <a href="#topic+invalid_city">invalid_city</a>).</p>
</td></tr>
<tr><td><code id="normal_address_+3A_punct">punct</code></td>
<td>
<p>A character value with which to replace all punctuation.</p>
</td></tr>
<tr><td><code id="normal_address_+3A_na_rep">na_rep</code></td>
<td>
<p>logical; If <code>TRUE</code>, replace all single digit (repeating)
strings with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="normal_address_+3A_abb_end">abb_end</code></td>
<td>
<p>logical; Should only the last word the string be abbreviated
with the <code>abbs</code> argument? Passed to the <code>end</code> argument of <code><a href="#topic+str_normal">str_normal()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of normalized street addresses.
</p>


<h3>See Also</h3>

<p>Other geographic normalization functions: 
<code><a href="#topic+abbrev_full">abbrev_full</a>()</code>,
<code><a href="#topic+abbrev_state">abbrev_state</a>()</code>,
<code><a href="#topic+check_city">check_city</a>()</code>,
<code><a href="#topic+expand_abbrev">expand_abbrev</a>()</code>,
<code><a href="#topic+expand_state">expand_state</a>()</code>,
<code><a href="#topic+fetch_city">fetch_city</a>()</code>,
<code><a href="#topic+normal_city">normal_city</a>()</code>,
<code><a href="#topic+normal_state">normal_state</a>()</code>,
<code><a href="#topic+normal_zip">normal_zip</a>()</code>,
<code><a href="#topic+str_normal">str_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normal_address("P.O. #123, C/O John Smith", abbs = usps_street)
normal_address("12east 2nd street, #209", abbs = usps_street, abb_end = FALSE)
</code></pre>

<hr>
<h2 id='normal_city'>Normalize city names</h2><span id='topic+normal_city'></span>

<h3>Description</h3>

<p>Return consistent version of a city names using <code style="white-space: pre;">&#8288;stringr::str_*()&#8288;</code> functions.
Letters are capitalized, hyphens and underscores are replaced with
whitespace, other punctuation is removed, numbers are removed, and excess
whitespace is trimmed and squished. Optionally, geographic abbreviations
(&quot;MT&quot;) can be replaced with their long form (&quot;MOUNT&quot;). Invalid addresses from
a vector can be removed (possibly using <a href="#topic+invalid_city">invalid_city</a>) as well as single
(repeating) character strings (&quot;XXXXXX&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_city(city, abbs = NULL, states = NULL, na = c("", "NA"), na_rep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_city_+3A_city">city</code></td>
<td>
<p>A vector of city names.</p>
</td></tr>
<tr><td><code id="normal_city_+3A_abbs">abbs</code></td>
<td>
<p>A named vector or data frame of abbreviations passed to
<a href="#topic+expand_abbrev">expand_abbrev</a>; see <a href="#topic+expand_abbrev">expand_abbrev</a> for format of <code>abb</code> argument or use
the <a href="#topic+usps_city">usps_city</a> tibble.</p>
</td></tr>
<tr><td><code id="normal_city_+3A_states">states</code></td>
<td>
<p>A vector of state abbreviations (&quot;VT&quot;) to remove from the
<em>end</em> (and only end) of city names (&quot;STOWE VT&quot;).</p>
</td></tr>
<tr><td><code id="normal_city_+3A_na">na</code></td>
<td>
<p>A vector of values to make <code>NA</code> (useful with the <a href="#topic+invalid_city">invalid_city</a>
vector).</p>
</td></tr>
<tr><td><code id="normal_city_+3A_na_rep">na_rep</code></td>
<td>
<p>logical; If <code>TRUE</code>, replace all single digit (repeating)
strings with <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of normalized city names.
</p>


<h3>See Also</h3>

<p>Other geographic normalization functions: 
<code><a href="#topic+abbrev_full">abbrev_full</a>()</code>,
<code><a href="#topic+abbrev_state">abbrev_state</a>()</code>,
<code><a href="#topic+check_city">check_city</a>()</code>,
<code><a href="#topic+expand_abbrev">expand_abbrev</a>()</code>,
<code><a href="#topic+expand_state">expand_state</a>()</code>,
<code><a href="#topic+fetch_city">fetch_city</a>()</code>,
<code><a href="#topic+normal_address">normal_address</a>()</code>,
<code><a href="#topic+normal_state">normal_state</a>()</code>,
<code><a href="#topic+normal_zip">normal_zip</a>()</code>,
<code><a href="#topic+str_normal">str_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normal_city(
  city = c("Stowe, VT", "UNKNOWN CITY", "Burlington", "ST JOHNSBURY", "XXX"),
  abbs = c("ST" = "SAINT"),
  states = "VT",
  na = invalid_city,
  na_rep = TRUE
)
</code></pre>

<hr>
<h2 id='normal_phone'>Normalize phone number</h2><span id='topic+normal_phone'></span>

<h3>Description</h3>

<p>Take US phone numbers in any number of formats and try to convert them to a
standard format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_phone(
  number,
  format = "(%a) %e-%l",
  na_bad = FALSE,
  convert = FALSE,
  rm_ext = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_phone_+3A_number">number</code></td>
<td>
<p>A vector of phone number in any format.</p>
</td></tr>
<tr><td><code id="normal_phone_+3A_format">format</code></td>
<td>
<p>The desired output format, with <code style="white-space: pre;">&#8288;%a&#8288;</code> representing the 3-digit
<strong>area</strong> code, <code style="white-space: pre;">&#8288;%e&#8288;</code> representing the 3-digit <strong>exchange</strong>, and <code style="white-space: pre;">&#8288;%l&#8288;</code>
representing the 4-digit <strong>line</strong> number. The punctuation between each part
of the format is used in the normalized number (e.g., <code>"(%a) %e-%l"</code> or
<code>"%a-%e-%l"</code>).</p>
</td></tr>
<tr><td><code id="normal_phone_+3A_na_bad">na_bad</code></td>
<td>
<p>logical; Should invalid numbers be replaced with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="normal_phone_+3A_convert">convert</code></td>
<td>
<p>logical; Should <code><a href="#topic+keypad_convert">keypad_convert()</a></code> be invoked to replace
numbers with their keypad equivalent.</p>
</td></tr>
<tr><td><code id="normal_phone_+3A_rm_ext">rm_ext</code></td>
<td>
<p>logical; Should extensions be removed from the end of a number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A normalized telephone number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normal_phone(number = c("916-225-5887"))
</code></pre>

<hr>
<h2 id='normal_state'>Normalize US State Abbreviations</h2><span id='topic+normal_state'></span>

<h3>Description</h3>

<p>Return consistent version of a state <em>abbreviations</em> using <code style="white-space: pre;">&#8288;stringr::str_*()&#8288;</code>
functions. Letters are capitalized, all non-letters characters are removed,
and excess whitespace is trimmed and squished, and then <code><a href="#topic+abbrev_full">abbrev_full()</a></code> is
called with <a href="#topic+usps_state">usps_state</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_state(
  state,
  abbreviate = TRUE,
  na = c("", "NA"),
  na_rep = FALSE,
  valid = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_state_+3A_state">state</code></td>
<td>
<p>A vector of US state names or abbreviations.</p>
</td></tr>
<tr><td><code id="normal_state_+3A_abbreviate">abbreviate</code></td>
<td>
<p>If TRUE (default), replace state names with the 2-digit
abbreviation using the built-in <code>state.abb</code> and <code>state.name</code> vectors.</p>
</td></tr>
<tr><td><code id="normal_state_+3A_na">na</code></td>
<td>
<p>A vector of values to make <code>NA</code>.</p>
</td></tr>
<tr><td><code id="normal_state_+3A_na_rep">na_rep</code></td>
<td>
<p>logical; If <code>TRUE</code>, make all single digit repeating strings
<code>NA</code> (removes valid &quot;AA&quot; code for &quot;American Armed Forces&quot;).</p>
</td></tr>
<tr><td><code id="normal_state_+3A_valid">valid</code></td>
<td>
<p>A vector of valid abbreviations to compare to and remove those
not shared.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of normalized 2-digit state abbreviations.
</p>


<h3>See Also</h3>

<p>Other geographic normalization functions: 
<code><a href="#topic+abbrev_full">abbrev_full</a>()</code>,
<code><a href="#topic+abbrev_state">abbrev_state</a>()</code>,
<code><a href="#topic+check_city">check_city</a>()</code>,
<code><a href="#topic+expand_abbrev">expand_abbrev</a>()</code>,
<code><a href="#topic+expand_state">expand_state</a>()</code>,
<code><a href="#topic+fetch_city">fetch_city</a>()</code>,
<code><a href="#topic+normal_address">normal_address</a>()</code>,
<code><a href="#topic+normal_city">normal_city</a>()</code>,
<code><a href="#topic+normal_zip">normal_zip</a>()</code>,
<code><a href="#topic+str_normal">str_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normal_state(
  state = c("VT", "N/A", "Vermont", "XX", "ZA"),
  abbreviate = TRUE,
  na = c("", "NA"),
  na_rep = TRUE,
  valid = NULL
)
</code></pre>

<hr>
<h2 id='normal_zip'>Normalize ZIP codes</h2><span id='topic+normal_zip'></span>

<h3>Description</h3>

<p>Return consistent version US ZIP codes using <code style="white-space: pre;">&#8288;stringr::str_*()&#8288;</code> functions.
Non-number characters are removed, strings are padded with zeroes on the
left, and ZIP+4 suffixes are removed. Invalid ZIP codes from a vector can be
removed as well as single (repeating) character strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_zip(zip, na = c("", "NA"), na_rep = FALSE, pad = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_zip_+3A_zip">zip</code></td>
<td>
<p>A vector of US ZIP codes.</p>
</td></tr>
<tr><td><code id="normal_zip_+3A_na">na</code></td>
<td>
<p>A vector of values to pass to <code><a href="#topic+na_in">na_in()</a></code>.</p>
</td></tr>
<tr><td><code id="normal_zip_+3A_na_rep">na_rep</code></td>
<td>
<p>logical; If <code>TRUE</code>, <code><a href="#topic+na_rep">na_rep()</a></code> will be called. Please note that
22222, 44444, and 55555 valid ZIP codes that will <em>not</em> be removed.</p>
</td></tr>
<tr><td><code id="normal_zip_+3A_pad">pad</code></td>
<td>
<p>logical; Should ZIP codes less than five digits be padded with a
leading zero? Leading zeros (as are found in New England ZIP codes) are
often dropped by programs like Microsoft Excel when parsed as numeric
values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em>character</em> vector of normalized 5-digit ZIP codes.
</p>


<h3>See Also</h3>

<p>Other geographic normalization functions: 
<code><a href="#topic+abbrev_full">abbrev_full</a>()</code>,
<code><a href="#topic+abbrev_state">abbrev_state</a>()</code>,
<code><a href="#topic+check_city">check_city</a>()</code>,
<code><a href="#topic+expand_abbrev">expand_abbrev</a>()</code>,
<code><a href="#topic+expand_state">expand_state</a>()</code>,
<code><a href="#topic+fetch_city">fetch_city</a>()</code>,
<code><a href="#topic+normal_address">normal_address</a>()</code>,
<code><a href="#topic+normal_city">normal_city</a>()</code>,
<code><a href="#topic+normal_state">normal_state</a>()</code>,
<code><a href="#topic+str_normal">str_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normal_zip(
  zip = c("05672-5563", "N/A", "05401", "5819", "00000"),
  na = c("", "NA"),
  na_rep = TRUE,
  pad = TRUE
)
</code></pre>

<hr>
<h2 id='path.abbrev'>Abbreviate a file path</h2><span id='topic+path.abbrev'></span>

<h3>Description</h3>

<p>This is an inverse of <code><a href="base.html#topic+path.expand">path.expand()</a></code>, which replaces the home directory or
project directory with a tilde.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path.abbrev(path, dir = fs::path_wd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path.abbrev_+3A_path">path</code></td>
<td>
<p>Character vector containing one or more full paths.</p>
</td></tr>
<tr><td><code id="path.abbrev_+3A_dir">dir</code></td>
<td>
<p>The directory to replace with <code>~</code>. Defaults to <code><a href="fs.html#topic+path">fs::path_wd()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Abbreviated file paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(fs::path_wd("test"))
path.abbrev(fs::path_wd("test"))
</code></pre>

<hr>
<h2 id='progress_table'>Create a progress table</h2><span id='topic+progress_table'></span>

<h3>Description</h3>

<p>Create a tibble with rows for each stage of normalization and columns for the
various statistics most useful in assessing the progress of each stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progress_table(..., compare)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="progress_table_+3A_...">...</code></td>
<td>
<p>Any number of vectors to check.</p>
</td></tr>
<tr><td><code id="progress_table_+3A_compare">compare</code></td>
<td>
<p>A vector to compare each of <code>...</code> against. Useful
with <a href="#topic+valid_zip">valid_zip</a>, <a href="#topic+valid_state">valid_state</a> (<a href="#topic+valid_name">valid_name</a>), or
<a href="#topic+valid_city">valid_city</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with a row for each vector in <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>progress_table(state.name, toupper(state.name), compare = valid_name)
</code></pre>

<hr>
<h2 id='prop_distinct'>Proportion missing</h2><span id='topic+prop_distinct'></span>

<h3>Description</h3>

<p>Find the proportion of values of <code>x</code> that are distinct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_distinct(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_distinct_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>length(unique(x))/length(x)</code>
</p>


<h3>Value</h3>

<p>The ratio of distinct values <code>x</code> to total values of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_diff">count_diff</a>()</code>,
<code><a href="#topic+count_in">count_in</a>()</code>,
<code><a href="#topic+count_na">count_na</a>()</code>,
<code><a href="#topic+count_out">count_out</a>()</code>,
<code><a href="#topic+na_in">na_in</a>()</code>,
<code><a href="#topic+na_out">na_out</a>()</code>,
<code><a href="#topic+na_rep">na_rep</a>()</code>,
<code><a href="#topic+prop_in">prop_in</a>()</code>,
<code><a href="#topic+prop_na">prop_na</a>()</code>,
<code><a href="#topic+prop_out">prop_out</a>()</code>,
<code><a href="#topic+what_in">what_in</a>()</code>,
<code><a href="#topic+what_out">what_out</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prop_distinct(c("VT", "VT", NA, "ME"))
</code></pre>

<hr>
<h2 id='prop_in'>Proportion in</h2><span id='topic+prop_in'></span>

<h3>Description</h3>

<p>Find the proportion of values of <code>x</code> that are <code>%in%</code> the vector <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_in(x, y, na.rm = TRUE, ignore.case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_in_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
<tr><td><code id="prop_in_+3A_y">y</code></td>
<td>
<p>A vector to compare against.</p>
</td></tr>
<tr><td><code id="prop_in_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; Should <code>NA</code> be ignored?</p>
</td></tr>
<tr><td><code id="prop_in_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical; if <code>FALSE</code>, the pattern matching is case
sensitive and if <code>TRUE</code>, case is ignored during matching.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mean(x %in% y)</code>
</p>


<h3>Value</h3>

<p>The proportion of <code>x</code> present in <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_diff">count_diff</a>()</code>,
<code><a href="#topic+count_in">count_in</a>()</code>,
<code><a href="#topic+count_na">count_na</a>()</code>,
<code><a href="#topic+count_out">count_out</a>()</code>,
<code><a href="#topic+na_in">na_in</a>()</code>,
<code><a href="#topic+na_out">na_out</a>()</code>,
<code><a href="#topic+na_rep">na_rep</a>()</code>,
<code><a href="#topic+prop_distinct">prop_distinct</a>()</code>,
<code><a href="#topic+prop_na">prop_na</a>()</code>,
<code><a href="#topic+prop_out">prop_out</a>()</code>,
<code><a href="#topic+what_in">what_in</a>()</code>,
<code><a href="#topic+what_out">what_out</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prop_in(c("VT", "NH", "ZZ", "ME"), state.abb)
</code></pre>

<hr>
<h2 id='prop_na'>Proportion missing</h2><span id='topic+prop_na'></span>

<h3>Description</h3>

<p>Find the proportion of values of <code>x</code> that are <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_na_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mean(is.na(x))</code>
</p>


<h3>Value</h3>

<p>The proportion of values of <code>x</code> that are <code>NA</code>.
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_diff">count_diff</a>()</code>,
<code><a href="#topic+count_in">count_in</a>()</code>,
<code><a href="#topic+count_na">count_na</a>()</code>,
<code><a href="#topic+count_out">count_out</a>()</code>,
<code><a href="#topic+na_in">na_in</a>()</code>,
<code><a href="#topic+na_out">na_out</a>()</code>,
<code><a href="#topic+na_rep">na_rep</a>()</code>,
<code><a href="#topic+prop_distinct">prop_distinct</a>()</code>,
<code><a href="#topic+prop_in">prop_in</a>()</code>,
<code><a href="#topic+prop_out">prop_out</a>()</code>,
<code><a href="#topic+what_in">what_in</a>()</code>,
<code><a href="#topic+what_out">what_out</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prop_na(c("VT", "NH", NA, "ME"))
</code></pre>

<hr>
<h2 id='prop_out'>Proportion out</h2><span id='topic+prop_out'></span>

<h3>Description</h3>

<p>Find the proportion of values of <code>x</code> that are <code style="white-space: pre;">&#8288;%out%&#8288;</code> of the vector <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_out(x, y, na.rm = TRUE, ignore.case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_out_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
<tr><td><code id="prop_out_+3A_y">y</code></td>
<td>
<p>A vector to compare against.</p>
</td></tr>
<tr><td><code id="prop_out_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; Should <code>NA</code> be ignored?</p>
</td></tr>
<tr><td><code id="prop_out_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical; if <code>FALSE</code>, the pattern matching is case
sensitive and if <code>TRUE</code>, case is ignored during matching.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mean(x %out% y)</code>
</p>


<h3>Value</h3>

<p>The proportion of <code>x</code> absent in <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_diff">count_diff</a>()</code>,
<code><a href="#topic+count_in">count_in</a>()</code>,
<code><a href="#topic+count_na">count_na</a>()</code>,
<code><a href="#topic+count_out">count_out</a>()</code>,
<code><a href="#topic+na_in">na_in</a>()</code>,
<code><a href="#topic+na_out">na_out</a>()</code>,
<code><a href="#topic+na_rep">na_rep</a>()</code>,
<code><a href="#topic+prop_distinct">prop_distinct</a>()</code>,
<code><a href="#topic+prop_in">prop_in</a>()</code>,
<code><a href="#topic+prop_na">prop_na</a>()</code>,
<code><a href="#topic+what_in">what_in</a>()</code>,
<code><a href="#topic+what_out">what_out</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prop_out(c("VT", "NH", "ZZ", "ME"), state.abb)
</code></pre>

<hr>
<h2 id='read_names'>Read column names</h2><span id='topic+read_names'></span>

<h3>Description</h3>

<p>Read the first line of a delimited file as vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_names(file, delim = guess_delim(file))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_names_+3A_file">file</code></td>
<td>
<p>Path to text file.</p>
</td></tr>
<tr><td><code id="read_names_+3A_delim">delim</code></td>
<td>
<p>Character separating column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read_names("date,lgl\n11/09/2016,TRUE")
</code></pre>

<hr>
<h2 id='rename_prefix'>Convert data frame name suffixes to prefixes</h2><span id='topic+rename_prefix'></span>

<h3>Description</h3>

<p>When performing a <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code>, the <code>suffix</code> argument allows the user
to replace the default <code>.x</code> and <code>.y</code> that are appended to column names shared
between the two data frames. This function allows a user to convert those
suffixes to <em>prefixes</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_prefix(df, suffix = c(".x", ".y"), punct = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_prefix_+3A_df">df</code></td>
<td>
<p>A joined data frame.</p>
</td></tr>
<tr><td><code id="rename_prefix_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in x and y, these
suffixes will be added to the output to disambiguate them. Should be a
character vector of length 2. Will be converted to prefixes.</p>
</td></tr>
<tr><td><code id="rename_prefix_+3A_punct">punct</code></td>
<td>
<p>logical; Should punctuation at the start of the suffix be
detected and placed at the end of the new prefix? <code>TRUE</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with new column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- data.frame(x = letters[1:3], y = 1:3)
b &lt;- data.frame(x = letters[1:3], y = 4:6)
df &lt;- dplyr::left_join(a, b, by = "x", suffix = c(".a", ".b"))
rename_prefix(df, suffix = c(".a", ".b"), punct = TRUE)
</code></pre>

<hr>
<h2 id='rx_break'>Form a word break regex pattern</h2><span id='topic+rx_break'></span>

<h3>Description</h3>

<p>Wrap a word in word boundary (<code style="white-space: pre;">&#8288;\\b&#8288;</code>) characters. Useful when combined with
<code><a href="stringr.html#topic+str_which">stringr::str_which()</a></code> and <code><a href="stringr.html#topic+str_detect">stringr::str_detect()</a></code> to match only entire words
and not that word <em>inside</em> another word (e.g., &quot;sting&quot; and &quot;testing&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_break(pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_break_+3A_pattern">pattern</code></td>
<td>
<p>A regex pattern (a word) to wrap in <code style="white-space: pre;">&#8288;\\b&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The a glue vector of <code>pattern</code> wrapped in <code style="white-space: pre;">&#8288;\\b&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rx_break("test")
rx_break(state.abb[1:5])
</code></pre>

<hr>
<h2 id='rx_phone'>Phone number regex</h2><span id='topic+rx_phone'></span>

<h3>Description</h3>

<p>The regex string to match US phone numbers in a variety of
common formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_phone
</code></pre>


<h3>Format</h3>

<p>A character string (length 1).
</p>

<hr>
<h2 id='rx_state'>State regex</h2><span id='topic+rx_state'></span>

<h3>Description</h3>

<p>The regex string to extract state string preceding ZIP code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_state
</code></pre>


<h3>Format</h3>

<p>A character string (length 1).
</p>

<hr>
<h2 id='rx_url'>URL regex</h2><span id='topic+rx_url'></span>

<h3>Description</h3>

<p>The regex string to match valid URLs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_url
</code></pre>


<h3>Format</h3>

<p>A character string (length 1).
</p>

<hr>
<h2 id='rx_zip'>ZIP code regex</h2><span id='topic+rx_zip'></span>

<h3>Description</h3>

<p>The regex string to extract ZIP code from the end of address.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_zip
</code></pre>


<h3>Format</h3>

<p>A character string (length 1).
</p>

<hr>
<h2 id='scale_x_truncate'>Truncate and wrap x-axis labels</h2><span id='topic+scale_x_truncate'></span><span id='topic+scale_x_wrap'></span>

<h3>Description</h3>

<p>Truncate the labels of a plot's discrete x-axis labels so that the text does
not overflow and collide with other bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_truncate(n = 15, ...)

scale_x_wrap(width = 15, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_truncate_+3A_n">n</code></td>
<td>
<p>The maximum width of string. Passed to <code><a href="stringr.html#topic+str_trunc">stringr::str_trunc()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_x_truncate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+scale_discrete">ggplot2::scale_x_discrete()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_x_truncate_+3A_width">width</code></td>
<td>
<p>Positive integer giving target line width in characters. A width
less than or equal to 1 will put each word on its own line. Passed to
<code><a href="stringr.html#topic+str_wrap">stringr::str_wrap()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='str_dist'>Calculate string distance</h2><span id='topic+str_dist'></span>

<h3>Description</h3>

<p>This function wraps around <code><a href="stringdist.html#topic+stringdist">stringdist::stringdist()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_dist(a, b, method = "osa", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_dist_+3A_a">a</code></td>
<td>
<p><code>R</code> object (target); will be converted by <code><a href="base.html#topic+character">base::as.character()</a></code>.</p>
</td></tr>
<tr><td><code id="str_dist_+3A_b">b</code></td>
<td>
<p><code>R</code> object (source); will be converted by <code><a href="base.html#topic+character">base::as.character()</a></code>.</p>
</td></tr>
<tr><td><code id="str_dist_+3A_method">method</code></td>
<td>
<p>Method for distance calculation. The default is &quot;osa.&quot;</p>
</td></tr>
<tr><td><code id="str_dist_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="stringdist.html#topic+stringdist">stringdist::stringdist()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance between string <code>a</code> and string <code>b</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_dist(a = "BRULINGTN", b = "BURLINGTON")
</code></pre>

<hr>
<h2 id='str_normal'>Normalize a character string</h2><span id='topic+str_normal'></span>

<h3>Description</h3>

<p>The generic normalization that underpins functions like <code><a href="#topic+normal_city">normal_city()</a></code> and
<code><a href="#topic+normal_address">normal_address()</a></code>. This function simply chains together three
<code style="white-space: pre;">&#8288;stringr::str_*()&#8288;</code> functions:
</p>

<ol>
<li><p> Convert to uppercase.
</p>
</li>
<li><p> Replace punctuation with whitespaces.
</p>
</li>
<li><p> Trim and squish excess whitespace.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>str_normal(x, case = TRUE, punct = "", quote = TRUE, squish = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_normal_+3A_x">x</code></td>
<td>
<p>A character string to normalize.</p>
</td></tr>
<tr><td><code id="str_normal_+3A_case">case</code></td>
<td>
<p>logical; whether <code><a href="stringr.html#topic+case">stringr::str_to_upper()</a></code> should be called.</p>
</td></tr>
<tr><td><code id="str_normal_+3A_punct">punct</code></td>
<td>
<p>character; A character string to replace most punctuation with.</p>
</td></tr>
<tr><td><code id="str_normal_+3A_quote">quote</code></td>
<td>
<p>logical; whether <code><a href="stringr.html#topic+str_replace">stringr::str_replace_all()</a></code> should be called
on double quotes.</p>
</td></tr>
<tr><td><code id="str_normal_+3A_squish">squish</code></td>
<td>
<p>logical; whether <code><a href="stringr.html#topic+str_trim">stringr::str_squish()</a></code> should be called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A normalized vector of the same length.
</p>


<h3>See Also</h3>

<p>Other geographic normalization functions: 
<code><a href="#topic+abbrev_full">abbrev_full</a>()</code>,
<code><a href="#topic+abbrev_state">abbrev_state</a>()</code>,
<code><a href="#topic+check_city">check_city</a>()</code>,
<code><a href="#topic+expand_abbrev">expand_abbrev</a>()</code>,
<code><a href="#topic+expand_state">expand_state</a>()</code>,
<code><a href="#topic+fetch_city">fetch_city</a>()</code>,
<code><a href="#topic+normal_address">normal_address</a>()</code>,
<code><a href="#topic+normal_city">normal_city</a>()</code>,
<code><a href="#topic+normal_state">normal_state</a>()</code>,
<code><a href="#topic+normal_zip">normal_zip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_normal("   TestING 123   example_test.String   ")
</code></pre>

<hr>
<h2 id='this_file_new'>Check if a single file is new</h2><span id='topic+this_file_new'></span>

<h3>Description</h3>

<p>This function tests whether a single file has a modification date equal to
the system date. Useful when repeatedly running code with a lengthy download
stage. Many state databases are updated daily, so new data can be helpful but
not always necessary. Set this function in an <code>if</code> statement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>this_file_new(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="this_file_new_+3A_path">path</code></td>
<td>
<p>The path to a file to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical; Whether the file has a modification date equal to today.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
this_file_new(tmp)
</code></pre>

<hr>
<h2 id='url_file_size'>Check a URL file size</h2><span id='topic+url_file_size'></span>

<h3>Description</h3>

<p>Call <code><a href="httr.html#topic+HEAD">httr::HEAD()</a></code> and return the number of bytes in the file to be
downloaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url_file_size(url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="url_file_size_+3A_url">url</code></td>
<td>
<p>The URL of the file to query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The size of a file to be downloaded.
</p>

<hr>
<h2 id='url2path'>Make a File Path from a URL</h2><span id='topic+url2path'></span>

<h3>Description</h3>

<p>Combine the <code><a href="base.html#topic+basename">basename()</a></code> of a file URL with a directory path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url2path(url, dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="url2path_+3A_url">url</code></td>
<td>
<p>The URL of a file to download.</p>
</td></tr>
<tr><td><code id="url2path_+3A_dir">dir</code></td>
<td>
<p>The directory where the file will be downloaded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful in the <code>destfile</code> argument to <code><a href="utils.html#topic+download.file">download.file()</a></code> to save a file with
the same name as the URL's file name.
</p>


<h3>Value</h3>

<p>The desired file path to a URL file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>url2path("https://floridalobbyist.gov/reports/llob.txt", tempdir())
</code></pre>

<hr>
<h2 id='use_diary'>Create a new template data diary</h2><span id='topic+use_diary'></span>

<h3>Description</h3>

<p>Take the arguments supplied and put them into the appropriate places in a
new template diary. Write the new template diary in the supplied directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_diary(
  st,
  type,
  author,
  path = "state/{st}/{type}/docs/{st}_{type}_diary.Rmd",
  auto = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_diary_+3A_st">st</code></td>
<td>
<p>The USPS state abbreviation. State data only, no federal agencies.</p>
</td></tr>
<tr><td><code id="use_diary_+3A_type">type</code></td>
<td>
<p>The type of data, one of &quot;contribs&quot;, &quot;expends&quot;, &quot;lobby&quot;,
&quot;contracts&quot;, &quot;salary&quot;, or &quot;voters&quot;.</p>
</td></tr>
<tr><td><code id="use_diary_+3A_author">author</code></td>
<td>
<p>The author name of the new diary.</p>
</td></tr>
<tr><td><code id="use_diary_+3A_path">path</code></td>
<td>
<p>The file path, relative to your working directory, where the
diary file will be created. If you use <code>NA</code>, then the lines of the diary
will be returned as a character vector. If you specify a character string
file path that contains directories that do not exist then they will be
created. By default, the path creates the diary in a directory that is
expected by the <a href="https://github.com/irworkshop/accountability_datacleaning">Accountability Project GitHub repository</a>.</p>
</td></tr>
<tr><td><code id="use_diary_+3A_auto">auto</code></td>
<td>
<p>Must be set to <code>TRUE</code> for the diary to be created and opened.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The file path of new diary, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use_diary("VT", "contribs", "Kiernan Nicholls", NA, auto = FALSE)
use_diary("DC", "expends", "Kiernan Nicholls", tempfile(), auto = FALSE)
</code></pre>

<hr>
<h2 id='usps_city'>USPS City Abbreviations</h2><span id='topic+usps_city'></span>

<h3>Description</h3>

<p>A curated and edited subset of <a href="#topic+usps_street">usps_street</a> containing the
USPS abbreviations found in city names. Useful as the <code>geo_abbs</code> argument
of <code><a href="#topic+normal_city">normal_city()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usps_city
</code></pre>


<h3>Format</h3>

<p>A tibble with 154 rows of 2 variables:
</p>

<dl>
<dt>full</dt><dd><p>Primary Street Suffix</p>
</dd>
<dt>abb</dt><dd><p>Commonly Used Street Suffix or Abbreviation</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>USPS Appendix C1,
<a href="https://pe.usps.com/text/pub28/28apc_002.htm">Street Abbreviations</a>
</p>

<hr>
<h2 id='usps_state'>USPS State Abbreviations</h2><span id='topic+usps_state'></span>

<h3>Description</h3>

<p>A tibble containing the USPS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usps_state
</code></pre>


<h3>Format</h3>

<p>A tibble with 62 rows of 2 variables:
</p>

<dl>
<dt>full</dt><dd><p>Primary Street Suffix</p>
</dd>
<dt>abb</dt><dd><p>Commonly Used Street Suffix or Abbreviation</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>USPS Appendix B,
<a href="https://pe.usps.com/text/pub28/28apb.htm">TwoLetter State Abbreviations</a>
</p>

<hr>
<h2 id='usps_street'>USPS Street Abbreviations</h2><span id='topic+usps_street'></span>

<h3>Description</h3>

<p>A tibble containing common street suffixes or suffix
abbreviations and their full equivalent. Useful as the <code>add_abbs</code> argument
of <code><a href="#topic+normal_address">normal_address()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usps_street
</code></pre>


<h3>Format</h3>

<p>A tibble with 325 rows of 3 variables:
</p>

<dl>
<dt>full</dt><dd><p>Primary Street Suffix.</p>
</dd>
<dt>abb</dt><dd><p>Commonly Used Street Suffix or Abbreviation.</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>USPS Appendix
<a href="https://pe.usps.com/text/pub28/28apc_002.htm">C1 Street Abbreviations</a>.
</p>

<hr>
<h2 id='valid_abb'>US State Abbreviations</h2><span id='topic+valid_abb'></span>

<h3>Description</h3>

<p>The <code>abb</code> column of the <code>usps_state</code> tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_abb
</code></pre>


<h3>Format</h3>

<p>A vector of 2-digit abbreviations (length 62).
</p>

<hr>
<h2 id='valid_city'>US City Names</h2><span id='topic+valid_city'></span>

<h3>Description</h3>

<p>The <code>city</code> column of the <code>zipcodes</code> tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_city
</code></pre>


<h3>Format</h3>

<p>A sorted vector of unique city names (length 19,083).
</p>

<hr>
<h2 id='valid_name'>US State Names</h2><span id='topic+valid_name'></span>

<h3>Description</h3>

<p>The <code>state</code> column of the <code>usps_state</code> tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_name
</code></pre>


<h3>Format</h3>

<p>A vector of state names (length 62).
</p>


<h3>Details</h3>

<p>Contains 12 more names than <a href="datasets.html#topic+state">datasets::state.name</a>.
</p>

<hr>
<h2 id='valid_state'>US State Abbreviations</h2><span id='topic+valid_state'></span>

<h3>Description</h3>

<p>The <code>abb</code> column of the <code>usps_state</code> tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_state
</code></pre>


<h3>Format</h3>

<p>A vector of 2-digit abbreviations (length 62).
</p>

<hr>
<h2 id='valid_zip'>Almost all of the valid USA ZIP Codes</h2><span id='topic+valid_zip'></span>

<h3>Description</h3>

<p>The <code>zip</code> column of the <code>geo</code> tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_zip
</code></pre>


<h3>Format</h3>

<p>A sorted vector of 5-digit ZIP codes (length 44334).
</p>

<hr>
<h2 id='what_in'>Which in</h2><span id='topic+what_in'></span>

<h3>Description</h3>

<p>Return the values of <code>x</code> that are <code>%in%</code> of the vector <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>what_in(x, y, ignore.case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="what_in_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
<tr><td><code id="what_in_+3A_y">y</code></td>
<td>
<p>A vector to compare against.</p>
</td></tr>
<tr><td><code id="what_in_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical; if <code>FALSE</code>, the pattern matching is case
sensitive and if <code>TRUE</code>, case is ignored during matching.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x[which(x %in% y)]</code>
</p>


<h3>Value</h3>

<p>The elements of <code>x</code> that are <code>%in%</code> y.
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_diff">count_diff</a>()</code>,
<code><a href="#topic+count_in">count_in</a>()</code>,
<code><a href="#topic+count_na">count_na</a>()</code>,
<code><a href="#topic+count_out">count_out</a>()</code>,
<code><a href="#topic+na_in">na_in</a>()</code>,
<code><a href="#topic+na_out">na_out</a>()</code>,
<code><a href="#topic+na_rep">na_rep</a>()</code>,
<code><a href="#topic+prop_distinct">prop_distinct</a>()</code>,
<code><a href="#topic+prop_in">prop_in</a>()</code>,
<code><a href="#topic+prop_na">prop_na</a>()</code>,
<code><a href="#topic+prop_out">prop_out</a>()</code>,
<code><a href="#topic+what_out">what_out</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>what_in(c("VT", "DC", NA), state.abb)
</code></pre>

<hr>
<h2 id='what_out'>Which out</h2><span id='topic+what_out'></span>

<h3>Description</h3>

<p>Return the values of <code>x</code> that are <code style="white-space: pre;">&#8288;%out%&#8288;</code> of the vector <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>what_out(x, y, na.rm = TRUE, ignore.case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="what_out_+3A_x">x</code></td>
<td>
<p>A vector to check.</p>
</td></tr>
<tr><td><code id="what_out_+3A_y">y</code></td>
<td>
<p>A vector to compare against.</p>
</td></tr>
<tr><td><code id="what_out_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; Should <code>NA</code> be ignored?</p>
</td></tr>
<tr><td><code id="what_out_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical; if <code>FALSE</code>, the pattern matching is case
sensitive and if <code>TRUE</code>, case is ignored during matching.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x[which(x %out% y)]</code>
</p>


<h3>Value</h3>

<p>The elements of <code>x</code> that are <code style="white-space: pre;">&#8288;%out%&#8288;</code> y.
</p>


<h3>See Also</h3>

<p>Other counting wrappers: 
<code><a href="#topic+count_diff">count_diff</a>()</code>,
<code><a href="#topic+count_in">count_in</a>()</code>,
<code><a href="#topic+count_na">count_na</a>()</code>,
<code><a href="#topic+count_out">count_out</a>()</code>,
<code><a href="#topic+na_in">na_in</a>()</code>,
<code><a href="#topic+na_out">na_out</a>()</code>,
<code><a href="#topic+na_rep">na_rep</a>()</code>,
<code><a href="#topic+prop_distinct">prop_distinct</a>()</code>,
<code><a href="#topic+prop_in">prop_in</a>()</code>,
<code><a href="#topic+prop_na">prop_na</a>()</code>,
<code><a href="#topic+prop_out">prop_out</a>()</code>,
<code><a href="#topic+what_in">what_in</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>what_out(c("VT", "DC", NA), state.abb)
</code></pre>

<hr>
<h2 id='zipcodes'>US City, state, and ZIP</h2><span id='topic+zipcodes'></span>

<h3>Description</h3>

<p>This tibble is the third version of a popular zipcodes database.
The original CivicSpace US ZIP Code Database was created by Schuyler Erle
using ZIP code gazetteers from the US Census Bureau from 1999 and 2000,
augmented with additional ZIP code information from the Census Bureaus
TIGER/Line 2003 data set. The second version was published as the
<code>zipcode::zipcode</code> dataframe object. This version has dropped the latitude
and longitude, reorganized columns, and normalize the city values with
<code><a href="#topic+normal_city">normal_city()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipcodes
</code></pre>


<h3>Format</h3>

<p>A tibble with 44,336 rows of 3 variables:
</p>

<dl>
<dt>city</dt><dd><p>Normalized city name.</p>
</dd>
<dt>state</dt><dd><p>Two letter state abbreviation.</p>
</dd>
<dt>zip</dt><dd><p>Five-digit ZIP Code.</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>Daniel Coven's federalgovernmentzipcodes.us web site and the
CivicSpace US ZIP Code Database written by Schuyler Erle
<a href="mailto:schuyler@geocoder.us">schuyler@geocoder.us</a>, 5 August 2004. Original CSV files available from
<a href="https://web.archive.org/web/20221005220101/http://federalgovernmentzipcodes.us/free-zipcode-database-Primary.csv">https://web.archive.org/web/20221005220101/http://federalgovernmentzipcodes.us/free-zipcode-database-Primary.csv</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
