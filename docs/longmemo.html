<!DOCTYPE html><html><head><title>Help for package longmemo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {longmemo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CetaARIMA'><p>Covariance for fractional ARIMA</p></a></li>
<li><a href='#CetaFGN'><p>Covariance Matrix of Eta for Fractional Gaussian Noise</p></a></li>
<li><a href='#ckARMA0'><p>Covariances of a Fractional ARIMA(0,d,0) Process</p></a></li>
<li><a href='#ckFGN0'><p>Covariances of a Fractional Gaussian Process</p></a></li>
<li><a href='#ethernetTraffic'><p>Ethernet Traffic Data Set</p></a></li>
<li><a href='#FEXPest'><p>Fractional EXP (FEXP) Model Estimator</p></a></li>
<li><a href='#llplot'><p>Log-Log and Log-X Plot of Spectrum</p></a></li>
<li><a href='#NBSdiff1kg'><p>NBS measurement deviations from 1 kg</p></a></li>
<li><a href='#NhemiTemp'><p>Northern Hemisphere Temperature</p></a></li>
<li><a href='#NileMin'><p>Nile River Minima, yearly 622&ndash;1284</p></a></li>
<li><a href='#per'><p>Simple Periodogram Estimate</p></a></li>
<li><a href='#plot.FEXP'><p>Plot Method for FEXP and WhittleEst Model Fits</p></a></li>
<li><a href='#Qeta'><p>Approximate Log Likelihood for Fractional Gaussian Noise / Fractional ARIMA</p></a></li>
<li><a href='#simGauss'><p>Simulate (Fractional) Gaussian Processes</p></a></li>
<li><a href='#specARIMA'><p>Spectral Density of Fractional ARMA Process</p></a></li>
<li><a href='#specFGN'><p>Spectral Density of Fractional Gaussian Noise</p></a></li>
<li><a href='#videoVBR'><p>Video VBR data</p></a></li>
<li><a href='#WhittleEst'><p>Whittle Estimator for Fractional Gaussian Noise / Fractional ARIMA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-05</td>
</tr>
<tr>
<td>Author:</td>
<td>S scripts originally by Jan Beran &lt;jan.beran@uni-konstanz.de&gt;;
        Datasets via Brandon Whitcher &lt;brandon@stat.washington.edu&gt;.
	Toplevel R functions and much more by Martin Maechler.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistics for Long-Memory Processes (Book Jan Beran), and
Related Functionality</td>
</tr>
<tr>
<td>Description:</td>
<td>Datasets and Functionality from
  'Jan Beran' (1994). Statistics for Long-Memory Processes; Chapman &amp; Hall.
  Estimation of Hurst (and more) parameters for fractional Gaussian noise,
  'fARIMA' and 'FEXP' models.</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, utils, stats</td>
</tr>
<tr>
<td>Enhances:</td>
<td>fracdiff</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sfsmisc</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-05 11:11:23 UTC; maechler</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-06 06:20:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='CetaARIMA'>Covariance for fractional ARIMA</h2><span id='topic+CetaARIMA'></span>

<h3>Description</h3>

<p>Compute the covariance matrix of <code class="reqn">\hat{eta}</code> for a fractional
ARIMA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CetaARIMA(eta, p, q, m = 10000, delta = 1e-9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CetaARIMA_+3A_eta">eta</code></td>
<td>
<p>parameter vector <code>eta = c(H, phi, psi)</code>.</p>
</td></tr>
<tr><td><code id="CetaARIMA_+3A_p">p</code>, <code id="CetaARIMA_+3A_q">q</code></td>
<td>
<p>integer scalars giving the AR and MA order respectively.</p>
</td></tr>
<tr><td><code id="CetaARIMA_+3A_m">m</code></td>
<td>
<p>integer specifying the length of the Riemann sum, with step
size <code>2 * pi/m</code>.</p>
</td></tr>
<tr><td><code id="CetaARIMA_+3A_delta">delta</code></td>
<td>
<p>step size for numerical derivative computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>builds on calling <code><a href="#topic+specARIMA">specARIMA</a>(eta,p,q,m)</code>
</p>


<h3>Value</h3>

<p>the (square) matrix containg covariances up to ...
</p>


<h3>Author(s)</h3>

<p>Jan Beran (principal) and Martin Maechler (fine tuning)</p>


<h3>References</h3>

<p>Beran(1984), listing on p.224&ndash;225.</p>


<h3>Examples</h3>

<pre><code class='language-R'> (C.7  &lt;- CetaARIMA(0.7, m = 256, p = 0, q = 0))
 (C.5  &lt;- CetaARIMA(eta = c(H = 0.5, phi=c(-.06, 0.42, -0.36), psi=0.776),
                    m = 256, p = 3, q = 1))
</code></pre>

<hr>
<h2 id='CetaFGN'>Covariance Matrix of Eta for Fractional Gaussian Noise</h2><span id='topic+CetaFGN'></span>

<h3>Description</h3>

<p>Covariance matrix of <code class="reqn">\hat{\eta}</code> for fractional Gaussian
noise (fGn).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CetaFGN(eta, m = 10000, delta = 1e-9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CetaFGN_+3A_eta">eta</code></td>
<td>
<p>parameter vector <code>eta = c(H, *)</code>.</p>
</td></tr>
<tr><td><code id="CetaFGN_+3A_m">m</code></td>
<td>
<p>integer specifying the length of the Riemann sum, with step
size <code>2 * pi/m</code>.  The default (10000) is realistic.</p>
</td></tr>
<tr><td><code id="CetaFGN_+3A_delta">delta</code></td>
<td>
<p>step size for numerical derivative computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the step size for numerical derivative is the same in all
coordinate directions of <code>eta</code>.  In principle, this can be far
from optimal.
</p>


<h3>Value</h3>

<p>Variance-covariance matrix of the estimated parameter vector
<code class="reqn">\hat{\eta}</code>.
</p>


<h3>Author(s)</h3>

<p>Jan Beran (principal) and Martin Maechler (speedup, fine tuning)</p>


<h3>See Also</h3>

<p><code><a href="#topic+specFGN">specFGN</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> (C.7  &lt;- CetaFGN(0.7, m = 256))
 (C.5  &lt;- CetaFGN(eta = c(H = 0.5), m = 256))
 (C.5. &lt;- CetaFGN(eta = c(H = 0.5), m = 1024))
</code></pre>

<hr>
<h2 id='ckARMA0'>Covariances of a Fractional ARIMA(0,d,0) Process</h2><span id='topic+ckARMA0'></span>

<h3>Description</h3>

<p>Compute the Autocovariances of a fractional ARIMA(0,d,0) process (d =
H - 1/2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ckARMA0(n, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ckARMA0_+3A_n">n</code></td>
<td>
<p>sample size (length of time series).</p>
</td></tr>
<tr><td><code id="ckARMA0_+3A_h">H</code></td>
<td>
<p>self-similarity (&lsquo;Hurst&rsquo;) parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The theoretical formula,
</p>
<p style="text-align: center;"><code class="reqn">C(k) = (-1)^k  \Gamma(1-2d) / (\Gamma(k+1-d) \Gamma(1-k-d)) ,</code>
</p>

<p>where <code class="reqn">d = H - 1/2</code>,
leads to over-/underflow for larger lags <code class="reqn">k</code>;
hence use the asymptotical formula there.
</p>


<h3>Value</h3>

<p>numeric vector of length <code>n</code> of covariances
<code class="reqn">C(0) \ldots C(n-1)</code>.
</p>


<h3>Author(s)</h3>

<p>Jan Beran (principal) and Martin Maechler (speedup, fine tuning)</p>


<h3>References</h3>

<p>Jan Beran (1994), p.63, (2.35) and (2.39).</p>


<h3>See Also</h3>

<p><code><a href="#topic+ckFGN0">ckFGN0</a></code> which does the same for fractional
Gaussian noise.</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(C.8 &lt;- ckARMA0(50, H = 0.8))
yl &lt;- c(0,max(C.8))
plot(0:49, C.8, type = "h", ylim = yl)
plot(0:49, C.8, type = "h", log = "xy",
     main = "Log-Log  ACF for ARIMA(0,d,0)")
</code></pre>

<hr>
<h2 id='ckFGN0'>Covariances of a Fractional Gaussian Process</h2><span id='topic+ckFGN0'></span>

<h3>Description</h3>

<p>Compute the Autocovariances of a fractional Gaussian process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ckFGN0(n, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ckFGN0_+3A_n">n</code></td>
<td>
<p>sample size (length of time series).</p>
</td></tr>
<tr><td><code id="ckFGN0_+3A_h">H</code></td>
<td>
<p>self-similarity (&lsquo;Hurst&rsquo;) parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of covariances upto lag n-1.
</p>


<h3>Author(s)</h3>

<p>Jan Beran (principal) and Martin Maechler (fine tuning)</p>


<h3>See Also</h3>

<p><code><a href="#topic+ckARMA0">ckARMA0</a></code> which does the same for a fractional
ARIMA process.</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(C.8 &lt;- ckFGN0(50, H = 0.8))
plot(0:49, C.8, type = "h", ylim = 0:1)
plot(0:49, C.8, type = "h", log = "xy",
     main = "Log-Log  ACF for frac.GaussNoise(H = 0.8)")
</code></pre>

<hr>
<h2 id='ethernetTraffic'>Ethernet Traffic Data Set</h2><span id='topic+ethernetTraffic'></span>

<h3>Description</h3>

<p>Ethernet traffic data from a LAN at Bellcore, Morristown (Leland et al.
1993, Leland and Wilson 1991).  The data are listed in
chronological sequence by row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ethernetTraffic)</code></pre>


<h3>Format</h3>

<p>A times series of length 4000.
</p>


<h3>Source</h3>

<p>Jan Beran and Brandon Whitcher by E-mail in fall 1995.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethernetTraffic)
str(ethernetTraffic)
plot(ethernetTraffic)## definitely special
</code></pre>

<hr>
<h2 id='FEXPest'>Fractional EXP (FEXP) Model Estimator</h2><span id='topic+FEXPest'></span><span id='topic+print.FEXP'></span>

<h3>Description</h3>

<p>Computes Beran's Fractional EXP or &lsquo;FEXP&rsquo; model estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FEXPest(x, order.poly, pvalmax, verbose = FALSE)
## S3 method for class 'FEXP'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FEXPest_+3A_x">x</code></td>
<td>
<p>numeric vector representing a time series.</p>
</td></tr>
<tr><td><code id="FEXPest_+3A_order.poly">order.poly</code></td>
<td>
<p>integer specifying the maximal polynomial order that
should be taken into account.  <code>order.poly = 0</code> is equivalent
to a FARIMA(0,d,0) model.</p>
</td></tr>
<tr><td><code id="FEXPest_+3A_pvalmax">pvalmax</code></td>
<td>
<p>maximal P-value &ndash; the other iteration stopping
criterion and &ldquo;model selection tuning parameter&rdquo;.
Setting this to <code>1</code>, will use <code>order.poly</code> alone, and
hence the final model order will be <code>= order.poly</code>.</p>
</td></tr>
<tr><td><code id="FEXPest_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if iteration output should be printed.</p>
</td></tr>
<tr><td><code id="FEXPest_+3A_digits">digits</code>, <code id="FEXPest_+3A_...">...</code></td>
<td>
<p>optional arguments for <code>print</code> method, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>FEXP</code> which is basically a list with components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the function <code><a href="base.html#topic+call">call</a></code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>time series length <code>length(x)</code>.</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>the &ldquo;Hurst&rdquo; parameter which is simply <code>(1-theta[2])/2</code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>numeric 4-column matrix as returned from
<code><a href="stats.html#topic+summary.glm">summary.glm</a>()</code>, with estimate of the full parameter
vector <code class="reqn">\theta</code>, its standard error estimates, t- and P-values,
as from the <code><a href="stats.html#topic+glm">glm</a>(*, family = Gamma)</code> fit.</p>
</td></tr>
<tr><td><code>order.poly</code></td>
<td>
<p>the effective polynomial order used.</p>
</td></tr>
<tr><td><code>max.order.poly</code></td>
<td>
<p>the original <code>order.poly</code> (argument).</p>
</td></tr>
<tr><td><code>early.stop</code></td>
<td>
<p>logical indicating if <code>order.poly</code> is less than
<code>max.order.poly</code>, i.e., the highest order polynomial terms were
dropped because of a non-significant P-value.</p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p>the spectral estimate <code class="reqn">f(\omega_j)</code>, at the Fourier
frequencies <code class="reqn">\omega_j</code>.  Note that <code>.ffreq(x$n)</code>
recomputes the Fourier frequencies vector (from a fitted FEXP or
WhittleEst model <code>x</code>).</p>
</td></tr>
<tr><td><code>yper</code></td>
<td>
<p>raw periodogram of (centered and scaled <code>x</code>) at
Fourier frequencies <code class="reqn">I(\omega_j)</code>.</p>
</td></tr>
</table>
<p>There currently are methods for <code><a href="base.html#topic+print">print</a>()</code>,
<code><a href="base.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+lines">lines</a></code> (see
<code><a href="#topic+plot.FEXP">plot.FEXP</a></code>) for objects of class <code>"FEXP"</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, using Beran's &ldquo;main program&rdquo; in
Beran(1994), p.234 ff
</p>


<h3>References</h3>

<p>Beran, Jan (1993)
Fitting long-memory models by generalized linear regression.
<em>Biometrika</em> <b>80</b>, 817&ndash;822.
</p>
<p>Beran, Jan (1994).
<em>Statistics for Long-Memory Processes</em>;
Chapman &amp; Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WhittleEst">WhittleEst</a></code>;
the plot method, <code><a href="#topic+plot.FEXP">plot.FEXP</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(videoVBR)
(fE  &lt;- FEXPest(videoVBR, order = 3, pvalmax = .5))
(fE3 &lt;- FEXPest(videoVBR, order = 3, pvalmax = 1 ))

(fE7 &lt;- FEXPest(videoVBR, order = 3, pvalmax = 0.10))
##--&gt; this also choses order 2, as "FE" :
all.equal(fE $coef,
          fE7$coef) # -&gt; TRUE

confint(fE)
confint(fE7, level = 0.99)
</code></pre>

<hr>
<h2 id='llplot'>Log-Log and Log-X Plot of Spectrum</h2><span id='topic+llplot'></span><span id='topic+lxplot'></span>

<h3>Description</h3>

<p>Log-Log and &ldquo;Log-X&rdquo; plot of spectrum.
Very simple utilities, kept here mainly for back compatibility, as
they appear in the book scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llplot(yper, spec)
lxplot(yper, spec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llplot_+3A_yper">yper</code></td>
<td>
<p>periodogram values</p>
</td></tr>
<tr><td><code id="llplot_+3A_spec">spec</code></td>
<td>
<p>spectrum values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Beran (principal) and Martin Maechler (speedup, fine tuning)</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+spectrum">spectrum</a>()</code> from standard <span class="rlang"><b>R</b></span> (package
<span class="pkg">stats</span>).
</p>

<hr>
<h2 id='NBSdiff1kg'>NBS measurement deviations from 1 kg</h2><span id='topic+NBSdiff1kg'></span>

<h3>Description</h3>

<p>NBS weight measurements - deviation from 1 kg in micrograms, see the
references.  The data are listed in chronological sequence by row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NBSdiff1kg)</code></pre>


<h3>Format</h3>

<p>A time series of length 289.
</p>


<h3>Source</h3>

<p>Jan Beran and Brandon Whitcher by E-mail in fall 1995.
</p>


<h3>References</h3>

<p>H.P. Graf, F.R. Hampel, and J.Tacier (1984).
The problem of unsuspected serial correlations.
In J. Franke, W. Härdle, and R.D. Martin, editors, <em>Robust
and Nonlinear Time Series Analysis</em>, Lecture Notes in Statistics
<b>26</b>, 127&ndash;145; Springer.
</p>
<p>Pollak, M., Croakin, C., and Hagwood, C. (1993).
<em>Surveillance schemes with applications to mass calibration.</em>
NIST report 5158; Gaithersburg, MD.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NBSdiff1kg)
plot(NBSdiff1kg)
</code></pre>

<hr>
<h2 id='NhemiTemp'>Northern Hemisphere Temperature</h2><span id='topic+NhemiTemp'></span>

<h3>Description</h3>

<p>Monthly temperature for the northern hemisphere for the years
1854-1989, from the data base held at the Climate Research Unit of the
University of East Anglia, Norwich, England.  The numbers consist of
the temperature (degrees C) difference from the monthly average over
the period 1950-1979.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NhemiTemp)</code></pre>


<h3>Format</h3>

<p>Time-Series (<code><a href="stats.html#topic+ts">ts</a></code>) of length 1632, frequency 12,
starting 1854, ending 1990.
</p>


<h3>Source</h3>

<p>Jan Beran and Brandon Whitcher by E-mail in fall 1995.
</p>


<h3>References</h3>

<p>Jones, P.D. and Briffa, K.R. (1992)
Global surface air temperature variations during the twentieth
century, part 1.
<em>The Holocene</em> <b>2</b>, 165&ndash;179.
</p>
<p>Jan Beran (1994). Dataset no. 5, p.29&ndash;31.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NhemiTemp)
plot(NhemiTemp)
mean(window(NhemiTemp, 1950,1979))# (about) 0 ``by definition''
</code></pre>

<hr>
<h2 id='NileMin'>Nile River Minima, yearly 622&ndash;1284</h2><span id='topic+NileMin'></span>

<h3>Description</h3>

<p>Yearly minimal water levels of the Nile river for the years 622
to 1281, measured at the Roda gauge near Cairo, (Tousson, p. 366&ndash;385).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NileMin)</code></pre>


<h3>Format</h3>

<p>Time-Series (<code><a href="stats.html#topic+ts">ts</a></code>) of length 663.
</p>


<h3>Source</h3>

<p>The original Nile river data supplied by Beran only contained only
500 observations (622 to 1121).  However, the book claimed to have
660 observations (622 to 1281).  First added the remaining observations
from the book by hand, and still came up short with only 653
observations (622 to 1264).  Finally have 663 observations : years
622&ndash;1284 (as in orig. source)
</p>


<h3>References</h3>

<p>Tousson, O. (1925).
Mémoire sur l'Histoire du Nil;
<em>Mémoire de l'Institut d'Egypte</em>.
</p>
<p>Jan Beran (1994). Dataset no.1, p.20&ndash;22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NileMin)
plot(NileMin, main = "Nile River Minima 622 - 1284")
</code></pre>

<hr>
<h2 id='per'>Simple Periodogram Estimate</h2><span id='topic+per'></span>

<h3>Description</h3>

<p>Simply estimate the periodogram via the Fast Fourier Transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>per(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="per_+3A_z">z</code></td>
<td>
<p>numeric vector with the series to compute the periodogram
from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is basically the same as<br />
<code>spec.pgram(z, fast = FALSE, detrend = FALSE, taper = 0) $ spec</code>,
and not really recommended to use &mdash; exactly for the reason that
<code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code> has the defaults differently,
<code>fast = TRUE, detrend = TRUE, taper = 0.1</code>, see that help page.
</p>


<h3>Value</h3>

<p>numeric vector of length <code class="reqn">1 + floor(n/2)</code> where <code>n = length(z)</code>.
</p>


<h3>Author(s)</h3>

<p>Jan Beran (principal) and Martin Maechler (fine tuning)</p>


<h3>See Also</h3>

<p>a more versatile periodogram estimate by
<code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(NileMin)
 plot(10*log10(per(NileMin)), type='l')
</code></pre>

<hr>
<h2 id='plot.FEXP'>Plot Method for FEXP and WhittleEst Model Fits</h2><span id='topic+plot.FEXP'></span><span id='topic+plot.WhittleEst'></span><span id='topic+lines.FEXP'></span><span id='topic+lines.WhittleEst'></span>

<h3>Description</h3>

<p>(S3) methods for the generic functions <code><a href="base.html#topic+plot">plot</a></code> (and
<code><a href="graphics.html#topic+lines">lines</a></code>)   applied to <b>f</b>ractional EXP (FEXP) and
<code>"WhittleEst"</code> (<code><a href="#topic+FEXPest">FEXPest</a></code>,
models.
<code>plot()</code> plots the data periodogram and the &lsquo;FEXP'&rsquo; model
estimated spectrum, where <code><a href="graphics.html#topic+lines">lines</a>()</code> and does the latter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FEXP'
plot(x, log = "xy", type = "l",
      col.spec = 4, lwd.spec = 2, xlab = NULL, ylab = expression(hat(f)(nu)),
      main = paste(deparse(x$call)[1]), sub = NULL, ...)

## (With identical argument list:)
## S3 method for class 'WhittleEst'
plot(x, log = "xy", type = "l",
      col.spec = 4, lwd.spec = 2, xlab = NULL, ylab = expression(hat(f)(nu)),
      main = paste(deparse(x$call)[1]), sub = NULL, ...)

## S3 method for class 'FEXP'
      lines(x, type = "l", col = 4, lwd = 2, ...)
## S3 method for class 'WhittleEst'
lines(x, type = "l", col = 4, lwd = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.FEXP_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of <code>class</code> <code>"FEXP"</code>, as from
<code><a href="#topic+FEXPest">FEXPest</a>()</code>.</p>
</td></tr>
<tr><td><code id="plot.FEXP_+3A_log">log</code></td>
<td>
<p>character specifying log scale should be used, see
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.  Note that the default log-log scale is
particularly sensible for long-range dependence.</p>
</td></tr>
<tr><td><code id="plot.FEXP_+3A_type">type</code></td>
<td>
<p>plot type for the periodogram, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="plot.FEXP_+3A_col.spec">col.spec</code>, <code id="plot.FEXP_+3A_lwd.spec">lwd.spec</code>, <code id="plot.FEXP_+3A_col">col</code>, <code id="plot.FEXP_+3A_lwd">lwd</code></td>
<td>
<p>graphical parameters used for drawing the
estimated spectrum, see <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plot.FEXP_+3A_xlab">xlab</code>, <code id="plot.FEXP_+3A_ylab">ylab</code>, <code id="plot.FEXP_+3A_main">main</code>, <code id="plot.FEXP_+3A_sub">sub</code></td>
<td>
<p>labels for annotating the plot, see
<code><a href="graphics.html#topic+title">title</a></code>, each with a sensible default.</p>
</td></tr>
<tr><td><code id="plot.FEXP_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+FEXPest">FEXPest</a></code>, <code><a href="#topic+WhittleEst">WhittleEst</a></code>;
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> and <code><a href="stats.html#topic+spectrum">spectrum</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(videoVBR)
fE &lt;- FEXPest(videoVBR, order = 3, pvalmax = .5)
plot(fE)
fE3 &lt;- FEXPest(videoVBR, order = 3, pvalmax = 1)#-&gt; order 3
lines(fE3, col = "red3", lty=2)

f.GN    &lt;- WhittleEst(videoVBR)
f.am21  &lt;- WhittleEst(videoVBR, model = "fARIMA",
                      start= list(H= .5, AR = c(.5,0), MA= .5))
lines(f.GN,   col = "blue4")
lines(f.am21, col = "goldenrod")

##--- Using a tapered periodogram ---------
spvVBR &lt;- spec.pgram(videoVBR, fast=FALSE, plot=FALSE)
fam21 &lt;- WhittleEst(periodogr.x = head(spvVBR$spec, -1),
                    n = length(videoVBR), model = "fARIMA",
                    start= list(H= .5, AR = c(.5,0), MA= .5))
fam21
f.am21 # similar but slightly different

plot(fam21)

## Now, comparing to traditional ("log-X", not "log-log") spectral plot:
plot(fam21, log="y")

## compared to the standard R spectral plot : s
if(dev.interactive(TRUE)) getOption("device")()# a new graphics window
plot(spvVBR, log = "yes", col="gray50")
all.equal(.ffreq(fE$n) / (2*pi) -&gt; ffr.,
          head(spvVBR$freq, -1))# TRUE
lines(ffr., fam21$spec, col=4, lwd=2)
## need to adjust for different 'theta1':
lines(ffr., f.am21$spec * fam21$theta1 / f.am21$theta1,
      col = adjustcolor("tomato", 0.6), lwd=2)
</code></pre>

<hr>
<h2 id='Qeta'>Approximate Log Likelihood for Fractional Gaussian Noise / Fractional ARIMA</h2><span id='topic+Qeta'></span>

<h3>Description</h3>

<p><code>Qeta()</code> (<code class="reqn">= \tilde{Q}(\eta)</code> of Beran(1994), p.117)
is up to scaling the negative log likelihood function of the specified
model, i.e., fractional Gaussian noise or fractional ARIMA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qeta(eta, model = c("fGn","fARIMA"), n, yper, pq.ARIMA, give.B.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qeta_+3A_eta">eta</code></td>
<td>
<p>parameter vector = (H, phi[1:p], psi[1:q]).</p>
</td></tr>
<tr><td><code id="Qeta_+3A_model">model</code></td>
<td>
<p>character specifying the kind model class.</p>
</td></tr>
<tr><td><code id="Qeta_+3A_n">n</code></td>
<td>
<p>data length</p>
</td></tr>
<tr><td><code id="Qeta_+3A_yper">yper</code></td>
<td>
<p>numeric vector of length <code>(n-1)%/% 2</code>, the
periodogram of the (scaled) data, see <code><a href="#topic+per">per</a></code>.</p>
</td></tr>
<tr><td><code id="Qeta_+3A_pq.arima">pq.ARIMA</code></td>
<td>
<p>integer, = c(p,q) specifying models orders of AR and
MA parts &mdash; only used when <code>model = "fARIMA"</code>.</p>
</td></tr>
<tr><td><code id="Qeta_+3A_give.b.only">give.B.only</code></td>
<td>
<p>logical, indicating if only the <code>B</code> component
(of the <code>Values</code> list below) should be returned.  Is set to
<code>TRUE</code> for the Whittle estimator minimization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of <code class="reqn">A, B</code> and <code class="reqn">T_n = A/B^2</code> where
<code class="reqn">A = 2\pi/n \sum_j 2*[I(\lambda_j)/f(\lambda_j)]</code>,
<code class="reqn">B = 2\pi/n \sum_j 2*[I(\lambda_j)/f(\lambda_j)]^2</code>
and the sum is taken over all Fourier frequencies
<code class="reqn">\lambda_j = 2\pi*j/n</code>, (<code class="reqn">j=1,\dots,(n-1)/2</code>).
</p>
<p><code class="reqn">f</code> is the spectral density of fractional Gaussian noise or
fractional ARIMA(p,d,q) with self-similarity parameter <code class="reqn">H</code> (and
<code class="reqn">p</code> AR and <code class="reqn">q</code> MA parameters in the latter case), and is
computed either by <code><a href="#topic+specFGN">specFGN</a></code> or <code><a href="#topic+specARIMA">specARIMA</a></code>.
</p>
<p style="text-align: center;"><code class="reqn">cov(X(t),X(t+k)) = \int \exp(iuk) f(u) du</code>
</p>



<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>= input</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>(<em>input</em>) Hurst parameter, = <code>eta[1]</code>.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>= input</p>
</td></tr>
<tr><td><code>A</code>, <code>B</code></td>
<td>
<p>defined as above.</p>
</td></tr>
<tr><td><code>Tn</code></td>
<td>
<p>the goodness of fit test statistic
<code class="reqn">Tn= A/B^2</code> defined in Beran (1992)</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>the standardized test statistic</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>the corresponding p-value P(W &gt; z)</p>
</td></tr>
<tr><td><code>theta1</code></td>
<td>
<p>the scale parameter
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta_1} = \frac{{\hat\sigma_\epsilon}^2}{2\pi}</code>
</p>

<p>such that <code class="reqn">f()= \theta_1 f_1()</code> and <code class="reqn">integral(\log[f_1(.)]) = 0</code>.
</p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p>scaled spectral density <code class="reqn">f_1</code> at the Fourier frequencies
<code class="reqn">\omega_j</code>, see <code><a href="#topic+FEXPest">FEXPest</a></code>; a numeric vector.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>yper[1] must be the periodogram <code class="reqn">I(\lambda_1)</code> at
the frequency <code class="reqn">2\pi/n</code>, i.e., not the frequency zero !
</p>


<h3>Author(s)</h3>

<p>Jan Beran (principal) and Martin Maechler (fine tuning)</p>


<h3>References</h3>

<p>Jan Beran (1992).
A Goodness-of-Fit Test for Time Series with Long Range Dependence.
<em>JRSS B</em> <b>54</b>, 749&ndash;760.
</p>
<p>Beran, Jan (1994).
<em>Statistics for Long-Memory Processes</em>;
Chapman &amp; Hall.
(Section 6.1, p.116&ndash;119; 12.1.3, p.223 ff)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WhittleEst">WhittleEst</a></code> computes an approximate MLE for fractional
Gaussian noise / fractional ARIMA, by minimizing <code>Qeta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NileMin)
y &lt;- NileMin
n &lt;- length(y)
yper &lt;- per(scale(y))[2:(1+ (n-1) %/% 2)]
eta &lt;- c(H = 0.3)
q.res &lt;- Qeta(eta, n=n, yper=yper)
str(q.res)
</code></pre>

<hr>
<h2 id='simGauss'>Simulate (Fractional) Gaussian Processes</h2><span id='topic+simGauss'></span><span id='topic+simARMA0'></span><span id='topic+simFGN0'></span><span id='topic+simFGN.fft'></span>

<h3>Description</h3>

<p>Simulation of a Gaussian series <code class="reqn">X(1), \dots, X(n)</code>.  Whereas
<code>simGauss</code> works from autocovariances, where <code>simFGN0</code> and
<code>simARMA0</code> call it,
for simulating a fractional ARIMA(0,d,0) process (<code class="reqn">d = H-1/2</code>),
or fractional Gaussian noise, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simARMA0  (n, H)
simFGN0   (n, H)
simFGN.fft(n, H, ...)
simGauss(autocov)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simGauss_+3A_n">n</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="simGauss_+3A_h">H</code></td>
<td>
<p>self-similarity parameter</p>
</td></tr>
<tr><td><code id="simGauss_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="#topic+B.specFGN">B.specFGN</a>()</code>.</p>
</td></tr>
<tr><td><code id="simGauss_+3A_autocov">autocov</code></td>
<td>
<p>numeric vector of auto covariances
<code class="reqn">\gamma(0), \ldots, \gamma(n-1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simGauss</code> implements the method by Davies and Harte which is
relatively fast using the FFT (<code><a href="stats.html#topic+fft">fft</a></code>) twice.
</p>
<p>To simulate ARIMA(p, d, q), (for d in (-1/2, 1,2), you can use
<code><a href="stats.html#topic+arima.sim">arima.sim</a>(n,  model = list(ar= .., ma = ..),
    innov= simARMA0(n,H=d+1/2) , n.start = 0)</code>.
</p>
<p><code>simFGN.fft()</code> is about twice as fast as <code>simFGN0()</code> and
uses Paxson's proposal, by default via
<code><a href="#topic+B.specFGN">B.specFGN</a>(*, k.approx=3, adjust=TRUE)</code>.
</p>


<h3>Value</h3>

<p>The simulated series <code class="reqn">X(1), \dots, X(n)</code>, an <span class="rlang"><b>R</b></span> object of class
<code>"ts"</code>, constructed from <code><a href="stats.html#topic+ts">ts</a>()</code>.
</p>


<h3>Author(s)</h3>

<p>Jan Beran (original) and Martin Maechler (<code>simGauss</code>,
speedup, simplication).
<code>simFGN.fft</code>: Vern Paxson.
</p>


<h3>References</h3>

<p>Beran (1994), 11.3.3, p.216 f, referring to
</p>
<p>Davis, R.B. and Harte, D.S. (1987).
Tests for Hurst effect, <em>Biometrika</em> <b>74</b>, 95&ndash;102.
</p>
<p>Vern Paxson (1997).
Fast, Approximate Synthesis of Fractional Gaussian Noise for
Generating Self-Similar Network Traffic;
<em>Computer Communications Review</em> <b>27</b> 5, 5&ndash;18.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ckARMA0">ckARMA0</a></code> on which <code>simARMA0</code> relies, and
<code><a href="#topic+ckFGN0">ckFGN0</a></code> on which <code>simFGN0</code> relies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x1 &lt;- simFGN0(100, 0.7)
  x2 &lt;- simARMA0(100, 0.7)
  plot(simFGN0(1000, 0.8)) #- time series plot
</code></pre>

<hr>
<h2 id='specARIMA'>Spectral Density of Fractional ARMA Process</h2><span id='topic+specARIMA'></span>

<h3>Description</h3>

<p>Calculate the spectral density of a fractional ARMA process
with standard normal innovations and self-similarity parameter H.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specARIMA(eta, p, q, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specARIMA_+3A_eta">eta</code></td>
<td>
<p>parameter vector <code>eta = c(H, phi, psi)</code>.</p>
</td></tr>
<tr><td><code id="specARIMA_+3A_p">p</code>, <code id="specARIMA_+3A_q">q</code></td>
<td>
<p>integers giving AR and MA order respectively.</p>
</td></tr>
<tr><td><code id="specARIMA_+3A_m">m</code></td>
<td>
<p>sample size determining Fourier frequencies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>at the Fourier frequencies <code class="reqn">2*\pi*j/n</code>, (<code class="reqn">j=1,\dots,(n-1)</code>),
cov(X(t),X(t+k)) = (sigma/(2*pi))*integral(exp(iuk)g(u)du).
</p>
<p>&mdash; or rather &ndash; FIXME &ndash;
</p>
<p>1. cov(X(t),X(t+k)) = integral[ exp(iuk)f(u)du ]
</p>
<p>2. f() = theta1 * f*() ; spec = f*(),  and integral[log(f*())] = 0
</p>


<h3>Value</h3>

<p>an object of class <code>"spec"</code> (see also <code><a href="stats.html#topic+spectrum">spectrum</a></code>)
with components
</p>
<table>
<tr><td><code>freq</code></td>
<td>
<p>the Fourier frequencies (in <code class="reqn">(0,\pi)</code>) at which the
spectrum is computed, see <code>freq</code> in <code><a href="#topic+specFGN">specFGN</a></code>.</p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p>the <em>scaled</em> values spectral density <code class="reqn">f(\lambda)</code>
values at the <code>freq</code> values of <code class="reqn">\lambda</code>.<br />
<code class="reqn">f^*(\lambda) = f(\lambda) / \theta_1</code>
adjusted such <code class="reqn">\int \log(f^*(\lambda)) d\lambda = 0</code>.</p>
</td></tr>
<tr><td><code>theta1</code></td>
<td>
<p>the scale factor <code class="reqn">\theta_1</code>.</p>
</td></tr>
<tr><td><code>pq</code></td>
<td>
<p>a vector of length two, <code>= c(p,q)</code>.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>a named vector <code>c(H=H, phi=phi, psi=psi)</code> from input.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character indicating the kind of model used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Beran (principal) and Martin Maechler (fine tuning)</p>


<h3>References</h3>

<p>Beran (1994) and more, see .... 
</p>


<h3>See Also</h3>

<p>The spectral estimate for fractional Gaussian noise,
<code><a href="#topic+specFGN">specFGN</a></code>.
In general, <code><a href="stats.html#topic+spectrum">spectrum</a></code> and <code><a href="stats.html#topic+spec.ar">spec.ar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> str(r.7  &lt;- specARIMA(0.7, m = 256, p = 0, q = 0))
 str(r.5  &lt;- specARIMA(eta = c(H = 0.5, phi=c(-.06, 0.42, -0.36), psi=0.776),
                       m = 256, p = 3, q = 1))
 plot(r.7)
 plot(r.5)
</code></pre>

<hr>
<h2 id='specFGN'>Spectral Density of Fractional Gaussian Noise</h2><span id='topic+specFGN'></span><span id='topic+B.specFGN'></span>

<h3>Description</h3>

<p>Calculation of the spectral density <code class="reqn">f</code> of
normalized fractional Gaussian noise with self-similarity parameter
<code class="reqn">H</code> at the Fourier frequencies 2*pi*j/m (j=1,...,(m-1)).
</p>
<p><code>B.specFGN</code> computes (approximations of) the <code class="reqn">B(\lambda, H)</code>
component of the spectrum <code class="reqn">f_H(\lambda)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  specFGN(eta, m, ...)
B.specFGN(lambd, H, k.approx=3, adjust = (k.approx == 3), nsum = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specFGN_+3A_eta">eta</code></td>
<td>
<p>parameter vector <code>eta = c(H, *)</code>.</p>
</td></tr>
<tr><td><code id="specFGN_+3A_m">m</code></td>
<td>
<p>sample size determining Fourier frequencies.</p>
</td></tr>
<tr><td><code id="specFGN_+3A_...">...</code></td>
<td>
<p>optional arguments for <code>B.specFGN()</code>:
<code>k.approx</code>, etc</p>
</td></tr>
<tr><td><code id="specFGN_+3A_lambd">lambd</code></td>
<td>
<p>numeric vector of frequencies in [0, pi]</p>
</td></tr>
<tr><td><code id="specFGN_+3A_h">H</code></td>
<td>
<p>Hurst parameter in <code class="reqn">(\frac 1 2, 1)</code>, (can be outside, here).</p>
</td></tr>
<tr><td><code id="specFGN_+3A_k.approx">k.approx</code></td>
<td>
<p>either integer (the order of the Paxson approximation), or
<code>NULL</code>, <code>NA</code> for choosing to use the slow direct sum (of
<code>nsum</code> terms.)</p>
</td></tr>
<tr><td><code id="specFGN_+3A_adjust">adjust</code></td>
<td>
<p>logical indicating (only for <code>k.approx == 3</code>, the
default) that Paxson's empirical adjustment should also be used.</p>
</td></tr>
<tr><td><code id="specFGN_+3A_nsum">nsum</code></td>
<td>
<p>if the slow sum is used (e.g. for k.approx = NA), the
number of terms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that
</p>

<ol>
<li><p> cov(X(t),X(t+k)) = integral[ exp(iuk)f(u)du ]
</p>
</li>
<li><p> f=theta1*spec and integral[log(spec)]=0.
</p>
</li></ol>

<p>Since <span class="pkg">longmemo</span> version 1.1-0, a fast approximation is available
(and default), using <code>k.approx</code> terms and an adjustment
(<code>adjust=TRUE</code> in the default case of <code>k.approx=3</code>),
which is due to the analysis and S code from Paxson (1997).






</p>



<h3>Value</h3>

<p><code>specFGN()</code> returns an object of class <code>"spec"</code> (see also
<code><a href="stats.html#topic+spectrum">spectrum</a></code>) with components
</p>
<table>
<tr><td><code>freq</code></td>
<td>
<p>the Fourier frequencies <code class="reqn">\omega_j \in (0,\pi)</code>) at which the spectrum is computed.  Note that
<code class="reqn">omega_j = 2\pi j/m</code> for <code class="reqn">j=1,..., m-1</code>,
and <code class="reqn">m = \left\lfloor\frac{n-1}{2}\right\rfloor</code>.
</p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p>the <em>scaled</em> values spectral density <code class="reqn">f(\lambda)</code>
values at the <code>freq</code> values of <code class="reqn">\lambda</code>.<br />
<code class="reqn">f^*(\lambda) = f(\lambda) / \theta_1</code>
adjusted such <code class="reqn">\int \log(f^*(\lambda)) d\lambda = 0</code>.</p>
</td></tr>
<tr><td><code>theta1</code></td>
<td>
<p>the scale factor <code class="reqn">\theta_1</code>.</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>the self-similarity parameter from input.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character indicating the kind of model used.</p>
</td></tr>
</table>
<p><code>B.specFGN()</code> returns a vector of (approximate) values
<code class="reqn">B(\lambda, H)</code>.
</p>


<h3>Author(s)</h3>

<p>Jan Beran originally (using the slow sum);
Martin Maechler, based on Vern Paxson (1997)'s code.
</p>


<h3>References</h3>

<p>Jan Beran (1994).
<em>Statistics for Long-Memory Processes</em>;
Chapman &amp; Hall, NY.
</p>
<p>Vern Paxson (1997).
Fast, Approximate Synthesis of Fractional Gaussian Noise for
Generating Self-Similar Network Traffic;
<em>Computer Communications Review</em> <b>27</b> 5, 5&ndash;18.
</p>


<h3>See Also</h3>

<p>The spectral estimate for fractional ARIMA,
<code><a href="#topic+specARIMA">specARIMA</a></code>; more generally, <code><a href="stats.html#topic+spectrum">spectrum</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> str(rg.7  &lt;- specFGN(0.7, m = 100))
 str(rg.5  &lt;- specFGN(0.5, m = 100))# { H = 0.5 &lt;--&gt; white noise ! }

 plot(rg.7) ## work around plot.spec() `bug' in R &lt; 1.6.0
 plot(rg.5, add = TRUE, col = "blue")
 text(2, mean(rg.5$spec), "H = 0.5 [white noise]", col = "blue", adj = c(0,-1/4))
## This was the original method in longmemo, upto version 1.0-0 (incl):
 rg.7.o &lt;- specFGN(0.7, m = 100, k.approx=NA, nsum = 200)
 ## quite accurate (but slightly slower):
 rg.7f  &lt;- specFGN(0.7, m = 100, k.approx=NA, nsum = 10000)
 ## comparing old and new default :
 all.equal(rg.7, rg.7.o)# different in about 5th digit
 all.equal(rg.7, rg.7f )# ==&gt; new default is *more* accurate: 1.42 e-6
 ## takes about  7 sec {in 2011}:
 rg.7ff &lt;- specFGN(0.7, m = 100, k.approx=NA, nsum = 500000)
 all.equal(rg.7f, rg.7ff)# ~ 10 ^ -7
 all.equal(rg.7  $spec, rg.7ff$spec)# ~ 1.33e-6 -- Paxson is accurate!
 all.equal(rg.7.o$spec, rg.7ff$spec)# ~ 2.40e-5 -- old default is less so

</code></pre>

<hr>
<h2 id='videoVBR'>Video VBR data</h2><span id='topic+videoVBR'></span>

<h3>Description</h3>

<p>Amount of coded information (<b>v</b>ariable <b>b</b>it <b>r</b>ate)
per frame for a certain video sequence. There were about 25 frames per
second.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(videoVBR)</code></pre>


<h3>Format</h3>

<p>a time-series of length 1000.
</p>


<h3>References</h3>

<p>Heeke, H. (1991)
Statistical multiplexing gain for variable bit rate codecs in ATM
networks. <em>Int. J. Digit. Analog. Commun. Syst.</em> <b>4</b>,
261&ndash;268.
</p>
<p>Heyman, D., Tabatabai, A., and Lakshman, T.V. (1991)
Statistical analysis and simulation of video teleconferencing in ATM
networks.
<em>IEEE Trans. Circuits. Syst. Video Technol.</em> <b>2</b>, 49&ndash;59.
</p>
<p>Jan Beran (1994). Dataset no. 2, p.22&ndash;23.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(videoVBR)
plot(log(videoVBR), main="VBR Data (log)")
</code></pre>

<hr>
<h2 id='WhittleEst'>Whittle Estimator for Fractional Gaussian Noise / Fractional ARIMA</h2><span id='topic+WhittleEst'></span><span id='topic+print.WhittleEst'></span><span id='topic+nobs'></span><span id='topic+nobs.WhittleEst'></span>

<h3>Description</h3>

<p>Computes Whittle's approximate MLE for fractional Gaussian noise or
fractional ARIMA (=: fARIMA) models, according to Beran's prescript.
</p>
<p>Relies on minmizing <code><a href="#topic+Qeta">Qeta</a>()</code> (<code class="reqn">= \tilde{Q}(\eta)</code>,
which itself is based on the &ldquo;true&rdquo; spectrum of the
corresponding process; for the spectrum, either
<code><a href="#topic+specFGN">specFGN</a></code> or <code><a href="#topic+specARIMA">specARIMA</a></code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WhittleEst(x,
           periodogr.x = per(if(scale) x/sd(x) else x)[2:((n+1) %/% 2)],
           n = length(x), scale = FALSE,
           model = c("fGn", "fARIMA"),
           p, q,
           start = list(H= 0.5, AR= numeric(), MA=numeric()),
           verbose = getOption("verbose"))

## S3 method for class 'WhittleEst'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WhittleEst_+3A_x">x</code></td>
<td>
<p>numeric vector representing a time series.  Maybe omitted if
<code>periodogr.x</code> and <code>n</code> are specified instead.</p>
</td></tr>
<tr><td><code id="WhittleEst_+3A_periodogr.x">periodogr.x</code></td>
<td>
<p>the (raw) periodogram of <code>x</code>; the default, as by
Beran, uses <code><a href="#topic+per">per</a></code>, but tapering etc may be an
alternative, see also <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>.</p>
</td></tr>
<tr><td><code id="WhittleEst_+3A_n">n</code></td>
<td>
<p>length of the time series, <code>length(x)</code>.</p>
</td></tr>
<tr><td><code id="WhittleEst_+3A_scale">scale</code></td>
<td>
<p>logical indicating if <code>x</code> should be standardized to
(<code><a href="stats.html#topic+sd">sd</a></code>) scale 1; originally, <code>scale = TRUE</code> used to
be built-in; for compatibility with other methods, notably plotting
spectra, <code>scale = FALSE</code> seems a more natural default.</p>
</td></tr>
<tr><td><code id="WhittleEst_+3A_model">model</code></td>
<td>
<p>numeric vector representing a time series.</p>
</td></tr>
<tr><td><code id="WhittleEst_+3A_p">p</code>, <code id="WhittleEst_+3A_q">q</code></td>
<td>
<p>optional integers specifying the AR and MA orders of the
fARIMA model, i.e., only applicable when <code>model</code> is <code>"fARIMA"</code>.</p>
</td></tr>
<tr><td><code id="WhittleEst_+3A_start">start</code></td>
<td>
<p>list of starting values; currently necessary for <code>model
      = "fARIMA"</code> and with a reasonable default for <code>model = "fGn"</code>.</p>
</td></tr>
<tr><td><code id="WhittleEst_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if iteration output should be printed.</p>
</td></tr>
<tr><td><code id="WhittleEst_+3A_digits">digits</code>, <code id="WhittleEst_+3A_...">...</code></td>
<td>
<p>optional arguments for <code>print</code> method, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>WhittleEst</code> which is basically a list with components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the function <code><a href="base.html#topic+call">call</a></code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>= input</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>time series length <code>length(x)</code>.</p>
</td></tr>
<tr><td><code>p</code>, <code>q</code></td>
<td>
<p>for &quot;fARIMA&quot;: order of AR and MA parts, respectively.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>numeric 4-column matrix of coefficients
with estimate of the full parameter vector <code class="reqn">\eta</code>, its standard
error estimates, z- and P-values.  This includes the Hurst parameter
<code class="reqn">H</code>.
</p>
</td></tr>
<tr><td><code>theta1</code></td>
<td>
<p>the scale parameter <code class="reqn">\hat{\theta_1}</code>, see
<code><a href="#topic+Qeta">Qeta</a></code>.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the variance-covariance matrix for <code class="reqn">\eta</code>.</p>
</td></tr>
<tr><td><code>periodogr.x</code></td>
<td>
<p>= input (with default).</p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p>the spectral estimate <code class="reqn">\hat{f}(\omega_j)</code>.</p>
</td></tr>
</table>
<p>There is a <code><a href="base.html#topic+print">print</a></code> method, and <code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="stats.html#topic+confint">confint</a></code> or <code><a href="stats.html#topic+vcov">vcov</a></code> methods work as well for
objects of class <code>"WhittleEst"</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, based on Beran's &ldquo;main program&rdquo; in
Beran(1994).
</p>


<h3>References</h3>

<p>Beran, Jan (1994).
<em>Statistics for Long-Memory Processes</em>;
Chapman &amp; Hall.
(Section 6.1, p.116&ndash;119; 12.1.3, p.223 ff)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qeta">Qeta</a></code> is the function minimized by these Whittle
estimators.
</p>
<p><code><a href="#topic+FEXPest">FEXPest</a></code> for an alternative model with Hurst parameter,
also estimated by a &ldquo;Whittle&rdquo; approximate MLE, i.e., a
Whittle's estimator in the more general sense.
</p>
<p>The plot method, <code><a href="#topic+plot.WhittleEst">plot.WhittleEst</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NileMin)
(f.Gn.N  &lt;- WhittleEst(NileMin))                             # H = 0.837
(f.A00.N &lt;- WhittleEst(NileMin, model = "fARIMA", p=0, q=0)) # H = 0.899
confint(f.Gn.N)
confint(f.A00.N)

data(videoVBR)
(f.GN    &lt;- WhittleEst(videoVBR))

## similar {but faster !}:
(f.am00  &lt;- WhittleEst(videoVBR, model = "fARIMA", p=0, q=0))
rbind(f.am00$coef,
      f.GN  $coef)# really similar

f.am11  &lt;- WhittleEst(videoVBR, model = "fARIMA",
                      start= list(H= .5, AR = .5, MA= .5))
f.am11
vcov(f.am11)

op &lt;- if(require("sfsmisc"))
  mult.fig(3, main = "Whittle Estimators for videoVBR data")$old.par  else
  par(mar = c(3,1), mgp = c(1.5, 0.6, 0), mar = c(4,4,2,1)+.1)
plot(f.GN)
plot(f.am00)
plot(f.am11)

et &lt;- as.list(coef(f.am11))
et$AR &lt;- c(et$AR, 0, 0) # two more AR coefficients ..
f.am31  &lt;- WhittleEst(videoVBR, model = "fARIMA", start = et)
## ... warning non nonconvergence,  but "kind of okay":
lines(f.am31, col = "red3") ## drawing on top of ARMA(1,1) above - *small* diff

f.am31 # not all three are "significant"
round(cov2cor(vcov(f.am31)), 3) # and they are highly correlated

et &lt;- as.list(coef(f.am31))
et$AR &lt;- unname(unlist(et[c("AR1", "AR2")]))
f.am21  &lt;- WhittleEst(videoVBR, model = "fARIMA",
                      start = c(et[c("H","AR", "MA")]))
f.am21
lines(f.am21, col = adjustcolor("gold", .4), lwd=4)

par(op)## (reset graphic layout)

##--&gt; ?plot.WhittleEst  for an example using  'periodogr.x'
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
