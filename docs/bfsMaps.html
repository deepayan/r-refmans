<!DOCTYPE html><html><head><title>Help for package bfsMaps</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bfsMaps}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bfsMaps-package'><p>Plotting Switzerland Maps from the Swiss Federal Statistical Office (SFSO)</p></a></li>
<li><a href='#AddWaters'><p> Add Waters to Switzerland Map</p></a></li>
<li><a href='#BfSStamp'><p>Stamp the Current Plot</p></a></li>
<li><a href='#CombinePolygons'><p>Combine Multiple Polygons to One Spatial Polygon</p></a></li>
<li><a href='#d.bfsrg'><p>Swiss Federal Statistical Office (SFSO) Spatial Divisions</p></a></li>
<li><a href='#DownloadBfSMaps'><p>Helps to Get the Map Data</p></a></li>
<li><a href='#GetMap'><p>Load a Map</p></a></li>
<li><a href='#kt'><p>Abbreviations for Swiss Cantons</p></a></li>
<li><a href='#Neighbours'><p>Find All Neighbours of a Regional Object</p></a></li>
<li><a href='#Plot Swiss Regions'><p> Plot Swiss Regions</p></a></li>
<li><a href='#PlotCH'><p>Plot a Map of Switzerland</p></a></li>
<li><a href='#PlotMapDot'><p>Plot a Map and a Dotplot</p></a></li>
<li><a href='#PlotPremReg'><p>Plot Premium Regions CH</p></a></li>
<li><a href='#SwissLocator'><p>Get the Community, District and Canton of a Located Mappoint</p></a></li>
<li><a href='#tkart'><p>Unlocked Environment for Maps</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Plot Maps from Switzerland by Swiss Federal Statistical Office</td>
</tr>
<tr>
<td>Version:</td>
<td>1.99.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-30</td>
</tr>
<tr>
<td>Description:</td>
<td>At the Swiss Federal Statistical Office (SFSO), spatial maps of Switzerland are available free of charge as 'Cartographic bases for small-scale thematic mapping'. This package contains convenience functions to import ESRI (Environmental Systems Research Institute) shape files using the package 'sf' and to plot them easily and quickly without having to worry too much about the technical details.
      It contains utilities to combine multiple areas to one single polygon and to find neighbours for single regions. For any point on a map, a special locator can be used to determine to which municipality, district or canton it belongs.</td>
</tr>
<tr>
<td>Depends:</td>
<td>base, stats, R (&ge; 4.0.0), DescTools</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, sf</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AndriSignorell/bfsMaps/">https://github.com/AndriSignorell/bfsMaps/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AndriSignorell/bfsMaps/issues">https://github.com/AndriSignorell/bfsMaps/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-30 20:30:24 UTC; andri</td>
</tr>
<tr>
<td>Author:</td>
<td>Andri Signorell [aut, cre],
  Juerg Guggenbuehl [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andri Signorell &lt;andri@signorell.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-30 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bfsMaps-package'>Plotting Switzerland Maps from the Swiss Federal Statistical Office (SFSO)
</h2><span id='topic+bfsMaps-package'></span><span id='topic+bfsMaps'></span>

<h3>Description</h3>

<p>This package contains convenience functions for plotting Switzerland maps distributed free of charge by the Swiss Federal Office of Statistics (SFSO). It uses the package <code>'sf'</code> for reading and plotting ESRI (Environmental Systems Research Institute) shapefiles.</p>


<h3>Details</h3>

<p>The generation of spatial images with maps normally requires several steps, which makes the handling for occasional users complex and confusing. Functions on a higher level of abstraction simplify the daily work. The purpose is to allow the user to get to the desired map as quickly and easily as possible.<br />
The idea behind the functions is to load the specific map, assign the desired color to the regions and create the plot. The arguments are kept  straightforward, what is needed is a vector with the specific ids of the regions and an equally sized vector for the colors.
<br /> There are specific functions for the most important spatial divisions in Switzerland.
Cantons can be plotted with <code><a href="#topic+PlotKant">PlotKant</a>()</code>, political municipalities with  <code><a href="#topic+PlotPolg">PlotPolg</a>()</code>, large regions with  <code><a href="#topic+PlotGreg">PlotGreg</a>()</code> and districts with  <code><a href="#topic+PlotBezk">PlotBezk</a>()</code>.
Lakes and rivers in multiple categories can be added to existing images with  <code><a href="#topic+AddLakes">AddLakes</a>()</code>,   <code><a href="#topic+AddRivers">AddRivers</a>()</code> or <code><a href="#topic+AddWaters">AddWaters</a>()</code>.
</p>
<p>Before the maps can be drawn, a few preparations must be made:
</p>

<ul>
<li><p> download the maps following the link 'Swiss Federal Office of Statistics - Base maps' (below) and unzip them into a folder
</p>
</li>
<li><p>declare the location as <code>options(bfsMaps.base = "//path_to_my_maps/")</code> 
</p>
</li>
<li><p>names and shortnames of the maps are stored in a file named <code>'maps.csv'</code>, which can be stored either in the <code>'bfsMaps.base'</code> folder or alternatively in the packages installation folder. <br /> An example file for the last map edition ('ThemaKart map boundaries - Set 2023') is included in the package and can be found in the packages <code>.../extdata</code> folder. If you are using a different edition, you have to adjust the file accordingly. 
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Andri Signorell &lt;andri@signorell.net&gt;
</p>


<h3>References</h3>

<p>Swiss Federal Office of Statistics - Base maps: <a href="https://www.bfs.admin.ch/bfs/de/home/statistiken/regionalstatistik/kartengrundlagen.html">https://www.bfs.admin.ch/bfs/de/home/statistiken/regionalstatistik/kartengrundlagen.html</a>
</p>
<p>Swiss Federal Office of Statistics - Spatial divisions: <a href="https://www.agvchapp.bfs.admin.ch/de/typologies/query">https://www.agvchapp.bfs.admin.ch/de/typologies/query</a>
</p>
<p>Official directory of towns and cities (PLZ): <a href="https://www.swisstopo.admin.ch/de/geodata/amtliche-verzeichnisse/ortschaftenverzeichnis.html">https://www.swisstopo.admin.ch/de/geodata/amtliche-verzeichnisse/ortschaftenverzeichnis.html</a>
</p>
<p>Swiss Premium Regions: <a href="https://www.priminfo.admin.ch/">https://www.priminfo.admin.ch/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note:
#   The examples can not be run without the map data being installed before!

try( {

# PlotKant simply tasks for the id and the color of the spatial region
# labels can be directly placed
PlotKant(id=c("ZH", "FR"), col=c("yellow","limegreen"), label=TRUE)
PlotKant(id="GR", col="orange", label=TRUE, add=TRUE)
AddLakes()
title("Switzerland with some cantons")
# mark the national border
PlotCH(col=NA, add=TRUE, lwd=2)


# The maps have all a general area and a vegetational area
PlotKant(c("VS", "BE"), SetAlpha(c("yellow","limegreen"),.50),
         col.vf=c("yellow","limegreen"), label=TRUE)


# The function returns the centroid points of the objects, which can be used
# to label the plot afterwards
xy &lt;- PlotGreg(c(3,6), SetAlpha(c("plum1", "lightslateblue"),.50),
               col.vf=c("plum1", "lightslateblue"), labels=NA)
AddLakes()
BoxedText(xy$x, xy$y, labels = c("here", "there"), border=NA,
          col = SetAlpha("white", 0.8))


# Plot political communities
PlotPolg(border="grey85" )
PlotBezk(border="grey55", add=TRUE  )
PlotKant(border="black", lwd=1, add=TRUE)
AddLakes()
AddRivers()

# Cantonal capitals
points(sf::st_coordinates(GetMap("stkt.pnt")$geometry),
       pch=21, col="grey", bg="red")



# Display vegetational area
PlotCH(col="wheat3", col.vf="wheat", border="wheat3", main="CH Vegetation Area")
AddRivers()
AddLakes()
PlotKant(col=NA, border="wheat4", add=TRUE, lwd=1)


# Use extended spatial divisions (language regions)
cols &lt;- c("peachpuff2","gainsboro","honeydew3","lightgoldenrodyellow")
PlotPolg(d.bfsrg$gem_id, col=cols[d.bfsrg$sprgeb_c], border="grey70",
         main="Language CH" )
PlotBezk(d.bfsrg$bezk_c, col=NA, border="grey40", add=TRUE)
AddLakes(col="lightsteelblue1", border="lightskyblue" )
legend(x="topleft", legend=c("german", "french","italian","romanche"), bg="white",
       cex=0.8, fill= cols )


# Swiss premiumregions demonstrating combinations of polygons
PlotCH(col="white", main="Premiumregions CH")

plot(CombinePolg(id=d.bfsrg$gem_id, g=d.bfsrg$preg_c),
     col=c("white","olivedrab4","olivedrab3","olivedrab2"), add=TRUE)

legend(x="topleft", fill=c("white","olivedrab4","olivedrab3","olivedrab2"), cex=0.8,
       legend=c("Region 0","Region 1","Region 2","Region 3") )

PlotKant(col=NA, border="grey40", add=TRUE)
AddLakes()

# Cities
cols &lt;- as.vector(sapply(c(hred, hblue, hyellow),
                         SetAlpha, alpha=c(1, 0.7, 0.5)))
old &lt;- Mar(right=20)
PlotPolg(id=d.bfsrg$gem_id, col=cols[as.numeric(d.bfsrg$gem_typ9_x)],
         border="grey70")
AddLakes(col="grey90", border="grey50")
PlotKant(add=TRUE, col=NA, border="grey30")
legend(x=2854724, y=1292274, fill=cols, border=NA, box.col=NA,
       y.intersp=c(1,1,1, 1.1,1.05,1.05, 1.1,1.07,1.07),
       legend=StrTrunc(levels(d.bfsrg$gem_typ9_x), 50),
       xjust=0, yjust=1, cex=0.8, xpd=NA)
par(mar=old)


# Degree of urbanisation
PlotPolg(col=SetAlpha(c(hred, hblue, hyellow), 0.8)[as.numeric(d.bfsrg$degurba_x)],
         main="Degree of Urbanisation 2022")
PlotKant(add=TRUE, border="grey30")
AddLakes(col = "grey90", border = "grey50")


# get cantons' area
area &lt;- sf::st_area(GetMap("kant.map")) / 1E6

# plot cantons
xy &lt;- PlotKant(col=colorRampPalette(c("white", "steelblue"),
                                    space = "rgb")(720)[trunc(area)/10],
               main=expression(paste( "Cantons' area in ", km^2)) )
AddLakes(col="grey90", border="grey60")
text(xy, labels=round(area,1), cex=0.7)


kant.gr &lt;- GetMap("kant.map") |&gt; (\(.) .[.$name=="Graubünden", "geometry"])()
# prepare plot
plot(kant.gr, asp=1, axes=FALSE, xlab="", ylab="",
     main="Beautiful Grisons", col="steelblue", lwd=2)

loctext &lt;- function(x, y, text){
  points(x, y, pch=15, col="lightgrey" )
  text(x, y, text, adj=c(0,0.5), col="white", font=2)
}
# the new swiss coordinates LV95 are:   x_new = x_old + 2e6, y_new = y_old + 1e6
loctext(2782783, 1185993,"  Davos")
loctext(2761412, 1176112,"  Valbella")
loctext(2784192, 1152424,"  St. Moritz")
loctext(2714275, 1175027,"  Rabius")


# Swiss metropolitan areas
cols &lt;- c("royalblue1","red","bisque3","yellow","orange","beige")
# we have to prepare the background here, for some reasons...
PlotCH(col="darkolivegreen1", border="grey", lwd=2, main="Swiss metropolitan areas")
# require other map
metr.map &lt;- GetMap("metr.map")
plot(metr.map$geometry, add=TRUE, border="grey60", col=cols)
AddLakes(col="grey90", border="grey70")
legend( x="topleft", legend=c("Ländliche Gemeinde", metr.map$name),
        fill=c("darkolivegreen1", cols),
        bg="white", cex=0.8, xpd=TRUE )


# We can find the neighbor cantons, here for the canton Glarus (id=8)
nbs &lt;- Neighbours(map=GetMap("kant.map"), id=8)
PlotKant(id = c(8, nbs), col=c("steelblue", rep("grey80", length(nbs))),
         main="Find Neighbours")



})</code></pre>

<hr>
<h2 id='AddWaters'> Add Waters to Switzerland Map
</h2><span id='topic+AddLakes'></span><span id='topic+AddWaters'></span><span id='topic+AddRivers'></span>

<h3>Description</h3>

<p>Add lakes and rivers to an already existing Switzerland map.
The lakes are defined in 2 categories 1 and 2, whereas category 1 contains the bigger ones, category 2 the smaller ones.<br />
The rivers are defined in 5 categories 1:5, wheras category 1 contains the largest rivers, category 5 the smallest ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddWaters(lakes = 1, rivers = 1:5, col = NULL,
          border = "lightskyblue3", lwd = 1, ...)

AddLakes(categ = 1:2, col = "lightskyblue1", border = "lightskyblue3",
         lwd = 1, ...)

AddRivers(categ = 1:5, col = "lightskyblue3", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddWaters_+3A_categ">categ</code></td>
<td>

<p>category of the lakes (<code>1, 2</code>) and rivers (<code>1:5</code>) . <code>1</code> are the bigest waters, <code>2</code>, resp. <code>5</code> the smallest ones.
</p>
</td></tr>
<tr><td><code id="AddWaters_+3A_lakes">lakes</code></td>
<td>
<p>the category for the lakes</p>
</td></tr>
<tr><td><code id="AddWaters_+3A_rivers">rivers</code></td>
<td>
<p>the category for the rivers</p>
</td></tr>
<tr><td><code id="AddWaters_+3A_col">col</code></td>
<td>
<p>color of the lakes, defaults to <code>"lightskyblue1"</code>
</p>
</td></tr>
<tr><td><code id="AddWaters_+3A_border">border</code></td>
<td>
<p>bordercolor of the lakes, defaults to <code>"lightskyblue3"</code>
</p>
</td></tr>
<tr><td><code id="AddWaters_+3A_lwd">lwd</code></td>
<td>
<p>linewidth of border
</p>
</td></tr>
<tr><td><code id="AddWaters_+3A_...">...</code></td>
<td>
<p>the dots are passed to the plot command
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>AddWaters()</code> is a wrapper with sensible defaults. If the color is not provided it will be set to a less intense tint of the border.
</p>
<p>Lakes are defined in the original files:
</p>

<ul>
<li><p> 00_TOPO/K4_seenyyyymmdd/c_shp/k4seenyyyymmdd11_ch2007Poly.shp
</p>
</li>
<li><p> 00_TOPO/K4_seenyyyymmdd/c_shp/k4seenyyyymmdd22_ch2007Poly.shp
</p>
</li></ul>

<p>Rivers are defined in the files:
</p>

<ul>
<li><p> 00_TOPO/K4_flusyyyymmdd/c_shp/k4flusyyyymmdd11_ch2007.shp
</p>
</li>
<li><p> 00_TOPO/K4_flusyyyymmdd/c_shp/k4flusyyyymmdd22_ch2007.shp
</p>
</li>
<li><p> 00_TOPO/K4_flusyyyymmdd/c_shp/k4flusyyyymmdd33_ch2007.shp
</p>
</li>
<li><p> 00_TOPO/K4_flusyyyymmdd/c_shp/k4flusyyyymmdd44_ch2007.shp
</p>
</li>
<li><p> 00_TOPO/K4_flusyyyymmdd/c_shp/k4flusyyyymmdd55_ch2007.shp
</p>
</li></ul>

<p>For accessing the meta data, we can simply use<br />
</p>
<pre>  lake &lt;- GetMap("see1.map")
  head(lake)
</pre>


<h3>Value</h3>

<p>None</p>


<h3>Author(s)</h3>

<p>Andri Signorell &lt;andri@signorell.net</p>


<h3>Examples</h3>

<pre><code class='language-R'>try({
  PlotKant()
  AddWaters(lakes=1, rivers=1, border="grey")
})

try({
  PlotKant()
  AddLakes(categ=1)      # adds the lakes of category 1 to the map
  AddRivers(categ=1:3)   # adds the rivers of category 1:3 to the map
})
</code></pre>

<hr>
<h2 id='BfSStamp'>Stamp the Current Plot
</h2><span id='topic+BfSStamp'></span>

<h3>Description</h3>

<p>Stamp the current plot in the lower right corner with the copyright of the BfS-maps:<br /><br /> <b>&quot;Kartengrundlage: (c) BFS, ThemaKart, 20xx&quot;<br /><br /></b>
This copyright is mandatory for all maps in public publications. The default coodinates are chosen by default in the bottomright corner of a Swiss map, but can be redefined by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BfSStamp(xy = NULL,
         year_n = getOption("bfsMaps.year", Year(Today())),
         txt = NULL, cex = 0.6, adj = c(1,0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BfSStamp_+3A_xy">xy</code></td>
<td>
<p>the coordinates for the text to be placed.</p>
</td></tr>
<tr><td><code id="BfSStamp_+3A_year_n">year_n</code></td>
<td>
<p>the year for the compulsory BfS copyright message.</p>
</td></tr>
<tr><td><code id="BfSStamp_+3A_txt">txt</code></td>
<td>
<p>the text to be used.</p>
</td></tr>
<tr><td><code id="BfSStamp_+3A_cex">cex</code></td>
<td>
<p>the character extension for the text (default is 0.6)</p>
</td></tr>
<tr><td><code id="BfSStamp_+3A_adj">adj</code></td>
<td>
<p>one or two values in [0, 1] which specify the x (and optionally y) adjustment ('justification') of the labels, with 0 for left/bottom, 1 for right/top, and 0.5 for centered. On most devices values outside [0, 1] will also work. See below.</p>
</td></tr>
<tr><td><code id="BfSStamp_+3A_...">...</code></td>
<td>
<p>the dots are passed to the function <code><a href="graphics.html#topic+text">text</a>()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default value for the year can be entered as option in the .Rprofile file.
bfsMaps.year=2022 would set the default to 2022.</p>


<h3>Value</h3>

<p>None</p>


<h3>Author(s)</h3>

<p>Andri Signorell &lt;andri@signorell.net&gt;
</p>


<h3>See Also</h3>

<p><code><a href="DescTools.html#topic+Stamp">Stamp</a>()</code>
</p>

<hr>
<h2 id='CombinePolygons'>Combine Multiple Polygons to One Spatial Polygon
</h2><span id='topic+CombinePolygons'></span><span id='topic+CombineKant'></span><span id='topic+CombinePolg'></span>

<h3>Description</h3>

<p>The function combines polygons to one single spatial polygon object, according to the ID vector that specifies which input polygons belong to which output polygon. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CombinePolygons(map, g)

CombineKant(id, g, map = GetMap("kant.map"))
CombinePolg(id, g, map = GetMap("polg.map"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CombinePolygons_+3A_map">map</code></td>
<td>
<p>the map containing the regions to be combined.
</p>
</td></tr>
<tr><td><code id="CombinePolygons_+3A_id">id</code></td>
<td>
<p>the id of the cantons or communities to be aggregated.</p>
</td></tr>
<tr><td><code id="CombinePolygons_+3A_g">g</code></td>
<td>
<p>a vector defining the assignment of the elements to the output polygons to be created. It may contain <code>NA</code> values for input objects not included in the union.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an aggregated spatial polygons object named with the aggregated IDs values in their sorting order; see the ID values of the output object to view the order.</p>


<h3>Author(s)</h3>

<p>Juerg Guggenbuehl, Andri Signorell &lt;andri@signorell.net&gt;
</p>


<h3>See Also</h3>

<p><code><a href="sf.html#topic+st_union">st_union</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(DescTools)

try( {

# Representation of the language areas in CH combined via cantons
# by majority per canton
tkt &lt;- table(d.bfsrg$kt_c, d.bfsrg$sprgeb_x)
grp &lt;- unique(d.bfsrg$sprgeb_x)[apply(tkt, 1, which.max)]

# combine and plot cantons
plot(CombineKant(rownames(tkt), grp), col=SetAlpha(c(horange, hyellow, hecru), 0.8),
     border="grey40", main="Languages in CH")

# copyright is mandatory for these SFSO maps
BfSStamp()
# waters make the maps more realistic ...
AddLakes(col = "grey80", border = "grey40")

})</code></pre>

<hr>
<h2 id='d.bfsrg'>Swiss Federal Statistical Office (SFSO) Spatial Divisions
</h2><span id='topic+d.bfsrg'></span>

<h3>Description</h3>

<p>The Swiss Federal Statistical Office (SFSO) produces, publishes and maintains various spatial divisions for Switzerland. A dataset for the year 2022 is part of the package.
</p>
<p>Granularity is the community level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("d.bfsrg")</code></pre>


<h3>Format</h3>

<p>A data frame with 2148 observations on the following 27 variables.
</p>

<dl>
<dt><code>gem_id</code></dt><dd><p>community id, a numeric vector</p>
</dd>
<dt><code>gemeinde_x</code></dt><dd><p>community name, factor with the names of the communities as levels (to ensure the correct order, if needed).</p>
</dd>
<dt><code>kt_c</code></dt><dd><p>canton id, numeric vector</p>
</dd>
<dt><code>kt_x</code></dt><dd><p>canton abbreviation, a factor with levels <code>ZH</code> <code>BE</code> <code>LU</code> <code>UR</code> <code>SZ</code> <code>OW</code> <code>NW</code> <code>GL</code> <code>ZG</code> <code>FR</code> <code>SO</code> <code>BS</code> <code>BL</code> <code>SH</code> <code>AR</code> <code>AI</code> <code>SG</code> <code>GR</code> <code>AG</code> <code>TG</code> <code>TI</code> <code>VD</code> <code>VS</code> <code>NE</code> <code>GE</code> <code>JU</code></p>
</dd>
<dt><code>kt_bez_x</code></dt><dd><p>a factor with levels <code>Zuerich</code> <code>Bern</code> <code>Luzern</code> <code>Uri</code> <code>Schwyz</code> <code>Obwalden</code> <code>Nidwalden</code> <code>Glarus</code> <code>Zug</code> <code>Fribourg</code> <code>Solothurn</code> <code>Basel-Stadt</code> <code>Basel-Landschaft</code> <code>Schaffhausen</code> <code>Appenzell Ausserrhoden</code> <code>Appenzell Innerrhoden</code> <code>St. Gallen</code> <code>Graubuenden</code> <code>Aargau</code> <code>Thurgau</code> <code>Ticino</code> <code>Vaud</code> <code>Wallis</code> <code>Neuchatel</code> <code>Geneve</code> <code>Jura</code></p>
</dd>
<dt><code>bezk_c</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>bezk_x</code></dt><dd><p>a factor with levels <code>Bezirk Affoltern</code> <code>Bezirk Andelfingen</code> <code>Bezirk Buelach</code> <code>Bezirk Dielsdorf</code> <code>Bezirk Hinwil</code> ...</p>
</dd>
<dt><code>greg_c</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>greg_x</code></dt><dd><p>a factor with levels <code>Region lemanique</code> <code>Espace Mittelland</code> <code>Nordwestschweiz</code> <code>Zuerich</code> <code>Ostschweiz</code> <code>Zentralschweiz</code> <code>Ticino</code></p>
</dd>
<dt><code>aggl_c</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>aggl_x</code></dt><dd><p>a factor with levels <code>keine Agglomerationsgemeinde und keine Kerngemeinde ausserhalb von Agglomerationen</code> <code>Winterthur</code> <code>Zuerich</code> <code>Bern</code> </p>
</dd>
<dt><code>aggl_grp_c</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>aggl_grp_x</code></dt><dd><p>a factor with levels <code>keine Agglomerationszugehoerigkeit</code> <code>&gt;= 500000 Einwohner/innen</code> <code>250000 - 499999 Einwohner/innen</code> <code>100000 - 249999 Einwohner/innen</code> </p>
</dd>
<dt><code>stadt_char_c</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>stadt_char_x</code></dt><dd><p>a factor with levels <code>Laendliche Gemeinde ohne staedtischen Charakter</code> <code>Agglomerationskerngemeinde (Kernstadt)</code> <code>Agglomerationskerngemeinde (Hauptkern)</code> <code>Agglomerationskerngemeinde (Nebenkern)</code> <code>Agglomerationsguertelgemeinde</code> <code>Mehrfach orientierte Gemeinde</code> <code>Kerngemeinde ausserhalb Agglomerationen</code></p>
</dd>
<dt><code>stadtland_c</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>stadtland_x</code></dt><dd><p>a factor with levels <code>stadt</code> <code>agglo</code> <code>land</code></p>
</dd>
<dt><code>gem_typ9_c</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>gem_typ9_x</code></dt><dd><p>a factor with 9 levels</p>
</dd>
<dt><code>gem_typ25_c</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>gem_typ25_x</code></dt><dd><p>a factor with 25 levels, definig types of communities</p>
</dd>
<dt><code>degurba_c</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>degurba_x</code></dt><dd><p>a factor with levels <code>dense</code> <code>intermediate</code> <code>thin</code></p>
</dd>
<dt><code>sprgeb_c</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>sprgeb_x</code></dt><dd><p>a factor with levels <code>d</code> <code>f</code> <code>i</code> <code>r</code></p>
</dd>
<dt><code>preg_c</code></dt><dd><p>a numeric vector containing the category of the premium region (0:3).</p>
</dd>
<dt><code>preg_x</code></dt><dd><p>a factor with levels <code>ZH1, ZH2, ZH3, BE1, BE2, ...</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>head(kt &lt;- unique(d.bfsrg[,c("kt_c","kt_x","kt_bez_x")][order(d.bfsrg$kt_c),]))
head(bezk &lt;- unique(d.bfsrg[,c("bezk_c","bezk_x","kt_x")][order(d.bfsrg$bezk_c),]))
</code></pre>

<hr>
<h2 id='DownloadBfSMaps'>Helps to Get the Map Data
</h2><span id='topic+DownloadBfSMaps'></span>

<h3>Description</h3>

<p>Helperfunction to download the mapdata and unzip them into a user defined location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DownloadBfSMaps(url = "https://dam-api.bfs.admin.ch/hub/api/dam/assets/21245514/master",
                path = paste0(path.expand("~"), "/MapData"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DownloadBfSMaps_+3A_url">url</code></td>
<td>
<p>the url for the data (might outdate and must then be redefined).
</p>
</td></tr>
<tr><td><code id="DownloadBfSMaps_+3A_path">path</code></td>
<td>
<p>the path where the data are to be installed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is convenient to not be forced to download the data by oneself. This function can be helpful.
</p>


<h3>Value</h3>

<p>the option entry is returned invisibly
</p>


<h3>Author(s)</h3>

<p>Andri Signorell &lt;andri@signorell.net&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

DownloadBfSMaps()
# enter the returned option
options(bfsMaps.base="*** your map folder ***")

library(bfsMaps)
PlotKant("ZH", "blue")

## End(Not run)
</code></pre>

<hr>
<h2 id='GetMap'>Load a Map
</h2><span id='topic+GetMap'></span>

<h3>Description</h3>

 <p><code>GetMap</code> directly looks up the path of a map based on a shortcut name or number, loads the map from this location and returns the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetMap(name_x, basedir = getOption("bfsMaps.base",
       default = file.path(find.package("bfsMaps"), "extdata")),
       crs = 2056)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetMap_+3A_name_x">name_x</code></td>
<td>
<p>the name of a map, currently supported are <code>"kant.map"</code>, <code>"bezk.map"</code>, <code>"polg.map"</code>, <code>"greg.map"</code>, <code>"ch.map"</code> or any number referring to a row in the 'maps.csv' file.</p>
</td></tr>
<tr><td><code id="GetMap_+3A_basedir">basedir</code></td>
<td>
<p>the root directory for the maps to reside. bfsMaps by default looks for the mapfiles in its install location in the extdata directory. The <code>basedir</code> can be set as an option too.</p>
</td></tr>
<tr><td><code id="GetMap_+3A_crs">crs</code></td>
<td>
<p>Coordinate reference system (default 2056) for the map, if not set to <code>NA</code> the map will be transformed to this crs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Loading the cards no longer causes performance problems and can thus be performed directly.
</p>


<h3>Value</h3>

<p>the map object
</p>


<h3>Author(s)</h3>

<p>Andri Signorell &lt;andri@signorell.net&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>try( {

# use map containing Swiss metropolitan regions
mymap &lt;- GetMap("metr.map")$geometry
PlotCH()
plot(mymap, col=Pal("Helsana"), add=TRUE, border=NA)

})</code></pre>

<hr>
<h2 id='kt'>Abbreviations for Swiss Cantons
</h2><span id='topic+kt'></span>

<h3>Description</h3>

<p>Abbreviations for Swiss Cantons in the correct order of BfS-ID. The motivation to define this constant is, that the ids in the official definition do not follow the alphabetic order of the canton names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kt</code></pre>


<h3>Format</h3>

<p>The format is:
Factor w/ 26 levels &quot;ZH&quot;,&quot;BE&quot;,&quot;LU&quot;,..: 1 2 3 4 5 6 7 8 9 10 ...
</p>

<hr>
<h2 id='Neighbours'>Find All Neighbours of a Regional Object
</h2><span id='topic+Neighbours'></span>

<h3>Description</h3>

<p>Finding all directly adjacent neighbours of a regional unit is not trivial. For a list of regional units, this function searches for the corresponding Neighbours and returns the results as a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Neighbours(map, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Neighbours_+3A_map">map</code></td>
<td>
<p>the name of the map
</p>
</td></tr>
<tr><td><code id="Neighbours_+3A_id">id</code></td>
<td>
<p>vector of ids for which the Neighbours are to be found. When it's left to <code>NULL</code> (default), the neighbours for all the polygons of the map will be returned.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors of ids for the neighbours of each region in the map.
</p>


<h3>Author(s)</h3>

<p>Andri Signorell &lt;andri@signorell.net&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>try( {

nbs &lt;- Neighbours(GetMap("kant.map"), kt_id &lt;- 18)
PlotKant(c(kt_id, nbs), col=c("red", rep("green", length(nbs))) )

# works as well for communities and for vector of ids
nbs &lt;- Neighbours(GetMap("polg.map"), polg_id &lt;- c(3851, 3352))
PlotPolg(c(polg_id, unlist(nbs)),
         col=c(rep("red", 2), rep("green", length(unlist(nbs)))))

})</code></pre>

<hr>
<h2 id='Plot+20Swiss+20Regions'> Plot Swiss Regions</h2><span id='topic+PlotKant'></span><span id='topic+PlotGreg'></span><span id='topic+PlotPolg'></span><span id='topic+PlotBezk'></span><span id='topic+PlotMSRe'></span>

<h3>Description</h3>

<p>The function plots a map of Switzerland overlayed with different types of regions. Included are greater regions ('Grossregionen'), MS regions ('mobilité spatiale'), cantons, districts and political communities. The single regions can be given a defined color, whereas the color need not be defined for all.<br />
The vegetational area is the spatial area where people live, excluding mountains and further uninhabitable area. The vegetational area can be drawn over an already existing map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotGreg(id = NULL, col = NA, pbg = "white", main = "",
         border = "grey", lwd = 1, col.vf = NA, border.vf = NA, labels = NULL,
         tmtxt = TRUE, add = FALSE, map_x = "greg.map", ...)

PlotKant(id = NULL, col = NA, pbg = "white", main = "",
         border = "grey", lwd = 1, col.vf = NA, border.vf = NA, labels = NULL,
         tmtxt = TRUE, add = FALSE, map_x = "kant.map", ...)

PlotMSRe(id = NULL, col = NA, pbg = "white", main = "",
         border = "grey", lwd = 1, col.vf = NA, border.vf = NA, labels = NULL,
         tmtxt = TRUE, add = FALSE, map_x = "msre.map", ...)

PlotBezk(id = NULL, col = NA, pbg = "white", main = "",
         border = "grey", lwd = 1, col.vf = NA, border.vf = NA, labels = NULL,
         tmtxt = TRUE, add = FALSE, map_x = "bezk.map", ...)

PlotPolg(id = NULL, col = NA, pbg = "white", main = "",
         border = "grey", lwd = 1, col.vf = NA, border.vf = NA, labels = NULL,
         tmtxt = TRUE, add = FALSE, map_x = "polg.map", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_id">id</code></td>
<td>
<p>vector of region ids. All types of regions can be addressed via their numeric ID, cantons can additionally be identified with their abbreviation:
<code>"AG"</code>, <code>"AI"</code>, <code>"AR"</code>, <code>"BE"</code>, <code>"BL"</code>, <code>"BS"</code>, <code>"FR"</code>, <code>"GE"</code>, <code>"GL"</code>, <code>"GR"</code>, <code>"JU"</code>, <code>"LU"</code>, <code>"NE"</code>,
<code>"NW"</code>, <code>"OW"</code>, <code>"SG"</code>, <code>"SH"</code>, <code>"SO"</code>, <code>"SZ"</code>, <code>"TG"</code>, <code>"TI"</code>, <code>"UR"</code>, <code>"VD"</code>, <code>"VS"</code>, <code>"ZG"</code>, <code>"ZH"</code>
</p>
</td></tr>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_col">col</code></td>
<td>
<p>vector of colors, defining the colors of the region area.
</p>
</td></tr>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_pbg">pbg</code></td>
<td>
<p>color for the plot background.
</p>
</td></tr>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_main">main</code></td>
<td>
<p>main title in the plot.
</p>
</td></tr>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_border">border</code></td>
<td>
<p>vector of colors for region borders. Default is <code>"grey30"</code>.
</p>
</td></tr>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_lwd">lwd</code></td>
<td>
<p>linewidth for region borders.
</p>
</td></tr>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_col.vf">col.vf</code></td>
<td>
<p>vector of colors for the vegetational. If set to <code>NA</code> (default)
the vegetational area will not be drawn.
</p>
</td></tr>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_border.vf">border.vf</code></td>
<td>
<p>color of borders for the vegetational area. If set to <code>NA</code> (default)
the borders of the vegetational area will not be drawn.
</p>
</td></tr>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_labels">labels</code></td>
<td>
<p>optional labels to be placed in the map, by default the centroids of the map is used for that.</p>
</td></tr>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_tmtxt">tmtxt</code></td>
<td>
<p>logical, should the copyright text be displayed. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_add">add</code></td>
<td>
<p>default <code>FALSE</code>; if <code>TRUE</code>, add to existing plot.</p>
</td></tr>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_map_x">map_x</code></td>
<td>
<p>the name ot the path of a map to be used. This is convenient, if we want to plot a newer map with the logic of this function.</p>
</td></tr>
<tr><td><code id="Plot+2B20Swiss+2B20Regions_+3A_...">...</code></td>
<td>
<p>the dots are passed to the plot command.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The different functions all use the same core code, but use different default maps. The default maps are named: <code>"greg.map"</code>, <code>"msre.map"</code>, <code>"kant.map"</code>, <code>"bezk.map"</code> and <code>"polg.map"</code>.
</p>
<p><code>PlotGreg</code> uses a map for Swiss regions (Grossregionen), as defined in <code>greg.map@data</code>. The regions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
			1</td><td style="text-align: left;">  Region lémanique</td>
</tr>
<tr>
 <td style="text-align: left;">
			2</td><td style="text-align: left;">  Espace Mittelland</td>
</tr>
<tr>
 <td style="text-align: left;">
			3</td><td style="text-align: left;">  Nordwestschweiz</td>
</tr>
<tr>
 <td style="text-align: left;">
			4</td><td style="text-align: left;">  Zürich</td>
</tr>
<tr>
 <td style="text-align: left;">
			5</td><td style="text-align: left;">  Ostschweiz</td>
</tr>
<tr>
 <td style="text-align: left;">
			6</td><td style="text-align: left;">  Zentralschweiz</td>
</tr>
<tr>
 <td style="text-align: left;">
			7</td><td style="text-align: left;">  Ticino
			</td>
</tr>

</table>

<p>The list of MS regions with names and ids can be found in <code>d.bfsrg</code>:<br />
<code>unique(d.bfsrg[, c("ms_reg_c", "ms_reg_x", "ms_typ_c", "ms_typ_x")])</code>
</p>
<p>The abbreviations of the cantons are compiled in the variable <code>kt</code>. More details can be extracted from<br /> <code>unique(d.bfsrg[,c("kt_c", "kt_x", "kt_bez_x")])</code>
</p>
<p>Districts (german: 'Bezirke') are associations of communities. The district id internally consists of the canton nr (1 or 2 digits) and a 2-digits 'Bezirk-nr'. So is 'Hinwil' with the district nr '51' the 5th district in Zurich (canton '1').<br />
The list of all districts is given in <code>d.bfsrg</code>: <br />
<code>unique(d.bfsrg[, c("bezirk_c", "kt_c", "bezirk_x", "kt_x")])</code>
</p>
<p>The list of all political communities is given in <code>d.bfsrg</code>:<br />
<code>d.bfsrg[,c("bfs_nr", "gemeinde_name_x", "kt_x")]</code>
</p>
<p>All the regions can also be accessd and plotted by manually loading the maps and use the generic <code>plot</code> function.
</p>
<pre>
cant &lt;- GetMap("kant.map")
plot(cant)
</pre>
<p>There are also dedicated maps for all regions, which contain only the coordinates of the regions' centroids. They can be accessed using according mapname with the extension <code>.pnt</code>, e.g. for the cantons <code>GetMap("kant.pnt")</code>.
</p>
<p>To simplify the description, the function returns the center coordinates. These can then be used with the function <code>text()</code>.
</p>


<h3>Value</h3>

<p>A list containing x and y components which are the centroids of the plotted spatial units.</p>


<h3>Author(s)</h3>

<p>Andri Signorell &lt;andri@signorell.net&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PlotCH">PlotCH</a></code>, <code><a href="#topic+d.bfsrg">d.bfsrg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note:
#   The examples can not be run without having the map data installed before!
try( {

# define the ids for the cantons and the according colors
PlotKant(id=c("GR","ZH","VS"), col=c("lightgrey","lightblue","lightsalmon"))

require(DescTools)
# get some percentage values...
some_p &lt;- c(AG=0.48,AI=0.47,AR=0.4,BE=0.48,BL=0.44,BS=0.4,FR=0.48,GE=0.28,GL=0.51,
           GR=0.4,JU=0.61,LU=0.49,NE=0.54,NW=0.43,OW=0.58,SG=0.45,SH=0.36,SO=0.45,
           SZ=0.39,TG=0.47,TI=0.46,UR=0.4,VD=0.46,VS=0.45,ZG=0.41,ZH=0.41)

# and a color ramp from white to hred
cols &lt;- colorRampPalette(c("white", hred))(100)

PlotKant(id=names(some_p), col=FindColor(some_p, cols=cols), main="ECO in CH")
ColorLegend(x="left", inset=-0.01, cols=cols,
            labels=formatC((seq(0, 1, .2)), digits=2, format="f"),
            width=12000, frame="grey", cex=0.8 )


# greater regions
PlotGreg(col=colorRampPalette(c("blue", "white", "red"), space = "rgb")(7),
         main="Greater Regions CH")

PlotGreg(id = c(2,4,7), col = c("bisque","darkolivegreen1","khaki"),
         main="Espace Mittelland, Zurich und Ticino")
AddLakes(col="grey90", border="darkgrey")

xy &lt;- sf::st_coordinates((greg.pnt &lt;- GetMap("greg.pnt"))$geometry[c(2,4,7)])
text(xy[,1], xy[,2], greg.pnt$name[c(2,4,7)], col="black")


# plot the districts
bezk.map &lt;- GetMap("bezk.map")
head(bezk.map)

PlotBezk(id=311:316, col=colorRampPalette(c("red", "white", "blue"), space = "rgb")(5))

PlotBezk(id=bezk.map[[1]], col=rainbow(147), main="Districts in CH")

cols &lt;- c(y=rgb(255,247,174,max=255), o=rgb(251,208,124,max=255),
          v=rgb(228,201,224,max=255), b=rgb(211,230,246,max=255),
          g=rgb(215,233,205,max=255), r=rgb(244,182,156,max=255),
          p=rgb(255,248,236,max=255))

# display MS regions
# start with a cantons map

# start with a cantons map
PlotKant(1:26,col=cols[c("g","g","o","r","v","b","y","g","y","o",
                    "v","o","y","v","y","v","o","y","r","b",
                    "v","y","b","r","v","b")],
         border="grey20", lwd=1, pbg=cols["p"],
         main="106 MS-Regions")

# add the MS regions borders
xy &lt;- PlotMSRe(add=TRUE, border="grey60")

# reoutline the cantons, as they have been overplotted in the step before
PlotKant(1:26, add=TRUE, border="grey30", lwd=1)

# add the waters
AddLakes(1:2, col=rgb(235, 247, 253, max=255), border=rgb(0,166,235, max=255))
AddRivers(1:5, col=rgb(0, 166, 235, max=255))

# ... and finally add labels
text(x=xy$x, y=xy$y, GetMap("msre.map")$id, cex=0.6)


# plot political communities

# plot only the first 10 elements
PlotPolg(id=1:10,
         col=colorRampPalette(c("red", "white", "blue"), space = "rgb")(10))

# plot all communities
PlotPolg(id=(map &lt;- GetMap("polg.map"))$id, col=rainbow(nrow(map)),
         main="Political communities in CH")

})</code></pre>

<hr>
<h2 id='PlotCH'>Plot a Map of Switzerland
</h2><span id='topic+PlotCH'></span>

<h3>Description</h3>

<p>Simple map plot of Switzerland following the borders valid since 1848.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotCH(col = NA, main = "", col.vf = NA,
       border = "grey", border.vf = NA, lwd = 1,
       tmtxt = TRUE, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotCH_+3A_col">col</code></td>
<td>
<p>vector of colors, defining the colors of the cantons.<br />
Note: <code>NA</code>s are recoded as white.
</p>
</td></tr>
<tr><td><code id="PlotCH_+3A_main">main</code></td>
<td>
<p>main title in the plot.
</p>
</td></tr>
<tr><td><code id="PlotCH_+3A_col.vf">col.vf</code></td>
<td>
<p>defines a color for the vegetational area (&quot;Vegetationsflaeche&quot;).  <br />
If <code>NA</code> only the total area is used.
</p>
</td></tr>
<tr><td><code id="PlotCH_+3A_border">border</code></td>
<td>
<p>color of map border. Default is <code>"grey"</code>.
</p>
</td></tr>
<tr><td><code id="PlotCH_+3A_border.vf">border.vf</code></td>
<td>
<p>color of borders for the vegetational area. Default is <code>"grey"</code>.
</p>
</td></tr>
<tr><td><code id="PlotCH_+3A_lwd">lwd</code></td>
<td>
<p>linewidth for the border. Default is <code>par("lwd")</code>.
</p>
</td></tr>
<tr><td><code id="PlotCH_+3A_tmtxt">tmtxt</code></td>
<td>
<p>logical, should the copyright text be displayed. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="PlotCH_+3A_add">add</code></td>
<td>
<p>default <code>FALSE</code>; if <code>TRUE</code>, add to existing plot.</p>
</td></tr>
<tr><td><code id="PlotCH_+3A_...">...</code></td>
<td>
<p>the dots are passed to the plot command.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of all cantons and their ids is given by d.bfsrg:<br />
<kbd>  cantons &lt;- unique(d.bfsrg[,c("kt_c", "kt_x", "kt_bez_x")])</kbd>
</p>


<h3>Value</h3>

<p>A list containing x and y component of the centroid of the plotted spatial unit.</p>


<h3>Author(s)</h3>

<p>Andri Signorell &lt;andri@signorell.net&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PlotGreg">PlotGreg</a></code>, <code><a href="#topic+PlotKant">PlotKant</a></code>, <code><a href="#topic+PlotBezk">PlotBezk</a></code>, <code><a href="#topic+PlotPolg">PlotPolg</a></code>, <code><a href="#topic+d.bfsrg">d.bfsrg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>try( {

PlotCH(col="lightgrey")
AddLakes()

# use the result to add a semitransparent label
xy &lt;- PlotCH(col.vf = "grey90", col="grey75", border="grey50", border.vf = NA)
AddLakes()
AddRivers()
PlotCH(add=TRUE, col=NA)
BoxedText(x=xy$x, y=xy$y, labels = "Visit\n Switzerland", cex=3, txt.col = "grey40",
          col=SetAlpha("white", 0.6), border=NA, ypad=0.5)


# wawing flag ...
PlotCH(col="red", main="Switzerland")
sw &lt;- 15000;
xc &lt;- 2671975;
yc &lt;- 1200600;

ccol &lt;- rgb(1,1,1,0.85)
rect(xleft=xc-sw, ytop=yc-sw, xright=xc+sw, ybottom=yc+sw, col=ccol, border=NA)
rect(xleft=(xc-2*sw)-sw, ytop=yc-sw, xright=(xc-2*sw)+sw, ybottom=yc+sw, col=ccol, border=NA)
rect(xleft=(xc+2*sw)-sw, ytop=yc-sw, xright=(xc+2*sw)+sw, ybottom=yc+sw, col=ccol, border=NA)
rect(xleft=xc-sw, ytop=(yc-2*sw)-sw, xright=xc+sw, ybottom=(yc-2*sw)+sw, col=ccol, border=NA)
rect(xleft=xc-sw, ytop=(yc+2*sw)-sw, xright=xc+sw, ybottom=(yc+2*sw)+sw, col=ccol, border=NA)

# using panel.first ensures that the borders are not hidden by waters
PlotCH(col=NA, lwd=2, panel.first=AddLakes())

})</code></pre>

<hr>
<h2 id='PlotMapDot'>Plot a Map and a Dotplot
</h2><span id='topic+PlotMapDot'></span>

<h3>Description</h3>

<p>Prepares the layout to plot a map and a dotplot side by side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotMapDot(mar = c(5.1,4.1,0,1), oma = c(0,0,5,0), widths = c(2,0.8))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotMapDot_+3A_mar">mar</code></td>
<td>
<p>defines the plot margins.
</p>
</td></tr>
<tr><td><code id="PlotMapDot_+3A_oma">oma</code></td>
<td>
<p>defines the outer margins. We use that for displaying a title.
</p>
</td></tr>
<tr><td><code id="PlotMapDot_+3A_widths">widths</code></td>
<td>

<p>a vector of values for the widths of two columns, the first for the map, the second for dotplot. Relative widths are specified with numeric values. Absolute widths (in centimetres) are specified with the lcm() function. Default is <code>c(2, 0.8)</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None</p>


<h3>Author(s)</h3>

<p> Andri Signorell &lt;andri@signorell.net&gt;
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+layout">layout</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(DescTools)

try( {

yes_p &lt;- c(ZH=0.465, BE=0.417, LU=0.376, UR=0.308, SZ=0.276,
           OW=0.273, NW=0.277, GL=0.324, ZG=0.344, FR=0.469, SO=0.352,
           BS=0.602, BL=0.414, SH=0.457, AR=0.325, AI=0.24, SG=0.365,
           GR=0.325, AG=0.347, TG=0.321, TI=0.446, VD=0.532, VS=0.329,
           NE=0.562, GE=0.601, JU=0.532)


PlotMapDot()
cols &lt;- colorRampPalette( colors=c("red","white","green"), space ="rgb")(10)
PlotKant(id=names(yes_p),
         col=FindColor(yes_p, cols=cols, min.x=0, max.x=1 ), main="",
         labels=TRUE)

ColorLegend(x="left", width=10000,
            labels=paste(seq(0, 100, 10), "%", sep=""),
            cols=cols, cex=0.8, adj=c(1,0.5), frame="grey")

x &lt;- Sort(yes_p, decreasing=TRUE)

opt &lt;- DescToolsOptions(stamp=NULL)
PlotDot(x, labels=gettextf("%s (%s)", names(x), Format(x, fmt="%", digits=1)),
        cex=0.9, xlim=c(0,1))
abline(v=0.5, col="grey")

title(main="Volksinitiative 'Mehr bezahlbare Wohnungen'
            Abstimmung vom 09.02.2020", outer=TRUE)
DescToolsOptions(opt)

# reset the layout
layout(1)

})</code></pre>

<hr>
<h2 id='PlotPremReg'>Plot Premium Regions CH
</h2><span id='topic+PlotPremReg'></span>

<h3>Description</h3>

<p>Plot premium regions in Switzerland.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPremReg(id = NULL, col = NA, pbg = "white", main = "",
            border = "grey", lwd = 1,
            labels = NULL, tmtxt = TRUE, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotPremReg_+3A_id">id</code></td>
<td>
<p>vector of region ids. The premium regions can be addressed via their their abbreviation:
<code>"AG0"</code>, <code>"AI0"</code>, <code>"AR0"</code>, <code>"BE1"</code>, ...
</p>
</td></tr>
<tr><td><code id="PlotPremReg_+3A_col">col</code></td>
<td>
<p>vector of colors, defining the colors of the region area.
</p>
</td></tr>
<tr><td><code id="PlotPremReg_+3A_pbg">pbg</code></td>
<td>
<p>color for the plot background.
</p>
</td></tr>
<tr><td><code id="PlotPremReg_+3A_main">main</code></td>
<td>
<p>main title in the plot.
</p>
</td></tr>
<tr><td><code id="PlotPremReg_+3A_border">border</code></td>
<td>
<p>vector of colors for region borders. Default is <code>"grey30"</code>.
</p>
</td></tr>
<tr><td><code id="PlotPremReg_+3A_lwd">lwd</code></td>
<td>
<p>linewidth for region borders.
</p>
</td></tr>
<tr><td><code id="PlotPremReg_+3A_labels">labels</code></td>
<td>
<p>optional labels to be placed in the map, by default the centroids of the map is used for that.</p>
</td></tr>
<tr><td><code id="PlotPremReg_+3A_tmtxt">tmtxt</code></td>
<td>
<p>logical, should the copyright text be displayed. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="PlotPremReg_+3A_add">add</code></td>
<td>
<p>default <code>FALSE</code>; if <code>TRUE</code>, add to existing plot.</p>
</td></tr>
<tr><td><code id="PlotPremReg_+3A_...">...</code></td>
<td>
<p>the dots are passed to the plot command.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing x and y components which are the centroids of the plotted spatial units.</p>


<h3>Author(s)</h3>

<p>Andri Signorell &lt;andri@signorell.net&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PlotCH">PlotCH</a></code>, <code><a href="#topic+d.bfsrg">d.bfsrg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note:
#   The examples can not be run without having the map data installed before!
try( {

preg_x &lt;- sort(unique(d.bfsrg$preg_x))

PlotPremReg(id=preg_x, border="grey60",
            col=c("white","olivedrab4", "olivedrab3", "olivedrab2")[
                StrVal(preg_x,as.numeric=T)+1],
            main="Prämienregionen CH")

legend(x="topleft", fill=c("white","olivedrab4","olivedrab3","olivedrab2"),
       cex=0.8,
       legend=c("Region 0","Region 1","Region 2","Region 3") )

AddLakes()

# plot all premium regions
# find all regions
d.bfsrg$preg_x &lt;- paste0(d.bfsrg$kt_x, d.bfsrg$preg_c)
preg &lt;- unique(d.bfsrg$preg_x)

cols &lt;- c("white","darkolivegreen3", "darkolivegreen2", "darkolivegreen1")

PlotPremReg(preg, cols[ZeroIfNA(StrVal(preg, as.numeric = T))+1], labels =NA)
PlotKant(add=TRUE, border="grey55")
AddLakes()

# plot some selected premium regions
PlotPremReg(c("ZH1", "GR2"), c("blue", "yellow"), labels=TRUE)
PlotKant(add=TRUE, border="grey55")
AddLakes()
})

</code></pre>

<hr>
<h2 id='SwissLocator'>Get the Community, District and Canton of a Located Mappoint
</h2><span id='topic+SwissLocator'></span>

<h3>Description</h3>

<p>Locate a point in a Switzerland map and get the according community, district and canton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SwissLocator()
</code></pre>


<h3>Value</h3>

<p>For each clicked and identified point the coordinates, the political community, the district and the canton will be returned.<br />
</p>
<pre>
            x        y bfs_nr       community_x               district_x  kt_x
1014 536281.5 167176.3   2703            Riehen       Kanton Basel-Stadt    BS
1781 616565.2 268959.6   5136         Onsernone     Distretto di Locarno    TI
1962 690861.6 119006.1   5524 Goumoens-la-Ville District du Gros-de-Vaud    VD
</pre>
<p>The result will also be stored for later use in the variable <code>tkart$found</code>.
</p>


<h3>Author(s)</h3>

<p>Andri Signorell &lt;andri@signorell.net&gt;
</p>

<hr>
<h2 id='tkart'>Unlocked Environment for Maps
</h2><span id='topic+tkart'></span>

<h3>Description</h3>

<p>Loading maps and parsing their structure takes time. In order to avoid to load the maps multiple times in a session they're cached in this special environment after the first load in a session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkart</code></pre>


<h3>Format</h3>

<p>The format is:
&lt;environment: 0x000001d443d516f8&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
