<!DOCTYPE html><html lang="en"><head><title>Help for package QZ</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {QZ}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#QZ-package'><p>Generalized Eigenvalues and QZ Decomposition</p></a></li>
<li><a href='#Conjugate+20transpose'><p>Conjugate Transpose for Complex Matrix</p></a></li>
<li><a href='#Example+20datasets'><p>Small example datasets</p></a></li>
<li><a href='#fda.geigen'><p> Generalized Eigen Analysis as in fda Package</p></a></li>
<li><a href='#Generalized+20Eigenvalues'><p> Generalized Eigen Values</p></a></li>
<li><a href='#Print+20methods'><p>Functions for Printing Objects According to Classes</p></a></li>
<li><a href='#QZ+20Decomposition'><p> QZ Decomposition</p></a></li>
<li><a href='#QZ+20Decomposition+20Reordering'><p> Reordering QZ Decomposition</p></a></li>
<li><a href='#qz.dgees'><p>QZ Decomposition for a Real Matrix</p></a></li>
<li><a href='#qz.dgeev'><p>Generalized Eigenvalues Decomposition for a Real Matrix</p></a></li>
<li><a href='#qz.dgges'><p>QZ Decomposition for Real Paired Matrices</p></a></li>
<li><a href='#qz.dggev'><p>Generalized Eigenvalues Decomposition for Real Paired Matrices</p></a></li>
<li><a href='#qz.dtgsen'><p>Reordered QZ Decomposition for Real Paired Matrices</p></a></li>
<li><a href='#qz.dtrsen'><p>Reordered QZ Decomposition for a Real Matrix</p></a></li>
<li><a href='#qz.zgees'><p>QZ Decomposition for a Complex Matrix</p></a></li>
<li><a href='#qz.zgeev'><p>Generalized Eigenvalues Decomposition for a Complex Matrix</p></a></li>
<li><a href='#qz.zgges'><p>QZ Decomposition for Complex Paired Matrices</p></a></li>
<li><a href='#qz.zggev'><p>Generalized Eigenvalues Decomposition for Complex Paired Matrices</p></a></li>
<li><a href='#qz.ztgsen'><p>Reordered QZ Decomposition for Complex Paired Matrices</p></a></li>
<li><a href='#qz.ztrsen'><p>Reordered QZ Decomposition for a Complex Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.2-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Eigenvalues and QZ Decomposition</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), methods, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fda</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See QZ/inst/LAPACK_LICENSE.txt for the files in src/qz/.</td>
</tr>
<tr>
<td>Description:</td>
<td>Generalized eigenvalues and eigenvectors
        use QZ decomposition (generalized Schur decomposition).
        The decomposition needs an N-by-N non-symmetric
        matrix A or paired matrices (A,B) with eigenvalues reordering
        mechanism. The decomposition functions are mainly based Fortran
        subroutines in complex*16 and double precision of LAPACK
        library (version 3.10.0 or later).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">Mozilla Public License 2.0</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wei-Chen Chen &lt;wccsnow@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-03 23:06:13 UTC; snoweye</td>
</tr>
<tr>
<td>Author:</td>
<td>Wei-Chen Chen [aut, cre],
  LAPACK authors [aut, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-04 20:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='QZ-package'>Generalized Eigenvalues and QZ Decomposition</h2><span id='topic+QZ-package'></span>

<h3>Description</h3>

<p>QZ package provides generalized eigenvalues and QZ decomposition
(generalized Schur form) for an N-by-N non-symmetric
matrix A or paired matrices (A,B) with eigenvalues reordering
mechanism. The package is mainly based complex*16 and double
precision of LAPACK library (version 3.4.2.)
</p>


<h3>Details</h3>

<p>The QZ package contains R functions for generalized eigenvalues and
QZ decomposition (generalized Schur form) for an N-by-N non-symmetric
matrix A or paired matrices (A,B) via two main functions, <code>qz.geigen()</code>
and <code>qz()</code>. The <code>qz()</code> function also provides an option for
eigenvalues reordering.
</p>
<p>The QZ package is also based on a minimum set of complex*16 and double
precision of LAPACK and BLAS Fortran libraries.
Most functions are wrapped in C via <code>.Call()</code> to avoid
extra memory copy and to improve performance and memory usage.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>
<p><a href="https://www.netlib.org/lapack/">https://www.netlib.org/lapack/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.geigen">qz.geigen</a></code>,
<code><a href="#topic+qz">qz</a></code>, <br />
<code><a href="#topic+qz.zgges">qz.zgges</a></code>,
<code><a href="#topic+qz.zggev">qz.zggev</a></code>,
<code><a href="#topic+qz.ztgsen">qz.ztgsen</a></code>,
<code><a href="#topic+qz.dgges">qz.dgges</a></code>,
<code><a href="#topic+qz.dggev">qz.dggev</a></code>,
<code><a href="#topic+qz.dtgsen">qz.dtgsen</a></code>, <br />
<code><a href="#topic+qz.zgees">qz.zgees</a></code>,
<code><a href="#topic+qz.zgeev">qz.zgeev</a></code>,
<code><a href="#topic+qz.ztrsen">qz.ztrsen</a></code>,
<code><a href="#topic+qz.dgees">qz.dgees</a></code>,
<code><a href="#topic+qz.dgeev">qz.dgeev</a></code>,
<code><a href="#topic+qz.dtrsen">qz.dtrsen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo(ex1_geigen, "QZ")
demo(ex2_qz, "QZ")
demo(ex3_ordqz, "QZ")
demo(ex4_fda_geigen, "QZ")

## End(Not run)
</code></pre>

<hr>
<h2 id='Conjugate+20transpose'>Conjugate Transpose for Complex Matrix</h2><span id='topic+H'></span>

<h3>Description</h3>

<p>Conjugate transpose, Hermitian transpose, or Hermitian conjugate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  H(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Conjugate+2B20transpose_+3A_x">x</code></td>
<td>
<p>a complex matrix or vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is equivalent to <code>Conj(t.default(x))</code>.
</p>


<h3>Value</h3>

<p>This returns a conjugate transpose of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

A &lt;- matrix(c(-21.10 -22.50i, 53.50 -50.50i, -34.50 +127.50i,   7.50  +0.50i,
               -0.46  -7.78i, -3.50 -37.50i, -15.50  +58.50i, -10.50  -1.50i,
                4.30  -5.50i, 39.70 -17.10i, -68.50  +12.50i,  -7.50  -3.50i,
                5.50  +4.40i, 14.40 +43.30i, -32.50  -46.00i, -19.00 -32.50i),
            nrow = 4, byrow = TRUE)
H(A)
</code></pre>

<hr>
<h2 id='Example+20datasets'>Small example datasets</h2><span id='topic+exAB1'></span><span id='topic+exAB2'></span><span id='topic+exAB3'></span><span id='topic+exAB4'></span><span id='topic+exA1'></span><span id='topic+exA2'></span><span id='topic+exA3'></span><span id='topic+exA4'></span>

<h3>Description</h3>

<p>These datasets are small for test operations and functions in
complex and double precision/matrices.
</p>


<h3>Format</h3>

<p>Each dataset contains information where it is from and two
matrices in pair of (A,B) or single matrix (A)
for testing functions <code>qz.*</code>
or related functions, either in complex or in double precision.
</p>


<h3>Details</h3>

<p>The example datasets are
</p>

<table>
<tr>
 <td style="text-align: left;">
  Examples   </td><td style="text-align: left;"> Source </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>exAB1</code> </td><td style="text-align: left;"> <a href="https://www.nag.com/lapack-ex/node124.html">https://www.nag.com/lapack-ex/node124.html</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>exAB2</code> </td><td style="text-align: left;"> <a href="https://www.nag.com/lapack-ex/node119.html">https://www.nag.com/lapack-ex/node119.html</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>exAB3</code> </td><td style="text-align: left;"> <a href="https://www.nag.com/numeric/fl/nagdoc_fl23/xhtml/f08/f08yuf.xml">https://www.nag.com/numeric/fl/nagdoc_fl23/xhtml/f08/f08yuf.xml</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>exAB4</code> </td><td style="text-align: left;"> <a href="https://www.nag.com/numeric/fl/nagdoc_fl23/xhtml/f08/f08ygf.xml">https://www.nag.com/numeric/fl/nagdoc_fl23/xhtml/f08/f08ygf.xml</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
               </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>exA1</code>  </td><td style="text-align: left;"> <a href="https://www.nag.com/lapack-ex/node94.html">https://www.nag.com/lapack-ex/node94.html</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>exA2</code>  </td><td style="text-align: left;"> <a href="https://www.nag.com/lapack-ex/node89.html">https://www.nag.com/lapack-ex/node89.html</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>exA3</code>  </td><td style="text-align: left;"> <a href="https://www.nag.com/numeric/fl/nagdoc_fl23/xhtml/f08/f08quf.xml">https://www.nag.com/numeric/fl/nagdoc_fl23/xhtml/f08/f08quf.xml</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>exA4</code>  </td><td style="text-align: left;"> <a href="https://www.nag.com/numeric/fl/nagdoc_fl22/xhtml/f08/f08qgf.xml">https://www.nag.com/numeric/fl/nagdoc_fl22/xhtml/f08/f08qgf.xml</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The elements of dataset are (if any)
</p>

<table>
<tr>
 <td style="text-align: left;">
  Elements           </td><td style="text-align: left;"> Usage </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>description</code> </td><td style="text-align: left;"> the source of data </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>A</code>           </td><td style="text-align: left;"> the first matrix A </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>B</code>           </td><td style="text-align: left;"> the second matrix B </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>S</code>           </td><td style="text-align: left;"> the Shur form </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>T</code>           </td><td style="text-align: left;"> the Shur form </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>Q</code>           </td><td style="text-align: left;"> the left Shur vectors </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>Z</code>           </td><td style="text-align: left;"> the right Shur vectors </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>

<hr>
<h2 id='fda.geigen'> Generalized Eigen Analysis as in fda Package</h2><span id='topic+fda.geigen'></span>

<h3>Description</h3>

<p>This is an equivalent function to <code>fda::geigen</code> which 
finds matrices L and M to maximize
</p>
<p>tr(L'AM) / sqrt(tr(L'BL) tr(M'CM))
</p>
<p>where A = a p x q matrix, B = p x p symmetric, positive definite
matrix, B = q x q symmetric positive definite matrix, L = p x s
matrix, and M = q x s matrix, where s = the number of non-zero
generalized eigenvalues of A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fda.geigen(Amat, Bmat, Cmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fda.geigen_+3A_amat">Amat</code></td>
<td>
<p> a numeric matrix </p>
</td></tr>
<tr><td><code id="fda.geigen_+3A_bmat">Bmat</code></td>
<td>

<p>a symmetric, positive definite matrix with dimension = number of
rows of A
</p>
</td></tr>
<tr><td><code id="fda.geigen_+3A_cmat">Cmat</code></td>
<td>

<p>a symmetric, positive definite matrix with dimension = number of
columns of A
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is equivalent to <code>fda::geigen(Amat, Bmat, Cmat)</code>
except that this is rewritten and utilizes LAPACK functions
via <code>qz.dggev</code>.
</p>
<p>Also, <code>Lmat</code> and <code>Mmat</code> are both scaled such that
L'BL and M'CM are identity matrices.
</p>


<h3>Value</h3>

<p>list(values, Lmat, Mmat)
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.geigen">qz.geigen</a></code>, <code><a href="#topic+qz.dggev">qz.dggev</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

A &lt;- matrix(as.double(1:6), 2)
B &lt;- matrix(as.double(c(2, 1, 1, 2)), 2)
C &lt;- diag(as.double(1:3))

ret.qz &lt;- fda.geigen(A, B, C)

### Verify
library(fda, quiet = TRUE)
ret.fda &lt;- fda::geigen(A, B, C)
</code></pre>

<hr>
<h2 id='Generalized+20Eigenvalues'> Generalized Eigen Values </h2><span id='topic+geigen'></span><span id='topic+qz.geigen'></span>

<h3>Description</h3>

<p>This function obtains generalized eigen values on input paired
matrices (A,B) or a single matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  geigen(A, B = NULL, only.values = FALSE, ...)

  qz.geigen(A, B = NULL, only.values = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Generalized+2B20Eigenvalues_+3A_a">A</code></td>
<td>
<p>a 'complex/real' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="Generalized+2B20Eigenvalues_+3A_b">B</code></td>
<td>
<p>a 'complex/real' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="Generalized+2B20Eigenvalues_+3A_only.values">only.values</code></td>
<td>
<p>if 'TRUE', only the eigenvalues are computed and returned,
otherwise both eigenvalues and eigenvectors are returned.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Eigenvalues_+3A_...">...</code></td>
<td>
<p>options to <code>qz.*</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Call one of <code><a href="#topic+qz.zggev">qz.zggev</a></code>, <code><a href="#topic+qz.dggev">qz.dggev</a></code>,
<code><a href="#topic+qz.zgeev">qz.zgeev</a></code>, or <code><a href="#topic+qz.dgeev">qz.dgeev</a></code> depending on the
input arguments and types.
</p>


<h3>Value</h3>

<p>Returns a list from the call.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz">qz</a></code>, <code><a href="#topic+ordqz">ordqz</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/lapack-ex/node122.html
(ret &lt;- qz.geigen(exAB1$A, exAB1$B))

### https://www.nag.com/lapack-ex/node117.html
(ret &lt;- qz.geigen(exAB2$A, exAB2$B))

### https://www.nag.com/lapack-ex/node92.html
(ret &lt;- qz.geigen(exA1$A))

### https://www.nag.com/lapack-ex/node87.html
(ret &lt;- qz.geigen(exA2$A))
</code></pre>

<hr>
<h2 id='Print+20methods'>Functions for Printing Objects According to Classes</h2><span id='topic+print.zgges'></span><span id='topic+print.zggev'></span><span id='topic+print.ztgsen'></span><span id='topic+print.dgges'></span><span id='topic+print.dggev'></span><span id='topic+print.dtgsen'></span><span id='topic+print.zgees'></span><span id='topic+print.zgeev'></span><span id='topic+print.ztrsen'></span><span id='topic+print.dgees'></span><span id='topic+print.dgeev'></span><span id='topic+print.dtrsen'></span>

<h3>Description</h3>

<p>Several classes are declared in <span class="pkg">QZ</span>, and these are functions
to print objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zgges'
print(x, digits = max(4, getOption("digits") - 3), ...)
## S3 method for class 'zggev'
print(x, digits = max(4, getOption("digits") - 3), ...)
## S3 method for class 'ztgsen'
print(x, digits = max(4, getOption("digits") - 3), ...)
## S3 method for class 'dgges'
print(x, digits = max(4, getOption("digits") - 3), ...)
## S3 method for class 'dggev'
print(x, digits = max(4, getOption("digits") - 3), ...)
## S3 method for class 'dtgsen'
print(x, digits = max(4, getOption("digits") - 3), ...)

## S3 method for class 'zgees'
print(x, digits = max(4, getOption("digits") - 3), ...)
## S3 method for class 'zgeev'
print(x, digits = max(4, getOption("digits") - 3), ...)
## S3 method for class 'ztrsen'
print(x, digits = max(4, getOption("digits") - 3), ...)
## S3 method for class 'dgees'
print(x, digits = max(4, getOption("digits") - 3), ...)
## S3 method for class 'dgeev'
print(x, digits = max(4, getOption("digits") - 3), ...)
## S3 method for class 'dtrsen'
print(x, digits = max(4, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Print+2B20methods_+3A_x">x</code></td>
<td>
<p>an object with the class attributes.</p>
</td></tr>
<tr><td><code id="Print+2B20methods_+3A_digits">digits</code></td>
<td>
<p>for printing out numbers.</p>
</td></tr>
<tr><td><code id="Print+2B20methods_+3A_...">...</code></td>
<td>
<p>other possible options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are useful functions for summarizing and debugging.
Use <code>names</code> or <code>str</code> to explore the details.
</p>


<h3>Value</h3>

<p>The results will cat or print on the STDOUT by default.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.zgges">qz.zgges</a></code>,
<code><a href="#topic+qz.zggev">qz.zggev</a></code>,
<code><a href="#topic+qz.ztgsen">qz.ztgsen</a></code>,
<code><a href="#topic+qz.dgges">qz.dgges</a></code>,
<code><a href="#topic+qz.dggev">qz.dggev</a></code>,
<code><a href="#topic+qz.dtgsen">qz.dtgsen</a></code>, <br />
<code><a href="#topic+qz.zgees">qz.zgees</a></code>,
<code><a href="#topic+qz.zgeev">qz.zgeev</a></code>,
<code><a href="#topic+qz.ztrsen">qz.ztrsen</a></code>,
<code><a href="#topic+qz.dgees">qz.dgees</a></code>,
<code><a href="#topic+qz.dgeev">qz.dgeev</a></code>,
<code><a href="#topic+qz.dtrsen">qz.dtrsen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Functions applied by directly type the names of objects.

## End(Not run)
</code></pre>

<hr>
<h2 id='QZ+20Decomposition'> QZ Decomposition </h2><span id='topic+qz'></span>

<h3>Description</h3>

<p>This function performs QZ decomposition on input paired matrices (A,B)
or a single matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz(A, B = NULL, select = NULL, only.values = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QZ+2B20Decomposition_+3A_a">A</code></td>
<td>
<p>a 'complex/real' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="QZ+2B20Decomposition_+3A_b">B</code></td>
<td>
<p>a 'complex/real' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="QZ+2B20Decomposition_+3A_select">select</code></td>
<td>
<p>specifies the eigenvalues in the selected cluster.</p>
</td></tr>
<tr><td><code id="QZ+2B20Decomposition_+3A_only.values">only.values</code></td>
<td>
<p>if 'TRUE', only the eigenvalues are computed and returned,
otherwise both eigenvalues and eigenvectors are returned.</p>
</td></tr>
<tr><td><code id="QZ+2B20Decomposition_+3A_...">...</code></td>
<td>
<p>options to <code>qz.*</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>select</code> is <code>NULL</code>, then
call one of <code><a href="#topic+qz.zgges">qz.zgges</a></code>, <code><a href="#topic+qz.dgges">qz.dgges</a></code>,
<code><a href="#topic+qz.zgees">qz.zgees</a></code>, or <code><a href="#topic+qz.dgees">qz.dgees</a></code> depending on the
input arguments and types.
</p>
<p>If <code>select</code> is not <code>NULL</code>, then
call one of <code><a href="#topic+qz.zgges">qz.zgges</a> + <a href="#topic+qz.ztgsen">qz.ztgsen</a></code>,
<code><a href="#topic+qz.dgges">qz.dgges</a> + <a href="#topic+qz.dtgsen">qz.dtgsen</a></code>, <br />
<code><a href="#topic+qz.zgees">qz.zgees</a> + <a href="#topic+qz.ztrsen">qz.ztrsen</a></code>, or
<code><a href="#topic+qz.dgees">qz.dgees</a> + <a href="#topic+qz.dtrsen">qz.dtrsen</a></code> depending on the
input arguments and types.
</p>


<h3>Value</h3>

<p>Returns a list from the call.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordqz">ordqz</a></code>, <code><a href="#topic+geigen">geigen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/lapack-ex/node124.html
(ret &lt;- qz(exAB1$A, exAB1$B))

### https://www.nag.com/lapack-ex/node119.html
(ret &lt;- qz(exAB2$A, exAB2$B))

### https://www.nag.com/lapack-ex/node94.html
(ret &lt;- qz(exA1$A))

### https://www.nag.com/lapack-ex/node89.html
(ret &lt;- qz(exA2$A))

# Reordering eigenvalues
select1 &lt;- c(TRUE, FALSE, FALSE, TRUE)
select2 &lt;- c(FALSE, TRUE, TRUE, FALSE)
(ret &lt;- qz(exAB1$A, exAB1$B, select = select1))
(ret &lt;- qz(exAB2$A, exAB2$B, select = select2))
(ret &lt;- qz(exA1$A, select = select1))
(ret &lt;- qz(exA2$A, select = select1))
</code></pre>

<hr>
<h2 id='QZ+20Decomposition+20Reordering'> Reordering QZ Decomposition </h2><span id='topic+ordqz'></span>

<h3>Description</h3>

<p>This function performs QZ decomposition on input paired matrices (A,B)
or a single matrix A with reordering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ordqz(A, B = NULL, cluster = NULL,
        keyword = c("lhp", "rhp", "udi", "udo", "ref", "cef",
                    "lhp.fo", "rhp.fo", "udi.fo", "udo.fo"),
        ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QZ+2B20Decomposition+2B20Reordering_+3A_a">A</code></td>
<td>
<p>a 'complex/real' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="QZ+2B20Decomposition+2B20Reordering_+3A_b">B</code></td>
<td>
<p>a 'complex/real' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="QZ+2B20Decomposition+2B20Reordering_+3A_cluster">cluster</code></td>
<td>
<p>specifies the eigenvalues in the selected cluster.</p>
</td></tr>
<tr><td><code id="QZ+2B20Decomposition+2B20Reordering_+3A_keyword">keyword</code></td>
<td>
<p>as similarly used in MATLAB.</p>
</td></tr>
<tr><td><code id="QZ+2B20Decomposition+2B20Reordering_+3A_...">...</code></td>
<td>
<p>options to <code>qz.*</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>cluster</code> or <code>keyword</code> should be specified.
</p>
<p><code>cluster</code> actually is the same as <code>select</code> in all <code>qz.*</code>
functions.
</p>
<p><code>keywork</code> actually is similar as MATLAB.
</p>

<table>
<tr>
 <td style="text-align: left;">
  keyword </td><td style="text-align: left;"> Selected Region </td>
</tr>
<tr>
 <td style="text-align: left;">
  'lhp'   </td><td style="text-align: left;"> Left-half plane (real(E) &lt; 0) </td>
</tr>
<tr>
 <td style="text-align: left;">
  'rhp'   </td><td style="text-align: left;"> Right-half plane (real(E) &gt;= 0) </td>
</tr>
<tr>
 <td style="text-align: left;">
  'udi'   </td><td style="text-align: left;"> Interior of unit disk (abs(E) &lt; 1) </td>
</tr>
<tr>
 <td style="text-align: left;">
  'udo'   </td><td style="text-align: left;"> Exterior of unit disk (abs(E) &gt;= 1) </td>
</tr>
<tr>
 <td style="text-align: left;">
  'ref'   </td><td style="text-align: left;"> Real eigenvalues first (top-left conner) </td>
</tr>
<tr>
 <td style="text-align: left;">
  'cef'   </td><td style="text-align: left;"> Complex eigenvalues first (top-left conner) </td>
</tr>
<tr>
 <td style="text-align: left;">
  'lhp'   </td><td style="text-align: left;"> Left-half plane (real(E) &lt; 0) and finite only </td>
</tr>
<tr>
 <td style="text-align: left;">
  'rhp'   </td><td style="text-align: left;"> Right-half plane (real(E) &gt;= 0) and finite only </td>
</tr>
<tr>
 <td style="text-align: left;">
  'udi'   </td><td style="text-align: left;"> Interior of unit disk (abs(E) &lt; 1) and finite only </td>
</tr>
<tr>
 <td style="text-align: left;">
  'udo'   </td><td style="text-align: left;"> Exterior of unit disk (abs(E) &gt;= 1) and finite only </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Returns a list from the call.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz">qz</a></code>, <code><a href="#topic+geigen">geigen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

# Reordering eigenvalues
(ret &lt;- ordqz(exAB1$A, exAB1$B, keyword = "lhp"))
(ret &lt;- ordqz(exAB1$A, exAB1$B, keyword = "rhp"))
(ret &lt;- ordqz(exAB1$A, exAB1$B, keyword = "udi"))
(ret &lt;- ordqz(exAB1$A, exAB1$B, keyword = "udo"))
(ret &lt;- ordqz(exAB1$A, exAB1$B, keyword = "ref"))
(ret &lt;- ordqz(exAB1$A, exAB1$B, keyword = "cef"))
(ret &lt;- ordqz(exAB1$A, exAB1$B, keyword = "lhp.fo"))
(ret &lt;- ordqz(exAB1$A, exAB1$B, keyword = "rhp.fo"))
(ret &lt;- ordqz(exAB1$A, exAB1$B, keyword = "udi.fo"))
(ret &lt;- ordqz(exAB1$A, exAB1$B, keyword = "udo.fo"))

</code></pre>

<hr>
<h2 id='qz.dgees'>QZ Decomposition for a Real Matrix</h2><span id='topic+qz.dgees'></span>

<h3>Description</h3>

<p>This function call 'dgees' in Fortran to decompose a 'real' matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz.dgees(A, vs = TRUE, LWORK = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qz.dgees_+3A_a">A</code></td>
<td>
<p>a 'real' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.dgees_+3A_vs">vs</code></td>
<td>
<p>if compute 'real' Schur vectors. (Q)</p>
</td></tr>
<tr><td><code id="qz.dgees_+3A_lwork">LWORK</code></td>
<td>
<p>optional, dimension of array WORK for workspace. (&gt;= 3N)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'dgees.f' for all details.
</p>
<p>DGEES computes for an N-by-N real non-symmetric matrix A, the
eigenvalues, the real Schur form T, and, optionally, the matrix of
Schur vectors Q.  This gives the Schur factorization A = Q*T*(Q**T).
</p>
<p>Optionally, it also orders the eigenvalues on the diagonal of the
real Schur form so that selected eigenvalues are at the top left.
The leading columns of Q then form an orthonormal basis for the
invariant subspace corresponding to the selected eigenvalues.
</p>
<p>A matrix is in real Schur form if it is upper quasi-triangular with
1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
form
</p>
<p>[  a  b  ]
[  c  a  ]
</p>
<p>where b*c &lt; 0. The eigenvalues of such a block are a +- sqrt(bc).
</p>


<h3>Value</h3>

<p>Return a list contains next:
</p>
<table role = "presentation">
<tr><td><code>'T'</code></td>
<td>
<p>A's generalized Schur form.</p>
</td></tr>
<tr><td><code>'WR'</code></td>
<td>
<p>original returns from 'dgees.f'.</p>
</td></tr>
<tr><td><code>'WI'</code></td>
<td>
<p>original returns from 'dgees.f'.</p>
</td></tr>
<tr><td><code>'VS'</code></td>
<td>
<p>original returns from 'dgees.f'.</p>
</td></tr>
<tr><td><code>'WORK'</code></td>
<td>
<p>optimal LWORK (for dgees.f only)</p>
</td></tr>
<tr><td><code>'INFO'</code></td>
<td>
<p>= 0: successful. &lt; 0: if INFO = -i, the i-th argument had
an illegal value. &lt;= N: QZ iteration failed.
=N+1: reordering problem.
=N+2: reordering failed.</p>
</td></tr>
</table>
<p>Extra returns in the list:
</p>
<table role = "presentation">
<tr><td><code>'W'</code></td>
<td>
<p>WR + WI * i.</p>
</td></tr>
<tr><td><code>'Q'</code></td>
<td>
<p>the Schur vectors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://www.netlib.org/lapack/double/dgees.f">https://www.netlib.org/lapack/double/dgees.f</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.dgeev">qz.dgeev</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/lapack-ex/node89.html
A &lt;- exA2$A
ret &lt;- qz.dgees(A)

# Verify 1
A.new &lt;- ret$Q %*% ret$T %*% solve(ret$Q)
round(A - A.new)

# verify 2
round(ret$Q %*% solve(ret$Q))
</code></pre>

<hr>
<h2 id='qz.dgeev'>Generalized Eigenvalues Decomposition for a Real Matrix</h2><span id='topic+qz.dgeev'></span>

<h3>Description</h3>

<p>This function call 'dgeev' in Fortran to decompose a 'real' matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz.dgeev(A, vl = TRUE, vr = TRUE, LWORK = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qz.dgeev_+3A_a">A</code></td>
<td>
<p>a 'real' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.dgeev_+3A_vl">vl</code></td>
<td>
<p>if compute left 'real' eigen vector. (U)</p>
</td></tr>
<tr><td><code id="qz.dgeev_+3A_vr">vr</code></td>
<td>
<p>if compute right 'real' eigen vector. (V)</p>
</td></tr>
<tr><td><code id="qz.dgeev_+3A_lwork">LWORK</code></td>
<td>
<p>optional, dimension of array WORK for workspace. (&gt;= 4N)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'dgeev.f' for all details.
</p>
<p>DGEEV computes for an N-by-N real non-symmetric matrix A, the
eigenvalues and, optionally, the left and/or right eigenvectors.
</p>
<p>The right eigenvector v(j) of A satisfies
</p>
<p>A * v(j) = lambda(j) * v(j)
</p>
<p>where lambda(j) is its eigenvalue.
The left eigenvector u(j) of A satisfies
</p>
<p>u(j)**T * A = lambda(j) * u(j)**T
</p>
<p>where u(j)**T denotes the transpose of u(j).
</p>
<p>The computed eigenvectors are normalized to have Euclidean norm
equal to 1 and largest component real.
</p>


<h3>Value</h3>

<p>Return a list contains next:
</p>
<table role = "presentation">
<tr><td><code>'WR'</code></td>
<td>
<p>original returns from 'dgeev.f'.</p>
</td></tr>
<tr><td><code>'WI'</code></td>
<td>
<p>original returns from 'dgeev.f'.</p>
</td></tr>
<tr><td><code>'VL'</code></td>
<td>
<p>original returns from 'dgeev.f'.</p>
</td></tr>
<tr><td><code>'VR'</code></td>
<td>
<p>original returns from 'dgeev.f'.</p>
</td></tr>
<tr><td><code>'WORK'</code></td>
<td>
<p>optimal LWORK (for dgeev.f only)</p>
</td></tr>
<tr><td><code>'INFO'</code></td>
<td>
<p>= 0: successful. &lt; 0: if INFO = -i, the i-th argument had
an illegal value. &gt; 0: QZ iteration failed.</p>
</td></tr>
</table>
<p>Extra returns in the list:
</p>
<table role = "presentation">
<tr><td><code>'W'</code></td>
<td>
<p>WR + WI * i.</p>
</td></tr>
<tr><td><code>'U'</code></td>
<td>
<p>the left eigen vectors.</p>
</td></tr>
<tr><td><code>'V'</code></td>
<td>
<p>the right eigen vectors.</p>
</td></tr>
</table>
<p>If WI[j] is zero, then the j-th eigenvalue is real; if
positive, then the j-th and (j+1)-st eigenvalues are a
complex conjugate pair, with WI[j+1] negative.
</p>
<p>If the j-th eigenvalue is real, then
U[, j] = VL[, j], the j-th column of VL. If the j-th and
(j+1)-th eigenvalues form a complex conjugate pair, then
U[, j] = VL[, j] + i * VL[, j+1] and
U[, j+1] = VL[, j] - i * VL[, j+1].
</p>
<p>Similarly, for the right eigenvectors of V and VR.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://www.netlib.org/lapack/double/dgeev.f">https://www.netlib.org/lapack/double/dgeev.f</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.dgees">qz.dgees</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/lapack-ex/node87.html
A &lt;- exA2$A
ret &lt;- qz.dgeev(A)

# Verify 1
diff.R &lt;- A %*% ret$V - matrix(ret$W, 4, 4, byrow = TRUE) * ret$V
diff.L &lt;- t(ret$U) %*% A - matrix(ret$W, 4, 4) * t(ret$U)
round(diff.R)
round(diff.L)

# Verify 2
round(ret$U %*% solve(ret$U))
round(ret$V %*% solve(ret$V))
</code></pre>

<hr>
<h2 id='qz.dgges'>QZ Decomposition for Real Paired Matrices</h2><span id='topic+qz.dgges'></span>

<h3>Description</h3>

<p>This function call 'dgges' in Fortran to decompose 'real' matrices (A,B).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz.dgges(A, B, vsl = TRUE, vsr = TRUE, LWORK = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qz.dgges_+3A_a">A</code></td>
<td>
<p>a 'real' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.dgges_+3A_b">B</code></td>
<td>
<p>a 'real' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.dgges_+3A_vsl">vsl</code></td>
<td>
<p>if compute left 'real' Schur vectors. (Q)</p>
</td></tr>
<tr><td><code id="qz.dgges_+3A_vsr">vsr</code></td>
<td>
<p>if compute right 'real' Schur vectors. (Z)</p>
</td></tr>
<tr><td><code id="qz.dgges_+3A_lwork">LWORK</code></td>
<td>
<p>optional, dimension of array WORK for workspace. (&gt;= 8N+16)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'dgges.f' for all details.
</p>
<p>DGGES computes for a pair of N-by-N real non-symmetric matrices (A,B),
the generalized eigenvalues, the generalized real Schur form (S,T),
optionally, the left and/or right matrices of Schur vectors (VSL and
VSR). This gives the generalized Schur factorization
</p>
<p>(A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
</p>
<p>Optionally, it also orders the eigenvalues so that a selected cluster
of eigenvalues appears in the leading diagonal blocks of the upper
quasi-triangular matrix S and the upper triangular matrix T.The
leading columns of VSL and VSR then form an orthonormal basis for the
corresponding left and right eigenspaces (deflating subspaces).
</p>
<p>(If only the generalized eigenvalues are needed, use the driver
DGGEV instead, which is faster.)
</p>
<p>A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
usually represented as the pair (alpha,beta), as there is a
reasonable interpretation for beta=0 or both being zero.
</p>
<p>A pair of matrices (S,T) is in generalized real Schur form if T is
upper triangular with non-negative diagonal and S is block upper
triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
to real generalized eigenvalues, while 2-by-2 blocks of S will be
&quot;standardized&quot; by making the corresponding elements of T have the
form:
</p>
<p>[  a  0  ] <br />
[  0  b  ]
</p>
<p>and the pair of corresponding 2-by-2 blocks in S and T will have a
complex conjugate pair of generalized eigenvalues.
</p>


<h3>Value</h3>

<p>Return a list contains next:
</p>
<table role = "presentation">
<tr><td><code>'S'</code></td>
<td>
<p>A's generalized Schur form.</p>
</td></tr>
<tr><td><code>'T'</code></td>
<td>
<p>B's generalized Schur form.</p>
</td></tr>
<tr><td><code>'ALPHAR'</code></td>
<td>
<p>original returns from 'dgges.f'.</p>
</td></tr>
<tr><td><code>'ALPHAI'</code></td>
<td>
<p>original returns from 'dgges.f'.</p>
</td></tr>
<tr><td><code>'BETA'</code></td>
<td>
<p>original returns from 'dgges.f'.</p>
</td></tr>
<tr><td><code>'VSL'</code></td>
<td>
<p>original returns from 'dgges.f'.</p>
</td></tr>
<tr><td><code>'VSR'</code></td>
<td>
<p>original returns from 'dgges.f'.</p>
</td></tr>
<tr><td><code>'WORK'</code></td>
<td>
<p>optimal LWORK (for dgges.f only)</p>
</td></tr>
<tr><td><code>'INFO'</code></td>
<td>
<p>= 0: successful. &lt; 0: if INFO = -i, the i-th argument had
an illegal value. =1,...,N: QZ iteration failed.
=N+1: other than QZ iteration failed in DHGEQZ.
=N+2: reordering problem.
=N+3: reordering failed.</p>
</td></tr>
</table>
<p>Extra returns in the list:
</p>
<table role = "presentation">
<tr><td><code>'ALPHA'</code></td>
<td>
<p>ALPHAR + ALPHAI * i.</p>
</td></tr>
<tr><td><code>'Q'</code></td>
<td>
<p>the left Schur vectors.</p>
</td></tr>
<tr><td><code>'Z'</code></td>
<td>
<p>the right Schur vectors.</p>
</td></tr>
</table>
<p>The ALPHA[j]/BETA[j] are generalized eigenvalues.
</p>
<p>If ALPHAI[j] is zero, then the j-th eigenvalue is real; if
positive, then the j-th and (j+1)-st eigenvalues are a
complex conjugate pair, with ALPHAI[j+1] negative.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://www.netlib.org/lapack/double/dgges.f">https://www.netlib.org/lapack/double/dgges.f</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.dggev">qz.dggev</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/lapack-ex/node119.html 
A &lt;- exAB2$A
B &lt;- exAB2$B
ret &lt;- qz.dgges(A, B)

# Verify 1
A.new &lt;- ret$Q %*% ret$S %*% t(ret$Z)
B.new &lt;- ret$Q %*% ret$T %*% t(ret$Z)
round(A - A.new)
round(B - B.new)

# verify 2
round(ret$Q %*% t(ret$Q))
round(ret$Z %*% t(ret$Z))
</code></pre>

<hr>
<h2 id='qz.dggev'>Generalized Eigenvalues Decomposition for Real Paired Matrices</h2><span id='topic+qz.dggev'></span>

<h3>Description</h3>

<p>This function call 'dggev' in Fortran to decompose 'real' matrices (A,B).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz.dggev(A, B, vl = TRUE, vr = TRUE, LWORK = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qz.dggev_+3A_a">A</code></td>
<td>
<p>a 'real' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.dggev_+3A_b">B</code></td>
<td>
<p>a 'real' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.dggev_+3A_vl">vl</code></td>
<td>
<p>if compute left 'real' eigen vector. (U)</p>
</td></tr>
<tr><td><code id="qz.dggev_+3A_vr">vr</code></td>
<td>
<p>if compute right 'real' eigen vector. (V)</p>
</td></tr>
<tr><td><code id="qz.dggev_+3A_lwork">LWORK</code></td>
<td>
<p>optional, dimension of array WORK for workspace. (&gt;= 8N)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'dggev.f' for all details.
</p>
<p>DGGEV computes for a pair of N-by-N real non-symmetric matrices (A,B)
the generalized eigenvalues, and optionally, the left and/or right
generalized eigenvectors.
</p>
<p>A generalized eigenvalue for a pair of matrices (A,B) is a scalar
lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
singular. It is usually represented as the pair (alpha,beta), as
there is a reasonable interpretation for beta=0, and even for both
being zero.
</p>
<p>The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
of (A,B) satisfies
</p>
<p>A * v(j) = lambda(j) * B * v(j).
</p>
<p>The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
of (A,B) satisfies
</p>
<p>u(j)**H * A  = lambda(j) * u(j)**H * B .
</p>
<p>where u(j)**H is the conjugate-transpose of u(j).
</p>


<h3>Value</h3>

<p>Return a list contains next:
</p>
<table role = "presentation">
<tr><td><code>'ALPHAR'</code></td>
<td>
<p>original returns from 'dggev.f'.</p>
</td></tr>
<tr><td><code>'ALPHAI'</code></td>
<td>
<p>original returns from 'dggev.f'.</p>
</td></tr>
<tr><td><code>'BETA'</code></td>
<td>
<p>original returns from 'dggev.f'.</p>
</td></tr>
<tr><td><code>'VL'</code></td>
<td>
<p>original returns from 'dggev.f'.</p>
</td></tr>
<tr><td><code>'VR'</code></td>
<td>
<p>original returns from 'dggev.f'.</p>
</td></tr>
<tr><td><code>'WORK'</code></td>
<td>
<p>optimal LWORK (for dggev.f only)</p>
</td></tr>
<tr><td><code>'INFO'</code></td>
<td>
<p>= 0: successful. &lt; 0: if INFO = -i, the i-th argument had
an illegal value. =1,...,N: QZ iteration failed.
=N+1: other than QZ iteration failed in DHGEQZ.
=N+2: reordering problem.
=N+3: reordering failed.</p>
</td></tr>
</table>
<p>Extra returns in the list:
</p>
<table role = "presentation">
<tr><td><code>'ALPHA'</code></td>
<td>
<p>ALPHAR + ALPHAI * i.</p>
</td></tr>
<tr><td><code>'U'</code></td>
<td>
<p>the left eigen vectors.</p>
</td></tr>
<tr><td><code>'V'</code></td>
<td>
<p>the right eigen vectors.</p>
</td></tr>
</table>
<p>If ALPHAI[j] is zero, then the j-th eigenvalue is real; if
positive, then the j-th and (j+1)-st eigenvalues are a
complex conjugate pair, with ALPHAI[j+1] negative.
</p>
<p>If the j-th eigenvalue is real, then
U[, j] = VL[, j], the j-th column of VL. If the j-th and
(j+1)-th eigenvalues form a complex conjugate pair, then
U[, j] = VL[, j] + i * VL[, j+1] and
U[, j+1] = VL[, j] - i * VL[, j+1].
Each eigenvector is scaled so the largest component has
abs(real part) + abs(imag. part) = 1.
</p>
<p>Similarly, for the right eigenvectors of V and VR.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://www.netlib.org/lapack/double/dggev.f">https://www.netlib.org/lapack/double/dggev.f</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.dgges">qz.dgges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/lapack-ex/node117.html 
A &lt;- exAB2$A
B &lt;- exAB2$B
ret &lt;- qz.dggev(A, B)

# Verify
(lambda &lt;- ret$ALPHA / ret$BETA)    # Unstable
diff.R &lt;- matrix(ret$BETA, 4, 4, byrow = TRUE) * A %*% ret$V -
          matrix(ret$ALPHA, 4, 4, byrow = TRUE) * B %*% ret$V
diff.L &lt;- matrix(ret$BETA, 4, 4) * H(ret$U) %*% A -
          matrix(ret$ALPHA, 4, 4) * H(ret$U) %*% B
round(diff.R)
round(diff.L)

# Verify 2
round(ret$U %*% solve(ret$U))
round(ret$V %*% solve(ret$V))
</code></pre>

<hr>
<h2 id='qz.dtgsen'>Reordered QZ Decomposition for Real Paired Matrices</h2><span id='topic+qz.dtgsen'></span>

<h3>Description</h3>

<p>This function call 'dtgsend' in Fortran to reorder 'double'
matrices (S,T,Q,Z).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz.dtgsen(S, T, Q, Z, select, ijob = 4L,
            want.Q = TRUE, want.Z = TRUE, LWORK = NULL, LIWORK = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qz.dtgsen_+3A_s">S</code></td>
<td>
<p>a 'double' generalized Schur form, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.dtgsen_+3A_t">T</code></td>
<td>
<p>a 'double' generalized Schur form, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.dtgsen_+3A_q">Q</code></td>
<td>
<p>a 'double' left Schur vectors, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.dtgsen_+3A_z">Z</code></td>
<td>
<p>a 'double' right Schur vectors, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.dtgsen_+3A_select">select</code></td>
<td>
<p>specifies the eigenvalues in the selected cluster.</p>
</td></tr>
<tr><td><code id="qz.dtgsen_+3A_ijob">ijob</code></td>
<td>
<p>specifies whether condition numbers are required for the
cluster of eigenvalues (PL and PR) or the deflating subspaces
(Difu and Difl).</p>
</td></tr>
<tr><td><code id="qz.dtgsen_+3A_want.q">want.Q</code></td>
<td>
<p>if update Q.</p>
</td></tr>
<tr><td><code id="qz.dtgsen_+3A_want.z">want.Z</code></td>
<td>
<p>if update Z.</p>
</td></tr>
<tr><td><code id="qz.dtgsen_+3A_lwork">LWORK</code></td>
<td>
<p>optional, dimension of array WORK for workspace. (&gt;= max(4N+16, N(N+1)))</p>
</td></tr>
<tr><td><code id="qz.dtgsen_+3A_liwork">LIWORK</code></td>
<td>
<p>optional, dimension of array IWORK for workspace. (&gt;= max(N+6, N(N+1)/2))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'dtgsen.f' for all details.
</p>
<p>DTGSEN reorders the generalized real Schur decomposition of a real
matrix pair (S,T) (in terms of an orthonormal equivalence transformation
Q**T * (S,T) * Z), so that a selected cluster of eigenvalues
appears in the leading diagonal blocks of the upper quasi-triangular
matrix S and the upper triangular T. The leading columns of Q and
Z form orthonormal bases of the corresponding left and right eigenspaces
(deflating subspaces). (S,T) must be in generalized real
Schur canonical form (as returned by DGGES), i.e. S is block upper
triangular with 1-by-1 and 2-by-2 diagonal blocks. T is upper
triangular.
</p>
<p>Note for 'ijob': <br />
=0: Only reorder w.r.t. SELECT. No extras. <br />
=1: Reciprocal of norms of &quot;projections&quot; onto left and right
eigenspaces w.r.t. the selected cluster (PL and PR). <br />
=2: Upper bounds on Difu and Difl. F-norm-based estimate (DIF(1:2)). <br />
=3: Estimate of Difu and Difl. 1-norm-based estimate (DIF(1:2)).
About 5 times as expensive as ijob = 2. <br />
=4: Compute PL, PR and DIF (i.e. 0, 1 and 2 above): Economic
version to get it all. <br />
=5: Compute PL, PR and DIF (i.e. 0, 1 and 3 above). <br />
</p>
<p>In short, if (A,B) = Q * (S,T) * Z**T from <code>qz.zgges</code> and input
(S,T,Q,Z) to <code>qz.ztgsen</code> with appropriate <code>select</code> option,
then it yields
</p>
<p>(A,B) = Q_n * (S_n,T_n) * Z_n**T
</p>
<p>where (S_n,T_n,Q_n,Z_n) is a new set of generalized Schur decomposition
of (A,B) according to the <code>select</code>.
</p>


<h3>Value</h3>

<p>Return a list contains next:
</p>
<table role = "presentation">
<tr><td><code>'S'</code></td>
<td>
<p>S's reorded generalized Schur form.</p>
</td></tr>
<tr><td><code>'T'</code></td>
<td>
<p>T's reorded generalized Schur form.</p>
</td></tr>
<tr><td><code>'ALPHAR'</code></td>
<td>
<p>original returns from 'dtgsen.f'.</p>
</td></tr>
<tr><td><code>'ALPHAI'</code></td>
<td>
<p>original returns from 'dtgsen.f'.</p>
</td></tr>
<tr><td><code>'BETA'</code></td>
<td>
<p>original returns from 'dtgsen.f'.</p>
</td></tr>
<tr><td><code>'M'</code></td>
<td>
<p>original returns from 'dtgsen.f'.</p>
</td></tr>
<tr><td><code>'PL'</code></td>
<td>
<p>original returns from 'dtgsen.f'.</p>
</td></tr>
<tr><td><code>'PR'</code></td>
<td>
<p>original returns from 'dtgsen.f'.</p>
</td></tr>
<tr><td><code>'DIF'</code></td>
<td>
<p>original returns from 'dtgsen.f'.</p>
</td></tr>
<tr><td><code>'WORK'</code></td>
<td>
<p>optimal LWORK (for dtgsen.f only)</p>
</td></tr>
<tr><td><code>'IWORK'</code></td>
<td>
<p>optimal LIWORK (for dtgsen.f only)</p>
</td></tr>
<tr><td><code>'INFO'</code></td>
<td>
<p>= 0: successful. &lt; 0: if INFO = -i, the i-th argument had
an illegal value. =1: reordering of (S,T) failed.</p>
</td></tr>
</table>
<p>Extra returns in the list:
</p>
<table role = "presentation">
<tr><td><code>'ALPHA'</code></td>
<td>
<p>ALPHAR + ALPHAI * i.</p>
</td></tr>
<tr><td><code>'Q'</code></td>
<td>
<p>the reorded left Schur vectors.</p>
</td></tr>
<tr><td><code>'Z'</code></td>
<td>
<p>the reorded right Schur vectors.</p>
</td></tr>
</table>


<h3>Warning(s)</h3>

<p>There is no format checking for <code>S</code>, <code>T</code>, <code>Q</code>, and <code>Z</code>
which are usually returned by <code>qz.dgges</code>.
</p>
<p>There is also no checking for <code>select</code> which is usually according to
the returns of <code>qz.dggev</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://www.netlib.org/lapack/double/dtgsen.f">https://www.netlib.org/lapack/double/dtgsen.f</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.zgges">qz.zgges</a></code>, <code><a href="#topic+qz.dgges">qz.dgges</a></code>, <code><a href="#topic+qz.ztgsen">qz.ztgsen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/numeric/fl/nagdoc_fl23/xhtml/f08/f08ygf.xml
S &lt;- exAB4$S
T &lt;- exAB4$T
Q &lt;- exAB4$Q
Z &lt;- exAB4$Z
select &lt;- c(FALSE, TRUE, TRUE, FALSE)
ret &lt;- qz.dtgsen(S, T, Q, Z, select)

# Verify 1
S.new &lt;- ret$Q %*% ret$S %*% t(ret$Z)
T.new &lt;- ret$Q %*% ret$T %*% t(ret$Z)
round(S - S.new)
round(T - T.new)

# verify 2
round(ret$Q %*% t(ret$Q))
round(ret$Z %*% t(ret$Z))
</code></pre>

<hr>
<h2 id='qz.dtrsen'>Reordered QZ Decomposition for a Real Matrix</h2><span id='topic+qz.dtrsen'></span>

<h3>Description</h3>

<p>This function call 'dtrsend' in Fortran to reorder 'double'
matrices (T,Q).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz.dtrsen(T, Q, select, job = c("B", "V", "E", "N"),
            want.Q = TRUE, LWORK = NULL, LIWORK = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qz.dtrsen_+3A_t">T</code></td>
<td>
<p>a 'double' generalized Schur form, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.dtrsen_+3A_q">Q</code></td>
<td>
<p>a 'double' Schur vectors, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.dtrsen_+3A_select">select</code></td>
<td>
<p>specifies the eigenvalues in the selected cluster.</p>
</td></tr>
<tr><td><code id="qz.dtrsen_+3A_job">job</code></td>
<td>
<p>Specifies whether condition numbers are required for the
cluster of eigenvalues (S) or the invariant subspace (SEP).</p>
</td></tr>
<tr><td><code id="qz.dtrsen_+3A_want.q">want.Q</code></td>
<td>
<p>if update Q.</p>
</td></tr>
<tr><td><code id="qz.dtrsen_+3A_lwork">LWORK</code></td>
<td>
<p>optional, dimension of array WORK for workspace. (&gt;= N(N+1)/2)</p>
</td></tr>
<tr><td><code id="qz.dtrsen_+3A_liwork">LIWORK</code></td>
<td>
<p>optional, dimension of array IWORK for workspace. (&gt;= N(N+1)/4)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'dtrsen.f' for all details.
</p>
<p>DTRSEN reorders the real Schur factorization of a real matrix
A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
the leading diagonal blocks of the upper quasi-triangular matrix T,
and the leading columns of Q form an orthonormal basis of the
corresponding right invariant subspace.
</p>
<p>Optionally the routine computes the reciprocal condition numbers of
the cluster of eigenvalues and/or the invariant subspace.
</p>
<p>T must be in Schur canonical form (as returned by DHSEQR), that is,
block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
2-by-2 diagonal block has its diagonal elements equal and its
off-diagonal elements of opposite sign.
</p>


<h3>Value</h3>

<p>Return a list contains next:
</p>
<table role = "presentation">
<tr><td><code>'T'</code></td>
<td>
<p>T's reorded generalized Schur form.</p>
</td></tr>
<tr><td><code>'WR'</code></td>
<td>
<p>original returns from 'dtrsen.f'.</p>
</td></tr>
<tr><td><code>'WI'</code></td>
<td>
<p>original returns from 'dtrsen.f'.</p>
</td></tr>
<tr><td><code>'M'</code></td>
<td>
<p>original returns from 'dtrsen.f'.</p>
</td></tr>
<tr><td><code>'S'</code></td>
<td>
<p>original returns from 'dtrsen.f'.</p>
</td></tr>
<tr><td><code>'SEP'</code></td>
<td>
<p>original returns from 'dtrsen.f'.</p>
</td></tr>
<tr><td><code>'WORK'</code></td>
<td>
<p>optimal LWORK (for dtrsen.f only)</p>
</td></tr>
<tr><td><code>'IWORK'</code></td>
<td>
<p>optimal LIWORK (for dtrsen.f only)</p>
</td></tr>
<tr><td><code>'INFO'</code></td>
<td>
<p>= 0: successful. &lt; 0: if INFO = -i, the i-th argument had
an illegal value. =1: reordering of T failed.</p>
</td></tr>
</table>
<p>Extra returns in the list:
</p>
<table role = "presentation">
<tr><td><code>'W'</code></td>
<td>
<p>WR + WI * i.</p>
</td></tr>
<tr><td><code>'Q'</code></td>
<td>
<p>the reorded Schur vectors.</p>
</td></tr>
</table>


<h3>Warning(s)</h3>

<p>There is no format checking for <code>T</code> and <code>Q</code>
which are usually returned by <code>qz.dgees</code>.
</p>
<p>There is also no checking for <code>select</code> which is usually according to
the returns of <code>qz.dgeev</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://www.netlib.org/lapack/double/dtrsen.f">https://www.netlib.org/lapack/double/dtrsen.f</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.zgees">qz.zgees</a></code>, <code><a href="#topic+qz.dgees">qz.dgees</a></code>, <code><a href="#topic+qz.ztrsen">qz.ztrsen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/numeric/fl/nagdoc_fl22/xhtml/f08/f08qgf.xml
T &lt;- exA4$T
Q &lt;- exA4$Q
select &lt;- c(TRUE, FALSE, FALSE, TRUE)
ret &lt;- qz.dtrsen(T, Q, select)

# Verify 1
A &lt;- Q %*% T %*% solve(Q)
A.new &lt;- ret$Q %*% ret$T %*% solve(ret$Q)
round(A - A.new)

# verify 2
round(ret$Q %*% t(ret$Q))
</code></pre>

<hr>
<h2 id='qz.zgees'>QZ Decomposition for a Complex Matrix</h2><span id='topic+qz.zgees'></span>

<h3>Description</h3>

<p>This function call 'zgees' in Fortran to decompose a 'complex' matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz.zgees(A, vs = TRUE, LWORK = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qz.zgees_+3A_a">A</code></td>
<td>
<p>a 'complex' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.zgees_+3A_vs">vs</code></td>
<td>
<p>if compute 'complex' Schur vectors. (Q)</p>
</td></tr>
<tr><td><code id="qz.zgees_+3A_lwork">LWORK</code></td>
<td>
<p>optional, dimension of array WORK for workspace. (&gt;= 2N)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'zgees.f' for all details.
</p>
<p>ZGEES computes for an N-by-N complex non-symmetric matrix A, the
eigenvalues, the Schur form T, and, optionally, the matrix of Schur
vectors Q.  This gives the Schur factorization A = Q*T*(Q**H).
</p>
<p>Optionally, it also orders the eigenvalues on the diagonal of the
Schur form so that selected eigenvalues are at the top left.
The leading columns of Q then form an orthonormal basis for the
invariant subspace corresponding to the selected eigenvalues.
</p>
<p>A complex matrix is in Schur form if it is upper triangular.
</p>


<h3>Value</h3>

<p>Return a list contains next:
</p>
<table role = "presentation">
<tr><td><code>'T'</code></td>
<td>
<p>A's generalized Schur form.</p>
</td></tr>
<tr><td><code>'W'</code></td>
<td>
<p>generalized eigenvalues.</p>
</td></tr>
<tr><td><code>'VS'</code></td>
<td>
<p>original returns from 'zgees.f'.</p>
</td></tr>
<tr><td><code>'WORK'</code></td>
<td>
<p>optimal LWORK (for zgees.f only)</p>
</td></tr>
<tr><td><code>'INFO'</code></td>
<td>
<p>= 0: successful. &lt; 0: if INFO = -i, the i-th argument had
an illegal value.
=1,...,N: QZ iteration failed.
=N+1: reordering problem.
=N+2: reordering failed.</p>
</td></tr>
</table>
<p>Extra returns in the list:
</p>
<table role = "presentation">
<tr><td><code>'Q'</code></td>
<td>
<p>the Schur vectors.</p>
</td></tr>
</table>


<h3>Warning(s)</h3>

<p>The results may not be consistent on 32 bits and 64 bits Windows systems,
but may be valid on both systems.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://www.netlib.org/lapack/complex16/zgees.f">https://www.netlib.org/lapack/complex16/zgees.f</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.zgeev">qz.zgeev</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/lapack-ex/node94.html
A &lt;- exA1$A
ret &lt;- qz.zgees(A)

# Verify 1
A.new &lt;- ret$Q %*% ret$T %*% H(ret$Q)
round(A - A.new)

# verify 2
round(ret$Q %*% H(ret$Q))
</code></pre>

<hr>
<h2 id='qz.zgeev'>Generalized Eigenvalues Decomposition for a Complex Matrix</h2><span id='topic+qz.zgeev'></span>

<h3>Description</h3>

<p>This function call 'zgeev' in Fortran to decompose a 'complex' matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz.zgeev(A, vl = TRUE, vr = TRUE, LWORK = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qz.zgeev_+3A_a">A</code></td>
<td>
<p>a 'complex' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.zgeev_+3A_vl">vl</code></td>
<td>
<p>if compute left 'complex' eigen vectors. (U)</p>
</td></tr>
<tr><td><code id="qz.zgeev_+3A_vr">vr</code></td>
<td>
<p>if compute right 'complex' eigen vectors. (V)</p>
</td></tr>
<tr><td><code id="qz.zgeev_+3A_lwork">LWORK</code></td>
<td>
<p>optional, dimension of array WORK for workspace. (&gt;= 2N)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'zgeev.f' for all details.
</p>
<p>ZGEEV computes for an N-by-N complex non-symmetric matrix A, the
eigenvalues and, optionally, the left and/or right eigenvectors.
</p>
<p>The right eigenvector v(j) of A satisfies
</p>
<p>A * v(j) = lambda(j) * v(j)
</p>
<p>where lambda(j) is its eigenvalue.
The left eigenvector u(j) of A satisfies
</p>
<p>u(j)**H * A = lambda(j) * u(j)**H
</p>
<p>where u(j)**H denotes the conjugate transpose of u(j).
</p>
<p>The computed eigenvectors are normalized to have Euclidean norm
equal to 1 and largest component real.
</p>


<h3>Value</h3>

<p>Return a list contains next:
</p>
<table role = "presentation">
<tr><td><code>'W'</code></td>
<td>
<p>original returns from 'zgeev.f'.</p>
</td></tr>
<tr><td><code>'VL'</code></td>
<td>
<p>original returns from 'zgeev.f'.</p>
</td></tr>
<tr><td><code>'VR'</code></td>
<td>
<p>original returns from 'zgeev.f'.</p>
</td></tr>
<tr><td><code>'WORK'</code></td>
<td>
<p>optimal LWORK (for zgeev.f only)</p>
</td></tr>
<tr><td><code>'INFO'</code></td>
<td>
<p>= 0: successful. &lt; 0: if INFO = -i, the i-th argument had
an illegal value. &gt; 0: QZ iteration failed.</p>
</td></tr>
</table>
<p>Extra returns in the list:
</p>
<table role = "presentation">
<tr><td><code>'U'</code></td>
<td>
<p>the left eigen vectors.</p>
</td></tr>
<tr><td><code>'V'</code></td>
<td>
<p>the right eigen vectors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://www.netlib.org/lapack/complex16/zgeev.f">https://www.netlib.org/lapack/complex16/zgeev.f</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.zgees">qz.zgees</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/lapack-ex/node92.html
A &lt;- exA1$A
ret &lt;- qz.zgeev(A)

# Verify 1
diff.R &lt;- A %*% ret$V - matrix(ret$W, 4, 4, byrow = TRUE) * ret$V
diff.L &lt;- H(ret$U) %*% A - matrix(ret$W, 4, 4) * H(ret$U)
round(diff.R)
round(diff.L)

# Verify 2
round(ret$U %*% H(ret$U))
round(ret$V %*% H(ret$V))
</code></pre>

<hr>
<h2 id='qz.zgges'>QZ Decomposition for Complex Paired Matrices</h2><span id='topic+qz.zgges'></span>

<h3>Description</h3>

<p>This function call 'zgges' in Fortran to decompose 'complex' matrices (A,B).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz.zgges(A, B, vsl = TRUE, vsr = TRUE, LWORK = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qz.zgges_+3A_a">A</code></td>
<td>
<p>a 'complex' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.zgges_+3A_b">B</code></td>
<td>
<p>a 'complex' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.zgges_+3A_vsl">vsl</code></td>
<td>
<p>if compute left 'complex' Schur vectors. (Q)</p>
</td></tr>
<tr><td><code id="qz.zgges_+3A_vsr">vsr</code></td>
<td>
<p>if compute right 'complex' Schur vectors. (Z)</p>
</td></tr>
<tr><td><code id="qz.zgges_+3A_lwork">LWORK</code></td>
<td>
<p>optional, dimension of array WORK for workspace. (&gt;= 2N)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'zgges.f' for all details.
</p>
<p>ZGGES computes for a pair of N-by-N complex non-symmetric matrices
(A,B), the generalized eigenvalues, the generalized complex Schur
form (S, T), and optionally left and/or right Schur vectors (VSL
and VSR). This gives the generalized Schur factorization
</p>
<p>(A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
</p>
<p>where (VSR)**H is the conjugate-transpose of VSR.
</p>
<p>Optionally, it also orders the eigenvalues so that a selected cluster
of eigenvalues appears in the leading diagonal blocks of the upper
triangular matrix S and the upper triangular matrix T. The leading
columns of VSL and VSR then form an unitary basis for the
corresponding left and right eigenspaces (deflating subspaces).
</p>
<p>(If only the generalized eigenvalues are needed, use the driver
ZGGEV instead, which is faster.)
</p>
<p>A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
usually represented as the pair (alpha,beta), as there is a
reasonable interpretation for beta=0, and even for both being zero.
</p>
<p>A pair of matrices (S,T) is in generalized complex Schur form if S
and T are upper triangular and, in addition, the diagonal elements
of T are non-negative real numbers.
</p>


<h3>Value</h3>

<p>Return a list contains next:
</p>
<table role = "presentation">
<tr><td><code>'S'</code></td>
<td>
<p>A's generalized Schur form.</p>
</td></tr>
<tr><td><code>'T'</code></td>
<td>
<p>B's generalized Schur form.</p>
</td></tr>
<tr><td><code>'ALPHA'</code></td>
<td>
<p>ALPHA[j]/BETA[j] are generalized eigenvalues.</p>
</td></tr>
<tr><td><code>'BETA'</code></td>
<td>
<p>ALPHA[j]/BETA[j] are generalized eigenvalues.</p>
</td></tr>
<tr><td><code>'VSL'</code></td>
<td>
<p>original returns from 'zgges.f'.</p>
</td></tr>
<tr><td><code>'VSR'</code></td>
<td>
<p>original returns from 'zgges.f'.</p>
</td></tr>
<tr><td><code>'WORK'</code></td>
<td>
<p>optimal LWORK (for zgges.f only)</p>
</td></tr>
<tr><td><code>'INFO'</code></td>
<td>
<p>= 0: successful. &lt; 0: if INFO = -i, the i-th argument had
an illegal value. =1,...,N: QZ iteration failed.
=N+1: other than QZ iteration failed in ZHGEQZ.
=N+2: reordering problem.
=N+3: reordering failed.</p>
</td></tr>
</table>
<p>Extra returns in the list:
</p>
<table role = "presentation">
<tr><td><code>'Q'</code></td>
<td>
<p>the left Schur vectors.</p>
</td></tr>
<tr><td><code>'Z'</code></td>
<td>
<p>the right Schur vectors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://www.netlib.org/lapack/complex16/zgges.f">https://www.netlib.org/lapack/complex16/zgges.f</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.zggev">qz.zggev</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/lapack-ex/node124.html
A &lt;- exAB1$A
B &lt;- exAB1$B
ret &lt;- qz.zgges(A, B)

# Verify 1
A.new &lt;- ret$Q %*% ret$S %*% H(ret$Z)
B.new &lt;- ret$Q %*% ret$T %*% H(ret$Z)
round(A - A.new)
round(B - B.new)

# verify 2
round(ret$Q %*% H(ret$Q))
round(ret$Z %*% H(ret$Z))
</code></pre>

<hr>
<h2 id='qz.zggev'>Generalized Eigenvalues Decomposition for Complex Paired Matrices</h2><span id='topic+qz.zggev'></span>

<h3>Description</h3>

<p>This function call 'zggev' in Fortran to decompose 'complex' matrices (A,B).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz.zggev(A, B, vl = TRUE, vr = TRUE, LWORK = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qz.zggev_+3A_a">A</code></td>
<td>
<p>a 'complex' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.zggev_+3A_b">B</code></td>
<td>
<p>a 'complex' matrix, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.zggev_+3A_vl">vl</code></td>
<td>
<p>if compute left 'complex' eigen vectors. (U)</p>
</td></tr>
<tr><td><code id="qz.zggev_+3A_vr">vr</code></td>
<td>
<p>if compute right 'complex' eigen vectors. (V)</p>
</td></tr>
<tr><td><code id="qz.zggev_+3A_lwork">LWORK</code></td>
<td>
<p>optional, dimension of array WORK for workspace. (&gt;= 2N)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'zggev.f' for all details.
</p>
<p>ZGGEV computes for a pair of N-by-N complex non-symmetric matrices
(A,B), the generalized eigenvalues, and optionally, the left and/or
right generalized eigenvectors.
</p>
<p>A generalized eigenvalue for a pair of matrices (A,B) is a scalar
lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
singular. It is usually represented as the pair (alpha,beta), as
there is a reasonable interpretation for beta=0, and even for both
being zero.
</p>
<p>The right generalized eigenvector v(j) corresponding to the
generalized eigenvalue lambda(j) of (A,B) satisfies
</p>
<p>A * v(j) = lambda(j) * B * v(j).
</p>
<p>The left generalized eigenvector u(j) corresponding to the
generalized eigenvalues lambda(j) of (A,B) satisfies
</p>
<p>u(j)**H * A = lambda(j) * u(j)**H * B
</p>
<p>where u(j)**H is the conjugate-transpose of u(j).
</p>


<h3>Value</h3>

<p>Return a list contains next:
</p>
<table role = "presentation">
<tr><td><code>'ALPHA'</code></td>
<td>
<p>original returns from 'zggev.f'.</p>
</td></tr>
<tr><td><code>'BETA'</code></td>
<td>
<p>original returns from 'zggev.f'.</p>
</td></tr>
<tr><td><code>'VL'</code></td>
<td>
<p>original returns from 'zggev.f'.</p>
</td></tr>
<tr><td><code>'VR'</code></td>
<td>
<p>original returns from 'zggev.f'.</p>
</td></tr>
<tr><td><code>'WORK'</code></td>
<td>
<p>optimal LWORK (for zggev.f only)</p>
</td></tr>
<tr><td><code>'INFO'</code></td>
<td>
<p>= 0: successful. &lt; 0: if INFO = -i, the i-th argument had
an illegal value. =1,...,N: QZ iteration failed.
=N+1: other than QZ iteration failed in ZHGEQZ.
=N+2: reordering problem.
=N+3: reordering failed.</p>
</td></tr>
</table>
<p>Extra returns in the list:
</p>
<table role = "presentation">
<tr><td><code>'U'</code></td>
<td>
<p>the left eigen vectors.</p>
</td></tr>
<tr><td><code>'V'</code></td>
<td>
<p>the right eigen vectors.</p>
</td></tr>
</table>
<p>Note that 'VL' and 'VR' are scaled so the largest component has
abs(real part) + abs(imag. part) = 1.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://www.netlib.org/lapack/complex16/zggev.f">https://www.netlib.org/lapack/complex16/zggev.f</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.zgges">qz.zgges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/lapack-ex/node122.html
A &lt;- exAB1$A
B &lt;- exAB1$B
ret &lt;- qz.zggev(A, B)

# Verify 1
(lambda &lt;- ret$ALPHA / ret$BETA)    # Unstable
diff.R &lt;- matrix(ret$BETA, 4, 4, byrow = TRUE) * A %*% ret$V -
          matrix(ret$ALPHA, 4, 4, byrow = TRUE) * B %*% ret$V
diff.L &lt;- matrix(ret$BETA, 4, 4) * H(ret$U) %*% A -
          matrix(ret$ALPHA, 4, 4) * H(ret$U) %*% B
round(diff.R)
round(diff.L)

# Verify 2
round(ret$U %*% solve(ret$U))
round(ret$V %*% solve(ret$V))
</code></pre>

<hr>
<h2 id='qz.ztgsen'>Reordered QZ Decomposition for Complex Paired Matrices</h2><span id='topic+qz.ztgsen'></span>

<h3>Description</h3>

<p>This function call 'ztgsend' in Fortran to reorder 'complex'
matrices (S,T,Q,Z).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz.ztgsen(S, T, Q, Z, select, ijob = 4L,
            want.Q = TRUE, want.Z = TRUE, LWORK = NULL, LIWORK = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qz.ztgsen_+3A_s">S</code></td>
<td>
<p>a 'complex' generalized Schur form, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.ztgsen_+3A_t">T</code></td>
<td>
<p>a 'complex' generalized Schur form, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.ztgsen_+3A_q">Q</code></td>
<td>
<p>a 'complex' left Schur vectors, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.ztgsen_+3A_z">Z</code></td>
<td>
<p>a 'complex' right Schur vectors, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.ztgsen_+3A_select">select</code></td>
<td>
<p>specifies the eigenvalues in the selected cluster.</p>
</td></tr>
<tr><td><code id="qz.ztgsen_+3A_ijob">ijob</code></td>
<td>
<p>specifies whether condition numbers are required for the
cluster of eigenvalues (PL and PR) or the deflating subspaces
(Difu and Difl).</p>
</td></tr>
<tr><td><code id="qz.ztgsen_+3A_want.q">want.Q</code></td>
<td>
<p>if update Q.</p>
</td></tr>
<tr><td><code id="qz.ztgsen_+3A_want.z">want.Z</code></td>
<td>
<p>if update Z.</p>
</td></tr>
<tr><td><code id="qz.ztgsen_+3A_lwork">LWORK</code></td>
<td>
<p>optional, dimension of array WORK for workspace. (&gt;= N(N+1))</p>
</td></tr>
<tr><td><code id="qz.ztgsen_+3A_liwork">LIWORK</code></td>
<td>
<p>optional, dimension of array IWORK for workspace. (&gt;= max(N+2, N(N+1)/2))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'ztgsen.f' for all details.
</p>
<p>ZTGSEN reorders the generalized Schur decomposition of a complex
matrix pair (S,T) (in terms of an unitary equivalence transformation
Q**H * (S,T) * Z), so that a selected cluster of eigenvalues
appears in the leading diagonal blocks of the pair (S,T). The leading
columns of Q and Z form unitary bases of the corresponding left and
right eigenspaces (deflating subspaces). (S,T) must be in
generalized Schur canonical form, that is, S and T are both upper
triangular.
</p>
<p>ZTGSEN also computes the generalized eigenvalues
</p>
<p>w(j)= ALPHA(j) / BETA(j)
</p>
<p>of the reordered matrix pair (S,T).
</p>
<p>Note for 'ijob': <br />
=0: Only reorder w.r.t. SELECT. No extras. <br />
=1: Reciprocal of norms of &quot;projections&quot; onto left and right
eigenspaces w.r.t. the selected cluster (PL and PR). <br />
=2: Upper bounds on Difu and Difl. F-norm-based estimate (DIF(1:2)). <br />
=3: Estimate of Difu and Difl. 1-norm-based estimate
(DIF(1:2)). About 5 times as expensive as ijob = 2. <br />
=4: Compute PL, PR and DIF (i.e. 0, 1 and 2 above): Economic
version to get it all. <br />
=5: Compute PL, PR and DIF (i.e. 0, 1 and 3 above). <br />
</p>
<p>In short, if (A,B) = Q * (S,T) * Z**H from <code>qz.zgges</code> and input
(S,T,Q,Z) to <code>qz.ztgsen</code> with appropriate <code>select</code> option,
then it yields
</p>
<p>(A,B) = Q_n * (S_n,T_n) * Z_n**H
</p>
<p>where (S_n,T_n,Q_n,Z_n) is a new set of generalized Schur decomposition
of (A,B) according to the <code>select</code>.
</p>


<h3>Value</h3>

<p>Return a list contains next:
</p>
<table role = "presentation">
<tr><td><code>'S'</code></td>
<td>
<p>S's reorded generalized Schur form.</p>
</td></tr>
<tr><td><code>'T'</code></td>
<td>
<p>T's reorded generalized Schur form.</p>
</td></tr>
<tr><td><code>'ALPHA'</code></td>
<td>
<p>ALPHA[j]/BETA[j] are generalized eigenvalues.</p>
</td></tr>
<tr><td><code>'BETA'</code></td>
<td>
<p>ALPHA[j]/BETA[j] are generalized eigenvalues.</p>
</td></tr>
<tr><td><code>'M'</code></td>
<td>
<p>original returns from 'ztgsen.f'.</p>
</td></tr>
<tr><td><code>'PL'</code></td>
<td>
<p>original returns from 'ztgsen.f'.</p>
</td></tr>
<tr><td><code>'PR'</code></td>
<td>
<p>original returns from 'ztgsen.f'.</p>
</td></tr>
<tr><td><code>'DIF'</code></td>
<td>
<p>original returns from 'ztgsen.f'.</p>
</td></tr>
<tr><td><code>'WORK'</code></td>
<td>
<p>optimal LWORK (for ztgsen.f only)</p>
</td></tr>
<tr><td><code>'IWORK'</code></td>
<td>
<p>optimal LIWORK (for ztgsen.f only)</p>
</td></tr>
<tr><td><code>'INFO'</code></td>
<td>
<p>= 0: successful. &lt; 0: if INFO = -i, the i-th argument had
an illegal value. =1: reordering of (S,T) failed.</p>
</td></tr>
</table>
<p>Extra returns in the list:
</p>
<table role = "presentation">
<tr><td><code>'Q'</code></td>
<td>
<p>the reorded left Schur vectors.</p>
</td></tr>
<tr><td><code>'Z'</code></td>
<td>
<p>the reorded right Schur vectors.</p>
</td></tr>
</table>


<h3>Warning(s)</h3>

<p>There is no format checking for <code>S</code>, <code>T</code>, <code>Q</code>, and <code>Z</code>
which are usually returned by <code>qz.zgges</code>.
</p>
<p>There is also no checking for <code>select</code> which is usually according to
the returns of <code>qz.zggev</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://www.netlib.org/lapack/complex16/ztgsen.f">https://www.netlib.org/lapack/complex16/ztgsen.f</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.zgges">qz.zgges</a></code>, <code><a href="#topic+qz.dgges">qz.dgges</a></code>, <code><a href="#topic+qz.dtgsen">qz.dtgsen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/numeric/fl/nagdoc_fl23/xhtml/f08/f08yuf.xml
S &lt;- exAB3$S
T &lt;- exAB3$T
Q &lt;- exAB3$Q
Z &lt;- exAB3$Z
select &lt;- c(FALSE, TRUE, TRUE, FALSE)
ret &lt;- qz.ztgsen(S, T, Q, Z, select)

# Verify 1
S.new &lt;- ret$Q %*% ret$S %*% H(ret$Z)
T.new &lt;- ret$Q %*% ret$T %*% H(ret$Z)
round(S - S.new)
round(T - T.new)

# verify 2
round(ret$Q %*% H(ret$Q))
round(ret$Z %*% H(ret$Z))
</code></pre>

<hr>
<h2 id='qz.ztrsen'>Reordered QZ Decomposition for a Complex Matrix</h2><span id='topic+qz.ztrsen'></span>

<h3>Description</h3>

<p>This function call 'ztrsend' in Fortran to reorder 'complex'
matrix (T,Q).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qz.ztrsen(T, Q, select, job = c("B", "V", "E", "N"),
            want.Q = TRUE, LWORK = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qz.ztrsen_+3A_t">T</code></td>
<td>
<p>a 'complex' generalized Schur form, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.ztrsen_+3A_q">Q</code></td>
<td>
<p>a 'complex' Schur vectors, dim = c(N, N).</p>
</td></tr>
<tr><td><code id="qz.ztrsen_+3A_select">select</code></td>
<td>
<p>specifies the eigenvalues in the selected cluster.</p>
</td></tr>
<tr><td><code id="qz.ztrsen_+3A_job">job</code></td>
<td>
<p>Specifies whether condition numbers are required for the
cluster of eigenvalues (S) or the invariant subspace (SEP).</p>
</td></tr>
<tr><td><code id="qz.ztrsen_+3A_want.q">want.Q</code></td>
<td>
<p>if update Q.</p>
</td></tr>
<tr><td><code id="qz.ztrsen_+3A_lwork">LWORK</code></td>
<td>
<p>optional, dimension of array WORK for workspace. (&gt;= N(N+1)/2)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'ztrsen.f' for all details.
</p>
<p>ZTRSEN reorders the Schur factorization of a complex matrix
A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
the leading positions on the diagonal of the upper triangular matrix
T, and the leading columns of Q form an orthonormal basis of the
corresponding right invariant subspace.
</p>
<p>Optionally the routine computes the reciprocal condition numbers of
the cluster of eigenvalues and/or the invariant subspace.
</p>


<h3>Value</h3>

<p>Return a list contains next:
</p>
<table role = "presentation">
<tr><td><code>'T'</code></td>
<td>
<p>T's reorded generalized Schur form.</p>
</td></tr>
<tr><td><code>'W'</code></td>
<td>
<p>generalized eigenvalues.</p>
</td></tr>
<tr><td><code>'M'</code></td>
<td>
<p>original returns from 'ztrsen.f'.</p>
</td></tr>
<tr><td><code>'S'</code></td>
<td>
<p>original returns from 'ztrsen.f'.</p>
</td></tr>
<tr><td><code>'SEP'</code></td>
<td>
<p>original returns from 'ztrsen.f'.</p>
</td></tr>
<tr><td><code>'WORK'</code></td>
<td>
<p>optimal LWORK (for ztrsen.f only)</p>
</td></tr>
<tr><td><code>'INFO'</code></td>
<td>
<p>= 0: successful. &lt; 0: if INFO = -i, the i-th argument had
an illegal value.</p>
</td></tr>
</table>
<p>Extra returns in the list:
</p>
<table role = "presentation">
<tr><td><code>'Q'</code></td>
<td>
<p>the reorded Schur vectors.</p>
</td></tr>
</table>


<h3>Warning(s)</h3>

<p>There is no format checking for <code>T</code> and <code>Q</code>
which are usually returned by <code>qz.zgees</code>.
</p>
<p>There is also no checking for <code>select</code> which is usually according to
the returns of <code>qz.zgeev</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1999) <em>LAPACK User's Guide,</em>
3rd edition, SIAM, Philadelphia.
</p>
<p><a href="https://www.netlib.org/lapack/complex16/ztrsen.f">https://www.netlib.org/lapack/complex16/ztrsen.f</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Schur_decomposition">https://en.wikipedia.org/wiki/Schur_decomposition</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qz.zgees">qz.zgees</a></code>, <code><a href="#topic+qz.dgees">qz.dgees</a></code>, <code><a href="#topic+qz.dtrsen">qz.dtrsen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(QZ, quiet = TRUE)

### https://www.nag.com/numeric/fl/nagdoc_fl23/xhtml/f08/f08quf.xml
T &lt;- exA3$T
Q &lt;- exA3$Q
select &lt;- c(TRUE, FALSE, FALSE, TRUE)
ret &lt;- qz.ztrsen(T, Q, select)

# Verify 1
A &lt;- Q %*% T %*% solve(Q)
A.new &lt;- ret$Q %*% ret$T %*% solve(ret$Q)
round(A - A.new)

# verify 2
round(ret$Q %*% solve(ret$Q))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
