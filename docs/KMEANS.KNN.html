<!DOCTYPE html><html><head><title>Help for package KMEANS.KNN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {KMEANS.KNN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#KMEANS.KNN-package'><p>KMEANS.KNN: KMeans and KNN Clustering Package</p></a></li>
<li><a href='#find_Kmeans_best_k'><p>find_Kmeans_best_k</p></a></li>
<li><a href='#find_Knn_best_k'><p>find_Knn_best_k</p></a></li>
<li><a href='#KMEANS_FUNCTION'><p>KMEANS_FUNCTION</p></a></li>
<li><a href='#knn_Function'><p>knn_Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>KMeans and KNN Clustering Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of Kmeans clustering algorithm and a supervised KNN (K Nearest Neighbors) learning method. It allows users to perform unsupervised clustering and supervised classification on their datasets. Additional features include data normalization, imputation of missing values, and the choice of distance metric. The package also provides functions to determine the optimal number of clusters for Kmeans and the best k-value for KNN: knn_Function(), find_Knn_best_k(), KMEANS_FUNCTION(), and find_Kmeans_best_k().</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>factoextra, cluster, ggplot2, stats, assertthat, class, caret,
grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-16 14:54:49 UTC; USER</td>
</tr>
<tr>
<td>Author:</td>
<td>LALLOGO Lassané <a href="https://orcid.org/0009-0004-1637-3511"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>LALLOGO Lassané &lt;lassanelallogo2002@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-17 09:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='KMEANS.KNN-package'>KMEANS.KNN: KMeans and KNN Clustering Package</h2><span id='topic+KMEANS.KNN'></span><span id='topic+KMEANS.KNN-package'></span>

<h3>Description</h3>

<p>Implementation of Kmeans clustering algorithm and a supervised KNN (K Nearest Neighbors) learning method. It allows users to perform unsupervised clustering and supervised classification on their datasets. Additional features include data normalization, imputation of missing values, and the choice of distance metric. The package also provides functions to determine the optimal number of clusters for Kmeans and the best k-value for KNN: knn_Function(), find_Knn_best_k(), KMEANS_FUNCTION(), and find_Kmeans_best_k().
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: LALLOGO Lassané <a href="mailto:lassanelallogo2002@gmail.com">lassanelallogo2002@gmail.com</a> (<a href="https://orcid.org/0009-0004-1637-3511">ORCID</a>)
</p>

<hr>
<h2 id='find_Kmeans_best_k'>find_Kmeans_best_k</h2><span id='topic+find_Kmeans_best_k'></span>

<h3>Description</h3>

<p>find_Kmeans_best_k
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_Kmeans_best_k(data, max_k = 10, Method = "coude", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_Kmeans_best_k_+3A_data">data</code></td>
<td>
<p>The dataset for which K-means clustering will be performed.</p>
</td></tr>
<tr><td><code id="find_Kmeans_best_k_+3A_max_k">max_k</code></td>
<td>
<p>The maximum number of clusters to consider. It defaults to 10.</p>
</td></tr>
<tr><td><code id="find_Kmeans_best_k_+3A_method">Method</code></td>
<td>
<p>The method used to determine the optimal number of clusters.
Acceptable values are &quot;coude&quot; (elbow method), &quot;silhouette&quot; (silhouette method),
or &quot;gap&quot; (gap statistics).</p>
</td></tr>
<tr><td><code id="find_Kmeans_best_k_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, additional output is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return a value but prints the optimal number of clusters
based on the chosen method and plots the corresponding graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
find_Kmeans_best_k(iris[,-5],9,Method = "coude")
</code></pre>

<hr>
<h2 id='find_Knn_best_k'>find_Knn_best_k</h2><span id='topic+find_Knn_best_k'></span>

<h3>Description</h3>

<p>This function finds the best k-value for KNN based on the provided data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_Knn_best_k(data, target_column, k_values, Prop_train = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_Knn_best_k_+3A_data">data</code></td>
<td>
<p>A dataframe containing the dataset to be used.</p>
</td></tr>
<tr><td><code id="find_Knn_best_k_+3A_target_column">target_column</code></td>
<td>
<p>A string specifying the name of the target column in the dataset.</p>
</td></tr>
<tr><td><code id="find_Knn_best_k_+3A_k_values">k_values</code></td>
<td>
<p>A numeric vector containing the different k-values to be tested.</p>
</td></tr>
<tr><td><code id="find_Knn_best_k_+3A_prop_train">Prop_train</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the proportion of the dataset to be used for training.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a dataframe with k-values and their corresponding accuracies, and the best k-value with its accuracy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
find_Knn_best_k(iris,"Species",1:10,Prop_train=0.8)
</code></pre>

<hr>
<h2 id='KMEANS_FUNCTION'>KMEANS_FUNCTION</h2><span id='topic+KMEANS_FUNCTION'></span>

<h3>Description</h3>

<p>This function implements the K-Means algorithm for data clustering.
It provides options for data preprocessing, such as normalization
and imputation of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KMEANS_FUNCTION(
  data,
  k,
  max_iter = 100,
  nstart = 25,
  distance_metric = "euclidean",
  scale_data = FALSE,
  impute_data = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KMEANS_FUNCTION_+3A_data">data</code></td>
<td>
<p>A dataframe containing the numerical data to be clustered.</p>
</td></tr>
<tr><td><code id="KMEANS_FUNCTION_+3A_k">k</code></td>
<td>
<p>The number of clusters to form.</p>
</td></tr>
<tr><td><code id="KMEANS_FUNCTION_+3A_max_iter">max_iter</code></td>
<td>
<p>The maximum number of iterations for the K-Means algorithm.</p>
</td></tr>
<tr><td><code id="KMEANS_FUNCTION_+3A_nstart">nstart</code></td>
<td>
<p>The number of times to randomly initialize the centroids.</p>
</td></tr>
<tr><td><code id="KMEANS_FUNCTION_+3A_distance_metric">distance_metric</code></td>
<td>
<p>The distance metric to use ('euclidean' or 'manhattan').</p>
</td></tr>
<tr><td><code id="KMEANS_FUNCTION_+3A_scale_data">scale_data</code></td>
<td>
<p>A boolean indicating whether the data should be normalized.</p>
</td></tr>
<tr><td><code id="KMEANS_FUNCTION_+3A_impute_data">impute_data</code></td>
<td>
<p>The imputation method for missing values ('mean', 'median', 'mode').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
- clusters: A vector indicating the cluster of each point.
- centers: The coordinates of the centroids of each cluster.
- additional_info: Additional information such as total distance and number of iterations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
data_iris &lt;- iris[, -5] # Exclude the species column
results &lt;- KMEANS_FUNCTION(data_iris, k = 3)
print(results$clusters)
</code></pre>

<hr>
<h2 id='knn_Function'>knn_Function</h2><span id='topic+knn_Function'></span>

<h3>Description</h3>

<p>This function implements a custom K-Nearest Neighbors (KNN) algorithm with data preprocessing options. It predicts the class of a new point based on the k closest neighbors in the feature space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn_Function(
  new_points,
  dataset,
  k = 5,
  distance_metric = "gower",
  target_variable,
  scale_data = TRUE,
  impute_data = "mean",
  weight_votes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_Function_+3A_new_points">new_points</code></td>
<td>
<p>A dataframe of new points to be classified.</p>
</td></tr>
<tr><td><code id="knn_Function_+3A_dataset">dataset</code></td>
<td>
<p>A dataframe of training data.</p>
</td></tr>
<tr><td><code id="knn_Function_+3A_k">k</code></td>
<td>
<p>The number of nearest neighbors to consider.</p>
</td></tr>
<tr><td><code id="knn_Function_+3A_distance_metric">distance_metric</code></td>
<td>
<p>The distance metric for calculating neighbors ('gower', 'euclidean', 'manhattan').</p>
</td></tr>
<tr><td><code id="knn_Function_+3A_target_variable">target_variable</code></td>
<td>
<p>The name of the target variable in 'dataset'.</p>
</td></tr>
<tr><td><code id="knn_Function_+3A_scale_data">scale_data</code></td>
<td>
<p>A boolean to indicate whether the data should be normalized.</p>
</td></tr>
<tr><td><code id="knn_Function_+3A_impute_data">impute_data</code></td>
<td>
<p>The imputation method for missing values ('mean', 'median', 'mode').</p>
</td></tr>
<tr><td><code id="knn_Function_+3A_weight_votes">weight_votes</code></td>
<td>
<p>A boolean to indicate whether votes should be weighted by the inverse of the distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing 'Predictions' with the predicted class for each new point, 'Data' with the 'new_points' dataframe and an additional column for predictions, 'Distances' with the distances of the k nearest neighbors, and 'Imputed_Values' with the imputed values for missing variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading training data (e.g., iris)
data(iris)

# Preparing new points for prediction (e.g., two new observations)
new_points &lt;- data.frame(Sepal.Length = c(5.1, 7.7, 1.3, 0.2, 5.1),
Sepal.Width = c(3.5, 2.6, 5, 3.7, 3.5),
Petal.Length = c(1.4 , 6.9, 4.5, 6, 3.4),
Petal.Width = c(10.1, 7.6, 5.6, 8.4, 5.2))

# Calling the custom KNN function
results &lt;- knn_Function(new_points, dataset = iris, k = 3, target_variable = "Species")

# Displaying predictions
print(results$Predictions)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
