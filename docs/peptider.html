<!DOCTYPE html><html><head><title>Help for package peptider</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {peptider}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BLOSUM80'><p>BLOSUM80 matrix</p></a></li>
<li><a href='#codons'><p>Compute the number of codon representations for a (vector of) peptide sequence(s)</p></a></li>
<li><a href='#coverage'><p>Coverage as expected number of peptides given all possible peptides</p></a></li>
<li><a href='#detect'><p>Detection probability in a single library of size N</p></a></li>
<li><a href='#diversity'><p>Diversity according to peptides paper (Sieber)</p></a></li>
<li><a href='#efficiency'><p>Relative efficiency of a library</p></a></li>
<li><a href='#encodingReduce'><p>Reduce the regular encoding to an easier/faster format</p></a></li>
<li><a href='#generateCustom'><p>Generate peptide and library information for a given scheme</p></a></li>
<li><a href='#generateCustomLib'><p>For a given scheme, generate a dataset with the library information</p></a></li>
<li><a href='#generateCustomNei'><p>For a given scheme, generate a dataset with the neighborhood information</p></a></li>
<li><a href='#generateCustomProbs'><p>For a given scheme, generate a dataset with the peptide probabilities</p></a></li>
<li><a href='#genNeighbors'><p>Calculate neighborhood distribution</p></a></li>
<li><a href='#genNeighbors_reduced'><p>Calculate neighborhood distribution</p></a></li>
<li><a href='#getChoices'><p>Get the number of peptides that reduce to a particular reduced encoding</p></a></li>
<li><a href='#getCounts'><p>Get the counts possible for each scheme and k</p></a></li>
<li><a href='#getNeighbors'><p>Find all neighbors of degree one for a set of peptide sequences</p></a></li>
<li><a href='#getNofNeighbors'><p>Compute the number of neighbor of degree one for a set of peptide sequences</p></a></li>
<li><a href='#libBuild'><p>Build peptide library of k-length sequences according to specified scheme</p></a></li>
<li><a href='#libscheme'><p>Get the specified library scheme</p></a></li>
<li><a href='#makowski'><p>Diversity index according to Makowski</p></a></li>
<li><a href='#ppeptide'><p>Probability of detection of a peptide sequence</p></a></li>
<li><a href='#scheme'><p>Get the specified library scheme definition</p></a></li>
<li><a href='#schemes'><p>Built-in library schemes for peptider</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Evaluation of Diversity in Nucleotide Libraries</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Evaluation of diversity in peptide libraries, including NNN, NNB,
    NNK/S, and 20/20 schemes. Custom encoding schemes can also be defined.
    Metrics for evaluation include expected coverage, relative efficiency, and
    the functional diversity of the library. Peptide-level inclusion
    probabilities are computable for both the native and custom encoding
    schemes.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/heike/peptider">https://github.com/heike/peptider</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/heike/peptider/issues">https://github.com/heike/peptider/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>discreteRV (&ge; 1.2), plyr, dplyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-09-15 18:21:31 UTC; erichare</td>
</tr>
<tr>
<td>Author:</td>
<td>Heike Hofmann [aut],
  Eric Hare [aut, cre],
  GGobi Foundation [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Hare &lt;erichare@iastate.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-09-16 10:05:27</td>
</tr>
</table>
<hr>
<h2 id='BLOSUM80'>BLOSUM80 matrix</h2><span id='topic+BLOSUM80'></span>

<h3>Description</h3>

<p>The BLOSUM80 matrix, which stands for Blocks Substitution Matrix, defines log-odds scores for the ratio of the chance of two amino acids appearing in a sequence over the chance that the two amino acids appear in any sequence.  Larger scores indicate a higher probability of substitutions.  This matrix is used in order to compute sequences which are in the neighborhood of other sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BLOSUM80)
</code></pre>


<h3>Details</h3>

<p>BLOSUM80 matrix
</p>

<hr>
<h2 id='codons'>Compute the number of codon representations for a (vector of) peptide sequence(s)</h2><span id='topic+codons'></span>

<h3>Description</h3>

<p>use this function for only a few peptide sequences. Any larger number of peptide sequences should be dealt with in the framework of the library scheme and the detect function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codons(x, libscheme, flag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codons_+3A_x">x</code></td>
<td>
<p>(vector) of character strings of  peptide sequences.</p>
</td></tr>
<tr><td><code id="codons_+3A_libscheme">libscheme</code></td>
<td>
<p>library scheme under which neighbors are being calculated. this is only of importance, if method=&quot;dna&quot;</p>
</td></tr>
<tr><td><code id="codons_+3A_flag">flag</code></td>
<td>
<p>internal use only: Set to true if calling this from another function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of numbers of codons
</p>


<h3>Examples</h3>

<pre><code class='language-R'>codons("APE", libscheme="NNK")
codons("HENNING", libscheme="NNK")
</code></pre>

<hr>
<h2 id='coverage'>Coverage as expected number of peptides given all possible peptides</h2><span id='topic+coverage'></span>

<h3>Description</h3>

<p>Coverage of library of size N given random sampling from the pool of all possible peptides according to probabilities determined according to the library scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage(k, libscheme, N, lib = NULL, variance = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coverage_+3A_k">k</code></td>
<td>
<p>length of peptide sequences</p>
</td></tr>
<tr><td><code id="coverage_+3A_libscheme">libscheme</code></td>
<td>
<p>Name (character vector) or definition (data frame) of scheme</p>
</td></tr>
<tr><td><code id="coverage_+3A_n">N</code></td>
<td>
<p>size of the library</p>
</td></tr>
<tr><td><code id="coverage_+3A_lib">lib</code></td>
<td>
<p>library scheme</p>
</td></tr>
<tr><td><code id="coverage_+3A_variance">variance</code></td>
<td>
<p>return the variance instead of the expected value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coverage index between 0 and 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coverage(2, "NNN", 10^3)
coverage(2, "NNK", 10^3)
coverage(2, "2020", 10^3) ## 20/20 coverage is not 1 because of random sampling.
</code></pre>

<hr>
<h2 id='detect'>Detection probability in a single library of size N</h2><span id='topic+detect'></span>

<h3>Description</h3>

<p>The probability that at least one of a number of specific peptide sequences (e. g. the &lsquo;best&rsquo; and closely related sequences) is contained in a library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect(lib = libscheme("NNK", 7), size = 10^8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_+3A_lib">lib</code></td>
<td>
<p>library used in experiment, defaults to NNK with peptide length 7</p>
</td></tr>
<tr><td><code id="detect_+3A_size">size</code></td>
<td>
<p>size of the library, defaults to 10^8</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of detection probabilities for peptide sequences in each class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(detect())

require(ggplot2)
lib &lt;- libscheme("NNK", 7)
qplot(detect(lib, size=10^8), weight=di, geom="histogram", data=lib$data)
</code></pre>

<hr>
<h2 id='diversity'>Diversity according to peptides paper (Sieber)</h2><span id='topic+diversity'></span>

<h3>Description</h3>

<p>Diversity according to peptides paper (Sieber)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversity(k, libscheme, N, lib = NULL, variance = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diversity_+3A_k">k</code></td>
<td>
<p>length of peptide sequences</p>
</td></tr>
<tr><td><code id="diversity_+3A_libscheme">libscheme</code></td>
<td>
<p>Name (character vector) or definition (data frame) of scheme</p>
</td></tr>
<tr><td><code id="diversity_+3A_n">N</code></td>
<td>
<p>size of the library</p>
</td></tr>
<tr><td><code id="diversity_+3A_lib">lib</code></td>
<td>
<p>library scheme</p>
</td></tr>
<tr><td><code id="diversity_+3A_variance">variance</code></td>
<td>
<p>return the variance instead of the expected value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Expected Diversity of the library
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diversity(2, "NNN", 10^3)
diversity(2, "NNK", 10^3)
</code></pre>

<hr>
<h2 id='efficiency'>Relative efficiency of a library</h2><span id='topic+efficiency'></span>

<h3>Description</h3>

<p>Relative efficiency of a peptide library, defined as the ratio of expected diversity of a peptide library relative to its overall number of oligonucleotides
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiency(k, libscheme, N, lib = NULL, variance = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiency_+3A_k">k</code></td>
<td>
<p>length of peptide sequences</p>
</td></tr>
<tr><td><code id="efficiency_+3A_libscheme">libscheme</code></td>
<td>
<p>Name (character vector) or definition (data frame) of scheme</p>
</td></tr>
<tr><td><code id="efficiency_+3A_n">N</code></td>
<td>
<p>size of the library</p>
</td></tr>
<tr><td><code id="efficiency_+3A_lib">lib</code></td>
<td>
<p>library, if null, libscheme will be used to create it</p>
</td></tr>
<tr><td><code id="efficiency_+3A_variance">variance</code></td>
<td>
<p>return the variance instead of the expected value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>relative efficiency index between 0 and 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>efficiency(3, "NNN", 10^2)
efficiency(3, "NNK", 10^2)
efficiency(3, "2020", 10^2) ## 20/20 efficiency is not 1 because of random sampling.
</code></pre>

<hr>
<h2 id='encodingReduce'>Reduce the regular encoding to an easier/faster format</h2><span id='topic+encodingReduce'></span>

<h3>Description</h3>

<p>Reduce the regular encoding to an easier/faster format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encodingReduce(class, libscheme)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encodingReduce_+3A_class">class</code></td>
<td>
<p>The peptide class</p>
</td></tr>
<tr><td><code id="encodingReduce_+3A_libscheme">libscheme</code></td>
<td>
<p>The scheme to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of reduced peptide encodings
</p>

<hr>
<h2 id='generateCustom'>Generate peptide and library information for a given scheme</h2><span id='topic+generateCustom'></span>

<h3>Description</h3>

<p>This function will generate library properties for a custom scheme.  It is primarily intended to be used on http://www.pelica.org.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateCustom(scheme_name = "custom", scheme_def = read.csv(file.choose()),
  k = 1:20, n = 1:25, savefile = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateCustom_+3A_scheme_name">scheme_name</code></td>
<td>
<p>The name of the resulting encoding scheme</p>
</td></tr>
<tr><td><code id="generateCustom_+3A_scheme_def">scheme_def</code></td>
<td>
<p>A data frame containing encoding information for the scheme</p>
</td></tr>
<tr><td><code id="generateCustom_+3A_k">k</code></td>
<td>
<p>peptide lengths to include</p>
</td></tr>
<tr><td><code id="generateCustom_+3A_n">n</code></td>
<td>
<p>exponents of the library size to include</p>
</td></tr>
<tr><td><code id="generateCustom_+3A_savefile">savefile</code></td>
<td>
<p>if true, save the results to an RData file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE upon completion of the script and output of the CSV files
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
generateCustom()
generateCustom(scheme_name = "NNN", scheme_def = scheme("NNN"))

## End(Not run)
</code></pre>

<hr>
<h2 id='generateCustomLib'>For a given scheme, generate a dataset with the library information</h2><span id='topic+generateCustomLib'></span>

<h3>Description</h3>

<p>For a given scheme, generate a dataset with the library information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateCustomLib(scheme_def, k = 1:20, n = 1:25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateCustomLib_+3A_scheme_def">scheme_def</code></td>
<td>
<p>definition of the custom scheme</p>
</td></tr>
<tr><td><code id="generateCustomLib_+3A_k">k</code></td>
<td>
<p>peptide lengths to include</p>
</td></tr>
<tr><td><code id="generateCustomLib_+3A_n">n</code></td>
<td>
<p>exponents of the library size to include</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of library information
</p>

<hr>
<h2 id='generateCustomNei'>For a given scheme, generate a dataset with the neighborhood information</h2><span id='topic+generateCustomNei'></span>

<h3>Description</h3>

<p>For a given scheme, generate a dataset with the neighborhood information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateCustomNei(scheme_def, k = 1:20, n = 1:25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateCustomNei_+3A_scheme_def">scheme_def</code></td>
<td>
<p>definition of the custom scheme</p>
</td></tr>
<tr><td><code id="generateCustomNei_+3A_k">k</code></td>
<td>
<p>peptide lengths to include</p>
</td></tr>
<tr><td><code id="generateCustomNei_+3A_n">n</code></td>
<td>
<p>exponents of the library size to include</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of neighborhood information
</p>

<hr>
<h2 id='generateCustomProbs'>For a given scheme, generate a dataset with the peptide probabilities</h2><span id='topic+generateCustomProbs'></span>

<h3>Description</h3>

<p>For a given scheme, generate a dataset with the peptide probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateCustomProbs(scheme_def, k = 1:20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateCustomProbs_+3A_scheme_def">scheme_def</code></td>
<td>
<p>definition of the custom scheme</p>
</td></tr>
<tr><td><code id="generateCustomProbs_+3A_k">k</code></td>
<td>
<p>peptide lengths to include</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of peptide probabilities
</p>

<hr>
<h2 id='genNeighbors'>Calculate neighborhood distribution</h2><span id='topic+genNeighbors'></span>

<h3>Description</h3>

<p>Calculate distribution of neighbors under library scheme lib for peptide sequences of length k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genNeighbors(sch, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genNeighbors_+3A_sch">sch</code></td>
<td>
<p>library scheme</p>
</td></tr>
<tr><td><code id="genNeighbors_+3A_k">k</code></td>
<td>
<p>length of the peptide sequences</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataset of peptide sequences: AA are amino acid sequences,
c0 are codons for self representation,
cr is the ratio of #neighbors in first degree neighborhood (not counting self representations) and #codons in self representation
N1 is the number of neighbors in codon representation (including self representation)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genNeighbors(scheme("NNK"), 2)
genNeighbors(scheme("2020"), 2)
</code></pre>

<hr>
<h2 id='genNeighbors_reduced'>Calculate neighborhood distribution</h2><span id='topic+genNeighbors_reduced'></span>

<h3>Description</h3>

<p>Calculate distribution of neighbors under library scheme lib for peptide sequences of length k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genNeighbors_reduced(sch, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genNeighbors_reduced_+3A_sch">sch</code></td>
<td>
<p>library scheme</p>
</td></tr>
<tr><td><code id="genNeighbors_reduced_+3A_k">k</code></td>
<td>
<p>length of the peptide sequences</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataset of peptide sequences: L are amino acid sequences,
c0 are codons for self representation,
cr is the ratio of #neighbors in first degree neighborhood (not counting self representations) and #codons in self representation
N1 is the number of neighbors in codon representation (including self representation)
s is the number of peptide sequences described by the label
o is the number of peptide sequences reached by permutations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genNeighbors_reduced(scheme("NNK"), 2)
genNeighbors_reduced(scheme("2020"), 2)
</code></pre>

<hr>
<h2 id='getChoices'>Get the number of peptides that reduce to a particular reduced encoding</h2><span id='topic+getChoices'></span>

<h3>Description</h3>

<p>Get the number of peptides that reduce to a particular reduced encoding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getChoices(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getChoices_+3A_str">str</code></td>
<td>
<p>The reduced encoding string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer of the possible number of peptides reducing to this encoding
</p>

<hr>
<h2 id='getCounts'>Get the counts possible for each scheme and k</h2><span id='topic+getCounts'></span>

<h3>Description</h3>

<p>Get the counts possible for each scheme and k
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCounts(libscheme, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCounts_+3A_libscheme">libscheme</code></td>
<td>
<p>The scheme to use</p>
</td></tr>
<tr><td><code id="getCounts_+3A_k">k</code></td>
<td>
<p>Peptide length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of possible counts for each class
</p>

<hr>
<h2 id='getNeighbors'>Find all neighbors of degree one for a set of peptide sequences</h2><span id='topic+getNeighbors'></span>

<h3>Description</h3>

<p>first degree neighbors - a neighbor of a peptide is defined as a peptide sequence that differs in at most one amino acid from a given sequence.
Additionally, we can restrict neighbors to regard only those sequences that have a certain minimal BLOSUM loading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNeighbors(x, blosum = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNeighbors_+3A_x">x</code></td>
<td>
<p>(vector) of character strings of  peptide sequences.</p>
</td></tr>
<tr><td><code id="getNeighbors_+3A_blosum">blosum</code></td>
<td>
<p>minimal BLOSUM loading, defaults to 1 for positive loadings only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of neighbor sequences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getNeighbors("APE")
getNeighbors(c("HI", "APE"))
getNeighbors(c("HI", "EARNEST", "APE"), blosum=3)
## degree 2 neighbors:
unique(unlist(getNeighbors(getNeighbors("APE"))))
</code></pre>

<hr>
<h2 id='getNofNeighbors'>Compute the number of neighbor of degree one for a set of peptide sequences</h2><span id='topic+getNofNeighbors'></span>

<h3>Description</h3>

<p>first degree neighbors - a neighbor of a peptide is defined as a peptide sequence that differs in at most one amino acid from a given sequence.
Additionally, we can restrict neighbors to regard only those sequences that have a certain minimal BLOSUM loading.
Use this function for only a few peptide sequences. Any larger number of peptide sequences will take too much main memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNofNeighbors(x, blosum = 1, method = "peptide", libscheme = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNofNeighbors_+3A_x">x</code></td>
<td>
<p>(vector) of character strings of  peptide sequences.</p>
</td></tr>
<tr><td><code id="getNofNeighbors_+3A_blosum">blosum</code></td>
<td>
<p>minimal BLOSUM loading, defaults to 1 for positive loadings only</p>
</td></tr>
<tr><td><code id="getNofNeighbors_+3A_method">method</code></td>
<td>
<p>character string, one of &quot;peptide&quot; or &quot;codon&quot;. This specifies the level at which the neighbors are calculated.</p>
</td></tr>
<tr><td><code id="getNofNeighbors_+3A_libscheme">libscheme</code></td>
<td>
<p>library scheme under which neighbors are being calculated. this is only of importance, if method=&quot;dna&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of numbers of neighbors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getNofNeighbors("APE")
getNofNeighbors(c("NEAREST", "EARNEST"))
getNofNeighbors("N")
getNofNeighbors("N", method="codon", libscheme="NNK")
</code></pre>

<hr>
<h2 id='libBuild'>Build peptide library of k-length sequences according to specified scheme</h2><span id='topic+libBuild'></span>

<h3>Description</h3>

<p>Build peptide library of k-length sequences according to specified scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>libBuild(k, libscheme, scale1 = 1, scale2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="libBuild_+3A_k">k</code></td>
<td>
<p>length of peptide sequences</p>
</td></tr>
<tr><td><code id="libBuild_+3A_libscheme">libscheme</code></td>
<td>
<p>library scheme specifying classes of amino acids according to number of encodings
last class is reserved for stop tags and other amino acids we are not interested in.</p>
</td></tr>
<tr><td><code id="libBuild_+3A_scale1">scale1</code></td>
<td>
<p>Scaling factor for first probs</p>
</td></tr>
<tr><td><code id="libBuild_+3A_scale2">scale2</code></td>
<td>
<p>Scaling factor for second probs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>library and library scheme used
</p>


<h3>Examples</h3>

<pre><code class='language-R'>user_scheme &lt;- data.frame(class=c("A", "B", "C", "Z"),
                          aacid=c("SLR", "AGPTV", "CDEFHIKMNQWY", "*"),
                          c=c(3,2,1,1))
user_library &lt;- libBuild(3, user_scheme)
</code></pre>

<hr>
<h2 id='libscheme'>Get the specified library scheme</h2><span id='topic+libscheme'></span>

<h3>Description</h3>

<p>Get the specified library scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>libscheme(schm, k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="libscheme_+3A_schm">schm</code></td>
<td>
<p>either a character vector giving the name of a built-in scheme, or a data frame consisting of the scheme definition</p>
</td></tr>
<tr><td><code id="libscheme_+3A_k">k</code></td>
<td>
<p>length of peptide sequences</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list consisting of a data frame of peptide classes, size of class, and its probabilities, and a list of additional information relating to the library scheme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>libscheme("NNN")
libscheme("NNK", 2)

# Build a custom 20/20 library
custom &lt;- data.frame(class = c("A", "Z"), aacid = c("SLRAGPTVIDEFHKNQYMW", "*"), c = c(1, 0))
libscheme(custom)
</code></pre>

<hr>
<h2 id='makowski'>Diversity index according to Makowski</h2><span id='topic+makowski'></span>

<h3>Description</h3>

<p>The Diversity of a peptide library of length k according to Makowski and colleagues
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makowski(k, libscheme)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makowski_+3A_k">k</code></td>
<td>
<p>length of peptide sequences</p>
</td></tr>
<tr><td><code id="makowski_+3A_libscheme">libscheme</code></td>
<td>
<p>Name (character vector) or definition (data frame) of scheme</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Makowski and colleagues [Makowski, Soares 2003] present another approach by defining functional diversity. They provide the mathematical background to determine the quality of a peptide library based on the probability of individual peptides to appear. In an ideal case, where every peptide has the same frequency the functional diversity is at a maximum of 1. With increasingly skew distributions, this value drops towards a minimum of 0. It is mostly independent of the actual number of sequences in a library but reflects effects caused by the degeneration of the genetic code. In the genetic code the number of codons per amino acid varies from one to six. Therefore random DNA sequences are biased towards encoding peptides enriched in amino acids encoded more frequently, which results in skew distributions of peptide frequencies.
</p>


<h3>Value</h3>

<p>diversity index between 0 and 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makowski(2, "NNN")
makowski(3, "NNK")
makowski(3, "2020")
</code></pre>

<hr>
<h2 id='ppeptide'>Probability of detection of a peptide sequence</h2><span id='topic+ppeptide'></span>

<h3>Description</h3>

<p>use this function for only a few peptide sequences. Any larger number of peptide sequences should be dealt with in the framework of the library scheme and the detect function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppeptide(x, libscheme, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppeptide_+3A_x">x</code></td>
<td>
<p>(vector) of character strings of  peptide sequences.</p>
</td></tr>
<tr><td><code id="ppeptide_+3A_libscheme">libscheme</code></td>
<td>
<p>library scheme under which neighbors are being calculated.</p>
</td></tr>
<tr><td><code id="ppeptide_+3A_n">N</code></td>
<td>
<p>number of valid DNA clones investigated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>probability of detection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ppeptide("APE", libscheme="NNK", N=10^8)
ppeptide("HENNING", libscheme="NNK", N=10^8)
</code></pre>

<hr>
<h2 id='scheme'>Get the specified library scheme definition</h2><span id='topic+scheme'></span>

<h3>Description</h3>

<p>Get the specified library scheme definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scheme(name, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scheme_+3A_name">name</code></td>
<td>
<p>name of the scheme as a character vector</p>
</td></tr>
<tr><td><code id="scheme_+3A_file">file</code></td>
<td>
<p>CSV file hosting scheme definition, if provided</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame of peptide classes, amino acids, and size of the classes corresponding to the selected scheme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scheme("NNN")
scheme("NNK")
</code></pre>

<hr>
<h2 id='schemes'>Built-in library schemes for peptider</h2><span id='topic+schemes'></span>

<h3>Description</h3>

<p>This data set contains descriptions of amino acid classes several commonly used library schemes: NNN, NNB, NNK, 20/20, and variations of each in which Cysteine is not considered a viable amino acid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(schemes)
</code></pre>


<h3>Details</h3>

<p>Built-in library schemes
</p>
<p>The schemes are defined as:
</p>
<p>NNN: All four bases (\&quot;N\&quot; = G/A/T/C) possible at all three positions in the codon.
NNB: All four bases in the first two codon positions possible, the third position is restricted to G, T or C (= \&quot;B\&quot;)
NNK/S: All four bases in the first two codon positions possible, the third position is restricted to G/T (= \&quot;K\&quot;) or two C/G (= \&quot;S\&quot;).
2020: 20/20 describes the concept that DNA is assembled from prefabricated trimeric building blocks. This allows the generation of libraries from a predefined set of codons and thereby complete exclusion of Stop codons and other unwanted codons.
NNN (-C): NNN with Cysteine ignored.
NNB (-C): NNB with Cysteine ignored.
NNK/SC (-C): NNK/S with Cysteine ignored.
2020 (-C): 20/20 with Cysteine ignored.
</p>
<p>The schemes differ in the number of used codons, ranging from 64 (NNN), 48 (NNB), 32 (NNK/S) to 20 or less (20/20). Coding schemes that allow varying ratios of codons/amino acid, result in libraries biased towards amino acids which are encoded more often. Further, the number of Stop codons that can lead to premature termination of the peptide sequence influences the performance of the library.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
