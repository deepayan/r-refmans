<!DOCTYPE html><html lang="en"><head><title>Help for package dtplyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dtplyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dtplyr-package'><p>dtplyr: Data Table Back-End for 'dplyr'</p></a></li>
<li><a href='#.datatable.aware'><p>dtplyr is data.table aware</p></a></li>
<li><a href='#arrange.dtplyr_step'><p>Arrange rows by column values</p></a></li>
<li><a href='#collect.dtplyr_step'><p>Force computation of a lazy data.table</p></a></li>
<li><a href='#complete.dtplyr_step'><p>Complete a data frame with missing combinations of data</p></a></li>
<li><a href='#count.dtplyr_step'><p>Count observations by group</p></a></li>
<li><a href='#distinct.dtplyr_step'><p>Subset distinct/unique rows</p></a></li>
<li><a href='#drop_na.dtplyr_step'><p>Drop rows containing missing values</p></a></li>
<li><a href='#expand.dtplyr_step'><p>Expand data frame to include all possible combinations of values.</p></a></li>
<li><a href='#fill.dtplyr_step'><p>Fill in missing values with previous or next value</p></a></li>
<li><a href='#filter.dtplyr_step'><p>Subset rows using column values</p></a></li>
<li><a href='#group_by.dtplyr_step'><p>Group and ungroup</p></a></li>
<li><a href='#group_modify.dtplyr_step'><p>Apply a function to each group</p></a></li>
<li><a href='#head.dtplyr_step'><p>Subset first or last rows</p></a></li>
<li><a href='#intersect.dtplyr_step'><p>Set operations</p></a></li>
<li><a href='#lazy_dt'><p>Create a &quot;lazy&quot; data.table for use with dplyr verbs</p></a></li>
<li><a href='#left_join.dtplyr_step'><p>Join data tables</p></a></li>
<li><a href='#mutate.dtplyr_step'><p>Create and modify columns</p></a></li>
<li><a href='#nest.dtplyr_step'><p>Nest</p></a></li>
<li><a href='#pivot_longer.dtplyr_step'><p>Pivot data from wide to long</p></a></li>
<li><a href='#pivot_wider.dtplyr_step'><p>Pivot data from long to wide</p></a></li>
<li><a href='#relocate.dtplyr_step'><p>Relocate variables using their names</p></a></li>
<li><a href='#rename.dtplyr_step'><p>Rename columns using their names</p></a></li>
<li><a href='#replace_na.dtplyr_step'><p>Replace NAs with specified values</p></a></li>
<li><a href='#select.dtplyr_step'><p>Subset columns using their names</p></a></li>
<li><a href='#separate.dtplyr_step'><p>Separate a character column into multiple columns with a regular</p>
expression or numeric locations</a></li>
<li><a href='#slice.dtplyr_step'><p>Subset rows using their positions</p></a></li>
<li><a href='#summarise.dtplyr_step'><p>Summarise each group to one row</p></a></li>
<li><a href='#transmute.dtplyr_step'><p>Create new columns, dropping old</p></a></li>
<li><a href='#unite.dtplyr_step'><p>Unite multiple columns into one by pasting strings together.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Data Table Back-End for 'dplyr'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a data.table backend for 'dplyr'. The goal of
    'dtplyr' is to allow you to write 'dplyr' code that is automatically
    translated to the equivalent, but usually much faster, data.table
    code.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dtplyr.tidyverse.org">https://dtplyr.tidyverse.org</a>, <a href="https://github.com/tidyverse/dtplyr">https://github.com/tidyverse/dtplyr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/dtplyr/issues">https://github.com/tidyverse/dtplyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.4.0), data.table (&ge; 1.13.0), dplyr (&ge; 1.1.0),
glue, lifecycle, rlang (&ge; 1.0.4), tibble, tidyselect (&ge;
1.2.0), vctrs (&ge; 0.4.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, covr, knitr, rmarkdown, testthat (&ge; 3.1.2), tidyr (&ge;
1.1.0), waldo (&ge; 0.3.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-21 14:31:40 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [cre, aut],
  Maximilian Girlich [aut],
  Mark Fairbanks [aut],
  Ryan Dickerson [aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-22 13:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='dtplyr-package'>dtplyr: Data Table Back-End for 'dplyr'</h2><span id='topic+dtplyr'></span><span id='topic+dtplyr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides a data.table backend for 'dplyr'. The goal of 'dtplyr' is to allow you to write 'dplyr' code that is automatically translated to the equivalent, but usually much faster, data.table code.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Maximilian Girlich
</p>
</li>
<li><p> Mark Fairbanks
</p>
</li>
<li><p> Ryan Dickerson
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://dtplyr.tidyverse.org">https://dtplyr.tidyverse.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/dtplyr">https://github.com/tidyverse/dtplyr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/dtplyr/issues">https://github.com/tidyverse/dtplyr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.datatable.aware'>dtplyr is data.table aware</h2><span id='topic+.datatable.aware'></span>

<h3>Description</h3>

<p>dtplyr is data.table aware
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.datatable.aware
</code></pre>


<h3>Format</h3>

<p>An object of class <code>logical</code> of length 1.
</p>

<hr>
<h2 id='arrange.dtplyr_step'>Arrange rows by column values</h2><span id='topic+arrange.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for dplyr generic <code><a href="dplyr.html#topic+arrange">arrange()</a></code>. It is translated to
an <code><a href="base.html#topic+order">order()</a></code> call in the <code>i</code> argument of <code style="white-space: pre;">&#8288;[.data.table&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
arrange(.data, ..., .by_group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="arrange.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Variables, or functions of
variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending order.</p>
</td></tr>
<tr><td><code id="arrange.dtplyr_step_+3A_.by_group">.by_group</code></td>
<td>
<p>If <code>TRUE</code>, will sort first by grouping variable. Applies to
grouped data frames only.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

dt &lt;- lazy_dt(mtcars)
dt %&gt;% arrange(vs, cyl)
dt %&gt;% arrange(desc(vs), cyl)
dt %&gt;% arrange(across(mpg:disp))
</code></pre>

<hr>
<h2 id='collect.dtplyr_step'>Force computation of a lazy data.table</h2><span id='topic+collect.dtplyr_step'></span><span id='topic+compute.dtplyr_step'></span><span id='topic+as.data.table.dtplyr_step'></span><span id='topic+as.data.frame.dtplyr_step'></span><span id='topic+as_tibble.dtplyr_step'></span>

<h3>Description</h3>


<ul>
<li> <p><code>collect()</code> returns a tibble, grouped if needed.
</p>
</li>
<li> <p><code>compute()</code> generates an intermediate assignment in the translation.
</p>
</li>
<li> <p><code>as.data.table()</code> returns a data.table.
</p>
</li>
<li> <p><code>as.data.frame()</code> returns a data frame.
</p>
</li>
<li> <p><code>as_tibble()</code> returns a tibble.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
collect(x, ...)

## S3 method for class 'dtplyr_step'
compute(x, name = unique_name(), ...)

## S3 method for class 'dtplyr_step'
as.data.table(x, keep.rownames = FALSE, ...)

## S3 method for class 'dtplyr_step'
as.data.frame(x, ...)

## S3 method for class 'dtplyr_step'
as_tibble(x, ..., .name_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collect.dtplyr_step_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+lazy_dt">lazy_dt</a></p>
</td></tr>
<tr><td><code id="collect.dtplyr_step_+3A_...">...</code></td>
<td>
<p>Arguments used by other methods.</p>
</td></tr>
<tr><td><code id="collect.dtplyr_step_+3A_name">name</code></td>
<td>
<p>Name of intermediate data.table.</p>
</td></tr>
<tr><td><code id="collect.dtplyr_step_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>Ignored as dplyr never preserves rownames.</p>
</td></tr>
<tr><td><code id="collect.dtplyr_step_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

dt &lt;- lazy_dt(mtcars)

# Generate translation
avg_mpg &lt;- dt %&gt;%
  filter(am == 1) %&gt;%
  group_by(cyl) %&gt;%
  summarise(mpg = mean(mpg))

# Show translation and temporarily compute result
avg_mpg

# compute and return tibble
avg_mpg_tb &lt;- as_tibble(avg_mpg)
avg_mpg_tb

# compute and return data.table
avg_mpg_dt &lt;- data.table::as.data.table(avg_mpg)
avg_mpg_dt

# modify translation to use intermediate assignment
compute(avg_mpg)

</code></pre>

<hr>
<h2 id='complete.dtplyr_step'>Complete a data frame with missing combinations of data</h2><span id='topic+complete.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the tidyr <code>complete()</code> generic. This is a wrapper
around <code>dtplyr</code> translations for <code>expand()</code>, <code>full_join()</code>, and <code>replace_na()</code>
that's useful for completing missing combinations of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
complete(data, ..., fill = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="complete.dtplyr_step_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="complete.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_data_masking">data-masking</a></code>&gt; Specification of columns
to expand or complete. Columns can be atomic vectors or lists.
</p>

<ul>
<li><p> To find all unique combinations of <code>x</code>, <code>y</code> and <code>z</code>, including those not
present in the data, supply each variable as a separate argument:
<code>expand(df, x, y, z)</code> or <code>complete(df, x, y, z)</code>.
</p>
</li>
<li><p> To find only the combinations that occur in the
data, use <code>nesting</code>: <code>expand(df, nesting(x, y, z))</code>.
</p>
</li>
<li><p> You can combine the two forms. For example,
<code>expand(df, nesting(school_id, student_id), date)</code> would produce
a row for each present school-student combination for all possible
dates.
</p>
</li></ul>

<p>When used with factors, <code><a href="tidyr.html#topic+expand">expand()</a></code> and <code><a href="tidyr.html#topic+complete">complete()</a></code> use the full set of
levels, not just those that appear in the data. If you want to use only the
values seen in the data, use <code>forcats::fct_drop()</code>.
</p>
<p>When used with continuous variables, you may need to fill in values
that do not appear in the data: to do so use expressions like
<code>year = 2010:2020</code> or <code>year = full_seq(year,1)</code>.</p>
</td></tr>
<tr><td><code id="complete.dtplyr_step_+3A_fill">fill</code></td>
<td>
<p>A named list that for each variable supplies a single value to
use instead of <code>NA</code> for missing combinations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyr)
tbl &lt;- tibble(x = 1:2, y = 1:2, z = 3:4)
dt &lt;- lazy_dt(tbl)

dt %&gt;%
  complete(x, y)

dt %&gt;%
  complete(x, y, fill = list(z = 10L))
</code></pre>

<hr>
<h2 id='count.dtplyr_step'>Count observations by group</h2><span id='topic+count.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="dplyr.html#topic+count">count()</a></code> generic. It is translated using
<code>.N</code> in the <code>j</code> argument, and supplying groups to <code>keyby</code> as appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
count(x, ..., wt = NULL, sort = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count.dtplyr_step_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code></p>
</td></tr>
<tr><td><code id="count.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Variables to group by.</p>
</td></tr>
<tr><td><code id="count.dtplyr_step_+3A_wt">wt</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="count.dtplyr_step_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="count.dtplyr_step_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>. If there's already a column called <code>n</code>,
it will use <code>nn</code>. If there's a column called <code>n</code> and <code>nn</code>, it'll use
<code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

dt &lt;- lazy_dt(dplyr::starwars)
dt %&gt;% count(species)
dt %&gt;% count(species, sort = TRUE)
dt %&gt;% count(species, wt = mass, sort = TRUE)
</code></pre>

<hr>
<h2 id='distinct.dtplyr_step'>Subset distinct/unique rows</h2><span id='topic+distinct.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="dplyr.html#topic+distinct">distinct()</a></code> generic. It is translated to
<code><a href="data.table.html#topic+duplicated">data.table::unique.data.table()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
distinct(.data, ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distinct.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code></p>
</td></tr>
<tr><td><code id="distinct.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Optional variables to use
when determining uniqueness. If there are multiple rows for a given
combination of inputs, only the first row will be preserved. If omitted,
will use all variables in the data frame.</p>
</td></tr>
<tr><td><code id="distinct.dtplyr_step_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in <code>.data</code>.
If a combination of <code>...</code> is not distinct, this keeps the
first row of values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
df &lt;- lazy_dt(data.frame(
  x = sample(10, 100, replace = TRUE),
  y = sample(10, 100, replace = TRUE)
))

df %&gt;% distinct(x)
df %&gt;% distinct(x, y)
df %&gt;% distinct(x, .keep_all = TRUE)
</code></pre>

<hr>
<h2 id='drop_na.dtplyr_step'>Drop rows containing missing values</h2><span id='topic+drop_na.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the tidyr <code>drop_na()</code> generic. It is translated to
<code>data.table::na.omit()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
drop_na(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_na.dtplyr_step_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="drop_na.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to inspect for
missing values. If empty, all columns are used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tidyr)

dt &lt;- lazy_dt(tibble(x = c(1, 2, NA), y = c("a", NA, "b")))
dt %&gt;% drop_na()
dt %&gt;% drop_na(x)

vars &lt;- "y"
dt %&gt;% drop_na(x, any_of(vars))
</code></pre>

<hr>
<h2 id='expand.dtplyr_step'>Expand data frame to include all possible combinations of values.</h2><span id='topic+expand.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the tidyr <code>expand()</code> generic. It is translated to
<code><a href="data.table.html#topic+J">data.table::CJ()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
expand(data, ..., .name_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand.dtplyr_step_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="expand.dtplyr_step_+3A_...">...</code></td>
<td>
<p>Specification of columns to expand. Columns can be atomic vectors
or lists.
</p>

<ul>
<li><p> To find all unique combinations of <code>x</code>, <code>y</code> and <code>z</code>, including those not
present in the data, supply each variable as a separate argument:
<code>expand(df, x, y, z)</code>.
</p>
</li>
<li><p> To find only the combinations that occur in the
data, use <code>nesting</code>: <code>expand(df, nesting(x, y, z))</code>.
</p>
</li>
<li><p> You can combine the two forms. For example,
<code>expand(df, nesting(school_id, student_id), date)</code> would produce
a row for each present school-student combination for all possible
dates.
</p>
</li></ul>

<p>Unlike the data.frame method, this method does not use the full set of
levels, just those that appear in the data.
</p>
<p>When used with continuous variables, you may need to fill in values
that do not appear in the data: to do so use expressions like
<code>year = 2010:2020</code> or <code>year = full_seq(year,1)</code>.</p>
</td></tr>
<tr><td><code id="expand.dtplyr_step_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyr)

fruits &lt;- lazy_dt(tibble(
  type   = c("apple", "orange", "apple", "orange", "orange", "orange"),
  year   = c(2010, 2010, 2012, 2010, 2010, 2012),
  size  =  factor(
    c("XS", "S",  "M", "S", "S", "M"),
    levels = c("XS", "S", "M", "L")
  ),
  weights = rnorm(6, as.numeric(size) + 2)
))

# All possible combinations ---------------------------------------
# Note that only present levels of the factor variable `size` are retained.
fruits %&gt;% expand(type)
fruits %&gt;% expand(type, size)

# This is different from the data frame behaviour:
fruits %&gt;% dplyr::collect() %&gt;% expand(type, size)

# Other uses -------------------------------------------------------
fruits %&gt;% expand(type, size, 2010:2012)

# Use `anti_join()` to determine which observations are missing
all &lt;- fruits %&gt;% expand(type, size, year)
all
all %&gt;% dplyr::anti_join(fruits)

# Use with `right_join()` to fill in missing rows
fruits %&gt;% dplyr::right_join(all)
</code></pre>

<hr>
<h2 id='fill.dtplyr_step'>Fill in missing values with previous or next value</h2><span id='topic+fill.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the tidyr <code>fill()</code> generic. It is translated to
<code><a href="data.table.html#topic+nafill">data.table::nafill()</a></code>. Note that <code>data.table::nafill()</code> currently only
works for integer and double columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
fill(data, ..., .direction = c("down", "up", "downup", "updown"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill.dtplyr_step_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="fill.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to fill.</p>
</td></tr>
<tr><td><code id="fill.dtplyr_step_+3A_.direction">.direction</code></td>
<td>
<p>Direction in which to fill missing values. Currently
either &quot;down&quot; (the default), &quot;up&quot;, &quot;downup&quot; (i.e. first down and then up)
or &quot;updown&quot; (first up and then down).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyr)

# Value (year) is recorded only when it changes
sales &lt;- lazy_dt(tibble::tribble(
  ~quarter, ~year, ~sales,
  "Q1",    2000,    66013,
  "Q2",      NA,    69182,
  "Q3",      NA,    53175,
  "Q4",      NA,    21001,
  "Q1",    2001,    46036,
  "Q2",      NA,    58842,
  "Q3",      NA,    44568,
  "Q4",      NA,    50197,
  "Q1",    2002,    39113,
  "Q2",      NA,    41668,
  "Q3",      NA,    30144,
  "Q4",      NA,    52897,
  "Q1",    2004,    32129,
  "Q2",      NA,    67686,
  "Q3",      NA,    31768,
  "Q4",      NA,    49094
))

# `fill()` defaults to replacing missing data from top to bottom
sales %&gt;% fill(year)

# Value (n_squirrels) is missing above and below within a group
squirrels &lt;- lazy_dt(tibble::tribble(
  ~group,    ~name,     ~role,     ~n_squirrels,
  1,      "Sam",    "Observer",   NA,
  1,     "Mara", "Scorekeeper",    8,
  1,    "Jesse",    "Observer",   NA,
  1,      "Tom",    "Observer",   NA,
  2,     "Mike",    "Observer",   NA,
  2,  "Rachael",    "Observer",   NA,
  2,  "Sydekea", "Scorekeeper",   14,
  2, "Gabriela",    "Observer",   NA,
  3,  "Derrick",    "Observer",   NA,
  3,     "Kara", "Scorekeeper",    9,
  3,    "Emily",    "Observer",   NA,
  3, "Danielle",    "Observer",   NA
))

# The values are inconsistently missing by position within the group
# Use .direction = "downup" to fill missing values in both directions
squirrels %&gt;%
  dplyr::group_by(group) %&gt;%
  fill(n_squirrels, .direction = "downup") %&gt;%
  dplyr::ungroup()

# Using `.direction = "updown"` accomplishes the same goal in this example
</code></pre>

<hr>
<h2 id='filter.dtplyr_step'>Subset rows using column values</h2><span id='topic+filter.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="dplyr.html#topic+arrange">arrange()</a></code> generic. It is translated to
the <code>i</code> argument of <code style="white-space: pre;">&#8288;[.data.table&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
filter(.data, ..., .by = NULL, .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="filter.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Expressions that return a
logical value, and are defined in terms of the variables in <code>.data</code>.
If multiple expressions are included, they are combined with the <code>&amp;</code> operator.
Only rows for which all conditions evaluate to <code>TRUE</code> are kept.</p>
</td></tr>
<tr><td><code id="filter.dtplyr_step_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="filter.dtplyr_step_+3A_.preserve">.preserve</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

dt &lt;- lazy_dt(mtcars)
dt %&gt;% filter(cyl == 4)
dt %&gt;% filter(vs, am)

dt %&gt;%
  group_by(cyl) %&gt;%
  filter(mpg &gt; mean(mpg))
</code></pre>

<hr>
<h2 id='group_by.dtplyr_step'>Group and ungroup</h2><span id='topic+group_by.dtplyr_step'></span><span id='topic+ungroup.dtplyr_step'></span>

<h3>Description</h3>

<p>These are methods for dplyr's <code><a href="dplyr.html#topic+group_by">group_by()</a></code> and <code><a href="dplyr.html#topic+ungroup">ungroup()</a></code> generics.
Grouping is translated to the either <code>keyby</code> and <code>by</code> argument of
<code style="white-space: pre;">&#8288;[.data.table&#8288;</code> depending on the value of the <code>arrange</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
group_by(.data, ..., .add = FALSE, arrange = TRUE)

## S3 method for class 'dtplyr_step'
ungroup(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_by.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code></p>
</td></tr>
<tr><td><code id="group_by.dtplyr_step_+3A_...">...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.</p>
</td></tr>
<tr><td><code id="group_by.dtplyr_step_+3A_.add">.add</code>, <code id="group_by.dtplyr_step_+3A_add">add</code></td>
<td>
<p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</td></tr>
<tr><td><code id="group_by.dtplyr_step_+3A_arrange">arrange</code></td>
<td>
<p>If <code>TRUE</code>, will automatically arrange the output of
subsequent grouped operations by group. If <code>FALSE</code>, output order will be
left unchanged. In the generated data.table code this switches between
using the <code>keyby</code> (<code>TRUE</code>) and <code>by</code> (<code>FALSE</code>) arguments.</p>
</td></tr>
<tr><td><code id="group_by.dtplyr_step_+3A_x">x</code></td>
<td>
<p>A <code><a href="dplyr.html#topic+tbl">tbl()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
dt &lt;- lazy_dt(mtcars)

# group_by() is usually translated to `keyby` so that the groups
# are ordered in the output
dt %&gt;%
 group_by(cyl) %&gt;%
 summarise(mpg = mean(mpg))

# use `arrange = FALSE` to instead use `by` so the original order
# or groups is preserved
dt %&gt;%
 group_by(cyl, arrange = FALSE) %&gt;%
 summarise(mpg = mean(mpg))
</code></pre>

<hr>
<h2 id='group_modify.dtplyr_step'>Apply a function to each group</h2><span id='topic+group_modify.dtplyr_step'></span><span id='topic+group_map.dtplyr_step'></span>

<h3>Description</h3>

<p>These are methods for the dplyr <code><a href="dplyr.html#topic+group_map">group_map()</a></code> and <code><a href="dplyr.html#topic+group_modify">group_modify()</a></code> generics.
They are both translated to <code style="white-space: pre;">&#8288;[.data.table&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
group_modify(.data, .f, ..., keep = FALSE)

## S3 method for class 'dtplyr_step'
group_map(.data, .f, ..., keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_modify.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code></p>
</td></tr>
<tr><td><code id="group_modify.dtplyr_step_+3A_.f">.f</code></td>
<td>
<p>The name of a two argument function. The first argument is passed
<code>.SD</code>,the data.table representing the current group; the second argument
is passed <code>.BY</code>, a list giving the current values of the grouping
variables. The function should return a list or data.table.</p>
</td></tr>
<tr><td><code id="group_modify.dtplyr_step_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>.f</code></p>
</td></tr>
<tr><td><code id="group_modify.dtplyr_step_+3A_keep">keep</code></td>
<td>
<p>Not supported for <a href="#topic+lazy_dt">lazy_dt</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>group_map()</code> applies <code>.f</code> to each group, returning a list.
<code>group_modify()</code> replaces each group with the results of <code>.f</code>, returning a
modified <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

dt &lt;- lazy_dt(mtcars)

dt %&gt;%
  group_by(cyl) %&gt;%
  group_modify(head, n = 2L)

dt %&gt;%
  group_by(cyl) %&gt;%
  group_map(head, n = 2L)
</code></pre>

<hr>
<h2 id='head.dtplyr_step'>Subset first or last rows</h2><span id='topic+head.dtplyr_step'></span><span id='topic+tail.dtplyr_step'></span>

<h3>Description</h3>

<p>These are methods for the base generics <code><a href="utils.html#topic+head">head()</a></code> and <code><a href="utils.html#topic+tail">tail()</a></code>. They
are not translated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
head(x, n = 6L, ...)

## S3 method for class 'dtplyr_step'
tail(x, n = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="head.dtplyr_step_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code></p>
</td></tr>
<tr><td><code id="head.dtplyr_step_+3A_n">n</code></td>
<td>
<p>Number of rows to select. Can use a negative number to instead
drop rows from the other end.</p>
</td></tr>
<tr><td><code id="head.dtplyr_step_+3A_...">...</code></td>
<td>
<p>Passed on to <code><a href="utils.html#topic+head">head()</a></code>/<code><a href="utils.html#topic+tail">tail()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
dt &lt;- lazy_dt(data.frame(x = 1:10))

# first three rows
head(dt, 3)
# last three rows
tail(dt, 3)

# drop first three rows
tail(dt, -3)
</code></pre>

<hr>
<h2 id='intersect.dtplyr_step'>Set operations</h2><span id='topic+intersect.dtplyr_step'></span><span id='topic+union.dtplyr_step'></span><span id='topic+union_all.dtplyr_step'></span><span id='topic+setdiff.dtplyr_step'></span>

<h3>Description</h3>

<p>These are methods for the dplyr generics <code><a href="base.html#topic+intersect">intersect()</a></code>, <code><a href="base.html#topic+union">union()</a></code>,
<code><a href="dplyr.html#topic+union_all">union_all()</a></code>, and <code><a href="base.html#topic+setdiff">setdiff()</a></code>. They are translated to
<code><a href="data.table.html#topic+setops">data.table::fintersect()</a></code>, <code><a href="data.table.html#topic+setops">data.table::funion()</a></code>, and
<code><a href="data.table.html#topic+setops">data.table::fsetdiff()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
intersect(x, y, ...)

## S3 method for class 'dtplyr_step'
union(x, y, ...)

## S3 method for class 'dtplyr_step'
union_all(x, y, ...)

## S3 method for class 'dtplyr_step'
setdiff(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intersect.dtplyr_step_+3A_x">x</code>, <code id="intersect.dtplyr_step_+3A_y">y</code></td>
<td>
<p>A pair of <code><a href="#topic+lazy_dt">lazy_dt()</a></code>s.</p>
</td></tr>
<tr><td><code id="intersect.dtplyr_step_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dt1 &lt;- lazy_dt(data.frame(x = 1:4))
dt2 &lt;- lazy_dt(data.frame(x = c(2, 4, 6)))

intersect(dt1, dt2)
union(dt1, dt2)
setdiff(dt1, dt2)

</code></pre>

<hr>
<h2 id='lazy_dt'>Create a &quot;lazy&quot; data.table for use with dplyr verbs</h2><span id='topic+lazy_dt'></span><span id='topic+tbl_dt'></span><span id='topic+grouped_dt'></span>

<h3>Description</h3>

<p>A lazy data.table lazy captures the intent of dplyr verbs, only actually
performing computation when requested (with <code><a href="dplyr.html#topic+collect">collect()</a></code>, <code><a href="dplyr.html#topic+pull">pull()</a></code>,
<code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code>, <code><a href="data.table.html#topic+as.data.table">data.table::as.data.table()</a></code>, or <code><a href="tibble.html#topic+as_tibble">tibble::as_tibble()</a></code>).
This allows dtplyr to convert dplyr verbs into as few data.table expressions
as possible, which leads to a high performance translation.
</p>
<p>See <code>vignette("translation")</code> for the details of the translation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lazy_dt(x, name = NULL, immutable = TRUE, key_by = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lazy_dt_+3A_x">x</code></td>
<td>
<p>A data table (or something can can be coerced to a data table).</p>
</td></tr>
<tr><td><code id="lazy_dt_+3A_name">name</code></td>
<td>
<p>Optionally, supply a name to be used in generated expressions.
For expert use only.</p>
</td></tr>
<tr><td><code id="lazy_dt_+3A_immutable">immutable</code></td>
<td>
<p>If <code>TRUE</code>, <code>x</code> is treated as immutable and will never
be modified by any code generated by dtplyr. Alternatively, you can set
<code>immutable = FALSE</code> to allow dtplyr to modify the input object.</p>
</td></tr>
<tr><td><code id="lazy_dt_+3A_key_by">key_by</code></td>
<td>
<p>Set keys for data frame, using <code><a href="dplyr.html#topic+select">select()</a></code> semantics (e.g.
<code>key_by = c(key1, key2)</code>.
</p>
<p>This uses <code><a href="data.table.html#topic+setkey">data.table::setkey()</a></code> to sort the table and build an index.
This will considerably improve performance for subsets, summaries, and
joins that use the keys.
</p>
<p>See <code>vignette("datatable-keys-fast-subset")</code> for more details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

# If you have a data.table, using it with any dplyr generic will
# automatically convert it to a lazy_dt object
dt &lt;- data.table::data.table(x = 1:10, y = 10:1)
dt %&gt;% filter(x == y)
dt %&gt;% mutate(z = x + y)

# Note that dtplyr will avoid mutating the input data.table, so the
# previous translation includes an automatic copy(). You can avoid this
# with a manual call to lazy_dt()
dt %&gt;%
  lazy_dt(immutable = FALSE) %&gt;%
  mutate(z = x + y)

# If you have a data frame, you can use lazy_dt() to convert it to
# a data.table:
mtcars2 &lt;- lazy_dt(mtcars)
mtcars2
mtcars2 %&gt;% select(mpg:cyl)
mtcars2 %&gt;% select(x = mpg, y = cyl)
mtcars2 %&gt;% filter(cyl == 4) %&gt;% select(mpg)
mtcars2 %&gt;% select(mpg, cyl) %&gt;% filter(cyl == 4)
mtcars2 %&gt;% mutate(cyl2 = cyl * 2, cyl4 = cyl2 * 2)
mtcars2 %&gt;% transmute(cyl2 = cyl * 2, vs2 = vs * 2)
mtcars2 %&gt;% filter(cyl == 8) %&gt;% mutate(cyl2 = cyl * 2)

# Learn more about translation in vignette("translation")
by_cyl &lt;- mtcars2 %&gt;% group_by(cyl)
by_cyl %&gt;% summarise(mpg = mean(mpg))
by_cyl %&gt;% mutate(mpg = mean(mpg))
by_cyl %&gt;%
  filter(mpg &lt; mean(mpg)) %&gt;%
  summarise(hp = mean(hp))
</code></pre>

<hr>
<h2 id='left_join.dtplyr_step'>Join data tables</h2><span id='topic+left_join.dtplyr_step'></span>

<h3>Description</h3>

<p>These are methods for the dplyr generics <code><a href="dplyr.html#topic+left_join">left_join()</a></code>, <code><a href="dplyr.html#topic+right_join">right_join()</a></code>,
<code><a href="dplyr.html#topic+inner_join">inner_join()</a></code>, <code><a href="dplyr.html#topic+full_join">full_join()</a></code>, <code><a href="dplyr.html#topic+anti_join">anti_join()</a></code>, and <code><a href="dplyr.html#topic+semi_join">semi_join()</a></code>. Left, right,
inner, and anti join are translated to the <code style="white-space: pre;">&#8288;[.data.table&#8288;</code> equivalent,
full joins to <code><a href="data.table.html#topic+merge">data.table::merge.data.table()</a></code>.
Left, right, and full joins are in some cases followed by calls to
<code><a href="data.table.html#topic+setcolorder">data.table::setcolorder()</a></code> and <code><a href="data.table.html#topic+setattr">data.table::setnames()</a></code> to ensure that column
order and names match dplyr conventions.
Semi-joins don't have a direct data.table equivalent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
left_join(x, y, ..., by = NULL, copy = FALSE, suffix = c(".x", ".y"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="left_join.dtplyr_step_+3A_x">x</code>, <code id="left_join.dtplyr_step_+3A_y">y</code></td>
<td>
<p>A pair of <code><a href="#topic+lazy_dt">lazy_dt()</a></code>s.</p>
</td></tr>
<tr><td><code id="left_join.dtplyr_step_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="left_join.dtplyr_step_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="left_join.dtplyr_step_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="left_join.dtplyr_step_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

band_dt &lt;- lazy_dt(dplyr::band_members)
instrument_dt &lt;- lazy_dt(dplyr::band_instruments)

band_dt %&gt;% left_join(instrument_dt)
band_dt %&gt;% right_join(instrument_dt)
band_dt %&gt;% inner_join(instrument_dt)
band_dt %&gt;% full_join(instrument_dt)

band_dt %&gt;% semi_join(instrument_dt)
band_dt %&gt;% anti_join(instrument_dt)
</code></pre>

<hr>
<h2 id='mutate.dtplyr_step'>Create and modify columns</h2><span id='topic+mutate.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="dplyr.html#topic+mutate">mutate()</a></code> generic. It is translated to
the <code>j</code> argument of <code style="white-space: pre;">&#8288;[.data.table&#8288;</code>, using <code style="white-space: pre;">&#8288;:=&#8288;</code> to modify &quot;in place&quot;. If
<code>.before</code> or <code>.after</code> is provided, the new columns are relocated with a call
to <code><a href="data.table.html#topic+setcolorder">data.table::setcolorder()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
mutate(
  .data,
  ...,
  .by = NULL,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="mutate.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate.dtplyr_step_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="mutate.dtplyr_step_+3A_.keep">.keep</code></td>
<td>
<p>Control which columns from <code>.data</code> are retained in the output. Grouping
columns and columns created by <code>...</code> are always kept.
</p>

<ul>
<li> <p><code>"all"</code> retains all columns from <code>.data</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code> retains only the columns used in <code>...</code> to create new
columns. This is useful for checking your work, as it displays inputs
and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> retains only the columns <em>not</em> used in <code>...</code> to create new
columns. This is useful if you generate new columns, but no longer need
the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code> doesn't retain any extra columns from <code>.data</code>. Only the grouping
variables and columns created by <code>...</code> are kept.
</p>
</li></ul>

<p>Note: With dtplyr <code>.keep</code> will only work with column names passed as symbols, and won't
work with other workflows (e.g. <code>eval(parse(text = "x + 1"))</code>)</p>
</td></tr>
<tr><td><code id="mutate.dtplyr_step_+3A_.before">.before</code>, <code id="mutate.dtplyr_step_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, control where new columns
should appear (the default is to add to the right hand side). See
<code><a href="dplyr.html#topic+relocate">relocate()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

dt &lt;- lazy_dt(data.frame(x = 1:5, y = 5:1))
dt %&gt;%
  mutate(a = (x + y) / 2, b = sqrt(x^2 + y^2))

# It uses a more sophisticated translation when newly created variables
# are used in the same expression
dt %&gt;%
  mutate(x1 = x + 1, x2 = x1 + 1)
</code></pre>

<hr>
<h2 id='nest.dtplyr_step'>Nest</h2><span id='topic+nest.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the tidyr <code><a href="tidyr.html#topic+nest">tidyr::nest()</a></code> generic. It is translated
using the non-nested variables in the <code>by</code> argument and <code>.SD</code> in the <code>j</code>
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
nest(.data, ..., .names_sep = NULL, .key = deprecated())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nest.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="nest.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to nest, specified
using name-variable pairs of the form <code>new_col = c(col1, col2, col3)</code>.
The right hand side can be any valid tidy select expression.</p>
</td></tr>
<tr><td><code id="nest.dtplyr_step_+3A_.names_sep">.names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the inner names will come from
the former outer names. If a string, the  new inner names will use the
outer names with <code>names_sep</code> automatically stripped. This makes
<code>names_sep</code> roughly symmetric between nesting and unnesting.</p>
</td></tr>
<tr><td><code id="nest.dtplyr_step_+3A_.key">.key</code></td>
<td>
<p>Not supported.</p>
</td></tr>
<tr><td><code id="nest.dtplyr_step_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("tidyr", quietly = TRUE)) {
  dt &lt;- lazy_dt(tibble(x = c(1, 2, 1), y = c("a", "a", "b")))
  dt %&gt;% nest(data = y)

  dt %&gt;% dplyr::group_by(x) %&gt;% nest()
}
</code></pre>

<hr>
<h2 id='pivot_longer.dtplyr_step'>Pivot data from wide to long</h2><span id='topic+pivot_longer.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the tidyr <code>pivot_longer()</code> generic. It is translated to
<code><a href="data.table.html#topic+melt.data.table">data.table::melt()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
pivot_longer(
  data,
  cols,
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  names_ptypes = NULL,
  names_transform = NULL,
  names_repair = "check_unique",
  values_to = "value",
  values_drop_na = FALSE,
  values_ptypes = NULL,
  values_transform = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivot_longer.dtplyr_step_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="pivot_longer.dtplyr_step_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to pivot into
longer format.</p>
</td></tr>
<tr><td><code id="pivot_longer.dtplyr_step_+3A_names_to">names_to</code></td>
<td>
<p>A character vector specifying the new column or columns to
create from the information stored in the column names of <code>data</code> specified
by <code>cols</code>.
</p>

<ul>
<li><p> If length 0, or if <code>NULL</code> is supplied, no columns will be created.
</p>
</li>
<li><p> If length 1, a single column will be created which will contain the
column names specified by <code>cols</code>.
</p>
</li>
<li><p> If length &gt;1, multiple columns will be created. In this case, one of
<code>names_sep</code> or <code>names_pattern</code> must be supplied to specify how the
column names should be split. There are also two additional character
values you can take advantage of:
</p>

<ul>
<li> <p><code>NA</code> will discard the corresponding component of the column name.
</p>
</li>
<li> <p><code>".value"</code> indicates that the corresponding component of the column
name defines the name of the output column containing the cell values,
overriding <code>values_to</code> entirely.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="pivot_longer.dtplyr_step_+3A_names_prefix">names_prefix</code></td>
<td>
<p>A regular expression used to remove matching text
from the start of each variable name.</p>
</td></tr>
<tr><td><code id="pivot_longer.dtplyr_step_+3A_names_sep">names_sep</code>, <code id="pivot_longer.dtplyr_step_+3A_names_pattern">names_pattern</code></td>
<td>
<p>If <code>names_to</code> contains multiple values,
these arguments control how the column name is broken up.
</p>
<p><code>names_sep</code> takes the same specification as <code><a href="tidyr.html#topic+separate">separate()</a></code>, and can either
be a numeric vector (specifying positions to break on), or a single string
(specifying a regular expression to split on).
</p>
<p><code>names_pattern</code> takes the same specification as <code><a href="tidyr.html#topic+extract">extract()</a></code>, a regular
expression containing matching groups (<code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>If these arguments do not give you enough control, use
<code>pivot_longer_spec()</code> to create a spec object and process manually as
needed.</p>
</td></tr>
<tr><td><code id="pivot_longer.dtplyr_step_+3A_names_ptypes">names_ptypes</code>, <code id="pivot_longer.dtplyr_step_+3A_names_transform">names_transform</code>, <code id="pivot_longer.dtplyr_step_+3A_values_ptypes">values_ptypes</code>, <code id="pivot_longer.dtplyr_step_+3A_values_transform">values_transform</code></td>
<td>
<p>Not currently supported by dtplyr.</p>
</td></tr>
<tr><td><code id="pivot_longer.dtplyr_step_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="pivot_longer.dtplyr_step_+3A_values_to">values_to</code></td>
<td>
<p>A string specifying the name of the column to create
from the data stored in cell values. If <code>names_to</code> is a character
containing the special <code>.value</code> sentinel, this value will be ignored,
and the name of the value column will be derived from part of the
existing column names.</p>
</td></tr>
<tr><td><code id="pivot_longer.dtplyr_step_+3A_values_drop_na">values_drop_na</code></td>
<td>
<p>If <code>TRUE</code>, will drop rows that contain only <code>NA</code>s
in the <code>value_to</code> column. This effectively converts explicit missing values
to implicit missing values, and should generally be used only when missing
values in <code>data</code> were created by its structure.</p>
</td></tr>
<tr><td><code id="pivot_longer.dtplyr_step_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyr)

# Simplest case where column names are character data
relig_income_dt &lt;- lazy_dt(relig_income)
relig_income_dt %&gt;%
  pivot_longer(!religion, names_to = "income", values_to = "count")

# Slightly more complex case where columns have common prefix,
# and missing missings are structural so should be dropped.
billboard_dt &lt;- lazy_dt(billboard)
billboard %&gt;%
 pivot_longer(
   cols = starts_with("wk"),
   names_to = "week",
   names_prefix = "wk",
   values_to = "rank",
   values_drop_na = TRUE
 )

# Multiple variables stored in column names
lazy_dt(who) %&gt;%
  pivot_longer(
    cols = new_sp_m014:newrel_f65,
    names_to = c("diagnosis", "gender", "age"),
    names_pattern = "new_?(.*)_(.)(.*)",
    values_to = "count"
  )

# Multiple observations per row
anscombe_dt &lt;- lazy_dt(anscombe)
anscombe_dt %&gt;%
 pivot_longer(
   everything(),
   names_to = c(".value", "set"),
   names_pattern = "(.)(.)"
 )
</code></pre>

<hr>
<h2 id='pivot_wider.dtplyr_step'>Pivot data from long to wide</h2><span id='topic+pivot_wider.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the tidyr <code>pivot_wider()</code> generic. It is translated to
<code><a href="data.table.html#topic+dcast.data.table">data.table::dcast()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
pivot_wider(
  data,
  id_cols = NULL,
  names_from = name,
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  names_sort = FALSE,
  names_repair = "check_unique",
  values_from = value,
  values_fill = NULL,
  values_fn = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivot_wider.dtplyr_step_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="pivot_wider.dtplyr_step_+3A_id_cols">id_cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A set of columns that
uniquely identify each observation. Typically used when you have
redundant variables, i.e. variables whose values are perfectly correlated
with existing variables.
</p>
<p>Defaults to all columns in <code>data</code> except for the columns specified through
<code>names_from</code> and <code>values_from</code>. If a tidyselect expression is supplied, it
will be evaluated on <code>data</code> after removing the columns specified through
<code>names_from</code> and <code>values_from</code>.</p>
</td></tr>
<tr><td><code id="pivot_wider.dtplyr_step_+3A_names_from">names_from</code>, <code id="pivot_wider.dtplyr_step_+3A_values_from">values_from</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A pair of
arguments describing which column (or columns) to get the name of the
output column (<code>names_from</code>), and which column (or columns) to get the
cell values from (<code>values_from</code>).
</p>
<p>If <code>values_from</code> contains multiple values, the value will be added to the
front of the output column.</p>
</td></tr>
<tr><td><code id="pivot_wider.dtplyr_step_+3A_names_prefix">names_prefix</code></td>
<td>
<p>String added to the start of every variable name. This is
particularly useful if <code>names_from</code> is a numeric vector and you want to
create syntactic variable names.</p>
</td></tr>
<tr><td><code id="pivot_wider.dtplyr_step_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>names_from</code> or <code>values_from</code> contains multiple
variables, this will be used to join their values together into a single
string to use as a column name.</p>
</td></tr>
<tr><td><code id="pivot_wider.dtplyr_step_+3A_names_glue">names_glue</code></td>
<td>
<p>Instead of <code>names_sep</code> and <code>names_prefix</code>, you can supply
a glue specification that uses the <code>names_from</code> columns (and special
<code>.value</code>) to create custom column names.</p>
</td></tr>
<tr><td><code id="pivot_wider.dtplyr_step_+3A_names_sort">names_sort</code></td>
<td>
<p>Should the column names be sorted? If <code>FALSE</code>, the default,
column names are ordered by first appearance.</p>
</td></tr>
<tr><td><code id="pivot_wider.dtplyr_step_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="pivot_wider.dtplyr_step_+3A_values_fill">values_fill</code></td>
<td>
<p>Optionally, a (scalar) value that specifies what each
<code>value</code> should be filled in with when missing.
</p>
<p>This can be a named list if you want to apply different fill values to
different value columns.</p>
</td></tr>
<tr><td><code id="pivot_wider.dtplyr_step_+3A_values_fn">values_fn</code></td>
<td>
<p>A function, the default is <code>length()</code>. Note this is different
behavior than <code>tidyr::pivot_wider()</code>, which returns a list column by default.</p>
</td></tr>
<tr><td><code id="pivot_wider.dtplyr_step_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyr)

fish_encounters_dt &lt;- lazy_dt(fish_encounters)
fish_encounters_dt
fish_encounters_dt %&gt;%
  pivot_wider(names_from = station, values_from = seen)
# Fill in missing values
fish_encounters_dt %&gt;%
  pivot_wider(names_from = station, values_from = seen, values_fill = 0)

# Generate column names from multiple variables
us_rent_income_dt &lt;- lazy_dt(us_rent_income)
us_rent_income_dt
us_rent_income_dt %&gt;%
  pivot_wider(names_from = variable, values_from = c(estimate, moe))

# When there are multiple `names_from` or `values_from`, you can use
# use `names_sep` or `names_glue` to control the output variable names
us_rent_income_dt %&gt;%
  pivot_wider(
    names_from = variable,
    names_sep = ".",
    values_from = c(estimate, moe)
  )

# Can perform aggregation with values_fn
warpbreaks_dt &lt;- lazy_dt(as_tibble(warpbreaks[c("wool", "tension", "breaks")]))
warpbreaks_dt
warpbreaks_dt %&gt;%
  pivot_wider(
    names_from = wool,
    values_from = breaks,
    values_fn = mean
  )
</code></pre>

<hr>
<h2 id='relocate.dtplyr_step'>Relocate variables using their names</h2><span id='topic+relocate.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="dplyr.html#topic+relocate">relocate()</a></code> generic. It is translated to
the <code>j</code> argument of <code style="white-space: pre;">&#8288;[.data.table&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
relocate(.data, ..., .before = NULL, .after = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relocate.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="relocate.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to move.</p>
</td></tr>
<tr><td><code id="relocate.dtplyr_step_+3A_.before">.before</code>, <code id="relocate.dtplyr_step_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Destination of
columns selected by <code>...</code>. Supplying neither will move columns to the
left-hand side; specifying both is an error.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

dt &lt;- lazy_dt(data.frame(x = 1, y = 2, z = 3))

dt %&gt;% relocate(z)
dt %&gt;% relocate(y, .before = x)
dt %&gt;% relocate(y, .after = y)
</code></pre>

<hr>
<h2 id='rename.dtplyr_step'>Rename columns using their names</h2><span id='topic+rename.dtplyr_step'></span><span id='topic+rename_with.dtplyr_step'></span>

<h3>Description</h3>

<p>These are methods for the dplyr generics <code><a href="dplyr.html#topic+rename">rename()</a></code> and <code><a href="dplyr.html#topic+rename_with">rename_with()</a></code>.
They are both translated to <code><a href="data.table.html#topic+setattr">data.table::setnames()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
rename(.data, ...)

## S3 method for class 'dtplyr_step'
rename_with(.data, .fn, .cols = everything(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code></p>
</td></tr>
<tr><td><code id="rename.dtplyr_step_+3A_...">...</code></td>
<td>
<p>For <code>rename()</code>: &lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Use
<code>new_name = old_name</code> to rename selected variables.
</p>
<p>For <code>rename_with()</code>: additional arguments passed onto <code>.fn</code>.</p>
</td></tr>
<tr><td><code id="rename.dtplyr_step_+3A_.fn">.fn</code></td>
<td>
<p>A function used to transform the selected <code>.cols</code>. Should
return a character vector the same length as the input.</p>
</td></tr>
<tr><td><code id="rename.dtplyr_step_+3A_.cols">.cols</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to rename;
defaults to all columns.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
dt &lt;- lazy_dt(data.frame(x = 1, y = 2, z = 3))
dt %&gt;% rename(new_x = x, new_y = y)
dt %&gt;% rename_with(toupper)
</code></pre>

<hr>
<h2 id='replace_na.dtplyr_step'>Replace NAs with specified values</h2><span id='topic+replace_na.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the tidyr <code>replace_na()</code> generic. It is translated to
<code><a href="data.table.html#topic+coalesce">data.table::fcoalesce()</a></code>.
</p>
<p>Note that unlike <code>tidyr::replace_na()</code>, <code>data.table::fcoalesce()</code> cannot
replace <code>NULL</code> values in lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
replace_na(data, replace = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_na.dtplyr_step_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="replace_na.dtplyr_step_+3A_replace">replace</code></td>
<td>
<p>If <code>data</code> is a data frame, <code>replace</code> takes a named list of
values, with one value for each column that has missing values to be
replaced. Each value in <code>replace</code> will be cast to the type of the column
in <code>data</code> that it being used as a replacement in.
</p>
<p>If <code>data</code> is a vector, <code>replace</code> takes a single value. This single value
replaces all of the missing values in the vector. <code>replace</code> will be cast
to the type of <code>data</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyr)

# Replace NAs in a data frame
dt &lt;- lazy_dt(tibble(x = c(1, 2, NA), y = c("a", NA, "b")))
dt %&gt;% replace_na(list(x = 0, y = "unknown"))

# Replace NAs using `dplyr::mutate()`
dt %&gt;% dplyr::mutate(x = replace_na(x, 0))
</code></pre>

<hr>
<h2 id='select.dtplyr_step'>Subset columns using their names</h2><span id='topic+select.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="dplyr.html#topic+select">select()</a></code> generic. It is translated to
the <code>j</code> argument of <code style="white-space: pre;">&#8288;[.data.table&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="select.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; One or more unquoted
expressions separated by commas. Variable names can be used as if they
were positions in the data frame, so expressions like <code>x:y</code> can
be used to select a range of variables.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

dt &lt;- lazy_dt(data.frame(x1 = 1, x2 = 2, y1 = 3, y2 = 4))

dt %&gt;% select(starts_with("x"))
dt %&gt;% select(ends_with("2"))
dt %&gt;% select(z1 = x1, z2 = x2)
</code></pre>

<hr>
<h2 id='separate.dtplyr_step'>Separate a character column into multiple columns with a regular
expression or numeric locations</h2><span id='topic+separate.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="tidyr.html#topic+separate">tidyr::separate()</a></code> generic. It is translated to
<code><a href="data.table.html#topic+tstrsplit">data.table::tstrsplit()</a></code> in the <code>j</code> argument of <code style="white-space: pre;">&#8288;[.data.table&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
separate(
  data,
  col,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE,
  convert = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="separate.dtplyr_step_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="separate.dtplyr_step_+3A_col">col</code></td>
<td>
<p>Column name or position.
</p>
<p>This argument is passed by expression and supports quasiquotation
(you can unquote column names or column positions).</p>
</td></tr>
<tr><td><code id="separate.dtplyr_step_+3A_into">into</code></td>
<td>
<p>Names of new variables to create as character vector.
Use <code>NA</code> to omit the variable in the output.</p>
</td></tr>
<tr><td><code id="separate.dtplyr_step_+3A_sep">sep</code></td>
<td>
<p>Separator between columns.
The default value is a regular expression that matches any sequence of non-alphanumeric values.</p>
</td></tr>
<tr><td><code id="separate.dtplyr_step_+3A_remove">remove</code></td>
<td>
<p>If TRUE, remove the input column from the output data frame.</p>
</td></tr>
<tr><td><code id="separate.dtplyr_step_+3A_convert">convert</code></td>
<td>
<p>If TRUE, will run type.convert() with as.is = TRUE on new columns.
This is useful if the component columns are integer, numeric or logical.
</p>
<p>NB: this will cause string &quot;NA&quot;s to be converted to NAs.</p>
</td></tr>
<tr><td><code id="separate.dtplyr_step_+3A_...">...</code></td>
<td>
<p>Arguments passed on to methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyr)
# If you want to split by any non-alphanumeric value (the default):
df &lt;- lazy_dt(data.frame(x = c(NA, "x.y", "x.z", "y.z")), "DT")
df %&gt;% separate(x, c("A", "B"))

# If you just want the second variable:
df %&gt;% separate(x, c(NA, "B"))

# Use regular expressions to separate on multiple characters:
df &lt;- lazy_dt(data.frame(x = c(NA, "x?y", "x.z", "y:z")), "DT")
df %&gt;% separate(x, c("A","B"), sep = "([.?:])")

# convert = TRUE detects column classes:
df &lt;- lazy_dt(data.frame(x = c("x:1", "x:2", "y:4", "z", NA)), "DT")
df %&gt;% separate(x, c("key","value"), ":") %&gt;% str
df %&gt;% separate(x, c("key","value"), ":", convert = TRUE) %&gt;% str
</code></pre>

<hr>
<h2 id='slice.dtplyr_step'>Subset rows using their positions</h2><span id='topic+slice.dtplyr_step'></span><span id='topic+slice_head.dtplyr_step'></span><span id='topic+slice_tail.dtplyr_step'></span><span id='topic+slice_min.dtplyr_step'></span><span id='topic+slice_max.dtplyr_step'></span>

<h3>Description</h3>

<p>These are methods for the dplyr <code><a href="dplyr.html#topic+slice">slice()</a></code>, <code>slice_head()</code>, <code>slice_tail()</code>,
<code>slice_min()</code>, <code>slice_max()</code> and <code>slice_sample()</code> generics. They are
translated to the <code>i</code> argument of <code style="white-space: pre;">&#8288;[.data.table&#8288;</code>.
</p>
<p>Unlike dplyr, <code>slice()</code> (and <code>slice()</code> alone) returns the same number of
rows per group, regardless of whether or not the indices appear in each
group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
slice(.data, ..., .by = NULL)

## S3 method for class 'dtplyr_step'
slice_head(.data, ..., n, prop, by = NULL)

## S3 method for class 'dtplyr_step'
slice_tail(.data, ..., n, prop, by = NULL)

## S3 method for class 'dtplyr_step'
slice_min(.data, order_by, ..., n, prop, by = NULL, with_ties = TRUE)

## S3 method for class 'dtplyr_step'
slice_max(.data, order_by, ..., n, prop, by = NULL, with_ties = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="slice.dtplyr_step_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Integer row
values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.</p>
</td></tr>
<tr><td><code id="slice.dtplyr_step_+3A_.by">.by</code>, <code id="slice.dtplyr_step_+3A_by">by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="slice.dtplyr_step_+3A_n">n</code>, <code id="slice.dtplyr_step_+3A_prop">prop</code></td>
<td>
<p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</td></tr>
<tr><td><code id="slice.dtplyr_step_+3A_order_by">order_by</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Variable or function
of variables to order by. To order by multiple variables, wrap them in a
data frame or tibble.</p>
</td></tr>
<tr><td><code id="slice.dtplyr_step_+3A_with_ties">with_ties</code></td>
<td>
<p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

dt &lt;- lazy_dt(mtcars)
dt %&gt;% slice(1, 5, 10)
dt %&gt;% slice(-(1:4))

# First and last rows based on existing order
dt %&gt;% slice_head(n = 5)
dt %&gt;% slice_tail(n = 5)

# Rows with minimum and maximum values of a variable
dt %&gt;% slice_min(mpg, n = 5)
dt %&gt;% slice_max(mpg, n = 5)

# slice_min() and slice_max() may return more rows than requested
# in the presence of ties. Use with_ties = FALSE to suppress
dt %&gt;% slice_min(cyl, n = 1)
dt %&gt;% slice_min(cyl, n = 1, with_ties = FALSE)

# slice_sample() allows you to random select with or without replacement
dt %&gt;% slice_sample(n = 5)
dt %&gt;% slice_sample(n = 5, replace = TRUE)

# you can optionally weight by a variable - this code weights by the
# physical weight of the cars, so heavy cars are more likely to get
# selected
dt %&gt;% slice_sample(weight_by = wt, n = 5)
</code></pre>

<hr>
<h2 id='summarise.dtplyr_step'>Summarise each group to one row</h2><span id='topic+summarise.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="dplyr.html#topic+summarise">summarise()</a></code> generic. It is translated to
the <code>j</code> argument of <code style="white-space: pre;">&#8288;[.data.table&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
summarise(.data, ..., .by = NULL, .groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="summarise.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Name-value pairs of summary
functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returning values with size 0 or &gt;1 was
deprecated as of 1.1.0. Please use <code><a href="dplyr.html#topic+reframe">reframe()</a></code> for this instead.</p>
</td></tr>
<tr><td><code id="summarise.dtplyr_step_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="summarise.dtplyr_step_+3A_.groups">.groups</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Grouping structure of the
result.
</p>

<ul>
<li><p> &quot;drop_last&quot;: dropping the last level of grouping. This was the
only supported option before version 1.0.0.
</p>
</li>
<li><p> &quot;drop&quot;: All levels of grouping are dropped.
</p>
</li>
<li><p> &quot;keep&quot;: Same grouping structure as <code>.data</code>.
</p>
</li>
<li><p> &quot;rowwise&quot;: Each row is its own group.
</p>
</li></ul>

<p>When <code>.groups</code> is not specified, it is chosen
based on the number of rows of the results:
</p>

<ul>
<li><p> If all the results have 1 row, you get &quot;drop_last&quot;.
</p>
</li>
<li><p> If the number of rows varies, you get &quot;keep&quot; (note that returning a
variable number of rows was deprecated in favor of <code><a href="dplyr.html#topic+reframe">reframe()</a></code>, which
also unconditionally drops all levels of grouping).
</p>
</li></ul>

<p>In addition, a message informs you of that choice, unless the result is ungrouped,
the option &quot;dplyr.summarise.inform&quot; is set to <code>FALSE</code>,
or when <code>summarise()</code> is called from a function in a package.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

dt &lt;- lazy_dt(mtcars)

dt %&gt;%
  group_by(cyl) %&gt;%
  summarise(vs = mean(vs))

dt %&gt;%
  group_by(cyl) %&gt;%
  summarise(across(disp:wt, mean))
</code></pre>

<hr>
<h2 id='transmute.dtplyr_step'>Create new columns, dropping old</h2><span id='topic+transmute.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="dplyr.html#topic+transmute">transmute()</a></code> generic. It is translated to
the <code>j</code> argument of <code style="white-space: pre;">&#8288;[.data.table&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
transmute(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transmute.dtplyr_step_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="#topic+lazy_dt">lazy_dt()</a></code>.</p>
</td></tr>
<tr><td><code id="transmute.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

dt &lt;- lazy_dt(dplyr::starwars)
dt %&gt;% transmute(name, sh = paste0(species, "/", homeworld))
</code></pre>

<hr>
<h2 id='unite.dtplyr_step'>Unite multiple columns into one by pasting strings together.</h2><span id='topic+unite.dtplyr_step'></span>

<h3>Description</h3>

<p>This is a method for the tidyr <code>unite()</code> generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtplyr_step'
unite(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unite.dtplyr_step_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unite.dtplyr_step_+3A_col">col</code></td>
<td>
<p>The name of the new column, as a string or symbol.
</p>
<p>This argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote strings
and symbols). The name is captured from the expression with
<code><a href="rlang.html#topic+defusing-advanced">rlang::ensym()</a></code> (note that this kind of interface where
symbols do not represent actual objects is now discouraged in the
tidyverse; we support it here for backward compatibility).</p>
</td></tr>
<tr><td><code id="unite.dtplyr_step_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to unite</p>
</td></tr>
<tr><td><code id="unite.dtplyr_step_+3A_sep">sep</code></td>
<td>
<p>Separator to use between values.</p>
</td></tr>
<tr><td><code id="unite.dtplyr_step_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input columns from output data frame.</p>
</td></tr>
<tr><td><code id="unite.dtplyr_step_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, missing values will be removed prior to uniting
each value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyr)

df &lt;- lazy_dt(expand_grid(x = c("a", NA), y = c("b", NA)))
df

df %&gt;% unite("z", x:y, remove = FALSE)

# Separate is almost the complement of unite
df %&gt;%
  unite("xy", x:y) %&gt;%
  separate(xy, c("x", "y"))
# (but note `x` and `y` contain now "NA" not NA)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
