<!DOCTYPE html><html><head><title>Help for package NonNorMvtDist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NonNorMvtDist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MvtBurr'><p>Multivariate Burr Distribution</p></a></li>
<li><a href='#MvtF'><p>Multivariate F Distribution</p></a></li>
<li><a href='#MvtGlomx'><p>Generalized Multivariate Lomax (Pareto Type II) Distribution</p></a></li>
<li><a href='#MvtInvBeta'><p>Multivariate Inverted Beta Distribution</p></a></li>
<li><a href='#MvtLogis'><p>Multivariate Logistic Distribution</p></a></li>
<li><a href='#MvtLomax'><p>Multivariate Lomax (Pareto Type II) Distribution</p></a></li>
<li><a href='#MvtMardiaPareto1'><p>Mardia's Multivariate Pareto Type I Distribution</p></a></li>
<li><a href='#MvtUniform'><p>Cook-Johnson's Multivariate Uniform Distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Lomax (Pareto Type II) and Its Related
Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhixin Lun &lt;zlun@oakland.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements calculation of probability density function, cumulative distribution function, equicoordinate quantile function and survival function, and random numbers generation for the following multivariate distributions: Lomax (Pareto Type II), generalized Lomax, Mardia’s Pareto of Type I, Logistic, Burr, Cook-Johnson’s uniform, F and Inverted Beta. See Tapan Nayak (1987) &lt;<a href="https://doi.org/10.2307%2F3214068">doi:10.2307/3214068</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, cubature</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-22 02:33:18 UTC; zlun3</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhixin Lun <a href="https://orcid.org/0000-0002-8980-1554"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Ravindra Khattree <a href="https://orcid.org/0000-0002-9305-2365"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-23 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='MvtBurr'>Multivariate Burr Distribution</h2><span id='topic+MvtBurr'></span><span id='topic+dmvburr'></span><span id='topic+pmvburr'></span><span id='topic+qmvburr'></span><span id='topic+rmvburr'></span><span id='topic+smvburr'></span>

<h3>Description</h3>

<p>Calculation of density function, cumulative distribution function, equicoordinate quantile function and survival function, and random numbers generation for multivariate Burr distribution with a scalar parameter <code>parm1</code> and vectors of parameters <code>parm2</code> and <code>parm3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvburr(x, parm1 = 1, parm2 = rep(1, k), parm3 = rep(1, k), log = FALSE)

pmvburr(q, parm1 = 1, parm2 = rep(1, k), parm3 = rep(1, k))

qmvburr(
  p,
  parm1 = 1,
  parm2 = rep(1, k),
  parm3 = rep(1, k),
  interval = c(0, 1e+08)
)

rmvburr(n, parm1 = 1, parm2 = rep(1, k), parm3 = rep(1, k))

smvburr(q, parm1 = 1, parm2 = rep(1, k), parm3 = rep(1, k))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MvtBurr_+3A_x">x</code></td>
<td>
<p>vector or matrix of quantiles. If <code class="reqn">x</code> is a matrix, each row vector constitutes a vector of quantiles for which the density <code class="reqn">f(x)</code> is calculated (for <code class="reqn">i</code>-th row <code class="reqn">x_i</code>, <code class="reqn">f(x_i)</code> is reported).</p>
</td></tr>
<tr><td><code id="MvtBurr_+3A_parm1">parm1</code></td>
<td>
<p>a scalar parameter, see parameter <code class="reqn">a</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtBurr_+3A_parm2">parm2</code></td>
<td>
<p>a vector of parameters, see parameters <code class="reqn">d_i</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtBurr_+3A_parm3">parm3</code></td>
<td>
<p>a vector of parameters, see parameters <code class="reqn">c_i</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtBurr_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability densities <code class="reqn">f</code> are given as <code class="reqn">log(f)</code>.</p>
</td></tr>
<tr><td><code id="MvtBurr_+3A_q">q</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="MvtBurr_+3A_p">p</code></td>
<td>
<p>a scalar value corresponding to probability.</p>
</td></tr>
<tr><td><code id="MvtBurr_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval to be searched. Default value is set as <code>c(0, 1e8)</code>.</p>
</td></tr>
<tr><td><code id="MvtBurr_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="MvtBurr_+3A_k">k</code></td>
<td>
<p>dimension of data or number of variates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate Burr distribution (Johnson and Kotz, 1972) is a joint distribution of positive random variables <code class="reqn">X_1, \cdots, X_k</code>. Its probability density is given as
</p>
<p style="text-align: center;"><code class="reqn">f(x_1, \cdots, x_k) = \frac{[ \prod_{i=1}^{k} c_i d_i] a(a+1) \cdots (a+k-1) [ \prod_{i=1}^{k} x_i^{c_i-1}]}{(1 + \sum_{i=1}^{k} d_i x_i^{c_i})^{a+k}},</code>
</p>

<p>where <code class="reqn">x_i &gt;0, a,c_i,d_i&gt;0, i=1,\cdots, k</code>.
</p>
<p>Cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> is obtained by the following formula related to survival function <code class="reqn">\bar{F}(x_1, \dots, x_k)</code> (Joe, 1997)
</p>
<p style="text-align: center;"><code class="reqn">F(x_1, \dots, x_k) = 1 + \sum_{S \in \mathcal{S}} (-1)^{|S|} \bar{F}_S(x_j, j \in S),</code>
</p>

<p>where the survival function is given by
</p>
<p style="text-align: center;"><code class="reqn">\bar{F}(x_1, \cdots, x_k) = \left( 1+\sum_{i=1}^{k} d_i x_i^{c_i} \right)^{-a}.</code>
</p>

<p>Equicoordinate quantile is obtained by solving the following equation for <code class="reqn">q</code> through the built-in one dimension root finding function <code><a href="stats.html#topic+uniroot">uniroot</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">\int_{0}^{q} \cdots \int_{0}^{q} f(x_1, \cdots, x_k) dx_k \cdots dx_1 = p,</code>
</p>

<p>where <code class="reqn">p</code> is the given cumulative probability.
</p>
<p>Random numbers <code class="reqn">X_1, \cdots, X_k</code> from multivariate Burr distribution can be generated through transformation of multivariate Lomax random variables <code class="reqn">Y_1, \cdots, Y_k</code> by letting <code class="reqn">X_i=(\theta_i Y_i/d_i)^{1/c_i}, i = 1, \cdots, k</code>; see Nayak (1987).
</p>


<h3>Value</h3>

<p><code>dmvburr</code> gives the numerical values of the probability density.
</p>
<p><code>pmvburr</code> gives the cumulative probability.
</p>
<p><code>qmvburr</code> gives the equicoordinate quantile.
</p>
<p><code>rmvburr</code> generates random numbers.
</p>
<p><code>smvburr</code> gives the value of survival function.
</p>


<h3>References</h3>

<p>Joe, H. (1997). <em>Multivariate Models and Dependence Concepts</em>. London: Chapman &amp; Hall.
</p>
<p>Johnson, N. L. and Kotz, S. (1972). <em>Distribution in Statistics: Continuous Multivariate Distributions</em>. New York: John Wiley &amp; Sons, INC.
</p>
<p>Nayak, T. K. (1987). Multivariate Lomax Distribution: Properties and Usefulness in Reliability Theory. <em>Journal of Applied Probability</em>, Vol. 24, No. 1, 170-177.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> for one dimensional root (zero) finding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculations for the multivariate Burr with parameters:
# a = 3, d1 = 1, d2 = 3, d3 = 5, c1 = 2, c2 = 4, c3 = 6
# Vector of quantiles: c(3, 2, 1)

dmvburr(x = c(3, 2, 1), parm1 = 3, parm2 = c(1, 3, 5), parm3 = c(2, 4, 6)) # Density

pmvburr(q = c(3, 2, 1), parm1 = 3, parm2 = c(1, 3, 5), parm3 = c(2, 4, 6)) # Cumulative Probability

# Equicoordinate quantile of cumulative probability 0.5
qmvburr(p = 0.5, parm1 = 3, parm2 = c(1, 3, 5), parm3 = c(2, 4, 6))

# Random numbers generation with sample size 100
rmvburr(n = 100, parm1 = 3, parm2 = c(1, 3, 5), parm3 = c(2, 4, 6))

smvburr(q = c(3, 2, 1), parm1 = 3, parm2 = c(1, 3, 5), parm3 = c(2, 4, 6)) # Survival function

</code></pre>

<hr>
<h2 id='MvtF'>Multivariate F Distribution</h2><span id='topic+MvtF'></span><span id='topic+dmvf'></span><span id='topic+pmvf'></span><span id='topic+qmvf'></span><span id='topic+rmvf'></span><span id='topic+smvf'></span>

<h3>Description</h3>

<p>Calculation of density function, cumulative distribution function, equicoordinate quantile function and survival function, and random numbers generation for multivariate <code class="reqn">F</code> distribution with degrees of freedom <code>df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvf(x, df = rep(1, k + 1), log = FALSE)

pmvf(q, df = rep(1, k + 1), algorithm = c("numerical", "MC"), nsim = 1e+07)

qmvf(
  p,
  df = rep(1, k + 1),
  interval = c(1e-08, 1e+08),
  algorithm = c("numerical", "MC"),
  nsim = 1e+06
)

rmvf(n, df = rep(1, k + 1))

smvf(q, df = rep(1, k + 1), algorithm = c("numerical", "MC"), nsim = 1e+07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MvtF_+3A_x">x</code></td>
<td>
<p>vector or matrix of quantiles. If <code class="reqn">x</code> is a matrix, each row vector constitutes a vector of quantiles for which the density <code class="reqn">f(x)</code> is calculated (for <code class="reqn">i</code>-th row <code class="reqn">x_i</code>, <code class="reqn">f(x_i)</code> is reported).</p>
</td></tr>
<tr><td><code id="MvtF_+3A_df">df</code></td>
<td>
<p>a vector of <code class="reqn">k+1</code> degrees of freedom, see parameter <code class="reqn">(2a, 2l_1, \ldots, 2l_k)</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtF_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability densities <code class="reqn">f</code> are given as <code class="reqn">log(f)</code>.</p>
</td></tr>
<tr><td><code id="MvtF_+3A_q">q</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="MvtF_+3A_algorithm">algorithm</code></td>
<td>
<p>method to be used for calculating cumulative probability. Two options are provided as (i) <code>numerical</code> using adaptive multivariate integral and (ii) <code>MC</code> using Monte Carlo method. Recommend algorithm <code>numerical</code> for <code class="reqn">(k &lt;= 4)</code> dimension and <code>MC</code> for <code class="reqn">(k &gt; 4)</code> dimension based on running time consumption. Default option is set as <code>numerical</code>.</p>
</td></tr>
<tr><td><code id="MvtF_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations used in algorithm <code>MC</code>.</p>
</td></tr>
<tr><td><code id="MvtF_+3A_p">p</code></td>
<td>
<p>a scalar value corresponding to probability.</p>
</td></tr>
<tr><td><code id="MvtF_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval to be searched. Default value is set as <code>c(1e-8, 1e8)</code>.</p>
</td></tr>
<tr><td><code id="MvtF_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="MvtF_+3A_k">k</code></td>
<td>
<p>dimension of data or number of variates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate <code class="reqn">F</code> distribution (Johnson and Kotz, 1972) is a joint probability distribution of positive random variables and its probability density is given as
</p>
<p style="text-align: center;"><code class="reqn">f(x_1, \cdots, x_k) = \frac{[ \prod_{i=1}^{k} (l_i/a)^{l_i}] \Gamma(\sum_{i=1}^{k} l_i + a) \prod_{i=1}^{k} x_i^{l_i-1}}{\Gamma(a) [ \prod_{i=1}^{k} \Gamma(l_i)] (1+\sum_{i=1}^{k} \frac{l_i}{a}x_i )^{\sum_{i=1}^{k} l_i + a}},</code>
</p>

<p>where <code class="reqn">x_i&gt;0, a&gt;0, l_i&gt;0, i=1,\cdots, k</code>. The degrees of freedom are <code class="reqn">(2a, 2l_1,\dots,2l_k)</code>.
</p>
<p>Cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> is obtained by multiple integral
</p>
<p style="text-align: center;"><code class="reqn">F(x_1, \dots, x_k) = \int_{0}^{x_1} \cdots  \int_{0}^{x_k} f(y_1, \cdots, y_k) dy_k \cdots dy_1.</code>
</p>

<p>This multiple integral is calculated by either adaptive multivariate integration using <code><a href="cubature.html#topic+hcubature">hcubature</a></code> in package <strong><a href="cubature.html#topic+cubature">cubature</a></strong> (Narasimhan et al., 2018) or via Monte Carlo method.
</p>
<p>Equicoordinate quantile is obtained by solving the following equation for <code class="reqn">q</code> through the built-in one dimension root finding function <code><a href="stats.html#topic+uniroot">uniroot</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">\int_{0}^{q} \cdots \int_{0}^{q} f(x_1, \cdots, x_k) dx_k \cdots dx_1 = p,</code>
</p>

<p>where <code class="reqn">p</code> is the given cumulative probability.
</p>
<p>The survival function <code class="reqn">\bar{F}(x_1, \cdots, x_k)</code> is obtained either by the following formula related to cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> (Joe, 1997)
</p>
<p style="text-align: center;"><code class="reqn">\bar{F}(x_1, \cdots, x_k) = 1 + \sum_{S \in \mathcal{S}} (-1)^{|S|} F_S(x_j, j \in S),</code>
</p>

<p>or via Monte Carlo method.
</p>
<p>Random numbers <code class="reqn">X_1, \cdots, X_k</code> from multivariate F distribution can be generated through parameter substitutions in simulation of generalized multivariate Lomax distribution by letting <code class="reqn">\theta_i = l_i/a, i = 1, \cdots, k</code>; see Nayak (1987).
</p>


<h3>Value</h3>

<p><code>dmvf</code> gives the numerical values of the probability density.
</p>
<p><code>pmvf</code> gives a list of two items:
</p>
<p><code class="reqn">\quad</code> <code>value</code> cumulative probability
</p>
<p><code class="reqn">\quad</code> <code>error</code> the estimated relative error by <code>algorithm = "numerical"</code> or the estimated standard error by <code>algorithm = "MC"</code>
</p>
<p><code>qmvf</code> gives the equicoordinate quantile. <code>NaN</code> is returned for no solution found in the given interval. The result is seed dependent if Monte Carlo algorithm is chosen  (<code>algorithm = "MC"</code>).
</p>
<p><code>rmvf</code> generates random numbers.
</p>
<p><code>smvf</code> gives a list of two items:
</p>
<p><code class="reqn">\quad</code> <code>value</code> the value of survial function
</p>
<p><code class="reqn">\quad</code> <code>error</code> the estimated relative error by <code>algorithm = "numerical"</code> or the estimated standard error by <code>algorithm = "MC"</code>
</p>


<h3>References</h3>

<p>Joe, H. (1997). <em>Multivariate Models and Dependence Concepts</em>. London: Chapman &amp; Hall.
</p>
<p>Johnson, N. L. and Kotz, S. (1972). <em>Distribution in Statistics: Continuous Multivariate Distributions</em>. New York: John Wiley &amp; Sons, INC.
</p>
<p>Narasimhan, B.,  Koller, M., Johnson, S. G., Hahn, T., Bouvier, A., Kiêu, K. and Gaure, S. (2018). cubature: Adaptive Multivariate Integration over Hypercubes. R package version 2.0.3.
</p>
<p>Nayak, T. K. (1987). Multivariate Lomax Distribution: Properties and Usefulness in Reliability Theory. <em>Journal of Applied Probability</em>, Vol. 24, No. 1, 170-177.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> for one dimensional root (zero) finding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculations for the multivariate F with degrees of freedom:
# df = c(2, 4, 6)
# Vector of quantiles:  c(1, 2)

dmvf(x = c(1, 2), df = c(2, 4, 6)) # Density

# Cumulative Probability using adaptive multivariate integral
pmvf(q = c(1, 2), df = c(2, 4, 6), algorithm = "numerical")


# Cumulative Probability using Monte Carlo method
pmvf(q = c(1, 2), df = c(2, 4, 6), algorithm = "MC")


# Equicoordinate quantile of cumulative probability 0.5
qmvf(p = 0.5, df = c(2, 4, 6))

# Random numbers generation with sample size 100
rmvf(n = 100, df = c(2, 4, 6))

smvf(q = c(1, 2), df = c(2, 4, 6)) # Survival function

</code></pre>

<hr>
<h2 id='MvtGlomx'>Generalized Multivariate Lomax (Pareto Type II) Distribution</h2><span id='topic+MvtGlomx'></span><span id='topic+dmvglomax'></span><span id='topic+pmvglomax'></span><span id='topic+qmvglomax'></span><span id='topic+rmvglomax'></span><span id='topic+smvglomax'></span>

<h3>Description</h3>

<p>Calculation of density function, cumulative distribution function, equicoordinate quantile function and survival function, and random numbers generation for generalized multivariate Lomax distribution with a scalar parameter <code>parm1</code> and vectors of parameters <code>parm2</code> and <code>parm3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvglomax(x, parm1 = 1, parm2 = rep(1, k), parm3 = rep(1, k), log = FALSE)

pmvglomax(
  q,
  parm1 = 1,
  parm2 = rep(1, k),
  parm3 = rep(1, k),
  algorithm = c("numerical", "MC"),
  nsim = 1e+07
)

qmvglomax(
  p,
  parm1 = 1,
  parm2 = rep(1, k),
  parm3 = rep(1, k),
  interval = c(1e-08, 1e+08),
  algorithm = c("numerical", "MC"),
  nsim = 1e+06
)

rmvglomax(n, parm1 = 1, parm2 = rep(1, k), parm3 = rep(1, k))

smvglomax(
  q,
  parm1 = 1,
  parm2 = rep(1, k),
  parm3 = rep(1, k),
  algorithm = c("numerical", "MC"),
  nsim = 1e+07
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MvtGlomx_+3A_x">x</code></td>
<td>
<p>vector or matrix of quantiles. If <code class="reqn">x</code> is a matrix, each row vector constitutes a vector of quantiles for which the density <code class="reqn">f(x)</code> is calculated (for <code class="reqn">i</code>-th row <code class="reqn">x_i</code>, <code class="reqn">f(x_i)</code> is reported).</p>
</td></tr>
<tr><td><code id="MvtGlomx_+3A_parm1">parm1</code></td>
<td>
<p>a scalar parameter, see parameter <code class="reqn">a</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtGlomx_+3A_parm2">parm2</code></td>
<td>
<p>a vector of parameters, see parameters <code class="reqn">\theta_i</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtGlomx_+3A_parm3">parm3</code></td>
<td>
<p>a vector of parameters, see parameters <code class="reqn">l_i</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtGlomx_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability densities <code class="reqn">f</code> are given as <code class="reqn">log(f)</code>.</p>
</td></tr>
<tr><td><code id="MvtGlomx_+3A_q">q</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="MvtGlomx_+3A_algorithm">algorithm</code></td>
<td>
<p>method to be used for calculating cumulative probability. Two options are provided as (i) <code>numerical</code> using adaptive multivariate integral and (ii) <code>MC</code> using Monte Carlo method. Recommend algorithm <code>numerical</code> for <code class="reqn">(k &lt;= 4)</code> dimension and <code>MC</code> for <code class="reqn">(k &gt; 4)</code> dimension based on running time consumption. Default option is set as <code>numerical</code>.</p>
</td></tr>
<tr><td><code id="MvtGlomx_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations used in algorithm <code>MC</code>.</p>
</td></tr>
<tr><td><code id="MvtGlomx_+3A_p">p</code></td>
<td>
<p>a scalar value corresponding to probability.</p>
</td></tr>
<tr><td><code id="MvtGlomx_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval to be searched. Default value is set as <code>c(1e-8, 1e8)</code>.</p>
</td></tr>
<tr><td><code id="MvtGlomx_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="MvtGlomx_+3A_k">k</code></td>
<td>
<p>dimension of data or number of variates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generalized multivariate Lomax (Pareto type II) distribution was introduced by Nayak (1987) as a joint probability distribution of several skewed nonnegative random variables <code class="reqn">X_1, X_2, \cdots, X_k</code>. Its probability density function is given by
</p>
<p style="text-align: center;"><code class="reqn">f(x_1, \cdots, x_k) = \frac{[ \prod_{i=1}^{k} \theta_i^{l_i}] \Gamma(\sum_{i=1}^{k} l_i + a ) \prod_{i=1}^{k} x_i^{l_i-1}}{\Gamma(a)[ \prod_{i=1}^{k} \Gamma(l_i)] (1+\sum_{i=1}^{k} \theta_i x_i )^{\sum_{i=1}^{k} l_i + a}},</code>
</p>

<p>where <code class="reqn">x_i&gt;0, a,\theta_i, l_i&gt;0, i=1,\cdots,k</code>.
</p>
<p>Cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> is obtained by multiple integral
</p>
<p style="text-align: center;"><code class="reqn">F(x_1, \dots, x_k) = \int_{0}^{x_1} \cdots  \int_{0}^{x_k} f(y_1, \cdots, y_k) dy_k \cdots dy_1.</code>
</p>

<p>This multiple integral is calculated by either adaptive multivariate integration using <code><a href="cubature.html#topic+hcubature">hcubature</a></code> in package <strong><a href="cubature.html#topic+cubature">cubature</a></strong> (Narasimhan et al., 2018) or via Monte Carlo method.
</p>
<p>Equicoordinate quantile is obtained by solving the following equation for <code class="reqn">q</code> through the built-in one dimension root finding function <code><a href="stats.html#topic+uniroot">uniroot</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">\int_{0}^{q} \cdots \int_{0}^{q} f(x_1, \cdots, x_k) dx_k \cdots dx_1 = p,</code>
</p>

<p>where <code class="reqn">p</code> is the given cumulative probability.
</p>
<p>The survival function <code class="reqn">\bar{F}(x_1, \cdots, x_k)</code> is obtained either by the following formula related to cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> (Joe, 1997)
</p>
<p style="text-align: center;"><code class="reqn">\bar{F}(x_1, \cdots, x_k) = 1 + \sum_{S \in \mathcal{S}} (-1)^{|S|} F_S(x_j, j \in S),</code>
</p>

<p>or via Monte Carlo method.
</p>
<p>Random numbers from generalized multivariate Lomax distribution can be generated by simulating <code class="reqn">k</code> independent gamma random variables having a common parameter following gamma distribution with shape parameter <code class="reqn">a</code> and scale parameter <code class="reqn">1</code>; see Nayak (1987).
</p>


<h3>Value</h3>

<p><code>dmvglomax</code> gives the numerical values of the probability density.
</p>
<p><code>pmvglomax</code> gives a list of two items:
</p>
<p><code class="reqn">\quad</code> <code>value</code> cumulative probability
</p>
<p><code class="reqn">\quad</code> <code>error</code> the estimated relative error by <code>algorithm = "numerical"</code> or the estimated standard error by <code>algorithm = "MC"</code>
</p>
<p><code>qmvglomax</code> gives the equicoordinate quantile. <code>NaN</code> is returned for no solution found in the given interval. The result is seed dependent if Monte Carlo algorithm is chosen  (<code>algorithm = "MC"</code>).
</p>
<p><code>rmvglomax</code> generates random numbers.
</p>
<p><code>smvglomax</code> gives a list of two items:
</p>
<p><code class="reqn">\quad</code> <code>value</code> the value of survial function
</p>
<p><code class="reqn">\quad</code> <code>error</code> the estimated relative error by <code>algorithm = "numerical"</code> or the estimated standard error by <code>algorithm = "MC"</code>
</p>


<h3>References</h3>

<p>Joe, H. (1997). <em>Multivariate Models and Dependence Concepts</em>. London: Chapman &amp; Hall.
</p>
<p>Narasimhan, B.,  Koller, M., Johnson, S. G., Hahn, T., Bouvier, A., Kiêu, K. and Gaure, S. (2018). cubature: Adaptive Multivariate Integration over Hypercubes. R package version 2.0.3.
</p>
<p>Nayak, T. K. (1987). Multivariate Lomax Distribution: Properties and Usefulness in Reliability Theory. <em>Journal of Applied Probability</em>, Vol. 24, No. 1, 170-177.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> for one dimensional root (zero) finding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculations for the generalized multivariate Lomax with parameters:
# a = 5, theta1 = 1, theta2 = 2, l1 = 4, l2 = 5
# Vector of quantiles: c(5, 6)

dmvglomax(x = c(5, 6), parm1 = 5, parm2 = c(1, 2), parm3 = c(4, 5)) # Density


# Cumulative Probability using adaptive multivariate integral
pmvglomax(q = c(5, 6), parm1 = 5, parm2 = c(1, 2), parm3 = c(4, 5))


# Cumulative Probability using Monte Carlo method
pmvglomax(q = c(5, 6), parm1 = 5, parm2 = c(1, 2), parm3 = c(4, 5), algorithm = "MC")


# Equicoordinate quantile of cumulative probability 0.5
qmvglomax(p = 0.5, parm1 = 5, parm2 = c(1, 2), parm3 = c(4, 5))

# Random numbers generation with sample size 100
rmvglomax(n = 100, parm1 = 5, parm2 = c(1, 2), parm3 = c(4, 5))

smvglomax(q = c(5, 6), parm1 = 5, parm2 = c(1, 2), parm3 = c(4, 5)) # Survival function

</code></pre>

<hr>
<h2 id='MvtInvBeta'>Multivariate Inverted Beta Distribution</h2><span id='topic+MvtInvBeta'></span><span id='topic+dmvinvbeta'></span><span id='topic+pmvinvbeta'></span><span id='topic+qmvinvbeta'></span><span id='topic+rmvinvbeta'></span><span id='topic+smvinvbeta'></span>

<h3>Description</h3>

<p>Calculation of density function, cumulative distribution function, equicoordinate quantile function and survival function, and random numbers generation for multivariate inverted beta distribution with a scalar parameter <code>parm1</code> and a vector of parameters <code>parm2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvinvbeta(x, parm1 = 1, parm2 = rep(1, k), log = FALSE)

pmvinvbeta(
  q,
  parm1 = 1,
  parm2 = rep(1, k),
  algorithm = c("numerical", "MC"),
  nsim = 1e+07
)

qmvinvbeta(
  p,
  parm1 = 1,
  parm2 = rep(1, k),
  interval = c(1e-08, 1e+08),
  algorithm = c("numerical", "MC"),
  nsim = 1e+06
)

rmvinvbeta(n, parm1 = 1, parm2 = rep(1, k))

smvinvbeta(
  q,
  parm1 = 1,
  parm2 = rep(1, k),
  algorithm = c("numerical", "MC"),
  nsim = 1e+07
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MvtInvBeta_+3A_x">x</code></td>
<td>
<p>vector or matrix of quantiles. If <code class="reqn">x</code> is a matrix, each row vector constitutes a vector of quantiles for which the density <code class="reqn">f(x)</code> is calculated (for <code class="reqn">i</code>-th row <code class="reqn">x_i</code>, <code class="reqn">f(x_i)</code> is reported).</p>
</td></tr>
<tr><td><code id="MvtInvBeta_+3A_parm1">parm1</code></td>
<td>
<p>a scalar parameter, see parameter <code class="reqn">a</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtInvBeta_+3A_parm2">parm2</code></td>
<td>
<p>a vector of parameters, see parameter <code class="reqn">l_i</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtInvBeta_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability densities <code class="reqn">f</code> are given as <code class="reqn">log(f)</code>.</p>
</td></tr>
<tr><td><code id="MvtInvBeta_+3A_q">q</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="MvtInvBeta_+3A_algorithm">algorithm</code></td>
<td>
<p>method to be used for calculating cumulative probability. Two options are provided as (i) <code>numerical</code> using adaptive multivariate integral and (ii) <code>MC</code> using Monte Carlo method. Recommend algorithm <code>numerical</code> for <code class="reqn">(k &lt;= 4)</code> dimension and <code>MC</code> for <code class="reqn">(k &gt; 4)</code> dimension based on running time consumption. Default option is set as <code>numerical</code>.</p>
</td></tr>
<tr><td><code id="MvtInvBeta_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations used in algorithm <code>MC</code>.</p>
</td></tr>
<tr><td><code id="MvtInvBeta_+3A_p">p</code></td>
<td>
<p>a scalar value corresponding to probability.</p>
</td></tr>
<tr><td><code id="MvtInvBeta_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval to be searched. Default value is set as <code>c(1e-8, 1e8)</code>.</p>
</td></tr>
<tr><td><code id="MvtInvBeta_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="MvtInvBeta_+3A_k">k</code></td>
<td>
<p>dimension of data or number of variates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate inverted beta distribution is an alternative expression of multivariate F distribution and is a special case of multivariate Lomax distribution (Balakrishnan and Lai, 2009). Its probability density is given as
</p>
<p style="text-align: center;"><code class="reqn">f(x_1, \cdots, x_p) = \frac{\Gamma(\sum_{i=1}^{p} l_i + a) \prod_{i=1}^{p} x_i^{l_i-1}}{\Gamma(a) [\prod_{i=1}^{p} \Gamma(l_i)] (1+\sum_{i=1}^{p} x_i)^{\sum_{i=1}^{p} l_i + a}},</code>
</p>

<p>where <code class="reqn">x_i&gt;0, a&gt;0, l_i&gt;0, i=1,\cdots, p</code>.
</p>
<p>Cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> is obtained by multiple integral
</p>
<p style="text-align: center;"><code class="reqn">F(x_1, \dots, x_k) = \int_{0}^{x_1} \cdots  \int_{0}^{x_k} f(y_1, \cdots, y_k) dy_k \cdots dy_1.</code>
</p>

<p>This multiple integral is calculated by either adaptive multivariate integration using <code><a href="cubature.html#topic+hcubature">hcubature</a></code> in package <strong><a href="cubature.html#topic+cubature">cubature</a></strong> (Narasimhan et al., 2018) or via Monte Carlo method.
</p>
<p>Equicoordinate quantile is obtained by solving the following equation for <code class="reqn">q</code> through the built-in one dimension root finding function <code><a href="stats.html#topic+uniroot">uniroot</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">\int_{0}^{q} \cdots \int_{0}^{q} f(x_1, \cdots, x_k) dx_k \cdots dx_1 = p,</code>
</p>

<p>where <code class="reqn">p</code> is the given cumulative probability.
</p>
<p>The survival function <code class="reqn">\bar{F}(x_1, \cdots, x_k)</code> is obtained either by the following formula related to cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> (Joe, 1997)
</p>
<p style="text-align: center;"><code class="reqn">\bar{F}(x_1, \cdots, x_k) = 1 + \sum_{S \in \mathcal{S}} (-1)^{|S|} F_S(x_j, j \in S),</code>
</p>

<p>or via Monte Carlo method.
</p>
<p>Random numbers <code class="reqn">X_1, \cdots, X_k</code> from multivariate inverted beta distribution can be generated through parameter substitutions in simulation of generalized multivariate Lomax distribution by letting <code class="reqn">\theta_i = 1, i = 1, \cdots, k</code>.
</p>


<h3>Value</h3>

<p><code>dmvinvbeta</code> gives the numerical values of the probability density.
</p>
<p><code>pmvinvbeta</code> gives a list of two items:
</p>
<p><code class="reqn">\quad</code> <code>value</code> cumulative probability
</p>
<p><code class="reqn">\quad</code> <code>error</code> the estimated relative error by <code>algorithm = "numerical"</code> or the estimated standard error by <code>algorithm = "MC"</code>
</p>
<p><code>qmvinvbeta</code> gives the equicoordinate quantile. <code>NaN</code> is returned for no solution found in the given interval. The result is seed dependent if Monte Carlo algorithm is chosen  (<code>algorithm = "MC"</code>).
</p>
<p><code>rmvinvbeta</code> generates random numbers.
</p>
<p><code>smvinvbeta</code> gives a list of two items:
</p>
<p><code class="reqn">\quad</code> <code>value</code> the value of survial function
</p>
<p><code class="reqn">\quad</code> <code>error</code> the estimated relative error by <code>algorithm = "numerical"</code> or the estimated standard error by <code>algorithm = "MC"</code>
</p>


<h3>References</h3>

<p>Balakrishnan, N. and Lai, C. (2009). <em>Continuous Bivariate Distributions. 2nd Edition.</em> New York: Springer.
</p>
<p>Joe, H. (1997). <em>Multivariate Models and Dependence Concepts</em>. London: Chapman &amp; Hall.
</p>
<p>Narasimhan, B.,  Koller, M., Johnson, S. G., Hahn, T., Bouvier, A., Kiêu, K. and Gaure, S. (2018). cubature: Adaptive Multivariate Integration over Hypercubes. R package version 2.0.3.
</p>
<p>Nayak, T. K. (1987). Multivariate Lomax Distribution: Properties and Usefulness in Reliability Theory. <em>Journal of Applied Probability</em>, Vol. 24, No. 1, 170-177.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> for one dimensional root (zero) finding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculations for the multivariate inverted beta with parameters:
# a = 7, l1 = 1, l2 = 3
# Vector of quantiles: c(2, 4)

dmvinvbeta(x = c(2, 4), parm1 = 7, parm2 = c(1, 3)) # Density

# Cumulative Probability using adaptive multivariate integral
pmvinvbeta(q = c(2, 4), parm1 = 7, parm2 = c(1, 3))


# Cumulative Probability using Monte Carlo method
pmvinvbeta(q = c(2, 4), parm1 = 7, parm2 = c(1, 3), algorithm = "MC")


# Equicoordinate quantile of cumulative probability 0.5
qmvinvbeta(p = 0.5, parm1 = 7, parm2 = c(1, 3))

# Random numbers generation with sample size 100
rmvinvbeta(n = 100, parm1 = 7, parm2 = c(1, 3))

smvinvbeta(q = c(2, 4), parm1 = 7, parm2 = c(1, 3)) # Survival function

</code></pre>

<hr>
<h2 id='MvtLogis'>Multivariate Logistic Distribution</h2><span id='topic+MvtLogis'></span><span id='topic+dmvlogis'></span><span id='topic+pmvlogis'></span><span id='topic+qmvlogis'></span><span id='topic+rmvlogis'></span><span id='topic+smvlogis'></span>

<h3>Description</h3>

<p>Calculation of density function, cumulative distribution function, equicoordinate quantile function and survival function, and random numbers generation for multivariate logistic distribution with vector parameter <code>parm1</code> and vector parameter <code>parm2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvlogis(x, parm1 = rep(1, k), parm2 = rep(1, k), log = FALSE)

pmvlogis(q, parm1 = rep(1, k), parm2 = rep(1, k))

qmvlogis(p, parm1 = rep(1, k), parm2 = rep(1, k), interval = c(0, 1e+08))

rmvlogis(n, parm1 = rep(1, k), parm2 = rep(1, k))

smvlogis(q, parm1 = rep(1, k), parm2 = rep(1, k))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MvtLogis_+3A_x">x</code></td>
<td>
<p>vector or matrix of quantiles. If <code class="reqn">x</code> is a matrix, each row vector constitutes a vector of quantiles for which the density <code class="reqn">f(x)</code> is calculated (for <code class="reqn">i</code>-th row <code class="reqn">x_i</code>, <code class="reqn">f(x_i)</code> is reported).</p>
</td></tr>
<tr><td><code id="MvtLogis_+3A_parm1">parm1</code></td>
<td>
<p>a vector of location parameters, see parameter <code class="reqn">\mu_i</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtLogis_+3A_parm2">parm2</code></td>
<td>
<p>a vector of scale parameters, see parameters <code class="reqn">\sigma_i</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtLogis_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability densities <code class="reqn">f</code> are given as <code class="reqn">log(f)</code>.</p>
</td></tr>
<tr><td><code id="MvtLogis_+3A_q">q</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="MvtLogis_+3A_p">p</code></td>
<td>
<p>a scalar value corresponding to probability.</p>
</td></tr>
<tr><td><code id="MvtLogis_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval to be searched. Default value is set as <code>c(0, 1e8)</code>.</p>
</td></tr>
<tr><td><code id="MvtLogis_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="MvtLogis_+3A_k">k</code></td>
<td>
<p>dimension of data or number of variates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bivariate logistic distribution was introduced by Gumbel (1961) and its multivariate generalization was given by Malik and Abraham (1973) as
</p>
<p style="text-align: center;"><code class="reqn">f(x_1, \cdots, x_k) = \frac{k! \exp{(-\sum_{i=1}^{k} \frac{x_i - \mu_i}{\sigma_i})}}{[\prod_{i=1}^{p} \sigma_i] [1 + \sum_{i=1}^{k} \exp{(-\frac{x_i - \mu_i}{\sigma_i})}]^{1+k}},</code>
</p>

<p>where <code class="reqn">-\infty&lt;x_i, \mu_i&lt;\infty, \sigma_i &gt; 0, i=1,\cdots, k</code>.
</p>
<p>Cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> is given as
</p>
<p style="text-align: center;"><code class="reqn">F(x_1, \cdots, x_k) = \left[1 + \sum_{i=1}^{k} \exp(-\frac{x_i-\mu_i}{\sigma_i})\right]^{-1}.</code>
</p>

<p>Equicoordinate quantile is obtained by solving the following equation for <code class="reqn">q</code> through the built-in one dimension root finding function <code><a href="stats.html#topic+uniroot">uniroot</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">\int_{-\infty}^{q} \cdots \int_{-\infty}^{q} f(x_1, \cdots, x_k) dx_k \cdots dx_1 = p,</code>
</p>

<p>where <code class="reqn">p</code> is the given cumulative probability.
</p>
<p>The survival function <code class="reqn">\bar{F}(x_1, \cdots, x_k)</code> is obtained by the following formula related to cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> (Joe, 1997)
</p>
<p style="text-align: center;"><code class="reqn">\bar{F}(x_1, \cdots, x_k) = 1 + \sum_{S \in \mathcal{S}} (-1)^{|S|} F_S(x_j, j \in S).</code>
</p>

<p>Random numbers <code class="reqn">X_1, \cdots, X_k</code> from multivariate logistic distribution can be generated through transformation of multivariate Lomax random variables <code class="reqn">Y_1, \cdots, Y_k</code> by letting <code class="reqn">X_i=\mu_i-\sigma_i\ln(\theta_i Y_i), i = 1, \cdots, k</code>; see Nayak (1987).
</p>


<h3>Value</h3>

<p><code>dmvlogis</code> gives the numerical values of the probability density.
</p>
<p><code>pmvlogis</code> gives the cumulative probability.
</p>
<p><code>qmvlogis</code> gives the equicoordinate quantile.
</p>
<p><code>rmvlogis</code> generates random numbers.
</p>
<p><code>smvlogis</code> gives the value of survival function
</p>


<h3>References</h3>

<p>Gumbel, E.J. (1961). Bivariate logistic distribution. <em>J. Am. Stat. Assoc.</em>, 56, 335-349.
</p>
<p>Joe, H. (1997). <em>Multivariate Models and Dependence Concepts</em>. London: Chapman &amp; Hall.
</p>
<p>Malik, H. J. and Abraham, B. (1973). Multivariate logistic distributions. <em>Ann. Statist.</em> 3, 588-590.
</p>
<p>Nayak, T. K. (1987). Multivariate Lomax Distribution: Properties and Usefulness in Reliability Theory. <em>Journal of Applied Probability</em>, Vol. 24, No. 1, 170-177.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> for one dimensional root (zero) finding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculations for the multivariate logistic distribution with parameters:
# mu1 = 0.5, mu2 = 1, mu3 = 2, sigma1 = 1, sigma2 = 2 and sigma3 = 3
# Vector of quantiles: c(3, 2, 1)

dmvlogis(x = c(3, 2, 1), parm1 = c(0.5, 1, 2), parm2 = c(1, 2, 3)) # Density

pmvlogis(q = c(3, 2, 1), parm1 = c(0.5, 1, 2), parm2 = c(1, 2, 3)) # Cumulative Probability

# Equicoordinate quantile of cumulative probability 0.5
qmvlogis(p = 0.5, parm1 = c(0.5, 1, 2), parm2 = c(1, 2, 3))

# Random numbers generation with sample size 100
rmvlogis(n = 100, parm1 = c(0.5, 1, 2), parm2 = c(1, 2, 3)) 

smvlogis(q = c(3, 2, 1), parm1 = c(0.5, 1, 2), parm2 = c(1, 2, 3)) # Survival function

</code></pre>

<hr>
<h2 id='MvtLomax'>Multivariate Lomax (Pareto Type II) Distribution</h2><span id='topic+MvtLomax'></span><span id='topic+dmvlomax'></span><span id='topic+pmvlomax'></span><span id='topic+qmvlomax'></span><span id='topic+rmvlomax'></span><span id='topic+smvlomax'></span>

<h3>Description</h3>

<p>Calculation of density function, cumulative distribution function, equicoordinate quantile function and survival function, and random numbers generation for multivariate Lomax (Pareto Type II) distribution with a scalar parameter <code>parm1</code> and vector parameter <code>parm2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvlomax(x, parm1 = 1, parm2 = rep(1, k), log = FALSE)

pmvlomax(q, parm1 = 1, parm2 = rep(1, k))

qmvlomax(p, parm1 = 1, parm2 = rep(1, k), interval = c(0, 1e+08))

rmvlomax(n, parm1 = 1, parm2 = rep(1, k))

smvlomax(q, parm1 = 1, parm2 = rep(1, k))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MvtLomax_+3A_x">x</code></td>
<td>
<p>vector or matrix of quantiles. If <code class="reqn">x</code> is a matrix, each row vector constitutes a vector of quantiles for which the density <code class="reqn">f(x)</code> is calculated (for <code class="reqn">i</code>-th row <code class="reqn">x_i</code>, <code class="reqn">f(x_i)</code> is reported).</p>
</td></tr>
<tr><td><code id="MvtLomax_+3A_parm1">parm1</code></td>
<td>
<p>a scalar parameter, see parameter <code class="reqn">a</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtLomax_+3A_parm2">parm2</code></td>
<td>
<p>a vector of parameters, see parameters <code class="reqn">\theta_i</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtLomax_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability densities <code class="reqn">f</code> are given as <code class="reqn">log(f)</code>.</p>
</td></tr>
<tr><td><code id="MvtLomax_+3A_q">q</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="MvtLomax_+3A_p">p</code></td>
<td>
<p>a scalar value corresponding to probability.</p>
</td></tr>
<tr><td><code id="MvtLomax_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval to be searched. Default value is set as <code>c(0, 1e8)</code>.</p>
</td></tr>
<tr><td><code id="MvtLomax_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="MvtLomax_+3A_k">k</code></td>
<td>
<p>dimension of data or number of variates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate Lomax (Pareto type II) distribution was introduced by Nayak (1987) as a joint probability distribution of several skewed positive random variables <code class="reqn">X_1, X_2, \cdots, X_k</code>. Its probability density function is given by
</p>
<p style="text-align: center;"><code class="reqn">f(x_1, x_2, \dots, x_k) = \frac{[ \prod_{i=1}^{k} \theta_i] a(a+1) \cdots (a+k-1)}{(1+\sum_{i=1}^{k} \theta_i x_i)^{a+k}},</code>
</p>

<p>where <code class="reqn">x_i &gt; 0, a&gt;0, \theta_i&gt;0, i=1,\dots,k</code>.
</p>
<p>Cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> is obtained by the following formula related to survival function <code class="reqn">\bar{F}(x_1, \dots, x_k)</code> (Joe, 1997)
</p>
<p style="text-align: center;"><code class="reqn">F(x_1, \dots, x_k) = 1 + \sum_{S \in \mathcal{S}} (-1)^{|S|} \bar{F}_S(x_j, j \in S),</code>
</p>

<p>where the survival function is given by
</p>
<p style="text-align: center;"><code class="reqn">\bar{F}(x_1, \dots, x_k) = ( 1+\sum_{i=1}^{k} \theta_i x_i )^{-a}.</code>
</p>

<p>Equicoordinate quantile is obtained by solving the following equation for <code class="reqn">q</code> through the built-in one dimension root finding function <code><a href="stats.html#topic+uniroot">uniroot</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">\int_{0}^{q} \cdots \int_{0}^{q} f(x_1, \cdots, x_k) dx_k \cdots dx_1 = p,</code>
</p>

<p>where <code class="reqn">p</code> is the given cumulative probability.
</p>
<p>Random numbers from multivariate Lomax distribution can be generated by simulating <code class="reqn">k</code> independent exponential random variables having a common environment parameter following gamma distribution with shape parameter <code class="reqn">a</code> and scale parameter <code class="reqn">1</code>; see Nayak (1987).
</p>


<h3>Value</h3>

<p><code>dmvlomax</code> gives the numerical values of the probability density.
</p>
<p><code>pmvlomax</code> gives the cumulative probability.
</p>
<p><code>qmvlomax</code> gives the equicoordinate quantile.
</p>
<p><code>rmvlomax</code> generates random numbers.
</p>
<p><code>smvlomax</code> gives the value of survival function.
</p>


<h3>References</h3>

<p>Joe, H. (1997). <em>Multivariate Models and Dependence Concepts</em>. London: Chapman &amp; Hall.
</p>
<p>Nayak, T. K. (1987). Multivariate Lomax Distribution: Properties and Usefulness in Reliability Theory. <em>Journal of Applied Probability</em>, Vol. 24, No. 1, 170-177.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> for one dimensional root (zero) finding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculations for the multivariate Lomax with parameters: 
# a = 5, theta1 = 1, theta2 = 2 and theta3 = 3.
# Vector of quantiles: c(3, 2, 1)

dmvlomax(x = c(3, 2, 1), parm1 = 5, parm2 = c(1, 2, 3)) # Density

pmvlomax(q = c(3, 2, 1), parm1 = 5, parm2 = c(1, 2, 3)) # Cumulative Probability

# Equicoordinate quantile of cumulative probability 0.5
qmvlomax(p = 0.5, parm1 = 5, parm2 = c(1, 2, 3)) 

# Random numbers generation with sample size 100
rmvlomax(n = 100, parm1 = 5, parm2 = c(1, 2, 3)) 

smvlomax(q = c(3, 2, 1), parm1 = 5, parm2 = c(1, 2, 3)) # Survival function

</code></pre>

<hr>
<h2 id='MvtMardiaPareto1'>Mardia's Multivariate Pareto Type I Distribution</h2><span id='topic+MvtMardiaPareto1'></span><span id='topic+dmvmpareto1'></span><span id='topic+pmvmpareto1'></span><span id='topic+qmvmpareto1'></span><span id='topic+rmvmpareto1'></span><span id='topic+smvmpareto1'></span>

<h3>Description</h3>

<p>Calculation of density function, cumulative distribution function, equicoordinate quantile function and survival function, and random numbers generation for Mardia's multivariate Pareto Type I distribution with a scalar parameter <code>parm1</code> and a vector of parameters <code>parm2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvmpareto1(x, parm1 = 1, parm2 = rep(1, k), log = FALSE)

pmvmpareto1(q, parm1 = 1, parm2 = rep(1, k))

qmvmpareto1(
  p,
  parm1 = 1,
  parm2 = rep(1, k),
  interval = c(max(1/parm2) + 1e-08, 1e+08)
)

rmvmpareto1(n, parm1 = 1, parm2 = rep(1, k))

smvmpareto1(q, parm1 = 1, parm2 = rep(1, k))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MvtMardiaPareto1_+3A_x">x</code></td>
<td>
<p>vector or matrix of quantiles. If <code class="reqn">x</code> is a matrix, each row vector constitutes a vector of quantiles for which the density <code class="reqn">f(x)</code> is calculated (for <code class="reqn">i</code>-th row <code class="reqn">x_i</code>, <code class="reqn">f(x_i)</code> is reported).</p>
</td></tr>
<tr><td><code id="MvtMardiaPareto1_+3A_parm1">parm1</code></td>
<td>
<p>a scalar parameter, see parameter <code class="reqn">a</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtMardiaPareto1_+3A_parm2">parm2</code></td>
<td>
<p>a vector of parameters, see parameters <code class="reqn">\theta_i</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtMardiaPareto1_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability densities <code class="reqn">f</code> are given as <code class="reqn">log(f)</code>.</p>
</td></tr>
<tr><td><code id="MvtMardiaPareto1_+3A_q">q</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="MvtMardiaPareto1_+3A_p">p</code></td>
<td>
<p>a scalar value corresponding to probability.</p>
</td></tr>
<tr><td><code id="MvtMardiaPareto1_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval to be searched. Default value is set as <code>c(max(1 / parm2) + 1e-8, 1e8)</code> according to <code class="reqn">x_i &gt; 1 / \theta_i, \theta_i&gt;0, i=1,\cdots, k</code>.</p>
</td></tr>
<tr><td><code id="MvtMardiaPareto1_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="MvtMardiaPareto1_+3A_k">k</code></td>
<td>
<p>dimension of data or number of variates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate Pareto type I distribution was introduced by Mardia (1962) as a joint probability distribution of several nonnegative random variables <code class="reqn">X_1, \cdots, X_k</code>. Its probability density function is given by
</p>
<p style="text-align: center;"><code class="reqn">f(x_1, \cdots, x_k) = \frac{[ \prod_{i=1}^{k} \theta_i] a(a+1) \cdots (a+k-1)}{(\sum_{i=1}^{k} \theta_i x_i - k + 1)^{a+k}},</code>
</p>

<p>where <code class="reqn">x_i &gt; 1 / \theta_i, a &gt;0, \theta_i&gt;0, i=1,\cdots, k</code>.
</p>
<p>Cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> is obtained by the following formula related to survival function <code class="reqn">\bar{F}(x_1, \dots, x_k)</code> (Joe, 1997)
</p>
<p style="text-align: center;"><code class="reqn">F(x_1, \dots, x_k) = 1 + \sum_{S \in \mathcal{S}} (-1)^{|S|} \bar{F}_S(x_j, j \in S),</code>
</p>

<p>where the survival function is given by
</p>
<p style="text-align: center;"><code class="reqn">\bar{F}(x_1, \cdots, x_k) = \left( \sum_{i=1}^{k} \theta_i x_i - k + 1 \right)^{-a}.</code>
</p>

<p>Equicoordinate quantile is obtained by solving the following equation for <code class="reqn">q</code> through the built-in one dimension root finding function <code><a href="stats.html#topic+uniroot">uniroot</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">\int_{0}^{q} \cdots \int_{0}^{q} f(x_1, \cdots, x_k) dx_k \cdots dx_1 = p,</code>
</p>

<p>where <code class="reqn">p</code> is the given cumulative probability.
</p>
<p>Random numbers <code class="reqn">X_1, \cdots, X_k</code> from Mardia's multivariate Pareto type I distribution can be generated through linear transformation of multivariate Lomax random variables <code class="reqn">Y_1, \cdots, Y_k</code> by letting <code class="reqn">X_i = Y_i + 1/\theta_i, i = 1, \cdots, k</code>; see Nayak (1987).
</p>


<h3>Value</h3>

<p><code>dmvmpareto1</code> gives the numerical values of the probability density.
</p>
<p><code>pmvmpareto1</code> gives the cumulative probability.
</p>
<p><code>qmvmpareto1</code> gives the equicoordinate quantile.
</p>
<p><code>rmvmpareto1</code> generates random numbers.
</p>
<p><code>smvmpareto1</code> gives the value of survival function.
</p>


<h3>References</h3>

<p>Joe, H. (1997). <em>Multivariate Models and Dependence Concepts</em>. London: Chapman &amp; Hall.
</p>
<p>Mardia, K. V. (1962). Multivariate Pareto distributions. <em>Ann. Math. Statist.</em> 33, 1008-1015.
</p>
<p>Nayak, T. K. (1987). Multivariate Lomax Distribution: Properties and Usefulness in Reliability Theory. <em>Journal of Applied Probability</em>, Vol. 24, No. 1, 170-177.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> for one dimensional root (zero) finding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculations for the Mardia's multivariate Pareto Type I with parameters:
# a = 5, theta1 = 1, theta2 = 2, theta3 = 3
# Vector of quantiles: c(2, 1, 1)

dmvmpareto1(x = c(2, 1, 1), parm1 = 5, parm2 = c(1, 2, 3)) # Density

pmvmpareto1(q = c(2, 1, 1), parm1 = 5, parm2 = c(1, 2, 3)) # Cumulative Probability

# Equicoordinate quantile of cumulative probability 0.5
qmvmpareto1(p = 0.5, parm1 = 5, parm2 =  c(1, 2, 3))

# Random numbers generation with sample size 100
rmvmpareto1(n = 100, parm1 = 5, parm2 = c(1, 2, 3)) 

smvmpareto1(q = c(2, 1, 1), parm1 = 5, parm2 = c(1, 2, 3)) # Survival function

</code></pre>

<hr>
<h2 id='MvtUniform'>Cook-Johnson's Multivariate Uniform Distribution</h2><span id='topic+MvtUniform'></span><span id='topic+dmvunif'></span><span id='topic+pmvunif'></span><span id='topic+qmvunif'></span><span id='topic+rmvunif'></span><span id='topic+smvunif'></span>

<h3>Description</h3>

<p>Calculation of density function, cumulative distribution function, equicoordinate quantile function and survival function, and random numbers generation for Cook-Johnson’s multivariate uniform distribution with a scalar parameter <code>parm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvunif(x, parm = 1, log = FALSE)

pmvunif(q, parm = 1)

qmvunif(p, parm = 1, dim = k, interval = c(0, 1))

rmvunif(n, parm = 1, dim = 1)

smvunif(q, parm = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MvtUniform_+3A_x">x</code></td>
<td>
<p>vector or matrix of quantiles. If <code class="reqn">x</code> is a matrix, each row vector constitutes a vector of quantiles for which the density <code class="reqn">f(x)</code> is calculated (for <code class="reqn">i</code>-th row <code class="reqn">x_i</code>, <code class="reqn">f(x_i)</code> is reported).</p>
</td></tr>
<tr><td><code id="MvtUniform_+3A_parm">parm</code></td>
<td>
<p>a scalar parameter, see parameter <code class="reqn">a</code> in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="MvtUniform_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability densities <code class="reqn">f</code> are given as <code class="reqn">log(f)</code>.</p>
</td></tr>
<tr><td><code id="MvtUniform_+3A_q">q</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="MvtUniform_+3A_p">p</code></td>
<td>
<p>a scalar value corresponding to probability.</p>
</td></tr>
<tr><td><code id="MvtUniform_+3A_dim">dim</code></td>
<td>
<p>dimension of data or number of variates (k).</p>
</td></tr>
<tr><td><code id="MvtUniform_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval to be searched. Default value is set as <code>c(0, 1)</code>.</p>
</td></tr>
<tr><td><code id="MvtUniform_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate uniform distribution of Cook and Johnson (1981) is a joint distribution of uniform variables over <code class="reqn">(0,1]</code> and its probability density is given as
</p>
<p style="text-align: center;"><code class="reqn">f(x_1, \cdots, x_k) = \frac{\Gamma(a+k)}{\Gamma(a)a^k}\prod_{i=1}^{k} x_i^{(-1/a)-1} \left[\sum_{i=1}^{k} x_i^{-1/a} - k +1 \right]^{-(a+k)},</code>
</p>

<p>where <code class="reqn">0 &lt; x_i &lt;=1, a&gt;0, i=1,\cdots, k</code>. In fact, Cook-Johnson's uniform distribution is also called Clayton copula (Nelsen, 2006).
</p>
<p>Cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> is given as
</p>
<p style="text-align: center;"><code class="reqn">F(x_1, \cdots, x_k) = \left[ \sum_{i=1}^{k} x_i^{-1/a} - k + 1 \right]^{-a}.</code>
</p>

<p>Equicoordinate quantile is obtained by solving the following equation for <code class="reqn">q</code> through the built-in one dimension root finding function <code><a href="stats.html#topic+uniroot">uniroot</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">\int_{0}^{q} \cdots \int_{0}^{q} f(x_1, \cdots, x_k) dx_k \cdots dx_1 = p,</code>
</p>

<p>where <code class="reqn">p</code> is the given cumulative probability.
</p>
<p>The survival function <code class="reqn">\bar{F}(x_1, \cdots, x_k)</code> is obtained by the following formula related to cumulative distribution function <code class="reqn">F(x_1, \dots, x_k)</code> (Joe, 1997)
</p>
<p style="text-align: center;"><code class="reqn">\bar{F}(x_1, \cdots, x_k) = 1 + \sum_{S \in \mathcal{S}} (-1)^{|S|} F_S(x_j, j \in S).</code>
</p>

<p>Random numbers <code class="reqn">X_1, \cdots, X_k</code> from Cook-Johnson’s multivariate uniform distribution can be generated through transformation of multivariate Lomax random variables <code class="reqn">Y_1, \cdots, Y_k</code> by letting <code class="reqn">X_i = (1+\theta_i Y_i)^{-a}, i = 1, \cdots, k</code>; see Nayak (1987).
</p>


<h3>Value</h3>

<p><code>dmvunif</code> gives the numerical values of the probability density.
</p>
<p><code>pmvunif</code> gives the cumulative probability.
</p>
<p><code>qmvunif</code> gives the equicoordinate quantile.
</p>
<p><code>rmvunif</code> generates random numbers.
</p>
<p><code>smvunif</code> gives the value of survival function.
</p>


<h3>References</h3>

<p>Cook, R. E. and Johnson, M. E. (1981). A family of distributions for modeling non-elliptically symmetric multivariate data. <em>J.R. Statist. Soc</em>. B 43, No. 2, 210-218.
</p>
<p>Joe, H. (1997). <em>Multivariate Models and Dependence Concepts</em>. London: Chapman &amp; Hall.
</p>
<p>Nayak, T. K. (1987). Multivariate Lomax Distribution: Properties and Usefulness in Reliability Theory. <em>Journal of Applied Probability</em>, Vol. 24, No. 1, 170-177.
</p>
<p>Nelsen, R. B. (2006). <em>An Introduction to Copulas, Second Edition</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> for one dimensional root (zero) finding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculations for the Cook-Johnson's multivariate uniform distribution with parameters:
# a = 2, dim = 3
# Vector of quantiles: c(0.8, 0.5, 0.2)

dmvunif(x = c(0.8, 0.5, 0.2), parm = 2) # Density

pmvunif(q = c(0.8, 0.5, 0.2), parm = 2) # Cumulative Probability

# Equicoordinate quantile of cumulative probability 0.5
qmvunif(p = 0.5, parm = 2, dim = 3)

# Random numbers generation with sample size 100
rmvunif(n = 100, parm = 2, dim = 3)

smvunif(q = c(0.8, 0.5, 0.2), parm = 3) # Survival function

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
