<!DOCTYPE html><html><head><title>Help for package rvinecopulib</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rvinecopulib}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_rvine_structure'><p>Coerce various kind of objects to R-vine structures and matrices</p></a></li>
<li><a href='#bicop'><p>Fit and select bivariate copula models</p></a></li>
<li><a href='#bicop_dist'><p>Bivariate copula models</p></a></li>
<li><a href='#bicop_distributions'><p>Bivariate copula distributions</p></a></li>
<li><a href='#bicop_predict_and_fitted'><p>Predictions and fitted values for a bivariate copula model</p></a></li>
<li><a href='#emp_cdf'><p>Corrected Empirical CDF</p></a></li>
<li><a href='#getters'><p>Extracts components of <code>bicop_dist</code> and <code>vinecop_dist</code> objects</p></a></li>
<li><a href='#mBICV'><p>Modified vine copula Bayesian information criterion (mBICv)</p></a></li>
<li><a href='#pairs_copula_data'><p>Exploratory pairs plot for copula data</p></a></li>
<li><a href='#par_to_ktau'><p>Conversion between Kendall's tau and parameters</p></a></li>
<li><a href='#plot.bicop_dist'><p>Plotting tools for <code>bicop_dist</code> and <code>bicop</code> objects</p></a></li>
<li><a href='#plot.rvine_structure'><p>Plotting R-vine structures</p></a></li>
<li><a href='#plot.vinecop_dist'><p>Plotting <code>vinecop_dist</code> and <code>vinecop</code> objects.</p></a></li>
<li><a href='#pseudo_obs'><p>Pseudo-Observations</p></a></li>
<li><a href='#rosenblatt'><p>(Inverse) Rosenblatt transform</p></a></li>
<li><a href='#rvine_structure'><p>R-vine structure</p></a></li>
<li><a href='#rvine_structure_sim'><p>Simulate R-vine structures</p></a></li>
<li><a href='#rvinecopulib'><p>High Performance Algorithms for Vine Copula Modeling</p></a></li>
<li><a href='#truncate_model'><p>Truncate a vine copula model</p></a></li>
<li><a href='#vine'><p>Vine copula models</p></a></li>
<li><a href='#vine_distributions'><p>Vine based distributions</p></a></li>
<li><a href='#vine_predict_and_fitted'><p>Predictions and fitted values for a vine copula model</p></a></li>
<li><a href='#vinecop'><p>Fitting vine copula models</p></a></li>
<li><a href='#vinecop_dist'><p>Vine copula models</p></a></li>
<li><a href='#vinecop_distributions'><p>Vine copula distributions</p></a></li>
<li><a href='#vinecop_predict_and_fitted'><p>Predictions and fitted values for a vine copula model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High Performance Algorithms for Vine Copula Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.3.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an interface to 'vinecopulib', a C++ library for vine 
 copula modeling. The 'rvinecopulib' package implements the core features of the
 popular 'VineCopula' package, in particular inference algorithms for both vine 
 copula and bivariate copula models. Advantages over 'VineCopula' are a sleeker 
 and more modern API, improved performances, especially in high dimensions, 
 nonparametric and multi-parameter families, and the ability to model discrete 
 variables. The 'rvinecopulib' package includes 'vinecopulib' as header-only 
 C++ library (currently version 0.6.2). Thus users do not need to install 
 'vinecopulib' itself in order to use 'rvinecopulib'. Since their initial 
 releases, 'vinecopulib' is licensed under the MIT License, and 'rvinecopulib' 
 is licensed under the GNU GPL version 3.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, graphics, grDevices, kde1d (&ge; 1.0.2), lattice,
Rcpp (&ge; 0.12.12), stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, ggplot2, ggraph, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, Rcpp, RcppEigen, RcppThread (&ge; 2.1.2), wdm, kde1d</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vinecopulib/rvinecopulib/issues">https://github.com/vinecopulib/rvinecopulib/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-21 12:50:11 UTC; n5</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Nagler [aut, cre],
  Thibault Vatter [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Nagler &lt;info@vinecopulib.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-23 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_rvine_structure'>Coerce various kind of objects to R-vine structures and matrices</h2><span id='topic+as_rvine_structure'></span><span id='topic+as_rvine_matrix'></span><span id='topic+as_rvine_structure.rvine_structure'></span><span id='topic+as_rvine_matrix.rvine_structure'></span><span id='topic+as_rvine_structure.list'></span><span id='topic+as_rvine_matrix.list'></span><span id='topic+as_rvine_structure.rvine_matrix'></span><span id='topic+as_rvine_matrix.rvine_matrix'></span><span id='topic+as_rvine_structure.matrix'></span><span id='topic+as_rvine_matrix.matrix'></span>

<h3>Description</h3>

<p><code>as_rvine_structure</code> and <code>as_rvine_matrix</code> are new S3 generics allowing to
coerce objects into R-vine structures and matrices (see <code><a href="#topic+rvine_structure">rvine_structure()</a></code>
and <code><a href="#topic+rvine_matrix">rvine_matrix()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_rvine_structure(x, ...)

as_rvine_matrix(x, ...)

## S3 method for class 'rvine_structure'
as_rvine_structure(x, ..., validate = FALSE)

## S3 method for class 'rvine_structure'
as_rvine_matrix(x, ..., validate = FALSE)

## S3 method for class 'list'
as_rvine_structure(x, ..., is_natural_order = FALSE)

## S3 method for class 'list'
as_rvine_matrix(x, ..., is_natural_order = FALSE)

## S3 method for class 'rvine_matrix'
as_rvine_structure(x, ..., validate = FALSE)

## S3 method for class 'rvine_matrix'
as_rvine_matrix(x, ..., validate = FALSE)

## S3 method for class 'matrix'
as_rvine_structure(x, ..., validate = TRUE)

## S3 method for class 'matrix'
as_rvine_matrix(x, ..., validate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_rvine_structure_+3A_x">x</code></td>
<td>
<p>An object of class <code>rvine_structure</code>, <code>rvine_matrix</code>, <code>matrix</code> or
<code>list</code> that can be coerced into an R-vine structure or R-vine matrix
(see <em>Details</em>).</p>
</td></tr>
<tr><td><code id="as_rvine_structure_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to individual methods.</p>
</td></tr>
<tr><td><code id="as_rvine_structure_+3A_validate">validate</code></td>
<td>
<p>When 'TRUE&ldquo;, verifies that the input is a valid
rvine-structure (see <em>Details</em>). You may want to suppress this when you
know that you already have a valid structure and you want to save some time,
or to explicitly enable it if you have a structure that you want to re-check.</p>
</td></tr>
<tr><td><code id="as_rvine_structure_+3A_is_natural_order">is_natural_order</code></td>
<td>
<p>A flag indicating whether the <code>struct_array</code> element
of <code>x</code> is assumed to be provided in natural order already (a structure is in
natural order if the anti-diagonal is 1, .., d from bottom left to top
right).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coercion to <code>rvine_structure</code> and <code>rvine_matrix</code> can be applied to
different kind of objects Currently, <code>rvine_structure</code>, <code>rvine_matrix</code>,
<code>matrix</code> and <code>list</code> are supported.
</p>
<p>For <code>as_rvine_structure</code>:
</p>

<ul>
<li> <p><code>rvine_structure</code> : the main use case is to re-check an object via
<code>validate = TRUE</code>.
</p>
</li>
<li> <p><code>rvine_matrix</code> and <code>matrix</code> : allow to coerce matrices into R-vine
structures (see <code><a href="#topic+rvine_structure">rvine_structure()</a></code> for more details). The main difference
between <code>rvine_matrix</code> and <code>matrix</code> is the nature of the validity
checks.
</p>
</li>
<li> <p><code>list</code> : must contain named elements <code>order</code> and <code>struct_array</code> to be
coerced into an R-vine structure (see <code><a href="#topic+rvine_structure">rvine_structure()</a></code> for more details).
</p>
</li></ul>

<p>For <code>as_rvine_matrix</code>:
</p>

<ul>
<li> <p><code>rvine_structure</code> : allow to coerce an <code>rvine_structure</code> into an
R-vine matrix (useful e.g. for printing).
</p>
</li>
<li> <p><code>rvine_matrix</code>: similar to <code>as_rvine_structure</code> for <code>rvine_structure</code>,
the main use case is to re-check an object via <code>validate = TRUE</code>.
</p>
</li>
<li> <p><code>matrix</code> : allow to coerce matrices into R-vine
matrices (mainly by checking that the matrix defines a valid
R-vine, see <code><a href="#topic+rvine_matrix">rvine_matrix()</a></code> for more details).
</p>
</li>
<li> <p><code>list</code> : must contain named elements <code>order</code> and <code>struct_array</code> to be
coerced into an R-vine matrix (see <code><a href="#topic+rvine_structure">rvine_structure()</a></code> for more details).
</p>
</li></ul>



<h3>Value</h3>

<p>Either an object of class <code>rvine_structure</code> or of class
<code>rvine_matrix</code> (see <code><a href="#topic+rvine_structure">rvine_structure()</a></code> or <code><a href="#topic+rvine_matrix">rvine_matrix()</a></code>).
</p>


<h3>See Also</h3>

<p>rvine_structure rvine_matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># R-vine structures can be constructed from the order vector and struct_array
rvine_structure(order = 1:4, struct_array = list(
  c(4, 4, 4),
  c(3, 3),
  2
))

# ... or a similar list can be coerced into an R-vine structure
as_rvine_structure(list(order = 1:4, struct_array = list(
  c(4, 4, 4),
  c(3, 3),
  2
)))

# similarly, standard matrices can be coerced into R-vine structures
mat &lt;- matrix(c(4, 3, 2, 1, 4, 3, 2, 0, 4, 3, 0, 0, 4, 0, 0, 0), 4, 4)
as_rvine_structure(mat)

# or truncate and construct the structure
mat[3, 1] &lt;- 0
as_rvine_structure(mat)

# throws an error
mat[3, 1] &lt;- 5
try(as_rvine_structure(mat))
</code></pre>

<hr>
<h2 id='bicop'>Fit and select bivariate copula models</h2><span id='topic+bicop'></span>

<h3>Description</h3>

<p>Fit a bivariate copula model for continuous or discrete data. The family
can be selected automatically from a vector of options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicop(
  data,
  var_types = c("c", "c"),
  family_set = "all",
  par_method = "mle",
  nonpar_method = "quadratic",
  mult = 1,
  selcrit = "aic",
  weights = numeric(),
  psi0 = 0.9,
  presel = TRUE,
  keep_data = FALSE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bicop_+3A_data">data</code></td>
<td>
<p>a matrix or data.frame with at least two columns, containing the
(pseudo-)observations for the two variables (copula data should have
approximately uniform margins). More columns are required for discrete
models, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="bicop_+3A_var_types">var_types</code></td>
<td>
<p>variable types, a length 2 vector; e.g., <code>c("c", "c")</code> for
both continuous (default), or <code>c("c", "d")</code> for first variable continuous
and second discrete.</p>
</td></tr>
<tr><td><code id="bicop_+3A_family_set">family_set</code></td>
<td>
<p>a character vector of families; see <em>Details</em> for
additional options.</p>
</td></tr>
<tr><td><code id="bicop_+3A_par_method">par_method</code></td>
<td>
<p>the estimation method for parametric models, either <code>"mle"</code>
for maximum likelihood or <code>"itau"</code> for inversion of Kendall's tau (only
available for one-parameter families and <code>"t"</code>.</p>
</td></tr>
<tr><td><code id="bicop_+3A_nonpar_method">nonpar_method</code></td>
<td>
<p>the estimation method for nonparametric models, either
<code>"constant"</code> for the standard transformation estimator, or
<code>"linear"</code>/<code>"quadratic"</code> for the local-likelihood approximations of order
one/two.</p>
</td></tr>
<tr><td><code id="bicop_+3A_mult">mult</code></td>
<td>
<p>multiplier for the smoothing parameters of nonparametric
families. Values larger than 1 make the estimate more smooth, values less
than 1 less smooth.</p>
</td></tr>
<tr><td><code id="bicop_+3A_selcrit">selcrit</code></td>
<td>
<p>criterion for family selection, either <code>"loglik"</code>, <code>"aic"</code>,
<code>"bic"</code>, <code>"mbic"</code>. For <code>vinecop()</code> there is the additional option
<code>"mbicv"</code>.</p>
</td></tr>
<tr><td><code id="bicop_+3A_weights">weights</code></td>
<td>
<p>optional vector of weights for each observation.</p>
</td></tr>
<tr><td><code id="bicop_+3A_psi0">psi0</code></td>
<td>
<p>see <code><a href="#topic+mBICV">mBICV()</a></code>.</p>
</td></tr>
<tr><td><code id="bicop_+3A_presel">presel</code></td>
<td>
<p>whether the family set should be thinned out according to
symmetry characteristics of the data.</p>
</td></tr>
<tr><td><code id="bicop_+3A_keep_data">keep_data</code></td>
<td>
<p>whether the data should be stored (necessary for using
<code><a href="stats.html#topic+fitted">fitted()</a></code>).</p>
</td></tr>
<tr><td><code id="bicop_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if more than 1, estimation for multiple
families is done in parallel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are missing data (i.e., <code>NA</code> entries), incomplete observations are
discarded before fitting the copula.
</p>


<h4>Discrete variables</h4>

<p>When at least one variable is discrete, more than two columns are required
for <code>data</code>: the first <code class="reqn">n \times 2</code> block contains realizations of
<code class="reqn">F_{X_1}(x_1), F_{X_2}(x_2)</code>. The second <code class="reqn">n \times 2</code> block contains
realizations of <code class="reqn">F_{X_1}(x_1^-), F_{X_1}(x_1^-)</code>. The minus indicates a
left-sided limit of the cdf. For, e.g., an integer-valued variable, it holds
<code class="reqn">F_{X_1}(x_1^-) = F_{X_1}(x_1 - 1)</code>. For continuous variables the left
limit and the cdf itself coincide. Respective columns can be omitted in the
second block.
</p>



<h4>Family collections</h4>

<p>The <code>family_set</code> argument accepts all families in <code>bicop_dist()</code> plus the
following convenience definitions:
</p>

<ul>
<li> <p><code>"all"</code> contains all the families,
</p>
</li>
<li> <p><code>"parametric"</code> contains the parametric families (all except <code>"tll"</code>),
</p>
</li>
<li> <p><code>"nonparametric"</code> contains the nonparametric families (<code>"indep"</code> and
<code>"tll"</code>)
</p>
</li>
<li> <p><code>"onepar"</code> contains the parametric families with a single parameter,
</p>
</li></ul>

<p>(<code>"gaussian"</code>, <code>"clayton"</code>, <code>"gumbel"</code>, <code>"frank"</code>, and <code>"joe"</code>),
</p>

<ul>
<li> <p><code>"twopar"</code> contains the parametric families with two parameters
(<code>"t"</code>, <code>"bb1"</code>, <code>"bb6"</code>, <code>"bb7"</code>, and <code>"bb8"</code>),
</p>
</li>
<li> <p><code>"elliptical"</code> contains the elliptical families,
</p>
</li>
<li> <p><code>"archimedean"</code> contains the archimedean families,
</p>
</li>
<li> <p><code>"BB"</code> contains the BB families,
</p>
</li>
<li> <p><code>"itau"</code> families for which estimation by Kendall's tau inversion is
available (<code>"indep"</code>,<code>"gaussian"</code>, <code>"t"</code>,<code>"clayton"</code>, <code>"gumbel"</code>,
<code>"frank"</code>, <code>"joe"</code>).
</p>
</li></ul>




<h3>Value</h3>

<p>An object inheriting from classes <code>bicop</code> and  <code>bicop_dist</code> . In addition to
the entries contained in <code>bicop_dist()</code>, objects from the <code>bicop</code> class
contain:
</p>

<ul>
<li> <p><code>data</code> (optionally, if <code>keep_data = TRUE</code> was used), the dataset that was
passed to <code><a href="#topic+bicop">bicop()</a></code>.
</p>
</li>
<li> <p><code>controls</code>, a <code>list</code> with the set of fit controls that was passed to
<code><a href="#topic+bicop">bicop()</a></code>.
</p>
</li>
<li> <p><code>loglik</code> the log-likelihood.
</p>
</li>
<li> <p><code>nobs</code>, an <code>integer</code> with the number of observations that was used to fit
the model.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bicop_dist">bicop_dist()</a></code>, <code><a href="#topic+plot.bicop">plot.bicop()</a></code>, <code><a href="#topic+contour.bicop">contour.bicop()</a></code>, <code><a href="#topic+dbicop">dbicop()</a></code>,
<code><a href="#topic+pbicop">pbicop()</a></code>, <code><a href="#topic+hbicop">hbicop()</a></code>, <code><a href="#topic+rbicop">rbicop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## fitting a continuous model from simulated data
u &lt;- rbicop(100, "clayton", 90, 3)
fit &lt;- bicop(u, family_set = "par")
summary(fit)

## compare fit with true model
contour(fit)
contour(bicop_dist("clayton", 90, 3), col = 2, add = TRUE)

## fit a model from discrete data
x_disc &lt;- qpois(u, 1)  # transform to Poisson margins
plot(x_disc)
udisc &lt;- cbind(ppois(x_disc, 1), ppois(x_disc - 1, 1))
fit_disc &lt;- bicop(udisc, var_types = c("d", "d"))
summary(fit_disc)
</code></pre>

<hr>
<h2 id='bicop_dist'>Bivariate copula models</h2><span id='topic+bicop_dist'></span>

<h3>Description</h3>

<p>Create custom bivariate copula models by specifying the family, rotation,
parameters, and variable types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicop_dist(
  family = "indep",
  rotation = 0,
  parameters = numeric(0),
  var_types = c("c", "c")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bicop_dist_+3A_family">family</code></td>
<td>
<p>the copula family, a string containing the family name (see
<em>Details</em> for all possible families).</p>
</td></tr>
<tr><td><code id="bicop_dist_+3A_rotation">rotation</code></td>
<td>
<p>the rotation of the copula, one of <code>0</code>, <code>90</code>, <code>180</code>, <code>270</code>.</p>
</td></tr>
<tr><td><code id="bicop_dist_+3A_parameters">parameters</code></td>
<td>
<p>a vector or matrix of copula parameters.</p>
</td></tr>
<tr><td><code id="bicop_dist_+3A_var_types">var_types</code></td>
<td>
<p>variable types, a length 2 vector; e.g., <code>c("c", "c")</code> for
both continuous (default), or <code>c("c", "d")</code> for first variable continuous
and second discrete.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Implemented families</h4>


<table>
<tr>
 <td style="text-align: left;">
   type </td><td style="text-align: left;"> name </td><td style="text-align: left;"> name in R </td>
</tr>
<tr>
 <td style="text-align: left;">
   - </td><td style="text-align: left;"> Independence </td><td style="text-align: left;"> "indep" </td>
</tr>
<tr>
 <td style="text-align: left;">
   Elliptical </td><td style="text-align: left;"> Gaussian </td><td style="text-align: left;"> "gaussian" </td>
</tr>
<tr>
 <td style="text-align: left;">
   " </td><td style="text-align: left;"> Student t </td><td style="text-align: left;"> "student" </td>
</tr>
<tr>
 <td style="text-align: left;">
   Archimedean </td><td style="text-align: left;"> Clayton </td><td style="text-align: left;"> "clayton" </td>
</tr>
<tr>
 <td style="text-align: left;">
   " </td><td style="text-align: left;"> Gumbel </td><td style="text-align: left;"> "gumbel" </td>
</tr>
<tr>
 <td style="text-align: left;">
   " </td><td style="text-align: left;"> Frank </td><td style="text-align: left;"> "frank" </td>
</tr>
<tr>
 <td style="text-align: left;">
   " </td><td style="text-align: left;"> Joe </td><td style="text-align: left;"> "joe" </td>
</tr>
<tr>
 <td style="text-align: left;">
   " </td><td style="text-align: left;"> Clayton-Gumbel (BB1) </td><td style="text-align: left;"> "bb1" </td>
</tr>
<tr>
 <td style="text-align: left;">
   " </td><td style="text-align: left;"> Joe-Gumbel (BB6) </td><td style="text-align: left;"> "bb6" </td>
</tr>
<tr>
 <td style="text-align: left;">
   " </td><td style="text-align: left;"> Joe-Clayton (BB7) </td><td style="text-align: left;"> "bb7" </td>
</tr>
<tr>
 <td style="text-align: left;">
   " </td><td style="text-align: left;"> Joe-Frank (BB8) </td><td style="text-align: left;"> "bb8" </td>
</tr>
<tr>
 <td style="text-align: left;">
   Nonparametric </td><td style="text-align: left;"> Transformation kernel </td><td style="text-align: left;"> "tll" </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h3>Value</h3>

<p>An object of class <code>bicop_dist</code>, i.e., a list containing:
</p>

<ul>
<li> <p><code>family</code>, a <code>character</code> indicating the copula family.
</p>
</li>
<li> <p><code>rotation</code>, an <code>integer</code> indicating the rotation (i.e., either 0, 90, 180,
or 270).
</p>
</li>
<li> <p><code>parameters</code>, a <code>numeric</code> vector or matrix of parameters.
</p>
</li>
<li> <p><code>npars</code>, a <code>numeric</code> with the (effective) number of parameters.
</p>
</li>
<li> <p><code>var_types</code>, the variable types.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bicop_dist">bicop_dist()</a></code>, <code><a href="#topic+plot.bicop">plot.bicop()</a></code>, <code><a href="#topic+contour.bicop">contour.bicop()</a></code>, <code><a href="#topic+dbicop">dbicop()</a></code>,
<code><a href="#topic+pbicop">pbicop()</a></code>, <code><a href="#topic+hbicop">hbicop()</a></code>, <code><a href="#topic+rbicop">rbicop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Clayton 90Â° copula with parameter 3
cop &lt;- bicop_dist("clayton", 90, 3)
cop
str(cop)

## visualization
plot(cop)
contour(cop)
plot(rbicop(200, cop))

## BB8 copula model for discrete data
cop_disc &lt;- bicop_dist("bb8", 0, c(2, 0.5), var_types = c("d", "d"))
cop_disc

</code></pre>

<hr>
<h2 id='bicop_distributions'>Bivariate copula distributions</h2><span id='topic+bicop_distributions'></span><span id='topic+dbicop'></span><span id='topic+pbicop'></span><span id='topic+rbicop'></span><span id='topic+hbicop'></span><span id='topic+dbicop_dist'></span><span id='topic+pbicop_dist'></span><span id='topic+rbicop_dist'></span><span id='topic+hbicop_dist'></span>

<h3>Description</h3>

<p>Density, distribution function, random generation and h-functions (with their
inverses) for the bivariate copula distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbicop(u, family, rotation, parameters, var_types = c("c", "c"))

pbicop(u, family, rotation, parameters, var_types = c("c", "c"))

rbicop(n, family, rotation, parameters, qrng = FALSE)

hbicop(
  u,
  cond_var,
  family,
  rotation,
  parameters,
  inverse = FALSE,
  var_types = c("c", "c")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bicop_distributions_+3A_u">u</code></td>
<td>
<p>evaluation points, a matrix with at least two columns, see
<em>Details</em>.</p>
</td></tr>
<tr><td><code id="bicop_distributions_+3A_family">family</code></td>
<td>
<p>the copula family, a string containing the family name (see
<code><a href="#topic+bicop">bicop</a></code> for all possible families).</p>
</td></tr>
<tr><td><code id="bicop_distributions_+3A_rotation">rotation</code></td>
<td>
<p>the rotation of the copula, one of <code>0</code>, <code>90</code>, <code>180</code>, <code>270</code>.</p>
</td></tr>
<tr><td><code id="bicop_distributions_+3A_parameters">parameters</code></td>
<td>
<p>a vector or matrix of copula parameters.</p>
</td></tr>
<tr><td><code id="bicop_distributions_+3A_var_types">var_types</code></td>
<td>
<p>variable types, a length 2 vector; e.g., <code>c("c", "c")</code> for
both continuous (default), or <code>c("c", "d")</code> for first variable continuous
and second discrete.</p>
</td></tr>
<tr><td><code id="bicop_distributions_+3A_n">n</code></td>
<td>
<p>number of observations. If 'length(n) &gt; 1&ldquo;, the length is taken to
be the number required.</p>
</td></tr>
<tr><td><code id="bicop_distributions_+3A_qrng">qrng</code></td>
<td>
<p>if <code>TRUE</code>, generates quasi-random numbers using the bivariate
Generalized Halton sequence (default <code>qrng = FALSE</code>).</p>
</td></tr>
<tr><td><code id="bicop_distributions_+3A_cond_var">cond_var</code></td>
<td>
<p>either <code>1</code> or <code>2</code>; <code>cond_var = 1</code> conditions on the first
variable, <code>cond_var = 2</code> on the second.</p>
</td></tr>
<tr><td><code id="bicop_distributions_+3A_inverse">inverse</code></td>
<td>
<p>whether to compute the h-function or its inverse.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+bicop">bicop</a> for the various implemented copula families.
</p>
<p>The copula density is defined as joint density divided by marginal
densities, irrespective of variable types.
</p>
<p>H-functions (<code>hbicop()</code>) are conditional distributions derived
from a copula. If <code class="reqn">C(u, v) = P(U \le u, V \le v)</code> is a copula, then
</p>
<p style="text-align: center;"><code class="reqn">h_1(u, v) = P(V \le v | U = u) = \partial C(u, v) / \partial u,</code>
</p>

<p style="text-align: center;"><code class="reqn">h_2(u, v) = P(U \le u | V = v) = \partial C(u, v) / \partial v.</code>
</p>

<p>In other words, the H-function number refers to the conditioning variable.
When inverting H-functions, the inverse is then taken with respect to the
other variable, that is <code>v</code> when <code>cond_var = 1</code> and <code>u</code> when <code>cond_var = 2</code>.
</p>


<h4>Discrete variables</h4>

<p>When at least one variable is discrete, more than two columns are required
for <code>u</code>: the first <code class="reqn">n \times 2</code> block contains realizations of
<code class="reqn">F_{X_1}(x_1), F_{X_2}(x_2)</code>. The second <code class="reqn">n \times 2</code> block contains
realizations of <code class="reqn">F_{X_1}(x_1^-), F_{X_1}(x_1^-)</code>. The minus indicates a
left-sided limit of the cdf. For, e.g., an integer-valued variable, it holds
<code class="reqn">F_{X_1}(x_1^-) = F_{X_1}(x_1 - 1)</code>. For continuous variables the left
limit and the cdf itself coincide. Respective columns can be omitted in the
second block.
</p>



<h3>Value</h3>

<p><code>dbicop()</code> gives the density, <code>pbicop()</code> gives the distribution function,
<code>rbicop()</code> generates random deviates, and <code>hbicop()</code> gives the h-functions
(and their inverses).
</p>
<p>The length of the result is determined by <code>n</code> for <code>rbicop()</code>, and
the number of rows in <code>u</code> for the other functions.
</p>
<p>The numerical arguments other than <code>n</code> are recycled to the length of the
result.
</p>


<h3>Note</h3>

<p>The functions can optionally be used with a <a href="#topic+bicop_dist">bicop_dist</a> object, e.g.,
<code>dbicop(c(0.1, 0.5), bicop_dist("indep"))</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bicop_dist">bicop_dist()</a></code>, <code><a href="#topic+bicop">bicop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## evaluate the copula density
dbicop(c(0.1, 0.2), "clay", 90, 3)
dbicop(c(0.1, 0.2), bicop_dist("clay", 90, 3))

## evaluate the copula cdf
pbicop(c(0.1, 0.2), "clay", 90, 3)

## simulate data
plot(rbicop(500, "clay", 90, 3))

## h-functions
joe_cop &lt;- bicop_dist("joe", 0, 3)
# h_1(0.1, 0.2)
hbicop(c(0.1, 0.2), 1, "bb8", 0, c(2, 0.5))
# h_2^{-1}(0.1, 0.2)
hbicop(c(0.1, 0.2), 2, joe_cop, inverse = TRUE)

## mixed discrete and continuous data
x &lt;- cbind(rpois(10, 1), rnorm(10, 1))
u &lt;- cbind(ppois(x[, 1], 1), pnorm(x[, 2]), ppois(x[, 1] - 1, 1))
pbicop(u, "clay", 90, 3, var_types = c("d", "c"))

</code></pre>

<hr>
<h2 id='bicop_predict_and_fitted'>Predictions and fitted values for a bivariate copula model</h2><span id='topic+bicop_predict_and_fitted'></span><span id='topic+predict.bicop_dist'></span><span id='topic+predict.bicop'></span><span id='topic+fitted.bicop'></span>

<h3>Description</h3>

<p>Predictions of the density, distribution function, h-functions (with their
inverses) for a bivariate copula model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bicop_dist'
predict(object, newdata, what = "pdf", ...)

## S3 method for class 'bicop'
fitted(object, what = "pdf", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bicop_predict_and_fitted_+3A_object">object</code></td>
<td>
<p>a <code>bicop</code> object.</p>
</td></tr>
<tr><td><code id="bicop_predict_and_fitted_+3A_newdata">newdata</code></td>
<td>
<p>points where the fit shall be evaluated.</p>
</td></tr>
<tr><td><code id="bicop_predict_and_fitted_+3A_what">what</code></td>
<td>
<p>what to predict, one of <code>"pdf"</code>, <code>"cdf"</code>, <code>"hfunc1"</code>, <code>"hfunc2"</code>,
<code>"hinv1"</code>, <code>"hinv2"</code>.</p>
</td></tr>
<tr><td><code id="bicop_predict_and_fitted_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitted()</code> can only be called if the model was fit with the
<code>keep_data = TRUE</code> option.
</p>


<h4>Discrete variables</h4>

<p>When at least one variable is discrete, more than two columns are required
for <code>newdata</code>: the first <code class="reqn">n \times 2</code> block contains realizations of
<code class="reqn">F_{X_1}(x_1), F_{X_2}(x_2)</code>. The second <code class="reqn">n \times 2</code> block contains
realizations of <code class="reqn">F_{X_1}(x_1^-), F_{X_1}(x_1^-)</code>. The minus indicates a
left-sided limit of the cdf. For, e.g., an integer-valued variable, it holds
<code class="reqn">F_{X_1}(x_1^-) = F_{X_1}(x_1 - 1)</code>. For continuous variables the left
limit and the cdf itself coincide. Respective columns can be omitted in the
second block.
</p>



<h3>Value</h3>

<p><code>fitted()</code> and <code>logLik()</code> have return values similar to <code><a href="#topic+dbicop">dbicop()</a></code>,
<code><a href="#topic+pbicop">pbicop()</a></code>, and <code><a href="#topic+hbicop">hbicop()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate and fit a bivariate copula model
u &lt;- rbicop(500, "gauss", 0, 0.5)
fit &lt;- bicop(u, family = "par", keep_data = TRUE)

# Predictions
all.equal(predict(fit, u, "hfunc1"), fitted(fit, "hfunc1"),
          check.environment = FALSE)
</code></pre>

<hr>
<h2 id='emp_cdf'>Corrected Empirical CDF</h2><span id='topic+emp_cdf'></span>

<h3>Description</h3>

<p>The empirical CDF with tail correction, ensuring that its output is never
0 or 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emp_cdf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emp_cdf_+3A_x">x</code></td>
<td>
<p>numeric vector of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The corrected empirical CDF is defined as
</p>
<p style="text-align: center;"><code class="reqn">
F_n(x) = \frac{1}{n + 1} \min\biggl\{1, \sum_{i = 1}^n 1(X_i \le x)\biggr\}
</code>
</p>



<h3>Value</h3>

<p>A function with signature <code style="white-space: pre;">&#8288;function(x)&#8288;</code> that returns <code class="reqn">F_n(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit ECDF on simulated data
x &lt;- rnorm(100)
cdf &lt;- emp_cdf(x)

# output is bounded away from 0 and 1
cdf(-50)
cdf(50)
</code></pre>

<hr>
<h2 id='getters'>Extracts components of <code>bicop_dist</code> and <code>vinecop_dist</code> objects</h2><span id='topic+getters'></span><span id='topic+get_structure'></span><span id='topic+get_pair_copula'></span><span id='topic+get_all_pair_copulas'></span><span id='topic+get_parameters'></span><span id='topic+get_all_parameters'></span><span id='topic+get_ktau'></span><span id='topic+get_all_ktaus'></span><span id='topic+get_matrix'></span><span id='topic+get_family'></span><span id='topic+get_all_families'></span>

<h3>Description</h3>

<p>Extracts either the structure matrix  (for <code>vinecop_dist</code> only), or
pair-copulas, their parameters, Kendall's taus, or families (for <code>bicop_dist</code>
and <code>vinecop_dist</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_structure(object)

get_pair_copula(object, tree = NA, edge = NA)

get_parameters(object, tree = NA, edge = NA)

get_ktau(object, tree = NA, edge = NA)

get_family(object, tree = NA, edge = NA)

get_all_pair_copulas(object, trees = NA)

get_all_parameters(object, trees = NA)

get_all_ktaus(object, trees = NA)

get_all_families(object, trees = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getters_+3A_object">object</code></td>
<td>
<p>a <code>bicop_dist</code>, <code>vinecop_dist</code> or <code>vine_dist</code> object.</p>
</td></tr>
<tr><td><code id="getters_+3A_tree">tree</code></td>
<td>
<p>tree index (not required if <code>object</code> is of class <code>bicop_dist</code>).</p>
</td></tr>
<tr><td><code id="getters_+3A_edge">edge</code></td>
<td>
<p>edge index (not required if <code>object</code> is of class <code>bicop_dist</code>).</p>
</td></tr>
<tr><td><code id="getters_+3A_trees">trees</code></td>
<td>
<p>the trees to extract from <code>object</code> (<code>trees = NA</code> extracts all
trees).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>#' The <a href="#topic+get_structure">get_structure</a> method (for <code>vinecop_dist</code> or <code>vine_dist</code>
objects only) extracts the structure (see <a href="#topic+rvine_structure">rvine_structure</a> for more
details).
</p>
<p>The <a href="#topic+get_matrix">get_matrix</a> method (for <code>vinecop_dist</code> or <code>vine_dist</code> objects only)
extracts the structure matrix (see <a href="#topic+rvine_structure">rvine_structure</a> for more details).
</p>
<p>The other <code>get_xyz</code> methods for <code>vinecop_dist</code> or <code>vine_dist</code> objects return
the entries corresponding to the pair-copula indexed by its <code>tree</code> and
<code>edge</code>. When <code>object</code> is of class <code>bicop_dist</code>, <code>tree</code> and <code>edge</code> are not
required. <br />
</p>

<ul>
<li> <p><code><a href="#topic+get_pair_copula">get_pair_copula()</a></code> = the pair-copula itself (see <a href="#topic+bicop">bicop</a>).
</p>
</li>
<li> <p><code><a href="#topic+get_parameters">get_parameters()</a></code> = the parameters of the pair-copula (i.e., a <code>numeric</code>
scalar, vector, or matrix).
</p>
</li>
<li> <p><code><a href="#topic+get_family">get_family()</a></code> = a character for the family (see <a href="#topic+bicop">bicop</a> for
implemented families).
</p>
</li>
<li> <p><code><a href="#topic+get_ktau">get_ktau()</a></code> = a <code>numeric</code> scalar with the pair-copula Kendall's tau.
</p>
</li></ul>

<p>The <code>get_all_xyz</code> methods (for <code>vinecop_dist</code> or <code>vine_dist</code> objects only)
return lists of lists, with each element corresponding to a tree in <code>trees</code>,
and then elements of the sublists correspond to edges. The returned lists
have two additional attributes:
</p>

<ul>
<li> <p><code>"d"</code> = the dimension of the model.
</p>
</li>
<li> <p><code>"trees"</code> = the extracted trees.
</p>
</li></ul>



<h3>Value</h3>

<p>The structure matrix, or pair-copulas, their parameters, Kendall's taus,
or families.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify pair-copulas
bicop &lt;- bicop_dist("bb1", 90, c(3, 2))
pcs &lt;- list(
  list(bicop, bicop), # pair-copulas in first tree
  list(bicop) # pair-copulas in second tree
)

# specify R-vine matrix
mat &lt;- matrix(c(1, 2, 3, 1, 2, 0, 1, 0, 0), 3, 3)

# set up vine copula model
vc &lt;- vinecop_dist(pcs, mat)

# get the structure
get_structure(vc)
all(get_matrix(vc) == mat)

# get pair-copulas
get_pair_copula(vc, 1, 1)
get_all_pair_copulas(vc)
all.equal(get_all_pair_copulas(vc), pcs,
          check.attributes = FALSE, check.environment = FALSE)
</code></pre>

<hr>
<h2 id='mBICV'>Modified vine copula Bayesian information criterion (mBICv)</h2><span id='topic+mBICV'></span>

<h3>Description</h3>

<p>Calculates the modified vine copula Bayesian information criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mBICV(object, psi0 = 0.9, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mBICV_+3A_object">object</code></td>
<td>
<p>a fitted <code>vinecop</code> object.</p>
</td></tr>
<tr><td><code id="mBICV_+3A_psi0">psi0</code></td>
<td>
<p>baseline prior probability of a non-independence copula.</p>
</td></tr>
<tr><td><code id="mBICV_+3A_newdata">newdata</code></td>
<td>
<p>optional; a new data set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The modified vine copula Bayesian information criterion (mBICv) is defined as
</p>
<p style="text-align: center;"><code class="reqn">BIC = -2 loglik +  \nu log(n) - 2 \sum_{t=1}^{d - 1} (q_t log(\psi_0^t)
- (d - t - q_t) log(1 - \psi_0^t)) </code>
</p>

<p>where <code class="reqn">\mathrm{loglik}</code> is the log-likelihood and <code class="reqn">\nu</code> is the
(effective) number of parameters of the model, <code class="reqn">t</code> is the tree level
<code class="reqn">\psi_0</code> is the prior probability of having a non-independence copula and
<code class="reqn">q_t</code> is the number of non-independence copulas in tree <code class="reqn">t</code>. The
mBICv is a consistent model selection criterion for parametric sparse vine
copula models.
</p>


<h3>References</h3>

<p>Nagler, T., Bumann, C., Czado, C. (2019). Model selection for
sparse high-dimensional vine copulas with application to portfolio risk.
<em>Journal of Multivariate Analysis, in press</em>
(<a href="https://arxiv.org/pdf/1801.09739.pdf">https://arxiv.org/pdf/1801.09739.pdf</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- sapply(1:5, function(i) runif(50))
fit &lt;- vinecop(u, family = "par", keep_data = TRUE)
mBICV(fit, 0.9) # with a 0.9 prior probability of a non-independence copula
mBICV(fit, 0.1) # with a 0.1 prior probability of a non-independence copula
</code></pre>

<hr>
<h2 id='pairs_copula_data'>Exploratory pairs plot for copula data</h2><span id='topic+pairs_copula_data'></span>

<h3>Description</h3>

<p>This function provides pair plots for copula data. It shows
bivariate contour plots on the lower panel, scatter plots and
correlations on the upper panel and histograms on the diagonal panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_copula_data(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs_copula_data_+3A_data">data</code></td>
<td>
<p>the data (must lie in the unit hypercube).</p>
</td></tr>
<tr><td><code id="pairs_copula_data_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>pairs.default()</code>,
<code>contour.bicop()</code>, <code>points.default()</code>, <code>hist.default()</code>, or <code>bicop()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- replicate(3, runif(100))
pairs_copula_data(u)
</code></pre>

<hr>
<h2 id='par_to_ktau'>Conversion between Kendall's tau and parameters</h2><span id='topic+par_to_ktau'></span><span id='topic+ktau_to_par'></span>

<h3>Description</h3>

<p>Conversion between Kendall's tau and parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_to_ktau(family, rotation, parameters)

ktau_to_par(family, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par_to_ktau_+3A_family">family</code></td>
<td>
<p>a copula family (see <code><a href="#topic+bicop_dist">bicop_dist()</a></code>) or a <a href="#topic+bicop_dist">bicop_dist</a> object.</p>
</td></tr>
<tr><td><code id="par_to_ktau_+3A_rotation">rotation</code></td>
<td>
<p>the rotation of the copula, one of <code>0</code>, <code>90</code>, <code>180</code>, <code>270</code>.</p>
</td></tr>
<tr><td><code id="par_to_ktau_+3A_parameters">parameters</code></td>
<td>
<p>vector or matrix of copula parameters, not used when
<code>family</code> is a <code>bicop_dist</code> object.</p>
</td></tr>
<tr><td><code id="par_to_ktau_+3A_tau">tau</code></td>
<td>
<p>Kendall's <code class="reqn">\tau</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># the following are equivalent
par_to_ktau(bicop_dist("clayton", 0, 3))
par_to_ktau("clayton", 0, 3)

ktau_to_par("clayton", 0.5)
ktau_to_par(bicop_dist("clayton", 0, 3), 0.5)
</code></pre>

<hr>
<h2 id='plot.bicop_dist'>Plotting tools for <code>bicop_dist</code> and <code>bicop</code> objects</h2><span id='topic+plot.bicop_dist'></span><span id='topic+contour.bicop_dist'></span><span id='topic+plot.bicop'></span><span id='topic+contour.bicop'></span>

<h3>Description</h3>

<p>There are several options for plotting bicop_dist objects. The density of a
bivariate copula density can be visualized as surface/perspective or contour
plot. Optionally, the density can be coupled with standard normal margins
(default for contour plots).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bicop_dist'
plot(x, type = "surface", margins, size, ...)

## S3 method for class 'bicop'
plot(x, type = "surface", margins, size, ...)

## S3 method for class 'bicop_dist'
contour(x, margins = "norm", size = 100L, ...)

## S3 method for class 'bicop'
contour(x, margins = "norm", size = 100L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bicop_dist_+3A_x">x</code></td>
<td>
<p><code>bicop_dist object.</code></p>
</td></tr>
<tr><td><code id="plot.bicop_dist_+3A_type">type</code></td>
<td>
<p>plot type; either <code>"surface"</code> or <code>"contour"</code>.</p>
</td></tr>
<tr><td><code id="plot.bicop_dist_+3A_margins">margins</code></td>
<td>
<p>options are: <code>"unif"</code> for the original copula density,
<code>"norm"</code> for the transformed density with standard normal margins,
<code>"exp"</code> with standard exponential margins, and  <code>"flexp"</code> with
flipped exponential margins. Default is <code>"norm"</code> for <code>type =
  "contour"</code>, and <code>"unif"</code> for <code>type = "surface"</code>.</p>
</td></tr>
<tr><td><code id="plot.bicop_dist_+3A_size">size</code></td>
<td>
<p>integer; the plot is based on values on a <code style="white-space: pre;">&#8288;size x size&#8288;</code> grid,
default is 100.</p>
</td></tr>
<tr><td><code id="plot.bicop_dist_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="graphics.html#topic+contour">contour</a></code> or
<code><a href="lattice.html#topic+wireframe">wireframe</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bicop_dist">bicop_dist()</a></code>, <code><a href="graphics.html#topic+contour">graphics::contour()</a></code>, <code><a href="lattice.html#topic+wireframe">wireframe()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## construct bicop_dist object for a student t copula
obj &lt;- bicop_dist(family = "t", rotation = 0, parameters = c(0.7, 4))

## plots
plot(obj) # surface plot of copula density
contour(obj) # contour plot with standard normal margins
contour(obj, margins = "unif") # contour plot of copula density
</code></pre>

<hr>
<h2 id='plot.rvine_structure'>Plotting R-vine structures</h2><span id='topic+plot.rvine_structure'></span><span id='topic+plot.rvine_matrix'></span>

<h3>Description</h3>

<p>Plot one or all trees of an R-vine structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rvine_structure'
plot(x, ...)

## S3 method for class 'rvine_matrix'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rvine_structure_+3A_x">x</code></td>
<td>
<p>an <code>rvine_structure</code> or <code>rvine_matrix</code> object.</p>
</td></tr>
<tr><td><code id="plot.rvine_structure_+3A_...">...</code></td>
<td>
<p>passed to <code>plot.vinecop_dist()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plot(cvine_structure(1:5))
plot(rvine_structure_sim(5))
mat &lt;- rbind(c(1, 1, 1), c(2, 2, 0), c(3, 0, 0))
plot(rvine_matrix(mat))
plot(rvine_matrix_sim(5))
</code></pre>

<hr>
<h2 id='plot.vinecop_dist'>Plotting <code>vinecop_dist</code> and <code>vinecop</code> objects.</h2><span id='topic+plot.vinecop_dist'></span><span id='topic+contour.vinecop_dist'></span><span id='topic+plot.vinecop'></span><span id='topic+contour.vinecop'></span>

<h3>Description</h3>

<p>There are two plotting generics for <code>vinecop_dist</code> objects.
<code>plot.vinecop_dist</code> plots one or all trees of a given R-vine copula
model. Edges can be labeled with information about the corresponding
pair-copula. <code>contour.vinecop_dist</code> produces a matrix of contour plots
(using <code><a href="#topic+plot.bicop">plot.bicop</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vinecop_dist'
plot(x, tree = 1, var_names = "ignore", edge_labels = NULL, ...)

## S3 method for class 'vinecop'
plot(x, tree = 1, var_names = "ignore", edge_labels = NULL, ...)

## S3 method for class 'vinecop_dist'
contour(x, tree = "ALL", cex.nums = 1, ...)

## S3 method for class 'vinecop'
contour(x, tree = "ALL", cex.nums = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.vinecop_dist_+3A_x">x</code></td>
<td>
<p><code>vinecop_dist</code> object.</p>
</td></tr>
<tr><td><code id="plot.vinecop_dist_+3A_tree">tree</code></td>
<td>
<p><code>"ALL"</code> or integer vector; specifies which trees are
plotted.</p>
</td></tr>
<tr><td><code id="plot.vinecop_dist_+3A_var_names">var_names</code></td>
<td>
<p>integer; specifies how to make use of variable names:
</p>

<ul>
<li><p> '&quot;ignore&quot;&ldquo; = variable names are ignored,
</p>
</li>
<li><p> '&quot;use&quot;&ldquo; = variable names are used to annotate vertices,
</p>
</li>
<li><p> '&quot;legend&quot;&ldquo; = uses numbers in plot and adds a legend for variable names,
</p>
</li>
<li><p> '&quot;hide&quot;&ldquo; = no numbers or names, just the node.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.vinecop_dist_+3A_edge_labels">edge_labels</code></td>
<td>
<p>character; options are:
</p>

<ul>
<li> <p><code>"family"</code> = pair-copula family (see <code style="white-space: pre;">&#8288;[bicop_dist()]&#8288;</code>),
</p>
</li>
<li><p> &lsquo;&quot;tau&quot;&ldquo; = pair-copula Kendall&rsquo;s tau
</p>
</li>
<li><p> &lsquo;&quot;family_tau&quot;&ldquo; = pair-copula family and Kendall&rsquo;s tau,
</p>
</li>
<li><p> '&quot;pair&quot;&ldquo; = the name of the involved variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.vinecop_dist_+3A_...">...</code></td>
<td>
<p>Unused for <code>plot</code> and passed to
<code><a href="#topic+contour.bicop">contour.bicop</a></code> for <code>contour</code>.</p>
</td></tr>
<tr><td><code id="plot.vinecop_dist_+3A_cex.nums">cex.nums</code></td>
<td>
<p>numeric; expansion factor for font of the numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you want the contour boxes to be perfect squares, the plot height should
be <code>1.25/length(tree)*(d - min(tree))</code> times the plot width.
</p>
<p>The <code>plot()</code> method returns an object that (among other things) contains the
<code>igraph</code> representation of the graph; see <em>Examples</em>.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler, Thibault Vatter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vinecop_dist">vinecop_dist</a></code>,
<code><a href="#topic+plot.bicop">plot.bicop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up vine copula model
u &lt;- matrix(runif(20 * 10), 20, 10)
vc &lt;- vinecop(u, family = "indep")

# plot
plot(vc, tree = c(1, 2))
plot(vc, edge_labels = "pair")

# extract igraph representation
plt &lt;- plot(vc, edge_labels = "family_tau")
igr_obj &lt;- get("g", plt$plot_env)[[1]]
igr_obj  # print object
igraph::E(igr_obj)$name  # extract edge labels

# set up another vine copula model
pcs &lt;- lapply(1:3, function(j) # pair-copulas in tree j
  lapply(runif(4 - j), function(cor) bicop_dist("gaussian", 0, cor)))
mat &lt;- rvine_matrix_sim(4)
vc &lt;- vinecop_dist(pcs, mat)

# contour plot
contour(vc)
</code></pre>

<hr>
<h2 id='pseudo_obs'>Pseudo-Observations</h2><span id='topic+pseudo_obs'></span>

<h3>Description</h3>

<p>Compute the pseudo-observations for the given data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_obs(x, ties_method = "average", lower_tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudo_obs_+3A_x">x</code></td>
<td>
<p>vector or matrix random variates to be converted (column wise) to
pseudo-observations.</p>
</td></tr>
<tr><td><code id="pseudo_obs_+3A_ties_method">ties_method</code></td>
<td>
<p>similar to <code>ties.method</code> of <code><a href="base.html#topic+rank">rank()</a></code> (only <code>"average"</code>,
<code>"first"</code> and <code>"random"</code> currently available).</p>
</td></tr>
<tr><td><code id="pseudo_obs_+3A_lower_tail">lower_tail</code></td>
<td>
<p><code>logical</code> which, if 'FALSE&ldquo;, returns the
pseudo-observations when applying the empirical marginal survival
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code>n</code> realizations <code class="reqn">x_i=(x_{i1}, \ldots,x_{id})</code>,
<code class="reqn">i \in \left\lbrace 1, \ldots,n \right\rbrace </code>
of a random vector <code>X</code>, the pseudo-observations are defined via
<code class="reqn">u_{ij}=r_{ij}/(n+1)</code> for
<code class="reqn">i \in \left\lbrace 1, \ldots,n \right\rbrace</code>
and
<code class="reqn">j \in \left\lbrace 1, \ldots,d \right\rbrace </code>, where
<code class="reqn">r_{ij}</code> denotes the rank of <code class="reqn">x_{ij}</code> among all <code class="reqn">x_{kj}</code>,
<code class="reqn">k \in \left\lbrace 1, \ldots,n \right\rbrace </code>.
</p>
<p>The pseudo-observations can thus also be computed by component-wise applying
the empirical distribution functions to the data and scaling the result by
<code class="reqn">n/(n+1)</code>. This asymptotically negligible scaling factor is used to force
the variates to fall inside the open unit hypercube, for example, to avoid
problems with density evaluation at the boundaries.
</p>
<p>When <code>lower_tail = FALSE</code>, then <code>pseudo_obs()</code> simply returns
<code>1 - pseudo_obs()</code>.
</p>


<h3>Value</h3>

<p>a vector of matrix of the same dimension as the input containing the
pseudo-observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># pseudo-observations for a vector
pseudo_obs(rnorm(10))

# pseudo-observations for a matrix
pseudo_obs(cbind(rnorm(10), rnorm(10)))
</code></pre>

<hr>
<h2 id='rosenblatt'>(Inverse) Rosenblatt transform</h2><span id='topic+rosenblatt'></span><span id='topic+inverse_rosenblatt'></span>

<h3>Description</h3>

<p>The Rosenblatt transform takes data generated from a model and turns it into
independent uniform variates, The inverse Rosenblatt transform computes
conditional quantiles and can be used simulate from a stochastic model,
see <em>Details</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rosenblatt(x, model, cores = 1)

inverse_rosenblatt(u, model, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rosenblatt_+3A_x">x</code></td>
<td>
<p>matrix of evaluation points; must be in <code class="reqn">(0, 1)^d</code> for copula
models.</p>
</td></tr>
<tr><td><code id="rosenblatt_+3A_model">model</code></td>
<td>
<p>a model object; classes currently supported are
<code>bicop_dist()</code>, <code>vinecop_dist()</code>, and <code>vine_dist()</code>.</p>
</td></tr>
<tr><td><code id="rosenblatt_+3A_cores">cores</code></td>
<td>
<p>if <code style="white-space: pre;">&#8288;&gt;1&#8288;</code>, computation is parallelized over <code>cores</code> batches (rows
of <code>u</code>).</p>
</td></tr>
<tr><td><code id="rosenblatt_+3A_u">u</code></td>
<td>
<p>matrix of evaluation points; must be in <code class="reqn">(0, 1)^d</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Rosenblatt transform (Rosenblatt, 1952) <code class="reqn">U = T(V)</code> of a random vector
<code class="reqn">V = (V_1,\ldots,V_d) ~ F</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
  U_1= F(V_1), U_{2} = F(V_{2}|V_1), \ldots, U_d =F(V_d|V_1,\ldots,V_{d-1}),
</code>
</p>

<p>where <code class="reqn">F(v_k|v_1,\ldots,v_{k-1})</code> is the conditional distribution of
<code class="reqn">V_k</code> given <code class="reqn">V_1 \ldots, V_{k-1}, k = 2,\ldots,d</code>. The vector
<code class="reqn">U  = (U_1, \dots, U_d)</code> then contains independent standard uniform
variables. The inverse operation
</p>
<p style="text-align: center;"><code class="reqn">
  V_1 = F^{-1}(U_1), V_{2} = F^{-1}(U_2|U_1), \ldots,
  V_d =F^{-1}(U_d|U_1,\ldots,U_{d-1}),
</code>
</p>

<p>can be used to simulate from a distribution. For any copula <code class="reqn">F</code>, if
<code class="reqn">U</code> is a vector of independent random variables, <code class="reqn">V = T^{-1}(U)</code> has
distribution <code class="reqn">F</code>.
</p>
<p>The formulas above assume a vine copula model with order <code class="reqn">d, \dots, 1</code>.
More generally, <code>rosenblatt()</code> returns the variables
</p>
<p style="text-align: center;"><code class="reqn">
  U_{M[d + 1- j, j]}= F(V_{M[d + 1- j, j]} | V_{M[d - j, j - 1]}, \dots, V_{M[1, 1]}),
</code>
</p>

<p>where <code class="reqn">M</code> is the structure matrix. Similarly, <code>inverse_rosenblatt()</code>
returns
</p>
<p style="text-align: center;"><code class="reqn">
  V_{M[d + 1- j, j]}= F^{-1}(U_{M[d + 1- j, j]} | U_{M[d - j, j - 1]}, \dots, U_{M[1, 1]}).
</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'># simulate data with some dependence
x &lt;- replicate(3, rnorm(200))
x[, 2:3] &lt;- x[, 2:3] + x[, 1]
pairs(x)

# estimate a vine distribution model
fit &lt;- vine(x, copula_controls = list(family_set = "par"))

# transform into independent uniforms
u &lt;- rosenblatt(x, fit)
pairs(u)

# inversion
pairs(inverse_rosenblatt(u, fit))

# works similarly for vinecop models
vc &lt;- fit$copula
rosenblatt(pseudo_obs(x), vc)
</code></pre>

<hr>
<h2 id='rvine_structure'>R-vine structure</h2><span id='topic+rvine_structure'></span><span id='topic+rvine_matrix'></span><span id='topic+is.rvine_structure'></span><span id='topic+is.rvine_matrix'></span><span id='topic+dvine_structure'></span><span id='topic+cvine_structure'></span>

<h3>Description</h3>

<p>R-vine structures are compressed representations encoding the tree structure
of the vine, i.e. the conditioned/conditioning variables of each edge. The
functions <code style="white-space: pre;">&#8288;[cvine_structure()]&#8288;</code> or <code style="white-space: pre;">&#8288;[dvine_structure()]&#8288;</code> give a simpler way
to construct C-vines (every tree is a star) and D-vines (every tree is a
path), respectively (see <em>Examples</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvine_structure(order, struct_array = list(), is_natural_order = FALSE)

cvine_structure(order, trunc_lvl = Inf)

dvine_structure(order, trunc_lvl = Inf)

rvine_matrix(matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvine_structure_+3A_order">order</code></td>
<td>
<p>a vector of positive integers.</p>
</td></tr>
<tr><td><code id="rvine_structure_+3A_struct_array">struct_array</code></td>
<td>
<p>a list of vectors of positive integers. The vectors
represent rows of the r-rvine structure and the number of elements have to
be compatible with the <code>order</code> vector. If empty, the model is 0-truncated.</p>
</td></tr>
<tr><td><code id="rvine_structure_+3A_is_natural_order">is_natural_order</code></td>
<td>
<p>whether <code>struct_array</code> is assumed to be provided in
natural order already (a structure is in natural order if the anti-
diagonal is 1, .., d from bottom left to top right).</p>
</td></tr>
<tr><td><code id="rvine_structure_+3A_trunc_lvl">trunc_lvl</code></td>
<td>
<p>the truncation level</p>
</td></tr>
<tr><td><code id="rvine_structure_+3A_matrix">matrix</code></td>
<td>
<p>an R-vine matrix, see <em>Details</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The R-vine structure is essentially a lower-triangular matrix/triangular
array, with a notation that differs from the one in the VineCopula package.
An example array is
</p>
<div class="sourceCode"><pre>4 4 4 4
3 3 3
2 2
1
</pre></div>
<p>which encodes the following pair-copulas:
</p>

<table>
<tr>
 <td style="text-align: left;">
tree </td><td style="text-align: left;">  edge </td><td style="text-align: left;"> pair-copulas   </td>
</tr>
<tr>
 <td style="text-align: left;">
0    </td><td style="text-align: left;">  0    </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;(1, 4)&#8288;</code>       </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;">  1    </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;(2, 4)&#8288;</code>       </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;">  2    </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;(3, 4)&#8288;</code>       </td>
</tr>
<tr>
 <td style="text-align: left;">
1    </td><td style="text-align: left;">  0    </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;(1, 3; 4)&#8288;</code>    </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;">  1    </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;(2, 3; 4)&#8288;</code>    </td>
</tr>
<tr>
 <td style="text-align: left;">
2    </td><td style="text-align: left;">  0    </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;(1, 2; 3, 4)&#8288;</code>
</td>
</tr>

</table>

<p>An R-vine structure can be converted to an R-vine matrix using
<code><a href="#topic+as_rvine_matrix">as_rvine_matrix()</a></code>, which encodes the same model with a square matrix filled
with zeros. For instance, the matrix corresponding to the structure above is:
</p>
<div class="sourceCode"><pre>4 4 4 4
3 3 3 0
2 2 0 0
1 0 0 0
</pre></div>
<p>Similarly, an R-vine matrix can be converted to an R-vine structure using
<code><a href="#topic+as_rvine_structure">as_rvine_structure()</a></code>.
</p>
<p>Denoting by <code>M[i, j]</code> the array entry in row <code>i</code> and column <code>j</code> (the
pair-copula index for edge <code>e</code> in tree <code>t</code> of a <code>d</code> dimensional vine is
<code style="white-space: pre;">&#8288;(M[d + 1 - e, e], M[t, e]; M[t - 1, e], ..., M[1, e])&#8288;</code>. Less formally,
</p>

<ol>
<li><p> Start with the counter-diagonal element of column <code>e</code> (first conditioned
variable).
</p>
</li>
<li><p> Jump up to the element in row <code>t</code> (second conditioned variable).
</p>
</li>
<li><p> Gather all entries further up in column <code>e</code> (conditioning set).
</p>
</li></ol>

<p>Internally, the diagonal is stored separately from the off-diagonal elements,
which are stored as a triangular array. For instance, the off-diagonal
elements off the structure above are stored as
</p>
<div class="sourceCode"><pre>4 4 4
3 3
2
</pre></div>
<p>for the structure above. The reason is that it allows for parsimonious
representations of truncated models. For instance, the 2-truncated model is
represented by the same diagonal and the following truncated triangular
array:
</p>
<div class="sourceCode"><pre>4 4 4
3 3
</pre></div>
<p>A valid R-vine structure or matrix must satisfy several conditions which are
checked when <code><a href="#topic+rvine_structure">rvine_structure()</a></code>, <code><a href="#topic+rvine_matrix">rvine_matrix()</a></code>, or some coercion methods
(see <code><a href="#topic+as_rvine_structure">as_rvine_structure()</a></code> and <code style="white-space: pre;">&#8288;as_rvine_matrix(&#8288;</code>) are called:
</p>

<ol>
<li><p> It can only contain numbers between 1 and d (and additionally zeros for
R-vine matrices).
</p>
</li>
<li><p> The anti-diagonal must contain the numbers 1, ..., d.
</p>
</li>
<li><p> The anti-diagonal entry of a column must not be contained in any column
further to the right.
</p>
</li>
<li><p> The entries of a column must be contained in all columns to the left.
</p>
</li>
<li><p> The proximity condition must hold: For all t = 1, ..., d - 2 and e = 1,
..., d - t there must exist an index j &gt; d, such that
<code style="white-space: pre;">&#8288;(M[t, e], {M[1, e], ..., M[t - 1, e]})&#8288;</code> equals either
<code style="white-space: pre;">&#8288;(M[d + 1 - j, j], {M[1, j], ..., M[t - 1, j]})&#8288;</code> or
<code style="white-space: pre;">&#8288;(M[t - 1, j], {M[d + 1 - j, j], M[1, j], ..., M[t - 2, j]})&#8288;</code>.
</p>
</li></ol>

<p>Condition 5 already implies conditions 2-4, but is more difficult to check by
hand.
</p>


<h3>Value</h3>

<p>Either an <code>rvine_structure</code> or an <code>rvine_matrix</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_rvine_structure">as_rvine_structure()</a></code>, <code><a href="#topic+as_rvine_matrix">as_rvine_matrix()</a></code>,
<code><a href="#topic+plot.rvine_structure">plot.rvine_structure()</a></code>, <code><a href="#topic+plot.rvine_matrix">plot.rvine_matrix()</a></code>,
<code><a href="#topic+rvine_structure_sim">rvine_structure_sim()</a></code>, <code><a href="#topic+rvine_matrix_sim">rvine_matrix_sim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# R-vine structures can be constructed from the order vector and struct_array
rvine_structure(order = 1:4, struct_array = list(
  c(4, 4, 4),
  c(3, 3),
  2
))

# R-vine matrices can be constructed from standard matrices
mat &lt;- matrix(c(4, 3, 2, 1, 4, 3, 2, 0, 4, 3, 0, 0, 4, 0, 0, 0), 4, 4)
rvine_matrix(mat)

# coerce to R-vine structure
str(as_rvine_structure(mat))

# truncate and construct the R-vine matrix
mat[3, 1] &lt;- 0
rvine_matrix(mat)

# or use directly the R-vine structure constructor
rvine_structure(order = 1:4, struct_array = list(
  c(4, 4, 4),
  c(3, 3)
))

# throws an error
mat[3, 1] &lt;- 5
try(rvine_matrix(mat))

# C-vine structure
cvine &lt;- cvine_structure(1:5)
cvine
plot(cvine)

# D-vine structure
dvine &lt;- dvine_structure(c(1, 4, 2, 3, 5))
dvine
plot(dvine)

</code></pre>

<hr>
<h2 id='rvine_structure_sim'>Simulate R-vine structures</h2><span id='topic+rvine_structure_sim'></span><span id='topic+rvine_matrix_sim'></span>

<h3>Description</h3>

<p>Simulates from a uniform distribution over all R-vine structures on d
variables. <code>rvine_structure_sim()</code> returns an <code><a href="#topic+rvine_structure">rvine_structure()</a></code> object,
<code>rvine_matrix_sim()</code> an <code><a href="#topic+rvine_matrix">rvine_matrix()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvine_structure_sim(d, natural_order = FALSE)

rvine_matrix_sim(d, natural_order = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvine_structure_sim_+3A_d">d</code></td>
<td>
<p>the number of variables</p>
</td></tr>
<tr><td><code id="rvine_structure_sim_+3A_natural_order">natural_order</code></td>
<td>
<p>boolean; whether the structures should be in natural
order (counter-diagonal is <code>1:d</code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rvine_structure">rvine_structure()</a></code>, <code><a href="#topic+rvine_matrix">rvine_matrix()</a></code>,
<code><a href="#topic+plot.rvine_structure">plot.rvine_structure()</a></code>, <code><a href="#topic+plot.rvine_matrix">plot.rvine_matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rvine_structure_sim(10)

rvine_structure_sim(10, natural_order = TRUE)  # counter-diagonal is 1:d

rvine_matrix_sim(10)
</code></pre>

<hr>
<h2 id='rvinecopulib'>High Performance Algorithms for Vine Copula Modeling</h2><span id='topic+rvinecopulib'></span>

<h3>Description</h3>

<p>Provides an interface to 'vinecopulib', a C++ library for vine copula
modeling based on 'Boost' and 'Eigen'. The 'rvinecopulib' package implements
the core features of the popular 'VineCopula' package, in particular
inference algorithms for both vine copula and bivariate copula models.
Advantages over 'VineCopula' are a sleeker and more modern API, improved
performances, especially in high dimensions, nonparametric and
multi-parameter families. The 'rvinecopulib' package includes 'vinecopulib'
as header-only C++ library (currently version 0.6.2). Thus users do not need
to install 'vinecopulib' itself in order to use 'rvinecopulib'. Since their
initial releases, 'vinecopulib' is licensed under the MIT License, and
'rvinecopulib' is licensed under the GNU GPL version 3.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler, Thibault Vatter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## bicop_dist objects
bicop_dist("gaussian", 0, 0.5)
str(bicop_dist("gauss", 0, 0.5))
bicop &lt;- bicop_dist("clayton", 90, 3)

## bicop objects
u &lt;- rbicop(500, "gauss", 0, 0.5)
fit1 &lt;- bicop(u, family = "par")
fit1

## vinecop_dist objects
## specify pair-copulas
bicop &lt;- bicop_dist("bb1", 90, c(3, 2))
pcs &lt;- list(
  list(bicop, bicop), # pair-copulas in first tree
  list(bicop) # pair-copulas in second tree
)
## specify R-vine matrix
mat &lt;- matrix(c(1, 2, 3, 1, 2, 0, 1, 0, 0), 3, 3)
## build the vinecop_dist object
vc &lt;- vinecop_dist(pcs, mat)
summary(vc)

## vinecop objects
u &lt;- sapply(1:3, function(i) runif(50))
vc &lt;- vinecop(u, family = "par")
summary(vc)

## vine_dist objects
vc &lt;- vine_dist(list(distr = "norm"), pcs, mat)
summary(vc)

## vine objects
x &lt;- sapply(1:3, function(i) rnorm(50))
vc &lt;- vine(x, copula_controls = list(family_set = "par"))
summary(vc)
</code></pre>

<hr>
<h2 id='truncate_model'>Truncate a vine copula model</h2><span id='topic+truncate_model'></span><span id='topic+truncate_model.rvine_structure'></span><span id='topic+truncate_model.rvine_matrix'></span><span id='topic+truncate_model.vinecop_dist'></span><span id='topic+truncate_model.vine_dist'></span>

<h3>Description</h3>

<p>Extracts a truncated sub-vine based on a truncation level supplied by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncate_model(object, ...)

## S3 method for class 'rvine_structure'
truncate_model(object, trunc_lvl, ...)

## S3 method for class 'rvine_matrix'
truncate_model(object, trunc_lvl, ...)

## S3 method for class 'vinecop_dist'
truncate_model(object, trunc_lvl, ...)

## S3 method for class 'vine_dist'
truncate_model(object, trunc_lvl, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncate_model_+3A_object">object</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="truncate_model_+3A_...">...</code></td>
<td>
<p>further arguments passed to specific methods.</p>
</td></tr>
<tr><td><code id="truncate_model_+3A_trunc_lvl">trunc_lvl</code></td>
<td>
<p>tree level after which the vine copula should be truncated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While a vine model for a <code>d</code> dimensional random vector contains at most <code>d-1</code>
nested trees, this function extracts a sub-model based on a given truncation
level.
</p>
<p>For instance, <code>truncate_model(object, 1)</code> results in a 1-truncated
vine (i.e., a vine with a single tree). Similarly <code>truncate_model(object, 2)</code>
results in a 2-truncated vine (i.e., a vine with two trees). Note that
<code>truncate_model(truncate_model(object, 1), 2)</code> returns a 1-truncated vine.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify pair-copulas
bicop &lt;- bicop_dist("bb1", 90, c(3, 2))
pcs &lt;- list(
  list(bicop, bicop), # pair-copulas in first tree
  list(bicop) # pair-copulas in second tree
)

# specify R-vine matrix
mat &lt;- matrix(c(1, 2, 3, 1, 2, 0, 1, 0, 0), 3, 3)

# set up vine structure
structure &lt;- as_rvine_structure(mat)

# truncate the model
truncate_model(structure, 1)

# set up vine copula model
vc &lt;- vinecop_dist(pcs, mat)

# truncate the model
truncate_model(vc, 1)
</code></pre>

<hr>
<h2 id='vine'>Vine copula models</h2><span id='topic+vine'></span><span id='topic+vine_dist'></span>

<h3>Description</h3>

<p>Automated fitting or creation of custom vine copula models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vine(
  data,
  margins_controls = list(mult = NULL, xmin = NaN, xmax = NaN, bw = NA, deg = 2),
  copula_controls = list(family_set = "all", structure = NA, par_method = "mle",
    nonpar_method = "constant", mult = 1, selcrit = "aic", psi0 = 0.9, presel = TRUE,
    trunc_lvl = Inf, tree_crit = "tau", threshold = 0, keep_data = FALSE, show_trace =
    FALSE, cores = 1),
  weights = numeric(),
  keep_data = FALSE,
  cores = 1
)

vine_dist(margins, pair_copulas, structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vine_+3A_data">data</code></td>
<td>
<p>a matrix or data.frame. Discrete variables have to be declared as
<code>ordered()</code>.</p>
</td></tr>
<tr><td><code id="vine_+3A_margins_controls">margins_controls</code></td>
<td>
<p>a list with arguments to be passed to
<code><a href="kde1d.html#topic+kde1d">kde1d::kde1d()</a></code>. Currently, there can be
</p>

<ul>
<li> <p><code>mult</code> numeric vector of length one or d; all bandwidths for marginal
kernel density estimation are multiplied with <code>mult</code>. Defaults to
<code>log(1 + d)</code> where <code>d</code> is the number of variables after applying
<code>rvinecopulib:::expand_factors()</code>.
</p>
</li>
<li> <p><code>xmin</code> numeric vector of length d; see <code><a href="kde1d.html#topic+kde1d">kde1d::kde1d()</a></code>.
</p>
</li>
<li> <p><code>xmax</code> numeric vector of length d; see <code><a href="kde1d.html#topic+kde1d">kde1d::kde1d()</a></code>.
</p>
</li>
<li> <p><code>bw</code> numeric vector of length d; see <code><a href="kde1d.html#topic+kde1d">kde1d::kde1d()</a></code>.
</p>
</li>
<li> <p><code>deg</code> numeric vector of length one or d; <code><a href="kde1d.html#topic+kde1d">kde1d::kde1d()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vine_+3A_copula_controls">copula_controls</code></td>
<td>
<p>a list with arguments to be passed to <code><a href="#topic+vinecop">vinecop()</a></code>.</p>
</td></tr>
<tr><td><code id="vine_+3A_weights">weights</code></td>
<td>
<p>optional vector of weights for each observation.</p>
</td></tr>
<tr><td><code id="vine_+3A_keep_data">keep_data</code></td>
<td>
<p>whether the original data should be stored; if you want to
store the pseudo-observations used for fitting the copula, use the
<code>copula_controls</code> argument.</p>
</td></tr>
<tr><td><code id="vine_+3A_cores">cores</code></td>
<td>
<p>the number of cores to use for parallel computations.</p>
</td></tr>
<tr><td><code id="vine_+3A_margins">margins</code></td>
<td>
<p>A list with with each element containing the specification of a
marginal <a href="stats.html#topic+Distributions">stats::Distributions</a>. Each marginal specification
should be a list with containing at least the distribution family (<code>"distr"</code>)
and optionally the parameters, e.g.
<code>list(list(distr = "norm"), list(distr = "norm", mu = 1), list(distr = "beta", shape1 = 1, shape2 = 1))</code>.
Note that parameters that have no default values have to be provided.
Furthermore, if <code>margins</code> has length one, it will be recycled for every component.</p>
</td></tr>
<tr><td><code id="vine_+3A_pair_copulas">pair_copulas</code></td>
<td>
<p>A nested list of 'bicop_dist' objects, where
<code>pair_copulas[[t]][[e]]</code> corresponds to the pair-copula at edge <code>e</code> in
tree <code>t</code>.</p>
</td></tr>
<tr><td><code id="vine_+3A_structure">structure</code></td>
<td>
<p>an <code>rvine_structure</code> object, namely a compressed
representation of the vine structure, or an object that can be coerced
into one (see <code><a href="#topic+rvine_structure">rvine_structure()</a></code> and <code><a href="#topic+as_rvine_structure">as_rvine_structure()</a></code>).
The dimension must be <code>length(pair_copulas[[1]]) + 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vine_dist()</code> creates a vine copula by specifying the margins, a nested list
of <code>bicop_dist</code> objects and a quadratic structure matrix.
</p>
<p><code>vine()</code> provides automated fitting for vine copula models.
<code>margins_controls</code> is a list with the same parameters as
<code><a href="kde1d.html#topic+kde1d">kde1d::kde1d()</a></code> (except for <code>x</code>). <code>copula_controls</code> is a list
with the same parameters as <code><a href="#topic+vinecop">vinecop()</a></code> (except for <code>data</code>).
</p>


<h3>Value</h3>

<p>Objects inheriting from <code>vine_dist</code> for <code><a href="#topic+vine_dist">vine_dist()</a></code>, and
<code>vine</code> and <code>vine_dist</code> for <code><a href="#topic+vine">vine()</a></code>.
</p>
<p>Objects from the <code>vine_dist</code> class are lists containing:
</p>

<ul>
<li> <p><code>margins</code>, a list of marginals (see below).
</p>
</li>
<li> <p><code>copula</code>, an object of the class <code>vinecop_dist</code>, see <code><a href="#topic+vinecop_dist">vinecop_dist()</a></code>.
</p>
</li></ul>

<p>For objects from the <code>vine</code> class, <code>copula</code> is also an object of the class
<code>vine</code>, see <code><a href="#topic+vinecop">vinecop()</a></code>. Additionally, objects from the <code>vine</code> class contain:
</p>

<ul>
<li> <p><code>margins_controls</code>, a <code>list</code> with the set of fit controls that was passed
to <code><a href="kde1d.html#topic+kde1d">kde1d::kde1d()</a></code> when estimating the margins.
</p>
</li>
<li> <p><code>copula_controls</code>, a <code>list</code> with the set of fit controls that was passed
to <code><a href="#topic+vinecop">vinecop()</a></code> when estimating the copula.
</p>
</li>
<li> <p><code>data</code> (optionally, if <code>keep_data = TRUE</code> was used), the dataset that was
passed to <code><a href="#topic+vine">vine()</a></code>.
</p>
</li>
<li> <p><code>nobs</code>, an <code>integer</code> containing the number of observations that was used
to fit the model.
</p>
</li></ul>

<p>Concerning <code>margins</code>:
</p>

<ul>
<li><p> For objects created with <code><a href="#topic+vine_dist">vine_dist()</a></code>, it simply corresponds to the <code>margins</code>
argument.
</p>
</li>
<li><p> For objects created with <code><a href="#topic+vine">vine()</a></code>, it is a list of objects of class <code>kde1d</code>,
see <code><a href="kde1d.html#topic+kde1d">kde1d::kde1d()</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># specify pair-copulas
bicop &lt;- bicop_dist("bb1", 90, c(3, 2))
pcs &lt;- list(
  list(bicop, bicop), # pair-copulas in first tree
  list(bicop) # pair-copulas in second tree
)

# specify R-vine matrix
mat &lt;- matrix(c(1, 2, 3, 1, 2, 0, 1, 0, 0), 3, 3)

# set up vine copula model with Gaussian margins
vc &lt;- vine_dist(list(distr = "norm"), pcs, mat)

# show model
summary(vc)

# simulate some data
x &lt;- rvine(50, vc)

# estimate a vine copula model
fit &lt;- vine(x, copula_controls = list(family_set = "par"))
summary(fit)

## model for discrete data
x &lt;- as.data.frame(x)
x[, 1] &lt;- ordered(round(x[, 1]), levels = seq.int(-5, 5))
fit_disc &lt;- vine(x, copula_controls = list(family_set = "par"))
summary(fit_disc)

</code></pre>

<hr>
<h2 id='vine_distributions'>Vine based distributions</h2><span id='topic+vine_distributions'></span><span id='topic+dvine'></span><span id='topic+pvine'></span><span id='topic+rvine'></span><span id='topic+dvine_dist'></span><span id='topic+pvine_dist'></span><span id='topic+rvine_dist'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation
for the vine based distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dvine(x, vine, cores = 1)

pvine(x, vine, n_mc = 10^4, cores = 1)

rvine(n, vine, qrng = FALSE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vine_distributions_+3A_x">x</code></td>
<td>
<p>evaluation points, either a length d vector or a d-column matrix,
where d is the number of variables in the vine.</p>
</td></tr>
<tr><td><code id="vine_distributions_+3A_vine">vine</code></td>
<td>
<p>an object of class <code>"vine_dist"</code>.</p>
</td></tr>
<tr><td><code id="vine_distributions_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if larger than one, computations are
done in parallel on <code>cores</code> batches .</p>
</td></tr>
<tr><td><code id="vine_distributions_+3A_n_mc">n_mc</code></td>
<td>
<p>number of samples used for quasi Monte Carlo integration.</p>
</td></tr>
<tr><td><code id="vine_distributions_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="vine_distributions_+3A_qrng">qrng</code></td>
<td>
<p>if <code>TRUE</code>, generates quasi-random numbers using the multivariate
Generalized Halton sequence up to dimension 300 and the Generalized Sobol
sequence in higher dimensions (default <code>qrng = FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+vine">vine</a> for the estimation and construction of vine models.
Here, the density, distribution function and random generation
for the vine distributions are standard.
</p>
<p>The functions are based on <code><a href="#topic+dvinecop">dvinecop()</a></code>, <code><a href="#topic+pvinecop">pvinecop()</a></code> and <code><a href="#topic+rvinecop">rvinecop()</a></code> for
<a href="#topic+vinecop">vinecop</a> objects, and either <code><a href="kde1d.html#topic+dkde1d">kde1d::dkde1d()</a></code>, <code><a href="kde1d.html#topic+dkde1d">kde1d::pkde1d()</a></code> and
<code><a href="kde1d.html#topic+dkde1d">kde1d::qkde1d()</a></code> for estimated vines (i.e., output of <code><a href="#topic+vine">vine()</a></code>), or the
standard <em>d/p/q-xxx</em> from <a href="stats.html#topic+Distributions">stats::Distributions</a> for custom vines
(i.e., output of <code><a href="#topic+vine_dist">vine_dist()</a></code>).
</p>


<h3>Value</h3>

<p><code>dvine()</code> gives the density, <code>pvine()</code> gives the distribution function,
and <code>rvine()</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rvine()</code>, and
the number of rows in <code>u</code> for the other functions.
</p>
<p>The <code>vine</code> object is recycled to the length of the
result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify pair-copulas
bicop &lt;- bicop_dist("bb1", 90, c(3, 2))
pcs &lt;- list(
  list(bicop, bicop), # pair-copulas in first tree
  list(bicop) # pair-copulas in second tree
)

# set up vine copula model
mat &lt;- rvine_matrix_sim(3)
vc &lt;- vine_dist(list(distr = "norm"), pcs, mat)

# simulate from the model
x &lt;- rvine(200, vc)
pairs(x)

# evaluate the density and cdf
dvine(x[1, ], vc)
pvine(x[1, ], vc)
</code></pre>

<hr>
<h2 id='vine_predict_and_fitted'>Predictions and fitted values for a vine copula model</h2><span id='topic+vine_predict_and_fitted'></span><span id='topic+predict.vine'></span><span id='topic+fitted.vine'></span>

<h3>Description</h3>

<p>Predictions of the density and distribution function
for a vine copula model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vine'
predict(object, newdata, what = "pdf", n_mc = 10^4, cores = 1, ...)

## S3 method for class 'vine'
fitted(object, what = "pdf", n_mc = 10^4, cores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vine_predict_and_fitted_+3A_object">object</code></td>
<td>
<p>a <code>vine</code> object.</p>
</td></tr>
<tr><td><code id="vine_predict_and_fitted_+3A_newdata">newdata</code></td>
<td>
<p>points where the fit shall be evaluated.</p>
</td></tr>
<tr><td><code id="vine_predict_and_fitted_+3A_what">what</code></td>
<td>
<p>what to predict, either <code>"pdf"</code> or <code>"cdf"</code>.</p>
</td></tr>
<tr><td><code id="vine_predict_and_fitted_+3A_n_mc">n_mc</code></td>
<td>
<p>number of samples used for quasi Monte Carlo integration when
<code>what = "cdf"</code>.</p>
</td></tr>
<tr><td><code id="vine_predict_and_fitted_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if larger than one, computations are
done in parallel on <code>cores</code> batches .</p>
</td></tr>
<tr><td><code id="vine_predict_and_fitted_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fitted()</code> and <code>predict()</code> have return values similar to <code><a href="#topic+dvine">dvine()</a></code>
and <code><a href="#topic+pvine">pvine()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sapply(1:5, function(i) rnorm(50))
fit &lt;- vine(x, copula_controls = list(family_set = "par"), keep_data = TRUE)
all.equal(predict(fit, x), fitted(fit), check.environment = FALSE)
</code></pre>

<hr>
<h2 id='vinecop'>Fitting vine copula models</h2><span id='topic+vinecop'></span>

<h3>Description</h3>

<p>Automated fitting and model selection for vine copula models with continuous
or discrete data. Selection of the structure is performed using the algorithm
of Dissmann et al. (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vinecop(
  data,
  var_types = rep("c", NCOL(data)),
  family_set = "all",
  structure = NA,
  par_method = "mle",
  nonpar_method = "constant",
  mult = 1,
  selcrit = "aic",
  weights = numeric(),
  psi0 = 0.9,
  presel = TRUE,
  trunc_lvl = Inf,
  tree_crit = "tau",
  threshold = 0,
  keep_data = FALSE,
  show_trace = FALSE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vinecop_+3A_data">data</code></td>
<td>
<p>a matrix or data.frame with at least two columns, containing the
(pseudo-)observations for the two variables (copula data should have
approximately uniform margins). More columns are required for discrete
models, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_var_types">var_types</code></td>
<td>
<p>variable types, a length d vector; e.g., <code>c("c", "c")</code> for
two continuous variables, or <code>c("c", "d")</code> for first variable continuous
and second discrete.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_family_set">family_set</code></td>
<td>
<p>a character vector of families; see <code><a href="#topic+bicop">bicop()</a></code> for
additional options.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_structure">structure</code></td>
<td>
<p>an <code>rvine_structure</code> object, namely a compressed
representation of the vine structure, or an object that can be coerced into
one (see <code><a href="#topic+rvine_structure">rvine_structure()</a></code> and <code><a href="#topic+as_rvine_structure">as_rvine_structure()</a></code>). The dimension
must be <code>length(pair_copulas[[1]]) + 1</code>; <code>structure = NA</code> performs
automatic selection based on Dissman's algorithm. See <em>Details</em> for partial
selection of the structure.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_par_method">par_method</code></td>
<td>
<p>the estimation method for parametric models, either <code>"mle"</code>
for maximum likelihood or <code>"itau"</code> for inversion of Kendall's tau (only
available for one-parameter families and <code>"t"</code>.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_nonpar_method">nonpar_method</code></td>
<td>
<p>the estimation method for nonparametric models, either
<code>"constant"</code> for the standard transformation estimator, or
<code>"linear"</code>/<code>"quadratic"</code> for the local-likelihood approximations of order
one/two.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_mult">mult</code></td>
<td>
<p>multiplier for the smoothing parameters of nonparametric
families. Values larger than 1 make the estimate more smooth, values less
than 1 less smooth.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_selcrit">selcrit</code></td>
<td>
<p>criterion for family selection, either <code>"loglik"</code>, <code>"aic"</code>,
<code>"bic"</code>, <code>"mbic"</code>. For <code>vinecop()</code> there is the additional option
<code>"mbicv"</code>.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_weights">weights</code></td>
<td>
<p>optional vector of weights for each observation.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_psi0">psi0</code></td>
<td>
<p>prior probability of a non-independence copula (only used for
<code>selcrit = "mbic"</code> and <code>selcrit = "mbicv"</code>).</p>
</td></tr>
<tr><td><code id="vinecop_+3A_presel">presel</code></td>
<td>
<p>whether the family set should be thinned out according to
symmetry characteristics of the data.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_trunc_lvl">trunc_lvl</code></td>
<td>
<p>the truncation level of the vine copula; <code>Inf</code> means no
truncation, <code>NA</code> indicates that the truncation level should be selected
automatically by <code><a href="#topic+mBICV">mBICV()</a></code>.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_tree_crit">tree_crit</code></td>
<td>
<p>the criterion for tree selection, one of <code>"tau"</code>, <code>"rho"</code>,
<code>"hoeffd"</code>, <code>"mcor"</code>, or <code>"joe"</code> for Kendall's <code class="reqn">\tau</code>, Spearman's
<code class="reqn">\rho</code>, Hoeffding's <code class="reqn">D</code>, maximum correlation, or logarithm of
the partial correlation, respectively.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_threshold">threshold</code></td>
<td>
<p>for thresholded vine copulas; <code>NA</code> indicates that the
threshold should be selected automatically by <code><a href="#topic+mBICV">mBICV()</a></code>.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_keep_data">keep_data</code></td>
<td>
<p>whether the data should be stored (necessary for using
<code><a href="stats.html#topic+fitted">fitted()</a></code>).</p>
</td></tr>
<tr><td><code id="vinecop_+3A_show_trace">show_trace</code></td>
<td>
<p>logical; whether a trace of the fitting progress should be
printed.</p>
</td></tr>
<tr><td><code id="vinecop_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if more than 1, estimation of pair
copulas within a tree is done in parallel.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Missing data</h4>

<p>If there are missing data (i.e., <code>NA</code> entries), incomplete observations are
discarded before fitting a pair-copula. This is done on a pair-by-pair basis
so that the maximal available information is used.
</p>



<h4>Discrete variables</h4>

<p>The dependence measures used to select trees (default: Kendall's tau) are
corrected for ties (see <a href="wdm.html#topic+wdm">wdm::wdm</a>).
</p>
<p>Let <code>n</code> be the number of observations and <code>d</code> the number of variables.
When at least one variable is discrete, two types of
&quot;observations&quot; are required in <code>data</code>: the first <code style="white-space: pre;">&#8288;n  x  d&#8288;</code> block
contains realizations of <code class="reqn">F_{X_j}(X_j)</code>. The second <code style="white-space: pre;">&#8288;n  x  d&#8288;</code>
block contains realizations of <code class="reqn">F_{X_j}(X_j^-)</code>. The minus indicates a
left-sided limit of the cdf. For, e.g., an integer-valued variable, it holds
<code class="reqn">F_{X_j}(X_j^-) = F_{X_j}(X_j - 1)</code>. For continuous variables the left
limit and the cdf itself coincide. Respective columns can be omitted in the
second block.
</p>



<h4>Partial structure selection</h4>

<p>It is possible to fix the vine structure only in the first trees and select
the remaining ones automatically. To specify only the first <code>k</code> trees, supply
a <code>k</code>-truncated <code>rvine_structure()</code> or <code>rvine_matrix()</code>. All trees up to
<code>trunc_lvl</code> will then be selected automatically.
</p>



<h3>Value</h3>

<p>Objects inheriting from <code>vinecop</code> and <code>vinecop_dist</code> for <code><a href="#topic+vinecop">vinecop()</a></code>. In
addition to the entries provided by <code><a href="#topic+vinecop_dist">vinecop_dist()</a></code>, there are:
</p>

<ul>
<li> <p><code>threshold</code>, the (set or estimated) threshold used for thresholding the
vine.
</p>
</li>
<li> <p><code>data</code> (optionally, if <code>keep_data = TRUE</code> was used), the dataset that was
passed to <code><a href="#topic+vinecop">vinecop()</a></code>.
</p>
</li>
<li> <p><code>controls</code>, a <code>list</code> with fit controls that was passed to <code><a href="#topic+vinecop">vinecop()</a></code>.
</p>
</li>
<li> <p><code>nobs</code>, the number of observations that were used to fit the model.
</p>
</li></ul>



<h3>References</h3>

<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka (2013).
<em>Selecting and estimating regular vine copulae and application to
financial returns.</em> Computational Statistics &amp; Data Analysis, 59 (1),
52-69.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vinecop">vinecop()</a></code>, <code><a href="#topic+dvinecop">dvinecop()</a></code>, <code><a href="#topic+pvinecop">pvinecop()</a></code>, <code><a href="#topic+rvinecop">rvinecop()</a></code>,
<code><a href="#topic+plot.vinecop">plot.vinecop()</a></code>, <code><a href="#topic+contour.vinecop">contour.vinecop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate dummy data
x &lt;- rnorm(30) * matrix(1, 30, 5) + 0.5 * matrix(rnorm(30 * 5), 30, 5)
u &lt;- pseudo_obs(x)

## fit and select the model structure, family and parameters
fit &lt;- vinecop(u)
summary(fit)
plot(fit)
contour(fit)

## select by log-likelihood criterion from one-paramter families
fit &lt;- vinecop(u, family_set = "onepar", selcrit = "bic")
summary(fit)

## Gaussian D-vine
fit &lt;- vinecop(u, structure = dvine_structure(1:5), family = "gauss")
plot(fit)
contour(fit)

## Partial structure selection with only first tree specified
structure &lt;- rvine_structure(order = 1:5, list(rep(5, 4)))
structure
fit &lt;- vinecop(u, structure = structure, family = "gauss")
plot(fit)

## 1-truncated model with random structure
fit &lt;- vinecop(u, structure = rvine_structure_sim(5), trunc_lvl = 1)
contour(fit)

## Model for discrete data
x &lt;- qpois(u, 1)  # transform to Poisson margins
# we require two types of observations (see Details)
u_disc &lt;- cbind(ppois(x, 1), ppois(x - 1, 1))
fit &lt;- vinecop(u_disc, var_types = rep("d", 5))

## Model for mixed data
x &lt;- qpois(u[, 1], 1)  # transform first variable to Poisson margin
# we require two types of observations (see Details)
u_disc &lt;- cbind(ppois(x, 1), u[, 2:5], ppois(x - 1, 1))
fit &lt;- vinecop(u_disc, var_types = c("d", rep("c", 4)))
</code></pre>

<hr>
<h2 id='vinecop_dist'>Vine copula models</h2><span id='topic+vinecop_dist'></span>

<h3>Description</h3>

<p>Create custom vine copula models by specifying the pair-copulas, structure,
and variable types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vinecop_dist(pair_copulas, structure, var_types = rep("c", dim(structure)[1]))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vinecop_dist_+3A_pair_copulas">pair_copulas</code></td>
<td>
<p>A nested list of '<code><a href="#topic+bicop_dist">bicop_dist()</a></code>' objects, where
<code>pair_copulas[[t]][[e]]</code> corresponds to the pair-copula at edge <code>e</code> in
tree <code>t</code>.</p>
</td></tr>
<tr><td><code id="vinecop_dist_+3A_structure">structure</code></td>
<td>
<p>an <code>rvine_structure</code> object, namely a compressed
representation of the vine structure, or an object that can be coerced into
one (see <code><a href="#topic+rvine_structure">rvine_structure()</a></code> and <code><a href="#topic+as_rvine_structure">as_rvine_structure()</a></code>). The dimension
must be <code>length(pair_copulas[[1]]) + 1</code>; <code>structure = NA</code> performs
automatic selection based on Dissman's algorithm. See <em>Details</em> for partial
selection of the structure.</p>
</td></tr>
<tr><td><code id="vinecop_dist_+3A_var_types">var_types</code></td>
<td>
<p>variable types, a length d vector; e.g., <code>c("c", "c")</code> for
two continuous variables, or <code>c("c", "d")</code> for first variable continuous
and second discrete.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>vinecop_dist</code>, i.e., a list containing:
</p>

<ul>
<li> <p><code>pair_copulas</code>, a list of lists. Each element of <code>pair_copulas</code> corresponds
to a tree, which is itself a list of <code><a href="#topic+bicop_dist">bicop_dist()</a></code> objects.
</p>
</li>
<li> <p><code>structure</code>, a compressed representation of the vine structure, or an
object that can be coerced into one (see <code><a href="#topic+rvine_structure">rvine_structure()</a></code> and
<code><a href="#topic+as_rvine_structure">as_rvine_structure()</a></code>).
</p>
</li>
<li> <p><code>npars</code>, a <code>numeric</code> with the number of (effective) parameters.
</p>
</li>
<li> <p><code>var_types</code> the variable types.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+rvine_structure">rvine_structure()</a></code>, <code><a href="#topic+rvine_matrix">rvine_matrix()</a></code>, <code><a href="#topic+vinecop">vinecop()</a></code>,
<code><a href="#topic+plot.vinecop_dist">plot.vinecop_dist()</a></code>, <code><a href="#topic+contour.vinecop_dist">contour.vinecop_dist()</a></code>, <code><a href="#topic+dvinecop">dvinecop()</a></code>,
<code><a href="#topic+pvinecop">pvinecop()</a></code>, <code><a href="#topic+rvinecop">rvinecop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify pair-copulas
bicop &lt;- bicop_dist("bb1", 90, c(3, 2))
pcs &lt;- list(
  list(bicop, bicop), # pair-copulas in first tree
  list(bicop) # pair-copulas in second tree
)

# specify R-vine matrix
mat &lt;- matrix(c(1, 2, 3, 1, 2, 0, 1, 0, 0), 3, 3)

# set up vine copula model
vc &lt;- vinecop_dist(pcs, mat)

# visualization
plot(vc)
contour(vc)

# simulate from the model
pairs(rvinecop(200, vc))
</code></pre>

<hr>
<h2 id='vinecop_distributions'>Vine copula distributions</h2><span id='topic+vinecop_distributions'></span><span id='topic+dvinecop'></span><span id='topic+pvinecop'></span><span id='topic+rvinecop'></span><span id='topic+dvinecop_dist'></span><span id='topic+pvinecop_dist'></span><span id='topic+rvinecop_dist'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for the vine copula
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dvinecop(u, vinecop, cores = 1)

pvinecop(u, vinecop, n_mc = 10^4, cores = 1)

rvinecop(n, vinecop, qrng = FALSE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vinecop_distributions_+3A_u">u</code></td>
<td>
<p>matrix of evaluation points; must contain at least d columns, where
d is the number of variables in the vine. More columns are required for
discrete models, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="vinecop_distributions_+3A_vinecop">vinecop</code></td>
<td>
<p>an object of class <code>"vinecop_dist"</code>.</p>
</td></tr>
<tr><td><code id="vinecop_distributions_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if larger than one, computations are
done in parallel on <code>cores</code> batches .</p>
</td></tr>
<tr><td><code id="vinecop_distributions_+3A_n_mc">n_mc</code></td>
<td>
<p>number of samples used for quasi Monte Carlo integration.</p>
</td></tr>
<tr><td><code id="vinecop_distributions_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="vinecop_distributions_+3A_qrng">qrng</code></td>
<td>
<p>if <code>TRUE</code>, generates quasi-random numbers using the multivariate
Generalized Halton sequence up to dimension 300 and the Generalized Sobol
sequence in higher dimensions (default <code>qrng = FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+vinecop">vinecop()</a></code> for the estimation and construction of vine copula
models.
</p>
<p>The copula density is defined as joint density divided by marginal
densities, irrespective of variable types.
</p>


<h4>Discrete variables</h4>

<p>When at least one variable is discrete, two types of
&quot;observations&quot; are required in <code>u</code>: the first <code class="reqn">n \; x \; d</code> block
contains realizations of <code class="reqn">F_{X_j}(X_j)</code>. The second <code class="reqn">n \; x \; d</code>
block contains realizations of <code class="reqn">F_{X_j}(X_j^-)</code>. The minus indicates a
left-sided limit of the cdf. For, e.g., an integer-valued variable, it holds
<code class="reqn">F_{X_j}(X_j^-) = F_{X_j}(X_j - 1)</code>. For continuous variables the left
limit and the cdf itself coincide. Respective columns can be omitted in the
second block.
</p>



<h3>Value</h3>

<p><code>dvinecop()</code> gives the density, <code>pvinecop()</code> gives the distribution function,
and <code>rvinecop()</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rvinecop()</code>, and
the number of rows in <code>u</code> for the other functions.
</p>
<p>The <code>vinecop</code> object is recycled to the length of the
result.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vinecop_dist">vinecop_dist()</a></code>, <code><a href="#topic+vinecop">vinecop()</a></code>, <code><a href="#topic+plot.vinecop">plot.vinecop()</a></code>, <code><a href="#topic+contour.vinecop">contour.vinecop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate dummy data
x &lt;- rnorm(30) * matrix(1, 30, 5) + 0.5 * matrix(rnorm(30 * 5), 30, 5)
u &lt;- pseudo_obs(x)

## fit a model
vc &lt;- vinecop(u, family = "clayton")

# simulate from the model
u &lt;- rvinecop(100, vc)
pairs(u)

# evaluate the density and cdf
dvinecop(u[1, ], vc)
pvinecop(u[1, ], vc)

## Discrete models
vc$var_types &lt;- rep("d", 5)  # convert model to discrete

# with discrete data we need two types of observations (see Details)
x &lt;- qpois(u, 1)  # transform to Poisson margins
u_disc &lt;- cbind(ppois(x, 1), ppois(x - 1, 1))

dvinecop(u_disc[1:5, ], vc)
pvinecop(u_disc[1:5, ], vc)

# simulated data always has uniform margins
pairs(rvinecop(200, vc))
</code></pre>

<hr>
<h2 id='vinecop_predict_and_fitted'>Predictions and fitted values for a vine copula model</h2><span id='topic+vinecop_predict_and_fitted'></span><span id='topic+predict.vinecop'></span><span id='topic+fitted.vinecop'></span>

<h3>Description</h3>

<p>Predictions of the density and distribution function
for a vine copula model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vinecop'
predict(object, newdata, what = "pdf", n_mc = 10^4, cores = 1, ...)

## S3 method for class 'vinecop'
fitted(object, what = "pdf", n_mc = 10^4, cores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vinecop_predict_and_fitted_+3A_object">object</code></td>
<td>
<p>a <code>vinecop</code> object.</p>
</td></tr>
<tr><td><code id="vinecop_predict_and_fitted_+3A_newdata">newdata</code></td>
<td>
<p>points where the fit shall be evaluated.</p>
</td></tr>
<tr><td><code id="vinecop_predict_and_fitted_+3A_what">what</code></td>
<td>
<p>what to predict, either <code>"pdf"</code> or <code>"cdf"</code>.</p>
</td></tr>
<tr><td><code id="vinecop_predict_and_fitted_+3A_n_mc">n_mc</code></td>
<td>
<p>number of samples used for quasi Monte Carlo integration when
<code>what = "cdf"</code>.</p>
</td></tr>
<tr><td><code id="vinecop_predict_and_fitted_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if larger than one, computations are
done in parallel on <code>cores</code> batches.</p>
</td></tr>
<tr><td><code id="vinecop_predict_and_fitted_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitted()</code> can only be called if the model was fit with the
<code>keep_data = TRUE</code> option.
</p>


<h4>Discrete variables</h4>

<p>When at least one variable is discrete, two types of
&quot;observations&quot; are required in <code>newdata</code>: the first <code class="reqn">n \; x \; d</code> block
contains realizations of <code class="reqn">F_{X_j}(X_j)</code>. The second <code class="reqn">n \; x \; d</code>
block contains realizations of <code class="reqn">F_{X_j}(X_j^-)</code>. The minus indicates a
left-sided limit of the cdf. For, e.g., an integer-valued variable, it holds
<code class="reqn">F_{X_j}(X_j^-) = F_{X_j}(X_j - 1)</code>. For continuous variables the left
limit and the cdf itself coincide. Respective columns can be omitted in the
second block.
</p>



<h3>Value</h3>

<p><code>fitted()</code> and <code>predict()</code> have return values similar to <code><a href="#topic+dvinecop">dvinecop()</a></code>
and <code><a href="#topic+pvinecop">pvinecop()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- sapply(1:5, function(i) runif(50))
fit &lt;- vinecop(u, family = "par", keep_data = TRUE)
all.equal(predict(fit, u), fitted(fit), check.environment = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
