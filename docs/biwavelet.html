<!DOCTYPE html><html><head><title>Help for package biwavelet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {biwavelet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biwavelet-package'><p>Conduct Univariate and Bivariate Wavelet Analyses</p></a></li>
<li><a href='#ar1_ma0_sim'><p>Slightly faster <code>arima.sim</code> implementation which assumes AR(1)</p>
and <code>ma=0</code>.</a></li>
<li><a href='#ar1.spectrum'><p>Power spectrum of a random red noise process</p></a></li>
<li><a href='#arrow'><p>Helper function for <code>phase.plot</code> (not exported)</p></a></li>
<li><a href='#arrow2'><p>This is an alternative helper function that plots arrows.</p>
It uses <code>text()</code> to print a character using a default font.
This way, it is possible to render different types of arrows.</a></li>
<li><a href='#check.data'><p>Check the format of time series</p></a></li>
<li><a href='#check.datum'><p>Helper function</p></a></li>
<li><a href='#convolve2D'><p>Fast column-wise convolution of a matrix</p></a></li>
<li><a href='#convolve2D_typeopen'><p>Speed-optimized version of convolve2D</p></a></li>
<li><a href='#enviro.data'><p>Multivariate ENSO (MEI), NPGO, and PDO indices</p></a></li>
<li><a href='#get_minroots'><p>Helper function (not exported)</p></a></li>
<li><a href='#MOTHERS'><p>Supported mother wavelets</p></a></li>
<li><a href='#phase.plot'><p>Plot phases with arrows</p></a></li>
<li><a href='#plot.biwavelet'><p>Plot <code>biwavelet</code> objects</p></a></li>
<li><a href='#pwtc'><p>Compute partial wavelet coherence</p></a></li>
<li><a href='#rcpp_row_quantile'><p>Row-wise quantile of a matrix</p></a></li>
<li><a href='#rcpp_wt_bases_dog'><p>Optimized &quot;wt.bases.dog&quot; function.</p></a></li>
<li><a href='#rcpp_wt_bases_morlet'><p>Optimized &quot;wt.bases.morlet&quot; function.</p></a></li>
<li><a href='#rcpp_wt_bases_paul'><p>Optimized &quot;wt.bases.paul&quot; function.</p></a></li>
<li><a href='#smooth.wavelet'><p>Smooth wavelet in both the time and scale domains</p></a></li>
<li><a href='#wclust'><p>Compute dissimilarity between multiple wavelet spectra</p></a></li>
<li><a href='#wdist'><p>Compute dissimilarity between two wavelet spectra</p></a></li>
<li><a href='#wt'><p>Compute wavelet transform</p></a></li>
<li><a href='#wt.bases'><p>Compute wavelet</p></a></li>
<li><a href='#wt.bases.dog'><p>Helper method (not exported)</p></a></li>
<li><a href='#wt.bases.morlet'><p>Helper method (not exported)</p></a></li>
<li><a href='#wt.bases.paul'><p>Helper method (not exported)</p></a></li>
<li><a href='#wt.sig'><p>Determine significance of wavelet transform</p></a></li>
<li><a href='#wtc'><p>Compute wavelet coherence</p></a></li>
<li><a href='#wtc_sig_parallel'><p>Parallel <code>wtc.sig</code></p></a></li>
<li><a href='#wtc.sig'><p>Determine significance of wavelet coherence</p></a></li>
<li><a href='#xwt'><p>Compute cross-wavelet</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Conduct Univariate and Bivariate Wavelet Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>0.20.21</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Tarik C. Gouhier, Aslak Grinsted, Viliam Simko</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tarik C. Gouhier &lt;tarik.gouhier@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This is a port of the WTC MATLAB package written by Aslak Grinsted
    and the wavelet program written by Christopher Torrence and Gibert P.
    Compo. This package can be used to perform univariate and bivariate
    (cross-wavelet, wavelet coherence, wavelet clustering) analyses.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tgouhier/biwavelet">https://github.com/tgouhier/biwavelet</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tgouhier/biwavelet/issues">https://github.com/tgouhier/biwavelet/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>fields, foreach, Rcpp (&ge; 0.12.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, devtools</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-25 14:36:13 UTC; tarik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-26 05:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='biwavelet-package'>Conduct Univariate and Bivariate Wavelet Analyses</h2><span id='topic+biwavelet-package'></span><span id='topic+biwavelet'></span>

<h3>Description</h3>

<p>This is a port of the WTC MATLAB package written by Aslak Grinsted and the
wavelet program written by Christopher Torrence and Gibert P. Compo. This
package can be used to perform univariate and bivariate (cross-wavelet,
wavelet coherence, wavelet clustering) wavelet analyses.
</p>


<h3>Details</h3>

<p>As of biwavelet version 0.14, the bias-corrected wavelet and cross-wavelet spectra
are automatically computed and plotted by default using the methods
described by Liu et al. (2007) and Veleda et al. (2012). This correction
is needed because the traditional approach for computing the power spectrum
(e.g., Torrence and Compo 1998) leads to an artificial and systematic reduction
in power at lower periods.
</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier
</p>
<p>Maintainer: Tarik C. Gouhier &lt;tarik.gouhier@gmail.com&gt;
</p>
<p>Code based on WTC MATLAB package written by Aslak Grinsted and the wavelet
MATLAB program written by Christopher Torrence and Gibert P. Compo.
</p>


<h3>References</h3>

<p>Cazelles, B., M. Chavez, D. Berteaux, F. Menard, J. O. Vik, S. Jenouvrier,
and N. C. Stenseth. 2008. Wavelet analysis of ecological time series.
<em>Oecologia</em> 156:287-304.
</p>
<p>Grinsted, A., J. C. Moore, and S. Jevrejeva. 2004. Application of the cross
wavelet transform and wavelet coherence to geophysical time series.
<em>Nonlinear Processes in Geophysics</em> 11:561-566.
</p>
<p>Liu, Y., X. San Liang, and R. H. Weisberg. 2007. Rectification of the Bias in
the Wavelet Power Spectrum. <em>Journal of Atmospheric and Oceanic Technology</em>
24:2093-2102.
</p>
<p>Rouyer, T., J. M. Fromentin, F. Menard, B. Cazelles, K. Briand, R. Pianet,
B. Planque, and N. C. Stenseth. 2008. Complex interplays among population
dynamics, environmental forcing, and exploitation in fisheries.
<em>Proceedings of the National Academy of Sciences</em> 105:5420-5425.
</p>
<p>Rouyer, T., J. M. Fromentin, N. C. Stenseth, and B. Cazelles. 2008.
Analysing multiple time series and extending significance testing in
wavelet analysis. <em>Marine Ecology Progress Series</em> 359:11-23.
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
<em>Bulletin of the American Meteorological Society</em> 79:61-78.
</p>
<p>Torrence, C., and P. J. Webster. 1998. The annual cycle of persistence in the
El Nino/Southern Oscillation.
<em>Quarterly Journal of the Royal Meteorological Society</em> 124:1985-2004.
</p>
<p>Veleda, D., R. Montagne, and M. Araujo. 2012. Cross-Wavelet Bias Corrected by Normalizing Scales.
<em>Journal of Atmospheric and Oceanic Technology</em> 29:1401-1408.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># As of biwavelet version 0.14, the bias-corrected wavelet and cross-wavelet spectra
# are automatically computed and plotted by default using the methods
# described by Liu et al. (2007) and Veleda et al. (2012). This correction
# is needed because the traditional approach for computing the power spectrum
# (e.g., Torrence and Compo 1998) leads to an artificial and systematic reduction
# in power at low periods.

# EXAMPLE OF BIAS CORRECTION:
require(biwavelet)
# Generate a synthetic time series 's' with the same power at three distinct periods
t1=sin(seq(from=0, to=2*5*pi, length=1000))
t2=sin(seq(from=0, to=2*15*pi, length=1000))
t3=sin(seq(from=0, to=2*40*pi, length=1000))
s=t1+t2+t3

# Compare non-corrected vs. corrected wavelet spectrum
wt1=wt(cbind(1:1000, s))
par(mfrow=c(1,2))
plot(wt1, type="power.corr.norm", main="Bias-corrected")
plot(wt1, type="power.norm", main="Not-corrected")

# ADDITIONAL EXAMPLES
t1 &lt;- cbind(1:100, rnorm(100))
t2 &lt;- cbind(1:100, rnorm(100))

# Continuous wavelet transform
wt.t1 &lt;- wt(t1)

# Plot power
# Make room to the right for the color bar
par(oma = c(0, 0, 0, 1), mar = c(5, 4, 4, 5) + 0.1)
plot(wt.t1, plot.cb=TRUE, plot.phase=FALSE)

# Compute cross-wavelet
xwt.t1t2 &lt;- xwt(t1, t2)

# Plot cross wavelet power and phase difference (arrows)
plot(xwt.t1t2, plot.cb=TRUE)

# Wavelet coherence; nrands should be large (&gt;= 1000)
wtc.t1t2=wtc(t1, t2, nrands=10)
# Plot wavelet coherence and phase difference (arrows)
# Make room to the right for the color bar
par(oma=c(0, 0, 0, 1), mar=c(5, 4, 4, 5) + 0.1)
plot(wtc.t1t2, plot.cb=TRUE)

# Perform wavelet clustering of three time series
t1=cbind(1:100, sin(seq(from=0, to=10*2*pi, length.out=100)))
t2=cbind(1:100, sin(seq(from=0, to=10*2*pi, length.out=100)+0.1*pi))
t3=cbind(1:100, rnorm(100))

# Compute wavelet spectra
wt.t1=wt(t1)
wt.t2=wt(t2)
wt.t3=wt(t3)

# Store all wavelet spectra into array
w.arr=array(NA, dim=c(3, NROW(wt.t1$wave), NCOL(wt.t1$wave)))
w.arr[1, , ]=wt.t1$wave
w.arr[2, , ]=wt.t2$wave
w.arr[3, , ]=wt.t3$wave

# Compute dissimilarity and distance matrices
w.arr.dis &lt;- wclust(w.arr)
plot(hclust(w.arr.dis$dist.mat, method = "ward.D"), sub = "", main = "",
     ylab = "Dissimilarity", hang = -1)
</code></pre>

<hr>
<h2 id='ar1_ma0_sim'>Slightly faster <code><a href="stats.html#topic+arima.sim">arima.sim</a></code> implementation which assumes AR(1)
and <code>ma=0</code>.</h2><span id='topic+ar1_ma0_sim'></span>

<h3>Description</h3>

<p>Slightly faster <code><a href="stats.html#topic+arima.sim">arima.sim</a></code> implementation which assumes AR(1)
and <code>ma=0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar1_ma0_sim(minroots, ar, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar1_ma0_sim_+3A_minroots">minroots</code></td>
<td>
<p>Output from <code><a href="#topic+get_minroots">get_minroots</a></code> function.</p>
</td></tr>
<tr><td><code id="ar1_ma0_sim_+3A_ar">ar</code></td>
<td>
<p>The 'ar' part of AR(1)</p>
</td></tr>
<tr><td><code id="ar1_ma0_sim_+3A_n">n</code></td>
<td>
<p>Length of output series, before un-differencing. A strictly positive
integer.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+arima.sim">arima.sim</a></code>
</p>

<hr>
<h2 id='ar1.spectrum'>Power spectrum of a random red noise process</h2><span id='topic+ar1.spectrum'></span>

<h3>Description</h3>

<p>Generate the power spectrum of a random time series with a specific AR(1)
coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar1.spectrum(ar1, periods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar1.spectrum_+3A_ar1">ar1</code></td>
<td>
<p>First order coefficient desired.</p>
</td></tr>
<tr><td><code id="ar1.spectrum_+3A_periods">periods</code></td>
<td>
<p>Periods of the time series at which the spectrum should be
computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the power spectrum as a vector of real numbers.
</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
Code based on WTC MATLAB package written by Aslak Grinsted.
</p>


<h3>References</h3>

<p>Cazelles, B., M. Chavez, D. Berteaux, F. Menard, J. O. Vik, S. Jenouvrier,
and N. C. Stenseth. 2008. Wavelet analysis of ecological time series.
<em>Oecologia</em> 156:287-304.
</p>
<p>Grinsted, A., J. C. Moore, and S. Jevrejeva. 2004. Application of the cross
wavelet transform and wavelet coherence to geophysical time series.
<em>Nonlinear Processes in Geophysics</em> 11:561-566.
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
<em>Bulletin of the American Meteorological Society</em> 79:61-78.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ar1.spectrum(0.5, 1:25)

</code></pre>

<hr>
<h2 id='arrow'>Helper function for <code><a href="#topic+phase.plot">phase.plot</a></code> (not exported)</h2><span id='topic+arrow'></span>

<h3>Description</h3>

<p>Helper function for <code><a href="#topic+phase.plot">phase.plot</a></code> (not exported)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrow(x, y, l = 0.1, w = 0.3 * l, alpha, col = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrow_+3A_x">x</code></td>
<td>
<p>X-coordinate of the arrow.</p>
</td></tr>
<tr><td><code id="arrow_+3A_y">y</code></td>
<td>
<p>Y-coordinate of the arrow.</p>
</td></tr>
<tr><td><code id="arrow_+3A_l">l</code></td>
<td>
<p>Length of the arrow.</p>
</td></tr>
<tr><td><code id="arrow_+3A_w">w</code></td>
<td>
<p>Width of the arrow.</p>
</td></tr>
<tr><td><code id="arrow_+3A_alpha">alpha</code></td>
<td>
<p>Angle of the arrow in radians (0 .. 2*pi).</p>
</td></tr>
<tr><td><code id="arrow_+3A_col">col</code></td>
<td>
<p>Color of the arrow.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plot.new()
arrow(0,0, alpha = 0)
</code></pre>

<hr>
<h2 id='arrow2'>This is an alternative helper function that plots arrows.
It uses <code><a href="graphics.html#topic+text">text</a>()</code> to print a character using a default font.
This way, it is possible to render different types of arrows.</h2><span id='topic+arrow2'></span>

<h3>Description</h3>

<p>This is an alternative helper function that plots arrows.
It uses <code><a href="graphics.html#topic+text">text</a>()</code> to print a character using a default font.
This way, it is possible to render different types of arrows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrow2(x, y, angle, size = 0.1, col = "black", chr = intToUtf8(10139))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrow2_+3A_x">x</code></td>
<td>
<p>X-coordinate of the arrow.</p>
</td></tr>
<tr><td><code id="arrow2_+3A_y">y</code></td>
<td>
<p>Y-coordinate of the arrow.</p>
</td></tr>
<tr><td><code id="arrow2_+3A_angle">angle</code></td>
<td>
<p>Angle in radians.</p>
</td></tr>
<tr><td><code id="arrow2_+3A_size">size</code></td>
<td>
<p>Similar to <code>arrow.len</code> parameter. Notice that we don't need
the <code>arrow.lwd</code> anymore</p>
</td></tr>
<tr><td><code id="arrow2_+3A_col">col</code></td>
<td>
<p>Color of the arrow.</p>
</td></tr>
<tr><td><code id="arrow2_+3A_chr">chr</code></td>
<td>
<p>Character representing the arrow. You should provide the character
as escaped UTF-8.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Viliam Simko
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not run: arrow2(x[j], y[i], angle = phases[i, j],
# Not run:        col = arrow.col, size = arrow.len)
</code></pre>

<hr>
<h2 id='check.data'>Check the format of time series</h2><span id='topic+check.data'></span>

<h3>Description</h3>

<p>Check the format of time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.data(y, x1 = NULL, x2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.data_+3A_y">y</code></td>
<td>
<p>Time series <code>y</code> in matrix format (<code>n</code> rows x 2 columns).
The first column should contain the time steps and the second column should
contain the values.</p>
</td></tr>
<tr><td><code id="check.data_+3A_x1">x1</code></td>
<td>
<p>Time series <code>x1</code> in matrix format (<code>n</code> rows x 2 columns).
The first column should contain the time steps and the second column should
contain the values.</p>
</td></tr>
<tr><td><code id="check.data_+3A_x2">x2</code></td>
<td>
<p>Time series <code>x2</code> in matrix format (<code>n</code> rows x 2 columns).
The first column should contain the time steps and the second column should
contain the values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing:
</p>
<table>
<tr><td><code>t</code></td>
<td>
<p>Time steps</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>Size of a time step</p>
</td></tr>
<tr><td><code>n.obs</code></td>
<td>
<p>Number of observations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
<em>Bulletin of the American Meteorological Society</em> 79:61-78.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- cbind(1:100, rnorm(100))
check.data(y = t1)

</code></pre>

<hr>
<h2 id='check.datum'>Helper function</h2><span id='topic+check.datum'></span>

<h3>Description</h3>

<p>Helper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.datum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.datum_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(t, dt, n.obs)
</p>


<h3>Note</h3>

<p>This function is not exported
</p>

<hr>
<h2 id='convolve2D'>Fast column-wise convolution of a matrix</h2><span id='topic+convolve2D'></span>

<h3>Description</h3>

<p>Use the Fast Fourier Transform to perform convolutions between a sequence and
each column of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convolve2D(x, y, conj = TRUE, type = c("circular", "open"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convolve2D_+3A_x">x</code></td>
<td>
<p>M <code>x</code> n matrix.</p>
</td></tr>
<tr><td><code id="convolve2D_+3A_y">y</code></td>
<td>
<p>Numeric sequence of length N.</p>
</td></tr>
<tr><td><code id="convolve2D_+3A_conj">conj</code></td>
<td>
<p>Logical; if <code>TRUE</code>, take the complex conjugate before
back-transforming. <code>TRUE</code> is used for usual convolution.</p>
</td></tr>
<tr><td><code id="convolve2D_+3A_type">type</code></td>
<td>
<p>Character; one of <code>circular</code>, <code>open</code> (beginning of word
is ok).
</p>
<p>For <code>circular</code>, the two sequences are treated as circular, i.e.,
periodic.
</p>
<p>For <code>open</code> and <code>filter</code>, the sequences are padded with zeros
(from left and right) first; <code>filter</code> returns the middle sub-vector of
open, namely, the result of running a weighted mean of <code>x</code> with
weights <code>y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a corrupted version of convolve made by replacing
<code><a href="stats.html#topic+fft">fft</a></code> with <code><a href="stats.html#topic+mvfft">mvfft</a></code> in a few places. It would be
nice to submit this to the R Developers for inclusion.
</p>


<h3>Value</h3>

<p>M <code>x</code> n matrix
</p>


<h3>Note</h3>

<p>This function was copied from <code>waveslim</code> to limit package
dependencies.
</p>


<h3>Author(s)</h3>

<p>Brandon Whitcher
</p>

<hr>
<h2 id='convolve2D_typeopen'>Speed-optimized version of convolve2D</h2><span id='topic+convolve2D_typeopen'></span>

<h3>Description</h3>

<p>Equivalent to <code>convolve2D(x, y, type = "open")</code>. The motivation for this
function was that convolution is called many times in a loop from
<code><a href="#topic+smooth.wavelet">smooth.wavelet</a></code>, always with the <code>type = "open"</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convolve2D_typeopen(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convolve2D_typeopen_+3A_x">x</code></td>
<td>
<p>M <code>x</code> n matrix.</p>
</td></tr>
<tr><td><code id="convolve2D_typeopen_+3A_y">y</code></td>
<td>
<p>Numeric sequence of length N.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Viliam Simko
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convolve2D">convolve2D</a></code>
</p>

<hr>
<h2 id='enviro.data'>Multivariate ENSO (MEI), NPGO, and PDO indices</h2><span id='topic+enviro.data'></span>

<h3>Description</h3>

<p>Monthly indices of ENSO, NPGO, and PDO from 1950 to 2009
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(enviro.data)
</code></pre>


<h3>Format</h3>

<p>A data frame with 720 observations on the following 6 variables.
</p>

<dl>
<dt><code>month</code></dt><dd><p>a numeric vector containing the month</p>
</dd>
<dt><code>year</code></dt><dd><p>a numeric vector containing the year</p>
</dd>
<dt><code>date</code></dt><dd><p>a numeric vecor containing the date</p>
</dd>
<dt><code>mei</code></dt><dd><p>a numeric vector containing the MEI index</p>
</dd>
<dt><code>npgo</code></dt><dd><p>a numeric vector containing the NPGO index</p>
</dd>
<dt><code>pdo</code></dt><dd><p>a numeric vector containing the PDO index</p>
</dd>
</dl>



<h3>Source</h3>

<p>MEI: <a href="https://psl.noaa.gov/enso/mei/">https://psl.noaa.gov/enso/mei/</a>
</p>
<p>NPGO: <a href="http://www.o3d.org/npgo/">http://www.o3d.org/npgo/</a>
</p>
<p>PDO: <a href="http://research.jisao.washington.edu/pdo/">http://research.jisao.washington.edu/pdo/</a>
</p>


<h3>References</h3>

<p>Di Lorenzo, E., N. Schneider, K. M. Cobb, P. J. S. Franks, K. Chhak, A. J. Miller,
J. C. McWilliams, S. J. Bograd, H. Arango, E. Curchitser, T. M. Powell, and
P. Riviere. 2008. North Pacific Gyre Oscillation links ocean climate and
ecosystem change. <em>Geophys. Res. Lett.</em> 35:L08607.
</p>
<p>Mantua, N. J., and S. R. Hare. 2002. The Pacific decadal oscillation.
<em>Journal of Oceanography</em> 58:35-44.
</p>
<p>Zhang, Y., J. M. Wallace, and D. S. Battisti. 1997. ENSO-like interdecadal
variability: 1900-93. <em>Journal of Climate</em> 10:1004-1020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(enviro.data)
head(enviro.data)

</code></pre>

<hr>
<h2 id='get_minroots'>Helper function (not exported)</h2><span id='topic+get_minroots'></span>

<h3>Description</h3>

<p>Helper function (not exported)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_minroots(ar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_minroots_+3A_ar">ar</code></td>
<td>
<p>The 'ar' part of AR(1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>

<hr>
<h2 id='MOTHERS'>Supported mother wavelets</h2><span id='topic+MOTHERS'></span>

<h3>Description</h3>

<p>The list of supported mother wavelets is used in multiple places
therefore, we provide it as a lazily evaluated promise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MOTHERS
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 3.
</p>

<hr>
<h2 id='phase.plot'>Plot phases with arrows</h2><span id='topic+phase.plot'></span>

<h3>Description</h3>

<p>Plot phases with arrows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase.plot(
  x,
  y,
  phases,
  arrow.len = min(par()$pin[2]/30, par()$pin[1]/40),
  arrow.col = "black",
  arrow.lwd = arrow.len * 0.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase.plot_+3A_x">x</code></td>
<td>
<p>X-coordinates</p>
</td></tr>
<tr><td><code id="phase.plot_+3A_y">y</code></td>
<td>
<p>Y-coordinates</p>
</td></tr>
<tr><td><code id="phase.plot_+3A_phases">phases</code></td>
<td>
<p>Phases</p>
</td></tr>
<tr><td><code id="phase.plot_+3A_arrow.len">arrow.len</code></td>
<td>
<p>Size of the arrows. Default is based on plotting region.</p>
</td></tr>
<tr><td><code id="phase.plot_+3A_arrow.col">arrow.col</code></td>
<td>
<p>Arrow line color.</p>
</td></tr>
<tr><td><code id="phase.plot_+3A_arrow.lwd">arrow.lwd</code></td>
<td>
<p>Width/thickness of arrows.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Arrows pointing to the right mean that <code>x</code> and <code>y</code> are in phase.
</p>
<p>Arrows pointing to the left mean that <code>x</code> and <code>y</code> are in anti-phase.
</p>
<p>Arrows pointing up mean that <code>y</code> leads <code>x</code> by <code class="reqn">\pi/2</code>.
</p>
<p>Arrows pointing down mean that <code>x</code> leads <code>y</code> by <code class="reqn">\pi/2</code>.
</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>
<p>Huidong Tian provided a much better implementation of the phase.plot function
that allows for more accurate phase arrows.
</p>
<p>Original code based on WTC MATLAB package written by Aslak Grinsted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not run: phase.plot(x, y, phases)

</code></pre>

<hr>
<h2 id='plot.biwavelet'>Plot <code>biwavelet</code> objects</h2><span id='topic+plot.biwavelet'></span>

<h3>Description</h3>

<p>Plot <code>biwavelet</code> objects such as the cwt, cross-wavelet and wavelet
coherence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biwavelet'
plot(
  x,
  ncol = 64,
  fill.cols = NULL,
  xlab = "Time",
  ylab = "Period",
  tol = 1,
  plot.cb = FALSE,
  plot.phase = FALSE,
  type = "power.corr.norm",
  plot.coi = TRUE,
  lwd.coi = 1,
  col.coi = "white",
  lty.coi = 1,
  alpha.coi = 0.5,
  plot.sig = TRUE,
  lwd.sig = 4,
  col.sig = "black",
  lty.sig = 1,
  bw = FALSE,
  legend.loc = NULL,
  legend.horiz = FALSE,
  arrow.len = min(par()$pin[2]/30, par()$pin[1]/40),
  arrow.lwd = arrow.len * 0.3,
  arrow.cutoff = 0.8,
  arrow.col = "black",
  xlim = NULL,
  ylim = NULL,
  zlim = NULL,
  xaxt = "s",
  yaxt = "s",
  form = "%Y",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.biwavelet_+3A_x">x</code></td>
<td>
<p><code>biwavelet</code> object generated by <code><a href="#topic+wt">wt</a></code>,
<code><a href="#topic+xwt">xwt</a></code>, or <code><a href="#topic+wtc">wtc</a></code>.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_ncol">ncol</code></td>
<td>
<p>Number of colors to use.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_fill.cols">fill.cols</code></td>
<td>
<p>Vector of fill colors to be used. Users can specify color
vectors using <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code> or
<code><a href="RColorBrewer.html#topic+brewer.pal">brewer.pal</a></code> from package
<code><a href="RColorBrewer.html#topic+RColorBrewer">RColorBrewer</a></code>. Value <code>NULL</code> generates
MATLAB's jet color palette.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_xlab">xlab</code></td>
<td>
<p>X-label of the figure.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_ylab">ylab</code></td>
<td>
<p>Y-label of the figure.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_tol">tol</code></td>
<td>
<p>Tolerance level for significance contours. Sigificance contours
will be drawn around all regions of the spectrum where
<code>spectrum/percentile &gt;= tol</code>. If strict <code class="reqn">i^{th}</code> percentile
regions are desired, then <code>tol</code> must be set to 1.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_plot.cb">plot.cb</code></td>
<td>
<p>Plot color bar if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_plot.phase">plot.phase</code></td>
<td>
<p>Plot phases with black arrows.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_type">type</code></td>
<td>
<p>Type of plot to create. Can be <code>power</code> to plot the power,
<code>power.corr</code> to plot the bias-corrected power, <code>power.norm</code> to
plot the power normalized by the variance, <code>power.corr.norm</code> to plot
the bias-corrected power normalized by the variance, <code>wavelet</code> to plot
the wavelet coefficients, or <code>phase</code> to plot the phase.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_plot.coi">plot.coi</code></td>
<td>
<p>Plot cone of influence (COI) as a semi-transparent polygon if
<code>TRUE</code>. Areas that fall within the polygon can be affected by edge
effects.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_lwd.coi">lwd.coi</code></td>
<td>
<p>Line width of COI.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_col.coi">col.coi</code></td>
<td>
<p>Color of COI.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_lty.coi">lty.coi</code></td>
<td>
<p>Line type of COI. Value 1 is for solide lines.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_alpha.coi">alpha.coi</code></td>
<td>
<p>Transparency of COI. Range is 0 (full transparency) to 1 (no
transparency).</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_plot.sig">plot.sig</code></td>
<td>
<p>Plot contours for significance if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_lwd.sig">lwd.sig</code></td>
<td>
<p>Line width of significance contours.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_col.sig">col.sig</code></td>
<td>
<p>Color of significance contours.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_lty.sig">lty.sig</code></td>
<td>
<p>Line type of significance contours.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_bw">bw</code></td>
<td>
<p>plot in black and white if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_legend.loc">legend.loc</code></td>
<td>
<p>Legend location coordinates as defined by
<code><a href="fields.html#topic+image.plot">image.plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_legend.horiz">legend.horiz</code></td>
<td>
<p>Plot a horizontal legend if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_arrow.len">arrow.len</code></td>
<td>
<p>Size of the arrows. Default is based on plotting region.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_arrow.lwd">arrow.lwd</code></td>
<td>
<p>Width/thickness of arrows.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_arrow.cutoff">arrow.cutoff</code></td>
<td>
<p>Cutoff value for plotting phase arrows. Phase arrows will
be be plotted in regions where the significance of the zvalues exceeds
<code>arrow.cutoff</code> for <code><a href="#topic+wt">wt</a></code> and <code><a href="#topic+xwt">xwt</a></code> objects. For
<code><a href="#topic+pwtc">pwtc</a></code> and <code><a href="#topic+wtc">wtc</a></code> objects, phase arrows will be
plotted in regions where the <code>rsq</code> value exceeds <code>arrow.cutoff</code>.
If the object being plotted does not have a significance field, regions
whose z-values exceed the <code>arrow.cutoff</code> quantile will be plotted.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_arrow.col">arrow.col</code></td>
<td>
<p>Color of arrows.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_xlim">xlim</code></td>
<td>
<p>The x limits.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_ylim">ylim</code></td>
<td>
<p>The y limits.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_zlim">zlim</code></td>
<td>
<p>The z limits.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_xaxt">xaxt</code></td>
<td>
<p>Add x-axis? Use <code>n</code> for none.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_yaxt">yaxt</code></td>
<td>
<p>Add y-axis? Use <code>n</code> for none.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_form">form</code></td>
<td>
<p>Format to use to display dates on the x-axis.
See <code><a href="base.html#topic+Date">Date</a></code> for other valid formats.</p>
</td></tr>
<tr><td><code id="plot.biwavelet_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arrows pointing to the right mean that <code>x</code> and <code>y</code> are in phase.
</p>
<p>Arrows pointing to the left mean that <code>x</code> and <code>y</code> are in anti-phase.
</p>
<p>Arrows pointing up mean that <code>y</code> leads <code>x</code> by <code class="reqn">\pi/2</code>.
</p>
<p>Arrows pointing down mean that <code>x</code> leads <code>y</code> by <code class="reqn">\pi/2</code>.
</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
Code based on WTC MATLAB package written by Aslak Grinsted.
</p>


<h3>References</h3>

<p>Cazelles, B., M. Chavez, D. Berteaux, F. Menard, J. O. Vik, S. Jenouvrier,
and N. C. Stenseth. 2008. Wavelet analysis of ecological time series.
<em>Oecologia</em> 156:287-304.
</p>
<p>Grinsted, A., J. C. Moore, and S. Jevrejeva. 2004. Application of the cross
wavelet transform and wavelet coherence to geophysical time series.
<em>Nonlinear Processes in Geophysics</em> 11:561-566.
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
<em>Bulletin of the American Meteorological Society</em> 79:61-78.
</p>
<p>Liu, Y., X. San Liang, and R. H. Weisberg. 2007. Rectification of the Bias in
the Wavelet Power Spectrum. <em>Journal of Atmospheric and Oceanic
Technology</em> 24:2093-2102.
</p>


<h3>See Also</h3>

<p><code><a href="fields.html#topic+image.plot">image.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- cbind(1:100, rnorm(100))
t2 &lt;- cbind(1:100, rnorm(100))

# Continuous wavelet transform
wt.t1 &lt;- wt(t1)

# Plot power
# Make room to the right for the color bar
par(oma = c(0, 0, 0, 1), mar = c(5, 4, 4, 5) + 0.1)
plot(wt.t1, plot.cb = TRUE, plot.phase = FALSE)

# Cross-wavelet transform
xwt.t1t2 &lt;- xwt(t1, t2)

# Plot cross-wavelet
par(oma = c(0, 0, 0, 1), mar = c(5, 4, 4, 5) + 0.1)
plot(xwt.t1t2, plot.cb = TRUE)

# Example of bias-correction
t1 &lt;- sin(seq(0, 2 * 5 * pi, length.out = 1000))
t2 &lt;- sin(seq(0, 2 * 15 * pi, length.out = 1000))
t3 &lt;- sin(seq(0, 2 * 40 * pi, length.out = 1000))

# This aggregate time series should have the same power
# at three distinct periods
s &lt;- t1 + t2 + t3

# Compare plots to see bias-effect on CWT:
# biased power spectrum artificially
# reduces the power of higher-frequency fluctuations.
wt1 &lt;- wt(cbind(1:1000, s))
par(mfrow = c(1,2))
plot(wt1, type = "power.corr.norm", main = "Bias-corrected")
plot(wt1, type = "power.norm", main = "Biased")

# Compare plots to see bias-effect on XWT:
# biased power spectrum artificially
# reduces the power of higher-frequency fluctuations.
x1 &lt;- xwt(cbind(1:1000, s), cbind(1:1000, s))
par(mfrow = c(1,2))

plot(x1, type = "power.corr.norm", main = "Bias-corrected")
plot(x1, type = "power.norm", main = "Biased")

</code></pre>

<hr>
<h2 id='pwtc'>Compute partial wavelet coherence</h2><span id='topic+pwtc'></span>

<h3>Description</h3>

<p>Compute partial wavelet coherence between <code>y</code> and <code>x1</code> by
partialling out the effect of <code>x2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwtc(
  y,
  x1,
  x2,
  pad = TRUE,
  dj = 1/12,
  s0 = 2 * dt,
  J1 = NULL,
  max.scale = NULL,
  mother = "morlet",
  param = -1,
  lag1 = NULL,
  sig.level = 0.95,
  sig.test = 0,
  nrands = 300,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwtc_+3A_y">y</code></td>
<td>
<p>Time series <code>y</code> in matrix format (<code>n</code> rows x 2 columns).
The first column should contain the time steps and the second column should
contain the values.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_x1">x1</code></td>
<td>
<p>Time series <code>x1</code> in matrix format (<code>n</code> rows x 2 columns).
The first column should contain the time steps and the second column should
contain the values.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_x2">x2</code></td>
<td>
<p>Time series <code>x2</code> whose effects should be partialled out in
matrix format (<code>n</code> rows x 2 columns). The first column should contain
the time steps and the second column should contain the values.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_pad">pad</code></td>
<td>
<p>Pad the values will with zeros to increase the speed of the
transform.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_dj">dj</code></td>
<td>
<p>Spacing between successive scales.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_s0">s0</code></td>
<td>
<p>Smallest scale of the wavelet.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_j1">J1</code></td>
<td>
<p>Number of scales - 1.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_max.scale">max.scale</code></td>
<td>
<p>Maximum scale. Computed automatically if left unspecified.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_mother">mother</code></td>
<td>
<p>Type of mother wavelet function to use. Can be set to
<code>morlet</code>, <code>dog</code>, or <code>paul</code>. Significance testing is only
available for <code>morlet</code> wavelet.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_param">param</code></td>
<td>
<p>Nondimensional parameter specific to the wavelet function.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_lag1">lag1</code></td>
<td>
<p>Vector containing the AR(1) coefficient of each time series.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_sig.test">sig.test</code></td>
<td>
<p>Type of significance test. If set to 0, use a regular
<code class="reqn">\chi^2</code> test. If set to 1, then perform a time-average test. If set to
2, then do a scale-average test.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_nrands">nrands</code></td>
<td>
<p>Number of Monte Carlo randomizations.</p>
</td></tr>
<tr><td><code id="pwtc_+3A_quiet">quiet</code></td>
<td>
<p>Do not display progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a <code>biwavelet</code> object containing:
</p>
<table>
<tr><td><code>coi</code></td>
<td>
<p>matrix containg cone of influence</p>
</td></tr>
<tr><td><code>wave</code></td>
<td>
<p>matrix containing the cross-wavelet transform of <code>y</code> and
<code>x1</code></p>
</td></tr>
<tr><td><code>rsq</code></td>
<td>
<p>matrix of partial wavelet coherence between <code>y</code> and <code>x1</code>
(with <code>x2</code> partialled out)</p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>matrix of phases between <code>y</code> and <code>x1</code></p>
</td></tr>
<tr><td><code>period</code></td>
<td>
<p>vector of periods</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>vector of scales</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>length of a time step</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>vector of times</p>
</td></tr>
<tr><td><code>xaxis</code></td>
<td>
<p>vector of values used to plot xaxis</p>
</td></tr>
<tr><td><code>s0</code></td>
<td>
<p>smallest scale of the wavelet </p>
</td></tr>
<tr><td><code>dj</code></td>
<td>
<p>spacing between successive scales</p>
</td></tr>
<tr><td><code>y.sigma</code></td>
<td>
<p>standard deviation of <code>y</code></p>
</td></tr>
<tr><td><code>x1.sigma</code></td>
<td>
<p>standard deviation of <code>x1</code></p>
</td></tr>
<tr><td><code>mother</code></td>
<td>
<p>mother wavelet used</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>type of <code>biwavelet</code> object created (<code><a href="#topic+pwtc">pwtc</a></code>)</p>
</td></tr>
<tr><td><code>signif</code></td>
<td>
<p>matrix containg <code>sig.level</code> percentiles of wavelet
coherence based on the Monte Carlo AR(1) time series</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The Monte Carlo randomizations can be extremely slow for large
datasets. For instance, 1000 randomizations of a dataset consisting of 1000
samples will take ~30 minutes on a 2.66 GHz dual-core Xeon processor.
</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
Code based on WTC MATLAB package written by Aslak Grinsted.
</p>


<h3>References</h3>

<p>Aguiar-Conraria, L., and M. J. Soares. 2013. The Continuous Wavelet
Transform: moving beyond uni- and bivariate analysis. <em>Journal of
Economic Surveys</em> In press.
</p>
<p>Cazelles, B., M. Chavez, D. Berteaux, F. Menard, J. O. Vik, S. Jenouvrier,
and N. C. Stenseth. 2008. Wavelet analysis of ecological time series.
<em>Oecologia</em> 156:287-304.
</p>
<p>Grinsted, A., J. C. Moore, and S. Jevrejeva. 2004. Application of the cross
wavelet transform and wavelet coherence to geophysical time series.
<em>Nonlinear Processes in Geophysics</em> 11:561-566.
</p>
<p>Ng, E. K. W., and J. C. L. Chan. 2012. Geophysical applications of partial
wavelet coherence and multiple wavelet coherence. <em>Journal of
Atmospheric and Oceanic Technology</em> 29:1845-1853.
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
<em>Bulletin of the American Meteorological Society</em> 79:61-78.
</p>
<p>Torrence, C., and P. J. Webster. 1998. The annual cycle of persistence in the
El Nino/Southern Oscillation. <em>Quarterly Journal of the Royal
Meteorological Society</em> 124:1985-2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- cbind(1:100, rnorm(100))
x1 &lt;- cbind(1:100, rnorm(100))
x2 &lt;- cbind(1:100, rnorm(100))

# Partial wavelet coherence of y and x1
pwtc.yx1 &lt;- pwtc(y, x1, x2, nrands = 0)

# Partial wavelet coherence of y and x2
pwtc.yx2 &lt;- pwtc(y, x2, x1, nrands = 0)

# Plot partial wavelet coherence and phase difference (arrows)
# Make room to the right for the color bar
par(mfrow = c(2,1), oma = c(4, 0, 0, 1),
    mar = c(1, 4, 4, 5), mgp = c(1.5, 0.5, 0))

plot(pwtc.yx1, xlab = "", plot.cb = TRUE,
     main = "Partial wavelet coherence of y and x1 | x2")

plot(pwtc.yx2, plot.cb = TRUE,
     main = "Partial wavelet coherence of y and x2 | x1")

</code></pre>

<hr>
<h2 id='rcpp_row_quantile'>Row-wise quantile of a matrix</h2><span id='topic+rcpp_row_quantile'></span>

<h3>Description</h3>

<p>This is a C++ speed-optimized version. It is equivalent to R version
<code>quantile(data, q, na.rm = TRUE)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_row_quantile(data, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_row_quantile_+3A_data">data</code></td>
<td>
<p>Numeric matrix whose row quantiles are wanted.</p>
</td></tr>
<tr><td><code id="rcpp_row_quantile_+3A_q">q</code></td>
<td>
<p>Probability with value in [0,1]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nrows(data)</code>, where each element represents
row quantile.
</p>


<h3>Author(s)</h3>

<p>Viliam Simko
</p>

<hr>
<h2 id='rcpp_wt_bases_dog'>Optimized &quot;wt.bases.dog&quot; function.</h2><span id='topic+rcpp_wt_bases_dog'></span>

<h3>Description</h3>

<p>This is a C++ version optimized for speed.
Computes the wavelet as a function of Fourier frequency
for &quot;dog&quot; mother wavelet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_wt_bases_dog(k, scale, param = -1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_wt_bases_dog_+3A_k">k</code></td>
<td>
<p>vector of frequencies at which to calculate the wavelet.</p>
</td></tr>
<tr><td><code id="rcpp_wt_bases_dog_+3A_scale">scale</code></td>
<td>
<p>the wavelet scale.</p>
</td></tr>
<tr><td><code id="rcpp_wt_bases_dog_+3A_param">param</code></td>
<td>
<p>nondimensional parameter specific to the wavelet function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>daughter</code></td>
<td>
<p>wavelet function</p>
</td></tr>
<tr><td><code>fourier.factor</code></td>
<td>
<p>ratio of fourier period to scale</p>
</td></tr>
<tr><td><code>coi</code></td>
<td>
<p>cone of influence</p>
</td></tr>
<tr><td><code>dof</code></td>
<td>
<p>degrees of freedom for each point in wavelet power</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This c++ implementation is approx. 50
</p>


<h3>Author(s)</h3>

<p>Viliam Simko
</p>

<hr>
<h2 id='rcpp_wt_bases_morlet'>Optimized &quot;wt.bases.morlet&quot; function.</h2><span id='topic+rcpp_wt_bases_morlet'></span>

<h3>Description</h3>

<p>This si a C++ version optimized for speed.
Computes the wavelet as a function of Fourier frequency
for &quot;morlet&quot; mother wavelet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_wt_bases_morlet(k, scale, param = -1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_wt_bases_morlet_+3A_k">k</code></td>
<td>
<p>vector of frequencies at which to calculate the wavelet.</p>
</td></tr>
<tr><td><code id="rcpp_wt_bases_morlet_+3A_scale">scale</code></td>
<td>
<p>the wavelet scale.</p>
</td></tr>
<tr><td><code id="rcpp_wt_bases_morlet_+3A_param">param</code></td>
<td>
<p>nondimensional parameter specific to the wavelet function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>daughter</code></td>
<td>
<p>wavelet function</p>
</td></tr>
<tr><td><code>fourier.factor</code></td>
<td>
<p>ratio of fourier period to scale</p>
</td></tr>
<tr><td><code>coi</code></td>
<td>
<p>cone of influence</p>
</td></tr>
<tr><td><code>dof</code></td>
<td>
<p>degrees of freedom for each point in wavelet power</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This c++ implementation is approx. 60
</p>


<h3>Author(s)</h3>

<p>Viliam Simko
</p>

<hr>
<h2 id='rcpp_wt_bases_paul'>Optimized &quot;wt.bases.paul&quot; function.</h2><span id='topic+rcpp_wt_bases_paul'></span>

<h3>Description</h3>

<p>This si a C++ version optimized for speed.
Computes the wavelet as a function of Fourier frequency
for &quot;paul&quot; mother wavelet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_wt_bases_paul(k, scale, param = -1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_wt_bases_paul_+3A_k">k</code></td>
<td>
<p>vector of frequencies at which to calculate the wavelet.</p>
</td></tr>
<tr><td><code id="rcpp_wt_bases_paul_+3A_scale">scale</code></td>
<td>
<p>the wavelet scale.</p>
</td></tr>
<tr><td><code id="rcpp_wt_bases_paul_+3A_param">param</code></td>
<td>
<p>nondimensional parameter specific to the wavelet function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>daughter</code></td>
<td>
<p>wavelet function</p>
</td></tr>
<tr><td><code>fourier.factor</code></td>
<td>
<p>ratio of fourier period to scale</p>
</td></tr>
<tr><td><code>coi</code></td>
<td>
<p>cone of influence</p>
</td></tr>
<tr><td><code>dof</code></td>
<td>
<p>degrees of freedom for each point in wavelet power</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This c++ implementation is approx. 59
</p>


<h3>Author(s)</h3>

<p>Viliam Simko
</p>

<hr>
<h2 id='smooth.wavelet'>Smooth wavelet in both the time and scale domains</h2><span id='topic+smooth.wavelet'></span>

<h3>Description</h3>

<p>The time smoothing uses a filter given by the absolute value of the wavelet
function at each scale, normalized to have a total weight of unity, which is
a Gaussian function for the Morlet wavelet. The scale smoothing is done with
a boxcar function of width 0.6, which corresponds to the decorrelation scale
of the Morlet wavelet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.wavelet(wave, dt, dj, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.wavelet_+3A_wave">wave</code></td>
<td>
<p>wavelet coefficients</p>
</td></tr>
<tr><td><code id="smooth.wavelet_+3A_dt">dt</code></td>
<td>
<p>size of time steps</p>
</td></tr>
<tr><td><code id="smooth.wavelet_+3A_dj">dj</code></td>
<td>
<p>number of octaves per scale</p>
</td></tr>
<tr><td><code id="smooth.wavelet_+3A_scale">scale</code></td>
<td>
<p>wavelet scales</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the smoothed wavelet.
</p>


<h3>Note</h3>

<p>This function is used internally for computing wavelet coherence.
It is only appropriate for the morlet wavelet.
</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>
<p>Code based on WTC MATLAB package written by Aslak Grinsted.
</p>


<h3>References</h3>

<p>Torrence, C., and P. J. Webster. 1998. The annual cycle of persistence in the
El Nino/Southern Oscillation.
<em>Quarterly Journal of the Royal Meteorological Society</em> 124:1985-2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not run: smooth.wt1 &lt;- smooth.wavelet(wave, dt, dj, scale)
</code></pre>

<hr>
<h2 id='wclust'>Compute dissimilarity between multiple wavelet spectra</h2><span id='topic+wclust'></span>

<h3>Description</h3>

<p>Compute dissimilarity between multiple wavelet spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wclust(w.arr, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wclust_+3A_w.arr">w.arr</code></td>
<td>
<p><code>N x p x t</code> array of wavelet spectra where <code>N</code> is the
number of wavelet spectra to be compared, <code>p</code> is the number of periods
in each wavelet spectrum and <code>t</code> is the number of time steps in each
wavelet spectrum.</p>
</td></tr>
<tr><td><code id="wclust_+3A_quiet">quiet</code></td>
<td>
<p>Do not display progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>diss.mat</code></td>
<td>
<p>square dissimilarity matrix</p>
</td></tr>
<tr><td><code>dist.mat</code></td>
<td>
<p>(lower triangular) distance matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Rouyer, T., J. M. Fromentin, F. Menard, B. Cazelles, K. Briand, R. Pianet,
B. Planque, and N. C. Stenseth. 2008. Complex interplays among population
dynamics, environmental forcing, and exploitation in fisheries.
<em>Proceedings of the National Academy of Sciences</em> 105:5420-5425.
</p>
<p>Rouyer, T., J. M. Fromentin, N. C. Stenseth, and B. Cazelles. 2008.
Analysing multiple time series and extending significance testing in
wavelet analysis. <em>Marine Ecology Progress Series</em> 359:11-23.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- cbind(1:100, sin(seq(0, 10 * 2 * pi, length.out = 100)))
t2 &lt;- cbind(1:100, sin(seq(0, 10 * 2 * pi, length.out = 100) + 0.1 * pi))
t3 &lt;- cbind(1:100, rnorm(100)) # white noise

## Compute wavelet spectra
wt.t1 &lt;- wt(t1)
wt.t2 &lt;- wt(t2)
wt.t3 &lt;- wt(t3)

## Store all wavelet spectra into array
w.arr &lt;- array(dim = c(3, NROW(wt.t1$wave), NCOL(wt.t1$wave)))
w.arr[1, , ] &lt;- wt.t1$wave
w.arr[2, , ] &lt;- wt.t2$wave
w.arr[3, , ] &lt;- wt.t3$wave

## Compute dissimilarity and distance matrices
w.arr.dis &lt;- wclust(w.arr)
plot(hclust(w.arr.dis$dist.mat, method = "ward.D"),
     sub = "", main = "", ylab = "Dissimilarity", hang = -1)

</code></pre>

<hr>
<h2 id='wdist'>Compute dissimilarity between two wavelet spectra</h2><span id='topic+wdist'></span>

<h3>Description</h3>

<p>Compute dissimilarity between two wavelet spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wdist(wt1, wt2, cutoff = 0.99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wdist_+3A_wt1">wt1</code></td>
<td>
<p><code>power</code>, <code>wave</code> or <code>rsq</code> matrix from
<code>biwavelet</code> object generated by <code><a href="#topic+wt">wt</a></code>, <code><a href="#topic+xwt">xwt</a></code>,
or <code><a href="#topic+wtc">wtc</a></code>.</p>
</td></tr>
<tr><td><code id="wdist_+3A_wt2">wt2</code></td>
<td>
<p><code>power</code>, <code>wave</code> or <code>rsq</code> matrix from
<code>biwavelet</code> object generated by <code><a href="#topic+wt">wt</a></code>, <code><a href="#topic+xwt">xwt</a></code>,
or <code><a href="#topic+wtc">wtc</a></code>.</p>
</td></tr>
<tr><td><code id="wdist_+3A_cutoff">cutoff</code></td>
<td>
<p>Cutoff value used to compute dissimilarity. Only orthogonal
axes that contribute more than <code>1-cutoff</code> to the total covariance
between the two wavelet spectra will be used to compute their
dissimilarity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns wavelet dissimilarity.
</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Rouyer, T., J. M. Fromentin, F. Menard, B. Cazelles, K. Briand, R. Pianet,
B. Planque, and N. C. Stenseth. 2008. Complex interplays among population
dynamics, environmental forcing, and exploitation in fisheries.
<em>Proceedings of the National Academy of Sciences</em> 105:5420-5425.
</p>
<p>Rouyer, T., J. M. Fromentin, N. C. Stenseth, and B. Cazelles. 2008.
Analysing multiple time series and extending significance testing in
wavelet analysis. <em>Marine Ecology Progress Series</em> 359:11-23.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- cbind(1:100, sin(seq(0, 10 * 2 * pi, length.out = 100)))
t2 &lt;- cbind(1:100, sin(seq(0, 10 * 2 * pi, length.out = 100) + 0.1 * pi))

# Compute wavelet spectra
wt.t1 &lt;- wt(t1)
wt.t2 &lt;- wt(t2)

# Compute dissimilarity
wdist(wt.t1$wave, wt.t2$wave)

</code></pre>

<hr>
<h2 id='wt'>Compute wavelet transform</h2><span id='topic+wt'></span>

<h3>Description</h3>

<p>Compute wavelet transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wt(
  d,
  pad = TRUE,
  dt = NULL,
  dj = 1/12,
  s0 = 2 * dt,
  J1 = NULL,
  max.scale = NULL,
  mother = "morlet",
  param = -1,
  lag1 = NULL,
  sig.level = 0.95,
  sig.test = 0,
  do.sig = TRUE,
  arima.method = "CSS"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt_+3A_d">d</code></td>
<td>
<p>Time series in matrix format (<code>n</code> rows x 2 columns). The first
column should contain the time steps and the second column should contain
the values.</p>
</td></tr>
<tr><td><code id="wt_+3A_pad">pad</code></td>
<td>
<p>Pad the values will with zeros to increase the speed of the
transform.</p>
</td></tr>
<tr><td><code id="wt_+3A_dt">dt</code></td>
<td>
<p>Length of a time step.</p>
</td></tr>
<tr><td><code id="wt_+3A_dj">dj</code></td>
<td>
<p>Spacing between successive scales.</p>
</td></tr>
<tr><td><code id="wt_+3A_s0">s0</code></td>
<td>
<p>Smallest scale of the wavelet.</p>
</td></tr>
<tr><td><code id="wt_+3A_j1">J1</code></td>
<td>
<p>Number of scales - 1.</p>
</td></tr>
<tr><td><code id="wt_+3A_max.scale">max.scale</code></td>
<td>
<p>Maximum scale. Computed automatically if left unspecified.</p>
</td></tr>
<tr><td><code id="wt_+3A_mother">mother</code></td>
<td>
<p>Type of mother wavelet function to use. Can be set to
<code>morlet</code>, <code>dog</code>, or <code>paul</code>.</p>
</td></tr>
<tr><td><code id="wt_+3A_param">param</code></td>
<td>
<p>Nondimensional parameter specific to the wavelet function.</p>
</td></tr>
<tr><td><code id="wt_+3A_lag1">lag1</code></td>
<td>
<p>AR(1) coefficient of time series used to test for significant
patterns.</p>
</td></tr>
<tr><td><code id="wt_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level.</p>
</td></tr>
<tr><td><code id="wt_+3A_sig.test">sig.test</code></td>
<td>
<p>Type of significance test. If set to 0, use a regular
<code class="reqn">\chi^2</code> test. If set to 1, then perform a time-average test.
If set to 2, then do a scale-average test.</p>
</td></tr>
<tr><td><code id="wt_+3A_do.sig">do.sig</code></td>
<td>
<p>Perform significance testing if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="wt_+3A_arima.method">arima.method</code></td>
<td>
<p>Fitting method. This parameter is passed as the
<code>method</code> Parameter to the <code><a href="stats.html#topic+arima">arima</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>biwavelet</code> object containing:
</p>
<table>
<tr><td><code>coi</code></td>
<td>
<p>matrix containg cone of influence</p>
</td></tr>
<tr><td><code>wave</code></td>
<td>
<p>matrix containing the wavelet transform</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>matrix of power</p>
</td></tr>
<tr><td><code>power.corr</code></td>
<td>
<p>matrix of bias-corrected power using the method described
by <code>Liu et al. (2007)</code></p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>matrix of phases</p>
</td></tr>
<tr><td><code>period</code></td>
<td>
<p>vector of periods</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>vector of scales</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>length of a time step</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>vector of times</p>
</td></tr>
<tr><td><code>xaxis</code></td>
<td>
<p>vector of values used to plot xaxis</p>
</td></tr>
<tr><td><code>s0</code></td>
<td>
<p>smallest scale of the wavelet </p>
</td></tr>
<tr><td><code>dj</code></td>
<td>
<p>spacing between successive scales</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>variance of time series</p>
</td></tr>
<tr><td><code>mother</code></td>
<td>
<p>mother wavelet used</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>type of <code>biwavelet</code> object created (<code><a href="#topic+wt">wt</a></code>)</p>
</td></tr>
<tr><td><code>signif</code></td>
<td>
<p>matrix containg significance levels</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>
<p>Code based on wavelet MATLAB program written by Christopher Torrence
and Gibert P. Compo.
</p>


<h3>References</h3>

<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
<em>Bulletin of the American Meteorological Society</em> 79:61-78.
</p>
<p>Liu, Y., X. San Liang, and R. H. Weisberg. 2007. Rectification of the Bias in
the Wavelet Power Spectrum. <em>Journal of Atmospheric and Oceanic
Technology</em> 24:2093-2102.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- cbind(1:100, rnorm(100))

## Continuous wavelet transform
wt.t1 &lt;- wt(t1)

## Plot power
## Make room to the right for the color bar
par(oma = c(0, 0, 0, 1), mar = c(5, 4, 4, 5) + 0.1)
plot(wt.t1, plot.cb = TRUE, plot.phase = FALSE)

</code></pre>

<hr>
<h2 id='wt.bases'>Compute wavelet</h2><span id='topic+wt.bases'></span>

<h3>Description</h3>

<p>Computes the wavelet as a function of Fourier frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wt.bases(mother = "morlet", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt.bases_+3A_mother">mother</code></td>
<td>
<p>Type of mother wavelet function to use. Can be set to
<code>morlet</code>, <code>dog</code>, or <code>paul</code>.</p>
</td></tr>
<tr><td><code id="wt.bases_+3A_...">...</code></td>
<td>
<p>See parameters <code>k</code>, <code>scale</code> and <code>param</code> in
functions: <code><a href="#topic+wt.bases.morlet">wt.bases.morlet</a></code>, <code><a href="#topic+wt.bases.paul">wt.bases.paul</a></code> and
<code><a href="#topic+wt.bases.dog">wt.bases.dog</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>daughter</code></td>
<td>
<p>wavelet function</p>
</td></tr>
<tr><td><code>fourier.factor</code></td>
<td>
<p>ratio of fourier period to scale</p>
</td></tr>
<tr><td><code>coi</code></td>
<td>
<p>cone of influence</p>
</td></tr>
<tr><td><code>dof</code></td>
<td>
<p>degrees of freedom for each point in wavelet power</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>
<p>Code based on wavelet MATLAB program written by Christopher Torrence and
Gibert P. Compo.
</p>


<h3>References</h3>

<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
<em>Bulletin of the American Meteorological Society</em> 79:61-78.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not run: wb &lt;- wt.bases(mother, k, scale[a1], param)

</code></pre>

<hr>
<h2 id='wt.bases.dog'>Helper method (not exported)</h2><span id='topic+wt.bases.dog'></span>

<h3>Description</h3>

<p>Helper method (not exported)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wt.bases.dog(k, scale, param = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt.bases.dog_+3A_k">k</code></td>
<td>
<p>Vector of frequencies at which to calculate the wavelet.</p>
</td></tr>
<tr><td><code id="wt.bases.dog_+3A_scale">scale</code></td>
<td>
<p>The wavelet scale.</p>
</td></tr>
<tr><td><code id="wt.bases.dog_+3A_param">param</code></td>
<td>
<p>Nondimensional parameter specific to the wavelet function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>daughter</code></td>
<td>
<p>wavelet function</p>
</td></tr>
<tr><td><code>fourier.factor</code></td>
<td>
<p>ratio of fourier period to scale</p>
</td></tr>
<tr><td><code>coi</code></td>
<td>
<p>cone of influence</p>
</td></tr>
<tr><td><code>dof</code></td>
<td>
<p>degrees of freedom for each point in wavelet power</p>
</td></tr>
</table>

<hr>
<h2 id='wt.bases.morlet'>Helper method (not exported)</h2><span id='topic+wt.bases.morlet'></span>

<h3>Description</h3>

<p>Helper method (not exported)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wt.bases.morlet(k, scale, param = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt.bases.morlet_+3A_k">k</code></td>
<td>
<p>Vector of frequencies at which to calculate the wavelet.</p>
</td></tr>
<tr><td><code id="wt.bases.morlet_+3A_scale">scale</code></td>
<td>
<p>The wavelet scale.</p>
</td></tr>
<tr><td><code id="wt.bases.morlet_+3A_param">param</code></td>
<td>
<p>Nondimensional parameter specific to the wavelet function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>daughter</code></td>
<td>
<p>wavelet function</p>
</td></tr>
<tr><td><code>fourier.factor</code></td>
<td>
<p>ratio of fourier period to scale</p>
</td></tr>
<tr><td><code>coi</code></td>
<td>
<p>cone of influence</p>
</td></tr>
<tr><td><code>dof</code></td>
<td>
<p>degrees of freedom for each point in wavelet power</p>
</td></tr>
</table>

<hr>
<h2 id='wt.bases.paul'>Helper method (not exported)</h2><span id='topic+wt.bases.paul'></span>

<h3>Description</h3>

<p>Helper method (not exported)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wt.bases.paul(k, scale, param = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt.bases.paul_+3A_k">k</code></td>
<td>
<p>Vector of frequencies at which to calculate the wavelet.</p>
</td></tr>
<tr><td><code id="wt.bases.paul_+3A_scale">scale</code></td>
<td>
<p>The wavelet scale.</p>
</td></tr>
<tr><td><code id="wt.bases.paul_+3A_param">param</code></td>
<td>
<p>Nondimensional parameter specific to the wavelet function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>daughter</code></td>
<td>
<p>wavelet function</p>
</td></tr>
<tr><td><code>fourier.factor</code></td>
<td>
<p>ratio of fourier period to scale</p>
</td></tr>
<tr><td><code>coi</code></td>
<td>
<p>cone of influence</p>
</td></tr>
<tr><td><code>dof</code></td>
<td>
<p>degrees of freedom for each point in wavelet power</p>
</td></tr>
</table>

<hr>
<h2 id='wt.sig'>Determine significance of wavelet transform</h2><span id='topic+wt.sig'></span>

<h3>Description</h3>

<p>Determine significance of wavelet transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wt.sig(
  d,
  dt,
  scale,
  sig.test = 0,
  sig.level = 0.95,
  dof = 2,
  lag1 = NULL,
  mother = "morlet",
  param = -1,
  sigma2 = NULL,
  arima.method = "CSS"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt.sig_+3A_d">d</code></td>
<td>
<p>Time series in matrix format (<code>n</code> rows x 2 columns). The first
column should contain the time steps and the second column should contain
the values.</p>
</td></tr>
<tr><td><code id="wt.sig_+3A_dt">dt</code></td>
<td>
<p>Length of a time step.</p>
</td></tr>
<tr><td><code id="wt.sig_+3A_scale">scale</code></td>
<td>
<p>The wavelet scale.</p>
</td></tr>
<tr><td><code id="wt.sig_+3A_sig.test">sig.test</code></td>
<td>
<p>Type of significance test. If set to 0, use a regular
<code class="reqn">\chi^2</code> test. If set to 1, then perform a time-average test. If set to
2, then do a scale-average test.</p>
</td></tr>
<tr><td><code id="wt.sig_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level.</p>
</td></tr>
<tr><td><code id="wt.sig_+3A_dof">dof</code></td>
<td>
<p>Degrees of freedom for each point in wavelet power.</p>
</td></tr>
<tr><td><code id="wt.sig_+3A_lag1">lag1</code></td>
<td>
<p>AR(1) coefficient of time series used to test for significant
patterns.</p>
</td></tr>
<tr><td><code id="wt.sig_+3A_mother">mother</code></td>
<td>
<p>Type of mother wavelet function to use. Can be set to
<code>morlet</code>, <code>dog</code>, or <code>paul</code>.</p>
</td></tr>
<tr><td><code id="wt.sig_+3A_param">param</code></td>
<td>
<p>Nondimensional parameter specific to the wavelet function.</p>
</td></tr>
<tr><td><code id="wt.sig_+3A_sigma2">sigma2</code></td>
<td>
<p>Variance of time series</p>
</td></tr>
<tr><td><code id="wt.sig_+3A_arima.method">arima.method</code></td>
<td>
<p>Fitting method. This parameter is passed as the
<code>method</code> Parameter to the <code><a href="stats.html#topic+arima">arima</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>signif</code></td>
<td>
<p>vector containing significance level for each scale</p>
</td></tr>
<tr><td><code>signif</code></td>
<td>
<p>vector of red-noise spectrum for each period</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>
<p>Code based on wavelet MATLAB program written by Christopher Torrence
and Gibert P. Compo.
</p>


<h3>References</h3>

<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
<em>Bulletin of the American Meteorological Society</em> 79:61-78.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not run: wt.sig(d, dt, scale, sig.test, sig.level, lag1,
#                 dof = -1, mother = "morlet", sigma2 = 1)

</code></pre>

<hr>
<h2 id='wtc'>Compute wavelet coherence</h2><span id='topic+wtc'></span>

<h3>Description</h3>

<p>Compute wavelet coherence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtc(
  d1,
  d2,
  pad = TRUE,
  dj = 1/12,
  s0 = 2 * dt,
  J1 = NULL,
  max.scale = NULL,
  mother = "morlet",
  param = -1,
  lag1 = NULL,
  sig.level = 0.95,
  sig.test = 0,
  nrands = 300,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtc_+3A_d1">d1</code></td>
<td>
<p>Time series 1 in matrix format (<code>n</code> rows x 2 columns). The
first column should contain the time steps and the second column should
contain the values.</p>
</td></tr>
<tr><td><code id="wtc_+3A_d2">d2</code></td>
<td>
<p>Time series 2 in matrix format (<code>n</code> rows x 2 columns). The
first column should contain the time steps and the second column should
contain the values.</p>
</td></tr>
<tr><td><code id="wtc_+3A_pad">pad</code></td>
<td>
<p>Pad the values will with zeros to increase the speed of the
transform.</p>
</td></tr>
<tr><td><code id="wtc_+3A_dj">dj</code></td>
<td>
<p>Spacing between successive scales.</p>
</td></tr>
<tr><td><code id="wtc_+3A_s0">s0</code></td>
<td>
<p>Smallest scale of the wavelet.</p>
</td></tr>
<tr><td><code id="wtc_+3A_j1">J1</code></td>
<td>
<p>Number of scales - 1.</p>
</td></tr>
<tr><td><code id="wtc_+3A_max.scale">max.scale</code></td>
<td>
<p>Maximum scale. Computed automatically if left unspecified.</p>
</td></tr>
<tr><td><code id="wtc_+3A_mother">mother</code></td>
<td>
<p>Type of mother wavelet function to use. Can be set to
<code>morlet</code>, <code>dog</code>, or <code>paul</code>.</p>
</td></tr>
<tr><td><code id="wtc_+3A_param">param</code></td>
<td>
<p>Nondimensional parameter specific to the wavelet function.</p>
</td></tr>
<tr><td><code id="wtc_+3A_lag1">lag1</code></td>
<td>
<p>Vector containing the AR(1) coefficient of each time series.</p>
</td></tr>
<tr><td><code id="wtc_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level.</p>
</td></tr>
<tr><td><code id="wtc_+3A_sig.test">sig.test</code></td>
<td>
<p>Type of significance test. If set to 0, use a regular
<code class="reqn">\chi^2</code> test. If set to 1, then perform a time-average test. If set to
2, then do a scale-average test.</p>
</td></tr>
<tr><td><code id="wtc_+3A_nrands">nrands</code></td>
<td>
<p>Number of Monte Carlo randomizations.</p>
</td></tr>
<tr><td><code id="wtc_+3A_quiet">quiet</code></td>
<td>
<p>Do not display progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a <code>biwavelet</code> object containing:
</p>
<table>
<tr><td><code>coi</code></td>
<td>
<p>matrix containg cone of influence</p>
</td></tr>
<tr><td><code>wave</code></td>
<td>
<p>matrix containing the cross-wavelet transform</p>
</td></tr>
<tr><td><code>wave.corr</code></td>
<td>
<p>matrix containing the bias-corrected cross-wavelet transform
using the method described by <code>Veleda et al. (2012)</code></p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>matrix of power</p>
</td></tr>
<tr><td><code>power.corr</code></td>
<td>
<p>matrix of bias-corrected cross-wavelet power using the method described
by <code>Veleda et al. (2012)</code></p>
</td></tr>
<tr><td><code>rsq</code></td>
<td>
<p>matrix of wavelet coherence</p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>matrix of phases</p>
</td></tr>
<tr><td><code>period</code></td>
<td>
<p>vector of periods</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>vector of scales</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>length of a time step</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>vector of times</p>
</td></tr>
<tr><td><code>xaxis</code></td>
<td>
<p>vector of values used to plot xaxis</p>
</td></tr>
<tr><td><code>s0</code></td>
<td>
<p>smallest scale of the wavelet </p>
</td></tr>
<tr><td><code>dj</code></td>
<td>
<p>spacing between successive scales</p>
</td></tr>
<tr><td><code>d1.sigma</code></td>
<td>
<p>standard deviation of time series 1</p>
</td></tr>
<tr><td><code>d2.sigma</code></td>
<td>
<p>standard deviation of time series 2</p>
</td></tr>
<tr><td><code>mother</code></td>
<td>
<p>mother wavelet used</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>type of <code>biwavelet</code> object created (<code><a href="#topic+wtc">wtc</a></code>)</p>
</td></tr>
<tr><td><code>signif</code></td>
<td>
<p>matrix containing <code>sig.level</code> percentiles of wavelet
coherence based on the Monte Carlo AR(1) time series</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The Monte Carlo randomizations can be extremely slow for large
datasets. For instance, 1000 randomizations of a dataset consisting of 1000
samples will take ~30 minutes on a 2.66 GHz dual-core Xeon processor.
</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>
<p>Code based on WTC MATLAB package written by Aslak Grinsted.
</p>


<h3>References</h3>

<p>Cazelles, B., M. Chavez, D. Berteaux, F. Menard, J. O. Vik, S. Jenouvrier,
and N. C. Stenseth. 2008. Wavelet analysis of ecological time series.
<em>Oecologia</em> 156:287-304.
</p>
<p>Grinsted, A., J. C. Moore, and S. Jevrejeva. 2004. Application of the cross
wavelet transform and wavelet coherence to geophysical time series.
<em>Nonlinear Processes in Geophysics</em> 11:561-566.
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
<em>Bulletin of the American Meteorological Society</em> 79:61-78.
</p>
<p>Torrence, C., and P. J. Webster. 1998. The annual cycle of persistence in the
El Nino/Southern Oscillation. <em>Quarterly Journal of the Royal
Meteorological Society</em> 124:1985-2004.
</p>
<p>Veleda, D., R. Montagne, and M. Araujo. 2012. Cross-Wavelet Bias Corrected by
Normalizing Scales. <em>Journal of Atmospheric and Oceanic Technology</em>
29:1401-1408.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- cbind(1:100, rnorm(100))
t2 &lt;- cbind(1:100, rnorm(100))

## Wavelet coherence
wtc.t1t2 &lt;- wtc(t1, t2, nrands = 10)

## Plot wavelet coherence and phase difference (arrows)
## Make room to the right for the color bar
par(oma = c(0, 0, 0, 1), mar = c(5, 4, 4, 5) + 0.1)
plot(wtc.t1t2, plot.cb = TRUE, plot.phase = TRUE)

</code></pre>

<hr>
<h2 id='wtc_sig_parallel'>Parallel <code><a href="#topic+wtc.sig">wtc.sig</a></code></h2><span id='topic+wtc_sig_parallel'></span>

<h3>Description</h3>

<p>Parallelized Monte Carlo simulation equivalent to <code><a href="#topic+wtc.sig">wtc.sig</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtc_sig_parallel(
  nrands = 300,
  lag1,
  dt,
  ntimesteps,
  pad = TRUE,
  dj = 1/12,
  s0,
  J1,
  max.scale = NULL,
  mother = "morlet",
  sig.level = 0.95,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtc_sig_parallel_+3A_nrands">nrands</code></td>
<td>
<p>Number of Monte Carlo randomizations.</p>
</td></tr>
<tr><td><code id="wtc_sig_parallel_+3A_lag1">lag1</code></td>
<td>
<p>Vector containing the AR(1) coefficient of each time series.</p>
</td></tr>
<tr><td><code id="wtc_sig_parallel_+3A_dt">dt</code></td>
<td>
<p>Length of a time step.</p>
</td></tr>
<tr><td><code id="wtc_sig_parallel_+3A_ntimesteps">ntimesteps</code></td>
<td>
<p>Number of time steps in time series.</p>
</td></tr>
<tr><td><code id="wtc_sig_parallel_+3A_pad">pad</code></td>
<td>
<p>Pad the values will with zeros to increase the speed of the
transform.</p>
</td></tr>
<tr><td><code id="wtc_sig_parallel_+3A_dj">dj</code></td>
<td>
<p>Spacing between successive scales.</p>
</td></tr>
<tr><td><code id="wtc_sig_parallel_+3A_s0">s0</code></td>
<td>
<p>Smallest scale of the wavelet.</p>
</td></tr>
<tr><td><code id="wtc_sig_parallel_+3A_j1">J1</code></td>
<td>
<p>Number of scales - 1.</p>
</td></tr>
<tr><td><code id="wtc_sig_parallel_+3A_max.scale">max.scale</code></td>
<td>
<p>Maximum scale.</p>
</td></tr>
<tr><td><code id="wtc_sig_parallel_+3A_mother">mother</code></td>
<td>
<p>Type of mother wavelet function to use. Can be set to
<code>morlet</code>, <code>dog</code>, or <code>paul</code>.
Significance testing is only available for <code>morlet</code> wavelet.</p>
</td></tr>
<tr><td><code id="wtc_sig_parallel_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level to compute.</p>
</td></tr>
<tr><td><code id="wtc_sig_parallel_+3A_quiet">quiet</code></td>
<td>
<p>Do not display progress bar.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="foreach.html#topic+foreach">foreach</a></code>
</p>
<p><code><a href="#topic+wtc.sig">wtc.sig</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not run: library(foreach)
# library(doParallel)
# cl &lt;- makeCluster(4, outfile="") # number of cores. Notice 'outfile'
# registerDoParallel(cl)
# wtc_sig_parallel(your parameters go here)
# stopCluster(cl)

</code></pre>

<hr>
<h2 id='wtc.sig'>Determine significance of wavelet coherence</h2><span id='topic+wtc.sig'></span>

<h3>Description</h3>

<p>Determine significance of wavelet coherence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtc.sig(
  nrands = 300,
  lag1,
  dt,
  ntimesteps,
  pad = TRUE,
  dj = 1/12,
  s0,
  J1,
  max.scale = NULL,
  mother = "morlet",
  sig.level = 0.95,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtc.sig_+3A_nrands">nrands</code></td>
<td>
<p>Number of Monte Carlo randomizations.</p>
</td></tr>
<tr><td><code id="wtc.sig_+3A_lag1">lag1</code></td>
<td>
<p>Vector containing the AR(1) coefficient of each time series.</p>
</td></tr>
<tr><td><code id="wtc.sig_+3A_dt">dt</code></td>
<td>
<p>Length of a time step.</p>
</td></tr>
<tr><td><code id="wtc.sig_+3A_ntimesteps">ntimesteps</code></td>
<td>
<p>Number of time steps in time series.</p>
</td></tr>
<tr><td><code id="wtc.sig_+3A_pad">pad</code></td>
<td>
<p>Pad the values will with zeros to increase the speed of the
transform.</p>
</td></tr>
<tr><td><code id="wtc.sig_+3A_dj">dj</code></td>
<td>
<p>Spacing between successive scales.</p>
</td></tr>
<tr><td><code id="wtc.sig_+3A_s0">s0</code></td>
<td>
<p>Smallest scale of the wavelet.</p>
</td></tr>
<tr><td><code id="wtc.sig_+3A_j1">J1</code></td>
<td>
<p>Number of scales - 1.</p>
</td></tr>
<tr><td><code id="wtc.sig_+3A_max.scale">max.scale</code></td>
<td>
<p>Maximum scale.</p>
</td></tr>
<tr><td><code id="wtc.sig_+3A_mother">mother</code></td>
<td>
<p>Type of mother wavelet function to use. Can be set to
<code>morlet</code>, <code>dog</code>, or <code>paul</code>.
Significance testing is only available for <code>morlet</code> wavelet.</p>
</td></tr>
<tr><td><code id="wtc.sig_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level to compute.</p>
</td></tr>
<tr><td><code id="wtc.sig_+3A_quiet">quiet</code></td>
<td>
<p>Do not display progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns significance matrix containing the <code>sig.level</code>
percentile of wavelet coherence at each time step and scale.
</p>


<h3>Note</h3>

<p>The Monte Carlo randomizations can be extremely slow for large
datasets. For instance, 1000 randomizations of a dataset consisting of 1000
samples will take ~30 minutes on a 2.66 GHz dual-core Xeon processor.
</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>
<p>Code based on WTC MATLAB package written by Aslak Grinsted.
</p>


<h3>References</h3>

<p>Cazelles, B., M. Chavez, D. Berteaux, F. Menard, J. O. Vik, S. Jenouvrier,
and N. C. Stenseth. 2008. Wavelet analysis of ecological time series.
<em>Oecologia</em> 156:287-304.
</p>
<p>Grinsted, A., J. C. Moore, and S. Jevrejeva. 2004. Application of the cross
wavelet transform and wavelet coherence to geophysical time series.
<em>Nonlinear Processes in Geophysics</em> 11:561-566.
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
<em>Bulletin of the American Meteorological Society</em> 79:61-78.
</p>
<p>Torrence, C., and P. J. Webster. 1998. The annual cycle of persistence in the
El Nino/Southern Oscillation. <em>Quarterly Journal of the Royal
Meteorological Society</em> 124:1985-2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not run: wtcsig &lt;- wtc.sig(nrands, lag1 = c(d1.ar1, d2.ar1), dt,
#                            pad, dj, J1, s0, mother = "morlet")

</code></pre>

<hr>
<h2 id='xwt'>Compute cross-wavelet</h2><span id='topic+xwt'></span>

<h3>Description</h3>

<p>Compute cross-wavelet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xwt(
  d1,
  d2,
  pad = TRUE,
  dj = 1/12,
  s0 = 2 * dt,
  J1 = NULL,
  max.scale = NULL,
  mother = "morlet",
  param = -1,
  lag1 = NULL,
  sig.level = 0.95,
  sig.test = 0,
  arima.method = "CSS"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xwt_+3A_d1">d1</code></td>
<td>
<p>Time series 1 in matrix format (<code>n</code> rows x 2 columns). The
first column should contain the time steps and the second column should
contain the values.</p>
</td></tr>
<tr><td><code id="xwt_+3A_d2">d2</code></td>
<td>
<p>Time series 2 in matrix format (<code>n</code> rows x 2 columns). The
first column should contain the time steps and the second column should
contain the values.</p>
</td></tr>
<tr><td><code id="xwt_+3A_pad">pad</code></td>
<td>
<p>Pad the values will with zeros to increase the speed of the
transform.</p>
</td></tr>
<tr><td><code id="xwt_+3A_dj">dj</code></td>
<td>
<p>Spacing between successive scales.</p>
</td></tr>
<tr><td><code id="xwt_+3A_s0">s0</code></td>
<td>
<p>Smallest scale of the wavelet.</p>
</td></tr>
<tr><td><code id="xwt_+3A_j1">J1</code></td>
<td>
<p>Number of scales - 1.</p>
</td></tr>
<tr><td><code id="xwt_+3A_max.scale">max.scale</code></td>
<td>
<p>Maximum scale. Computed automatically if left unspecified.</p>
</td></tr>
<tr><td><code id="xwt_+3A_mother">mother</code></td>
<td>
<p>Type of mother wavelet function to use. Can be set to
<code>morlet</code>, <code>dog</code>, or <code>paul</code>. Significance testing is only
available for <code>morlet</code> wavelet.</p>
</td></tr>
<tr><td><code id="xwt_+3A_param">param</code></td>
<td>
<p>Nondimensional parameter specific to the wavelet function.</p>
</td></tr>
<tr><td><code id="xwt_+3A_lag1">lag1</code></td>
<td>
<p>Vector containing the AR(1) coefficient of each time series.</p>
</td></tr>
<tr><td><code id="xwt_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level.</p>
</td></tr>
<tr><td><code id="xwt_+3A_sig.test">sig.test</code></td>
<td>
<p>Type of significance test. If set to 0, use a regular
<code class="reqn">\chi^2</code> test. If set to 1, then perform a time-average test. If set to
2, then do a scale-average test.</p>
</td></tr>
<tr><td><code id="xwt_+3A_arima.method">arima.method</code></td>
<td>
<p>Fitting method. This parameter is passed as the
<code>method</code> parameter to the <code><a href="stats.html#topic+arima">arima</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>biwavelet</code> object containing:
</p>
<table>
<tr><td><code>coi</code></td>
<td>
<p>matrix containg cone of influence</p>
</td></tr>
<tr><td><code>wave</code></td>
<td>
<p>matrix containing the cross-wavelet transform</p>
</td></tr>
<tr><td><code>wave.corr</code></td>
<td>
<p>matrix containing the bias-corrected cross-wavelet transform
using the method described by <code>Veleda et al. (2012)</code></p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>matrix of power</p>
</td></tr>
<tr><td><code>power.corr</code></td>
<td>
<p>matrix of bias-corrected cross-wavelet power using the
method described by <code>Veleda et al. (2012)</code></p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>matrix of phases</p>
</td></tr>
<tr><td><code>period</code></td>
<td>
<p>vector of periods</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>vector of scales</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>length of a time step</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>vector of times</p>
</td></tr>
<tr><td><code>xaxis</code></td>
<td>
<p>vector of values used to plot xaxis</p>
</td></tr>
<tr><td><code>s0</code></td>
<td>
<p>smallest scale of the wavelet </p>
</td></tr>
<tr><td><code>dj</code></td>
<td>
<p>spacing between successive scales</p>
</td></tr>
<tr><td><code>d1.sigma</code></td>
<td>
<p>standard deviation of time series 1</p>
</td></tr>
<tr><td><code>d2.sigma</code></td>
<td>
<p>standard deviation of time series 2</p>
</td></tr>
<tr><td><code>mother</code></td>
<td>
<p>mother wavelet used</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>type of <code>biwavelet</code> object created (<code><a href="#topic+xwt">xwt</a></code>)</p>
</td></tr>
<tr><td><code>signif</code></td>
<td>
<p>matrix containg significance levels</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
Code based on WTC MATLAB package written by Aslak Grinsted.
</p>


<h3>References</h3>

<p>Cazelles, B., M. Chavez, D. Berteaux, F. Menard, J. O. Vik, S. Jenouvrier,
and N. C. Stenseth. 2008. Wavelet analysis of ecological time series.
<em>Oecologia</em> 156:287-304.
</p>
<p>Grinsted, A., J. C. Moore, and S. Jevrejeva. 2004. Application of the cross
wavelet transform and wavelet coherence to geophysical time series.
<em>Nonlinear Processes in Geophysics</em> 11:561-566.
</p>
<p>Torrence, C., and G. P. Compo. 1998. A Practical Guide to Wavelet Analysis.
<em>Bulletin of the American Meteorological Society</em> 79:61-78.
</p>
<p>Torrence, C., and P. J. Webster. 1998. The annual cycle of persistence in the
El Nino/Southern Oscillation. <em>Quarterly Journal of the Royal
Meteorological Society</em> 124:1985-2004.
</p>
<p>Veleda, D., R. Montagne, and M. Araujo. 2012. Cross-Wavelet Bias Corrected by
Normalizing Scales. <em>Journal of Atmospheric and Oceanic Technology</em>
29:1401-1408.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- cbind(1:100, rnorm(100))
t2 &lt;- cbind(1:100, rnorm(100))

# Compute Cross-wavelet
xwt.t1t2 &lt;- xwt(t1, t2)
plot(xwt.t1t2, plot.cb = TRUE, plot.phase = TRUE,
     main = "Plot cross-wavelet and phase difference (arrows)")

# Real data
data(enviro.data)

# Cross-wavelet of MEI and NPGO
xwt.mei.npgo &lt;- xwt(subset(enviro.data, select = c("date", "mei")),
                    subset(enviro.data, select = c("date", "npgo")))

# Make room to the right for the color bar
par(oma = c(0, 0, 0, 1), mar = c(5, 4, 4, 5) + 0.1)
plot(xwt.mei.npgo, plot.cb = TRUE, plot.phase = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
